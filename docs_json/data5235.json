{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.09512"}, {"@name": "filename", "#text": "14496_001009635.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL INSTITUTO DE INFORM\u00c1TICA CURSO DE ENGENHARIA DE COMPUTA\u00c7\u00c3O\nKLEBER PORTO DOS SANTOS\nAn\u00e1lise de efici\u00eancia, cobertura de erros e custos da t\u00e9cnica de TMR Heterog\u00eaneo em um processador VLIW\nMonografia apresentada como requisito parcial para a obten\u00e7\u00e3o do grau de Bacharel em Engenharia de Computa\u00e7\u00e3o.\nOrientador: Prof. Dr. Antonio C. S. Beck Filho Co-orientador: Doutorando Anderson Luiz Sartor\nPorto Alegre\n2016\nUNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL\nReitor: Prof. Rui Vicente Oppermann\nVice-Reitor: Profa. Jane Fraga Tutikian\nPr\u00f3-Reitor de Gradua\u00e7\u00e3o: Prof. Vladimir Pinheiro do Nascimento\nDiretor do Instituto de Inform\u00e1tica: Prof. Carla Maria Dal Sasso Freitas\nCoordenador do Curso de Engenharia da Computa\u00e7\u00e3o: Prof. Raul Fernando Weber\nBibliotec\u00e1ria-Chefe do Instituto de Inform\u00e1tica: Beatriz Regina Bastos Haro\nAGRADECIMENTOS\nAgrade\u00e7o aos meus pais e demais familiares pelo suporte oferecido durante o meu desenvolvimento como estudante, aos meus Orientadores que estiveram sempre dispostos a sanar d\u00favidas e a ajudar com ideias que contribu\u00edram para o desenvolvimento deste trabalho. E um agradecimento \u00e0 minha namorada pelo apoio que me foi dado durante a gradua\u00e7\u00e3o.\nRESUMO\nO aumento da integra\u00e7\u00e3o de componentes eletr\u00f4nicos torna-os tamb\u00e9m mais suscet\u00edveis a falhas transientes causadas por radia\u00e7\u00e3o, at\u00e9 mesmo quando tais componentes se encontram dentro da atmosfera terrestre. Assim, \u00e9 necess\u00e1rio o uso de t\u00e9cnicas para prevenir danos causados em sistemas cr\u00edticos, como miss\u00f5es espaciais, extra\u00e7\u00e3o de petr\u00f3leo, avia\u00e7\u00e3o civil, carros inteligentes, entre outras. Entretanto, existem aplica\u00e7\u00f5es que atendem nichos espec\u00edficos e possuem diferentes caracter\u00edsticas, tendo um foco maior na redu\u00e7\u00e3o do consumo de pot\u00eancia ou uma necessidade maior de tolerar falhas, ou seja, algumas aplica\u00e7\u00f5es precisam um maior n\u00edvel prote\u00e7\u00e3o que outras. Devido aos problemas citados acima, este trabalho visa aplicar t\u00e9cnicas de toler\u00e2ncia a falhas em um processador VLIW, arquitetura que utiliza ILP (Instruction Level Paralallelism) para atingir maior desempenho. Mais especificamente, implementa, em VHDL, a t\u00e9cnica de Redund\u00e2ncia Modular Tripla Heterog\u00eanea ao processador VLIW p-VEX, utilizando diferentes varia\u00e7\u00f5es de sua microarquitetura. Sempre considerando um conjunto de tr\u00eas aplica\u00e7\u00f5es: \u00e9 capaz de proteger a mais cr\u00edtica com a t\u00e9cnica TMR, uma segunda aplica\u00e7\u00e3o menos cr\u00edtica com a t\u00e9cnica DMR e uma aplica\u00e7\u00e3o executando sem prote\u00e7\u00e3o. Foram realizadas an\u00e1lises de custo em termos de performance, consumo energ\u00e9tico e cobertura de erros utilizando ferramentas de valida\u00e7\u00e3o e simuladores.\nPalavras-chave: TMR. VLIW. Toler\u00e2ncia a Falhas. Softcore. p-VEX.\nEfficiency, Fault Coverage and Cost analysis of the Heterogeneous TMR Technique Applied to a VLIW Processor\nABSTRACT\nThe increasing integration of electronic components also increases the likelihood of single event upsets due to radiation, even when said components are within the Earth's atmosphere. Therefore, techniques are needed to prevent damage caused to critical systems, such as space missions, oil extraction, aviation, smart cars, among others. However, there are applications with distinct characteristics, aimed to reduce power consumption or that need higher fault tolerance, meaning that some applications may need a higher level of protection against faults than others. This paper makes use of fault tolerance techniques in a VLIW processor, an architecture that uses ILP (Instruction Level Parallelism) to achieve a higher performance. More precisely, we implemented, in VHDL, the Heterogeneous Triple Modular Redundancy technique to the p-VEX softcore processor, using different variations of its micro architecture. It always works with a set of 3 applications, by protecting the most critical one using the TMR technique; the second, which demands less protection, using DMR; and the last, which executes without any protection. We analyze the cost in terms of performance, energy consumption and fault coverage, using specific tools for validation and wave simulation.\nKeywords: TMR. VLIW. Fault Tolerance. Softcore p-VEX.\nLISTA DE FIGURAS\nFigura 1.1: Compara\u00e7\u00e3o entre a arquitetura Superscalar e VLIW.......................15\nFigura 1.2: Redund\u00e2ncia Tripla como prevista por Von Neumann........................13\nFigura 1.3: Metodologia de Gera\u00e7\u00e3o de um processador p-VEX..........................15\nFigura 1.4: Arquitetura completa do processador p-VEX...............................16\nFigura 3.1: Arquitetura de TMR Heterog\u00eaneo com compara\u00e7\u00e3o ao final da execu\u00e7\u00e3o......23\nFigura 3.2: TMR Heterog\u00eaneo com checkpoints de sincroniza\u00e7\u00e3o........................24\nFigura 3.3: TMR Heterog\u00eaneo com buffers de sincroniza\u00e7\u00e3o............................25\nFigura 3.4 Vis\u00e3o geral da Ideia Desenvolvida........................................26\nFigura 3.5: Execu\u00e7\u00e3o de uma tarefa no decorrer do tempo nas diferentes microarquiteturas.. 27\nFigura 3.6: Execu\u00e7\u00e3o de tr\u00eas tarefas no decorrer do tempo nas diferentes microarquiteturas . 28\nLISTA DE TABELAS\nTabela 5.1 - Compara\u00e7\u00e3o de \u00c1rea do entre as diferentes microarquiteturas............34\nTabela 5.2 - Compara\u00e7\u00e3o de \u00c1rea do TMR Heterog\u00eaneo e Homog\u00eaneo......................35\nTabela 5.4\t- Medidas de Pot\u00eancia do TMR Homog\u00eaneo e Heterog\u00eaneo.....................35\nTabela 5.3\t- Medidas de Pot\u00eancia de cada configura\u00e7\u00e3o do\tp-VEX...................35\nTabela 5.5\t- Dados obtidos a partir da inje\u00e7\u00e3o de falhas no\tTMR Homog\u00eaneo...........37\nTabela 5.6\t- Dados obtidos a partir da inje\u00e7\u00e3o de falhas no\tTMR Heterog\u00eaneo.........38\nTabela 5.7: Compara\u00e7\u00e3o do n\u00edvel de prote\u00e7\u00e3o do TMR Homog\u00eaneo e Heterog\u00eaneo..........39\nASIC\tApplication Specific Integrated Circuits\nECC\tError Correction Code\nFPGA\tField Programable Gate Array\nHP\tHewllet-Packard\nISA\tInstruction Set Architecture\nLUT\tLookup Table\nSEU\tSingle Event Upset\nTMR\tTriple Modular Redundancy\nUF\tUnidade Funcional\nVEX\tVLIW Example\nVLIW\tVery Long Instruction Word\nSUM\u00c1RIO\n1\tINTRODU\u00c7\u00c3O...........................................................10\n1.1\tT\u00e9cnicas de Toler\u00e2ncia a Falhas....................................12\n1.1.1\tTMR Homog\u00eaneo....................................................12\n1.1.2\tTMR Heterog\u00eaneo..................................................13\n1.1.3\tDMR..............................................................14\n1.2\tPlataforma p-VEX...................................................15\n2\tREFER\u00caNCIA BIBLIOGR\u00c1FICA............................................17\n2.1\tTrabalhos Relacionados.............................................17\n3\tALTERNATIVAS PARA IMPLEMENTA\u00c7\u00c3O DO TMR HETEROG\u00caNEO.................22\n3.1\tIdeia Desenvolvida.................................................26\n3.1.1\tArquitetura Geral................................................27\n3.1.2\tModifica\u00e7\u00f5es no C\u00f3digo Base VHDL.................................29\n4\tMETODOLOGIA.........................................................31\n4.1\tConfigura\u00e7\u00e3o das microarquiteturas.................................31\n4.1.1\tMicroarquitetura TMR Homog\u00eaneo...................................31\n4.1.2\tMicroarquitetura TMR Heterog\u00eaneo.................................31\n4.2\tScripts .........................................................32\n4.2.1\tInjetor de Falhas................................................32\n4.2.2\tVotador..........................................................33\n5\tRESULTADOS..........................................................34\n5.1\tCompara\u00e7\u00f5es entre TMR Heterog\u00eaneo e o Homog\u00eaneo....................34\n5.1.1\t\u00c1rea.............................................................34\n5.1.2\tPot\u00eancia.........................................................34\n5.1.3\tDesempenho.......................................................36\n5.2\tProblemas encontrados durante o desenvolvimento....................39\n5.2.1\tPilha ...........................................................39\n5.2.2\tMem\u00f3ria RAM......................................................40\n5.3\tDiscuss\u00e3o sobre o n\u00edvel de prote\u00e7\u00e3o................................36\n5.3.1\tN\u00edvel de Prote\u00e7\u00e3o TMR Homog\u00eaneo..................................37\n5.3.2\tN\u00edvel de Prote\u00e7\u00e3o TMR Heterog\u00eaneo................................37\n5.3.3\tComparativo do n\u00edvel de prote\u00e7\u00e3o TMR Homog\u00eaneo x TMR Heterog\u00eaneo.38\n6\tCONCLUS\u00d5ES E TRABALHOS FUTUROS......................................41\n6.2\tConclus\u00f5es ........................................................41\n6.2\tTrabalhos Futuros .................................................41\nREFER\u00caNCIAS............................................................44\n1\tINTRODU\u00c7\u00c3O\nO constante avan\u00e7o e desenvolvimento tecnol\u00f3gico na \u00e1rea da microeletr\u00f4nica permitiu o desenvolvimento de transistores cada vez menores e assim, aumenta-se a densidade de componentes nos processadores para aproveitar melhor a \u00e1rea dispon\u00edvel, chegando a integra\u00e7\u00e3o de bilh\u00f5es de transistores (TOTONI et al., 2012). Isto permitiu a constru\u00e7\u00e3o de chips com maior capacidade de processamento ocupando a mesma \u00e1rea.\nProgramas espaciais, bem como sistemas de extra\u00e7\u00e3o de petr\u00f3leo no fundo do oceano, s\u00e3o grandes benefici\u00e1rios do desenvolvimento e aplica\u00e7\u00e3o de t\u00e9cnicas que traga maior confiabilidade para seus sistemas de tempo real. Al\u00e9m disso, \u00e9 necess\u00e1ria uma arquitetura capaz de suprir a demanda pela alta vaz\u00e3o de instru\u00e7\u00f5es processadas. Para tanto, s\u00e3o empregadas arquiteturas com grande capacidade de processamento paralelo, como as arquiteturas Superescalar e VLIW (Very Long Instruction Word), que precisam ser protegidas atrav\u00e9s de t\u00e9cnicas de toler\u00e2ncia a falhas para evitar cat\u00e1strofes e a gera\u00e7\u00e3o de dados incorretos causados por falhas.\nCom a alta densidade de transistores por \u00e1rea, circuitos que operam em faixas reduzidas de tens\u00e3o e a alta frequ\u00eancia operacional dos processadores, os dispositivos tornam-se suscet\u00edveis a falhas causadas por part\u00edculas radioativas, modificando os valores de bits em posi\u00e7\u00f5es de mem\u00f3ria, flip-flops, latches, registradores ou dados em processamento nas unidades funcionais (BAUMANN, 2005). Falhas em hardware podem representar at\u00e9 50% dos defeitos em um sistema computacional (WEBER, 2003). Torna-se ent\u00e3o necess\u00e1ria a utiliza\u00e7\u00e3o de t\u00e9cnicas de toler\u00e2ncia a falhas para prevenir que falhas se propaguem e tornem-se erros, causando graves consequ\u00eancias em sistemas cr\u00edticos.\nEm processadores Superescalares, as instru\u00e7\u00f5es s\u00e3o analisadas em tempo de execu\u00e7\u00e3o e despachadas para as diferentes Unidades Funcionais (UFs). Ap\u00f3s o t\u00e9rmino do est\u00e1gio de execu\u00e7\u00e3o do pipeline, as instru\u00e7\u00f5es s\u00e3o novamente reordenadas, atrav\u00e9s do buffer de reordenamento, e os dados necess\u00e1rios s\u00e3o gravados na mem\u00f3ria e banco de registradores. Isto aumenta a complexidade de hardware, bem como o consumo de energia, devido \u00e0 necessidade dos processadores Superescalares possu\u00edrem fila de instru\u00e7\u00f5es, buffer de reordenamento e o hardware dedicado a verificar as depend\u00eancias de instru\u00e7\u00f5es e dados.\nA arquitetura VLIW tamb\u00e9m explora o paralelismo de instru\u00e7\u00f5es e, da mesma forma, utiliza diferentes unidades funcionais do processador para executar duas ou mais instru\u00e7\u00f5es ao mesmo tempo. Entretanto, ao contr\u00e1rio dos processadores Superescalares, a an\u00e1lise do c\u00f3digo para determinar instru\u00e7\u00f5es que podem ser executadas concomitantemente (i.e.: n\u00e3o possuem\nFigura 1.1: Compara\u00e7\u00e3o entre a arquitetura Superscalar e VLIW.\nFonte: (SABENA; REORDA; STERPONE, 2014) depend\u00eancias entre si) \u00e9 feita em tempo de compila\u00e7\u00e3o. Ap\u00f3s esta an\u00e1lise, o compilador gera uma \u00fanica palavra, bastante larga (que justifica o nome do processador do processador -VLIW), muitas vezes tamb\u00e9m chamada de bundle, composta por instru\u00e7\u00f5es que podem ser executadas simultaneamente. Sem a necessidade de hardware para analisar as instru\u00e7\u00f5es em tempo de execu\u00e7\u00e3o, verificar depend\u00eancias e reordena-las depois da execu\u00e7\u00e3o, o hardware de um processador VLIW torna-se mais simples que o de um processador Superescalar. A Figura\n1.1\tfaz um comparativo entre as duas arquiteturas, deixando claro onde ocorre o Scheduling de instru\u00e7\u00f5es, durante a execu\u00e7\u00e3o no processador Superescalar, e durante a compila\u00e7\u00e3o no processador VLIW.\nNeste trabalho, analisou-se viabilidade, em termos de consumo de energia, \u00e1rea e cobertura de falhas, de um sistema provido de um processador VLIW protegido utilizando a t\u00e9cnica de Redund\u00e2ncia Modular Tripla Heterog\u00eanea, que consiste em utilizar tr\u00eas processadores com diferentes microarquiteturas, mas que implementam a mesma organiza\u00e7\u00e3o (isto \u00e9, s\u00e3o capazes de executar o mesmo bin\u00e1rio) para realizar a execu\u00e7\u00e3o das mesmas aplica\u00e7\u00f5es e decidir, atrav\u00e9s de um votador, qual o resultado correto. Al\u00e9m disso, como aplica\u00e7\u00f5es possuem diferentes caracter\u00edsticas e diferentes n\u00edveis de necessidade de prote\u00e7\u00e3o contra falhas, como dito anteriormente, foi desenvolvido ent\u00e3o um sistema que executa sempre grupos de tr\u00eas aplica\u00e7\u00f5es: sendo uma podendo ser protegida por TMR, executando em tr\u00eas processadores; uma protegida por DMR, executando em apenas dois e uma aplica\u00e7\u00e3o rodando em apenas um processador e sem prote\u00e7\u00e3o nenhuma.\nDevido aos fatores citados acima, foi desenvolvido neste trabalho, o que foi chamado de TMR Heterog\u00eaneo, utilizando microarquiteturas 2-issue, 4-issue e 8-issue. Desta forma, \u00e9 poss\u00edvel tamb\u00e9m balancear o tempo de execu\u00e7\u00e3o das aplica\u00e7\u00f5es, distribuindo as tarefas uniformemente, e preencher lacunas de tempo em que o hardware esteja ocioso geradas pela diferen\u00e7a de capacidade de processamento entre os processadores, atingir o n\u00edvel de prote\u00e7\u00e3o de um TMR para a aplica\u00e7\u00e3o mais cr\u00edtica, e proteger com DMR uma segunda aplica\u00e7\u00e3o, fazendo um equil\u00edbrio entre \u00e1rea ocupada pelo sistema, desempenho e prote\u00e7\u00e3o das aplica\u00e7\u00f5es.\n1.1\tT\u00e9cnicas de Toler\u00e2ncia a Falhas\nAbaixo, ser\u00e3o descritos alguns conceitos, pontos positivos e falhas das t\u00e9cnicas de toler\u00e2ncia a falhas empregadas neste trabalho, sendo elas o TMR (Triple Modular Redundancy, ou Redund\u00e2ncia Modular Tripla em portugu\u00eas) homog\u00eaneo, o TMR Heterog\u00eaneo e a t\u00e9cnica de DMR (DualModular Redundancy, ou Redund\u00e2ncia Modular Dupla em portugu\u00eas).\n1.1.1\tTMR Homog\u00eaneo\nComo j\u00e1 foi citado, o TMR padr\u00e3o - ou homog\u00eaneo, para diferenciar da t\u00e9cnica proposta -\u00e9 uma t\u00e9cnica, criada por Von Neumann (LYONS; VANDERKULK, 1962), altamente difundida entre os pesquisadores e a ind\u00fastria. Consiste na replica\u00e7\u00e3o de componentes de hardware - podendo ser no n\u00edvel das unidades funcionais, datapaths, processadores ou at\u00e9 mesmo sistemas inteiros - ou software - executando a mesma instru\u00e7\u00e3o, tarefa ou aplica\u00e7\u00e3o -com o objetivo de utilizar a redund\u00e2ncia para mascarar falhas, como \u00e9 poss\u00edvel ver na Figura\n1.2\tfeita por Von Neumann. Altamente eficiente contra falhas do tipo single event upset (SEU) - erros n\u00e3o permanentes causados por radia\u00e7\u00e3o como bitflips, por exemplo - faz o uso de um elemento votador para selecionar o resultado com o maior n\u00famero de votos, dois ou mais, no caso da utiliza\u00e7\u00e3o de tr\u00eas componentes e, em algumas situa\u00e7\u00f5es, obt\u00e9m-se como resultado o valor m\u00e9dio das tr\u00eas sa\u00eddas. Quando utilizado o TMR por maioria de votos, caso ao final da execu\u00e7\u00e3o n\u00e3o houver um resultado com maioria de votos (isto \u00e9, as entradas do votador s\u00e3o diferentes), considera-se que o TMR n\u00e3o foi capaz de mascarar a falha.\nFigura 1.2: Redund\u00e2ncia Tripla como prevista por Von Neumann\nFonte: (LYONS; VANDERKULK, 1962)\nAssumindo-se que o votador n\u00e3o est\u00e1 sujeito a falhas, podemos obter o c\u00e1lculo da confiabilidade do TMR atrav\u00e9s de uma fun\u00e7\u00e3o, onde RM \u00e9 a confiabilidade individual de cada componente. O sistema como um todo apresentar\u00e1 uma falha apenas se mais de um componente apresentar um valor errado em sua sa\u00edda. Assim, devido ao fato de que a probabilidade de um componente apresentar falhas \u00e9 mutualmente exclusiva em rela\u00e7\u00e3o aos demais, chegamos \u00e0 seguinte formula para a confiabilidade total R do sistema (LYONS; VANDERKULK, 1962):\n2\nR = Rm3\n+ 3Rm2(1 - Rm) = 3R\n2Rm3\nM\nCom o modelo visto na imagem acima, \u00e9 f\u00e1cil notar que o votador, por estar em s\u00e9rie com os demais componentes, \u00e9 um Single Point of Failure, ou seja, se o votador apresentar uma falha, todo o sistema \u00e9 prejudicado. Por isso, \u00e9 necess\u00e1rio buscar formas de aumentar a confiabilidade do m\u00f3dulo votador, seja atrav\u00e9s da utiliza\u00e7\u00e3o de componentes mais confi\u00e1veis; utilizando redund\u00e2ncia de votadores e um comparador; ou atrav\u00e9s da implementa\u00e7\u00e3o do votador em software (WEBER, 2003), que ser\u00e1 explicado nos cap\u00edtulos seguintes deste trabalho.\n1.1.2\tTMR Heterog\u00eaneo\nPara este trabalho, foi adotado o conceito de TMR Heterog\u00eaneo, que foi definido pela utiliza\u00e7\u00e3o de diversidade entre os m\u00f3dulos, de software ou hardware, utilizados para implementar o TMR. O principal problema do TMR Homog\u00eaneo \u00e9 a triplica\u00e7\u00e3o total de seus componentes, fazendo com que um sistema protegido por TMR ocupe tr\u00eas vezes mais \u00e1rea que a vers\u00e3o desprotegida. Com isso, triplica-se tamb\u00e9m a pot\u00eancia dissipada pelo sistema. Com a diversidade do TMR Heterog\u00eaneo, busca-se reduzir tais custos de \u00e1rea e pot\u00eancia dissipada\natrav\u00e9s da utiliza\u00e7\u00e3o de processadores menores, mas evitar ao m\u00e1ximo a degrada\u00e7\u00e3o do desempenho do sistema.\nAp\u00f3s implementar o TMR Homog\u00eaneo, busca-se obter medidas de dissipa\u00e7\u00e3o de pot\u00eancia, consumo energ\u00e9tico e \u00e1rea ocupada. Realizando um estudo comparativo entre os pontos positivos, ou negativos, de realizar a implementa\u00e7\u00e3o do TMR Heterog\u00eaneo que ocupa menos \u00e1rea em troca de uma queda no n\u00edvel de prote\u00e7\u00e3o. Com isso, \u00e9 poss\u00edvel determinar uma rela\u00e7\u00e3o custo x benef\u00edcio (redu\u00e7\u00e3o de \u00e1rea e pot\u00eancia com a diminui\u00e7\u00e3o da cobertura de falhas) quando se emprega m\u00f3dulos com maior processamento, por\u00e9m com maior \u00e1rea, atrav\u00e9s da compara\u00e7\u00e3o entre as duas vers\u00f5es\nPara fins de compara\u00e7\u00e3o, primeiramente foi implementado um TMR cl\u00e1ssico, com tr\u00eas inst\u00e2ncias id\u00eanticas do processador, para que fossem obtidos resultados conhecidos para comparar as diferentes vers\u00f5es. Com um processador softcore, como o p-VEX, \u00e9 poss\u00edvel alterar a sua configura\u00e7\u00e3o a fim de implementar o TMR Heterog\u00eaneo realizado neste trabalho atrav\u00e9s de altera\u00e7\u00f5es em seu core. Assim, cada processador pode ter um conjunto diferente de unidades funcionais como ULAs, multiplicadores, unidades de mem\u00f3ria e unidades de branch, bem como n\u00famero de issue-slots diferentes. Desta forma, o TMR Heterog\u00eaneo foi desenvolvido utilizando tr\u00eas processadores, um 2-issue, um 4-issue e um terceiro com microarquitetura 8-issue. Atrav\u00e9s da utiliza\u00e7\u00e3o de processadores de tamanhos diferentes, busca-se atingir uma redu\u00e7\u00e3o da \u00e1rea ocupada, bem como da pot\u00eancia dissipada, tentando evitar a queda de desempenho do sistema.\n1.1.3\tDMR\nA t\u00e9cnica de DMR (DualModular Redundancy) possu\u00ed o mesmo princ\u00edpio do TMR: buscar o aumento da confiabilidade atrav\u00e9s do emprego de redund\u00e2ncia. A grande diferen\u00e7a est\u00e1 no fato do DMR utilizar apenas dois m\u00f3dulos redundantes, enquanto o TMR utiliza tr\u00eas. Obviamente, isto reduz a \u00e1rea em rela\u00e7\u00e3o ao TMR (no caso da redund\u00e2ncia ser aplicada em componentes de hardware), por\u00e9m em caso de falhas, \u00e9 imposs\u00edvel decidir qual \u00e9 o resultado correto quando os resultados chegam ao comparador. Por isso o DMR \u00e9 capaz apenas de sinalizar falhas, fazendo necess\u00e1ria uma nova execu\u00e7\u00e3o da aplica\u00e7\u00e3o para determinar o valor correto ou o envio de um sinal de erro para parar todo o sistema.\n1.2\tPlataforma p-VEX\nO processador VLIW configur\u00e1vel p-VEX, utilizado como processador base do TMR, \u00e9 um softcore desenvolvido na Delft Technical University (TUDelft). Trata-se de uma implementa\u00e7\u00e3o em VHDL de 32 bits, com uma ISA VLIW desenvolvida pela HP, e altamente customiz\u00e1vel (ANJAM; WONG, 2013). O compilador da HP, o VEX C compiler, baseia-se na t\u00e9cnica de trace scheduling para gerar o c\u00f3digo VLIW para rodar no p-VEX. Tal t\u00e9cnica permite o escalonamento de instru\u00e7\u00f5es com um alcance al\u00e9m de basic blocks (Blocos formados por instru\u00e7\u00f5es limitadas por duas instru\u00e7\u00f5es de desvio) (LOWNEY et al., 1993). O VEX C compiler possu\u00ed como par\u00e2metros o c\u00f3digo C da aplica\u00e7\u00e3o, que deve seguir o padr\u00e3o ISSO/C89 e um arquivo de configura\u00e7\u00e3o do processador para qual o c\u00f3digo est\u00e1 sendo compilado. Neste arquivo de configura\u00e7\u00e3o, chamado Machine Model, descreve-se todas as unidades funcionais e quantas elas s\u00e3o, al\u00e9m do Issue-Width da microarquitetura. Com esta informa\u00e7\u00e3o, o compilador\nFigura 1.3: Metodologia de Gera\u00e7\u00e3o de um processador p-VEX.\nH.P. VEX toolchain:\nPara meterized C compiler and cyde-accurate simulator\nProcessor\nDescription\nExecution cycles Stall cycles Executed operations Total branches Memory accesses Total misses\nInstruction and data memories\nSynthesizable VHDL\nI\nFonte: (AJAM; WONG, 2013)\nParameters:\n\u25a0\tlssue-widtii\n\u25a0\tNo. of ALUs\n\u25a0\tNo. of MULs\n\u25a0\tNo. of MEMs\n\u25a0\tFU Latencies\n\u25a0\tRegister file size\nVLIW Processor Generation\nParameterized\nProcessor\n\n0\nconsegue realizar o schedule das instru\u00e7\u00f5es de forma a aumentar o paralelismo e a efici\u00eancia do p-VEX. A Figura 1.3 mostra o processo completo para a execu\u00e7\u00e3o de uma aplica\u00e7\u00e3o no processador p-VEX desde seu c\u00f3digo C, at\u00e9 a gera\u00e7\u00e3o do c\u00f3digo assembly utilizando o toolchain VEX da HP que \u00e9 distribu\u00eddo pela pr\u00f3pria HP (HP LABS, [s.d.]). A partir do c\u00f3digo assembly, gera-se o c\u00f3digo execut\u00e1vel - mem\u00f3ria de instru\u00e7\u00f5es e mem\u00f3ria de dados - para o p-VEX atrav\u00e9s do Binutils desenvolvido por pesquisadores da TUDelft.\nCom o seu core em VHDL altamente manipul\u00e1vel, \u00e9 poss\u00edvel alterar o issue-width, quantas e quais unidades funcionais o processador possuir\u00e1, instru\u00e7\u00f5es suportadas, largura de mem\u00f3ria e tamanho do register file, tornando poss\u00edvel, assim, realizar as modifica\u00e7\u00f5es necess\u00e1rias para desenvolver o TMR Heterog\u00eaneo.\nAl\u00e9m de basear-se na arquitetura VLIW, o processador possui um pipeline de cinco est\u00e1gios, sendo eles: busca, decodifica\u00e7\u00e3o, execu\u00e7\u00e3o 0, execu\u00e7\u00e3o 1/mem\u00f3ria, e o est\u00e1gio de writeback. O processador tamb\u00e9m disp\u00f5es de 64 registradores de 32 bits para prop\u00f3sitos gerais e 8 registradores de branch (BR) de 1 bit. A mem\u00f3ria \u00e9 baseada na Arquitetura Harvard, possuindo uma mem\u00f3ria de dados e uma de instru\u00e7\u00f5es de 32kB cada(WONG; VAN AS; BROWN, 2008). A Figura 1.4 representa a arquitetura geral do processador com ambas as mem\u00f3rias - de instru\u00e7\u00f5es e de dados - e os 5 est\u00e1gios de pipeline.\nFigura 1.4: Arquitetura completa do processador p-VEX\nFonte: (WONG; VAN AS; BROWN, 2008)\n2\tREFER\u00caNCIA BIBLIOGR\u00c1FICA\nNeste cap\u00edtulo que segue, ser\u00e1 discutido sobre pesquisas e artigos realizados na \u00e1rea e que, de alguma forma, contribu\u00edram para o projeto e desenvolvimento deste trabalho de gradua\u00e7\u00e3o. Entre os artigos pesquisados, encontram-se diferentes formas de implementa\u00e7\u00e3o e valida\u00e7\u00e3o de diversas formas de TMR, tanto homog\u00eaneo, como heterog\u00eaneos. Foram estudadas pesquisas que utilizavam softcores, processadores com arquitetura VLIW e implementa\u00e7\u00f5es que utilizam FPGAs e ASICs. Assim, foi poss\u00edvel reunir conhecimentos e desafios enfrentados por outros autores, a fim de embasar as decis\u00f5es de projeto tomadas neste trabalho.\n2.1\tTrabalhos Relacionados\n\u00c9 poss\u00edvel encontrar diversos artigos onde os autores utilizam TMR ou outras t\u00e9cnicas, em hardware ou software, para a prote\u00e7\u00e3o de diferentes arquiteturas de processadores utilizando diferentes abordagens. O TMR cl\u00e1ssico, cujo a maioria dos trabalhos mencionados a seguir baseia-se, \u00e9 uma t\u00e9cnica bem difundida na \u00e1rea de Toler\u00e2ncia a Falhas e consiste na realiza\u00e7\u00e3o de uma tarefa (e.g. uma instru\u00e7\u00e3o, um conjunto de instru\u00e7\u00f5es, ou at\u00e9 uma aplica\u00e7\u00e3o inteira) por tr\u00eas m\u00f3dulos de hardware, ou at\u00e9 mesmo de software. Ao final da execu\u00e7\u00e3o, os tr\u00eas resultados devem passar por um m\u00f3dulo adicional, usualmente chamado de votador, que exibe em sua sa\u00edda o resultado que possuir a maioria dos votos. Como j\u00e1 citado anteriormente, os trabalhos relacionados descritos a seguir, partem do princ\u00edpio do TMR cl\u00e1ssico e realizam modifica\u00e7\u00f5es de acordo com a situa\u00e7\u00e3o-problema e o tipo de processador que almejam proteger.\nEm (SCHOLZEL, 2007), o autor prop\u00f5e o que foi chamado de Redund\u00e2ncia Modular Tripla Reduzida (Reduced TMR) como uma forma de autocorre\u00e7\u00e3o embutida em um processador VLIW. Esta t\u00e9cnica realiza instru\u00e7\u00f5es duplicadas e compara o resultado entre elas. Caso o resultado seja diferente, a instru\u00e7\u00e3o \u00e9 executada uma terceira vez. Com isto, reduz-se o tempo ocioso do hardware, utilizando a c\u00f3pia do processador, que atuaria apenas em casos de falha, para processar instru\u00e7\u00f5es em paralelo. Entretanto, em alguns sistemas cr\u00edticos, pode ser fundamental a sinaliza\u00e7\u00e3o de uma falha o mais cedo poss\u00edvel. Com a abordagem proposta por este autor, ser\u00e1 necess\u00e1rio que a instru\u00e7\u00e3o gaste o dobro do tempo para executar, duas em paralelo e a terceira ap\u00f3s o t\u00e9rmino destas, para que seja detectado um erro que poder\u00e1 se\npropagar.\nA proposta em (SAMUDRALA; RAMOS; KATKOORI, 2004), disp\u00f5e de diversos m\u00f3dulos, alguns ativos e rodando a aplica\u00e7\u00e3o, enquanto outros permanecem em standby. Assim, quando um dos m\u00f3dulos ativos apresenta uma falha permanente, os recursos f\u00edsicos s\u00e3o remanejados para um dos m\u00f3dulos em standby. Com isso, o autor pretende estender o tempo de vida do processador em miss\u00f5es de longa dura\u00e7\u00e3o. A desvantagem \u00e9 que isto requer um grande n\u00famero de m\u00f3dulos de processamento, o que aumenta o custo do projeto. Al\u00e9m disso, \u00e9 necess\u00e1rio implementar a t\u00e9cnica realizada para remapear os recursos dos processadores que apresentaram falhas para os m\u00f3dulos em standby, aumentando o hardware e tornando necess\u00e1rio um tipo de comunica\u00e7\u00e3o entre tais m\u00f3dulos. Ainda que a t\u00e9cnica TMR seja capaz de mascarar falhas permanentes, desde que ocorra apenas em um processador, tais decis\u00f5es v\u00e3o contra a proposta deste trabalho de buscar uma solu\u00e7\u00e3o de baixo custo e consumo energ\u00e9tico para tratar, como principal enfoque, falhas transientes.\nO artigo (TAMBARA et al., 2014) realizou um estudo sobre a t\u00e9cnica DDR (Design Diversity Redundancy) que explora o uso de diferentes arquiteturas rodando uma mesma aplica\u00e7\u00e3o, de forma ass\u00edncrona, e seleciona o resultado correto ao t\u00e9rmino da execu\u00e7\u00e3o atrav\u00e9s de um votador majorit\u00e1rio. Atrav\u00e9s da implementa\u00e7\u00e3o utilizando um circuito FPGA independente para cada uma das arquiteturas, previne-se que uma falha cause um curto-circuito entre m\u00f3dulos redundantes, o que dificultaria o mascaramento das falhas pelo TMR. \u00c9 importante ressaltar que as arquiteturas utilizadas apresentam uma grande diferen\u00e7a em termos de desempenho e, portanto, arquiteturas com maior performance eram limitadas pelas arquiteturas que levam mais tempo para executar a mesma aplica\u00e7\u00e3o, causando desperd\u00edcio de recursos. Outro fator importante \u00e9 a compara\u00e7\u00e3o entre os resultados apenas ao t\u00e9rmino da execu\u00e7\u00e3o completa da aplica\u00e7\u00e3o. Isso ocorre pois existe uma diferen\u00e7a entre a capacidade de processamento das arquiteturas. Assim, seria necess\u00e1rio tomar medidas para aproveitar melhor o tempo de ociosidade dos processadores com maior poder computacional.\nComo exemplo de TMR implementado em software aplicado a um processador VLIW, temos o trabalho do autor (SABENA; REORDA; STERPONE, 2014), que utilizou o conceito de Toler\u00e2ncia a Falhas de Hardware Implementada em Software (SIHFT, do ingl\u00eas Software-Implemented Hardware Fault Tolerance). A t\u00e9cnica consiste em alterar o c\u00f3digo assembly gerado pelo compilador VLIW de modo a realizar cada computa\u00e7\u00e3o tr\u00eas vezes, em paralelo, utilizando recursos diferentes. Ent\u00e3o, um conjunto de instru\u00e7\u00f5es, chamado pelos autores de instru\u00e7\u00f5es votadoras, realizam uma vota\u00e7\u00e3o majorit\u00e1ria entre os tr\u00eas resultados obtidos, por\u00e9m, isto reduz a efici\u00eancia do processador em rela\u00e7\u00e3o ao processamento das aplica\u00e7\u00f5es, pois ser\u00e3o\nacrescentadas diversas instru\u00e7\u00f5es, em v\u00e1rios pontos do c\u00f3digo, aumentando o tempo necess\u00e1rio para obter os resultados necess\u00e1rios. Apesar de ser uma solu\u00e7\u00e3o com um menor custo de hardware, pois n\u00e3o precisaria modificar o processador no qual a aplica\u00e7\u00e3o ir\u00e1 executar, uma camada de testes a ser realizada \u00e9 adicionada. Al\u00e9m da verifica\u00e7\u00e3o do c\u00f3digo da aplica\u00e7\u00e3o, \u00e9 necess\u00e1rio analisar o c\u00f3digo em assembly gerado ap\u00f3s as altera\u00e7\u00f5es para a introdu\u00e7\u00e3o das instru\u00e7\u00f5es votadoras da t\u00e9cnica de TMR.\nO trabalho dos autores (PRATT et al., 2006) analisa o fato de que grande maioria das c\u00e9lulas de mem\u00f3ria de um FPGA s\u00e3o respons\u00e1veis por armazenar dados sobre a configura\u00e7\u00e3o do circuito implementado, e prop\u00f5e o que foi chamado por eles de TMR Parcial. Esta t\u00e9cnica prop\u00f5e proteger, contra SEU, elementos respons\u00e1veis por dados persistentes contidos no FPGA, como a configura\u00e7\u00e3o de suas LUTs (lookup tables), por exemplo. Atrav\u00e9s disto, prop\u00f5e-se a prote\u00e7\u00e3o atrav\u00e9s de TMR de apenas parte do circuito, diminuindo a \u00e1rea ocupada quando comparado \u00e0 um TMR completo do processador. Entretanto, tais componentes respons\u00e1veis pela persist\u00eancia variam conforme a aplica\u00e7\u00e3o devido \u00e0 diferen\u00e7a de roteamento de sinais internos, portas de I/O, e principalmente a diferen\u00e7a entre os pr\u00f3prios circuitos como um todo e, por isso, \u00e9 necess\u00e1ria a an\u00e1lise caso a caso. O autor cita a utiliza\u00e7\u00e3o de uma s\u00e9rie de simula\u00e7\u00f5es com inje\u00e7\u00e3o de falhas e utiliza\u00e7\u00e3o de intelig\u00eancia artificial para determinar quais partes do circuito eram as consideradas mais cr\u00edticas. A necessidade de analisar cada novo sistema desenvolvido acaba dificultando o uso deste TMR em larga escala, como em COTS (Commercial off-the-shelf), por exemplo.\nComo trabalho que foca mais em aumentar a confiabilidade do votador e a re-execu\u00e7\u00e3o da aplica\u00e7\u00e3o quando o votador n\u00e3o \u00e9 capaz de decidir o resultado, pode ser citado o trabalho de (SHIN; KIM, 1994). Para determinar a forma que a aplica\u00e7\u00e3o, cuja falha n\u00e3o pode ser mascarada pelo TMR, acontece atrav\u00e9s da utiliza\u00e7\u00e3o de duas t\u00e9cnicas, sendo elas a RSWH (Reexecution of the task on the Same HardWare) e RHWR (Replace the faulty Hardware, reload, andRestart). Com apenas um votador tradicional, por ser um single-point offailure, caso ocorra uma falha, perde-se toda a computa\u00e7\u00e3o realizada pelos processadores. Por isso, os autores do artigo implementam uma solu\u00e7\u00e3o com dois m\u00f3dulos votadores onde cada um realiza a compara\u00e7\u00e3o de dois processadores. O resultado destes dois votadores passa por um comparador, que verifica a validade dos resultados obtidos. Em caso de diferen\u00e7a de resultados na entrada de um dos votadores, \u00e9 feita uma an\u00e1lise de custo e, baseado nesta an\u00e1lise, a t\u00e9cnica menos custosa entre RSWH e RHWR \u00e9 executada a fim de obter o resultado correto. Apesar de ser\numa t\u00e9cnica com capacidade de recupera\u00e7\u00e3o e uma maior cobertura de falhas, pois cobre falhas inclusive no m\u00f3dulo votador, tem-se um aumento no hardware - devido ao votador extra e o m\u00f3dulo comparador - e tamb\u00e9m na complexidade para executar as t\u00e9cnicas de decis\u00e3o de como ser\u00e1 realizada a recupera\u00e7\u00e3o do sistema.\nA ideia desenvolvida por (ICHINOMIYA et al., 2010) desenvolve um TMR utilizando o softcore MicroBlaze e, atrav\u00e9s da t\u00e9cnica de Reconfigura\u00e7\u00e3o Parcial, recuperar-se de falhas permanentes que atingem a mem\u00f3ria de configura\u00e7\u00e3o do FPGA onde o processador est\u00e1 executando. Neste TMR, triplicaram-se apenas os processadores, timers e controladores de interrup\u00e7\u00f5es, pois a mem\u00f3ria, assim como a deste trabalho de gradua\u00e7\u00e3o, \u00e9 protegida atrav\u00e9s de ECC (Error Correction Code) - c\u00f3digos de corre\u00e7\u00e3o utilizados para garantir a integridade de dados. Com a ajuda de votadores e m\u00f3dulos detectores, para indicar qual dos tr\u00eas processadores apresentou a falha, realiza-se a reconfigura\u00e7\u00e3o da mem\u00f3ria onde est\u00e1 armazenada a configura\u00e7\u00e3o do processador que apresentou a falha. A reconfigura\u00e7\u00e3o ocorre enquanto os dois processadores que apresentaram o resultado correto continuam sua execu\u00e7\u00e3o e, quando o processador que apresentou falha est\u00e1 pronto para voltar a executar, aciona-se uma interrup\u00e7\u00e3o e ocorre a sincroniza\u00e7\u00e3o dos processadores. Os processadores n\u00e3o defeituosos salvam na mem\u00f3ria todos os dados que estavam sendo utilizados em sua execu\u00e7\u00e3o e ent\u00e3o os tr\u00eas processadores carregam novamente este \u00faltimo estado salvo em mem\u00f3ria. Isto garante que os tr\u00eas processadores possuem o mesmo estado em seus registradores internos. Esta solu\u00e7\u00e3o cobre um ponto importante do TMR tradicional que \u00e9 a recupera\u00e7\u00e3o de falhas quando um dos tr\u00eas m\u00f3dulos sofre um SEU capaz de tornar o m\u00f3dulo persistentemente defeituoso. Entretanto, os autores do artigo citado n\u00e3o possuem nenhum compromisso em reduzir \u00e1rea e consumo de energia e, al\u00e9m disso, a t\u00e9cnica de Reconfigura\u00e7\u00e3o Parcial funciona apenas em FPGAs, enquanto o TMR desenvolvido neste trabalho possui foco maior em falhas transientes e pode ser implementado em FPGAs e ASICs.\nNeste trabalho de gradua\u00e7\u00e3o, foi desenvolvido um projeto similar ao de (TAMBARA et al., 2014), por\u00e9m, diminui-se o tempo ocioso do sistema atrav\u00e9s da execu\u00e7\u00e3o de mais de uma aplica\u00e7\u00e3o em processadores de maior desempenho. O artigo de (SAMUDRALA; RAMOS; KATKOORI, 2004) utiliza diversos m\u00f3dulos extras, que permanecem em stand by, e substituem m\u00f3dulos que apresentem falhas. Isso, obviamente, aumenta consideravelmente a \u00e1rea ocupada pelo sistema e vai contra uma das propostas deste trabalho de gradua\u00e7\u00e3o, que \u00e9 buscar a redu\u00e7\u00e3o de \u00e1rea do TMR. A implementa\u00e7\u00e3o feita por (ICHINOMIYA et al., 2010) n\u00e3o visa realizar a redu\u00e7\u00e3o de \u00e1rea do TMR - visto que foi empregada a total triplica\u00e7\u00e3o do\nprocessador - sendo isso um fator importante no desenvolvimento do projeto desse trabalho de gradua\u00e7\u00e3o.\n3\tALTERNATIVAS PARA IMPLEMENTA\u00c7\u00c3O DO TMR HETEROG\u00caNEO\nComo j\u00e1 foi citado nos trabalhos relacionados, existem maneiras diferentes de implementar um TMR Heterog\u00eaneo: atrav\u00e9s de software ou hardware; analisando o resultado final da aplica\u00e7\u00e3o; o resultado final de um grupo de instru\u00e7\u00f5es; ou ent\u00e3o comparando cada instru\u00e7\u00e3o. Cada uma das tr\u00eas maneiras diferentes \u00e9 descrita abaixo, citando seus pontos negativos e positivos. Embora fosse interessante realizar as tr\u00eas implementa\u00e7\u00f5es e comparar entre elas para determinar suas vantagens em rela\u00e7\u00e3o a energia, \u00e1rea e cobertura de falhas, apenas uma ser\u00e1 escolhida para a implementa\u00e7\u00e3o durante a segunda etapa do Trabalho de Gradua\u00e7\u00e3o.\nA Figura 3.1 representa uma vis\u00e3o geral da arquitetura de um TMR Heterog\u00eaneo com tr\u00eas inst\u00e2ncias diferentes do processador p-VEX e um votador que coleta o resultado dos processadores ao final da execu\u00e7\u00e3o e realiza uma compara\u00e7\u00e3o, semelhante \u00e0 solu\u00e7\u00e3o implementada em (TAMBARA et al., 2014), que utiliza arquiteturas diferentes, ao contr\u00e1rio do projeto desenvolvido neste trabalho, no qual o TMR \u00e9 desenvolvido utilizando a mesma ISA. Na sa\u00edda, haver\u00e1 o resultado com maioria de votos na sa\u00edda dos processadores p-VEX configura\u00e7\u00e3o 1, microarquitetura 2-issue, p-VEX com a configura\u00e7\u00e3o 2, o processador 4-issue, e p-VEX com a configura\u00e7\u00e3o 3, com a microarquitetura 8-issue. Atrav\u00e9s de diferentes configura\u00e7\u00f5es, ser\u00e1 poss\u00edvel realizar uma an\u00e1lise para determinar como atingir o melhor custo-benef\u00edcio. Como pr\u00f3s, este modelo possui a vantagem de manter o c\u00f3digo da aplica\u00e7\u00e3o inalterado e dispensa qualquer tipo de sincroniza\u00e7\u00e3o entre os processadores, tornando o hardware mais simples. Em contrapartida, com os processadores executando durante um per\u00edodo muito grande sem nenhuma verifica\u00e7\u00e3o de seus resultados, aumentam as chances de que outro processador apresente uma falha, tornando o TMR limitado ao processador mais lento. Por isso, executa-se mais de uma aplica\u00e7\u00e3o, reduzindo os problemas da diferen\u00e7a de desempenho dos processadores, o que ser\u00e1 discutido adiante neste mesmo cap\u00edtulo. Entretanto, caso ocorra um SEU enquanto o processador n\u00e3o estiver operando, est\u00e1 falha n\u00e3o causar\u00e1 danos \u00e0 execu\u00e7\u00e3o do processador. Como as falhas ser\u00e3o injetadas apenas no processador, considerase que as mem\u00f3rias est\u00e3o protegidas por ECC (Error Correction Code) - codifica\u00e7\u00f5es utilizadas em palavras de mem\u00f3ria para detectar e corrigir bits inconsistentes.\nFigura 3.1: Arquitetura de TMR Heterog\u00eaneo com compara\u00e7\u00e3o ao final da execu\u00e7\u00e3o.\nFonte: O autor\nOutra poss\u00edvel abordagem seria a utiliza\u00e7\u00e3o de checkpoints introduzidos no c\u00f3digo assembly da aplica\u00e7\u00e3o. Ao atingir um checkpoint, o votador recebe uma sinaliza\u00e7\u00e3o de checkpoint atingido, informando valores contidos nas sa\u00eddas dos processadores est\u00e3o sincronizados e dispon\u00edveis para compara\u00e7\u00e3o. Esta abordagem \u00e9 semelhante \u00e0 realizada em (SABENA; REORDA; STERPONE, 2014), por\u00e9m, neste caso, o autor adicionava instru\u00e7\u00f5es que atuavam como votador. A Figura 3.2 ilustra como seria a arquitetura desta segunda abordagem, mostrando os checkpoints destacados no c\u00f3digo da aplica\u00e7\u00e3o. Um dos pontos fortes desse modelo \u00e9 a aus\u00eancia de uma sincroniza\u00e7\u00e3o em hardware dos processadores, o que facilita sua implementa\u00e7\u00e3o, com processadores podendo possuir tamanho de issue-slots diferentes, por exemplo. Por\u00e9m, uma das dificuldades seria avaliar a quantidade de checkpoints necess\u00e1ria em cada caso. Checkpoints excessivos podem tornar o c\u00f3digo muito extenso, enquanto que a subutiliza\u00e7\u00e3o de checkpoints pode nos levar \u00e0 uma menor cobertura de falhas como discutido no modelo anterior.\nFigura 3.2: TMR Heterog\u00eaneo com checkpoints de sincroniza\u00e7\u00e3o.\nAplica\u00e7\u00e3o\n- - Checkpoint\nFonte: O autor\nA terceira abordagem para o problema de sincroniza\u00e7\u00e3o das instru\u00e7\u00f5es e realizar a compara\u00e7\u00e3o no votador seria atrav\u00e9s da utiliza\u00e7\u00e3o de buffers. A ideia principal \u00e9 utilizar o compartilhamento de mem\u00f3ria e bancos de registradores entre os processadores, enquanto o n\u00famero de issues e as unidades funcionais seriam diferentes para cada processador. Por\u00e9m, devido ao uso de microarquiteturas com issue-slots de tamanhos diferentes, os processadores facilmente perderiam a sincronia, impossibilitando a avalia\u00e7\u00e3o das instru\u00e7\u00f5es pelo votador. Por isto, adiciona-se um buffer na sa\u00edda de cada processador; assim, o votador l\u00ea e compara as instru\u00e7\u00f5es diretamente de cada buffer. Tamb\u00e9m, \u00e9 necess\u00e1rio analisar e dimensionar corretamente cada buffer a fim de evitar poss\u00edveis overflows. A Figura 3.3 ilustra a arquitetura geral desta solu\u00e7\u00e3o. Embora esta solu\u00e7\u00e3o pare\u00e7a a melhor em um primeiro momento, pois realiza o TMR no n\u00edvel das instru\u00e7\u00f5es e com baixa lat\u00eancia de sinaliza\u00e7\u00e3o em caso de falhas n\u00e3o mascaradas, bem como a redu\u00e7\u00e3o do hardware devido ao uso de mem\u00f3ria compartilhada e, portanto, menor dissipa\u00e7\u00e3o de pot\u00eancia, h\u00e1 um grande desafio em como realizar a quebra de\nFigura 3.3: TMR Heterog\u00eaneo com buffers de sincroniza\u00e7\u00e3o.\nbundles de instru\u00e7\u00f5es, de modo que este possa ser executado em todas as microarquiteturas do processador, independentemente do n\u00famero de issues. Os autores em (BRANDON; WONG, 2013) realizaram uma an\u00e1lise sobre requisitos para realizar o particionamento de bundles atrav\u00e9s da an\u00e1lise de um grafo gerado a partir das instru\u00e7\u00f5es contidas no bundle a ser fracionado. Desta forma, como resultado do fracionamento, foi observado um aumento de at\u00e9 30% de overhead quando comparado ao c\u00f3digo compilado diretamente para o seu devido issue-width. Outro problema nesta implementa\u00e7\u00e3o seria a introdu\u00e7\u00e3o de um ponto \u00fanico de falhas ao utilizar apenas uma mem\u00f3ria e um banco de registradores.\n3.1\tIdeia Desenvolvida\nAp\u00f3s analisar estas tr\u00eas propostas, optou-se por desenvolver a primeira, com a vota\u00e7\u00e3o ao final da execu\u00e7\u00e3o da aplica\u00e7\u00e3o. Assim, \u00e9 poss\u00edvel utilizar arquiteturas com desempenho diferente, n\u00e3o sendo necess\u00e1rio parar completamente a execu\u00e7\u00e3o de um processador, que possua maior capacidade de processamento, para aguardar o t\u00e9rmino do processador de menor vaz\u00e3o de instru\u00e7\u00f5es. Outro fator importante \u00e9 que n\u00e3o ser\u00e1 necess\u00e1rio alterar o c\u00f3digo da aplica\u00e7\u00e3o para adicionar instru\u00e7\u00f5es espec\u00edficas do sistema TMR, evitando assim, a perda de desempenho em rela\u00e7\u00e3o \u00e0 execu\u00e7\u00e3o da aplica\u00e7\u00e3o de forma desprotegida. Al\u00e9m disso, n\u00e3o \u00e9 necess\u00e1rio nenhum tipo de buffer de instru\u00e7\u00f5es, como no terceiro modelo, que aumentaria \u00e1rea do sistema,\nFigura 3.4 Vis\u00e3o geral da Ideia Desenvolvida\nAplica\u00e7\u00f5es\nC\u00f3digo C\nbem como a pot\u00eancia dissipada, sendo a otimiza\u00e7\u00e3o destes dois fatores a principal motiva\u00e7\u00e3o deste trabalho.\n3.1.1\tArquitetura Geral\nComo no TMR comum, tamb\u00e9m s\u00e3o utilizadas tr\u00eas unidades de processamento, por\u00e9m, para o TMR Heterog\u00eaneo, como citado anteriormente, utiliza-se tr\u00eas unidades diferentes, como pode ser melhor visualizado na Figura 3.4. O TMR \u00e9 gerado a partir de tr\u00eas inst\u00e2ncias do softcore p-VEX onde a primeira possui dois lanes de execu\u00e7\u00e3o, ou seja, 2-issue, o segundo softcore \u00e9 um 4-issue e o terceiro \u00e9 um p-VEX 8-issue. Entretanto, devido \u00e0 diferente taxa de instru\u00e7\u00f5es processadas por cada inst\u00e2ncia ser diferente, por quest\u00f5es de diferen\u00e7a de poder de processamento, um TMR simples deixaria as inst\u00e2ncias 4-issue e 8-issue ociosas aguardando pelo t\u00e9rmino da execu\u00e7\u00e3o da aplica\u00e7\u00e3o na inst\u00e2ncia 2-issue. Por isso, decidiu-se tomar uma abordagem diferente: executar tr\u00eas aplica\u00e7\u00f5es na microarquitetura 8-issue, 2 aplica\u00e7\u00f5es na arquitetura 4-issue e uma aplica\u00e7\u00e3o na arquitetura 2-issue. Com isso, busca-se alcan\u00e7ar um equil\u00edbrio no tempo total de execu\u00e7\u00e3o das aplica\u00e7\u00f5es.\nDevido \u00e0 essa preocupa\u00e7\u00e3o com a ociosidade de processadores, foi criado um modelo onde uma aplica\u00e7\u00e3o roda com um TMR com mascaramento de falhas - no p-VEX 2, 4 e 8-issue -, uma aplica\u00e7\u00e3o roda um DMR com sinaliza\u00e7\u00e3o de falhas - nos p-VEX 4 e 8-issue - e uma aplica\u00e7\u00e3o roda de maneira desprotegida no p-VEX 8-issue. Com isso, mesmo que o tempo para\nFigura 3.5: Execu\u00e7\u00e3o de uma tarefa no decorrer do tempo nas diferentes microarquiteturas\nXt\n8-issue\n4-issue\n2-issue\nt\n-Xt\nFonte: O autor\nexecutar tr\u00eas aplica\u00e7\u00f5es no p-VEX 8-issue n\u00e3o seja o mesmo para executar uma aplica\u00e7\u00e3o no p-VEX 2-issue, aproveita-se melhor o tempo pois ao inv\u00e9s de executar uma aplica\u00e7\u00e3o e aguardar um certo per\u00edodo Xt de forma ociosa, executa-se tr\u00eas aplica\u00e7\u00f5es, para s\u00f3 ent\u00e3o ocorrer um per\u00edodo de tempo de aproximadamente Xt ocioso novamente. Atrav\u00e9s das Figura 3.5 \u00e9 poss\u00edvel visualizar como ocorre normalmente a execu\u00e7\u00e3o de uma mesma aplica\u00e7\u00e3o entre as diferentes microarquiteturas, onde Xt representa o tempo que o processador de maior desempenho precisa esperar para que a aplica\u00e7\u00e3o seja finalizada no processador que leva mais tempo para terminar sua execu\u00e7\u00e3o. A Figura 3.6 mostra como uma melhor distribui\u00e7\u00e3o e balanceamento de cargas \u00e9 capaz gera um melhor aproveitamento dos processadores. Os blocos completamente preenchidos em cinza representam uma mesma aplica\u00e7\u00e3o sendo executada nos tr\u00eas processadores, sendo assim, um TMR completo; os blocos com listras diagonais representam uma segunda aplica\u00e7\u00e3o que executa nos processadores 8-issue e 4-issue, ou seja, um DMR; e, por fim, o bloco com listras horizontais representa uma terceira aplica\u00e7\u00e3o que \u00e9 executada de maneira desprotegida no processador 8-issue. Desta forma, \u00e9 poss\u00edvel reduzir -ao final de uma longa miss\u00e3o, por exemplo - o tempo total de ociosidade do sistema, tornando mais eficiente a execu\u00e7\u00e3o de tr\u00eas aplica\u00e7\u00f5es mesmo quando o tempo necess\u00e1rio para terminar as tarefas no processador 8-issue seja maior que o tempo necess\u00e1rio para terminar a aplica\u00e7\u00e3o no processador 2-issue.\n3.1.2\tModifica\u00e7\u00f5es no C\u00f3digo Base VHDL\nPara realizar a execu\u00e7\u00e3o das aplica\u00e7\u00f5es nos tr\u00eas p-VEX de forma paralela, o arquivo onde o sistema \u00e9 instanciado, que inicialmente instanciava apenas um sistema do p-VEX, foi modificado para que fosse criada tr\u00eas inst\u00e2ncias do sistema. Com isso, foram necess\u00e1rias uma s\u00e9rie de modifica\u00e7\u00f5es para que, em fase de s\u00edntese, o compilador reconhecesse qual o tipo de p-VEX est\u00e1 sendo instanciado - 2, 4 ou 8-issue - e gerar os demais sinais, vetores, componentes, entidades, etc de forma correta. Isso foi feito atrav\u00e9s da adi\u00e7\u00e3o de um valor do tipo Generic passado ao Component do sistema p-VEX.\nOutra modifica\u00e7\u00e3o necess\u00e1ria no c\u00f3digo base do p-VEX foi transferir o nome dos arquivos de mem\u00f3ria para a declara\u00e7\u00e3o do componente p-VEX. Com isso, \u00e9 poss\u00edvel passar diferentes nomes de arquivos, uma vez que s\u00e3o gerados arquivos diferentes para cada issue-widths. Assim, ao declarar o p-VEX 2-issue, por exemplo, atribui-se aos arquivos de mem\u00f3ria (de dados e de instru\u00e7\u00f5es) o nome referente aos arquivos compilados para tal configura\u00e7\u00e3o do p-VEX, o mesmo ocorre para os casos 4-issue e 8-issue. Sendo tal modifica\u00e7\u00e3o muito importante no momento em que uma aplica\u00e7\u00e3o \u00e9 finalizada, pois torna poss\u00edvel o carregamento das diferentes aplica\u00e7\u00f5es. Assim, cada vers\u00e3o do p-VEX instancia o n\u00famero de mem\u00f3rias necess\u00e1rias - tr\u00eas mem\u00f3rias de dados e instru\u00e7\u00f5es por processador, quando o processador precisa executar duas aplica\u00e7\u00f5es, duas mem\u00f3rias de instru\u00e7\u00f5es e duas de dados quando o processador executa duas aplica\u00e7\u00f5es, e um m\u00f3dulo de mem\u00f3ria de dados e um m\u00f3dulo de mem\u00f3ria de instru\u00e7\u00f5es quando o processador executa apenas uma aplica\u00e7\u00e3o.\nO controle de execu\u00e7\u00e3o das aplica\u00e7\u00f5es tamb\u00e9m sofreu altera\u00e7\u00f5es. Como anteriormente apenas uma aplica\u00e7\u00e3o era executada em apenas um core, o contador de ciclos e o processo respons\u00e1vel por supervisionar o t\u00e9rmino da simula\u00e7\u00e3o era mais simples. Com dois cores a mais e o aumento do n\u00famero de aplica\u00e7\u00f5es durante a simula\u00e7\u00e3o, o processo de controle utiliza contadores para cada core e sinalizar, quando um dos processadores finaliza as aplica\u00e7\u00f5es que lhe s\u00e3o atribu\u00eddas. Assim, com essa modifica\u00e7\u00e3o, garante-se que a simula\u00e7\u00e3o ser\u00e1 encerrada apenas quando os tr\u00eas processadores rodarem todas as suas aplica\u00e7\u00f5es. Al\u00e9m disso, o processo respons\u00e1vel por contar os ciclos, que era encerrado quando o \u00fanico processador finalizava sua execu\u00e7\u00e3o, tamb\u00e9m foi alterado para continuar contando o n\u00famero total de ciclos at\u00e9 o termino da execu\u00e7\u00e3o de todas as aplica\u00e7\u00f5es, garantindo o controle de quantos ciclos cada processador leva para executar o seu batch de tarefas, bem como o n\u00famero de ciclos necess\u00e1rios para\nexecutar cada uma de suas aplica\u00e7\u00f5es. O controle do n\u00famero de ciclos \u00e9 importante pois uma falha pode interferir no sistema de controle do processador e fazer com que o processador execute indeterminadamente, sem atingir o t\u00e9rmino de sua execu\u00e7\u00e3o. Com o controle do n\u00famero total de ciclos \u00e9 poss\u00edvel finalizar a execu\u00e7\u00e3o quando algum processador extrapolar o tempo esperado para a execu\u00e7\u00e3o do benchmark.\nPara que fosse poss\u00edvel gerar os arquivos de mem\u00f3ria para realizar a compara\u00e7\u00e3o, foram adicionados breakpoints nos pontos onde cada aplica\u00e7\u00e3o \u00e9 terminada para cada processador. Com isso, \u00e9 poss\u00edvel que a simula\u00e7\u00e3o determine quando deve pausar a execu\u00e7\u00e3o do processador e gerar o arquivo contendo o estado final da mem\u00f3ria para futura compara\u00e7\u00e3o. Vale ressaltar que \u00e9 importante a diferencia\u00e7\u00e3o entre qual das tr\u00eas aplica\u00e7\u00f5es e em qual dos tr\u00eas processadores a execu\u00e7\u00e3o foi finalizada para que possa ser gerado arquivos de mem\u00f3ria independentes de cada aplica\u00e7\u00e3o e compar\u00e1-los corretamente no m\u00f3dulo respons\u00e1vel pela vota\u00e7\u00e3o.\nA defini\u00e7\u00e3o do issue-width de cada processador \u00e9 determinada ao criar a inst\u00e2ncia do processador. Assim, dentro do m\u00f3dulo p-VEX, foi necess\u00e1ria uma adapta\u00e7\u00e3o para que os seus componentes internos fossem gerados dinamicamente de acordo com o tamanho do issue-width. Por isso, foram feitas altera\u00e7\u00f5es no sistema p-VEX, bem como nas mem\u00f3rias de dados e instru\u00e7\u00f5es para que tais m\u00f3dulos instanciassem seus componentes de acordo com o tamanho issue-width durante a s\u00edntese, n\u00e3o sendo mais necess\u00e1rio altera-los manualmente.\n4\tMETODOLOGIA\nPara desenvolver este trabalho, foram utilizadas diversas ferramentas para simula\u00e7\u00e3o, s\u00edntese e extra\u00e7\u00e3o de informa\u00e7\u00f5es sobre o circuito. Para s\u00edntese e teste das vers\u00f5es do TMR, foi utilizado a ferramenta Modelsim. O ISE, da Xilinx, tamb\u00e9m foi necess\u00e1rio para gerar parte dos scripts de inje\u00e7\u00e3o, que ser\u00e3o explicados abaixo. Como ferramenta de medida de \u00e1rea e pot\u00eancia, foi utilizado o Cadence\u00ae Encounter RTL. O benchmark executado nas tr\u00eas inst\u00e2ncias do p-VEX \u00e9 um produto vetorial, devido \u00e0 problemas discutidos no cap\u00edtulo 5.\n4.1\tConfigura\u00e7\u00e3o das microarquiteturas\nPara a realiza\u00e7\u00e3o dos testes e medi\u00e7\u00f5es, foram utilizadas, como dito anteriormente, duas vers\u00f5es de TMR: Uma Homog\u00eanea, onde as tr\u00eas microarquiteturas s\u00e3o 8-issue e uma vers\u00e3o Heterog\u00eanea, com microarquiteturas 2-issue, 4-issue e 8-issue. Al\u00e9m das varia\u00e7\u00f5es no n\u00famero de s\u00edlabas por instru\u00e7\u00e3o VLIW, tamb\u00e9m h\u00e1 modifica\u00e7\u00f5es significativas nas Unidades Funcionais, aumentando o desempenho nas arquiteturas com maior grau de paralelismo. Abaixo segue a descri\u00e7\u00e3o das microarquiteturas utilizadas nas duas vers\u00f5es de TMR desenvolvidas para este trabalho.\n4.1.1\tMicroarquitetura TMR Homog\u00eaneo\nNa microarquitetura do TMR Homog\u00eaneo foram utilizadas tr\u00eas inst\u00e2ncias do p-VEX 8-issue com duas Unidades de Multiplica\u00e7\u00e3o e uma Unidade de Mem\u00f3ria. Com isso, foi poss\u00edvel obter um padr\u00e3o para a compara\u00e7\u00e3o entre os dois tipos de TMR. Com as tr\u00eas microarquiteturas com o m\u00e1ximo de paralelismo poss\u00edvel, alcan\u00e7a-se o maior n\u00edvel de prote\u00e7\u00e3o com o pre\u00e7o de aumentar consideravelmente a \u00e1rea ocupada pelo sistema.\n4.1.2\tMicroarquitetura TMR Heterog\u00eaneo\nNo TMR heterog\u00eaneo, como dito anteriormente, h\u00e1 uma instancia 2-issue do p-VEX que, por ser mais simples, possui apenas uma Unidade de Multiplica\u00e7\u00e3o. J\u00e1 a inst\u00e2ncia 4-issue, segue\nexatamente igual \u00e0 vers\u00e3o encontrada no TMR Homog\u00eaneo, com duas Unidades de Multiplica\u00e7\u00e3o. A inst\u00e2ncia 8-issue possui quatro Unidades. Devido \u00e0 uma limita\u00e7\u00e3o do processador p-VEX, todas as inst\u00e2ncias possuem apenas uma Unidade de Mem\u00f3ria e apenas uma Unidade de Branch.\n4.2\tScripts\nAbaixo s\u00e3o descritos dois grupos de scripts, dos quais um \u00e9 utilizado para injetar falhas no sistema atrav\u00e9s de bitflips; e outro respons\u00e1vel por realizar a vota\u00e7\u00e3o dos resultados da aplica\u00e7\u00e3o. Os scripts injetores de falhas foram fornecidos pelo grupo do Orientador deste trabalho, sendo necess\u00e1rias a realiza\u00e7\u00e3o de algumas adapta\u00e7\u00f5es que ser\u00e3o descritas abaixo. O script votador foi desenvolvido a partir de outro script, tamb\u00e9m fornecido pelo grupo, que realizava apenas a verifica\u00e7\u00e3o de uma mem\u00f3ria, sendo necess\u00e1rio adicionar as vota\u00e7\u00f5es do TMR e do DMR para a realiza\u00e7\u00e3o deste trabalho.\n4.2.1\tInjetor de Falhas\nO script injetor de falhas \u00e9 o respons\u00e1vel por gerar anomalias na execu\u00e7\u00e3o das aplica\u00e7\u00f5es atrav\u00e9s da invers\u00e3o do valor de um bit. Antes de cada simula\u00e7\u00e3o, o script injetor seleciona um instante de tempo aleat\u00f3rio e um bit, tamb\u00e9m aleat\u00f3rio, de uma lista de sinais contidos nas inst\u00e2ncias do p-VEX. Ap\u00f3s escolher o instante de tempo e o bit a ser modificado, a simula\u00e7\u00e3o \u00e9 iniciada. Ao atingir o instante de tempo selecionado, a simula\u00e7\u00e3o \u00e9 pausada e o bit selecionado tem o seu valor invertido - se antes o valor deste bit era 1, passa a ter o valor 0 e vice-versa -e, ap\u00f3s isto, a execu\u00e7\u00e3o da aplica\u00e7\u00e3o segue normalmente. Desta forma, \u00e9 poss\u00edvel simular a ocorr\u00eancia de falhas transientes, como as geradas por radia\u00e7\u00e3o, e testar como o sistema se comporta na presen\u00e7a destas mudan\u00e7as nos valores dos bits atrav\u00e9s da compara\u00e7\u00e3o - da mem\u00f3ria de dados e n\u00famero de ciclos totais das aplica\u00e7\u00f5es - ap\u00f3s a execu\u00e7\u00e3o na aus\u00eancia de falhas e a execu\u00e7\u00e3o com inje\u00e7\u00e3o de falhas. \u00c9 importante ressaltar que o instante de tempo selecionado e o bit a ser invertido s\u00e3o gerados randomicamente antes de cada simula\u00e7\u00e3o do sistema executando as tr\u00eas aplica\u00e7\u00f5es, garantindo que cada inje\u00e7\u00e3o de falha seja completamente independente das demais. Outro fator importante e que tamb\u00e9m deve ser ressaltado, \u00e9 que as falhas s\u00e3o injetadas em qualquer um dos piplanes de qualquer um dos processadores podendo,\nassim, atingir um processador durante a execu\u00e7\u00e3o de uma aplica\u00e7\u00e3o protegida por TMR, ou uma aplica\u00e7\u00e3o protegida por DMR ou a aplica\u00e7\u00e3o que executa de maneira desprotegida. Por esse motivo, considera-se que as mem\u00f3rias est\u00e3o protegidas com ECC pois n\u00e3o s\u00e3o afetadas pelas falhas injetadas. As listas de sinais, necess\u00e1rias para a utiliza\u00e7\u00e3o do injetor, s\u00e3o obtidas de arquivos Verilog intermedi\u00e1rios gerados atrav\u00e9s da s\u00edntese dos pipelanes (issue-slols) utilizando o ISE Design Suite da Xilinx. Durante a simula\u00e7\u00e3o, cada inst\u00e2ncia do p-VEX possui um processo que monitora se houve o t\u00e9rmino da aplica\u00e7\u00e3o. Quando a aplica\u00e7\u00e3o \u00e9 finalizada, \u00e9 gerado um arquivo contendo todo o conte\u00fado presente na mem\u00f3ria de dados do processador e, quando necess\u00e1rio, carrega-se as pr\u00f3ximas mem\u00f3rias de dados e instru\u00e7\u00f5es que devem ser executadas.\n4.2.2\tVotador\nO m\u00f3dulo votador, como descrito anteriormente, \u00e9 respons\u00e1vel por determinar se a aplica\u00e7\u00e3o executou de maneira correta ou se houve uma falha. Para determinar se houve alguma falha, ao t\u00e9rmino de cada execu\u00e7\u00e3o, o votador realiza a compara\u00e7\u00e3o das tr\u00eas mem\u00f3rias da aplica\u00e7\u00e3o 1, que rodou nos tr\u00eas processadores, e assume que a execu\u00e7\u00e3o foi correta quando duas ou mais mem\u00f3rias est\u00e3o com os valores iguais. O votador ent\u00e3o compara o resultado das duas aplica\u00e7\u00f5es que rodaram nas inst\u00e2ncias do p-VEX 4-issue e 8-issue e sinaliza caso elas estejam erradas. Por fim, o votador analisa a aplica\u00e7\u00e3o que rodou desprotegida no p-VEX 8-issue e, para fins de c\u00e1lculo da cobertura de falhas, indica se houve uma falha nesta aplica\u00e7\u00e3o. \u00c9 importante relembrar que, para evitar ociosidade de processadores, cada processador executa suas aplica\u00e7\u00f5es de maneira independente. Ou seja, ao terminar sua primeira aplica\u00e7\u00e3o, o p -VEX 8-issue, por exemplo, passa a executar sua segunda aplica\u00e7\u00e3o imediatamente, sem aguardar que a vota\u00e7\u00e3o ocorra.\n5\tRESULTADOS\n5.1\tCompara\u00e7\u00f5es entre TMR Heterog\u00eaneo e o Homog\u00eaneo\nA seguir ser\u00e1 realizado o comparativo entre os resultados obtidos. Como padr\u00e3o, ser\u00e1 adotado como par\u00e2metro o sistema do TMR Homog\u00eaneo e ent\u00e3o ser\u00e1 feita a compara\u00e7\u00e3o com o TMR Heterog\u00eaneo de \u00c1rea, Pot\u00eancia e Desempenho.\n5.1.1\t\u00c1rea\nBuscar a redu\u00e7\u00e3o da \u00e1rea ocupada pelo sistema TMR foi um dos principais prop\u00f3sitos desse trabalho e foi realizado atrav\u00e9s da utiliza\u00e7\u00e3o de microarquiteturas com hardware menor, em troca do n\u00edvel de prote\u00e7\u00e3o atingido. Atrav\u00e9s do Encounter RTL, da Cadence, e do ISE, da Xilinx, foi poss\u00edvel chegar aos valores de \u00e1rea ocupadas em n\u00famero de c\u00e9lulas ASIC, n\u00famero de LUTs e n\u00famero de Registradores, em FPGA, como descritos na tabela Tabela 5.1 para cada configura\u00e7\u00e3o.\nA partir dos dados mostrados na Tabela 5.1, foi poss\u00edvel calcular a \u00e1rea total de cada TMR, Homog\u00eaneo e Heterog\u00eaneo, atrav\u00e9s da soma do n\u00famero de Registradores, LUTs e ASICs referente a cada uma das microarquiteturas que comp\u00f5em cada TMR, e realizar um comparativo entre eles, tomando o TMR Homog\u00eaneo como refer\u00eancia de compara\u00e7\u00e3o, como visto na Tabela\n5.2.\nTabela 5.1 - Compara\u00e7\u00e3o de \u00c1rea do entre as diferentes microarquiteturas.\n\tFPGA\t\tASIC\n\tRegistradores\tLUTs\tCells\n2-Issue\t2652\t7709\t17228\n4-Issue\t3047\t15931\t28049\n8-Issue\t3922\t34984\t65281\n\tFPGA\t\t\tASIC\t\n\tRegistradores\tLUTs\tOverhead\tCells\tOverhead\nTMR Homog\u00eaneo (8-Issue)\t11766\t104952\t1\t195843\t1\nTMR Heterog\u00eaneo (2-,4-,8-issue)\t9621\t58624\t0,5585\t110558\t0,5645\nFonte: O autor\n5.1.2\tPot\u00eancia\nEm teoria, diminuindo-se a \u00e1rea de um processador, diminui-se tamb\u00e9m a pot\u00eancia dissipada, pois haver\u00e1 menos transistores e, consequentemente, menos consumo de corrente. Assim, atrav\u00e9s das ferramentas da Cadence\u00ae Encounter RTL, pode-se chegar ao comparativo total da pot\u00eancia dissipada por ambos TMR. Primeiramente, foram realizadas as medidas de cada configura\u00e7\u00e3o do p-VEX. Chegando aos resultados contidos na Tabela 5.3.\nTabela 5.3 - Medidas de Pot\u00eancia de cada configura\u00e7\u00e3o do p-VEX.\nConfigura\u00e7\u00e3o\tPot\u00eancia (nW)\n2-Issue\t7256991,415\n4-Issue\t13763346,318\n8-Issue\t31373640,353\nFonte: O autor\nTabela 5.4 - Medidas de Pot\u00eancia do TMR Homog\u00eaneo e Heterog\u00eaneo.\nConfigura\u00e7\u00e3o\tPot\u00eancia (nW)\tPropor\u00e7\u00e3o\nTMR Homog\u00eaneo (8-Issue)\t94120921,059\t1\nTMR Heterog\u00eaneo (2-, 4-, 8-Issue)\t52393978,086\t0,5566\nCom isso, pode-se calcular a pot\u00eancia total dissipada e, tomando o TMR Homog\u00eaneo como par\u00e2metro, calcular qual a taxa de redu\u00e7\u00e3o de pot\u00eancia atingida, mostrada na Tabela 5.4.\n5.1.3\tDesempenho\nCom a redu\u00e7\u00e3o do tamanho do Hardware atrav\u00e9s da redu\u00e7\u00e3o do n\u00famero de unidades funcionais e tamb\u00e9m do n\u00edvel de paralelismo utilizado, \u00e9 de se esperar que ocorra uma queda de desempenho do sistema. Foi poss\u00edvel observar que, utilizando aplica\u00e7\u00f5es que demandam um tempo de execu\u00e7\u00e3o muito alto, o tempo total de execu\u00e7\u00e3o das aplica\u00e7\u00f5es \u00e9 determinado pelo processador que executa tr\u00eas aplica\u00e7\u00f5es. O benchmark executado para a inje\u00e7\u00e3o de falhas, c\u00e1lculo do produto interno, precisou de 2325 ciclos no p-VEX 8-issue, 2328 no 4-issue e 2864 ciclos no 2-issue.\n5.2\tN\u00edvel de Prote\u00e7\u00e3o\nNesta se\u00e7\u00e3o ser\u00e1 discutido os resultados e comparativos entre o n\u00edvel de prote\u00e7\u00e3o atingido com o TMR Homog\u00eaneo e o TMR Heterog\u00eaneo. Para tanto, executou-se o injetor de falhas nos dois TMRs durante um per\u00edodo de tempo e anotou-se os n\u00fameros de falhas injetadas, quantas falhas foram protegidas pelo TMR completo, quantas foram sinalizadas pelo DMR e quantas falhas n\u00e3o foram detectadas, pois incidiram no processador desprotegido. \u00c9 importante discutir sobre os tr\u00eas tipos de erros detectados pelo injetor. O primeiro tipo \u00e9 o erro de dados e ocorre quando o algum dado contido na mem\u00f3ria do processador ap\u00f3s sua execu\u00e7\u00e3o est\u00e1 diferente do dado que deveria possuir ap\u00f3s uma execu\u00e7\u00e3o sem a incid\u00eancia de falhas transientes, ou seja, ocorreu um bitflip em algum dado no Datapath que foi propagado e guardado na mem\u00f3ria incorretamente. Outro tipo de erro \u00e9 o erro de controle, que ocorre quando o bitflip altera o fluxo natural de execu\u00e7\u00e3o do programa - alterando o endere\u00e7o alvo de um desvio, por exemplo\n-\tfazendo com que o processador passe a executar indeterminadamente. Esse tipo de erro \u00e9 considerado como erro tratado pela exist\u00eancia de um process que atua como Watchdog Timer\n-\tum timer que sinaliza sempre que o processador parar de responder, realizando a reinicializa\u00e7\u00e3o quando necess\u00e1rio. O terceiro tipo de erro \u00e9 o erro de simula\u00e7\u00e3o. Este erro ocorre quando o ModelSim apresenta um comportamento inesperado e seu processo \u00e9 finalizado abruptamente, sendo estes erros irrelevantes para a an\u00e1lise de resultados.\nTMR Homog\u00eaneo\n\tAppl (TMR)\tApp2 (TMR)\tApp3 (TMR)\nTotal de Falhas Injetadas\t1341\t\t\nErros de Controle\t3\t\t\nErros de Simula\u00e7\u00e3o\t0\t\t\nErros de Dados\t0\t\t\nTaxa de Defeitos\t0%\t0%\t0%\nFonte: O autor\n5.2.1\tN\u00edvel de Prote\u00e7\u00e3o TMR Homog\u00eaneo\nPara determinar o n\u00edvel de prote\u00e7\u00e3o do TMR Homog\u00eaneo, ap\u00f3s a inje\u00e7\u00e3o das falhas, foi feita uma an\u00e1lise de quantas falhas n\u00e3o foram mascaradas pelo TMR. Como o injetor afeta apenas um processador por vez, foi observado o comportamento esperado de um TMR Homog\u00eaneo onde seus processadores s\u00e3o completamente independentes e todas os erros foram mascarados, assim, com o n\u00famero de falhas injetadas, foi poss\u00edvel comprovar essa hip\u00f3tese. A Tabela 5.5 mostra a rela\u00e7\u00e3o de falhas injetadas, erros de controle, erros de simula\u00e7\u00e3o e o n\u00famero de erros de dados que n\u00e3o foram mascarados pelo TMR. Assim, como o esperado, pode-se observar que, na sa\u00edda do TMR sob efeitos de falhas transientes, observa-se uma taxa de defeitos de 0%.\n5.2.2\tN\u00edvel de Prote\u00e7\u00e3o TMR Heterog\u00eaneo\nAbaixo segue o estudo do n\u00edvel de prote\u00e7\u00e3o alcan\u00e7ado com o TMR Heterog\u00eaneo, onde foi injetado um total de 12071 falhas, obtendo-se uma m\u00e9dia est\u00e1vel dos dados analisados. Al\u00e9m dos tipos de erros j\u00e1 citados (erro de dados, simula\u00e7\u00e3o e controle), o TMR Heterog\u00eaneo possui alguns casos particulares. Pelo fato do TMR Heterog\u00eaneo ser composto de um TMR, um DMR\nTMR Heterog\u00eaneo\nN\u00edvel de Prote\u00e7\u00e3o\tAplica\u00e7\u00e3o 1 (TMR)\tAplica\u00e7\u00e3o 2 (DMR)\tAplica\u00e7\u00e3o 3 (Desprotegida)\nTotal de Falhas\t\t12071\t\nInjetadas\t\t\t\nErros de Controle\t65\t\t\nErros de Simula\u00e7\u00e3o\t1\t\t\nErros de Dados\t0\t472\t465\nTaxa de Defeitos\t0%\t0%\t3,85%\nFonte: O autor\ne uma aplica\u00e7\u00e3o desprotegida, foi necess\u00e1rio analisar tais casos. Assim, a Tabela 5.6 mostra a rela\u00e7\u00e3o de falhas injetadas, falhas mascaradas (Erros de dados que foram mascarados pelo TMR), falhas sinalizadas pelo DMR, ou seja, uma mem\u00f3ria do DMR \u00e9 diferente da outra e essa falha foi sinalizada pelo DMR, o n\u00famero de falhas apresentadas pela aplica\u00e7\u00e3o desprotegida e os demais tipos de erros discutidos anteriormente. Assim, como o \u00e9 injetada apenas uma falha por vez em apenas um processador, o TMR, como esperado, \u00e9 capaz de mascarar todas as falhas e, al\u00e9m disso, o DMR tamb\u00e9m \u00e9 capaz de sinalizar as falhas, sendo o \u00fanico caso de falhas propagadas para a sa\u00edda, aquelas afetam o processador desprotegido do TMR.\n5.2.3\tComparativo do n\u00edvel de prote\u00e7\u00e3o TMR Homog\u00eaneo x TMR Heterog\u00eaneo\nPara finalizar a an\u00e1lise de falhas, a Tabela 5.7 mostra um comparativo entre a porcentagem de prote\u00e7\u00e3o contra falhas foi atingida com cada uma das vers\u00f5es do TMR. Nesta tabela, \u00e9 poss\u00edvel observar que a execu\u00e7\u00e3o de ambos os TMRs possuem, como o esperado, a mesma taxa de defeitos. A aplica\u00e7\u00e3o executada em DMR tamb\u00e9m apresenta a sinaliza\u00e7\u00e3o de 100% das falhas que prejudicariam a execu\u00e7\u00e3o da aplica\u00e7\u00e3o.\nTabela 5.7: Compara\u00e7\u00e3o do n\u00edvel de prote\u00e7\u00e3o do TMR Homog\u00eaneo e Heterog\u00eaneo.\n\tTMR Heterog\u00eaneo\t\t\tTMR Homog\u00eaneo\nProte\u00e7\u00e3o da Aplica\u00e7\u00e3o\tTMR\tDMR\tDesprotegido\tTMR\nTotal de Falhas Injetadas\t12071\t\t\t1341\nErros de Controle\t65\t\t\t3\nErros de Simula\u00e7\u00e3o\t1\t\t\t0\nErros de Dados\t0\t472\t465\t0\nTaxa de Defeitos\t0%\t0%\t3,85%\t0%\nFonte: O autor\n5.3\tProblemas encontrados durante o desenvolvimento\nSegue a seguir uma discuss\u00e3o sobre problemas encontrados durante o desenvolvimento do trabalho. Obviamente, ocorrem muitas dificuldades em quest\u00e3o de desenvolvimento do c\u00f3digo, por\u00e9m ser\u00e3o listadas apenas dificuldades mais cr\u00edticas e que exigiram um maior estudo sobre o caso e tomadas de decis\u00f5es para que o projeto pudesse ser conclu\u00eddo.\n5.3.1\tPilha\nComo problemas durante o desenvolvimento \u00e9 necess\u00e1rio citar uma certa dificuldade em rela\u00e7\u00e3o \u00e0 pilha dos processadores. Com processadores de diferentes issue-widths, o bin\u00e1rio gerado pela compila\u00e7\u00e3o \u00e9 diferente para cada vers\u00e3o e, com isso, a pilha se comporta de maneira diferente. Assim, ao comparar as mem\u00f3rias entre as diferentes vers\u00f5es do p-VEX, no TMR Heterog\u00eaneo, foi poss\u00edvel notar que a \u00fanica diferen\u00e7a na mem\u00f3ria de dados era a regi\u00e3o utilizada pela pilha. Para que fosse poss\u00edvel realizar a compara\u00e7\u00e3o entre as diferentes vers\u00f5es das microarquiteturas, cada mem\u00f3ria ap\u00f3s a inje\u00e7\u00e3o de falhas foi comparada com uma mem\u00f3ria\n5.3.2\tMem\u00f3ria RAM\nDurante o desenvolvimento do TMR, percebeu-se um consider\u00e1vel aumento no consumo de mem\u00f3ria RAM durante a simula\u00e7\u00e3o da vers\u00e3o em que h\u00e1 processadores que executam mais de uma aplica\u00e7\u00e3o. Isso foi causado pela exist\u00eancia de tr\u00eas m\u00f3dulos de mem\u00f3ria para armazenar instru\u00e7\u00f5es e tr\u00eas m\u00f3dulos de mem\u00f3ria de dados por processador, totalizando nove mem\u00f3rias de instru\u00e7\u00f5es e nove mem\u00f3rias de dados, no caso do TMR Homog\u00eaneo. Isso foi necess\u00e1rio devido \u00e0s trocas de aplica\u00e7\u00f5es, ou seja, cada aplica\u00e7\u00e3o possui a sua mem\u00f3ria de dados e sua mem\u00f3ria de instru\u00e7\u00f5es. Devido a esse problema com o consumo de mem\u00f3ria RAM, os m\u00f3dulos de mem\u00f3ria do p-VEX foram dimensionados de maneira que o tamanho total de cada mem\u00f3ria seja apenas o suficiente para conter toda a aplica\u00e7\u00e3o, evitando que as mem\u00f3rias fossem subutilizadas - com instru\u00e7\u00f5es vazias, por exemplo - reduzindo o consumo total de mem\u00f3ria RAM ocupada pelo Modelsim e tornando poss\u00edvel a simula\u00e7\u00e3o.\n6\tCONCLUS\u00d5ES E TRABALHOS FUTUROS\nA seguir, neste cap\u00edtulo s\u00e3o apresentadas as conclus\u00f5es obtidas durante a realiza\u00e7\u00e3o deste trabalho de gradua\u00e7\u00e3o. Tamb\u00e9m s\u00e3o apresentadas algumas propostas para trabalhos futuros baseados na experi\u00eancia e ideias obtidas durante o desenvolvimento e que, por algum motivo, n\u00e3o p\u00f4de ser desenvolvida nesse projeto.\n6.2\tConclus\u00f5es\nConforme foi observado, \u00e9 poss\u00edvel concluir que se atinge n\u00edveis satisfat\u00f3rios de \u00e1rea e redu\u00e7\u00e3o de pot\u00eancia, reduzindo ambas a praticamente metade. Por\u00e9m, a taxa de erros na aplica\u00e7\u00e3o desprotegida \u00e9 extremamente alta para os padr\u00f5es mais altos de sistemas cr\u00edticos. Por\u00e9m, para aplica\u00e7\u00f5es em miss\u00f5es espaciais onde, por exemplo, coleta-se imagens constantemente, a perda de alguma dessas imagens, ou algum pixel com a cor levemente alterada n\u00e3o causaria grande impacto frente \u00e0 redu\u00e7\u00e3o de dissipa\u00e7\u00e3o de energia e \u00e1rea atingidas. Sobre o desempenho, \u00e9 necess\u00e1rio observar que, para os experimentos finais, n\u00e3o foi poss\u00edvel reduzir completamente a ociosidade dos processadores mais lentos, como discutido em 3.1.1, devido ao problema com a mem\u00f3ria RAM discutido em 5.3.2. Por\u00e9m, os resultados obtidos continuam validos pois a simula\u00e7\u00e3o tratou cada grupo de aplica\u00e7\u00f5es (protegidas por TMR, DMR e desprotegida) de maneira independente. Durante este trabalho tamb\u00e9m foi poss\u00edvel compreender melhor as diversas etapas de um projeto de hardware, desde o desenvolvimento de uma ideia abstrata, at\u00e9 as simula\u00e7\u00f5es e extra\u00e7\u00e3o de dados que possibilitam determinar pontos fortes e fracos do novo sistema desenvolvido.\n6.2\tTrabalhos Futuros\nPara poss\u00edveis trabalhos futuros, podem ser realizadas melhorias neste modelo apresentado, bem como a simula\u00e7\u00e3o do comportamento deste sistema sob a influ\u00eancia de um ambiente com maior radia\u00e7\u00e3o, gerando um n\u00famero maior de bitflips.\nUma das principais propostas seria transformar o m\u00f3dulo votador, que neste trabalho foi realizado em software, em um componente de hardware que possa ser implementado\njuntamente no mesmo circuito, ou at\u00e9 mesmo em um circuito a parte, garantindo uma maior autonomia para o sistema.\nOutra possibilidade seria a de modificar a forma como as aplica\u00e7\u00f5es s\u00e3o carregadas, tornando poss\u00edvel decidir em tempo de execu\u00e7\u00e3o qual aplica\u00e7\u00e3o ir\u00e1 executar. Assim, seria poss\u00edvel implementar uma solu\u00e7\u00e3o mais din\u00e2mica e com um maior mascaramento de falhas. A ideia seria executar primeiramente a aplica\u00e7\u00e3o do TMR no processador 2-issue, a aplica\u00e7\u00e3o do DMR no 4-issue e no 8-issue. A segunda aplica\u00e7\u00e3o dos processadores 4 e 8-issue, ent\u00e3o, seria a aplica\u00e7\u00e3o protegida com TMR. Assim, caso ocorresse uma diferen\u00e7a de resultado entre a execu\u00e7\u00e3o das aplica\u00e7\u00f5es do DMR, seria poss\u00edvel carregar novamente a aplica\u00e7\u00e3o DMR no processador 8-issue e ent\u00e3o realizar uma nova compara\u00e7\u00e3o com este novo resultado. Com isso, mascara-se a falha sinalizada pelo DMR e n\u00e3o haveria a necessidade de descartar toda a computa\u00e7\u00e3o realizada e nem reexecutar a aplica\u00e7\u00e3o aumentando o n\u00edvel de prote\u00e7\u00e3o do sistema. Durante a pr\u00f3xima execu\u00e7\u00e3o, caso o DMR n\u00e3o apresente diferen\u00e7a entre as duas execu\u00e7\u00f5es, o processador 8-issue seguiria com a execu\u00e7\u00e3o da terceira aplica\u00e7\u00e3o normalmente. Esta seria apenas uma das caracter\u00edsticas que poderiam ser exploradas utilizando este TMR Heterog\u00eaneo. Sendo poss\u00edvel atingir o n\u00edvel de prote\u00e7\u00e3o do TMR tradicional, por\u00e9m ocupando muito menos \u00e1rea.\nA partir da Tabela 5.1, que mostra a \u00e1rea ocupada por cada microarquitetura, \u00e9 poss\u00edvel notar que 6 inst\u00e2ncias do processador 2-issue ocupam, aproximadamente, a mesma \u00e1rea do TMR Heterog\u00eaneo 2-,4-,8-issue. Como proposta para atingir um maior desempenho, poderia ser realizado um estudo sobre a seguinte abordagem: Utilizar seis inst\u00e2ncias do p -VEX 2-issue e executar as tr\u00eas aplica\u00e7\u00f5es de forma paralela, com o objetivo de obter os mesmos n\u00edveis de prote\u00e7\u00e3o atingidos neste trabalho, com uma aplica\u00e7\u00e3o protegida por TMR, uma aplica\u00e7\u00e3o protegida por DMR e uma aplica\u00e7\u00e3o desprotegida. Sendo assim, tr\u00eas processadores executariam em paralelo uma aplica\u00e7\u00e3o, sendo essa protegida por TMR, dois processadores executando a segunda aplica\u00e7\u00e3o, protegida por DMR, e o sexto processador executando a terceira aplica\u00e7\u00e3o de maneira desprotegida. Apesar desta abordagem, a princ\u00edpio, aumentar o desempenho do sistema, um dos problemas dessa abordagem seria a quantidade total de mem\u00f3rias, seis mem\u00f3rias de instru\u00e7\u00f5es e seis mem\u00f3rias de dados, o que poderia aumentar consideravelmente o tamanho final do sistema.\nSeguindo ainda a ideia do TMR Heterog\u00eaneo, seria interessante utilizar o trabalho realizado por (BRANDON; WONG, 2013), que torna poss\u00edvel a execu\u00e7\u00e3o do mesmo c\u00f3digo bin\u00e1rio entre as diferentes microarquiteturas, sendo poss\u00edvel a utiliza\u00e7\u00e3o de apenas uma mem\u00f3ria e um banco\nde registrador, reduzindo a \u00e1rea total do sistema TMR. Por\u00e9m, como foi observado, isso cria um ponto \u00fanico de falha que precisaria ser analisado e, caso as simula\u00e7\u00f5es mostrassem necess\u00e1rias, desenvolver uma t\u00e9cnica de prote\u00e7\u00e3o da mem\u00f3ria e do banco de registradores.\nREFER\u00caNCIAS\nANJAM, F.; WONG, S. Configurable fault-tolerance for a configurable VLIW processor.\nInternational Symposium on Applied Reconfigurable Computing. Anais...2013\nBAUMANN, R. C. Radiation-induced soft errors in advanced semiconductor technologies.\nDevice and Materials Reliability, IEEE Transactions on, v. 5, n. 3, p. 305-316, 2005.\nBRANDON, A.; WONG, S. Support for dynamic issue width in VLIW processors using generic binaries. Proceedings of the Conference on Design, Automation and Test in Europe. Anais...2013\nHP LABS. VEX Toolchain. Dispon\u00edvel em:&lt;http://www.hpl.hp.com/downloads/vex/>.\nICHINOMIYA, Y. et al. Improving the robustness of a softcore processor against SEUs by using TMR and partial reconfiguration. Field-Programmable Custom Computing Machines (FCCM), 2010 18th IEEE Annual International Symposium on. Anais...2010\nLI, Y.; SKADRON, K. TMR: A Solution for Hardware Security Designs. [s.d.].\nLOWNEY, P. G. et al. The multiflow trace scheduling compiler. The journal of Supercomputing, v. 7, n. 1-2, p. 51-142, 1993.\nLYONS, R. E.; VANDERKULK, W. The use of triple-modular redundancy to improve computer reliability. IBM Journal of Research and Development, v. 6, n. 2, p. 200-209, 1962.\nPRATT, B. et al. Improving FPGA design robustness with partial TMR. 2006 IEEE\nInternational Reliability Physics Symposium Proceedings. Anais...2006\nSABENA, D.; REORDA, M. S.; STERPONE, L. Soft error effects analysis and mitigation in VLIW safety-critical applications. Very Large Scale Integration (VLSI-SoC), 2014 22nd International Conference on. Anais...2014\nSAMUDRALA, P. K.; RAMOS, J.; KATKOORI, S. Selective triple modular redundancy\n(STMR) based single-event upset (SEU) tolerant synthesis for FPGAs. Nuclear Science, IEEE Transactions on, v. 51, n. 5, p. 2957-2969, 2004.\nSCHOLZEL, M. Reduced Triple Modular redundancy for built-in self-repair in VLIW-processors. Signal Processing Algorithms, Architectures, Arrangements and Applications, 2007. Anais...2007\nSHIN, K. G.; KIM, H. A time redundancy approach to TMR failures using fault-state likelihoods. IEEE Transactions on Computers, v. 43, n. 10, p. 1151-1162, 1994.\nTAMBARA, L. A. et al. Decreasing FIT with diverse triple modular redundancy in SRAMbased FPGAs. Defect and Fault Tolerance in VLSI and Nanotechnology Systems (DFT), 2014 IEEE International Symposium on. Anais...2014\nTOTONI, E. et al. Comparing the power and performance of Intel\u2019s SCC to state-of-the-art CPUs and GPUs. Performance Analysis of Systems and Software (ISPASS), 2012 IEEE International Symposium on. Anais...2012\nWEBER, T. S. Toler\u00e2ncia a falhas: conceitos e exemplos. Apostila do Programa de P\u00f3s-\nGradua\u00e7\u00e3o--Instituto de Inform\u00e1tica-UFRGS. Porto Alegre, 2003.\nWONG, S.; VAN AS, T.; BROWN, G. p-VEX: A reconfigurable and extensible softcore VLIW processor. ICECE Technology, 2008. FPT 2008. International Conference on. Anais...2008"}]}}}