{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.11359"}, {"@name": "filename", "#text": "16635_000709217.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL \n\nINSTITUTO DE INFORM\u00c1TICA \n\nPROGRAMA DE P\u00d3S-GRADUA\u00c7\u00c3O EM COMPUTA\u00c7\u00c3O \n\n \n\n \n\n \n\n \n\n \n\nEDUARDO STUDZINSKI ESTIMA DE CASTRO \n\n \n\n \n\n \n\n \n\nK-Aspects: uma abordagem baseada em \naspectos para implementa\u00e7\u00e3o de sistemas de \n\nconhecimento \n \n\n \n\n \n\n \n\n \n\n \n\nDisserta\u00e7\u00e3o apresentada como requisito parcial \npara a obten\u00e7\u00e3o do grau de Mestre em Ci\u00eancia \nda Computa\u00e7\u00e3o \n\n \n \nProf. Dr. Roberto Tom Price \nOrientador \n \n \nProfa. Dra. Mara Abel \nCo-orientadora \n\n \n \n \n \n \n \n\nPorto Alegre, maio de 2009.\n\n\n\n \n\n \n\n \n\nCIP \u2013 CATALOGA\u00c7\u00c3O NA PUBLICA\u00c7\u00c3O \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \nUNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL \nReitor: Prof. Carlos Alexandre Netto \nVice-Reitor: Prof. Rui Vicente Oppermann \nPr\u00f3-Reitor de P\u00f3s-Gradua\u00e7\u00e3o: Prof. Aldo Bolten Lucion \nDiretor do Instituto de Inform\u00e1tica: Prof. Fl\u00e1vio Rech Wagner \nCoordenador do PPGC: Prof. \u00c1lvaro Freitas Moreira \nBibliotec\u00e1ria-Chefe do Instituto de Inform\u00e1tica: Beatriz Regina Bastos Haro \n\nCastro, Eduardo Studzinski Estima de \n\nK-Aspects: uma abordagem baseada em aspectos para \nimplementa\u00e7\u00e3o de sistemas de conhecimento / Eduardo Studzinski \nEstima de Castro \u2013 Porto Alegre: Programa de P\u00f3s-Gradua\u00e7\u00e3o em \nComputa\u00e7\u00e3o, 2009. \n\n83 f.:il. \n\nDisserta\u00e7\u00e3o (mestrado) \u2013 Universidade Federal do Rio Grande \ndo Sul. Programa de P\u00f3s-Gradua\u00e7\u00e3o em Computa\u00e7\u00e3o. Porto \nAlegre, BR \u2013 RS, 2009. Orientador: Roberto Tom Price; Co-\norientadora: Mara Abel. \n\n1.Engenharia de Software. 2.Sistemas de Conhecimento \n3.Projeto. I. Price, Orientador da.  II. Abel, Co-orientador da. III. \nK-Aspects: uma abordagem baseada em aspectos para \nimplementa\u00e7\u00e3o de sistemas de conhecimento. \n\n\n\n \n\n \n\n3 \n\n \n\nAGRADECIMENTOS \n\nGostaria de agradecer a minha fam\u00edlia e a minha namorada, Gisele, pelo apoio na \nrealiza\u00e7\u00e3o desse mestrado. Principalmente, por entender a minha aus\u00eancia em alguns \nmomentos para a realiza\u00e7\u00e3o do trabalho. \n\nGostaria de agradecer aos meus orientadores, Professor Tom Price e Professora \nMara Abel pelo completo apoio prestado durante o desenvolvimento desse trabalho e \npela riqueza do conhecimento adquirido ao longo desse mestrado.  \n\nGostaria de agradecer aos amigos do Grupo BDI pela riqueza de id\u00e9ias trocadas. \nPrincipalmente ao Sandro, pelas longas discuss\u00f5es te\u00f3ricas e t\u00e9cnicas. \n\nGostaria de agradecer a ENDEEPER por ter apoiado esse trabalho. \n\nGostaria de agradecer a todo o corpo docente e funcion\u00e1rios do Instituto de \nInform\u00e1tica/UFRGS pelo esfor\u00e7o conjunto realizado ao longo dos anos possibilitando a \np\u00f3s-gradua\u00e7\u00e3o estar em um excelente n\u00edvel. \n\nPor fim, gostaria de agradecer a todos aqueles que contribu\u00edram de alguma forma \npara esse trabalho. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n4 \n\nSUM\u00c1RIO \n\nLISTA DE ABREVIATURAS E SIGLAS ....................................................... 6 \n\nLISTA DE FIGURAS ..................................................................................... 7 \n\nLISTA DE TABELAS .................................................................................... 8 \n\nRESUMO ...................................................................................................... 9 \n\nABSTRACT ................................................................................................ 10 \n\n1 INTRODU\u00c7\u00c3O ...................................................................................... 11 \n1.1 Motiva\u00e7\u00e3o ............................................................................................................................... 13 \n1.2 Objetivos ................................................................................................................................ 15 \n1.3 Organiza\u00e7\u00e3o dos Cap\u00edtulos ................................................................................................... 17 \n\n2 CONCEITOS E TRABALHOS RELACIONADOS ................................ 19 \n2.1 Orienta\u00e7\u00e3o a Aspectos........................................................................................................... 19 \n2.2 Orienta\u00e7\u00e3o a Aspectos e Sistemas de Conhecimento .......................................................... 21 \n2.3 Anota\u00e7\u00f5es de Metadados....................................................................................................... 22 \n2.4 Orienta\u00e7\u00e3o a Objetos e Sistemas de Conhecimento............................................................ 24 \n\n2.4.1 Sistemas Orientados a Objetos para Processamento de Regras ............................................. 24 \n2.4.2 XP.K ...................................................................................................................................... 24 \n\n2.5 An\u00e1lise Cr\u00edtica dos Trabalhos Relacionados....................................................................... 27 \n\n3 K-ASPECTS: ASPECTOS PARA IMPLEMENTA\u00c7\u00c3O DO \nCOMPONENTE CONCEITUAL ....................................................................... 29 \n\n3.1 Processo de Uso de K-Annotations....................................................................................... 30 \n3.2 Biblioteca de K-Annotations................................................................................................. 32 \n3.3 Biblioteca de Tratamento de Facets, Axiomas e Regras .................................................... 38 \n3.4 Biblioteca de K-Aspects do Componente Conceitual ......................................................... 39 \n3.5 Sum\u00e1rio do Cap\u00edtulo 3 .......................................................................................................... 41 \n\n4 K-ASPECTS: ASPECTOS PARA IMPLEMENTA\u00c7\u00c3O DOS \nCOMPONENTES DE TAREFA E INFERENCIAL ........................................... 42 \n\n4.1 Biblioteca de K-Aspects para Componentes de Tarefa e Inferencial................................ 43 \n4.2 Exemplo Did\u00e1tico .................................................................................................................. 46 \n4.3 Sum\u00e1rio do Cap\u00edtulo 4 .......................................................................................................... 49 \n\n5 VALIDA\u00c7\u00c3O DA PROPOSTA .............................................................. 50 \n5.1 Estudo de Caso: Sistema Petroledge .................................................................................... 50 \n\n\n\n \n\n \n\n5 \n\n5.1.1 Componente Conceitual ......................................................................................................... 52 \n5.1.2 Componentes de Tarefa e Inferencial .................................................................................... 58 \n\n5.2 Solu\u00e7\u00e3o Atual ......................................................................................................................... 61 \n5.2.1 Implementa\u00e7\u00e3o do Componente do Modelo Conceitual sem K-Aspects ............................... 62 \n5.2.2 Implementa\u00e7\u00e3o dos Componentes de Tarefa e Inferencial sem K-Aspects ........................... 65 \n\n5.3 Solu\u00e7\u00e3o com K-Aspects ......................................................................................................... 66 \n5.3.1 Implementa\u00e7\u00e3o do Componente do Modelo Conceitual com K-Aspects............................... 67 \n5.3.2 Implementa\u00e7\u00e3o dos Componentes de Tarefa e Inferencial com K-Aspects ........................... 70 \n5.3.3 Benef\u00edcios da Implementa\u00e7\u00e3o do Petroledge usando K-Aspects ........................................... 71 \n\n5.4 Sum\u00e1rio do Cap\u00edtulo 5 .......................................................................................................... 73 \n\n6 CONCLUS\u00c3O ....................................................................................... 76 \n6.1 Trabalhos Futuros ................................................................................................................. 77 \n\nREFER\u00caNCIAS........................................................................................... 78 \n\nANEXO GRAM\u00c1TICA DO JEP (AXIOMAS) .............................................. 82 \n\n \n\n\n\n \n\n \n\n6 \n\nLISTA DE ABREVIATURAS E SIGLAS \n\nCKADS CommonKADS \n\nIA Intelig\u00eancia Artificial \n\nJEP Java Expression Parser \n\nMC Modelo de Conhecimento \n\nOO Orienta\u00e7\u00e3o a Objetos \n\nOA Orienta\u00e7\u00e3o a Aspectos \n\nPSM M\u00e9todos de Solu\u00e7\u00f5es de Problemas \u2013 Padr\u00f5es Cognitivos \n\nSC Sistema de Conhecimento \n\nSGBD Sistema Gerenciador de Banco de Dados \n\nUML Unified Modeling Language \n\n \n\n \n\n\n\n \n\n \n\n7 \n\nLISTA DE FIGURAS \n\nFigura 2.1: Exemplo de Dispers\u00e3o devido a Funcionalidades Transversais. ................. 20 \nFigura 2.2: Exemplo de Aspecto para Log de Invoca\u00e7\u00e3o de M\u00e9todo............................. 20 \nFigura 2.3: C\u00f3digo-fonte da Anota\u00e7\u00e3o Log. ................................................................... 23 \nFigura 2.4: C\u00f3digo-fonte da obten\u00e7\u00e3o de anota\u00e7\u00f5es de uma classe via reflex\u00e3o. .......... 23 \nFigura 3.1: Processo de Uso de K-Annotations. ............................................................. 31 \nFigura 3.2: Diagrama de Sequ\u00eancia para Valida\u00e7\u00e3o de Axioma. ................................... 32 \nFigura 3.3: Metamodelo dos Construtos do Componente Conceitual............................ 34 \nFigura 3.4: Vis\u00e3o L\u00f3gica das K-Annotations. ................................................................ 34 \nFigura 3.5: Vis\u00e3o L\u00f3gica da Biblioteca de Tratamento de K-Annotations..................... 38 \nFigura 3.6: Vis\u00e3o L\u00f3gica dos K-Aspects para o Componente Conceitual...................... 41 \nFigura 4.1: Estrutura de infer\u00eancia que descreve o m\u00e9todo de classifica\u00e7\u00e3o ................. 43 \nFigura 4.2: Vis\u00e3o L\u00f3gica dos K-Aspects para os Componentes do Modelo de \nConhecimento. ................................................................................................................ 45 \nFigura 4.3: Exemplo de Implementa\u00e7\u00e3o do Componente Conceitual. ........................... 47 \nFigura 4.4: Pointcut para valida\u00e7\u00e3o de valor m\u00e1ximo.................................................... 48 \nFigura 4.5: Advice para valida\u00e7\u00e3o de valor m\u00e1ximo. ..................................................... 48 \nFigura 5.1: Fluxo de Trabalho do Sistema Petroledge .................................................. 50 \nFigura 5.2: Tela para Entrada de Dados de Microscopia ............................................... 51 \nFigura 5.3: Conceitos do Sistema Petroledge. ................................................................ 56 \nFigura 5.4: Metamodelo de Grafo de Conhecimento para Interpreta\u00e7\u00e3o ....................... 57 \nFigura 5.5: Exemplo de Grafo de Conhecimento. .......................................................... 57 \nFigura 5.6: Modelo da Tarefa de Interpreta\u00e7\u00e3o de Ambiente Diagen\u00e9tico .................... 59 \nFigura 5.7: Modelo de Infer\u00eancia do PSM de Interpreta\u00e7\u00e3o de Ambientes Diagen\u00e9ticos\n........................................................................................................................................ 60 \nFigura 5.8: Fragmento da Implementa\u00e7\u00e3o Atual do Conceito ThinIdentification. ........ 63 \nFigura 5.9: Fragmento da Implementa\u00e7\u00e3o Atual do Conceito Microscopic. ................. 64 \nFigura 5.10: Diagrama de Sequ\u00eancia da Implementa\u00e7\u00e3o do PSM de Interpreta\u00e7\u00e3o. ..... 65 \nFigura 5.11: Aspectos identificados na implementa\u00e7\u00e3o de tr\u00eas conceitos. .................... 67 \nFigura 5.12: Fragmento da Implementa\u00e7\u00e3o com K-Aspects do Conceito \nThinIdentification. .......................................................................................................... 69 \nFigura 5.13: Fragmento da Implementa\u00e7\u00e3o com K-Aspects do Conceito Microscopic. 70 \n\n \n\n \n\n \n\n\n\n \n\n \n\n8 \n\nLISTA DE TABELAS \n\nTabela 3.1: K-Annotations para a Defini\u00e7\u00e3o de Facets. ................................................. 37 \nTabela 4.1: Exemplo de Infer\u00eancias . ............................................................................. 42 \nTabela 4.2: Exemplo de Componente Conceitual. ......................................................... 46 \nTabela 5.1: Modelo de Conceitos do Sistema Petroledge ............................................. 53 \nTabela 5.2: Quantidade de Funcionalidades Transversais Tratadas via Aspectos. ........ 66 \n\n \n\n \n\n\n\n \n\n \n\n9 \n\nRESUMO \n\nEsse trabalho define K-Aspects (Knowledge Aspects), uma abordagem para a \nimplementa\u00e7\u00e3o de Sistemas de Conhecimento (SC) em linguagens orientadas a objetos usando o \nparadigma orientado a aspectos (OA) e anota\u00e7\u00f5es de metadados. Essa abordagem define uma \nforte correspond\u00eancia entre o Modelo de Conhecimento (MC) e sua implementa\u00e7\u00e3o no \nparadigma da orienta\u00e7\u00e3o a objetos (OO). K-Aspects fornece um conjunto de anota\u00e7\u00f5es \ndocumentacionais para facilitar a leitura da associa\u00e7\u00e3o entre o modelo de implementa\u00e7\u00e3o e o \nmodelo conceitual do conhecimento; um conjunto de anota\u00e7\u00f5es para facilitar a separa\u00e7\u00e3o de \ninteresses na implementa\u00e7\u00e3o do SC usando OA; um conjunto de bibliotecas para realizar a \ninterpreta\u00e7\u00e3o das anota\u00e7\u00f5es e sua execu\u00e7\u00e3o em aspectos; e uma ferramenta para gera\u00e7\u00e3o de \ndocumenta\u00e7\u00e3o do MC a partir das anota\u00e7\u00f5es no c\u00f3digo. A abordagem busca atender tanto os \nengenheiros de conhecimento quanto os engenheiros de desenvolvimento em projetos de SC. Os \nengenheiros de conhecimento tem ao seu alcance um modo adequado para elaborar a \nespecifica\u00e7\u00e3o do MC que resulta em uma especifica\u00e7\u00e3o em uma linguagem orientada a objetos, \npermitindo aos engenheiros de desenvolvimento implementarem o sistema preservando a \nestrutura do modelo conceitual e mantendo clara distin\u00e7\u00e3o entre os requisitos associados ao MC \ndos demais requisitos. \n\nK-Annotations adicionam recursos de OA ao modelo conceitual do conhecimento OO, \noferecendo facilidades de tratamento separado de diversas funcionalidades transversais de um \nSC, atrav\u00e9s do particionamento do sistema em aspectos que implementam funcionalidades \nespec\u00edficas, ativadas atrav\u00e9s das anota\u00e7\u00f5es inseridas no componente do modelo conceitual. \nAnota\u00e7\u00f5es distinguem, clara e visualmente, no c\u00f3digo, os elementos do MC em rela\u00e7\u00e3o ao \nrestante do c\u00f3digo do programa, facilitando a leitura do c\u00f3digo pelos engenheiros de \nconhecimento. A fun\u00e7\u00e3o principal das anota\u00e7\u00f5es \u00e9 prover as informa\u00e7\u00f5es necess\u00e1rias para a \ninterpreta\u00e7\u00e3o dos elementos de conhecimento durante a execu\u00e7\u00e3o do programa. Anota\u00e7\u00f5es \nidentificam as funcionalidades transversais relativas aos construtos do modelo e s\u00e3o gerenciadas \npela biblioteca de aspectos. \n\nA abordagem foi validada re-escrevendo com o uso de K-Annotations um sistema de \nconhecimento no dom\u00ednio da an\u00e1lise da qualidade de reservat\u00f3rios de petr\u00f3leo. O modelo desse \nsistema representa uma ontologia de dom\u00ednio sobre o qual m\u00e9todos de solu\u00e7\u00e3o de problemas \npara interpreta\u00e7\u00e3o e classifica\u00e7\u00e3o de rochas s\u00e3o aplicados. A an\u00e1lise dos resultados identificou \num conjunto de vantagens no uso de K-Aspects, como distin\u00e7\u00e3o clara entre a implementa\u00e7\u00e3o do \nMC e a implementa\u00e7\u00e3o dos demais requisitos, suporte nativo aos construtos providos no modelo \nde conhecimento e alto grau de rastreabilidade entre o modelo e sua implementa\u00e7\u00e3o. Al\u00e9m \ndisso, prov\u00ea redu\u00e7\u00e3o de tarefas repetitivas de implementa\u00e7\u00e3o e redu\u00e7\u00e3o da dispers\u00e3o de c\u00f3digo a \npartir da gera\u00e7\u00e3o autom\u00e1tica de c\u00f3digo. As bibliotecas de aspectos garantem o encapsulamento \nde infer\u00eancias e tarefas. As bibliotecas tratam os construtos do modelo para garantir a \nreutiliza\u00e7\u00e3o em diferentes projetos de SCs. \n\n \n\nPalavras-Chave: engenharia de software, engenharia de conhecimento, orienta\u00e7\u00e3o a aspectos, \nanota\u00e7\u00f5es de metadados, projeto de sistemas baseados em conhecimento \n\n\n\n \n\n \n\n10 \n\nK-Aspects: an approach for building knowledge systems using aspects \n\nABSTRACT \n\nThis work defines K-Aspects (Knowledge Aspects), an approach for implementing \nKnowledge Systems (KS) with object-oriented languages using the aspect-oriented paradigm \n(AO) and metadata annotations. This approach defines a strong link between the knowledge \nmodel (KM) and its implementation in the object-oriented paradigm (OO). K-Aspects provides \na set of documentational annotations to make the association between the implementation model \nand the knowledge conceptual model easier to read; a set of annotations to enable the separation \nof concerns, using aspect orientation, of the implementation of the different requirements of the \nknowledge system; a set of libraries to perform the interpretation and execution as aspects of \nannotations; and a tool for documentation generation of the KM extracted from the annotations \non the code. The approach aims to support both knowledge engineers and development \nengineers in KS projects, by providing to  the knowledge engineers a well-defined way to \nelaborate the KS specification, which results in a specification presented in an object oriented \nlanguage, making it easily understandable  and extensible by development engineers that can \nthus implement the knowledge system preserving its conceptual knowledge structure and \nkeeping a clear distinction of the requirements associated to the KM from the other \nrequirements. \n\nK-Annotations add aspect oriented resources to the OO conceptual knowledge model, \nproviding features to manage separately the multiple crosscutting concerns of a KS, partitioning \nthe system in aspects that implement specific features, activated by annotations inserted in the \nknowledge conceptual model. Annotations distinguish, clearly and visually, within the code, \nKM elements from the rest of the code, making easier the code reading by the knowledge \nengineers. The most important function of the annotations is to provide information necessary \nfor interpreting knowledge elements during runtime. Annotations identify several crosscutting \nconcerns related to the model constructs. Annotations are managed and executed by the aspect \nlibraries.  \n\nThis approach was validated by re-coding, using K-Annotations, a complex commercial KS \non the domain of oil reservoir quality analysis. The model of this system represents a domain \nontology on which problem-resolving methods for rock interpretation and classification are \nperformed. The analysis of the results identified several advantages of using K-Aspects as: a \nclear distinction of the KM implementation among other requirements; native support for \nknowledge model constructs; and high traceability between the knowledge conceptual model \nand its implementation. Moreover, the use of K-Aspects reduces repetitive implementation tasks \nand code dispersion because of the automatic code generation. The provided aspect libraries \nenable the encapsulation of inferences and the execution of several tasks. The libraries manage \nthe constructs of the model thus providing reusability among multiple KS projects. \n\n \n\n \n\nKeywords: software engineering, knowledge engineering, aspect oriented paradigm, metadata \nannotations, project of knowledge systems. \n\n\n\n \n\n \n\n11 \n\n1 INTRODU\u00c7\u00c3O \n\nA evolu\u00e7\u00e3o do desenvolvimento de sistemas de conhecimento (SC) pode ser \ndividida em diferentes etapas. As primeiras gera\u00e7\u00f5es desses sistemas foram \nimplementadas atrav\u00e9s de processos ad-hoc de desenvolvimento, sem utiliza\u00e7\u00e3o de uma \nmetodologia que definisse um processo de engenharia, controlado e repet\u00edvel. A falta de \numa metodologia de desenvolvimento contribui para altos custos de constru\u00e7\u00e3o de \nsistemas e a baixa qualidade nos projetos. As primeiras gera\u00e7\u00f5es de SC produzidas no \nambiente acad\u00eamico alcan\u00e7aram bons resultados cient\u00edficos; entretanto, quando eram \naplicadas no ambiente comercial, falhavam, pois n\u00e3o conseguiam atender as \ncaracter\u00edsticas essenciais aos sistemas comerciais, dentre as quais destacam-se \nconfiabilidade, manutenabilidade e adaptabilidade \u00e0 evolu\u00e7\u00e3o do conhecimento e \ncapacidade de tratar de um grande volume de informa\u00e7\u00e3o (STUDER, BENJAMINS e \nFENSEL, 1998). \n\nA dificuldade em transferir a tecnologia de SC do meio acad\u00eamico para o meio \ncomercial pode ser comparada \u00e0 crise do final dos anos sessenta relativa ao \ndesenvolvimento de sistemas de software tradicionais. Naquela \u00e9poca, o modo de \ndesenvolvimento de pequenos prot\u00f3tipos n\u00e3o era suficiente para atender as necessidades \nde projeto e a manutenabilidade de sistemas comerciais. Desse modo, houve o \ndesenvolvimento da Engenharia de Software para tratar essa defici\u00eancia. O mesmo pode \nser identificado na \u00e1rea de Engenharia de Conhecimento: essa \u00e1rea se desenvolveu \nvoltada para o estabelecimento de uma disciplina de engenharia no desenvolvimento de \nSC (STUDER, BENJAMINS e FENSEL, 1998). A Engenharia de Conhecimento tem \ncomo foco a aquisi\u00e7\u00e3o do conhecimento que d\u00e1 suporte a solu\u00e7\u00e3o de problemas pelo \nsistema e sua representa\u00e7\u00e3o em modelos process\u00e1veis por computador. J\u00e1 a Engenharia \nde Software lida com todos os aspectos ligados ao tratamento desses modelos para que \no processo de implementa\u00e7\u00e3o seja vi\u00e1vel e o resultado final seja um software que \nimplemente completamente esses modelos e os algoritmos de racioc\u00ednio, atendendo aos \nrequisitos da aplica\u00e7\u00e3o e dos ambientes para os quais foram concebidos.  \n\nO estabelecimento da Engenharia de Conhecimento, posterior ao da Engenharia de \nSoftware est\u00e1 relacionado a caracter\u00edsticas espec\u00edficas desses sistemas que devem ser \ntratadas no seu desenvolvimento. SC distinguem-se de sistemas de informa\u00e7\u00e3o \ntradicionais devido \u00e0s seguintes caracter\u00edsticas: \n\n\u2022 Representam o conhecimento de especialistas em algum dom\u00ednio espec\u00edfico de \nconhecimento (BROMBY, MACMILLAN e MCKELLAR, 2003); \n\n\u2022 Prov\u00eaem meios para o compartilhamento de informa\u00e7\u00f5es valiosas que \nfrequentemente est\u00e3o centralizadas por um especialista (SCHREIBER et al., \n2000); \n\n\u2022 Resolvem problemas que n\u00e3o s\u00e3o trat\u00e1veis atrav\u00e9s de solu\u00e7\u00f5es algor\u00edtmicas que \nnecessitem de uma sequ\u00eancia finita e n\u00e3o amb\u00edgua de instru\u00e7\u00f5es. SCs prop\u00f5em \nsolu\u00e7\u00f5es em que algoritmos tradicionais n\u00e3o s\u00e3o capazes de resolver o problema \nde forma eficiente em termos de utiliza\u00e7\u00e3o dos recursos de m\u00e1quina, ou cuja \nsolu\u00e7\u00e3o torna-se excessivamente complexa quando comparada \u00e0 utiliza\u00e7\u00e3o de \nm\u00e9todos de busca simb\u00f3lica associados a heur\u00edsticas sobre o problema \n(BRACHMAN e LEVESQUE, 2004); \n\n\n\n \n\n \n\n12 \n\n\u2022 S\u00e3o capazes de gerenciar o conhecimento e realizar infer\u00eancias sobre os \nmesmos. A sequ\u00eancia de passos de racioc\u00ednio desenvolvida no processo de \nsolu\u00e7\u00e3o de problemas deve ser verific\u00e1vel pelo usu\u00e1rio (SCHREIBER et al., \n2000); \n\n\u2022 Suportam a expans\u00e3o e atualiza\u00e7\u00e3o do conhecimento tratado pelo pr\u00f3prio \nsistema (SCHREIBER et al., 2000); \n\n\u2022 Os requisitos do sistema mudam frequentemente devido \u00e0 complexidade, \nimprecis\u00e3o e constante evolu\u00e7\u00e3o do conhecimento (CASTRO, VICTORETI, \nFIORINI, ABEL e PRICE, 2008). \n\nA principal fraqueza de metodologias puramente oriundas da Engenharia de \nConhecimento, segundo Knublauch (2002), \u00e9 a tentativa de tratar isoladamente a \nmodelagem de conhecimento do restante da aplica\u00e7\u00e3o. Esse isolamento torna bastante \ndif\u00edcil a transi\u00e7\u00e3o de representa\u00e7\u00f5es de conhecimento baseadas em modelos conceituais \npara m\u00f3dulos execut\u00e1veis. SCs se caracterizam por uma cont\u00ednua evolu\u00e7\u00e3o da base de \nconhecimento, refletindo o estado da \u00e1rea ao qual se aplica, portanto a arquitetura do \nsistema e a documenta\u00e7\u00e3o dos modelos de conhecimento e dados devem ser concebidas \nde forma a absorver e facilitar a modifica\u00e7\u00e3o frequente dos sistemas sem rupturas em \nsua utiliza\u00e7\u00e3o.  Mais modernamente, cresce a necessidade de integra\u00e7\u00e3o dos SCs com os \ndemais sistemas de informa\u00e7\u00e3o corporativos das organiza\u00e7\u00f5es e a demanda por uma \nmaior capacidade de processamento de informa\u00e7\u00f5es por esses sistemas, que n\u00e3o se \nconstitu\u00edam em requisitos importantes nos primeiros sistemas de conhecimento \ncomerciais.  \n\nEssas dificuldades s\u00e3o ampliadas pelo fato de que projetos de SC possu\u00edrem mais \nagentes envolvidos no desenvolvimento dos sistemas. Alem dos problemas de \ncomunica\u00e7\u00e3o e documenta\u00e7\u00e3o entre engenheiros de desenvolvimento, existem tamb\u00e9m \nos problemas de comunica\u00e7\u00e3o destes com o engenheiro de conhecimento, respons\u00e1vel \npela defini\u00e7\u00e3o dos modelos e formaliza\u00e7\u00e3o da evolu\u00e7\u00e3o dos requisitos. As linguagens de \nmodelagem utilizadas nessas metodologias s\u00e3o de amplo conhecimento dos engenheiros \nde conhecimento, mas n\u00e3o s\u00e3o amplamente utilizadas pelos engenheiros de \ndesenvolvimento, pois muitas n\u00e3o oferecem compiladores ou apenas oferecem \ncompiladores experimentais, invi\u00e1veis para uso em sistemas comerciais.  \n\nDevido \u00e0s caracter\u00edsticas definidas acima, principalmente devido \u00e0 dinamicidade dos \nrequisitos de um SC, conforme Knublauch (2002), toda metodologia de \ndesenvolvimento de SCs deve oferecer linguagens e ferramentas de modelagem de \nconhecimento que suportem eficientemente evolu\u00e7\u00e3o, retroalimenta\u00e7\u00e3o e comunica\u00e7\u00e3o. \nDurante a evolu\u00e7\u00e3o da Engenharia de Conhecimento, uma s\u00e9rie de metodologias para a \nconstru\u00e7\u00e3o de SCs foram propostas, entre elas:  \n\n\u2022 VITAL (MESEGUER e PREECE, 1995); \n\n\u2022 MIKE (ANGELE et al., 1998); \n\n\u2022 CommonKADS (Common Knowledge Acquisition and Design System) \n(SCHREIBER et al., 2000); \n\n\u2022 Prot\u00e9g\u00e9 (GENNARI et al., 2003); \n\n\u2022 XP.K (KNUBLAUCH, 2002);  \n\n\u2022 RapidOWL (AUER, 2006); \n\n\n\n \n\n \n\n13 \n\n\u2022 KM-IRIS (CHALMETA e GRANGEL, 2008);   \n\nCommonKADS, diferencia-se das demais por ser uma metodologia alinhada a \nmetodologias heavy-weight da Engenharia de Software como RUP, pois aborda todos os \naspectos de um projeto de SC: ger\u00eancia de projeto, workflow de desenvolvimento, \nintegra\u00e7\u00e3o, aquisi\u00e7\u00e3o de conhecimento e desenvolvimento de software. Prot\u00e9g\u00e9, apesar \nde n\u00e3o ser uma metodologia completa, destaca-se por ser um ambiente para o \ndesenvolvimento de SCs que oferece uma ferramenta com suporte a ontologias e frames \npara modelagem de conhecimento; essa ferramenta tem evolu\u00eddo continuamente e tem \nsido usada com sucesso em projetos de SC. A metodologia KM-IRIS \u00e9 voltada para SCs \nque envolvem toda a empresa alvo. Ela busca definir um conjunto de processos \nnecess\u00e1rios para a realiza\u00e7\u00e3o de todas as etapas de desenvolvimento de um sistema de \nconhecimento (CHALMETA e GRANGEL, 2008), mas n\u00e3o detalha os modelos \nenvolvidos, nem trata detalhadamente a complexidade para integrar todos os sistemas \nde informa\u00e7\u00e3o de uma empresa que servem de entrada para o sistema de conhecimento. \nMais recentemente, XP.K e RapidOWL buscaram adaptar os princ\u00edpios das \nmetodologias \u00e1geis ao desenvolvimento de SCs. XP.K destaca-se por ter organizado os \nprinc\u00edpios e valores de metodologias \u00e1geis aliados a orienta\u00e7\u00e3o a objetos para serem \naplicados no desenvolvimento de SCs. \n\n1.1 Motiva\u00e7\u00e3o \nAs metodologias citadas acima tem como enfoque a fase de modelagem do projeto, \n\nespecialmente, na elabora\u00e7\u00e3o do modelo de conhecimento. Segundo Schreiber et al. \n(2000), esse modelo \u00e9 composto por tr\u00eas componentes (o termo componente \u00e9 utilizado, \nno caso do modelo de conhecimento, para caracterizar os elementos que comp\u00f5e esse \nmodelo): \n\n\u2022 Componente Conceitual: descreve as informa\u00e7\u00f5es est\u00e1ticas/estruturas do \nconhecimento (conceitos, atributos, rela\u00e7\u00f5es, regras e axiomas) relacionadas ao \ndom\u00ednio da aplica\u00e7\u00e3o (por exemplo: doen\u00e7as cr\u00f4nicas, petrografia sedimentar); \n\n\u2022 Componente de Tarefa: descreve as estrat\u00e9gias usadas pelo sistema (no \ncomponente conceitual) para resolver problemas, orientado a sistema. A tarefa, \ndependente do dom\u00ednio da aplica\u00e7\u00e3o, define a rela\u00e7\u00e3o entre um m\u00e9todo gen\u00e9rico \nde solu\u00e7\u00e3o de problema (PSM) e os conceitos particulares do dom\u00ednio da \naplica\u00e7\u00e3o descrito no componente conceitual (ABEL, 2001);  \n\no Cada m\u00e9todo de solu\u00e7\u00e3o de problemas (PSM) \u00e9 um modelo abstrato de \ninfer\u00eancia reus\u00e1vel para um mesmo tipo de tarefa (ex.: interpreta\u00e7\u00e3o, \nclassifica\u00e7\u00e3o) em diferentes dom\u00ednios de aplica\u00e7\u00e3o (ex.: medicina, \nconserto de carro). Por exemplo, a tarefa de diagn\u00f3stico \u00e9 necess\u00e1ria para \nsolu\u00e7\u00e3o de problemas em diferentes dom\u00ednios (diagnosticar a doen\u00e7a de \num paciente, interpretar um problema de carro). Nesse caso, um PSM \nvoltado para essa tarefa deve ser reus\u00e1vel em ambos dom\u00ednios. A \nmetodologia CommonKADS (SCHREIBER et al., 2000) define uma \nbiblioteca extensa de estruturas de infer\u00eancia que correspondem a PSMs \nno \u00e2mbito da metodologia; \n\n\u2022 Componente Inferencial: define os passos b\u00e1sicos de racioc\u00ednio usados para \nrealizar tarefas usando os elementos do componente conceitual; \n\n\n\n \n\n \n\n14 \n\nEssas metodologias usam diferentes linguagens para modelagem de conhecimento \ncomo Frames (FIKES e KEHLER, 1985), OCML (TANASESCU, DOMINGUE e \nCABRAL, 2004), CML (SCHREIBER et al., 2000), RDF (BRICKLEY e GUHA, 2000) \ne OWL (ANTONIOU e HARMELEN, 2004). A maioria dessas linguagens define \nconstrutos que n\u00e3o s\u00e3o nativamente suportados na OO. Desse modo, modelos de \nconhecimento definidos nessas linguagens n\u00e3o podem ser facilmente convertidos para o \nparadigma da OO.  \n\nA aus\u00eancia de um solu\u00e7\u00e3o padr\u00e3o para a convers\u00e3o de modelos de conhecimento em \ncomponentes de software traz um problema relevante para a fase de desenvolvimento de \nprojetos de SC: muitos SC complexos s\u00e3o desenvolvidos usando linguagens OO, mas a \nimplementa\u00e7\u00e3o do modelo de conhecimento \u00e9 feita utilizando uma solu\u00e7\u00e3o ad-hoc que \nn\u00e3o permite a preserva\u00e7\u00e3o das estruturas definidas no modelo de conhecimento. Desse \nmodo, mesmo que o modelo de conhecimento possa ser modelado usando diferentes \nparadigmas, \u00e9 importante prover uma forma de representa\u00e7\u00e3o padr\u00e3o no paradigma OO, \npois muitos projetos usam Java e C# como linguagens para desenvolvimento de SCs. \n\nApesar de todas essas propostas de metodologias, nenhuma delas oferece uma \nabordagem composta por padr\u00f5es, ferramentas e bibliotecas de c\u00f3digo para o \nmapeamento do modelo de conhecimento para uma linguagem OO. Somente XP.K \nbusca definir uma abordagem padr\u00e3o para implementa\u00e7\u00e3o de SCs na OO, mas apresenta \numa s\u00e9rie de desvantagens que impedem sua utiliza\u00e7\u00e3o de fato. XP.K \u00e9 revisada no \ncap\u00edtulo 2. Atualmente, cada projeto de SC utiliza uma solu\u00e7\u00e3o ad-hoc para a \nimplementa\u00e7\u00e3o desse modelo. Por exemplo, uma solu\u00e7\u00e3o ad-hoc em uso pelo sistema \nPetroledge (ABEL, 2001), SC complexo para a avalia\u00e7\u00e3o da qualidade de reservat\u00f3rios \nde petr\u00f3leo, utiliza os seguintes mapeamentos para a implementa\u00e7\u00e3o do modelo de \nconhecimento usando o paradigma da OO: \n\n\u2022 Componente conceitual \u00e9 implementado pelo seguinte mapeamento (SILVA, \n2001):  \n\no Conceitos s\u00e3o mapeados para classes; \n\no Atributos dos conceitos s\u00e3o mapeados para propriedades de classes;  \n\no Facets axiomas e regras s\u00e3o mapeados para classes externas (seguindo a \ndesign pattern validator (FOWLER, 1997)) ou para m\u00e9todos das classes \nque implementam conceitos ou para m\u00e9todos presentes nas pr\u00f3prias \ninterfaces gr\u00e1ficas. Facets s\u00e3o usados para defini\u00e7\u00e3o de restri\u00e7\u00f5es, por \nexemplo, propriedade n\u00e3o pode ter valor null. Axiomas s\u00e3o usados para a \ndefini\u00e7\u00e3o de rela\u00e7\u00f5es matem\u00e1ticas que devem ser sempre verdadeiras, \npor exemplo a soma de duas propriedades deve ser sempre maior que \nzero. E regras s\u00e3o usadas para definir valida\u00e7\u00f5es e implica\u00e7\u00f5es entre \ndiferentes propriedades, por exemplo, se uma pessoa n\u00e3o tem esposa, ela \nn\u00e3o pode ser casada. O mapeamento dessas tr\u00eas estruturas para m\u00e9todos \nreduz a manutenabilidade do sistema, pois esse mapeamento torna dif\u00edcil \ndistingui-las na implementa\u00e7\u00e3o e tamb\u00e9m acaba ocasionando uma grande \ndispers\u00e3o de chamadas \u00e0 biblioteca de valida\u00e7\u00f5es da facets, axiomas e \nregras que fazem o tratamento das mesmas; \n\n\u2022 Componente de tarefa, apesar de ser modelado como um PSM, \u00e9 implementado \ncomo um algoritmo dependente do dom\u00ednio da aplica\u00e7\u00e3o e possui depend\u00eancia \nde banco de dados para funcionamento. O principal fator de depend\u00eancia do \n\n\n\n \n\n \n\n15 \n\ndom\u00ednio \u00e9 a falta de uma distin\u00e7\u00e3o clara dos construtos do modelo conceitual. A \ndepend\u00eancia em rela\u00e7\u00e3o ao dom\u00ednio da aplica\u00e7\u00e3o impede o reuso dos artefatos de \nsoftware em outros SCs. A depend\u00eancia em rela\u00e7\u00e3o ao banco de dados reduz o \nreuso quando a persist\u00eancia \u00e9 realizada em diferentes tipos de bancos de dados. \nPara cada tipo de SGBD (relacional, XML, OO), uma implementa\u00e7\u00e3o diferente \nprecisa ser realizada; \n\n\u2022 Componente inferencial \u00e9 implementado por fun\u00e7\u00f5es que s\u00e3o dependentes do \ndom\u00ednio da aplica\u00e7\u00e3o devido a falta de uma distin\u00e7\u00e3o clara dos elementos \noriginados do modelo conceitual em rela\u00e7\u00e3o aos demais elementos da aplica\u00e7\u00e3o. \nEntretanto, essas fun\u00e7\u00f5es deveriam ser independentes do dom\u00ednio para que \nsejam reusadas em diferentes projetos. \n\nEm consequ\u00eancia da falta de uma solu\u00e7\u00e3o previamente validada e uso de solu\u00e7\u00f5es \nad-hoc, que n\u00e3o apresentam valida\u00e7\u00f5es pr\u00e9vias em diferentes SCs, n\u00e3o apenas o projeto \ncitado acima, mas diversos projetos de SC enfrentam os seguintes problemas \n(CASTRO, ABEL e PRICE, 2009): \n\n\u2022 Na maioria dos casos, solu\u00e7\u00f5es ad-hoc geram componentes que n\u00e3o preservam \nas estruturas do modelo de conhecimento, por exemplo, conceito e rela\u00e7\u00f5es \ntornam-se classes; facets, axiomas e regras s\u00e3o todos transformados em m\u00e9todos. \nEssa falta de preserva\u00e7\u00e3o aumenta significativamente os custos de manuten\u00e7\u00e3o \ndos SCs, pois a rastreabilidade entre modelo e implementa\u00e7\u00e3o fica \ncomprometida; \n\n\u2022 A solu\u00e7\u00e3o pode atender a demanda atual do projeto, mas rapidamente deixar de \natender completamente os requisitos, lembrando que os requisitos de SC tendem \na evoluir rapidamente; \n\n\u2022 O custo de evolu\u00e7\u00e3o e manuten\u00e7\u00e3o de uma solu\u00e7\u00e3o ad-hoc pode tornar-se \nbastante elevado ao longo do projeto, pois cada modifica\u00e7\u00e3o pode afetar todos os \ncomponentes implementados. Isso muitas vezes ocorre devido ao alto volume de \nrela\u00e7\u00f5es que os elementos do modelo de conhecimento apresentam; \n\n\u2022 A solu\u00e7\u00e3o \u00e9 conhecida somente pelos envolvidos no projeto; entretanto, ao longo \ndo ciclo de vida de um projeto, a maioria dos participantes acaba migrando para \noutros projetos. Desse modo, o risco de problemas para manuten\u00e7\u00e3o do sistema \ntorna-se bastante elevado; \n\n\u2022 \u00c9 dif\u00edcil manter coerente a documenta\u00e7\u00e3o do modelo de conhecimento com sua \nimplementa\u00e7\u00e3o. \n\nOs problemas apontados acima motivaram a busca de uma abordagem que pudesse \nelimin\u00e1-los ou reduzi-los.  \n\n1.2 Objetivos \nA abordagem proposta nesse trabalho utiliza como base o paradigma orientado a \n\naspectos (OA) associado a anota\u00e7\u00f5es de metadados para organizar uma solu\u00e7\u00e3o que \nofere\u00e7a as ferramentas e bibliotecas necess\u00e1rias para a constru\u00e7\u00e3o de componentes de \nsoftware de SCs que mantenham as estruturas definidas no modelo de conhecimento. A \npreserva\u00e7\u00e3o das estruturas pode ser alcan\u00e7ada atrav\u00e9s do suporte aos construtos das \nlinguagens de modelagem nas linguagens OO utilizadas para implementa\u00e7\u00e3o de \ncomponentes de software que implementam o modelo. Ao suportar os construtos de \n\n\n\n \n\n \n\n16 \n\nmodelagem diretamente nos componentes de software, pode-se distinguir claramente \ncada elemento do modelo de conhecimento garantindo a rastreabilidade entre modelo e \ncomponente de software. A rastreabilidade entre modelo e componentes reduz os custos \nde manuten\u00e7\u00e3o de SCs, pois a consist\u00eancia entre modelo e implementa\u00e7\u00e3o pode ser mais \nfacilmente mantida.  \n\nConforme Kiczales et al. (1997), um aspecto \u00e9 \u201cuma entidade de software que \ncaptura uma funcionalidade transversal \u00e0 uma aplica\u00e7\u00e3o\u201d. Aspectos permitem o \ntratamento isolado de diferentes funcionalidades do sistema, por exemplo, \u00e9 poss\u00edvel \nisolar o tratamento de auditoria de todos os outros m\u00f3dulos do sistema, sendo que esses \nm\u00f3dulos atrav\u00e9s de aspectos ser\u00e3o auditados. Em suma, um aspecto permite o \ntratamento de funcionalidades sem que o c\u00f3digo para isso tenha que ser explicitamente \nadicionado a todos os m\u00f3dulos que fazem uso delas. Aspectos t\u00eam sido aplicados com \nsucesso em diferentes \u00e1reas como sistemas operacionais (CUNHA, SOBRAL e \nMONTEIRO, 2006), seguran\u00e7a (ZHU e ZULKERNINE, 2009) e sistemas distribu\u00eddos \n(KOURAI, HIBINO e CHIVA, 2007). \n\nAnota\u00e7\u00f5es s\u00e3o elementos tipados (type-safe) que permitem a adi\u00e7\u00e3o de metadados a \nclasses, m\u00e9todos, vari\u00e1veis, par\u00e2metros e pacotes (ANNOTATIONS, 2004). Anota\u00e7\u00f5es \ntem sido utilizadas em diversas \u00e1reas como bancos de dados (JSR 220B, 2005), sistemas \noperacionais (CUNHA, SOBRAL e MONTEIRO, 2006) e sistemas distribu\u00eddos (JSR \n220A, 2005) para fins documentacionais e de marca\u00e7\u00e3o para gera\u00e7\u00e3o autom\u00e1tica de \nc\u00f3digo ou tratamento por aspectos. Por exemplo, uma anota\u00e7\u00e3o associada a uma \nvari\u00e1vel pode indicar que a vari\u00e1vel representa um campo a ser armazenado em um \nbanco de dados. \n\nAnota\u00e7\u00f5es podem marcar pontos no c\u00f3digo e fornecer dados necess\u00e1rios para a \nimplementa\u00e7\u00e3o por aspectos de certas funcionalidades, por exemplo, auditoria. As \nse\u00e7\u00f5es 2.1 e 2.3 revisam esses dois assuntos para melhor compreens\u00e3o do trabalho. \n\nEm K-Aspects, anota\u00e7\u00f5es (K-Anntations) s\u00e3o utilizadas para identificar claramente \nos construtos do modelo conceitual do conhecimento utilizados na modelagem de um \nSC (ex.: conceito, atributo, rela\u00e7\u00e3o, facet, axioma e etc) no c\u00f3digo-fonte do sistema, \nfacilitando a identifica\u00e7\u00e3o da implementa\u00e7\u00e3o desses construtos e tamb\u00e9m a revis\u00e3o dos \nmesmos. O K nos termos K-Aspects e K-Annotations refere-se a Knowledge \n(conhecimento em Ingl\u00eas), pois est\u00e3o relacionados ao tratamento dos elementos do \nmodelo de conhecimento. Esses termos foram criados nesse trabalho.  \n\nO uso de anota\u00e7\u00f5es permite que a documenta\u00e7\u00e3o do modelo seja obtida diretamente \ndo c\u00f3digo-fonte e aumenta a rastreabilidade entre modelo e os componentes de software \ngerados. O mapeamento direto entre construtos do modelo e anota\u00e7\u00f5es tamb\u00e9m \nfavorece o desenvolvimento orientado a modelos, j\u00e1 que ferramentas de gera\u00e7\u00e3o de \nc\u00f3digo podem ler os modelos e gerar as respectivas anota\u00e7\u00f5es. \n\nAnota\u00e7\u00f5es servem para marcar classes e seus membros (ex.: m\u00e9todos, propriedades) \npara que os aspectos possam implementar a sem\u00e2ntica de cada anota\u00e7\u00e3o atrav\u00e9s de \ninterpreta\u00e7\u00e3o. Por exemplo, uma classe pode ser anotada com @Concept para \nidentific\u00e1-la como um conceito, uma propriedade chamada idade pode ser anotada com \n@Attribute para que seja reconhecida como um atributo. Essa propriedade ainda pode \nser anotada com @FacetMinValue(value=0) para indicar que seu limite inferior \u00e9 0. \nEssas anota\u00e7\u00f5es identificam aos aspectos os pontos em que a sem\u00e2ntica de cada \nanota\u00e7\u00e3o deve ser tratada e tamb\u00e9m fornecem dados necess\u00e1rios para esse tratamento \n(ex.: o valor m\u00ednimo para uma propriedade). O uso de anota\u00e7\u00f5es e aspectos, em \n\n\n\n \n\n \n\n17 \n\nsubstitui\u00e7\u00e3o a chamadas expl\u00edcitas a fun\u00e7\u00f5es definidas em uma biblioteca de \ncomponentes, automatiza o tratamento da sem\u00e2ntica dos construtos, evitando que o \nengenheiro de desenvolvimento tenha que manualmente invocar em todos os pontos de \ntratamento desses construtos a biblioteca. A automatiza\u00e7\u00e3o reduz o risco de bugs \nrelacionados a omiss\u00e3o de chamadas \u00e0 biblioteca em pontos necess\u00e1rios e reduz os \ncustos de manuten\u00e7\u00e3o, pois caso um problema esteja relacionado \u00e0 invoca\u00e7\u00e3o da \nbiblioteca, n\u00e3o ser\u00e1 necess\u00e1rio alterar todos os pontos de chamada, apenas o aspecto que \nrealiza a chamada precisa ser corrigido.  \n\nO uso de anota\u00e7\u00f5es visa preservar as estruturas definidas no modelo de \nconhecimento, especificamente os construtos, evitando o uso de conven\u00e7\u00f5es de c\u00f3digo \npara esse fim. Conven\u00e7\u00f5es de c\u00f3digo devem ser evitadas, pois, enquanto anota\u00e7\u00f5es s\u00e3o \nvalidadas pelos interpretadores de linguagens, conven\u00e7\u00f5es n\u00e3o o s\u00e3o, podendo ser \nfacilmente desrespeitadas. Al\u00e9m disso, conven\u00e7\u00f5es de c\u00f3digo n\u00e3o s\u00e3o tipadas, \nsuportando apenas strings, o que aumenta significativamente a inser\u00e7\u00e3o de erros \nrelacioados a tipos. \n\nO tratamento por aspectos da sem\u00e2ntica associada a cada construto do modelo de \nconhecimento evita a dispers\u00e3o de uma s\u00e9rie de m\u00e9todos e propriedades auxiliares \nnecess\u00e1rios para o tratamento da sem\u00e2ntica. Por exemplo, para determinar que uma \npropriedade n\u00e3o pode ter valor null, basta utilizar uma anota\u00e7\u00e3o que representa a facet \ncom essa fun\u00e7\u00e3o n\u00e3o \u00e9 necess\u00e1rio para cada ponto da aplica\u00e7\u00e3o em que a atribui\u00e7\u00e3o de \nvalor a essa propriedade, basta utilizar uma anota\u00e7\u00e3o. A pr\u00f3pria ferramenta para \ntratamento de aspectos passa a ser respons\u00e1vel por interpretar a anota\u00e7\u00e3o e gerar \nautomaticamente o c\u00f3digo necess\u00e1rio para prover a sem\u00e2ntica de cada anota\u00e7\u00e3o. O \nc\u00f3digo gerado realiza a invoca\u00e7\u00e3o de componentes organizados em uma biblioteca para \ntratamento das mesmas. A biblioteca para tratamento das anota\u00e7\u00f5es \u00e9 componente desse \ntrabalho e visa prover um conjunto de funcionalidades b\u00e1sicas necess\u00e1rias a diferentes \nprojetos de SC.  \n\n1.3 Organiza\u00e7\u00e3o dos Cap\u00edtulos \nO cap\u00edtulo 2 revisa conceitos e trabalhos relacionados \u00e0 abordagem definida nesse \n\nprojeto. Os conceitos de orienta\u00e7\u00e3o a aspectos (OA) e anota\u00e7\u00f5es de metadados, assim \ncomo suas aplica\u00e7\u00f5es, s\u00e3o apresentados para permitir uma melhor compreens\u00e3o das \npropostas definidas nos cap\u00edtulos 3 e 4. Esse cap\u00edtulo tamb\u00e9m analisa e avalia XP.K, \nque define uma alternativa para implementa\u00e7\u00e3o de SCs em OO. Parte das propostas \norganizadas em XP.K s\u00e3o extendidas e melhoradas para elimina\u00e7\u00e3o de uma s\u00e9rie de \ndesvantagens identificadas associadas \u00e0 proposta citada.  \n\nO cap\u00edtulo 3 apresenta a proposta de utiliza\u00e7\u00e3o de aspectos para a implementa\u00e7\u00e3o do \ncomponente conceitual de modelo de conhecimento. Essa proposta busca apresentar \numa solu\u00e7\u00e3o padr\u00e3o para a implementa\u00e7\u00e3o desse modelo, evitando os problemas de \nsolu\u00e7\u00f5es ad-hoc e da solu\u00e7\u00e3o proposta em XP.K. \n\nO cap\u00edtulo 4 define a proposta de utiliza\u00e7\u00e3o de aspectos para a implementa\u00e7\u00e3o dos \noutros dois componentes do modelo de conhecimento: componentes de tarefa e \ninferencial. Essa proposta busca apresentar uma solu\u00e7\u00e3o padr\u00e3o para a implementa\u00e7\u00e3o \ndesse modelo, evitando os problemas de solu\u00e7\u00f5es ad-hoc caracterizados na introdu\u00e7\u00e3o. \n\nO cap\u00edtulo 5 apresenta o sistema utilizado para valida\u00e7\u00e3o da proposta K-Aspects. Na \nprimeira parte, \u00e9 apresentada a implementa\u00e7\u00e3o atual do sistema, sem utiliza\u00e7\u00e3o de K-\n\n\n\n \n\n \n\n18 \n\nAspects. A segunda parte apresenta o resultado da implementa\u00e7\u00e3o utilizando K-Aspects \ne descreve vantagens e limita\u00e7\u00f5es dessa abordagem. \n\nO cap\u00edtulo 6 apresenta as conclus\u00f5es do trabalho, destacando os resultados \nalcan\u00e7ados com esse trabalho e propondo poss\u00edveis trabalhos futuros. \n\n  \n\n \n\n\n\n \n\n \n\n19 \n\n2 CONCEITOS E TRABALHOS RELACIONADOS \n\nEntre as metodologias citadas na introdu\u00e7\u00e3o, XP.K destaca-se para o \ndesenvolvimento de SCs por apresentar a OO como ponto de partida e propor uma \nabordagem padr\u00e3o para a implementa\u00e7\u00e3o de SCs. XP.K prop\u00f5e uma abordagem \nchamada de KBeans para a implementa\u00e7\u00e3o do componente conceitual, mas n\u00e3o detalha \no desenvolvimento dos componentes de tarefa e inferencial. Apenas oferece uma \nferramenta para aquisi\u00e7\u00e3o de conhecimento. A se\u00e7\u00e3o 2.4, utilizando como refer\u00eancia \nprincipal Knublauch (2002), faz uma breve introdu\u00e7\u00e3o dessa metodologia e identifica os \nprincipais problemas dessa proposta. \n\n2.1 Orienta\u00e7\u00e3o a Aspectos \nA orienta\u00e7\u00e3o a aspectos (OA) foi desenvolvida pela Xerox e \u00e9 considerada uma \n\ncomplementa\u00e7\u00e3o da programa\u00e7\u00e3o orientada a objetos (KICZALES et al., 1997). Esse \nnovo paradigma define uma abordagem para o tratamento de funcionalidades \ntransversais \u00e0s funcionalidades essenciais de um software. Exemplos de funcionalidades \ntransversais frequentemente encontradas em aplica\u00e7\u00f5es (CACHO et al., 2006) s\u00e3o \nseguran\u00e7a, persist\u00eancia, inje\u00e7\u00e3o de recursos, tratamento de exce\u00e7\u00f5es, concorr\u00eancia, \nsincroniza\u00e7\u00e3o e auditoria. Por exemplo, em uma aplica\u00e7\u00e3o banc\u00e1ria, uma funcionalidade \nessencial seria a realiza\u00e7\u00e3o de uma transfer\u00eancia de dinheiro entre duas contas. Quando \nessa funcionalidade \u00e9 implementada, funcionalidades transversais, como log da \nopera\u00e7\u00e3o e valida\u00e7\u00f5es de seguran\u00e7a tamb\u00e9m precisam ser tratadas. Essas \nfuncionalidades transversais existem em diversos m\u00f3dulos da aplica\u00e7\u00e3o e desse modo, \nn\u00e3o podem ser encapsuladas em m\u00f3dulos unit\u00e1rios como proposto na OO. Utilizando \nsomente a OO, essas funcionalidades acabam dispersas ao longo do c\u00f3digo, dificultando \na manuten\u00e7\u00e3o do sistema e aumentando o custo de manuten\u00e7\u00e3o.  \n\nA Figura 2.1 exemplifica a dispers\u00e3o ocasionada pela implementa\u00e7\u00e3o da \nfuncionalidade de log (transversal ao objetivo de cada componente) em tr\u00eas \ncomponentes, as retic\u00eancias correspondem a funcionalidade do m\u00f3dulo, j\u00e1 a chamada ao \nLog identifica a dispers\u00e3o de c\u00f3digo referente \u00e0 auditoria. A dispers\u00e3o de c\u00f3digo ocorre \nporque \u00e9 necess\u00e1rio manter um registro de m\u00e9todos invocados, nesse caso, o engenheiro \nde desenvolvimento para cada registro de opera\u00e7\u00e3o precisa acrescentar um trecho de \nc\u00f3digo para registrar a opera\u00e7\u00e3o. Na plataforma Java, existem diversos pacotes que \npodem oferecer esse recurso, entretanto, ao ser utilizado um determinado pacote, a \nchamada aos m\u00e9todos que permitem a realiza\u00e7\u00e3o do log fica dispersa ao longo de todo o \nc\u00f3digo da aplica\u00e7\u00e3o. Essa dispers\u00e3o aumenta o custo de manuten\u00e7\u00e3o do c\u00f3digo, pois, \ncaso fosse necess\u00e1rio mudar de pacote para o suporte de log, seria necess\u00e1rio modificar \na chamada aos m\u00e9todos de log existentes em diversas classes de diversos m\u00f3dulos da \naplica\u00e7\u00e3o. Al\u00e9m disso, o engenheiro de desenvolvimento poderia facilmente esquecer \n\n\n\n \n\n \n\n20 \n\nde fazer a chamada para o log em um determinado m\u00e9todo, n\u00e3o atendendo a um \nrequisito transversal do sistema. Tamb\u00e9m \u00e9 dif\u00edcil verificar se os logs est\u00e3o sendo feitos \nnas diversas situa\u00e7\u00f5es que o exigem. \n\n \n\nFigura 2.2: Exemplo de Dispers\u00e3o devido a Funcionalidades Transversais. \n\nPara tratar adequadamente essas funcionalidades transversais, permitindo encapsul\u00e1-\nlas adequadamente, a OA introduz o conceito chamado de aspecto. Conforme Kiczales \net al. (1997), um aspecto \u00e9 \u201cuma entidade de software que captura uma funcionalidade \ntransversal a uma aplica\u00e7\u00e3o\u201d. Esse conceito permite a especifica\u00e7\u00e3o de uma entidade \nque fornece uma funcionalidade utilizada ao longo de toda a aplica\u00e7\u00e3o, evitando que, ao \nser necess\u00e1rio uma modifica\u00e7\u00e3o nessa funcionalidade, toda a aplica\u00e7\u00e3o deva ser \nmodificada. Um aspecto \u00e9 complementado por tr\u00eas outros conceitos b\u00e1sicos de OA \n(KICZALES et al., 1997):  \n\n\u2022 Pointcut: identifica os pontos da aplica\u00e7\u00e3o em que uma funcionalidade \ntransversal deve ser implementada. Por exemplo, na Figura 2.2, a defini\u00e7\u00e3o do \npointcut call(...) define que qualquer invoca\u00e7\u00e3o de m\u00e9todo deve ser registrada \nem um log; \n\n\u2022 Advice: c\u00f3digo adicional necess\u00e1rio para a realiza\u00e7\u00e3o de uma funcionalidade \ntransversal. Por exemplo, na Figura 2.2, o termo before identifica que o log deve \nser realizado antes da efetiva invoca\u00e7\u00e3o do m\u00e9todo, o advice realiza o log atrav\u00e9s \nda chamada Log.grava(mensagem); \n\n\u2022 Ponto de jun\u00e7\u00e3o: ponto na execu\u00e7\u00e3o de um programa no qual, em torno dele, um \nou mais aspectos podem ser adicionados (KICZALES et al., 1997). Os principais \npontos de jun\u00e7\u00e3o suportados pela OA em uma aplica\u00e7\u00e3o s\u00e3o chamados de \nconstrutores, conclus\u00e3o de execu\u00e7\u00e3o de construtores, chamadas de m\u00e9todos, \nconclus\u00e3o de chamadas de m\u00e9todos, atribui\u00e7\u00e3o de valor a uma propriedade, pr\u00e9-\ninicializa\u00e7\u00e3o de classe, inicializa\u00e7\u00e3o de classe, tratamento de execu\u00e7\u00e3o e, \ntamb\u00e9m, execu\u00e7\u00e3o de um advice. \n\n \n\nFigura 2.3: Exemplo de Aspecto para Log de Invoca\u00e7\u00e3o de M\u00e9todo. \n\nO uso de aspectos faz uso do processo chamado de costura (weaving). Esse \nprocesso, realizado pelo costurador (weaver), conecta os m\u00f3dulos da aplica\u00e7\u00e3o com os \naspectos para que as funcionalidades transversais sejam disponibilizadas nos pontos da \naplica\u00e7\u00e3o especificados nos pointcuts. Esse processo pode ocorrer em tempo de \ncompila\u00e7\u00e3o ou em tempo de execu\u00e7\u00e3o, conforme a implementa\u00e7\u00e3o do costurador.     \n\nApesar das vantagens de utiliza\u00e7\u00e3o de aspectos, deve-se destacar alguns pontos de \nlimita\u00e7\u00e3o em rela\u00e7\u00e3o ao uso da OO: \n\nString transforma{ \n.... \n Log.grava(\u201ctransforma\u201d); \n.... \n\n} \n\nvoid adiciona{ \n    .... \n    Log.grava(\u201cadiciona\u201d); \n    .... \n} \n\nvoid envia{ \n    .... \n    Log.grava(\u201cenvia\u201d); \n    .... \n} \n\npointcut invocacaoMetodo() : call(*.*(..)); \n\nbefore() : invocacaoMetodo() {      \n      Log.grava(\u2018mensagem\u2019); \n} \n\n\n\n \n\n \n\n21 \n\n\u2022 Depura\u00e7\u00e3o de Programas: a depura\u00e7\u00e3o de programas que fazem uso desse \nparadigma \u00e9 mais complexa que a de programas puramente OO. Isso ocorre \nporque o tratamento dos aspectos envolve a gera\u00e7\u00e3o de c\u00f3digo adicional, n\u00e3o \nconhecido pelo engenheiro de desenvolvimento e realizado pelo costurador. \nCaso o c\u00f3digo gerado apresente algum problema ou provoque alguma \nmodifica\u00e7\u00e3o n\u00e3o prevista pelo engenheiro de desenvolvimento, a depura\u00e7\u00e3o do \nprograma n\u00e3o ir\u00e1 apresentar o c\u00f3digo fonte desse c\u00f3digo, j\u00e1 que ele foi gerado \npelo costurador; \n\n\u2022 Ambiguidade de Aplica\u00e7\u00e3o: na proposta inicial de OA (KICZALES et al., \n2001), os pointcuts s\u00e3o especificados atrav\u00e9s da defini\u00e7\u00e3o de uma consulta \nsobre a aplica\u00e7\u00e3o. Por exemplo, \u201cpointcut log() : execution(* *.set*(..) )\u201d \nidentifica que o advice \u201clog\u201d deve ser invocado em todos m\u00e9todos que iniciem \ncom set. Contudo, essas declara\u00e7\u00f5es podem gerar ambiguidades, por exemplo, \num programador pode definir um m\u00e9todo iniciado com set, mas que n\u00e3o \ndeveria ser aplicado o log. Para evitar esse problema e permitir que os \nengenheiros de desenvolvimento definam explicitamente onde os aspectos \ndevem ser aplicados, OA pode fazer o uso do conceito de anota\u00e7\u00f5es de \nmetadados dispon\u00edvel nas principais linguagens OO (Java utiliza o nome \nanota\u00e7\u00f5es, C# utiliza o nome atributo). Al\u00e9m disso, as anota\u00e7\u00f5es s\u00e3o \nnecess\u00e1rias para fornecer dados essenciais para a realiza\u00e7\u00e3o de um aspecto, por \nexemplo, para a persist\u00eancia de uma determinada classe, a anota\u00e7\u00e3o pode \nfornecer o nome da tabela em que essa classe deve ser salva. A pr\u00f3xima se\u00e7\u00e3o \ndetalha a contribui\u00e7\u00e3o de anota\u00e7\u00f5es para o uso da OA;  \n\nO suporte a OA em linguagens OO como Java e C# \u00e9 disponibilizado atrav\u00e9s de \nextens\u00f5es da linguagem providas por bibliotecas de c\u00f3digo. Entre as extens\u00f5es para \nJava destaca-se AspectJ (KICZALES et al., 2001), pois ela oferece um conjunto de \nferramentas que auxiliam o uso de aspectos nessa linguagem. A valida\u00e7\u00e3o desse \ntrabalho \u00e9 realizada usando AspectJ, pois o SC apresentado \u00e9 desenvolvido em Java. \nExtens\u00f5es semelhantes est\u00e3o dispon\u00edveis para C#. \n\n2.2 Orienta\u00e7\u00e3o a Aspectos e Sistemas de Conhecimento \nO uso de aspectos para a implementa\u00e7\u00e3o de regras de neg\u00f3cios (CIBR\u00c1N, \n\nD'HONDT e JONCKERS, 2003) e (CIBR\u00c1N, D'HONDT e SUV\u00c9E, 2005) busca isolar \na implementa\u00e7\u00e3o das regras de neg\u00f3cios do restante da aplica\u00e7\u00e3o. Objetivo \u00e9 permitir \nfacilitar a manuten\u00e7\u00e3o e rastreamento dessas regras, frequentemente complexas. O \nisolamento tamb\u00e9m \u00e9 realizado para permitir que as regras possam ser adequadamente \nexternalizadas em caso de necessidade. O isolamento das regras de neg\u00f3cios dos demais \nrequisitos pode ser visto como an\u00e1logo a necessidade de isolar, em SCs, a \nimplementa\u00e7\u00e3o do modelo de conhecimento em rela\u00e7\u00e3o a implementa\u00e7\u00e3o dos demais \nrequisitos, para melhor manuten\u00e7\u00e3o e rastreabilidade. \n\nEm D\u2019Hondt, Meuter e Wuyts (1999), a utiliza\u00e7\u00e3o de aspectos para defini\u00e7\u00e3o de \nconhecimento de dom\u00ednio \u00e9 proposta atrav\u00e9s do paradigma l\u00f3gico. Entretanto, apenas \nexperimentos bastante reduzidos foram realizados utilizando aspectos e l\u00f3gica e a \ndist\u00e2ncia entre o paradigma l\u00f3gico e orientado a objetos dificulta a utiliza\u00e7\u00e3o dessa \nproposta, j\u00e1 que exigiria o mapeamento entre os diferentes paradigmas. \n\nEm Filman (2000) \u00e9 apresentada uma proposta para organizar os sistemas em \ncomponentes integrados via aspectos, para melhor isolamento entre cada componente e \n\n\n\n \n\n \n\n22 \n\nsuas funcionalidades. O objetivo do isolamento \u00e9 melhorar o processo de s\u00edntese de \nnovos sistemas, a partir da combina\u00e7\u00e3o de uma s\u00e9rie de componentes. \n\nAspectos tamb\u00e9m t\u00eam sido utilizados para estender ferramentas para modelagem de \nconhecimento. Em Eriksson (2004), \u00e9 proposta uma abordagem para extens\u00e3o da \nferramenta Prot\u00e9g\u00e9 usando aspectos. Inicialmente essa ferramenta \u00e9 estendida usando \nOO, entretanto, quando uma nova vers\u00e3o \u00e9 lan\u00e7ada, novamente a extens\u00e3o deve ser \nconectada ao c\u00f3digo-fonte original da ferramenta, tornando o processo lento e \nrepetitivo. Usando aspectos, esse processo pode ser automatizado, j\u00e1 que a costura entre \na extens\u00e3o e a nova vers\u00e3o passa a ser realizada diretamente por ferramentas da OA.  \n\n2.3 Anota\u00e7\u00f5es de Metadados \n \n\nAnota\u00e7\u00f5es s\u00e3o elementos tipados (type-safe) que permitem a adi\u00e7\u00e3o de metadados a \nclasses, m\u00e9todos, vari\u00e1veis, par\u00e2metros e pacotes (ANNOTATIONS, 2004). Esse \nmecanismo permite que partes de um c\u00f3digo-fonte sejam decoradas para que, no caso \nde OA, um interpretador de aspectos identifique pontos em que funcionalidades \ntransversais precisam ser tratadas e tamb\u00e9m tenha os dados necess\u00e1rios para esse \ntratamento. Por exemplo, na Figura 2.2, uma anota\u00e7\u00e3o @Log poderia ser declarada \njunto ao m\u00e9todo para fornecer uma mensagem adicional ao log e n\u00e3o somente o nome \ndo m\u00e9todo. Esses dados s\u00e3o fornecidos atrav\u00e9s dos atributos das anota\u00e7\u00f5es.  \n\nAnota\u00e7\u00f5es nas linguagens Java e C# t\u00eam sido usadas para diversos fins relacionados \na aspectos. Por exemplo, para tratamento de funcionalidades transversais de persist\u00eancia \n(JSR 220B, 2005), documenta\u00e7\u00e3o (ANNOTATIONS, 2004) e inje\u00e7\u00e3o de recursos (JSR \n220A, 2005): \n\n\u2022 Persist\u00eancia: utiliza um conjunto de anota\u00e7\u00f5es para permitir, que nas pr\u00f3prias \nclasses que devem ser persistidas, seja definido o modo como isso deve ser feito. \nPor exemplo, o uso da anota\u00e7\u00e3o @Table(Name=\"Pessoa\") em uma declara\u00e7\u00e3o \nde classe, identifica que essa classe deve ser persistida na tabela Pessoa. A \nanota\u00e7\u00e3o @Field(Name=\"idade\") sobre uma propriedade chamada de age \nidentifica que essa propriedade deve ser persistida em um campo chamado \nidade. Essas anota\u00e7\u00f5es ao serem identificadas por um interpretador de anota\u00e7\u00f5es \n(por exemplo, implementado por aspectos) fornecem as informa\u00e7\u00f5es necess\u00e1rias \npara que o costurador dos aspectos saiba, respectivamente, em qual tabela \npersistir os dados de pessoa e qual campo armazenar a idade; \n\n\u2022 Documenta\u00e7\u00e3o: uma anota\u00e7\u00e3o @RequestForEnhancement(id=2868724, synopsi \n=\"Melhorar identa\u00e7\u00e3o\") pode indicar que determinado c\u00f3digo precisa ter sua \nidenta\u00e7\u00e3o melhorada; \n\n\u2022 Inje\u00e7\u00e3o de recursos: utilizada para que recursos sejam disponibilizados em \ntempo de execu\u00e7\u00e3o, sem que o engenheiro de desenvolvimento tenha que \nrepetidamente implementar manualmente essa chamada ao recurso. Por \nexemplo, @Resource permite que uma inst\u00e2ncia de um determinado componente \nseja automaticamente disponibilizada em uma vari\u00e1vel (JSR 220A, 2005). Para \nque isso ocorra, primeiro anota-se uma vari\u00e1vel com a anota\u00e7\u00e3o citada, ap\u00f3s, o \ninterpretador dessa anota\u00e7\u00e3o gera o c\u00f3digo necess\u00e1rio para que esse recurso seja \ninstanciado e disponibilizado na vari\u00e1vel anotada. A declara\u00e7\u00e3o \n\n\n\n \n\n \n\n23 \n\n@Resource(type=\"javax.mail.Session\") sobre uma vari\u00e1vel identifica que uma \nsess\u00e3o de servi\u00e7o de envio de e-mails deve ser disponibilizada nessa vari\u00e1vel.  \n\nPara melhor compreens\u00e3o da estrutura das anota\u00e7\u00f5es, a Figura 2.4 apresenta o \nc\u00f3digo-fonte da anota\u00e7\u00e3o para realiza\u00e7\u00e3o de log. O c\u00f3digo-fonte mostra outras \nanota\u00e7\u00f5es, fornecidas pela linguagem Java (ou C#), que s\u00e3o utilizadas para a defini\u00e7\u00e3o \nda anota\u00e7\u00e3o Log. A anota\u00e7\u00e3o Retention serve para definir a pol\u00edtica de reten\u00e7\u00e3o de \nanota\u00e7\u00f5es declaradas no c\u00f3digo-fonte, por exemplo, a pol\u00edtica RUNTIME identifica que \na anota\u00e7\u00e3o Log ser\u00e1 disponibilizada junto ao c\u00f3digo bin\u00e1rio das classes em que ela for \ndeclarada, caso tivesse sido utilizada a pol\u00edtica SOURCE, essa anota\u00e7\u00e3o estaria \ndispon\u00edvel somente no c\u00f3digo-fonte. A anota\u00e7\u00e3o Target identifica em quais elementos \nda linguagem a anota\u00e7\u00e3o pode ser aplicada, no caso de Log, a defini\u00e7\u00e3o do tipo do \nelemento como TYPE define que ela pode ser usada somente na declara\u00e7\u00e3o de m\u00e9todos, \no que corresponde a classes e interfaces na linguagem Java. Se fosse utilizado FIELD, \nessa anota\u00e7\u00e3o s\u00f3 poderia ser utilizada em propriedades. Se um engenheiro de \ndesenvolvimento tentar utilizar a anota\u00e7\u00e3o Log em uma propriedade, o pr\u00f3prio \ncompilador da linguagem informar\u00e1 o erro, sem necessidade de extens\u00e3o. As \npropriedades declaradas no corpo da anota\u00e7\u00e3o s\u00e3o disponibilizadas para preenchimento \npelo engenheiro de desenvolvimento, no caso de Log, a propriedade message permite \nque seja definida a mensagem que ser\u00e1 gravada, quando o m\u00e9todo anotado for chamado. \n\npackage com.example; \n \nimport java.lang.annotation.ElementType; \nimport java.lang.annotation.Retention; \nimport java.lang.annotation.RetentionPolicy; \nimport java.lang.annotation.Target; \n \n@Retention(RetentionPolicy.RUNTIME) \n@Target(value = {ElementType.METHOD}) \npublic @interface Log { \n String message();  \n} \n\nFigura 2.4: C\u00f3digo-fonte da Anota\u00e7\u00e3o Log. \n\nAs anota\u00e7\u00f5es de metadados, ap\u00f3s definidas, s\u00e3o acess\u00edveis em tempo de compila\u00e7\u00e3o \ne de execu\u00e7\u00e3o. O acesso em tempo de compila\u00e7\u00e3o \u00e9 necess\u00e1rio para que as ferramentas \nde tratamento dos aspectos identifiquem pontos em que as funcionalidades transversais \nprecisam ser gerenciadas e tenham as informa\u00e7\u00f5es necess\u00e1rias para o tratamento. O \nacesso aos metadados em tempo de execu\u00e7\u00e3o, pode ser feito, tanto em Java, quanto C# \natrav\u00e9s de reflex\u00e3o estrutural. Reflex\u00e3o \u00e9 definida como o processo que permite um \nprograma observar e modificar sua pr\u00f3pria estrutura e comportamento (MAES, 1987). \nEsse tipo de reflex\u00e3o permite que, em tempo de execu\u00e7\u00e3o, o pr\u00f3prio software consiga \nacessar informa\u00e7\u00f5es sobre os tipos abstratos de dados que o comp\u00f5em (informa\u00e7\u00f5es de \nclasses, m\u00e9todos) e, desse modo, pode alterar o seu comportamento (DEMERS e \nMALENFANT, 1995). A Figura 2.5 ilustra o uso de reflex\u00e3o para obten\u00e7\u00e3o de todas as \nanota\u00e7\u00f5es que existem em uma determinada classe.  \n\nPessoa p = new Pessoa(\"Eduardo\"); \nAnnotation[] annotations = p.getClass().getAnnotations(); \n\nFigura 2.5: C\u00f3digo-fonte da obten\u00e7\u00e3o de anota\u00e7\u00f5es de uma classe via reflex\u00e3o. \n\n \n\n\n\n \n\n \n\n24 \n\n2.4 Orienta\u00e7\u00e3o a Objetos e Sistemas de Conhecimento  \nO paradigma OO tem sido amplamente utilizado na constru\u00e7\u00e3o de sistemas; \n\nentretanto, devido \u00e0s caracter\u00edsticas de SCs, para ser utilizado nesse desenvolvimento \ndesse tipo sistema, extens\u00f5es ou convers\u00f5es s\u00e3o necess\u00e1rias. Essa se\u00e7\u00e3o detalha \ntrabalhos relacionados a constru\u00e7\u00e3o de SCs que fazem uso da OO. \n\n2.4.1 Sistemas Orientados a Objetos para Processamento de Regras \n\nEm Meditskos e Bassiliades (2006) e Bassiliades e Vlahavas (2006), O-DEVICE e \nR-DEVICE s\u00e3o respectivamente propostos. Esses sistemas orientados a objetos s\u00e3o \nvoltados para a realiza\u00e7\u00e3o de racioc\u00ednio sobre OWL e RDF, linguagens tradicionais de \nmodelagem de conhecmento. Ambos os sistemas utlizam a linguagem C Language \nIntegrated Production System (CLIPS) e convertem modelos definidos em OWL e RDF \npara objetos da linguagem CLIPS, chamados de COOL. A convers\u00e3o para OO realiza o \nmapeamento de classes OWL/RDF para classes OO e propriedades de classes \nOWL/RDF para atributos de classes OO. Facets, axiomas precisam tamb\u00e9m ser \nexpressos atrav\u00e9s de regras, a obriga\u00e7\u00e3o da defini\u00e7\u00e3o de facets e axiomas por regras \u00e9 \numa desvantagem, pois o processo de convers\u00e3o n\u00e3o peserva a estrutura original do \nmodelo, por exemplo, um facet passa a ser uma regra, o que dificulta a rastreabilidade \ndo modelo e consequentemente a sua manuten\u00e7\u00e3o. Essa convers\u00e3o para OO busca \notimizar o processo de racioc\u00ednio, j\u00e1 que encapsula todos os elementos associados a \numa classe na pr\u00f3pria classe, diferentemente do uso de triplas que n\u00e3o o fazem. O uso \nde triplas exigiria  jun\u00e7\u00e3o de diversas triplas para a constitui\u00e7\u00e3o de uma \u00fanica classe. \n\nA principal desvantagem dessa abordagem \u00e9 que CLIPS foi proposta quando se \nacreditava que SCs poderiam ser constru\u00eddos apenas com uso de regras. Entretanto, \nsabe-se atualmente que \u00e9 invi\u00e1vel a constru\u00e7\u00e3o de SCs complexos apenas com regras, j\u00e1 \nque o n\u00famero tende a ser exponencial e torna invi\u00e1vel a manuten\u00e7\u00e3o dos sistemas. \nCLIPS n\u00e3o oferece um conjunto completo de bibliotecas para constru\u00e7\u00e3o de interface \ngr\u00e1ficas, comunica\u00e7\u00e3o com outros sistemas e portabilidade para diferentes sistemas \noperacionais. Essa linguagem parece adequada apenas para SCs de pequeno porte, que \nn\u00e3o apresentam um grande n\u00famero de regras. \n\n2.4.2 XP.K \n\nXP.K busca resolver a limita\u00e7\u00e3o das metodologias focadas na constru\u00e7\u00e3o de \nmodelos de conhecimento de forma isolada dos aspectos de implementa\u00e7\u00e3o. SC devem \nser integrados ao ambiente de TI pr\u00e9-existente, desse modo, os componentes de \nconhecimento precisam interagir com componentes escritos em linguagens amplamente \nusadas comercialmente, por exemplo, Java e C#. Esse isolamento e a necessidade de \nacessar recursos de linguagens usuais provocam a cria\u00e7\u00e3o de sistemas h\u00edbridos que \nutilizam m\u00faltiplos paradigmas, linguagens e ferramentas. Sistemas h\u00edbridos s\u00e3o de \ndif\u00edcil manuten\u00e7\u00e3o, pois geram redund\u00e2ncias de implementa\u00e7\u00e3o, por exemplo, um \nmodelo \u00e9 implementado com classes da orienta\u00e7\u00e3o a objetos e tamb\u00e9m em uma \nlinguagem funcional para aplica\u00e7\u00e3o de t\u00e9cnicas de IA. Sistemas h\u00edbridos tamb\u00e9m \nacabam muitas vezes sofrendo com os problemas de baixo desempenho encontrados em \nlinguagens de intelig\u00eancia artificial (PREE, BECKENKAMP e VIADEMONTE, 1997).  \n\nXP.K aborda a possibilidade de utiliza\u00e7\u00e3o da orienta\u00e7\u00e3o a objetos como ponto de \npartida para o desenvolvimento de SCs, integrando id\u00e9ias da Engenharia de \nConhecimento e de metodologias \u00e1geis. O desenvolvimento de SC usando XP.K \u00e9 \n\n\n\n \n\n \n\n25 \n\nbaseado no uso do paradigma da OO nas fases de modelagem e implementa\u00e7\u00e3o. O uso \nda OO visa atender o requisito de suporte \u00e0 evolu\u00e7\u00e3o atrav\u00e9s de artefatos de modelagem \nfacilmente manuten\u00edveis, reduzindo o custo de mudan\u00e7a e facilitando o uso da \nprototipa\u00e7\u00e3o. O suporte \u00e0 retroalimenta\u00e7\u00e3o necessita de ferramentas eficientes e \nreduzido tempo de transi\u00e7\u00e3o entre modelos conceituais e c\u00f3digo fonte. O suporte \u00e0 \ncolabora\u00e7\u00e3o requer uma linguagem de modelagem facilmente comunic\u00e1vel entre \nespecialistas do dom\u00ednio e os demais participantes de um projeto. Para alcan\u00e7ar isso, \nXP.K utiliza a abordagem de centralizar o processo de desenvolvimento ao redor de um \nartefato, o componente conceitual orientado a objetos (ontologia). Objetos est\u00e3o \nrelativamente pr\u00f3ximos do modo de pensamento de um especialista e tamb\u00e9m n\u00e3o est\u00e3o \ndistante de c\u00f3digo execut\u00e1vel, diferentemente de linguagens de modelagem tradicionais \n(RDF, OWL, entre outras). Entretanto, conforme Abel (2001), o desenvolvimento de \num SC normalmente requer um modelo de conhecimento composto por um conjunto de \ncomponentes para que o conhecimento tratado seja explicitado o suficiente para ser \nimplementado em um programa de computador. M\u00faltiplos componentes s\u00e3o necess\u00e1rios \ndevido \u00e0 complexidade do conhecimento e cada componente possui construtos \ndiferentes; entretanto em XP.K isso n\u00e3o \u00e9 abordado.  \n\nOntologias e linguagens orientadas a objetos possuem caracter\u00edsticas semelhantes \ncomo alta coer\u00eancia interna, baixo acoplamento, extensibilidade, uso de categorias \nnaturais e nomes (ex.: classes, propriedades). Ontologias e linguagens orientadas a \nobjetos utilizam abordagens similares para a declara\u00e7\u00e3o de estruturas est\u00e1ticas como \nclasses (conceitos), hierarquia de classes (usando heran\u00e7a), atributos, rela\u00e7\u00f5es e \ninst\u00e2ncias. Apesar das semelhan\u00e7as citadas, existem diferen\u00e7as significativas na \nrepresenta\u00e7\u00e3o sem\u00e2ntica. Ontologias permitem definir a sem\u00e2ntica declarativamente \natrav\u00e9s de restri\u00e7\u00f5es, axiomas e regras. Na orienta\u00e7\u00e3o a objetos, a sem\u00e2ntica \u00e9 \nimplementada imperativamente atrav\u00e9s de m\u00e9todos (sequ\u00eancia imperativa de \ncomandos), apesar de UML representar a sem\u00e2ntica da aplica\u00e7\u00e3o por casos de uso, \ndiagramas de atividades, diagramas de estado, al\u00e9m de diagramas de objetos com seus \natributos e m\u00e9todos. \n\nMesmo considerando a expressividade de ambas as abordagens, a abordagem \ndeclarativa \u00e9 mais adequada para a modelagem conceitual. Por exemplo, em um modelo \nconceitual de rela\u00e7\u00f5es familiares, diversos pressupostos sem\u00e2nticos precisam ser \nrepresentados [E.g.: n\u00famero m\u00e1ximo de filhos (restri\u00e7\u00e3o/facet), idades dos filhos deve \nser menor que a dos pais (axioma), a defini\u00e7\u00e3o de um valor para esposa implica que o \nestado civil deixe de ser casado (regra)]. Esses pressupostos s\u00e3o importantes para definir \no dom\u00ednio v\u00e1lido das inst\u00e2ncias e permitir a sua reutiliza\u00e7\u00e3o. Contudo, em uma \nlinguagem imperativa, por exemplo, Java, os construtos usados no componente do \nmodelo conceitual n\u00e3o s\u00e3o suportados e a implementa\u00e7\u00e3o n\u00e3o preserva as estruturas \ndefinidas no modelo conceitual. Por exemplo, a restri\u00e7\u00e3o sobre idade de uma pessoa, \npode ser implementada por uma cl\u00e1usula if; entretanto, no modelo conceitual ela \u00e9 \nexpressa somente por um facet, que n\u00e3o declara a forma como isso \u00e9 feito. Desse modo, \nas estruturas originais s\u00e3o implementadas de modo impl\u00edcito, principalmente para que \ntodos poss\u00edveis caminhos de execu\u00e7\u00e3o respeitem as defini\u00e7\u00f5es do modelo conceitual. \nEssa representa\u00e7\u00e3o impl\u00edcita apresenta os seguintes problemas: \n\n\u2022 Complexidade dos caminhos de execu\u00e7\u00e3o torna a aplica\u00e7\u00e3o muito suscet\u00edvel a \nerros. Qualquer altera\u00e7\u00e3o no c\u00f3digo pode gerar novos caminhos que deixam de \natender os pressupostos sem\u00e2nticos; \n\n\n\n \n\n \n\n26 \n\n\u2022 A manuten\u00e7\u00e3o da aplica\u00e7\u00e3o torna-se bastante complexa e torna-se praticamente \nimposs\u00edvel realizar a engenharia reversa do c\u00f3digo para modelos conceituais, \npois as estruturas n\u00e3o s\u00e3o preservadas entre o modelo e sua respectiva \nimplementa\u00e7\u00e3o (DEMEYER, DUCASSE e TICHELAAR, 1999); \n\nA origem dos problemas est\u00e1 na implementa\u00e7\u00e3o n\u00e3o transparente desses \npressupostos sem\u00e2nticos. Para evitar isso, XP.K prop\u00f5e utilizar a orienta\u00e7\u00e3o a objetos \npara permitir a modelagem conceitual e sua implementa\u00e7\u00e3o com transpar\u00eancia \nsem\u00e2ntica. \n\nTranspar\u00eancia sem\u00e2ntica significa que humanos e m\u00e1quinas avaliam os modelos sem \nambiguidade (tendo uma precisa interpreta\u00e7\u00e3o de significado) e que satisfazem \nsimultaneamente um conjunto de restri\u00e7\u00f5es (COVER, 1998). No caso de linguagens \ndeclarativas como UML, pressupostos sem\u00e2nticos podem ser adicionados em \ncoment\u00e1rios ou em Object Constraint Language (OCL); entretanto, UML n\u00e3o \u00e9 \nexecut\u00e1vel e OCL n\u00e3o \u00e9 amplamente utilizada na Engenharia do Conhecimento. Para \ntratar esse problema e permitir que o componente do modelo conceitual seja \ndesenvolvido no paradigma OO, XP.K prop\u00f5em KBeans, uma proposta para a \nconstru\u00e7\u00e3o de modelos conceituais utilizando a orienta\u00e7\u00e3o a objetos. A pr\u00f3xima se\u00e7\u00e3o \ndetalha KBeans para posterior an\u00e1lise.   \n\n2.4.2.1 KBeans  \n\nKBeans \u00e9 uma proposta para adi\u00e7\u00e3o de transpar\u00eancia sem\u00e2ntica a estruturas de \nclasses da orienta\u00e7\u00e3o a objetos atrav\u00e9s da extens\u00e3o de JavaBeans (KNUBLAUCH, \n2002). Para m\u00e1quinas, a transpar\u00eancia sem\u00e2ntica pode ser reduzida \u00e0 informa\u00e7\u00e3o formal \nsobre elementos de um modelo de objeto e suas rela\u00e7\u00f5es. Desse modo, o elemento \nchave para o desenvolvimento de objetos transparentes semanticamente \u00e9 prover essa \ninforma\u00e7\u00e3o sobre os objetos. Uma forma de prover estes dados, os metadados, em \nlinguagens como Java e C#, \u00e9 por reflex\u00e3o (MAES, 1987), sendo assim poss\u00edvel \nadicionar transpar\u00eancia sem\u00e2ntica a classes dessas linguagens. Essa proposta, \nimplementada em Java, utiliza um conjunto extenso de conven\u00e7\u00f5es de c\u00f3digo para \nrepresentar os metadados diretamente no c\u00f3digo fonte e uma API baseada em reflex\u00e3o \npara extrair esses metadados. Cada KBeans pode ser visto como um componente de \nconhecimento reus\u00e1vel, por exemplo, podemos criar um KBeans para representar uma \npessoa e suas rela\u00e7\u00f5es familiares. Al\u00e9m de permitir a constru\u00e7\u00e3o de componentes de \nconhecimento, essa proposta oferece um cat\u00e1logo pr\u00e9-definido de tipos de facets de \nKBeans (Exemplo: minValue, maxValue, maxCardinality). Facet, na modelagem de \nconhecimento por frames, corresponde a uma rela\u00e7\u00e3o tern\u00e1ria para expressar restri\u00e7\u00f5es \nem valores de slots (semelhante a uma propriedade de uma classe), por exemplo, a facet \nminValue define o valor m\u00ednimo que uma propriedade pode assumir.  \n\nPara utilizar uma facet, por exemplo, minValue, \u00e9 necess\u00e1rio seguir estritamente a \nconven\u00e7\u00e3o de c\u00f3digo&lt;property>MinValue. No caso, para a propriedade idade, a \nrestri\u00e7\u00e3o do menor valor poss\u00edvel \u00e9 feita atrav\u00e9s de idadeMinValue = 0.  \n\nEssa proposta suporta a transpar\u00eancia sem\u00e2ntica de classe de linguagens orientadas a \nobjetos como Java e C# atrav\u00e9s da declara\u00e7\u00e3o e avalia\u00e7\u00e3o de facets (metadados).  \nKBeans prov\u00ea essa transpar\u00eancia no tempo de constru\u00e7\u00e3o das classes atrav\u00e9s de \nconven\u00e7\u00f5es que permitem aos parsers extrair declara\u00e7\u00f5es de ontologias das \ncorrespondentes classes Java e, ent\u00e3o, permitir a convers\u00e3o de ontologias UML para \nJava e vice-versa. Os parsers necessitam analisar m\u00e9todos e propriedades que estejam \n\n\n\n \n\n \n\n27 \n\nde acordo com as conven\u00e7\u00f5es de facets. Essas conven\u00e7\u00f5es, em tempo de execu\u00e7\u00e3o, \npodem ser analisadas atrav\u00e9s do mecanismo de reflex\u00e3o, permitindo que as restri\u00e7\u00f5es \nsem\u00e2nticas sejam identificadas e analisadas para cada inst\u00e2ncia de KBeans. \n\n2.5 An\u00e1lise Cr\u00edtica dos Trabalhos Relacionados \nEntre os trabalhos citados acima para implementa\u00e7\u00e3o do modelo de conhecimento \n\nna OO. Destacam-se O-DEVICE, R-DEVICE e a abordagem KBeans, entretanto, todos \napresentam o problema da ambiguidade do mapeamento dos construtos das linguagens \nde modelagem para a implementa\u00e7\u00e3o em OO. \n\nNos sistemas O-DEVICE e R-DEVICE, o problema de ambiguidade pode ser \nidentificado devido o mapeamento de diversos construtos para regras. Por exemplo, \ntodos os facets, axiomas e regras s\u00e3o mapeados para regras. Isso ocorre porque esses \nsistemas foram baseados em CLIPS, uma linguagem desenvolvida quando se acreditava \nque SCs poderiam ser constru\u00eddos apenas com o uso de regras. \n\nA abordagem KBeans apresenta uma proposta para o tratamento dos construtos das \nlinguagens de modelagem em OO, entretanto, os seguintes problemas podem ser \napontados, conforme Castro, Abel e Price  (2009) \u2013 artigo do autor dessa disserta\u00e7\u00e3o: \n\n\u2022 O uso de conven\u00e7\u00f5es de c\u00f3digo para representar conhecimento na pr\u00f3pria classe \ncria ambiguidade sobre a fun\u00e7\u00e3o dos diferentes elementos: uma classe pode \nrepresentar um conceito ou uma rela\u00e7\u00e3o; um m\u00e9todo pode ser a implementa\u00e7\u00e3o \nde uma regra ou de um axioma; uma propriedade de uma classe pode representar \num atirbuto de um conceito ou uma facet. Por exemplo, uma propriedade \nchamada salarioMinValue pode ser lida como o menor valor permitido para o \nsal\u00e1rio de uma pessoa (nesse caso \u00e9 um facet para o atributo) ou como o menor \nvalor de sal\u00e1rio que uma pessoa recebe mensalmente (nesse caso \u00e9 apenas um \natributo). Apesar de KBeans tentar solucionar o problema da ambiguidade entre \na implementa\u00e7\u00e3o do componente do modelo conceitual e o restante da \nimplementa\u00e7\u00e3o, o uso de padr\u00f5es acaba mantendo o problema (diferentes \nconstrutos s\u00e3o mapeados para um mesmo elemento, por exemplo, atributos e \nfacets s\u00e3o implementados como propriedades). Essa ambiguidade impede que o \nmodelo abstrato seja completamente obtido pela leitura da implementa\u00e7\u00e3o; \n\n\u2022 A biblioteca exige que todos os m\u00e9todos e propriedades de restri\u00e7\u00f5es sejam \ndeclarados como p\u00fablicos, dificultando a leitura da classe pelo engenheiro de \ndesenvolvimento e podendo gerar problemas de modifica\u00e7\u00f5es indevidas a \npropriedades; \n\n\u2022 Ocasiona a prolifera\u00e7\u00e3o de uma grande quantidade de m\u00e9todos auxiliares nas \nclasses que implementam o componente do modelo conceitual do SC. Por \nexemplo, para cada propriedade que tem um facet associado, uma segunda \npropriedade precisa ser definida. Isso aumenta a complexidade do c\u00f3digo, \ndificultando a manuten\u00e7\u00e3o do sistema e a leitura de diagramas UML dessas \nclasses; \n\n\u2022 Exige o dom\u00ednio de uma ampla conven\u00e7\u00e3o de c\u00f3digo. Isso exige um forte \ntreinamento da equipe de desenvolvimento, longas sess\u00f5es de revis\u00e3o de c\u00f3digo \ne torna o c\u00f3digo produzido bastante suscet\u00edvel a erros, pois se a conven\u00e7\u00e3o n\u00e3o \u00e9 \nrespeitada, o c\u00f3digo n\u00e3o \u00e9 interpretado corretamente pela biblioteca de software \ndo KBeans. Por exemplo, a declara\u00e7\u00e3o de uma facet como idadeMinimumValue \n\n\n\n \n\n \n\n28 \n\n\u00e9 inv\u00e1lida, o correto seria idadeMinValue; entretanto, o interpretador da \nlinguagem n\u00e3o \u00e9 capaz de identificar  esse erro; \n\n\u2022 A conven\u00e7\u00e3o de c\u00f3digo obrigat\u00f3ria para a correta interpreta\u00e7\u00e3o pela biblioteca \nde software do KBeans aumenta significativamente a chance de inser\u00e7\u00e3o de \nerros quando refatora\u00e7\u00e3o \u00e9 utilizada. Refatora\u00e7\u00e3o, conforme Fowler (1999), \u00e9 \ndefinida como o processo de modifica\u00e7\u00e3o de um sistema no qual o \ncomportamento externo do sistema n\u00e3o \u00e9 alterado, mas sua estrutura interna \u00e9 \nmelhorada. Por exemplo, a refatora\u00e7\u00e3o de uma propriedade chamada idade para \ntempo, que possui uma facet idadeMinValue, geraria um problema na \nimplementa\u00e7\u00e3o, pois a facet idadeMinValue n\u00e3o seria automaticamente \nrenomeada para tempoMinValue. O mecanismo de refatora\u00e7\u00e3o n\u00e3o identifica \ndepend\u00eancias entre propriedades e facets; \n\n\u2022 Obriga a extens\u00e3o de classe padr\u00e3o (AbstractKBeans) impedindo o uso de \nheran\u00e7a, mesmo que simples, entre conceitos do modelo conceitual; \n\n\u2022 Destaca-se tamb\u00e9m que KBeans n\u00e3o utiliza nenhuma linguagem para defini\u00e7\u00e3o \nde axiomas, o que exige a implementa\u00e7\u00e3o diretamente em c\u00f3digo-fonte da \nlinguagem OO.  \n\nKBeans foi proposto quando as linguagens Java e C# ainda n\u00e3o proviam \nmecanismos para inser\u00e7\u00e3o de metadados em classes e seus elementos (se\u00e7\u00e3o 2.3), nem a \nOA (se\u00e7\u00e3o 2.1) oferecia ferramentas para utiliza\u00e7\u00e3o nessas linguagens. Posteriormente, \nessas linguagens passaram a suportar o conceito de anota\u00e7\u00f5es de metadados \n(ANNOTATIONS, 2004), um mecanismo para inser\u00e7\u00e3o de metadados tipados em \nclasses e seus elementos e ferramentas como AspectJ (KICZALES et al., 2001) foram \ndesenvolvidas para o suporte a aspectos nas linguagens mencionadas anteriormente.  \n\nAnota\u00e7\u00f5es e aspectos s\u00e3o utilizados como base para a defini\u00e7\u00e3o de K-Aspects, pois \npodem reduzir/eliminar os problemas identificados acima. Conforme detalhado no \ncap\u00edtulo 3, as anota\u00e7\u00f5es permitem a implementa\u00e7\u00e3o dos construtos das linguagens de \nmodelagem sem ambig\u00fcidades. A possibilidade de acesso a essas anota\u00e7\u00f5es em tempo \nde execu\u00e7\u00e3o, cap\u00edtulo 4, possibilita que as mesmas sirvam de base para a \nimplementa\u00e7\u00e3o dos componentes de tarefa e inferencial independentes do dom\u00ednio da \naplica\u00e7\u00e3o, por exemplo, uma tarefa para realiza\u00e7\u00e3o de interpreta\u00e7\u00e3o na \u00e1rea da geologia \nou medicina (Cap\u00edtulo 5). \n\n \n\n  \n \n\n\n\n \n\n \n\n29 \n\n3 K-ASPECTS: ASPECTOS PARA IMPLEMENTA\u00c7\u00c3O \nDO COMPONENTE CONCEITUAL \n\nA exist\u00eancia de um s\u00e9rie de metodologias para desenvolvimento de SCs, conforme \napresentado no cap\u00edtulo 1, ainda n\u00e3o atende adequadamente a fase de desenvolvimento \nde sistemas que necessitem modelar conhecimento e infer\u00eancia e evoluir requistos com \nagilidade. A fase de desenvolvimento precisa tratar adequadamente a implementa\u00e7\u00e3o \ndos componentes do modelo de conhecimento e os problemas de comunica\u00e7\u00e3o entre os \ndiferentes agentes de condu\u00e7\u00e3o do projeto: analistas, engenheiros de desenvolvimento e \nengenheiros de conhecimento.  Esse cap\u00edtulo define uma abordagem para tratar do \nmapeamento do componente conceitual de sistemas de conhecimento para uma \nimplementa\u00e7\u00e3o. As solu\u00e7\u00f5es propostas neste cap\u00edtulo foram inicialmente analisadas \npelo autor no artigo (CASTRO, ABEL e PRICE, 2009). \n\nA abordagem proposta permite a implementa\u00e7\u00e3o do componente conceitual do SC \nusando o paradigma OO estabelecendo um caminho padr\u00e3o para a implementa\u00e7\u00e3o desse \nmodelo. O principal objetivo dessa abordagem \u00e9 prover uma forma para que o \ncomponente conceitual e o c\u00f3digo relacionado ao modelo n\u00e3o sejam distintos a tal ponto \nque n\u00e3o seja poss\u00edvel identificar claramente as estruturas definidas no modelo na sua \nrespectiva implementa\u00e7\u00e3o. Uma abordagem padr\u00e3o permite que detalhes de \nimplementa\u00e7\u00e3o sejam mais facilmente identificados e compreendidos tanto por \nprogramadores rec\u00e9m-chegados quanto programadores sazonais desse tipo de sistema. \nIsso pode reduzir o custo de manuten\u00e7\u00e3o e reduzir o risco de inser\u00e7\u00e3o de defeitos por \nproblemas de compreens\u00e3o entre modelo e implementa\u00e7\u00e3o. \n\nA proposta de implementa\u00e7\u00e3o do componente conceitual definida nesse cap\u00edtulo \u00e9 \ncomposta por um conjunto de aspectos (K-Aspects) e um conjunto de anota\u00e7\u00f5es de \nmetadados (K-Annotations). As anota\u00e7\u00f5es s\u00e3o utilizadas para distinguir claramente os \nelementos do componente conceitual em rela\u00e7\u00e3o aos demais elementos que comp\u00f5em \num SC. Por exemplo, uma anota\u00e7\u00e3o @Concept identifica, sem ambiguidades, que uma \ndeterminada classe representa um conceito. As anota\u00e7\u00f5es para implementa\u00e7\u00e3o do \ncomponente conceitual, definidas na se\u00e7\u00e3o 3.2, permitem que o engenheiro de \nconhecimento identifique o seu modelo no c\u00f3digo implementado e, tamb\u00e9m, \nidentificam os pontos em que o interpretador dessas anota\u00e7\u00f5es precisa atuar para a \nrealiza\u00e7\u00e3o do processamento de facets, axiomas e chamada \u00e0s tarefas. \n\nA possibilidade do engenheiro de conhecimento identificar facilmente os construtos \ndo componente conceitual diretamente na implementa\u00e7\u00e3o do mesmo, ou em \ndocumenta\u00e7\u00e3o gerada automaticamente, aumenta significativamente a rastreabilidade \nentre o modelo e sua correspondente implementa\u00e7\u00e3o. Atualmente, a aus\u00eancia de \nelementos de marca\u00e7\u00e3o (anota\u00e7\u00f5es nesse trabalho) dificulta imensamente o processo de \nverifica\u00e7\u00e3o da consist\u00eancia entre o modelo de conhecimento e sua correspondente \n\n\n\n \n\n \n\n30 \n\nimplementa\u00e7\u00e3o, pois a implementa\u00e7\u00e3o faz uso de uma s\u00e9rie de conven\u00e7\u00f5es que \nmapeiam os construtos para m\u00e9todos e propriedades auxiliares (quebra do princ\u00edpio da \npreserva\u00e7\u00e3o de estruturas (SCHREIBER et al., 2000)). A falta de preserva\u00e7\u00e3o de \nestruturas acaba dificultando a comunica\u00e7\u00e3o entre o engenheiro de conhecimento e os \nengenheiros de desenvolvimento, pois enquanto o engenheiro de conhecimento \nidentifica claramente as estruturas no modelo, os engenheiro de desenvolvimento \nprecisam conhecer detalhadamente uma s\u00e9rie de conven\u00e7\u00f5es e n\u00e3o utilizam os \nconstrutos definidos no modelo.  \n\nAl\u00e9m de servirem para preservar as estruturas definidas no modelo de conhecimento \ne estabelecer um protocolo de comunica\u00e7\u00e3o entre engenheiro de conhecimento e de \ndesenvolvimento, as anota\u00e7\u00f5es marcam claramente o c\u00f3digo-fonte associado \u00e0 \nimplementa\u00e7\u00e3o dos componentes do modelo de conhecimento. Essa marca\u00e7\u00e3o auxilia na \nidentifica\u00e7\u00e3o de pontos da aplica\u00e7\u00e3o (pointcuts) em que uma funcionalidade transversal \ndeve ser implementada. No caso da implementa\u00e7\u00e3o do modelo de conhecimento, pode-\nse citar valida\u00e7\u00f5es de valores aceitos para um determinado atributo. As anota\u00e7\u00f5es \ntamb\u00e9m fornecem os dados necess\u00e1rios para que os aspectos realizem o tratamento \nadequado da sem\u00e2ntica associada a cada construtor.  \n\nAl\u00e9m disso, as anota\u00e7\u00f5es s\u00e3o usadas para distinguir claramente os elementos do \ncomponente conceitual do restante do c\u00f3digo. A marca\u00e7\u00e3o clara desses elementos \u00e9 \nessencial para que seja poss\u00edvel identificar todos os pontos da aplica\u00e7\u00e3o em que \naspectos do componente conceitual est\u00e3o presentes. As anota\u00e7\u00f5es fornecem os dados \nnecess\u00e1rios para que os aspectos sejam adequadamente tratados. Os aspectos \nidentificados para a modelagem conceitual visam evitar a dispers\u00e3o de c\u00f3digo gerada \npelo tratamento da sem\u00e2ntica de facets, regras e axiomas e padronizar o tratamento das \nmesmas. Reduzindo custo de manuten\u00e7\u00e3o e aumentando a reusabilidade dos \ncomponentes gerados.  \n\nNa se\u00e7\u00e3o 3.1 \u00e9 definido o processo padr\u00e3o de utiliza\u00e7\u00e3o da abordagem proposta. Na \nse\u00e7\u00e3o 3.2 \u00e9 definida a biblioteca de anota\u00e7\u00f5es utilizadas para a marca\u00e7\u00e3o dos elementos \ndo componente conceitual e implementa\u00e7\u00e3o de aspectos relacionados a esse \ncomponente. Na se\u00e7\u00e3o 3.3 \u00e9 apresentada a biblioteca que realiza o tratamento da \nsem\u00e2ntica das anota\u00e7\u00f5es definidas na se\u00e7\u00e3o 3.2. Na se\u00e7\u00e3o 3.4 \u00e9 apresentada a biblioteca \nde aspectos identificados para o tratamento da implementa\u00e7\u00e3o do componente \nconceitual. \n\n3.1 Processo de Uso de K-Annotations \nO processo de uso de k-annotations define os passos necess\u00e1rios para que a \n\nimplementa\u00e7\u00e3o OO do componente do modelo conceitual seja gerada com sucesso.  \nEsse processo \u00e9 definido para ser reutilizado em diferentes projetos de SCs, \nindependente do dom\u00ednio de aplica\u00e7\u00e3o. \n\nO processo, Figura 3.1, inicia quando o engenheiro de desenvolvimento recebe uma \nespecifica\u00e7\u00e3o do modelo conceitual. \u00c9 necess\u00e1ria a implementa\u00e7\u00e3o da especifica\u00e7\u00e3o \nusando OO acrescido de k-annotations, definidas na se\u00e7\u00e3o 3.2. Ap\u00f3s a implementa\u00e7\u00e3o \ndo componente do modelo conceitual, o interpretador de aspectos recebe como entrada \na implementa\u00e7\u00e3o elaborada pelo engenheiro de desenvolvimento, a biblioteca de \nanota\u00e7\u00f5es, a biblioteca de aspectos e a biblioteca para tratamento de facets, axiomas e \nregras (as bibliotecas s\u00e3o reus\u00e1veis em diferentes projetos). Se o c\u00f3digo n\u00e3o apresentar \nnenhum problema, o interpretador gera o byte-code (c\u00f3digo intermedi\u00e1rio usado por \n\n\n\n \n\n \n\n31 \n\nlinguagens interpretadas), esse c\u00f3digo intermedi\u00e1rio da implementa\u00e7\u00e3o do modelo e dos \naspectos \u00e9 ent\u00e3o costurado pelo weaver (fornecido junto com o interpretador de \naspectos) para a implementa\u00e7\u00e3o da sem\u00e2ntica associada \u00e0s anota\u00e7\u00f5es via aspectos. O \nresultado da interpreta\u00e7\u00e3o \u00e9 a implementa\u00e7\u00e3o execut\u00e1vel do componente conceitual em \numa m\u00e1quina virtual (Java ou C#). Al\u00e9m da implementa\u00e7\u00e3o do componente conceitual, \no compilador tamb\u00e9m invoca a ferramenta KA-DocGen, que gera a documenta\u00e7\u00e3o da \nimplementa\u00e7\u00e3o do componente conceitual, para que mais facilmente seja poss\u00edvel \nrealizar revis\u00f5es entre a especifica\u00e7\u00e3o e a implementa\u00e7\u00e3o. Na Figura 3.1, os ret\u00e2ngulos \nsombreados identificam elementos desenvolvidos nesse trabalho.  \n\n \n\nFigura 3.1: Processo de Uso de K-Annotations. \n\nA sequ\u00eancia de passos realizados no tratamento de anota\u00e7\u00f5es \u00e9 exemplificada na \nFigura 3.2. O primeiro passo decorre da interface gr\u00e1fica que invoca um m\u00e9todo para \nmodifica\u00e7\u00e3o do valor de um atributo do conceito Pessoa. Antes da atribui\u00e7\u00e3o do valor \nao atributo, o advice evalAxiom do aspecto de valida\u00e7\u00e3o de axiomas \u00e9 acionado; esse \nadvice invoca o m\u00e9todo manage da biblioteca de tratamento de axiomas \n(AxiomManager). Esse m\u00e9todo utiliza a biblioteca JEP (JAVA, 2009) para processar a \nespecifica\u00e7\u00e3o do axioma e valid\u00e1-lo. A biblioteca Java Expression Parser (JEP), \ndefinida em (JAVA, 2009), possibilita o processamento de axiomas em Java e \nbibliotecas semelhantes est\u00e3o dispon\u00edveis para C#. Essa biblioteca pode ser utilizada j\u00e1 \n\nImplementa\u00e7\u00e3o \nExecut\u00e1vel do Comp. \n\nConceitual \n\nCompilador de \nAspectos (ajc) \n\nBiblioteca de \nK-Aspects \n\nKA-DocGen \n\nDocumenta\u00e7\u00e3o do \nCM para revis\u00e3o \n\nC\u00f3digo \nok? \n\nSim \n\nN\u00e3o \nEnvia alertas ao eng. \nde desenvolvimento. \n\nC\u00f3digo fonte do \nModelo Conceitual  \n\nanotado com K-\nAnnotations \n\nBiblioteca de \nTratamento de \n\nFacets, Axiomas e \nRegras \n\nBiblioteca de \nK-Annotations \n\nCosturador \n (Weaver) \n\n \n\n\n\n \n\n \n\n32 \n\nque sua gram\u00e1tica \u00e9 compat\u00edvel com a gram\u00e1tica de CML para defini\u00e7\u00e3o de axiomas, \nevitando que o programador tenha que converter express\u00f5es definidas no modelo de \nconhecimento. \n\n Na ilustra\u00e7\u00e3o, a valida\u00e7\u00e3o identificou que o axioma foi atendido, ent\u00e3o a sequ\u00eancia \nde retorno indica o valor VERDADE e, por fim, o valor \u00e9 atribu\u00eddo ao atributo Idade \n(propriedade pIdade). Caso a valida\u00e7\u00e3o tivesse indicado o n\u00e3o-atendimento ao axioma, \no valor n\u00e3o seria atribu\u00eddo ao atributo e o tratamento de exce\u00e7\u00e3o seria lan\u00e7ado. \n\nNo processo apresentado, caso o engenheiro de desenvolvimento n\u00e3o necessite \nestender os aspectos fornecidos como biblioteca, n\u00e3o h\u00e1 necessidade de utiliza\u00e7\u00e3o do \ncompilador de aspectos, apenas \u00e9 necess\u00e1rio utilizar o costurador para a implementa\u00e7\u00e3o \nda sem\u00e2ntica associada \u00e0s anota\u00e7\u00f5es via aspectos. \n\n \n\nFigura 3.2: Diagrama de Sequ\u00eancia para Valida\u00e7\u00e3o de Axioma. \n\n3.2 Biblioteca de K-Annotations \nUma abordagem padr\u00e3o para o desenvolvimento de SCs usando OO com apoio da \n\nOA precisa suportar os construtos existentes em linguagens de modelagem de SCs. \nDestaca-se que esses construtos n\u00e3o est\u00e3o dispon\u00edveis nativamente na OO e muitas \nvezes s\u00e3o tratados por solu\u00e7\u00f5es ad-hoc que n\u00e3o preservam as estruturas dos mesmos, \ndificultando severamente a manuten\u00e7\u00e3o desses sistemas e gerando problemas, conforme \ndefinido no cap\u00edtulo 1. \n\nOs desvantagens apontadas na se\u00e7\u00e3o 2.5. podem ser reduzidas usando a abordagem \nde k-annotations. Anota\u00e7\u00f5es podem reduzir ou eliminar o uso de conven\u00e7\u00f5es de c\u00f3digo, \npois cada anota\u00e7\u00e3o tem um papel claramente definido e facilita a identifica\u00e7\u00e3o dos \naspectos que precisam ser tratados, permitindo a gera\u00e7\u00e3o autom\u00e1tica de c\u00f3digo. \nAnota\u00e7\u00f5es s\u00e3o verificadas pelo interpretador de linguagem, ao passo que conven\u00e7\u00f5es de \nc\u00f3digo n\u00e3o o s\u00e3o (PIVETA et al., 2007). O problema de ambiguidade entre os pap\u00e9is de \npropriedades e m\u00e9todos \u00e9 evitado com elimina\u00e7\u00e3o/redu\u00e7\u00e3o do uso de conven\u00e7\u00e3o de \nc\u00f3digo. Os construtos do componente conceitual s\u00e3o claramente identificados. \n\nA prolifera\u00e7\u00e3o de propriedades e m\u00e9todos auxiliares \u00e9 reduzida usando anota\u00e7\u00f5es. \nEssas anota\u00e7\u00f5es podem ser facilmente interpretadas pelo interpretador de aspectos \nrespons\u00e1vel pela gera\u00e7\u00e3o de c\u00f3digo, e tamb\u00e9m pela ferramenta respons\u00e1vel por gerar \ndocumenta\u00e7\u00e3o. \n\n\n\n \n\n \n\n33 \n\nA equipe de desenvolvimento n\u00e3o precisa mais utilizar um amplo conjunto de \nconven\u00e7\u00f5es de c\u00f3digo n\u00e3o verificado pelo interpretador. Anota\u00e7\u00f5es, sendo validadas \npelo interpretador, evitam erros cometidos pelos engenheiros de desenvolvimento. \n\nO problema da refatora\u00e7\u00e3o de c\u00f3digo \u00e9 reduzido. Por exemplo, uma facet que \nrestringe um valor m\u00ednimo de uma propriedade \u00e9 definida usando @FacetMinValue. Se \na propriedade \u00e9 renomeada, isso n\u00e3o afeta a facet. \n\nO suporte a esses construtos, n\u00e3o nativamente suportados pela OO, pode ser atingido \na partir da defini\u00e7\u00e3o de um conjunto de anota\u00e7\u00f5es que representam claramente esses \nconstrutos no dom\u00ednio da OO entre os demais elementos que atendem outros requisitos \n(ex.: persist\u00eancia, auditoria). A implementa\u00e7\u00e3o do componente conceitual precisa tratar \na sem\u00e2ntica desses construtos. O correto tratamento desses construtos \u00e9 necess\u00e1rio para \nque o SC tenha o comportamento esperado, conforme o modelo de conhecimento. Os \nconstrutos tratados nesse trabalho foram extra\u00eddos de duas linguagens amplamente \nutilizadas na modelagem de conhecimento: Frames (FIKES e KEHLER, 1985) e CML \n(SCHREIBER et al., 2000), visando permitir a utiliza\u00e7\u00e3o dessa abordagem na grande \nparte dos projetos de SCs.  \n\nA seguir s\u00e3o apresentados os construtos suportados e suas rela\u00e7\u00f5es (a Figura 3.3 \napresenta o metamodelo dos construtos e suas rela\u00e7\u00f5es): \n\n\u2022 Conceitos: representam classes de objetos no dom\u00ednio de aplica\u00e7\u00e3o. Semelhante \nao termo entidade da modelagem E-R e classe da orienta\u00e7\u00e3o a objetos. Um \nconceito obrigatoriamente deve ter um nome \u00fanico e suporta heran\u00e7a simples \n(esta restri\u00e7\u00e3o \u00e9 devida ao uso na implementa\u00e7\u00e3o de linguagens de OO como \nJava e C#, que suportam apenas heran\u00e7a simples). Um conceito tamb\u00e9m pode ser \nparte de outro conceito e pode possuir atributos;  \n\n\u2022 Rela\u00e7\u00f5es: representam a liga\u00e7\u00e3o entre diferentes conceitos e devem possuir um \nnome. Conceitos s\u00e3o argumentos de rela\u00e7\u00f5es. Por exemplo, a rela\u00e7\u00e3o \nATENDIDO-POR pode realizar a liga\u00e7\u00e3o entre m\u00e9dico e paciente; \n\n\u2022 Atributos/Slots: representam propriedades de um conceito ou rela\u00e7\u00e3o. Um \natributo possui um nome e um tipo associado. Um atributo pode pertencer a um \nconceito ou a uma rela\u00e7\u00e3o. Por exemplo, a idade de uma pessoa. O termo slot \u00e9 \nutilizado em frames; \n\n\u2022 Facets: definem restri\u00e7\u00f5es (constraints) para os valores v\u00e1lidos para atributos. \nPor exemplo, valor m\u00ednimo para idade \u00e9 0. As facets suportadas nesse trabalho \nforam extra\u00eddas de (KNUBLAUCH, 2002) e correspondem ao principal conjunto \nde facets suportadas em linguagens de modelagem conceitual; \n\n\u2022 Axiomas: especificam rela\u00e7\u00f5es matem\u00e1ticas que precisam ser sempre \nverdadeiras. S\u00e3o aplicados a atributos. Por exemplo, filho.idade &lt;pai.idade; \n\n\u2022 Regras: definem regras de implica\u00e7\u00f5es aplicadas a atributos ou rela\u00e7\u00f5es. Por \nexemplo, podemos definir a seguinte regra relacionada \u00e0 idade:  \n\no SE pessoa.idade > 18 ENT\u00c3O pessoa.maioridade = VERDADEIRA \n\n\n\n \n\n \n\n34 \n\n \n\nFigura 3.3: Metamodelo dos Construtos do Componente Conceitual. \n\n \n\nFigura 3.4: Vis\u00e3o L\u00f3gica das K-Annotations. \n\nOs construtos definidos acima correspondem ao seguinte conjunto de k-annotations \n- Figura 3.4 (a valida\u00e7\u00e3o e o estudo de caso s\u00e3o apresentados no cap\u00edtulo 5). \nRecomenda-se que qualquer classe ou propriedade que esteja implementando um \nelemento do modelo de conhecimento deve apresentar exatamente o mesmo nome \ndefinido no modelo, por exemplo, um conceito Pessoa dever\u00e1 implementado por uma \nclasse chamada de Pessoa. A exig\u00eancia do mesmo nome busca garantir a consist\u00eancia e \no rastreamento entre modelo e implementa\u00e7\u00e3o. Caso n\u00e3o seja poss\u00edvel manter o mesmo \nnome, por exemplo, quando K-Annotations s\u00e3o aplicadas em um sistema legado, o \natributo name deve ser preenchido com o nome definido no modelo. As seguintes K-\nAnnotations s\u00e3o providas: \n\n\u2022 @Concept: usada junto \u00e0 declara\u00e7\u00e3o de classe para defini-la como um conceito. \nA interpreta\u00e7\u00e3o dessa classe gera c\u00f3digo necess\u00e1rio para monitorar que uma \ninst\u00e2ncia foi criada/destru\u00edda. O registro das inst\u00e2ncias v\u00e1lidas \u00e9 necess\u00e1rio para \na realiza\u00e7\u00e3o de infer\u00eancias sobre as mesmas. Caso contr\u00e1rio, n\u00e3o seria poss\u00edvel \ntratar com diferentes conceitos em uma mesma infer\u00eancia. Essa anota\u00e7\u00e3o \ntamb\u00e9m \u00e9 processada pela KA-DocGen para gerar a documenta\u00e7\u00e3o de conceito;  \n\n\u2022 @Attribute: usada junto \u00e0 declara\u00e7\u00e3o de propriedade de uma classe (conceito \nou rela\u00e7\u00e3o) para defini-la como atributo. A interpreta\u00e7\u00e3o dessa anota\u00e7\u00e3o gera \nc\u00f3digo necess\u00e1rio para monitora\u00e7\u00e3o de troca de valores do atributo, pois os \n\n\n\n \n\n \n\n35 \n\naspectos monitoraram mudan\u00e7as nos valores, acionando a valida\u00e7\u00e3o de facets, \nregras e axiomas; \n\n\u2022 @HasParts: define as partes de um conceito. Neste modelo, HasParts \u00e9 uma \nrela\u00e7\u00e3o n\u00e3o-reflexiva e transitiva entre classes que descreve uma partonomia n\u00e3o \ncompleta. Cada parte corresponde a uma classe. Optou-se por exigir que as \nclasses sejam informadas e n\u00e3o somente o nome do conceito, para evitar \nproblemas de grafia com nomes de conceitos. Por exemplo, se fosse permitido \n@HasParts(parts={\u2018Pessoa\u2019}), o engenheiro de desenvolvimento poderia digitar \npesoa ao inv\u00e9s de Pessoa , inserindo um erro na anota\u00e7\u00e3o e quebrando a \nespecifica\u00e7\u00e3o do modelo. Como \u00e9 obrigat\u00f3rio informar a classe do conceito, \n@HasParts(parts={Pessoa.class}), caso haja um erro de grafia, o interpretador \nda linguagem OO ir\u00e1 informar o erro, pois o interpretador n\u00e3o encontrar\u00e1 a \nclasse especificada. Caso ocorra uma refatora\u00e7\u00e3o no nome da classe de um \nconceito, o interpretador automaticamente ir\u00e1 renomear todas as refer\u00eancias \u00e0 \nclasse renomeada, por exemplo, na anota\u00e7\u00e3o @HasParts; \n\n\u2022 @PartOf: define que um conceito \u00e9 parte de outro conceito. \u00c9 uma rela\u00e7\u00e3o n\u00e3o-\nreflexiva e transitiva entre classes e rela\u00e7\u00e3o inversa de HasParts. Deve ser usada \njunto \u00e0 declara\u00e7\u00e3o de classe. Por exemplo, quando a anota\u00e7\u00e3o \n@PartOf(partOf=A.class) \u00e9 declarada em uma classe B, o interpretador de \naspectos ir\u00e1 verificar se a classe B possui um construtor cujo \u00fanico argumento \nv\u00e1lido \u00e9 uma classe do tipo A. Se isso n\u00e3o for detectado, um erro \u00e9 emitido ao \nengenheiro de desenvolvimento e o processo \u00e9 encerrado. Essa verifica\u00e7\u00e3o \u00e9 \nnecess\u00e1ria porque o relacionamento part-of define que uma classe parte de outra, \ns\u00f3 pode existir se a possuidora existir; \n\n\u2022 @Relation: usada junto \u00e0 declara\u00e7\u00e3o de uma classe para definir uma rela\u00e7\u00e3o. A \ndefini\u00e7\u00e3o da aridade da rela\u00e7\u00e3o \u00e9 realizada atrav\u00e9s do uso da anota\u00e7\u00e3o \n@Argument. Por exemplo: \n\no Para uma rela\u00e7\u00e3o bin\u00e1ria, 2 argumentos s\u00e3o necess\u00e1rios, nesse caso, a \nclasse da rela\u00e7\u00e3o bin\u00e1ria deve possuir 2 propriedades anotadas com \n@Argument(order=1) e @Argument(order=2); \n\no Para uma rela\u00e7\u00e3o tern\u00e1ria, 3 argumentos s\u00e3o necess\u00e1rios, nesse caso, a \nclasse da rela\u00e7\u00e3o tern\u00e1ria deve possuir 3 propriedades anotadas \nrespectivamente com @Argument(order=1), @Argument(order=2) e \n@Argument(order=3); \n\n\u2022 @Argument(order): o par\u00e2metro order, obrigat\u00f3rio, identifica a ordem do \natributo na rela\u00e7\u00e3o. Essa anota\u00e7\u00e3o identifica o argumento de uma rela\u00e7\u00e3o, pois \u00e9 \nusada junto \u00e0 declara\u00e7\u00e3o de uma propriedade de uma rela\u00e7\u00e3o. Por exemplo: \n\no Em uma rela\u00e7\u00e3o bin\u00e1ria \u2018atendido-por\u2019, ter\u00edamos como primeiro \nargumento um paciente e como segundo argumento um m\u00e9dico;  \n\no Em uma rela\u00e7\u00e3o do tipo n:m, onde um paciente \u00e9 atendido por v\u00e1rios \nm\u00e9dicos, a cardinalidade de cada argumento \u00e9 definida pelas anota\u00e7\u00f5es \n@FacetMinCardinality/@FacetMaxCardinality; \n\n\u2022 @Facet<Fun\u00e7\u00e3o>: todas anota\u00e7\u00f5es que iniciam por Facet s\u00e3o defini\u00e7\u00f5es de \nrestri\u00e7\u00f5es sobre os valores v\u00e1lidos para atributos/argumentos. Os par\u00e2metros \ndessas facets variam conforme sua fun\u00e7\u00e3o. Essas anota\u00e7\u00f5es indicam ao \n\n\n\n \n\n \n\n36 \n\ninterpretador de aspectos a presen\u00e7a do aspecto de tratamento de facets. A \ninterpreta\u00e7\u00e3o dessas anota\u00e7\u00f5es gera o c\u00f3digo necess\u00e1rio para tratar a sem\u00e2ntica \ncorrespondente, evitando que o desenvolver tenha que manualmente realizar esse \ntratamento, evitando problemas de implementa\u00e7\u00e3o devido a falhas do engenheiro \nde desenvolvimento e reduzindo custos de manuten\u00e7\u00e3o. Chamadas a bibliotecas \nque tratam a sem\u00e2ntica dessas anota\u00e7\u00f5es s\u00e3o geradas pelo pr\u00f3prio interpretador \nde aspectos, evitando dispers\u00e3o destas por toda a implementa\u00e7\u00e3o do componente \nconceitual. A Tabela 3.1 sumariza o conjunto de facets suportadas, conjunto \nextra\u00eddo do cat\u00e1logo de KBeans (KNUBLAUCH, 2002); \n\n\u2022 @Axiom(specification): definida junto a declara\u00e7\u00e3o de conceito para definir \nexpress\u00f5es matem\u00e1ticas que devem ser sempre v\u00e1lidas. Essa anota\u00e7\u00e3o tem como \npar\u00e2metro obrigat\u00f3rio a especifica\u00e7\u00e3o do axioma. A especifica\u00e7\u00e3o \u00e9 realizada \nusando a gram\u00e1tica do JEP, definida em (JAVA, 2009) \u2013 ANEXO. Quando o \ninterpretador de aspectos detecta essa anota\u00e7\u00e3o, ele identifica o aspecto para \ntratamento de axiomas. Nesse caso, o advice realiza a invoca\u00e7\u00e3o da biblioteca de \ntratamento de axiomas toda vez que os valores dos atributos envolvidos no \naxioma s\u00e3o modificados; \n\n\u2022 @Rule(value): definida junto \u00e0 declara\u00e7\u00e3o de conceito para especifica\u00e7\u00e3o de \nregras que s\u00e3o aplicadas sobre os atributos dos conceitos. Exige o preenchimento \ndo par\u00e2metro value que identifica a classe que implementa uma ou mais regras. \nEssa classe deve obrigatoriamente ter um m\u00e9todo chamado de runRules, que \ncont\u00e9m as regras. Quando o interpretador de aspectos detecta essa anota\u00e7\u00e3o, ele \nidentifica o aspecto para tratamento de regras. O advice desse aspecto \u00e9 acionado \npara cada modifica\u00e7\u00e3o de valores de atributos participantes da regra. Nesse caso, \no advice invoca a classe de tratamento de regras. Essa invoca\u00e7\u00e3o \u00e9 necess\u00e1ria \npara verificar os valores e poss\u00edveis altera\u00e7\u00f5es devido \u00e0 execu\u00e7\u00e3o da regra. As \nregras s\u00e3o especificadas usando a sintaxe da linguagem OO usada para o \ndesenvolvimento do SC (ex.: Java, C#). Exemplos dessas regras s\u00e3o \napresentados na se\u00e7\u00e3o 5.3.1; \n\nUm importante ponto a ser ressaltado \u00e9 a ger\u00eancia de exce\u00e7\u00f5es. A fase de \nmodelagem n\u00e3o define como s\u00e3o tratadas as viola\u00e7\u00f5es de conhecimento, por exemplo, \ndurante a execu\u00e7\u00e3o da aplica\u00e7\u00e3o, qual deveria ser o comportamento do sistema quando a \nfacet que impede valores null \u00e9 violada. Por exemplo, o sistema poderia bloquear todas \nas opera\u00e7\u00f5es correntes e exibir um alerta ao usu\u00e1rio para que ele corrigisse a \ninconsist\u00eancia. Para permitir o tratamento de exce\u00e7\u00f5es de viola\u00e7\u00e3o de conhecimento, \ntodas as anota\u00e7\u00f5es @Facet<Fun\u00e7\u00e3o>, @Axiom e @Rule possuem um par\u00e2metro \nchamado de exceptionManager. Esse par\u00e2metro recebe uma classe como argumento. \nEssa classe define como s\u00e3o gerenciadas exce\u00e7\u00f5es em tempo de execu\u00e7\u00e3o. Uma classe \nde tratamento de exce\u00e7\u00f5es deve ter obrigatoriamente um construtor sem argumentos, \npara ser invocado por reflex\u00e3o, e um m\u00e9todo com a assinatura manage(Map context). \nEsse m\u00e9todo \u00e9 invocado quando uma exce\u00e7\u00e3o ocorre e o contexto fornecido indica qual \nfacet foi violado, o atributo alvo da facet e a inst\u00e2ncia do conceito que isso ocorreu. \nEssas informa\u00e7\u00f5es s\u00e3o necess\u00e1rias para que o tratamento seja adequadamente \nexecutado.  \n\nHeran\u00e7a simples \u00e9 suportada para conceitos, pois \u00e9 diretamente suportada pela OO. \nN\u00e3o \u00e9 necess\u00e1rio utilizar uma anota\u00e7\u00e3o espec\u00edfica. Heran\u00e7a m\u00faltipla n\u00e3o \u00e9 suportada \n\n\n\n \n\n \n\n37 \n\npela OO, nem por essa abordagem. Para verificar que um conceito \u00e9 supertipo de outro, \nJava e C# oferecem mecanismos de reflex\u00e3o estrutural que fornecem essa informa\u00e7\u00e3o. \n\nO detalhamento da biblioteca que implementa a sem\u00e2ntica de cada anota\u00e7\u00e3o \u00e9 \napresentado na se\u00e7\u00e3o 3.3. \n\nTabela 3.1: K-Annotations para a Defini\u00e7\u00e3o de Facets. \n\nAnota\u00e7\u00e3o Papel \n@FacetNotNull Define que um atributo n\u00e3o pode ter valor null. \n@FacetDefaultValue \n(value = x) \n\nDefine que o valor padr\u00e3o de um atributo \u00e9 x. \n\n@FacetMinInclusive \n@FacetMaxInclusive \n (value = x) \n\nDefine que um valor de atributo precisa ser \nmaior/menor ou igual a x. \n\n@FacetMinExclusive  \n@FacetMaxExclusive \n(value = x) \n\nDefine que um valor de atributo precisa ser \nmaior/menor que x. \n\n@FacetMinLength \n@FacetMaxLength \n(value = x) \n\nDefine o valor m\u00ednimo/m\u00e1ximo de caracteres \nde uma string. \n\n@FacetFractionDigits \n(value = x) \n\nDefine o n\u00famero m\u00e1ximo de d\u00edgitos que um \nvalor pode possuir. \n\n@FacetMaxCardinality  \n@FacetMinCardinality \n(value = x) \n\nDefine a cardinalidade m\u00ednima/m\u00e1xima que \numa cole\u00e7\u00e3o pode possuir. \n\n@FacetValidClasses \n@FacetInvalidClasses \n\nDefine as classes que uma cole\u00e7\u00e3o suporta \n(n\u00e3o-suporta). Par\u00e2metros omitidos. \n\n@FacetPatterns \n(patterns = {x, y, \u2026}) \n\nDefine que um valor de atributo precisa \nrespeitar o padr\u00e3o x ou y. Os padr\u00f5es s\u00e3o \ndefinidos como express\u00f5es regulares. \n\n@FacetOrdered Define que os valores de uma cole\u00e7\u00e3o devem \nser ordenados. \n\n@FacetDuplicateFree Define que uma cole\u00e7\u00e3o n\u00e3o pode ter valores \nduplicados. \n\n@FacetValidValues \n@FacetInvalidValues \n\nDefine os valores v\u00e1lidos/inv\u00e1lidos para um \natributo. Essa anota\u00e7\u00e3o oferece o par\u00e2metro \nvalues caso o engenheiro de desenvolvimento \nqueira fornecer a lista de valores diretamente \nna anota\u00e7\u00e3o (pr\u00e1tica n\u00e3o recomendada, pois \num novo valor v\u00e1lido iria exigir a \nrecompila\u00e7\u00e3o do modelo). O par\u00e2metro source \nrecebe um classe que deve obrigatoriamente \nter um m\u00e9todo com a assinatura Objects[] \ngetValues(); esse m\u00e9todo fornece todos os \nvalores v\u00e1lidos. Isso permite, por exemplo, que \nos valores sejam recuperados de um banco de \ndados relacional.  \n\n\n\n \n\n \n\n38 \n\n3.3 Biblioteca de Tratamento de Facets, Axiomas e Regras \nA biblioteca de tratamento de facets, axiomas e regras fornece o c\u00f3digo necess\u00e1rio \n\npara implementar a sem\u00e2ntica das anota\u00e7\u00f5es referentes a esses elementos. Por exemplo, \npara prover a sem\u00e2ntica da anota\u00e7\u00e3o @FacetNotNull, \u00e9 necess\u00e1rio que o advice do \naspecto que trata essa anota\u00e7\u00e3o contenha um teste que verifique se o valor que ser\u00e1 \natribu\u00eddo \u00e0 propriedade n\u00e3o \u00e9 null. A Figura 3.5 apresenta a vis\u00e3o l\u00f3gica dessa \nbiblioteca. \n\n \n\nFigura 3.5: Vis\u00e3o L\u00f3gica da Biblioteca de Tratamento de K-Annotations. \n\nPara evitar que advice contenha em seu corpo o pr\u00f3prio teste de valor e evitar que a \ncustomiza\u00e7\u00e3o desse m\u00e9todo requeira a modifica\u00e7\u00e3o da biblioteca de aspectos \n(conhecimento em OA), optou-se por chamar a classe da biblioteca de tratamento de \nanota\u00e7\u00f5es que realiza essa opera\u00e7\u00e3o. Desse modo, caso o engenheiro de \ndesenvolvimento queira customizar o tratamento de cada anota\u00e7\u00e3o, ele n\u00e3o precisa ter \nconhecimento em OA, mas somente em OO, pois a biblioteca de tratamento somente \nutiliza OO. Essa biblioteca, tamb\u00e9m, por exemplo, poderia invocar servi\u00e7os web para \nrealizar o tratamento. A estrutura de classes dessa biblioteca \u00e9 a seguinte: \n\n\u2022 Facet<Fun\u00e7\u00e3o>: para cada facet existe uma classe chamada \nFacet<Fun\u00e7\u00e3o>Manager. Por exemplo, para a anota\u00e7\u00e3o @FacetValidValues \nexiste uma classe que implementa a fun\u00e7\u00e3o de valida\u00e7\u00e3o cujo nome \u00e9 \nFacetValidValuesManager. Essa classe oferece a fun\u00e7\u00e3o que compara o valor \nque ser\u00e1 atribu\u00eddo a uma propriedade com os valores v\u00e1lidos. Caso o valor n\u00e3o \nseja v\u00e1lido, a atribui\u00e7\u00e3o n\u00e3o ser\u00e1 conclu\u00edda e o tratamento de exce\u00e7\u00e3o de \nviola\u00e7\u00e3o de conhecimento \u00e9 acionado. Toda classe de tratamento de facet \npossui um m\u00e9todo com a assinatura manage(Facet<Fun\u00e7\u00e3o> annotation, Map \ncontext) que realiza o tratamento da facet. \n\n\u2022 Axiom: para a anota\u00e7\u00e3o @Axiom, a classe AxiomManager recebe a defini\u00e7\u00e3o \ndo axioma como String (defini\u00e7\u00e3o fornecida na pr\u00f3pria anota\u00e7\u00e3o) e ent\u00e3o \ninvoca a biblioteca que trata de axiomas, no caso desse trabalho, a biblioteca \ndo JEP (JAVA, 2009). Caso o engenheiro de desenvolvimento opte por utilizar \noutra biblioteca de processamento de axiomas, basta modificar o c\u00f3digo da \nclasse AxiomManager; \n\n\u2022 Rule: para a anota\u00e7\u00e3o @Rule, a classe RuleManager \u00e9 respons\u00e1vel por \ninstanciar a classe (fornecida como par\u00e2metro dessa anota\u00e7\u00e3o) que implementa \n\n\n\n \n\n \n\n39 \n\na(s) regra(s). Ap\u00f3s a instancia\u00e7\u00e3o da classe, o m\u00e9todo runRules \u00e9 invocado \npara execu\u00e7\u00e3o das regras. \n\nClasses adicionais podem ser adicionadas a essa biblioteca conforme as \nnecessidades de cada projeto. Essas classes servem para estender as funcionalidades \ndessa biblioteca, por exemplo, se uma nova linguagem para defini\u00e7\u00e3o de axiomas fosse \ndisponibilizada, uma nova classe para o tratamento dessa linguagem poderia ser \nacrescentada. Se um novo projeto exigisse a utiliza\u00e7\u00e3o de uma linguagem para \nprocessamento de regras, uma classe poderia ser acrescentada para que o tratamento \nfosse poss\u00edvel. Se novos tipos de facets fossem propostos, bastaria criar as anota\u00e7\u00f5es \ncorrespondentes e as classes necess\u00e1rias para o respectivo tratamento. A extens\u00e3o das \nbibliotecas contidas em K-Aspects \u00e9 semelhante ao proposto em KBeans \n(KNUBLAUCH, 2002), no qual novas funcionalidades s\u00e3o providas atrav\u00e9s da inclus\u00e3o \nde novas classes e m\u00e9todos na biblioteca. No caso de K-Aspects novos aspectos tamb\u00e9m \npodem ser necess\u00e1rios, quando novas funcionalidades transversais forem identificadas. \nDestaca-se que essas classes n\u00e3o devem ter depend\u00eancia com o dom\u00ednio da aplica\u00e7\u00e3o, \npara que sejam facilmente reutilizadas em diferentes projetos. \n\nEssa biblioteca foi organizada para prover os construtos definidos em CML e \nFrames. CML foi escolhida por apresentar os principais construtos providos pelas \nlinguagens de modelagem de conhecimento e ser a linguagem de modelagem de \nCommonKADS, metodologia extensivamente utilizada para desenvolvimento de SCs. \nFrames tamb\u00e9m \u00e9 suportado inicialmente por essa biblioteca por ser a linguagem de \nmodelagem utilizada como base para a elabora\u00e7\u00e3o do SC apresentado na valida\u00e7\u00e3o \ndessa proposta. \n\n3.4 Biblioteca de K-Aspects do Componente Conceitual  \nAspectos, conforme a se\u00e7\u00e3o 2.1, t\u00eam sido utilizados com sucesso no tratamento de \n\ndiversas funcionalidades transversais encontradas em sistemas, por exemplo, \npersist\u00eancia e auditoria. No caso de SCs, aspectos podem ser usados para o tratamento \nda implementa\u00e7\u00e3o do componente do modelo conceitual. Aspectos evitam que a \nimplementa\u00e7\u00e3o do componente do modelo conceitual acabe tendo que fazer chamadas \nexpl\u00edcitas a bibliotecas que tratam a sem\u00e2ntica de facets, axiomas e regras. O \nengenheiro de desenvolvimento do componente do modelo conceitual precisa apenas \nidentificar claramente os elementos desse modelo usando as anota\u00e7\u00f5es. As anota\u00e7\u00f5es \ns\u00e3o essenciais para identificar os pontos em que o tratamento por aspectos deve ocorrer \ne fornecer as informa\u00e7\u00f5es necess\u00e1rias para que esse tratamento seja realizado com \nsucesso.  \n\nO uso de aspectos tamb\u00e9m evita a dispers\u00e3o de chamadas a bibliotecas que tratam \nfacets, axiomas e regras. Facilitando a leitura do c\u00f3digo e evitando erros do engenheiro \nde desenvolvimento, por exemplo, a falta da invoca\u00e7\u00e3o do c\u00f3digo que trata a valida\u00e7\u00e3o \nde valores de acordo com uma facet. Ao evitar dispers\u00e3o e tarefas repetitivas manuais, \nreduz-se o custo de desenvolvimento e manuten\u00e7\u00e3o do SC. \n\nOs aspectos identificados para o tratamento de funcionalidades necess\u00e1rias \u00e0 \nimplementa\u00e7\u00e3o da modelagem conceitual s\u00e3o os seguintes (Figura 3.6 apresenta a vis\u00e3o \nl\u00f3gica desses aspectos): \n\n\u2022 ConceptAspect: aspecto que monitora a cria\u00e7\u00e3o/destrui\u00e7\u00e3o de qualquer \ninst\u00e2ncia de conceito do componente conceitual. Esse aspecto evita que o \n\n\n\n \n\n \n\n40 \n\nengenheiro de desenvolvimento tenha que manualmente registrar a \ncria\u00e7\u00e3o/destrui\u00e7\u00e3o de inst\u00e2ncias. O pointcut desse aspecto corresponde ao \ninstante seguinte \u00e0 instancia\u00e7\u00e3o de um conceito. O advice desse aspecto invoca \numa classe que armazena as inst\u00e2ncias atuais dos conceitos. Armazenar as \ninst\u00e2ncias correntes \u00e9 importante para realiza\u00e7\u00e3o de tarefas, pois essas operam \nem cima das inst\u00e2ncias dos conceitos (detalhado no cap\u00edtulo 4); \n\n\u2022 AttributeAspect: aspecto que monitora a modifica\u00e7\u00e3o de qualquer valor de \natributo de conceito do componente conceitual. Esse aspecto evita que o \nengenheiro de desenvolvimento tenha que manualmente registrar a modifica\u00e7\u00e3o \nde valores. O pointcut desse aspecto corresponde ao instante seguinte \u00e0 \natualiza\u00e7\u00e3o do valor de qualquer atributo. Destaca-se que os aspectos das facets, \naxiomas e regras s\u00f3 permitem a modifica\u00e7\u00e3o do valor do atributo se ele estiver \nde acordo com as defini\u00e7\u00f5es dos mesmos. Desse modo, n\u00e3o ocorre o caso de ser \nnecess\u00e1rio reverter o valor do atributo e as opera\u00e7\u00f5es que levaram a essa \nmodifica\u00e7\u00e3o. O advice desse aspecto invoca todas as classes que realizam \ninfer\u00eancias em cima do atributo cujo valor foi modificado. A realiza\u00e7\u00e3o de \ninfer\u00eancias \u00e9 a base para realiza\u00e7\u00e3o de tarefas (detalhado no cap\u00edtulo 4); \n\n\u2022 RelationAspect: aspecto que monitora a cria\u00e7\u00e3o/destrui\u00e7\u00e3o de qualquer rela\u00e7\u00e3o \ndo componente conceitual. Esse aspecto evita que o engenheiro de \ndesenvolvimento tenha que manualmente registrar a cria\u00e7\u00e3o/destrui\u00e7\u00e3o de \ninst\u00e2ncias. O pointcut desse aspecto corresponde ao instante seguinte \u00e0 \ninstancia\u00e7\u00e3o de uma rela\u00e7\u00e3o. O advice desse aspecto invoca uma classe que \narmazena as inst\u00e2ncias atuais das rela\u00e7\u00f5es. Armazenar as inst\u00e2ncias correntes \u00e9 \nimportante para realiza\u00e7\u00e3o de tarefas, pois essas operam em cima das inst\u00e2ncias \nde rela\u00e7\u00f5es (detalhado no cap\u00edtulo 4); \n\n\u2022 Facet<Fun\u00e7\u00e3o>Aspect: para cada facet um aspecto foi identificado. Cada \naspecto trata a sem\u00e2ntica de uma facet. Esses aspectos evitam que o engenheiro \nde desenvolvimento tenha que manualmente realizar chamadas ao tratamento de \nfacets em cada troca de valor de atributo. O pointcut desses aspectos \ncorresponde ao instante anterior \u00e0 troca de um valor de atributo. Antes de \npermitir a troca de um valor, todas facets associadas \u00e0quele atributo precisam ser \nvalidadas. Os advices desses aspectos invocam a biblioteca que trata a sem\u00e2ntica \nde cada facet. Essa biblioteca de tratamento \u00e9 extens\u00edvel para que diferentes SCs, \nque apresentam diferentes formas de tratamento de facets, possam usar a \nbiblioteca de aspectos definidos nessa proposta. Caso o valor viole alguma facet, \nesse valor n\u00e3o \u00e9 atribu\u00eddo ao atributo e o gerenciamento de exce\u00e7\u00e3o \u00e9 acionado; \n\n\u2022 AxiomAspect: aspecto que trata os axiomas definidos no modelo conceitual. \nEsse aspecto evita que o engenheiro de desenvolvimento tenha que manualmente \nrealizar chamadas ao tratamento de axiomas em cada troca de valor de atributo. \nO pointcut desse aspecto corresponde ao instante anterior \u00e0 troca de um valor de \natributo. Antes de permitir a troca de um valor, todos os axiomas associados \n\u00e0quele atributo precisam ser validados. O advice desse aspecto utiliza a \nbiblioteca JEP para validar os axiomas. Caso algum axioma seja violado, o valor \nn\u00e3o \u00e9 atribu\u00eddo ao atributo e o gerenciamento de exce\u00e7\u00e3o \u00e9 acionado; \n\n\u2022 RuleAspect: aspecto que trata as regras definidas no componente conceitual. \nEsse aspecto evita que o engenheiro de desenvolvimento tenha que manualmente \nrealizar chamadas ao tratamento de regras em cada troca de valor de atributo. O \n\n\n\n \n\n \n\n41 \n\npointcut desse aspecto corresponde ao instante posterior \u00e0 troca de um valor de \natributo. Ap\u00f3s a troca de um valor, todos as regras associadas \u00e0quele atributo \nprecisam ser executadas. O advice desse aspecto invoca as classes que \nimplementa as regras e estas classes avaliam os valores dos atributos e, \nconforme, necess\u00e1rio alteram outros atributos; \n\nEsses aspectos s\u00e3o fornecidos em uma biblioteca resultante desse trabalho. O \nobjetivo dessa biblioteca \u00e9 permitir o reuso desses aspectos em diferentes projetos de \nSCs, fornecendo uma solu\u00e7\u00e3o padr\u00e3o, j\u00e1 validada, evitando os problemas de solu\u00e7\u00f5es \nad-hoc. Conforme citado anteriormente, KBeans (KNUBLAUCH, 2002) buscou \norganizar uma biblioteca para implementa\u00e7\u00e3o de SCs na OO, entretanto, os problemas \nidentificados (se\u00e7\u00e3o 2.4.2.1) acabam dificultando sua utiliza\u00e7\u00e3o de fato. A valida\u00e7\u00e3o da \nbiblioteca de aspectos \u00e9 apresentada no cap\u00edtulo 5. \n\n \n\nFigura 3.6: Vis\u00e3o L\u00f3gica dos K-Aspects para o Componente Conceitual. \n\n3.5 Sum\u00e1rio do Cap\u00edtulo 3 \nO uso de anota\u00e7\u00f5es para representa\u00e7\u00e3o dos construtos em linguagens OO permite a \n\ndefini\u00e7\u00e3o de uma fun\u00e7\u00e3o bijetora entre modelo e implementa\u00e7\u00e3o. Cada construto da \nlinguagem de modelagem apresenta uma representa\u00e7\u00e3o \u00fanica na implementa\u00e7\u00e3o \ngarantindo a rastreabilidade entre modelo e implementa\u00e7\u00e3o. A preserva\u00e7\u00e3o das \nestruturas tamb\u00e9m facilita a comunica\u00e7\u00e3o entre engenheiros de conhecimento e \ndesenvolvimento, pois as anota\u00e7\u00f5es padronizam a comunica\u00e7\u00e3o sobre as estruturas. \n\nO uso de aspectos permitiu encapsular todo o c\u00f3digo necess\u00e1rio para o tratamento da \nsem\u00e2ntica de cada construto evitando o desenvolvimento manual de uma s\u00e9rie de \nchamadas manuais a bibliotecas que fazem o tratamento desses construtos. A redu\u00e7\u00e3o \ndas tarefas manuais reduz o risco de bugs nos componentes de software que \nimplementam o componente conceitual, pois o tratamento passa a ser responsabilidade \ndo interpretador de aspectos, que gera o c\u00f3digo automaticamente necess\u00e1rio para o \ntratamento. \n\nA defini\u00e7\u00e3o de bibliotecas reus\u00e1veis para diferentes projetos de SC garante que o \nconhecimento adquirido pelos engenheiros de desenvolvimento seja v\u00e1lido para \ndiferentes projetos, reduzindo o custo de desenvolvimento desse tipo de sistema e \ntamb\u00e9m de manuten\u00e7\u00e3o. \n\n\n\n \n\n \n\n42 \n\n4 K-ASPECTS: ASPECTOS PARA IMPLEMENTA\u00c7\u00c3O \nDOS COMPONENTES DE TAREFA E INFERENCIAL \n\nOs componentes de tarefa e inferencial pertencem ao modelo de conhecimento. O \ncomponente de tarefa descreve as estrat\u00e9gias utilizadas para que o sistema resolva \ntarefas intensivas em conhecimento. CommonKADS (SCHREIBER et al., 2000) define \num conjunto de tarefas intensivas em conhecimento e prop\u00f5em um modelo abstrato de \nalgoritmo para solu\u00e7\u00e3o de cada tarefa. Por exemplo, tarefas de classifica\u00e7\u00e3o e \ninterpreta\u00e7\u00e3o. Exemplos concretos de tarefas s\u00e3o o diagn\u00f3stico de qual doen\u00e7a um \npaciente possui ou a interpreta\u00e7\u00e3o de ambientes (ex.: seco, chuvoso) a que uma rocha \nfoi submetida. Destaca-se que as tarefas buscam simular o racioc\u00ednio realizado pelo \nespecialista humano no dom\u00ednio da aplica\u00e7\u00e3o (ABEL, 2001). \n\nPara a resolu\u00e7\u00e3o de tarefas, passos b\u00e1sicos de racioc\u00ednio precisam ser utilizados, \nesses passos s\u00e3o definidos no componente inferencial. A Tabela 4.1 apresenta um \nconjunto de infer\u00eancias e seu significado. Essas infer\u00eancias foram propostas em \nCommonKADS (SCHREIBER et al., 2000) e s\u00e3o utilizadas nos PSMs de classifica\u00e7\u00e3o \ne interpreta\u00e7\u00e3o: \n\nTabela 4.1: Exemplo de Infer\u00eancias (Extra\u00eddo de ABEL, 2001). \n\nInfer\u00eancias de CommonKADS \n\nInfer\u00eancia Significado \nAbstrai \nAbstract \n\nA entrada \u00e9 um dado e a sa\u00edda \u00e9 um modelo abstrato desse dado. O \nmodelo deve ser fornecido para que a abstra\u00e7\u00e3o seja realizada. Nesse \nprojeto, as informa\u00e7\u00f5es do modelo abstrato s\u00e3o expressas nas \nanota\u00e7\u00f5es definidas na se\u00e7\u00e3o 3.2.  \n\nAvalia \nEvaluate \n\nA entrada \u00e9 um dado e uma norma e a sa\u00edda \u00e9 um valor-verdade \nindicando se o dado se adequa a norma. \n\nCompara \nMatch \n\nA entrada s\u00e3o dois valores e a sa\u00edda \u00e9 indica se o primeiro \u00e9 maior, \nigual ou menor do que o segundo. \n\nDecomp\u00f5e \nDecompose \n\nA entrada \u00e9 um conceito \u00fanico e a sa\u00edda \u00e9 o conjunto das partes que o \ncomp\u00f5e. A decomposi\u00e7\u00e3o exige o fornecimento do modelo. \n\nEspecifica \nSpecify \n\nA entrada \u00e9 um objeto e a sa\u00edda \u00e9 um novo objeto associado de \nalguma maneira com o objeto da entrada. A decomposi\u00e7\u00e3o exige o \nfornecimento do modelo. \n\nSeleciona \nSelect \n\nA entrada \u00e9 um conjunto de dados e a sa\u00edda \u00e9 um elemento ou \nsubconjunto desses dados. \n\nA biblioteca de PSMs (modelo abstratos para solu\u00e7\u00e3o de tarefas) fornecida em \nCommonKADS \u00e9 apresentada somente no n\u00edvel abstrato, n\u00e3o havendo nenhuma \n\n\n\n \n\n \n\n43 \n\ndefini\u00e7\u00e3o padr\u00e3o para implementa\u00e7\u00e3o. A falta de proposta padr\u00e3o obriga cada projeto de \nSC utilizar uma solu\u00e7\u00e3o ad-hoc, que, frequentemente, acaba sendo dependente da \naplica\u00e7\u00e3o e pouco reus\u00e1vel em diferentes projetos. Para tratar desses problemas, \naspectos e anota\u00e7\u00f5es podem ser utilizados, como apresentado na pr\u00f3xima se\u00e7\u00e3o. \n\n4.1 Biblioteca de K-Aspects para Componentes de Tarefa e Inferencial \nUm PSM \u00e9 um modelo abstrato de infer\u00eancia reus\u00e1vel (exemplo na Figura 4.1) para \n\num mesmo tipo de tarefa (ex.: classifica\u00e7\u00e3o, interpreta\u00e7\u00e3o) em diferentes dom\u00ednios de \naplica\u00e7\u00e3o (ex.: medicina, geologia). No caso da tarefa de interpreta\u00e7\u00e3o, diferentes \ndom\u00ednios precisam realiz\u00e1-la (interpretar o ambiente diagen\u00e9tico a que uma rocha foi \nsubmetida, interpretar os processos a que um paciente foi submetido). Nesse caso, um \nPSM voltado para essa tarefa deve ser reus\u00e1vel em ambos os dom\u00ednios. Pode-se dizer \nque a realiza\u00e7\u00e3o de uma tarefa espec\u00edfica a um dom\u00ednio, por exemplo, a tarefa \ninterpreta\u00e7\u00e3o de ambiente diagen\u00e9tico instancia o PSM para interpreta\u00e7\u00e3o. \n\nA implementa\u00e7\u00e3o usual de PSMs na OO tem utilizado solu\u00e7\u00f5es ad-hoc e tem sido \norientada pela defini\u00e7\u00e3o de uma sequ\u00eancia de passos/infer\u00eancias que devem ser \nrealizados. Por exemplo, a Figura 4.1 define a sequ\u00eancia de infer\u00eancias realizadas pelo \nm\u00e9todo de classifica\u00e7\u00e3o. Observa-se que as implementa\u00e7\u00f5es de PSMs n\u00e3o t\u00eam \nexplorado a caracter\u00edstica at\u00f4mica de cada infer\u00eancia e a independ\u00eancia entre algumas \ndessas infer\u00eancias.  \n\nPor exemplo, a abstra\u00e7\u00e3o e compara\u00e7\u00e3o poderiam ser realizadas ao longo do pr\u00f3prio \npreenchimento das inst\u00e2ncias do componente conceitual; n\u00e3o seria necess\u00e1rio aguardar \na finaliza\u00e7\u00e3o do preenchimento pelo usu\u00e1rio para que elas fossem realizadas. J\u00e1 a \nsolu\u00e7\u00e3o deve aguardar um certo n\u00famero de dados para ser atualizada, para evitar \nsobrecarga de processamento do sistema, j\u00e1 que SCs podem trabalhar com um grande \nvolume de dados. Por exemplo, em alguns SCs, tarefas intensivas em conhecimento \npodem utilizar mais de dez mil regras. \n\n \n\n \n\n \n\n \n\n  \n\n \n\n \n\nFigura 4.1: Estrutura de infer\u00eancia que descreve o m\u00e9todo de classifica\u00e7\u00e3o \n(Adaptado de ABEL, 2001).  \n\nAspectos e anota\u00e7\u00f5es podem ser utilizados em conjunto para que uma solu\u00e7\u00e3o \npadr\u00e3o para a implementa\u00e7\u00e3o de PSMs seja alcan\u00e7ada. Por exemplo, pode-se visualizar \numa infer\u00eancia como um aspecto (funcionalidade transversal) que deve ser tratado ao \nlongo do preenchimento da inst\u00e2ncia dos componentes do componente conceitual. \nDestaca-se que os PSMs s\u00e3o usados para a modelagem das tarefas que SCs realizam.  \n\nAl\u00e9m disso, como PSMs buscam simular a forma de racioc\u00ednio humano, eles \ndeveriam explorar a caracter\u00edstica de concorr\u00eancia que o c\u00e9rebro humano possui. Por \n\nAbstra\u00e7\u00e3o de \nDados \n\nHip\u00f3teses \n\nSolu\u00e7\u00e3o \n\nCompara \n\nEspecifica \n\nDados \n\nAbstrai \n\n\n\n \n\n \n\n44 \n\nexemplo, quando \u00e9 necess\u00e1rio classificar um animal a partir da leitura de um texto, em \nparalelo \u00e0 realiza\u00e7\u00e3o da leitura do texto, o leitor identifica uma s\u00e9rie de evid\u00eancias \n(caracter\u00edsticas) que comprovam/refutam hip\u00f3teses de classifica\u00e7\u00e3o para esse animal. \nAo final da leitura ou at\u00e9 mesmo antes (em alguns casos), a classifica\u00e7\u00e3o j\u00e1 estar\u00e1 \ndeterminada, sem necessidade de avalia\u00e7\u00e3o de todas as evid\u00eancias e hip\u00f3teses, pois \ngrande parte delas j\u00e1 ter\u00e1 sido avaliada em paralelo \u00e0 leitura. \n\nSimular a concorr\u00eancia do racioc\u00ednio humano em PSMs pode melhorar o tempo de \nresolu\u00e7\u00e3o de tarefas de SCs, j\u00e1 que ao longo do preenchimento de dados pelo usu\u00e1rio, \npode-se realizar uma s\u00e9rie de infer\u00eancias. Evitando que todas as infer\u00eancias sejam \nrealizadas somente ao final do preenchimento dos dados pelo usu\u00e1rio, exigindo que o \nusu\u00e1rio aguarde a realiza\u00e7\u00e3o de todas as infer\u00eancias. Atualmente, isso n\u00e3o tem sido \nadotado. A realiza\u00e7\u00e3o de tarefas \u00e9 sequencial e \u00e9 realizada somente quando o usu\u00e1rio, \nap\u00f3s ter finalizado o preenchimento das inst\u00e2ncias do componente conceitual, solicita a \nrealiza\u00e7\u00e3o da tarefa. No entanto, etapas intermedi\u00e1rias de infer\u00eancias podem ser \nexecutadas ao longo do preenchimento das inst\u00e2ncias do componente conceitual, \nexplorando o potencial da concorr\u00eancia. \n\nPara exemplificar a proposta, a Figura 4.1 apresenta a estrutura de infer\u00eancia para a \ntarefa de classifica\u00e7\u00e3o. As infer\u00eancias (elementos ovais) podem ser tratadas como \naspectos, que s\u00e3o acionados conforme o usu\u00e1rio manipula as inst\u00e2ncias do componente \nconceitual, por exemplo, enquanto ele preenche dados que devem ser classificados. A \ninfer\u00eancia abstrai pode ser identificada com um aspecto cujo pointcut corresponde ao \ninstante seguinte \u00e0 modifica\u00e7\u00e3o de um valor de atributo. O encerramento da execu\u00e7\u00e3o \ndo advice do aspecto abstrair tamb\u00e9m identifica outro aspecto, o aspecto de compara \nque realiza a compara\u00e7\u00e3o. O advice desse aspecto realiza compara\u00e7\u00e3o com as hip\u00f3teses \npresentes na base de conhecimento, usando triplas do tipo&lt;conceito,atributo,valor>. \nObserva-se que uma tripla \u00e9 v\u00e1lida para qualquer dom\u00ednio de aplica\u00e7\u00e3o, sendo esse \nalgoritmo gen\u00e9rico para qualquer tipo de compara\u00e7\u00e3o. Cada hip\u00f3tese validada \u00e9 \narmazenada, at\u00e9 que um conjunto m\u00ednimo que valide uma determinada classifica\u00e7\u00e3o \n(solu\u00e7\u00e3o) seja atingido. Quando o conjunto m\u00ednimo \u00e9 atingido, a classifica\u00e7\u00e3o \u00e9 exibida \ncomo resultado, usando a infer\u00eancia especializa que identifica o objeto alvo como sendo \nda classe validada. \n\nSem o uso de aspectos, a implementa\u00e7\u00e3o da solu\u00e7\u00e3o acima, teria que invocar os \nm\u00e9todos que iniciam as infer\u00eancias em todos os pontos da aplica\u00e7\u00e3o em que valores de \natributos s\u00e3o modificados, pois cada modifica\u00e7\u00e3o de valor pode influenciar os \nresultados das infer\u00eancias. Usando aspectos, essas chamadas deixam de ser necess\u00e1rias, \npois os pontos de a\u00e7\u00e3o das infer\u00eancias (pointcuts) s\u00e3o determinados diretamente nos \naspectos, sem necessidade de interven\u00e7\u00e3o do engenheiro de desenvolvimento. Cada \naspecto trata uma infer\u00eancia espec\u00edfica, destaca-se que esses aspectos s\u00e3o modulares \npara que a fun\u00e7\u00e3o de infer\u00eancia possa ser determinada pelo engenheiro de \ndesenvolvimento da aplica\u00e7\u00e3o. Por exemplo, a compara\u00e7\u00e3o de um determinado atributo \npode exigir opera\u00e7\u00f5es complexas que podem variar conforme a estrat\u00e9gia de \nimplementa\u00e7\u00e3o de projeto para projeto. O objetivo dessa modularidade \u00e9 oferecer certa \nflexibilidade aos engenheiros de desenvolvimento que adotem k-aspects em diferentes \nprojetos. Por exemplo, a modularidade permite que diversos projetos usem uma mesma \nbiblioteca de compara\u00e7\u00f5es. \n\nOs aspectos fornecidos como biblioteca resultante desse trabalho oferecem uma \nsolu\u00e7\u00e3o padr\u00e3o para as infer\u00eancias que podem ser realizadas concorrentemente ao \npreenchimento de inst\u00e2ncias do modelo pelo usu\u00e1rio. O conjunto fornecido permite a \n\n\n\n \n\n \n\n45 \n\nimplementa\u00e7\u00e3o de diferentes PSMs usando aspectos, Figura 4.2 (valida\u00e7\u00e3o apresentada \nno cap\u00edtulo 6): \n\n\u2022 AbstractAspect: esse aspecto trata a infer\u00eancia abstrai. O pointcut desse \naspecto corresponde ao instante seguinte \u00e0 modifica\u00e7\u00e3o do valor de um atributo. \nO advice identifica o atributo cujo valor foi modificado e abstrai gerando uma \ntripla&lt;conceito,atributo,valor>. Essa abstra\u00e7\u00e3o \u00e9 poss\u00edvel porque o componente \nconceitual constru\u00eddo usando k-annotations fornece em tempo de execu\u00e7\u00e3o as \nanota\u00e7\u00f5es (metadados) que identificam o atributo e seu respectivo conceito; \n\n\u2022 EvaluateAspect: esse aspecto trata a infer\u00eancia avalia. O pointcut desse aspecto \ncorresponde ao instante seguinte \u00e0 finaliza\u00e7\u00e3o do advice do aspecto \nAbstractAspect. O advice verifica se a tripla fornecida est\u00e1 adequada a uma \ndeterminada norma (o engenheiro de desenvolvimento deve fornecer a classe \nque obt\u00e9m as normas). Caso esteja adequada, o resultado \u00e9 verdadeiro, caso \ncontr\u00e1rio \u00e9 falso. Esse aspecto \u00e9 configur\u00e1vel de modo que seja poss\u00edvel o \nengenheiro de desenvolvimento fornecer o m\u00e9todo que realiza a avalia\u00e7\u00e3o; \n\n\u2022 MatchAspect: esse aspecto trata a infer\u00eancia compara. O pointcut desse aspecto \ncorresponde ao instante seguinte a finaliza\u00e7\u00e3o do advice do aspecto \nEvaluateAspect quando tiver sido verificada como verdade a adequa\u00e7\u00e3o do valor \n\u00e0 norma. Esse advice verifica se a soma dos valores atribu\u00eddos \u00e0s normas \u00e9 \nsuperior ao limiar estabelecido para uma conclus\u00e3o, caso o seja, ele aciona a \ninfer\u00eancia especifica que fornece ao usu\u00e1rio o resultado da tarefa do PSM (ex.: \numa interpreta\u00e7\u00e3o); \n\n \n\nFigura 4.2: Vis\u00e3o L\u00f3gica dos K-Aspects para os Componentes do Modelo de \nConhecimento. \n\nAs demais infer\u00eancias n\u00e3o foram implementadas por aspectos, pois s\u00e3o utilizadas a \npartir das tr\u00eas infer\u00eancias implementadas como aspectos. Por exemplo, a infer\u00eancia \nseleciona \u00e9 utilizada para selecionar uma norma de um conjunto de normas. Essa \ninfer\u00eancia \u00e9 invocada diretamente no advice do aspecto EvaluateAspect, pois \u00e9 na \n\n\n\n \n\n \n\n46 \n\navalia\u00e7\u00e3o que as normas s\u00e3o utilizadas. O mesmo ocorre para a infer\u00eancia decomp\u00f5e, a \ndecomposi\u00e7\u00e3o de um conceito em suas partes \u00e9 utilizada quando \u00e9 realizada uma \nabstra\u00e7\u00e3o do conceito, no caso, na infer\u00eancia abstrai. \n\nAl\u00e9m das infer\u00eancias, foram criados aspectos para as diferentes tarefas. Esses \naspectos s\u00e3o respons\u00e1veis por realizar valida\u00e7\u00f5es finais das tarefas e ent\u00e3o fornecer os \nresultados para o usu\u00e1rio. Na valida\u00e7\u00e3o apresentada no cap\u00edtulo seguinte, uma interface \ngr\u00e1fica chamada de Knowledge Advisor, exibe os resultados das tarefas ao longo do \npr\u00f3prio preenchimento da inst\u00e2ncia de amostra de rocha pelo usu\u00e1rio, sem necessidade \nque o usu\u00e1rio explicitamente solicite a realiza\u00e7\u00e3o dessa tarefa. \n\nA valida\u00e7\u00e3o da proposta de uma solu\u00e7\u00e3o padr\u00e3o para a implementa\u00e7\u00e3o dos modelos \ncitados nesse cap\u00edtulo usando PSMs \u00e9 apresentada no cap\u00edtulo seguinte. A se\u00e7\u00e3o 4.2 \nexemplifica didaticamente o uso da abordagem apresentada para facilitar a compreens\u00e3o \nda valida\u00e7\u00e3o. \n\n4.2 Exemplo Did\u00e1tico \nO exemplo did\u00e1tico dessa se\u00e7\u00e3o foi definido usando como base o exemplo \n\norganizado em (SCHREIBER et al., 2000). O exemplo trata da tarefa de autorizar/negar \no aluguel de uma resid\u00eancia por um determinado solicitante (pessoa que deseja alugar o \nim\u00f3vel). \n\nO componente conceitual desse exemplo \u00e9 composto por dois conceitos e uma \nrela\u00e7\u00e3o conforme a Tabela 4.2. Cada conceito apresenta um conjunto de atributos. Cada \natributo apresenta um dom\u00ednio v\u00e1lido de valores. \n\nTabela 4.2: Exemplo de Componente Conceitual. \n\nConceito Resid\u00eancia \nCodigo integer, [0, 1000000] \nTipo string(50) one-of [apartamento, casa] \nValorAluguel real, range [0.0 - 10000] \nNumeroHabitantes integer, [1, 10] \u2013 indica o n\u00famero m\u00e1ximo de habitants para a resid\u00eancia \n\nConceito Solicitante \nNome string(200) \nDataNascimento date, [DD/MM/YYYY] \nIdade integer, range [0 \u2013 150] \nSalario real, range [0.0 - 30000] \nAxiomas: \n\u2022 Solicitante.Idade = Hoje \u2013 Solicitante.DataNascimento  \n\nRela\u00e7\u00e3o Solicita\u00e7\u00e3oAluguel \nArgumento-1 one of Solicitante \nArgumento-2 one of Resid\u00eancia \nAtributo Autorizada boolean //identifica se a solicita\u00e7\u00e3o foi autorizada ou negada. \n\nCada conceito corresponder\u00e1 a uma classe. Essas classes dever\u00e3o ser anotadas com \n@Concept para identific\u00e1-las que s\u00e3o conceitos oriundos de um componente \nconceitual.O nome de uma classe anotada \u00e9 igual nome do conceito. Cada classe \ntamb\u00e9m ter\u00e1 anota\u00e7\u00f5es que identificam atributos e suas respectivas facets. Por exemplo, \npara Resid\u00eancia, o atributo Codigo ser\u00e1 implementado como uma propriedade chamada \nCodigo do tipo inteiro anotada com @Attribute. Al\u00e9m da anota\u00e7\u00e3o @Attribute, duas \nanota\u00e7\u00f5es adicionais @FacetMinValue(0) e @FacetMaxValue(1000000) ser\u00e3o \nutilizadas para, respectivamente, restringir o valor m\u00ednimo e m\u00e1ximo permitido para \nessa propriedade. A Figura 4.3 apresenta a implementa\u00e7\u00e3o dos dois conceitos. \n\n\n\n \n\n \n\n47 \n\n@Concept \npublic class Residencia{ \n    @Attribute \n    @FacetMaxInclusive(100000) \n    @FacetMinInclusive(0) \n    Integer Codigo; \n \n    @Attribute        \n    @FacetValidValues(values={\"apartamento, casa\"})    \n    String Tipo; \n     \n    @Attribute \n    @FacetMaxInclusive(10000f) \n    @FacetMinInclusive(0f)     \n    Float Aluguel; \n \n    @Attribute \n    @FacetMaxInclusive(10) \n    @FacetMinInclusive(0) \n    Integer NumeroHabitantes; \n \n    //m\u00e9todos de getters/setters omitidos \n}  \n \n@Relation \npublic class SolicitacaoAluguel{ \n    @Argument(order=1) \n    Solicitante solicitante; \n \n    @Argument(order=2) \n    Residencia residencia; \n \n    @Attribute \n    Boolean Autorizada; \n \n    //m\u00e9todos de getters/setters omitidos \n} \n\n@Concept \n@Axiom(expression=\"Solicitante.Idade = Hoje \u2013 \nSolicitante.DataNascimento \") \n) \npublic class Solicitante{ \n    @Attribute \n    @FacetMaxLength(length=200) \n    Integer Codigo; \n \n    @Attribute \n    @FacetPattern(pattern=\"[0-9][0-9]/[0-9][0-9]/[0-9][0-\n9][0-9][0-9]\") \n    String Date = \"\";    \n \n    @Attribute \n    @FacetMaxInclusive(150) \n    @FacetMinInclusive(0) \n    Integer Idade; \n \n    @Attribute \n    @FacetMaxInclusive(30000f) \n    @FacetMinInclusive(0f)     \n    Float Salario; \n \n    //m\u00e9todos de getters/setters omitidos \n} \n\nFigura 4.3: Exemplo de Implementa\u00e7\u00e3o do Componente Conceitual. \n\nEssa implementa\u00e7\u00e3o do componente conceitual ser\u00e1 ent\u00e3o tratada no processo de \ncostura dos aspectos. Esse processo inicialmente verifica nas classes os pointcuts \nexistentes de acordo com os aspectos fornecidos na biblioteca de aspectos. Por exemplo, \na exist\u00eancia da anota\u00e7\u00e3o @FacetMaxInclusive(10) sobre a propriedade intHabitantes e a \nexist\u00eancia de um m\u00e9todo (setHabitantes), que modifica o valor da propriedade, \ncorresponde ao pointcut evalMaxRangeField (Figura 4.4) definido no aspecto \nFacetValueRangeAspect.  \n\nDurante o processo de costura, quando esse ponto \u00e9 identificado, um c\u00f3digo \nadicional (advice - Figura 4.5) \u00e9 inserido para ser invocado antes da efetiva atribui\u00e7\u00e3o \ndo valor a propriedade. Esse c\u00f3digo invoca o componente da biblioteca de valida\u00e7\u00e3o de \nintervalos num\u00e9ricos, especificamente, o m\u00e9todo validaMaxRange(...). Esse m\u00e9todo \nrecebe como argumento o conceito, o atributo, a facet e o valor que se deseja atribuir a \npropriedade. A facet corresponde a anota\u00e7\u00e3o @FacetMaxInclusive(10), essa anota\u00e7\u00e3o \nfornece o valor 10 para indicar qual o valor m\u00e1ximo permitido para esse atributo. Esse \nprocesso termina quando todos os c\u00f3digos adicionais foram inseridos para todos os \npointcuts identificados na implementa\u00e7\u00e3o fornecida. O resultado desse processo \u00e9 a \nimplementa\u00e7\u00e3o execut\u00e1vel do componente conceitual. \n\n\n\n \n\n \n\n48 \n\n pointcut evalMaxRangeField (Object instance) :   (set (@FacetMaxExclusive * *) || \n                                                                       set (@FacetMaxInclusive * *)) &amp;&amp; args(instance); \n\nFigura 4.4: Pointcut para valida\u00e7\u00e3o de valor m\u00e1ximo. \n\n//Advice para valida\u00e7\u00e3o de valor m\u00e1ximo permitido \nbefore(Object instance) : evalMaxRangeField(instance) { \n    //Obt\u00e9m a lista de anota\u00e7\u00f5es existentes sobre a classe em que o advice est\u00e1 agindo. \n    Annotation[] annotations = getField(thisJoinPoint.getTarget(),    \n                          thisJoinPointStaticPart.getSignature().getName()).getAnnotations(); \n    //Obt\u00e9m o conceito. \n    Concept concept = thisJoinPoint.getTarget().getClass().getAnnotation(Concept.class); \n    //Obt\u00e9m o atributo. \n    Attribute attrib = (Attribute)getAnnotation(annotations, Attribute.class); \n    //Obt\u00e9m a anota\u00e7\u00e3o de valor m\u00e1ximo. \n    Annotation facet = getAnnotation(annotations, FacetMaxInclusive.class);           \n    //Invoca o componente RangeValidator, respons\u00e1vel por validar o valor. \n    //Instance \u00e9 o valor que se deseja atributir. \n    RangeValidator.validateMaxRange(concept, attrib, facet, instance);  \n} \n\nFigura 4.5: Advice para valida\u00e7\u00e3o de valor m\u00e1ximo. \n\nQuando uma inst\u00e2ncia do conceito Solicitante \u00e9 criada e invoca-se o m\u00e9todo \nsetHabitantes (20), antes de ocorrer a atribui\u00e7\u00e3o do valor 20 a propriedade intHabitante, \nconforme definido no aspecto acima, o advice de valida\u00e7\u00e3o \u00e9 acionado. Esse advice, \nfazendo uso da biblioteca de valida\u00e7\u00e3o, identificar\u00e1 que o valor passado como \nargumento \u00e9 superior ao m\u00e1ximo permitido. Desse modo, esse advice n\u00e3o permitir\u00e1 que \nesse valor seja atributo \u00e0 vari\u00e1vel intHabitantes (o valor m\u00e1ximo \u00e9 10) e enviar\u00e1 uma \nmensagem de exce\u00e7\u00e3o ao usu\u00e1rio atrav\u00e9s do KnowledgeAdvisor. Nesse exemplo, a \nexce\u00e7\u00e3o \u00e9 exibida no KnowledgeAdvisor porque a implementa\u00e7\u00e3o n\u00e3o fez uso da \npropriedade exceptionManager presente em @FacetMaxInclusive. Por padr\u00e3o, a \nbiblioteca utiliza o KnowledgeAdvisor para exibir mensagens. Caso tivesse sido \nfornecido um outro gerenciador de exce\u00e7\u00f5es para envio de um sinal sonoro, esse sinal \nseria emitido quando invocado setHabitantes (20). Para todos os demais conceitos, \natributos, facets, axiomas e regras o tratamento \u00e9 realizado conforme o exemplificado. \n\nO objetivo da tarefa de autoriza\u00e7\u00e3o de aluguel \u00e9 analisar as caracter\u00edsticas de um \nsolicitante com as caracter\u00edsticas da resid\u00eancia para determinar se ele pode alugar a \nresid\u00eancia solicitada. Na implementa\u00e7\u00e3o desse exemplo, sem k-aspects, essa tarefa seria \nrealizada somente quando um conjunto de inst\u00e2ncias da rela\u00e7\u00e3o Solicitac\u00e3oAluguel \ntivesse sido criado. Supondo-se que esse conjunto tivesse mais de 100 mil solicita\u00e7\u00f5es, \na realiza\u00e7\u00e3o dessa tarefa iria exigir diversos minutos para ser executada, pois \u00e9 realizada \nsequencialmente. Na implementa\u00e7\u00e3o com k-aspects, faz-se uso dos aspectos de \ninfer\u00eancias e tamb\u00e9m de um aspecto adicional espec\u00edfico para a tarefa de autoriza\u00e7\u00e3o.  \n\nO aspecto AutorizaAluguelTask define o pointcut validaAutorizacao acionado a cada \ncinco modifica\u00e7\u00f5es em valores atributos de Solicitante, Resid\u00eancia e \nSolicita\u00e7\u00e3oAluguel. Esse valor de cinco modifica\u00e7\u00f5es \u00e9 apenas um exemplo. \nRecomenda-se que um limiar de modifica\u00e7\u00f5es seja definido para evitar que a realiza\u00e7\u00e3o \nda tarefa ocorra a cada modifica\u00e7\u00e3o, o que poderia provocar problemas de desempenho. \nO AutorizaAluguelTask faz uso dos resultados das infer\u00eancias abstrai, valia e compara, \ntamb\u00e9m implementadas como aspectos, conforme definido na se\u00e7\u00e3o anterior. A \ninfer\u00eancia abstrai, aspecto AbstractAspect, identifica o conceito, o atributo e o valor \nmodificado e abstrai para uma tripla. Essa tripla \u00e9 ent\u00e3o processada pelo aspecto \nEvaluateAspect; esse aspecto, a partir do conceito e atributo, obt\u00e9m todas as normas \n\n\n\n \n\n \n\n49 \n\nassociadas ao atributo. As normas (determinam as regras para autorizar/negar o aluguel) \ns\u00e3o validadas quando o valor da tripla \u00e9 compat\u00edvel com o valor especificado na norma.     \nCada norma tem um peso associado a decis\u00e3o, desse modo, quando validada, ela \u00e9 \nmarcada como v\u00e1lida para posterior avalia\u00e7\u00e3o na infer\u00eancia compara. Ap\u00f3s a avalia\u00e7\u00e3o \ndas normas, o aspecto MatchAspect \u00e9 acionado para verificar se o limiar m\u00ednimo para \nautoriza\u00e7\u00e3o foi atingido; para isso, o somat\u00f3rio dos pesos das normas consideradas \nv\u00e1lidas \u00e9 comparado com o limiar. Se o somat\u00f3rio for maior ou igual ao limiar, o \npr\u00f3prio advice modifica a propriedade Autorizada da rela\u00e7\u00e3o Solicta\u00e7\u00e3oAluguel para \nvalor verdade. Al\u00e9m de modificar o valor, quando uma solicita\u00e7\u00e3o \u00e9 autorizada, advice \ninforma ao usu\u00e1rio da autoriza\u00e7\u00e3o atrav\u00e9s do KnowledgeAdvisor.  \n\nEsse exemplo demonstrou didaticamente a utiliza\u00e7\u00e3o da proposta. O pr\u00f3ximo \ncap\u00edtulo apresenta a valida\u00e7\u00e3o dessa proposta em um SC de grande porte atualmente em \nuso.  \n\n4.3 Sum\u00e1rio do Cap\u00edtulo 4 \nO uso de aspectos para a realiza\u00e7\u00e3o dos passos de racioc\u00ednio, infer\u00eancias, \n\nnecess\u00e1rios para a realiza\u00e7\u00e3o das tarefas atribu\u00eddas a um SC permitiu explorar a \natomicidade das infer\u00eancias para compartilhamento dos resultados entre diferentes \ntarefas. Ao tratar cada infer\u00eancia individualmente, as tarefas passam a ser realizadas \natrav\u00e9s da composi\u00e7\u00e3o de uma s\u00e9rie de infer\u00eancias. Os resultados das infer\u00eancias s\u00e3o \narmazenados em estruturas como pilhas e conjuntos para acesso posterior pelas demais \ninfer\u00eancias. \n\nO processamento das mesmas em paralelo ao preenchimento das inst\u00e2ncias do \nmodelo conceitual, sem necessidade do engenheiro de desenvolvimento utilizar recursos \nespec\u00edficos de processamento paralelo para obter resultados similares, evita a dispers\u00e3o \nde m\u00e9todos associados ao processamento paralelo. Resultados obtidos pela realiza\u00e7\u00e3o \ndas tarefas podem ser exibidos ao longo do pr\u00f3prio preenchimento das inst\u00e2ncias, sem \nnecessidade que o usu\u00e1rio aguarde todo o preenchimento para poder obter os resultados \ndas tarefas. \n\nAl\u00e9m disso, a utiliza\u00e7\u00e3o de infer\u00eancias fornecidas pela biblioteca desenvolvida nesse \ntrabalho, evita a implementa\u00e7\u00e3o manual das mesmas e permitindo o reuso. O \ncompartilhamento dessa biblioteca padr\u00e3o de infer\u00eancia permite que diferentes projetos \na utilizem. Ressalta-se que o conhecimento adquirido pelos engenheiros de \ndesenvolvimento permanece v\u00e1lido para diferentes projetos. \n\n \n\n\n\n \n\n \n\n50 \n\n5 VALIDA\u00c7\u00c3O DA PROPOSTA \n\nA valida\u00e7\u00e3o das propostas apresentadas nos cap\u00edtulos 3 e 4 foi realizada atrav\u00e9s da \ncompara\u00e7\u00e3o entre a solu\u00e7\u00e3o atual, ad-hoc, adotada em um SC de grande porte, \nconstru\u00eddo a partir de uma ontologia de dom\u00ednio sobe a qual s\u00e3o executados m\u00e9todos de \nsolu\u00e7\u00e3o de problemas, e a respectiva solu\u00e7\u00e3o com k-aspects. Essa se\u00e7\u00e3o apresenta as \nduas solu\u00e7\u00f5es e, por fim, avalia a proposta de k-aspects para implementa\u00e7\u00e3o de SCs. \n\n5.1 Estudo de Caso: Sistema Petroledge \nO sistema de conhecimento Petroledge\u00ae \u00e9 voltado para a avalia\u00e7\u00e3o da qualidade de \n\nreservat\u00f3rios de petr\u00f3leo usando como base descri\u00e7\u00f5es de rochas sedimentares e \ninterpreta\u00e7\u00f5es automatizadas pelo sistema. Esse sistema \u00e9 resultado dos trabalhos de \n(ABEL, 2001; SILVA, 2001; MASTELLA, 2005 e VICTORETI, 2007) no \u00e2mbito do \nGrupo de Bancos de Dados Inteligentes da UFRGS e atualmente est\u00e1 sendo usado por \ndiversas empresas do setor do petr\u00f3leo. \n\n \n\nFigura 5.1: Fluxo de Trabalho do Sistema Petroledge (GUIA, 2009). \n\nO fluxo de uso desse sistema inicia quando o usu\u00e1rio (petr\u00f3grafo) recebe uma \namostra de rocha. Essa amostra \u00e9 ent\u00e3o descrita no sistema Petroledge a partir da \nobserva\u00e7\u00e3o de uma l\u00e2mina de rocha realizada usando um microsc\u00f3pio. O fluxo de \n\n\n\n \n\n \n\n51 \n\ntrabalho nesse sistema \u00e9 apresentado na Figura 5.1. Inicialmente o usu\u00e1rio insere um \nconjunto de dados de descri\u00e7\u00e3o em diferentes interfaces gr\u00e1ficas (Figura 5.2 - entrada de \ndados de microscopia). Ap\u00f3s completar a inser\u00e7\u00e3o dos dados, o usu\u00e1rio pode salvar os \ndados (dados s\u00e3o persistidos em banco de dados relacional) e solicitar que o sistema \nrealize algumas tarefas sobre os dados: tarefa de interpreta\u00e7\u00e3o e classifica\u00e7\u00e3o. Essas \ntarefas s\u00e3o realizadas atrav\u00e9s de algoritmos que implementam os PSMs de interpreta\u00e7\u00e3o \ne classifica\u00e7\u00e3o, respectivamente. Atualmente, essas tarefas podem levar mais de 5 \nminutos, pois todas as infer\u00eancias necess\u00e1rias s\u00e3o realizadas somente ap\u00f3s a solicita\u00e7\u00e3o \nda realiza\u00e7\u00e3o da tarefa e essas utilizam centenas de consultas a um banco de dados \nrelacional, sendo assim diretamente influenciadas pela lat\u00eancia de acesso ao banco e \ntempo de resposta. \n\n \n\nFigura 5.2: Tela para Entrada de Dados de Microscopia (GUIA, 2009). \n\nA descri\u00e7\u00e3o realizada pelo ge\u00f3logo instancia os conceitos definidos no componente \nconceitual. Esses conceitos apresentam atributos com dom\u00ednio pr\u00e9-definidos em \nconceitos que comp\u00f5em a nomenclatura do sistema. A pr\u00e9-defini\u00e7\u00e3o de valores \u00e9 \nnecess\u00e1ria para padroniza\u00e7\u00e3o da nomenclatura e automatiza\u00e7\u00e3o de tarefas. Por fim, o \nusu\u00e1rio solicita ao sistema que realize as tarefas de interpreta\u00e7\u00e3o. Essas tarefas, \nconforme a descri\u00e7\u00e3o realizada pelo usu\u00e1rio, instanciam automaticamente conceitos que \ndescrevem as interpreta\u00e7\u00f5es obtidas. Os modelos que comp\u00f5em o sistema s\u00e3o descritos \nnas se\u00e7\u00f5es 5.1.1 e 5.1.2. \n\n\n\n \n\n \n\n52 \n\n5.1.1 Componente Conceitual \n\nO componente conceitual do Petroledge, Figura 5.3, \u00e9 composto por tr\u00eas grupos de \nconceitos: \n\n\u2022 Conceitos para Descri\u00e7\u00e3o de Rocha (Figura 5.3a): conjunto de conceitos que \ns\u00e3o instanciados pelo usu\u00e1rios (petr\u00f3grafo) durante a tarefa de descri\u00e7\u00e3o de \nrochas; \n\n\u2022 Conceitos de Defini\u00e7\u00e3o de Nomenclatura (Figura 5.3b): conjunto de conceitos \nque comp\u00f5em a nomenclatura do sistema. Certos atributos de conceitos, \ndescritos pelo usu\u00e1rio, apresentam uma nomenclatura geol\u00f3gica pr\u00e9-definida. \nPor exemplo, uma descri\u00e7\u00e3o de rocha pode ser realizada para diferentes fins. \nEsses fins s\u00e3o pr\u00e9-definidos pelo especialista que forneceu o conhecimento \ndisponibilizado no sistema; \n\n\u2022 Conceitos para Realiza\u00e7\u00e3o de Tarefas (Figura 5.3c): conjunto de conceitos \nque s\u00e3o instanciados automaticamente pelas tarefas que o sistema \u00e9 capaz de \nrealizar. Por exemplo, a tarefa que realiza interpreta\u00e7\u00f5es sobre os ambientes (ex: \nclima seco, chuvoso, etc) a qual a rocha foi submetida, instancia o conceito de \ninterpreta\u00e7\u00e3o de ambiente diagen\u00e9tico. \n\nCada conceito \u00e9 formado por um conjunto de atributos, os dom\u00ednios de valores para \nesses atributos s\u00e3o definidos via facets. Axiomas e regras tamb\u00e9m s\u00e3o aplicados a esses \nconceitos. A Tabela 5.1 apresenta a modelagem em concepts dos conceitos de descri\u00e7\u00e3o \nde rocha e conceitos de defini\u00e7\u00e3o de nomenclatura utilizados na valida\u00e7\u00e3o desse \ntrabalho. A descri\u00e7\u00e3o completa desse componente conceitual pode ser encontrada em \nABEL, 2001.  \n\nA modelagem dos conceitos para realiza\u00e7\u00e3o da tarefa de interpreta\u00e7\u00e3o de ambiente \ndiagen\u00e9tico, especificamente do conceito \u201cAmbiente Diagen\u00e9tico\u201d, \u00e9 realizada atrav\u00e9s \nde grafos de conhecimento. Grafos de conhecimento s\u00e3o \u00e1rvores que representam \ngraficamente as associa\u00e7\u00f5es entre os conceitos de descri\u00e7\u00e3o de rocha e respectivas \ninterpreta\u00e7\u00f5es diagen\u00e9ticas (ABEL, 2001). O metamodelo de grafo de conhecimento \u00e9 \ndefinido na Figura 5.4.  Um grafo corresponde a uma interpreta\u00e7\u00e3o de ambiente (por \nexemplo: ambiente de clima seco) e \u00e9 composto por um conjunto de pacotes (Figura \n5.5a). Cada pacote representa um conjunto de fei\u00e7\u00f5es visuais (pr\u00e9-definidas pelo \nespecialista em geologia) e possui um peso. Esse peso \u00e9 utilizado para determinar se \numa determinada interpreta\u00e7\u00e3o foi atingida, pois cada interpreta\u00e7\u00e3o apresenta um limiar. \nCada fei\u00e7\u00e3o visual (Figura 5.5b) \u00e9 identificada a partir de um conjunto de evid\u00eancias. \nCada evid\u00eancia (Figura 5.5c) corresponde a uma tripla&lt;conceito,atributo,valor> que \ndeve ser encontrada na inst\u00e2ncia preenchida pelo petr\u00f3grafo. A Figura 5.5 apresenta um \nexemplo de grafo de conhecimento para interpreta\u00e7\u00e3o de ambiente diagen\u00e9tico. \nSegundo Abel (2001, p. 158), os grafos representam: \n\nNo modelo, o papel de regras, que orientam as infer\u00eancias poss\u00edveis do \nsistema, por\u00e9m representam as informa\u00e7\u00f5es de forma mais estruturada. A \nsem\u00e2ntica de um \u00fanico grafo, se fosse representado atrav\u00e9s de regras exigiria \nmais de 20 regras para ser representada. Isso tornaria bastante complicada a \nmanuten\u00e7\u00e3o dessas regras. \n\nOs grafos de conhecimento s\u00e3o utilizados nos modelos de tarefa e inferencial para \nrealiza\u00e7\u00e3o da tarefa de interpreta\u00e7\u00e3o. O detalhamento de como eles s\u00e3o utilizados \u00e9 \nrealizado na se\u00e7\u00e3o  5.1.2. \n\n\n\n \n\n \n\n53 \n\nTabela 5.1: Modelo de Conceitos do Sistema Petroledge (Adaptado de ABEL, \n2001). \n\nConcept Sample \nIs-a Object \nSample-ID string(20) \n\nConcept ThinIdentification \nIs-a Object \nPart-of Concept Sample \nThin-ID string(20) \nUnit string(60) \u2013 Pattern [a-zA-Z]*-[0-9] \nBasin  string(40) \nField string(20) \nWell   string(20) \nTopDepth  real, range [0.0 - 9999.99] \nBaseDepth  real, range [0.0 - 9999.99] \nPlace string(40) \nUse string(80), list-of [Depositional, Diagenetic, Ecologic, \n\nPaleogeographic/paleogeologic, Provenance, Reservoir, Stratigraphic, \nOther use], MAX [3 ocorrences] \n\nDate date, [DD/MM/YYYY] \nPetrographer string(20) \nAxiomas: \n\u2022 Identification.BaseDepth >= Identification.TopDepth || Identification.BaseDepth = 0 \n\nConcept Microscopic \nIs-a Object \nPart-of Concept Sample \nGrainSize string(20), one-of [gravel, very coarse sand, coarse sand, medium sand, fine \n\nsand, very fine sand, silt, clay]  \nNumericGrainSize string(15), one-of [<number and metric unit(mm)> or&lt;number - number \n\nand metric unit(mm)>], range [0 - 100], [ex.: 23 mm, 12 - 21 mm] \nModalGrainSizes string(80), list-of [gravel, very coarse sand, coarse sand,  \n\nmedium sand, fine sand, very fine sand, silt, clay], MAX [4 ocorrences] \nNumericModalGrainSize string(15), list-of [<number and metric unit(mm)> or&lt;number - number \n\nand metric unit(mm)>], range [0 - 100], MAX [4 ocorrences], [ex.: 23 mm, \n12 - 21 mm] \n\nStructures string(90), list-of [parallel bedding, cross bedding, normal-graded  bedding, \nreverse-graded  bedding, massive bedding,  \nparallel lamination, climbing lamination, linser lamination,  \nflaser lamination, massive,  bioturbation, fluidized, load, folded, fractured, \nstylolites, nodules, crystalline, crusts, roots, spotted, vesicular, \namigdaloidal, flow, bioconstruction, bioacumulation], MAX [3 ocorrences] \n\nGravel real, range [0.0 - 100.00] \nSand real, range [0.0 - 100.00] \nMud real, range [0.0 - 100.00] \nSorting string(20), one-of [very well sorted, well sorted, moderately sorted, poorly \n\nsorted, very poorly sorted] \nNumericSorting real, range [0.0 - 100.00] \nRoundness string(20), one-of  [well rounded, rounded, sub-rounded, \n\nsub-angular, angular] \nRoundnessModifiers string(75), list-of [soft intraclasts, intraclasts, pressure dissolution, \n\ncorrosion, deformation, replacement, overgrowths],  \nMAX [3 ocorrences]. \n\nSphericity string(10), one-of [high, medium, low] \nOrientation string(20), one-of [parallel, imbricated,  homogeneous, heterogeneous, \n\noriented, chaotic] \nPacking string(15), one-of[loose, normal, tight] \n\n\n\n \n\n \n\n54 \n\nPackingIndex [real, range [0.0 - 55.00]] \nPointContacts string(10), one-of [abundant, common, rare, trace]  \n\nor [real, range [0.0 - 100.00]] \nSuturedContacts string(10), one-of [abundant, common, rare, trace]  \n\nor [real, range [0.0 - 100.00]] \nPointContacts string(10), one-of [abundant, common, rare, trace]  \n\nor [real, range [0.0 - 100.00]] \nConcaveConvexContacts string(10), one-of [abundant, common, rare, trace]  \n\nor [real, range [0.0 - 100.00]] \nSupport string(30), one-of [grain-supported, grain to matrix-supported, \n\ngrain to cement-supported, matrix-supported, \nmatrix to cement-supported, cement-supported] \n\nAxiomas: \nGravel + Sand + Mud = 0 || Gravel + Sand + Mud = 100 \nPointContacts + LongContacts + ConcavoConvexContacts + SuturedContacts = 0 || PointContacts + \nLongContacts + ConcavoConvexContacts + SuturedContacts = 0 \nRegras:  \n//Regras para Packing \n\u2022 IF PackingIndex&lt;= 40 THEN Packing = loose \n\u2022 IF PackingIndex > 40 AND PackingIndex&lt;= 55 THEN Packing = normal \n\u2022 IF PackingIndex > 55 THEN Packing = tigtht \n \n//Regras para Sorting \n\u2022 IF NumericSorting&lt;= 0.35 THEN Sorting = very well sorted \n\u2022 IF NumericSorting > 0.35 AND NumericSorting&lt;= 0.5 THEN Sorting = well sorted \n\u2022 IF NumericSorting > 0.5 AND NumericSorting&lt;= 0.7 THEN Sorting = moderately sorted \n\u2022 IF NumericSorting > 0.7 AND NumericSorting&lt;= 2 THEN Sorting = poorly sorted \n\u2022 IF NumericSorting > 2 THEN Sorting = very poorly sorted \n\nConcept Composition-Description \nIs-a Object \nPart-of Concept Sample \nObservations string(100) \n\nConcept Primary-Description \nIs-a Object \nPart-of Concept Composition-Description \nPrimaryComposition list-of [instance-of&lt;Concept Primary-Composition>] \n\nConcept Primary-Composition-Item \nIs-a Object \nPart-of Concept Primary-Description \nMineralName string(80), one-of [Primary-Constituent]. \nConstituentSet string(40), one-of [Detrital quartz, Detrital feldspar, Plutonic rock \n\nfragments, Volcanic rock fragments, Sedimentary rock fragments, \nMetamorphic rock fragments, Micas/chlorite, Heavy minerals, Intrabasinal \ngrains, Detrital matrix, Other detrital constituents] \n\nLocation string(40), one-of [in metamorphic rock fragment, in plutonic rock \nfragment, in sedimentary rock fragment, in volcanic rock fragment, in \nintrabasinal fragment, as monomineralic grain] \n\nAmount real, range [0.0 - 100.00] \nDescription string(256) \n\nConcept Primary-Constituents \nIs-a Object \nMineralName string(100), one-of [Acritarch, Aglutinant benthic foraminifer bioclast, \n\nAlgae bioclast undifferentiated, Alterite fragment, Amphibole, Amphibolite \nrock fragment, Andalusite, Annelid (worm) bioclast, Apatite, Argillaceous \nmud intraclast, Arthropod bioclast undifferentiated, Asteroid bioclast, \nBasic/ultrabasic plutonic rock fragment, Benthonic foraminifer bioclast, \nBlastoid bioclast, Bone undifferentiated, Brachiopod bioclast, Bryozoan \n\n\n\n \n\n \n\n55 \n\nbioclast, Carbonate pisolith, Carbonate sand intraclast, Cephalopod \nbioclast, Conodont bioclast, Crustacean bioclast, Detrital quartz, Detrital \nquartz polycrystalline, Detrital quartz polycrystalline stretched, Fish scale, \nGypsum monocrystalline detrital, Hornfelse rock fragment, Marl fragment, \nMeta-sandstone rock fragment, Mudstone fragment, Muscovite, Phosphate \ngrain, Phyllite rock fragment] \n\nConcept Diagenetic-Description \nIs-a Object \nPart-of Concept Composition-Description \nDiageneticComposition list-of [instance-of&lt;Concept Diagenetic-Composition>] \n\nConcept Diagenetic-Composition \nIs-a Object \nPart-of Concept Diagenetic-Description \nMineralName string(80), one-of  [Diagenetic-Constituent] \nHabit string(20), one-of [Blocky, Booklet, Botryoid, Bridge, \n\nCoarsely-crystalline, Coarse mosaic, Coating, Discrete crystal, \nFibro-radiated, Fibrous, Fine mosaic, Framboid, Ingrowth, Internal \nsediment, Lamella, Large rhomb, Massive, Meniscus, Microcrystalline, \nOoid, Outgrowth, Overgrowth, Parallel-prismatic, Pelletoid, Peloid, \nPigment, Poikilotopic, Prismatic, Prismatic-radiated, Radiated, Rim, \nRosette, Sheaf, Small rhomb, Spherulite, Vermicule] \n\nAmount real, range [0.0 - 100.00] \nLocation string(40), one-of [intergranular continous pore-lining, intergranular \n\ndiscontinous pore-lining, intergranular pore-filling, intergranular discrete, \nintergranular displacive, intragranular replacive, intragranular pore-lining, \nintragranular pore-filling, intragranular discrete crystals, intragranular \ndisplacive, moldic pore-lining, moldic pore-filling, oversized pore-lining, \noversized pore-filling, grain fracture-filling, grain fracture-lining, rock \nfracture-filling, rock fracture-lining, concretions/nodules, massive \nbeds/lenses] \n\nModifier string(40), one-of [dissolved, zoned, fractured, recrystallized] \nDescription string(256) \n\nConcept Diagenetic-Nomenclature \nIs-a Object \nMineralName list-of [instance-of &lt;Concept Diagenetic-Constituents >] \n\nConcept Diagenetic-Constituents \nIs-a Object \nMineralName string(80), one of [Albite, Analcime, Anhydrite, Aragonite, \n\nAttapulgite/sepiolite, Authigenic clay mineral undifferentiated, Baryte, \nBerthierine/chamosite, Bitumen, Bornite, Calcite, Carbonate pseudomatrix, \nCarbonate undifferentiated, Carnalite, Carnotite, Celadonite, Celestite, \nChabasite, Chalcedony, Chalcocite, Chalcopyrite, Chlorite, \nChlorite/smectite, Clay pseudomatrix, Collophane, Diagenetic amphibole, \nDiagenetic anatase, Diagenetic apatite, Diagenetic brookite, Diagenetic \ncarbonate, Diagenetic carbonate undifferentiated, Diagenetic clay \nundifferentiated, Diagenetic epidote] \n\n \n\n \n\n\n\n \n\n \n\n56 \n\n \n\nFigura 5.3: Conceitos do Sistema Petroledge (Adaptado de ABEL, 2001). \n\n\n\n \n\n \n\n57 \n\n \n\nFigura 5.4: Metamodelo de Grafo de Conhecimento para Interpreta\u00e7\u00e3o (ABEL, 2001). \n\n \n\n \n\nFigura 5.5: Exemplo de Grafo de Conhecimento (ABEL, 2001). \n\n\n\n \n\n \n\n58 \n\n5.1.2 Componentes de Tarefa e Inferencial \n\nO sistema Petroledge \u00e9 capaz de resolver automaticamente tarefas de interpreta\u00e7\u00e3o e \nclassifica\u00e7\u00e3o. Nessa valida\u00e7\u00e3o, somente a tarefa de interpreta\u00e7\u00e3o \u00e9 avaliada, pois ela \napresenta maior quantidade de infer\u00eancias, permitindo melhor compara\u00e7\u00e3o entre a \nimplementa\u00e7\u00e3o atual e a implementa\u00e7\u00e3o por k-aspects. \n\nA tarefa de interpreta\u00e7\u00e3o por grafos, descrita na Figura 5.6, conforme Abel (2001, p. \n170) ocorre da seguinte forma: \n\nOs dados da amostra s\u00e3o comparados sucessivamente a cada um dos grafos e, \nem cada um dos grafos, a cada um dos pacotes. O processo \u00e9 n\u00e3o \ndetermin\u00edstico. Dependendo das fei\u00e7\u00f5es que o usu\u00e1rio decidiu descrever, o \nsistema vai comparar sucessivamente com as respectivas fei\u00e7\u00f5es descritas \nnos pacotes dos grafos, cortando a busca sempre que for poss\u00edvel descartar \num pacote.  A conclus\u00e3o final \u00e9 definida pelo conjunto das interpreta\u00e7\u00f5es \nassociadas aos grafos validados. \n\nTAREFA  interpreta\u00e7\u00e3o de ambiente diagen\u00e9tico  por gera\u00e7\u00e3o e teste usando grafos de conhecimento; \n      PAPEIS:  \n  ENTRADA: caso: \"Amostra a ser interpretada\"; ; \n        conjunto de normas: \"Grafos de conhecimento\" \n  SAIDA:      interpreta\u00e7\u00e3o: \"Lista de ambientes diagen\u00e9ticos\";   \n FIM TAREFA  avalia\u00e7\u00e3o; \n \nM\u00c9TODO DA TAREFA interpreta\u00e7\u00e3o por encadeamento progressivo; \n REALIZA:  interpreta\u00e7\u00e3o; \n DECOMPOSI\u00c7\u00c3O: \n  INFERENCIAS : abstrai, seleciona, avalia, decomp\u00f5e, especifica, compara; \n PAPEIS: \n  INTERMEDI\u00c1RIOS: \n  caso-abstra\u00eddo: \"Dados da amostra selecionados pela interface\" \n  conceito-atributo-valor: \"\"Fei\u00e7\u00f5es geol\u00f3gicas\" \n  conjunto de normas:  \"Conjunto dos grafos de conhecimento \n  norma: \"Grafo selecionado para avalia\u00e7\u00e3o\" \n  express\u00f5es de dom\u00ednio: \"Pacotes visuais\" \n  express\u00e3o de dom\u00ednio: \"Pacote selecionado para compara\u00e7\u00e3o\" \n  pesos da express\u00e3o de dom\u00ednio: \"Peso do pacote no grafo\" \n  valor do conceito-atributo-valor: \"Fei\u00e7\u00e3o encontrada ou n\u00e3o encontrada\" \n  valor da express\u00e3o de dom\u00ednio:  \"Pacote encontrado ou n\u00e3o encontrado\" \n  valor da norma:  \"Grafo validado ou n\u00e3o validado\" \n ESTRUTURA DE CONTROLE: \n  abstrai (caso -> caso abstra\u00eddo)  \n ENQUANTO  TEM-GRAFOS  \n DO  \n  seleciona ( conjunto normas -> norma); \n  decomp\u00f5e (norma -> express\u00f5es de dom\u00ednio); \n  ENQUANTO TEM-PACOTES \n  DO  \n  seleciona (express\u00f5es de dom\u00ednio -> express\u00e3o de dom\u00ednio); \n  decomp\u00f5e (express\u00e3o de dom\u00ednio -> conjunto de conceito-atributo-valor) \n  ENQUANTO  valor do conceito-atributo-valor&lt;> falso \n  DO  \n   seleciona (conjunto de conceito-atributo-valor -> conceito-atributo-valor) \n   seleciona  (caso abstra\u00eddo -> conceito-atributo-valor) \n   se conceito-atributo-valor&lt;> nulo;     \"Usu\u00e1rio descreveu a fei\u00e7\u00e3o     \n                                                                                                      geol\u00f3gica\" \n   ent\u00e3o decomp\u00f5e (conceito-atributo-valor -> valores) \n    valor do conceito atributo valor := compara (valor = valores ) ; \n  valor da express\u00e3o de dom\u00ednio := valor do conceito atributo valor ; \n\n\n\n \n\n \n\n59 \n\n  calcula (valor norma := soma (pesos das express\u00f5es de dom\u00ednio) );  \n  se valor norma > limiar  \n     ent\u00e3o especifica (interpreta\u00e7\u00e3o := conclus\u00e3o da norma) \n  FIM ENQUANTO  \n  FIM ENQUANTO  \n FIM ENQUANTO  \nFIM METODO DA TAREFA interpreta\u00e7\u00e3o por encadeamento progressivo. \n\nFigura 5.6: Modelo da Tarefa de Interpreta\u00e7\u00e3o de Ambiente Diagen\u00e9tico (Adaptado \nde ABEL, 2001). \n\nEssa tarefa de interpreta\u00e7\u00e3o foi modelada usando o PSM de interpreta\u00e7\u00e3o por grafos \nde conhecimento. Cada PSM pode ser visto como uma solu\u00e7\u00e3o padr\u00e3o para determinada \ntarefa que n\u00e3o deve apresentar depend\u00eancias espec\u00edficas com a interpreta\u00e7\u00e3o realizada. \nPor exemplo, um PSM de interpreta\u00e7\u00e3o poderia ser aplicado para interpretar um \nambiente diagen\u00e9tico, mas tamb\u00e9m para interpretar quem \u00e9 o criminoso de uma hist\u00f3ria \npolicial. \n\nO modelo de infer\u00eancias usado nesse PSM (Figura 5.7) descreve como as \ninterpreta\u00e7\u00f5es s\u00e3o realizadas por uma sequ\u00eancia de infer\u00eancias: \n\n\u2022 A entrada para interpreta\u00e7\u00e3o desse modelo \u00e9 chamada de caso e corresponde \numa amostra descrita pelo usu\u00e1rio do sistema (Figura 5.7a);  \n\n\u2022 As fei\u00e7\u00f5es geol\u00f3gicas descritas (ex.: microscopia, composi\u00e7\u00e3o) s\u00e3o \nselecionadas de acordo com os grafos de interpreta\u00e7\u00e3o dispon\u00edveis (Figura \n5.7b);  \n\n\u2022 Cada grafo assume o papel de norma na infer\u00eancia. Cada um deles \u00e9 ent\u00e3o \nselecionado (Figura 5.7c) para avalia\u00e7\u00e3o;  \n\n\u2022 A avalia\u00e7\u00e3o \u00e9 feita pela decomposi\u00e7\u00e3o de cada grafo em pacotes (Figura \n5.7d). Cada pacote corresponde a uma premissa a ser validada;  \n\n\u2022 Os pacotes s\u00e3o selecionados um a um para compara\u00e7\u00e3o (Figura 5.7e); \n\n\u2022 Ao serem selecionados, os pacotes s\u00e3o decompostos (Figura 5.7f) em fei\u00e7\u00f5es \ngeol\u00f3gicas para que seja poss\u00edvel a compara\u00e7\u00e3o com as informa\u00e7\u00f5es \ndescritas pelo usu\u00e1rio (ex.: microscopia, composi\u00e7\u00e3o). A decomposi\u00e7\u00e3o gera \ntriplas com a assinatura&lt;conceito, atributo, valor>;  \n\n\u2022 As fei\u00e7\u00f5es oriundas dos pacotes e as fei\u00e7\u00f5es fornecidas pelo usu\u00e1rio s\u00e3o \nent\u00e3o comparadas (Figura 5.7g). Por exemplo, no grafo da Figura 5.5, uma \nfei\u00e7\u00e3o do pacote kaolinite cement \u00e9&lt;diagenetic composition, habit, \nlamella>. Essa fei\u00e7\u00e3o durante a infer\u00eancia \u00e9 comparada com as existentes no \ncaso fornecido pelo usu\u00e1rio;  \n\n\u2022 Caso o conjunto de fei\u00e7\u00f5es validadas seja superior ao limiar necess\u00e1rio para \nvalida\u00e7\u00e3o do grafo (Figura 5.7h), a interpreta\u00e7\u00e3o \u00e9 confirmada (Figura 5.7i).  \n\nOs modelos apresentados atualmente foram implementados no Petroledge usando uma \nsolu\u00e7\u00e3o ad-hoc, pois as metodologias para constru\u00e7\u00e3o de SCs n\u00e3o fornecem uma \nsolu\u00e7\u00e3o padr\u00e3o para a implementa\u00e7\u00e3o desses modelos na OO. A se\u00e7\u00e3o seguinte, 5.2, \napresenta a implementa\u00e7\u00e3o atual dos modelos descritos no sistema Petroledge para \nposterior avalia\u00e7\u00e3o.  \n\n\n\n \n\n \n\n60 \n\n \n\nFigura 5.7: Modelo de Infer\u00eancia do PSM de Interpreta\u00e7\u00e3o de Ambientes Diagen\u00e9ticos \n(ABEL, 2001). \n\n \n\n \n\n \n\nPapel de \nconhecimento \n\nA\u00e7\u00e3o de infer\u00eancia \n\nFluxo de dados e \n\nconhecimento \n\nConjuntos de  dados \n\ne conhecimento \n\nespecifica Interpreta\u00e7\u00e3o \n\nConceito-Atributo-\nValor \n\navalia \n\nValor do Conceito -\nAtributo-Valor \n\nNorma \n\nseleciona \n\nExpress\u00e3o de dom\u00ednio \n\nConjunto de Normas \n\nseleciona \n\nCaso \n\ndecomp\u00f5e \n\nConceito-Atributo-\nValores \n\nGrafos \n\nCaso abstra\u00eddo \n\nabstrai \n\nseleciona \n\nConceitos \n\nGrafos \n\nValor da  norma \n\ncompara \n\ngrafos \n\ngrafo \n\npacote \n\nExpress\u00f5es de dom\u00ednio \n(Premissas) \n\ndecomp\u00f5e \n\npacotes \n\nfei\u00e7\u00e3o \ngeol\u00f3gica \n\nV ou F \n\nAcima ou \nabaixo do \n\nLimiar \n\namostra \nde rocha \n\ndescri\u00e7\u00e3o \n\nfei\u00e7\u00e3o \ngeol\u00f3gica \n\nAmbiente \ndiagen\u00e9tico \n\n(c) \n\n(d) \n\n(e) \n\n(f) \n\n(g) \n\n(h) \n\n(a) \n\n(b) \n\n(i) \n\nLimiar \n\n\n\n \n\n \n\n61 \n\n5.2 Solu\u00e7\u00e3o Atual \nO sistema Petroledge \u00e9 desenvolvido no paradigma da OO. A solu\u00e7\u00e3o ad-hoc \n\natualmente utilizada para implementa\u00e7\u00e3o dos componentes do modelo conhecimento foi \ndesenvolvida ao longo do projeto do sistema. Os principais problemas identificados \nnessa solu\u00e7\u00e3o s\u00e3o os seguintes: \n\n\u2022 As estruturas definidas no modelo de conhecimento n\u00e3o s\u00e3o facilmente \nidentific\u00e1veis no c\u00f3digo-fonte da aplica\u00e7\u00e3o: n\u00e3o \u00e9 poss\u00edvel identificar \nfacilmente o c\u00f3digo-fonte que implementa os conceitos, atributos, facets, \naxiomas e regras. Por exemplo, no conjunto de duas mil classes dessa aplica\u00e7\u00e3o, \nn\u00e3o h\u00e1 marca\u00e7\u00e3o que identifique quais classes implementam conceitos e quais \nclasses implementam regras. A falta de marca\u00e7\u00e3o torna praticamente imposs\u00edvel \nrealizar a engenharia reversa do c\u00f3digo de modo que um Engenheiro de \nConhecimento possa verificar se o c\u00f3digo-fonte atende exatamente a \nespecifica\u00e7\u00e3o do modelo de conhecimento \n\n\u2022 Dispers\u00e3o de c\u00f3digo: o tratamento de facets, axiomas e regras precisa ser \nimplementado manualmente pelo engenheiro de desenvolvimento do sistema. \nPor exemplo, se um facet que limita o valor m\u00e1ximo \u00e9 especificado para um \natributo chamado idade, todos os pontos no software, em que a valor desse \natributo \u00e9 modificado precisam invocar o m\u00e9todo que valida se o valor \u00e9 inferior \nao valor m\u00e1ximo. Facilmente um engenheiro de desenvolvimento pode esquecer \nde definir essa invoca\u00e7\u00e3o e um ponto em que o valor \u00e9 modificado e gerar uma \ninconsist\u00eancia na implementa\u00e7\u00e3o do modelo. Por exemplo, se em um m\u00e9todo \nque modifica o valor do atributo idade, por falha do engenheiro de \ndesenvolvimento, n\u00e3o valida o valor, uma idade abaixo de zero poderia ser \natribu\u00edda; \n\n\u2022 Implementa\u00e7\u00e3o de PSMs dependem de mapeamentos entre modelo e \nrespectiva implementa\u00e7\u00e3o: as implementa\u00e7\u00f5es dos PSMs, devido a aus\u00eancia de \nmarca\u00e7\u00e3o no componente conceitual precisam fazer uso de mapeamentos \nelaborados manualmente pelos engenheiros de desenvolvimento. Por exemplo, \ncomo n\u00e3o \u00e9 poss\u00edvel extrair em tempo de execu\u00e7\u00e3o, o modelo abstrato (conceito, \natributo, valor) das pr\u00f3prias inst\u00e2ncias do modelo, \u00e9 necess\u00e1rio que o engenheiro \nde desenvolvimento forne\u00e7a uma tabela de mapeamento que identifique qual \nclasse implementa tal conceito e qual propriedade implementa tal atributo. Esse \nmapeamento \u00e9 bastante suscet\u00edvel a falhas. Se a implementa\u00e7\u00e3o do modelo for \nalterada (atributo renomeado) e o mapeamento n\u00e3o for atualizado, as tarefas \npodem ser realizadas incorretamente. Um atributo pode n\u00e3o ser encontrado e, \ncaso ele seja essencial para uma determinada interpreta\u00e7\u00e3o ou classifica\u00e7\u00e3o, a \ntarefa poder\u00e1 indicar um resultado incorreto; \n\n\u2022 Implementa\u00e7\u00e3o de PSM somente segue passos sequenciais: a implementa\u00e7\u00e3o \ndo PSM de interpreta\u00e7\u00e3o por grafos \u00e9 constitu\u00edda por uma sequ\u00eancia de \ninfer\u00eancias que s\u00e3o realizadas somente ap\u00f3s a finaliza\u00e7\u00e3o da descri\u00e7\u00e3o. Parte \ndessas infer\u00eancias (ex.: avalia), podem ser realizadas ao longo do preenchimento \ndas inst\u00e2ncias do componente conceitual (ex.: entrada de dados de microscopia,  \nde composi\u00e7\u00e3o), evitando que o usu\u00e1rio tenha que, ao final, aguardar a \nrealiza\u00e7\u00e3o de todas as infer\u00eancias. Por exemplo, atualmente, a realiza\u00e7\u00e3o de \ntodas infer\u00eancias leva aproximadamente dois minutos para ser completada. A \nimplementa\u00e7\u00e3o do PSM de classifica\u00e7\u00e3o sofre o mesmo problema, n\u00e3o explora a \n\n\n\n \n\n \n\n62 \n\natomicidade de certas infer\u00eancias, que podem ser realizadas antes da finaliza\u00e7\u00e3o \ndo preenchimento das inst\u00e2ncias do componente conceitual. \n\nPara melhor caracterizar os problemas, o detalhamento da implementa\u00e7\u00e3o atual \u00e9 \nmostrado a seguir. \n\n5.2.1 Implementa\u00e7\u00e3o do Componente do Modelo Conceitual sem K-Aspects \n\nA solu\u00e7\u00e3o atual utilizada para implementa\u00e7\u00e3o do componente do modelo conceitual \nsegue o seguinte mapeamento: \n\n\u2022 Conceitos s\u00e3o mapeados para classes. Entretanto, n\u00e3o h\u00e1 marca\u00e7\u00e3o nessas \nclasses para que haja distin\u00e7\u00e3o do seu papel em rela\u00e7\u00e3o a demais classes do SC; \n\n\u2022 Atributos s\u00e3o mapeados para propriedades de classes. Entretanto, n\u00e3o h\u00e1 \nmarca\u00e7\u00e3o que fa\u00e7a distin\u00e7\u00e3o entre propriedades que representam atributos e \npropriedades usadas para atender outros requisitos, por exemplo, auditoria e \nseguran\u00e7a; \n\n\u2022 Facets s\u00e3o implementados por m\u00e9todos de classes externas a pr\u00f3pria classe do \natributo que tem seu dom\u00ednio definido pelas facets. Utiliza-se a pattern validator \npara realiza\u00e7\u00e3o de valida\u00e7\u00f5es. Entretanto, o engenheiro de desenvolvimento deve \nobrigatoriamente invocar as valida\u00e7\u00f5es em todos os pontos do software que \npodem modificar o valor de um atributo. A invoca\u00e7\u00e3o em todos os pontos gera \ndispers\u00e3o de c\u00f3digo e \u00e9 bastante suscet\u00edvel a falhas, pois basta o engenheiro de \ndesenvolvimento esquecer uma valida\u00e7\u00e3o para o modelo ficar inconsistente; \n\n\u2022 Axiomas s\u00e3o implementados por m\u00e9todos localizados na pr\u00f3pria classe que \nrepresentam conceitos ou em classes externas (dificultando o rastreamento dos \naxiomas j\u00e1 implementados). A especifica\u00e7\u00e3o das express\u00f5es dos axiomas \ndefinidas no modelo precisa ser manualmente traduzida para c\u00f3digo-fonte pelo \nengenheiro de desenvolvimento. Essa convers\u00e3o \u00e9 suscet\u00edvel a falhas e n\u00e3o \npreserva o construto axioma, pois ele \u00e9 transformado para um m\u00e9todo. M\u00e9todos \ndos axiomas n\u00e3o s\u00e3o distingu\u00edveis de m\u00e9todos que implementam outras fun\u00e7\u00f5es, \nn\u00e3o h\u00e1 marca\u00e7\u00e3o para essa fun\u00e7\u00e3o; \n\n\u2022 Regras s\u00e3o implementadas por m\u00e9todos localizados nas pr\u00f3prias classes que \nrepresentam conceitos. Os m\u00e9todos das regras n\u00e3o s\u00e3o distingu\u00edveis de m\u00e9todos \nque implementam outras fun\u00e7\u00f5es, n\u00e3o h\u00e1 marca\u00e7\u00e3o para essa fun\u00e7\u00e3o. \n\nA Figura 5.8 e a Figura 5.9 mostram o c\u00f3digo-fonte parcial de duas classes que \nimplementam conceitos. Os coment\u00e1rios \u2018//Conceito e //Atributo\u2019 apenas identificam \nque a classe e suas propriedades representam o conceito e sues atributos; entretanto, s\u00e3o \napenas coment\u00e1rios textuais que facilmente podem ser esquecidos e tamb\u00e9m n\u00e3o s\u00e3o \ntipados, trazendo problemas para interpreta\u00e7\u00e3o desse modelo pelo computador. J\u00e1 os \ncoment\u00e1rios \u2018//PartOf, //Facet, //Axioma e //Regra\u2019 identificam pontos em que houve \nquebra na preserva\u00e7\u00e3o de estrutura, pois o construto do componente conceitual foi \ntransformado em valida\u00e7\u00f5es ou m\u00e9todos. Observa-se uma grande quantidade de \nchamadas de m\u00e9todos e valida\u00e7\u00f5es que s\u00e3o implementadas manualmente, essas \nchamadas e valida\u00e7\u00f5es implementam a sem\u00e2ntica dos facets, axiomas e regras definidas \nno modelo. Observando essas classes pode-se identificar claramente que todos os \nconstrutos para facets, axiomas e regras definidos no componente conceitual acabam \nsendo transformados manualmente para valida\u00e7\u00f5es e m\u00e9todos, tornando praticamente \nimposs\u00edvel a engenharia reversa dessa implementa\u00e7\u00e3o. Al\u00e9m disso, a necessidade de \n\n\n\n \n\n \n\n63 \n\nimplementa\u00e7\u00e3o manual aumenta consideravelmente o risco de o engenheiro de \ndesenvolvimento cometer um erro e n\u00e3o adicionar uma valida\u00e7\u00e3o especificada no \nmodelo.  \n\n//Conceito \npublic class ThinIdentificationImpl{ \n    private SampleImpl thinParent = null;  //PartOf  \n    private String strUnit = null;  //Atributo \n    private String strBasin = null; //Atributo \n    private Float fltTop = null; //Atributo \n    private Float fltBase = null; //Atributo \n    private List<String> colUses  = new ArrayList(); \n    //Demais atributos omitidos \n    public ThinIdentificationImpl(Thin parent) { \n        //PartOf \n        if (parent != null){ \n            thinParent = (Thin) parent; \n            thinParent.setThinIdentification(this); \n        } else { \n            throw new IllegalArgumentException(); \n        } \n    } \n    //Unit \n    public void setUnit(String unit) { \n        if (!validateUnit(unit)){ \n              throw new KnowledgeException() ; \n        } \n        strUnit = unit; \n    } \n    public String getUnit(){..} \n    //Basin \n    public void setBasin(String basin) { \n        if (!validateBasin(basin)){ \n              throw new KnowledgeException() ; \n        } \n        strBasin = basin; \n    } \n    public String getBasin(){..} \n    //TopDepth    \n    public void setTop(Float depth) { \n        if (!validateTop(depth)){ \n              throw new KnowledgeException() ; \n        } \n        fltTop = depth; \n    } \n    public Float getTop(){..}    } \n    //Uses \n    public void addUses(String use) { \n        if (!validateUse(use)){ \n              throw new KnowledgeException() ; \n        } \n        colUses.add(use); \n    } \n    //Parent  \n    public Parent getParent() {..} \n    //Demais m\u00e9todos set/get omitidos. \n} \n\n//Validator para o conceito ThinIdentification. \npublic class ThinIdentificationValidator{ \n    boolean validateUnit(String value) { \n         boolean isValid = true ; \n         isValid &amp;= (value == null ? false : true); //Facet \n         isValid &amp;= (value.length &lt;60); //Facet \n         isValid &amp;= value.match(\u201c[a-zA-Z]*-[0-9]\u201d); \n//Facet \n          return isValid ; \n    };     \n    boolean validateBasin(String value) { \n         boolean isValid = true ; \n         isValid &amp;= (value == null ? false : true); //Facet \n         isValid &amp;= (value.length &lt;40); //Facet \n         return isValid; \n    };     \n    boolean validateTop(Float value) { \n         boolean isValid = true ; \n         isValid &amp;= (value == null ? false : true); //Facet \n         isValid &amp;= (value &lt;0 ? false : true; //Facet \n         isValid &amp;= (value > 9999.99 ? false : true; //Facet \n         isValid &amp;= (value > fltBase?false:true); //Axioma   \n         return isValid ; \n    };     \n    boolean validateBase(Float value) { \n         boolean isValid = true ; \n         isValid &amp;= (value == null ? false : true ; //Facet \n         isValid &amp;= (value &lt;0 ? false : true ; //Facet \n         isValid &amp;= (value > 9999.99?false : true ; //Facet \n         isValid &amp;= (value &lt;fltTop ?false:true;) //Axioma \n         return isValid; \n    };     \n    boolean validateUses(String uses) { \n         Collection validValues = ThinDAO.getUses(); \n         if (colUses.size() == 3){ \n              throw new            KnowledgeException(\u2018M\u00e1ximo \natingido\u2019); \n         } \n         if ( !validUses.contains(uses)){return false ;} \n    };     \n    boolean validateField(String value) { \n         boolean isValid = true ; \n         isValid &amp;= (value == null ? false : true); //Facet \n         isValid &amp;= (value.length &lt;20); //Facet \n         return isValid; \n    };     \n    boolean validateOrigin(String value) {..};           \n    boolean validatePlace(String value) {..};     \n    boolean validateStage(String value) {..};     \n    boolean validateCountry(String value) {..};     \n    boolean validateCoreNumber(String value) {..};     \n    boolean validateBoxNumber(String value) {..};     \n    boolean validateSampleType(String value) {..};  \n} \n\nFigura 5.8: Fragmento da Implementa\u00e7\u00e3o Atual do Conceito ThinIdentification. \n\n \n\n\n\n \n\n \n\n64 \n\n \n\n//Conceito \npublic class MicroscopicImpl { \n     \n    private SampleImpl pdParent; //PartOf \n    private OntologyIntervalarValue<String> \noivGrainsize = null; \n    private OntologyIntervalarMetricValue<Float> \noimNumericGrainsize = null; \n    private TreeMap<Integer, \nOntologyIntervalarMetricValue<Integer>> mapScales = \nnew TreeMap(); \n    private TreeMap<Integer, String> mapStructures = \nnew TreeMap(); \n    private TreeMap<Integer, String> \nmapModalGrainSizes = new TreeMap(); \n    private TreeMap<Integer, String> \nmapRoundnessModifiers = new TreeMap(); \n    private TreeMap<Integer, Float> \nmapNumericModalGrainSizes = new TreeMap(); \n    private Float fltGravel = null; \n    private Float fltMud = null; \n    private Float fltSand = null; \n    private String odvSorting = null; \n    private Float fltSortingNumeric = null; \n    private String odvSupport = null; \n    private String odvPacking = null; \n    private Integer intPackingIndex = null; \n    private String odvPointContacts = null; \n    private Float fltPointContacts = null; \n     \n    /** Creates a new instance of MicroscopicImpl */ \n    public MicroscopicImpl(SampleImpl parent) { \n        setParent(parent);         \n    } \n    public void setGrainSize(  \n          OntologyIntervalarValue<String>  \n              grainsize) { \n        oivGrainsize = grainsize; \n    } \n    public void setScale(Integer importance,  \n            OntologyIntervalarMetricValue<Integer>  \n            scale) { \n       //Facets e axiomas no validator \n        if (mvValidator.validateScale(importance)){ \n            mapScales.put(importance, scale); \n        } else { \n            throw new IllegalArgumentException(); \n        } \n    }     \n    public void setStructure(Integer importance,   \n         String  structure) { \n       //Facets e axiomas no validator \n        if (mvValidator.validateStructure(importance)){ \n            mapStructures.put(importance, structure); \n        } else { \n            throw new IllegalArgumentException(); \n        } \n    } \n\n    public void setNumericModalGrainSize(Integer  \n        importance, Float grainsize) { \n        if (mvValidator. \n               validateNumericModalGrainSize(importance)){ \n             mapNumericModalGrainSizes.put(importance,   \n             grainsize) } else { \n            throw new IllegalArgumentException(); \n        } \n    } \n    public void setRoundnessModifier(Integer   \n       importance, String roundnessmodifier) { \n       //Facets e axiomas no validator \n        if (mvValidator. \n              validateRoundnessModifier(importance)){ \n                  mapRoundnessModifiers.put(importance,   \n                     oundnessmodifier); \n        } else { \n            throw new IllegalArgumentException(); \n        } \n    } \n     \n    public void setPackingIndex (Integer index) { \n        intPackingIndex = index; \n        //Regra \n         if (intPackingIndex&lt;= 40){ \n            instance.setPacking(MicroscopicD2D(). \n                    getPackingByName(\"loose\")); \n        }else if(intPackingIndex > 40  \n                        &amp;&amp; intPackingIndex&lt;= 55){ \n            instance.setPacking(MicroscopicD2D(). \n                    getPackingByName(\"normal\")); \n        }else if(intPackingIndex > 55){ \n               setPacking( \n                  MicroscopicD2D(). \n                         getPackingByName(\"tight\")); \n         } \n    }         \n    public void setPointContacts(String contact) { \n        odvPointContacts = contact; \n        //Axioma \n        if (fltPointContacts + fltSuturedContacts +  \n             fltConcaveConvexContacts + fltLongContact !=   \n             100){ \n                    throw new RuntimeException(\u2018Knowledge  \n                   Violation\u2019 ) ; \n  } \n    } \n    public void setPointContactsPercentage(Float  \n       percentage) { \n        fltPointContacts = percentage; \n    } \n    public void setSupport(String support) { \n        odvSupport = support; \n    } \n    public Parent getParent() { \n        return pdParent; \n   }   \n      //Demais m\u00e9todos omitidos       \n\nFigura 5.9: Fragmento da Implementa\u00e7\u00e3o Atual do Conceito Microscopic. \n\n\n\n \n\n \n\n65 \n\n5.2.2 Implementa\u00e7\u00e3o dos Componentes de Tarefa e Inferencial sem K-Aspects \n\nA implementa\u00e7\u00e3o do componente de tarefa atualmente tamb\u00e9m engloba o \ncomponente inferencial. Esse acoplamento entre os dois componentes ocorre porque a \nimplementa\u00e7\u00e3o atual realiza todas as infer\u00eancias somente ao final do preenchimento das \ninst\u00e2ncias do componente conceitual e n\u00e3o explora a possibilidade de realizar parte \ndelas ao longo do pr\u00f3prio preenchimento. As infer\u00eancias s\u00e3o vistas como sub-elementos \ndo componente de tarefa, algo que reduz a reusabilidade das mesmas. Esse alto \nacoplamento ocorre porque elas acabam sendo implementadas por m\u00e9todos que fazem \nparte da pr\u00f3pria implementa\u00e7\u00e3o do componente de tarefa.  \n\n \n\nFigura 5.10: Diagrama de Sequ\u00eancia da Implementa\u00e7\u00e3o do PSM de Interpreta\u00e7\u00e3o. \n\nPara facilitar a compreens\u00e3o da implementa\u00e7\u00e3o do PSM para interpreta\u00e7\u00e3o por \ngrafos e devido \u00e0 extens\u00e3o do c\u00f3digo-fonte desse PSM, optou-se por apresentar o \ndigrama de sequ\u00eancia (Figura 5.10) atual dessa tarefa para posterior compara\u00e7\u00e3o com a \nabordagem por k-aspects. \n\nA realiza\u00e7\u00e3o da tarefa somente inicia quando o usu\u00e1rio solicita a interpreta\u00e7\u00e3o de \numa determinada amostra. A interpreta\u00e7\u00e3o inicialmente obt\u00e9m todos os modelos de \ninterpreta\u00e7\u00e3o (os grafos de interpreta\u00e7\u00e3o existentes) e seleciona sequencialmente cada \num dos grafos. Para cada grafo, um conceito \u00e9 selecionado e decomposto em atributo, \nesses atributos s\u00e3o decompostos at\u00e9 uma lista de valores. Para cada atributo, pelo menos \n\n\n\n \n\n \n\n66 \n\num valor precisa ser encontrado na amostra para que ele seja validado (os valores \ncorrespondem a evid\u00eancias de interpreta\u00e7\u00f5es). A infer\u00eancia avalia \u00e9 respons\u00e1vel por \nverificar se o valor existe na amostra. Para avaliar e validar o valor, o mapeamento entre \nimplementa\u00e7\u00e3o e modelo abstrato, elaborado manualmente pelo engenheiro de \ndesenvolvimento, \u00e9 utilizado. Esse mapeamento, na implementa\u00e7\u00e3o atual, indica em \nqual tabela e campo do banco de dados est\u00e1 localizado o valor procurado, para ent\u00e3o ser \nprocurado. Esse mapeamento aponta para o banco de dados para utilizar os mecanismos \nde consultas dispon\u00edveis nos bancos de dados e evitar que o engenheiro de \ndesenvolvimento tenha que utilizar uma s\u00e9rie de chamadas por reflex\u00e3o estrutural \u00e0 \ninst\u00e2ncia que est\u00e1 sendo validada. \n\nQuando todos os atributos s\u00e3o avaliados como V, o conceito \u00e9 considerado validado. \nSe a soma dos pesos dos conceitos for superior ao limiar determinado para a \ninterpreta\u00e7\u00e3o (infer\u00eancia compara), a interpreta\u00e7\u00e3o \u00e9 considerada v\u00e1lida. Caso contr\u00e1rio, \na interpreta\u00e7\u00e3o n\u00e3o \u00e9 validada e n\u00e3o \u00e9 apresentada para o usu\u00e1rio. Todas interpreta\u00e7\u00f5es \nvalidadas s\u00e3o apresentadas ao usu\u00e1rio no final do processo. Atualmente, em um \nambiente de produ\u00e7\u00e3o em que o sistema opera, esse processo leva em m\u00e9dia dois \nminutos para ser realizado, devido \u00e0 lat\u00eancia do banco de dados e ao grande n\u00famero de \nconsultas realizadas para a valida\u00e7\u00e3o de cada interpreta\u00e7\u00e3o (grafo). \n\n5.3 Solu\u00e7\u00e3o com K-Aspects \nOs problemas definidos na se\u00e7\u00e3o 5.2 podem ser reduzidos/eliminados com o uso da \n\nabordagem k-aspect. O uso de anota\u00e7\u00f5es para marca\u00e7\u00e3o do c\u00f3digo-fonte referente a \nimplementa\u00e7\u00e3o do modelo de conhecimento permite a distin\u00e7\u00e3o clara dos elementos \noriundos desse modelo. Al\u00e9m disso, o uso de aspectos para tratamento da sem\u00e2ntica \ndesses construtos elimina a dispers\u00e3o de c\u00f3digo relacionada ao tratamento das \nfuncionalidades transversais a pr\u00f3pria implementa\u00e7\u00e3o do modelo.  \n\nTabela 5.2: Quantidade de Funcionalidades Transversais Tratadas via Aspectos. \n\nConceito Tratamentos via Aspectos \nThinIdentification 120 \n\nMicroscopic 263 \nMacroscopic 84 \n\nDiageneticComposition-Item 47 \nPrimaryComposition-Item 33 \n\nPoreComposition-Item 39 \nTotal 93 \n\nAdditionalAnalysis 9 \nPoreSystem 13 \n\nA Figura 5.11, obtida a partir da biblioteca AspectJ, mostra a implementa\u00e7\u00e3o de tr\u00eas \nconceitos do componente conceitual. Para cada classe, as linhas que apresentam \ndiferentes tons de cinza mostram pontos em que aspectos est\u00e3o agindo e eliminando a \nnecessidade de implementa\u00e7\u00e3o manual do engenheiro de desenvolvimento. Linhas em \nque m\u00faltiplos tons s\u00e3o apresentados indicam que mais de um aspecto est\u00e1 atuando nessa \nlinha. Os aspectos detectados s\u00e3o apresentados na legenda da figura, cada um com uma \ncor diferente. As regi\u00f5es sombreadas s\u00e3o pontos do c\u00f3digo em que funcionalidades \ntransversais foram encapsuladas via aspectos, eliminando a necessidade de \n\n\n\n \n\n \n\n67 \n\nimplementa\u00e7\u00e3o manual pelo engenheiro de desenvolvimento. As por\u00e7\u00f5es em branco s\u00e3o \npontos em que funcionalidades transversais n\u00e3o foram detectadas, nessa implementa\u00e7\u00e3o, \ncorrespondem principalmente aos m\u00e9todos getters (m\u00e9todos que retornam valores de \npropriedades), nos quais n\u00e3o \u00e9 feita nenhuma valida\u00e7\u00e3o, nem axiomas e regras s\u00e3o \naplicados. Para demonstrar o impacto positivo do uso dessa abordagem, a Tabela 5.2 \napresenta para implementa\u00e7\u00f5es de conceitos, o n\u00famero de pontos em que \nfuncionalidades transversais (valida\u00e7\u00f5es de facets, axiomas, aplica\u00e7\u00f5es de regras, \nrealiza\u00e7\u00e3o de infer\u00eancias) foram tratadas por aspectos, evitando que o engenheiro de \ndesenvolvimento tivesse que implementar manualmente chamada a m\u00e9todos ou \nvalida\u00e7\u00f5es. \n\nConsidera-se o tratamento das facets, axiomas e regras como funcionalidades \ntransversais a implementa\u00e7\u00e3o do modelo. A implementa\u00e7\u00e3o do modelo deve apenas ser \nrespons\u00e1vel por refletir os construtos do pr\u00f3prio modelo, a sem\u00e2ntica deve ser tratada \nvia aspectos, evitando tarefas manuais e repetitivas de implementa\u00e7\u00e3o. \n\n \n\nFigura 5.11: Aspectos identificados na implementa\u00e7\u00e3o de tr\u00eas conceitos. \n\n5.3.1 Implementa\u00e7\u00e3o do Componente do Modelo Conceitual com K-Aspects  \n\nA implementa\u00e7\u00e3o do componente do modelo conceitual usando k-aspects reduz \nsignificativamente o c\u00f3digo-fonte de implementa\u00e7\u00e3o do modelo, j\u00e1 que o engenheiro de \ndesenvolvimento n\u00e3o mais precisa implementar manualmente as valida\u00e7\u00f5es e chamadas \na m\u00e9todos para tratar regras, axiomas e etc. O tratamento todo \u00e9 feito via aspectos, j\u00e1 \npreviamente fornecidos como biblioteca.  \n\n\n\n \n\n \n\n68 \n\nAs classes de valida\u00e7\u00f5es, constru\u00eddas pelo engenheiro de desenvolvimento, para \ncada conceito s\u00e3o eliminadas, j\u00e1 que as valida\u00e7\u00f5es passam a ser realizadas pela \nbiblioteca de tratamento de facets, axiomas e regras. As classes oriundas da \nimplementa\u00e7\u00e3o do componente conceitual s\u00e3o claramente identific\u00e1veis a partir das \nanota\u00e7\u00f5es utilizadas e podem ser recuperadas em tempo de execu\u00e7\u00e3o pela pr\u00f3pria \naplica\u00e7\u00e3o. A obten\u00e7\u00e3o dessas anota\u00e7\u00f5es em tempo de execu\u00e7\u00e3o \u00e9 necess\u00e1ria para o \ntratamento adequado das anota\u00e7\u00f5es. Por exemplo, quando a anota\u00e7\u00e3o \n@FacetValidValues apresenta a propriedade source preenchida, em tempo de execu\u00e7\u00e3o \no sistema precisa recuperar o valor de source, para ent\u00e3o obter todos os valores v\u00e1lidos \npara um determinado atributo. \n\nA Figura 5.12 e a Figura 5.13 apresentam implementa\u00e7\u00f5es de dois conceitos usando \nk-aspects e k-annotations. Pode-se observar que todas as chamadas a validators foram \neliminadas. Al\u00e9m disso, as valida\u00e7\u00f5es, execu\u00e7\u00e3o de regras e execu\u00e7\u00e3o de axiomas que \neram implementadas diretamente nos m\u00e9todos set (modificam valores de atributo) \nforam todas suprimidas. Essas supress\u00f5es s\u00e3o poss\u00edveis pelo uso de aspectos, j\u00e1 que s\u00e3o \nesses que passam a tratar esses pontos, evitando que o engenheiro de desenvolvimento \ntenha que faz\u00ea-los manualmente. \n\nNa Figura 5.13 pode-se identificar que uma classe adicional \n(MicroscopicPackingRules) foi criada para implementar as regras aplicadas sobre o \natributo Packing. Recomenda-se que regras aplicadas sobre um mesmo atributo sejam \nimplementadas em uma mesma classe e o nome dessa classe identifique o atributo a \nqual a regra aplica-se. Essa pr\u00e1tica facilita a identifica\u00e7\u00e3o das regras aplicadas sobre \ncada conceito/rela\u00e7\u00e3o/atributo. Deve-se tamb\u00e9m evitar a cria\u00e7\u00e3o de uma \u00fanica classe \nque implemente todas as regras para um determinado conceito/rela\u00e7\u00e3o, pois a \ncentraliza\u00e7\u00e3o em uma \u00fanica classe pode dificultar o rastreamento das regras \nimplementadas. \n\n@Concept \n@PartOf(SampleImpl.class) \n@Axiom(specification=\"(ThinIdentification.TopDepth&lt;= \nThinIdentification.BaseDepth ) || ( ThinIdentification.BaseDepth == 0 )\") \npublic class ThinIdentification { \n     @FacetNotNull \n     SampleImpl thinParent = null;    \n \n    @Attribute \n    @FacetMaxLength(length=20) \n    String thinID = \"\"; \n     \n    @Attribute \n    @FacetPattern(pattern=\"[a-zA-Z]*-[0-9]\") \n    @FacetMaxLength(length=60) \n    String unit = \"\"; \n     \n    @Attribute \n    @FacetMaxLength(length=40) \n    String basin = \"\"; \n     \n    @Attribute \n    @FacetMaxLength(length=20) \n    String field = \"\"; \n     \n    @Attribute \n    @FacetMaxLength(length=20) \n    String well = \"\"; \n\n    /** Creates a new instance */ \n    public ThinIdentification(    \n      SampleImpl parent){     \n        setParent(parent); \n    } \n     \n    public String getUnit() { \n        return unit; \n    } \n    public void setUnit(String u) { \n        unit = u; \n    } \n     \n    public String getBasin() { \n        return basin; \n    } \n    public void setBasin(String b)    \n    { \n        basin = b; \n    } \n     \n    public String getField() { \n        return field; \n    } \n    public void setField(String f) { \n       field = f; \n    } \n     \n\n\n\n \n\n \n\n69 \n\n     \n    @Attribute \n    @FacetMaxExclusive(9999.99f) \n    @FacetMinExclusive(0f) \n    Float topDepth = 0f; \n     \n    @Attribute \n    @FacetMaxInclusive(9999.99f) \n    @FacetMinInclusive(0f) \n    Float baseDepth = 0f;    \n     \n    @Attribute \n    @FacetMaxLength(length=40)     \n    String place = \"\";     \n     \n    @Attribute \n    @FacetMaxCardinality(cardinality = 3) \n    @FacetDuplicateFree \n    @FacetValidValues(values={\"Depositional\", Diagenetic\", \n\"Ecologic\",\"Provenance\", \"Reservoir\", \"Stratigraphic\", \"Other use\"}) \n    List<String> use = new ArrayList<String>(); \n     \n    @Attribute \n    @FacetMaxLength(length=20) \n    String petrographer = \"\"; \n     \n    @Attribute \n    @FacetPattern(pattern=\"[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]\") \n    String date = \"\";    \n\n    public String getWell() { \n        return well; \n    } \n    public void setOrigin(String  \n        o)   \n    { \n        well = o; \n    } \n     \n    public Float getBase() { \n        return base; \n    } \n    public void setBase(Float depth) { \n        base = depth; \n    } \n     \n    public Float getTop() { \n        return top; \n    }     \n    public void setTop(Float depth) { \n        top = depth; \n    }     \n} \n \n\nFigura 5.12: Fragmento da Implementa\u00e7\u00e3o com K-Aspects do Conceito \nThinIdentification. \n\n@Concept \n@PartOf(SampleImpl.class) \n@Axioms( axioms = { \n     @Axiom(expression=\"( Microscopic.Gravel +  \n     Microscopic.Sand + Microscopic.Mud == 100 ) ||  \n     (Microscopic.Gravel + Microscopic.Sand +  \n     Microscopic.Mud == 0 )\"), \n     @Axiom(expression=\" \n          ( ( ( ThinIdentification.BaseDepth > 4000 ) &amp;&amp;  \n                ( Microscopic.Gravel > 10 ) ) ||  \n          ( ( ThinIdentification.BaseDepth&lt;= 4000 ) &amp;&amp; \n             ( Microscopic.Gravel&lt;= 10 ) ))\") \n}) \n@Rules({@Rule(MicroscopicPackingRules.class),  \n @Rule(MicroscopicSortingRules.class)} \n) \npublic class Microscopic{ \n    @Attribute \n    @FacetMaxInclusive(100f) \n    @FacetMinInclusive(0f) \n    Float gravel = 0f; \n     \n    @Attribute \n    @FacetMaxInclusive(100f) \n    @FacetMinInclusive(0f)     \n    Float mud = 0f; \n     \n    @Attribute \n    @FacetMaxInclusive(100f) \n\n    @Attribute \n    @FacetValidValues(source= \n        MicroscopicValueProvider.class) \n    String longContacts = null; \n    @FacetMaxInclusive(100f) \n    @FacetMinInclusive(0f)         \n    Float nLongContacts = 0f; \n               \n    @Attribute \n    @FacetMinCardinality(cardinality=0) \n    @FacetMaxCardinality(cardinality=3) \n    @FacetDuplicateFree \n    TreeMap<Integer,  \n          OntologyIntervalarMetricValue<Integer>> scales \n= new TreeMap(); \n     \n    @Attribute \n    @FacetMinCardinality(cardinality=0) \n    @FacetMaxCardinality(cardinality=3) \n    @FacetDuplicateFree \n    TreeMap<Integer, String> structures = new \nTreeMap();     \n    @Attribute \n    @FacetMinCardinality(cardinality=0)      \n    @FacetMaxCardinality(cardinality=3) \n    @FacetDuplicateFree \n    TreeMap<Integer, String> roundnessModifiers = new \nTreeMap(); \n     \n\n\n\n \n\n \n\n70 \n\n    @FacetMinInclusive(0f)     \n    Float sand = 0f; \n     \n    @Attribute \n    @FacetValidValues(source= \n       MicroscopicSupportValueProvider.class) \n    String support = null; \n     \n    @Attribute \n    @FacetValidValues(source= \n        MicroscopicValueProvider.class) \n    String sorting = null; \n     \n    @Attribute \n    Float numericSorting = null; \n         \n    @Attribute \n    @FacetValidValues(source= \n        MicroscopicValueProvider.class) \n    String roundness = null; \n         \n    @Attribute \n    @FacetValidValues(source= \n        MicroscopicValueProvider.class) \n    String orientation = null; \n    @Attribute \n    @FacetValidValues(source= \n        MicroscopicValueProvider.class) \n    String packing = null;  \n \n    @Attribute \n    @FacetMaxInclusive(100) \n    @FacetMinInclusive(0)        \n    Integer packingIndex = null; \n \n    @Attribute \n    @FacetValidValues(source= \n        MicroscopicValueProvider.class) \n    String pointContacts = null; \n    @FacetMaxInclusive(100f) \n    @FacetMinInclusive(0f)      \n    Float nPointContacts = 0f; \n\n    @Attribute  \n    @FacetMinCardinality(cardinality=0)      \n    @FacetMaxCardinality(cardinality=4) \n    @FacetDuplicateFree \n    TreeMap<Integer, String> modalGrainSizes = new \nTreeMap(); \n        \n    @Attribute \n    @FacetMinCardinality(cardinality=0)      \n    @FacetMaxCardinality(cardinality=3) \n    @FacetDuplicateFree \n    TreeMap<Integer, Float> numericModalGrainSizes = \nnew TreeMap();            \n \n    //Getters/setters omitidos, pois s\u00e3o apenas \natribui\u00e7\u00f5es \n} \n \n//Regras \npublic class MicroscopicPackingRules { \n    public MicroscopicPackingRules(){   \n    }  \n    public void runRules(Map context) throws \nException{ \n        MicroscopicImpl instance =  \n             context.get(\"instance\"); \n        Integer packingIndex =  \n             instance.getPackingIndex(); \n        if (packingIndex&lt;= 40){ \n            instance.setPacking(MetaModelDAOFactory. \n                 getMicroscopicD2D(). \n                    getPackingByName(\"loose\")); \n        }else if(packingIndex > 40  \n                        &amp;&amp; packingIndex&lt;= 55){ \n            instance.setPacking(MetaModelDAOFactory. \n                getMicroscopicD2D(). \n                    getPackingByName(\"normal\")); \n        }else if(packingIndex > 55){ \n               instance.setPacking( \n                  MetaModelDAOFactory.               \n                     getMicroscopicD2D(). \n                         getPackingByName(\"tight\")); \n         } \n    } \n} \n\nFigura 5.13: Fragmento da Implementa\u00e7\u00e3o com K-Aspects do Conceito Microscopic. \n\n5.3.2 Implementa\u00e7\u00e3o dos Componentes de Tarefa e Inferencial com K-Aspects \n\nA implementa\u00e7\u00e3o dos componentes de tarefa e inferencial buscou explorar a \npossibilidade de realizar infer\u00eancias em paralelo ao preenchimento da inst\u00e2ncia de \namostra de rocha pelo usu\u00e1rio e tamb\u00e9m aumentar a reusabilidade das infer\u00eancias \nimplementadas no projeto de valida\u00e7\u00e3o dessa proposta. \n\nPara tratar a realiza\u00e7\u00e3o das infer\u00eancias em paralelo ao preenchimento da inst\u00e2ncia da \namostra de rocha, optou-se por utilizar aspectos. Os aspectos evitam a dispers\u00e3o de \nc\u00f3digo que realizaria a chamada a classes e respectivos m\u00e9todos que implementam as \ninfer\u00eancias necess\u00e1rias para a interpreta\u00e7\u00e3o. Essas chamadas precisariam ser inseridas \nem todos os pontos do software em que valores da inst\u00e2ncia da amostra corrente sofrem \n\n\n\n \n\n \n\n71 \n\nmodifica\u00e7\u00f5es. Por exemplo, para a realiza\u00e7\u00e3o da infer\u00eancia de avalia\u00e7\u00e3o, que valida o \nvalor esperado para o atributo (definido no modelo de cada interpreta\u00e7\u00e3o) com o valor \nexistente na inst\u00e2ncia, todo ponto do software que modifica valor de atributo precisaria \nchamar as infer\u00eancias de avalia\u00e7\u00e3o para verificar o novo valor encontrado. \n\nAl\u00e9m disso, al\u00e9m dos aspectos que realizam infer\u00eancias (ex.: MatchAspect e \nEvaluateAspect), foi criado um aspecto para cada tipo de tarefa (ex.: \nInterpretationTaskAspect, ClassificationTaskAspect). Esses aspectos s\u00e3o necess\u00e1rios \npara realizar a conclus\u00e3o das tarefas e organizar a exibi\u00e7\u00e3o dos resultados ao usu\u00e1rio. \nPor exemplo, o aspecto referente \u00e0 tarefa de interpreta\u00e7\u00e3o \u00e9 respons\u00e1vel por verificar \ntodos os gr\u00e1ficos validados e prepar\u00e1-los para exibi\u00e7\u00e3o ao usu\u00e1rio, como essa valida\u00e7\u00e3o \n\u00e9 custosa, pois requer a verifica\u00e7\u00e3o de uma lista de conceitos e somat\u00f3rio de pesos, esse \naspecto pode ser configurado para ser acionado somente a cada dez ou x modifica\u00e7\u00f5es \nde valores de atributos (evitando verifica\u00e7\u00f5es  repetitivas a cada modifica\u00e7\u00e3o de valor). \nRecomenda-se a cria\u00e7\u00e3o de um aspecto para cada tarefa e deve-se evitar a realiza\u00e7\u00e3o de \ninfer\u00eancias nesses aspectos, eles devem utilizar os resultados das infer\u00eancias realizadas \npelos aspectos de cada infer\u00eancia. \n\nA realiza\u00e7\u00e3o da tarefa de interpreta\u00e7\u00e3o usando essa abordagem, evitando \nmapeamentos manuais (o pr\u00f3prio modelo abstrato \u00e9 fornecido atrav\u00e9s das anota\u00e7\u00f5es e \nacess\u00edvel em tempo de execu\u00e7\u00e3o), evitando acessos ao banco de dados para realiza\u00e7\u00e3o \nde infer\u00eancias e evitando que as infer\u00eancias sejam realizadas somente ao final do \npreenchimento da inst\u00e2ncia de amostra rocha, permitiu uma redu\u00e7\u00e3o significativa no \ntempo de realiza\u00e7\u00e3o dessas tarefas. O tempo foi reduzido para a m\u00e9dia de 20 segundos \n(implementa\u00e7\u00e3o atual tem m\u00e9dia de 2 minutos). A avalia\u00e7\u00e3o de desempenho detalhada \nn\u00e3o \u00e9 o foco desse trabalho. \n\nEssa organiza\u00e7\u00e3o em m\u00faltiplos aspectos para uma determinada tarefa visa explorar \nmelhor a concorr\u00eancia poss\u00edvel nessas tarefas e melhorar a reusabilidade de cada \ninfer\u00eancia. Os aspectos que implementam tarefas e infer\u00eancias fazem parte da biblioteca \ndesse trabalho, mas podem ser estendidos conforme as necessidades de cada projeto. \n\nA se\u00e7\u00e3o 5.3.3 apresenta os benef\u00edcios trazidos pela implementa\u00e7\u00e3o do Petroledge \nusando K-Aspects em compara\u00e7\u00e3o com a solu\u00e7\u00e3o original, ad-hoc. A se\u00e7\u00e3o 5.4 define os \nbenef\u00edcios e limita\u00e7\u00f5es da abordagem K-Aspects em termos gerais, quando aplicada a \ndiferentes projetos de SCs \n\n5.3.3 Benef\u00edcios da Implementa\u00e7\u00e3o do Petroledge usando K-Aspects \n\nA implementa\u00e7\u00e3o do Petroledge usando K-Aspects em compara\u00e7\u00e3o a solu\u00e7\u00e3o \noriginal, ad-hoc trouxe os seguintes benef\u00edcios: \n\n\u2022 Redu\u00e7\u00e3o de dispers\u00e3o e linhas de c\u00f3digo: o uso de aspectos para o tratamento \nda sem\u00e2ntica associada aos construtos dos componentes do conhecimento \nimpactaram diretamente na dispers\u00e3o de c\u00f3digo relacionado ao tratamento \ndesses construtos. Conforme apresentado na Tabela 5.2, 701 pontos para \ntratamento de funcionalidades transversais foram identificados. A \nimplementa\u00e7\u00e3o na solu\u00e7\u00e3o ad-hoc apresentava 4437 linhas, j\u00e1 a implementa\u00e7\u00e3o \nusando K-Aspects reduziu o n\u00famero de linhas para 2718, uma redu\u00e7\u00e3o de 38%. \nEssa significativa redu\u00e7\u00e3o \u00e9 devido \u00e0 elimina\u00e7\u00e3o da necessidade do engenheiro \nde desenvolvimento manualmente implementar m\u00e9todos e classes relacionadas \nao tratamento de facets, axiomas, regras e infer\u00eancias. Todos esses m\u00e9todos e \ngrande parte das classes foram encapsulados em bibliotecas para reuso em outros \n\n\n\n \n\n \n\n72 \n\nprojetos. A invoca\u00e7\u00e3o dessas bibliotecas passa a ser inserida automaticamente no \nc\u00f3digo interpretado atrav\u00e9s da biblioteca de aspectos, tamb\u00e9m fornecida com \nessa proposta. A redu\u00e7\u00e3o de linhas de c\u00f3digo e centraliza\u00e7\u00e3o do c\u00f3digo de \ntratamento em uma \u00fanica biblioteca pode reduzir o custo de manuten\u00e7\u00e3o do \nsistema, pois, caso um problema seja identificado em um tratamento, basta \napenas corrigi-lo na biblioteca. Na solu\u00e7\u00e3o ad-hoc, devido a pontos de \nduplica\u00e7\u00e3o, um problema poderia se repetir em diversos pontos e exigir \nm\u00faltiplas corre\u00e7\u00f5es. Destaca-se que a porcentagem de redu\u00e7\u00e3o pode ser ainda \nmaior quando o modelo possui um grande n\u00famero de facets, axiomas e regras \nassociados, pois cada elemento adicional implicaria em novas linhas de c\u00f3digo \nimplementadas manualmente na solu\u00e7\u00e3o ad-hoc, o que n\u00e3o acontece quando \nutilizado K-Aspects; \n\n\u2022 Aumento da rastreabilidade entre modelo e implementa\u00e7\u00e3o: a utiliza\u00e7\u00e3o de \nanota\u00e7\u00f5es para marcar as implementa\u00e7\u00f5es dos componentes de conhecimento do \nPetroledge permite que facilmente seja poss\u00edvel rastrear a implementa\u00e7\u00e3o \nresultante a partir de um elemento do modelo. Por exemplo, para rastrear a \nimplementa\u00e7\u00e3o de um axioma em um determinado conceito, basta procurar a \npr\u00f3pria especifica\u00e7\u00e3o do axioma no c\u00f3digo-fonte, pois n\u00e3o h\u00e1 transforma\u00e7\u00e3o \nentre a especifica\u00e7\u00e3o e sua implementa\u00e7\u00e3o. Para rastrear uma rela\u00e7\u00e3o, basta \nlocalizar a anota\u00e7\u00e3o @Relation que tenha como nome a rela\u00e7\u00e3o que se deseja \nencontrar. Aumentando a rastreabilidade, mais facilmente \u00e9 poss\u00edvel identificar \ninconformidade entre o modelo e o c\u00f3digo, pois basta localizar as estruturas \nusando as estruturas como refer\u00eancia; \n\n\u2022 Gera\u00e7\u00e3o autom\u00e1tica de documenta\u00e7\u00e3o: na solu\u00e7\u00e3o ad-hoc era praticamente \nimposs\u00edvel extrair documenta\u00e7\u00e3o espec\u00edfica \u00e0 implementa\u00e7\u00e3o do modelo de \nconhecimento. A documenta\u00e7\u00e3o gerada era compreens\u00edvel somente aos \nengenheiros de desenvolvimento, pois os construtos definidos no modelo n\u00e3o \neram mantidos na implementa\u00e7\u00e3o e acabam sendo transformados em classes, \npropriedades e m\u00e9todos. Com o uso da ferramenta KA-DocGen, a documenta\u00e7\u00e3o \ndo modelo de conhecimento pode ser gerada automaticamente, essa \ndocumenta\u00e7\u00e3o \u00e9 compreens\u00edvel tamb\u00e9m ao engenheiro de conhecimento, pois os \nconstrutos definidos no modelo e as estruturas desse modelo s\u00e3o mantidos e \napresentados na documenta\u00e7\u00e3o gerada pela ferramenta; \n\n\u2022 Aumento da comunica\u00e7\u00e3o entre engenheiros de conhecimento e de \ndesenvolvimento: a defini\u00e7\u00e3o de um conjunto de anota\u00e7\u00f5es que utiliza a mesma \nnomenclatura utilizada no modelo de conhecimento facilita a comunica\u00e7\u00e3o entre \nos engenheiros de conhecimento e de desenvolvimento. Esses \u00faltimos passam a \npoder utilizar no c\u00f3digo-fonte os mesmos construtos conhecidos pelos \nengenheiros de conhecimento. Desse modo, o mesmo vocabul\u00e1rio passa a ser \nutilizado por esses dois grupos de participantes; \n\n\u2022 Segmenta\u00e7\u00e3o de realiza\u00e7\u00e3o das tarefas: a organiza\u00e7\u00e3o das infer\u00eancias em \naspectos passou a permitir que, ao longo do pr\u00f3prio preenchimento das \ninst\u00e2ncias do modelo, possa-se acionar automaticamente a realiza\u00e7\u00e3o de algumas \ninfer\u00eancias. Esse acionamento permite segmentar a realiza\u00e7\u00e3o das tarefas, pois \nboa parte da mesma \u00e9 realizada ao longo do preenchimento da inst\u00e2ncia, \nreduzindo o processamento necess\u00e1rio ao final do preenchimento para que a \ntarefa seja realizada e o resultado exibido ao usu\u00e1rio. O sistema passou a ter a \n\n\n\n \n\n \n\n73 \n\ncapacidade de exibir resultados de tarefas ao longo do pr\u00f3prio preenchimento. \nEssa segmenta\u00e7\u00e3o atrav\u00e9s de aspectos n\u00e3o exigiu a implementa\u00e7\u00e3o de chamadas \nexpl\u00edcitas para a realiza\u00e7\u00e3o de infer\u00eancia. Por exemplo, o uso de aspectos evita \nque para toda modifica\u00e7\u00e3o de valor de atributo, seja necess\u00e1rio explicitamente \ninvocar a infer\u00eancia abstrai; \n\n\u2022 Reuso de infer\u00eancias: a organiza\u00e7\u00e3o de parte das infer\u00eancias em uma biblioteca \nevita que elas sejam reimplementadas em diferentes pontos do sistema, causando \nduplica\u00e7\u00e3o de c\u00f3digo. O reuso permite que uma vez testada e validada uma \ninfer\u00eancia, ela possa ser usada em diferentes pontos, sem necessidade de novos \ntestes. Essa redu\u00e7\u00e3o na quantidade de testes e valida\u00e7\u00f5es colabora para reduzir o \ncusto de desenvolvimento e manuten\u00e7\u00e3o do sistema. \n\nOs benef\u00edcios citados mostram que a implementa\u00e7\u00e3o usando K-Aspects colabora \npara a redu\u00e7\u00e3o de tarefas manuais na etapa de desenvolvimento e garante maior \nrastreabilidade entre modelos e implementa\u00e7\u00f5es. A manuten\u00e7\u00e3o da coer\u00eancia entre \nmodelo e implementa\u00e7\u00e3o \u00e9 um ponto fundamental de um projeto de SC, pois os \nrequisitos tendem a mudar frequentemente e os engenheiros de desenvolvimento devem \nser capazes de refletir essas mudan\u00e7as no c\u00f3digo, sem demandar um longo per\u00edodo de \ndesenvolvimento ou revis\u00e3o. A gera\u00e7\u00e3o autom\u00e1tica de documenta\u00e7\u00e3o facilita o processo \nde revis\u00e3o da implementa\u00e7\u00e3o e ap\u00f3ia a comunica\u00e7\u00e3o entre engenheiros de conhecimento \ne de desenvolvimento. A otimiza\u00e7\u00e3o do processo de implementa\u00e7\u00e3o colabora para a \nredu\u00e7\u00e3o de custos de projeto de SC.   \n\n5.4 Sum\u00e1rio do Cap\u00edtulo 5 \nA compara\u00e7\u00e3o das abordagens apresentadas nas se\u00e7\u00f5es anteriores permite identificar \n\nos seguintes benef\u00edcios relacionados \u00e0 abordagem k-aspects: \n\n\u2022 Suporte aos construtos do modelo conhecimento e preserva\u00e7\u00e3o das \nestruturas: o conjunto de k-annotations desenvolvido nessa proposta permite \nque os construtos do componente conceitual sejam preservados na \nimplementa\u00e7\u00e3o OO. As anota\u00e7\u00f5es identificam as estruturas definidas nos \ncomponentes do modelo de conhecimento claramente no c\u00f3digo-fonte da \naplica\u00e7\u00e3o. Por exemplo, a anota\u00e7\u00e3o @Concept permite que a implementa\u00e7\u00e3o de \num conceito seja reconhecida imediatamente pelo engenheiro de \ndesenvolvimento e tamb\u00e9m permite que um programa fa\u00e7a esse reconhecimento. \nJ\u00e1 que essa anota\u00e7\u00e3o est\u00e1 dispon\u00edvel em tempo de execu\u00e7\u00e3o e pode ser \nrecuperada atrav\u00e9s de reflex\u00e3o estrutural; \n\n\u2022 Elimina\u00e7\u00e3o da dispers\u00e3o de c\u00f3digo relacionado aos construtos do modelo de \nconhecimento: a utiliza\u00e7\u00e3o de aspectos para tratar as funcionalidades \ntransversais exigidas para implementar a sem\u00e2ntica dos construtos de facets, \naxiomas e regras elimina o problema de dispers\u00e3o de c\u00f3digo existente na solu\u00e7\u00e3o \natual. Todo o c\u00f3digo que era implementado manualmente pelo engenheiro de \ndesenvolvimento para o tratamento dos construtos citados, passa a ser gerado \nautomaticamente pelo costurador (ferramenta que conecta os m\u00f3dulos da \naplica\u00e7\u00e3o com os aspectos para que as funcionalidades transversais sejam \ndisponibilizadas nos pontos da aplica\u00e7\u00e3o especificados nos pointcuts); \n\n\u2022 Tratamento padronizado de Facets, Axiomas e Regras: essa abordagem \nfornece uma biblioteca padr\u00e3o para o tratamento de facets, axiomas e regras. \n\n\n\n \n\n \n\n74 \n\nEssa biblioteca pode ser reutilizada em diversos projetos, evitando duplica\u00e7\u00e3o de \nc\u00f3digo e diminuindo o risco de problemas relacionados a ela, j\u00e1 que ela foi \npreviamente validada e n\u00e3o foi desenvolvida ao longo de um \u00fanico projeto de \nSC; \n\n\u2022 Reusabilidade de Bibliotecas: as bibliotecas de anota\u00e7\u00f5es, tratamento de \nanota\u00e7\u00f5es e aspectos foram concebidas para serem reutilizadas em diferentes \nprojetos de SC, pois tratam construtos do modelo de conhecimento e n\u00e3o s\u00e3o \ndependentes do dom\u00ednio de aplica\u00e7\u00e3o do sistema; \n\n\u2022 Gera\u00e7\u00e3o autom\u00e1tica de documenta\u00e7\u00e3o: a marca\u00e7\u00e3o clara dos elementos do \nmodelo de conhecimento no c\u00f3digo-fonte e a possibilidade de recupera\u00e7\u00e3o \ndesses dados atrav\u00e9s de reflex\u00e3o estrutural permitem que uma ferramenta de \ngera\u00e7\u00e3o de documenta\u00e7\u00e3o espec\u00edfica ao modelo de conhecimento seja \ndisponibilizada. Desse modo, o engenheiro de conhecimento pode mais \nfacilmente revisar o modelo e suas respectiva implementa\u00e7\u00e3o, reduzindo os \nriscos de problemas de conformidade; \n\n\u2022 Explora\u00e7\u00e3o da concorr\u00eancia para infer\u00eancias evitando dispers\u00e3o de c\u00f3digo: \no uso de aspectos permite que infer\u00eancias sejam realizadas ao longo do \npreenchimento das inst\u00e2ncias do modelo pelo usu\u00e1rio, evitando que todas sejam \nrealizadas somente ao final do preenchimento. Isso visa aperfei\u00e7oar a realiza\u00e7\u00e3o \ndas tarefas sem exigir que uma s\u00e9rie de chamadas manuais sejam inseridas no \nsistema, gerando uma grande dispers\u00e3o de c\u00f3digo, muitas vezes duplicado em \ndiferentes pontos. Al\u00e9m disso, a realiza\u00e7\u00e3o das infer\u00eancias sobre a pr\u00f3pria \ninst\u00e2ncia do modelo no paradigma OO evita que mapeamentos tenham que ser \nfeitos para outros paradigmas (ex.: relacional) gerando uma carga adicional de \nmanuten\u00e7\u00e3o desses mapeamentos durante a etapa de manuten\u00e7\u00e3o/evolu\u00e7\u00e3o de \num SC; \n\n\u2022 Encapsulamento da implementa\u00e7\u00e3o do modelo de infer\u00eancias: a \nimplementa\u00e7\u00e3o de cada infer\u00eancia como aspecto permite que elas sejam reusadas \npor diferentes projetos e diferentes tarefas. De fato, elas s\u00e3o realizadas, \npreviamente a tarefa, desse modo, a tarefa que precisa dos resultados dessas \ninfer\u00eancias j\u00e1 os ter\u00e1 dispon\u00edveis quando for acionada, pois os aspectos das \ninfer\u00eancias s\u00e3o acionados antes das mesmas. Isso ocorre porque as tarefas podem \nser configuradas para serem executadas somente ap\u00f3s um certo n\u00famero de \nmodifica\u00e7\u00f5es nas inst\u00e2ncias do modelo, permitindo que infer\u00eancias sejam \nrealizadas previamente; \n\n\u2022 Simplifica\u00e7\u00e3o de Testes de SCs: as vantagens citadas acima impactam \npositivamente na defini\u00e7\u00e3o de testes para os componentes do modelo de \nconhecimento. A identifica\u00e7\u00e3o clara dos componentes do modelo e a redu\u00e7\u00e3o de \ndispers\u00e3o de c\u00f3digo facilita a cria\u00e7\u00e3o de testes unit\u00e1rios para os mesmos. A \npr\u00f3pria especifica\u00e7\u00e3o do modelo identifica uma s\u00e9rie de caracter\u00edsticas que \npodem ser testadas unitariamente. Por exemplo, se na especifica\u00e7\u00e3o o modelo \ndefine que um atributo n\u00e3o pode ter valores acima de 100, pode-se criar um teste \nunit\u00e1rio que tenta preencher o atributo com um valor maior que 100. Esse teste \ndeve esperar que uma exce\u00e7\u00e3o seja lan\u00e7ada nesse caso. Caso n\u00e3o ocorra exce\u00e7\u00e3o, \nidentifica-se uma falha na implementa\u00e7\u00e3o e, nessa abordagem, essa falha indica \na aus\u00eancia da anota\u00e7\u00e3o @FacetMaxInclusive(100). J\u00e1 que o tratamento da \nanota\u00e7\u00e3o \u00e9 parte de uma biblioteca previamente validada. A verifica\u00e7\u00e3o entre o \n\n\n\n \n\n \n\n75 \n\nmodelo e sua implementa\u00e7\u00e3o tamb\u00e9m \u00e9 facilitada pela gera\u00e7\u00e3o autom\u00e1tica de \nc\u00f3digo, que reduz a necessidade de revis\u00e3o diretamente em c\u00f3digo. Testes em \nrela\u00e7\u00e3o a tarefas continuam a demandar casos reais de problemas fornecidos pelo \nespecialista do dom\u00ednio do SC, para que o sistema aponte a solu\u00e7\u00e3o e ent\u00e3o esta \nseja comparada com a resposta previamente fornecida pelo especialista; \n\n\u2022 Simplifica\u00e7\u00e3o da Manuten\u00e7\u00e3o de SCs: as vantagens citadas acima tamb\u00e9m \nimpactam positivamente no processo de manuten\u00e7\u00e3o de SCs. A identifica\u00e7\u00e3o \nclara, o encapsulamento dos componentes do modelo e a gera\u00e7\u00e3o autom\u00e1tica de \ndocumenta\u00e7\u00e3o facilitam a manuten\u00e7\u00e3o dos mesmos, pois quando \ninconformidades s\u00e3o detectadas nesses componentes, s\u00e3o mais rapidamente \nrastreados tanto pelos engenheiros de desenvolvimento quanto pelos engenheiros \nde conhecimento. Os engenheiros de desenvolvimento passam a compartilhar o \nvocabul\u00e1rio dos engenheiros de conhecimento (por exemplo, conceito, atributo e \nn\u00e3o mais classe e propriedade), melhorando a comunica\u00e7\u00e3o para resolu\u00e7\u00e3o de \nquaisquer d\u00favidas associadas \u00e0 manuten\u00e7\u00e3o desses componentes. A redu\u00e7\u00e3o da \ndispers\u00e3o de c\u00f3digo e gera\u00e7\u00e3o de c\u00f3digo tamb\u00e9m evita que um problema \ndetectado esteja replicado em diversos outros componentes, pois parte de tarefas \nrepetitivas manuais foram substitu\u00eddas pela gera\u00e7\u00e3o autom\u00e1tica; \n\nApesar dos diversos benef\u00edcios existentes no uso dessa abordagem, deve-se destacar \nalgumas limita\u00e7\u00f5es que devem ser levadas em considera\u00e7\u00e3o por projetos que optem por \nutiliz\u00e1-la: \n\n\u2022 Dificuldade de depura\u00e7\u00e3o: o processo de costura insere uma quantidade \nsignificativa de c\u00f3digo referente aos diversos aspectos. Esse c\u00f3digo n\u00e3o \u00e9 \nvisualiz\u00e1vel claramente pelos engenheiros de desenvolvimento, pois ele \u00e9 gerado \nsomente ap\u00f3s a compila\u00e7\u00e3o do c\u00f3digo inicial. Desse modo, em certos casos, \npode haver certa dificuldade em realizar a depura\u00e7\u00e3o do c\u00f3digo. Essas limita\u00e7\u00f5es \ns\u00e3o inerentes ao paradigma OA e existem em todos os projetos que o utilizam. \nTodo novo paradigma exige um exerc\u00edcio mental dos engenheiros de \ndesenvolvimento, para que ele seja corretamente assimilado e seu potencial seja \ncorretamente utilizado. Espera-se, que a evolu\u00e7\u00e3o desse paradigma ofere\u00e7a \nmelhores ferramentas para o tratamento da depura\u00e7\u00e3o; \n\n\u2022 Evolu\u00e7\u00e3o/manuten\u00e7\u00e3o das bibliotecas: a evolu\u00e7\u00e3o/manuten\u00e7\u00e3o das bibliotecas \ndesenvolvidas nessa proposta pode impactar nos projetos que fazem uso de \nvers\u00f5es anteriores dessas bibliotecas. Desse modo, assim como qualquer outra \nbiblioteca, a evolu\u00e7\u00e3o deve manter ao m\u00e1ximo as fun\u00e7\u00f5es que as vers\u00f5es pr\u00e9vias \nofereciam, sem exigir manuten\u00e7\u00e3o no c\u00f3digo que faz uso delas. Por exemplo, as \nbibliotecas que comp\u00f5em a linguagem Java, ao evolu\u00edrem de vers\u00e3o, mant\u00eam \ntodas as fun\u00e7\u00f5es que existiam anteriormente, mesmo que essas fun\u00e7\u00f5es sejam \nestendidas, as funcionalidades pr\u00e9-existentes continuam apresentando o mesmo \ncomportamento.  \n\n\n\n \n\n \n\n76 \n\n6 CONCLUS\u00c3O \n\nProjetos de SCs envolvem altos custos e riscos. Mesmo com a exist\u00eancia de uma \ns\u00e9rie de metodologias para a realiza\u00e7\u00e3o desses projetos, identificou-se uma lacuna na \netapa de desenvolvimento desse tipo de sistema: diferentes linguagens e metodologias \ns\u00e3o propostas para a constru\u00e7\u00e3o do modelo de conhecimento, mas nenhuma delas \noferece uma solu\u00e7\u00e3o padr\u00e3o para a implementa\u00e7\u00e3o desse modelo no paradigma mais \nutilizado na \u00e1rea de desenvolvimento de software, o paradigma OO. \n\nEsse trabalho definiu uma proposta padr\u00e3o, chamada de k-aspects para a \nimplementa\u00e7\u00e3o do modelo de conhecimento no paradigma OO utilizando os recursos \nprovidos pela OA. O uso de OA visa melhor tratar as funcionalidades transversais \nreferentes ao tratamento da implementa\u00e7\u00e3o do modelo de conhecimento, evitando \ndispers\u00e3o e duplica\u00e7\u00e3o de c\u00f3digo, antes manualmente inserido pelos engenheiros de \ndesenvolvimento. Esses tratamentos se referem \u00e0 sem\u00e2ntica de cada construtor utilizado \nnesse tipo de modelo e tamb\u00e9m ao tratamento de tarefas que SCs precisam realizar.  \n\nTarefas necessitam de uma s\u00e9rie de infer\u00eancias para serem realizadas e essas \ninfer\u00eancias podem ser utilizadas por diferentes tarefas. Desse modo, permitir que elas \nsejam reutilizadas evita custos relacionados \u00e0 manuten\u00e7\u00e3o de c\u00f3digo duplicado e \naumenta a reusabilidade dos componentes em diferentes projetos. \n\nO uso de anota\u00e7\u00f5es visa fornecer o pr\u00f3prio modelo abstrato da implementa\u00e7\u00e3o junto \n\u00e0 sua implementa\u00e7\u00e3o, para que infer\u00eancias que dependem desse modelo possam ser \nrealizadas no pr\u00f3prio paradigma OO, sem necessidade de mapeamentos. Al\u00e9m disso, as \nanota\u00e7\u00f5es permitem a defini\u00e7\u00e3o de construtos n\u00e3o suportados nativamente pela OO  \nnesse paradigma. O suporte a esses construtos \u00e9 essencial para que as estruturas \ndefinidas no modelo de conhecimento sejam facilmente identific\u00e1veis na \nimplementa\u00e7\u00e3o resultante, facilitando o processo de manuten\u00e7\u00e3o de coer\u00eancia entre \nmodelos e respectivas implementa\u00e7\u00f5es. \n\nAs bibliotecas constru\u00eddas nesse trabalho organizam um conjunto de anota\u00e7\u00f5es, \naspectos e componentes que tratam elementos comuns a diferentes projetos de SC, por \nexemplo, tratamento de facets, axiomas e infer\u00eancias. As bibliotecas dessa proposta, \nindependentes de um projeto espec\u00edfico de SC, oferecem uma base de elementos para a \nconstru\u00e7\u00e3o de SCs, evitando m\u00faltiplas implementa\u00e7\u00f5es para o tratamento de uma \nmesma funcionalidade. O uso dessas bibliotecas, validadas anteriormente em projetos \nde SC, reduz os riscos associados a solu\u00e7\u00f5es ad-hocs e tamb\u00e9m reduz os riscos \nassociados a uma nova implementa\u00e7\u00e3o a cada projeto, por exemplo, exist\u00eancia bugs. \nEspera-se que a utiliza\u00e7\u00e3o dessa biblioteca em diferentes projetos facilite a comunica\u00e7\u00e3o \nentre as equipes de desenvolvimento e os engenheiros de conhecimento, j\u00e1 que os \ntermos utilizados buscam aumentar a rastreabilidade entre os modelos e suas \nimplementa\u00e7\u00f5es. \n\n\n\n \n\n \n\n77 \n\nEspera-se que k-aspects e o conjunto de bibliotecas elaboradas nesse trabalho sejam \nutilizados como solu\u00e7\u00e3o de base para diferentes SCs que utilizem o paradigma OO, \nevitando-se os riscos e problemas associados a solu\u00e7\u00f5es ad-hoc. \n\n6.1 Trabalhos Futuros \nA proposta de K-Aspects foi desenvolvida tendo como base diferentes linguagens \n\npara modelagem de conhecimento. Apesar de uma s\u00e9rie de construtos serem suportados \npor essa proposta, a an\u00e1lise detalhada das principais linguagens dispon\u00edveis para \nmodelagem de conhecimento pode identificar a necessidade de novas k-annotations e \nextens\u00f5es das bibliotecas de tratamento dos construtos. \n\nFerramentas para constru\u00e7\u00e3o de modelos de conhecimento, como Prot\u00e9g\u00e9 poderiam \nser estendidas para suportar a gera\u00e7\u00e3o de c\u00f3digo em diferentes linguagens OO. A \ngera\u00e7\u00e3o automatizada de c\u00f3digo pode reduzir a tarefa manual de implementa\u00e7\u00e3o dos \ncomponentes do modelo na linguagem OO. \n\nA valida\u00e7\u00e3o desse trabalho foi realizada em um SC de grande porte que faz amplo \nuso dos construtos do modelo de conhecimento, mas novas caracter\u00edsticas \neventualmente poderiam ser identificadas em outros projetos. Desse modo, a biblioteca \nde tratamento de facets, axiomas e regras pode requerer novas funcionalidades \nidentific\u00e1veis pela valida\u00e7\u00e3o dessa proposta em outros projetos de SCs. \n\nEspecificamente a implementa\u00e7\u00e3o das regras definidas no componente conceitual \nainda \u00e9 convertida manualmente para a linguagem OO usada no desenvolvimento do \nSC. Uma linguagem para defini\u00e7\u00e3o de regras e uma biblioteca para o parser e avalia\u00e7\u00e3o \ndessas regras evitaria a tarefa manual de convers\u00e3o, muito suscet\u00edvel a erros e de dif\u00edcil \nengenharia reversa para compara\u00e7\u00e3o com a regra especificada no modelo. \n\n \n\n\n\n \n\n \n\n78 \n\nREFER\u00caNCIAS \n\nABEL, M. Estudo da Per\u00edcia em Petrografia Sedimentar e sua Import\u00e2ncia para a \nEngenharia de Conhecimento. Porto Alegre: UFRGS, 2001. 239 f. Tese (Doutorado) \n\u2013 Programa de P\u00f3s-Gradua\u00e7\u00e3o em Computa\u00e7\u00e3o, Universidade Federal do Rio Grande \ndo Sul, Porto Alegre, 2001. \n\nANGELE, J. et al. Developing Knowledge-Based Systems with MIKE. Automated \nSoftware Engg. v. 5, n. 2, p. 389-418, out. 1998. \n\nANNOTATIONS. [S.l.]: Sun Microsystems, 2004. Dispon\u00edvel em: \n<http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html>. Acesso em: 20 \nfev. 2006. \n\nANTONIOU, G.; HARMELEN, F.V. Web ontology language: OWL. Handbook on \nontologies. Berlin: Springer-Verlag, 2004. p. 67-92. \n\nAUER, S. Towards Agile Knowledge Engineering: Methodology, Concepts and \nApplications. Leipzig: Universidade de Leipzig, 2006. 156 f. Tese (Doutorado), \nUniversidade de Leipzig, Leipzig, 2006. \n\nBASSILIADES, N.; VLAHAVAS, I. R-DEVICE: An Object-Oriented Knowledge \nBase System for RDF Metadata. International Journal on Semantic Web and \nInformation Systems, v. 2, n. 2, p. 24-90, 2006. \n\nBRACHMAN, R.; LEVESQUE, H. Knowledge Representation and Reasoning. \nMorgan Kaufmann Publishers Inc, 2004. \n\nBRICKLEY, D.; GUHA, R.V. Resource description framework (RDF) schema \nspecification 1.0. In W3C, 2000. Dispon\u00edvel em:&lt;http://www.w3.org/TR/2000/CR-rdf-\nschema-20000327/>. Acesso em: 15 fev. 2009. \n\nBROMBY, M.; MACMILLAN, M.; MCKELLAR, P. A CommonKADS \nRepresentation for a Knowledge-based System to Evaluate Eyewitness Identification. \nInternational Review of Law, Computers &amp; Technology, vol. 17, n. 1, p. 99-108, \nmar. 2003. \n\nCACHO, N. et al.. Improving modularity of reflective middleware with aspect oriented \nprogramming. In: INTERNATIONAL WORKSHOP ON SOFTWARE \nENGINEERING AND MIDDLEWARE, 6., SEM\u201906, 2006, Portland, Proceedings\u2026 \nNew York: ACM, 2006, p. 31-38. \n\nCASTRO, E.S.E.; VICTORETI, F.; FIORINI, S.; ABEL, M; PRICE, R.T. Um Caso de \nIntegra\u00e7\u00e3o de Gerenciamento \u00c1gil de Projetos \u00e0 Metodologia CommonKADS. In: \n\n\n\n \n\n \n\n79 \n\nWORKSHOP DE GER\u00caNCIA DE PROJETO DE SOFTWARE, 1., WGPS\u201908, 2008, \nFlorian\u00f3polis, Proceedings... Florian\u00f3polis: [s.n], 2008, p. 1-4. \n\nCASTRO, E.S.E.; ABEL, M; PRICE, R.T. K-Annotations: An Approach for \nConceptual Knowledge Implementation using Metadata Annotations. In: \nINTERNATIONAL CONFERENCE ON ENTERPRISE INFORMATION SYSTEMS, \n11., ICEIS\u201909, 2009, Mil\u00e3o, Proceedings\u2026 [S.l.:s.n], 2009 (TO BE PUBLISHED). \n\nCHALMETA, R. and GRANGEL, R. Methodology for the implementation of \nknowledge management systems. Journal of American Society for Information \nScience and Technology, vol. 59, n. 5,  p. 742-755, mar. 2008. \n\nCIBR\u00c1N, M.A.; D'HONDT, M.; JONCKERS, V.. Aspect-oriented programming for \nconnecting business rules. In: INTERNATIONAL CONFERENCE ON BUSINESS \nINFORMATION SYSTEMS, 6., BIS\u201903, 2003, Colorado Springs, USA, Proceedings... \n[S.l.:s.n], 2003, p. 1-6.  \n\nCIBR\u00c1N, M.A.; D'HONDT, M.; SUV\u00c9E, D. Linking business rules to object-oriented \nsoftware using JAsCo. Journal of Computational Methods in Sciences and \nEngineering, vol. 5, n. 1, p. 13-27, IOS, 2005.  \n\nCOVER, R. XML and semantic transparency. [S.l.:s.n], 1998. Dispon\u00edvel em \n<http://www.oasis-open.org/cover/xmlAndSemantics.html>. Acesso em: 10 abr. 2008. \n\nCHUNA, C. A.; SOBRAL, J. L.; MONTEIRO, M. P. Reusable aspect-oriented \nimplementations of concurrency patterns and mechanisms. In: INTERNATIONAL \nCONFERENCE ON ASPECT-ORIENTED SOFTWARE DEVELOPMENT, 5., \nAOSD\u201906, 2006, Bonn, Germany, Proceedings... New York: ACM, 2006, p. 134-145. \n\nDEMERS, F. N.; MALENFANT, J. Reflection in logic, functional and object-oriented \nprogramming: a short comparative study. In: WORKSHOP ON REFLECTION AND \nMETALEVEL AND THEIR APPLICATIONS in ARTIFICIAL INTELLIGENCE, 1., \nIJCAI '95, 1995, Quebec, Proceedings... [S.l.:s.n], 1995, p. 29-38. \n\nDEMEYER, S.; DUCASSE, S.; TICHELAAR, S. Why unified is not universal: UML \nshortcomings for coping with round-trip engineering. In: INTERNATIONAL \nCONFERENCE ON THE UNIFIED MODELING LANGUAGE, 2., UML\u201999, 1999, \nFort Collins, USA, Proceedings... [S.l.]: Springer-Verlag, 1999, p. 630-645. \n\nD'HONDT, M.; MEUTER, W.D.; WUYTS, R. Using Reflective Logic Programming to \nDescribe Domain Knowledge as an Aspect. In: INTERNATIONAL SYMPOSIUM ON \nGENERATIVE AND COMPONENT-BASED SOFTWARE ENGINEERING, 1., \nGCSE\u201999, 1999, Erfurt, Germany, Proceedings... London: K. Czarnecki and U. W. \nEisenecker, Eds. Lecture Notes In Computer Science, vol. 1799, Springer-Verlag, 2000, \np. 16-23. \n\nERIKSSON, H. Using aspect-oriented programming to extend prot\u00e9g\u00e9. In: International \nProt\u00e9g\u00e9 Conference, 7., 2004, Maryland. Proceedings... Maryland: [s.n], 2004. \n\nFIKES, R.; KEHLER, T. The role of frame-based representation in reasoning. \nCommunications of the ACM, [S.I.], v. 238, n. 9, p. 904-920, 1985. \n\nFILMAN, R. E. Applying Aspect-Oriented Programming to Intelligent Synthesis. \nTechnical Report. UMI Order Number: 00000047., RIACS, 2000. \n\nFOWLER, M. Analysis Patterns: Reusable Object Models. Addison-Wesley, 1997. \n\n\n\n \n\n \n\n80 \n\nFOWLER, M. Refactoring. Improving the Design of Existing Code. Addison-\nWesley, 1999. \n\nGENNARI, J.H. et al. The evolution of Prot\u00e9g\u00e9: an environment for knowledge-based \nsystems development. International Journal of Human-Computer Studies, vol. 58, \nn. 1, p. 89-123, 2003. \n\nGUIA do Usu\u00e1rio Petroledge. [S.l.]: ENDEEPER, 2009. Dispon\u00edvel em \n<http://www.endeeper.com/customer_area/Guia_Usuario_PETROLEDGE.pdf>. Acesso \nem: 20 abr. 2009. \n\nJAVA Expression Grammar. Singular Systems, 2009. Dispon\u00edvel em &lt;\nhttp://www.singularsys.com/jep >.  Acesso em: 20 abr. 2009. \n\nJSR220A: Enterprise JavaBeans Specification, v3.0, EJB Core Contracts and \nRequeriments, v3.0 \u2013 Proposed Final. [S.l.]: Sun Microsystems, 2005. Dispon\u00edvel em: \n<http://jcp.org/aboutJava/communityprocess/pr/jsr220/>. Acesso em: 2 mar. 2006. \n\nJSR220B: Enterprise JavaBeans Specification, v3.0, Java Persistence API \u2013 Proposed \nFinal. [S.l.]: Sun Microsystems, 2005. Dispon\u00edvel em: \n<http://jcp.org/aboutJava/communityprocess/pr/jsr220/>. Acesso em: 2 mar. 2006. \n\nKICZALES, G. et al.. Aspect-Oriented Programming, In: EUROPEAN CONFERENCE \nON OBJECT-ORIENTED PROGRAMMING, 11., ECOOS\u201997, 1997, Finland, \nProceedings... [S.l.]: Springer-Verlag, 1997, p. 220-242. \n\nKICZALES, G. et al.. An overview of AspectJ. In: EUROPEAN CONFERENCE ON \nOBJECT-ORIENTED PROGRAMMING, 15., ECOOS\u201901, 2001, Budapest, Hungary, \nProceedings...  London: Springer-Verlag, 2001, p. 327-353. \n\nKNUBLAUCH, H. An Agile Development Methodology for Knowledge-Based \nSystems. Ulm: Universidade de Ulm, 2002. 216 f. Tese (Doutorado) \u2013 Universidade de \nUlm, Berlin, 2002. \n\nKOURAI, K.; HIBINO, H.; CHIBA, S. Aspect-oriented application-level scheduling for \nJ2EE servers. In: International Conference on Aspect-Oriented Software Development, \n6., AOSD\u201907, 2007, Vancouver, Canada, Proceedings...  New York: ACM, 2007, p. 1-\n13. \n\nMAES, P. Concepts and experiments in computational reflection. SIGPLAN Not. 22, \nvol. 12, p. 147-155, dec. 1987. \n\nMASTELLA, L.. Um Modelo de Conhecimento Baseado em Eventos para \nAquisi\u00e7\u00e3o e Representa\u00e7\u00e3o de Seq\u00fc\u00eancias Temporais. Porto Alegre: UFRGS, 2005. \n162 f. Disserta\u00e7\u00e3o (Mestrado) \u2013 Programa de P\u00f3s-Gradua\u00e7\u00e3o em Computa\u00e7\u00e3o, \nUniversidade Federal do Rio Grande do Sul, Porto Alegre, 2005. \n\nMEDITSKOS, G.; BASSILIADES, N. O-DEVICE: An Object-Oriented Knowledge \nBase System for OWL Ontologies. In: HELLENIC CONFERENCE ON ARTIFICIAL \nINTELLIGENCE, 4., SETN'06, 2006, Proceedings... Crete: Springer-Verlag: \nANTONIOU G. et al., LNAI 3955, p. 256-266, 2006. \n\nMESEGUER, P.; PREECE, A. D. Verification and Validation of Knowledge-Based \nSystems with Formal Specifications. The Knowledge Engineering Review, v. 10, n. 4, \n1995. \n\n\n\n \n\n \n\n81 \n\nPIVETA, E, et al.. Avoiding Bad Smells in Aspect-Oriented Software. In: \nINTERNATIONAL CONFERENCE ON SOFTWARE ENGINEERING AND \nKNOWLEDGE ENGINEERING, 19., SEKE\u201907, 2007, Boston, USA, Proceedings...  \nBoston: Knowledge Systems Institute Graduate School, 2007, p. 81-84. \n\nPREE, W.; BECKENKAMP, F.; VIADEMONTE, S. OO design and implementation of \na flexible software architecture for decision support systems. In: INTERNATIONAL \nCONFERENCE ON SOFTWARE ENGINEERING AND KNOWLEDGE \nENGINEERING, 9., SEKE\u201997, 1997, Madrid, Spain, Proceedings... Spain: [s.n], 1997. \n\nSCHREIBER, G. et al. Knowledge Engineering and Management: The \nCommonKADS Methodology. Cambridge: MIT Press, 2000. \n\nSILVA, L.A.L. Aplicando m\u00e9todos de solu\u00e7\u00e3o de problemas em tarefas de \ninterpreta\u00e7\u00e3o de rochas. Porto Alegre: UFRGS, 2001. 160 f. Disserta\u00e7\u00e3o (Mestrado) \u2013 \nPrograma de P\u00f3s-Gradua\u00e7\u00e3o em Computa\u00e7\u00e3o, Universidade Federal do Rio Grande do \nSul, Porto Alegre, 2001. \n\nSTUDER, R.; BENJAMINS, V. R.; FENSEL, D. Knowledge Engineering: Principles \nand Methods. Data &amp; Knowledge Engineering, v. 25, n. 1/2, p. 161-197, 1998. \n\nTANASESCU, V.; DOMINGUE, J.; CABRAL, L. OCML Ontologies to XML Schema \nLowering, In: First AKT Workshop on Semantic Web Services (AKT-SWS04), \nKMi, The Open University, Milton Keynes, UK, 2004. \n\nVICTORETI, F.I. Mapeamento e Documenta\u00e7\u00e3o de Fei\u00e7\u00f5es Visuais Diagn\u00f3sticas \npara Interpreta\u00e7\u00e3o em Sistema Baseado em Conhecimento no Dom\u00ednio da \nPetrografia. Porto Alegre: UFRGS, 2007. 87 f. Disserta\u00e7\u00e3o (Mestrado) \u2013 Programa de \nP\u00f3s-Gradua\u00e7\u00e3o em Computa\u00e7\u00e3o, Universidade Federal do Rio Grande do Sul, Porto \nAlegre, 2007. \nZHU, Z. J.; ZULKERNINE, M. A model-based aspect-oriented framework for building \nintrusion-aware software systems. Information and Softwre Technology, v. 51, n. 5, \np. 865-875, 2009. \n\n\n\n \n\n \n\n82 \n\nANEXO GRAM\u00c1TICA DO JEP (AXIOMAS) \n\nA gram\u00e1tica suportada pelo Java Expression Parser \u00e9 apresentada a seguir. Extra\u00edda \nde&lt;http://www.singularsys.com/jep/doc/html/grammar.html#prod3>. Operadores com \nmenor preced\u00eancia est\u00e3o no topo, operadores com maior preced\u00eancia est\u00e3o na base. \n\nStart ::= ( Expression (&lt;EOF> |&lt;SEMI> ) | (&lt;EOF> |&lt;SEMI> ) ) \n\nExpression ::= AssignExpression \n\n | RightExpression \n\nAssignExpression ::= ( LValue&lt;ASSIGN> Expression ) \n\nRightExpression ::= OrExpression \n\nOrExpression ::= AndExpression ( (&lt;OR> AndExpression ) )* \n\nAndExpression ::= EqualExpression((<AND>EqualExpression ) )* \n\nEqualExpression ::= RelationalExpression ( (&lt;NE> RelationalExpression ) | (&lt;EQ> \nRelationalExpression ) )* \n\nRelationalExpression ::= AdditiveExpression ( (&lt;LT> AdditiveExpression ) | (&lt;GT> \nAdditiveExpression ) | (&lt;LE> AdditiveExpression ) | (&lt;GE> \nAdditiveExpression ) )* \n\nAdditiveExpression ::= MultiplicativeExpression ( (&lt;PLUS> MultiplicativeExpression ) | ( \n<MINUS> MultiplicativeExpression ) )* \n\nMultiplicativeExpression ::= UnaryExpression((PowerExpression)|(<MUL> UnaryExpression) | \n(<DOT> UnaryExpression ) | (<CROSS> UnaryExpression ) | \n(<DIV> UnaryExpression ) | (<MOD> UnaryExpression ) )* \n\nUnaryExpression ::= (&lt;PLUS> UnaryExpression ) \n\n | (&lt;MINUS> UnaryExpression ) \n\n | (&lt;NOT> UnaryExpression ) \n\n | PowerExpression \n\nPowerExpression ::= UnaryExpressionNotPlusMinus((<POWER>UnaryExpression ) )? \n\nUnaryExpressionNotPlusMinus ::= AnyConstant \n\n | ArrayAccess \n\n | Function \n\n | Variable \n\n\n\n \n\n \n\n83 \n\n |&lt;LRND> Expression&lt;RRND> \n\n | ListExpression \n\nListExpression ::=&lt;LSQ> ( Expression (&lt;COMMA> Expression )* )?&lt;RSQ> \n\nLValue ::= ArrayAccess \n\n | Variable \n\nArrayAccess ::= Variable ListExpression  \n\nVariable ::= ( Identifier ) \n\nFunction ::= ( Identifier&lt;LRND> ArgumentList&lt;RRND> ) \n\nArgumentList ::= ( Expression (&lt;COMMA> Expression )* )? \n\nIdentifier ::= (&lt;INDENTIFIER1> |&lt;INDENTIFIER2> ) \n\nAnyConstant ::= (&lt;STRING_LITERAL> | RealConstant ) \n\nRealConstant ::= (<INTEGER_LITERAL>|&lt;FLOATING_POINT_LITERAL> )"}]}}}