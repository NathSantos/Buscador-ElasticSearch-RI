{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.19438"}, {"@name": "filename", "#text": "2788_Pereira_RomuloAlbuquerque_M.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Escalonamento de Atividades de\n\nDesenvolvimento de Poc?os de Petro?leo:\n\nGRASP\n\nRomulo Albuquerque Pereira\n\nDissertac?a?o de Mestrado\n\ni\n\n\n\nInstituto de Computac?a?o\n\nUniversidade Estadual de Campinas\n\nEscalonamento de Atividades de Desenvolvimento de\n\nPoc?os de Petro?leo: GRASP\n\nRomulo Albuquerque Pereira\n\nNovembro de 2005\n\nBanca Examinadora:\n\n\u2022 Prof. Dr. Arnaldo Vieira Moura (Orientador)\n\n\u2022 Prof. Dr. Ricardo Dahab\n\nInstituto de Computac?a?o \u2013 UNICAMP\n\n\u2022 Prof. Dr. Vin??cius Amaral Armentano\n\nFaculdade de Engenharia Ele?trica e de Computac?a?o \u2013 UNICAMP\n\n\u2022 Prof. Dr. Joa?o Meidanis (Suplente)\n\nInstituto de Computac?a?o \u2013 UNICAMP\n\nii\n\n\n\n\n\n\n\nEscalonamento de Atividades de Desenvolvimento de\n\nPoc?os de Petro?leo: GRASP\n\nEste exemplar corresponde a? redac?a?o final da\n\nDissertac?a?o devidamente corrigida e defendida\n\npor Romulo Albuquerque Pereira e aprovada\n\npela Banca Examinadora.\n\nCampinas, 16 de novembro de 2005.\n\nProf. Dr. Arnaldo Vieira Moura (Orientador)\n\nProf. Dr. Cid Carvalho de Souza\n\n(Co-orientador)\n\nDissertac?a?o apresentada ao Instituto de Com-\n\nputac?a?o, unicamp, como requisito parcial para\n\na obtenc?a?o do t??tulo de Mestre em Cie?ncia da\n\nComputac?a?o.\n\nv\n\n\n\nc\u00a9 Romulo Albuquerque Pereira, 2005.\n\nTodos os direitos reservados.\n\nvi\n\n\n\nResumo\n\nEste trabalho de mestrado procurou estudar e resolver um problema real de escalonamento\n\ndas atividades de desenvolvimento de poc?os de petro?leo em alto mar. Uma versa?o mais\n\nsimples deste mesmo problema foi provada ser NP-dif??cil. Nosso estudo se concentrou no\n\nproblema real enfrentado pela Petrobras, com todas suas caracter??sticas e nuances.\n\nAntes que locais promissores de bacias petrol??feras sejam efetivamente desenvolvidos\n\nem poc?os de petro?leo produtivos, e? necessa?rio realizar diversas atividades de perfurac?a?o,\n\ncompletac?a?o e interligac?a?o nesses locais. O escalonamento dessas atividades deve satisfa-\n\nzer va?rias restric?o?es conflitantes e buscar a maximizac?a?o da produc?a?o de petro?leo em um\n\ndado horizonte de tempo. O problema foi atacado em duas etapas: uma sem conside-\n\nrar o deslocamento de recursos e outra considerando-os. Para tal, adotamos a estrate?gia\n\nGreedy Randomized Adaptive Search Procedure (GRASP) e incorporamos va?rias te?cnicas\n\nespec??ficas para obter melhores desempenho e qualidade da soluc?a?o final. Os resultados\n\nsa?o comparados com outros produzidos por uma ferramenta computacional baseada em\n\nProgramac?a?o por Restric?o?es (PR). Esta u?ltima, ja? em uso e bem aceita na empresa, foi\n\ndesenvolvida pela Petrobras. Resultados comparativos realizados em insta?ncias reais indi-\n\ncam que a implementac?a?o GRASP supera a ferramenta de PR produzindo soluc?o?es com\n\nexpressivos aumentos de produc?a?o.\n\nvii\n\n\n\nAbstract\n\nThis dissertation aimed at studying and solving a real world scheduling problem. We deal\n\nwith the scheduling of offshore oil well development activities. A simpler version of this\n\nsame problem was proved to be in NP-hard. Our approach treats this problem as faced by\n\nPetrobras, with all its characteristics and details.\n\nBefore promising locations at petroliferous basins become productive oil wells, it is often\n\nnecessary to complete activities of drilling, completion and interconnection at these locati-\n\nons. The scheduling of such activities must satisfy several conflicting constraints and aim\n\nat the maximization of oil production. The problem was solved in two parts: one without\n\nconsidering resource displacements and other taking into account such displacements. For\n\nsuch, we used a Greedy Randomized Adaptive Search Procedure (GRASP) metaheuristic\n\nand used several techniques and variants in order to obtain more efficiency and produce\n\nbetter solutions. The results are compared with schedules produced by a well-accepted cons-\n\ntraint programming implementation. Computational experience on real instances indicates\n\nthat the GRASP implementation is competitive, outperforming the constraint programming\n\nimplementation.\n\nix\n\n\n\nAgradecimentos\n\nAgradec?o...\n\nA? Deus, meu Pai. Por me encorajar, me iluminar e me inspirar a sempre fazer o que e? bom.\n\nPor ser um excelente oleiro. Por me amar e por me dar tantos e muitos outros motivos\n\npara Lhe agradecer.\n\nAos meus pais, por terem me ensinado a aprender. Por terem me dado o gosto pela leitura\n\ne, principalmente, pela escrita. Por me amarem e serem ta?o especiais!\n\nA? minha fam??lia, por terem acreditado em mim e por sempre orarem por mim. Sou muito\n\ngrato a todos!\n\nAos meus orientadores, por me iniciarem no mundo da pesquisa e por trabalharem duro\n\njunto comigo. Por me mostrarem que na seriedade de um trabalho, pode-se se divertir e\n\ncontar com excelentes amigos.\n\nA? Josy, por me deslumbrar e deixar um escritor sem palavras...\n\nAo Repu?blica Futebol Clube: Vin??cius Pato, Vin??cius Beic?o, Ulisses Monge e Harry Um-\n\nbrella por momentos inesquec??veis de grande amizade.\n\nA? Petrobras, por me empregar como terceirizado e por nos fornecer os dados para ana?lise.\n\nAo Fernando, por ser o \u201cchefe\u201d que todo empregado gostaria de ter. E aos meus colegas de\n\ntrabalho, pela amizade e companheirismo.\n\nxi\n\n\n\nPor que?\n\nPor que sa?o ta?o loucas as coisas loucas\n\nda vida?\n\nE por que sa?o ta?o poucas?\n\nPorque sa?o na?o ocas\n\nDelas cria-se um universo\n\nFazem-se esses versos\n\nOs fazem belos\n\nElos ao eterno?\n\nSim.\n\nRomulo A. Pereira\n\n\u201cMuitos, que Digam Muito\u201d\n\nA ser lanc?ado\n\nxiii\n\n\n\nConteu?do\n\nResumo vii\n\nAbstract ix\n\nAgradecimentos xi\n\n1 Introduc?a?o 1\n\n1.1 Organizac?a?o do Texto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nI Descric?a?o do Problema 3\n\n2 O Escalonamento no Desenvolvimento de Poc?os de Petro?leo 5\n\n2.1 Produc?a?o de Petro?leo e Objetivos . . . . . . . . . . . . . . . . . . . . . . . . 7\n\n2.2 As Restric?o?es do EDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n\n2.3 Relac?a?o entre o EDP e o Job Shop Scheduling . . . . . . . . . . . . . . . . . 9\n\n2.4 Histo?rico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\nII Fundamentos Teo?ricos 13\n\n3 GRASP 15\n\n4 Programac?a?o por Restric?o?es 19\n\nIII O Trabalho Desenvolvido 23\n\n5 ORCA: Resolvedor de Programac?a?o por Restric?o?es 25\n\n5.1 Modelo do ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n5.1.1 Algoritmos do ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\n5.1.2 Func?a?o Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\nxv\n\n\n\n5.1.3 Te?cnicas de Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\n5.1.4 Goals para Escalonar as Atividades . . . . . . . . . . . . . . . . . . . 29\n\n5.1.5 Resultados do ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\n6 O EDP sem Deslocamento de Recursos 31\n\n1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n2 The Well Drilling Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n\n3 A GRASP for the WDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n\n4 Computational Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n\n5 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n6 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n\n7 O EDP com Deslocamento de Recursos 49\n\n1 Scheduling the Development of Oil Wells . . . . . . . . . . . . . . . . . . . . 52\n\n1.1 Oil Yield and Objectives . . . . . . . . . . . . . . . . . . . . . . . . . 53\n\n1.2 The WDRDP Constraints . . . . . . . . . . . . . . . . . . . . . . . . 53\n\n1.3 The Constraint Programming Solution . . . . . . . . . . . . . . . . . 55\n\n1.4 The Resource Displacement . . . . . . . . . . . . . . . . . . . . . . . 55\n\n2 GRASP Strategies for the WDRDP . . . . . . . . . . . . . . . . . . . . . . . 56\n\n2.1 Greedy Randomized Adaptive Search Procedure (GRASP) . . . . . . 57\n\n2.2 GRASP Advanced Techniques . . . . . . . . . . . . . . . . . . . . . . 58\n\n2.3 The New GRASP Solver Implementation: GRASPW . . . . . . . . . 61\n\n2.4 The Construction Phase . . . . . . . . . . . . . . . . . . . . . . . . . 62\n\n2.5 The Local Search Phase . . . . . . . . . . . . . . . . . . . . . . . . . 64\n\n3 Computational Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n3.1 Typical Instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n3.2 Setting GRASPW Parameters . . . . . . . . . . . . . . . . . . . . . . 66\n\n3.3 The GRASPW Implementations . . . . . . . . . . . . . . . . . . . . . 69\n\n3.4 Comparative Results . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\n4 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n\n5 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n\nIV Considerac?o?es Finais 83\n\n8 Concluso?es 85\n\n9 Trabalhos Futuros 87\n\nBibliografia 88\n\nxvi\n\n\n\nLista de Tabelas\n\nCap??tulo 4\n\n4.1 Estrutura ba?sica de um programa em Programac?a?o por Restric?o?es . . . . . . 20\n\nCap??tulo 6\n\n1 Test instances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n\nCap??tulo 7\n\n1 Tested Instances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n\n2 Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71\n\n3 Values obtained by the Solvers in the Comparative Criteria . . . . . . . . . . 72\n\n4 Rank of the Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\n5 Analysis of the Rank of the Solvers . . . . . . . . . . . . . . . . . . . . . . . 74\n\n6 Rank of the Best Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n\nxvii\n\n\n\nLista de Figuras\n\nCap??tulo 2\n\n2.1 A?rvore de Natal Molhada. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n\n2.2 Restric?a?o de Superf??cie. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\nCap??tulo 3\n\n3.1 Pseudo-co?digo da Metaheur??stica GRASP . . . . . . . . . . . . . . . . . . . 15\n\n3.2 Pseudo-co?digo da Fase Construc?a?o . . . . . . . . . . . . . . . . . . . . . . . 17\n\n3.3 Pseudo-co?digo da Fase Busca Local . . . . . . . . . . . . . . . . . . . . . . . 17\n\nCap??tulo 5\n\n5.1 ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\nCap??tulo 6\n\n1 Pseudo-code of the GRASP Metaheuristic. . . . . . . . . . . . . . . . . . . . . . 36\n\n2 Pseudo-code of the Construction Phase of GRASP. . . . . . . . . . . . . . . . . 37\n\n3 Static Sized RCL x Dynamic Sized RCL. . . . . . . . . . . . . . . . . . . . . . 41\n\n4 BIR \u00d7 FIR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n5 ORCA x GRASPW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n6 ORCA x GRASPW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n\nCap??tulo 7\n\n1 Schedules without and with resource displacement. . . . . . . . . . . . . . . . . 56\n\n2 Pseudo-code of the GRASP Meta-heuristic. . . . . . . . . . . . . . . . . . . . . 57\n\n3 Pseudo-code of the Construction Phase of GRASP. . . . . . . . . . . . . . . . . 58\n\n4 2-exchange swap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n\n5 Static Sized RCL Solver x Dynamic Sized RCL Solver. . . . . . . . . . . . . . . 67\n\n6 BIR x FIR: Example 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n\n7 BIR x FIR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n\nxix\n\n\n\n8 Bias Functions, I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n\n9 Bias Functions, II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n10 ORCA \u00d7 G14, I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\n\n11 ORCA \u00d7 G14, II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\n12 ORCA\u00d7G14: Example 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\nxx\n\n\n\nCap??tulo 1\n\nIntroduc?a?o\n\nA pesquisa cient??fica sobre problemas de escalonamento (scheduling) e? intensa e tem ele-\n\nvado teor pra?tico, existindo desde a Segunda Guerra Mundial. Notadamente, quase toda\n\nempresa de certo porte, em que a organizac?a?o, reduc?a?o de custos e produtividade sa?o in-\n\ndispensa?veis para competir no mercado, ja? aplica te?cnicas da pesquisa operacional. Ocorre,\n\npore?m, que a grande maioria destes problemas sa?o comprovadamente classificados como\n\nNP-dif??ceis (Garey &amp; Johnson (1979)). Isso praticamente exclui algoritmos determin??sticos\n\neficientes para solucionar esses problemas, especialmente para insta?ncias de entrada sufici-\n\nentemente grandes. Na ause?ncia de algoritmos polinomiais, uma alternativa promissora e? o\n\nuso de heur??sticas eficazes que possam auxiliar no processo de busca de boas soluc?o?es. Em\n\nvista disso, e dadas as especificidades de cada problema, e? raro encontrar-se ferramentas\n\ncomerciais acabadas que atendam a?s necessidades de cada situac?a?o.\n\nPetro?leo e ga?s sa?o combust??veis fo?sseis de larga utilizac?a?o na sociedade atual, sendo\n\naproveitados na fabricac?a?o de pla?sticos, tintas, querosene, combust??vel veicular e de aviac?a?o,\n\nga?s de cozinha e em muitas outras aplicac?o?es. Boa parte desses combust??veis fo?sseis e? hoje\n\nextra??da de bacias ocea?nicas, como a de Marlim, no Estado do Rio de Janeiro. A variac?a?o na\n\noferta e nos prec?os desses combust??veis, aliada a? necessidade da reduc?a?o dos seus custos de\n\nproduc?a?o, com manutenc?a?o da produtividade, torna cada vez mais importante a utilizac?a?o\n\nde mecanismos que permitam a organizac?a?o racional das atividades de produc?a?o de um\n\ncampo petrol??fero (Hasle et al. (1997)). Algumas das atividades inerentes ao processo de\n\nexplorac?a?o de petro?leo possuem um custo muito elevado, principalmente devido ao aluguel\n\nde equipamentos de grande porte, tais como barcos e sondas.\n\nA Petrobras e? uma das empresas pioneiras e l??deres na explorac?a?o de petro?leo em a?guas\n\nprofundas, sendo tambe?m uma das 20 maiores empresas petrol??feras do planeta. Ela ex-\n\nplora diversas bacias petrol??feras, cada uma com centenas de locais promissores onde poc?os\n\nde petro?leo podem ser colocados em produc?a?o. Entretanto, esses locais precisam ser de-\n\nsenvolvidos antes de se tornarem produtivos. Para realizar as atividades envolvidas no\n\n1\n\n\n\n2 Cap??tulo 1. Introduc?a?o\n\ndesenvolvimento de um poc?o de petro?leo, a Petrobras utiliza recursos \u2014 sondas e navios\n\n\u2014 alguns alugados, outros de sua propriedade. Esses recursos sa?o limitados e de alto\n\ncusto, seja em sua aquisic?a?o ou no prec?o de aluguel, e, dessa forma, devem ser utilizados\n\neficientemente.\n\nCiente disso, a empresa resolveu utilizar ferramentas computacionais que pudessem\n\nmelhor escalonar suas atividades realizadas na Bacia Petrol??fera de Campos. Ale?m do\n\nescalonamento das atividades, ela tambe?m deseja que o mecanismo resolvedor considere o\n\ndeslocamento dos recursos. Num primeiro passo, a empresa procurou por programas comer-\n\nciais que solucionassem seu problema espec??fico. Pore?m, logo verificou que tais programas\n\nna?o esta?o dispon??veis no mercado. Assim, a Petrobras expo?s seu problema a? Unicamp e\n\nsugeriu uma parceria de pesquisa sobre algoritmos e heur??sticas que pudessem auxiliar na\n\nbusca de uma soluc?a?o satisfato?ria (Moura &amp; de Souza (2000)). Este projeto se insere no es-\n\ncopo dessa cooperac?a?o. A empresa procurou obter, com o desenvolvimento deste trabalho,\n\nale?m de maior produtividade e outros benef??cios, uma boa reduc?a?o de custos na operac?a?o\n\nde seus equipamentos.\n\n1.1 Organizac?a?o do Texto\n\nO texto dessa dissertac?a?o encontra-se dividido em quatro partes principais:\n\nA Parte I traz uma descric?a?o detalhada do problema tratado. Apresentamos todas as\n\nrestric?o?es operacionais e de engenharia envolvidas no escalonamento, e mostramos um breve\n\nhisto?rico de como esse problema foi resolvido.\n\nA Parte II apresenta, resumidamente, os fundamentos teo?ricos necessa?rios para um\n\nentendimento adequado do trabalho descrito nesta dissertac?a?o. O Cap??tulo 3 expo?e as\n\nide?ias ba?sicas a respeito da metaheur??stica GRASP. O Cap??tulo 4 conte?m uma introduc?a?o\n\na? metodologia de Programac?a?o por Restric?o?es.\n\nNa Parte III, esta?o inclu??dos uma descric?a?o da ferramenta ORCA (Cap??tulo 5) e dois\n\nartigos resultantes deste trabalho de mestrado. Os artigos esta?o escritos em ingle?s. A\n\ncada um dos artigos esta?o anexadas uma nova introduc?a?o e uma nova conclusa?o estendidas,\n\nambas em portugue?s. O Cap??tulo 6 discute a soluc?a?o do problema de escalonamento no\n\ndesenvolvimento de poc?os de petro?leo sem deslocamento de recursos e o Cap??tulo 7 trata\n\ndo mesmo problema, mas com deslocamento de recursos.\n\nPor fim, a Parte IV expo?e as concluso?es finais alcanc?adas com este trabalho e enu-\n\nmera algumas poss??veis direc?o?es de pesquisa que poderiam ser tomadas no sentido de dar\n\ncontinuidade a este estudo.\n\n\n\nParte I\n\nDescric?a?o do Problema\n\n3\n\n\n\nCap??tulo 2\n\nO Escalonamento no\n\nDesenvolvimento de Poc?os de\n\nPetro?leo\n\nQuando um ponto em alto mar e? considerado um promissor poc?o de petro?leo, sondas sa?o\n\nenviadas ao local para realizar as devidas operac?o?es de perfurac?a?o. O desenvolvimento de\n\num poc?o, desde a determinac?a?o da sua localizac?a?o ate? ser colocado em produc?a?o, envolve\n\nva?rias etapas.\n\nApo?s perfurado, inicia-se o processo de preparac?a?o do poc?o para a extrac?a?o de petro?leo\n\n(completac?a?o). Em primeiro lugar, e? instalada a \u201cA?rvore de Natal Molhada (ANM)\u201d 1 sobre\n\na boca do poc?o para que a mate?ria-prima na?o extravase para o mar. Posteriormente, um\n\nnavio LSV2 leva uma tubulac?a?o da qual uma extremidade e? conectada a? ANM e a outra\n\nextremidade e? encaixada num manifold 3, ou enta?o sobe direto para a superf??cie, sendo\n\nconectada a uma plataforma. Esse esta?gio e? conhecido como interligac?a?o. O manifold\n\ne? instalado por uma sonda, ou por uma BGL4, e seu uso evita que cada poc?o necessite\n\nde tubulac?o?es exclusivas que o conecte desde o fundo do mar ate? a? superf??cie. Assim,\n\nas mangueiras de va?rios poc?os relativamente pro?ximos podem se interligar ao manifold e,\n\ndeste, uma u?nica tubulac?a?o sobe ate? a superf??cie. Na ause?ncia de manifolds, e com o metro\n\nde tubulac?a?o tendo alto valor, o processo todo teria valor excessivamente elevado.\n\nCompletado o processo de interligac?a?o, parte-se para a extrac?a?o do petro?leo propria-\n\nmente dita. Para tal, sa?o colocadas bases de captura de petro?leo na superf??cie do mar, as\n\nchamadas UEPs (Unidade Estaciona?ria de Produc?a?o), onde se armazenara? o produto ate?\n\n1Complexa estrutura meta?lica com tubulac?o?es onde se encaixam va?lvulas para extrac?a?o do petro?leo.\nVide Figura 2.1.\n\n2Navio de apoio.\n3Um manifold e? uma estrutura para a junc?a?o de tubulac?o?es no fundo do mar.\n4Barcac?a guindaste.\n\n5\n\n\n\n6 Cap??tulo 2. O Escalonamento no Desenvolvimento de Poc?os de Petro?leo\n\nFigura 2.1: A?rvore de Natal Molhada.\n\nque navios venham recolhe?-lo e leva?-lo para terra. Se a vaza?o de petro?leo for muito elevada,\n\npode-se optar pela instalac?a?o local de uma plataforma petrol??fera.\n\nO problema de Escalonamento no Desenvolvimento de Poc?os de petro?leo em alto mar\n\n(EDP) pode ser definido como: dados um conjunto de poc?os, as atividades a serem exe-\n\ncutadas em cada poc?o e os recursos dispon??veis para a execuc?a?o dessas atividades, deter-\n\nminar um sequ?enciamento das atividades em um dado horizonte de tempo, indicando seus\n\ninstantes de in??cio e fim e o recurso que a realizara?, de forma a otimizar uma func?a?o ob-\n\njetivo, a saber, maximizar a produc?a?o de petro?leo. Este sequ?enciamento deve levar em\n\nconta diversas restric?o?es operacionais e de engenharia. Ale?m disso, pode ser considerado\n\no deslocamento dos recursos. Nesse trabalho, o EDP e? estudado, levando em conta as\n\nespecificidades encontradas pela Petrobras na explorac?a?o de petro?leo em a?guas profundas.\n\nAs restric?o?es operacionais e de engenharia sera?o apresentadas em detalhes, bem como uma\n\nmetaheur??stica para a resoluc?a?o do problema.\n\nPropostas de soluc?a?o ja? foram desenvolvidas para problemas similares (do Nascimento\n\n(2002)). Entretanto, o EDP na forma aqui estudada inclui restric?o?es de grande releva?ncia\n\npra?tica que na?o sa?o tratadas em outros trabalhos, e que nos foram fornecidas pela Petrobras.\n\nPor exemplo, no EDP com deslocamento de recursos (que chamamos de EDPDR) considera-\n\nse que a movimentac?a?o dos recursos entre os poc?os consome tempo e que, nesse per??odo,\n\neles ficam indispon??veis.\n\n\n\n2.1. Produc?a?o de Petro?leo e Objetivos 7\n\n2.1 Produc?a?o de Petro?leo e Objetivos\n\nA produc?a?o de petro?leo de um poc?o e? calculada da seguinte forma. Cada poc?o tem uma\n\nvaza?o associada e uma atividade cujo propo?sito e? indicar o in??cio da produc?a?o. Quando esta\n\nu?ltima atividade e? conclu??da, o poc?o e? considerado em produc?a?o. A produc?a?o e? calculada\n\nmultiplicando-se a vaza?o de petro?leo do poc?o pelo tempo restante desde o in??cio da produc?a?o\n\nate? o horizonte de produc?a?o estabelecido. Se o in??cio da produc?a?o ocorrer apo?s o horizonte\n\nde produc?a?o, a produc?a?o do poc?o correspondente na?o sera? considerada.\n\nO objetivo e? obter um escalonamento para todas as atividades de desenvolvimento,\n\nsatisfazendo todas as restric?o?es e maximizando a produc?a?o de petro?leo. Outros objetivos a\n\nserem atingidos sa?o:\n\n1. Gerar soluc?o?es mais rapidamente. Soluc?o?es criadas por engenheiros levam muitas\n\nhoras, ate? dias, para serem constru??das. Um me?todo mais ra?pido permitiria a ana?lise\n\nde diferentes cena?rios para o mesmo problema como, por exemplo, acrescentando-se\n\nou removendo-se recursos. Ale?m disso, imprevistos na?o resultariam em novas horas\n\nou dias em replanejamento.\n\n2. Melhor alocac?a?o de recursos. Com a automac?a?o do escalonamento, engenheiros al-\n\ntamente especializados, antes responsa?veis por planejar o escalonamento, podem ser\n\nrealocados para outras a?reas da empresa.\n\n3. Ganhos. O escalonamento automatizado devera? gerar soluc?o?es pelo menos ta?o boas\n\nquanto as manuais. A ferramenta desenvolvida deve tambe?m gerar soluc?o?es pelo me-\n\nnos ta?o boas quanto a?quelas geradas pelo ORCA, uma aplicac?a?o em uso na Petrobras.\n\n2.2 As Restric?o?es do EDP\n\nAs principais restric?o?es envolvidas no processo de escalonamento das atividades de desen-\n\nvolvimento dos poc?os de petro?leo sa?o:\n\nC1. Precede?ncia Tecnolo?gica: estabelece uma ordem entre as atividades. Ha? quatro cate-\n\ngorias de precede?ncia tecnolo?gica:\n\n(a) FS(A,B): Atividade A deve terminar depois do in??cio da atividade B.\n\n(b) SS(A,B): Atividade A deve iniciar depois do in??cio da atividade B.\n\n(c) SF(A,B): Atividade A deve iniciar depois do fim da atividade B.\n\n(d) FF(A,B): Atividade A deve terminar depois do fim da atividade B.\n\n\n\n8 Cap??tulo 2. O Escalonamento no Desenvolvimento de Poc?os de Petro?leo\n\nC2. Marco-Atividade: uma atividade deve terminar antes ou iniciar depois de uma deter-\n\nminada data, ou marco, com ou sem lag. Essa data esta? geralmente relacionada com\n\nalgum evento externo, e.g., a instalac?a?o de uma plataforma petrol??fera.\n\nC3. Baseline: estabelece uma data de in??cio para uma determinada atividade.\n\nC4. Restric?o?es no Uso dos Recursos: para executar uma atividade, dependendo da sua\n\nnatureza, e? necessa?rio um recurso que atenda a?s suas caracter??sticas operacionais.\n\nPara uma atividade que requer um barco, deve ser verificado se os equipamentos do\n\nmesmo podem operar na profundidade especificada. Para uma atividade que requer\n\numa sonda, deve ser verificado:\n\n(a) Seu tipo: ancorada, SSDP, NSDP ou navio-sonda.\n\n(b) Suas capacidades: TOP DRIVE, HPHT, BOP 16, BOP 18, Perfurac?a?o.\n\n(c) Sua ma?xima e m??nima profundidade de operac?a?o.\n\n(d) Sua ma?xima profundidade de perfurac?a?o.\n\nC5. Concorre?ncia: duas atividades do mesmo poc?o na?o podem ser executadas simulta-\n\nneamente. Similarmente, duas atividades na?o podem ser executadas por um mesmo\n\nrecurso simultaneamente.\n\nC6. Indisponibilidade: recursos podem estar indispon??veis por um per??odo de tempo, para\n\nmanutenc?a?o ou devido a te?rmino de contrato.\n\nC7. Seque?ncias de Poc?os Definidas pelo Usua?rio: o usua?rio pode especificar uma seque?ncia\n\ndesejada para as atividades de perfurac?a?o ou para as atividades de \u201cin??cio de produc?a?o\u201d\n\nde diferentes poc?os. A seque?ncia e? uma lista ordenada de dois ou mais poc?os de tal\n\nforma que se o poc?o A precede o poc?o B na lista, enta?o a atividade FA do poc?o A\n\ndeve terminar antes do in??cio da atividade SB do poc?o B. As atividades FA e SB sa?o\n\nou atividades de \u201cperfurac?a?o\u201d ou atividades de \u201cin??cio de produc?a?o\u201d de seus respec-\n\ntivos poc?os, dependendo do tipo da seque?ncia. Essas seque?ncias sa?o especificadas por\n\nengenheiros de modo a evitar perda de pressa?o no campo petrol??fero.\n\nC8. Restric?a?o de Superf??cie: tambe?m conhecida como bolha assassina, essa restric?a?o re-\n\npresenta uma a?rea de seguranc?a, definida pelo usua?rio ao redor de cada poc?o, para\n\nque as sondas usadas em atividades desses poc?os na?o colidam. A a?rea restrita e? espe-\n\ncificada por um pol??gono fechado definido por coordenadas ao redor do poc?o. Quando\n\no centro do primeiro poc?o esta? dentro da a?rea restrita do segundo poc?o, as ativida-\n\ndes executadas por sondas nesses poc?os na?o podem ser simulta?neas. Essas restric?o?es\n\ndevem ser verificadas entre cada par de sondas mo?veis, e entre cada par de sondas\n\n\n\n2.3. Relac?a?o entre o EDP e o Job Shop Scheduling 9\n\nmo?veis e ancoradas. Por exemplo, na Figura 2.2, o centro do poc?o JUB-16 esta? dentro\n\nda a?rea de seguranc?a do poc?o JUB-02-I, e portanto atividades executadas por sondas\n\nnesses poc?os na?o podem ser simulta?neas.\n\nFigura 2.2: Restric?a?o de Superf??cie.\n\nC9. Cluster : uma atividade pode ser parte de um cluster, que e? um conjunto de atividades\n\nque devem usar o mesmo recurso.\n\nC10. Deslocamento de Sonda: Essa restric?a?o na?o aparece no EDP puro, mas e? considerada\n\nno EDPDR. Ela estabelece que quando uma sonda se deslocar de um poc?o para outro,\n\num tempo de set-up5 deve ser considerado. Dessa forma, deslocamentos desnecessa?rios\n\ndevem ser evitados, por exemplo, fazendo com que uma sonda execute o ma?ximo de\n\natividades de um mesmo poc?o.\n\nPela descric?a?o do problema e de suas restric?o?es, pode ser observado que, ale?m de lidar-\n\nmos com uma aplicac?a?o real e de grande importa?ncia, trata-se um problema com va?rias\n\nparticularidades, que o diferencia em relac?a?o a? problemas descritos na literatura (do Nas-\n\ncimento (2002)).\n\n2.3 Relac?a?o entre o EDP e o Job Shop Scheduling\n\nEm va?rias deciso?es e escolhas de para?metros em nosso resolvedor, tomamos como base\n\nestudos e te?cnicas utilizadas para o problema cla?ssico do Job Shop Scheduling (JSP). Isso\n\n5Tempo para desancorar, deslocar, e ancorar novamente.\n\n\n\n10 Cap??tulo 2. O Escalonamento no Desenvolvimento de Poc?os de Petro?leo\n\nfoi feito porque o EDP e o JSP podem ser facilmente relacionados, como se mostra a seguir,\n\napesar de o EDP ser um problema bem mais complexo.\n\nUm JSP pode ser definido como: um conjunto M de ma?quinas, um conjunto J de\n\ntarefas, e para cada tarefa j ? J esta? associada uma colec?a?o ordenada de operac?o?es tk[j],\n\n1 ? k ? nj, onde nj e? o nu?mero de operac?o?es associadas com a tarefa j. Para cada operac?a?o\n\nt (t e? uma abreviac?a?o de tk[j]) esta? associada uma durac?a?o l(t) e uma ma?quina m(t). O\n\nproblema e? encontrar um escalonamento para as operac?o?es que otimize uma dada func?a?o\n\nobjetivo. Esse escalonamento deve obedecer a? ordem das operac?o?es nas tarefas e na?o pode\n\npermitir que a mesma ma?quina execute mais de uma operac?a?o simultaneamente. A relac?a?o\n\nentre o JSP e o EDP pode ser observada considerando-se as tarefas como poc?os de petro?leo,\n\ne as operac?o?es das tarefas como as atividades dos poc?os. A relac?a?o de precede?ncia entre\n\natividades dos poc?os corresponde a? ordem das operac?o?es das tarefas. Os recursos do EDP\n\nseriam as ma?quinas que executam as operac?o?es no JSP. Note, entretanto, que o EDP e? um\n\nproblema bem mais complexo que o JSP, ja? que as atividades na?o te?m necessariamente um\n\nrecurso determinado para executa?-las. Ale?m disso, uma soluc?a?o do EDP deve satisfazer a\n\nmuitas e variadas restric?o?es e sua func?a?o objetivo e? a maximizac?a?o da produc?a?o de petro?leo.\n\nCom base nessa relac?a?o, do Nascimento (2002) provou que uma versa?o mais simples do\n\nEDP e? NP-dif??cil.\n\n2.4 Histo?rico\n\nPara o entendimento da magnitude do problema e de sua importa?ncia para a Petrobras,\n\napresentamos um breve histo?rico das etapas do desenvolvimento do projeto:\n\n\u2022 In??cio de 2000: Ocorrem as primeiras reunio?es entre engenheiros da E&amp;P (Explorac?a?o\n\ne Produc?a?o) e desenvolvedores da TI (Tecnologia da Informac?a?o), ambas a?reas da\n\nPetrobras. O problema e? formalmente descrito e inicia-se um estudo de como resolve?-\n\nlo de forma automa?tica. Ate? enta?o, ele e? resolvido manualmente por engenheiros\n\nespecialistas da Petrobras.\n\n\u2022 Meados de 2000: A Petrobras contrata uma mestranda do INPE especialista em\n\nheur??sticas e inicia contatos com a UNICAMP (Moura &amp; de Souza (2000)).\n\n\u2022 In??cio de 2001: Os professores doutores Arnaldo Vieira Moura e Cid Carvalho de\n\nSouza fazem reunio?es com os graduandos Romulo Albuquerque Pereira e Vin??cius\n\nJose? Fortuna e lhes explicam o problema.\n\n\u2022 Meados de 2001: Aprovadas as bolsas de IC (Iniciac?a?o Cient??fica) para os alunos\n\nRomulo e Vin??cius, que iniciam os primeiros trabalhos em relac?a?o ao problema. A\n\nPetrobras, por sua vez, inicia trabalhos pro?prios para lidar com o problema.\n\n\n\n2.4. Histo?rico 11\n\n\u2022 In??cio de 2002: Juliana Martins do Nascimento inicia seu Mestrado atacando o mesmo\n\nproblema.\n\n\u2022 Meados de 2002: Fim da IC de Romulo e Vin??cius. O primeiro desenvolveu modelos\n\nmatema?ticos, que se mostraram ruins para o problema, e modelos de programac?a?o por\n\nrestric?o?es (Pereira et al. (2002)). O segundo desenvolveu uma eficiente ferramenta que\n\nutiliza da Busca Tabu para resoluc?a?o do problema (Fortuna et al. (2002)). Romulo\n\npassa a trabalhar como terceirizado na Petrobras, cuidando do desenvolvimento da\n\nferrramenta que a Petrobras vinha fazendo.\n\n\u2022 In??cio de 2003: Romulo inicia seu mestrado no mesmo problema, pore?m com mais\n\nrestric?o?es e dados reais.\n\n\u2022 Fim de 2003: Juliana defende sua tese de mestrado, mostrando uma ferramenta\n\nh??brida que utiliza programac?a?o por restric?o?es e busca tabu para atacar o problema\n\n(do Nascimento (2002)). Como a Petrobras, voltada para seu pro?prio desenvolvi-\n\nmento, na?o mais manteve contato, Juliana resolveu um problema parcial, incompleto\n\ne mais simples.\n\n\u2022 Meados de 2004: Romulo termina sua ferramenta GRASP para o EDP. A Petrobras\n\nrequisita que se considere o deslocamento de recursos.\n\n\u2022 In??cio de 2005: Artigo do EDP e? aprovado no 4th International Workshop on Efficient\n\nand Experimental Algorithms6 (WEA2005). Romulo vai apresentar o trabalho na\n\nconfere?ncia, realizada na ilha de Santorini, Gre?cia. O trabalho e? publicado no livro\n\nPereira et al. (2005a). Finda-se tambe?m um GRASP para o EDP com deslocamento\n\nde recursos (EDPDR).\n\n\u2022 Meados de 2005: Artigo do EDPDR sagra-se um dos vencedores do Pre?mio Petrobras\n\nde Tecnologia7. A ferramenta desenvolvida e? incorporada ao ORCA, ferramenta da\n\nPetrobras para o EDPDR, e passa a ser utilizada pelos engenheiros da Petrobras em\n\nprocessos da Bacia de Campos e Bacia do Esp??rito Santo.\n\n\u2022 Fim de 2005: Submissa?o do artigo do EDPDR ao Journal of Heuristics8. A tese de\n\nmestrado de Romulo e? redigida.\n\n6http://ru1.cti.gr/wea05/\n7http://www2.petrobras.com.br/tecnologia2/port/pptecnologia.asp\n8http://www.kluweronline.com/issn/1381-1231\n\n\n\nParte II\n\nFundamentos Teo?ricos\n\n13\n\n\n\nCap??tulo 3\n\nGRASP\n\nNeste projeto foi utilizada a metodologia GRASP para buscar soluc?o?es para o problema\n\ntratado. Alguns artigos de refere?ncia do GRASP sa?o: Resende &amp; Ribeiro (2002), Souza\n\net al. (2004), Binato &amp; Oliveira (2002), Faria et al. (2005), Srinivasan et al. (2000), Ribeiro\n\n(2002) e Festa &amp; Resende (2002).\n\nA metodologia GRASP (Greedy Randomized Adaptive Search Procedure) e? um processo\n\niterativo, onde cada iterac?a?o consiste de 2 fases, Construc?a?o e Busca Local. A fase\n\nConstruc?a?o constro?i uma soluc?a?o fact??vel, onde a vizinhanc?a e? explorada posteriormente\n\npela fase Busca Local, sendo este processo realizado por diversas iterac?o?es. A melhor\n\nsoluc?a?o dentre todas iterac?o?es do GRASP e? selecionada como resultado final.\n\n1: procedure GRASP(ListSize, MaxIter, Seed)\n2: for k = 1 to MaxIter do\n3: Solution ? Construct Solution(ListSize, Seed);\n4: Solution ? Local Search(Solution);\n5: Update Solution(Solution, Best Solution F ound);\n6: end for\n7: return Best Solution F ound;\n8: end GRASP\n\nFigura 3.1: Pseudo-co?digo da Metaheur??stica GRASP\n\nA Figura 3.1 ilustra uma implementac?a?o gene?rica do bloco principal do GRASP, em\n\npseudo-co?digo. As entradas para o algoritmo incluem para?metros para o ajuste do tamanho\n\nda lista de candidatos (ListSize), nu?mero ma?ximo de iterac?o?es do GRASP (MaxIter), ale?m\n\nda semente aleato?ria (Seed) para uso inicial na gerac?a?o de valores aleato?rios. As iterac?o?es\n\ndo GRASP sa?o mostradas nas linhas 2 a? 6. Cada iterac?a?o do GRASP, como dito anteri-\n\normente, consiste de uma fase Construc?a?o (Construct Solution), linha 3, uma fase Busca\n\n15\n\n\n\n16 Cap??tulo 3. GRASP\n\nLocal (Local Search), linha 4 e, se necessa?rio, uma atualizac?a?o da soluc?a?o encontrada, linha\n\n5. O algoritmo Construct Solution gera uma soluc?a?o fact??vel para o problema, atualizando\n\na varia?vel Solution. De posse da soluc?a?o fact??vel gerada, o algoritmo Local Search procura\n\npor uma soluc?a?o melhor visando a minimizac?a?o ou a maximizac?a?o de uma func?a?o objetivo,\n\ne atualiza a varia?vel Solution. O algoritmo Update Solution compara a soluc?a?o encontrada\n\ncom a soluc?a?o armazenada, que e? a melhor soluc?a?o dentre todas que ja? foram encontradas.\n\nCaso a soluc?a?o gerada seja melhor que a atualmente armazenada, este substitui a soluc?a?o\n\narmazenada pela soluc?a?o atual. Este processo de Construc?a?o, Busca e Atualizac?a?o e? reali-\n\nzado um nu?mero MaxIter de vezes relativamente grande, a fim de procurar obter a melhor\n\nsoluc?a?o poss??vel para o problema.\n\nFase Construc?a?o\n\nNa fase Construc?a?o e? constru??da uma soluc?a?o fact??vel, um elemento de cada vez. Em cada\n\niterac?a?o da Construc?a?o, o pro?ximo elemento a ser adicionado e? determinado ordenando-\n\nse todos os poss??veis elementos em uma lista de candidatos com respeito a uma func?a?o\n\ngulosa (greedy) que mede o benef??cio de selecionar cada elemento. Esta lista e? chamada de\n\nRCL (Restricted Candidate List). A componente adapta?vel da heur??stica vem do fato de\n\nque os benef??cios associados com cada elemento sa?o atualizados em cada iterac?a?o da fase\n\nConstruc?a?o a fim de refletir as alterac?o?es incorporadas pela selec?a?o dos elementos anteriores.\n\nA componente probabil??stica do GRASP e? caracterizada pela escolha aleato?ria de um dos\n\nmelhores candidatos da RCL, mas geralmente na?o o melhor deles. Esta maneira de realizar\n\na escolha permite a obtenc?a?o de diferentes soluc?o?es para cada iterac?a?o do GRASP, na?o\n\nnecessariamente descaracterizando a componente gulosa adapta?vel. As soluc?o?es geradas\n\npela fase Construc?a?o do GRASP na?o sa?o garantidamente o?timas com respeito a?s definic?o?es\n\nda vizinhanc?a. Portanto, e? quase sempre bene?fico aplicar uma busca local para tentar gerar\n\numa soluc?a?o melhor.\n\nA Figura 3.2 ilustra uma implementac?a?o gene?rica do bloco Construc?a?o do GRASP, em\n\npseudo-co?digo. As entradas para o algoritmo incluem para?metros para o ajuste do tamanho\n\nda lista de candidatos (ListSize), ale?m da semente aleato?ria (Seed) para uso inicial na\n\ngerac?a?o de valores aleato?rios. As iterac?o?es do bloco Construc?a?o sa?o mostradas nas linhas\n\nde 2 a? 8.\n\nConforme mencionado anteriormente, este algoritmo constro?i uma soluc?a?o fact??vel atra-\n\nve?s da avaliac?a?o incremental dos poss??veis candidatos, selecionando os candidatos dentre\n\naqueles inclu??dos na RCL. A selec?a?o de um candidato s da lista e? realizada aleatoriamente\n\ne a varia?vel Solution e? atualizada, incluindo-se o candidato selecionado. De posse deste\n\ncandidato, e? realizada uma reavaliac?a?o incremental do custo da soluc?a?o. Este processo\n\ntermina quando uma soluc?a?o e? determinada.\n\n\n\n17\n\n1: procedure Construct Solution(ListSize, Seed)\n2: Solution ? 0;\n3: Evaluate the incremental costs of the candidate elements;\n4: while Solution is not a complete solution do\n5: Build the RCL(ListSize);\n6: Select an element s f rom the RCL at random;\n7: Solution ? Solution ? {s};\n8: Reevaluate the incremental costs;\n9: end while\n\n10: return Solution;\n11: end Construct Solution\n\nFigura 3.2: Pseudo-co?digo da Fase Construc?a?o\n\nFase Busca Local\n\nUm algoritmo de busca local funciona de um modo iterativo, sucessivamente trocando a\n\nsoluc?a?o atual por uma soluc?a?o melhor de sua vizinhanc?a. O algoritmo termina quando na?o\n\ne? encontrada soluc?a?o melhor na vizinhanc?a com respeito a? func?a?o objetivo.\n\nA Figura 3.3 ilustra uma implementac?a?o gene?rica da Busca Local do GRASP em pseudo-\n\nco?digo. A entrada para o algoritmo inclui como para?metro a Soluc?a?o encontrada na fase\n\nConstruc?a?o (Solution). As iterac?o?es da Busca Local sa?o mostradas nas linhas de 2 a? 4.\n\n1: procedure Local Search(Solution)\n2: while Solution is not locally optimal do\n3: F ind s? ? N (Solution) with f (s?) &lt;f (Solution);\n4: Solution ? s?;\n5: end while\n6: return Solution;\n7: end Local Search\n\nFigura 3.3: Pseudo-co?digo da Fase Busca Local\n\nEste algoritmo procura otimizar a soluc?a?o encontrada na fase Construc?a?o atrave?s da\n\nbusca de um vizinho melhor s?, isto e?, um elemento de menor (minimizac?a?o) ou maior (ma-\n\nximizac?a?o) valor segundo a func?a?o objetivo. Esta busca na vizinhanc?a pode ser implemen-\n\ntada usando-se tanto a estrate?gia \u201cbest-improving\u201d quanto a estate?gia \u201cfirst-improving\u201d.\n\nNo primeiro caso, best-improving, todos os vizinhos sa?o analisados e o melhor dentre eles e?\n\nselecionado. Ja? na estrate?gia first-improving, a selec?a?o e? realizada para o primeiro candidato\n\nque apresentar um valor melhor para a func?a?o objetivo, sendo a soluc?a?o atual atualizada\n\n\n\n18 Cap??tulo 3. GRASP\n\npara este valor.\n\nAplicac?o?es do GRASP\n\nA metaheur??stica GRASP tem sido aplicada com sucesso em diversos tipos de problemas\n\nde otimizac?a?o combinato?ria, incluindo-se, set covering, quadratic assigment, roteamento\n\nde ve??culos, problemas de localizac?a?o, conjunto ma?ximo independente, feedback vertex set,\n\nplanejamento de rede de transmissa?o, e planarizac?a?o de grafos, entre outros. Para uma\n\nbibliografia detalhada, vide Festa &amp; Resende (2002).\n\n\n\nCap??tulo 4\n\nProgramac?a?o por Restric?o?es\n\nO trabalho Jaffar &amp; Lassez (1987) estabeleceu os fundamentos teo?ricos a partir dos quais di-\n\nversas linguagens de programac?a?o por restric?o?es puderam ser desenvolvidas1. A ide?ia ba?sica\n\ne? substituir o mecanismo de infere?ncia lo?gica tradicional (unificac?a?o) por um mecanismo\n\nmais gene?rico e eficiente, conhecido como manipulac?a?o de restric?o?es. Este mecanismo ja? e?\n\nusado no campo da Intelige?ncia Artificial desde a de?cada de 80, na resoluc?a?o dos chamados\n\nConstraint Satisfaction Problems. (CSPs). Um CSP e? composto por\n\n\u2022 Um conjunto de varia?veis X = {x1, ..., xn};\n\n\u2022 Para cada varia?vel xi, um conjunto finito de valores, Di, denominado seu dom??nio;\n\n\u2022 Um conjunto de restric?o?es, C, que atuam sobre subconjuntos das varia?veis de X,\n\nlimitando os valores que lhes podem ser atribu??dos.\n\nUma soluc?a?o para um CSP e? uma atribuic?a?o de valores a?s varia?veis de X, obedecendo\n\nas restric?o?es de C.\n\nMuitos problemas em Pesquisa Operacional, tais como escalonamento de tarefas, aloca-\n\nc?a?o de hora?rios e outros problemas combinato?rios podem ser representados como CSPs,\n\ne a Programac?a?o por Restric?o?es vem se afirmando como uma ferramenta poderosa para\n\nabordar tais problemas (Lever et al. (1995), Le Pape (1994), Hasle et al. (1997), Yunes\n\net al. (2000a) e Yunes et al. (2000b)).\n\nUm programa em Programac?a?o por Restric?o?es geralmente obedece a? estrutura apresen-\n\ntada na Tabela 4.1. Note que essa estrutura se assemelha a um CSP.\n\nAs varia?veis com seus dom??nios definem o espac?o de soluc?o?es. As restric?o?es estabelecem\n\nrelac?o?es entre as varia?veis, limitando os valores que elas podem assumir concomitantemente\n\n1Entretanto, vale ressaltar que desde a de?cada de 60 ja? existem linguagens que lidam com restric?o?es.\n\n19\n\n\n\n20 Cap??tulo 4. Programac?a?o por Restric?o?es\n\n<Declarac?a?o de Varia?veis e Dom??nios>\n<Imposic?a?o de Restric?o?es>\n\n<Busca por Soluc?o?es (labeling)>\n\nTabela 4.1: Estrutura ba?sica de um programa em Programac?a?o por Restric?o?es\n\ne reduzindo o espac?o de busca. Essa reduc?a?o se processa atrave?s de um mecanismo deno-\n\nminado propagac?a?o de restric?o?es, cuja func?a?o e? garantir a consiste?ncia parcial do sistema\n\ncomo um todo.\n\nO mecanismo de propagac?a?o de restric?o?es funciona da seguinte forma. Sempre que\n\no dom??nio de uma varia?vel e? alterado, e.g. pela remoc?a?o de um de seus elementos, esta\n\ninformac?a?o e? transmitida (propagada) para as demais varia?veis associadas a ela por uma ou\n\nmais restric?o?es. Durante esse processo, procura-se sempre manter a consiste?ncia do sistema,\n\ni.e. a satisfac?a?o das restric?o?es do programa. Por exemplo: sejam X e Y varia?veis que podem\n\nassumir valores inteiros no intervalo (dom??nio) [1, 10]. Isto significa que, inicialmente, os\n\ndom??nios de X e Y sa?o os mesmos: DX = DY = [1, 10]. Impondo-se a restric?a?o de que\n\nX &lt;Y , os dom??nios se alteram para DX = [1, 9] e DY = [2, 10]. Isto porque, se X = 10 e\n\nX &lt;Y , conclui-se que Y ? 11. Contudo 11 na?o pertence ao dom??nio de Y . Analogamente,\n\nmostra-se que Y na?o pode receber o valor 1. Suponha agora que a restric?a?o X ? 5 seja\n\nimposta. Isto faz com que DX = [5, 9]. Como Y esta? relacionada a X pela restric?a?o X &lt;Y ,\n\no dom??nio de Y e? automaticamente alterado para DY = [6, 10].\n\nA consiste?ncia do sistema e? dita parcial porque na?o ha? algoritmos polinomiais conheci-\n\ndos que garantam a consiste?ncia total de um CSP gene?rico2 (Marriott &amp; Stuckey (1998)).\n\nAle?m disso, por questo?es de eficie?ncia, os algoritmos normalmente utilizados para detectar\n\nviolac?o?es das restric?o?es na?o sa?o capazes de identificar certos tipos de estados inconsistentes.\n\nUm desses algoritmos, denominado arc-consistency, funciona assim: sejam duas varia?veis,\n\nA e B, relacionadas por uma restric?a?o r, e cujos dom??nios sa?o, respectivamente, DA e DB.\n\nDiz-se que um valor vA ? DA tem suporte no dom??nio DB se, ao atribuir-se va a A, existir\n\num valor vB ? DB que pode ser atribu??do a B sem violar r. O algoritmo, enta?o, removera?\n\ndo dom??nio de cada varia?vel todos aqueles valores que na?o te?m suporte no dom??nio de uma\n\noutra varia?vel qualquer, associada a ela por alguma restric?a?o (Marriott &amp; Stuckey (1998)).\n\nEm resumo, o que acontece e? o seguinte: os dom??nios originais das varia?veis sa?o inicial-\n\nmente reduzidos pelas restric?o?es do programa. Neste instante, e? poss??vel que haja alguma\n\ninconsiste?ncia ainda na?o detectada. A seguir, da?-se in??cio ao processo de labeling (vide Ta-\n\nbela 4.1) onde, a cada passo, seleciona-se uma varia?vel a? qual sera? atribu??do um valor de seu\n\ndom??nio. A ordem de escolha das varia?veis e dos valores e? totalmente flex??vel e influencia\n\n2CSPs pertencem a? classe de problemas NP-completos.\n\n\n\n21\n\nno tempo de resposta do programa. Ao se atribu??rem valores a?s varia?veis, o mecanismo de\n\npropagac?a?o se encarrega de reduzir os outros dom??nios. Caso alguma inconsiste?ncia seja\n\ndetectada, a u?ltima atribuic?a?o de valor tem de ser desfeita (backtracking), dando lugar a\n\numa outra alternativa. O processo todo se repete ate? que uma soluc?a?o seja encontrada ou\n\nate? que se prove a inexiste?ncia de soluc?o?es via?veis (Marriott &amp; Stuckey (1998), Lever et al.\n\n(1995)).\n\nEm certos casos, procura-se na?o somente uma soluc?a?o via?vel qualquer, mas aquela que\n\nminimiza (ou maximiza) uma func?a?o objetivo. Uma forma de dar suporte ao conceito\n\nde otimizac?a?o em Programac?a?o por Restric?o?es e? a seguinte. Sempre que uma soluc?a?o e?\n\nencontrada, calcula-se o seu custo c e impo?e-se uma nova restric?a?o ao sistema indicando\n\nque o custo da pro?xima soluc?a?o devera? ser menor que c (em caso de minimizac?a?o). Repete-\n\nse este processo ate? que na?o haja mais soluc?o?es via?veis. Nesse ponto, a u?ltima soluc?a?o\n\nencontrada e? uma soluc?a?o de custo o?timo (Marriott &amp; Stuckey (1998), Lever et al. (1995)).\n\nUm grande desafio da programac?a?o por restric?o?es e? a criac?a?o de um modelo que repre-\n\nsente adequadamente as condic?o?es reais de um problema. Um modelo ruim, por exemplo,\n\npode gerar soluc?o?es erro?neas ou na?o satisfato?rias, e ate? mesmo na?o levar a uma soluc?a?o.\n\nO modelo, portanto, sera? um fator que determinara? o tempo de resposta do programa e a\n\nqualidade da soluc?a?o gerada.\n\n\n\nParte III\n\nO Trabalho Desenvolvido\n\n23\n\n\n\nCap??tulo 5\n\nORCA: Resolvedor de Programac?a?o\n\npor Restric?o?es\n\nEm 2000, um consultor da a?rea de Explorac?a?o e Produc?a?o (E&amp;P) da Petrobras decidiu\n\ncriar um projeto para automatizar o processo de escalonamento das atividades de desenvol-\n\nvimento de poc?os de petro?leo em alto mar e seus respectivos recursos (barcos e sondas), ate?\n\nenta?o feito manualmente. A ferramenta tambe?m deveria otimizar a produc?a?o de petro?leo.\n\nAlgumas ana?lises foram conduzidas e o time de projeto desenvolveu um modelo de\n\nProgramac?a?o por Restric?o?es (cf., Marriott &amp; Stuckey (1998)) usando as bibliotecas ILOG\n\nSolver e ILOG Scheduler (ILOG (1999a)). Essas bibliotecas permitem fa?cil modelagem,\n\nmanutenc?a?o e entendimento do co?digo.\n\nDepois de quatro anos de desenvolvimento, alterac?o?es, correc?o?es e melhorias, a ferra-\n\nmenta desenvolvida, de nome ORCA (\u201cOtimizac?a?o de Recursos Cr??ticos na Atividade de\n\nproduc?a?o\u201d), tornou-se operacional e bem sucedida.\n\nAs pro?ximas sec?o?es descrevem o modelo e os algoritmos utilizados no desenvolvimento\n\ndo ORCA.\n\n5.1 Modelo do ORCA\n\nA modelagem do ORCA foi feita utilizando o ILOG Solver e o ILOG Scheduler, bibliotecas\n\nC++ de Programac?a?o por Restric?o?es da ILOG 1. Usando tal abordagem, a representac?a?o do\n\nproblema e? feita desassociada dos algoritmos usados para resolve?-lo, dessa forma oferecendo\n\nfacilidade de desenvolvimento, entendimento e adaptac?a?o (ILOG (1999b)).\n\nO modelo consiste de dois tipos de varia?veis, ambos inteiros:\n\n1http://www.ilog.com\n\n25\n\n\n\n26 Cap??tulo 5. ORCA: Resolvedor de Programac?a?o por Restric?o?es\n\n(a) Tela Inicial (b) Tela de Busca de Soluc?a?o\n\nFigura 5.1: ORCA\n\n\u2022 Um que representa a data de in??cio de execuc?a?o da atividade por um recurso. E?\n\ncaracterizado por um m??nimo e ma?ximo tempo de in??cio.\n\n\u2022 Um que representa qual recurso executara? a atividade do poc?o. E? caracterizado por\n\num conjunto de poss??veis recursos, dos quais um deve ser escolhido para realizar a\n\nrespectiva atividade.\n\nTodas as restric?o?es descritas na Sec?a?o 2.2 foram impostas sobre as varia?veis descritas\n\nacima atrave?s de me?todos predefinidos das classes da ILOG. Por examplo, sendo a e b\n\natividades representadas por objetos da classe ILOG IlcActivity e seja P1 o modelo repre-\n\nsentado pela classe ILOG IlcManager, estabelecemos que a deve iniciar depois do fim de b\n\natrave?s do seguinte co?digo:\n\nP1.add(a.startsAfterEnd(b));\n\nO mecanismo de propagac?a?o das restric?o?es, responsa?vel pela reduc?a?o de dom??nio das\n\nvaria?veis, fica a cargo das bibliotecas da ILOG. Entretanto, a simples propagac?a?o das\n\nrestric?o?es na?o e? suficiente para se chegar a um valor u?nico nas varia?veis. Dessa forma,\n\nfaz-se necessa?rio utilizar de um algoritmo de busca para encontrar soluc?o?es.\n\n\n\n5.1. Modelo do ORCA 27\n\n5.1.1 Algoritmos do ORCA\n\nAs bibliotecas da ILOG prove?m na?o apenas um algoritmo de busca gene?rico, mas tambe?m\n\nmeios para se desenvolver um me?todo de busca pro?prio.\n\nNo ILOG Solver, a implementac?a?o de algoritmos de busca e? baseado na ide?ia de go-\n\nals. Goals tornam poss??vel a implementac?a?o de algoritmos em que a exata seque?ncia de\n\noperac?o?es na?o e? conhecida antecipadamente. Esse tipo de programac?a?o e? frequ?entemente\n\nconhecida como na?o-determin??stica, ja? que seus passos na?o esta?o determinados, ainda que\n\na programac?a?o tenha um propo?sito ou objetivo (goal) em vista.\n\nO mecanismo de busca explora o seguinte algoritmo: Enquanto existir alguma varia?vel\n\nsem valor fixo,\n\n1. escolha uma dessas varia?veis;\n\n2. atribua a? varia?vel um dos valores do seu dom??nio;\n\n3. propague os efeitos dessa atribuic?a?o.\n\nEntretanto, na?o se sabe qual valor no dom??nio e? consistente com as restric?o?es. Assim,\n\nse a atribuic?a?o levar a? inconsiste?ncias, ela deve ser desfeita e outro valor deve ser tentado.\n\nTal processo e? conhecido como backtracking.\n\n5.1.2 Func?a?o Objetivo\n\nA Petrobras na?o quer apenas uma soluc?a?o para o problema, mas uma soluc?a?o que maximize\n\na produc?a?o de petro?leo. Para isso, o ILOG Solver oferece meios predefinidos para minimizar\n\nou maximizar um crite?rio. A te?cnica usada no Solver e? o cla?ssico Branch &amp; Bound (Cormen\n\net al. (2001)).\n\nPara realizar a otimizac?a?o, a implementac?a?o da biblioteca ILOG segue o seguinte algo-\n\nritmo:\n\n1. Busque uma soluc?a?o da forma definida pelos goals inseridos no modelo.\n\n2. Salve a soluc?a?o encontrada.\n\n3. Acrescente a restric?a?o que estabelece que a pro?xima soluc?a?o deve ser pelo menos uma\n\nunidade melhor que a soluc?a?o encontrada anteriormente.\n\n4. Repita o processo ate? que nenhuma outra soluc?a?o seja encontrada ou ate? que o tempo\n\nde busca se esgote.\n\nAssim, ate? o fim da busca, teremos a melhor soluc?a?o encontrada, a com a maior produc?a?o\n\nde petro?leo.\n\n\n\n28 Cap??tulo 5. ORCA: Resolvedor de Programac?a?o por Restric?o?es\n\n5.1.3 Te?cnicas de Busca\n\nO ILOG Solver implementa va?rios procedimentos de busca de pesquisa operacional e in-\n\ntelige?ncia artificial, tais como best first search (BFS), limited discrepancy search (LDS),\n\ndepth bounded discrepancy search (DDS), e interleaved depth first search (IDFS). Esses\n\nprocedimentos de busca mudam a ordem na qual os no?s da a?rvore de busca sa?o explorados.\n\nA biblioteca implementa uma representac?a?o impl??cita dos estados de busca para arma-\n\nzenar va?rios estados a serem explorados. Essa representac?a?o envolve um caminho na a?rvore\n\nbina?ria de busca. O caminho consiste de uma seque?ncia de deciso?es \u2014 esquerda e direita\n\n\u2014 na a?rvore de busca. A busca vai de uma posic?a?o na a?rvore para outra atrave?s de uma\n\ncombinac?a?o de backtracking e recomputac?a?o (Clocksin (1987)).\n\nA busca do Solver trabalha assim: no?s abertos (isto e?, no?s que podem ser explorados) sa?o\n\nguardados numa pilha, e, a cada passo, o Solver escolhe o melhor no? aberto de acordo com\n\numa func?a?o de avaliac?a?o e o explora. O Solver implementa func?o?es de avaliac?a?o predefinadas\n\npara as seguintes te?cnicas de busca:\n\n\u2022 Depth First Search (DFS) e? o procedimento de busca padra?o do ILOG Solver. DFS\n\nconsidera as arestas de sa??da de um ve?rtice antes que os vizinhos daquele ve?rtice. O\n\nmaior problema do DFS e? que ele na?o se recupera de ma?s escolhas iniciais. Uma ma?\n\ndecisa?o tomada no in??cio pode levar a busca a percorrer inu?meros estados inconsis-\n\ntentes ou de baixa qualidade.\n\n\u2022 Best First Search (BFS) e? um algoritmo de busca que otimiza o Breadth First Search2\n\nvia ordenac?a?o de todos os caminhos correntes de acordo com alguma heur??stica. A\n\nheur??stica tenta predizer qua?o perto o caminho esta? de alcanc?ar uma soluc?a?o. Ca-\n\nminhos que sa?o tidos como mais pro?ximos de uma soluc?a?o sa?o explorados primeiro\n\n(Nilsson (1971)). A implementac?a?o do Solver usa um para?metro ?. Ao selecionar um\n\nno? aberto, o Solver determina o conjunto de no?s abertos cujo custo e? no ma?ximo 1 + ?\n\npior que o melhor no? aberto. Se o filho do no? corrente esta? nesse conjunto, o Solver\n\nexplora esse filho. Se na?o, o Solver escolhe o melhor no? aberto.\n\n\u2022 Limited Discrepancy Search (LDS) foi definido em Harvey &amp; Ginsberg (1995). A\n\ndiscrepa?ncia de um no? de busca e? definida como sua profundidade direita, isto e?, o\n\nnu?mero de vezes que a busca escolheu a ramificac?a?o direita em um ponto de escolha\n\n(choice point) quando ia do no? raiz ate? o no? corrente. Dado um para?metro k, a busca\n\nvai primeiro explorar no?s com discrepa?ncia menor que k. Depois que essa explorac?a?o\n\nfor completada, ele ira? explorar no?s com discrepa?ncia entre k e 2k, e assim por diante.\n\nDessa forma, essa busca corta a a?rvore de busca em tiras.\n\n2Breadth first search e? um algoritmo de busca em a?rvore que comec?a no no? raiz e explora todos os no?s\nvizinhos, e so? depois seus filhos.\n\n\n\n5.1. Modelo do ORCA 29\n\n\u2022 Depth Bounded Discrepancy Search (DDS) foi introduzido em Walsh (1997). Uma\n\nvariac?a?o do LDS, o DDS assume que ma?s escolhas sa?o provavelmente tomadas mais\n\npro?ximo do topo da a?rvore de busca. Por isso, esse procedimento na?o conta o nu?mero\n\nde discrepa?ncias, mas a profundidades da u?ltima. O ILOG Solver implementa uma\n\nversa?o aprimorada do esquema em Walsh (1997); na?o se conta a profundidade da\n\nu?ltima discrepa?ncia, mas a da d-e?sima u?ltima, onde d e? um para?metro da busca.\n\n\u2022 Interleaved Depth First Search (IDFS) foi introduzido em Meseguer (1997). IDFS\n\ntenta imitar o comportamento de um nu?mero infinito de threads explorando a a?rvore\n\nde busca. O Solver implementa uma variac?a?o que limita a profundidade deste com-\n\nportamento.\n\nTodas esses procedimentos de busca foram testados em insta?ncias reais do EDP. O BFS\n\nse provou ineficiente para o problema. Em quase todas as insta?ncias, ele na?o gerou soluc?o?es\n\ndentro da primeira hora de execuc?a?o. O DFS e o IDFS se mostraram bem melhores, mas os\n\nmelhores resultados foram obtidos usando o LDS e o DDS. Nos testes, o LDS foi levemente\n\nsuperior ao DDS, ale?m de ser mais flex??vel. Isso porque o DDS e? eficiente se a heur??stica de\n\nbusca e? muito boa, i.e., se ela faz ma?s escolhas apenas no topo da a?rvore de busca (ILOG\n\n(1999a)), o que e? algo dif??cil de se obter.\n\n5.1.4 Goals para Escalonar as Atividades\n\nApresentamos agora os goals criados para guiar o processo de busca. Eles sa?o executados\n\nna ordem em que sa?o apresentados:\n\n1. Escolhendo os recursos: Este goal seleciona para cada atividade o recurso dis-\n\npon??vel que menos foi utilizado ate? o momento.\n\n2. Tratando a restric?a?o C7: Caso haja seque?ncias de poc?os, este goal atribui datas de\n\nin??cio de execuc?a?o para as atividades das seque?ncias. Na ordenac?a?o das atividades,\n\nele seleciona a varia?vel dispon??vel entre aquelas das seque?ncias que ainda na?o foi\n\natribu??da e que gera o maior incremento na produc?a?o de petro?leo. Da?-se prefere?ncia\n\na?s atividades de perfurac?a?o em detrimento das de produc?a?o.\n\n3. Escalonando atividades de produc?a?o: Este goal atribui datas de in??cio de execu-\n\nc?a?o para as atividades de in??cio de produc?a?o. Na ordenac?a?o das atividades, ele seleci-\n\nona a varia?vel dispon??vel na?o atribu??da que gera o maior incremento na produc?a?o de\n\npetro?leo.\n\n\n\n30 Cap??tulo 5. ORCA: Resolvedor de Programac?a?o por Restric?o?es\n\n4. Escalonando as outras atividades: Este goal atribui a data de in??cio de todas as\n\natividades restantes. Na ordenac?a?o das atividades, ele seleciona a primeira ainda na?o\n\natribu??da.\n\n5.1.5 Resultados do ORCA\n\nO ORCA foi frequ?entemente utilizado por engenheiros da Petrobras para definir bons esca-\n\nlonamentos no desenvolvimento dos poc?os de petro?leo em alto mar. Foi tambe?m usado para\n\nanalisar a necessidade de se adquirir ou alugar novos recursos. Esses usua?rios confirmaram\n\nque o ORCA gera soluc?o?es pelo menos ta?o boas quanto as manuais. E, ale?m disso, demanda\n\napenas um minuto de execuc?a?o para gerar um bom escalonamento, quando manualmente\n\nse demorava de um a dois dias. Em uma de suas utilizac?o?es numa insta?ncia real, o ORCA\n\nmostrou ser melhor acrescentar um barco LSV a? comprar uma terceira sonda. Com isso, o\n\nORCA assegurou ganhos de US$15 milho?es a? Petrobras, e antecipou o in??cio de produc?a?o\n\ndos poc?os em 26 dias.\n\n\n\nCap??tulo 6\n\nO EDP sem Deslocamento de\n\nRecursos\n\nPro?logo\n\nO artigo a seguir trata o problema de escalonamento no desenvolvimento de poc?os de\n\npetro?leo em alto mar (EDP), na?o sendo considerados deslocamentos de recursos.\n\nApo?s uma descric?a?o detalhada do problema e das restric?o?es envolvidas, e? apresentado um\n\nresolvedor GRASP que supera uma ferramenta de programac?a?o por restric?o?es desenvolvida\n\npela Petrobras.\n\nEste artigo e? uma versa?o reduzida do relato?rio te?cnico Pereira et al. (2005b) e foi apre-\n\nsentado na confere?ncia Fourth International Workshop on Efficient and Experimental Al-\n\ngorithms (WEA2005, http://ru1.cti.gr/wea05/), que ocorreu na ilha de Santorini, Gre?cia,\n\nnos dias 10 a 13 de maio de 2005. O trabalho foi um dos 47 artigos regulares aceitos\n\ndentre 176 submetidos e foi publicado no volume 3503 da se?rie Lecture Notes in Computer\n\nScience, que conte?m os anais da confere?ncia (Pereira et al. (2005a)). Convidado, Romulo\n\nfoi apresentar seu trabalho na confere?ncia, tendo excelente receptividade pela comunidade\n\npresente. O artigo tambe?m esta? sendo considerado para o Special Issue of the ACM Journal\n\non Experimental Algorithmics (JEA, http://www.jea.acm.org), dedicado ao evento.\n\nO artigo esta? transcrito na sua ??ntegra, em ingle?s.\n\n31\n\n\n\n32 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nComparative Experiments with GRASP and\n\nConstraint Programming for the Oil Well Drilling\n\nProblem\n\nRomulo A. Pereira Arnaldo V. Moura Cid C. de Souza\n\nromulo a pereira@yahoo.com.br arnaldo@ic.unicamp.br cid@ic.unicamp.br\n\nInstitute of Computing, University of Campinas\n\nAbstract\n\nBefore promising locations become productive oil wells, it is often necessary to com-\n\nplete drilling activities at these locations. The scheduling of such activities must\n\nsatisfy several conflicting constraints and attain a number of goals. Here, we describe\n\na Greedy Randomized Adaptive Search Procedure (GRASP) for the scheduling of oil\n\nwell drilling activities. The results are compared with those from a well accepted con-\n\nstraint programming implementation. Computational experience on real instances\n\nindicates that the GRASP implementation is competitive, outperforming the con-\n\nstraint programming implementation.\n\n1 Introduction\n\nOil extracted from oceanic basins is an increasingly important fraction of the total world\n\noffer of petroleum and gas. Usually, diverse petroliferous basins are explored, each with\n\nhundreds of promising spots where productive oil wells could be located. However, before\n\nthese places are turned into productive wells they must be developed, that is, a sequence of\n\nengineering activities must be completed at each promising spot, to render them ready for\n\noil extraction. Oil derricks and ships are used to complete these activities. These resources\n\nare limited and expensive, either in acquisition or rent value, and must be used efficiently.\n\nThe oil well drilling problem (WDP) can be summarized thus: given a set of promising\n\nspots, the activities to be executed at each location, and the available resources, find a\n\nscheduling of the activities and resources, fulfilling several conflicting engineering and op-\n\nerational constraints, in such a way as to optimize some objective criteria. In this work,\n\nthe specific WDP faced by Petrobras (a leading company in deep water oil extraction) is\n\nstudied. This WDP imposes much more realistic constraints than other similar studies\n\n\n\n2. The Well Drilling Problem 33\n\n(do Nascimento (2002)). The constraints are presented in detail, and an heuristic strategy\n\nis developed in order to maximize oil production within a given time horizon.\n\nThe next section describes the WDP. Section 3 discusses a GRASP implementation for\n\nthe WDP. Section 4 presents our computational results obtained with this new algorithm\n\nand compares them to other results derived from a constraint programming implementation\n\npresently running at Petrobras. Finally, some concluding remarks are offered in the last\n\nsection.\n\n2 The Well Drilling Problem\n\nAfter a well is drilled, the preparation for oil extraction develops in several stages. First,\n\noil derricks place Wet Christmas Trees (or WCTs, structures where hydraulic valves are\n\nattached) at the mouth of the wells in order to avoid oil leakage. Later, boats connect\n\npipelines between WCTs and manifolds. Manifolds are metallic structures installed by\n\nboats at the sea floor. Their use prevents the need for exclusive pipelines connecting each\n\nwell to the surface, which would be prohibitively expensive. Once this stage is completed,\n\noil extraction can begin. For that, Stationary Units of Production (SUPs) are anchored at\n\nspecific locations in the surface, and boats interconnect manifolds to them. SUPs are used\n\nto process, and possibly store, the extracted products. Later, ships fetch the products from\n\nSUPs to land storage sites or other processing units. If the oil outflow is very high or a SUP\n\ndoes not have storage capacity, a petroliferous platform may be installed at the surface.\n\nThe constraints involved in the scheduling of oil development activities are:\n\nC1. Technological Precedence: sets an order between pairs of activities. When considering\n\nthe precedence between the start and finish of the activities in each pair, any of the\n\nfour possibilities can be present.\n\nC2. Mark-Activity: an activity must finish before or initiate after a fixed date, with or\n\nwithout lag time. This date is often related to some external event.\n\nC3. Baseline: sets the start date of the activities.\n\nC4. Use of Resources: to execute an activity, due to its intrinsic nature, a resource used\n\nmust match some operational characteristics. For a boat, it must be verified if the\n\non-board equipments can operate at the specified depth. For an oil derrick, its type\n\nand capabilities must be verified, as well as the maximum and minimum depth of\n\noperation and drilling.\n\nC5. Concurrence: two activities at the same well, or executed by the same resource,\n\ncannot be simultaneous.\n\n\n\n34 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nC6. Unavailability: resources may be unavailable for a period of time, either for mainte-\n\nnance reasons or due to contract expiration.\n\nC7. User Defined Sequences: the user can specify a sequence for the drilling or for the\n\n\u201cstart production\u201d activities of different wells. These sequences are specified by engi-\n\nneers in order to avoid loss of pressure in the oil field. If well A appears before well B\n\nin the sequence, then activity FA of well A must finish before the start of activity SB\nof well B. The activities FA and SB are either the activity of drilling or the activity\n\nof start production of their respective wells, according to the type of the sequence.\n\nC8. Surface Constraints: represented by a polygonal security area defined around a well.\n\nWhen a well is inside the restricted area of another well, activities executed at them\n\ncannot be simultaneous. These constraints must be verified between pairs of mobile\n\nand pairs of mobile and anchored oil derricks.\n\nC9. Cluster Constraints: an activity can be part of a cluster, which is a set of activities\n\nthat must use the same resource.\n\nC10. Same Derrick : it is desirable that the same oil derrick executes as much of the\n\nactivities at a well as possible, in order to avoid unnecessary displacements.\n\nThe oil yield is calculated as follows. Each well has an associated outflow and an activity\n\nthat marks the beginning of its production. When this last activity is concluded, the well is\n\nconsidered in production. The yield is obtained by multiplying the oil outflow by the period\n\nbetween that instant and the established time horizon. If the start production activity is\n\nset for after the time horizon, the corresponding yield is disregarded. The objective is to\n\nobtain a schedule of all activities, satisfying all constraints, while maximizing the oil yield.\n\nOther goals to be attained by automating the schedule of the activities are:\n\n1. Faster solutions. Human made solutions take many hours, even days, to be con-\n\nstructed. A faster method would permit the analysis of different scenarios for the\n\nsame problem, for example, by adding or removing resources. Furthermore, modifi-\n\ncations in already committed plans would not result in new hours, or days, spent in\n\nrescheduling.\n\n2. Better resource allocation. With an automated scheduling, all highly skilled engineers\n\nresponsible for the manual scheduling can receive other duties.\n\nFrom the above description, it can be seen that the WDP is a difficult combinatorial\n\nproblem. In fact, it is simple to devise a polynomial-time reduction to the classical Job\n\nShop Scheduling problem, showing that the WDP is NP-hard.\n\n\n\n3. A GRASP for the WDP 35\n\nThe WDP treated here shows several differences from similar problems studied in the\n\nliterature (do Nascimento (2002)). To tackle the same problem, a project team from Petro-\n\nbras developed a Constraint Programming (cf., Marriott &amp; Stuckey (1998)) model using\n\nILOG\u2019s Solver and Scheduler (ILOG (1999)). After four years of development and testing,\n\nthe tool, named ORCA (Portuguese acronym for \u201cOptimization of Critical Resources in\n\nthe Production Activity\u201d), became operational and very successful. Nowadays, the ORCA\n\nsolver is often used by engineers both to define a good schedule for the drilling activities\n\nand, also, to analyze the need for acquiring or renting new resources. They confirmed that\n\nORCA generates better solutions than those made by humans. In one real instance, ORCA\n\nshowed that buying a third oil derrick was unnecessary and that it was better to add a new\n\nLSV ship instead. As a result, Petrobras avoided a expenditure of US$ 15 million, while\n\nanticipating oil production by 26 days. Despite the good performance of ORCA, searching\n\nfor even better solutions is still important, since a tenth of a percent of improvement in\n\nthe oil production may represent millions of dollars in the company\u2019s revenue. The next\n\nsections show how we obtain such gains using GRASP.\n\n3 A GRASP for the WDP\n\nOur search for alternatives to compete with ORCA started with an implementation of Tabu\n\nSearch (Glover &amp; Laguna (1997)) for a simpler version of the WDP (do Nascimento (2002)).\n\nHowever, some issues proved to be particularly difficult to treat, especially the definition of\n\nan adequate neighborhood and ways to explore it. After some investigation, GRASP (Feo\n\n&amp; Resende (1995)) seemed most appropriate for the WDP. Contrary to what occurs with\n\nother metaheuristics, such as tabu search or genetic algorithms, which use a large number of\n\nparameters in their implementations, the basic GRASP version requires the adjustment of\n\nfewer parameters. Despite its simplicity, GRASP is a well studied metaheuristic which has\n\nbeen successfully applied to a wide variety of optimization problems (cf. Festa &amp; Resende\n\n(2001)). In particular, applications of GRASP to scheduling problems can be found in Aiex\n\net al. (2003), Bard &amp; Feo (1989), Feo &amp; Bard (1989), Feo et al. (1995) and Binato et al.\n\n(2001).\n\nThe next paragraphs review some GRASP basics and describe our specific implemen-\n\ntation designed to solve the WDP, named GRASP-WDP (GRASPW). The model and its\n\nalgorithms are shown in the subsequent paragraphs.\n\nGRASP Basics. In the GRASP methodology each iteration consists of two phases: con-\n\nstruction and local search (Feo &amp; Resende (1995)). Figure 1 illustrates a generic implemen-\n\ntation of GRASP, in pseudo-code. The input includes parameters for setting the candidate\n\nlist size (ListSize), the maximum number iterations (MaxIter), and the seed (Seed) for the\n\n\n\n36 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nrandom number generator. The iterations are carried out in lines 2-6. Each iteration con-\n\nsists of the construction phase (line 3), the local search phase (line 4) and, if necessary, the\n\nincumbent solution update (line 5). In the construction phase, a feasible solution is built,\n\nupdating the variable Solution. Then the local search algorithm seeks a better solution in\n\nthe neighborhood of Solution, according to a given criterion, and updates Solution. This\n\nprocess of construction, search and update is executed MaxIter times.\n\n1: procedure GRASP (ListSize, MaxIter, Seed)\n2: for k = 1 a MaxIter do\n3: Solution ? Construct Solution(ListSize, Seed);\n4: Solution ? Local Search(Solution);\n5: Update Solution(Solution, Best Solution F ound);\n6: end for\n7: return Best Solution F ound;\n8: end GRASP\n\nFigure 1: Pseudo-code of the GRASP Metaheuristic.\n\nIn the construction phase, a feasible solution is built one element at a time. Figure\n\n2 illustrates a generic implementation of the construction phase, in pseudo-code. Input\n\nincludes the candidate list size (ListSize) and the seed (Seed). The iterations are carried\n\nout in lines 2-8. At each iteration, the next element to be added is determined by adding\n\nall possible elements to a candidate list, ordered with respect to a greedy function that\n\nmeasures the, maybe myopic, benefit of selecting each element. This list is called the\n\nRestricted Candidate List (RCL). The adaptive component of the heuristic arises from the\n\nfact that the benefits associated with every element are updated at each iteration to reflect\n\nthe changes brought on by the selection of the element in the previous iteration. The\n\nprobabilistic component is present by the random choice of one of the best candidates in\n\nthe RCL, but usually not the best one. This way of choosing elements allows for different\n\nsolutions to be obtained at each iteration, while not necessarily jeopardizing the adaptive\n\ngreedy component. The solutions generated by the construction phase are not guaranteed\n\nto be locally optimal. Hence, it is almost always beneficial to apply a local search to attempt\n\nto improve each constructed solution. The search phase is a standard deterministic local\n\nsearch algorithm that seeks to optimize the solution built in the construction phase.\n\nThe GRASPW Implementation. The GRASPW implementation was constructed us-\n\ning the C/C++ programming language. The heuristic uses two types of integer variables.\n\nOne represents the beginning of execution of each activity in the corresponding well. These\n\nvalues range between a minimum and a maximum start time, with those values depending\n\non the current partial solution being constructed. The second type of variables represents\n\n\n\n3. A GRASP for the WDP 37\n\n1: procedure Construct Solution(ListSize, Seed)\n2: Solution ? 0;\n3: Evaluate the incremental costs of the candidate elements;\n4: while Solution is not a complete solution do\n5: Build the restricted candidate list, RCL(ListSize);\n6: Select an element s f rom the RCL at random;\n7: Solution ? Solution ? {s};\n8: Reevaluate the incremental costs;\n9: end while\n\n10: return Solution;\n11: end Construct Solution\n\nFigure 2: Pseudo-code of the Construction Phase of GRASP.\n\nwhich resource will execute each activity in its well. Their domains are characterized by a\n\nset of the possible resources, of whose one must be chosen to execute the activity. All the\n\nconstraints described in Section 2 were enforced. Three constraints, namely, C2, C3 and\n\nC4, were set while reading the problem data, before the search begins. Note that, in these\n\ncases, all values needed to set the constraints are already defined. The other constraints\n\nwere dealt with during the search for solutions, the variables involved being assigned single\n\nvalues.\n\nThe following adaptations were made to the procedure illustrated in Figure 1: (i) the\n\nsearch procedure was interrupted by a time limit instead of by the number of iterations;\n\nand (ii) During a complete run of the GRASPW heuristic, the value of ListSize can be\n\nmonotonically incremented by a fixed amount when a predefined interval of time is reached\n\nwith no improvement on the best solution. Doing so, the algorithm will explore larger\n\nregions of the search space. Alternatively, during a run of GRASPW, the value of ListSize\n\ncan be monotonically decremented between iterations, thus focusing into a greedier heuris-\n\ntic. With this scheme we obtain a dynamic sized RCL in opposition to the original static\n\nsized RCL. Note that, as GRASP iterations are independent, one could think that there is\n\nno difference between increasing and decreasing the RCL size. However, as we do not know\n\nin advance the amount of time the algorithm will execute at each run or when the RCL\n\nsize will be altered, we can not anticipate the result of a GRASPW run, when increasing\n\nor decreasing the RCL size.\n\nAs in the ORCA implementation, we seek solutions with the highest oil yield. To this\n\nend the construction phase illustrated in Figure 2 was modified thus:\n\n1. The first time ever the construction phase is initiated, we use ListSize equal to one,\n\nwhen the algorithm behaves like a pure greedy heuristic. With few constraints ob-\n\nstructing the greedy heuristic, it tends to generate a good or even very good solution.\n\n\n\n38 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nFor example, in two out of twelve real instances, the best solution was found in the\n\nfirst pass of the construction phase.\n\n2. Before line 3, we added a function called isPressed. It verifies if any activity of any well\n\nhas a start time with a small domain and if only one resource can do it at that time.\n\nBy a start time with a small domain we mean that its minimum and maximum values\n\nare very close, such that having only one resource able to execute it indicates that\n\nthere is almost no flexibility to schedule the activity. If there are such activities, the\n\nfunction schedules their wells. Retarding the schedule of such activities could render\n\nthe solution infeasible, as other activities may occupy the period of time where those\n\nactivities would be scheduled. We schedule the wells, and not only the activities, in\n\norder to comply with constraint C10.\n\n3. The candidates are defined by the production wells that are available (meaning that\n\nthere are no wells yet not scheduled which must precede them), or the injection wells\n\nthat have activities of production wells succeeding them. The activities of injection\n\nwells that do not have activities of production wells succeeding them are left to be\n\nscheduled after all others. Note that injection wells are not productive and therefore\n\nmust not be scheduled before production wells, unless there are constraints forcing\n\nsuch a schedule.\n\n4. The evaluation of incremental costs (line 3 of Figure 2) assesses how much oil a well\n\ncan offer until the end of the time horizon. The RCL is built with those wells that\n\noffer the highest yields of oil. Actually, not only the oil offer is considered, but also\n\nthe oil offer of the constrained successors of that well.\n\n5. In the construction phase, the next element to be introduced in the solution is chosen\n\nuniformly from the candidates in the RCL (line 5 of Figure 2). However, any proba-\n\nbility distribution can be used to bias the selection.We tried to bias the selection of\n\nthe candidates proportionally to their oil offer.\n\n6. To schedule the candidate well (line 7 of Figure 2), proceed as follows.\n\nAs long as there are activities not yet scheduled in the well: (i) choose any activity\n\navailable in the well, i.e., one not yet scheduled and such that there is no other one\n\nnot yet scheduled in the wells that must precede it; (ii) choose a resource for this\n\nactivity that can execute it, and that can complete the activity the earliest; (iii) set\n\nthe start time of the activity at the earliest possible time, i.e., the maximum between\n\nthe earliest time the resource is available to execute the activity and the minimum\n\nstart time of the activity; and (iv) all activities that are constrained to succeed the\n\nchosen one must have their minimum start times updated to satisfy any constraints.\n\n\n\n3. A GRASP for the WDP 39\n\nThe scheduling of a well is done so as to satisfy all constraints, including the seven\n\nones not yet enforced. In case of violations, and this can be tested after each activity\n\nis scheduled, the construction of this solution is aborted and a new one is started. In-\n\nstead, we could backtrack a few steps, but this would slow down this phase, especially\n\nif the first steps were not appropriate.\n\n7. After a well is scheduled, any activities that must succeed it has their minimum start\n\ntime updated to satisfy any constraints. If that is not possible, the construction of\n\nthis solution is also aborted.\n\nFor the search phase, an appropriate neighborhood was defined, so as to permit explo-\n\nrations quickly leading to better solutions. The 2-exchange local search algorithm based on\n\nthe disjunctive graph model of Roy &amp; Sussmann (1964) was used. The same neighborhood\n\nwas used in Binato et al. (2001) for a Job Shop Scheduling problem. In order to apply the\n\n2-exchange local search to the WDP, we swap two elements in the scheduling. For example,\n\nif in resource X the scheduling was ... ? X1 ? A ? X2 ? ... and in resource Y it was\n\n... ? Y 1 ? B ? Y 2 ? ..., where ? represents a conjunctive arc, the result of the swap\n\nwould be a schedule like ... ? X1 ? B ? X2 ? ... and ... ? Y 1 ? A ? Y 2 ? ...,\n\nin resources X and Y , respectively. Since the execution time of elements A and B can be\n\ndifferent, all activities after them may have their start times updated.\n\nWe need to decide, of course, what an element stands for. Some options are: (i) An\n\nactivity: with very small granularity, giving rise to huge neighborhoods (do Nascimento\n\n(2002)), and, worse, moving an activity to another position would possibly force us to move\n\nalso its predecessors and successors in the same well, because of constraints C10; or (ii) A\n\nwell: with higher granularity, but since the sequence of activities in a well may be splited\n\nin the present schedule due to constraints C1, some problems now being that moving all\n\nactivities takes time to verify all constraints, and exchanging the whole well may not be\n\npossible even though exchanging only part of it could be; or finally (iii) Part of a well:\n\n(that is, a maximal set of activities of the same well scheduled consecutively in the same\n\nresource) with medium granularity and already satisfying constraint C10.\n\nIn our implementation we chose the last possibility, where the local search algorithm\n\nexchanges all pairs of parts of two wells, no matter on what resource they have been\n\nscheduled. That neighborhood is of size O(n2), where n is the number of parts of wells.\n\nFor practical instances, this is one order of magnitude smaller than the neighborhood that\n\nuses activities as the moving elements.\n\nTo fully specify the local search phase we need a rule that defines how the neighborhood\n\nis searched and which solution replaces the current one. This rule is called the pivoting rule\n\n(Yannakakis (1997)), and examples of it are the first improvement rule (FIR) and the best\n\nimprovement rule (BIR). In the first case, the algorithm moves to a neighboring solution\n\n\n\n40 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nas soon as it finds a better solution; in the second case, all neighbors are checked and the\n\nbest one is chosen. In either case, the worst case running time of each iteration is bounded\n\nby O(n2), where n is the number of elements in the neighborhood. In the next section we\n\npresent a comparison between these two alternatives.\n\n4 Computational Results\n\nIn this section, computational results for the GRASPW implementation are given. They\n\nare also compared with results obtained with the ORCA implementation over the same\n\nreal instances. All tests were run on a platform equipped with a Sun SPARC Ultra 60\n\nprocessor running a Solaris 9 operating system at 450 MHz and with 1024 MB of RAM.\n\nBoth GRASPW and ORCA were allowed to run for 1800 seconds on each instance.\n\nTypical Instances. Twenty one real instances provided by Petrobras were used in our\n\ntests. Table 1 summarizes the dataset. Columns with the same numerical data refer to\n\ndistinct instances that differ in the number of other constraints, like C9. The first part of\n\nthat table displays the instances were no C7 constraints were found. In order to reduce the\n\namount of time spent in testing, in some experiments we used only 7 of these instances,\n\neliminating instances that differed only in the number of clusters (see constraint C9, in\n\nSection 2). The lower part shows the nine instances were C7 constraints were present. The\n\nORCA implementation had difficulties to handle these contraints.\n\nInstance 1 2 3 4 5 6 7 8 9 10 11 12\n# wells 29 22 29 29 17 22 22 29 29 22 29 22\n# activities 98 107 98 98 111 107 128 98 98 107 98 107\n# boats 1 1 2 1 1 2 1 1 1 2 1 2\n# derriks 3 2 3 3 2 2 3 3 3 2 3 2\n# C7 constr. 0 0 0 0 0 0 0 0 0 0 0 0\n\nInstance 13 14 15 16 17 18 19 20 21\n# wells 22 22 22 22 22 22 22 22 29\n# activities 107 107 107 107 107 107 107 107 98\n# boats 2 2 2 1 2 2 2 2 1\n# derriks 2 2 2 2 2 2 2 2 3\n# C7 constr. 1 1 1 1 1 1 1 1 2\n\nTable 1: Test instances.\n\nSetting GRASPW Parameters. In Section 3 we presented the idea of a dynamic sized\n\nRCL. There are at least two ways we could exploit this idea: we may decrease the number\n\n\n\n4. Computational Results 41\n\nof candidates through time, using a greedier heuristic; or we may increase the number of\n\ncandidates through time, in order to drive away from a local optimum into new regions of the\n\nsearch tree. In the first case, the initial RCL size is set to max(13, w), w being the number of\n\nwells, and is decreased by one every 300 seconds without improvement. In the second case,\n\nwe start with max(5, w) for the initial RCL size and increase it by one every 300 seconds\n\nwithout improvement. The first approach did not yield good results when applied to the\n\nWDP, generating the same or worse solutions than those found by GRASPW with a static\n\nsized RCL. However, the second approach proved promising. Figure 3.a shows the algorithm\n\nwith dynamic sized RCL generating better solutions after 150 thousand iterations, when\n\nthe RCL is increased. The same happens in Figure 3.b after 50 thousand iterations, when\n\nanother real instance is tested. Amongst twelve scenarios tested, four had better solutions\n\nwith the dynamic sized RCL, totalizing an increase of around 261 thousand barrels of oil.\n\nIn the other eight scenarios, the same solutions were found.\n\n(a) Instance 1 (b) Instance 2\n\nFigure 3: Static Sized RCL x Dynamic Sized RCL.\n\nAnother technique tested was to bias the selection towards some particular candidates,\n\nthose with the highest oil yield, but this strategy did not produce good results. Amongst\n\ntwelve instances tested, three had slightly worse solutions with such a bias function, totaling\n\na decreasing of 40 thousand barrels of oil. Worse, with the bias function in place, the\n\nalgorithm takes much more time to find the same solution than when no bias is used.\n\nSumming up all the differences in time for the twelve scenarios, with the bias function the\n\nalgorithm took 3431 more seconds to reach the same results, an average increase of 72%.\n\nWe also considered two options for searching the neighborhood and selecting a new\n\nneighbor: the first improvement rule (FIR) and the best improvement rule (BIR). We\n\ntested both of them on seven instances. The BIR heuristics proved to be the best one when\n\nfinding solutions whose production was equal to a predefined target value and with the\n\n\n\n42 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nleast number of iterations (see Figure 4 (a) and (c)). On average, to find a solution with\n\na predefined production, the BIR strategy used about 60% of the number of iterations of\n\nthe FIR strategy. On the other hand, the FIR strategy was faster in most instances (see\n\nFigure 4 (b) and (d)). On average, to find a solution with a predefined production, the FIR\n\nstrategy used 66% of the time used by the BIR strategy. That is because, on average, a\n\nFIR iteration was almost seven times faster than a BIR iteration. Since, to users, running\n\ntime was deemed important, the FIR strategy was found to better suit this problem.\n\n(a) Instance 1 - BIR (b) Instance 1 - FIR\n\n(c) Instance 2 - BIR (d) Instance 2 - FIR\n\nFigure 4: BIR \u00d7 FIR.\n\nThe ORCA and the GRASPW Implementations. Our GRASPW implementation\n\nfound better solutions than the ORCA implementation on all twelve but one of the real\n\ninstances tested and, in that one, it found the same solution. GRASPW achieved 0.14%\n\nmore oil production on average which, despite being a small percentage, means an increase\n\nof almost one million barrels of oil, in total. Perhaps, the highest gain with GRASPW was\n\nin running time. It found solutions with the same production of those generated by ORCA,\n\n\n\n5. Conclusions 43\n\non average, in only 36.3% of the time used by ORCA on the same instances. Figure 5.a\n\nshows that the best GRASPW solution has a production 290 thousand barrels of oil higher\n\nthan the best ORCA solution. Furthermore, GRASPW found a solution with the same\n\noil production of the best ORCA solution within the first second, while ORCA found it\n\nonly after 2200 seconds. Similarly, Figure 5.b shows that the best GRASPW solution has\n\na production of almost 200 thousand barrels of oil higher than the best ORCA solution.\n\nAgain, GRASPW found a solution with the same oil yield as the best ORCA solution within\n\nthe first second, while ORCA found it only after 1000 seconds.\n\n(a) Instance 1 (b) Instance 2\n\nFigure 5: ORCA x GRASPW.\n\nIn all the nine tested scenarios, where the constraints C7 were present, GRASPW found\n\nbetter solutions than ORCA. In one of them, ORCA could not find any solution, while\n\nGRASPW found one with about 26 million barrels of oil production. Comparing the other\n\neight scenarios, GRASPW achieved 5.3% more oil production, on average, which means an\n\nincrease of around 4.6 million barrels of oil, in total. In Figure 6 we present the results over\n\nfour such instances. In all of them GRASPW was more effective than ORCA.\n\n5 Conclusions\n\nScheduling activities efficiently is of paramount importance to the industry, in general.\n\nPetrobras, a leading company in deep water exploration of oil, presented us the WDP, a\n\nscheduling problem related to oil well drilling. Here we constrast two approaches to the\n\nWDP: the constraint programming tool ORCA and a GRASP implementation, dubbed\n\nGRASPW. Computational experiments were carried out on several real instances. We\n\nconclude that GRASPW greatly outperforms ORCA. Not only it generates solutions with\n\n\n\n44 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\n(a) Instance 3 (b) Instance 4\n\n(c) Instance 5 (d) Instance 6\n\nFigure 6: ORCA x GRASPW.\n\nhigher oil production, but often it outputs solutions with the same oil production as ORCA\n\nin much less time. We also note that ORCA already produced better results than the\n\nmanual solutions.\n\nIt is worth mentioning that ORCA is built over the ILOG Constraint Programming\n\nsuite, a set of highly expensive and sophisticated libraries with years of development. Us-\n\ning GRASPW, which was entirely programmed from the ground up, these costs could be\n\naverted. In opposition, the ILOG suite favors easiness of development, of maintenance and\n\nof understanding of the source code.\n\nAcknowledgements The third author was supported by grants 307773/2004-3 from\n\nCNPq and 03/09925-5 from FAPESP.\n\n\n\n6. References 45\n\n6 References\n\nAiex, R. M., Binato, S. and Resende, M. G. C., 2003, \u2018Parallel GRASP with path-relinking\n\nfor job shop scheduling\u2019, Parallel Computing 29(4), 393\u2013430.\n\nBard, J. F. and Feo, T. A., 1989, \u2018Operations sequencing in discrete parts manufacturing\u2019,\n\nManagement Science 35, 249\u2013255.\n\nBinato, S., Hery, W. J., Loewenstern, D. and Resende, M. G. C., 2001, A GRASP for job\n\nshop scheduling, in P. Hansen and C. C. Ribeiro, eds, \u2018Essays and surveys on metaheuris-\n\ntics\u2019, Kluwer Academic Publishers, pp. 59\u201379.\n\ndo Nascimento, J. M., 2002, Hybrid computational tools for the optimization of the pro-\n\nduction of petroleum in deep waters, Master\u2019s thesis, Institute of Computing, University of\n\nCampinas.\n\nFeo, T. A. and Bard, J. F., 1989, \u2018Flight scheduling and maintenance base planning\u2019, Man-\n\nagement Science 35, 1415\u20131432.\n\nFeo, T. A., Bard, J. and Holland, S., 1995, \u2018Facility-wide planning and scheduling of printed\n\nwiring board assembly\u2019, Operations Research 43, 219\u2013230.\n\nFeo, T. A. and Resende, M. G. C., 1995, \u2018Greedy randomized adaptative search procedures\u2019,\n\nJournal of Global Optimization 6, 109\u2013133.\n\nFesta, P. and Resende, M. G. C., 2001, GRASP: An annotated bibliography, Technical\n\nreport, AT&amp;T Labs.\n\nGlover, F. and Laguna, M., 1997, Tabu Search, Kluwer Academic Publishers, Norwell,\n\nMassachusetts.\n\nILOG, 1999, ILOG Solver 4.4 Reference Manual, ILOG.\n\nMarriott, K. and Stuckey, P. J., 1998, Programming with Constraints: An introduction,\n\nMIT Press, Cambridge, Massachusetts.\n\nRoy, B. and Sussmann, B., 1964, Les proble?mes d\u2019ordonnancement avec contraintes dis-\n\njonctives, in \u2018Note DS No 9 bis\u2019, SEMA, Paris.\n\n\n\n46 Cap??tulo 6. O EDP sem Deslocamento de Recursos\n\nYannakakis, M., 1997, Computational complexity, in E. H. L. Aarts and J. K. Lenstra, eds,\n\n\u2018Local Search in Combinatorial Optimization\u2019, John Wiley &amp; Sons, Chichester, pp. 19\u201355.\n\n\n\nEp??logo\n\nTodos os testes realizados tiveram um limite de tempo de execuc?a?o de 1800 segundos, con-\n\nforme ja? informado no artigo. Entretanto, engenheiros da Petrobras ao usar um resolvedor\n\npara o problema fixam um limite de tempo de apenas 120 segundos. Isso ocorre porque\n\nesses engenheiros realizam diversas ana?lises sobre uma mesma insta?ncia, ou seja, a testam\n\nretirando/adicionando/trocando restric?o?es e recursos, avaliando por exemplo a necessidade\n\nou benef??cios de se adquirir novas sondas ou barcos. Para poder executar um bom nu?mero\n\nde ana?lises e? prefer??vel usar um limite de tempo baixo, tendo em vista que o tempo desses\n\nengenheiros e? limitado. E? por isso que comparamos na?o so? a soluc?a?o final dos resolvedo-\n\nres, como tambe?m as curvas de produc?a?o gerada das soluc?o?es pelo tempo, e preferimos\n\nresolvedores que convergem rapidamente para boas soluc?o?es.\n\nJa? quanto ao tempo em que se da? a alterac?a?o do tamanho da RCL, o fixamos em 1/6\n\ndo tempo total, ou 300 segundos sem melhoras na melhor soluc?a?o, conforme ja? informado\n\nno artigo. Fixar um tempo na?o e? o ideal, pois ao se migrar para plataformas de hardware\n\nsuperior, esse tempo poderia se tornar excessivo. Assim, o que poderia ser feito e? fixar essa\n\nalterac?a?o pelo nu?mero de iterac?o?es GRASP proporcional ao limite de tempo fornecido. Tal\n\nna?o foi feito pois para se comparar de forma mais justa as te?cnicas BIR e FIR, quer??amos\n\num fator igual para alterac?a?o no tamanho da RCL. Se utiliza?ssemos o nu?mero de iterac?o?es,\n\num resolvedor com BIR, em que as iterac?o?es sa?o mais lentas que um com FIR, teria sua\n\nRCL alterada bem depois, prejudicando-o quando comparado a um resolvedor com FIR.\n\nAo se disponibilizar a ferramenta GRASP para a Petrobras, a alterac?a?o do tamanho da\n\nRCL devera? ser feita apo?s um nu?mero de iterac?o?es sem melhorias na melhor soluc?a?o, sendo\n\nesse nu?mero proporcional ao limite de tempo fornecido.\n\nUm ponto importante na?o mencionado no artigo e? que, como o GRASP faz uso de\n\nrandomizac?a?o, cada insta?ncia e? testada cinco vezes, e os resultados reportados sa?o sempre\n\numa me?dia dos testes. Poder-se-ia fazer uma ana?lise do desvio padra?o das produc?o?es das\n\nmelhores soluc?o?es geradas pelo GRASP, verificando formalmente sua robustez, mas tal na?o\n\nse mostrou necessa?rio. Isso porque em todos os testes realizados com um mesmo resolvedor\n\nem uma mesma insta?ncia, a diferenc?a entre as produc?o?es de soluc?o?es diferentes nunca\n\nsuperou os 0.5%. Dessa forma, um mesmo resolvedor GRASP mostra uma variac?a?o muito\n\npequena entre a qualidade de suas soluc?o?es para uma mesma insta?ncia.\n\nOutro ponto que vale a pena ressaltar e? que a vizinhanc?a utilizada no GRASP tambe?m\n\npoderia ser utilizada numa Busca Tabu. A Juliana em seu trabalho (do Nascimento 2002)\n\nteve dificuldades na definic?a?o de uma vizinhanc?a pois usou uma vizinhanc?a de larga escala,\n\nem que desenvolveu uma te?cnica h??brida entre programac?a?o por restric?o?es e Busca Tabu.\n\nA escolha da utilizac?a?o da metaheur??stica GRASP nessa tese se deveu principalmente a sua\n\nmenor quantidade de para?metros a serem ajustados.\n\n47\n\n\n\nApesar da ferramenta ORCA ter se apresentada robusta e eficiente, gerando ganhos ex-\n\npressivos a? Petrobras, nosso trabalho conseguiu gerar uma aplicac?a?o GRASP que produziu\n\nresultados ainda melhores que aqueles obtidos pelo ORCA. Diante do fato, obtivemos apoio\n\nda Petrobras para atacar uma versa?o estendida do EDP, agora considerando os desloca-\n\nmentos de recursos, como e? mostrado no cap??tulo a seguir.\n\n48\n\n\n\nCap??tulo 7\n\nO EDP com Deslocamento de\n\nRecursos\n\nPro?logo\n\nCom o sucesso obtido com o GRASP no EDP, a Petrobras se comprometeu a nos fornecer\n\ninformac?o?es para tratar tambe?m o deslocamento dos recursos, o que aproximaria ainda mais\n\nos escalonamentos gerados com os realmente executados na pra?tica. Dessa forma, surgiu o\n\nEDPDR, uma extensa?o importante do EDP.\n\nO artigo a seguir trata o problema de escalonamento no desenvolvimento de poc?os de\n\npetro?leo em alto mar com deslocamento de recursos (EDPDR). O texto esta? em ingle?s,\n\ntranscrevendo na ??ntegra o artigo submetido ao Journal of Heuristics.\n\nApo?s uma descric?a?o detalhada do problema e das restric?o?es envolvidas, e? apresentado um\n\nresolvedor GRASP que supera uma ferramenta de programac?a?o por restric?o?es desenvolvida\n\npela Petrobras. Como o problema se tornou bem mais complicado, o que prejudicou a\n\nperformance da ferramenta ORCA e a qualidade de suas soluc?o?es, incorporamos te?cnicas\n\nmais avanc?adas ao GRASP para aumentar ainda mais os ganhos obtidos em relac?a?o ao\n\nORCA.\n\nO estudo do EDPDR resultou em tre?s publicac?o?es:\n\n\u2022 Relato?rio Te?cnico: Pereira et al. (2005c), emitido pelo Instituto de Computac?a?o da\n\nUnicamp.\n\n\u2022 Pre?mio Petrobras de Tecnologia: O artigo, traduzido para o portugue?s, foi o terceiro\n\ncolocado dentre 25 inscritos na categoria Produc?a?o, recebendo premiac?a?o em dinheiro\n\ne uma bolsa de doutorado. Para mais detalhes, vide o site:\n\nhttp://www2.petrobras.com.br/tecnologia2/port/pptecnologia.asp.\n\n49\n\n\n\n\u2022 Journal of Heuristics: O artigo foi submetido e espera o retorno dos avaliadores. Vide:\n\nhttp://www.kluweronline.com/issn/1381-1231.\n\n50\n\n\n\n51\n\nGRASP Strategies for Scheduling Activities\n\nat Oil Wells with Resource Displacement\n\nRomulo A. Pereira Arnaldo V. Moura Cid C. de Souza\n\nromulo a pereira@yahoo.com.br arnaldo@ic.unicamp.br cid@ic.unicamp.br\n\nInstitute of Computing, University of Campinas\n\nAbstract\n\nBefore promising locations at petroliferous basins become productive oil wells, it is\n\nnecessary to complete development activities at these locations. The scheduling of\n\nsuch activities must satisfy several conflicting constraints and attain a number of goals.\n\nMoreover, resource displacements between wells are also important. We describe a\n\nGreedy Randomized Adaptive Search Procedure (GRASP) for the scheduling of oil\n\nwell development activities with resource displacement. The results are compared\n\nwith schedules produced by a well accepted constraint programming implementation.\n\nComputational experience on real instances indicates that the GRASP implementa-\n\ntion is competitive, outperforming the constraint programming implementation.\n\nToday, oil and gas are fossil fuels of wide use in our society. They are important\n\ningredients in the processes of making plastics, dyes, kerosene, gasoline, gas and many\n\nother products. A significant amount of these fossil fuels is extracted from oceanic basins,\n\ne.g., from the offshore Marlin basin in Rio de Janeiro, Brazil. Petrobras is a company with\n\nrecognized expertise in oil exploration in deep sea waters, being also one of the twenty\n\nbiggest oil companies in the world. Usually, Petrobras explores diverse petroliferous basins,\n\neach with hundreds of promising spots where productive oil wells could be located. However,\n\nbefore these places are turned into productive wells they must be developed, that is, a\n\nsequence of engineering activities must be completed at each promising spot, to render\n\nthem ready for oil extraction. Oil derricks and ships are used to complete these activities.\n\nThese resources have to move from one spot to another and such displacements must be\n\nconsidered when sequencing the activities. Furthermore, such resources are limited and\n\nexpensive, either in acquisition or rent value, and must be used efficiently.\n\nThe oil well development with resource displacement problem (WDRDP) can be sum-\n\nmarized thus: given a set of promising spots, the activities to be executed at each location,\n\n\n\n52 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nand the available resources, find a scheduling of the activities and resources, fulfilling sev-\n\neral conflicting engineering and operational constraints, including the displacements of the\n\nresources, in such a way as to optimize some objective criteria. In this work, the specific\n\nWDRDP faced by Petrobras is studied.\n\nThis WDRDP imposes much more realistic constraints than other similar studies (do\n\nNascimento (2002), Pereira et al. (2005)). Actually, Pereira et al. (2005) is an early\n\nversion of this paper, which did not consider the displacement of the resources. Here, we\n\nwill take this special characteristic into account. In addition, in this paper, we discuss other\n\nadvanced techniques not explored in Pereira et al. (2005).\n\nIn the sequel, the constraints are presented in detail and our GRASP heuristic strate-\n\ngies are developed, maximizing oil production within a given time horizon. The GRASP\n\nimplementations were built and tested over several real instances provided by Petrobras.\n\nThe best implementation indicated a gain of almost 16 million barrels of oil, or more\n\nthan US$ 830 millions, summing up over the average solutions of all the instances, when\n\ncompared to solutions generated by the constraint programming scheduler in use by the\n\ncompany. As another advantage, our methods rely on non commercial libraries, whereas\n\nthe constraint programming implementation relied on expensive third party constraint pro-\n\ngramming solvers.\n\nThe next section describes the WDRDP. Section 2 discusses GRASP implementations\n\nfor the WDRDP. Section 3 presents our computational results and compares them to\n\nother results derived from the constraint programming implementation presently running\n\nat Petrobras. Finally, some concluding remarks are offered in the last section.\n\n1 Scheduling the Development of Oil Wells\n\nWhen a spot is considered a promising oil well, oil derricks are sent there to accomplish the\n\ndue drilling operations. After a well is drilled, the preparation for oil extraction develops\n\nin several stages.\n\nFirst, in the stage called completion, oil derricks place Wet Christmas Trees (or WCTs,\n\nstructures where hydraulic valves are attached) at the mouth of the wells in order to avoid\n\noil leakage. Later, boats connect pipelines between WCTs and manifolds, this stage being\n\ncalled interconnection. Manifolds are metallic structures installed by boats at the sea floor.\n\nTheir use prevents the need for exclusive pipelines connecting each well to the surface,\n\nwhich would be prohibitively expensive. Once this stage is completed, oil extraction can\n\nbegin. For that, Stationary Units of Production (SUPs) are anchored at specific locations\n\nin the surface and boats interconnect manifolds to them. SUPs are used to process, and\n\npossibly store, the extracted products. Later, ships fetch the products from SUPs to land\n\nstorage sites or other processing units. If the oil outflow is very high or a SUP does not\n\n\n\n1. Scheduling the Development of Oil Wells 53\n\nhave storage capacity, a petroliferous platform may be installed at the surface.\n\nThere are two types of wells that may be developed: (i) productive wells, which are\n\nthose who have an oil yield; and (ii) injection wells, where only maintenance activities are\n\nexecuted and oil is not extracted from them.\n\n1.1 Oil Yield and Objectives\n\nThe oil yield is calculated as follows. Each well has an associated outflow and an activity\n\nthat marks the beginning of its production. When this last activity is concluded, the well\n\nis considered in production. The yield is obtained by multiplying the oil outflow by the\n\nperiod between that instant and the established time horizon of production. If the start\n\nproduction activity is set for a time after the horizon, the corresponding yield is disregarded.\n\nThe objective is to obtain a scheduling of all activities, satisfying all constraints, while\n\nmaximizing the oil yield.\n\nOther goals to be attained by automating the scheduling of the activities are:\n\n1. Faster solutions. Human made solutions take many hours, even days, to be con-\n\nstructed. A faster method would permit the analysis of different scenarios for the\n\nsame problem, for example, by adding or removing resources. Furthermore, modifi-\n\ncations in already committed plans would not result in new hours, or days, spent in\n\nrescheduling.\n\n2. Better resource allocation. With an automated scheduling, all highly skilled engineers\n\nresponsible for the manual scheduling can receive other duties.\n\n3. Savings. The automated schedule will, usually, result in a better use of boats and\n\nderricks, thereby saving considerable operational resources.\n\n1.2 The WDRDP Constraints\n\nThe constraints involved in the scheduling of oil well development activities are:\n\nC1. Technological Precedence: sets an order between pairs of activities. When considering\n\nthe precedence between the start and finish of the activities in each pair, any of the\n\nfour possible combinations can be present.\n\nC2. Mark-Activity: an activity must finish before or initiate after a fixed date, or mark,\n\nwith or without lag time. This date is often related to some external event, e.g., the\n\ninstallation of a petroliferous platform.\n\nC3. Baseline: sets the start date of the activities.\n\n\n\n54 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nC4. Use of Resources: to execute an activity, due to its intrinsic nature, a resource used\n\nmust match some operational characteristics. For a boat, it must be verified if the\n\non-board equipments can operate at the specified depth. For an oil derrick, its type\n\nand capabilities must be verified, as well as its maximum and minimum depth of\n\noperation and drilling.\n\nC5. Concurrence: two activities at the same well, or executed by the same resource, can\n\nnot be simultaneous.\n\nC6. Unavailability: resources may be unavailable for a period of time, either for mainte-\n\nnance reasons or due to contract expiration.\n\nC7. User Defined Sequences: the user can specify a sequence for the drilling activities or\n\nfor the \u201cstart production\u201d activities of different wells, depending to the type of this\n\nsequence. These sequences are specified by engineers in order to avoid loss of pressure\n\nin the oil field. If well A appears before well B in the sequence, then the activity of\n\nwell A must terminate before the start of activity of well B can be scheduled.\n\nC8. Surface Constraints: represented by a polygonal security area defined around a well.\n\nWhen the center of a well is inside the restricted area of another well, activities\n\nexecuted at both wells cannot be simultaneous. These constraints must be verified\n\nbetween pairs of mobile and pairs of mobile and anchored oil derricks.\n\nC9. Cluster Constraints: an activity may be part of a cluster, which is a set of activities\n\nthat must use the same resource.\n\nC10. Oil Derrick Displacements: when an oil derrick moves between two wells, a set-up\n\ntime1 will be considered. Therefore, unnecessary displacements must be avoided,\n\nfor example, by making the same oil derrick execute as much activities at a well as\n\npossible. For more details, see Subsection 1.4.\n\nFrom the above description, it can be seen that the WDRDP is a difficult combinatorial\n\noptimization problem. In fact, it is simple to devise a polynomial-time reduction from\n\nthe classical Job Shop Scheduling Problem (JSP) to the WDRDP, thus showing that the\n\nWDRDP is NP-hard. The WDRDP treated here shows several differences from similar\n\nproblems studied in the literature (do Nascimento (2002), Pereira et al. (2005)).\n\n1Time to unanchor, move and anchor in a new place.\n\n\n\n1. Scheduling the Development of Oil Wells 55\n\n1.3 The Constraint Programming Solution\n\nTo tackle the same problem, a project team from Petrobras developed a Constraint Pro-\n\ngramming (cf., Marriott &amp; Stuckey (1998)) model using ILOG\u2019s Solver and Scheduler2\n\n(ILOG (1999b)). After four years of development and testing, the tool, named ORCA3,\n\nbecame operational and very successful. Nowadays, the ORCA solver is often used by en-\n\ngineers both to define a good scheduling for the drilling activities and, also, to analyze the\n\nneed for acquiring or renting new resources. They confirmed that ORCA generates better\n\nsolutions than those made by humans. In one real instance, ORCA showed that buying a\n\nthird oil derrick was unnecessary and that it was better to add a new LSV ship instead. As\n\na result, an expenditure of US$ 15 million was avoided, while anticipating oil production\n\nby 26 days. Despite the good performance of ORCA, searching for even better solutions is\n\nstill important, since a tenth of a percent improvement in the oil production may represent\n\nan increase of millions of dollars in the company\u2019s revenue.\n\n1.4 The Resource Displacement\n\nAs already mentioned, here we will deal with a new facet of the problem, the resource\n\ndisplacement. This constraint forces a period of \u201cinactivity\u201d for the resource, so that it can\n\nunanchor, travel between two wells and anchor in the new spot. We call this period the\n\nset-up time. It is set between activities of different wells which are scheduled consecutively.\n\nIn Figure 1.a we see a typical schedule with no resource displacement. Each square in\n\nthe \u201cSchedule\u201d area represents a different well. A square in dark gray represents a group\n\nof activities of the same well which are executed by the resource, the light gray square,\n\nwhich is in the same horizontal line. In Figure 1.b, we present a schedule with resource\n\ndisplacement. Note that between each well there is a void period of time, which is the\n\nset-up time.\n\nThe set-up time is a constant for each resource. It is calculated by engineers, based\n\non the average speed of the resource and the average distance between spots in the field,\n\nplus the average time to anchor and unanchor. As engineers noted when scheduling the\n\nactivities at wells of an oil basin, the average distance between these wells does not differ\n\nmuch from the average distance traveled by the resources. The weather, which influences\n\nthe speed of the resource, was also considered in the average speed.\n\nHowever, different resources may have different set-up times. Consider, for example,\n\nresources X and Y in Figure 1.b. Note that the set-up time of Y is twice longer than the\n\nset-up time of X. This may alter the selection of which resource will execute activities\n\nat a well. For example, if both resources X and Y are available at the same instant and\n\n2Registered trade marks of ILOG Inc.\n3Portuguese acronym for \u201cOptimization of Critical Resources in the Production Activity\u201d.\n\n\n\n56 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\n(a) No Displacement (b) With Displacement\n\nFigure 1: Schedules without and with resource displacement.\n\ncan execute the next well to be scheduled, it does matter which resource we choose. This\n\nwould not be the case if both resources had the same set-up times. Thus, a good selection of\n\nwhich resource will execute the activity is even more important when resource displacement\n\nis considered.\n\nThe constraint programming solver had many difficulties when treating the resource\n\ndisplacement. A first approach used created virtual activities to represent the set-up time.\n\nBut, since as it is not known in advance if an activity from another well will be scheduled\n\nconsecutively, it would be necessary to create virtual activities dynamically, during the\n\nsearch for solutions. Of course they would have to be destroyed when backtracking. This\n\nprocess was quite complex and slowed down the search considerably, and so this approach\n\nwas abandoned. Instead, an if-then constraint was set, imposing that if the previous activity\n\nexecuted by the resource was from another well, then the current activity was shifted by\n\nthe corresponding set-up time. Of course, as this constraint needed to hold between each\n\npair of activities, the number of constraints added to the problem was n? (n?1)/2, where\n\nn is the number of activities. This increase in the number of constraints also slowed down\n\nthe execution of ORCA, and it did not generate very good solutions for many instances.\n\n2 GRASP Strategies for the WDRDP\n\nOur search for alternatives to compete with ORCA started with an implementation of a tabu\n\nsearch strategy (Glover &amp; Laguna (1997)) for a simpler version of the WDRDP (do Nasci-\n\nmento (2002)). However, some issues proved to be particularly difficult to treat, especially\n\nthe definition of an adequate neighborhood and ways to explore it. After some investigation,\n\nthe GRASP (Feo &amp; Resende (1995)) method seemed to be a more appropriate approach for\n\nthe WDRDP. Contrary to what occurs with other meta-heuristics, such as tabu search or\n\ngenetic algorithms which use a large number of parameters in their implementations, the\n\n\n\n2. GRASP Strategies for the WDRDP 57\n\nbasic GRASP version requires the adjustment of fewer parameters. Despite its simplicity,\n\nGRASP is a well studied meta-heuristic which has been successfully applied to a wide va-\n\nriety of optimization problems (cf. Festa &amp; Resende (2002)). In particular, applications of\n\nGRASP to scheduling problems can be found in Bard &amp; Feo (1989), Feo &amp; Bard (1989),\n\nFeo et al. (1995), Bard et al. (1996) and Binato et al. (2002). It is worth mentioning that\n\nGRASP proved itself very valuable in dealing with the well development problem without\n\nresource displacement (Pereira et al. (2005)).\n\nThe next paragraphs review some GRASP basics and describe our specific implemen-\n\ntation designed to solve the WDRDP, named GRASP-WDRDP (or GRASPW, for short).\n\nIn the sequel, we present some advanced GRASP techniques that were used to improve our\n\nsolver. The model and its algorithms are also shown in detail in the subsequent paragraphs.\n\n2.1 Greedy Randomized Adaptive Search Procedure (GRASP)\n\nIn the GRASP methodology each iteration consists of two phases: construction and\n\nlocal search (Feo &amp; Resende (1995)). Figure 2 illustrates a generic implementation of\n\nGRASP, in pseudo-code. The input includes parameters for setting the candidate list size\n\n(ListSize), the maximum number of iterations (MaxIter), and the seed (Seed) for the\n\nrandom number generator. The iterations are carried out in lines 2-6. Each iteration\n\nconsists of the construction phase (line 3), the local search phase (line 4) and, if necessary,\n\nthe incumbent solution update (line 5). In the construction phase, a feasible solution is built,\n\nupdating the variable Solution. Then the local search algorithm seeks a better solution in\n\nthe neighborhood of Solution, according to a given criterion, and updates Solution. This\n\nprocess of construction, search and update is executed MaxIter times.\n\n1: procedure GRASP (ListSize, MaxIter, Seed)\n2: for k = 1 to MaxIter do\n3: Solution ? Construct Solution(ListSize, Seed);\n4: Solution ? Local Search(Solution);\n5: Update Solution(Solution, Best Solution F ound);\n6: end for\n7: return Best Solution F ound;\n8: end GRASP\n\nFigure 2: Pseudo-code of the GRASP Meta-heuristic.\n\nIn the construction phase, a feasible solution is built one element at a time. Figure\n\n3 illustrates a generic implementation of the construction phase, in pseudo-code. Input\n\nincludes the candidate list size (ListSize) and the seed (Seed). The iterations are carried\n\nout in lines 2-8. At each iteration, the next element is selected from all possible elements\n\n\n\n58 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nadded to the candidate list. These elements are ordered with respect to a greedy function\n\nthat measures the, maybe myopic, benefit of selecting each element. This list is called the\n\nRestricted Candidate List (RCL). The adaptive component of the heuristic arises from the\n\nfact that the benefits associated with every element are updated at each iteration to reflect\n\nthe changes brought on by the selection of the candidate in the previous iteration. The\n\nprobabilistic component is present by the random choice of one of the best candidates in\n\nthe RCL, but usually not the best one. This way of choosing elements allows for different\n\nsolutions to be obtained at each iteration, while not necessarily jeopardizing the adaptive\n\ngreedy component.\n\nThe solutions generated by the construction phase are not guaranteed to be locally op-\n\ntimal. Hence, it is almost always beneficial to apply a local search procedure to improve the\n\nconstructed solution. The search phase is a standard deterministic local search algorithm\n\nthat seeks to optimize the solution built in the construction phase.\n\n1: procedure Construct Solution(ListSize, Seed)\n2: Solution ? 0;\n3: Evaluate the incremental costs of the candidate elements;\n4: while Solution is not a complete solution do\n5: Build the restricted candidate list, RCL(ListSize);\n6: Select an element s f rom the RCL at random;\n7: Solution ? Solution ? {s};\n8: Reevaluate the incremental costs;\n9: end while\n\n10: return Solution;\n11: end Construct Solution\n\nFigure 3: Pseudo-code of the Construction Phase of GRASP.\n\n2.2 GRASP Advanced Techniques\n\nAs the problem increased in complexity, compared to the problem with no resource dis-\n\nplacement studied in Pereira et al. (2005), we decided to consider some improvements and\n\nalternative techniques to be introduced in the basic GRASP procedure.\n\nBias Function: In the construction procedure of the basic GRASP, the next element to\n\nbe introduced in the solution is chosen at random from the candidates in the RCL.\n\nThe elements of the RCL are assigned equal probabilities of being chosen. However,\n\nany probability distribution can be used to bias the selection toward some particular\n\ncandidates. Bresina (1996) proposed a construction mechanism based on the rank\n\nr(?) assigned to each candidate element ?, according to its value, measured by the\n\n\n\n2. GRASP Strategies for the WDRDP 59\n\ngreedy function, v(?). However, as the sorting of elements to obtain the rank has\n\ntime complexity O(n log n), where n is the number of elements in the RCL, and since\n\nthe sorting must be repeated at each choice of an element, this process could slow\n\ndown the implementation. Thus, we decided to use directly the value v(?) of the\n\ncandidates to create the following bias functions:\n\n\u2022 uniform: bias(?) = 1\n\n\u2022 linear: bias(?) = v(?)\n\n\u2022 log: bias(?) = ln v(?)\n\n\u2022 exponential: bias(?) = ev(?)\n\n\u2022 quadratic: bias(?) = v(?)2\n\n\u2022 square root: bias(?) =\n?\n\nv(?)\n\nOnce the value of the bias function is evaluated for all elements of the RCL, the\n\nprobability of the candidate ? being chosen is:\n\nbias(?)\n?\n\n???RCL\nbias(??)\n\nProximate Optimality Principle (POP): This technique is based in the idea that\n\n\u201cgood solutions at one level are likely to be found \u2018close to\u2019 good solutions at an\n\nadjacent level\u201d (Glover &amp; Laguna (1997)). Fleurent &amp; Glover (1999) provided a\n\nGRASP interpretation of this principle. They suggested that imperfections introduced\n\nduring steps of the GRASP construction phase can be ironed out by applying local\n\nsearch during (and not only at the end of) the GRASP construction phase. Due to\n\nefficiency considerations, a practical use of the POP in a GRASP implementation\n\nwould be to apply a local search during a few points in the construction phase, and\n\nnot at the end of each construction iteration. Binato et al. (2002), when dealing with\n\na JSP, applied a local search when 40% and 80% of the construction moves have been\n\ntaken, as well as at the end of the construction phase. Due to the relation between\n\nthe JSP and the WDRDP (see Section 1.2), and after some promising tests, the same\n\nvalues were used in our GRASP solver.\n\nOne possible shortcoming of the basic GRASP method is the independence of its iter-\n\nations, i.e., the fact that it does not learn from the history of solutions found in previous\n\niterations. This is so because the standard algorithm discards information about any so-\n\nlution encountered that does not improve the incumbent solution. Information gathered\n\nfrom good solutions can be used to implement memory-based procedures. We show some\n\nof these strategies below.\n\n\n\n60 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nIntensification: Fleurent &amp; Glover (1999) observed that the standard GRASP does not\n\nuse long term memory and proposed a scheme to use this kind of memory in the\n\nheuristic. Long term memory is one of the pillars of tabu search. The idea of the\n\napproach is to maintain a set of elite solutions. To be included in this set, a solution\n\nmust either be better than all elite solutions according to some objective function, or\n\nmust be better than the worst solution of the set, while being sufficiently different\n\nfrom all elite solutions. In our problem, a solution is considered sufficiently different\n\nfrom another if the number of activities that have different start dates in both, or the\n\nnumber of different resources allocated to both is higher than the number of activities\n\ndivided by the number of resources. As the number of resources is usually smaller\n\nthan five, two solutions will be sufficiently different if at least 20% of their activities\n\nhave a different start date or resource allocated to both.\n\nWe show next how the elite solutions will bias the selection of the candidates in the\n\nGRASP construction phase. To each candidate ? we evaluate the intensity function\n\nInt(?) as follows:\n\nInt(?) =\n\n?\n\nei?S\nP rod(ei)\n\nMaxej ?EP rod(ej)\n.\n\nIn this function, S is the set of elite solutions in which the element ? has the same\n\nstart date and resource allocated when compared to the solution being built; P rod()\n\nis the value of oil yield associated with a solution, E is the set of elite solutions, and\n\nMax returns the maximum value in the indicated set.\n\nLet iter be the amount of iterations executed and k a parameter, we define the bias\n\nfunction using the intensity function as follows:\n\nbiasInt(?) = bias(?) +\nInt(?) \u00b7 iter\n\nk\n\nThe fraction iter/k is used to give emphasis to the intensity function as the number of\n\niterations increases, and thus the quality of the elite solutions in which the intensity\n\nfunction is based also possibly increases.\n\nPath-Relinking (P-R): This technique was originally proposed in Glover (1996) as\n\nan intensification strategy exploring trajectories connecting elite solutions obtained\n\nby tabu search or scatter search methods (Glover (2000), Glover &amp; Laguna (1997),\n\nGlover et al. (2000)). Starting from one or more elite solutions, paths in the solution\n\nspace leading towards other elite solutions are generated and explored in the search\n\nfor better solutions. This is accomplished by selecting moves that introduce, in the\n\n\n\n2. GRASP Strategies for the WDRDP 61\n\nmoving solution, attributes contained in the target solution. Path-relinking may be\n\nviewed as a strategy that seeks to incorporate attributes of high quality solutions, by\n\nfavoring these attributes in the selected moves.\n\nThe use of path-relinking within a GRASP procedure was first proposed in Glover\n\net al. (2000). It was followed by several extensions, improvements and successful\n\napplications (Aiex et al. (2000), Canuto et al. (2001), Resende &amp; Ribeiro (2001)).\n\nTwo basic strategies are:\n\n\u2022 path-relinking is applied as a post-optimization step to all pairs of elite solutions.\n\n\u2022 path-relinking is applied as an intensification strategy to each local optimum\n\nobtained after the local search phase.\n\nAccording to Resende &amp; Ribeiro (2002) the second strategy is more promising. An-\n\nother consideration, also from Resende &amp; Ribeiro (2002), is that exploring the two\n\ntrajectories, in both directions, between two solutions results in small gains and de-\n\nmands twice the time. Thus, it is usually more appropriate to explore only one path,\n\nthe one from the best solution to the other, as better solutions are more often found\n\nnear the neighborhood of the best solutions (Resende &amp; Ribeiro (2002)).\n\nSelective Local Search (SLS): Another approach that can be used within the standard\n\nGRASP procedure is to apply local search only in those solutions sufficiently different\n\nfrom the elite solutions, or that have a good quality, i.e., better than the worst of\n\nthe elite solutions. In other words, we try to apply local search only where there are\n\nhigher chances of obtaining better solutions, improving the efficiency of the algorithm.\n\n2.3 The New GRASP Solver Implementation: GRASPW\n\nThe GRASPW implementation was constructed using the C/C++ programming language.\n\nOur model uses two types of integer variables. One represents the beginning of execution\n\nof each activity in the corresponding well. These values range between a minimum and\n\na maximum start time, depending on the current partial solution being constructed. The\n\nsecond type of variables represents which resource will execute each activity in a well. Their\n\ndomains are characterized by a set of the possible resources, of whose one must be chosen\n\nto execute the corresponding activity.\n\nAll the constraints described in Section 1 were enforced. Three constraints, namely,\n\nC2, C3 e C4, were set while reading the problem data, before the search begins. Note\n\nthat, in these cases, all values needed to set the constraints are already defined. The other\n\nconstraints were dealt with during the search for solutions, the variables involved being\n\nassigned single values.\n\n\n\n62 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nConstraint C10, that deals with resource displacement and which was responsible for a\n\nloss of performance of the ORCA search algorithm, was treated here in a simple way. As we\n\ndo not use a mechanism of constraint propagation, we displace the current activity by at\n\nleast the amount of the set-up time, if the previous activity scheduled in the same resource\n\nis from a different well.\n\nOf course, we could also have imposed constraint C10 during the search in ORCA\n\ninstead of writing such constraints directly in the model. However this was not done for\n\ntwo reasons:\n\n\u2022 First, this goes against the fundamental design principle in constraint programming,\n\nwhich dissociates the representation of the problem from strategies for its resolution\n\n(ILOG (1999c), ILOG (1999a)). This approach is known as declarative programming.\n\nIn other words, this separation of the model from the search has a number of prac-\n\ntical implications: it shortens development time, decreases maintenance problems\n\nand heightens adaptability of the application. Furthermore, such separation makes\n\nit easier to experiment with different strategies and different algorithms without re-\n\ndesigning the model, and even allows for the addition of further constraints to the\n\nproblem without having to rewrite the search method.\n\n\u2022 Besides generating solutions to the WDRDP, ORCA has also the functionality of\n\nvalidating the model. If the data of the problem generates inconsistencies, ORCA\n\nwill inform the user that there is no feasible solution to the problem. In order to\n\nvalidate the import data, all the constraints must be imposed in the model, including\n\nthe C10 constraints. Our GRASP solver does not have this functionality.\n\n2.4 The Construction Phase\n\nThe following two adaptations were made to the procedure illustrated in Figure 2:\n\n\u2022 The search procedure was interrupted by a time limit instead of by the number of\n\niterations; and\n\n\u2022 During a complete run of the GRASPW meta-heuristic, the value of ListSize can\n\nbe monotonically incremented by a fixed amount when a predefined interval of time\n\nis reached with no improvement on the best solution. This allows the algorithm to\n\nexplore larger regions of the search space. Alternatively, during a run of GRASPW,\n\nthe value of ListSize can be monotonically decremented between iterations, thus\n\nfocusing into a greedier heuristic. With this scheme we obtain a dynamic sized RCL,\n\nin opposition to the original static sized RCL. Note that, as GRASP iterations are\n\nindependent, one could imagine that there is no difference between increasing and\n\n\n\n2. GRASP Strategies for the WDRDP 63\n\ndecreasing the RCL size. However, as we do not know in advance the amount of time\n\nthe algorithm will execute in each run, or when the RCL size will be altered, we can\n\nnot anticipate the result of a GRASPW run, when increasing or decreasing the RCL\n\nsize.\n\nAs in the ORCA implementation, we seek solutions with the highest oil yield. To this\n\nend, the construction phase illustrated in Figure 3 was modified thus:\n\n1. The first time the construction phase is initiated, we use ListSize equals to one, when\n\nthe algorithm behaves like a greedy heuristic. With few constraints obstructing the\n\ngreedy heuristic, it tends to generate good or even very good solutions. For example,\n\nin six out of seventeen real instances, the best solution was found in the first pass of\n\nthe construction phase.\n\n2. The candidates are defined by the production wells that are available (meaning that\n\nthere are no wells yet not scheduled which must precede them), or the injection wells\n\nthat have activities of production wells succeeding them. The activities of injection\n\nwells that do not have activities of production wells succeeding them are left to be\n\nscheduled after all others. Note that injection wells are not productive and there-\n\nfore must not be scheduled before production wells, unless there are technological\n\nconstraints forcing such a schedule. We schedule the wells and not single activi-\n\nties because otherwise the solution would have a huge number of displacements of\n\nresources between wells, which would affect the oil production negatively.\n\n3. The evaluation of incremental costs (line 3 of Figure 3) assesses how much oil a well\n\ncan offer until the end of the time horizon. The RCL is built with those wells that\n\noffer the highest yields of oil. Actually, not only the oil offer is considered, but also\n\nthe oil offer of the constrained successors of a well.\n\n4. In the construction phase, the next element to be introduced in the solution is chosen\n\nuniformly from the candidates in the RCL (line 5 of Figure 3). However, any proba-\n\nbility distribution can be used to bias the selection (see Section 2.2). We tried some\n\nbias functions in the selection of the candidates, as will be discussed later.\n\n5. To schedule the candidate well (line 7 of Figure 3), the routine is as follows.\n\nAs long as there are activities not yet scheduled in the well:\n\n(a) choose any activity available in the well, i.e., one not yet scheduled and such\n\nthat there is no other activity not yet scheduled in the wells that must precede\n\nit;\n\n\n\n64 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\n(b) choose a resource for this activity that can execute it, and that can complete the\n\nactivity the earliest;\n\n(c) set the start time of the activity at the earliest possible time, i.e., the maximum\n\nbetween the earliest time the resource is available to execute the activity (con-\n\nsidering the constraints, including the set-up time) and the minimum start time\n\nof the activity; and\n\n(d) all activities that are constrained to succeed the chosen one must have their\n\nminimum start times updated so that all constraints are satisfied.\n\nThe scheduling of a well is done so as to satisfy all constraints, including the seven\n\nones not yet enforced while reading the problem data. In case of violations, and\n\nthis can be tested after each activity is scheduled, the construction of this solution is\n\naborted and a new one is started. We could, instead, backtrack a few steps, but this\n\nwould slow down this phase, especially if the first steps were not appropriate.\n\n6. After a well is scheduled, any activities that must succeed it have their minimum start\n\ntimes updated to satisfy all constraints. If that is not possible, the construction of\n\nthis solution is also aborted.\n\n2.5 The Local Search Phase\n\nAs we have no guaranties that the solution found in the construction phase is locally opti-\n\nmum, a local search is used to improve the solution. For the search phase, an appropriate\n\nneighborhood was defined, so as to permit explorations that quickly lead to better solu-\n\ntions. The 2-exchange local search algorithm based on the disjunctive graph model of Roy\n\n&amp; Sussmann (1964) was used. The same neighborhood was used in Binato et al. (2002)\n\nfor a Job Shop Scheduling problem. In order to apply the 2-exchange local search to the\n\nWDRDP, we swap two elements in the scheduling. For example, consider the schedule\n\npresented in Figure 4.a. The elements (light gray squares) are executed by the resource\n\n(dark gray squares) which is depicted in the same horizontal line. The size of the squares\n\nrepresents the execution time of the corresponding elements. We swap elements A and B,\n\nwhich results in the schedule shown in Figure 4.b. Since the execution time of elements A\n\nand B can be different, all activities after them may have their start times updated.\n\nWe need to decide, of course, what an element stands for. Some options are:\n\n1. An activity. Very small granularity, giving rise to huge neighborhoods (do Nascimento\n\n(2002)) and, worse, moving an activity to another position would possibly force its\n\npredecessors and successors in the same well to be moved as well, in order to avoid\n\nthe displacements that may result from constraints of type C10;\n\n\n\n2. GRASP Strategies for the WDRDP 65\n\n(a) Before (b) After\n\nFigure 4: 2-exchange swap.\n\n2. A well. With higher granularity. But since the sequence of activities in a well may be\n\nsplitted in the present schedule due to constraints of type C1, moving all activities\n\ntakes time to verify all constraints, and exchanging the whole well may not be possible\n\neven though exchanging only part of it could be;\n\n3. Part of a well. That means a maximal set of activities of the same well scheduled con-\n\nsecutively in the same resource. With medium granularity, it avoids the displacements\n\nthat may result from constraints of type C10.\n\nIn our implementation, we chose the last alternative, where the local search algorithm\n\nexchanges all pairs of parts of wells, no matter on what resource they have been scheduled.\n\nThat neighborhood is of size O(n2), where n is the number of parts of wells. For practical\n\ninstances, this is one order of magnitude smaller than the neighborhood that uses activities\n\nas the moving elements.\n\nTo fully specify the local search phase we need a rule that defines how the neighborhood\n\nis searched and which solution replaces the current one. This rule is called the pivoting rule\n\n(Yannakakis (1997)), and examples of it are the first improvement rule (FIR) and the best\n\nimprovement rule (BIR). In the first case, the algorithm moves to a neighboring solution\n\nas soon as it finds a better solution; in the second case, all neighbors are checked and the\n\nbest one is chosen. In either case, the worst case running time of each iteration is bounded\n\nby O(n2), where n is the number of elements in the neighborhood. In the next section we\n\npresent a comparison between these two alternatives.\n\nBesides the improvements proposed above to the standard GRASP procedure, all the\n\nadvanced techniques presented in Section 2.2 were implemented and tested.\n\n\n\n66 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\n3 Computational Results\n\nIn this section, computational results for the GRASPW implementation are discussed. They\n\nare also compared with results obtained with the ORCA implementation over the same real\n\ninstances. All tests were run on a platform equipped with a Sun SPARC Ultra 60 processor,\n\nrunning a Solaris 9 operating system at 450 MHz and with 1024 MB of RAM. Both the\n\nGRASPW and the ORCA implementations were allowed to run for 1800 seconds on each\n\ninstance.\n\n3.1 Typical Instances\n\nTwenty two real instances provided by Petrobras were used in our tests. Table 1 summarizes\n\nthe dataset. Columns with the same numerical data, like columns 8 and 9, refer to distinct\n\ninstances that differ in the number of other constraints not shown in the table, like C9. The\n\nfirst part of that table displays the instances were no C7 constraints were found. In order\n\nto reduce the amount of time spent in testing, in some experiments we used only 7 of these\n\ninstances, eliminating instances that differed only by a few constraints. The lower part of\n\nTable 1 shows the ten instances were C7 constraints were present. It is worth mentioning\n\nthat, as GRASP makes use of randomization, each instance was tested five times, and the\n\nresults being reported always reflect the average of the tests.\n\nThe horizon of production ranges from a thousand to three thousand days. Note that,\n\nafter every well has been scheduled, the oil yield is the same between all solutions until\n\nthe horizon of production. Thus, any gains in production, when comparing two solutions,\n\nhappen before all wells are scheduled. If we considered the full horizon to compute yields,\n\nthese gains, in percent, would be smaller. Therefore, for each instance we use as the horizon\n\nof production the end date of the last activity of the well scheduled the latest, among all\n\nsolutions of the solvers.\n\n3.2 Setting GRASPW Parameters\n\nIn Section 2 we presented the idea of a dynamic sized RCL. There are at least two ways\n\nwe could exploit this idea: we may decrease monotonically the number of candidates using\n\na greedier heuristic; or we may increase monotonically the number of candidates in order\n\nto drive away from a local optimum into new regions of the search tree. In the first case,\n\nthe initial RCL size is set to max(13, w), w being the number of wells, and is decreased by\n\none every 300 seconds without improvement. In the second case, we start with max(5, w)\n\nfor the initial RCL size and increase it by one every 300 seconds without improvement.\n\nThe first approach did not yield good results when applied to the WDRDP, generating the\n\nsame or worse solutions than those found by GRASPW with a static sized RCL. However,\n\n\n\n3. Computational Results 67\n\nInstance 1 2 3 4 5 6 7 8 9 10 11 12\n# wells 29 22 29 29 17 22 22 29 29 22 29 22\n# activities 98 107 98 98 111 107 128 98 98 107 98 107\n# boats 1 1 2 1 1 2 1 1 1 2 1 2\n# derricks 3 2 3 3 2 2 3 3 3 2 3 2\n# C7 0 0 0 0 0 0 0 0 0 0 0 0\n\nInstance 13 14 15 16 17 18 19 20 21 22\n# wells 22 22 22 22 22 22 22 22 29 65\n# activities 107 107 107 107 107 107 107 107 98 338\n# boats 2 2 2 1 2 2 2 2 1 1\n# derricks 2 2 2 2 2 2 2 2 3 2\n# C7 1 1 1 1 1 1 1 1 2 2\n\nTable 1: Tested Instances.\n\nthe second approach proved promising. Figure 5.a shows the algorithm with dynamic sized\n\nRCL generating better solutions after 150 thousand iterations, when the RCL is increased.\n\nThe same happens in Figure 5.b after 50 thousand iterations, when another real instance is\n\ntested. Amongst twelve scenarios tested, four had better solutions with the dynamic sized\n\nRCL, summing up an increase of around 261 thousand barrels of oil. In the other eight\n\nscenarios, the same solutions were found.\n\n(a) Example 1 (b) Example 2\n\nFigure 5: Static Sized RCL Solver x Dynamic Sized RCL Solver.\n\nWe also considered two options for searching the neighborhood and selecting a new\n\nneighbor: the first improvement rule (FIR) and the best improvement rule (BIR) strategy.\n\nTests were executed and FIR has proved to be better. The BIR heuristics found solutions\n\nwhose production was equal to a predefined target value with the least number of iterations\n\n\n\n68 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\n(see Figure 6.a). On average, to find a solution with a predefined production, the BIR\n\nstrategy used about 60% of the number of iterations of the FIR strategy. On the other\n\nhand, the FIR strategy was faster in most instances (see Figure 6.b). On the average, to\n\nfind a solution with a predefined production, the FIR strategy used 66% of the time used by\n\nthe BIR strategy. That is because, on the average, a FIR iteration was almost seven times\n\nfaster than a BIR iteration. Note that, to users, running time is deemed important. Note\n\nalso that the FIR solver built solutions with a slightly higher oil production, as can be seen\n\nin Figures 6 and 7. Summing up all instances, the gain was almost 80 thousand barrels of\n\noil. We concluded that the FIR strategy was the one that better suited this problem.\n\n(a) (b)\n\nFigure 6: BIR x FIR: Example 1\n\n(a) Example 2 (b) Example 3\n\nFigure 7: BIR x FIR.\n\nAnother technique tested was to bias the selection towards some particular candidates,\n\n\n\n3. Computational Results 69\n\nthose with the highest oil yield. Five probability distributions, besides the uniform distrib-\n\nution, were considered, as presented in Section 2.2. Comparative experiments showed that\n\nthe exponential and quadratic bias functions generated much worse solutions, with pro-\n\nduction of more than 2 millions barrels of oil smaller than the other approaches, summing\n\nup over all instances. Among the other bias functions, the function based on square root\n\nproved to be the best one for this problem, as can be seen in Figures 8.a and 9.a. For a\n\nbetter view over this two examples, we zoom comparing square root to others bias functions\n\non Figures 8.(b,c,d) and 9.(b,c,d).\n\n(a) Example 1 (b) Example 1: Square root X Linear\n\n(c) Example 1: Square root X Uniform (d) Example 1: Square root X Log\n\nFigure 8: Bias Functions, I.\n\n3.3 The GRASPW Implementations\n\nIn Section 2.2, we presented some advanced techniques that can be included in the basic\n\nGRASP procedure. Many combinations of these were tested, but not all possible com-\n\nbinations. With 6 distinct techniques (five advanced plus the pivoting rule), all possible\n\n\n\n70 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\n(a) Example 2 (b) Example 2: Square root X Linear\n\n(c) Example 2: Square root X Uniform (d) Example 2: Square root X Log\n\nFigure 9: Bias Functions, II\n\ncombinations would number 64 distinct solvers. It was simply too time consuming to exe-\n\ncute broad tests with each and every one of these solvers. We choose the best combinations\n\nbased on faster tests, selecting a pool of 27 solvers. To simplify the visualization and data\n\nanalysis, we show only 14 solvers, besides the ORCA solver. See Table 2.\n\nAs there are many solvers and in many tests there were ties between them, we elaborated\n\nfive criteria to analyze which would be the best solver. We list these criteria below:\n\n1. Sum of the oil production of the best solutions for all instances.\n\n2. Sum of the oil production of the average solutions for all instances.\n\n3. Average of the rank obtained sorting decreasingly the solver solutions of each instance\n\nusing the Ranking1 Rule (R1), explained below. The sorting was according to the\n\naverage oil production and average time of execution to find the best solution. We\n\nranked all solvers.\n\n\n\n3. Computational Results 71\n\nTechniques C.P. GRASP POP Bias Int P-R SLS BIR\nORCA \u2022\nG1 \u2022\nG2 \u2022 \u2022\nG3 \u2022 \u2022 \u2022\nG4 \u2022 \u2022\nG5 \u2022 \u2022\nG6 \u2022 \u2022\nG7 \u2022 \u2022\nG8 \u2022 \u2022 \u2022\nG9 \u2022 \u2022 \u2022\nG10 \u2022 \u2022 \u2022\nG11 \u2022 \u2022 \u2022 \u2022\nG12 \u2022 \u2022 \u2022 \u2022 \u2022\nG13 \u2022 \u2022 \u2022 \u2022 \u2022\nG14 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022\n\nC.P. Constraint Programming\nGRASP Greedy Randomized Adaptive Search Procedure\nPOP Proximate Optimality Principle\nBias Bias Function (Square Root)\nInt Intensification\nP-R Path-Relinking\nSLS Selective Local Search\nBIR BIR\n\nTable 2: Solvers\n\n4. Average of the rank obtained sorting decreasingly the solver solutions of each instance\n\nusing the Ranking2 Rule (R2), explained below. The sorting was according to the\n\naverage oil production and average time of execution to find the best solution. We\n\nranked all solvers.\n\n5. Number of instances for which the solver obtained the best solution known to that\n\ninstance.\n\nRanking1 Rule is a rank where, if s solvers are drawn in rank r, the next solvers would\n\ncome in rank r + 1. Ranking2 Rule, in the same example, would put the next solvers in\n\nrank r + s.\n\nTable 3 presents the values of the criteria achieved by the 15 solvers created for the\n\nWDRDP. Values in boldface are the best results among the solvers for each criteria. Note\n\nthat G14 stands out being the best solver according to three criteria, followed closely by\n\nG7 which was the best in two criteria. However we can not say yet that G14 is the best\n\nsolver, because if it behaves poorly in the other two criteria, another solver could prove\n\n\n\n72 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nto be more appropriate for the WDRDP. According to these values, we elaborated Table\n\n4, where we show the rank of the solvers in each criterion. Note that there are significant\n\nvariations in the rank of the solvers when using different criteria.\n\nCriterion 1 2 3 4 5\nORCA 331.043.827 331.043.827 9,588235 23,47059 2\nG1 354.428.768 346.325.637 7,682353 10,47059 7\nG2 354.421.217 346.255.908 8,035294 11,11765 6\nG3 354.528.275 346.318.220 7,470588 10,23529 6\nG4 354.379.849 346.255.508 8 11,41176 6\nG5 354.428.768 346.342.803 6,823529 9,176471 7\nG6 354.432.875 346.377.716 4,623529 8,235294 7\nG7 354.838.320 346.807.529 2,941176 4,352941 8\nG8 354.838.320 346.744.587 4,352941 5,764706 8\nG9 354.838.320 346.801.864 3,470588 5,294118 8\nG10 354.929.689 346.782.341 4,411765 6,588235 7\nG11 354.929.689 346.762.940 4,294118 6,411765 9\nG12 354.929.689 346.762.060 4,588235 6,941176 7\nG13 354.932.391 346.765.955 4,058824 6 7\nG14 354.888.020 346.814.967 2,941176 4,764706 9\n\nTable 3: Values obtained by the Solvers in the Comparative Criteria\n\nIn order to make a decision about which would be the best solver, we again ranked the\n\nsolvers according to the average rank they obtained in each criterion. We made this rank\n\nusing both R1 and R2 type rules, as can be seen in Table 5. Using this table, we obtained\n\nthe rank of the best solvers, presented in Table 6. We conclude that G14 is actually the\n\nbest GRASP solver that we developed for the WDRDP.\n\nThis solver makes use of many advanced techniques for GRASP heuristics, like POP,\n\nbias function based on square root, intensification, Path-Relinking and SLS (see Section\n\n2.2). Our second best solver for the problem was G7, which makes use only of the POP\n\ntechnique. As can be seen in Table 3, and by the average rank in Table 5, G7 is almost as\n\ngood as G14. Hence, the other advanced techniques used in solver G14, besides POP, give\n\nonly marginal gains to G14. POP, on the other hand, improves drastically the performance\n\nof a solver for this problem. This can be seen comparing G1 (basic GRASP) to G7 (basic\n\nGRASP with POP) in the same tables mentioned above, or comparing the group of solvers\n\nG1 until G6 (solvers without POP) to the group of G7 and the other solvers, that is, the\n\ngroup of solvers that implemented POP. When POP is applied, a great leap in quality can\n\nbe seen. Note, for example, that G1 is just the eleventh best solver, while G7 is the second\n\nbest.\n\nNote also that G7 is better than G10, G11, G12 and G13, solvers which combine POP\n\nand other advanced techniques. This happened because these advanced techniques required\n\n\n\n3. Computational Results 73\n\nCriterion 1 2 3 4 5\nG13 G14 G7-G14 G7 G11-G14\n\nG10-G11-G12 G7 G9 G14 G7-G8-G9\nG14 G9 G13 G9 G1-G5-G6-G10-G12-G13\n\nG7-G8-G9 G10 G11 G8 G2-G3-G4\nG3 G13 G8 G13 ORCA\nG6 G11 G10 G11\n\nG1-G5 G12 G12 G10\nG2 G8 G6 G12\nG4 G6 G5 G6\n\nORCA G5 G3 G5\nG1 G1 G3\nG3 G4 G1\nG2 G2 G2\nG4 ORCA G4\n\nORCA ORCA\n\nTable 4: Rank of the Solvers\n\nlonger processing times from the solvers, and the gains were not sufficient to justify their\n\nuse. Solver G7 could only be overcame when all the advanced techniques were combined\n\nin G14, and even so it was just slightly overcame.\n\nWith the above facts in mind, we concluded that POP is the best advanced technique\n\nto solve the WDRDP.\n\n3.4 Comparative Results\n\nAs can be seen in Section 3.3, the G14 solver was considered the best GRASPW implemen-\n\ntation. Note that the constraint programming solver, ORCA, was much worse than all the\n\nGRASPW solvers, even when compared to the standard GRASP procedure, G1.\n\nCompared to ORCA, the G14 solver generated gains of more than 16 millions barrels of\n\noil, summing up the average solutions of all instances. This means an increase of 4,5% in\n\nthe oil production. Note that, with the oil barrel price around US$ 52, the use of the G14\n\nsolver, instead of the ORCA solver, would yield gains of almost US$ 832 million. Besides,\n\neven generating better solutions, G14 takes, to find its best solution, only 95% of the time\n\nORCA takes to find its best solution. And to find better solutions than the ORCA\u2019s best\n\none, G14 takes only 45% of the time taken by ORCA. Among the 17 instances tested, G14\n\ngenerates, within the first second of execution, better solutions than ORCA\u2019s best solution,\n\nin 14 instances. Two examples of that can be seen in Figure 10. In Figure 11, we show\n\ntwo instances where G14 does not generate, within the first second of execution, solutions\n\nbetter that the ORCA best solution.\n\n\n\n74 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nAnalysis of Criteria R1 R2 Average R1-R2\nORCA 11,8 15 13,4\nG1 8,8 10,4 9,6\nG2 10,2 13 11,6\nG3 8,4 11 9,7\nG4 10,6 13,4 12\nG5 7,8 9,4 8,6\nG6 7 8,6 7,8\nG7 2 2,6 2,3\nG8 4,6 5,4 5\nG9 2,8 3,6 3,2\nG10 4,4 5,2 4,8\nG11 3,8 4 3,9\nG12 5,4 6,2 5,8\nG13 3,4 4,2 3,8\nG14 1,6 2 1,8\n\nTable 5: Analysis of the Rank of the Solvers\n\nHowever, there is an instance where ORCA was competitive compared to G14, as can\n\nbe seen in Figure 12. Here, ORCA\u2019s best solution was found in 5 seconds and G14 only\n\ngenerated a better solution than that after 1134 seconds. Nevertheless, after 1522 seconds,\n\nG14 generated a solution with an oil production almost 63 thousand barrels superior than\n\nORCA\u2019s best solution.\n\nWe conclude that our GRASPW implementation is much more efficient and generate\n\nbetter solutions than the ORCA solver.\n\n(a) Example 1 (b) Example 2\n\nFigure 10: ORCA \u00d7 G14, I\n\n\n\n4. Conclusions 75\n\nSolver\nG14\nG7\nG9\nG13\nG11\nG10\nG8\nG12\nG6\nG5\nG1\nG3\nG2\nG4\n\nORCA\n\nTable 6: Rank of the Best Solvers\n\n4 Conclusions\n\nScheduling activities efficiently is of paramount importance to the industry, in general.\n\nPetrobras, a leading company in deep water oil exploration, presented us the WDRDP,\n\na scheduling problem related to oil well development. Here we constrast two approaches\n\nto the WDRDP: the constraint programming tool ORCA and a GRASP implementation,\n\ndubbed GRASPW.\n\nComputational experiments were carried out on several real instances. We conclude\n\nthat GRASPW greatly outperforms ORCA. Not only it generates solutions with higher oil\n\nproduction, but often it outputs solutions with the same oil production as ORCA, but in\n\nmuch less time. We recall that ORCA already produced better results than the manual\n\nsolutions.\n\nIt is worth mentioning that ORCA is built using the ILOG Constraint Programming\n\nsuite, a set of expensive and sophisticated libraries with years of development. Using\n\nGRASPW, which was entirely programmed from the ground up, these costs could be\n\naverted. In opposition, the ILOG suite favors easiness of development, of maintenance\n\nand of understanding of the source code.\n\n\n\n76 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\n(a) Example 3 (b) Example 4\n\nFigure 11: ORCA \u00d7 G14, II\n\nFigure 12: ORCA\u00d7G14: Example 5\n\n\n\n5. References 77\n\n5 References\n\nAiex, R. M., Resende, M. G. C. and Toraldo, G., 2000, GRASP with path-relinking for the\n\nthree-index assignment problem, Technical report, AT&amp;T Labs.\n\nBard, J. F. and Feo, T. A., 1989, \u2018Operations sequencing in discrete parts manufacturing\u2019,\n\nManagement Science 35, 249\u2013255.\n\nBard, J., Feo, T. and Holland, S., 1996, \u2018A GRASP for scheduling printed wiring board\n\nassembly\u2019, I.I.E. Transactions 28, 155\u2013165.\n\nBinato, S., Hery, W. J., Loewenstern, D. and Resende, M. G. C., 2001, A GRASP for job\n\nshop scheduling, in P. Hansen and C. C. Ribeiro, eds, \u2018Essays and surveys on metaheuris-\n\ntics\u2019, Kluwer Academic Publishers, pp. 59\u201379.\n\nBresina, J. L., 1996, Heuristic-biased stochastic sampling, in \u2018Proceedings of the Thirteenth\n\nNational Conference on Artificial Intelligence\u2019, pp. 271\u2013278.\n\nCanuto, S. A., Resende, M. G. C. and Ribeiro, C. C., 2001, \u2018Local search with perturba-\n\ntions for the prize-collecting steiner tree problem in graphs\u2019, Networks 38, 50\u201358.\n\ndo Nascimento, J. M., 2002, Hybrid computational tools for the optimization of the pro-\n\nduction of petroleum in deep waters, Master\u2019s thesis, Institute of Computing, University of\n\nCampinas.\n\nFeo, T. A. and Bard, J. F., 1989, \u2018Flight scheduling and maintenance base planning\u2019, Man-\n\nagement Science 35, 1415\u20131432.\n\nFeo, T. A., Bard, J. and Holland, S., 1995, \u2018Facility-wide planning and scheduling of printed\n\nwiring board assembly\u2019, Operations Research 43, 219\u2013230.\n\nFeo, T. A. and Resende, M. G. C., 1995, \u2018Greedy randomized adaptative search procedures\u2019,\n\nJournal of Global Optimization 6, 109\u2013133.\n\nFesta, P. and Resende, M. G. C., 2001, GRASP: An annotated bibliography, Technical\n\nreport, AT&amp;T Labs.\n\nFleurent, C. and Glover, F., 1999, \u2018Improved constructive multistart strategies for the\n\n\n\n78 Cap??tulo 7. O EDP com Deslocamento de Recursos\n\nquadratic assignment problem using adaptive memory\u2019, INFORMS Journal on Computing\n\n11, 198\u2013204.\n\nGlover, F., 1996, Tabu search and adaptive memory programming \u2014 advances, applica-\n\ntions and challenges, in R. S. Barr, R. V. Helgason and J. L. Kennington, eds, \u2018Interfaces\n\nin Computer Science and Operations Research\u2019, Kluwer, pp. 1\u201375.\n\nGlover, F., 2000, Multi-start and strategic oscillation methods \u2014 principles to exploit\n\nadaptive memory, in M. Laguna and J. L. Gonza?les-Velarde, eds, \u2018Computing Tools for\n\nModeling, Optimization and Simulation: Interfaces in Computer Science and Operations\n\nResearch\u2019, Kluwer, pp. 1\u201324.\n\nGlover, F., Laguma, M. and Mart??, R., 2000, Fundamentals of scatter search and path re-\n\nlinking, in M. Laguna and J. L. Gonza?les-Velarde, eds, \u2018Control and Cybernetics\u2019, Vol. 39,\n\nKluwer, pp. 653\u2013684.\n\nGlover, F. and Laguna, M., 1997, Tabu Search, Kluwer Academic Publishers, Norwell,\n\nMassachusetts.\n\nILOG, 1999a, ILOG Solver 4.4 Getting Started, ILOG.\n\nILOG, 1999, ILOG Solver 4.4 Reference Manual, ILOG.\n\nILOG , 1999c, ILOG Solver 4.4 User\u2019s Manual, ILOG.\n\nMarriott, K. and Stuckey, P. J., 1998, Programming with Constraints: An introduction,\n\nMIT Press, Cambridge, Massachusetts.\n\nPereira, R. A., Moura, A. V. and de Souza, C. C., 2005, Comparative experiments with\n\nGRASP and constraint programming for the oil well drilling problem, in S. E. Nikoletseas,\n\ned., \u2018Experimental and Efficient Algorithms - WEA 2005, LNCS 3503\u2019, Springer,\n\npp. 328\u2013340.\n\nResende, M. G. C. and Ribeiro, C. C., 2001, A GRASP with path-relinking for private\n\nvirtual circuit routing, Technical report, AT&amp;T Labs.\n\nResende, M. G. C. and Ribeiro, C. C., 2002, \u2018Greedy randomized adaptive search proce-\n\ndure\u2019, AT&amp;T Labs Research Technical Report TD53RSJY.\n\n\n\n5. References 79\n\nRoy, B. and Sussmann, B., 1964, Les proble?mes d\u2019ordonnancement avec contraintes dis-\n\njonctives, in \u2018Note DS No 9 bis\u2019, SEMA, Paris.\n\nYannakakis, M., 1997, Computational complexity, in E. H. L. Aarts and J. K. Lenstra, eds,\n\n\u2018Local Search in Combinatorial Optimization\u2019, John Wiley &amp; Sons, Chichester, pp. 19\u201355.\n\n\n\nEp??logo\n\nFoi explicado no artigo que um dos motivos para a na?o imposic?a?o das restric?o?es de deslo-\n\ncamento de recursos diretamente na busca e? o princ??pio fundamental da programac?a?o por\n\nrestric?o?es, que defende a dissociac?a?o entre modelo e busca. Assim, o ORCA consome um\n\ntempo de execuc?a?o considera?vel na propagac?a?o das restric?o?es de deslocamento, que sa?o de\n\nordem O(n2), e portanto perde eficie?ncia. Ainda assim, o ORCA preferiu seguir o princ??pio\n\nda programac?a?o por restric?o?es. Isso porque, por exemplo, no ORCA atual se fosse decidido\n\nque as restric?o?es de deslocamento na?o sa?o mais necessa?rias, apenas o modelo seria alterado.\n\nJa? se essas restric?o?es estivessem definidas na busca, toda ela teria de ser remodelada. Ou\n\nseja, nesse u?ltimo caso, uma alterac?a?o de modelagem implicaria numa alterac?a?o no algo-\n\nritmo de busca. Isso dificulta a manutenc?a?o do co?digo, pois para alterar a modelagem um\n\nindiv??duo deve conhecer na?o so? o modelo, como tambe?m a busca.\n\nAssim como no primeiro artigo, optamos por na?o fazer uma ana?lise do desvio padra?o das\n\nproduc?o?es das melhores soluc?o?es geradas pelo GRASP e, portanto, de sua robustez. Isso\n\nporque em todos os testes realizados com um mesmo resolvedor em uma mesma insta?ncia,\n\na diferenc?a entre as produc?o?es de soluc?o?es diferentes nunca superou os 0.5%. Dessa forma,\n\num mesmo resolvedor GRASP mostra uma variac?a?o muito pequena entre a qualidade de\n\nsuas soluc?o?es para uma mesma insta?ncia.\n\nNo artigo, foi explicado duas regras, dentre outras, para a escolha dos melhores resolve-\n\ndores GRASP, a saber as regras Ranking1 Rule (R1) e Ranking2 Rule (R2). Para esclarecer\n\nmelhor essas regras, suponha um exemplo em que os resolvedores X e Y geram as melhores\n\nsoluc?o?es, ambos com uma me?dia ide?ntica na produc?a?o de suas soluc?o?es. Assim, ambos\n\nesta?o na posic?a?o 1, tanto em R1 como em R2, ja? que sa?o os melhores. O resolvedor Z,\n\npor sua vez, vem logo apo?s os resolvedores anteriores na qualidade das soluc?o?es geradas.\n\nQuanto a R1, Z esta? na posic?a?o 2, pois gera as soluc?o?es de segunda melhor qualidade. Ja?\n\nquanto a R2, Z esta? na posic?a?o 3, pois e? o terceiro melhor resolvedor. Essas duas regras\n\nforam utilizadas por representarem visualizac?o?es diferentes e importantes para a escolha do\n\nmelhor resolvedor.\n\nOutro fato a ser mencionado aqui e? que, diferentemente de outras publicac?o?es, tais como\n\nAiex et al. (2001), Resende &amp; Ribeiro (2001) e Aiex et al. (2003), o path-relinking gerou\n\npoucos ganhos em nosso GRASP. Como explicado no artigo, a estrate?gia do path-relinking\n\nconsiste em explorar caminhos que levam de uma soluc?a?o a? outra. Esse \u201ccaminho\u201d, por sua\n\nvez, pode ser definido de va?rias formas. Em nosso trabalho, optamos por levar um poc?o a?\n\numa posic?a?o na ordem de execuc?a?o de um recurso igual a?quela em que ocorre na soluc?a?o\n\nsendo comparada. Ou seja, ao caminharmos da soluc?a?o E2 para a E1, tomamos o poc?o P 1\n\nque foi o primeiro executado pelo barco B1 em E1 e o fazemos o primeiro executado pelo\n\nmesmo B1 em E2. Isso e? feito via 2-exchange (Roy &amp; Sussmann (1964)), ou seja, colocamos\n\n80\n\n\n\nP 1 em primeiro e colocamos o que antes era primeiro onde estava P 1 no escalonamento. O\n\nprocesso e? repetido para todos os recursos e todas as posic?o?es de execuc?o?es nos recursos.\n\nDessa forma E2 convergira? para uma soluc?a?o igual ou semelhante a? E1.\n\nEntretanto, ha? um problema intr??nseco nessa abordagem. Devido a?s mir??ades de res-\n\ntric?o?es do problema, poc?os podem ter sido particionados no escalonamento tanto na soluc?a?o\n\nE2 como na E1, mas na?o necessariamente os mesmos poc?os e da mesma forma. Assim,\n\npara aproximarmos E2 de E1, precisar??amos unir as atividades dos poc?os particionados\n\nem E2 que na?o se particionaram em E1, e separar as atividades dos poc?os unidos de E2\n\nque esta?o particionadas em E1. Ale?m disso, um poc?o pode estar particionado em E1 e\n\nem E2, mas de formas diferentes. Enta?o, aproximar duas soluc?o?es quando ha? particiona-\n\nmentos torna-se um problema razoa?vel de codificac?a?o e, muito pior, demanda um tempo\n\ncomputacional significativo, prejudicando a performance do algoritmo. Ou seja, se imple-\n\nmentada essa aproximac?a?o, o path-relinking iria tornar as iterac?o?es do GRASP bem mais\n\nlentas. Dessa forma, optamos por aproximar as soluc?o?es apenas com os poc?os que na?o esta?o\n\nparticionados em ambas as soluc?o?es, limitando pore?m a aproximac?a?o entre elas. Logo, o\n\npath-relinking implementado e? incompleto.\n\nOutra questa?o e? que nas publicac?o?es ja? citadas opta-se por sempre escolher o melhor\n\nmovimento na vizinhanc?a de uma soluc?a?o em direc?a?o a? soluc?a?o guia. Nesta tese, na?o\n\nescolhemos necessariamente o melhor movimento, isso porque decidir qual e? o melhor mo-\n\nvimento poderia demandar um tempo computacional excessivo. Entretanto, escolhemos\n\nmovimentos que tendem a ter maior impacto na produc?a?o final, e que portanto tendem a\n\nser os melhores, ja? que nossos movimentos se concentram nos primeros poc?os escalonados\n\ndiferentemente nas soluc?o?es. Uma opc?a?o a ser testada futuramente e? sempre escolher o\n\nmelhor movimento, mas aplicar o path-relinking apenas a?s soluc?o?es que superem um certo\n\ncrite?rio de qualidade, assim evitando um consumo excessivo de tempo computacional. Para\n\nacelerar ainda mais o algoritmo, pode-se tambe?m truncar o caminho entre as soluc?o?es.\n\nOutro ide?ia seria selecionar a soluc?a?o elite a ser combinada com a soluc?a?o GRASP\n\naleatoriamente, mas com probabilidades proporcionais ao nu?mero de elementos diferentes\n\nentre essas soluc?o?es. Isso tende a gerar caminhos mais longos entre as duas soluc?o?es, levando\n\na mais chances de encontrar soluc?o?es melhores (Resende &amp; Ribeiro (2003)).\n\nAinda outra alternativa e? aplicar a busca local em soluc?o?es encontradas no caminho do\n\npath-relinking. A aplicac?a?o da busca local deve se dar de tempos em tempos, de acordo com\n\nalgum para?metro de frequ?e?ncia ou crite?rio de qualidade, para evitar perda de eficie?ncia do\n\nalgoritmo.\n\nAssim, melhorias no esquema de path-relinking podem ser tentadas em trabalhos futu-\n\nros.\n\n81\n\n\n\nParte IV\n\nConsiderac?o?es Finais\n\n83\n\n\n\nCap??tulo 8\n\nConcluso?es\n\nO GRASP e? uma metaheur??stica bem estudada e aplicada em diversos problemas NP-\n\ndif??cieis. Entretanto, a Petrobras enfrenta um particular tipo de problema de escalonamento\n\npara o qual na?o existe ferramenta comercial pronta, nem algoritmos eficientes sob estudo.\n\nO GRASP nunca foi testado nesse problema. Assim, pioneiramente, aplicamos o GRASP\n\nao problema enfrentado pela Petrobras para lidar com escalonamento de recursos em alto\n\nmar. A ferramenta desenvolvida na?o so? automatiza o processo, antes manual, como otimiza\n\nesse processo e supera uma ferramenta desenvolvida pela empresa para o mesmo fim. O\n\nproblema e?, provavelmente, tambe?m enfrentado por outras empresas petrol??feras ao redor\n\ndo globo, tornando o inovador estudo do problema ainda mais abrangente.\n\nNosso estudo na?o so? aumentou os conhecimentos sobre a metaheur??stica GRASP, testan-\n\ndo-a sob um novo prisma, como criou melhores formas de tratar o problema de escalona-\n\nmento de recursos em alto mar. Para a Petrobras, os ganhos sa?o de cerca de 1 milha?o de\n\nbarris de petro?leo por escalonamento, quando comparada a uma ferramenta ja? superior ao\n\nprocesso manual. Com o barril de petro?leo a US$581, os ganhos sa?o de cerca de US$58\n\nmilho?es, por escalonamento. A Petrobras faz em me?dia 2 ou 3 escalonamentos por ano.\n\nOutro ponto importante e? que, apesar de o GRASP fazer uso de randomizac?a?o, em todos\n\nos testes realizados com um mesmo resolvedor em uma mesma insta?ncia, a diferenc?a entre\n\nas produc?o?es de soluc?o?es diferentes nunca superou os 0.5%. Dessa forma, os resolvedores\n\nGRASP se mostraram robustos. Isso e? relevante para os engenheiros da Petrobras, pois o\n\nGRASP dificilmente seria aceito se suas execuc?o?es variassem entre soluc?o?es boas, me?dias,\n\nruins e situac?o?es de na?o soluc?a?o.\n\nNo meio acade?mico, o trabalho foi bem recebido, e um artigo inicial descrevendo a abor-\n\ndagem adotada foi aprovado no 4th International Workshop on Efficient and Experimental\n\nAlgorithms (WEA 2005 - http://ru1.cti.gr/wea05/). Convidado, Romulo foi apresentar o\n\ntrabalho no congresso, realizado na Ilha de Santorini, Gre?cia. O artigo tambe?m foi publi-\n\n1Cotac?a?o de 16/11/2005.\n\n85\n\n\n\ncado no volume 35032 da se?rie Lecture Notes in Computer Science, da editora Springer.\n\nEsse artigo inicial, por ter participado do WEA2005, podera? vir a ser publicado numa\n\nedic?a?o especial do ACM Journal on Experimental Algorithmics (www.jea.acm.org) dedi-\n\ncado ao evento. Um segundo artigo foi premiado no Pre?mio Petrobras de Tecnologia como\n\nterceiro colocado na categoria Produc?a?o3 e foi submetido ao Journal of Heuristics4, uma\n\nimportante publicac?a?o da a?rea de otimizac?a?o combinato?ria.\n\nDevido ao sucesso da ferramenta desenvolvida, ela ja? foi implantada na Petrobras e ja?\n\nesta? em uso em processos na Bacia de Campos e Bacia do Esp??rito Santo.\n\nAo mesmo tempo em que procurou estudar o problema de escalonamento no desen-\n\nvolvimento de poc?os de petro?leo em alto mar enfrentado pela Petrobras, essa dissertac?a?o\n\nteve como objetivo adicional comparar os resultados de uma implementac?a?o espec??fica de\n\nprogramac?a?o por restric?o?es e uma implementac?a?o espec??fica da metaheur??stica GRASP. Ex-\n\nperimentos computacionais foram conduzidos em insta?ncias reais do problema. Conclu??mos\n\nque o GRASP desenvolvido gera soluc?o?es com maior produc?a?o petrol??fera que aquelas gera-\n\ndas pelo resolvedor ORCA, que usa programac?a?o por restric?o?es. Tal se deu tanto no EDP,\n\nquanto no EDPDR, quando se adotou te?cnicas mais avanc?adas do GRASP. Os resultados\n\ntambe?m provam que o GRASP supera o resolvedor ORCA quando gera soluc?o?es de mesma\n\nproduc?a?o em menor tempo de execuc?a?o.\n\nE? va?lido mencionar que o resolvedor ORCA foi constru??do com a su??te de Programac?a?o\n\npor Restric?o?es da ILOG, que consiste de sofisticadas bibliotecas com mais de uma de?cada\n\nde desenvolvimento5 . Ale?m disso, essa su??te e? de prec?o elevado, tanto no valor de aquisic?a?o,\n\nquanto no valor de manutenc?a?o da licenc?a. Dessa forma, usando o GRASP desenvolvido,\n\na Petrobras pode evitar esses custos. Note, entretanto, que a su??te da ILOG favorece a\n\nfacilidade de desenvolvimento, de manutenc?a?o e de entendimento do co?digo fonte. Note\n\ntambe?m que os resultados gerados pelo ORCA superam resultados manuais, i.e., soluc?o?es\n\ndesenvolvidas por engenheiros.\n\nDe uma maneira geral, acredita-se que os objetivos dessa dissertac?a?o foram alcanc?ados\n\nsatisfatoriamente. Insta?ncias reais do problema original foram resolvidas em tempos de\n\ncomputac?a?o aceita?veis. Ale?m disso, foi poss??vel conhecer mais a fundo todas as te?cnicas\n\nutilizadas e as dificuldades intr??nsecas do problema tratado. Desse modo, contribuiu-se\n\npositivamente para o sucesso de futuros empreendimentos nessa a?rea.\n\n2http://www.springeronline.com/sgw/cda/frontpage/0,11855,4-149-22-48266374-0,00.html\n3Vide: http://www2.petrobras.com.br/tecnologia2/port/pptecnologia.asp\n4http://www.kluweronline.com/issn/1381-1231\n5Vide http://www.ilog.com\n\n86\n\n\n\nCap??tulo 9\n\nTrabalhos Futuros\n\nO trabalho desenvolvido nesta dissertac?a?o pode ser estendido de diversas maneiras:\n\n\u2022 Diferentemente de outras publicac?o?es, tais como Aiex et al. (2001), Resende &amp; Ribeiro\n\n(2001) e Aiex et al. (2003), o path-relinking gerou poucos ganhos em nosso GRASP.\n\nPoder-se-ia tentar adaptar essa te?cnica de uma melhor forma para o EDP, usando por\n\nexemplo as abordagens citadas no ep??logo do Cap??tulo 7.\n\n\u2022 A Petrobras vem incorporando clusters de processadores ao seu parque computacio-\n\nnal. Dessa forma, seria interessante adaptar a ferramenta GRASP aqui desenvolvida\n\npara atuar paralelamente, utilizando o paralelismo dos clusters.\n\n\u2022 Testar te?cnicas de \u201cperturbac?o?es nos custos\u201d (cost perturbations) no GRASP, como\n\nem Canuto et al. (2001), Ribeiro et al. (2002) e Resende &amp; Ribeiro (2002).\n\n\u2022 Testar te?cnicas h??bridas, como GRASP com busca tabu (Ribeiro et al. (2002), Colome?\n\n&amp; Serra (1998)) ou GRASP com algoritmos gene?ticos (Lourenc?o et al. (1998)).\n\n\u2022 Testar outras te?cnicas, como busca tabu e algoritmos gene?ticos para o EDP, e com-\n\npara?-las ao GRASP.\n\n87\n\n\n\nBibliografia\n\nAiex, R. M., Binato, S. &amp; Resende, M. G. C. (2003), \u2018Parallel GRASP with path-relinking\n\nfor job shop scheduling\u2019, Parallel Computing 29(4), 393\u2013430.\n\nAiex, R. M., Resende, M. G. C. &amp; Toraldo, G. (2001), GRASP with path-relinking for the\n\nthree-index assignment problem, Technical report, AT&amp;T Labs.\n\nBinato, S. &amp; Oliveira, G. (2002), \u2018A reactive GRASP for transmission network expansion\n\nplanning\u2019, Essays And Surveys In Metaheuristics - Kluwer Academic Publishers .\n\nCanuto, S. A., Resende, M. G. C. &amp; Ribeiro, C. C. (2001), \u2018Local search with perturbations\n\nfor the prize-collecting steiner tree problem in graphs\u2019, Networks 38, 50\u201358.\n\nClocksin, W. (1987), \u2018Principles of the delphi parallel inference machine\u2019, Computer Journal\n\n30(5), 386\u2013392.\n\nColome?, R. &amp; Serra, D. (1998), \u2018Consumer choice in competitive location models: Formu-\n\nlations and heuristics\u2019, Economics Working Papers (290).\n\nCormen, T. H., Leiserson, C. E., Rivest, R. L. &amp; Stein, C. (2001), Introduction to Algo-\n\nrithms, 2nd edn, MIT Press.\n\ndo Nascimento, J. M. (2002), Hybrid computational tools for the optimization of the produc-\n\ntion of petroleum in deep waters, Master\u2019s thesis, Institute of Computing, University\n\nof Campinas.\n\nFaria, H., Binato, S., Resende, M. &amp; Falca?o, D. M. (2005), \u2018Power transmission network\n\ndesign by a greedy randomized adaptive path relinking approach\u2019, IEEE Transactions\n\non Power Systems 20(1), 43\u201349.\n\nFesta, P. &amp; Resende, M. (2002), \u2018GRASP: An annotated bibliography\u2019, Essays And Surveys\n\nIn Metaheuristics - Kluwer Academic Publishers .\n\nFortuna, V. J., Moura, A. V. &amp; de Souza, C. C. (2002), Relato?rio 2 de iniciac?a?o cient??fica,\n\nRelato?rio FAPESP, Instituto de Computac?a?o, Unicamp.\n\n89\n\n\n\nGarey, M. R. &amp; Johnson, D. S. (1979), Computers and intractability: A guide to the theory\n\nof NP-Completeness, W. H. Freeman and Company, San Francisco, California.\n\nHarvey, W. D. &amp; Ginsberg, M. L. (1995), \u2018Limited discrepancy search\u2019, Proceedings of the\n\nInternational Joint Conference on Artificial Intelligence (IJCAI) 1, 607\u2013613.\n\nHasle, G., Haut, R., Johansen, B. &amp; \u00d8lberg, T. (1997), Well activity scheduling \u2013 an ap-\n\nplication of constraint reasoning, in \u2018Proceedings of PACT\u201997 (The 1997 International\n\nConference on Parallel Architectures and Compilation Techniques)\u2019, San Francisco,\n\nCallifornia.\n\nILOG (1999a), ILOG Solver 4.4 Reference Manual, ILOG.\n\nILOG (1999b), ILOG Solver 4.4 User\u2019s Manual, ILOG.\n\nJaffar, J. &amp; Lassez, J. (1987), Constraint logic programming, in \u201814 th ACM Symposium on\n\nPrinciples of Programming Languages\u2019, Munique, Alemanha, pp. 111\u2013119.\n\nLe Pape, C. (1994), \u2018Implementation of resource constraints in ILOG SCHEDULE: a li-\n\nbrary for the development of constraint-based scheduling systems\u2019, Intelligent Systems\n\nEngineering 3(2), 55\u201366.\n\nLever, J., Wallace, M. &amp; Richards, B. (1995), \u2018Constraint logic programming for scheduling\n\nand planning\u2019, BT Technology Journal 13(1), 73\u201380.\n\nLourenc?o, H. R., Paixa?o, J. &amp; Portugal, R. (1998), Metaheuristics for the bus-driver sche-\n\nduling problem, in \u2018Economics Working Papers\u2019, Vol. 304, Department of Economics\n\nand Business, Universitat Pompeu Fabra.\n\nMarriott, K. &amp; Stuckey, P. J. (1998), Programming with Constraints: An introduction, MIT\n\nPress, Cambridge, Massachusetts.\n\nMeseguer, P. (1997), \u2018Interleaved depth-first search\u2019, Proceedings of the International Joint\n\nConference on Artificial Intelligence (IJCAI) 2, 1382\u20131387.\n\nMoura, A. V. &amp; de Souza, C. C. (2000), \u2018Reunio?es com Engenheiros da Petrobras, estacio-\n\nnados na Bacia Petrol??fera de Campos \u2014 notas na?o publicadas\u2019.\n\nNilsson, N. J. (1971), Problem Solving Methods in Artificial Intelligence, McGraw-Hill.\n\nPereira, R. A., Moura, A. V. &amp; de Souza, C. C. (2002), Estudo e desenvolvimento de ferra-\n\nmentas para sequenciamento de atividades no desenvolvimento de poc?os de petro?leo:\n\nUso de programac?a?o por restric?o?es, Relato?rio FAPESP, Instituto de Computac?a?o, Uni-\n\ncamp.\n\n90\n\n\n\nPereira, R. A., Moura, A. V. &amp; de Souza, C. C. (2005a), Comparative experiments with\n\nGRASP and constraint programming for the oil well drilling problem, in S. E. Nikolet-\n\nseas, ed., \u2018Experimental and Efficient Algorithms - WEA 2005, LNCS 3503\u2019, Springer,\n\npp. 328\u2013340.\n\nPereira, R. A., Moura, A. V. &amp; de Souza, C. C. (2005b), Constraint programming\n\nand grasp approaches to schedule oil well drillings, Relato?rio te?cnico IC-05-001,\n\nhttp://www.ic.unicamp.br/reltec-ftp/2005/titles.html, Instituto de Computac?a?o, Uni-\n\ncamp.\n\nPereira, R. A., Moura, A. V. &amp; de Souza, C. C. (2005c), Grasp strategies for schedu-\n\nling activities at oil wells with resource displacement, Relato?rio te?cnico IC-05-028,\n\nhttp://www.ic.unicamp.br/reltec-ftp/2005/titles.html, Instituto de Computac?a?o, Uni-\n\ncamp.\n\nResende, M. G. C. &amp; Ribeiro, C. C. (2001), A GRASP with path-relinking for private\n\nvirtual circuit routing, Technical report, AT&amp;T Labs.\n\nResende, M. G. C. &amp; Ribeiro, C. C. (2002), \u2018Greedy randomized adaptive search procedure\u2019,\n\nAT&amp;T Labs Research Technical Report TD53RSJY .\n\nResende, M. G. C. &amp; Ribeiro, C. C. (2003), GRASP and path-relinking: Recent advances\n\nand applications, Technical report td-5tu726, AT&amp;T Labs Research.\n\nRibeiro, C. C., Uchoa, E. &amp; Werneck, R. F. (2002), \u2018A hybrid GRASP with perturbations\n\nfor the steiner problem in graphs\u2019, INFORMS Journal on Computing 14, 228\u2013246.\n\nRibeiro, M. (2002), \u2018A GRASP for job shop scheduling\u2019, Essays And Surveys In Metaheu-\n\nristics pp. 59\u201379.\n\nRoy, B. &amp; Sussmann, B. (1964), Les proble?mes d\u2019ordonnancement avec contraintes disjonc-\n\ntives, in \u2018Note DS No 9 bis\u2019, SEMA, Paris.\n\nSouza, M., Duhamel, C. &amp; Ribeiro, C. (2004), \u2018A GRASP heuristic for the capacitated\n\nminimum spanning tree problem using a memory-based local search strategy\u2019, Applied\n\nOptimization pp. 627\u2013657.\n\nSrinivasan, A., Ramakrishnan, K. &amp; Kumaran, K. (2000), \u2018Optimal design of signaling\n\nnetworks for internet telephony\u2019, Lucent Technologies, Labs Innovations .\n\nWalsh, T. (1997), \u2018Depth-bounded discrepancy search\u2019, Proceedings of the International\n\nJoint Conference on Artificial Intelligence (IJCAI) 2, 1388\u20131393.\n\n91\n\n\n\nYunes, T. H., Moura, A. V. &amp; de Souza, C. C. (2000a), A hybrid approach for solving large\n\nscale crew scheduling problems, in \u2018Lecture Notes in Computer Science, vol. 1753\u2019,\n\nBoston, MA, EUA, pp. 293\u2013307. Anais do Second International Workshop on Practical\n\nAspects of Declarative Languages (PADL\u201900).\n\nYunes, T. H., Moura, A. V. &amp; de Souza, C. C. (2000b), Solving very large crew scheduling\n\nproblems to optimality, in \u201814 th ACM Symposium on Applied Computing (SAC\u201900)\u2019,\n\nComo, Ita?lia, pp. 446\u2013451.\n\n92"}]}}}