{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.17712"}, {"@name": "filename", "#text": "24517_JPMS_Versao_Corrigida.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE DE S\u00c3O PAULO\n\nESCOLA DE ENGENHARIA DE S\u00c3O CARLOS\n\nJO\u00c3O PAULO MARTINS DOS SANTOS\n\nM\u00c9TODO MULTIGRID ALG\u00c9BRICO:\nREUTILIZA\u00c7\u00c3O DAS ESTRUTURAS MULTIGRID NO\n\nTRANSPORTE DE CONTAMINANTES\n\nS\u00e3o Carlos, S\u00e3o Paulo\n\n2015\n\n\n\n\n\nJO\u00c3O PAULO MARTINS DOS SANTOS\n\nM\u00c9TODO MULTIGRID ALG\u00c9BRICO:\nREUTILIZA\u00c7\u00c3O DAS ESTRUTURAS MULTIGRID NO\n\nTRANSPORTE DE CONTAMINANTES\n\nTese apresentada \u00e0 Escola de Engenharia de\nS\u00e3o Carlos, da Universidade de S\u00e3o Paulo,\ncomo parte dos requisitos para obten\u00e7\u00e3o do\nt\u00edtulo de Doutor em Ci\u00eancias: Engenharia\nHidr\u00e1ulica e Saneamento.\n\nOrientador: Prof. Dr. Edson Cezar Wendland\n\nS\u00e3o Carlos, S\u00e3o Paulo\n2015\n\n\n\nAUTORIZO A REPRODU\u00c7\u00c3O TOTAL OU PARCIAL DESTE TRABALHO,\nPOR QUALQUER MEIO CONVENCIONAL OU ELETR\u00d4NICO, PARA FINS\nDE ESTUDO E PESQUISA, DESDE QUE CITADA A FONTE.\n\nSantos, Jo\u00e3o Paulo Martins dos\n S237m M\u00e9todo multigrid alg\u00e9brico : reutiliza\u00e7\u00e3o das \n\nestruturas multigrid no transporte de contaminantes /\nJo\u00e3o Paulo Martins dos Santos; orientador Edson Cezar \nWendland. S\u00e3o Carlos, 2015.\n\nTese (Doutorado) - Programa de P\u00f3s-Gradua\u00e7\u00e3o e \u00c1rea \nde Concentra\u00e7\u00e3o em Hidr\u00e1ulica e Saneamento -- Escola de\nEngenharia de S\u00e3o Carlos da Universidade de S\u00e3o Paulo,\n2015.\n\n1. M\u00e9todo dos elementos finitos. 2. M\u00e9todo \nmultigrid alg\u00e9brico. 3. M\u00e9todo interativo\nn\u00e3o-estacion\u00e1rio. 4. Computa\u00e7\u00e3o cient\u00edfica. 5. Python.\n6. Estimador residual. I. T\u00edtulo.\n\n\n\n\n\nEste trabalho \u00e9 dedicado \u00e0 todos aqueles que,\ndireta ou indiretamente, contribu\u00edram para a\n\nsua realiza\u00e7\u00e3o.\n\n\n\nAgradecimentos\n\nAo Prof. Edson, pela orienta\u00e7\u00e3o.\n\n\u00c0 For\u00e7a A\u00e9rea pelo incentivo \u00e0 titula\u00e7\u00e3o de seus docentes.\n\nAo Prof. Alessandro pelas longas discuss\u00f5es.\n\nAos professores da Academia da For\u00e7a A\u00e9rea pelo apoio.\n\nAo pessoal do Departamento de Hidr\u00e1ulica e Saneamento.\n\nAos amigos do Laborat\u00f3rio de Hidr\u00e1ulica Computacional (LHC).\n\nAo Senhor Jos\u00e9 Sidney e Senhora Maria Eug\u00eania.\n\nAo Senhor Paulo Roberto e Senhora Creuza Alves.\n\n\u00c0 Rita.\n\nA todos os meus sinceros agradecimentos.\n\n\n\n\n\nResumo\nSANTOS, J.P.M (2015). M\u00e9todo multigrid alg\u00e9brico: a reutiliza\u00e7\u00e3o das estruturas multigrid\nno transporte de contaminantes. S\u00e3o Carlos, 2015. 197p. Tese (Doutorado) \u2013 Escola de\nEngenharia de S\u00e3o Carlos, Universidade de S\u00e3o Paulo, S\u00e3o Carlos, 2015.\n\nA necessidade de obter solu\u00e7\u00e3o de grandes sistemas lineares resultantes de processos de\ndiscretiza\u00e7\u00e3o de equa\u00e7\u00f5es diferenciais parciais provenientes da modelagem de diferentes\nfen\u00f4menos f\u00edsicos conduz \u00e0 busca de t\u00e9cnicas num\u00e9ricas escal\u00e1veis. M\u00e9todos multigrid\ns\u00e3o classificados como algoritmos escal\u00e1veis.Um estimador de erros deve estar associado\n\u00e0 solu\u00e7\u00e3o num\u00e9rica do problema discreto de modo a propiciar a adequada avalia\u00e7\u00e3o da\nsolu\u00e7\u00e3o obtida pelo processo de aproxima\u00e7\u00e3o. Nesse contexto, a presente tese caracteriza-se\npela proposta de reutiliza\u00e7\u00e3o das estruturas matriciais hier\u00e1rquicas de operadores de\ntransfer\u00eancia e restri\u00e7\u00e3o dos m\u00e9todos multigrid alg\u00e9bricos para acelerar o tempo de solu\u00e7\u00e3o\ndos sistemas lineares associados \u00e0 equa\u00e7\u00e3o do transporte de contaminantes em meio poroso\nsaturado. Adicionalmente, caracteriza-se pela implementa\u00e7\u00e3o das estimativas residuais para\nos problemas que envolvem dados constantes ou n\u00e3o constantes, os regimes de pequena\nou grande advec\u00e7\u00e3o e pela proposta de utiliza\u00e7\u00e3o das estimativas residuais associadas\nao termo de fonte e \u00e0 condi\u00e7\u00e3o inicial para construir procedimentos adaptativos para os\ndados do problema. O desenvolvimento dos c\u00f3digos do m\u00e9todo de elementos finitos, do\nestimador residual e dos procedimentos adaptativos foram baseados no projeto FEniCS,\nutilizando a linguagem de programa\u00e7\u00e3o PY THONR e desenvolvidos na plataforma Eclipse.\nA implementa\u00e7\u00e3o dos m\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o considera a biblioteca\nPyAMG. Baseado na reutiliza\u00e7\u00e3o das estruturas hier\u00e1rquicas, os m\u00e9todos multigrid com\nreutiliza\u00e7\u00e3o com par\u00e2metro fixo e autom\u00e1tica s\u00e3o propostos, e esses conceitos s\u00e3o estendidos\npara os m\u00e9todos iterativos n\u00e3o-estacion\u00e1rios tais como GMRES e BICGSTAB. Os\nresultados num\u00e9ricos mostraram que o estimador residual captura o comportamento\ndo erro real da solu\u00e7\u00e3o num\u00e9rica, e fornece algoritmos adaptativos para os dados cuja\nmalha retornada produz uma solu\u00e7\u00e3o num\u00e9rica similar \u00e0 uma malha uniforme com mais\nelementos. Adicionalmente, os m\u00e9todos com reutiliza\u00e7\u00e3o s\u00e3o mais r\u00e1pidos que os m\u00e9todos\nque n\u00e3o empregam o processo de reutiliza\u00e7\u00e3o de estruturas. Al\u00e9m disso, a efici\u00eancia dos\nm\u00e9todos com reutiliza\u00e7\u00e3o tamb\u00e9m pode ser observada na solu\u00e7\u00e3o do problema auxiliar,\no qual \u00e9 necess\u00e1rio para obten\u00e7\u00e3o das estimativas residuais para o regime de grande\nadvec\u00e7\u00e3o. Esses resultados englobam tanto os m\u00e9todos multigrid alg\u00e9bricos do tipo SA\nquanto os m\u00e9todos pr\u00e9-condicionados por m\u00e9todos multigrid alg\u00e9brico SA, e envolvem o\ntransporte de contaminantes em regime de pequena e grande advec\u00e7\u00e3o, malhas estruturadas\ne n\u00e3o estruturadas, problemas bidimensionais, problemas tridimensionais e dom\u00ednios com\ndiferentes escalas.\n\nPalavras-chave: m\u00e9todo de elementos finitos. m\u00e9todo multigrid alg\u00e9brico. m\u00e9todo itera-\n\n\n\ntivo n\u00e3o-estacion\u00e1rio. estimador residual. computa\u00e7\u00e3o cient\u00edfica. PythonR.\n\n\n\nAbstract\nSANTOS, J.P.M (2015). Algebraic multigrid method: the multigrid structures reuse in\ncontaminant transport. S\u00e3o Carlos, 2015. 183p. Thesis (Doctorate) \u2013 School of Engineering\nof S\u00e3o Carlos, University of S\u00e3o Paulo, S\u00e3o Carlos.\n\nThe need for solving large linear systems arising from the discretization of partial differential\nequations modelling physical phenomena motivates the search for scalable numerical\ntechniques. Multigrid algorithms are instances of such techniques.In order to provide a\nsuitable assessment of the solution obtained by such algorithms, an error estimator must\nbe associated to the numerical solution of the discretized problem. In this context, this\nthesis proposes the reutilization of the hierarchical matrix structures of transfer operators\nand the restriction to algebraic multigrid methods to speed up the process of solving the\nlinear systems associated with the contaminant transport equation in saturated porous\nmedia. In addition, it features the implementation of residual estimates for problems\ninvolving constant or non-constant data, the regimes of small- or large-scale advection and\nthe proposal of employing the residual estimates associated to the source term and to the\ninitial condition to build adaptive procedures for the problem data. The development of the\ncomputer codes of the finite element method, residual estimator and adaptive procedures\nwere based on the FEniCS project, using the programming language PY THONR and\ndeveloped on the Eclipse platform. The implementation of the algebraic methods with\nreutilization relied upon the libray PyAMG. Grounding on the idea of reutilizing the\nhierarchical structures, fixed and automatic parameters multigrid methods were proposed\nand extended to non-stationary iterative methods such as GMRES and BICGSTAB.\nThe numerical results demonstrate that the residual estimator captures the behavior of\nthe real error of the numerical solution, and provide adaptive algorithms for the data\nwhose output mesh yields a numerical solution alike to that obtained from a uniform\nmesh with more elements. Moreover, the methods with reutilization are faster than those\nthat do not reuse the structures. Besides, the efficiency of such methods can also be\nobserved in the solution of an auxiliary problem, which is necessary for deriving the\nresidual estimates in the regime of large-scale advection. These results encompass both\nthe type SA algebraic multigrid method and those pre-conditioned by them. Moreover,\nthey involve the transport of contaminants in regime of small- and large-scale advection,\nstructured and non-structured meshes, bi- and tridimensional problems and domains with\ndifferent scales.\n\nKeywords:: finite element method. algebraic multigrid method. non-stationary iterative\nmethod. residual estimator. scientific computing. PythonR.\n\n\n\n\n\nLista de ilustra\u00e7\u00f5es\n\nFigura 1 \u2013 Malha grossa ?H e malha fina ?h com H = 2h e esquema multigrid\nV -ciclo de dois n\u00edveis . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n\nFigura 2 \u2013 Esquemas multigrid V -ciclo e F-ciclo de n n\u00edveis . . . . . . . . . . . . 35\nFigura 3 \u2013 Esquemas multigrid V -ciclo de 4 n\u00edveis e sistemas lineares associados . 35\nFigura 4 \u2013 Divis\u00e3o das vari\u00e1veis da malha fina em agregados: C-vari\u00e1veis e F-\n\nvari\u00e1veis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\nFigura 5 \u2013 Representa\u00e7\u00e3o esquem\u00e1tica das condi\u00e7\u00f5es iniciais e de contorno i.,ii.,iii.,\n\niv. e v. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\nFigura 6 \u2013 Dois elementos vizinhos que compartilham uma aresta e a representa\u00e7\u00e3o\n\ndo salto da aresta de K+ para K?(PRAETORIUS; WEINMULLER;\nWISSGOTT, 2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n\nFigura 7 \u2013 Duas malhas de pontos igualmente espa\u00e7ados nas dire\u00e7\u00f5es coordenadas 72\nFigura 8 \u2013 As solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica em malha elementos finitos triangulares\n\ne fun\u00e7\u00f5es lagrangeanas lineares . . . . . . . . . . . . . . . . . . . . . . 84\nFigura 9 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica E = Erro = |CAnal?itica\n\nC0\n?\n\nCNume?rica\nC0\n\n| representado em malha de elementos finitos triangulares e\nfun\u00e7\u00f5es lagrangeanas lineares . . . . . . . . . . . . . . . . . . . . . . . 85\n\nFigura 10 \u2013 Perfis de concentra\u00e7\u00e3o comparando as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica . 86\nFigura 11 \u2013 O indicador espacial ?K em cada elemento . . . . . . . . . . . . . . . . 87\nFigura 12 \u2013 O indicador do elemento ?1K em cada elemento . . . . . . . . . . . . . 87\nFigura 13 \u2013 Os indicadores do salto ?2E e temporal ?? em cada elemento . . . . . . 88\nFigura 14 \u2013 A solu\u00e7\u00e3o anal\u00edtica e isolinhas em malha de elementos finitos e fun\u00e7\u00f5es\n\nlineares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nFigura 15 \u2013 A solu\u00e7\u00e3o num\u00e9rica e isolinhas em malha de elementos finitos e fun\u00e7\u00f5es\n\nlineares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nFigura 16 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica E = Erro = |CAnal?itica\n\nC0\n?\n\nCNume?rica\nC0\n\n| representado em malha de elementos finitos triangulares e\nfun\u00e7\u00f5es lagrangeanas lineares . . . . . . . . . . . . . . . . . . . . . . . 91\n\nFigura 17 \u2013 O indicador espacial ?K em cada elemento . . . . . . . . . . . . . . . . 92\nFigura 18 \u2013 O indicador do elemento ?1K em cada elemento . . . . . . . . . . . . . 92\nFigura 19 \u2013 O indicador do salto ?2E em cada elemento . . . . . . . . . . . . . . . . 93\nFigura 20 \u2013 Campo de velocidades n\u00e3o uniforme v = (vx,vy) = (0.5(x+1.0),?0.5(y+\n\n1)), condi\u00e7\u00e3o inicial e condi\u00e7\u00f5es de Dirichlet e Neumann . . . . . . . . 94\nFigura 21 \u2013 As solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica em malha de elementos finitos e fun\u00e7\u00f5es\n\nlineares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\nFigura 22 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica E = Erro = |CA ?C1000| 97\n\n\n\nFigura 23 \u2013 Perfis de concentra\u00e7\u00e3o para as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica . . . . . . 97\nFigura 24 \u2013 A express\u00e3o anal\u00edtica avaliada em tr\u00eas malhas diferentes: Malha01\n\npossui dois elementos em cada dire\u00e7\u00e3o coordenada, Malha02 foi obtida\npor refinamento uniforme da Malha01 e Malha03 foi obtida por 04\nrefinamentos uniformes e sucessivos da Malha01. A fun\u00e7\u00e3o fMalha03 \u00e9\nconsiderada adequada para a representa\u00e7\u00e3o da express\u00e3o anal\u00edtica de\nf(x) = x2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n\nFigura 25 \u2013 A fL2 e o erro de representa\u00e7\u00e3o da fun\u00e7\u00e3o f pela fun\u00e7\u00e3o fL2 . . . . . . 100\nFigura 26 \u2013 Malha T ?0 fornecida pelo usu\u00e1rio antes do processo adaptativo . . . . . 102\nFigura 27 \u2013 Malha T0 adequada aos dados gerada pelo procedimento adaptativo . 103\nFigura 28 \u2013 Solu\u00e7\u00e3o num\u00e9rica em malha adequada \u00e0 representa\u00e7\u00e3o dos dados . . . 103\nFigura 29 \u2013 O indicador espacial ?K em cada elemento da malha refinada no 1000-\n\n\u00e9simo instante de tempo . . . . . . . . . . . . . . . . . . . . . . . . . . 106\nFigura 30 \u2013 O indicador do elemento ?1K em cada elemento da malha refinada no\n\n1000-\u00e9simo instante de tempo . . . . . . . . . . . . . . . . . . . . . . . 106\nFigura 31 \u2013 O indicador do salto ?2E em cada elemento da malha refinada no 1000-\n\n\u00e9simo instante de tempo . . . . . . . . . . . . . . . . . . . . . . . . . . 107\nFigura 32 \u2013 O indicador temporal ??1000 em cada elemento da malha refinada . . . . 107\nFigura 33 \u2013 Malha inicial T ?0 e malha adaptada adequada aos dados dxx, dxy = dyx,\n\ndyy, f?D, f. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\nFigura 34 \u2013 A representa\u00e7\u00e3o, em malha adaptada, das fun\u00e7\u00f5es dyy, da condi\u00e7\u00e3o de\n\nDirichlet f?D e do termo de fonte f(x,y). . . . . . . . . . . . . . . . . . 110\nFigura 35 \u2013 O dom\u00ednio computacional, as curvas de n\u00edvel do termo de fonte, o campo\n\nde velocidades e as condi\u00e7\u00f5es de Dirichlet e Neumann . . . . . . . . . . 112\nFigura 36 \u2013 A solu\u00e7\u00e3o num\u00e9rica em malha estruturada com fun\u00e7\u00f5es lagrangeanas\n\nlineares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\nFigura 37 \u2013 As curvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica apresentada na figura (36) . . 113\nFigura 38 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica . . . . . . . . . . . 115\nFigura 39 \u2013 O tempo computacional e o tempo total para os sistemas lineares com\n\ncom Nv = 1282401 vari\u00e1veis . . . . . . . . . . . . . . . . . . . . . . . . 116\nFigura 40 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica . . . . . . . . . . . 117\nFigura 41 \u2013 Os tempos computacional e total para sistema linear com Nv = 1326721\n\nvari\u00e1veis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\nFigura 42 \u2013 O dom\u00ednio computacional, as curvas de n\u00edvel para C0\n\nCC0\n, o campo de\n\nvelocidades com u0 = 0.1 e as condi\u00e7\u00f5es de Dirichlet e Neumann . . . . 119\nFigura 43 \u2013 O campo de velocidades e as curvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica . . . 119\nFigura 44 \u2013 Res\u00edduos associadas \u00e0 solu\u00e7\u00e3o num\u00e9rica . . . . . . . . . . . . . . . . . . 121\nFigura 45 \u2013 O tempo computacional e o tempo total para um sistema linear com\n\nNv = 2253001 vari\u00e1veis . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\n\n\nFigura 46 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica . . . . . . . . . . . 123\nFigura 47 \u2013 O tempo computacional e o tempo total para um sistema com N =\n\n1024961 vari\u00e1veis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nFigura 48 \u2013 Malha n\u00e3o-estruturada em dom\u00ednio n\u00e3o retangular . . . . . . . . . . . 125\nFigura 49 \u2013 A condi\u00e7\u00e3o inicial em malha tranladada para origem . . . . . . . . . . 125\nFigura 50 \u2013 Curvas de n\u00edvel da fun\u00e7\u00e3o de distribui\u00e7\u00e3o de contaminantes em malha\n\ntransladada para origem . . . . . . . . . . . . . . . . . . . . . . . . . . 126\nFigura 51 \u2013 Medidas dos res\u00edduos associados a solu\u00e7\u00e3o num\u00e9rica . . . . . . . . . . . 127\nFigura 52 \u2013 O tempo computacional e o tempo total para sistemas lineares com\n\nNv = 1617033 vari\u00e1veis . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nFigura 53 \u2013 Extrapola\u00e7\u00e3o do tempo computacional para o n\u00famero de passos de\n\ntempo n > 100 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\nFigura 54 \u2013 Malha inicial e malha adaptada aos dados do problema do transporte\n\nde contaminantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\nFigura 55 \u2013 O tempo computacional e o tempo total para os problemas do transporte\n\ne auxiliar. Sistema linear com Nv = 72333 v\u00e9rtices . . . . . . . . . . . 133\nFigura 56 \u2013 O tempo computacional e o tempo total combinados para os problemas\n\ndo transporte e auxiliar. Sistema linear com Nv = 72333 vari\u00e1veis . . 134\nFigura 57 \u2013 Curvas de n\u00edvel das solu\u00e7\u00f5es num\u00e9rica C(x,y,z = constante,t40) e\n\ncurvas de n\u00edvel da solu\u00e7\u00e3o anal\u00edtica de Wexler (WEXLER, 1992) . . . . 135\nFigura 58 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica e as respectivas curvas\n\nde n\u00edvel considerando a solu\u00e7\u00e3o num\u00e9rica do problema tridimensional\nC40z=constante = C(x,y,z = constante,t40) . . . . . . . . . . . . . . . . . 135\n\nFigura 59 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica . . . . . . . . . . . 137\nFigura 60 \u2013 O tempo computacional e o tempo total para sistemas lineares com\n\nNv = 1238361 vari\u00e1veis . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n\n\n\n\n\nLista de tabelas\n\nTabela 1 \u2013 Compara\u00e7\u00e3o da performance do m\u00e9todo multigrid alg\u00e9brico cl\u00e1ssico,\nproposto por Ruge-St\u00fcben(R-S), com o m\u00e9todo do Gradiente Conjugado\nPr\u00e9-condicionado por fatora\u00e7\u00e3o de Cholesky incompleta (PCG2) para\ncinco problemas envolvendo o meio poroso. . . . . . . . . . . . . . . . 40\n\nTabela 2 \u2013 A solu\u00e7\u00e3o num\u00e9rica no 200-\u00e9simo instante de tempo com concentra\u00e7\u00e3o\nnormalizada, C200\n\nC0\n= CNume?rica\n\nC0\n, a solu\u00e7\u00e3o anal\u00edtica em t = tf = 1000.0d\n\ncom concentra\u00e7\u00e3o normalizada, CA\nC0\n\n= CAnal?itica\nC0\n\n, o erro real (Erro),\nindicador espacial (?K), o indicador do elemento (?1K) e o indicador do\nsalto (?2E) para um conjunto de pontos . . . . . . . . . . . . . . . . . 83\n\nTabela 3 \u2013 A solu\u00e7\u00e3o num\u00e9rica no 200-\u00e9simo instante de tempo com concentra\u00e7\u00e3o\nnormalizada, C200\n\nC0\n= CNume?rica\n\nC0\n, a solu\u00e7\u00e3o anal\u00edtica em t = tf = 1000.0d\n\ncom concentra\u00e7\u00e3o normalizada, CA\nC0\n\n= CAnal?itica\nC0\n\n, o erro real (Erro),\nindicador espacial (?K), o indicador do elemento (?1K) e o indicador do\nsalto (?2E) para um conjunto de pontos . . . . . . . . . . . . . . . . . 89\n\nTabela 4 \u2013 As solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica e o erro real no 1000-\u00e9simo instante\nde tempo do processo de simula\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . 95\n\nTabela 5 \u2013 Valores m\u00e1ximos para todos os passos de tempo n = {1, 2, 3, \u00b7 \u00b7 \u00b7 ,NI}:\nm\u00e1ximo dos res\u00edduos m\u00e1ximos, m\u00e1ximo dos res\u00edduos m\u00e9dios e o m\u00e1ximo\ndos res\u00edduos na norma l2 . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\n\n\n\n\nSum\u00e1rio\n\nSum\u00e1rio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n1 Introdu\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n1.1 M\u00e9todo de elementos finitos . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n1.2 Estimativas residuais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n1.3 Adaptatividade dos dados do problema do transporte . . . . . . . . . . . . 24\n1.4 M\u00e9todos multigrid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n1.5 Computa\u00e7\u00e3o Cient\u00edfica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n1.6 Considera\u00e7\u00f5es do Cap\u00edtulo . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\n2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n2.1 Objetivo principal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n3 Revis\u00e3o Bibliogr\u00e1fica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n3.1 Conceitos importantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n3.2 M\u00e9todo Multigrid Geom\u00e9trico . . . . . . . . . . . . . . . . . . . . . . . . . 33\n\n3.2.1 Os esquemas multigrid V-ciclo e F-ciclo . . . . . . . . . . . . . . . . 33\n3.3 M\u00e9todo Multigrid Alg\u00e9brico . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n3.4 M\u00e9todo Multigrid Alg\u00e9brico baseado em agrega\u00e7\u00e3o . . . . . . . . . . . . . 41\n\n3.4.1 AMG baseado em agrega\u00e7\u00e3o suavizada . . . . . . . . . . . . . . . . 42\n3.5 M\u00e9todo Multigrid Alg\u00e9brico Adaptativo . . . . . . . . . . . . . . . . . . . 44\n\n4 Metodologia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n4.1 A equa\u00e7\u00e3o do transporte de solutos em meio poroso . . . . . . . . . . . . . 47\n4.2 M\u00e9todo de Elementos Finitos e Estimativas Residuais . . . . . . . . . . . . 48\n\n4.2.1 Condi\u00e7\u00f5es adicionais para o estimador residual . . . . . . . . . . . . 49\n4.2.2 Formula\u00e7\u00e3o Variacional do Problema parab\u00f3lico . . . . . . . . . . . 50\n4.2.3 Solu\u00e7\u00e3o Anal\u00edtica para Campo Uniforme . . . . . . . . . . . . . . . 52\n4.2.4 Solu\u00e7\u00e3o anal\u00edtica para campo com depend\u00eancia espacial . . . . . . . 53\n\n4.3 Estimativas Residuais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n4.3.1 Classifica\u00e7\u00e3o dos Regimes de Advec\u00e7\u00e3o . . . . . . . . . . . . . . . . 54\n4.3.2 Contribui\u00e7\u00f5es residuais . . . . . . . . . . . . . . . . . . . . . . . . . 55\n4.3.3 Estimativas Residuais a posteriori . . . . . . . . . . . . . . . . . . . 57\n4.3.4 Estimativas Residuais Robustas . . . . . . . . . . . . . . . . . . . . 59\n4.3.5 Estimativas Residuais Gerais . . . . . . . . . . . . . . . . . . . . . . 61\n4.3.6 Discuss\u00e3o Adicional sobre as Estimativas Residuais . . . . . . . . . 61\n\n4.3.6.1 Parti\u00e7\u00e3o do Estimador Residual . . . . . . . . . . . . . . 62\n4.3.7 Contribui\u00e7\u00f5es Residuais de cada elemento da malha . . . . . . . . . 64\n\n4.4 Adaptatividade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4.4.1 Limita\u00e7\u00e3o do Erro ??I . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n\n\n4.4.2 Adaptatividade da Condi\u00e7\u00e3o Inicial . . . . . . . . . . . . . . . . . . 68\n4.4.3 Adaptatividade da fun\u00e7\u00e3o de fonte . . . . . . . . . . . . . . . . . . 69\n\n4.5 Proje\u00e7\u00e3o L2 e c\u00e1lculo das constantes ? e ? . . . . . . . . . . . . . . . . . . 70\n4.5.1 Proje\u00e7\u00e3o L2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n4.5.2 C\u00e1lculo das constante ? e ? . . . . . . . . . . . . . . . . . . . . . . 71\n\n4.5.2.1 ? atrav\u00e9s do c\u00e1lculo de autovalores . . . . . . . . . . . . . 71\n4.5.2.2 C\u00e1lculo da Constante ? . . . . . . . . . . . . . . . . . . . 72\n\n4.6 AMG com Reutiliza\u00e7\u00e3o de estruturas . . . . . . . . . . . . . . . . . . . . . 73\n4.6.1 SA com Reutiliza\u00e7\u00e3o-SAReu(?) . . . . . . . . . . . . . . . . . . . . 75\n4.6.2 SA com Reutiliza\u00e7\u00e3o e autom\u00e1tico . . . . . . . . . . . . . . . . . . 75\n4.6.3 M\u00e9todo Iterativo Pr\u00e9-condicionado por SA?Reu . . . . . . . . . . 76\n4.6.4 M\u00e9todo iterativo Pr\u00e9-condicionado por SA?ReuAuto . . . . . . . 76\n4.6.5 Compara\u00e7\u00e3o de resultados . . . . . . . . . . . . . . . . . . . . . . . 77\n4.6.6 Tempo Computacional . . . . . . . . . . . . . . . . . . . . . . . . . 78\n\n4.7 Notas sobre os desenvolvimentos . . . . . . . . . . . . . . . . . . . . . . . . 78\n5 Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n\n5.1 M\u00e9todo de elementos finitos e Estimador Residual . . . . . . . . . . . . . . 81\n5.1.1 Exemplo 01 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n\n5.1.1.1 Transporte Conservativo em Campo Uniforme:? = 0 . . . 83\n5.1.1.2 Transporte Reativo: ? 6= 0 . . . . . . . . . . . . . . . . . . 89\n\n5.1.2 Exemplo 02 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93\n5.1.3 Proje\u00e7\u00e3o L2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n5.2 Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados . . . . . . . . . . . . . . . . . 101\n5.2.1 Exemplo 03: Malha adequada \u00e0 Condi\u00e7\u00e3o Inicial . . . . . . . . . . . 101\n\n5.2.1.1 Discuss\u00e3o sobre as estimativas residuais . . . . . . . . . . 104\n5.2.2 Exemplo 04: Malha adequada \u00e0 representa\u00e7\u00e3o da fun\u00e7\u00e3o de fonte . 108\n\n5.3 M\u00e9todos Multigrid Acelerados . . . . . . . . . . . . . . . . . . . . . . . . . 111\n5.3.1 BICGSTAB Pr\u00e9-Condicionado SA . . . . . . . . . . . . . . . . . . 112\n\n5.3.1.1 Malha Estruturada . . . . . . . . . . . . . . . . . . . . . . 114\n5.3.1.2 Malha n\u00e3o estruturada . . . . . . . . . . . . . . . . . . . . 116\n\n5.3.2 Multigrid Alg\u00e9brico SA e GMRES Pr\u00e9-Condicionado por SA . . . 118\n5.3.2.1 Malha Estruturada . . . . . . . . . . . . . . . . . . . . . . 120\n5.3.2.2 Malha n\u00e3o estruturada: GMRES Pr\u00e9-Condicionado por SA122\n\n5.3.3 Malha n\u00e3o estruturada em dom\u00ednio n\u00e3o retangular . . . . . . . . . 124\n5.3.4 Reutiliza\u00e7\u00e3o para malha adaptada aos dados em regime de grande\n\nadve\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n5.3.4.1 Malha n\u00e3o estruturada adaptada aos dados do transporte 130\n\n5.3.5 A reutiliza\u00e7\u00e3o para o trasporte 3D . . . . . . . . . . . . . . . . . . 134\n6 Conclus\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n\n\n\n6.1 Sugest\u00f5es para Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . 140\n\nRefer\u00eancias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nAP\u00caNDICE A C\u00f3digo Python . . . . . . . . . . . . . . . . . . . . . . . . . . . 151\n\nA.1 C\u00f3digos para o Estimador Residual . . . . . . . . . . . . . . . . . . . . . . 151\nA.1.1 C\u00f3digo para a proje\u00e7\u00e3o L2 . . . . . . . . . . . . . . . . . . . . . . . 152\nA.1.2 C\u00f3digo para campo gradiente cont\u00ednuo . . . . . . . . . . . . . . . . 152\nA.1.3 C\u00f3digo para transformar os dados . . . . . . . . . . . . . . . . . . . 153\nA.1.4 C\u00f3digo para componentes do erro residual . . . . . . . . . . . . . . 154\nA.1.5 C\u00f3digo para o fator de pondera\u00e7\u00e3o ?S . . . . . . . . . . . . . . . . 155\nA.1.6 C\u00f3digo para as contribui\u00e7\u00f5es residuais . . . . . . . . . . . . . . . . 155\nA.1.7 C\u00f3digo para os indicadores residuais . . . . . . . . . . . . . . . . . 156\nA.1.8 C\u00f3digo para as estimativas residuais espacial e temporal . . . . . . 157\n\nA.2 O regime de grande advec\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . 158\nA.2.1 C\u00f3digo para as formas bilinear e linear do problema auxiliar . . . . 158\nA.2.2 C\u00f3digo para as contribui\u00e7\u00f5es residuais do problema auxiliar . . . . 159\nA.2.3 C\u00f3digo para obter as estimativas residuais do problema auxiliar . . 160\n\nA.3 C\u00f3digos para as estimativas dos dados . . . . . . . . . . . . . . . . . . . . 160\nA.3.1 C\u00f3digo das fun\u00e7\u00f5es auxiliares para estimativas dos dados . . . . . . 161\nA.3.2 C\u00f3digo para as componentes residuais dos dados . . . . . . . . . . . 161\nA.3.3 C\u00f3digo para as contribui\u00e7\u00f5es residuais dos dados . . . . . . . . . . 163\nA.3.4 C\u00f3digo para os indicadores residuais dos dados . . . . . . . . . . . . 164\nA.3.5 C\u00f3digo para as estimativas residuais dos dados . . . . . . . . . . . . 164\n\nA.4 C\u00f3digos para as estimativas associadas ao termo de fonte . . . . . . . . . . 165\nA.4.1 C\u00f3digo para os indicadores associados ao termo de fonte . . . . . . 166\n\nA.5 C\u00f3digo para as estimativas residuais das fronteiras . . . . . . . . . . . . . . 167\nA.6 C\u00f3digo adicional para as estimativas . . . . . . . . . . . . . . . . . . . . . 167\nA.7 C\u00f3digo para adaptatividade da condi\u00e7\u00e3o inicial . . . . . . . . . . . . . . . 169\n\nA.7.1 C\u00f3digo para estimativa do erro da condi\u00e7\u00e3o inicial . . . . . . . . . . 169\nA.7.2 C\u00f3digo para refinamento adaptativo da condi\u00e7\u00e3o inicial . . . . . . . 170\nA.7.3 C\u00f3digo modificado para refinamento adaptativo da condi\u00e7\u00e3o inicial 171\nA.7.4 C\u00f3digo para refinamento adaptativo da fun\u00e7\u00e3o de fonte . . . . . . . 172\n\nA.8 C\u00f3digos adicionais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nA.8.1 Avalia\u00e7\u00e3o do erro real . . . . . . . . . . . . . . . . . . . . . . . . . . 173\n\nA.9 Reutiliza\u00e7\u00e3o das estruturas multigrid . . . . . . . . . . . . . . . . . . . . . 174\nA.10 Nota Final . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n\nAP\u00caNDICE B Exemplos completos . . . . . . . . . . . . . . . . . . . . . . . . 181\nB.1 FEM e solu\u00e7\u00e3o anal\u00edtica . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\n\nB.1.1 Compara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica, gr\u00e1ficos . . . . . . . 185\n\n\n\nB.2 Estrat\u00e9gia adaptativa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187\nB.3 C\u00f3digo completo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\n\n\n\n21\n\n1 Introdu\u00e7\u00e3o\n\nDevido \u00e0 import\u00e2ncia dada ao entendimento e \u00e0 necessidade de previs\u00f5es envolvendo\no transporte de contaminantes, muitos modelos implementando a migra\u00e7\u00e3o de solutos em\nmeio poroso aparecem constantemente em publica\u00e7\u00f5es cient\u00edficas. Estes modelos, formula-\ndos como equa\u00e7\u00f5es diferenciais parciais (edp\u2019s), podem incluir uma s\u00e9rie de fen\u00f4menos\ntais como difus\u00e3o molecular, dispers\u00e3o mec\u00e2nica, dispers\u00e3o hidrodin\u00e2mica, depend\u00eancia\nespacial e temporal dos par\u00e2metros, rea\u00e7\u00f5es qu\u00edmicas, processos biol\u00f3gicos, heterogeneidade\ne anisotropia do meio poroso e fluido de densidade vari\u00e1vel (SIMMONS; FENSTEMAKER;\nJR., 2001), (CAO; KITANIDIS, 1999), (BEKHIT; EL-KORDY; HASSAN, 2009), (FITTS,\n2013), (LAPWORTH et al., 2012), (TUFENKJI; EMELKO; NRIAGU, 2011).\n\nSolu\u00e7\u00f5es computacionais das edp\u2019s atrav\u00e9s de m\u00e9todos de aproxima\u00e7\u00e3o tais como\nm\u00e9todo de elementos finitos requerem um adequado m\u00e9todo de solu\u00e7\u00e3o do sistema linear\ngerado. Por sua vez, essas solu\u00e7\u00f5es cont\u00eam erros inerentes ao processo de aproxima\u00e7\u00e3o, os\nquais precisam ser quantificados. Essa quantifica\u00e7\u00e3o favorece a avalia\u00e7\u00e3o da qualidade da\naproxima\u00e7\u00e3o num\u00e9rica e fornece condi\u00e7\u00f5es para o desenvolvimento de uma metodologia de\nrefinamento adaptativo.\n\nA combina\u00e7\u00e3o de alguns fatores tais como estrat\u00e9gias de refinamento adaptativo,\ngrandes dom\u00ednios, elevada precis\u00e3o, representa\u00e7\u00e3o adequada dos fen\u00f4menos f\u00edsico-qu\u00edmicos\nou biol\u00f3gicos pode gerar sistemas lineares com milhares, milh\u00f5es ou bilh\u00f5es de vari\u00e1veis.\nInfelizmente, em muitos casos, tanto os m\u00e9todos estacion\u00e1rios quanto os n\u00e3o-estacion\u00e1rios\nn\u00e3o s\u00e3o eficientes para resolver esses sistemas em um tempo aceit\u00e1vel. Para esses sistemas,\ntorna-se necess\u00e1ria a utiliza\u00e7\u00e3o de m\u00e9todos multigrid, os quais s\u00e3o considerados m\u00e9todos\ncuja estimativa de tempo varia aproximadamente com o n\u00famero de vari\u00e1veis. Embora nem\ntodos os m\u00e9todos multigrid sejam robustos, eles s\u00e3o r\u00e1pidos e, em muitos casos, escal\u00e1veis\n(ST\u00dcBEN; DELANEY; CHMAKOV, 2010), (ST\u00dcBEN, 2001). Esse potencial \u00fanico \u00e9\nfundamental e tem conduzido as pesquisas para o desenvolvimento de algoritmos multigrid\neficientes.\n\nNos \u00faltimos anos, os m\u00e9todos multigrid alg\u00e9bricos tornaram-se dispon\u00edveis por meio\nde bibliotecas num\u00e9ricas tais como PyAMG (BELL; OLSON; SCHRODER, 2011), HYPRE\n(FALGOUT; YANG, 2002), Trilinos (GEE et al., 2006). A possibilidade de integra\u00e7\u00e3o com\noutras bibliotecas tais como SciPy (JONES et al., 2001) e FEniCS (FENICS PROJECT,\n2014) torna poss\u00edvel propor e testar novos m\u00e9todos multigrid alg\u00e9bricos.\n\nBasicamente, a presente tese \u00e9 composta de quatro partes: a formula\u00e7\u00e3o de elementos\nfinitos baseada nas formas bilinear e linear, o estimador de erros com caracter\u00edsticas\nresiduais, a t\u00e9cnica adaptativa para os dados da equa\u00e7\u00e3o e reutiliza\u00e7\u00e3o das estruturas\n\n\n\n22 Cap\u00edtulo 1. Introdu\u00e7\u00e3o\n\nmultigrid para acelerar o processo de solu\u00e7\u00e3o dos sistemas lineares.\n\nPrimeiramente, a formula\u00e7\u00e3o variacional para os elementos finitos e respectiva\nvalida\u00e7\u00e3o do c\u00f3digo s\u00e3o apresentadas. Nesta parte s\u00e3o apresentados: o c\u00f3digo para im-\nplementa\u00e7\u00e3o da aproxima\u00e7\u00e3o do m\u00e9todo de elementos finitos com formula\u00e7\u00e3o ?A-est\u00e1vel\ne a valida\u00e7\u00e3o do c\u00f3digo computacional atrav\u00e9s da compara\u00e7\u00e3o com solu\u00e7\u00f5es anal\u00edticas\ndispon\u00edveis na literatura.\n\nA disponibilidade da solu\u00e7\u00e3o anal\u00edtica possibilita a avalia\u00e7\u00e3o do erro real e, por sua\nvez, possibilita a compara\u00e7\u00e3o com as quantidades disponibilizadas pelo estimador residual.\nA compara\u00e7\u00e3o das quantidades reais locais com as quantidades estimadas locais permite a\nvalida\u00e7\u00e3o do estimador residual. Essas quantidades locais propiciam o desenvolvimento de\nestrat\u00e9gias adaptativas e o c\u00e1lculo das quantidades globais associadas 1.\n\nEm seguida, a adaptatividade dos dados do problema do transporte \u00e9 discutida.\nEssa adaptatividade \u00e9 baseada nas estimativas residuais locais e globais para os dados do\nproblema do transporte e tem por objetivo construir malhas adequadas \u00e0 representa\u00e7\u00e3o\ndos dados.\n\nFinalmente, s\u00e3o propostos os m\u00e9todos multigrid alg\u00e9bricos que reutilizam as estru-\nturas hier\u00e1rquicas para acelerar o processo de solu\u00e7\u00e3o dos sistemas lineares gerados pela\naproxima\u00e7\u00e3o de elementos finitos. Essa proposta \u00e9 baseada na pequena velocidade do\nfluxo subterr\u00e2neo e na exist\u00eancia de uma estrutura hier\u00e1rquica dos m\u00e9todos multigrid. Os\nresultados envolvendo a t\u00e9cnica de reutiliza\u00e7\u00e3o consideram os m\u00e9todos multigrid alg\u00e9bricos\nbaseados em agrega\u00e7\u00e3o suavizada e os m\u00e9todos n\u00e3o-estacion\u00e1rios pr\u00e9-condicionados por\nm\u00e9todos multigrid baseados em agrega\u00e7\u00e3o suavizada.\n\nA finalidade das se\u00e7\u00f5es seguintes \u00e9 caracterizar o m\u00e9todo de elementos finitos, as\nestimativas residuais, a adaptatividade dos dados do problema do transporte e os m\u00e9todos\nmultigrid alg\u00e9bricos.\n\n1.1 M\u00e9todo de elementos finitos\n\nA aproxima\u00e7\u00e3o por elementos finitos da equa\u00e7\u00e3o de advec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o, que\ngoverna o transporte de contaminantes em meio poroso saturado, gera um sistema linear de\nequa\u00e7\u00f5es alg\u00e9bricas da forma AnCn = bn, em que A \u00e9 uma matriz que depende da malha de\nelementos finitos e do grau das fun\u00e7\u00f5es utilizadas na aproxima\u00e7\u00e3o da solu\u00e7\u00e3o desconhecida,\nC \u00e9 a solu\u00e7\u00e3o do sistema linear e representa a solu\u00e7\u00e3o de elementos finitos nos v\u00e9rtices dos\nelementos e n \u00e9 o passo de tempo. Iterativamente, obt\u00e9m-se uma sequ\u00eancia de solu\u00e7\u00f5es\n(Ci)NIi=0 que comp\u00f5e as respectivas solu\u00e7\u00f5es em cada passo de tempo da aproxima\u00e7\u00e3o para\n\n1. Refere-se a uma quantidade definida sobre todo o dom\u00ednio computacional. Em oposi\u00e7\u00e3o tem-se as\nquantidades locais definidas em um elemento espec\u00edfico do dom\u00ednio computacional.\n\n\n\n1.2. Estimativas residuais 23\n\num total de NI passos. Nesse caso, para cada n, a solu\u00e7\u00e3o Cn fornece as respectivas\nconcentra\u00e7\u00f5es nodais da malha de elementos finitos. Se um problema com solu\u00e7\u00e3o anal\u00edtica\n\u00e9 considerado, ent\u00e3o uma compara\u00e7\u00e3o quantitativa da solu\u00e7\u00e3o num\u00e9rica com solu\u00e7\u00e3o\nanal\u00edtica respectiva pode ser efetuada para a valida\u00e7\u00e3o do c\u00f3digo computacional.\n\nO desenvolvimento do c\u00f3digo computacional que implementa o m\u00e9todo de elementos\nfinitos com esquema ?A-est\u00e1vel e as solu\u00e7\u00f5es anal\u00edticas caracterizam a primeira parte deste\ntrabalho.\n\n1.2 Estimativas residuais\n\nAs estimativas residuais s\u00e3o consideradas para fornecer medidas quantitativas da\nqualidade da solu\u00e7\u00e3o num\u00e9rica tanto globalmente como localmente. As medidas globais\nreferem-se \u00e0s quantidades definidas sobre toda a malha de elementos finitos enquanto\nque as medidas locais referem-se \u00e0s quantidades definidas em cada entidade da malha\nde elementos finitos. A utiliza\u00e7\u00e3o conjunta das quantidades locais e globais favorece a\nimplementa\u00e7\u00e3o de algoritmos adaptativos para a redu\u00e7\u00e3o local e global dos erros associados\n\u00e0 aproxima\u00e7\u00e3o de elementos finitos.\n\nNeste trabalho, as contribui\u00e7\u00f5es locais s\u00e3o: as contribui\u00e7\u00f5es dos interiores; as\ncontribui\u00e7\u00f5es dos saltos; as contribui\u00e7\u00f5es das fronteiras; as contribui\u00e7\u00f5es dos dados, das\nfronteiras de Neumann e do termo de fonte; as contribui\u00e7\u00f5es da norma da energia, a qual\nest\u00e1 relacionada \u00e0 contribui\u00e7\u00e3o temporal. Essas contribui\u00e7\u00f5es locais geram as contribui\u00e7\u00f5es\nglobais dos elementos, dos saltos, das fronteiras, dos dados, das fronteiras de Neumann, do\ntermo de fonte e da norma da energia. A soma dessas contribui\u00e7\u00f5es globais em determinado\npasso de tempo, conduz \u00e0s contribui\u00e7\u00f5es globais naquele passo espec\u00edfico de tempo. A\nadequada pondera\u00e7\u00e3o dessas quantidades globais gera a estimativa global sobre toda a\nmalha e sobre todos os passos de tempo.\n\nAs medidas residuais adotadas dependem do regime de advec\u00e7\u00e3o, o qual \u00e9\ncaracterizado por constantes que relacionam os termos difusivos e advectivos da equa\u00e7\u00e3o.\nEssas constantes, baseadas apenas nas rela\u00e7\u00f5es entre os termos difusivos e advectivos,\npossibilitam separar os regimes de dispers\u00e3o dominante e advec\u00e7\u00e3o dominante 2. As estima-\ntivas residuais para os regimes de dispers\u00e3o dominante caracterizam-se pela estimativa da\nnorma da energia baseada nas quantidades calculadas na solu\u00e7\u00e3o da equa\u00e7\u00e3o de advec\u00e7\u00e3o-\ndifus\u00e3o-rea\u00e7\u00e3o, enquanto que as estimativas residuais para o regime de advec\u00e7\u00e3o dominante\ncaracteriza-se pela solu\u00e7\u00e3o de um problema el\u00edptico auxiliar. Esse problema auxiliar inclui\num esfor\u00e7o computacional para obten\u00e7\u00e3o das estimativas residuais, pois \u00e9 definido sobre a\nmesma malha de elementos finitos com fun\u00e7\u00f5es lagrangeanas lineares.\n\n2. Verf\u00fcrth (2014) separa os regimes em pequena e grande advec\u00e7\u00e3o.\n\n\n\n24 Cap\u00edtulo 1. Introdu\u00e7\u00e3o\n\nO desenvolvimento de uma metodologia para o c\u00e1lculo das estimativas residuais em\nregimes de dispers\u00e3o dominante e advec\u00e7\u00e3o dominante caracteriza a segunda parte do\ntrabalho.\n\n1.3 Adaptatividade dos dados do problema do transporte\n\nA adaptatividade configura-se como uma t\u00e9cnica para aprimorar a solu\u00e7\u00e3o em regi\u00f5es\nespec\u00edficas. Basicamente, s\u00e3o utilizadas as estimativas globais e estimativas locais para\ncontrolar o processo adaptativo. A estimativa global controla a execu\u00e7\u00e3o do processo\nenquanto as estimativas locais controlam os elementos que devem ser refinados.\n\nA adaptatividade dos dados refere-se \u00e0 t\u00e9cnica adaptativa para a constru\u00e7\u00e3o de uma\nmalha inicial T0, adequada \u00e0 representa\u00e7\u00e3o dos dados no espa\u00e7o de elementos finitos. Essa\nconstru\u00e7\u00e3o \u00e9 necess\u00e1ria, pois os dados podem n\u00e3o estar bem representados no espa\u00e7o de\nfun\u00e7\u00f5es adotado e, al\u00e9m disso, a exist\u00eancia da malha T0 \u00e9 uma das condi\u00e7\u00f5es essenciais para\no emprego do algoritmo adaptativo geral apresentado por Verf\u00fcrth (2014). Por exemplo, a\nrepresenta\u00e7\u00e3o de fun\u00e7\u00f5es com varia\u00e7\u00e3o exponencial pode n\u00e3o ser adequada em uma malha\nde elementos finitos com fun\u00e7\u00f5es lineares.\n\nNeste trabalho, duas metodologias para a constru\u00e7\u00e3o da malha T0 s\u00e3o propostas.\nA primeira \u00e9 baseada na estimativa residual associada \u00e0 condi\u00e7\u00e3o inicial, enquanto que\na segunda \u00e9 baseada na estimativa residual do termo de fonte. Os exemplos apresentam\nresultados envolvendo as duas estrat\u00e9gias.\n\nCom base nas estimativas residuais e no algoritmo adaptativo geral, a quest\u00e3o da\nrepresenta\u00e7\u00e3o adequada dos dados foi discutida. Essa discuss\u00e3o foi motivada pela suposi\u00e7\u00e3o,\npresente no algoritmo adaptativo geral, de que uma malha que represente adequadamente\nos dados e a geometria do problema est\u00e3o dispon\u00edveis. Nesse caso, uma malha uniforme e\nrefinada pode ser constru\u00edda, mas, no entanto, a quantidade de elementos pode ser grande\ne afetar os processos de refinamento adaptativo da solu\u00e7\u00e3o num\u00e9rica. Nesse contexto, o\nalgoritmo adaptativo para a adequada representa\u00e7\u00e3o dos dados, baseado nas estimativas\nresiduais, foi proposto. Esse algoritmo considera que fun\u00e7\u00f5es lagrangeanas de ordens p\ne p + k, em que p, k s\u00e3o inteiros, fornecem representa\u00e7\u00f5es diferentes dos dados. Logo,\nbaseado na estimativa residual adequada, o processo de refinamento pode ser proposto.\n\nA quest\u00e3o da adaptatividade dos dados do problema do transporte caracteriza a\nterceira parte deste trabalho.\n\n\n\n1.4. M\u00e9todos multigrid 25\n\n1.4 M\u00e9todos multigrid\n\nDe posse de uma malha adequada \u00e0 representa\u00e7\u00e3o dos dados do problema 3, os m\u00e9to-\ndos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o das estruturas hier\u00e1rquicas s\u00e3o empregados para\nobter uma solu\u00e7\u00e3o da equa\u00e7\u00e3o do transporte. As malhas de elementos finitos s\u00e3o obtidas\natrav\u00e9s de refinamentos uniformes sucessivos de uma malha inicial ou de refinamentos\nuniformes sucessivos de uma malha inicial adaptada. Ambos os processos geram sistemas\nlineares com milhares ou milh\u00f5es de vari\u00e1veis.\n\nOs m\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o das estruturas s\u00e3o utilizados para\nobter as solu\u00e7\u00f5es tanto do problema de advec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o quanto do problema\nauxiliar associado \u00e0s estimativas residuais do regime de advec\u00e7\u00e3o dominante. As solu\u00e7\u00f5es\nnum\u00e9ricas, obtidas por diferentes estrat\u00e9gias de reutiliza\u00e7\u00e3o, s\u00e3o comparadas com as\nsolu\u00e7\u00f5es obtidas pelos m\u00e9todos sem reutiliza\u00e7\u00e3o.\n\nBasicamente, nesta parte duas classes de m\u00e9todos com reutiliza\u00e7\u00e3o s\u00e3o definidas:\na classe de m\u00e9todos em que os c\u00e1lculos das agrega\u00e7\u00f5es e operadores de transfer\u00eancia de\nresultados s\u00e3o executados a cada ? passos de tempo e a classe de m\u00e9todos que determina,\nbaseada no n\u00famero de itera\u00e7\u00f5es necess\u00e1rias para a converg\u00eancia no momento da execu\u00e7\u00e3o\ndos c\u00e1lculos, automaticamente o passo de tempo em que os c\u00e1lculos das agrega\u00e7\u00f5es e\noperadores de transfer\u00eancia de resultados s\u00e3o necess\u00e1rios. As t\u00e9cnicas de reutiliza\u00e7\u00e3o podem\nser aplicadas tanto aos m\u00e9todos multigrid alg\u00e9bricos quanto aos m\u00e9todos n\u00e3o-estacion\u00e1rios\npr\u00e9-condicionados por multigrid alg\u00e9bricos.\n\nOs m\u00e9todos multigrid alg\u00e9bricos considerados s\u00e3o implementados na biblioteca\nPyAMG (BELL; OLSON; SCHRODER, 2011), enquanto que os m\u00e9todos n\u00e3o-estacion\u00e1rios\ns\u00e3o aqueles implementados por meio do pacote linalg dispon\u00edvel na biblioteca SciPy\n(JONES et al., 2001).\n\n1.5 Computa\u00e7\u00e3o Cient\u00edfica\n\nA possibilidade de integra\u00e7\u00e3o das diferentes bibliotecas utilizadas neste trabalho\nfacilita o desenvolvimento e teste de diferentes m\u00e9todos ou metodologias. No caso deste\ntrabalho, a integra\u00e7\u00e3o dos pacotes e bibliotecas possibilitaram: an\u00e1lise num\u00e9rica dos\nresultados obtidos, apresenta\u00e7\u00e3o gr\u00e1fica com metodologia similar ao MatlabR, a integra\u00e7\u00e3o\nnum\u00e9rica, a maximiza\u00e7\u00e3o e minimiza\u00e7\u00e3o de fun\u00e7\u00f5es, as manipula\u00e7\u00f5es vetoriais e matriciais\ndos resultados num\u00e9ricos e a convers\u00e3o de dados para os diferentes formatos exigidos pelas\ndiferentes bibliotecas utilizadas.\n\nA an\u00e1lise detalhada das solu\u00e7\u00f5es num\u00e9ricas \u00e9 possibilitada pela biblioteca\n\n3. Uma malha com refinamento uniforme ou malha gerada pelo algoritmo adaptativo\n\n\n\n26 Cap\u00edtulo 1. Introdu\u00e7\u00e3o\n\nNumPy (WALT; COLBERT; VAROQUAUX, 2011). Isso permite uma an\u00e1lise detalhada\ndas concentra\u00e7\u00f5es em cada um dos v\u00e9rtices dos elementos finitos al\u00e9m de disponibilizar as\nrespectivas coordenadas. Al\u00e9m disso, a an\u00e1lise a posteriori das solu\u00e7\u00f5es \u00e9 facilitada pelas\nfun\u00e7\u00f5es que permitem ler e salvar arquivos em formatos diversos para p\u00f3s-processamento.\n\nA biblioteca SciPy (JONES et al., 2001) disponibiliza, entre outras possibilidades,\no pacote de integra\u00e7\u00e3o num\u00e9rica QUADPACK, o pacote linalg e alguns m\u00e9todos de\nminimiza\u00e7\u00e3o local e global. Isso torna poss\u00edvel, atrav\u00e9s de uma metodologia aqui apresen-\ntada, o c\u00e1lculo das constantes ?, ?, ? necess\u00e1rias \u00e0s estimativas residuais, a integra\u00e7\u00e3o\nnum\u00e9rica para obten\u00e7\u00e3o das solu\u00e7\u00f5es anal\u00edticas cuja avalia\u00e7\u00e3o acurada exigem m\u00e9todos\nadaptativos de integra\u00e7\u00e3o, a utiliza\u00e7\u00e3o de m\u00e9todos n\u00e3o estacion\u00e1rios j\u00e1 testados e com\nc\u00f3digos eficientemente implementados.\n\nA biblioteca gr\u00e1fica matplotlib (HUNTER, 2007) fornece um ambiente adequado para\nas apresenta\u00e7\u00f5es gr\u00e1ficas tornando poss\u00edvel tanto a apresenta\u00e7\u00e3o de solu\u00e7\u00f5es em malhas\nestruturadas e n\u00e3o estruturadas. Para grandes conjuntos de dados e apresenta\u00e7\u00f5es mais\nelaboradas pode-se usar o Paraview (AYACHIT, 2015). Por outro lado, uma visualiza\u00e7\u00e3o\nr\u00e1pida pode ser obtida por meio das ferramentas dispon\u00edveis em FEniCS (FENICS\nPROJECT, 2014).\n\nA biblioteca para m\u00e9todos multigrid \u00e9 utilizada para obter solu\u00e7\u00e3o iterativa dos\nsistemas lineares gerados pela aproxima\u00e7\u00e3o de elementos finitos da equa\u00e7\u00e3o do transporte. A\nconveniente transforma\u00e7\u00e3o entre os diversos formatos de dados requeridos \u00e9 proporcionada\npela biblioteca SciPy (JONES et al., 2001).\n\nA integra\u00e7\u00e3o entre todas as bibliotecas num\u00e9ricas utilizadas nessa tese foi feita em Lin-\nguagem PythonR. A utiliza\u00e7\u00e3o dessa linguagem est\u00e1 estritamente ligada \u00e0 disponibilidade\nde documenta\u00e7\u00e3o para integra\u00e7\u00e3o das diferentes bibliotecas num\u00e9ricas citadas.\n\n1.6 Considera\u00e7\u00f5es do Cap\u00edtulo\n\nO desenvolvimento do c\u00f3digo computacional para a aproxima\u00e7\u00e3o da solu\u00e7\u00e3o num\u00e9rica\npelo m\u00e9todo de elementos finitos \u00e9 o primeiro item considerado nesse trabalho. Em seguida,\nas estimativas residuais, a metodologia para o c\u00e1lculo das constantes ?,? e as estrat\u00e9gias\nadaptativas dos dados s\u00e3o apresentados e desenvolvidos. Finalmente, os m\u00e9todos multigrid\ncom reutiliza\u00e7\u00e3o s\u00e3o introduzidos.\n\nBasicamente, a presente tese apresenta as contribui\u00e7\u00f5es divididas em tr\u00eas partes:\n\n1. O desenvolvimento do c\u00f3dio computacional para o m\u00e9todo de elementos finitos com\nesquema ?A-est\u00e1vel, o c\u00f3digo para o estimador residual para os regimes de dispers\u00e3o\ndominante e advec\u00e7\u00e3o dominante. Adicionalmente, s\u00e3o desenvolvidos os c\u00f3digos para\nincorporar as estimativas residuais associadas aos dados do problema do transporte\n\n\n\n1.6. Considera\u00e7\u00f5es do Cap\u00edtulo 27\n\ne uma metodologia para c\u00e1lculo das constantes associadas \u00e0s estimativas residuais\ndo regime de advec\u00e7\u00e3o dominante.\nA parti\u00e7\u00e3o do c\u00f3digo, a qual reflete a parti\u00e7\u00e3o do estimador residual, permite que\no c\u00e1lculo das estimativas residuais seja efetuado de maneira similar \u00e0s f\u00f3rmulas\napresentadas.\n\n2. O desenvolvimento de duas estrat\u00e9gias adaptativas para os dados do problema do\ntransporte de contaminantes. A primeira estrat\u00e9gia adaptativa \u00e9 baseada na estima-\ntiva residual para a condi\u00e7\u00e3o inicial, enquanto que a segunda estrat\u00e9gia \u00e9 baseada\nna estimativa residual para o termo de fonte. A estrat\u00e9gia para a condi\u00e7\u00e3o inicial\nconstr\u00f3i uma malha adequada \u00e0 representa\u00e7\u00e3o da condi\u00e7\u00e3o inicial enquanto que a\nsegunda estrat\u00e9gia constr\u00f3i uma malha adequada \u00e0 representa\u00e7\u00e3o do termo de fonte.\nAqui, ambas as estrat\u00e9gias s\u00e3o aplicadas aos outros termos presentes na equa\u00e7\u00e3o de\nadvec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o.\n\n3. O desenvolvimento de um esquema de reutiliza\u00e7\u00e3o das estruturas hier\u00e1rquicas do\nm\u00e9todo multigrid alg\u00e9brico. Novamente, duas possibilidades s\u00e3o apresentadas: um\nm\u00e9todo em que a reutiliza\u00e7\u00e3o das estruturas multigrid \u00e9 feita por um n\u00famero fixo\nde passos de tempo e um m\u00e9todo que determina automaticamente se a estrutura\nmultigrid pode ser usada no pr\u00f3ximo passo de tempo. Essas t\u00e9cnicas s\u00e3o estendidas\npara os m\u00e9todos iterativos pr\u00e9-condicionados por m\u00e9todos multigrid alg\u00e9bricos.\nPara conduzir essas discuss\u00f5es, suas respectivas implementa\u00e7\u00f5es, as contribui\u00e7\u00f5es\n\ne os resultados apresentados neste trabalho, a tese encontra-se organizada da seguinte\nforma:\n\nO cap\u00edtulo 01 apresenta uma breve descri\u00e7\u00e3o do problema a ser abordado juntamente\ncom as etapas desenvolvidas e as contribui\u00e7\u00f5es do trabalho.\n\nO cap\u00edtulo 02 apresenta, de forma sucinta, o objetivo principal da tese e as etapas\nintermedi\u00e1rias necess\u00e1rias.\n\nO cap\u00edtulo 03 apresenta uma revis\u00e3o bibliogr\u00e1fica, descrevendo os m\u00e9todos multigrid\ngeom\u00e9tricos, os m\u00e9todos multigrid alg\u00e9bricos cl\u00e1ssicos, os m\u00e9todos multigrid alg\u00e9bricos\nbaseados em agrega\u00e7\u00e3o suavizada e os m\u00e9todos multigrid alg\u00e9bricos adaptativos. A rela\u00e7\u00e3o\nentre os m\u00e9todos multigrid alg\u00e9bricos e geom\u00e9tricos \u00e9 apresentada de forma sucinta bem\ncomo as rela\u00e7\u00f5es entre os m\u00e9todos multigrid alg\u00e9bricos cl\u00e1ssicos e os baseados em agrega\u00e7\u00e3o\nsuavizada.\n\nO cap\u00edtulo 04 descreve a metodologia utilizada nesta tese. Nesse cap\u00edtulo, s\u00e3o\napresentados: a formula\u00e7\u00e3o de elementos finitos, as estimativas residuais globais e locais,\na estrat\u00e9gia adaptativa para a condi\u00e7\u00e3o inicial, a estrat\u00e9gia adaptativa para o termo de\nfonte e a t\u00e9cnica de reutiliza\u00e7\u00e3o. Adicionalmente, s\u00e3o apresentados: a metodologia de\ncompara\u00e7\u00e3o dos resultados num\u00e9ricos e anal\u00edticos e a metodologia de compara\u00e7\u00e3o dos\ntempos de solu\u00e7\u00f5es dos sistemas lineares.\n\n\n\n28 Cap\u00edtulo 1. Introdu\u00e7\u00e3o\n\nO cap\u00edtulo 05 apresenta os resultados e discuss\u00e3o. Inicialmente, a valida\u00e7\u00e3o do c\u00f3digo\ncomputacional para a aproxima\u00e7\u00e3o de elementos finitos, implementado em linguagem\nPythonR, \u00e9 apresentada. Em seguida, os estimadores e indicadores residuais s\u00e3o apresen-\ntados. Ap\u00f3s, os resultados das estrat\u00e9gias adaptativas para a condi\u00e7\u00e3o inicial e o termo\nde fonte s\u00e3o apresentados. Finalmente, os resultados envolvendo os m\u00e9todos multigrid\nalg\u00e9bricos com reutiliza\u00e7\u00e3o s\u00e3o comparados aos resultados provenientes dos m\u00e9todos\nmultgrid sem reutiliza\u00e7\u00e3o. Os m\u00e9todos com reutiliza\u00e7\u00e3o s\u00e3o empregados em diversos\nproblemas envolvendo o transporte de contaminantes e englobam problemas reativos e\nn\u00e3o reativos, malhas estruturadas e n\u00e3o estruturadas, dados com depend\u00eancia espacial e\nproblemas tridimensionais.\n\nO cap\u00edtulo 06 apresenta as conclus\u00f5es acerca das contribui\u00e7\u00f5es apresentadas no corpo\ndesta tese e aplicadas em problemas diversos envolvendo o transporte de contaminantes em\nmeio poroso. Na se\u00e7\u00e3o [6.1], s\u00e3o descritos os trabalhos futuros, os quais t\u00eam por objetivo\ncomplementar os trabalhos desenvolvidos nesta tese.\n\nOs ap\u00eandices [A] e [B] apresentam, respectivamente, as classes e fun\u00e7\u00f5es desenvolvidas\npara este trabalho e alguns exemplos de c\u00f3digos que podem ser \u00fateis para a continuidade\nou desenvolvimento de trabalhos futuros.\n\n\n\n29\n\n2 Objetivos\n\nNeste cap\u00edtulo s\u00e3o descritos o objetivo principal e as etapas intermedi\u00e1rias deste tra-\nbalho cient\u00edfico orientado pela seguinte hip\u00f3tese: A reutiliza\u00e7\u00e3o das estruturas hier\u00e1rquicas\nmultigrid produz um algoritmo multigrid eficiente para resolver a aproxima\u00e7\u00e3o, pelo\nm\u00e9todo de elementos finitos, da equa\u00e7\u00e3o do transporte de contaminantes em meio poroso\nsaturado.\n\n2.1 Objetivo principal\n\nFormular e implementar um m\u00e9todo multigrid alg\u00e9brico com reutiliza\u00e7\u00e3o das es-\ntruturas de agrega\u00e7\u00e3o e operadores de transfer\u00eancia de resultados para resolver sistemas\nlineares gerados pela aproxima\u00e7\u00e3o, pelo m\u00e9todo de elementos finitos, da equa\u00e7\u00e3o de\nadvec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o.\n\nPara que o Objetivo Principal da tese seja alcan\u00e7ado, s\u00e3o delineadas as seguintes\netapas intermedi\u00e1rias:\n\n1. Elaborar um c\u00f3digo computacional, em linguagem Python, para resolver a equa\u00e7\u00e3o do\ntransporte de contaminantes, utilizando o m\u00e9todo de elementos finitos com esquema\n?A-est\u00e1vel;\n\n2. Desenvolver uma metodologia para o c\u00e1lculo das constantes envolvidas nas estimativas\nresiduais, utilizando os processos de minimiza\u00e7\u00e3o;\n\n3. Elaborar um c\u00f3digo computacional para a metodologia do item 2;\n\n4. Elaborar um c\u00f3digo computacional, em linguagem Python, para calcular as esti-\nmativas residuais associadas \u00e0 equa\u00e7\u00e3o de advec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o em meio poroso\nsaturado. Esse c\u00f3digo deve ser capaz de incluir as estimativas residuais para os\nregimes de dispers\u00e3o dominante e advec\u00e7\u00e3o dominante, as estimativas residuais dos\ndados, as estimativas residuais associadas \u00e0s fronteiras de Neumann e as estimativas\nresiduais associadas aos termos de fonte;\n\n5. Desenvolver: uma estrat\u00e9gia de refinamento adaptativo para a condi\u00e7\u00e3o inicial e uma\nestrat\u00e9gia de refinamento adaptativo para o termo de fonte;\n\n6. Elaborar os c\u00f3digos computacionais, em linguagem Python, para o item 5;\n\n7. Desenvolver um algoritmo multigrid com reutiliza\u00e7\u00e3o das estruturas em determinados\npassos de tempo do processo de simula\u00e7\u00e3o;\n\n\n\n30 Cap\u00edtulo 2. Objetivos\n\n8. Desenvolver um algoritmo multigrid com reutiliza\u00e7\u00e3o autom\u00e1tica: o m\u00e9todo deve\nincorporar uma estrat\u00e9gia para verificar se a reutiliza\u00e7\u00e3o das estruturas \u00e9 eficiente\npara resolver o sistema linear no pr\u00f3ximo passo de tempo;\n\n9. Elaborar um c\u00f3digo computacional, em linguagem Python, para o item 6 e 7;\n\n10. Expandir os desenvolvimentos dos itens 7.,8. e 9. para os m\u00e9todos n\u00e3o estacion\u00e1rios\npr\u00e9-condicionados por m\u00e9todos multigrid alg\u00e9bricos;\n\n11. Verificar que os m\u00e9todos propostos fornecem solu\u00e7\u00f5es compat\u00edveis com aquelas do\nm\u00e9todo original.\n\n\n\n31\n\n3 Revis\u00e3o Bibliogr\u00e1fica\n\nA necessidade de obter solu\u00e7\u00e3o de grandes sistemas lineares provenientes de processos\nde discretiza\u00e7\u00e3o de equa\u00e7\u00f5es diferenciais parciais que surgem da modelagem de diferentes\nfen\u00f4menos f\u00edsicos conduz \u00e0 busca de t\u00e9cnicas computacionais que sejam r\u00e1pidas (escal\u00e1veis).\nConsiderando um problema de Poisson 3D, a solu\u00e7\u00e3o de um sistema linear da forma Ax = b,\nem que A \u00e9 N \u00d7N, exige O(N9) opera\u00e7\u00f5es para Elimina\u00e7\u00e3o Gaussiana sem utiliza\u00e7\u00e3o da\ncaracter\u00edstica de esparsidade da matriz, O(N5) para os m\u00e9todos de Jacobi e Gauss-Seidel\ne O(N4) para o m\u00e9todo SOR para uma escolha \u00f3tima do par\u00e2metro (MACLACHLAN,\n2004).\n\nA considera\u00e7\u00e3o de extensos dom\u00ednios, a presen\u00e7a de diversos fen\u00f4menos f\u00edsico-qu\u00edmicos,\na necessidade de uso de algoritmos adaptativos e simula\u00e7\u00f5es 3D tornam esses m\u00e9todos menos\natrativos em rela\u00e7\u00e3o aos m\u00e9todos multigrid. M\u00e9todos multigrid s\u00e3o, geralmente, classificados\nna literatura como algoritmos r\u00e1pidos ou escal\u00e1veis e a generalidade de aplica\u00e7\u00f5es favorece\nseu uso em problemas envolvendo o transporte de contaminantes em meio poroso. Segundo\nSt\u00fcben (2001), os m\u00e9todos multigrid podem ser divididos em duas classes distintas: m\u00e9todos\nmultigrid geom\u00e9tricos e m\u00e9todos multigrid alg\u00e9bricos. Esses m\u00e9todos s\u00e3o estritamente\nrelacionados e, por isso, os conceitos envolvendo m\u00e9todos multigrid geom\u00e9tricos s\u00e3o\napresentados primeiramente. Em seguida, os conceitos relacionados aos m\u00e9todos multigrid\nalg\u00e9bricos s\u00e3o apresentados.\n\n3.1 Conceitos importantes\n\nNesta parte, alguns conceitos relacionados ao desenvolvimento e entendimento dos\nm\u00e9todos multigrid s\u00e3o apresentados. Esses conceitos seguem, principalmente, os pontos\nde vista das refer\u00eancias (RUGE; ST\u00dcBEN, 1986), (TROTTENBERG; OOSTERLEE;\nSCHULLER, 2001), (BRIGGS, 1999) e (DOUGLAS, 1992).\n\nConsidere o problema de obter a solu\u00e7\u00e3o do sistema Au = f, onde A \u00e9 uma matriz\nN \u00d7N e seja v uma solu\u00e7\u00e3o aproximada para u. O erro e = u?v, medido de acordo com\nas normas ||e||? = max|ei| ou a norma ||e||22 =\n\n?N\ni=1 e\n\n2\ni , pode ser relacionado com o res\u00edduo\n\nr atrav\u00e9s da equa\u00e7\u00e3o r = f ?Au. Desta forma, o erro satisfaz a equa\u00e7\u00e3o Ae = f ?Au = r.\nSe a solu\u00e7\u00e3o exata da equa\u00e7\u00e3o e = A?1r \u00e9 conhecida, ent\u00e3o u = v + e \u00e9 a solu\u00e7\u00e3o exata do\nsistema de equa\u00e7\u00f5es. No entanto, esse esquema de corre\u00e7\u00e3o residual n\u00e3o \u00e9 efetivo, pois o\ntrabalho computacional equivale a resolver o sistema original.\n\nBaseado na observa\u00e7\u00e3o acima, um m\u00e9todo mais efetivo pode ser desenvolvido. Con-\nsidere, por exemplo, o m\u00e9todo iterativo de Jacobi para a solu\u00e7\u00e3o do sistema linear Au = f,\n\n\n\n32 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\nou seja, A = D ? (L + U), onde D \u00e9 a matriz diagonal e L,U s\u00e3o as matrizes com partes\ninferiores e superiores de A, respectivamente. Logo,\n\nAu = f ? (D ? (L + U))u = f ? u = Ru + D?1f (3.1)\n\nonde R = D?1(L + U). O m\u00e9todo iterativo pode ser escrito como v(i+1) = Rv(i) + D?1f e\no erro e = u?v(i+1) pode ser escrito como\n\ne(i+1) = u?v(i+1) = Ru + D?1f ? (Rv(i) + D?1f) = R(u?v(i)) = Re(i), (3.2)\n\no qual pode, recursivamente, ser escrito como e(i+1) = R(i+1)e(0), para todo i ? 1.\n\nBaseado nos conceitos de \u00c1lgebra Linear, se existe um conjunto de N autovetores\nlinearmente independentes para uma matriz N \u00d7N ent\u00e3o este conjunto forma uma base\n{wk}Nk=1. Logo, um vetor v pode ser escrito como combina\u00e7\u00e3o linear dos elementos da\nbase, ou seja, v =\n\n?N\nk=1 ckwk,ck ? R,k ? 1. Consequentemente, o erro inicial e(0) pode ser\n\nrepresentado por esta base, ou seja, e(0) =\n?N\ni=0 ckwk e o erro na i-\u00e9sima itera\u00e7\u00e3o pode ser\n\nrepresentado por\n\ne(i+1) = R(i+1)e(0) =\nN?\ni=1\n\nckR\n(i+1)wk =\n\nN?\ni=1\n\nck?\n(i+1)\nk wk (3.3)\n\nonde ?k s\u00e3o os autovalores da matriz R. Logo, para todo erro inicial e(0), ent\u00e3o e(i+1) ? 0\nquando i ?? se e somente se ?(R) = max{|?1|, |?2|, \u00b7 \u00b7 \u00b7 , |?N|} &lt;1 1 (BRIGGS, 1999).\n\nO maior valor absoluto dentre os autovalores na metade superior do espectro da\nmatriz de itera\u00e7\u00e3o R \u00e9 chamado fator de suaviza\u00e7\u00e3o (BRIGGS, 1999) e \u00e9 dado por:\n\nSmothingFactor = max{|?k|}, para\nN\n\n2\n6 k 6 N (3.4)\n\nA primeira observa\u00e7\u00e3o para a constru\u00e7\u00e3o dos m\u00e9todos multigrid \u00e9 que muitos esque-\nmas de relaxa\u00e7\u00e3o possuem essa propriedade de suaviza\u00e7\u00e3o, em que os modos oscilat\u00f3rios\ndo erro s\u00e3o eliminados efetivamente, enquanto modos suaves s\u00e3o reduzidos lentamente.\nO fator de suaviza\u00e7\u00e3o \u00e9 dependente da quantidade de elementos na malha, e a utiliza\u00e7\u00e3o\nde uma malha mais grossa, com menos elementos, transforma os modos suaves da malha\nfina em modos oscilantes na malha grossa. Na malha grossa, os modos oscilantes podem,\nnovamente, ser efetivamente eliminados (BRIGGS, 1999).\n\nA segunda observa\u00e7\u00e3o consiste em utilizar o esquema de corre\u00e7\u00e3o residual para a\nmalha grossa. A pr\u00f3xima se\u00e7\u00e3o apresenta o esquema de dois n\u00edveis.\n\n1. Segundo Briggs (1999) ?(R) &lt;1 assegura a converg\u00eancia do processo iterativo definido por R e\n?(R) \u00e9 chamado o fator de converg\u00eancia.\n\n\n\n3.2. M\u00e9todo Multigrid Geom\u00e9trico 33\n\n3.2 M\u00e9todo Multigrid Geom\u00e9trico\n\nO primeiro trabalho descrevendo as ideias dos m\u00e9todos multigrid \u00e9 datado de 1935,\nquando Southwell discute um esquema de relaxa\u00e7\u00e3o para uma malha de dois n\u00edveis. Em\n1964 Fedorenko formulou o primeiro algoritmo multigrid verdadeiro para um esquema\npadr\u00e3o de diferen\u00e7as finitas aplicado \u00e0 equa\u00e7\u00e3o de Poisson, mostrando que o esfor\u00e7o\ncomputacional requerido para atingir dada precis\u00e3o era da ordem do n\u00famero de vari\u00e1veis\nno sistema linear. O reconhecimento da utilidade pr\u00e1tica e da generalidade tornou a nova\nt\u00e9cnica aplic\u00e1vel em diversas \u00e1reas do conhecimento (SAAD, 2003).\n\nNo contexto do meio subterr\u00e2neo, a t\u00e9cnica multigrid encontrou aplica\u00e7\u00f5es nas\nsimula\u00e7\u00f5es envolvendo reservat\u00f3rios de petr\u00f3leo em duas e tr\u00eas dimens\u00f5es (SCOTT, 1985).\nA considera\u00e7\u00e3o de grandes sistemas envolvendo meio poroso, computa\u00e7\u00e3o em paralelo, a\ninflu\u00eancia dos avan\u00e7os computacionais nas t\u00e9cnicas iterativas e solu\u00e7\u00e3o de grandes sistemas\nlineares s\u00e3o apresentadas em (H\u00d6LTER; VANDERBERGHE, 1990), (MCBRYAN et al.,\n1991) e (SAIED; MAHINTHAKUMAR, 1998). A utiliza\u00e7\u00e3o do processamento em paralelo\npara resolu\u00e7\u00e3o de problemas envolvendo o meio poroso foi considerada em (MUSTAPHA;\nGHORAYEB; MUSTAPHA, 2010) e (COUMOU et al., 2008).\n\nM\u00e9todos multigrid foram aplicados na resolu\u00e7\u00e3o num\u00e9rica das equa\u00e7\u00f5es de advec\u00e7\u00e3o-\ndifus\u00e3o por (MURATOVA; ANDREEVA, 2009), considerando esquema de diferen\u00e7as\nfinitas e estado estacion\u00e1rio. Coeficientes vari\u00e1veis e esquema de diferen\u00e7as finitas com\nrefinamento local s\u00e3o apresentados em (LAI; WU; TSENG, 2007) e (ZHANG; SUN; ZHAO,\n2002). Al\u00e9m disso, a adaptatividade foi considerada por (TRANGENSTEIN, 2002) e (LI;\nCHENG; YEH, 2000).\n\n3.2.1 Os esquemas multigrid V-ciclo e F-ciclo\n\nConsidere duas malhas de elementos finitos ?h e ?H, sendo que ?h \u00e9 um refinamento\nuniforme de ?H. O processo de aproxima\u00e7\u00e3o da equa\u00e7\u00e3o diferencial parcial em cada malha\nconduz a solu\u00e7\u00e3o dos sistemas lineares Ahxh = bh e AHxH = bH. Um esquema multigrid\nde dois n\u00edveis pode ser apresentado como segue (BRIGGS, 1999):\n\nALGORITMO 01: M\u00e9todo V-ciclo de dois n\u00edveis\n\n1. Fa\u00e7a ?1 itera\u00e7\u00f5es em Ahuh = fh, com solu\u00e7\u00e3o inicial vh arbitr\u00e1ria;\n2. Calcule res\u00edduo rh = fh ? Ahuh e transfira os resultados para a malha grossa\n\nusando o operador de transfer\u00eancia de resultados da malha fina para a malha\ngrossa rH = IHh rh;\n\n\n\n34 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\n3. Resolva a equa\u00e7\u00e3o residual na malha grossa para obter a corre\u00e7\u00e3o residual,\nou seja, AHeH = rH ? eH = (AH)?1rH;\n\n4. Utilize o operador de transfer\u00eancia de resultados da malha grossa para a malha fina\neh ? IhHeH, para obter um resultado aproximado do erro na malha fina;\n\n5. Atualize o resultado obtido na malha fina, vh ? vh + eh = uh + IhHuh;\n6. Fa\u00e7a ?2 itera\u00e7\u00f5es em Ahuh = fh, em ?h com solu\u00e7\u00e3o inicial vh atualizada\n\nno passo anterior.\n\nA aplica\u00e7\u00e3o de um ciclo do esquema apresentado \u00e9 denotada por vh ? MG(fh,vh,?1,?2).\nEsse esquema \u00e9 conhecido como esquema de dois n\u00edveis, e \u00e9 essencial no entendimento dos\nm\u00e9todos multigrid. Ilustrativamente, a figura (1-a) representa um esquema de duas malhas\npara o caso de elementos finitos retangulares 2. Nesse caso, a figura (1 ? a) representa\nas discretiza\u00e7\u00f5es com malhas de tamanho h e H = 2h, enquanto que a figura (1 ? b)\nrepresenta, esquematicamente, o processo de corre\u00e7\u00e3o.\n\nFigura 1 \u2013 Malha grossa ?H e malha fina ?h com H = 2h e esquema multigrid V -ciclo de dois\nn\u00edveis\n\nFonte: (FULTON; CIELSILSKI; SCHUBERT, 1986) e (BRIGGS, 1999), respectivamente.\n\nO esquema de dois n\u00edveis possibilita o entendimento de um m\u00e9todo multigrid de n\nn\u00edveis, pois basta aplicar o processo recursivamente.\n\nAs figuras (2-a) e (2-b) representam, esquematicamente, os m\u00e9todos multigrid do\ntipo V ?Ciclo e F ?Ciclo, respectivamente. A diferen\u00e7a b\u00e1sica \u00e9 o in\u00edcio do processo\niterativo, que pode ser dividido em m\u00e9todos de corre\u00e7\u00e3o e m\u00e9todo de itera\u00e7\u00f5es sucessivas.\nO esquema V-ciclo tem in\u00edcio na malha fina e transfere os resultados para a malha mais\ngrossa enquanto que o esquema F-ciclo tem in\u00edcio na malha grossa e transfere os resultados\npara a malha mais fina.\n\n2. Originalmente, os esquemas de diferen\u00e7as finitas foram considerados\n\n\n\n3.2. M\u00e9todo Multigrid Geom\u00e9trico 35\n\nA transfer\u00eancia dos resultados da malha fina para a malha grossa \u00e9 realizada pelo\noperador de restri\u00e7\u00e3o IHh : ?h ?? ?H, enquanto que a transfer\u00eancia de resultados da malha\ngrossa para a malha fina \u00e9 realizada pelo operador de prolongamento IhH : ?h ?? ?H. Para\no m\u00e9todo de elementos finitos, os operadores de restri\u00e7\u00e3o e prolongamento s\u00e3o relacionados\npelo Princ\u00edpio de Galerkin, isto \u00e9, AH = IHh AhIhH (ST\u00dcBEN, 2001).\n\nFigura 2 \u2013 Esquemas multigrid V -ciclo e F-ciclo de n n\u00edveis\n\nFonte: (BRIGGS, 1999)\n\nDo ponto de vista matricial, os m\u00e9todos multigrid geom\u00e9tricos podem ser caracteri-\nzados, ilustrativamente, pela figura (3).\n\n(a) As malhas de um m\u00e9todo multigrid de 4 n\u00edveis (b) Os sistemas lineares associados \u00e0s mal-\nhas de elementos finitos\n\nFigura 3 \u2013 Esquemas multigrid V -ciclo de 4 n\u00edveis e sistemas lineares associados\n\nFonte: (ST\u00dcBEN, 2009)\n\n\n\n36 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\n3.3 M\u00e9todo Multigrid Alg\u00e9brico\n\nM\u00e9todos multigrid alg\u00e9bricos, em contraste com os m\u00e9todos geom\u00e9tricos, n\u00e3o\nnecessitam de conhecimento expl\u00edcito da geometria do problema. Estes m\u00e9todos con-\nstroem a hierarquia de malhas para o problema baseados no sistema linear e em certas\nsuposi\u00e7\u00f5es sobre o erro de solu\u00e7\u00e3o do sistema linear.\n\nOs conceitos dos m\u00e9todos multigrid alg\u00e9bricos (AMG) foram introduzidos por A.\nBrandt, S. McCormick e J. Ruge com contribui\u00e7\u00f5es de A.Brandt. A apresenta\u00e7\u00e3o dos prin-\ncipais conceitos envolvendo o m\u00e9todo alg\u00e9brico \u00e9 fornecida em (ST\u00dcBEN, 2001) enquanto\num tratamento completo dos m\u00e9todos multigrid \u00e9 apresentado em (TROTTENBERG;\nOOSTERLEE; SCHULLER, 2001).\n\nA dificuldade de utiliza\u00e7\u00e3o dos m\u00e9todos multigrid geom\u00e9tricos conduziu \u00e0 busca\nde m\u00e9todos algebricamente orientados. Uma das raz\u00f5es \u00e9 a crescente complexidade das\ngeometrias em aplica\u00e7\u00f5es, o que limita o uso dos m\u00e9todos multigrid baseados em hierarquias\nde malhas . A segunda raz\u00e3o \u00e9 que os m\u00e9todos multigrid podem ser m\u00e9todos escal\u00e1veis,\nou seja, o esfor\u00e7o computacional varia, aproximadamente, com o n\u00famero de vari\u00e1veis\n(ST\u00dcBEN; DELANEY; CHMAKOV, 2010).\n\nA busca por m\u00e9todos escal\u00e1veis \u00e9 necess\u00e1ria, pois a quantidade de vari\u00e1veis envolvidas\npode tornar o esfor\u00e7o computacional invi\u00e1vel para problemas com alguns milh\u00f5es ou\nbilh\u00f5es de vari\u00e1veis, ou seja, problemas em que o n\u00famero de vari\u00e1veis s\u00e3o O(106) ou\nO(109). Apesar dos avan\u00e7os computacionais, esses problemas ainda requerem m\u00e9todos\neficientes que possam ser integrados nos softwares existentes, sem necessidade de altera\u00e7\u00e3o\nde todo c\u00f3digo desenvolvido e em tempo reduzido (ST\u00dcBEN; DELANEY; CHMAKOV,\n2010).\n\nResumidamente, o m\u00e9todo multigrid geom\u00e9trico fixa as malhas e define, convenien-\ntemente, os operadores de interpola\u00e7\u00e3o e restri\u00e7\u00e3o. O m\u00e9todo multigrid alg\u00e9brico tem\numa abordagem oposta e substitui os conceitos geom\u00e9tricos por conceitos abstratos de\nconjuntos. Da mesma forma que no m\u00e9todo multigrid geom\u00e9trico \u00e9 necess\u00e1rio resolver um\nsistema linear:\n\nAhu\nh = fh ou\n\nN?\ni=1\n\nahij = f\nh\ni para i ? ?\n\nh. (3.5)\n\nA diferen\u00e7a \u00e9 que, no contexto dos m\u00e9todos multigrid alg\u00e9bricos, ?h \u00e9 um conjunto de\n\u00edndices, enquanto no m\u00e9todo multigrid geom\u00e9trico ?h corresponde a uma discretiza\u00e7\u00e3o do\ndom\u00ednio. Finalmente, uma malha grossa H \u00e9 um subconjunto, ?H, do conjunto de \u00edndices\n?h. Se os operadores de transfer\u00eancia de resultados s\u00e3o conhecidos, ent\u00e3o o mapeamento\ndos vetores de ?H em vetores de ?h pode ser feito por um operador de interpola\u00e7\u00e3o de\n\n\n\n3.3. M\u00e9todo Multigrid Alg\u00e9brico 37\n\nposto completo. O operador da malha grossa AH \u00e9 definido por\n\nAH := IHh A\nhIhH com I\n\nH\nh = (I\n\nh\nH)\n\nT . (3.6)\n\nDessa forma, o m\u00e9todo multigrid alg\u00e9brico de dois n\u00edveis pode ser definido de forma\nsimilar ao m\u00e9todo multigrid geom\u00e9trico, ou seja, uh ? uh + IhHeH ? uh + eh em que a\ncorre\u00e7\u00e3o rH = IHh rh \u00e9 a solu\u00e7\u00e3o exata da equa\u00e7\u00e3o na malha grossa. Esquematicamente, as\nfiguras (1-b), (2-a), (2-b) e (3) podem ser utilizadas para representar um m\u00e9todo multigrid\nalg\u00e9brico.\n\nSe eh = uexact ?uh \u00e9 o erro entre a solu\u00e7\u00e3o exata na malha fina e a solu\u00e7\u00e3o depois\nde algumas itera\u00e7\u00f5es, ent\u00e3o\n\nehi+1 = K\nH\nh e\n\nh\ni = (Ih ? I\n\nh\nHA\n?1\nH I\n\nH\nh Ah)e\n\nh, (3.7)\n\nonde KHh \u00e9 chamado operador de corre\u00e7\u00e3o da malha grossa. No AMG cl\u00e1ssico, tamb\u00e9m\nchamado de Ruge-St\u00fcben (RS), as vari\u00e1veis da malha fina s\u00e3o divididas em dois conjuntos\ndisjuntos, ou seja, ?h = Ch?Fh onde Ch = ?H s\u00e3o vari\u00e1veis que pertencem \u00e0 malha grossa\n(C-vari\u00e1veis) e Fh = ?h ?Ch as vari\u00e1veis complementares que pertencem estritamente \u00e0\nmalha fina (F-vari\u00e1veis). As vari\u00e1veis C e F s\u00e3o escolhidas de acordo com as seguintes\nobserva\u00e7\u00f5es (TROTTENBERG; OOSTERLEE; SCHULLER, 2001), (BRIGGS, 1999):\n\n1. Determine um subconjunto de pontos da malha grossa que possa ser usado com os\nseguintes objetivos:\ni. representar os erros suaves;\nii. para interpolar estes erros na malha fina;\n\n2. intuitivamente, um ponto uj \u00e9 um bom candidato para um C-ponto se o seu valor \u00e9\nimportante para determina\u00e7\u00e3o do valor de outro ponto ui na i-\u00e9sima equa\u00e7\u00e3o;\n\n3. Se o coeficiente aij \u00e9 \"grande\"comparado com outros elementos fora da diagonal na\ni-\u00e9sima equa\u00e7\u00e3o, ent\u00e3o uj influencia ui, ou ui depende de uj. Para matrizes sim\u00e9tricas\ne positivas definidas, se\n\n?aij > ? max\nk 6=i\n{?aik}, 0 &lt;? ? 1, (3.8)\n\nent\u00e3o o ponto i influencia o ponto j;\n\n4. O conjunto de dependentes de uma vari\u00e1vel ui, ou seja, as vari\u00e1veis das quais o valor\nde ui depende \u00e9 definido por Si = {j : aij > ? max\n\nk 6=i\n{?aik}}, e o conjunto de pontos\n\nque \u00e9 influenciado por ui \u00e9 definido por STi = {j : i ? Sj}.\n\n\n\n38 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\nDenotando, C o conjunto das vari\u00e1veis da malha grossa, F o conjunto de vari\u00e1veis\nna malha fina e Phi o conjunto de vari\u00e1veis interpoladoras da malha grossa, ou seja,\nas vari\u00e1veis da malha grossa usadas para interpolar o valor da vari\u00e1vel da malha\nfina.\n\n5. A escolha dos C-pontos \u00e9 norteada por dois crit\u00e9rios:\n\ni. Para cada i ? F, cada j ? Si deve estar em C ou deve depender de pelo menos\num ponto Phi\n\nii. C deve ser o maior subconjunto com a propriedade em que nenhum C-ponto\ndepende de outro\n\nCom estes dois crit\u00e9rios, a estrat\u00e9gia para escolher os C-pontos \u00e9 dada por:\n\n1. para cada ponto da malha k, calcule o n\u00famero de pontos que dependem de k. Atribua\na este ponto o valor calculado\n\n2. escolha o primeiro ponto com m\u00e1ximo valor global como sendo um C-ponto\n\n3. O novo C-ponto pode ser usado para interpolar os valores dos pontos que ele\ninfluencia. Marque todos estes pontos como F-pontos\n\n4. outros pontos influenciando estes novos F-pontos podem ser usados na interpola\u00e7\u00e3o.\nAtualize seus valores\n\n5. Repita at\u00e9 que todos os pontos s\u00e3o C-pontos ou F-pontos.\n\nO procedimento apresentado fornece uma parti\u00e7\u00e3o da malha e \u00e9 chamada parti\u00e7\u00e3o\nC/F . Considerando que \u00e9 dada uma parti\u00e7\u00e3o C/F , o operador de interpola\u00e7\u00e3o \u00e9 definido\npor :\n\nehi = (I\nh\nHe\n\nH)i =\n\n??\n? e\n\nH\ni se i ? Ch?\nk?Ph\n\ni\nwhike\n\nH\nk se i ? Fh\n\n(3.9)\n\nPor raz\u00f5es de efici\u00eancia Pi precisa ser um conjunto pequeno de vari\u00e1veis da malha\ngrossa na vizinhan\u00e7a do ponto i (ST\u00dcBEN, 2001). Heuristicamente, para o esquema de\nGauss-Seidel, um erro que converge lentamente \u00e9 tal que\n\nei+1 = (I ? (L + D)?1A)ei ? ei ? (L + D)?1Aei ? 0 ? r ? 0 ? ri&lt;&lt;aiiei. (3.10)\n\nLogo, se e \u00e9 um erro com converg\u00eancia lenta, ent\u00e3o localmente ei pode ser representado\npela m\u00e9dia de seus vizinhos (ST\u00dcBEN, 2001). Para definir os pesos convenientemente, \u00e9\nnecess\u00e1rio diferenciar entre os tipos de conex\u00f5es existentes, ou seja:\n\ni. Ci-i \u00e9 dependente destes C?pontos;\n\nii. Dsi - i \u00e9 dependente destes F?pontos;\n\n\n\n3.3. M\u00e9todo Multigrid Alg\u00e9brico 39\n\niii. Dwi - i n\u00e3o \u00e9 dependente destes pontos fracamente conectados sendo C-pontos ou\nF-pontos;\n\nO operador de prolongamento \u00e9 baseado na suavidade do erro e nas depend\u00eancias\ndefinidas acima com os pesos s\u00e3o definidos por\n\n?ij =\naij +\n\n?\nj?Ds\n\ni\n\naikakj?\nm?Ci\n\nakm\n\naii +\n?\nn?Dw\n\ni\nain\n\n. (3.11)\n\nCom essas nota\u00e7\u00f5es, um algoritmo multigrid alg\u00e9brico pode ser visto como um\nm\u00e9todo multigrid geom\u00e9trico com as no\u00e7\u00f5es de pontos, malha e operadores de transfer\u00eancia\nsubstitu\u00eddas adequadamente.\n\nConsidere uma sequencia de malhas ?l ? ?l+1, l = 1, 2, ...,L e um m\u00e9todo itera-\ntivo x ? (I ? RlAl)x + Rlbl para o sistema Alx = bl, em cada n\u00edvel l ? {1, 2, ...,L}.\nAl\u00e9m disso, considere que a hierarquia de malhas \u00e9 definida pelo operador de Galerkin,\nAl+1 = (Ill+1)TAlIll+1. Logo, o algoritmo multigrid alg\u00e9brico \u00e9 dado por:\n\nALGORITMO 2: AMGl\n\n1. Pr\u00e9-suaviza\u00e7\u00e3o(Presmoothing): aplique ?1 vezes o processo iterativo em\nAlxl = bl na forma xl ? (I ?RlAl)x + Rlbl;\n\n2. Corre\u00e7\u00e3o (Coarse-grid correction):\na. Defina bl+1 = (Ill+1)T (bl ?Alxl)\nb. Se l + 1 &lt;L, defina xl+1 = 0 e resolva o\nproblema da corre\u00e7\u00e3o da malha grossa Al+1xl+1 = bl+1, pela aplica\u00e7\u00e3o de\nxl+1 ? AMGl+1(xl+1,bl+1).\nSen\u00e3o, resolva o problema na malha grossa diretamente.\nc. Fa\u00e7a a corre\u00e7\u00e3o da solu\u00e7\u00e3o no n\u00edvel l: xl ? xl + Ill+1xl+1\n\n3. P\u00f3s-suaviza\u00e7\u00e3o (Postsmoothing): Aplique ?2 vezes o processo iterativo em\nAlxl = bl na forma xl ? (I ?RlAl)xl + Rlbl.\n\nA aplica\u00e7\u00e3o de uma etapa do ALGORITMO 2 \u00e9 denotada por AMG(fh,vh,?1,?2).\n\nNo contexto do meio subterr\u00e2neo, o tamanho e a complexidade do dom\u00ednio computa-\ncional s\u00e3o dois fatores-chave para utiliza\u00e7\u00e3o dos m\u00e9todos multigrid alg\u00e9bricos. As solu\u00e7\u00f5es\ndos sistemas lineares envolvem problemas com milhares ou milh\u00f5es de vari\u00e1veis, mesmo\nsem levar em conta algoritmos adaptativos, heterogeneidades, anisotropia, fluidos com\ndensidade vari\u00e1vel e processos qu\u00edmicos e biol\u00f3gicos.\n\nUtilizando esquema de diferen\u00e7as finitas, Mehl e Hill (2001) comparam a performance\n\n\n\n40 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\ndo m\u00e9todo alg\u00e9brico multigrid cl\u00e1ssico, proposto por Ruge e St\u00fcben(RUGE; ST\u00dcBEN,\n1986), com o m\u00e9todo do Gradiente Conjugado Pr\u00e9-Condicionado por Fatora\u00e7\u00e3o de Cholesky\nincompleta (PCG2) para cinco problemas envolvendo o fluxo em meio poroso. Os resultados\nobtidos, levando-se em conta apenas esfor\u00e7o computacional, s\u00e3o mostrados na tabela [1]:\n\nTabela 1 \u2013 Compara\u00e7\u00e3o da performance do m\u00e9todo multigrid alg\u00e9brico cl\u00e1s-\nsico, proposto por Ruge-St\u00fcben(R-S), com o m\u00e9todo do Gradiente\nConjugado Pr\u00e9-condicionado por fatora\u00e7\u00e3o de Cholesky incompleta\n(PCG2) para cinco problemas envolvendo o meio poroso.\n\nTipo do problema N\u00famero PCG2(s) AMG(s) PCG2(s)/AMG(s)\nvari\u00e1veis\n\nN\u00e3o linear/estacion\u00e1rio 1 728 000 3082 1781 1.73\n\nLinear/estacion\u00e1rio 1 050 000 5243 205 25.58\n\nN\u00e3o linear/transiente 147 440 852 631 1.35\n\nLinear/estacion\u00e1rio 465 600 942 50 18.84\n\nN\u00e3o linear/estacion\u00e1rio 78 817 654 108 6.06\n\nFonte: (MEHL; HILL, 2001)\n\nAs raz\u00f5es entre os tempos gastos pelos m\u00e9todos PCG2 e AMG mostram que o AMG\npossui performance superior ao PCG2 para os problemas estudados. Embora os problemas\nestacion\u00e1rios sejam resolvidos com ganho computacional de at\u00e9, aproximadamente, 25\nvezes, os problemas transientes s\u00e3o resolvidos com ganho computacional de at\u00e9 1.3 vezes.\nSegundo Mehl e Hill (2001), a efici\u00eancia de ambos os m\u00e9todos na solu\u00e7\u00e3o de problemas\ntransientes \u00e9 devida \u00e0 iteratividade do processo de simula\u00e7\u00e3o, ou seja, a solu\u00e7\u00e3o no tempo\nk \u00e9 utilizada como solu\u00e7\u00e3o inicial no tempo k + 1, e esta solu\u00e7\u00e3o \u00e9 uma solu\u00e7\u00e3o aproximada\npara o passo k + 1.\n\nMais recentemente, Detwiler et al. (2002) comparam os m\u00e9todos PCG2 e GMRES\npr\u00e9-condicionado por fatora\u00e7\u00e3o ILU, aplicados ao fluxo e transporte em meio poroso. Essa\ncompara\u00e7\u00e3o \u00e9 feita utilizando diferen\u00e7as finitas e estados estacion\u00e1rios. A an\u00e1lise dos\nresultados mostrou um ganho computacional de at\u00e9 140 vezes. No entanto, os problemas\nenvolvendo o transporte de contaminantes o ganho computacional pode atingir 17 vezes.\n\nSt\u00fcben, Delaney e Chmakov (2010) comparam um algoritmo AMG modificado\n(SAMG) com os m\u00e9todos do Gradiente Conjugado pr\u00e9-condicionado por fatora\u00e7\u00e3o ILU\ne Gradiente Bi-Conjugado Estabilizado, dependendo do problema ser sim\u00e9trico ou n\u00e3o.\nAs aplica\u00e7\u00f5es incluem os problemas abordados em Mehl e Hill (2001), e os resultados\nmostram ganho computacional de at\u00e9 duas ordens de grandeza para problemas com at\u00e9\n2.3 milh\u00f5es de vari\u00e1veis. Entretanto, mant\u00e9m-se a prefer\u00eancia por problemas estacion\u00e1rios\ne a adaptatividade do m\u00e9todo multigrid n\u00e3o \u00e9 considerada.\n\n\n\n3.4. M\u00e9todo Multigrid Alg\u00e9brico baseado em agrega\u00e7\u00e3o 41\n\nA pr\u00f3xima se\u00e7\u00e3o introduz os m\u00e9todos multigrid alg\u00e9bricos baseados em agrega\u00e7\u00e3o e\nagrega\u00e7\u00e3o suavizada.\n\n3.4 M\u00e9todo Multigrid Alg\u00e9brico baseado em agrega\u00e7\u00e3o\n\nComo no m\u00e9todo alg\u00e9brico multigrid cl\u00e1ssico, o m\u00e9todo multigrid alg\u00e9brico baseado\nem agrega\u00e7\u00e3o(SA-AMG) baseia seus operadores de transfer\u00eancia em certas hip\u00f3teses sobre\na natureza dos erros.\n\nSegundo Trottenberg, Oosterlee e Schuller (2001), se a interpola\u00e7\u00e3o \u00e9 definida tal que\ncada F-vari\u00e1vel \u00e9 interpolada exatamente por uma C-vari\u00e1vel, ent\u00e3o os m\u00e9todos baseados\nem agrega\u00e7\u00e3o s\u00e3o obtidos. Resumidamente, embora cada F-vari\u00e1vel i possa ter mais que\numa conex\u00e3o com o conjunto de C-vari\u00e1veis, o conjunto de vari\u00e1veis interpoladoras, Phi ,\n\u00e9 restrito de modo a conter exatamente uma C-vari\u00e1vel. Consequentemente, o peso ser\u00e1\nigual a um se a soma da i-\u00e9sima linha da matriz for nula. No entanto, se \u00e9 assumido que o\npeso \u00e9 unit\u00e1rio para qualquer valor da soma das linhas, ent\u00e3o o operador de interpola\u00e7\u00e3o\n\u00e9 simplificado. Consequentemente, o n\u00famero total de vari\u00e1veis pode ser dividido em\nagregados Ik, em que k ? C e Ik cont\u00e9m todos os \u00edndices i correspondendo a F-vari\u00e1veis\nque s\u00e3o interpoladas pela vari\u00e1vel C-vari\u00e1vel k.\n\nGeometricamente, um esquema para o m\u00e9todo de agrega\u00e7\u00e3o \u00e9 apresentado na figura\n(4). Note que, esquematicamente, os agregados s\u00e3o disjuntos dois a dois e cada F-vari\u00e1vel\nest\u00e1 relacionada com apenas uma C-vari\u00e1vel. Portanto, os m\u00e9todos multigrid alg\u00e9bricos\nbaseados em agrega\u00e7\u00e3o podem ser vistos como casos limites ou particulares dos m\u00e9todos\nmultigrid alg\u00e9bricos com parti\u00e7\u00e3o C/F (TROTTENBERG; OOSTERLEE; SCHULLER,\n2001).\n\nFigura 4 \u2013 Divis\u00e3o das vari\u00e1veis da malha fina em agregados: C-vari\u00e1veis e F-vari\u00e1veis.\n\nFonte: (TROTTENBERG; OOSTERLEE; SCHULLER, 2001)\n\nCom essas nota\u00e7\u00f5es, o operador de Galerkin ou operador de transfer\u00eancia de resultados\n\n\n\n42 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\npara a malha grossa \u00e9 dado por:\n\nIHh AhI\nh\nH = (akl)\n\nH =\n?\ni?Ik\n\n?\nj?Il\n\nahij (k,l ? C). (3.12)\n\nO m\u00e9todo proposto possui converg\u00eancia lenta e n\u00e3o \u00e9 robusto, mas existem duas\nalternativas para contornar esse problema. A primeira consiste em multiplicar o operador\nde Galerkin por uma constante ? = 1/? e a segunda em utilizar o pr\u00f3prio m\u00e9todo\niterativo para resolver os problemas de converg\u00eancia (TROTTENBERG; OOSTERLEE;\nSCHULLER, 2001). A utiliza\u00e7\u00e3o do m\u00e9todo iterativo conduz ao m\u00e9todo multigrid alg\u00e9brico\nbaseado em agrega\u00e7\u00e3o suavizada (SA-AMG).\n\n3.4.1 AMG baseado em agrega\u00e7\u00e3o suavizada\n\nNo m\u00e9todo multigrid alg\u00e9brico baseado em agrega\u00e7\u00e3o suavizada (SA-AMG), o\noperador constante por partes \u00e9 apenas uma tentativa inicial, a qual \u00e9 melhorada\npor algum processo de suaviza\u00e7\u00e3o antes do operador de Galerkin ser computado. Con-\nsidere, por exemplo, o m\u00e9todo de ??Jacobi para o processo de relaxa\u00e7\u00e3o e denote I?hH o\noperador de interpola\u00e7\u00e3o. O operador de transfer\u00eancia do m\u00e9todo SA-AMG \u00e9 dador por\n(TROTTENBERG; OOSTERLEE; SCHULLER, 2001):\n\nIhH = (Ih ??D\n?1\nh A\n\nf\nh)I?\n\nh\nH. (3.13)\n\nUm algoritmo para o m\u00e9todo SA-AMG pode ser formalmente visto como um m\u00e9todo\nmultigrid alg\u00e9brico definido na se\u00e7\u00e3o (3.3) com uma escolha especial dos operadores de\ntransfer\u00eancia. O operador de prolongamento \u00e9 definido como o produto do operador de\nprolongamento suavizador, Sl, com o operador de prolongamento tentativa P ll+1, ou seja:\n\nIll+1 = SlP\nl\nl+1. (3.14)\n\nA constru\u00e7\u00e3o dos operadores P ll+1 est\u00e1 baseada na constru\u00e7\u00e3o dos agregados. Por sua\nvez, os agregados Ali podem ser formados baseado apenas nas informa\u00e7\u00f5es de conectividade\ne for\u00e7a das conex\u00f5es entre as entradas da matriz Al, tais que ?Ni=1Ali = Al,Ai ? Aj =\n{?}, i = 1, 2, ...N, conforme definido na parti\u00e7\u00e3o C/F.\n\nO segundo ingrediente na constru\u00e7\u00e3o geral de um operador de agrega\u00e7\u00e3o inicial P ll+1\nconsiste em fornecer a estrutura de esparsidade derivada da agrega\u00e7\u00e3o nodal com valores\napropriados. Come\u00e7ando com uma matriz inicial, B1, cujas colunas representam o espa\u00e7o\nnulo aproximado do operador da malha fina, a constru\u00e7\u00e3o do operador de prolongamento\n\n\n\n3.4. M\u00e9todo Multigrid Alg\u00e9brico baseado em agrega\u00e7\u00e3o 43\n\ntentativa \u00e9 efetuada, e a representa\u00e7\u00e3o na malha grossa dos componentes do espa\u00e7o nulo\naproximado para satisfazer simultaneamente as equa\u00e7\u00f5es\n\nP l+1l B\nl+1 = Bl, (P ll+1)\n\nTP ll+1 = I. (3.15)\n\nDessa forma, o algoritmo para o m\u00e9todo de agrega\u00e7\u00e3o suavizada padr\u00e3o \u00e9 dado por:\n\nALGORITMO 3: M\u00e9todo de Agrega\u00e7\u00e3o Suavizada Padr\u00e3o\n\nDado A1,B1,L, para l = 1, 2, ...,L? 1:\na. Construa os agregados Ali, tais que ?i=1Ali = Al,Ai ? Aj = ?,i 6= j\n\nbaseado na informa\u00e7\u00e3o do n\u00edvel Al\nb. Construa os operadores Bl+1 e Pl+1 usando as equa\u00e7\u00f5es acima, baseado\n\nna constru\u00e7\u00e3o dos agregados\nc. Construa o operador de prolongamento suavizado :Il+1 = SlPl+1\nd. Construa a matriz da malha grossa: Al+1 = (Il+1)TAlIl+1\n\nSegundo Van?k et al. (1995), este m\u00e9todo possui taxa de converg\u00eancia 10?20 vezes menor\nque o m\u00e9todo multigrid alg\u00e9brico cl\u00e1ssico proposto por Ruge e St\u00fcben. Al\u00e9m disso, as\ncaracter\u00edsticas seguintes apontam o m\u00e9todo de agrega\u00e7\u00e3o suavizada como m\u00e9todo indicado\npara problemas envolvendo o transporte de contaminantes em meio poroso:\n\n1. m\u00e9todos baseados na t\u00e9cnica de agrega\u00e7\u00e3o suavizada \u00e9 uma forma de lidar com as\ndificuldades que surgem do uso de n\u00e3o M-matrizes (KRAUS; MARGENOV, 2009);\n\n2. Segundo Janka (2007a), Janka (2007b)\n\ni. esse m\u00e9todo \u00e9 robusto para geometrias alongadas. No caso do transporte de\ncontaminantes em meio poroso, os dom\u00ednios s\u00e3o grandes e com pouca espessura;\n\nii. pode ser aplicado em problemas com coeficientes com saltos de diversas ordens\nde grandeza (10 para 107);\n\niii. pode ser utilizado em sistemas de equa\u00e7\u00f5es com cond(A) ? 109;\n\niv. \u00e9 est\u00e1vel com respeito ao tamanho do passo de tempo;\n\nA pr\u00f3xima se\u00e7\u00e3o introduz o m\u00e9todo multigrid alg\u00e9brico adaptativo baseado em\nagrega\u00e7\u00e3o (?SA-AMG). Esse m\u00e9todo conjuga as caracter\u00edsticas do m\u00e9todo de agrega\u00e7\u00e3o\nsuavizada com adaptatividade do pr\u00f3prio m\u00e9todo iterativo.\n\n\n\n44 Cap\u00edtulo 3. Revis\u00e3o Bibliogr\u00e1fica\n\n3.5 M\u00e9todo Multigrid Alg\u00e9brico Adaptativo\n\nEssa se\u00e7\u00e3o apresenta os m\u00e9todos multigrid alg\u00e9bricos adaptativos (?-AMG) seguindo\nestritamente o ponto de vista das refer\u00eancias (BREZINA et al., 2004), (BREZINA et\nal., 2005), (BREZINA et al., 2010). Para maiores detalhes envolvendo a constru\u00e7\u00e3o dos\nm\u00e9todos multigrid alg\u00e9bricos adaptativos, as refer\u00eancias devem ser consultadas.\n\n\u00c9 conveniente ressaltar que o termo adaptativo aqui refere-se ao pr\u00f3prio m\u00e9todo\nmultigrid alg\u00e9brico e diferencia-se do termo adaptativo quando utilizando no contexto da\nmalha de elementos finitos. Em outras palavras, no m\u00e9todo de elementos finitos, o termo\nadaptativo refere-se a um processo executado sobre a malha de elementos finitos e baseado\nnos estimadores de erros, o qual refina a malha e melhora a solu\u00e7\u00e3o de acordo com o\nalgoritmo utilizado. Basicamente, um m\u00e9todo multigrid alg\u00e9brico adaptativo refere-se \u00e0\nadaptatividade do m\u00e9todo multigrid alg\u00e9brico, ou seja, um m\u00e9todo iterativo que utiliza\num algoritmo computacional para construir uma representa\u00e7\u00e3o adequada dos erros para\nmelhorar a taxa de converg\u00eancia.\n\nO termo multigrid alg\u00e9brico significa uma classe de m\u00e9todos baseados no princ\u00edpio\nmultigrid que depende pouco ou n\u00e3o depende da informa\u00e7\u00e3o geom\u00e9trica do problema, mas\nem vez disso baseia-se no conceito de suavidade alg\u00e9brica para determinar um processo\nefetivo de defini\u00e7\u00e3o das vari\u00e1veis da malha grossa. M\u00e9todos desse tipo assumem alguma\ncaracter\u00edstica da suavidade alg\u00e9brica, especificando as componentes do erro que n\u00e3o s\u00e3o\nrapidamente eliminadas pelo processo de relaxa\u00e7\u00e3o que est\u00e1 sendo usado. No m\u00e9todo\ncl\u00e1ssico, por exemplo, todas as componentes variam na dire\u00e7\u00e3o das conex\u00f5es fortes da\nmatriz enquanto que no m\u00e9todo de agrega\u00e7\u00e3o suavizado as conex\u00f5es s\u00e3o representadas\nlocalmente por um pequeno conjunto de vetores iniciais fornecidos pelo usu\u00e1rio (BREZINA\net al., 2005).\n\nSegundo Brezina et al. (2005), a ideia de empregar o m\u00e9todo para melhor\u00e1-lo n\u00e3o \u00e9\nnova e foi introduzida por Brandt, McCormick e Ruge. A adaptatividade, como apresentada\nnas se\u00e7\u00f5es pr\u00e9vias, \u00e9 introduzida por Brezina et al. (2004), por meio do m\u00e9todo ? SA-\nAMG. Este m\u00e9todo adaptativo considera o esquema de agrega\u00e7\u00e3o suavizada proposto por\nVan?k (VAN?K, 1995). O desenvolvimento e a extens\u00e3o dos conceitos para os m\u00e9todos\nmultigrid alg\u00e9bricos adaptativos (?-AMG) foram realizados por Brezina et al. (2005), e a\nconsidera\u00e7\u00e3o de problemas n\u00e3o-sim\u00e9tricos foi apresentada por Brezina et al. (2010).\n\nAs hip\u00f3teses da suavidade alg\u00e9brica e as hip\u00f3teses adicionais adotadas possibilitam\num tratamento efetivo de muitos problemas, mas tamb\u00e9m limitam o campo de aplica\u00e7\u00e3o.\nErros que escapam do processo de relaxa\u00e7\u00e3o variam drasticamente ao longo das conex\u00f5es\nfortes, e muitos outros n\u00e3o oferecem um claro entendimento do que significa conex\u00f5es\nfortes (BREZINA et al., 2005).\n\nEnquanto o uso das caracter\u00edsticas de suavidade alg\u00e9brica parece essencial para\n\n\n\n3.5. M\u00e9todo Multigrid Alg\u00e9brico Adaptativo 45\n\nobter solu\u00e7\u00e3o efetiva dos sistemas lineares, estas hip\u00f3teses adicionais limitam as aplica\u00e7\u00f5es\ndestes m\u00e9todos. Em muitos casos importantes, os erros perdidos pelo processo de relaxa\u00e7\u00e3o\npodem variar substancialmente ao longo das conex\u00f5es fortes, e, em muitos casos, at\u00e9 o\nconceito de conex\u00e3o forte n\u00e3o \u00e9 bem entendido. Al\u00e9m disso, o fornecimento de um conjunto\nrepresentativo completo de prot\u00f3tipos dos componentes suaves n\u00e3o \u00e9 sempre f\u00e1cil e nem\nposs\u00edvel na pr\u00e1tica (BREZINA et al., 2005).\n\nA ideia central do processo adaptativo \u00e9 a defini\u00e7\u00e3o do erro algebricamente suave sem\nsuposi\u00e7\u00f5es adicionais de forma que o m\u00e9todo possa determinar as vari\u00e1veis da malha grossa\nusando apenas informa\u00e7\u00f5es do sistema. O m\u00e9todo adaptativo est\u00e1 baseado na aplica\u00e7\u00e3o\ndo m\u00e9todo iterativo linear ao sistema Ax = 0 para revelar as componentes do erro que o\nm\u00e9todo n\u00e3o reduz efetivamente. Como as componentes do erro que n\u00e3o s\u00e3o eliminadas\npelo processo de suaviza\u00e7\u00e3o s\u00e3o representadas em um espa\u00e7o de dimens\u00e3o menor que a\ndimens\u00e3o original, ent\u00e3o o objetivo da fase inicial do m\u00e9todo adaptativo ?SA \u00e9 calcular\num conjunto de vetores, B, tal que represente as componentes do erro que a relaxa\u00e7\u00e3o n\u00e3o\n\u00e9 eficiente. Tais componentes, s\u00e3o chamadas de algebricamente suaves (BREZINA et al.,\n2004).\n\n\n\n\n\n47\n\n4 Metodologia\n\nEste cap\u00edtulo apresenta a sequ\u00eancia de desenvolvimento deste trabalho. Inicialmente\na equa\u00e7\u00e3o que descreve o transporte de solutos em meio poroso \u00e9 apresentada. Em\nseguida, o m\u00e9todo de elementos finitos com formula\u00e7\u00e3o ?-est\u00e1vel \u00e9 utilizado para derivar\na formula\u00e7\u00e3o variacional do problema do transporte de contaminantes em meio poroso\nsaturado. A verifica\u00e7\u00e3o e valida\u00e7\u00e3o do c\u00f3digo computacional \u00e9 feita por meio de solu\u00e7\u00f5es\nanal\u00edticas conhecidas na literatura, as quais englobam problemas com termos reativos ou\nn\u00e3o reativos, dados constantes ou n\u00e3o constantes. Finalmente, as estimativas residuais,\nas t\u00e9cnicas adaptativas para os dados da equa\u00e7\u00e3o do transporte de contaminantes e os\nm\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o s\u00e3o introduzidos.\n\n4.1 A equa\u00e7\u00e3o do transporte de solutos em meio poroso\n\n\u00c1gua superficial ou subterr\u00e2nea, em estado natural, nunca \u00e9 pura. Muitos constitu-\nintes est\u00e3o presentes devido a intera\u00e7\u00e3o com o ambiente. A qualidade da \u00e1gua depende\ndas diferentes quantidades de subst\u00e2ncias dissolvidas e quantidade de um soluto dissolvido\nno solo \u00e1gua pode ser expresso atrav\u00e9s da sua concentra\u00e7\u00e3o, C, que \u00e9 a massa de soluto\npor volume de \u00e1gua, com dimens\u00f5es [M/L3] , normalmente expressa em mg/l ou o g/m3\n\nequivalente. A adequada quantifica\u00e7\u00e3o da concentra\u00e7\u00e3o C em meios subterr\u00e2neos \u00e9 depen-\ndente tanto das caracter\u00edsticas do soluto quanto das caracter\u00edsticas do meio subterr\u00e2neo\n(DE SMEDT, 2006).\n\nA \u00e1gua e subst\u00e2ncias dissolvidas se movem lentamente em camadas menos perme\u00e1veis\ntais como argila, mas suas velocidades aumentam significativamente em camadas mais\nperme\u00e1veis tais como areia e cascalho. Al\u00e9m disso, os contaminantes podem ser dispersos\npor difus\u00e3o molecular, dispers\u00e3o mec\u00e2nica, retardados por troca i\u00f4nica ou absorvidos pelo\nmaterial s\u00f3lido, degradados por rea\u00e7\u00f5es qu\u00edmicas naturais ou processos bioqu\u00edmicos (DE\nSMEDT, 2006). Uma descri\u00e7\u00e3o detalhada dos fen\u00f4menos envolvidos no transporte de\ncontaminantes em meio poroso subterr\u00e2neo pode ser encontrada em (BATU, 2006).\n\nNeste trabalho, a equa\u00e7\u00e3o de advec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o (ADR) \u00e9 considerada para\ndescrever o transporte de contaminantes em um meio poroso subterr\u00e2neo. Essa equa\u00e7\u00e3o\nincorpora os fluxos advectivo e dispersivos associados \u00e0s transforma\u00e7\u00f5es qu\u00edmicas de\nprimeira ordem e um termo de fonte ou sorvedouro f?\n\n[\nM\nL3T\n\n]\nem aqu\u00edferos com fluxo\n\n\n\n48 Cap\u00edtulo 4. Metodologia\n\nn\u00e3o-uniforme e \u00e9 dada por (BEAR, 1979):\n\n?t (?C + ?bKdC) ?div(D???C) + v? \u00b7?C + ?(?C + ?bKdC) = f? (4.1)\n\nonde C \u00e9 a concentra\u00e7\u00e3o de soluto[M/L3], ? o conte\u00fado de umidade no solo [adimensional],\n?C o gradiente de concentra\u00e7\u00e3o [M/L4], D? = Dm + Dd o tensor da dispers\u00e3o hidrod-\nin\u00e2mica [L2/T], v? vetor de velocidade aparente [L/T], ? o coeficiente de decaimento de\n1a ordem [T?1], ?b a densidade volum\u00e9trica do meio poroso [M/L3] e Kd \u00e9 o coeficiente de\ndistribui\u00e7\u00e3o 1.\n\nNo caso em que o meio poroso \u00e9 saturado e o aqu\u00edfero \u00e9 confinado, a equa\u00e7\u00e3o [4.1]\npode ser simplificada para\n\n?tC ?div(D?C) + v \u00b7?C + ?C = f (4.2)\n\nonde o conte\u00fado de umidade ? assume o mesmo valor da porosidade efetiva ?efe, D = D?/R,\nv = v?/(?efeR), f = f?/(?efeR).\n\nA adequada modelagem do fen\u00f4menos f\u00edsico requer que condi\u00e7\u00f5es iniciais e de\nfronteira sejam impostas \u00e0s equa\u00e7\u00f5es diferenciais parciais. A pr\u00f3xima se\u00e7\u00e3o considera a\nequa\u00e7\u00e3o [4.2] e as condi\u00e7\u00f5es iniciais e de fronteira, necess\u00e1rias \u00e0 obten\u00e7\u00e3o de uma solu\u00e7\u00e3o\nnum\u00e9rica ou anal\u00edtica. Al\u00e9m disso, a formula\u00e7\u00e3o do m\u00e9todo de elementos finitos e as\nhip\u00f3teses necess\u00e1rias para obten\u00e7\u00e3o das estimativas residuais s\u00e3o apresentadas.\n\n4.2 M\u00e9todo de Elementos Finitos e Estimativas Residuais\n\nFormalmente, o problema do transporte de contaminantes considera a equa\u00e7\u00e3o [4.2]\ne as condi\u00e7\u00f5es iniciais e de fronteira, e \u00e9 dado por 2:\n\n?tC ?div(D?C) + v \u00b7?C + ?C = f em ? \u00d7 (0, tfinal]\nC = 0 em ?D \u00d7 (0, tfinal]\n\nn \u00b7D?C = g em ?N \u00d7 (0, tfinal]\nC = C0 em ? para t = 0\n\n(4.3)\n\nonde x = (x1,x2, \u00b7 \u00b7 \u00b7 ,xd), d > 2, ? ? Rd, \u00e9 um dom\u00ednio poligonal com fronteira de\nLipschitz ? formado de duas partes disjuntas ?D, ?N, C = C(x,t) \u00e9 a solu\u00e7\u00e3o do problema,\nD = D(x,t) \u00e9 a matriz de dispers\u00e3o, v = v(x,t) = (v1(x,t),v2(x,t)), \u00b7 \u00b7 \u00b7 ,vd(x,t) \u00e9\no campo de velocidades, ? = ?(x,t)) \u00e9 uma fun\u00e7\u00e3o que descreve as rea\u00e7\u00f5es do meio,\n\n1. Ver (BATU, 2006) para uma discuss\u00e3o sobre o coeficiente Kd\n2. Esta \u00e9 a equa\u00e7\u00e3o adotada por (VERF\u00dcRTH, 2004) para obter as estimativas residuais\n\n\n\n4.2. M\u00e9todo de Elementos Finitos e Estimativas Residuais 49\n\nf = f(x,t) \u00e9 a fonte de contamina\u00e7\u00e3o, C = 0 em ?D \u00d7 (0, tfinal] \u00e9 a condi\u00e7\u00e3o de fronteira\nde Dirichlet, n \u00b7D?C = g em ?N \u00d7 (0, tfinal] \u00e9 a condi\u00e7\u00e3o de fronteira do tipo Neumann e\nC0 = C(x,y) = C(x,y,t = 0) \u00e9 a condi\u00e7\u00e3o inicial.\n\n4.2.1 Condi\u00e7\u00f5es adicionais para o estimador residual\n\nA formula\u00e7\u00e3o matem\u00e1tica do m\u00e9todo de elementos finitos considera a formula\u00e7\u00e3o\nvariacional, a qual exige considera\u00e7\u00f5es adicionais sobre os dados para garantir a exist\u00ean-\ncia e unicidade de solu\u00e7\u00e3o da formula\u00e7\u00e3o variacional (PRAETORIUS; WEINMULLER;\nWISSGOTT, 2008).\n\nOs dados D, v, ?, f, g e C0 s\u00e3o fun\u00e7\u00f5es reais com depend\u00eancia espacial e temporal.\nAl\u00e9m disso, as seguintes condi\u00e7\u00f5es adicionais dever ser satisfeitas, conforme descrito em\nVerf\u00fcrth (2004) e Praetorius, Weinmuller e Wissgott (2008):\n\n(P1) A matriz de dispers\u00e3o 3 D \u00e9 sim\u00e9trica, uniformemente positiva definida e uniforme-\nmente isotr\u00f3pica. Formalmente,\n\n? = inf\n0<t?tfinal\n\ninf\nx??\n\nmin\nRd?{0}\n\nzT \u00b7D(x,t)z\nzTz\n\n> 0 (4.4)\n\ne\n\n? =??1 sup\n0<t?tfinal\n\nsup\nx??\n\nmax\nz?Rd?{0}\n\nzT \u00b7D(x,t)z\nzTz\n\n= O(1) (4.5)\n\nA constante ? de (P1) \u00e9 um limitante inferior para o menor autovalor de D em ?\n(PRAETORIUS; WEINMULLER; WISSGOTT, 2008).\n\n(P2) A fun\u00e7\u00e3o de rea\u00e7\u00e3o ? = ?(x,t) \u00e9 uma fun\u00e7\u00e3o escalar e n\u00e3o negativa.\n\n(P3) Existe uma constante ? tal que ? ? 12divv ? ? ? 0 para quase todo x ? ? e\n0 ? t ? T. Al\u00e9m disso, existe uma constante c? ? 0 de tamanho moderado tal que\nsup\n\n0?t?T\nsup\nx??\n|?(x,t)| ? c??.\n\n(P4) As fronteiras de Dirichlet ?D t\u00eam medida (d? 1) - dimensional positiva e incluem o\nfluxo de entrada\n\n?\n0<t?T\n\n{x ? ? : v \u00b7n(x) &lt;0}.\n\n(P4?) Na fronteira de Neumann ?N existe apenas fluxo de sa\u00edda convectivo, ou seja,?\n0<t?T\n\n{x ? ? : v \u00b7n(x) > 0}.\n\n3. Verf\u00fcrth (2014), Verf\u00fcrth (2004) e Praetorius, Weinmuller e Wissgott (2008) referem-se \u00e0 difus\u00e3o.\nNo entanto, no contexto do fluxo subterr\u00e2neo o termo mais adequado \u00e9 dispers\u00e3o, pois o efeito difusivo \u00e9\num dos respons\u00e1veis pelo transporte de contaminantes (Ver Batu (2006),(BEAR, 1979) para uma discuss\u00e3o\ndetalhada dos termos respons\u00e1veis pela dispers\u00e3o de contaminantes)\n\n\n\n50 Cap\u00edtulo 4. Metodologia\n\n4.2.2 Formula\u00e7\u00e3o Variacional do Problema parab\u00f3lico\n\nPara derivar a discretiza\u00e7\u00e3o espa\u00e7o-temporal da equa\u00e7\u00e3o (4.3), considere uma fun\u00e7\u00e3o\nteste w ? H1D(?) em que H1D(?) denota o subespa\u00e7o do espa\u00e7o de Sobolev H1(?) =\nW 1,2(?), com fun\u00e7\u00f5es que s\u00e3o nulas nas fronteiras de Dirichlet ?D. Multiplicando a equa\u00e7\u00e3o\n(4.3) por uma fun\u00e7\u00e3o teste w e usando integra\u00e7\u00e3o por partes, a forma fraca (4.6) \u00e9 obtida.\n\n?\n?\n\n(?tCw + ?C \u00b7D?w + v \u00b7?Cw + ?Cw) d? =\n?\n\n?\nfwd? +\n\n?\n?N\ngwdS (4.6)\n\nPara a discretiza\u00e7\u00e3o temporal, escolha NI > 1 e defina a parti\u00e7\u00e3o do tempo por\nI = {t0 = 0 &lt;t1 &lt;.. . &lt;tN?1 &lt;tN = tfinal} com passos de tempo ?n = tn ? tn?1.\nPara um tempo arbitr\u00e1rio tn, denote a solu\u00e7\u00e3o discreta e os dados por Cn = C(x,y,tn),\nDn = D(x,y,tn), vn = v(x,y,tn), ?n = ?(x,y,tn), fn = f(x,y,tn), gn = g(x,y,tn). Al\u00e9m\ndisso, defina a triangula\u00e7\u00e3o espacial Tn do dom\u00ednio ? e o espa\u00e7o de elementos finitos Xn\nque consiste de todas as fun\u00e7\u00f5es polinomiais cont\u00ednuas por partes com grau no m\u00ednimo\num 4.\n\nA derivada temporal \u00e9 aproximada por diferen\u00e7as finitas de primeira ordem, ou seja,\n\n?tC =\nCn ?Cn?1\n\n?n\n, (4.7)\n\nenquanto que as outras quantidades com depend\u00eancia temporal s\u00e3o aproximadas pelo ?-\nesquema, o qual \u00e9 a combina\u00e7\u00e3o convexa dos esquemas de diferen\u00e7as atrasadas e adiantadas\nde Euler. Formalmente,\n\nCn,? := ?Cn + (1 ??)Cn?1, Dn,? := ?Dn + (1 ??)Dn?1,\nvn,? = ?vn + (1 ??)vn?1, ?n,? = ??n + (1 ??)?n?1,\nfn,? := ?fn + (1 ??)fn?1, gn,? := ?gn + (1 ??)gn?1.\n\n(4.8)\n\nA equa\u00e7\u00e3o (4.3), atrav\u00e9s da formula\u00e7\u00e3o variacional, \u00e9 transformada no problema\ndiscreto:\n\n4. No caso em que um algoritmo para a adaptatividade espacial e temporal \u00e9 empregado, condi\u00e7\u00f5es\nadicionais sobre a malha de elementos finitos e o espa\u00e7o de fun\u00e7\u00f5es polinomiais devem ser incorporadas.\nVer (VERF\u00dcRTH, 2004) para maiores detalhes.\n\n\n\n4.2. M\u00e9todo de Elementos Finitos e Estimativas Residuais 51\n\nEncontrar Cn ? Xn, 0 ? n ? NI, tal que C0 = ?0C0 e para n = 1, 2, ...,NI?\n?\n\n1\n?n\n\n(Cn ?Cn?1)wnd? +\n?\n\n?\n(??Cn + (1 ??)?Cn?1) \u00b7Dn,?h ?wnd?+?\n\n?\nv\nn,?\nh \u00b7?(?C\n\nn + (1 ??)Cn?1)wnd? +\n?\n\n?\n?\nn,?\nh (?C\n\nn + (1 ??)Cn?1)wnd? =?\n?\n\n(fnh + (1 ??)f\nn?1\nh )wnd? +\n\n?\n?N\n\n(?gnh + (1 ??)g\nn?1\nh )wnd?, wn ? Xn (4.9)\n\nonde Dn,?h , v\nn,?\nh , ?\n\nn,?\nh , f\n\nn,?\nh e g\n\nn,?\nh representam os dados no espa\u00e7o de elementos finitos Xn e\n\nmalha Tn.\n\nA formula\u00e7\u00e3o (4.9) pode ser escrita em uma forma compacta a(Cnn,wn) = l(wn) em\nque a(Cnn,wn) \u00e9 a forma bilinear (4.10) e l(wn) \u00e9 a forma linear (4.11) e dadas por:\n\na(Cn,w) =\n?\n\n?\n\n1\n?n\nCnwnd? +\n\n?\n?\n\n(??Cn) \u00b7Dn,?h ?wnd?+?\n?\nv\nn,?\nh \u00b7?(?C\n\nn)wnd?+\n?\n\n?\n?\nn,?\nh (?C\n\nn)wnd? ?\n?\n\n?N\n?n \u00b7Dnh?C\n\nnwndS (4.10)\n\nL(wn) =\n?\n\n?\n\n1\n?n\nCn?1wnd? +\n\n?\n?\n\n((? ? 1)?Cn?1) \u00b7Dn,?h ?wnd?+?\n?\nv\nn,?\nh \u00b7?((? ? 1)C\n\nn?1)wnd? +\n?\n\n?\n?\nn,?\nh ((? ? 1)C\n\nn?1)wnd?+?\n?\n\n(?fnh + (1 ??)f\nn?1\nh )wnd? +\n\n?\n?N\n\n(1 ??) n \u00b7Dn?1h ?C\nn?1wndS. (4.11)\n\nEssa formula\u00e7\u00e3o de elementos finitos possibilita a obten\u00e7\u00e3o das formas bilinear\ne linear, as quais s\u00e3o essenciais para a implementa\u00e7\u00e3o do m\u00e9todo de elementos finitos\nseguindo a metodologia FEniCS (FENICS PROJECT, 2014).\n\nA implementa\u00e7\u00e3o das formas bilinear (4.10) e linear (4.11), geram sistemas lineares\nda forma AnCn = bn, em que n denota tanto o passo de tempo, a malha de elementos\nfinitos e o espa\u00e7o de elementos finitos no passo n. Desse modo, da solu\u00e7\u00e3o no n? 1-\u00e9simo\npasso de tempo, a solu\u00e7\u00e3o no n-\u00e9simo passo de tempo \u00e9 calculada. Matematicamente, a\nsolu\u00e7\u00e3o \u00e9 computada por Cn = (An)?1b mas, computacionalmente, esse procedimento \u00e9\nexecutado por meio de um m\u00e9todo direto ou iterativo.\n\nUm exemplo de c\u00f3digo computacional que implementa o transporte de contaminantes,\nutilizando as formas bilinear e linear, com m\u00e9todo direto de solu\u00e7\u00e3o, \u00e9 apresentado no\nap\u00eandice (B.1).\n\nAs pr\u00f3ximas se\u00e7\u00f5es apresentam duas solu\u00e7\u00f5es anal\u00edticas utilizadas para valida\u00e7\u00e3o do\nc\u00f3digo computacional para a aproxima\u00e7\u00e3o de elementos finitos e para o estimador residual.\n\n\n\n52 Cap\u00edtulo 4. Metodologia\n\n4.2.3 Solu\u00e7\u00e3o Anal\u00edtica para Campo Uniforme\n\nEsta se\u00e7\u00e3o considera a solu\u00e7\u00e3o anal\u00edtica bidimensional apresentada por Wexler (1992)\npara campo de velocidades uniforme em dom\u00ednio infinito e com dados constantes. A solu\u00e7\u00e3o\nanal\u00edtica apresentada requer as seguintes hip\u00f3teses adicionais:\n\n1. o aqu\u00edfero possui extens\u00e3o infinita, e a fonte n\u00e3o pontual de contamina\u00e7\u00e3o tem\ncomprimento finito;\n\n2. a densidade e a viscosidade do fluido s\u00e3o constantes;\n\n3. o contaminante est\u00e1 sujeito a transforma\u00e7\u00e3o qu\u00edmica de primeira ordem. Se o\ncontaminante \u00e9 conservativo, ent\u00e3o ? = 0;\n\n4. o fluxo uniforme ocorre na dire\u00e7\u00e3o x com velocidade constante vx;\n\n5. os coeficientes de dispers\u00e3o longitudinal e transversal (Dx,Dy) s\u00e3o constantes.\n\nAl\u00e9m disso, as condi\u00e7\u00f5es iniciais e de contorno devem ser tais que:\n\ni. C = C0 para x = 0 e Y1 &lt;y &lt;Y2\n\nii. C = 0 para x = 0 e y ? Y1 y ? Y2\n\niii. C = 0, ?C\n?y\n\n= 0, y = \u00b1?\n\niv. C = 0, ?C\n?x\n\n= 0, x = ?\n\nv. C = 0 para t = 0 e 0 ? x ?\u00b1?\n\nonde Y1,Y2 s\u00e3o as coordenadas dos extremos da fonte de contaminantes. Ilustrativamente,\na (5-a) representa o campo de velocidades e as condi\u00e7\u00f5es i., ii. e v., enquanto que a figura\n(5-b) representa as condi\u00e7\u00f5es iii. e iv.\n\n(a) O campo de velocidades e as condi\u00e7\u00f5es i., ii. e v. (b) As condi\u00e7\u00f5es iii. e iv.\n\nFigura 5 \u2013 Representa\u00e7\u00e3o esquem\u00e1tica das condi\u00e7\u00f5es iniciais e de contorno i.,ii.,iii., iv. e v.\n\n\n\n4.2. M\u00e9todo de Elementos Finitos e Estimativas Residuais 53\n\nNeste caso, a solu\u00e7\u00e3o anal\u00edtica \u00e9 dada por:\n\nC(x,y,t) =\nC0x?\n?Dx\n\nexp\n(\nx \u00b7vx\n2Dx\n\n)? t/4\n0\n\n1\nZ3\n\nexp\n[\n?\n(\nV 2\n\n4Dx\n+ ?\n\n)\nZ4 ?\n\nx2\n\n4DxZ4\n\n]\n\u00d7?\n\n?erfc\n?\n? Y1 ?y\n\n2Z2\n?\nDy\n\n?\n??erfc\n\n?\n? Y2 ?y\n\n2Z2\n?\nDy\n\n?\n?\n?\n?dZ (4.12)\n\nonde erfc(z) = 1 ?erf(z) \u00e9 a fun\u00e7\u00e3o erro complementar e erf(z) \u00e9 a fun\u00e7\u00e3o erro obtida\nda distribui\u00e7\u00e3o normal padr\u00e3o.\n\nA solu\u00e7\u00e3o anal\u00edtica (4.12) \u00e9 calculada por interm\u00e9dio da utiliza\u00e7\u00e3o conjunta das\nbibliotecas FEniCS (FENICS PROJECT, 2014) e SciPy (JONES et al., 2001). A integral\n\u00e9 avaliada pelo pacote de quadratura num\u00e9rica QUADPACK disponibilizado no SciPy.\nPara as avalia\u00e7\u00f5es envolvendo os valores nodais das concentra\u00e7\u00f5es, os resultados anal\u00edticos\ne num\u00e9ricos s\u00e3o utilizados em forma vetorial ou matricial. As avalia\u00e7\u00f5es envolvendo a\nnorma L2 consideram a interpola\u00e7\u00e3o dos resultados anal\u00edticos na malha de elementos com\nfun\u00e7\u00f5es lagrangeanas da mesma ordem utilizada no m\u00e9todos dos elementos finitos.\n\nUm exemplo de c\u00f3digo computacional que implementa a solu\u00e7\u00e3o de elementos finitos,\na solu\u00e7\u00e3o anal\u00edtica, as compara\u00e7\u00f5es e interpola\u00e7\u00e3o dos resultados anal\u00edticos no espa\u00e7o de\nelementos finitos \u00e9 apresentado no ap\u00eandice (B.1).\n\n4.2.4 Solu\u00e7\u00e3o anal\u00edtica para campo com depend\u00eancia espacial\n\nEsta se\u00e7\u00e3o considera uma solu\u00e7\u00e3o anal\u00edtica em que os dados da equa\u00e7\u00e3o de advec\u00e7\u00e3o-\ndifus\u00e3o-rea\u00e7\u00e3o s\u00e3o (vx,vy) = (u0x,?u0y), Dx = D0v20x2, Dy = D0v20y2, para x > 0, y > 0\ne u0,D0 constantes.\n\nSegundo Zoppou e Knight (1999) a equa\u00e7\u00e3o sem termo reativo, em forma conservativa,\n\u00e9 dada por:\n\n?C\n\n?t\n+\n\n?\n\n?x\n(vxC) +\n\n?\n\n?y\n(vyC) =\n\n?\n\n?x\n(Dx\n\n?C\n\n?x\n) +\n\n?\n\n?y\n(Dy\n\n?C\n\n?y\n) (4.13)\n\nonde ?\u00b7(vx,vy) = 0 e a fonte de contaminantes possui formato de segmento de reta unit\u00e1rio\ncuja massa unit\u00e1ria \u00e9 liberada instantaneamente em (x0,y0), possui solu\u00e7\u00e3o anal\u00edtica dada\npor:\n\nC(x,y,t) =\n1\n\n4?D0u20t\n?\nxyx0y0\n\n(\nxy0\nx0y\n\n)1/2u0D0\n\u00d7 exp\n\n(\n??2 ? 2(1 + D20u20)t2\n\n4D0t\n\n)\n, (4.14)\n\nonde ? = (1.0/u0) \u00b7\n?\n\nlog(x/x0)2 + log(y/y0)2.\n\n\n\n54 Cap\u00edtulo 4. Metodologia\n\nA pr\u00f3xima se\u00e7\u00e3o apresenta as estimativas residuais, que incorporam a diferencia\u00e7\u00e3o\ndos regimes de advec\u00e7\u00e3o, os termos de fonte, as fronteiras, a condi\u00e7\u00e3o inicial e a estimativa\ntemporal.\n\n4.3 Estimativas Residuais\n\nNa equa\u00e7\u00e3o (4.3), div(D?C) \u00e9 o termo dispersivo 5, v \u00b7?C \u00e9 o termo advectivo e\n?C \u00e9 o termo reativo. A fun\u00e7\u00e3o f \u00e9 chamada de termo de fonte e representa a entrada ou\nsa\u00edda de solutos do dom\u00ednio computacional ?.\n\nO efeito combinado dos termos dispersivo, difusivo e reativo determina a distribui\u00e7\u00e3o\nde contaminantes no dom\u00ednio computacional. No entanto, um dos termos pode determinar o\ncomportamento qualitativo do transporte, e essa predomin\u00e2ncia \u00e9 utilizada para classificar\no regime de transporte de contaminantes.\n\n4.3.1 Classifica\u00e7\u00e3o dos Regimes de Advec\u00e7\u00e3o\n\nDe acordo com a predomin\u00e2ncia dos termos, o regime de transporte de contaminantes\n\u00e9 classificado em:\n\n1. Dispers\u00e3o dominante: Se |v|L?(0,tfinal;W 1,?(?)) 6 cc? e ? 6 cr? com constantes de\nordem 1;\n\nNeste caso o temo div(D?C) domina o regime de transporte. Fisicamente, isso\nsignifica que o transporte \u00e9 realizado da regi\u00e3o com alta concentra\u00e7\u00e3o para a regi\u00e3o\ncom baixa concentra\u00e7\u00e3o at\u00e9 que o equil\u00edbrio ocorra. A matriz de coeficientes D \u00e9\nproporcional \u00e0 dispersividade, ou seja, determina a velocidade e dire\u00e7\u00e3o do processo\n(PRAETORIUS; WEINMULLER; WISSGOTT, 2008).\n\n2. Rea\u00e7\u00e3o dominante: O temo ?C domina se |v|L?(0,tfinal;W 1,?(?)) 6 cc? e ? ? cr?\ncom constantes de ordem 1. O nome deste termo \u00e9 relacionado com as rea\u00e7\u00f5es\nqu\u00edmicas de primeira ordem. 6\n\n3. Advec\u00e7\u00e3o dominante: Se |v|L?(0,tfinal;W 1,?(?)) ? ?, o temo v \u00b7?C determina o\ncomportamento qualitativo da solu\u00e7\u00e3o de (4.3) 7 (PRAETORIUS; WEINMULLER;\nWISSGOTT, 2008).\n\n5. D engloba os efeitos de difus\u00e3o molecular e dispers\u00e3o hidrodin\u00e2mica conforme apresentado em\nBatu (2006), ou seja, D = D0 + Dm\n\n6. Uma rea\u00e7\u00e3o de primeira ordem tem a taxa proporcional \u00e0 concentra\u00e7\u00e3o de um dos reagentes\n(PRAETORIUS; WEINMULLER; WISSGOTT, 2008)\n\n7. A convec\u00e7\u00e3o ou advec\u00e7\u00e3o \u00e9 a transfer\u00eancia for\u00e7ada de concentra\u00e7\u00e3o ou energia. O campo vetorial\nv define dire\u00e7\u00e3o, sentido e magnitude do processo\n\n\n\n4.3. Estimativas Residuais 55\n\nA classifica\u00e7\u00e3o do regime \u00e9 baseada apenas nas rela\u00e7\u00f5es entre os termos advectivos,\ndispersivos e reativos e, portanto, n\u00e3o \u00e9 dependente do processo de aproxima\u00e7\u00e3o da equa\u00e7\u00e3o\ndiferencial parcial. Por outro lado a classifica\u00e7\u00e3o baseada no n\u00famero de Peclet e Courant \u00e9\ndependente da parti\u00e7\u00e3o do dom\u00ednio computacional e da parti\u00e7\u00e3o temporal. Firmiano (2010)\nprop\u00f5e um intervalo para a constante caracter\u00edstica cc baseado nos n\u00fameros de Peclet e\nCourant. Uma generaliza\u00e7\u00e3o dos resultados obtidos por Firmiano (2010) \u00e9 apresentada na\nse\u00e7\u00e3o (5.1.1).\n\n4.3.2 Contribui\u00e7\u00f5es residuais\n\nEsta se\u00e7\u00e3o apresenta o estimador residual preliminar em sua forma mais geral\napresentada por Verf\u00fcrth (2004). Isso fornece uma vis\u00e3o geral da constru\u00e7\u00e3o do estimador\nresidual e possibilita esclarecer algumas considera\u00e7\u00f5es adotadas na tese. Al\u00e9m disso, essa\napresenta\u00e7\u00e3o facilita a introdu\u00e7\u00e3o e justifica a utiliza\u00e7\u00e3o do estimador residual, apresentado\npor Praetorius, Weinmuller e Wissgott (2008), nos algoritmos adaptativos para os dados\ndo problema do transporte.\n\nBasicamente o estimador residual preliminar engloba os res\u00edduos, medidos em norma\nconveniente, da aproxima\u00e7\u00e3o de cada uma das entidades presentes na aproxima\u00e7\u00e3o da\nequa\u00e7\u00e3o ADR.\n\nA quantidade residual que avalia a qualidade da solu\u00e7\u00e3o num\u00e9rica em um elemento\nespec\u00edfico da malha de elementos finitos \u00e9 chamada residual do elemento. Para todo\nelemento K, o residual do elemento RK \u00e9 dado por:\n\nRK = fI ?\n1\n?n\n\n(\nCn ?Cn?1\n\n)\n+ div(Dhn,??(?Cn + (1 ??)Cn?1))\n\n?vn,?h \u00b7?(?C\nn + (1 ? ?)Cn?1) ??n,?h (?C\n\nn + (1 ? ?)Cn?1), (4.15)\n\nonde as fun\u00e7\u00f5es fI,gI s\u00e3o as proje\u00e7\u00f5es L2 da fun\u00e7\u00e3o f, discretizadas pelo ?-esquema, sobre\nos espa\u00e7os de elementos finitos Xn. Matematicamente,\n\nfI(\u00b7, t) = ?n(?f(\u00b7, tn) + (1 ??)f(\u00b7, tn?1)) = ?n(?fn + (1 ??)fn?1 (4.16)\n\ngI(\u00b7, t) = ?n(?g(\u00b7, tn) + (1 ??)g(\u00b7, tn?1)) = ?n(?gn + (1 ??)gn?1 (4.17)\n\npara todo 1 ? n ? NI.\n\nOutra quantidade importante \u00e9 o residual lateral, o qual avalia a varia\u00e7\u00e3o do diver-\ngente de um elemento para outro e fornece tanto uma aproxima\u00e7\u00e3o para conserva\u00e7\u00e3o do\nfluxo para elementos vizinhos como elementos com face ou aresta na fronteira de Neumann\n(PRAETORIUS; WEINMULLER; WISSGOTT, 2008).Essa quantidade residual deve ser\ncalculada para todas as arestas E da malha de elementos finitos e \u00e9 dada por:\n\n\n\n56 Cap\u00edtulo 4. Metodologia\n\nRE =\n\n?????\n????\n[\nn \u00b7Dhn,??(?Cn + (1 ??)Cn?1)\n\n]\nE\n\nse E * ?\ngI ? n \u00b7Dhn,??(?Cn + (1 ??)Cn?1) se E ? ?N\n0 se E ? ?D\n\n(4.18)\n\nonde [\u00b7]E representa o operador de salto.\n\nOperador de Salto: Seja d = 2, K+ e K? dois elementos vizinhos que compartilham\numa mesma aresta E = K+ ?K?, como mostrado na figura (6). Considere q em H1(K+)?\nH1(K?), ent\u00e3o existem as restri\u00e7\u00f5es q|?K+ e q|?K? e o operador de salto de q de K+ para\nK? na dire\u00e7\u00e3o do vetor normal n = nK+\n\n[q]E =\n{\nq|?K+ ? q|?K?\n\n}\n|E (4.19)\n\nFigura 6 \u2013 Dois elementos vizinhos que compartilham uma aresta e a representa\u00e7\u00e3o do salto da\naresta de K+ para K?(PRAETORIUS; WEINMULLER; WISSGOTT, 2008)\n\nFonte: (PRAETORIUS; WEINMULLER; WISSGOTT, 2008)\n\nSe d = 3, ent\u00e3o o operador de salto deve ser definido para as faces e arestas dos\nelementos.\n\nDa mesma forma que a representa\u00e7\u00e3o da solu\u00e7\u00e3o num\u00e9rica ocasiona as contribui\u00e7\u00f5es\nresiduais RK e RE, a representa\u00e7\u00e3o dos dados tamb\u00e9m ocasiona as contribui\u00e7\u00f5es residuais\ndos dados DK e DE. Essas contribui\u00e7\u00f5es ser\u00e3o denominadas contribui\u00e7\u00f5es dos dados para\nos elementos e para as laterais, respectivamente, e dados por:\n\nDK = ?div\n{(\nD\nn,?\nh ?D\n\nn,?\n)\n?\n(\n?Cn + (1 ??)Cn?1\n\n)}\n+(\n\nv\nn,?\nh ?v\n\nn,?\n)\n\u00b7?\n\n(\n?Cn + (1 ??)Cn?1\n\n)\n?\n(\n?\nn,?\nh ??\n\nn,?\n)(\n?Cn + (1 ??)Cn?1\n\n)\n, (4.20)\n\n\n\n4.3. Estimativas Residuais 57\n\nDE =\n\n?????\n????\n[\nn \u00b7\n\n(\nD\nn,?\nh ?D\n\nn,?\n)\n?(?Cn + (1 ??)Cn?1)\n\n]\nE\n\nse E * ?\nn \u00b7\n\n(\nDn,?n ?Dn,?\n\n)\n?(?Cn + (1 ??)Cn?1) se E ? ?N\n\n0 se E ? ?D,\n(4.21)\n\nonde Dn,?h ,v\nn,?\nh ,?\n\nn,?\nh denotam a aproxima\u00e7\u00e3o de elementos finitos, enquanto que Dn,?,vn,?,?n,?\n\ndenotam a discretiza\u00e7\u00e3o temporal.\n\nNesse momento, algumas observa\u00e7\u00f5es s\u00e3o necess\u00e1rias:\n\n1. Considere que X = D,? ou X = v. Logo, Xn,?h \u00e9 a representa\u00e7\u00e3o espacial da\ndiscretiza\u00e7\u00e3o temporal Xn,?, enquanto que Xn,? = ?X(\u00b7, tn) + (1 ? ?)X(\u00b7, tn?1)\n\u00e9 a representa\u00e7\u00e3o anal\u00edtica da discretiza\u00e7\u00e3o temporal.\n\n2. Grosseiramente, a diferen\u00e7a Xn,?h ?Xn,? avalia a qualidade da representa\u00e7\u00e3o espacial\ndo esquema de discretiza\u00e7\u00e3o temporal. Se Xn,? \u00e9 representado exatamente, ent\u00e3o a\ndiferen\u00e7a \u00e9 nula e, consequentemente, o erro de representa\u00e7\u00e3o associado \u00e9 nulo.\n\n4.3.3 Estimativas Residuais a posteriori\n\nNesta se\u00e7\u00e3o o estimador residual preliminar \u00e9 apresentado. Esse estimador incorpora\nas quantidades residuais RK, RE, DK, DE, a norma da energia ||| \u00b7 ||| e a norma dual\n||| \u00b7 |||? 8, a qual necessita de hip\u00f3teses adicionais sobre o regime de advec\u00e7\u00e3o para obten\u00e7\u00e3o\ndas estimativas residuais robustas. No entanto, a adequada apresenta\u00e7\u00e3o do estimador\nresidual requer algumas defini\u00e7\u00f5es adicionais.\n\n1. A norma da energia ||| \u00b7 ||| \u00e9 dada por:\n\n|||Cn ?Cn?1||| =\n{\n?||?(Cn ?Cn?1)||L2(?) + ?||Cn ?Cn?1||L2(?)\n\n}1/2\n. (4.22)\n\n2. Fator de pondera\u00e7\u00e3o ?S: Para cada elemento na malha de elementos finitos, defina o\nfator de pondera\u00e7\u00e3o ?S por\n\n?S := min{hS??1/2,??1/2} (4.23)\n\nonde S ? {K,E} \u00e9 um par\u00e2metro local de um elemento ou uma face ou aresta,\nrespectivamente, ? e ? s\u00e3o os par\u00e2metros definidos nas condi\u00e7\u00f5es impostas sobre os\ndados do problema e hS \u00e9 o di\u00e2metro do elemento.\n\n8. Ver Verf\u00fcrth (2004)\n\n\n\n58 Cap\u00edtulo 4. Metodologia\n\n3. Estimador Espacial ((?(n))2) 9 e Estimador dos Dados ((?(n))2): Para todo 1 ? n ?\nNI e todo elemento N, as quantidades ((?(n))2) e (?(n))\n\n2 s\u00e3o dadas por 10:\n\n(\n?(n)\n\n)2\n=\n?\nK\n\n?2K||RK||\n2\nL2(K) +\n\n?\nE\n\n??\n1\n2 ?E||RE||2L2(E), (4.24)\n\n(\n?(n)\n\n)2\n=\n?\nK\n\n?2K||DK||\n2\nL2(K) +\n\n?\nE\n\n??\n1\n2 ?E||DE||2L2(E). (4.25)\n\nSegundo Verf\u00fcrth (2004), considerando que as condi\u00e7\u00f5es P1 ? P4 s\u00e3o satisfeitas,\no erro da solu\u00e7\u00e3o do problema variacional (4.6) e do problema discreto (4.9) \u00e9 limitado\nsuperiormente por:\n\n?u?uh,??X(0,T)? c?\n{\n?C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+ |||Cn ?Cn?1|||2 + |||v \u00b7?\n\n(\nCn ?Cn?1\n\n)\n|||2?\n]\n\n+\n\n?f ?fh,??2L2(0,T,H?1(?))+?g ?gh,??\n2\nL2(0,T,H?1(?N ))\n\n}1/2\n(4.26)\n\ne em cada intervalo (tn?1, tn], 1 ? n ? N, inferiormente por\n\n?1/2n\n\n{(\n?(n)\n\n)2\n+ |||Cn ?Cn?1||| + |||v \u00b7?\n\n(\nCn ?Cn?1\n\n)\n|||2?\n}1/2\n\n?\n\nc?\n\n{\n?C ?Ch,??2X(0,T)+?n\n\n(\n?(n)\n\n)2\n+?f ?fh,??2L2(0,T,H?1(?))+?g ?gh,??\n\n2\nL2(0,T,H?1(?N ))\n\n}1/2\n.\n\nA constante c? depende das raz\u00f5es hK/?K e h?K/?K, enquanto a constante c? depende\ndas raz\u00e3o hK/?K, do m\u00e1ximo grau das fun\u00e7\u00f5es nos elementos finitos e da constante\n?.Todas as constantes s\u00e3o independentes do tempo final e dos par\u00e2metros (?,|c| e r no\ncaso constante).\n\nSegundo Praetorius, Weinmuller e Wissgott (2008), se as condi\u00e7\u00f5es (P1)-(P4?) s\u00e3o\nsatisfeitas, ent\u00e3o o limite superior do estimador residual \u00e9 dado por:\n\n?u?uh,??X(0,T)?c?\n{\n?C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?\n\n(n)\nf\n\n)2\n+\n(\n?\n\n(n)\nN\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2 (4.27)\n\n9. Praetorius, Weinmuller e Wissgott (2008) denota essa quantidade por Erro de Verf\u00fcrth tipo I\n10. Verf\u00fcrth (2004) incorpora condi\u00e7\u00f5es adicionais devido ao processo adaptativo espacial-temporal\n\n\n\n4.3. Estimativas Residuais 59\n\nonde\n(\n?\n\n(n)\nf\n\n)\n,\n(\n?\n\n(n)\nN\n\n)\ne\n(\n?(n)?\n\n)2\ns\u00e3o as contribui\u00e7\u00f5es do termo de fonte, das fronteiras de\n\nNeumann e contribui\u00e7\u00e3o temporal, respectivamente, e dadas por:\n\n(\n?\n\n(n)\nf\n\n)2\n=\n?\nK\n\n?K\n[\n?2?f(\u00b7, tn) ?f\n\n(n)\nh ?\n\n2\nK+(1 ??)\n\n2?f(\u00b7, tn?1) ?f\n(n?1)\nh ?\n\n2\nK\n\n]\n(4.28)\n\n(\n?\n\n(n)\nN\n\n)2\n= ??1/2\n\n?\nE\n\n?E\n[\n?2?g(\u00b7, tn) ?g\n\n(n)\nh ?\n\n2\nK+(1 ??)\n\n2?g(\u00b7, tn?1) ?g\n(n?1)\nh ?\n\n2\nK\n\n]\n(4.29)\n\n(\n?(n)?\n\n)2\n= |||Cn ?Cn?1|||2 + |||v \u00b7?(Cn ?Cn?1)|||?+\n\n(1 + ?)2?n\n[? tn\n\ntn?1\n?f?(t)?2dt +\n\n? tn\ntn?1\n?g?(t)?N?\n\n2dt + ??1\n? tn\ntn?1\n?D?(t) \u00b7?uh?2dt+\n\n? tn\ntn?1\n?c? \u00b7?uh?2dt +\n\n? tn\ntn?1\n?r?(t)uh(t)?2dt\n\n]\n(4.30)\n\nA quantidade (4.26) diferencia-se de (4.27) pela exist\u00eancia das estimativas dos erros\nde aproxima\u00e7\u00e3o das fun\u00e7\u00f5es f, g e pelas estimativas temporais adicionais. Al\u00e9m disso,\no estimador de Praetorius, Weinmuller e Wissgott (2008) n\u00e3o possui um limite inferior\npara o caso geral. No entanto, se ambas as condi\u00e7\u00f5es (P4) e (P4?) s\u00e3o satisfeitas, ent\u00e3o a\nestimativa do limite superior de Praetorius, Weinmuller e Wissgott (2008) pode ser usada\nno estimador de Verf\u00fcrth (2004) 11.\n\nO estimador residual preliminar n\u00e3o \u00e9 comput\u00e1vel, pois envolve o termo ||| \u00b7 |||?. Os\npr\u00f3ximos resultados limitam o termo ||| \u00b7 |||? por quantidades comput\u00e1veis para os casos\nde dispers\u00e3o dominante e advec\u00e7\u00e3o dominante.\n\n4.3.4 Estimativas Residuais Robustas\n\nA diferencia\u00e7\u00e3o dos regimes est\u00e1 ligada \u00e0 forma de obten\u00e7\u00e3o das estimativas residuais.\nSe o regime \u00e9 caracterizado pela dispers\u00e3o dominante, ent\u00e3o estimativas diretas podem\nser obtidas. No entanto, se o regime \u00e9 caracterizado pela advec\u00e7\u00e3o dominante, ent\u00e3o \u00e9\nnecess\u00e1rio resolver um problema auxiliar em cada passo de tempo para obter estimativas\nresiduais robustas da equa\u00e7\u00e3o de advec\u00e7\u00e3o-difus\u00e3o-rea\u00e7\u00e3o.\n\nSe o m\u00e1ximo valor do campo de velocidades \u00e9 relativamente pequeno comparado ao\nfator ?1/2 max{?,?}1/2, ent\u00e3o a norma ||| \u00b7 |||? fornece uma contribui\u00e7\u00e3o pequena (PRAE-\nTORIUS; WEINMULLER; WISSGOTT, 2008). Formalmente,\n\n11. An\u00e1logamente para os limites inferiores\n\n\n\n60 Cap\u00edtulo 4. Metodologia\n\n1. Se ||v(x, t)||L?(0,T,L?(?)2) / Cc?\n1\n2 max{?,?}\n\n1\n2 para uma constante Cc de tamanho\n\nmoderado, o regime \u00e9 de dispers\u00e3o dominante. Neste caso, existe uma constante c?\n\ntal que\n\n|||v?(Cn ?Cn?1)|||? ? max{1,c?}cc|||Cn ?Cn?1|||, (4.31)\n\nonde c? \u00e9 a constante da desigualdade de Poincar\u00e9 (VERF\u00dcRTH, 2004).\n\n2. Se o m\u00e1ximo valor do campo de velocidades \u00e9 estritamente maior que a dispers\u00e3o,\nent\u00e3o o regime \u00e9 caracterizado pela advec\u00e7\u00e3o dominante. Formalmente, o regime \u00e9\nde advec\u00e7\u00e3o dominante se\n\n||v(x, t)||L?(0,T,L?(?)2) ? ?\n1\n2 max{?,?}\n\n1\n2 . (4.32)\n\nNesse caso, a inequa\u00e7\u00e3o (4.31) n\u00e3o \u00e9 indicada para a estimativa da norma dual. O\nprocedimento para limita\u00e7\u00e3o da norma dual \u00e9 baseado na solu\u00e7\u00e3o de um problema\nestacion\u00e1rio de rea\u00e7\u00e3o-difus\u00e3o, o qual \u00e9 o caso estacion\u00e1rio da equa\u00e7\u00e3o do transporte\ncom campo de velocidades nulo (VERF\u00dcRTH, 2004).\n\nPara as estimativas adicionais necess\u00e1rias ao regime de advec\u00e7\u00e3o dominante, considera-\nse, para todo 1 ? n ? NI, X?1,0n (T?n) denote o espa\u00e7o de fun\u00e7\u00f5es lineares e cont\u00ednuas\npor partes correspondentes \u00e0 parti\u00e7\u00e3o T?n e tais que s\u00e3o nulas na fronteira de Dirichlet.\nAdicionalmente, considere que C?n \u00e9 a \u00fanica solu\u00e7\u00e3o do problema discreto de rea\u00e7\u00e3o-difus\u00e3o,\ndado por:\n\n?\n?\n\n?\n?C?n \u00b7?wd? + ?\n\n?\n?\nC?nwd? =\n\n?\n?\nvn \u00b7?\n\n(\nCn ?Cn?1\n\n)\nwd? (4.33)\n\npara todo ? ? X?1,0n .\n\nCom essas nota\u00e7\u00f5es, o estimador residual do problema auxiliar \u00e9 dado por:\n(\n??(n)\n\n)2\n=\n?\nK\n\n?2K\n??????vn \u00b7?(Cn ?Cn?1)??C?n??????2\n\nL2(K)\n+\n\n?\nE\n\n??\n1\n2 ?E\n\n??????[n \u00b7?C?n]\nE\n\n??????2\nL2(E)\n\n(4.34)\n\nLogo, existem constantes c?? e c??, as quais dependem somente da raz\u00e3o hK/?K tal\nque:\n\nc??\n{?????????C?nTn????????? + (??(n))} ? ?????????c \u00b7?(CnTn ?Cn?1Tn?1)?????????? ? c??\n\n{?????????C?nTn????????? + (??(n))} (4.35)\n\n\n\n4.3. Estimativas Residuais 61\n\n4.3.5 Estimativas Residuais Gerais\n\nConforme apresentado, o estimador residual envolve diferentes termos. No entanto,\nindependentemente do regime de advec\u00e7\u00e3o, o estimador residual Verf\u00fcrth (2004) pode ser\nescrito como:\n\n(?I) =\n\n??\n??C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n, (4.36)\n\nonde\n(\n?(n)?\n\n)2\n= |||Cn ?Cn?1|||2 para o regime de dispers\u00e3o dominante e\n\n(\n?(n)?\n\n)2\n= |||Cn ?\n\nCn?1|||2 +\n(\n??(n)\n\n)2\n+ |||C?n|||2 para o regime de advec\u00e7\u00e3o dominante.\n\nDa mesma forma o estimador residual de Praetorius, Weinmuller e Wissgott (2008)\npara os regimes de dispers\u00e3o dominante ou advec\u00e7\u00e3o dominante \u00e9 dado por:\n\n(?I) =\n{\n?C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?\n\n(n)\nf\n\n)2\n+\n(\n?\n\n(n)\nN\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n(4.37)\n\n4.3.6 Discuss\u00e3o Adicional sobre as Estimativas Residuais\n\nAs estimativas residuais para os regimes de dispers\u00e3o dominante e advec\u00e7\u00e3o domi-\nnante, que incorporam as estimativas dos erros de representa\u00e7\u00e3o da condi\u00e7\u00e3o inicial, do\ntermo de fonte, das fronteiras de Neumann e as estimativas temporais s\u00e3o consideradas\npara fornecer uma avalia\u00e7\u00e3o da qualidade da solu\u00e7\u00e3o num\u00e9rica obtida. Essas estimativas\nconsideram as diferentes hip\u00f3teses sobre os dados, mas podem ser colocadas em uma \u00fanica\nforma fechada dada por:\n\n(?I) =\n{\n?C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?\n\n(n)\nf\n\n)2\n+\n(\n?\n\n(n)\nN\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n, (4.38)\n\nonde (?(n)f )2 = (?\n(n)\nN )2 = 0 para o estimador residual de Verf\u00fcrth. Caso, as hip\u00f3teses para\n\no estimador residual de Praetorius, Weinmuller e Wissgott (2008) sejam satisfeitas, ent\u00e3o\nas quantidades (?(n)f )2 e (?\n\n(n)\nN )2 devem ser consideradas.\n\nConsiderando o estimador residual de Verf\u00fcrth (2004), dados constantes e regime de\ndispers\u00e3o dominante, a equa\u00e7\u00e3o (4.38) \u00e9 dada por:\n\n\n\n62 Cap\u00edtulo 4. Metodologia\n\n(?I) =\n\n??\n?\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n=\n\n??\n?\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+ |||Cn ?Cn?1|||2\n\n]??\n?\n\n1/2\n\n. (4.39)\n\nPor sua vez, o estimador dado por (4.39) \u00e9 mais acurado que o estimador proposto\npor Firmiano (2010) no sentido que a estimativa espacial incorpora todos os termos.\nFormalmente, as estimativas aqui implementadas s\u00e3o tais que:\n\n{?\nK\n\n?2K||RK||\n2\nL2(K) +\n\n?\nE\n\n??\n1\n2 ?E||RE||2L2(E)\n\n}1/2\n>\n\n{?\nK\n\n?2K||RK||\n2\nL2(K)\n\n}1/2\n(4.40)\n\nem que o lado direito \u00e9 o estimador proposto por Firmiano (2010).\n\nPor sua vez, o estimador de Praetorius, Weinmuller e Wissgott (2008) \u00e9 mais geral\nque o estimador de Verf\u00fcrth (2004) no sentido que incorpora estimativas adicionais para\no termo de fonte, a fronteira de Neumann e o tempo. Essas estimativas adicionais s\u00e3o\nincorporadas por meio de uma conveniente parti\u00e7\u00e3o das estimativas residuais.\n\nConsidere agora que os dados da equa\u00e7\u00e3o possuem apenas depend\u00eancia espacial e\nque a fun\u00e7\u00e3o g seja definida implicitamente pela forma bilinear. Logo, (?N )\n\nn = 0 e\n\n?? = |||Cn ?Cn?1||| + |||v \u00b7?(Cn ?Cn?1)|||?. (4.41)\n\nA primeira igualdade \u00e9 devida \u00e0 representa\u00e7\u00e3o da condi\u00e7\u00e3o de Neumann no espa\u00e7o\nde elementos finitos 12 enquanto que a segunda \u00e9 devida \u00e0 depend\u00eancia apenas espacial\ndos dados.\n\nA pr\u00f3xima se\u00e7\u00e3o considera apenas o estimador residual de Verf\u00fcrth (2004) para os\nregimes dispers\u00e3o dominante e advec\u00e7\u00e3o dominante. O estimador residual de Praetorius,\nWeinmuller e Wissgott (2008) difere apenas pela presen\u00e7a das estimativas ?f, ?N e a\nestimativa temporal.\n\n4.3.6.1 Parti\u00e7\u00e3o do Estimador Residual\n\nA metologia aqui apresentada \u00e9 baseada em Praetorius, Weinmuller e Wissgott (2008)\nenquanto que os c\u00f3digos s\u00e3o baseados em Fenics Project (2014).\n\nUsando as ferramentas dispon\u00edveis, a aproxima\u00e7\u00e3o em elementos finitos para a\nequa\u00e7\u00e3o do transporte de contaminantes \u00e9 implementada diretamente atrav\u00e9s das formas\nbilinear e linear. A solu\u00e7\u00e3o do sistema linear Ax = b \u00e9 calculada numericamente atrav\u00e9s de\n\n12. Como a condi\u00e7\u00e3o de Neumann \u00e9 definida implicitamente, ent\u00e3o \u00e9 representada no espa\u00e7o de\nelementos finitos. Logo, n\u00e3o existem erros associados \u00e0 representa\u00e7\u00e3o.\n\n\n\n4.3. Estimativas Residuais 63\n\nalgum m\u00e9todo iterativo ou direto. Em seguida, o estimador espacial pode ser calculado 13\n\natrav\u00e9s da somat\u00f3ria de todas as contribui\u00e7\u00f5es dos elementos, saltos e fronteiras, ou seja:\n\n(\n?(n)\n\n)2\n=\n?\nK\n\n?2K||RK||\n2\nL2(K)? ?? ?\n\n?n\nK\n\n+\n?\nE*?\n\n??\n1\n2 ?E||RE||2L2(E)\n\n? ?? ?\n?n\nE\n\n+\n?\nE??N\n\n??\n1\n2 ?E||RE||2L2(E)? ?? ?\n?n\nB\n\n(4.42)\n\nonde as componentes ?nK, ?nE, ?nB ser\u00e3o chamadas, respectivamente: contribui\u00e7\u00f5es dos\nelementos, saltos, fronteiras para o n-\u00e9simo passo de tempo. Analogamente, o residual dos\ndados pode ser calculado por:\n\n(\n?(n)\n\n)2\n=\n?\nK\n\n?2K||DK||\n2\nL2(K)? ?? ?\n\nDn\nK\n\n+\n?\nE\n\n??\n1\n2 ?E||DE||2L2(E)? ?? ?\n\nDn\nE\n\n, (4.43)\n\nonde DnK e DnE s\u00e3o as contribui\u00e7\u00f5es dos elementos e dos saltos para os dados, respectiva-\nmente. Em cada passo de tempo, a contribui\u00e7\u00e3o residual total \u00e9 composta das contribui\u00e7\u00f5es\nespaciais e das contribui\u00e7\u00f5es temporais. Logo, a contribui\u00e7\u00e3o em cada passo pode ser\nreescrita como(\nEnstep\n\n)2\n=\n(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?(n)?\n\n)2\n. (4.44)\n\nCom as nota\u00e7\u00f5es acima, o res\u00edduo pode ser reescrito como:\n\n??I =\n\n??\n?||C0 ??0C0||2L(?) +\n\nNI?\nn=1\n\n?n(Enstep)\n2\n\n??\n?\n\n1\n2\n\n. (4.45)\n\nNo caso de advec\u00e7\u00e3o dominante, o problema auxiliar \u00e9 resolvido utilizando a mesma\nmetodologia aplicada ao problema do transporte. Nesse caso, as formas para os c\u00e1lculos\nde (?n?n)\n\n2 e para o problema auxiliar precisam ser somadas.\n\nA parti\u00e7\u00e3o das estimativas residuais permite que as contribui\u00e7\u00f5es sejam comparadas\ne esses resultados favorecem o entendimento do comportamento das componentes do\nestimador residual. As quantidades RnJump/Estep, R\n\nn\nJump/Elemen, (?\n\nn\n? )\n\n(2) definidas por:\n\nRnJump/Element =\n\n?\nE*?\n\n??\n1\n2 ?E||RE||2L2(E)\n\n?\nK\n\n?2K||RK||\n2\nL2(K)\n\n, RnJump/Estep =\n\n?\nE*?\n\n??\n1\n2 ?E||RE||2L2(E)\n(\nEnstep\n\n)2 , (4.46)\n13. Aqui o autor refere-se \u00e0 implementa\u00e7\u00e3o do c\u00f3digo computacional\n\n\n\n64 Cap\u00edtulo 4. Metodologia\n\nfornecem rela\u00e7\u00f5es entre as componentes residuais. A rela\u00e7\u00e3o RnJump/Element compara a\nmagnitude dos saltos e dos elementos, a rela\u00e7\u00e3o RnJump/Estep compara as contribui\u00e7\u00f5es dos\nsaltos com as contribui\u00e7\u00f5es obtidas em cada passo enquanto que ?n? expressa o res\u00edduo\ntemporal. A utiliza\u00e7\u00e3o destas rela\u00e7\u00f5es para comparar as magnitudes das estimativas\nresiduais s\u00e3o apresentadas em Santos, Firmiano e Wendland (2014), Santos, Firmiano\ne Wendland (b), Santos, Firmiano e Wendland (a). Outros resultados s\u00e3o apresentados\nem Firmiano et al. (2013), Firmiano, Santos e Wendland (2013), Firmiano et al. (2012),\nFirmiano, Wendland e Santos (2012).\n\n4.3.7 Contribui\u00e7\u00f5es Residuais de cada elemento da malha\n\nO estimador residual apresentado \u00e9 composto de quantidades locais que, quando\nsomadas, produzem a quantidade global(sobre toda a malha). No entanto, as quantidades\nlocais podem ser definidas e calculadas da mesma forma que as quantidades globais. Essas\nquantidades locais s\u00e3o importantes para a formula\u00e7\u00e3o de estrat\u00e9gias adaptativas.\n\nDa mesma forma que\n\n(\n?(n)\n\n)2\n=\n?\nK\n\n?2K||RK||\n2\nL2(K)? ?? ?\n\n?n\nK\n\n+\n?\nE*?\n\n??\n1\n2 ?E||RE||2L2(E)\n\n? ?? ?\n?n\nE\n\n+\n?\nE??N\n\n??\n1\n2 ?E||RE||2L2(E)? ?? ?\n?n\nB\n\n(4.47)\n\ndefine-se a contribui\u00e7\u00e3o local para o elemento K, ?K, como a soma das contribui\u00e7\u00f5es do\nelemento, do salto e fronteira em cada elemento. Formalmente, para um dado elemento K,\na contribui\u00e7\u00e3o local \u00e9 dada por:\n\n?2K = ?\n2\nK||RK||\n\n2\nL2(K)? ?? ?\n\nK\n\n+ ??\n1\n2 ?E||RE||2L2(E)? ?? ?\n\nE*?\n\n+ ??\n1\n2 ?E||RE||2L2(E)? ?? ?\n\nE??N\n\n:= ?21K + ?22E + ?23B\n\n(4.48)\n\nonde ?21K = ?2K||RK||2L2(K), ?\n2\n2E = ??\n\n1\n2 ?E||RE||2L2(E) e ?\n\n2\n3B = ??\n\n1\n2 ?E||RE||2L2(E). Os valores\n\n?2K, ?21K,?22E,?23B ser\u00e3o chamados contribui\u00e7\u00f5es do elemento, do salto e da fronteira, respec-\ntivamente, para o elemento K. Essas quantidades possibilitam o c\u00e1lculo das contribui\u00e7\u00f5es\nm\u00e1ximas:\n\ni. A contribui\u00e7\u00e3o m\u00e1xima dos elementos ?21K,max:\n\n?21K,max = max\nK\n\n?21K (4.49)\n\n\n\n4.3. Estimativas Residuais 65\n\nii. A contribui\u00e7\u00e3o m\u00e1xima dos saltos ?22E,max:\n\n?22E,max = max\nE*?N\n\n?22E (4.50)\n\niii. A contribui\u00e7\u00e3o m\u00e1xima das fronteiras ?23B,max:\n\n?23B,max = max\nE??N\n\n?23B (4.51)\n\niv. A contribui\u00e7\u00e3o m\u00e1xima espacial ?2N,max:\n\n?2K,max = max\nK\n\n?2K (4.52)\n\nAnalogamente, considere\n\n(\n?(n)\n\n)2\n=\n?\nK\n\n?2K||DK||\n2\nL2(K)? ?? ?\n\nDn\nK\n\n+\n?\nE\n\n??\n1\n2 ?E||DE||2L2(E)? ?? ?\n\nDn\nE\n\n. (4.53)\n\nLogo, as quantidades locais referentes aos residuais dos dados podem ser calculados por:\n\n?2K = ?\n2\nK||DK||\n\n2\nL2(K) + ?\n\n?12 ?E||DE||2L2(E) = ?\n2\n1K + ?\n\n2\n2E. (4.54)\n\nDesta forma, as quantidades m\u00e1ximas para os dados podem ser definidas por:\n\nv. A contribui\u00e7\u00e3o m\u00e1xima dos dados para os elementos ?21K,max:\n\n?21K,max = max\nK\n\n?21K ? (4.55)\n\nvi. A contribui\u00e7\u00e3o m\u00e1xima dos dados para os elementos ?22E,max:\n\n?22E,max = max\nE*?N\n\n?22E (4.56)\n\nvii. A contribui\u00e7\u00e3o m\u00e1xima dos dados para os elementos ?2K,max:\n\n?2K,max = max\nK\n\n?2K (4.57)\n\n.\n\nOutras quantidades de interesse s\u00e3o os indicadores locais, os quais s\u00e3o utilizados\nnas estrat\u00e9gias adaptativas. Os indicadores locais s\u00e3o obtidos das quantidades locais\ni-vii, e dados pela express\u00e3o IndicadorLocal = (QuantidadeLocal)1/2 (PRAETORIUS;\nWEINMULLER; WISSGOTT, 2008).\n\n\n\n66 Cap\u00edtulo 4. Metodologia\n\n4.4 Adaptatividade\n\nAqui, a adaptatividade refere-se \u00e0 utiliza\u00e7\u00e3o do estimador residual para controlar o\nerro espacial e temporal da malha de elementos finitos, enquanto que a adaptatividade\ndos dados refere-se ao adequado controle dos erros associados aos dados. Nesse caso, a\nadaptatividade pode ser dividida entre: a adaptatividade da condi\u00e7\u00e3o inicial, das dispers\u00f5es,\ndo campo de velocidades e da fun\u00e7\u00e3o de fonte.\n\nA metodologia apresentada engloba esquemas adaptativos para a condi\u00e7\u00e3o inicial e\no termo de fonte. A proposta \u00e9 baseada nas componentes do estimador residual e no fato\nde que a geometria e os dados devem ser adequadamente representados.\n\n4.4.1 Limita\u00e7\u00e3o do Erro ??I\n\nConsidere o estimador residual ??I, o termo ?1/2n ?n pode ser considerado como indicador\ndo erro espacial local e o termo ?n(?(n)? )1/2 pode ser considerado o indicador de erro temporal\nlocal (VERF\u00dcRTH, 2014).\n\nConsidere que\n\nEstep2i = ?n\n[(\n?(n)\n\n)2\n+ (?(n))2 + (?n? )\n\n2\n]\n\n(4.58)\n\n\u00e9 o erro em cada passo de tempo ?n. Logo, para uma dada toler\u00e2ncia ?1, se ?n\n[\n(?n)2 + (?(n))2\n\n]\n<\n\n?21/2 e ?n(?(n)? )2 &lt;?21/2, ent\u00e3o Estep2i = ?n\n[\n(?n)2 + (?(n))2 + (?n? )2\n\n]\n&lt;?21. Portanto, o erro\n\nglobal ser\u00e1 dado por\n\n??I&lt;\n\n?\n?NI?\ni=1\n\n?21\n\n?\n?1/2 = ?1?NI (4.59)\n\nconsiderando que ||C0 ??0C0||2L2(?) = 0. Caso ||C0 ??0C0||\n2\nL2(?) 6= 0, mas a representa\u00e7\u00e3o\n\nda condi\u00e7\u00e3o inicial \u00e9 tal que ||C0 ??0C0||2L2(?) &lt;?\n2, ent\u00e3o o erro global ser\u00e1 dado por\n\n??I&lt;\n\n?\n??2 + NI?\n\ni=1\n?21\n\n?\n?1/2 6 max(?,?1) \u00b7?NI + 1 ? max(?,?1) \u00b7?NI, para NI >> 1 (4.60)\n\nAnalogamente, suponha que as condi\u00e7\u00f5es P1-P4* sejam satisfeitas. Logo, as estima-\ntivas residuais incorporam as estimativas para o termo de fonte 14. Nesse caso, se ?2f &lt;?2f,\n\n14. O termo referente \u00e0 fronteira de Neumann \u00e9 nulo devido \u00e0s hip\u00f3teses adotadas para o m\u00e9todo de\nelementos finitos.\n\n\n\n4.4. Adaptatividade 67\n\nent\u00e3o\n\nEstep2i = ?n\n[(\n?(n)\n\n)2\n+ (?(n))2 + (?(n)f )\n\n2 + (?n? )\n2\n]\n6 ?21 + ?\n\n2\nf. (4.61)\n\nComo consequ\u00eancia,\n\n??I&lt;\n\n?\n??2 + NI?\n\ni=1\n\n(\n?21 + ?\n\n2\nf\n\n)??1/2 6 max(?,?1, ?f ) \u00b7?NI + 1 (4.62)\nEssas estimativas sugerem que o algoritmo adaptativo geral, proposto em Verf\u00fcrth\n\n(2014), pode ser modificado para incorporar um procedimento adaptativo para a constru\u00e7\u00e3o\nde uma malha de elementos finitos que represente adequadamente a condi\u00e7\u00e3o inicial e o\ntermo de fonte 15.\n\nO algoritmo adaptativo geral, proposto por Verf\u00fcrth (2014), possui a seguinte forma:\n\nALGORITMO ADAPTATIVO GERAL\n1.Considere que s\u00e3o fornecidos os dados iniciais de uma equa\u00e7\u00e3o diferencial parcial\n\ne uma toler\u00e2ncia, deseja-se encontrar uma solu\u00e7\u00e3o num\u00e9rica com um erro\nmenor que a toler\u00e2ncia dada;\n\n2.Construa uma malha inicial T0 representando suficientemente bem a geometria\ne os dados do problema;\n\n3. Resolva o problema discreto para a malha Tn, para n = 0;\n4.Para todo elemento K ? Tk calcule a estimativa a posteriori;\n5. Se o erro estimado \u00e9 menor que a toler\u00e2ncia, ent\u00e3o pare. Caso contr\u00e1rio, decida\n\nquais elementos devem ser refinados e construa a pr\u00f3xima malha Tk+1. Fa\u00e7a\nk ? k + 1 e retorne ao passo (2).\n\nNeste trabalho, o processo de refinamento adaptativo 16 \u00e9 governado pela estrat\u00e9gia\ndo m\u00e1ximo (VERF\u00dcRTH, 2014):\n\nESTRAT\u00c9GIA DO M\u00c1XIMO\n1. Dado: uma parti\u00e7\u00e3o T, um indicador do error ?K para um elemento na malha de\n\nelementos finitos , e uma fra\u00e7\u00e3o ?1 ? (0, 1). Encontrar um subconjunto T?\nde elementos que precisam ser refinados;\n\n2. Calcule ?K,max = max\nK\n\n?K;\n3.Se ?K > ?1?T,max marque o elemento K para refinamento e adicione-o ao conjunto\n\nT?;\n4. Refine todos os elementos na malha de elementos finitos.\n\n15. A representa\u00e7\u00e3o adequada da geometria n\u00e3o \u00e9 discutida aqui.\n16. referente \u00e0 constru\u00e7\u00e3o da malha adequada aos dados\n\n\n\n68 Cap\u00edtulo 4. Metodologia\n\nO ponto de partida para as pr\u00f3ximas se\u00e7\u00f5es \u00e9 o item 2. do algoritmo adaptativo\ngeral apresentado, pois a constru\u00e7\u00e3o da malha inicial T0 n\u00e3o \u00e9 descrita. No entanto, existe\na premissa de que os dados e a geometria s\u00e3o adequadamente representados, ou seja, a\ncondi\u00e7\u00f5es iniciais e de fronteira, o termo de fonte, o campo de velocidades, as dispers\u00f5es e\na fun\u00e7\u00e3o que descreve as rea\u00e7\u00f5es do meio s\u00e3o representadas adequadamente.\n\n4.4.2 Adaptatividade da Condi\u00e7\u00e3o Inicial\n\nSuponha que o erro de representa\u00e7\u00e3o da condi\u00e7\u00e3o inicial, dado por ||C0 ??0C0||2L2(?)\n\u00e9 n\u00e3o nulo e que a condi\u00e7\u00e3o inicial \u00e9 n\u00e3o constante. Neste caso, \u00e9 necess\u00e1rio que a condi\u00e7\u00e3o\ninicial seja adequadamente representada no espa\u00e7o de elementos finitos, ou seja, \u00e9 necess\u00e1rio\nobter um malha tal que ||C0 ? ?0C0||2L2(?) &lt;?\n\n2\n1, em que ?1 \u00e9 uma toler\u00e2ncia e ?C0 \u00e9 a\n\nproje\u00e7\u00e3o L2 no espa\u00e7o de elementos finitos.\n\nGlobalmente, a estimativa do erro para a condi\u00e7\u00e3o inicial \u00e9 definida por:\n\n||C0 ??0C0||2L2(?) =\n?\nK\n\n||C0 ??C0||2L2(K), (4.63)\n\na qual avalia a qualidade da representa\u00e7\u00e3o da express\u00e3o C0 na malha de elementos finitos 17.\nLocalmente, a contribui\u00e7\u00e3o de um elemento K e o respectivo indicador do erro para a\ncondi\u00e7\u00e3o inicial s\u00e3o dados por:\n\n?2K,C0 = ||C0 ??0C0||\n2\nL2(K), ?K,C0 = ||C0 ??0C0||L2(K), (4.64)\n\nSeja NT o n\u00famero de elementos na malha inicial T ?0, fornecida pelo usu\u00e1rio antes\ndo processo de simula\u00e7\u00e3o, e considere que o elemento N possui o maior erro local de\nrepresenta\u00e7\u00e3o, ou seja, ?C0,max = max\n\nK\n{?K,C0}. Logo, dada uma malha inicial T ?0, uma\n\ntoler\u00e2ncia ?C0 e uma fra\u00e7\u00e3o fracC0, o elemento K ser\u00e1 marcado para refinamento, de\nacordo com a estrat\u00e9gia do m\u00e1ximo, se ?K,C0 > fracC0 \u00b7?Kf,max. Com essas nota\u00e7\u00f5es, o\nalgoritmo adaptativo para a condi\u00e7\u00e3o inicial \u00e9 dado por:\n\nALGORITMO ADAPTATIVO PARA A CONDI\u00c7\u00c3O INICIAL\n1. Dado uma malha inicial T ?0 fornecida pelo usu\u00e1rio, uma fra\u00e7\u00e3o fracC0,\n\ntoler\u00e2ncia ?C0, a express\u00e3o anal\u00edtica para a condi\u00e7\u00e3o inicial, obter uma\nrepresenta\u00e7\u00e3o adequada da fun\u00e7\u00e3o C0;\n\n2. Se ||C0 ??0C0||2L2(?) &lt;?C0, ent\u00e3o pare;\n3. Sen\u00e3o, calcule a estimativa ||Cp0 ? C\n\np+k\n0 ||2L2(?), em que C\n\np\n0 e C\n\np+k\n0 s\u00e3o\n\n17. O problema da representa\u00e7\u00e3o anal\u00edtica de uma express\u00e3o \u00e9 discutida na se\u00e7\u00e3o [4.5]\n\n\n\n4.4. Adaptatividade 69\n\nrepresenta\u00e7\u00f5es da condi\u00e7\u00e3o inicial que usam fun\u00e7\u00f5es lagrangeanas de ordens\np e p + k, respectivamente;\n\n4. Se ||Cp0 ? C\np+k\n0 ||2L2(?) &lt;?C0, ent\u00e3o pare. Sen\u00e3o, calcule os indicadores locais\n\n?K,C0;\n5. Se ?K,C0 > fracC0?KC0,max, ent\u00e3o marque o elemento K para refinamento\n5. Refine todos os elementos marcados. Volte ao item 4.\n\nEsse procedimento \u00e9 similar ao algoritmo adaptativo geral e pode ser utilizado para\nos outros dados do problema tais como as componentes do campos de velocidades, a\ncondi\u00e7\u00e3o inicial, as dispers\u00f5es e o termo reativo.\n\n4.4.3 Adaptatividade da fun\u00e7\u00e3o de fonte\n\nSuponha que o erro de representa\u00e7\u00e3o do termo de fonte ?f \u00e9 n\u00e3o nulo. A representa\u00e7\u00e3o\nadequada deve ser utilizada para a solu\u00e7\u00e3o da equa\u00e7\u00e3o do transporte de contaminantes, pois\nos erros de representa\u00e7\u00e3o da fun\u00e7\u00e3o f s\u00e3o inseridos nas estimativas residuais e propagados\ndurante o processo de simula\u00e7\u00e3o.\n\nNesta parte, o estimador residual referente \u00e0s estimativas de Praetorius, Weinmuller\ne Wissgott (2008) \u00e9 utilizado para obter uma malha inicial, adequada ao processo de\nsimula\u00e7\u00e3o, a partir de uma malha inicial fornecida pelo usu\u00e1rio.\n\nGlobalmente, a estimativa residual associada ao termo de fonte, denotado por\n(\n?\n\n(n)\nf\n\n)\n,\n\n\u00e9 dada por:\n\n?\n(n)\nf =\n\n{?\nK\n\n?2K\n[\n?2||f(tn) ?f\n\n(n)\nh ||\n\n2\nK + (1 ??)\n\n2||f(tn?1) ?f\n(n?1)\nh ||\n\n2\nK\n\n]}1/2\n. (4.65)\n\nonde fh := ?f(n) denota a proje\u00e7\u00e3o L2 no espa\u00e7o de elementos finitos, fh = ?f(n) +\n(1 ??)f(n?1) e n = {1, 2 \u00b7 \u00b7 \u00b7 ,NI}.\n\nEssa quantidade \u00e9 utilizada para obter uma malha que representa adequadamente a\nfun\u00e7\u00e3o f para um determinado passo de tempo ?n. Localmente, o indicador dado por\n\n?Kf =\n{\n?2K\n\n[\n?2||f(tn) ?f\n\n(n)\nh ||\n\n2\nK + (1 ??)\n\n2||f(tn?1) ?f\n(n?1)\nh ||\n\n2\nE\n\n]}1/2\n, (4.66)\n\navalia a qualidade da representa\u00e7\u00e3o da fun\u00e7\u00e3o f na malha de elementos finitos dada.\n\nConsidere que NT \u00e9 o n\u00famero de elementos na malha de elementos finitos, que o\nelemento N possui o maior erro local de representa\u00e7\u00e3o da fun\u00e7\u00e3o f, ou seja, ?Kf,max =\nmax{?Nf}. Logo, dado uma malha inicial T0, o passo de tempo ?n, uma toler\u00e2ncia ?f e um\n\n\n\n70 Cap\u00edtulo 4. Metodologia\n\npar\u00e2metro fracfonte ? (0, 1), o elemento K ser\u00e1 marcado para refinamento, de acordo com\na estrat\u00e9gia do m\u00e1ximo, se ?Kf > fracfonte \u00b7?Kf,max. Dessa forma o algoritmo adaptativo\npara o termo de fonte \u00e9 dado por:\n\nALGORITMO ADAPTATIVO PARA A FUN\u00c7\u00c3O DE FONTE f\n1. Dado uma malha inicial T0 fornecida pelo usu\u00e1rio, uma fra\u00e7\u00e3o fracfonte,\n\ntoler\u00e2ncia ?f, a express\u00e3o anal\u00edtica da fun\u00e7\u00e3o f e os valores das constantes ?,?\nenvolvidas no estimador de erros, obter uma representa\u00e7\u00e3o adequada de f;\n\n2. Calcule a estimativa global ?nf , utilizando fun\u00e7\u00f5es lagrangeanas de ordens p e p + k;\n3. Se ?nf 6 ?f, ent\u00e3o pare. Sen\u00e3o, calcule os indicadores locais ?Kf;\n4. Se ?Kf > fracfonte?Kf,max, ent\u00e3o marque o elemento K para refinamento;\n5. Refine todos os elementos marcados. Volte ao item 2.\n\nA utiliza\u00e7\u00e3o desta fun\u00e7\u00e3o exige a avalia\u00e7\u00e3o de f em um espa\u00e7o de ordem superior\nou com malha refinada. Ambos os procedimentos incluem um significativo esfor\u00e7o com-\nputacional, pois elevam o n\u00famero de vari\u00e1veis no sistema linear associado. No entanto, a\nutiliza\u00e7\u00e3o de malha adequada pode garantir a qualidade do resultado e, ainda, reduzir o\nesfor\u00e7o computacional.\n\n4.5 Proje\u00e7\u00e3o L2 e c\u00e1lculo das constantes ? e ?\n\nA proje\u00e7\u00e3o L2 de uma fun\u00e7\u00e3o f e as constantes ? e ? est\u00e3o estritamente relacionadas\n\u00e0 obten\u00e7\u00e3o das estimativas residuais. A metologia de c\u00e1lculo da proje\u00e7\u00e3o L2 \u00e9 descrita em\nLarson (2010), enquanto que a metodologia de c\u00e1lculo das constantes ? e ? \u00e9 baseada no\nSciPy (JONES et al., 2001).\n\n4.5.1 Proje\u00e7\u00e3o L2\n\nSegundo Larson (2010), a interpola\u00e7\u00e3o \u00e9 a maneira mais simples de aproximar fun\u00e7\u00f5es\ncont\u00ednuas, mas existem outras formas. Nesta parte a proje\u00e7\u00e3o L2 ou proje\u00e7\u00e3o ortogonal \u00e9\napresentada seguindo estritamente o ponto de vista de Larson (2010).\n\nDefini\u00e7\u00e3o: Para uma dada fun\u00e7\u00e3o f ? L2, a proje\u00e7\u00e3o L2 de f, denotada por ?hf \u00e9\ndefinida por?\n\n?\n(f ??hf)vdx = 0,?v ? Vh. (4.67)\n\nonde Vh \u00e9 o espa\u00e7o de elementos finitos.\n\nPara calcular a proje\u00e7\u00e3o L2, ?hf, deve-se notar que a defini\u00e7\u00e3o acima \u00e9 equivalente\na?\n\n?\n(f ??hf)?id? = 0, i = 0, 1, 2, 3, ...,n (4.68)\n\n\n\n4.5. Proje\u00e7\u00e3o L2 e c\u00e1lculo das constantes ? e ? 71\n\nonde ?i \u00e9 uma base para o espa\u00e7o Vh. Isso \u00e9 consequ\u00eancia do fato de que a equa\u00e7\u00e3o (4.67) \u00e9\nsatisfeita para todo v ? Vh. Logo, deve ser satisfeita para uma combina\u00e7\u00e3o linear qualquer\ndestas fun\u00e7\u00f5es, e reciprocamente, desde que qualquer fun\u00e7\u00e3o v ? Vh \u00e9 uma combina\u00e7\u00e3o\nlinear das fun\u00e7\u00f5es ?i, ent\u00e3o (4.67) implica (4.68) (LARSON, 2010).\n\nA estimativa do erro de aproxima\u00e7\u00e3o utiliza a representa\u00e7\u00e3o da fun\u00e7\u00e3o aproximada\nem uma malha refinada com espa\u00e7o de elementos finitos com fun\u00e7\u00f5es de ordem mais\nelevada. Essa metodologia de representa\u00e7\u00e3o e c\u00e1lculos de erros \u00e9 apresentada em Fenics\nProject (2014).\n\n4.5.2 C\u00e1lculo das constante ? e ?\n\nA metodologia de c\u00e1lculo dessas constantes baseia-se em conceitos de \u00c1lgebra Linear\ne em um procedimento de minimiza\u00e7\u00e3o de fun\u00e7\u00f5es em dom\u00ednios fechados. \u00c9 importante\nressaltar que esse tamb\u00e9m \u00e9 um ponto importante do trabalho e pode servir de base para\nc\u00e1lculos mais elaborados e problemas com depend\u00eancia temporal 18.\n\nAs constantes a serem determinadas s\u00e3o aquelas relacionadas na hip\u00f3teses do esti-\nmador residual (P1) e (P3). Para o c\u00e1lculo da constantes ? e ? o c\u00e1lculo de autovalores da\nmatriz de dispers\u00e3o \u00e9 utilizado. Nesse caso, o problema \u00e9 reduzido \u00e0 m\u00ednimos de fun\u00e7\u00f5es\nde duas vari\u00e1veis por meio de algumas considera\u00e7\u00f5es. Por outro lado, a constante ? \u00e9\navaliada diretamente por meio de um procedimento num\u00e9rico.\n\n4.5.2.1 ? atrav\u00e9s do c\u00e1lculo de autovalores\n\nConsidere que as componentes da matriz de dispers\u00e3o D possuem depend\u00eancia\nespacial e s\u00e3o dadas por dxx(x,y), dxy(x,y), dyx(x,y) e dyy(x,y) em um dom\u00ednio ? ? R2.\nLogo, para um ponto (x0,y0) ? ?, os autovalores associados D(x0,y0, t) = D(x0,y0) s\u00e3o\ncalculados atrav\u00e9s da equa\u00e7\u00e3o caracter\u00edstica 19:\n\n?2?(dxx(x0,y0)+dyy(x0,y0))?+(dxx(x0,y0)dyy(x0,y0)?dxy(x0,y0)dyx(x0,y0)) = 0. (4.69)\n\nResumidamente, a equa\u00e7\u00e3o (4.69) pode ser dada por:\n\n?2 ?Tr(D)? + det(D) = 0.0, (4.70)\n\nonde Tr(D) = Tr(D(x0,y0)) e det(D) = det(D(x0,y0)) s\u00e3o, respectivamente, o tra\u00e7o e o\ndeterminante da matriz D no ponto (x0,y0).\n\n18. Uma sugest\u00e3o para os c\u00e1lculos envolvendo problemas com depend\u00eancia temporal \u00e9 apresentada\nna se\u00e7\u00e3o [6.1]\n\n19. det(?I ?D) = 0\n\n\n\n72 Cap\u00edtulo 4. Metodologia\n\nAs ra\u00edzes da equa\u00e7\u00e3o (4.69) s\u00e3o:\n\n?1 =\nTr(D) ?\n\n?\nTr(D)2 ? 4Det(D)\n\n2\n, ?2 =\n\nTr(D) +\n?\nTr(D)2 ? 4Det(D)\n\n2\n. (4.71)\n\nonde ?1,?2 s\u00e3o, respectivamente, o menor e maior autovalores de D em (x0,y0) ? ?.\n\nComo (x0,y0) ? ? \u00e9 um ponto gen\u00e9rico no dom\u00ednio, ?1 e ?2 podem ser consideradas\nfun\u00e7\u00f5es de duas vari\u00e1veis em um dom\u00ednio ?. O valor ? \u00e9 o ponto de m\u00ednimo de ?1, enquanto\nque ? \u00e9 o valor m\u00e1ximo de ?2.\n\nComputacionalmente, esses c\u00e1lculos requerem uma discretiza\u00e7\u00e3o do dom\u00ednio com-\nputacional a qual pode n\u00e3o fornecer o valor adequado de ? e ?. Nesse caso, o autor considera\no seguinte procedimento:\n\n1. Considere duas discretiza\u00e7\u00f5es ?h e ?h/2 do dom\u00ednio computacional ?. Essas discretiza-\n\u00e7\u00f5es s\u00e3o constitu\u00eddas de pontos igualmente espa\u00e7ados nas dire\u00e7\u00f5es coordenadas 20.\nAs figuras (7-a, b) ilustram o procedimento de constru\u00e7\u00e3o das malhas de pontos ?h\n\ne ?h/2;\n\n(a) Malha de pontos ?h (b) Malha de pontos ?h/2\n\nFigura 7 \u2013 Duas malhas de pontos igualmente espa\u00e7ados nas dire\u00e7\u00f5es coordenadas\n\n2. Calcule os valores ?h,?h e ?h/2,?h/2;\n3. Se ?h = ?h/2 e ?h = ?h/2 ent\u00e3o ? = ?h e ? = ?h;\n4. Sen\u00e3o, considere a discretiza\u00e7\u00e3o ?h/4 e repita o processo.\n\n4.5.2.2 C\u00e1lculo da Constante ?\n\nSuponha que ? = ?(x,y) e vx e vy s\u00e3o fun\u00e7\u00f5es cont\u00ednuas para o campo de velocidades.\nDefinindo ? := inf\n\n(x,y)??,0<t6T\n(?? (1/2)div(v)), ent\u00e3o ? \u00e9 tal que ?? (1/2)div(v) > ?.\n\n20. Aqui apenas pontos s\u00e3o considerados para os c\u00e1lculos. Esse procedimento produz uma malha de\npontos similar ao esquema de diferen\u00e7as finitas\n\n\n\n4.6. AMG com Reutiliza\u00e7\u00e3o de estruturas 73\n\nAqui, algumas observa\u00e7\u00f5es s\u00e3o necess\u00e1rias:\n\n1. Se o campo de velocidades \u00e9 constante nas dire\u00e7\u00f5es, ent\u00e3o div(v) = 0. Logo, o c\u00e1lculo\nde ? \u00e9 simplificado;\n\n2. Se o campo de velocidades n\u00e3o \u00e9 constante nas dire\u00e7\u00f5es e foi obtido da solu\u00e7\u00e3o da\nequa\u00e7\u00e3o do fluxo, ent\u00e3o \u00e9 necess\u00e1rio transform\u00e1-lo em um campo cont\u00ednuo antes de\nefetuar o c\u00e1lculo do divergente;\n\n3. O problema do item [2] \u00e9 resolvido seguindo a metodologia descrita em Fenics Project\n(2014) ou pode ser executado por projectGradient(kargs**) 21.\n\nAs pr\u00f3ximas se\u00e7\u00f5es tratam do processo de reutiliza\u00e7\u00e3o das estruturas hier\u00e1rquicas\ndos m\u00e9todos multigrid alg\u00e9bricos para acelerar o processo de solu\u00e7\u00e3o de sistemas lineares.\n\n4.6 AMG com Reutiliza\u00e7\u00e3o de estruturas\n\nEsta parte considera a solu\u00e7\u00e3o da equa\u00e7\u00e3o do transporte de contaminantes em meio\nporoso saturado atrav\u00e9s de um m\u00e9todo multigrid alg\u00e9brico com reutiliza\u00e7\u00e3o das estruturas\nde agrega\u00e7\u00e3o e operadores de transfer\u00eancia de resultados. Essa proposta \u00e9 baseada nas\nseguintes observa\u00e7\u00f5es e considera\u00e7\u00f5es:\n\n1. Como apontado em Notay (2012), para problemas sim\u00e9tricos, provenientes de\nequa\u00e7\u00f5es el\u00edpticas, existem v\u00e1rias abordagens que conduzem a m\u00e9todos eficientes\nde solu\u00e7\u00e3o do sistema linear Ax = b. Entretanto, para problemas n\u00e3o sim\u00e9tricos,\nobtidos da equa\u00e7\u00e3o de advec\u00e7\u00e3o-difus\u00e3o ? 4u + v \u00b7?u = f, apenas os resultados de\nBrezina et al. (2010) e Wu, Howard e Elman (2004) s\u00e3o encontrados.\n\n2. Problemas n\u00e3o sim\u00e9tricos est\u00e3o associados a solu\u00e7\u00e3o de equa\u00e7\u00f5es diferenciais parciais\nde advec\u00e7\u00e3o-difus\u00e3o (estado estacion\u00e1rio), com depend\u00eancia temporal, ou n\u00e3o lineares\n(BREZINA et al., 2010);\n\n3. Problemas envolvendo o transporte de contaminantes em meio poroso saturado, em\ngeral, envolvem:\n\ni. termos advectivos, difusivos e reativos;\n\nii. presen\u00e7a de comportamentos transientes - depend\u00eancia temporal;\n\niii. coeficientes vari\u00e1veis, ou seja, os dados da equa\u00e7\u00e3o do transporte podem possuir\ndepend\u00eancia espacial ou temporal;\n\niv. dom\u00ednios irregulares e geometrias alongadas;\n\nv. processos adaptativos.\n\n21. Esta fun\u00e7\u00e3o \u00e9 fornecida no ap\u00eandice.\n\n\n\n74 Cap\u00edtulo 4. Metodologia\n\n4. \u00c9 necess\u00e1rio que o m\u00e9todo seja robusto, ou seja, possa ser usado em aplica\u00e7\u00f5es\ndiversas envolvendo o fluxo e o transporte em meio poroso saturado;\n\n5. as estimativas residuais para problemas com advec\u00e7\u00e3o dominante aumentam o\ntrabalho computacional devido \u00e0 necessidade de resolver um problema auxiliar.\n\nSuponha, primeiramente, que o m\u00e9todo multigrid gerado no passo n juntamente com\na estrutura hier\u00e1rquica de matrizes e os operadores de transfer\u00eancia de resultados estejam\ndispon\u00edveis para o passo n + 1. Com isso, dois tipos de m\u00e9todos multigrid com reutiliza\u00e7\u00e3o\nforam elaborados: o m\u00e9todo com reutiliza\u00e7\u00e3o com n\u00famero fixo de reutiliza\u00e7\u00f5es e o m\u00e9todo\nautom\u00e1tico.\n\nO primeiro m\u00e9todo consiste em reutilizar as estruturas multigrid em um n\u00famero fixo\nde passos de tempo, enquanto o segundo m\u00e9todo determina automaticamente o n\u00famero\nde passos que o processo deve ser repetido. Como consequ\u00eancia da reutiliza\u00e7\u00e3o, obt\u00e9m-se\nos m\u00e9todos pr\u00e9-condicionados por m\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o.\n\nSem perda de generalidade, suponha que o m\u00e9todo multigrid alg\u00e9brico SA \u00e9 utilizado.\nAdotam-se as seguintes nota\u00e7\u00f5es para descrever os m\u00e9todos multigrid alg\u00e9bricos que\nempregam a reutiliza\u00e7\u00e3o:\n\n1. SA: o m\u00e9todo multigrid alg\u00e9brico SA a ser adotado para as compara\u00e7\u00f5es envolvendo a\nreutiliza\u00e7\u00e3o.\n\n2. SAReu(?): o m\u00e9todo multigrid alg\u00e9brico SA com par\u00e2metro de reutiliza\u00e7\u00e3o ?, em\nque ? denota o n\u00famero de passos de tempo em que o processo de reutiliza\u00e7\u00e3o ser\u00e1\nexecutado.\n\n3. SAReuAuto: o m\u00e9todo multigrid alg\u00e9brico SA com reutiliza\u00e7\u00e3o, cujo n\u00famero de passos\nde tempo \u00e9 determinado automaticamente durante o processo de solu\u00e7\u00e3o.\n\nOs esquemas apresentados nas subse\u00e7\u00f5es (4.6.1) e (4.6.2) podem ser usados tanto\npara o m\u00e9todo multigrid quanto para um m\u00e9todo iterativo pr\u00e9-condicionado por multigrid\nalg\u00e9brico. Basta que a adequada manipula\u00e7\u00e3o seja executada.\n\nSem perda de generalidade, suponha que o m\u00e9todo iterativo GMRES \u00e9 utilizado.\nAdota-se as seguintes nota\u00e7\u00f5es para descrever os m\u00e9todos iterativos pr\u00e9-condicionados por\nm\u00e9todos multigrid alg\u00e9bricos que empregam a reutiliza\u00e7\u00e3o:\n\n4. GMRESSA: o m\u00e9todo GMRES pr\u00e9-condicionado pelo m\u00e9todo multigrid alg\u00e9brico\nSA.\n\n5. GMRESSAReu: o m\u00e9todo GMRES pr\u00e9-condicionado pelo m\u00e9todo multigrid alg\u00e9brico\nSAReu.\n\n6. GMRESSAReuaUTO: o m\u00e9todo GMRES pr\u00e9-condicionado pelo m\u00e9todo multigrid al-\ng\u00e9brico SAReuAuto.\n\n\n\n4.6. AMG com Reutiliza\u00e7\u00e3o de estruturas 75\n\nSegundo St\u00fcben (2001), os m\u00e9todos multigrid s\u00e3o bons pr\u00e9-condicionantes e devem\nser considerados para a solu\u00e7\u00e3o iterativa de sistemas lineares.\n\nOs diferentes m\u00e9todos propostos s\u00e3o apresentados nas subse\u00e7\u00f5es (4.6.1), (4.6.2),\n(4.6.3) e (4.6.4).\n\n4.6.1 SA com Reutiliza\u00e7\u00e3o-SAReu(?)\n\nEsse m\u00e9todo consiste na reutiliza\u00e7\u00e3o das estruturas em um n\u00famero fixo ? de passos\nde tempo de simula\u00e7\u00e3o da equa\u00e7\u00e3o do transporte de contaminantes. O par\u00e2metro ? ser\u00e1\nchamado par\u00e2metro de reutiliza\u00e7\u00e3o.\n\nSA COM REUTILIZA\u00c7\u00c3O: SA-Reu(?)\n1.Defina o par\u00e2metro de reutiliza\u00e7\u00e3o ?, o n\u00famero total de passos Nstep = NI\n\ndo processo de simula\u00e7\u00e3o e o contador n para o n\u00famero de passos de tempo.\n2. Se n ? 0 mod (?), defina o m\u00e9todo SA, guarde as estruturas geradas\n\npara os pr\u00f3ximos passos de tempo.\n3. Se n ? 0 mod (?), ent\u00e3o resolva o sistema linear. Sen\u00e3o, reuse o m\u00e9todo\n\ngerado em (2) para resolver os ? ? 1 passos seguintes.\n\n4.6.2 SA com Reutiliza\u00e7\u00e3o e autom\u00e1tico\n\nO m\u00e9todo SAReu executa os c\u00e1lculos das estruturas no passo n = 1 e repete esses\nc\u00e1lculos a cada ? passos, em que o par\u00e2metro ? \u00e9 escolhido de modo arbitr\u00e1rio. Esta\nse\u00e7\u00e3o prop\u00f5e que o m\u00e9todo determine o passo de tempo em que o c\u00e1lculo das estruturas \u00e9\nnecess\u00e1rio. Essa determina\u00e7\u00e3o autom\u00e1tica \u00e9 baseada no n\u00famero de itera\u00e7\u00f5es necess\u00e1rias \u00e0\nconverg\u00eancia no passo em que o c\u00e1lculo das estruturas \u00e9 executado.\n\nO algoritmo abaixo apresenta o m\u00e9todo SA com reutiliza\u00e7\u00e3o e autom\u00e1tico(SAReuAuto).\n\nSA COM REUTILIZA\u00c7\u00c3O E AUTOM\u00c1TICO: SAReuAuto\n1. Defina a fra\u00e7\u00e3o par\u00e2metro de reutiliza\u00e7\u00e3o 0 &lt;nfrac 6 1 , o contador i e o n\u00famero\n\ntotal de passos Nstep = NI do processo de simula\u00e7\u00e3o.\n2. Defina o m\u00e9todo SA e guarde as estruturas geradas para os pr\u00f3ximos passos.\n\nResolva o sistema linear e determine o n\u00famero de itera\u00e7\u00f5es para a\nconverg\u00eancia(AmgIter1). Guarde AmgIter1\ne o m\u00e9todo gerado para os pr\u00f3ximos passos.\n\n3. Reuse o m\u00e9todo gerado no pr\u00f3ximo passo e calcule o n\u00famero de itera\u00e7\u00f5es\nnecess\u00e1rias para a converg\u00eancia (AmgIter2).\n\n4. Se AmgIter2 > AmgIter1 \u00b7 (1 + nfrac), siga para o passo 2. Sen\u00e3o, enquanto\n\n\n\n76 Cap\u00edtulo 4. Metodologia\n\nAmgIter2 6 AmgIter1 \u00b7 (1 + nfrac) siga para o passo (3).\n\n4.6.3 M\u00e9todo Iterativo Pr\u00e9-condicionado por SA?Reu\n\nPara obter o m\u00e9todo GMRESSAReu basta substituir adequadamente o m\u00e9todo pr\u00e9-\ncondicionante do m\u00e9todo GMRESSA. Dessa forma, a \u00fanica diferen\u00e7a \u00e9 a constru\u00e7\u00e3o do\nm\u00e9todo multigrid SA?Reu, o qual foi apresentado na se\u00e7\u00e3o (4.6.1).\n\nGMRES PR\u00c9-CONDICIONADO POR SA?Reu: GMRESSA?Reu(?)\n1.Defina o par\u00e2metro de reutiliza\u00e7\u00e3o ?, o n\u00famero total de passos Nstep = NI\n\ne o contador n para o n\u00famero de passos de tempo.\n2. Se n ? 0 mod (?), defina o m\u00e9todo SA e guarde as estruturas geradas\n\npara os pr\u00f3ximos passos de tempo. Construa o m\u00e9todo GMRESSA\n3. Se n ? 0 mod (?), ent\u00e3o resolva o sistema linear utilizando GMRES\n\npr\u00e9-condicionado por SA. Sen\u00e3o, reuse o m\u00e9todo gerado em (2) nos\n? ? 1 passos seguintes.\n\n4.6.4 M\u00e9todo iterativo Pr\u00e9-condicionado por SA?ReuAuto\n\nPara obter o m\u00e9todo GMRESSAReuAuto basta substituir adequadamente o m\u00e9todo\npr\u00e9-condicionante do m\u00e9todo GMRESSA. Esse m\u00e9todo \u00e9 id\u00eantico \u00e0quele apresentado na\nse\u00e7\u00e3o (4.6.2) com as convenientes altera\u00e7\u00f5es.\n\nO algoritmo para o m\u00e9todo pr\u00e9-condicionado por SA com reutiliza\u00e7\u00e3o e autom\u00e1tico\n\u00e9 dado por:\n\nGMRES PR\u00c9-CONDICIONADO POR SA?ReuAuto: GMRESSA?ReuAuto\n1. Defina a fra\u00e7\u00e3o par\u00e2metro de reutiliza\u00e7\u00e3o 0 &lt;nfrac 6 1, o contador i\n\ne o n\u00famero de passos de tempo nstep do problema.\n2. Defina o m\u00e9todo SA e guarde as estruturas geradas para os pr\u00f3ximos\n\npassos de tempo. Construa o m\u00e9todo GMRES pr\u00e9-condicionado por SA.\nResolva o sistema linear e determine o n\u00famero de itera\u00e7\u00f5es necess\u00e1rias\npara a converg\u00eancia (GmresIter1). Guarde GmresIter1 e o m\u00e9todo gerado\npara os pr\u00f3ximos passos.\n\n3. Reuse o m\u00e9todo gerado no pr\u00f3ximo passo e calcule o n\u00famero de itera\u00e7\u00f5es\nnecess\u00e1rias para a converg\u00eancia (GmresIter2).\n\n4. Se GmresIter2 > GmresIter1 \u00b7 (1 + nfrac), siga para o passo 2. Sen\u00e3o,\nenquanto GmresIter2 6 GmresIter1 \u00b7 (1 + nfrac) siga para o passo (3)\n\n\n\n4.6. AMG com Reutiliza\u00e7\u00e3o de estruturas 77\n\n4.6.5 Compara\u00e7\u00e3o de resultados\n\nAs solu\u00e7\u00f5es obtidas pelas diferentes estrat\u00e9gias SA?Reu ou SA?ReuAuto necessitam\nser comparadas com a solu\u00e7\u00e3o obtida pelo m\u00e9todo original SA.\n\nSem perda de generalidade, considere que o sistema linear, originado da aproxima\u00e7\u00e3o\nde elementos finitos em malha triangular, no passo de tempo n ?{1, 2, 3 \u00b7 \u00b7 \u00b7 ,NI}, possui a\nforma caracter\u00edstica AnCn = bn, em que Cn = (An)?1bn \u00e9 a solu\u00e7\u00e3o obtida numericamente\npelos diferentes m\u00e9todos adotados.\n\nConsidere que CnSAReu = Cn(x,y,tn), CnSAReuAuto = CnSAReuAuto(x,y,tn) e\nCnSA = CnSA(x,y,tn) sejam as solu\u00e7\u00f5es obtidas pelos m\u00e9todos SAReu, SAReuAuto e\nSA, respectivamente. Adicionalmente, considere que os res\u00edduos das solu\u00e7\u00f5es s\u00e3o dados\npor ResnSA = ResnSA(x,y,tn) = bn ? CnSA, ResnSAReu = Resn(x,y,tn) = bn ? CnSAReu e\nResnSAReuAuto = Resn(x,y,tn) = bn ?CnSAReuAuto.\n\nAs solu\u00e7\u00f5es CnSA, CnSAReu e CnSAReuAuto fornecem as concentra\u00e7\u00f5es para os v\u00e9rtices\n(x,y) dos tri\u00e2ngulos no n-\u00e9simo passo de tempo. Da mesma forma, ResnSA, ResnSAReu e\nResnSAReuAuto s\u00e3o os res\u00edduos nos v\u00e9rtices (x,y) dos tri\u00e2ngulos no n-\u00e9simo passo de tempo.\n\nA compara\u00e7\u00e3o dessas sequ\u00eancias de solu\u00e7\u00f5es e res\u00edduos \u00e9 baseada nas seguintes\ndiferen\u00e7as:\n\ni. DiffnSAReu/SA = Diff\nn\nSAReu/SA(x,y,tn) = C\n\nn\nSA ?CnSAReu\n\nii. DiffnSAReuAuto/SA = Diff\nn\nSAReuAuto/SA(x,y,tn) = C\n\nn\nSA ?CnSAReuAuto\n\niii. ResDiffnSAReu/SA = ResDiff\nn\nSAReu/SA(x,y,tn) = Res\n\nn\nSA ?ResnSAReu\n\niv. ResDiffnSAReuAuto/SA = ResDiff\nn\nSAReuAuto/SA(x,y,tn) = Res\n\nn\nSA ?ResnSAReuAuto\n\nA verifica\u00e7\u00e3o da igualdade das solu\u00e7\u00f5es ou dos res\u00edduos considera a fun\u00e7\u00e3o\ncount_non_zero, dispon\u00edvel na biblioteca NumPy (WALT; COLBERT; VAROQUAUX,\n2011). Caso valores n\u00e3o nulos sejam retornados, ent\u00e3o os valores m\u00e1ximos e m\u00ednimos das\nrespectivas diferen\u00e7as s\u00e3o calculados.\n\nO res\u00edduo da solu\u00e7\u00e3o num\u00e9rica no n-\u00e9simo passo de tempo, denotado por Resn, \u00e9\naquele obtido ap\u00f3s a converg\u00eancia do m\u00e9todo multigrid utilizado. No entanto, as an\u00e1lises\nnum\u00e9ricas apresentadas neste trabalho tamb\u00e9m consideram os res\u00edduos ap\u00f3s k itera\u00e7\u00f5es\ndo m\u00e9todo multigrid. Nesse caso, para evitar sobrecarga de nota\u00e7\u00e3o, a nota\u00e7\u00e3o Ax = b \u00e9\nutilizada para representar o sistema linear AnCn = bn no passo n, sendo que o passo de\ntempo e o m\u00e9todo ficam indicados implicitamente pelo contexto.\n\nO res\u00edduo da solu\u00e7\u00e3o aproximada, em cada itera\u00e7\u00e3o de um determinado m\u00e9todo\niterativo, \u00e9 dado por :\n\nrin := b?Ax\ni, i = 1, 2, 3 \u00b7 \u00b7 \u00b7 ,k (4.72)\n\n\n\n78 Cap\u00edtulo 4. Metodologia\n\nonde xi \u00e9 a solu\u00e7\u00e3o obtida na itera\u00e7\u00e3o i, i = {1, 2, \u00b7 \u00b7 \u00b7k} \u00e9 o n\u00famero de itera\u00e7\u00f5es do m\u00e9todo,\nk \u00e9 o n\u00famero total de itera\u00e7\u00f5es, n \u00e9 o passo de tempo 22. O res\u00edduo relativo para cada\nitera\u00e7\u00e3o do m\u00e9todo \u00e9 definido por resi/res1, i = {1, 2, \u00b7 \u00b7 \u00b7k}. Al\u00e9m do res\u00edduo relativo,\neste trabalho considera a norma l2 do res\u00edduo, o m\u00e1ximo res\u00edduo e o res\u00edduo m\u00e9dio.\n\nAs apresenta\u00e7\u00f5es gr\u00e1ficas e an\u00e1lises envolvendo as quantidades num\u00e9ricas definidas\nnesta parte s\u00e3o apresentadas em detalhes no cap\u00edtulo de resultados [5].\n\n4.6.6 Tempo Computacional\n\nUma das quest\u00f5es principais da proposta dos m\u00e9todos com reutiliza\u00e7\u00e3o \u00e9 o tempo\ngasto na solu\u00e7\u00e3o dos sistemas lineares. Aqui, o tempo gasto em cada passo do processo de\nsimula\u00e7\u00e3o \u00e9 chamado tempo computacional e leva em conta apenas o tempo requerido\npelo m\u00e9todo num\u00e9rico para obter a solu\u00e7\u00e3o. Formalmente \u00e9 dado por ?tn = tn1 ? tn0, em\nque tn0 \u00e9 o tempo imediatamente antes da aplica\u00e7\u00e3o do m\u00e9todo de solu\u00e7\u00e3o e tn1 \u00e9 o tempo\nimediatamente ap\u00f3s a obten\u00e7\u00e3o da solu\u00e7\u00e3o. Consequentemente, define-se o tempo total\ngasto para resolver todos os sistemas lineares do processo de simula\u00e7\u00e3o pela soma dos\ntempos computacionais. Matematicamente, o tempo total \u00e9 dado por:\n\nTan :=\nn?\ni=1\n\n?ti, 1 6 n 6 NI. (4.73)\n\n4.7 Notas sobre os desenvolvimentos\n\nO desenvolvimento dos c\u00f3digos utilizados nesta tese foi feito em linguagem PythonR,\nutilizando a plataforma de desenvolvimento Eclipse 23 que \u00e9 uma plataforma de c\u00f3digo\nlivre desenvolvida para a constru\u00e7\u00e3o de ambientes integrados e que podem ser usados para\no desenvolvimento de aplica\u00e7\u00f5es de diversos tipos (ECLIPSE FOUNDATION, 2015). A\nimplementa\u00e7\u00e3o do c\u00f3digo computacional de elementos finitos foi norteado pela metodologia\ndescrita Fenics Project (2014) 24 enquanto que a implementa\u00e7\u00e3o do m\u00e9todo multigrid\nalg\u00e9brico foi norteado pela metodologia descrita na biblioteca Bell, Olson e Schroder\n(2011). A implementa\u00e7\u00e3o do c\u00f3digo para o c\u00e1lculo das constantes envolvidas no estimador\nde erros foi norteado pela metologia descrita em Jones et al. (2001), a qual fornece, dentre\noutros, os m\u00e9todos de minimiza\u00e7\u00e3o de fun\u00e7\u00f5es tais como gradiente conjugado. Al\u00e9m disso,\n\n22. O res\u00edduo na itera\u00e7\u00e3o k, rkn, \u00e9 tal que Resn = rkn. Essa dupla defini\u00e7\u00e3o serve apenas para evitar\nsobrecarregar a nota\u00e7\u00e3o\n\n23. Aqui IDE Eclipse foi utilizada (ECLIPSE FOUNDATION, 2015). A linguagem PythonR \u00e9\ndisponibilizada atrav\u00e9s do plugin PyDev.\n\n24. O site disponibiliza uma s\u00e9rie de refer\u00eancias, exemplos e outras facilidades para o leitor.\n\n\n\n4.7. Notas sobre os desenvolvimentos 79\n\na implementa\u00e7\u00e3o e utiliza\u00e7\u00e3o dos m\u00e9todos iterativos 25 utilizam o pacote Sparse de Jones\net al. (2001).\n\nAs classes e fun\u00e7\u00f5es que implementam o m\u00e9todo de elementos finitos e as esti-\nmativas residuais s\u00e3o constru\u00eddas separadamente, de forma que \u00e9 poss\u00edvel alter\u00e1-las sem\ncomprometimento das partes desenvolvidas. A implementa\u00e7\u00e3o do m\u00e9todo de elementos\nfinitos \u00e9 facilitados pela introdu\u00e7\u00e3o das formas bilinear e linear, as quais utilizam lingua-\ngens espec\u00edficas e facilitam a introdu\u00e7\u00e3o e desenvolvimento das formula\u00e7\u00f5es variacionais.\nAdicionalmente, as ferramentas dispon\u00edveis possibilitam avaliar qualquer uma das partes\ncomponentes do estimador residual conforme apresentado na se\u00e7\u00e3o (4.3.6).\n\nA parti\u00e7\u00e3o do estimador residual permite que os regimes de dispers\u00e3o dominante\ne advec\u00e7\u00e3o dominante sejam tratados da mesma forma, ou seja, o estimador residual\n\u00e9 dado pela soma das estimativas espacial, dos dados e temporal. A incorpora\u00e7\u00e3o de\nestimativas adicionais \u00e9 realizada pela introdu\u00e7\u00e3o de classes e fun\u00e7\u00f5es espec\u00edficas no\nc\u00f3digo computacional. Dessa forma, o procedimento b\u00e1sico de c\u00e1lculo das estimativas e\nindicadores \u00e9 semelhante aos c\u00e1lculos efetuados para os problemas caracterizados pela\ndispers\u00e3o dominante e por dados constantes. Adicionalmente, a adequada obten\u00e7\u00e3o das\nestimativas residuais est\u00e1 associada \u00e0 obten\u00e7\u00e3o das constantes ?, ? e ?, cuja metodologia de\nc\u00e1lculo \u00e9 baseada nos m\u00e9todos de minimiza\u00e7\u00e3o de fun\u00e7\u00f5es de v\u00e1rias vari\u00e1veis, dispon\u00edveis\nno em Jones et al. (2001).\n\nO desenvolvimento dos m\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o foi baseado na\nbiblioteca num\u00e9rica PyAMG (BELL; OLSON; SCHRODER, 2011), a qual disponibiliza\nos c\u00f3digos computacionais em PythonR. Essa biblioteca requer uma estrutura espec\u00edfica,\ndiferente daquela utilizada pela biblioteca de elementos finitos dolfin (FENICS PROJECT,\n2014). Essa estrutura espec\u00edfica \u00e9 disponibilizada atrav\u00e9s do pacote Scipy Sparse (JONES\net al., 2001), o qual fornece ferramentas para manipula\u00e7\u00e3o de matrizes esparsas. As\nmanipula\u00e7\u00f5es matriciais adicionais s\u00e3o executadas pela biblioteca num\u00e9rica NumPy (WALT;\nCOLBERT; VAROQUAUX, 2011).\n\nA integra\u00e7\u00e3o entre as bibliotecas do FEniCS e a biblioteca PyAMG foi baseada no\nexemplo dispon\u00edvel da documenta\u00e7\u00e3o da biblioteca PyAMG (BELL; OLSON; SCHRODER,\n2011). A forma como os m\u00e9todos multigrid s\u00e3o implementados possibilita a implementa\u00e7\u00e3o\ne teste de outros m\u00e9todos multigrid atrav\u00e9s das classes e estruturas j\u00e1 desenvolvidas.\n\nBaseado no m\u00f3dulo blackbox do PyAMG, o c\u00f3digo para reutiliza\u00e7\u00e3o foi constru\u00eddo\natrav\u00e9s de algumas modifica\u00e7\u00f5es. Essa abordagem, al\u00e9m de disponibilizar as estruturas\nmultigrid, n\u00famero de itera\u00e7\u00f5es necess\u00e1rias \u00e0 converg\u00eancia e residuais em cada itera\u00e7\u00e3o do\nm\u00e9todo, permite a constru\u00e7\u00e3o tanto dos m\u00e9todos com reutiliza\u00e7\u00e3o com par\u00e2metro fixo ?\nquanto dos m\u00e9todos com reutiliza\u00e7\u00e3o autom\u00e1tica. Al\u00e9m disso, se nenhuma especializa\u00e7\u00e3o\n\n25. Os m\u00e9todos iterativos n\u00e3o estacion\u00e1rios utilizados nesta tese tais como GMRES,BICGSTAB.\n\n\n\n80 Cap\u00edtulo 4. Metodologia\n\n\u00e9 passada via dicion\u00e1rio de par\u00e2metros, ent\u00e3o o m\u00f3dulo com modifica\u00e7\u00f5es utiliza \u00e0quela\nespecializa\u00e7\u00e3o definida pelo m\u00f3dulo blackbox.\n\nDe posse das solu\u00e7\u00f5es num\u00e9ricas e res\u00edduos, as compara\u00e7\u00f5es num\u00e9ricas entre os val-\nores obtidos pelos diferentes m\u00e9todos s\u00e3o realizadas por meio da fun\u00e7\u00e3o count_non_zero,\ndispon\u00edvel na biblioteca NumPy (WALT; COLBERT; VAROQUAUX, 2011). Essa fun\u00e7\u00e3o,\naplicada \u00e0s matrizes DiffnSAReu/SA, Diff\n\nn\nSAReuAuto/SA, ResDiff\n\nn\nSAReu/SA e ResDiff\n\nn\nSAReu/SA,\n\nretorna o n\u00famero de elementos n\u00e3o nulos em uma dada matriz. Como consequ\u00eancia, per-\nmite avaliar se as solu\u00e7\u00f5es s\u00e3o id\u00eanticas ou diferentes. A magnitude das diferen\u00e7as, caso\nexistam, pode ser avaliada atrav\u00e9s do c\u00e1lculo dos valores m\u00e1ximos, os quais podem ser\nfornecidos pelas ferramentas computacionais dispon\u00edveis em NumPy. Adicionalmente, os\nresultados num\u00e9ricos envolvendo c\u00e1lculos da norma l2, valores m\u00e1ximos, valores m\u00ednimos e\nm\u00e9dias foram baseados nas fun\u00e7\u00f5es dispon\u00edveis na biblioteca NumPy (WALT; COLBERT;\nVAROQUAUX, 2011).\n\nAs apresenta\u00e7\u00f5es gr\u00e1ficas s\u00e3o baseadas nas bibliotecas matlotlib (HUNTER, 2007) e\nno software ParaView (AYACHIT, 2015). Eventualmente, as ferramentas de visualiza\u00e7\u00e3o\ndisponibilizadas no Projeto FEniCS s\u00e3o utilizadas (FENICS PROJECT, 2014).\n\n\u00c9 importante salientar que a integra\u00e7\u00e3o entre as diferentes bibliotecas utilizadas \u00e9 um\ndos aspectos fundamentais desse trabalho. A escolha da plataforma de desenvolvimento, da\nbiblioteca de elementos finitos juntamente com a linguagem de programa\u00e7\u00e3o e as ferramen-\ntas dispon\u00edveis, a integra\u00e7\u00e3o da biblioteca para m\u00e9todos multigrid e a disponibilidade dos\nm\u00e9todos iterativos n\u00e3o-estacion\u00e1rios por meio do pacote linalg formaram a base essencial\npara o desenvolvimento dessa tese.\n\n\n\n81\n\n5 Resultados\n\nNeste cap\u00edtulo os resultados da implementa\u00e7\u00e3o do c\u00f3digo de elementos finitos, as\nestrat\u00e9gias de refinamento adaptativo para os dados da equa\u00e7\u00e3o do transporte e os\nm\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o s\u00e3o descritos. As primeiras se\u00e7\u00f5es descrevem\nos resultados envolvendo a valida\u00e7\u00e3o do c\u00f3digo de elementos finitos juntamente com a\nvalida\u00e7\u00e3o dos estimadores residuais. Em seguida, as estrat\u00e9gias adaptativas para obter\nmalhas adequadas \u00e0s representa\u00e7\u00f5es dos dados s\u00e3o discutidas. Finalmente, os resultados\nenvolvendo os m\u00e9todos multigrid com reutiliza\u00e7\u00e3o das estruturas hier\u00e1rquicas s\u00e3o descritos.\n\n-\n\n5.1 M\u00e9todo de elementos finitos e Estimador Residual\n\nEsta se\u00e7\u00e3o apresenta os resultados num\u00e9ricos da solu\u00e7\u00e3o da equa\u00e7\u00e3o do transporte\nde contaminantes, as respectivas solu\u00e7\u00f5es anal\u00edticas e os estimadores de erros residuais. As\nsolu\u00e7\u00f5es num\u00e9ricas e anal\u00edticas s\u00e3o comparadas de acordo com a metodologia exposta.\n\n5.1.1 Exemplo 01\n\nEste problema considera a equa\u00e7\u00e3o do transporte de contaminantes em dom\u00ednio\nretangular ? = [x0,x1] \u00d7 [y0,y1] = [0.0, 3000.0] \u00d7 [0.0, 1500.0] e \u00e9 uma adapta\u00e7\u00e3o espacial\ndo problema apresentado em Sorek (SOREK, 1988). Os par\u00e2metros f\u00edsicos s\u00e3o Dx =\n100.0,Dy = 20.0m\n\n2\n\nd\npara a dispers\u00e3o longitudinal e transversal, vx = 0.2md e vy = 0.0\n\nm\nd\n\npara as componentes da velocidade e rea\u00e7\u00e3o ? = Constante ? R. A fronteira de Dirichlet\n\u00e9 definida em ?D = {x0}\u00d7 [y0,y1] ?{y0}\u00d7 [x0,x1] ?{y1}\u00d7 [x0,x1] por\n\nC(x,y,t)\nC0\n\n=\n\n??\n? 1.0, para x = 0, |y ? 750.0| &lt;115.0, t > 00, caso contr\u00e1rio (5.1)\n\ne a fronteira de Neumann \u00e9 definida em ?N = ? \\ ?D = {x1}\u00d7 [y0,y1] por g = n \u00b7?(C).\nA condi\u00e7\u00e3o inicial \u00e9 C0 = C(x,y,t0 = 0.0) = 0.0 para todo x ? ?.\n\nNesse caso, a solu\u00e7\u00e3o anal\u00edtica apresentada na se\u00e7\u00e3o (4.2.3), \u00e9 utilizada para valida\u00e7\u00e3o\ndo c\u00f3digo. Os dois pr\u00f3ximos exemplos apresentam os resultados num\u00e9rico e anal\u00edtico da\nsolu\u00e7\u00e3o da equa\u00e7\u00e3o ADR, os indicadores espaciais, dos elementos, dos saltos e das fronteiras.\n\n\n\n82 Cap\u00edtulo 5. Resultados\n\nNesse caso, o estimador residual dado pela equa\u00e7\u00e3o (4.37) \u00e9 o estimador de Verf\u00fcrth (2014),\npois satisfaz as condi\u00e7\u00f5es (P1)-(P4). Formalmente 1,\n\n(?I) =\n\n??\n??C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n.\n\n(5.2)\n\nO estimador (5.11) pode ser simplificado, pois a condi\u00e7\u00e3o inicial e os dados podem\nser representados exatamente pelo m\u00e9todo de elementos finitos com fun\u00e7\u00f5es lagrangeanas\nlineares. Al\u00e9m disso, o regime \u00e9 caracterizado pela dispers\u00e3o dominante, ou seja, existe\numa constante Cc definida por\n\nCc :=\n|v|\n\n?1/2 \u00b7 max(?,?)1/2\n(5.3)\n\ntal que 0.2 6 Cc \u00b7?1/2 \u00b7 max(?,?)1/2 (FIRMIANO, 2010). Em ambos os casos considerados,\nreativo ou conservativo, o regime de dispers\u00e3o dominante caracteriza o estimador de erros\ne possui constante Cc dada por:\n\nCc :=\n0.2\n\n201/2 \u00b7 max(20, 0)1/2\n=\n\n0.2\n201/2 \u00b7 max(20,?)1/3\n\n=\n0.2\n20\n\n= 0.01, para ? &lt;20. (5.4)\n\nDessa forma, o estimador residual (5.11) pode ser simplificado para\n\n(?I) =\n\n??\n?\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n=\n\n??\n?\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+ |||Cn ?Cn?1|||2\n\n]??\n?\n\n1/2\n\n. (5.5)\n\nO estimador residual (5.5) \u00e9 mais acurado que o estimador proposto por Firmiano\n(2010) no sentido que a estimativa espacial associada \u00e0 equa\u00e7\u00e3o (5.5) \u00e9 tal que :\n\n(\n?(n)\n\n)\n=\n{?\n\nK\n\n?2K||RK||\n2\nL2(K)\n\n}1/2\n?\n(\n?(n)\n\n)\n, (5.6)\n\nem que o lado esquerdo \u00e9 o estimador espacial apresentador por Firmiano (2010) e o lado\ndireito \u00e9 estimador espacial dado pela express\u00e3o (4.24).\n\n1. Aqui os termos (?f )(n) e (?N )(n) devem ser desconsiderados pois s\u00e3o v\u00e1lidas as hip\u00f3teses (P1)-(P4).\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 83\n\n5.1.1.1 Transporte Conservativo em Campo Uniforme:? = 0\n\nEste caso considera uma malha com Ne = 90.000 elementos finitos triangulares,\nNv = 45.451 v\u00e9rtices e orienta\u00e7\u00e3o left/right. Os par\u00e2metros para implementa\u00e7\u00e3o s\u00e3o\nnx = 2ny = 300 elementos finitos triangulares em cada dire\u00e7\u00e3o coordenada, fun\u00e7\u00f5es\nlagrangeanas lineares, ? = 1/2, ?n = 5.0d, tfinal = 1000.0d, n = {1, 2, \u00b7 \u00b7 \u00b7 ,NI = 200}.\n\nA compara\u00e7\u00e3o das solu\u00e7\u00f5es fornece um erro m\u00e1ximo Emax = max(Erro) = 0.0289\ne um erro m\u00e9dio Eme?dio = 5.39265 \u00b7 10?05. A tabela [2] fornece as solu\u00e7\u00f5es num\u00e9rica e\nanal\u00edtica com concentra\u00e7\u00f5es normalizadas por C0, o erro real e os indicadores residuais\npara um conjunto de pontos no 200-\u00e9simo instante de tempo.\n\nTabela 2 \u2013 A solu\u00e7\u00e3o num\u00e9rica no 200-\u00e9simo instante de tempo com concentra\u00e7\u00e3o normalizada,\nC200\n\nC0\n= CNume?rica\n\nC0\n, a solu\u00e7\u00e3o anal\u00edtica em t = tf = 1000.0d com concentra\u00e7\u00e3o normal-\n\nizada, CA\nC0\n\n= CAnal?itica\nC0\n\n, o erro real (Erro), indicador espacial (?K), o indicador do\nelemento (?1K) e o indicador do salto (?2E) para um conjunto de pontos\n\n(x,y) C200\nC0\n\nCA\nC0\n\nErro ?K ?1K ?2E\n\n(10.0,630.0) 0.1955 0.2240 0.0286 7.3409 0.0499 7.3407\n(20.0,630.0) 0.2953 0.3233 0.0279 3.9684 0.0237 3.9683\n(30.0,630.0) 0.3479 0.3660 0.0181 3.0211 0.0178 3.0211\n(40.0,630.0) 0.3760 0.3868 0.0108 1.7680 0.0071 1.7680\n(10.0,640.0) 0.7934 0.7644 0.0290 6.9242 0.0499 6.9240\n(20.0,640.0) 0.6816 0.6535 0.0281 4.0881 0.0286 4.0880\n(30.0,640.0) 0.6171 0.5988 0.0183 2.5756 0.0178 2.5755\n(40.0,640.0) 0.5767 0.5658 0.0109 2.6781 0.0179 2.6781\n(10.0,860.0) 0.7934 0.7644 0.0290 7.3409 0.0499 7.3407\n(20.0,860.0) 0.6816 0.6535 0.0281 3.9684 0.0237 3.9683\n(30.0,860.0) 0.6171 0.5988 0.0183 3.0211 0.0178 3.0211\n(40.0,860.0) 0.5767 0.5658 0.0109 1.7680 0.0071 1.7680\n(10.0,870.0) 0.1955 0.2240 0.0286 4.5142 0.0305 4.5141\n(20.0,870.0) 0.2953 0.3233 0.0279 3.5722 0.0237 3.5721\n(30.0,870.0) 0.3479 0.3660 0.0181 2.7178 0.0176 2.7178\n(40.0,870.0) 0.3760 0.3868 0.0108 1.5031 0.0071 1.5031\n\nAs figuras (8-a,b) apresentam, respectivamente, as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica com\nas respectivas isolinhas. O erro real (Erro), em cada ponto do dom\u00ednio computacional, \u00e9\napresentado na figura (9). Esse erro evidencia a exist\u00eancia de uma regi\u00e3o, em torno dos\npontos de descontinuidade da fun\u00e7\u00e3o de fonte (y = 635 e y = 865), em que a solu\u00e7\u00e3o\nanal\u00edtica n\u00e3o \u00e9 representada adequadamente pela solu\u00e7\u00e3o num\u00e9rica. Esses erros englobam\n\n\n\n84 Cap\u00edtulo 5. Resultados\n\nos erros de representa\u00e7\u00e3o da fun\u00e7\u00e3o de fonte, a qual \u00e9 descont\u00ednua, e os erros devidos ao\navan\u00e7o da frente de contamina\u00e7\u00e3o.\n\n(a) Solu\u00e7\u00e3o anal\u00edtica e isolinhas nas dire\u00e7\u00f5es coordenadas\n\n(b) Solu\u00e7\u00e3o num\u00e9rica e isolinhas nas dire\u00e7\u00f5es coordenadas\n\nFigura 8 \u2013 As solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica em malha elementos finitos triangulares e fun\u00e7\u00f5es\nlagrangeanas lineares\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 85\n\nFigura 9 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica E = Erro = |CAnal?itica\nC0\n\n? CNume?rica\nC0\n\n|\nrepresentado em malha de elementos finitos triangulares e fun\u00e7\u00f5es lagrangeanas\nlineares\n\nA representa\u00e7\u00e3o inadequada \u00e9 devida \u00e0s fun\u00e7\u00f5es cont\u00ednuas do m\u00e9todo de elementos\nfinitos. Uma representa\u00e7\u00e3o adequada da fun\u00e7\u00e3o de fonte pode ser obtida atrav\u00e9s da\nutiliza\u00e7\u00e3o do m\u00e9todo de Galerkin descont\u00ednuo. Os erros relativos ao avan\u00e7o da frente de\ncontaminantes s\u00e3o referentes \u00e0 discretiza\u00e7\u00e3o adotada e podem ser corrigidos atrav\u00e9s da\nutiliza\u00e7\u00e3o de uma malha mais refinada. No entanto, aqui apenas os m\u00e9todos cont\u00ednuos\ns\u00e3o utilizados, pois os objetivos s\u00e3o a valida\u00e7\u00e3o do c\u00f3digo computacional de elementos\nfinitos e dos estimadores residuais. Essa valida\u00e7\u00e3o permite utilizar esses c\u00f3digos para gerar\nsistemas lineares, os quais ser\u00e3o resolvidos pelos m\u00e9todos multigrid com reutiliza\u00e7\u00e3o.\n\nA adequa\u00e7\u00e3o entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica tamb\u00e9m pode ser analisada\natrav\u00e9s dos perfis de concentra\u00e7\u00e3o, apresentados nas figuras (10-a,b). Esses perfis mostram\nas solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica sobre as retas y = y0 = 250, 500, 620, 630, 640. Novamente,\nas solu\u00e7\u00f5es anal\u00edticas e num\u00e9ricas discordam apenas nas regi\u00f5es de descontinuidade da\nfun\u00e7\u00e3o de fonte.\n\nA an\u00e1lise mostra que o c\u00f3digo computacional est\u00e1 adequadamente implementado,\npois as solu\u00e7\u00f5es anal\u00edtica e num\u00e9rica possuem comportamento qualitativo semelhante.\nAl\u00e9m disso, as diferen\u00e7as observadas s\u00e3o devidas \u00e0 representa\u00e7\u00e3o inadequada da fonte de\ncontaminantes e ao n\u00famero de elementos finitos na malha.\n\n\n\n86 Cap\u00edtulo 5. Resultados\n\n(a) Compara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica para um conjunto de pontos\n\n(b) Compara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica para um conjunto de pontos\n\nFigura 10 \u2013 Perfis de concentra\u00e7\u00e3o comparando as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica\n\nOs indicadores residuais, representados na malha de elementos finitos, s\u00e3o apresenta-\ndos nas figuras (11, 12 e 13).\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 87\n\nFigura 11 \u2013 O indicador espacial ?K em cada elemento\n\nFigura 12 \u2013 O indicador do elemento ?1K em cada elemento\n\n\n\n88 Cap\u00edtulo 5. Resultados\n\n(a) O indicador do salto ?2E em cada elemento\n\n(b) O indicador temporal ??n em cada elemento\n\nFigura 13 \u2013 Os indicadores do salto ?2E e temporal ?? em cada elemento\n\nA an\u00e1lise desses indicadores fornece valores m\u00e1ximos ?K,max = 7.3411, ?1K,max =\n0.1311, ?2E,max = 7.3407 e ?3B,max = 0.0, max(?? ) = 3.5 \u00b7 10?5. Os indicadores espaciais\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 89\n\ncapturam os erros relacionados a representa\u00e7\u00e3o da descontinuidade da fun\u00e7\u00e3o de fonte e\nos erros relacionados ao avan\u00e7o da frente de contamina\u00e7\u00e3o. Similarmente, os indicadores\ndos elementos e dos saltos ainda capturam o comportamento do erro e podem ser usados\nem uma estrat\u00e9gia adaptativa que contemplem a utiliza\u00e7\u00e3o das componentes do estimador\nresidual. Por sua vez, o indicador temporal n\u00e3o possui uma interpreta\u00e7\u00e3o relacionada\n\u00e0 solu\u00e7\u00e3o num\u00e9rica, mas \u00e9 apresentado para ilustrar a contribui\u00e7\u00e3o que cada elemento\nfornece \u00e0 estimativa temporal.\n\nO pr\u00f3ximo caso analisa o transporte de contaminantes com termo reativo ? 6= 0.\n\n5.1.1.2 Transporte Reativo: ? 6= 0\n\nEste caso considera os mesmos dados do problema anterior exceto ?n = 5.0d,\ntfinal = 1000.0d, n = {1, 2, \u00b7 \u00b7 \u00b7 ,NI = 200} e o fator de rea\u00e7\u00e3o constante ? = 0.01.\nAnalogamente ao caso anterior, a tabela [3] fornece um conjunto de pontos e as respectivas\nsolu\u00e7\u00f5es num\u00e9rica e anal\u00edtica com concentra\u00e7\u00f5es normalizadas no 200-\u00e9simo instante de\ntempo.\n\nTabela 3 \u2013 A solu\u00e7\u00e3o num\u00e9rica no 200-\u00e9simo instante de tempo com concentra\u00e7\u00e3o normalizada,\nC200\n\nC0\n= CNume?rica\n\nC0\n, a solu\u00e7\u00e3o anal\u00edtica em t = tf = 1000.0d com concentra\u00e7\u00e3o normal-\n\nizada, CA\nC0\n\n= CAnal?itica\nC0\n\n, o erro real (Erro), indicador espacial (?K), o indicador do\nelemento (?1K) e o indicador do salto (?2E) para um conjunto de pontos\n\n(x,y)\nC200\n\nC0\n\nCA\nC0\n\nErro ?K ?1K ?2E\n\n(10.0,630.0) 0.1623 0.1913 0.0290 9.0060 0.0667 9.0058\n(20.0,630.0) 0.2318 0.2597 0.0279 2.7122 0.0108 2.7122\n(30.0,630.0) 0.2559 0.2742 0.0183 4.1785 0.0309 4.1784\n(40.0,630.0) 0.2588 0.2695 0.0106 1.1058 0.0036 1.1058\n(10.0,640.0) 0.7518 0.7221 0.0297 8.6658 0.0667 8.6656\n(20.0,640.0) 0.6026 0.5747 0.0279 5.7929 0.0453 5.7927\n(30.0,640.0) 0.5065 0.4879 0.0186 3.7845 0.0309 3.7844\n(10.0,860.0) 0.7518 0.7221 0.0297 9.0060 0.0667 9.0058\n(20.0,860.0) 0.6026 0.5747 0.0279 2.7122 0.0108 2.7122\n(30.0,860.0) 0.5065 0.4879 0.0186 4.1785 0.0309 4.1784\n(40.0,860.0) 0.4373 0.4267 0.0107 1.1058 0.0036 1.1058\n(10.0,870.0) 0.1623 0.1913 0.0290 3.1874 0.0192 3.1874\n(20.0,870.0) 0.2318 0.2597 0.0279 2.5833 0.0108 2.5832\n(30.0,870.0) 0.2559 0.2742 0.0183 1.5341 0.0073 1.5341\n\n\n\n90 Cap\u00edtulo 5. Resultados\n\nAs figuras (14 e 15) fornecem as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica e respectivas curvas\nde n\u00edvel.\n\nFigura 14 \u2013 A solu\u00e7\u00e3o anal\u00edtica e isolinhas em malha de elementos finitos e fun\u00e7\u00f5es lineares\n\nFigura 15 \u2013 A solu\u00e7\u00e3o num\u00e9rica e isolinhas em malha de elementos finitos e fun\u00e7\u00f5es lineares\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 91\n\nA compara\u00e7\u00e3o das solu\u00e7\u00f5es fornece um erro m\u00e1ximo Emax = max(Erro200) = 0.0296\ne um erro m\u00e9dio Eme?dio = 2.0982 \u00b7 10?05, mostrando que o c\u00f3digo computacional resolve\nadequadamente o transporte de contaminantes com rea\u00e7\u00e3o. O mapa de erros \u00e9 apresentado\nna figura (20).\n\nNovamente, verifica-se que os maiores erros est\u00e3o sobre as retas y = Y1 e y = Y2\ndevido \u00e0 descontinuidade da fonte de contaminantes nos pontos (0,Y1) e (0,Y2) conforme\npode ser observado na tabela [3] e nas figuras (20).\n\nFigura 16 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica E = Erro = |CAnal?itica\nC0\n\n? CNume?rica\nC0\n\n|\nrepresentado em malha de elementos finitos triangulares e fun\u00e7\u00f5es lagrangeanas\nlineares\n\nAs figuras (17), (18) e (19-a,b) apresentam, respectivamente, os indicadores espaciais,\ndos elementos, dos saltos e das fronteiras de Neumann. Novamente, o comportamento\nqualitativo do mapa de erros \u00e9 capturado pelos indicadores de erros. A an\u00e1lise quantitativa\nfornece valores m\u00e1ximos ?K,max = 9.0063, ?1K,max = 0.1088, ?2E,max = 9.0057 e ?3B,max =\n0.0. A diferen\u00e7a entre os valores m\u00e1ximos deste problema e do caso anterior \u00e9 a presen\u00e7a do\nfator de rea\u00e7\u00e3o, o qual afeta o avan\u00e7o da frente de contamina\u00e7\u00e3o e as estimativas residuais.\n\n\n\n92 Cap\u00edtulo 5. Resultados\n\nFigura 17 \u2013 O indicador espacial ?K em cada elemento\n\nFigura 18 \u2013 O indicador do elemento ?1K em cada elemento\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 93\n\nFigura 19 \u2013 O indicador do salto ?2E em cada elemento\n\nA pr\u00f3xima se\u00e7\u00e3o considera o transporte de contaminantes em um dom\u00ednio ? em que\nos dados possuem depend\u00eancia espacial. A representa\u00e7\u00e3o desses dados em um espa\u00e7o de\nelementos finitos pode n\u00e3o ser exata e depende da fun\u00e7\u00e3o que est\u00e1 sendo representada e do\ngrau do polin\u00f4mio utilizado no m\u00e9todo de elementos finitos. Por exemplo, a representa\u00e7\u00e3o\nde um campo de velocidades com componentes lineares \u00e9 exata em um espa\u00e7o de fun\u00e7\u00f5es\nlineares, mas a representa\u00e7\u00e3o de um campo com componentes com varia\u00e7\u00e3o quadr\u00e1tica\nn\u00e3o \u00e9 exata para espa\u00e7o de fun\u00e7\u00f5es lineares. A discuss\u00e3o sobre representa\u00e7\u00e3o adequada dos\ndados do problema do transporte \u00e9 inserida na se\u00e7\u00e3o (5.1.3), e \u00e9 apresentada juntamente\ncom as estimativas residuais.\n\n5.1.2 Exemplo 02\n\nNesta se\u00e7\u00e3o uma adapta\u00e7\u00e3o do problema apresentado em Zoppou e Knight (1999)\n\u00e9 considerada. O problema do transporte de contaminantes \u00e9 definido em um dom\u00ednio\nbidimensional ? = [0, 20]\u00d7[0, 20] com campo vari\u00e1vel de velocidades v e matriz de dispers\u00e3o\nD = D(x,y) com elementos com depend\u00eancia espacial. O campo de velocidades \u00e9 dado por\nv = (vx,vy) = (u0 \u00b7x,?u0 \u00b7y) enquanto que as componentes da matriz de dispers\u00e3o s\u00e3o\nfun\u00e7\u00f5es com depend\u00eancia espacial e dadas por d11(x,y) = D0\u00b7u20\u00b7x2, d12(x,y) = d21(x,y) =\n0 e d22(x,y) = D0 \u00b7u20 \u00b7y2, em que D0 \u00e9 uma constante. Adicionalmente, a fronteira de\nNeumann \u00e9 definida em ?N = {x1}\u00d7 (y0,y1) ?{y1}\u00d7 (x0,x1) por g = n \u00b7D?C, a fun\u00e7\u00e3o\n\n\n\n94 Cap\u00edtulo 5. Resultados\n\nde fonte \u00e9 dada por f(x,y,t) = 0 e a condi\u00e7\u00e3o inicial \u00e9\n\nC0(x,y,t0 = 0.0) =\n\n???\n??\n\n1\n? \u00b7R2\n\n, se (x?x0)2 + (y ?y0)2 6 R2\n\n0, caso contra?rio\n. (5.7)\n\nonde (x0,y0) \u00e9 ponto no dom\u00ednio ? e R uma constante.\n\nComo a fonte de contaminantes \u00e9 pequena em rela\u00e7\u00e3o ao dom\u00ednio computacional,\nent\u00e3o a solu\u00e7\u00e3o anal\u00edtica, apresentada em [5.1.2], \u00e9 considerada adequada para esse\nproblema.\n\nA aproxima\u00e7\u00e3o de elementos finitos considera uma malha com Ne = 80000 elementos\nfinitos triangulares, Nv = 40401 v\u00e9rtices e orienta\u00e7\u00e3o left/right. Os par\u00e2metros para im-\nplementa\u00e7\u00e3o s\u00e3o nx = ny = 200 elementos finitos triangulares em cada dire\u00e7\u00e3o coordenada,\nfun\u00e7\u00f5es lagrangeanas de ordem 1, ? = 1/2, ?n = 0.0001d, tfinal = 0.1d, n = {1, 2, \u00b7 \u00b7 \u00b7 , 1000}\ne constantes u0 = 0.5, D0 = 2.0.\n\nA figura (20) representa as componentes do campo de velocidades, a condi\u00e7\u00e3o\ninicial C0 e as fronteiras de Dirichlet e Neumann. Nesse caso, o campo de velocidades \u00e9\nrepresentado exatamente pelas fun\u00e7\u00f5es lineares. No entanto, a varia\u00e7\u00e3o quadr\u00e1tica das\ndispers\u00f5es pode n\u00e3o ser adequadamente capturada.\n\nFigura 20 \u2013 Campo de velocidades n\u00e3o uniforme v = (vx,vy) = (0.5(x + 1.0),?0.5(y + 1)),\ncondi\u00e7\u00e3o inicial e condi\u00e7\u00f5es de Dirichlet e Neumann\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 95\n\nQualitativamente, os resultados num\u00e9ricos s\u00e3o semelhantes aos resultados obtidos\npor Zoppou e Knight (1999). A compara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica fornece um\nerro m\u00e1ximo Emax = max(Erro1000) = 0.0009288 e um erro m\u00e9dio Eme?dio = 4.6092 \u00b7 10?05.\nEsse erro m\u00e1ximo representa, aproximadamente, 1.79%(0.0009288/0.05181 = 0.0179) do\nvalor da concentra\u00e7\u00e3o naquela coordenada.\n\nA tabela [4] fornece as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica e o erro real em um conjunto de\npontos no 1000-\u00e9simo instante de tempo do processo de simula\u00e7\u00e3o.\n\nTabela 4 \u2013 As solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica e o erro real no 1000-\u00e9simo instante de tempo do\nprocesso de simula\u00e7\u00e3o\n\n(x,y) C1000 CA Erro1000\n\n(4.4,3.6) 0.0461 0.0452 0.0009\n(4.6,3.6) 0.0483 0.0474 0.0009\n(4.3,3.7) 0.0473 0.0464 0.0009\n(4.5,3.7) 0.0501 0.0492 0.0009\n(4.7,3.7) 0.0519 0.0510 0.0009\n(4.2,3.8) 0.0479 0.0470 0.0009\n(4.4,3.8) 0.0513 0.0504 0.0009\n(4.6,3.8) 0.0537 0.0528 0.0009\n(4.8,3.8) 0.0551 0.0542 0.0009\n(4.1,3.9) 0.0477 0.0468 0.0009\n(4.3,3.9) 0.0518 0.0509 0.0009\n(4.5,3.9) 0.0549 0.0539 0.0009\n(4.7,3.9) 0.0569 0.0559 0.0009\n(4.0,4.0) 0.0469 0.0460 0.0009\n(4.2,4.0) 0.0516 0.0507 0.0009\n(4.4,4.0) 0.0553 0.0544 0.0009\n(4.6,4.0) 0.0579 0.0570 0.0009\n(4.1,4.1) 0.0507 0.0498 0.0009\n(4.3,4.1) 0.0551 0.0541 0.0009\n(4.5,4.1) 0.0583 0.0574 0.0009\n(4.0,4.2) 0.0492 0.0483 0.0009\n(4.2,4.2) 0.0541 0.0532 0.0009\n(4.4,4.2) 0.0580 0.0571 0.0009\n(4.1,4.3) 0.0525 0.0516 0.0009\n(4.3,4.3) 0.0570 0.0561 0.0009\n\nAs figuras (21-a,b) apresentam as solu\u00e7\u00f5es anal\u00edtica e num\u00e9rica juntamente com as\n\n\n\n96 Cap\u00edtulo 5. Resultados\n\nrespectivas curvas de n\u00edvel.\n\n(a) Solu\u00e7\u00e3o anal\u00edtica e isolinhas nas dire\u00e7\u00f5es coordenadas\n\n(b) Solu\u00e7\u00e3o num\u00e9rica e isolinhas nas dire\u00e7\u00f5es coordenadas\n\nFigura 21 \u2013 As solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica em malha de elementos finitos e fun\u00e7\u00f5es lineares\n\nQualitativamente, a solu\u00e7\u00e3o num\u00e9rica \u00e9 adequada ao problema proposto. Uma an\u00e1lise\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 97\n\nquantitativa, por meio do mapa de erros (figura 22), mostra que a solu\u00e7\u00e3o num\u00e9rica captura\nadequadamente o comportamento da solu\u00e7\u00e3o anal\u00edtica.\n\nFigura 22 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica E = Erro = |CA ?C1000|\n\nFigura 23 \u2013 Perfis de concentra\u00e7\u00e3o para as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica\n\n\n\n98 Cap\u00edtulo 5. Resultados\n\nO mapa de erros e as respectivas curvas de n\u00edvel mostram que a solu\u00e7\u00e3o num\u00e9rica\ne anal\u00edtica possuem mesmos pontos de m\u00e1ximos e, al\u00e9m disso, o avan\u00e7o da frente de\ncontaminantes \u00e9 capturado pela solu\u00e7\u00e3o num\u00e9rica. Essa adequa\u00e7\u00e3o pode ser observada\natrav\u00e9s dos perfis de concentra\u00e7\u00e3o, apresentados nas figuras (23).\n\nA an\u00e1lise dos perfis de concentra\u00e7\u00e3o, apresentados nas figuras (23-a,b), mostram que\na forma da solu\u00e7\u00e3o anal\u00edtica \u00e9 capturada adequadamente pela solu\u00e7\u00e3o num\u00e9rica. Al\u00e9m\ndisso, a presen\u00e7a do campo de velocidades n\u00e3o uniforme e n\u00e3o constante influencia na\nforma da frente de contamina\u00e7\u00e3o e na velocidade da dispers\u00e3o em cada dire\u00e7\u00e3o e ambos os\nefeitos s\u00e3o capturados pelo c\u00f3digo num\u00e9rico.\n\nA pr\u00f3xima se\u00e7\u00e3o discute a proje\u00e7\u00e3o L2. Esse t\u00f3pico \u00e9 importante para as estimativas\nresiduais e, al\u00e9m disso, introduz a quest\u00e3o da representa\u00e7\u00e3o adequada das express\u00f5es\nanal\u00edticas.\n\n5.1.3 Proje\u00e7\u00e3o L2\n\nA obten\u00e7\u00e3o das estimativas residuais e, consequentemente, dos indicadores residuais\nexige proje\u00e7\u00e3o L2 de fun\u00e7\u00f5es sobre o espa\u00e7o de elementos finitos. Este exemplo discute a\nproje\u00e7\u00e3o L2, a representa\u00e7\u00e3o das fun\u00e7\u00f5es no espa\u00e7o de elementos finitos e a representa\u00e7\u00e3o\nanal\u00edtica da fun\u00e7\u00e3o. O termo anal\u00edtica refere-se a fun\u00e7\u00e3o que \u00e9 representada em uma malha\nrefinada ou com fun\u00e7\u00f5es lagrangeanas de ordem superior \u00e0quela utilizada na representa\u00e7\u00e3o\nL2. Para esta discuss\u00e3o considera-se os seguintes problemas:\n\nProblema 01: Ilustrar a representa\u00e7\u00e3o da fun\u00e7\u00e3o f(x) = x2 utilizando diferentes\nmalhas de elementos finitos.\n\nIlustrativamente, a figura [24] apresenta a representa\u00e7\u00e3o da fun\u00e7\u00e3o f(x) = x2 em\ndiferentes malhas de elementos finitos com fun\u00e7\u00f5es lagrangeanas lineares. A fun\u00e7\u00e3o fMalha01\n\u00e9 a aproxima\u00e7\u00e3o da fun\u00e7\u00e3o f(x) = x2 em uma malha, Malha01, com nx = ny = 2\nelementos em cada dire\u00e7\u00e3o coordenada, a fun\u00e7\u00e3o fMalha02 \u00e9 a aproxima\u00e7\u00e3o da fun\u00e7\u00e3o f\nem uma malha, Malha02, obtida por meio de um refinamento uniforme de Malha01 e a\nfun\u00e7\u00e3o fMalha03 \u00e9 a aproxima\u00e7\u00e3o obtida por meio de 04 refinamentos uniformes e sucessivos\nda Malha01. Nesse caso, a aproxima\u00e7\u00e3o fMalha03 \u00e9 considerada uma aproxima\u00e7\u00e3o adequada\npara representa\u00e7\u00e3o da express\u00e3o anal\u00edtica f(x) = x2.\n\nProblema 02: Obter a proje\u00e7\u00e3o L2 da fun\u00e7\u00e3o f(x,y) = 1 + x2 + y2 em um dom\u00ednio\n? = [0, 32] \u00d7 [0, 32] com ne = nx = ny = 8 elementos finitos triangulares com orienta\u00e7\u00e3o\nleft/right e fun\u00e7\u00f5es lagrangeanas lineares. Fornecer uma representa\u00e7\u00e3o gr\u00e1fica do erro\nassociado.\n\nNeste caso, primeiramente \u00e9 necess\u00e1rio resolver um sistema linear da forma Ax = b 2.\n\n2. Este sistema \u00e9 gerado pela adequada defini\u00e7\u00e3o das formas bilinear a e linear L.\n\n\n\n5.1. M\u00e9todo de elementos finitos e Estimador Residual 99\n\nFigura 24 \u2013 A express\u00e3o anal\u00edtica avaliada em tr\u00eas malhas diferentes: Malha01 possui dois\nelementos em cada dire\u00e7\u00e3o coordenada, Malha02 foi obtida por refinamento uniforme\nda Malha01 e Malha03 foi obtida por 04 refinamentos uniformes e sucessivos da\nMalha01. A fun\u00e7\u00e3o fMalha03 \u00e9 considerada adequada para a representa\u00e7\u00e3o da\nexpress\u00e3o anal\u00edtica de f(x) = x2\n\nA solu\u00e7\u00e3o 3 (FENICS PROJECT, 2014) fornece os valores nodais, os quais representam a\nproje\u00e7\u00e3o L2. Esses valores s\u00e3o interpolados e o resultado \u00e9 apresentado na figura (25-a).\nEssa figura \u00e9 a proje\u00e7\u00e3o L2 da fun\u00e7\u00e3o f(x,y) = 1 + x2 + y2 conforme especificado pelo\nproblema.\n\nA compara\u00e7\u00e3o dos resultados \u00e9 feita na malha para representa\u00e7\u00e3o anal\u00edtica da fun\u00e7\u00e3o\nf, ou seja, a malha mais refinada ou com fun\u00e7\u00f5es de ordem superior.\n\nA figura (25-b) apresenta o erro da aproxima\u00e7\u00e3o da fun\u00e7\u00e3o f utilizando malha\nrefinada.\n\nA malha refinada foi obtida da malha inicial atrav\u00e9s de quatro refinamentos uniformes\nsucessivos. A malha inicial possui ne = 128 elementos com nv = 81 v\u00e9rtices, enquanto\na malha refinada possui ne = 32768 elementos com nv = 16641. Os sistemas lineares\nrespectivos possuem 81 e 16641 vari\u00e1veis.\n\nO erro de representa\u00e7\u00e3o \u00e9 calculado atrav\u00e9s da diferen\u00e7a entre as fun\u00e7\u00f5es, ou seja,\nE = Erro = f(x,y) ?fL2 (x,y), em que f \u00e9 a representa\u00e7\u00e3o da fun\u00e7\u00e3o anal\u00edtica em malha\nrefinada e fL2 \u00e9 a proje\u00e7\u00e3o L2.\n\n3. O m\u00e9todo adotado \u00e9 a fatora\u00e7\u00e3o LU, o qual esta dispon\u00edvel na biblioteca num\u00e9rica dolfin/FEniCS\n\n\n\n100 Cap\u00edtulo 5. Resultados\n\n(a) fL2 : a proje\u00e7\u00e3o L2 da fun\u00e7\u00e3o f(x,y) = 1 + x2 + y2\n\n(b) Erro(E), E = |f(x,y) ?fL2|\n\nFigura 25 \u2013 A fL2 e o erro de representa\u00e7\u00e3o da fun\u00e7\u00e3o f pela fun\u00e7\u00e3o fL2\n\nEsse exemplo fornece a proje\u00e7\u00e3o L2 da fun\u00e7\u00e3o f, obtida por meio do m\u00e9todo da\n\n\n\n5.2. Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados 101\n\nfatora\u00e7\u00e3o LU 4. Nesse caso, o sistema linear inicial possui n = 81 vari\u00e1veis enquanto o\nsistema associado \u00e0 malha refinada possui 16641 vari\u00e1veis. Para dom\u00ednios grandes ou\nprocessos de refinamento adaptativo, o crescimento do n\u00famero de vari\u00e1veis pode inviabilizar\na utiliza\u00e7\u00e3o de alguns m\u00e9todos num\u00e9ricos diretos ou iterativos. Para tornar poss\u00edvel a\nutiliza\u00e7\u00e3o de outros m\u00e9todos num\u00e9ricos, \u00e9 necess\u00e1rio disponibilizar a matriz A e o vetor b.\n\nConsiderando a utiliza\u00e7\u00e3o da biblioteca PyAMG (BELL; OLSON; SCHRODER,\n2011), a fun\u00e7\u00e3o Python projectionFunction(kargs**), descrita no ap\u00eandice [A.1], re-\ntorna o sistema linear definido pelas formas bilineares a e L 5. Isso facilita a utiliza\u00e7\u00e3o de\noutros m\u00e9todos num\u00e9ricos para a solu\u00e7\u00e3o do sistema linear associado a proje\u00e7\u00e3o L2.\n\nA pr\u00f3xima se\u00e7\u00e3o considera a constru\u00e7\u00e3o de malhas adequadas \u00e0 representa\u00e7\u00e3o da\ncondi\u00e7\u00e3o inicial C0 = C(x,y, 0) e do termo de fonte f.\n\n5.2 Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados\n\nEsta se\u00e7\u00e3o descreve duas aplica\u00e7\u00f5es da t\u00e9cnica adaptativa, baseada nas componentes\n?f e ||C0 ? ?C0||L2(?) do estimador residual, para os dados do problema do transporte\nde contaminantes. O primeiro exemplo considera a utiliza\u00e7\u00e3o da estimativa residual da\ncondi\u00e7\u00e3o inicial, ou seja, a malha retornada \u00e9 adequada \u00e0 representa\u00e7\u00e3o da condi\u00e7\u00e3o\ninicial do problema. O segundo exemplo considera a estimativa ?f para gerar uma malha\nadequada \u00e0 representa\u00e7\u00e3o do termo de fonte.\n\n5.2.1 Exemplo 03: Malha adequada \u00e0 Condi\u00e7\u00e3o Inicial\n\nEste exemplo considera uma modifica\u00e7\u00e3o do problema apresentado na se\u00e7\u00e3o [5.1.2]\nde modo que as condi\u00e7\u00e3o (P1) seja satisfeita. Consequentemente, as condi\u00e7\u00f5es (P1)-(P4?)\ns\u00e3o satisfeitas e o estimador residual de Praetorius, Weinmuller e Wissgott (2008) pode\nser utilizado.\n\nConsidere um dom\u00ednio retangular ? = [x0,x1] \u00d7 [y0,y1] = [0, 20] \u00d7 [0, 20] com campo\nde velocidade vari\u00e1vel v e matriz de dispers\u00e3o D = D(x,y). Sejam u0 = 0.5, D0 = 2.0\nconstantes e defina o campo de velocidades por v = (vx,vy) = (u0(x + 1.0),?u0(y + 1)).\nAl\u00e9m disso, considere que os coeficientes da matriz de dispers\u00e3o s\u00e3o dados por d11 =\nd11(x,y) = D0u20(x + 1)2, d12(x,y) = d21(x,y) = 0 e d22 = d22(x,y) = D0u20(y + 1)2.\n\n4. Dispon\u00edvel em FEniCS (FENICS PROJECT, 2014)\n5. Associadas \u00e0 proje\u00e7\u00e3o L2\n\n\n\n102 Cap\u00edtulo 5. Resultados\n\nAdicionalmente, considere que a condi\u00e7\u00e3o inicial \u00e9\n\nC0(x,y,t0 = 0)\nCC0\n\n= exp\n(\n?\n\n(x?\u00b51)\n2\n\n2?21\n?\n\n(y ?\u00b52)\n2\n\n2?22\n\n)\n, (5.8)\n\nonde \u00b51 = 5.0,\u00b52 = 5.0,?21 = ?22 = 0.5 e CC0 \u00e9 uma constante.\n\nNeste caso, os dados n\u00e3o s\u00e3o constantes, e uma representa\u00e7\u00e3o adequada deve ser\nconstru\u00edda. Aqui, em vez de adotar uma malha uniforme conforme adotado na se\u00e7\u00e3o [5.1.2],\na fun\u00e7\u00e3o RefineMesh_for_InitCond(kargs**), baseada na estimativa residual para a\ncondi\u00e7\u00e3o inicial ||C0 ??C0||2L2(?), \u00e9 utilizada para a constru\u00e7\u00e3o de uma malha adequada\naos dados do problema do transporte. Adicionalmente, essa fun\u00e7\u00e3o \u00e9 utilizada para dxx,\ndyy, carga hidr\u00e1ulica H := u0/2 \u00b7 (x + 1.0)2 ?u0/2 \u00b7 (y + 1.0)2, vx,vy e C0.\n\nAs figuras (26), (27) e (28) mostram a malha grossa T ?0 fornecida pelo usu\u00e1rio, a\nmalha gerada pela aplica\u00e7\u00e3o do processo adaptativo e a solu\u00e7\u00e3o num\u00e9rica em malha\nadaptada.\n\nFigura 26 \u2013 Malha T ?0 fornecida pelo usu\u00e1rio antes do processo adaptativo\n\n\n\n5.2. Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados 103\n\nFigura 27 \u2013 Malha T0 adequada aos dados gerada pelo procedimento adaptativo\n\nFigura 28 \u2013 Solu\u00e7\u00e3o num\u00e9rica em malha adequada \u00e0 representa\u00e7\u00e3o dos dados\n\nA malha adequada T0 aos dados, de acordo com o crit\u00e9rio de parada estabele-\ncido, \u00e9 composta de Nv = 4381 v\u00e9rtices com Nv = 8504 elementos. Essa malha \u00e9\n\n\n\n104 Cap\u00edtulo 5. Resultados\n\ntal que ||X ? ?X||L2 &lt;toler = 0.25, em que X refere-se \u00e0 dxx,dyy, f, vx, vy, carga\nhidr\u00e1ulica H e ||C0 ??C0|| &lt;0.01, respectivamente. Os demais par\u00e2metros para a fun\u00e7\u00e3o\nRefineMesh_for_InitCond(kargs**) s\u00e3o fraction = 0.5, Degree = 1 e RaiseDegree =\n1. A solu\u00e7\u00e3o num\u00e9rica, apresentada na figura (28), considera uma malha T2, a qual \u00e9\nobtida atrav\u00e9s de um refinamento uniforme da malha adaptada aos dados T1, fun\u00e7\u00f5es\nlagrangeanas lineares, ? = 1.0, ?n = 0.001d e tfinal = 0.1d.\n\nOs resultados em malha T2 s\u00e3o comparados \u00e0queles obtidos em uma malha uniforme\ndefinida por nx = ny = 200 elementos em cada dire\u00e7\u00e3o coordenada com orienta\u00e7\u00e3o\nleft/right e par\u00e2metros id\u00eanticos. A malha uniforme possui Nv = 40401 v\u00e9rtices e\nNe = 80000 elementos, enquanto que a malha T2 possui Nv = 17265 v\u00e9rtices e Ne = 34016\nelementos. Essa compara\u00e7\u00e3o \u00e9 feita atrav\u00e9s da proje\u00e7\u00e3o dos resultados em malha T2 sobre\na malha uniforme.\n\nDenotando CT2 a solu\u00e7\u00e3o num\u00e9rica na malha T2, CUniforme a solu\u00e7\u00e3o num\u00e9rica em\nmalha uniforme e CProjetada a proje\u00e7\u00e3o da solu\u00e7\u00e3o CT2 sobre a malha uniforme. A an\u00e1lise dos\nresultados mostra que a m\u00e1xima diferen\u00e7a entre as solu\u00e7\u00f5es \u00e9 |CT1?CUniforme| = 0.0009352.\nAl\u00e9m disso, os valores m\u00e1ximos das concentra\u00e7\u00f5es nas malhas T1 e uniforme s\u00e3o produzidos\nno ponto (5.0, 4.4).\n\nA an\u00e1lise dos resultados mostra que a malha adaptada fornece resultados simi-\nlares \u00e0queles fornecidos pela malha uniforme. No entanto, a quantidade de elementos e,\nconsequentemente, o tamanho do sistema linear \u00e9 reduzido.\n\n5.2.1.1 Discuss\u00e3o sobre as estimativas residuais\n\nNesse caso, as condi\u00e7\u00f5es (P1)-(P4) e (P1)-(P4*) s\u00e3o satisfeitas. Logo, o estimador\nresidual pode incorporar todos os termos apresentados na express\u00e3o (4.37). Essa estimativa\npode ser simplificada, pois:\n\ni. a representa\u00e7\u00e3o da condi\u00e7\u00e3o de Neumann, dada numericamente por g = n \u00b7 D?(C),\npossui representa\u00e7\u00e3o exata e, portanto, ?N = 0.\n\nii. a equa\u00e7\u00e3o do transporte n\u00e3o possui termo de fonte e, portanto, ?f = 0\n\niii. o regime \u00e9 de advec\u00e7\u00e3o dominante pois ? = 0.5, ? = 220.5/0.5 = 441, ? = 0 e\nCc = max(|v|)/? = ((u0(20 + 1))2 + (?u0(20 + 1))2)1/2/? ? 29.7.\n\niv. os dados n\u00e3o possuem depend\u00eancia espacial, ou seja, f?(t) = 0,D?(t) = 0, ??(t) = 0 e\nv? = 0.\n\nv. devido \u00e0s considera\u00e7\u00f5es [iii.] e [iv.], a estimativa temporal \u00e9 dada por:\n\n\n\n5.2. Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados 105\n\n(\n?(n)?\n\n)2\n= |||Cn ?Cn?1|||2 + |||v \u00b7?(Cn ?Cn?1)|||?+\n\n= |||Cn ?Cn?1|||2 + |||Cn ?Cn?1|||2 +\n(\n??(n)\n\n)2\n+ |||C?n|||2+\n\n(1 + ?)2?n\n[? tn\n\ntn?1\n?g?(t)?N?\n\n2dt\n\n]\n? |||Cn ?Cn?1|||2 +\n\n(\n??(n)\n\n)2\n+ |||C?n|||2 (5.9)\n\nem que a \u00faltima simplifica\u00e7\u00e3o considera que g?(t) ? 0. Essa considera\u00e7\u00e3o \u00e9 baseada no\nseguinte argumento:\n\ng?(t) ?\ng(tn) ?g(tn?1)\n\n?n\n=\n\nn \u00b7Dn?(Cn) ?n \u00b7Dn?1?(Cn?1)\n?n\n\n=\n\nn \u00b7D?(Cn ?Cn?1)\n?n\n\n? 0 (5.10)\n\nDessa forma, a express\u00e3o (4.37) pode ser reescrita como:\n\n(?I) =\n\n??\n??C0 ??C0?2L2(?)+\n\nNI?\ni=1\n\n?n\n\n[(\n?(n)\n\n)2\n+\n(\n?(n)\n\n)2\n+\n(\n?(n)?\n\n)2]???\n1/2\n\n.\n\n(5.11)\n\nEsse estimador \u00e9 mais geral do que o estimador de Verf\u00fcrth (2004) no sentido que\npode englob\u00e1-lo. Esses resultados s\u00e3o obtidos por meio de convenientes modifica\u00e7\u00f5es das\nclasses e fun\u00e7\u00f5es provenientes das estimativas em dispers\u00e3o dominante.\n\nOs avan\u00e7os computacionais em rela\u00e7\u00e3o aos resultados apresentados em Praetorius,\nWeinmuller e Wissgott (2008) residem na facilidade de implementa\u00e7\u00e3o das estimativas, na\nconsidera\u00e7\u00e3o de problemas envolvendo dados n\u00e3o constantes, na utiliza\u00e7\u00e3o de fun\u00e7\u00f5es de\nordem superior e no procedimento computacional para a estimativa das constantes ? e ?.\nNo entanto, o processo de refinamento n\u00e3o \u00e9 considerado aqui.\n\nAs figuras (29, 30) e (31, 32) apresentam os indicadores espacial, do elemento, do\nsalto e da fronteiras de Neumann em cada elemento no dom\u00ednio computacional na malha\nadaptada. Essas quantidades fornecem valores que possibilitam avaliar a regi\u00e3o que ainda\nnecessita refinamento.\n\nOs indicadores espaciais capturam o comportamento da fun\u00e7\u00e3o de distribui\u00e7\u00e3o de\nconcentra\u00e7\u00f5es. Devido \u00e0s magnitudes envolvidas nos indicadores residuais, um procedimento\nadaptativo pode ser utilizado para melhorar a qualidade da solu\u00e7\u00e3o num\u00e9rica nesse passo\nde tempo. Esse procedimento faz parte de um algoritmo adaptativo geral, o qual n\u00e3o \u00e9\ndiscutido nessa tese. No entanto, a utiliza\u00e7\u00e3o de uma malha inicial adequada \u00e0 representa\u00e7\u00e3o\ndos dados favorece a aplica\u00e7\u00e3o de um algoritmo adaptativo geral, pois reduz a quantidade\nde elementos necess\u00e1rios \u00e0 adequada representa\u00e7\u00e3o dos dados.\n\n\n\n106 Cap\u00edtulo 5. Resultados\n\nFigura 29 \u2013 O indicador espacial ?K em cada elemento da malha refinada no 1000-\u00e9simo instante\nde tempo\n\nFigura 30 \u2013 O indicador do elemento ?1K em cada elemento da malha refinada no 1000-\u00e9simo\ninstante de tempo\n\n\n\n5.2. Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados 107\n\nFigura 31 \u2013 O indicador do salto ?2E em cada elemento da malha refinada no 1000-\u00e9simo instante\nde tempo\n\nFigura 32 \u2013 O indicador temporal ??1000 em cada elemento da malha refinada\n\n\n\n108 Cap\u00edtulo 5. Resultados\n\n5.2.2 Exemplo 04: Malha adequada \u00e0 representa\u00e7\u00e3o da fun\u00e7\u00e3o de fonte\n\nO objetivo desta parte \u00e9 exemplificar a utiliza\u00e7\u00e3o do algoritmo adaptativo baseado\nna estimativa residual da fun\u00e7\u00e3o f.\n\nConsidere um dom\u00ednio retangular ? = [x0,x1] \u00d7 [y0,y1] = [0, 1000] \u00d7 [0, 1000] com\ncampo de velocidade vari\u00e1vel v e matriz de dispers\u00e3o D = D(x,y). Sejam u0, D0 constantes\ne defina o campo de velocidades por v = (vx,vy) = (ax + b1,?ay + b2). Considere que os\ncoeficientes da matriz de dispers\u00e3o s\u00e3o dependentes do espa\u00e7o e definidos por\n\ndxx = d11(x,y) = D0 + EpL\nv2x\n|v|\n\n+ EpTh\nv2y)\n|v|\n\ndyy = d11(x,y) = D0 + EpL\nv2y\n|v|\n\n+ EpTh\nv2x)\n|v|\n\ndxy(x,y) = dyx(x,y) = D0 + (EpL ?EpTh)\nvxvy\n|v|\n\n(5.12)\n\nem que D0, EpL, EpT s\u00e3o constantes (BEAR, 1979).\n\nA condi\u00e7\u00e3o de Dirichlet \u00e9 definida em ?D = {x0}?{y0,y1}, por f?D(x0,y) = C?D =\n0.0, enquanto que a condi\u00e7\u00e3o de Neumann \u00e9 definida nas demais fronteiras. Adicionalmente,\nconsidere que o termo de fonte \u00e9 dado por uma fun\u00e7\u00e3o exponencial bidimensional definida\npor\n\nf(x,y) = Cf0 exp\n(\n?\n\n(x?\u00b51)\n2\n\n2?21\n?\n\n(y ?\u00b52)\n2\n\n2?22\n\n)\n(5.13)\n\nonde Cf0 = 1.0,\n\nNesse problema, \u00e9 considerado que a malha inicial possui nx = ny = 2 elementos\ntriangulares nas dire\u00e7\u00f5es coordenadas com orienta\u00e7\u00e3o left/right, EpL = 10.0, EpTH =\n1.40,D0 = 0.0, ? = 0.280, ? = 5.83, ? = 0.0 6, a = 0.003, b1 = 0.2 e b2 = 0.0.\n\nAnalogamente ao caso anterior, a representa\u00e7\u00e3o dos dados n\u00e3o \u00e9 adequada e uma\nmalha refinada precisa ser obtida. Na realidade, a malha inicial \u00e9 inadequada para todos os\nprop\u00f3sitos de aproxima\u00e7\u00e3o pelo m\u00e9todo de elementos finitos. No entanto, o esquema adap-\ntativo consegue produzir uma malha refinada adequada aos dados baseado na estimativa\nresidual da fun\u00e7\u00e3o f.\n\nA fun\u00e7\u00e3o RefineMeshForFfunction(kargs**) implementa o esquema adaptativo\nbaseado na estimativa residual para o termo de fonte. Os resultados das figuras (33-\na,b) mostram a malha inicial T ?0 e a malha refinada, obtida por aplica\u00e7\u00f5es sucessivas\nprocedimento adaptativo aos dados do problema.\n\n6. O c\u00e1lculo dos valores ? , ? e ? \u00e9 discutido em detalhes em [4.5.2]\n\n\n\n5.2. Malhas adequadas \u00e0 representa\u00e7\u00e3o dos dados 109\n\n(a) Malha inicial T ?0 fornecida pelo usu\u00e1rio\n\n(b) Malha gerada pelo procedimento adaptativo\n\nFigura 33 \u2013 Malha inicial T ?0 e malha adaptada adequada aos dados dxx, dxy = dyx, dyy, f?D, f.\n\nAs figuras (34-a,b) mostram a dispers\u00e3o dyy, a fun\u00e7\u00e3o que define a fronteira de\nDirichlet f?D e o termo de fonte f em malha adaptada.\n\n\n\n110 Cap\u00edtulo 5. Resultados\n\n(a) A dispers\u00e3o dyy em malha adaptada\n\n(b) A condi\u00e7\u00e3o de Dirichlet e termo de fonte em malha adaptada\n\nFigura 34 \u2013 A representa\u00e7\u00e3o, em malha adaptada, das fun\u00e7\u00f5es dyy, da condi\u00e7\u00e3o de Dirichlet f?D\ne do termo de fonte f(x,y).\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 111\n\nA malha inicial T ?0 possui ne = 08 elementos triangulares com nv = 09 v\u00e9rtices\ne a malha adaptada possui ne = elementos triangulares com nv = v\u00e9rtices. A malha\nadaptada \u00e9 tal que ?f &lt;toler = 1.0, em que X refere-se \u00e0 dxx, dyy, dxy = dyx, f?D e f.\nOs demais par\u00e2metros para a fun\u00e7\u00e3o RefineMeshForFfunction s\u00e3o maxIterF = 1000,\ntoleranceF = 1.0, fractionF = 0.5, degree = 1, raiseDegree = 1 e dt1 = 1.0.\n\nAnalogamente ao caso anterior, para comprovar a adequa\u00e7\u00e3o da malha adaptada,\numa malha uniforme com nx = ny = 400 elementos em cada dire\u00e7\u00e3o coordenada e mesma\norienta\u00e7\u00e3o da malha inicial \u00e9 utilizada. A malha uniforme possui ne = 320000 elementos\ntriangulares com nv = 160801 v\u00e9rtices e \u00e9 considerada adequada para a representa\u00e7\u00e3o\nanal\u00edtica de cada um dos dados da equa\u00e7\u00e3o. Os dados, na malha inicial e adaptada, s\u00e3o\nent\u00e3o projetados na malha uniforme e as diferen\u00e7as entre esses resultados fornecem os\nerros reais de representa\u00e7\u00e3o Edxx, Edyy, Edxy = Edyx, Ef?D e Ef em cada ponto do dom\u00ednio\ncomputacional. Matematicamente, essas diferen\u00e7as s\u00e3o definidas por:\n\nE0XX = |XX\ninicial ?XXanal?\u00edtica|, E1XX = |XX\n\nadaptada ?XXanal?\u00edtica|, (5.14)\n\nonde XX denota dxx,dyy,dxy,dyx,f ou f?D, XXanal?itica \u00e9 a representa\u00e7\u00e3o anal\u00edtica de XX\ne XXadaptada denota a utiliza\u00e7\u00e3o da malha adaptada.\n\nA an\u00e1lise dos resultados fornece max(E0dxx) = 0.4439, max(E\n1\ndxx\n\n) = 0.0022, max(E0dxy) =\nmax(E0dyx) = 1.2332, max(E\n\n1\ndxy\n\n) = max(E1dyx) = 0.0020, max(E\n0\ndyy\n\n) = 1.2190, max(E1dyy) =\n0.0068, max(E0f?D ) = 0.9949, max(E\n\n1\n?D) = 0.0030,max(E\n\n0\nf ) = 0.7829 e max(E1f ) = 0.0035.\n\nNovamente, o esquema adaptativo produz uma malha adequada \u00e0 representa\u00e7\u00e3o dos\ndados. Em todos os casos, o erro produzido pelo procedimento adaptativo \u00e9 menor que o\nerro associado \u00e0 malha inicial.\n\n5.3 M\u00e9todos Multigrid Acelerados\n\nEsta se\u00e7\u00e3o considera o tempo gasto na solu\u00e7\u00e3o do sistema linear associado \u00e0 aproxi-\nma\u00e7\u00e3o da equa\u00e7\u00e3o do transporte de contaminantes. Cada exemplo considera tr\u00eas m\u00e9todos\niterativos para a solu\u00e7\u00e3o do sistema linear associado. O primeiro \u00e9 o m\u00e9todo padr\u00e3o 7,\nenquanto que o segundo e terceiro s\u00e3o os m\u00e9todos otimizados, os quais reutilizam as estru-\nturas multigrid para acelerar o processo de solu\u00e7\u00e3o. A compara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9ricas,\no c\u00e1lculo do tempo computacional e o c\u00e1lculo do tempo total seguem a metodologia\ndescrita no cap\u00edtulo de metodologia [4].\n\nOs exemplos apresentados consideram tanto os m\u00e9todos multigrid alg\u00e9bricos quanto\nos m\u00e9todos n\u00e3o estacion\u00e1rios pr\u00e9-condicionados por multigrid.\n\n7. M\u00e9todo padr\u00e3o refere-se ao m\u00e9todo cuja estrutura hier\u00e1rquica ser\u00e1 reutilizada\n\n\n\n112 Cap\u00edtulo 5. Resultados\n\n5.3.1 BICGSTAB Pr\u00e9-Condicionado SA\n\nConsidere o problema do transporte de contaminantes em um dom\u00ednio retangular\n? = [x0,x1]\u00d7[y0,y1] com fonte de contaminante no interior do dom\u00ednio computacional. Esse\nproblema \u00e9 uma adapta\u00e7\u00e3o de Hofinger e Judex (2005) e considera o dom\u00ednio computacional\n? = [x0,x1] \u00d7 [y0,y1] = [0, 80] \u00d7 [0, 40]m2, e a fonte de contaminantes\n\nf(x,y)\nf0\n\n= exp\n(\n?\n\n1\n2\n\n(x?\u00b51)2\n?21\n\n?\n1\n2\n\n(y ?\u00b52)2\n?22\n\n)\n, (5.15)\n\nonde \u00b51 = 10.0,\u00b52 = 2.0,?21 = ?22 = 2.0 e f0 \u00e9 constante para normaliza\u00e7\u00e3o; (iii) a\nfronteira de Neumann definida em ?N = {x1}\u00d7 (y0,y1) por g = n \u00b7D?C; (iv) a fronteira\nde Dirichlet definida em ?D = {x0}\u00d7 (y0,y1) ?{y0}\u00d7 (x0,x1) ?{y1}\u00d7 (x0,x1) por C = 0;\n(v) a condi\u00e7\u00e3o inicial \u00e9 dada por C0 = C(x,y,t0) = 0.0. A difusividade, o campo de\nvelocidades e matriz de dispers\u00e3o s\u00e3o, respectivamente, ?D = 0.05m, v = (vx = 0.864,vy =\n0.0)m\n\nd\ne D = ?DvxI2\u00d72, em que I2\u00d72 \u00e9 a matriz identidade.\n\nA figura (35) ilustra o dom\u00ednio computacional, as curvas de n\u00edvel para o termo de\nfonte, o campo de velocidades e as condi\u00e7\u00f5es de Dirichlet e Neumann.\n\nFigura 35 \u2013 O dom\u00ednio computacional, as curvas de n\u00edvel do termo de fonte, o campo de veloci-\ndades e as condi\u00e7\u00f5es de Dirichlet e Neumann\n\nA figura (36) apresenta a solu\u00e7\u00e3o num\u00e9rica, obtida pelo m\u00e9todo BICGSTAB pr\u00e9-\ncondicionado pelo m\u00e9todo SA sem reutiliza\u00e7\u00e3o, para uma malha com nx = 2ny = 200\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 113\n\nelementos triangulares, ? = 1/2, fun\u00e7\u00f5es lagrangeanas lineares, ?n = 0.5d, tfinal = 60d.\nEsse resultado mostra a distribui\u00e7\u00e3o de concentra\u00e7\u00f5es, C120 = C(x,y,t120), que fornece a\nconcentra\u00e7\u00e3o em cada ponto do dom\u00ednio computacional no instante de tempo n = 120.\nA avalia\u00e7\u00e3o mais detalhada do avan\u00e7o da frente de contamina\u00e7\u00e3o pode ser visualizada\natrav\u00e9s das curvas de n\u00edvel, apresentadas na figura (37).\n\nFigura 36 \u2013 A solu\u00e7\u00e3o num\u00e9rica em malha estruturada com fun\u00e7\u00f5es lagrangeanas lineares\n\nFigura 37 \u2013 As curvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica apresentada na figura (36)\n\n\n\n114 Cap\u00edtulo 5. Resultados\n\nNos pr\u00f3ximos resultados, a solu\u00e7\u00e3o num\u00e9rica \u00e9 calculada pelo m\u00e9todo do Gradi-\nente Bi-Conjugado Estabilizado (BICGSTAB) pr\u00e9-condicionado por SA, SA ? Reu\ne SA ? ReuAuto. De forma simplificada, denota-se esses m\u00e9todos por BICGSTABSA,\nBICGSTABSAReu e BICGSTABSAReuAuto.\n\n5.3.1.1 Malha Estruturada\n\nO exemplo considera uma malha triangular uniforme com 2ny = nx = 1600 elementos\nem cada dire\u00e7\u00e3o coordenada e orienta\u00e7\u00e3o left /right (FENICS PROJECT, 2014). A malha\ntem Nv = 1282401 v\u00e9rtices e Ne = 2560000 elementos triangulares. A aproxima\u00e7\u00e3o de\nelementos finitos considera: i. passo de tempo fixo ?n = ? = 0.500d; ii. tempo final de\nsimula\u00e7\u00e3o tfinal = 20.0d; iii. par\u00e2metro de discretiza\u00e7\u00e3o temporal ? = 1.0/2.0; iv. Fun\u00e7\u00f5es\nlagrangeanas lineares.\n\nNesse caso, os seguintes par\u00e2metros para o m\u00e9todo multigrid alg\u00e9brico SA, passados\nvia dicion\u00e1rio de par\u00e2metros, foram utilizados.\n\n1 config=solver_configuration(Asp,verb=True)\nconfig [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\n\n3 config [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\nconfig [ \u2019smooth\u2019] =(None,{\u2019gauss_seidel\u2019},{\u2019iterations \u2019 :2})\n\n5 config [ \u2019strength\u2019 ] = [(\u2019 classical \u2019,{\u2019theta\u2019 :0.1}) ,( \u2019 classical \u2019,{\u2019theta\u2019 :0.1}) ]\nconfig [ \u2019max_levels\u2019]=(max_levels)\n\n7 config [ \u2019max_coarse\u2019]=(10000)\nconfig [ \u2019coarse_solver\u2019]=(\u2019gauss_seidel\u2019)\n\n9 config [ \u2019aggregate\u2019]=(\u2019standard\u2019)\nconfig [ \u2019presmoother\u2019] = (\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :1})\n\n11 config [ \u2019postsmoother\u2019] = (\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :3})\nconfig [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.0000000001e?8})\n\n13 config [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019: \u2019symmetric\u2019,\u2019 iterations \u2019 :0}) ,None]\nconfig [ \u2019diagonal_dominance\u2019]=(False)\n\n15 config [ \u2019keep\u2019] =(False)\n\nA compara\u00e7\u00e3o da solu\u00e7\u00f5es fornece que DiffnSAReu/SA = 0 e Diff\nn\nSAReuAuto/SA = 0,\n\npara todos os passos de tempo n ? {1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}. Como consequ\u00eancia direta, os\nm\u00e9todos modificados produzem as mesmas solu\u00e7\u00f5es que o m\u00e9todo padr\u00e3o.\n\nOs resultados envolvendo os res\u00edduos da solu\u00e7\u00e3o e os res\u00edduos associados a cada\nitera\u00e7\u00e3o do m\u00e9todo multigrid s\u00e3o apresentados nas figuras (38-a,b,c,d). A figura (38-a)\napresenta a norma l2 do res\u00edduo, o res\u00edduo m\u00e1ximo e o res\u00edduo m\u00e9dio da solu\u00e7\u00e3o num\u00e9rica\nem cada passo de tempo e mostra que o m\u00e9todo iterativo fornece um res\u00edduo adequado.\nA figura (38-b) apresenta a norma l2 do res\u00edduo reskn em cada passo de tempo n e em\ncada itera\u00e7\u00e3o k do m\u00e9todo multigrid. A redu\u00e7\u00e3o do res\u00edduo a cada itera\u00e7\u00e3o do m\u00e9todo\nmultigrid, ou seja, a sequ\u00eancia de valores res0n,res1n, \u00b7 \u00b7 \u00b7 pode ser analisada para todos os\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 115\n\npassos de tempo. Nesse caso, verifica-se que tanto o m\u00e9todo padr\u00e3o quanto os m\u00e9todos\notimizados produzem a mesma redu\u00e7\u00e3o do res\u00edduo.\n\nA figura (38-c) mostra a redu\u00e7\u00e3o relativa do res\u00edduo, ou seja, as sequ\u00eancias\nres1n/res\n\n1\nn,res\n\n2\nn/res\n\n1\nn,res\n\n3\nn/res\n\n1\nn, . . .. Nesse caso, a redu\u00e7\u00e3o do res\u00edduo \u00e9 aproximadamente\n\nconstante em todos os passos da simula\u00e7\u00e3o. Esse fato fica evidenciado pela an\u00e1lise de algu-\nmas sequ\u00eancias de res\u00edduos relativos, apresentadas na figura (38-d). Ambos os resultados\nfornecem uma justificativa para efici\u00eancia dos m\u00e9todos acelerados.\n\n(a) Norma l2 do res\u00edduo, res\u00edduo m\u00e1ximo e m\u00e9dia do\nres\u00edduo da solu\u00e7\u00e3o para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}\n\n(b) Res\u00edduo em cada itera\u00e7\u00e3o do m\u00e9todo multigrid para\ntodo passo de tempo n\n\n(c) Res\u00edduo relativo em cada itera\u00e7\u00e3o do m\u00e9todo\nmultigrid para todo passo de tempo n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}\n\n(d) reskn/res0n para n = 1, 10, 20, 30, 40\n\nFigura 38 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica\n\nO tempo computacional ?tn e o tempo total Tan para os m\u00e9todos BICGSTABSA,\nBICGSTABSAReu e BICGSTABSAReuAuto s\u00e3o apresentados nas figuras (39-a) e (39-b),\nrespectivamente. A an\u00e1lise dos resultados mostra que a reutiliza\u00e7\u00e3o das estruturas \u00e9 uma\nestrat\u00e9gia efetiva para reduzir o tempo total, o qual \u00e9 uma consequ\u00eancia da redu\u00e7\u00e3o do\ntempo computacional.\n\n\n\n116 Cap\u00edtulo 5. Resultados\n\n(a) Tempo ?tn no passo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40} (b) Tempo total Tan at\u00e9 o n\u00e9simo passo de tempo n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}\n\nFigura 39 \u2013 O tempo computacional e o tempo total para os sistemas lineares com com Nv =\n1282401 vari\u00e1veis\n\n5.3.1.2 Malha n\u00e3o estruturada\n\nEsse exemplo considera uma malha n\u00e3o estruturada com Nv = 1326721 v\u00e9rtices\ne Ne = 2649088 elementos triangulares, os quais foram obtidos de uma malha inicial\ncom l = 1.25 e quatro refinamentos uniformes e sucessivos. A aproxima\u00e7\u00e3o de elementos\nfinitos considera: i. passo de tempo fixo ?n = ? = 0.25d; ii. tempo final tstop = 10.0d; iii.\npar\u00e2metro de discretiza\u00e7\u00e3o ? = 1.0/2.0; iv. Fun\u00e7\u00f5es lagrangeanas lineares.\n\nOs seguintes par\u00e2metros para o m\u00e9todo multigrid foram utilizados.\n\n1 config=solver_configuration(Asp,verb=True)\nconfig [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\n\n3 config [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\nconfig [ \u2019smooth\u2019] =(None,{\u2019krylov\u2019:\u2019gmres\u2019,\u2019maxiter\u2019:3, \u2019degree\u2019 :1,\\\n\n5 \u2019weighting\u2019: \u2019 local \u2019},{\u2019 iterations \u2019 :2})\nconfig [ \u2019strength\u2019 ] = [(\u2019 classical \u2019,{\u2019theta\u2019 :0.2}) ,( \u2019 classical \u2019,\\\n\n7 {\u2019theta\u2019 :0.2}) ]\nconfig [ \u2019max_levels\u2019]=(max_levels); config[\u2019max_coarse\u2019]=(10000)\n\n9 config [ \u2019coarse_solver\u2019]=(\u2019gauss_seidel\u2019)\nconfig [ \u2019aggregate\u2019]=(\u2019standard\u2019)\n\n11 config [ \u2019presmoother\u2019] = (\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\nconfig [ \u2019postsmoother\u2019] = (\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\n13 config [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.0000000001e?8})\nconfig [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019: \u2019symmetric\u2019,\\\n\n15 \u2019 iterations \u2019 :0}) ,None]\nconfig [ \u2019diagonal_dominance\u2019]=(True)\n\n17 config [ \u2019keep\u2019] =(False)\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 117\n\nA compara\u00e7\u00e3o da solu\u00e7\u00f5es fornece que DiffnSAReu/SA = 0 e Diff\nn\nSAReuAuto/SA = 0,\n\npara todos os passos de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}. Os resultados envolvendo os res\u00edduos\nda solu\u00e7\u00e3o e os res\u00edduos de cada itera\u00e7\u00e3o do m\u00e9todo multigrid s\u00e3o apresentados nas figuras\n(40-a,b,c,d).\n\n(a) Norma l2 do res\u00edduo, res\u00edduo m\u00e1ximo e m\u00e9dia do\nres\u00edduo da solu\u00e7\u00e3o para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}\n\n(b) Res\u00edduos em cada itera\u00e7\u00e3o do m\u00e9todo multigrid\npara todo passo de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}\n\n(c) Res\u00edduos relativos em cada itera\u00e7\u00e3o do m\u00e9todo\nmultigrid para todo passo de tempo n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 40}\n\n(d) reskn/res0n para n = 1, 10, 20, 30, 40\n\nFigura 40 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica\n\nO tempo computacional ?tn e o tempo total Tan s\u00e3o apresentados nas figuras (41-\na,b), respectivamente. Analogamente ao caso anterior, a an\u00e1lise dos resultados mostra que a\nreutiliza\u00e7\u00e3o das estruturas \u00e9 uma estrat\u00e9gia efetiva para reduzir o tempo computacional e o\ntempo total. O m\u00e9todo autom\u00e1tico \u00e9 mais efetivo, pois realiza menos agrega\u00e7\u00f5es e c\u00e1lculos\ndos operadores de transfer\u00eancia de resultados. Nesse caso, o tempo computacional de ambas\nas estrat\u00e9gias, SAReu e SAReuAuto, representam 385/496 = 0.7762 e 382.6/496 = 0.7714\ndo tempo total do m\u00e9todo padr\u00e3o SA. Novamente, essa \u00e9 uma diferen\u00e7a significante para\numa classe de m\u00e9todos que \u00e9 considerado escal\u00e1vel.\n\n\n\n118 Cap\u00edtulo 5. Resultados\n\n(a) Tempo ?tn para resolver o sistema linear em cda\npasso de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(b) Tempo total Tan =\n?n\n\ni=1 ?Ti at\u00e9 o n\u00e9simo passo\nde tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\nFigura 41 \u2013 Os tempos computacional e total para sistema linear com Nv = 1326721 vari\u00e1veis\n\n5.3.2 Multigrid Alg\u00e9brico SA e GMRES Pr\u00e9-Condicionado por SA\n\nNesta se\u00e7\u00e3o, os m\u00e9todos SA, SAReu e SAReuAuto s\u00e3o usados para calcular a solu\u00e7\u00e3o\nnum\u00e9rica em malha estruturada, enquanto que o m\u00e9todo GMRES pr\u00e9-condicionado por\nSA, SAReu e SAReuAuto s\u00e3o usados para o problema em malha n\u00e3o estruturada. Sim-\nplificadamente, denota-se os m\u00e9todos pr\u00e9-condicionados por GMRESSA, GMRESSAReu\ne GMRESSAReuAuto.\n\nEsta se\u00e7\u00e3o considera uma adapta\u00e7\u00e3o do problema apresentado em Zoppou e Knight\n(1999). O transporte de contaminantes \u00e9 definido em um dom\u00ednio bidimensional retangular\n? = [x0,x1] \u00d7 [y0,y1] = [0, 20.0] \u00d7 [0, 20.0] com um campo vari\u00e1vel de velocidades v e uma\nmatriz de dispers\u00e3o com depend\u00eancia espacial D = D(x,y).\n\nConsidere que u0, D0 s\u00e3o constantes e defina o campo de velocidades por v =\n(vx,vy) = (u0(x + 1.0),?u0(y + 1)), ou seja, a velocidade \u00e9 uma fun\u00e7\u00e3o linear da vari\u00e1vel\nnaquela dire\u00e7\u00e3o. Considere que as componentes da matriz de dispers\u00e3o s\u00e3o fun\u00e7\u00f5es com\ndepend\u00eancia espacial e definidas por d11(x,y) = D0u20(x + 1)2, d12(x,y) = d21(x,y) = 0 e\nd22(x,y) = D0u20(y + 1)2. Adicionalmente, considere que a fronteira de Neumann \u00e9 definida\nem ?N = {x1}\u00d7 (y0,y1) ?{y1}\u00d7 (x0,x1) por g = n \u00b7D?C, a fonte de contaminantes \u00e9\ndada pela fun\u00e7\u00e3o f(x,y,t) = 0 e que a condi\u00e7\u00e3o inicial \u00e9\n\nC0(x,y,t0 = 0)\nCC0\n\n= \u00d7exp\n(\n?\n\n1\n2\n\n(x?\u00b51)2\n?21\n\n?\n1\n2\n\n(x?\u00b52)2\n?22\n\n)\n. (5.16)\n\nonde CC0 \u00e9 uma constante, \u00b51,\u00b52,?1,?2 s\u00e3o par\u00e2metros da fun\u00e7\u00e3o C0.\n\nA figura (42) ilustra o dom\u00ednio computacional, o campo de velocidades, as curvas\nde n\u00edvel da condi\u00e7\u00e3o inicial e as condi\u00e7\u00f5es de fronteira de Dirichlet e Neumann para\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 119\n\n\u00b51 = \u00b52 = y1/4 e ? = 1/2, u0 = 0.1 e D0 = 1.0.\n\nFigura 42 \u2013 O dom\u00ednio computacional, as curvas de n\u00edvel para C0\nCC0\n\n, o campo de velocidades com\nu0 = 0.1 e as condi\u00e7\u00f5es de Dirichlet e Neumann\n\nFigura 43 \u2013 O campo de velocidades e as curvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica\n\nA figura (43) apresenta a curvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica, obtida pelo m\u00e9todo\nGMRES pr\u00e9-condicionado pelo m\u00e9todo SA sem reutiliza\u00e7\u00e3o, para uma malha n\u00e3o estru-\n\n\n\n120 Cap\u00edtulo 5. Resultados\n\nturada com elementos triangulares com lado l = 0.25, ? = 1, fun\u00e7\u00f5es lagrangeanas lineares,\n?n = 0.025d, tfinal = 1.5d.\n\n5.3.2.1 Malha Estruturada\n\nEste exemplo considera as constantes u0 = 0.1 e D0 = 1.0, uma malha triangular\nuniforme com ny = nx = 1500 elementos em cada dire\u00e7\u00e3o coordenada e orienta\u00e7\u00e3o\nleft /right (FENICS PROJECT, 2014) com Nv = 2253001 v\u00e9rtices, Ne = 4500000\nelementos triangulares, passo de tempo fixo ?n = ? = 0.005d, tempo final tfinal = 0.25d,\npar\u00e2metro de discretiza\u00e7\u00e3o temporal ? = 1.0/2.0, fun\u00e7\u00f5es lagrangeanas lineares, CC0 = 1.0,\n\u00b51 = \u00b52 = y1/4 = 5.0 e ?1 = ?2 = 0.50.\n\nNeste caso, os seguintes par\u00e2metros foram adotados.\n\n1 config=solver_configuration(Asp,verb=True)\n\n3 config [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\nconfig [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n\n5 config [ \u2019smooth\u2019] =(None,{\u2019krylov\u2019:\u2019gmres\u2019},{\u2019 iterations \u2019 :2})\nconfig [ \u2019strength\u2019 ] = [(\u2019 classical \u2019,{\u2019theta\u2019 :0.10}) ,( \u2019 classical \u2019 ,\n\n7 {\u2019theta\u2019 :0.10}) ]\nconfig [ \u2019max_levels\u2019]=(max_levels);config[\u2019max_coarse\u2019]=(10000)\n\n9 config [ \u2019coarse_solver\u2019]=(\u2019gauss_seidel\u2019)\nconfig [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\n\n11 config [ \u2019aggregate\u2019]=(\u2019standard\u2019)\nconfig [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\n\n13 \u2019symmetric\u2019, \u2019 iterations \u2019 :2})\nconfig [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\n\n15 \u2019symmetric\u2019, \u2019 iterations \u2019 :2})\nconfig [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.0000000001e?8})\n\n17 config [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\n\u2019symmetric\u2019,\u2019 iterations \u2019 :0}) ,None]\n\n19 config [ \u2019diagonal_dominance\u2019]=(False)\nconfig [ \u2019keep\u2019] =(False)\n\n21\n\nAs compara\u00e7\u00f5es das solu\u00e7\u00f5es mostram que os m\u00e9todos calculam as mesmas solu\u00e7\u00f5es\nnum\u00e9ricas, ou seja, DiffnSAReu/SA = 0, Diff\n\nn\nSAReuAuto/SA = 0, ResDiff\n\nn\nSAReu/SA = 0 e\n\nResDiffnSAReu/SA = 0 para todos os passos de tempo n ? {1, 2, \u00b7 \u00b7 \u00b7 ,NI}. Os resulta-\ndos envolvendo os res\u00edduos das solu\u00e7\u00f5es e os res\u00edduos de cada itera\u00e7\u00e3o do m\u00e9todo s\u00e3o\napresentados nas figuras (44-a,b,c,d).\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 121\n\n(a) Norma l2 do res\u00edduo, m\u00e1ximo e m\u00e9dia do res\u00edduo da\nsolu\u00e7\u00e3o para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 50}\n\n(b) Res\u00edduos em cada itera\u00e7\u00e3o do m\u00e9todo multigrid\npara todo passo de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 50}\n\n(c) Res\u00edduos relativos em cada itera\u00e7\u00e3o do m\u00e9todo\nmultigrid para todo passo de tempo n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 50}\n\n(d) reskn/res0n para n = 1, 10, 20, 30, 40, 50\n\nFigura 44 \u2013 Res\u00edduos associadas \u00e0 solu\u00e7\u00e3o num\u00e9rica\n\nO tempo computacional ?tn e o tempo total Tan requerido m\u00e9todo multigrid alg\u00e9brico\nbaseado em agrega\u00e7\u00e3o s\u00e3o apresentados nas figuras (45-a) e (45-b), respectivamente. A\nan\u00e1lise dos resultados mostra que o m\u00e9todo SA ? ReuAuto \u00e9 mais r\u00e1pido devido ao\nn\u00famero de vezes que o processo de agrega\u00e7\u00f5es e c\u00e1lculos dos operadores de transfer\u00eancia\ns\u00e3o realizados. No entanto, ambas as estrat\u00e9gias, SA?Reu e SA?ReuAuto, fornecem um\navan\u00e7o significante em rela\u00e7\u00e3o do m\u00e9todo padr\u00e3o SA, pois representam 378.85/484.03 =\n0.7826 e 372.05/484.03 = 0.7686 do tempo.\n\nA an\u00e1lise dos resultados apresentados nas figuras (44) e (45) mostra que que a\nredu\u00e7\u00e3o no tempo computacional dos m\u00e9todos com reutiliza\u00e7\u00e3o n\u00e3o ocasiona mudan\u00e7as\nna performance dos respectivos m\u00e9todos.\n\n\n\n122 Cap\u00edtulo 5. Resultados\n\n(a) Tempo ?tn para resolver o sistema linear em cada\npasso de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(b) Tempo total Tan =\n?n\n\ni=1 ?Ti at\u00e9 o n\u00e9simo passo\nde tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\nFigura 45 \u2013 O tempo computacional e o tempo total para um sistema linear com Nv = 2253001\nvari\u00e1veis\n\n5.3.2.2 Malha n\u00e3o estruturada: GMRES Pr\u00e9-Condicionado por SA\n\nEste exemplo considera constantes u0 = 0.1,D0 = 1.0 e uma malha n\u00e3o estruturada\ncom N = 1024961 v\u00e9rtices e Ne = 2045824 elementos triangulares, a qual foi obtida de\numa malha inicial com l = 0.25 e tr\u00eas refinamentos sucessivos. Al\u00e9m disso, passo de tempo\nfixo ?n = ? = 0.025d, tempo final tfinal = 1.50d, par\u00e2metro de discretiza\u00e7\u00e3o ? = 1.0,\nfun\u00e7\u00f5es lagrangeanas lineares.\n\nNeste caso, os seguintes par\u00e2metros foram adotados.\n\nconfig [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\n2 config [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n\nconfig [ \u2019smooth\u2019] =(\u2019energy\u2019,{\u2019krylov\u2019 : \u2019gmres\u2019},{\u2019 iterations \u2019 :1})\n4 config [ \u2019strength\u2019 ] = [(\u2019 classical \u2019,{\u2019theta\u2019 :0.10}) ,\n\n(\u2019 classical \u2019,{\u2019theta\u2019 :0.10}) ]\n6 config [ \u2019max_levels\u2019]=(max_levels)\n\nconfig [ \u2019max_coarse\u2019]=(10000)\n8 config [ \u2019coarse_solver\u2019]=(\u2019gauss_seidel\u2019)\n\nconfig [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\n10 config [ \u2019aggregate\u2019]=(\u2019standard\u2019)\n\nconfig [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n12 config [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :3})\n\nconfig [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.0000000001e?8})\n14 config [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\n\n\u2019symmetric\u2019,\u2019 iterations \u2019 :0}) ,None]\n16 config [ \u2019diagonal_dominance\u2019]=(True)\n\nconfig [ \u2019keep\u2019] =(False)\n18\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 123\n\nNesse caso, compara\u00e7\u00e3o da solu\u00e7\u00f5es tamb\u00e9m fornecem que DiffnSAReu/SA = 0,\nDiffnSAReuAuto/SA = 0, ResDiff\n\nn\nSAReu/SA = 0 e ResDiff\n\nn\nSAReu/SA = 0 para todos os\n\npassos de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}. Os resultados envolvendo os res\u00edduos das solu\u00e7\u00f5es e\nos res\u00edduos de cada itera\u00e7\u00e3o do m\u00e9todo s\u00e3o apresentados nas figuras (46-a,b,c,d).\n\n(a) Norma l2 do res\u00edduo, m\u00e1ximo e m\u00e9dia do res\u00edduo da\nsolu\u00e7\u00e3o para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 60}\n\n(b) Res\u00edduos em cada itera\u00e7\u00e3o do m\u00e9todo multigrid\npara todo passo de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 60}\n\n(c) Res\u00edduos relativos em cada itera\u00e7\u00e3o do m\u00e9todo\nmultigrid para todo passo de tempo n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 60}\n\n(d) reskn/res0n para n = 1, 20, 30, 40, 50, 60\n\nFigura 46 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica\n\nO tempo computacional ?tn e o tempo total Tan para os m\u00e9todos GMRESSA,\nGMRESSAReu e GMRESSAReuAuto s\u00e3o apresentados nas figuras (47-a,b), respectivamente.\n\nNeste caso, o m\u00e9todo GMRESSAReuAuto realiza as agrega\u00e7\u00f5es e c\u00e1lculos dos oper-\nadores de transfer\u00eancia de resultados em tr\u00eas passos de tempo, enquanto que o m\u00e9todo\nGMRESSAReu executa as opera\u00e7\u00f5es em seis passos de tempo. O tempo computacional de\nambas as estrat\u00e9gias, com reutiliza\u00e7\u00e3o ou reutiliza\u00e7\u00e3o autom\u00e1tica, representam 760.88/1184.7 =\n0.6422 e 744.34/1184.7 = 0.6282 do tempo total do m\u00e9todo que n\u00e3o executa a reutiliza\u00e7\u00e3o.\n\n\n\n124 Cap\u00edtulo 5. Resultados\n\n(a) Tempo ?tn para resolver o sistema linear em cada\npasso de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(b) Tempo total Tan =\n?n\n\ni=1 ?tn at\u00e9 o n\u00e9simo passo\nde tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\nFigura 47 \u2013 O tempo computacional e o tempo total para um sistema com N = 1024961 vari\u00e1veis\n\n5.3.3 Malha n\u00e3o estruturada em dom\u00ednio n\u00e3o retangular\n\nEsta se\u00e7\u00e3o considera o transporte de contaminantes em um dom\u00ednio bidimensional\n? definido pela malha T0 apresentada na figura (48). Assuma que i. o contaminante \u00e9\nconservativo, ii. condi\u00e7\u00e3o de Dirichlet \u00e9 definida sobre toda a fronteira por C = C0 = 0.0 e\niii. a condi\u00e7\u00e3o inicial \u00e9 dada por\n\nC0(x,y,t = 0.0) = C01 exp\n(\n?\n\n(x?\u00b5x1)2\n2?2x1\n\n?\n(x?\u00b5y1)2\n\n2?2y1\n\n)\n+\n\nC02exp\n\n(\n?\n\n(x?\u00b5x2)2\n2?2x2\n\n?\n(x?\u00b5y2)2\n\n2?2y2\n\n)\n+ C03 exp\n\n(\n?\n\n(x?\u00b5x3)2\n2?2x3\n\n?\n(x?\u00b5y3)2\n\n2?2y3\n\n)\n, (5.17)\n\nonde \u00b5x1 = 400000.00, \u00b5y1 = 9000000.00, ?x1 = ?y1 = 10000.0, \u00b5x2 = 400000.00,\n\u00b5y2 = 8700000.00, ?x2 = ?y2 = 10000.0, \u00b5x3 = 500000.00, \u00b5y3 = 9200000.00, ?x3 =\n?y3 = 10000.0, = C01 = C02 = C03 = 1.0. Considere que a matriz de dispers\u00e3o possui com-\nponentes constantes d11(x,y) = 50.0m2/d, d12(x,y) = d21(x,y) = 0, d22(x,y) = 5.0m2/d e\nque o campo de velocidades \u00e9 vari\u00e1vel na dire\u00e7\u00e3o do eixo X e dado por:\n\nvx =\n\n?????\n????\n\n0.05 se x 6 \u00b5x1\n?0.04 x?\u00b5x1\n\n\u00b5x3?\u00b5x1\n+ 0.05 se \u00b5x1 &lt;x 6 \u00b5x3\n\n0.01 se x > \u00b5x3\n(5.18)\n\nvy =\n\n?????\n????\n\n0.05 se x 6 \u00b5x1\n?0.04 x?\u00b5x1\n\n\u00b5x3?\u00b5x1\n+ 0.05 se \u00b5x1 &lt;x 6 \u00b5x3\n\n0.0 se x > \u00b5x3\n. (5.19)\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 125\n\nOs resultados apresentados nas figuras (48) e (49) consideram um refinamento\nuniforme da malha T0, ? = 1.0, ?n = 500.0d fun\u00e7\u00f5es lagrangeanas de ordem dois. Adi-\ncionalmente, uma transla\u00e7\u00e3o da malha foi realizada de modo que o ponto com menores\ncoordenadas em T0 coincida com a origem do sistema de coordenadas cartesianas 8.\n\nFigura 48 \u2013 Malha n\u00e3o-estruturada em dom\u00ednio n\u00e3o retangular\n\nFigura 49 \u2013 A condi\u00e7\u00e3o inicial em malha tranladada para origem\n\n8. Esse artif\u00edcio \u00e9 utilizado para facilitar a apresenta\u00e7\u00e3o dos resultados gr\u00e1ficos\n\n\n\n126 Cap\u00edtulo 5. Resultados\n\nOs seguintes par\u00e2metros para os m\u00e9todos multigrid foram adotados.\n\n1 config [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\nconfig [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n\n3\nconfig [ \u2019smooth\u2019] =(\u2019energy\u2019, {\u2019krylov\u2019 : \u2019gmres\u2019}, {\u2019 filter \u2019 : True},{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\n5 config [ \u2019strength\u2019 ] =(\u2019 classical \u2019,{\u2019theta\u2019 :0.0})\nconfig [ \u2019max_levels\u2019]=(max_levels)\n\n7\nconfig [ \u2019max_coarse\u2019]=(1000)\n\n9 config [ \u2019coarse_solver\u2019]=(\u2019gauss_seidel\u2019)\nconfig [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\n\n11 config [ \u2019aggregate\u2019]=(\u2019standard\u2019)\nconfig [ \u2019presmoother\u2019] = (\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\n13 config [ \u2019postsmoother\u2019] = (\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :3})\nconfig [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.000001e?12})\n\n15 config [ \u2019improve_candidates\u2019]=[(\u2019gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2}) ]\n\n17 config [ \u2019diagonal_dominance\u2019]=(True)\nconfig [ \u2019keep\u2019] =(False)\n\n19\n\nPara a adequada visualiza\u00e7\u00e3o do avan\u00e7o da frente de contaminantes, os resultados\nforam projetados sobre uma malhas retangulares e uniformes. A figura (50) mostra as\ncurvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica projetada sobre malha uniforme.\n\nFigura 50 \u2013 Curvas de n\u00edvel da fun\u00e7\u00e3o de distribui\u00e7\u00e3o de contaminantes em malha transladada\npara origem\n\nPara o c\u00e1lculo do tempo computacional, os mesmos par\u00e2metros s\u00e3o adotados, exceto\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 127\n\na malha. Essa, por sua vez, foi obtida por meio de uma sequ\u00eancia de tr\u00eas refinamentos\nuniformes e sucessivos da malha inicial T0, o qual produz uma malha T1 com Ne = 792640\nelementos triangulares com Nv = 412197 v\u00e9rtices. Nesse caso, os m\u00e9todos SA, SA?Reu\ne SA?ReuAuto, sem precondicionantes, foram considerados para a solu\u00e7\u00e3o do sistema\nlinear, o qual possui Nv = 1617033 vari\u00e1veis.\n\nA compara\u00e7\u00e3o dos resultados num\u00e9ricos fornece DiffnSAReu/SA = Diff\nn\nSAReuAuto/SA =\n\n0.0, ResDiffnSAReu/SA = ResDiff\nn\nSAReuAuto/SA = 0.0 para todos os passos de tempo\n\nn ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 100}. Os resultados envolvendo os res\u00edduos das solu\u00e7\u00f5es e os res\u00edduos\nde cada itera\u00e7\u00e3o do m\u00e9todo s\u00e3o apresentados nas figuras (51-a,b,c,d).\n\n(a) Norma l2 do res\u00edduo, res\u00edduo m\u00e1ximo e m\u00e9dia do\nres\u00edduo da solu\u00e7\u00e3o para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 100}\n\n(b) Res\u00edduos em cada itera\u00e7\u00e3o do m\u00e9todo multigrid\npara todo passo de tempo n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 100}\n\n(c) Res\u00edduos relativos em cada itera\u00e7\u00e3o do m\u00e9todo\nmultigrid para todo passo de tempo n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 100}\n\n(d) reskn/res0n para n = 1, 25, 50, 75, 100\n\nFigura 51 \u2013 Medidas dos res\u00edduos associados a solu\u00e7\u00e3o num\u00e9rica\n\nO tempo computacional e o tempo total s\u00e3o apresentados nas figuras (52-a,b). Nesse\ncaso, ambos os m\u00e9todos modificados SAReu e SAReuAuto s\u00e3o efetivos para reduzir o\n\n\n\n128 Cap\u00edtulo 5. Resultados\n\ntempo computacional e representam 2836.9552/4993.2425 = 0.57 e 2639.7683/4993.2425 =\n0.53 do tempo total gasto pelo m\u00e9todo SA. Para todos os efeitos, essa redu\u00e7\u00e3o \u00e9 significante.\n\n(a) Tempo computacional ?tn para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}(b) Tempo total Tan =\n?n\n\ni=1 ?ti para n ?\n{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\nFigura 52 \u2013 O tempo computacional e o tempo total para sistemas lineares com Nv = 1617033\nvari\u00e1veis\n\nDevido \u00e0 rela\u00e7\u00e3o aproximadamente linear entre o tempo total e o passo de tempo, as\nretas de regress\u00e3o de m\u00ednimos quadrados rSA, rSAReu e rSAReuAuto foram calculadas por\nmeio do m\u00f3dulo stats do Scipy Jones et al. (2001). A reta de m\u00ednimos quadrados, o valor\nr, o valor p e o erro padr\u00e3o s\u00e3o apresentados em (5.20), (5.21) e (5.22):\n\nrSA(n) = 49.830n? 13.058\n\nr = 1.0,pvalue = 0.000,stderror = 0.00520,r2 = 1.0 (5.20)\n\nrSAReu(n) = 28.284n + 16.689\n\nr = 1.0,pvalue = 0.000,stderror = 0.0152,r2 = 1.0 (5.21)\n\nrSAReuAuto(n) = 26.1040n + 29.76\n\nr = 1.0,pvalue = 0.000,stdvalue = 0.009865,r2 = 1.0 (5.22)\n\nA figura (53) ilustra a extrapola\u00e7\u00e3o do tempo computacional para um n\u00famero\nn > 100 de passos de tempo. A an\u00e1lise desses resultados mostra o avan\u00e7o computacional\ndo m\u00e9todo multigrid com reutiliza\u00e7\u00e3o em rela\u00e7\u00e3o ao m\u00e9todo multigrid sem reutiliza\u00e7\u00e3o.\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 129\n\nFigura 53 \u2013 Extrapola\u00e7\u00e3o do tempo computacional para o n\u00famero de passos de tempo n > 100\n\nAt\u00e9 o momento, os exemplos considerados mostram que as solu\u00e7\u00f5es num\u00e9ricas e os\nres\u00edduos s\u00e3o id\u00eanticos e, portanto, tanto o m\u00e9todo SAReu quanto o m\u00e9todo SAReuAuto\npodem ser utilizados. No entanto, o m\u00e9todo autom\u00e1tico \u00e9 mais eficiente pois fornece a\nsolu\u00e7\u00e3o do problema sem, no entanto, escolher o par\u00e2metro ? para a reutiliza\u00e7\u00e3o.\n\nOs pr\u00f3ximos resultados conjugam a solu\u00e7\u00e3o do problema auxiliar, o qual \u00e9 associado\nao problema transiente do transporte nos casos em que o regime \u00e9 de advec\u00e7\u00e3o dominante.\nAl\u00e9m disso, malhas adaptadas aos dados s\u00e3o consideradas.\n\n5.3.4 Reutiliza\u00e7\u00e3o para malha adaptada aos dados em regime de grande\nadve\u00e7\u00e3o\n\nO exemplo desta se\u00e7\u00e3o considera malha adaptada aos dados do transporte de\ncontaminantes. Al\u00e9m disso, considera-se a solu\u00e7\u00e3o do problema auxiliar, o qual \u00e9 necess\u00e1rio\npara a obten\u00e7\u00e3o das estimativas residuais em regime de advec\u00e7\u00e3o dominante. A obten\u00e7\u00e3o\ndas estimativas residuais para o regime de advec\u00e7\u00e3o dominante foi discutida na se\u00e7\u00e3o\n[5.2.1] e n\u00e3o \u00e9 discutida nesta parte, pois o objetivo \u00e9 avaliar a performance do m\u00e9todo\nmultigrid para os diferentes problemas envolvidos.\n\n\n\n130 Cap\u00edtulo 5. Resultados\n\n5.3.4.1 Malha n\u00e3o estruturada adaptada aos dados do transporte\n\nEste exemplo considera os dados do problema apresentado na se\u00e7\u00e3o (5.3.2) com\nm\u00e9todo GMRES pr\u00e9-condicionado por multigrid alg\u00e9brico SA. A malha utilizada foi\nobtida por meio dois refinamentos uniformes e sucessivos da malha (54-b) que, por sua vez,\nfoi obtida pelo procedimento adaptativo RefineMesh_for_InitCond(kargs**) aplicado\naos dados do problema com a malha inicial (54-a). Os resultados num\u00e9ricos para a solu\u00e7\u00e3o\ne as curvas de n\u00edvel s\u00e3o similares aos apresentados na se\u00e7\u00e3o (5.3.2) e n\u00e3o s\u00e3o apresentados\nnesta se\u00e7\u00e3o.\n\nO procedimento adaptativo foi utilizado sequencialmente aos dados\ndxx = D0 \u00b7u20(x + 1)2, dyy = D0 \u00b7u20(y + 1)2, \u00e0 condi\u00e7\u00e3o inicial C0(x,y,t = 0), ao potencial\nhidr\u00e1ulico H e \u00e0s componentes do campo de velocidades vx = u0(x + 1), vy = ?u0(y + 1),\nrespectivamente. A condi\u00e7\u00e3o inicial e o potencial hidr\u00e1ulico s\u00e3o dados por:\n\nC0(x,y,t = 0) = CC0 exp\n(\n?\n\n1\n2\nx?\u00b51\n?21\n\n?\n1\n2\ny ?\u00b51\n?22\n\n)\n, (5.23)\n\ne\n\nH =\nu0\n2\n\u00b7 (x + 1.0)2 ?\n\nu0\n2\n\u00b7 (y + 1.0)2 . (5.24)\n\nNesse caso, as constantes \u00b51 = y1/4, ? = 0.5, u0 = 0.1 e CC0 = 1 foram considerados.\nOs par\u00e2metros abaixo forma considerados para fun\u00e7\u00e3o RefineMesh_for_InitCond(kargs**).\n\ntoldxx=0.005;fraction=0.5;degree=1;RaiseDegree=2\n2 u_0=0.1;D_0=1.0;kappa=4.41;epsilon=0.01;beta=0.0\nmu_1=y_1/4; sigma_1=0.5\n\nUm exemplo de c\u00f3digo computacional para a utiliza\u00e7\u00e3o procedimento adaptativo \u00e9\nfornecido no ap\u00eandice [B].\n\nA malha inicial possui Ne = 4065 elementos triangulares com Nv = 2105 v\u00e9rtices,\nenquanto que a malha adaptada aos dados possui Ne = 8978 elementos triangulares e Nv =\n4617 v\u00e9rtices. A malha final, utilizada para aproxima\u00e7\u00e3o do transporte de contaminantes,\nobtida por dois refinamentos sucessivos da malha refinada, possui Nv = 72333 v\u00e9rtices e\nNe = 143648 elementos triangulares. Os demais par\u00e2metros da aproxima\u00e7\u00e3o de elementos\nfinitos s\u00e3o ?n = 0.005, ? = 1/2, tfinal = 0.25 e fun\u00e7\u00f5es lagrangeanas lineares 9.\n\n9. O problema auxiliar utiliza os mesmos dados que o problema do transporte\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 131\n\n(a) Malha inicial com Ne = 4065 elementos\ntriangulares\n\n(b) Malha adaptada aos dados com Ne = 8978\nelementos triangulares\n\nFigura 54 \u2013 Malha inicial e malha adaptada aos dados do problema do transporte de contami-\nnantes\n\nNesse caso, o m\u00e9todo GMRES pr\u00e9-condicionado por SA, SA?Reu e SA?ReuAuto\nfoi utilizado tanto para o problema do transporte quanto para o problema auxiliar.\n\nOs seguintes par\u00e2metros para os m\u00e9todos multigrid foram adotados.\n\n1 def DictSA(Asp,max_levels,solver_configuration):\nconfig=solver_configuration(Asp,verb=True)\n\n3 config [ \u2019symmetry\u2019]=(\u2019nonsymmetric\u2019)\nconfig [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\n\n5 config [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\nconfig [ \u2019smooth\u2019] =(None,{ \u2019krylov\u2019:\u2019bicg\u2019},{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\n7 config [ \u2019strength\u2019 ] =(\u2019 classical \u2019,{\u2019theta\u2019 :0.1})\nconfig [ \u2019max_levels\u2019]=(max_levels)\n\n9 config [ \u2019max_coarse\u2019]=(1000)\nconfig [ \u2019coarse_solver\u2019]=(\u2019lu\u2019)\n\n11 config [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\nconfig [ \u2019aggregate\u2019]=(\u2019standard\u2019)\n\n13 config [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :1})\nconfig [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\n15 config [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.000001e?10})\nconfig [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2}) ]\n\n17 config [ \u2019diagonal_dominance\u2019]=(True)\nconfig [ \u2019keep\u2019] =(False)\n\n19 return config\n\n21 def DictSAAuxiliar(AspLarge,max_levels,solver_configuration):\nconfig2=solver_configuration(AspLarge,verb=True)\n\n23 return config2\n\n\n\n132 Cap\u00edtulo 5. Resultados\n\nDiferentemente dos outros casos considerados, as solu\u00e7\u00f5es obtidas n\u00e3o s\u00e3o id\u00eanticas\npara todos os passos de tempo. Nesse caso, apenas as solu\u00e7\u00f5es para o problema do\ntransporte s\u00e3o id\u00eanticas, enquanto que as solu\u00e7\u00f5es para o problema auxiliar associado n\u00e3o\ns\u00e3o id\u00eanticas. A tabela [5] os valores m\u00e1ximos sobre todos os passos de tempo tanto para\no problema do transporte quanto para o problema auxiliar. Especificamente, o m\u00e1ximo\ndos res\u00edduos m\u00e1ximos, o m\u00e1ximo dos res\u00edduos m\u00e9dios e o m\u00e1ximo dos res\u00edduos da norma\nl2 s\u00e3o apresentados.\n\nA an\u00e1lise dos resultados apresentados na tabela [5] mostra que os m\u00e9todos modificados\nfornecem praticamente a mesma solu\u00e7\u00e3o tanto para problema do transporte quanto para o\nproblema auxiliar. Essa conclus\u00e3o \u00e9 baseada nos resultados para os m\u00e1ximos das diferen\u00e7as\npara as diversas medidas consideradas. Logo, considera-se que os m\u00e9todos produzem\nsolu\u00e7\u00f5es equivalentes e, portanto, os tempos computacionais podem ser comparados.\n\nTabela 5 \u2013 Valores m\u00e1ximos para todos os passos de tempo n = {1, 2, 3, \u00b7 \u00b7 \u00b7 ,NI}: m\u00e1ximo dos\nres\u00edduos m\u00e1ximos, m\u00e1ximo dos res\u00edduos m\u00e9dios e o m\u00e1ximo dos res\u00edduos na norma l2\n\nTransporte n = 1, 2, 3 \u00b7 \u00b7 \u00b7 ,NI max max() maxme?dia() maxnorma?l2 ()\nResnSA 1.83e-13 2.97e-15 2.86e-12\nResnSAReu 1.83e-13 2.97e-15 2.86e-12\nResnSAReuAuto 1.83e-13 2.97e-15 2.86e-12\nDiffnSAReu/SA 0.0 0.0 0.0\nDiffnSAReuAuto/SA 0.0 0.0 0.0\nResDiffnSAReu/SA 0.0 0.0 0.0\nResDiffnSAReuAuto/SA 0.0 0.0 0.0\n\nAuxiliar n = 1, 2, 3 \u00b7 \u00b7 \u00b7 ,NI max max() maxme?dia() maxnorma?l2 ()\n\nResnSA 4.31e-13 9.16e-15 8.22e-12\nResnSAReu 4.60e-13 9.71e-15 8.72e-12\nResnSAReuAuto 4.33e-13 9.13e-15 8.20e-12\nDiffnSAReu/SA 1.23e-11 3.39e-13 2.57e-10\nDiffnSAReuAuto/SA 1.23e-11 3.39e-13 2.57e-10\nResDiffnSAReu/SA 1.29e-13 7.72e-16 7.88e-13\nResDiffnSAReuAuto/SA 1.31e-13 3.24e-16 5.06e-13\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 133\n\nOs tempos computacional e total para o problema do transporte e problema auxiliar\ns\u00e3o apresentados nas figuras (55-a,b) e (55-c,d), respectivamente.\n\nAs figuras (56-a,b) apresentam os tempos computacionais combinados, ou seja, a\nsoma dos tempos computacionais provenientes dos problemas do transporte e auxiliar.\nA an\u00e1lise dos resultados mostra que a reutiliza\u00e7\u00e3o produz um tempo computacional\ncombinado menor que o tempo combinado dos m\u00e9todos sem reutiliza\u00e7\u00e3o. Esse resultado\nrefor\u00e7a a tese de reutilizar as estruturas multigrid como forma de acelerar os m\u00e9todos\nmultigrid alg\u00e9bricos em problemas envolvendo o transporte de contaminantes.\n\n(a) Tempo ?tn para o sistema linear da equa\u00e7\u00e3o do\ntransporte n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(b) Tempo ?tn para o sistema linear do problema\nauxiliar n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(c) Tempo total Tan =\n?n\n\ni=1 ?ti do problema do\ntransporte para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(d) Tempo total Tan =\n?n\n\ni=1 ?ti do problema auxiliar\npara n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\nFigura 55 \u2013 O tempo computacional e o tempo total para os problemas do transporte e auxiliar.\nSistema linear com Nv = 72333 v\u00e9rtices\n\n\n\n134 Cap\u00edtulo 5. Resultados\n\n(a) Soma dos tempo de (55-a) e (55-b) (b) O tempo total obtido de (56-a)\n\nFigura 56 \u2013 O tempo computacional e o tempo total combinados para os problemas do transporte\ne auxiliar. Sistema linear com Nv = 72333 vari\u00e1veis\n\nA pr\u00f3xima se\u00e7\u00e3o ilustra a aplica\u00e7\u00e3o do procedimento de reutiliza\u00e7\u00e3o para problemas\ntridimensionais.\n\n5.3.5 A reutiliza\u00e7\u00e3o para o trasporte 3D\n\nEsta se\u00e7\u00e3o considera uma adapta\u00e7\u00e3o do transporte de contaminantes tridimen-\nsional apresentado em Parkhurst (PARKHURST D.L.; CHARLTON, 2004), o qual \u00e9 um\nproblema tridimensional. Nesse caso, fluxo unidimensional na dire\u00e7\u00e3o x em um dom\u00ednio\ncomputacional ? com 100m\u00d7 40m\u00d7 24m \u00e9 considerado. Os par\u00e2metros incluem trans-\nporte conservativo, velocidade v = 0, 1m/d, um coeficiente de dispersividade longitudinal\n?L = 1, 5m, dispersividade horizontal transversal ?TH = 0, 3m, dispersividade vertical\ntransversal ?Tv = 0, 02m.\n\nA condi\u00e7\u00e3o inicial \u00e9 dada por C(x,y,z,t = 0.0) = 0.0 e as condi\u00e7\u00f5es de contorno s\u00e3o\ndadas por\n\nC(x,y,t)\nC0\n\n=\n\n??\n? 1 se |y ? 20| 6\n\nss\n2\n\n0 caso contr\u00e1rio\n(5.25)\n\nonde ss \u00e9 uma constante.\n\nNesse caso, a valida\u00e7\u00e3o do c\u00f3digo num\u00e9rico considera a solu\u00e7\u00e3o anal\u00edtica bidimensional\nde Wexler (WEXLER, 1992) pois as hip\u00f3teses apresentadas em [4.2.3] s\u00e3o satisfeitas. Al\u00e9m\ndisso, utilizar uma solu\u00e7\u00e3o anal\u00edtica bidimensional facilita os c\u00e1lculos.\n\nOs resultados apresentados nas figuras (57-a,b) apresentam as curvas de n\u00edvel da\nsolu\u00e7\u00e3o num\u00e9rica C(x,y,z = constante,t40) projetada em uma malha bidimensional com\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 135\n\nnx = 2ny = 100 elementos triangulares nas dire\u00e7\u00f5es coordenadas. A aproxima\u00e7\u00e3o de\nelementos finitos do problema 3D considera uma malha com Ne = 900000 tetraedros e\nNv = 159681 v\u00e9rtices obtida por meio de nx = 100, ny = 50 e nz = 30 elementos em cada\ndire\u00e7\u00e3o coordenada, , ss = 5.0, ?n = 5.00, tfinal = 200.0, ? = 1.0 e fun\u00e7\u00f5es lagrangeanas\nlineares.\n\n(a) Curvas de n\u00edvel da solu\u00e7\u00e3o num\u00e9rica em z =\nconstante\n\n(b) Curvas de n\u00edvel da solu\u00e7\u00e3o anal\u00edtica de Wexler\n\nFigura 57 \u2013 Curvas de n\u00edvel das solu\u00e7\u00f5es num\u00e9rica C(x,y,z = constante,t40) e curvas de n\u00edvel\nda solu\u00e7\u00e3o anal\u00edtica de Wexler (WEXLER, 1992)\n\n(a) O erro, E,entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica (b) Curvas de n\u00edvel do\n\nFigura 58 \u2013 O erro entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica e as respectivas curvas de n\u00edvel con-\nsiderando a solu\u00e7\u00e3o num\u00e9rica do problema tridimensional C40z=constante = C(x,y,z =\nconstante,t40)\n\nApesar da reduzida quantidade de elementos em cada dire\u00e7\u00e3o coordenada, a malha de\nelementos finitos possui uma quantidade significativa de vari\u00e1veis mostrando a influ\u00eancia\ndo problema tridimensional. As diferen\u00e7as entre as solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica s\u00e3o\n\n\n\n136 Cap\u00edtulo 5. Resultados\n\ndevidas \u00e0 representa\u00e7\u00e3o do termo de fonte no dom\u00ednio tridimensional. O mapa de erros e\nrespectivas curvas de n\u00edvel ilustram essa discuss\u00e3o e s\u00e3o apresentados nas figuras (58-a, b).\n\nA avalia\u00e7\u00e3o do tempo computacional considera uma malha com Ne = 7200000\ntetraedros e Nv = 1238361 v\u00e9rtices, obtida por meio de dois refinamentos uniformes\ne sucessivos de uma malha inicial com nx = 50,ny = 25,nz = 15 elementos em cada\ndire\u00e7\u00e3o coordenada, ?n = 10.0, tfinal = 500.0, ? = 1.0 e fun\u00e7\u00f5es lagrangeanas lineares. A\ncompara\u00e7\u00e3o dos resultados num\u00e9ricos fornece DiffnSAReu/SA = 0.0, Diff\n\nn\nSAReuAuto/SA = 0.0,\n\nResDiffnSAReu/SA = 0.0 e ResDiff\nn\nSAReuAuto/SA = 0.0 para todos os passos de tempo\n\nn ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI = 70}.\n\nOs seguintes par\u00e2metros para os m\u00e9todos multigrid foram adotados.\n\n1 config=solver_configuration(Asp,verb=False)\n\n3 config [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\nconfig [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n\n5 config [ \u2019smooth\u2019] =(None,{\u2019gauss_seidel\u2019},{\u2019iterations \u2019 :2})\nconfig [ \u2019strength\u2019 ] =(\u2019 classical \u2019,{\u2019theta\u2019 :0.1})\n\n7 config [ \u2019max_levels\u2019]=(max_levels)\nconfig [ \u2019max_coarse\u2019]=(100)\n\n9 config [ \u2019coarse_solver\u2019]=(\u2019lu\u2019)\nconfig [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\n\n11 config [ \u2019aggregate\u2019]=(\u2019standard\u2019)\nconfig [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019,\n\n13 {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\nconfig [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019,\n\n15 {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :3})\nconfig [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.000001e?8})\n\n17 config [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019,\n{\u2019sweep\u2019: \u2019symmetric\u2019,\u2019 iterations \u2019 :0}) ,None]\n\n19 config [ \u2019diagonal_dominance\u2019]=(True)\nconfig [ \u2019keep\u2019] =(False)\n\n21\n\nO tempo computacional e o tempo total s\u00e3o apresentados, respectivamente, nas\nfiguras (59-a,b), enquanto que as figuras (60-a,b) apresentam as medidas dos res\u00edduos das\nsolu\u00e7\u00f5es e a evolu\u00e7\u00e3o dos res\u00edduos em alguns passos de tempo, respectivamente.\n\nAqui, o ganho computacional n\u00e3o \u00e9 t\u00e3o expressivo, mas isso pode ser consequ\u00eancia\ndos par\u00e2metros adotados para o m\u00e9todo multigrid. No entanto, a an\u00e1lise dos resultados\nmostra a influ\u00eancia do processo de agrega\u00e7\u00e3o no tempo computacional e, portanto, ainda\nrefor\u00e7a a tese do trabalho.\n\n\n\n5.3. M\u00e9todos Multigrid Acelerados 137\n\n(a) Norma l2 do res\u00edduo, res\u00edduo m\u00e1ximo e m\u00e9dia do\nres\u00edduo da solu\u00e7\u00e3o para n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(b) reskn/res0n para n = 1, 21, 31, 41, 50\n\nFigura 59 \u2013 Medidas dos res\u00edduos associados \u00e0 solu\u00e7\u00e3o num\u00e9rica\n\n(a) Tempo para resolver o sistema linear da equa\u00e7\u00e3o do\ntransporte n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\n(b) Tempo para resolver o sistema linear do problema\nauxiliar n ?{1, 2, \u00b7 \u00b7 \u00b7 ,NI}\n\nFigura 60 \u2013 O tempo computacional e o tempo total para sistemas lineares com Nv = 1238361\nvari\u00e1veis\n\n\n\n\n\n139\n\n6 Conclus\u00e3o\n\nDe posse das estimativas residuais, os indicadores residuais foram calculados e os\nresultados mostram que o comportamento qualitativo dos erros reais s\u00e3o capturados pelos\nindicadores das componentes residuais espaciais, dos elementos e dos saltos. No entanto, as\nmagnitudes envolvidas variam e h\u00e1 a predomin\u00e2ncia, nos casos considerados, das estimativas\ndos saltos em rela\u00e7\u00e3o \u00e0s outras quantidades. O avan\u00e7o computacional em rela\u00e7\u00e3o aos\nresultados apresentados em Praetorius, Weinmuller e Wissgott (2008) residem na facilidade\nde implementa\u00e7\u00e3o das estimativas, na considera\u00e7\u00e3o de problemas envolvendo dados n\u00e3o\nconstantes, na utiliza\u00e7\u00e3o de fun\u00e7\u00f5es lagrangeanas de ordem superior e, principalmente, a\nconsidera\u00e7\u00e3o de problemas diversos envolvendo o transporte de contaminantes em meio\nporoso saturado.\n\nEstreitamente ligados \u00e0s estimativas residuais est\u00e3o os c\u00e1lculos das constantes ? e\n?. O desenvolvimento e implementa\u00e7\u00e3o da metodologia de calculo das constantes ? e ?\npossibilitou a adequada implementa\u00e7\u00e3o das estimativas residuais.\n\nA solu\u00e7\u00e3o da ADR em malha adaptada aos dados produziu uma solu\u00e7\u00e3o similar\n\u00e0quela dada por uma malha uniforme. Al\u00e9m disso, a malha adequada aos dados possu\u00eda,\naproximadamente, duas vezes menos elementos. Esse resultado refor\u00e7a a tese da influ\u00eancia\nda adequada representa\u00e7\u00e3o dos dados no processo de solu\u00e7\u00e3o.\n\nFinalmente, os m\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o das estruturas hi-\ner\u00e1rquicas foram desenvolvidos. Esses m\u00e9todos incluem:\n\ni. os m\u00e9todos multigrid alg\u00e9bricos com reutiliza\u00e7\u00e3o autom\u00e1tica ou com par\u00e2metro ?;\n\nii. os m\u00e9todos iterativos n\u00e3o-estacion\u00e1rios pr\u00e9-condicionados por multigrid com reutiliza\u00e7\u00e3o\nautom\u00e1tica ou com par\u00e2metro ?.\n\nAmbos os casos i. e ii. foram analisados e os resultados mostraram um ganho\ncomputacional significativo tanto para m\u00e9todos com reutiliza\u00e7\u00e3o autom\u00e1tica quanto para\nos m\u00e9todos com par\u00e2metro fixo ?. Os m\u00e9todos autom\u00e1ticos s\u00e3o mais eficientes que os\nm\u00e9todos com par\u00e2metro ? no sentido que o crit\u00e9rio de decis\u00e3o \u00e9 tomado baseado no\nn\u00famero de itera\u00e7\u00f5es necess\u00e1rias \u00e0 converg\u00eancia. No entanto, independente do esquema\nadotado, todos resultados apontam que a reutiliza\u00e7\u00e3o \u00e9 uma ferramenta eficaz para acelerar\no c\u00e1lculo das solu\u00e7\u00f5es dos sistemas lineares. Essa otimiza\u00e7\u00e3o \u00e9 dependente do m\u00e9todo\nadotado e do tipo de problema considerados.\n\nA pr\u00f3xima se\u00e7\u00e3o prop\u00f5e alguns trabalhos futuros.\n\n\n\n140 Cap\u00edtulo 6. Conclus\u00e3o\n\n6.1 Sugest\u00f5es para Trabalhos Futuros\n\nAs propostas de trabalhos futuros aqui apresentadas refletem as ideias ou trabalhos\nn\u00e3o desenvolvidos nesta tese.\n\n1. A incorpora\u00e7\u00e3o da depend\u00eancia temporal dos dados do problema do transporte.\nNesse caso, al\u00e9m da adequa\u00e7\u00e3o dos c\u00f3digos desenvolvidos, a metodologia de c\u00e1lculo\ndas constantes ? e ? deve ser modificada. Uma proposta para essa implementa\u00e7\u00e3o\n\u00e9 a seguinte:\ni. considerar duas parti\u00e7\u00f5es temporais IM = {t0, t1, \u00b7 \u00b7 \u00b7 , tM} e IN = {t0, t1, \u00b7 \u00b7 \u00b7 , tN}\ncom N > M, desvinculadas do m\u00e9todo de elementos finitos;\n\nii. Calcular as sequ\u00eancias de m\u00ednimos e m\u00e1ximos autovalores para cada parti\u00e7\u00e3o\ntemporal, ou seja,\n\nSeq1 = (?IMk )\nM\nk=0,Seq2 = (?INj )\n\nN\nj=0 (6.1)\n\nSeq3 = (?IMk )\nM\nk=0,Seq4 = (?INj )\n\nN\nj=0 (6.2)\n\n(6.3)\n\nii. Se ?0 = min Seq1 = min Seq2 ? ? = ?0. Caso contr\u00e1rio, construa uma nova\nparti\u00e7\u00e3o mais refinada e repita o processo. Analogamente, o valor de ? pode ser\ncalculado.\n\n2. Considere que as constantes ? e ? para dados com depend\u00eancia temporal est\u00e3o\ndispon\u00edveis. Os c\u00f3digos apresentados nesse trabalho devem ser adequadamente\nmodificados para incorporar a depend\u00eancia temporal dos dados. A quest\u00e3o adap-\ntativa dos dados deve ser repensada, pois a adequa\u00e7\u00e3o da malha passa a possuir\ndepend\u00eancia temporal. Al\u00e9m disso, \u00e9 interessante considerar a implementa\u00e7\u00e3o de\numa classe para refinamento adaptativo. Uma sugest\u00e3o \u00e9 conjugar os c\u00f3digos aqui\ndesenvolvidos com o c\u00f3digo desenvolvido em Praetorius, Weinmuller e Wissgott\n(2008). A dificuldade inicial \u00e9 a transfer\u00eancia das informa\u00e7\u00f5es entre as bibliotecas\nutilizadas nesse trabalho e o software MatlabR 1.\n\n3. A inadequa\u00e7\u00e3o do m\u00e9todo de elementos finitos cont\u00ednuos em capturar descon-\ntinuidades dos dados conduz ao m\u00e9todos dos elementos finitos descont\u00ednuos. Nesse\ncaso, analogamente aos trabalhos desenvolvidos, adequadas estimativas residuais\ndevem ser obtidas. Em princ\u00edpio, os m\u00e9todos multigrid com reutiliza\u00e7\u00e3o podem\nser utilizados neste tipo de problema.\n\n4. Aqui, apenas o caso linear da equa\u00e7\u00e3o do transporte de contaminantes foi tratado.\nConsequentemente, sugere-se que as equa\u00e7\u00f5es n\u00e3o-lineares sejam abordadas. Nesse\ncaso, as estimativas residuais propostas em Verf\u00fcrth (2014), Verf\u00fcrth (2004) e\n\n1. O projeto FEniCS traz documenta\u00e7\u00e3o e sugest\u00f5es de como conjugar o MatlabR e as bibliotecas\ndo Projeto FEniCS.\n\n\n\n6.1. Sugest\u00f5es para Trabalhos Futuros 141\n\nPraetorius, Weinmuller e Wissgott (2008) precisam ser revisadas para adequa\u00e7\u00e3o\n\u00e0s estimativas propostas em Verf\u00fcrth (2004b).\n\n5. A integra\u00e7\u00e3o dessas ferramentas e c\u00f3digos desenvolvidos em um software de\nreferenciamento geogr\u00e1fico \u00e9 outro aspecto importante a ser considerado. O trabalho\ndesenvolvido por Firmiano (2015) leva em conta essa integra\u00e7\u00e3o.\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2013\n\n\n\n\n\n143\n\nRefer\u00eancias\n\nAYACHIT, U. The ParaView Guide: A Parallel Visualization Application. Kitware, 2015.\nISBN 978-1930934306.\n\nBATU, V. Applied Flow and Solute Transport Modeling in Aquifers: Fundamental\nPrinciples and Analytical and Numerical Methods.: CRC Press Taylor, 2006. ISBN 10:\n0-8493-3574-4 (Hardcover).\n\nBEAR, J. Hydrogeology.: CRC Press Taylor, 1979. 698 p.\n\nBEKHIT, H. M.; EL-KORDY, M. A.; HASSAN, A. E. Contaminant transport in\ngroundwater in the presence of colloids and bacteria: Model development and verification.\nJournal of Contaminant Hydrology, v. 108, n. 3-4, p. 152\u2013167, set. 2009. ISSN 01697722.\n\nBELL, W. N.; OLSON, L. N.; SCHRODER, J. B. PyAMG: Algebraic Multigrid Solvers in\nPython v2.0. 2011. Release 2.0. Dispon\u00edvel em:&lt;http://www.pyamg.org>.\n\nBREZINA, M. et al. Adaptive smoothed aggregation (?SA). SIAM J. SCI. COMP, v. 25,\nn. 6, p. 2004, 2004.\n\nBREZINA, M. et al. Adaptive algebraic multigrid. SIAM J. Sci. Comput.,\nv. 27, n. 4, p. 1261\u20131286, nov. 2005. ISSN 1064-8275. Dispon\u00edvel em:&lt;http:\n//dx.doi.org/10.1137/040614402>.\n\nBREZINA, M. et al. Towards adaptive smoothed aggregation (?sa) for nonsymmetric\nproblems. SIAM Journal on Scientific Computing, v. 32, n. 1, p. 14\u201339, jan. 2010. ISSN 1064-\n8275, 1095-7197. Dispon\u00edvel em:&lt;http://epubs.siam.org/doi/abs/10.1137/080727336>.\n\nBRIGGS, W. L. A multigrid tutorial. 1999. Dispon\u00edvel em:&lt;http://www.mgnet.org>.\nAcesso em: 24 set. 2012.\n\nCAO, J.; KITANIDIS, P. K. Adaptive-grid simulation of groundwater flow in heterogeneous\naquifers. Advances in Water Resources, v. 22, n. 7, p. 681\u2013696, abr. 1999. ISSN 0309-1708.\nDispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/S0309170898000475>.\n\nCOUMOU, D. et al. A parallel FE\u2013FV scheme to solve fluid flow in complex geologic\nmedia. Computers &amp; Geosciences, v. 34, n. 12, p. 1697\u20131707, dez. 2008. ISSN 0098-3004.\nDispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/S009830040800112X>.\n\nDETWILER, R. L. et al. Comparison of an algebraic multigrid algorithm to two iterative\nsolvers used for modeling ground water flow and transport. Ground water, v. 40, n. 3, p.\n267\u2013272, jun. 2002. ISSN 0017-467X. PMID: 12019641.\n\nhttp://www.pyamg.org\nhttp://dx.doi.org/10.1137/040614402\nhttp://dx.doi.org/10.1137/040614402\nhttp://epubs.siam.org/doi/abs/10.1137/080727336\nhttp://www.mgnet.org\nhttp://www.sciencedirect.com/science/article/pii/S0309170898000475\nhttp://www.sciencedirect.com/science/article/pii/S009830040800112X\n\n\n144 Refer\u00eancias\n\nDOUGLAS, C. C. MGNet: A Multigrid and Domain Decomposition Network.\nSIGNUM Newsl., v. 27, n. 4, p. 2\u20138, out. 1992. ISSN 0163-5778. Dispon\u00edvel em:\n<http://doi.acm.org/10.1145/148089.148092>.\n\nECLIPSE FOUNDATION. Eclipse IDE for Java. 2015. Dispon\u00edvel em:&lt;https:\n//eclipse.org/>.\n\nFALGOUT, R. D.; YANG, U. M. hypre: a Library of High Performance Preconditioners.\nIn: Preconditioners,\u201d Lecture Notes in Computer Science. [S.l.: s.n.], 2002. p. 632\u2013641.\n\nFENICS PROJECT. Fenics Project. 2014. Dispon\u00edvel em:&lt;http://fenicsproject.org/>.\n\nFIRMIANO, A. Um Estimador de Erro a posteriori para a Equa\u00e7\u00e3o do Transporte de\nContaminantes em Regime de Pequena Advec\u00e7\u00e3o. Tese (Doutorado) \u2014 Escola de Engenharia\nde S\u00e3o Carlos, EESC-USP, 2010. Dispon\u00edvel em:&lt;EscoladeEngenhariadeS~aoCarlos/\nUSP>.\n\nFIRMIANO, A. Relat\u00f3rio P\u00f3s-Doc 2014 das atividades desenvolvidas na FH-K\u00d6LN como\nparte integrante do \"Programa Ci\u00eancia Sem Fronteiras\"(CsF) em parceria com a miss\u00e3o\nextra plamens exterior do Minist\u00e9rio da Defesa e da Institui\u00e7\u00e3o de origem, A Academia\nda For\u00e7a A\u00e9rea - AFA, 2015. Nota: Fornecido pelo autor.\n\nFIRMIANO, A. et al. Estimando os limites inferiores e superiores do erro residual da\nsolu\u00e7\u00e3o num\u00e9rica de um modelo adr. CQD-Revista Eletr\u00f4nica Paulista de Matem\u00e1tica,\nv. 02, 2013. Dispon\u00edvel em:&lt;http://www2.fc.-10>.\n\nFIRMIANO, A. et al. Estimando os limites inferiores e superiores do erro residual da\nsolu\u00e7\u00e3o num\u00e9rica de um modelo adr. In: CNMAC, 2012, \u00c1guas de Lind\u00f3ia. Anais do\nCNMAC. S\u00e3o Carlos, S\u00e3o Paulo: SBMAC, 2012. v. 04, p. 312\u2013318.\n\nFIRMIANO, A.; SANTOS, J. P. M.; WENDLAND, E. C. Implementa\u00e7\u00e3o java no estudo\ndo erro residual da equa\u00e7\u00e3o do transporte de contaminantes. Perspectivas em Ci\u00eancias\nTecnol\u00f3gicas, v. 02, p. 09\u201320, 2013.\n\nFIRMIANO, A.; WENDLAND, E.; SANTOS, J. P. M. Avalia\u00e7\u00e3o do \u00cdndice de efici\u00eancia\ndo indicador residual aplicado na equa\u00e7\u00e3o do transporte de contaminantes. In: ERMAC,\n2012, Botucatu. [S.l.: s.n.], 2012. v. 1.\n\nFITTS, C. R. 11 - groundwater contamination. In: Groundwater Science (Second Edition).\nBoston: Academic Press, 2013. p. 499\u2013585. ISBN 978-0-12-384705-8. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/B978012384705800011X>.\n\nFULTON, S. E.; CIELSILSKI, P. E.; SCHUBERT, W. H. Multigrid methods for elliptic\nproblems: a review. Monthly Weather Review, v. 14, p. 943\u2013959, 1986. Dispon\u00edvel em:\n<http://www.twister.ou.edu/CFD2001/>.\n\nGEE, M. et al. ML 5.0 Smoothed Aggregation User\u2019s Guide. Sandia National Laboratories,\n2006. Dispon\u00edvel em:&lt;http://trilinos.sandia.gov/packages/ml/mlguide5.pdf>.\n\nhttp://doi.acm.org/10.1145/148089.148092\nhttps://eclipse.org/\nhttps://eclipse.org/\nhttp://fenicsproject.org/\nEscola de Engenharia de S~ao Carlos/USP\nEscola de Engenharia de S~ao Carlos/USP\nhttp://www2.fc.-10\nhttp://www.sciencedirect.com/science/article/pii/B978012384705800011X\nhttp://www.twister.ou.edu/CFD2001/\nhttp://trilinos.sandia.gov/packages/ml/mlguide5.pdf\n\n\nRefer\u00eancias 145\n\nH\u00d6LTER, B.; VANDERBERGHE, G. A comparison of vectorized methods\nfor solving the two-dimensional diffusion equation: multigrid versus polynomial\npreconditioned conjugate gradient. Applied Mathematics and Computation,\nv. 40, n. 1, p. 77\u2013103, nov. 1990. ISSN 0096-3003. Dispon\u00edvel em:&lt;http:\n//www.sciencedirect.com/science/article/pii/009630039090099O>.\n\nHOFINGER, G.; JUDEX, F. Pollution in groundwater flow: definition of argesim\ncomparison c19. Simulation News Europe, v. 44, n. 45, p. 51\u201352, 2005.\n\nHUNTER, J. D. Matplotlib: A 2d graphics environment. Computing In Science &amp;\nEngineering, IEEE COMPUTER SOC, v. 9, n. 3, p. 90\u201395, 2007.\n\nJANKA, A. Smoothed aggregation multigrid for incompressible flows. 2007. Dispon\u00edvel em\nhttp://perso.unifr.ch/ales.janka/papers/ acessado em 23/11/2012.\n\nJANKA, A. Smoothed aggregation multigrid for incompressible flows. PAMM,\nv. 7, n. 1, p. 1025901\u20131025902, 2007. ISSN 1617-7061. Dispon\u00edvel em:&lt;http:\n//onlinelibrary.wiley.com/doi/10.1002/pamm.200700457/abstract>.\n\nJONES, E. et al. SciPy: Open source scientific tools for Python. 2001. Dispon\u00edvel em:\n<http://www.scipy.org/>.\n\nKRAUS, J.; MARGENOV, S. Robust Algebraic Multilevel Methods and Algorithms. [S.l.]:\nWalter de Gruyter GmbH &amp; Co., 2009. ISBN 978-3-11-019365-7.\n\nLAI, M.-C.; WU, C.-T.; TSENG, Y.-H. An efficient semi-coarsening multigrid\nmethod for variable diffusion problems in cylindrical coordinates. Applied Numerical\nMathematics, v. 57, n. 5\u20137, p. 801\u2013810, maio 2007. ISSN 0168-9274. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/S0168927406001577>.\n\nLAPWORTH, D. et al. Emerging organic contaminants in groundwater: A review of\nsources, fate and occurrence. Environmental Pollution, v. 163, n. 0, p. 287\u2013303, abr. 2012.\nISSN 0269-7491. Dispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/\nS0269749111007044>.\n\nLARSON, F. B. M. G. The Finite Element Method: Theory, Implementation, and Practice.\nSpringer, 2010. 270 p.\n\nLI, M.; CHENG, H.; YEH, G. Solving 3D subsurface flow and transport with adaptive\nmultigrid. Journal of Hydrologic Engineering, v. 5, n. 1, p. 74\u201381, 2000. ISSN 1084-0699.\nDispon\u00edvel em:&lt;http://ascelibrary.org/doi/abs/10.1061/%28ASCE%291084-0699%\n282000%%295%3A1%2874%29>.\n\nLOGG, A. et al. Automated Solution of Differential Equations by the Finite Element\nMethod. [S.l.]: Springer, 2012. ISBN 978-3-642-23098-1.\n\nhttp://www.sciencedirect.com/science/article/pii/009630039090099O\nhttp://www.sciencedirect.com/science/article/pii/009630039090099O\nhttp://onlinelibrary.wiley.com/doi/10.1002/pamm.200700457/abstract\nhttp://onlinelibrary.wiley.com/doi/10.1002/pamm.200700457/abstract\nhttp://www.scipy.org/\nhttp://www.sciencedirect.com/science/article/pii/S0168927406001577\nhttp://www.sciencedirect.com/science/article/pii/S0269749111007044\nhttp://www.sciencedirect.com/science/article/pii/S0269749111007044\nhttp://ascelibrary.org/doi/abs/10.1061/%28ASCE%291084-0699%282000% %295%3A1%2874%29\nhttp://ascelibrary.org/doi/abs/10.1061/%28ASCE%291084-0699%282000% %295%3A1%2874%29\n\n\n146 Refer\u00eancias\n\nMACLACHLAN, S. P. Improving Robustness in Multiscale Methods. Tese (Doutorado) \u2014\nDepartment of Applied Mathematics, Faculty of the Graduate School of the University\nof Colorado, 2004. Dispon\u00edvel em&lt;http://neumann.math.tufts.edu/~scott/research/\nSMthesis.pdf.>\n\nMCBRYAN, O. A. et al. Multigrid methods on parallel computers\u2014A survey of recent\ndevelopments. IMPACT of Computing in Science and Engineering, v. 3, n. 1, p. 1\u201375,\nmar. 1991. ISSN 0899-8248. Dispon\u00edvel em:&lt;http://www.sciencedirect.com/science/\narticle/pii/089982489190015M>.\n\nMEHL, S. W.; HILL, M. C. MODFLOW-2000, the U.S. Geological Survey Modular\nGround-Water Model \u2013 User Guide to the Link-AMG (LMG) Package for Solving\nMatrix Equations Using an Algebraic Multigrid Solver. 2001. Dispon\u00edvel em:\n<http://water.usgs.gov/acessadoem21/11/2012>. Acesso em: 21 nov. 2012.\n\nMURATOVA, G. V.; ANDREEVA, E. M. Multigrid method for solving convection-\ndiffusion problems with dominant convection. Journal of Computational and Applied\nMathematics, v. 226, n. 1, p. 77\u201383, abr. 2009. ISSN 0377-0427. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/S0377042708002239>.\n\nMUSTAPHA, H.; GHORAYEB, A.; MUSTAPHA, K. Underground flow simulations using\nparallel finite element method. Computers &amp; Geosciences, v. 36, n. 2, p. 161\u2013166, fev.\n2010. ISSN 0098-3004. Dispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/\nS0098300409002933>.\n\nNOTAY, Y. Aggregation-based algebraic multigrid for convection-diffusion equations.\nSIAM Journal on Scientific Computing, v. 34, n. 4, p. A2288\u2013A2316, jan. 2012. ISSN 1064-\n8275, 1095-7197. Dispon\u00edvel em:&lt;http://epubs.siam.org/doi/abs/10.1137/110835347>.\n\nPARKHURST D.L., K. K. E. P.; CHARLTON, S. Phast \u2013 a program for simulating\ngroundwater flow, solute transport and multicomponent geochemical reactions. usgs,\ndenver, colorado, 2004. In: Techniques and Methods 6\u2013A8, 154 p. U.S. Geological Survey,\n2004. Dispon\u00edvel em:&lt;http://pubs.usgs.gov/tm/2005/tm6A8/pdf/tm6a8.pdf>.\n\nPRAETORIUS, D.; WEINMULLER, E.; WISSGOTT, P. A Space-Time Adaptive\nAlgorithm for Linear Parabolic Problems. [S.l.], 2008. Available at www.asc.tuwien.ac.at\nISBN 978-3-902627-00-1.\n\nRUGE, J.; ST\u00dcBEN, K. Algebraic Multigrid (AMG), in \u201cMultigrid Methods\u201d (S.\nMcCormick, ed.), Frontiers in Applied Mathematics, Vol 5. [S.l.]: SIAM- Society for\nIndustrial and Applied Mathematics, 1986. Philadelphia.\n\nSAAD, Y. Iterative Methods for Sparse Linear Systems. SIAM- Society for Industrial and\nApplied Mathematics, 2003.\n\nhttp://neumann.math.tufts.edu/~scott/research/SMthesis.pdf.\nhttp://neumann.math.tufts.edu/~scott/research/SMthesis.pdf.\nhttp://www.sciencedirect.com/science/article/pii/089982489190015M\nhttp://www.sciencedirect.com/science/article/pii/089982489190015M\nhttp://water.usgs.gov/ acessado em 21/11/2012\nhttp://www.sciencedirect.com/science/article/pii/S0377042708002239\nhttp://www.sciencedirect.com/science/article/pii/S0098300409002933\nhttp://www.sciencedirect.com/science/article/pii/S0098300409002933\nhttp://epubs.siam.org/doi/abs/10.1137/110835347\nhttp://pubs.usgs.gov/tm/2005/tm6A8/pdf/tm6a8.pdf\n\n\nRefer\u00eancias 147\n\nSAIED, F.; MAHINTHAKUMAR, G. Efficient parallel multigrid based solvers\nfor large scale groundwater flow simulations. Computers &amp; Mathematics with\nApplications, v. 35, n. 7, p. 45\u201354, abr. 1998. ISSN 0898-1221. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/S0898122198000315>.\n\nSANTOS, J.P. M. ;FIRMIANO; A.; WENDLAND, E. Jump dominance on the\ncontaminant transport residual error estimator. Tend\u00eancias em Matem\u00e1tica Aplicada e\nComputacional, v. 15, p. 037\u2013046, 2014.\n\nSANTOS, J. P. M.; FIRMIANO, A.; WENDLAND, E. C. In: . [S.l.: s.n.].\n\nSANTOS, J. P. M.; FIRMIANO, A.; WENDLAND, E. C. Domin\u00e2ncia das contribui\u00e7\u00f5es\nlaterais no estimador residual da equa\u00e7\u00e3o do transporte de contaminantes. In: Congresso\nde Matem\u00e1tica Aplicada e Computacional CMAC Sudeste 2013, 2013, Bauru. Anais do\nCongresso de Matem\u00e1tica Aplicada e Computacional CMAC Sudeste 2013. S\u00e3o Carlos,\nS\u00e3o Paulo: [s.n.].\n\nSCOTT, T. Multi-grid methods for oil reservoir simulation in two and three dimensions.\nJournal of Computational Physics, v. 59, n. 2, p. 290\u2013307, jun. 1985. ISSN 0021-9991.\nDispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/0021999185901470>.\n\nSIMMONS, C. T.; FENSTEMAKER, T. R.; JR., J. M. S. Variable-density groundwater\nflow and solute transport in heterogeneous porous media: approaches, resolutions and\nfuture challenges. Journal of Contaminant Hydrology, v. 52, n. 1\u20134, p. 245\u2013275, nov. 2001.\nISSN 0169-7722. Dispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/\nS0169772201001607>.\n\nDE SMEDT, F. Groundwater ModellingCourse Notes, 2006 Dispon\u00edvel em:\n<Home-page:http://homepages.vub.ac.be/~fdesmedt/>;\n\nSOREK, S. Two-dimensional adaptive Eulerian-Lagrangian method for mass\ntransport with spatial velocity distribution. Transport in Porous Media, v. 3,\nn. 5, p. 473\u2013489, out. 1988. ISSN 0169-3913, 1573-1634. Dispon\u00edvel em:&lt;http:\n//rd.springer.com/article/10.1007/BF00138612>.\n\nST\u00dcBEN, K. A review of algebraic multigrid. Journal of Computational and Applied\nMathematics, v. 128, n. 1\u20132, p. 281\u2013309, mar. 2001. ISSN 0377-0427. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/S0377042700005161>.\n\nST\u00dcBEN, K.; DELANEY, P.; CHMAKOV, S. Algebraic multigrid (amg) for ground water\nflow and oil reservoir simulation. 2010. Dispon\u00edvel em acessado em 10/2012. Dispon\u00edvel\nem:&lt;https://www.scai.fraunhofer.de/fileadmin/download/samg/paper/Modflow\\_Paper.\npdf>. Acesso em: 15/05/2015.\n\nST\u00dcBEN, K. Multigrid Methods and Parallel Computing. 2009. Dispon\u00edvel em:\n<http://feflow.info/uploads/media/Stueben.pdf>. Acesso em: 26 set. 2015.\n\nhttp://www.sciencedirect.com/science/article/pii/S0898122198000315\nhttp://www.sciencedirect.com/science/article/pii/0021999185901470\nhttp://www.sciencedirect.com/science/article/pii/S0169772201001607\nhttp://www.sciencedirect.com/science/article/pii/S0169772201001607\nHome-page: http://homepages.vub.ac.be/~fdesmedt/\nhttp://rd.springer.com/article/10.1007/BF00138612\nhttp://rd.springer.com/article/10.1007/BF00138612\nhttp://www.sciencedirect.com/science/article/pii/S0377042700005161\nhttps://www.scai.fraunhofer.de/fileadmin/download/samg/paper/Modflow\\_Paper.pdf\nhttps://www.scai.fraunhofer.de/fileadmin/download/samg/paper/Modflow\\_Paper.pdf\nhttp://feflow.info/uploads/media/Stueben.pdf\n\n\n148 Refer\u00eancias\n\nTRANGENSTEIN, J. A. Multi-scale iterative techniques and adaptive mesh\nrefinement for flow in porous media. Advances in Water Resources, v. 25,\nn. 8\u201312, p. 1175\u20131213, ago. 2002. ISSN 0309-1708. Dispon\u00edvel em:&lt;http:\n//www.sciencedirect.com/science/article/pii/S0309170802000532>.\n\nTROTTENBERG, U.; OOSTERLEE, C.; SCHULLER, A. Multigrid. [S.l.]: Academic\nPress, 2001.\n\nTUFENKJI, N.; EMELKO, M.; NRIAGU, E. in C. O. Fate and transport of\nmicrobial contaminants in groundwater. In: Encyclopedia of Environmental Health.\nBurlington: Elsevier, 2011. p. 715\u2013726. ISBN 978-0-444-52272-6. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/B9780444522726000404>.\n\nVAN?K, P. Fast multigrid solver. Applications of Mathematics, v. 40, n. 1, p. 1\u201320, 1995.\nISSN 0862-7940. Dispon\u00edvel em:&lt;http://dml.cz/dmlcz/134274>.\n\nVAN?K, P. et al. Algebraic multigrid by smoothed aggregation for second and fourth\norder elliptic problems. Computing, v. 56, p. 179\u2013196, 1995.\n\nVERF\u00dcRTH, R. A posteriori error estimates for non-linear parabolic equations. Dispon\u00edvel\nem:&lt;http://www.ruhr-uni-bochum.de/num1/files/reports/APNLPE.pdf>.\n\nVERF\u00dcRTH, R. A posteriori error estimates for linear parabolic equations. p. 26, 2004.\nDispon\u00edvel em:&lt;http://www.ruhr-uni-bochum.de/num1/files/reports/APEELPE.pdf>.\n\nVERF\u00dcRTH, R. Adaptive Finite Element Methods: Lecture Notes Winter Term 2013/14.\n[s.n.], 2014. Dispon\u00edvel em:&lt;http://www.ruhr-uni-bochum.de/num1/files/lectures/\nAdaptiveFEM.pdf>.\n\nWALT, S. van der; COLBERT, S.; VAROQUAUX, G. The NumPy Array: A Structure\nfor Efficient Numerical Computation. Computing in Science Engineering, v. 13, n. 2, p.\n22\u201330, mar. 2011. ISSN 1521-9615.\n\nWEXLER, E. Chapter b7: Applications of hydraulics analytical solutions for one-, two-\nand three-dimensional solute transport in groundwater systems with uniform flow. In:\nTechniques of Water Resources Investigations of the United State Geological Survey, Book\n3: Applications to Hydraulics. Denver, USA: U.S. Geological Survey, 1992.\n\nWU, C.-t.; HOWARD; ELMAN, C. Analysis and comparison of geometric and algebraic\nmultigrid for convection-diffusion equations. [S.l.], 2004.\n\nZHANG, J.; SUN, H.; ZHAO, J. J. High order compact scheme with multigrid local mesh\nrefinement procedure for convection diffusion problems. Computer Methods in Applied\nMechanics and Engineering, v. 191, n. 41\u201342, p. 4661\u20134674, set. 2002. ISSN 0045-7825.\nDispon\u00edvel em:&lt;http://www.sciencedirect.com/science/article/pii/S0045782502003985>.\n\nhttp://www.sciencedirect.com/science/article/pii/S0309170802000532\nhttp://www.sciencedirect.com/science/article/pii/S0309170802000532\nhttp://www.sciencedirect.com/science/article/pii/B9780444522726000404\nhttp://dml.cz/dmlcz/134274\nhttp://www.ruhr-uni-bochum.de/num1/files/reports/APNLPE.pdf\nhttp://www.ruhr-uni-bochum.de/num1/files/reports/APEELPE.pdf\nhttp://www.ruhr-uni-bochum.de/num1/files/lectures/AdaptiveFEM.pdf\nhttp://www.ruhr-uni-bochum.de/num1/files/lectures/AdaptiveFEM.pdf\nhttp://www.sciencedirect.com/science/article/pii/S0045782502003985\n\n\nRefer\u00eancias 149\n\nZOPPOU, C.; KNIGHT, J. H. Analytical solution of a spatially variable coefficient\nadvection\u2013diffusion equation in up to three dimensions. Applied Mathematical\nModelling, v. 23, n. 9, p. 667\u2013685, set. 1999. ISSN 0307-904X. Dispon\u00edvel em:\n<http://www.sciencedirect.com/science/article/pii/S0307904X99000050>.\n\nhttp://www.sciencedirect.com/science/article/pii/S0307904X99000050\n\n\n\n\n151\n\nAP\u00caNDICE A \u2013 C\u00f3digo Python\n\nNesta parte, a implementa\u00e7\u00e3o em linguagem de programa\u00e7\u00e3o Python, desenvolvida\nna plataforma Eclipse (ECLIPSE FOUNDATION, 2015), \u00e9 descrita em detalhe. As\nfun\u00e7\u00f5es, classes e resultados gr\u00e1ficos apresentados utilizam as bibliotecas Numpy (WALT;\nCOLBERT; VAROQUAUX, 2011), Scipy (JONES et al., 2001), Matplotlib (HUNTER,\n2007), ParaView (AYACHIT, 2015) juntamente com aquelas disponibilizadas pela biblioteca\nFEniCS (FENICS PROJECT, 2014). Uma descri\u00e7\u00e3o completa do Projecto FEniCS \u00e9 o\nlivro (LOGG et al., 2012).\n\nO cap\u00edtulo [B] fornece alguns exemplos de c\u00f3digos completos para a solu\u00e7\u00e3o pelo\nm\u00e9todo dos elementos finitos, a implementa\u00e7\u00e3o da solu\u00e7\u00e3o anal\u00edtica de Wexler (1992), o\nm\u00e9todo multigrid com reutiliza\u00e7\u00e3o e a metodologia de compara\u00e7\u00e3o de solu\u00e7\u00f5es.\n\nA.1 C\u00f3digos para o Estimador Residual\n\nNesta se\u00e7\u00e3o, as classes e fun\u00e7\u00f5es necess\u00e1rias \u00e0 implementa\u00e7\u00e3o do estimador residual\ns\u00e3o apresentadas. Esses c\u00f3digos incluem as classes e fun\u00e7\u00f5es necess\u00e1rias para a obten\u00e7\u00e3o\ndas estimativas residuais para o regime de pequena advec\u00e7\u00e3o. Al\u00e9m disso, s\u00e3o fornecidos\nos indicadores de erros e algumas classes e fun\u00e7\u00f5es adicionais desenvolvidas, mas que n\u00e3o\nforam utilizadas na tese.\n\nPrimeiramente, o desenvolvimento dos c\u00f3digos \u00e9 baseado nas bibliotecas Numpy e\ndolfin, a qual \u00e9 disponibilizada atrav\u00e9s do Projeto FEniCS(FENICS PROJECT, 2014). A\nadequada manipula\u00e7\u00e3o das estruturas matriciais para posterior disponibiliza\u00e7\u00e3o para os\nm\u00e9todos iterativos \u00e9 feita atrav\u00e9s do pacote scipy.sparse. Essas ferramentas s\u00e3o disponibi-\nlizadas atrav\u00e9s do c\u00f3digo abaixo:\n\n1 import numpy as np\nfrom numpy import ?\n\n3 from dolfin import ?\ndolfin .parameters.reorder_dofs_serial = False\n\n5 #https://answers.launchpad.net/dolfin/+question/219220\n#????????????????????????????????????????????????????????\n\n7 # Part I: Setup problem with Dolfin\ntry:\n\n9 from dolfin import ?\nexcept ImportError:\n\n11 raise ImportError(\u2019Problem with Dolfin Installation\u2019)\nparameters.linear_algebra_backend = \"uBLAS\"\n\n13 #????????????????????????????????????????????????????????\nfrom scipy.sparse import csr_matrix\n\n15 from numpy import intc\n\n\n\n152 AP\u00caNDICE A. C\u00f3digo Python\n\nA.1.1 C\u00f3digo para a proje\u00e7\u00e3o L2\n\nA fun\u00e7\u00e3o projectionFunction(**kargs) disponibiliza o sistema linear associado\nao c\u00e1lculo da proje\u00e7\u00e3o L2 de uma fun\u00e7\u00e3o f. Essa ferramenta pode ser \u00fatil para os m\u00e9todos\ndispon\u00edveis na biblioteca num\u00e9rica PyAMG, a qual permite a utiliza\u00e7\u00e3o dos m\u00e9todos\nmultigrid alg\u00e9bricos.\n\n1.Uso: Aspf,bf,nfsize=projectionFunction(mesh,C,f)\n\n2.mesh: malha de elementos finitos;\n\n3.C: espa\u00e7o de fun\u00e7\u00f5es lagrangeanas definido sobre a malha de elementos finitos;\n\n4.f: a express\u00e3o anal\u00edtica para a fun\u00e7\u00e3o f;\n\n5.Aspf, bf,nfsize: a matriz do sistema linear Asp? fprojection = bf, em que fprojection\n\u00e9 a proje\u00e7\u00e3o L2 a ser calculada, bf \u00e9 o lado direito do sistema linear e nfsize \u00e9 o\ntamanho do sistema linear associado.\n\n1 def projectionFunction(mesh,C,f):\n# Define variational problem for projection\n\n3 wf = TestFunction(C)\nvf = TrialFunction(C)\n\n5 af = inner(wf,vf)?dx\nLf = inner(wf,f)?dx\n\n7 # Assemble linear system with no boundary conditions because defining a function\nAf, rhsf = assemble_system(af,Lf)\n\n9\n(rowf, colf ,dataf) = Af.data() # get sparse data\n\n11 colf = intc(colf )\nrowf = intc(rowf)\n\n13 nfsize = Af.size(0)# the size of the linear system\nAspf = csr_matrix((dataf,colf,rowf),shape=(nfsize,nfsize))\n\n15 bf = rhsf.data()\nreturn Aspf,bf, nfsize\n\nA.1.2 C\u00f3digo para campo gradiente cont\u00ednuo\n\nA fun\u00e7\u00e3o ProjectionGradient(**kargs) disponibiliza o campo gradiente cont\u00ednuo,\no qual \u00e9 obtido da solu\u00e7\u00e3o de elementos finitos do problema do transporte. Este c\u00e1lculo\npode ser \u00fatil, quando existe a exig\u00eancia por campos gradientes cont\u00ednuos e \u00e9 baseado nos\nexemplos dispon\u00edveis no endere\u00e7o eletr\u00f4nico do Projeto FEniCS. Da mesma forma que\n\n\n\nA.1. C\u00f3digos para o Estimador Residual 153\n\nno item anterior, o sistema linear associado pode ser disponibilizado para a solu\u00e7\u00e3o com\noutros m\u00e9todos iterativos.\n\n1.Uso:\n\ngradFieldContx,gradFieldConty,\\\ngradFieldCont=ProjectionGradient(mesh,gradField,degree)\n\n2.mesh: malha de elementos finitos;\n\n3.gradField: o campo gradiente calculado pelo m\u00e9todo de elementos finitos;\n\n4.degree: grau do espa\u00e7o de fun\u00e7\u00f5es;\n\n5.gradFieldContx,gradFieldConty,gradFieldCont: campo gradiente cont\u00ednuo na di-\nre\u00e7\u00e3o x, campo gradiente cont\u00ednuo na dire\u00e7\u00e3o y e campo gradiente, respectivamente.\n\ndef ProjectionGradient(mesh,gradField,degree):\n2 Vg = VectorFunctionSpace(mesh,\u2019Lagrange\u2019,degree)\n\nw = TrialFunction(Vg)\n4 v1 = TestFunction(Vg)\n\na = inner(w,v1)?dx(mesh)\n6 L = inner(gradField, v1)?dx\n\ngradFieldCont= Function(Vg)\n8 solve(a == L,gradFieldCont)\n\nparameters[\u2019allow_extrapolation\u2019] = True\n10 gradFieldContx,gradFieldConty = gradFieldCont.split(deepcopy=True)\n\nreturn gradFieldContx,gradFieldConty,gradFieldCont\n\nA.1.3 C\u00f3digo para transformar os dados\n\nA fun\u00e7\u00e3o MakeSystem_and_TransformData(**kargs) disponibiliza o sistema linear\nassociado ao problema do transporte de contaminantes. Esta ferramenta, possibilita a\nutiliza\u00e7\u00e3o de outros m\u00e9todos iterativos para resolver o sistema linear. No entanto, neste\ntrabalho, este processo \u00e9 pouco utilizado, pois o autor prefere a transforma\u00e7\u00e3o direta\ndentro do c\u00f3digo utilizado.\n\n1.Uso: Asp,b,nsize=MakeSystem_and_TransformData(a,L,boundary_parts,bcs)\n\n2.a, L: formas bilinear e linear associadas ao problema do transporte ;\n\n3.boundary_parts: classes definindo a fronteira de Neumann;\n\n4.bcs: lista de classes definindo a fronteira de Dirichlet;\n\n5.Asp,b,nsize: o sistema linear, o lado direito e o tamanho do sistema linear, respectiva-\nmente.\n\n\n\n154 AP\u00caNDICE A. C\u00f3digo Python\n\n1 def MakeSystem_and_TransformData(a,L,boundary_parts,bcs):\nA = assemble(a, exterior_facet_domains=boundary_parts)\n\n3 rhs = assemble(L,exterior_facet_domains=boundary_parts)\n#Setting the Dirichlet boundary conditions\n\n5 for bc in bcs:\nbc.apply(A, rhs)\n\n7 (row,col,data) = A.data()\ncol = intc(col)\n\n9 row = intc(row)\nnsize = A.size(0)\n\n11 Asp = csr_matrix((data,col,row),shape=(nsize,nsize))\nb = rhs.data()\n\n13 return Asp,b,nsize\n\nA.1.4 C\u00f3digo para componentes do erro residual\n\nA fun\u00e7\u00e3o ErrorComponents(**kargs) disponibiliza as componentes do estimador\nresidual relacionado \u00e0 estimativa espacial sem considerar os residuais referentes aos dados\ndo problema.\n\n1.Uso:\n\nn,gx,rk,gradot,salt,rneumann,\\\nrdirichlet=ErrorComponents(mesh,D,c,c1,VField,theta,Lambda,fx,dt)\n\n2.mesh,n: malha de elementos finitos e vetor normal as arestas ou faces dos elementos;\n\n3.D,c,c1,VField,theta,Lambda,fx,dt: a matriz de dispers\u00e3o, a solu\u00e7\u00e3o no tempo k,\na solu\u00e7\u00e3o no tempo k ? 1, o campo de velocidades, o par\u00e2metro de discretiza\u00e7\u00e3o\ntemporal, a fun\u00e7\u00e3o de rea\u00e7\u00e3o, a proje\u00e7\u00e3o L2 da fun\u00e7\u00e3o f e o valor para o passo de\ntempo, respectivamente.\n\n3.gx: a proje\u00e7\u00e3o na dire\u00e7\u00e3o normal ao gradiente;\n\n4.rk,gradot: o erro residual do elemento e fun\u00e7\u00e3o auxiliar, respectivamente;\n\n5.salt,rneumann,rdirichlet: o erro do salto, o erro na fronteira de Neumann e o erro\nna fronteira de Dirichlet.\n\n1 def ErrorComponents(mesh,D,c,c1,VField,theta,Lambda,fx,dt):\nn = FacetNormal(mesh);\n\n3 gx=dot((D?grad(c)),n);\nrk=fx?(1.0/dt)?(c?c1)+div(D?grad(theta?c+(1.0?theta)?c1))?\\\n\n5 theta?dot(VField,grad(c))?(1.0?theta)?dot(VField,grad(c1))?Lambda?(theta?c?(1.0?theta)?c1);\nfunction=D?grad(theta?c+(1.0?theta)?c1);\n\n7 gradot=dot(function,n);\nsalt=?jump(gradot);\n\n9 rneumann=gx?gradot;\n\n\n\nA.1. C\u00f3digos para o Estimador Residual 155\n\nrdirichlet =0.0;\n11 return n,gx,rk,gradot,salt ,rneumann,rdirichlet\n\nA.1.5 C\u00f3digo para o fator de pondera\u00e7\u00e3o ?S\n\nA fun\u00e7\u00e3o AlphaS(**kargs) disponibiliza o fator de pondera\u00e7\u00e3o ?S := min(??1/2,??1/2)\npara a malha de elementos finitos. Essa fun\u00e7\u00e3o \u00e9 essencial para o c\u00e1lculo do estimador\nresidual e \u00e9 definida sobre todas as entidades da malha de elementos finitos.\n\n1.Uso: alphaS=AlphaS(mesh,epsilon,beta,C)\n\n2.mesh,epsilon,beta,C: malha de elementos finitos, epsilon=?, beta=?;\n\n3.alphaS: o fator de pondera\u00e7\u00e3o ?S definido em cada entidade da malha de elementos\nfinitos.\n\n1 def AlphaS(mesh,epsilon,beta,C):\ntolerance=1.0E?5\n\n3 class my_func(Expression):\ndef __init__(self,mesh,epsilon,beta):\n\n5 self .mesh = mesh\nself . epsilon = epsilon\n\n7 self .beta = beta\ndef eval_cell( self , values, x, ufc_cell):\n\n9 dolfin_cell = Cell( self .mesh, ufc_cell.index)\n#print dolfin_cell .diameter()\n\n11 if beta<=0.0+tolerance:\nvalues[0]=(1.0/np.sqrt(epsilon))?dolfin_cell .diameter()\n\n13 else :\nintermed=(1.0/np.sqrt(epsilon))?dolfin_cell .diameter()\n\n15 values [0] =min(intermed,1.0/np.sqrt(beta))\nalphaS=my_func(mesh,epsilon,beta);\n\n17 alphaS=interpolate(alphaS,C)\nreturn alphaS\n\nA.1.6 C\u00f3digo para as contribui\u00e7\u00f5es residuais\n\nA fun\u00e7\u00e3o FormErrorsDef(**kargs) disponibiliza as matrizes que armazenam as\ncontribui\u00e7\u00f5es residuais de cada entidade da malha de elementos finitos. Essa fun\u00e7\u00e3o\nincorpora todas as contribui\u00e7\u00f5es e \u00e9 um dos elementos principais do c\u00f3digo do estimador\nresidual.\n\n1.Uso:\n\n\n\n156 AP\u00caNDICE A. C\u00f3digo Python\n\nindicators1,indicators,indicator1,indicator2,indicator3,\\\ntime_indicator=FormErrorsDef(alpha_S,mesh,gx,rk,gradot,\\\n\nsalt,rneuman,rdirichlet,epsilon,beta)\n\n2.alphaS: o fator de pondera\u00e7\u00e3o ?S definido em cada entidade da malha de elementos\nfinitos.\n\n3.mesh,gx,rk,gradot,salt,rneuman,rdirichlet,epsilon,beta: malha de elementos\nfinitos, componentes do estimador residual e constantes epsilon=?, beta=?;\n\n4.indicators1,indicators,indicator1,indicator2,indicator3,time_indicator: as\ncontribui\u00e7\u00f5es residuais para cada entidade na malha de elementos finitos: as con-\ntribui\u00e7\u00f5es espaciais, dos elementos, dos saltos, das fronteiras e temporal, respectiva-\nmente.\n\ndef FormErrorsDef(alpha_S,mesh,gx,rk,gradot,salt,rneuman,rdirichlet,epsilon,beta):\n2 Constants = FunctionSpace(mesh,\"DG\", 0)\n\nw = TestFunction(Constants)\n4 # Define forms for assembling error indicators and error estimator\n\nform1 =alpha_S??2?rk??2?w?dx()\n6 #???COULD USE:form2=alpha_S(\u2019+\u2019)?salt??2?w(\u2019+\u2019)?dS\n\nform2=(1.0/np.sqrt(epsilon))?avg(alpha_S)?salt??2?avg(w)?dS\n8 form3=(1.0/np.sqrt(epsilon))?alpha_S?rneuman??2?w?ds(0)+(1.0/np.sqrt(epsilon))?alpha_S?rneuman??2\n\n?w?ds(1)\nform_time=epsilon?(grad(c?c1))??2?w?dx()+beta?(c?c1)??2?w?dx()\n\n10 form= form1+form2+form3; form_space=form1+form2+form3\nindicators1=assemble(form_space); indicators=assemble(form); indicator1=assemble(form1)\n\n12 indicator2=assemble(form2);indicator3=assemble(form3); time_indicator=assemble(form_time)\nreturn indicators1 , indicators ,indicator1,indicator2,indicator3,time_indicator\n\nA.1.7 C\u00f3digo para os indicadores residuais\n\nA fun\u00e7\u00e3o Indicators(**kargs) disponibiliza as matrizes que armazenam os indi-\ncadores residuais de cada entidade da malha de elementos finitos. Essa fun\u00e7\u00e3o possibilita a\nconstru\u00e7\u00e3o de estrat\u00e9gias de refinamento para o problema do transporte de contaminantes.\n\nNos casos em que as estimativas para os dados e para o regime de grande advec\u00e7\u00e3o\ns\u00e3o necess\u00e1rias, a manipula\u00e7\u00e3o adequada dessas classes deve ser efetuada.\n\n1.Uso:\n\nindicator_spatial,indicator_form1,indicator_form2,\nindicator_form3,indicator_time=Indicators(indicators1,indicators,\\\nindicator1,indicator2,indicator3,time_indicator)\n\n\n\nA.1. C\u00f3digos para o Estimador Residual 157\n\n2.indicators1,indicators,indicator1,indicator2,indicator3 e\ntime_indicator: as contribui\u00e7\u00f5es residuais para cada entidade na malha de ele-\nmentos finitos: as contribui\u00e7\u00f5es espaciais, dos elementos, dos saltos, das fronteiras e\ntemporal, respectivamente.\n\n3.indicator_spatial,indicator_form1,indicator_form2,indicator_form3 e\nindicator_time: os indicadores residuais locais para cada entidade na malha de\nelementos finitos: os indicadores espaciais, dos elementos, dos saltos, das fronteiras\nde Neumann e temporal.\n\n1 def Indicators(indicators1 , indicators ,indicator1,indicator2,indicator3,time_indicator):\n\"\"\" The various indicators that can be formed using the forms presented in AssembleForm_Estimates\"\"\"\n\n3 indicator_spatial =array([sqrt(i) for i in indicators ])\nindicator_form1 = array([sqrt(i) for i in indicator1 ])\n\n5 indicator_form2 = array([sqrt(i) for i in indicator2 ])\nindicator_form3 = array([sqrt(i) for i in indicator3 ])\n\n7 indicator_time = array([sqrt(i) for i in time_indicator])\nreturn indicator_spatial,indicator_form1,indicator_form2,indicator_form3,indicator_time\n\nA.1.8 C\u00f3digo para as estimativas residuais espacial e temporal\n\nA fun\u00e7\u00e3o ErrorEstimatesSpaceTime(**kargs) fornece as contribui\u00e7\u00f5es espacial,\ndos elementos, dos saltos, das fronteiras e temporal.\n\n1.Uso:\n\nerror_estimate_space,error_estimate1,error_estimate2,\\\nerror_estimate3,error_time=ErrorEstimatesSpaceTime(indicators1,indicators,\nindicator1,indicator2,indicator3,time_indicator,dt)\n\n2.error_estimate_space: a contribui\u00e7\u00e3o espacial, a qual \u00e9 composta da soma das con-\ntribui\u00e7\u00f5es dos elementos, dos saltos e das fronteiras, respectivamente;\n\n3.error_estimate1: a contribui\u00e7\u00e3o dos elementos, a qual \u00e9 composta da soma das con-\ntribui\u00e7\u00f5es residuais dos elementos RK;\n\n4.error_estimate2: a contribui\u00e7\u00e3o dos saltos, a qual \u00e9 composta da soma das contribui\u00e7\u00f5es\nresiduais dos saltos RE;\n\n5.error_estimate3: a contribui\u00e7\u00e3o das fronteiras de Neumann, a qual \u00e9 composta da soma\ndas contribui\u00e7\u00f5es residuais dos elementos, definidos sobre a fronteira de Neumann,\nRE.\n\n6.error_time: a contribui\u00e7\u00e3o temporal, a qual \u00e9 composta da soma das contribui\u00e7\u00f5es\nresiduais, sobre toda a malha de elementos finitos.\n\n\n\n158 AP\u00caNDICE A. C\u00f3digo Python\n\ndef ErrorEstimatesSpaceTime(indicators1,indicators,indicator1,indicator2,indicator3,time_indicator,dt):\n2 error_estimate_space = dt?(sum(i for i in indicators1 .array()))#the spatial error contribuition\n\nerror_estimate1 = dt?(sum(i for i in indicator1.array()))# local interior contribuition to global error\n4 error_estimate2 = dt?(sum(i for i in indicator2.array()))# local jump contribution to global error\n\nerror_estimate3 = dt?(sum(i for i in indicator3.array()))# local boundary contribuition to global\n6 error_time = dt?(sum(i for i in time_indicator.array()))# time contribuiton to global error\n\nreturn error_estimate_space,error_estimate1,error_estimate2,error_estimate3,error_time\n\nAs estimativas residuais para o regime de grande advec\u00e7\u00e3o podem ser inseridas por\nmeio de uma matriz de valores similar \u00e0 error_time.\n\nA.2 O regime de grande advec\u00e7\u00e3o\n\nNesta se\u00e7\u00e3o, as classes e fun\u00e7\u00f5es necess\u00e1rias \u00e0s estimativas residuais associadas ao\nregime de grande advec\u00e7\u00e3o s\u00e3o apresentadas. Essas estimativas devem ser incorporadas\nadequadamente \u00e0s estimativas temporais, obtidas na se\u00e7\u00e3o anterior.\n\nA.2.1 C\u00f3digo para as formas bilinear e linear do problema auxiliar\n\nA fun\u00e7\u00e3o FormLargeAdvection(**kargs) disponibiliza o sistema linear associado\nao problema auxiliar. Esse sistema linear pode ser resolvido por um m\u00e9todo multigrid\nalg\u00e9brico ou qualquer outro m\u00e9todo iterativo dispon\u00edvel.\n\n1.Uso: ALarge,bLarge=FormLargeAdvection(epsilon,beta,c,c1,v,mesh=mesh)\n\n2.epsilon=? e beta=? s\u00e3o as constantes envolvidas no estimador residual;\n\n3.c,c1,v,mesh: as solu\u00e7\u00f5es num\u00e9ricas no tempo k e k ? 1, o campo de velocidades e a\nmalha de elementos finitos;\n\n4.ALarge,bLarge: os componentes do sistema linear ALarge? ctil = bLarge, em que ctil\n\u00e9 a solu\u00e7\u00e3o do problema auxiliar associado ao problema do transporte.\n\n1 #??????????Form for large advection\ndef FormLargeAdvection(epsilon,beta,c,c1,v,mesh=mesh):\n\n3 degtil=1\nCtil = FunctionSpace(mesh,\"Lagrange\",degtil)\n\n5 ctil = TrialFunction(Ctil)\nwtil = TestFunction(Ctil)\n\n7 #?????????????????????????????????????????\nc=interpolate(c,Ctil)\n\n9 c1=interpolate(c1,Ctil)\ndifftil =c.vector()?c1.vector();\n\n11 diff =Function(Ctil)\ndiff .vector() [:]= difftil\n\n\n\nA.2. O regime de grande advec\u00e7\u00e3o 159\n\n13 #Dirichlet conditions is null as well the Neumann conditions\nc0=Constant(0.0)\n\n15 # the problem has only dirichlet boundary\nclass AuxiliarBoundary(SubDomain):\n\n17 def inside( self , x, on_boundary):\ntol = 1E?14\n\n19 return on_boundary\nGamma_0 = DirichletBC(Ctil, c0, AuxiliarBoundary())\n\n21 bcs=[Gamma_0]\ng=Constant(0.0)# the function for neumann boundaries...\n\n23 aLarge=inner(epsilon?nabla_grad(ctil),nabla_grad(wtil))?dx+beta?ctil?wtil?dx\nLLarge=inner(v,nabla_grad(diff))?wtil?dx?g?wtil?ds\n\n25 #Assemble and apply boundary conditions\nALarge=assemble(aLarge)\n\n27 bLarge=assemble(LLarge)\nfor bc in bcs:\n\n29 bc.apply(ALarge, bLarge)\nreturn ALarge,bLarge\n\n31\n\nA.2.2 C\u00f3digo para as contribui\u00e7\u00f5es residuais do problema auxiliar\n\nA fun\u00e7\u00e3o LargeAdvecEstimates(**kargs) implementa as contribui\u00e7\u00f5es residuais\nassociadas ao problema auxiliar. Analogamente \u00e0s contribui\u00e7\u00f5es residuais para o regime de\npequena advec\u00e7\u00e3o, essas contribui\u00e7\u00f5es s\u00e3o divididas entre as contribui\u00e7\u00f5es dos elementos e\ndos saltos.\n\n1.Uso:\n\nformarray,form1array,form2array,\nform3array=LargeAdvectionEstimates(alpha_S,mesh,epsilon,beta,c,\n\nc1,ctil,VField)\n\n2.alpha_S,mesh,epsilon,beta,c,c1,ctil,VField: o fator de pondera\u00e7\u00e3o ?S, a malha\nde elementos finitos, as constantes do estimador residual epsilon=? e beta=?, as\nsolu\u00e7\u00f5es num\u00e9ricas do problema do transporte nos tempos k e k ? 1, a solu\u00e7\u00e3o\nnum\u00e9rica do problema auxiliar ctil e o campo de velocidades, respectivamente.\n\n3.formarray: as matrizes que cont\u00eam as contribui\u00e7\u00f5es relativas ao problema auxiliar.\n\u00c9 composta das contribui\u00e7\u00f5es dos elementos, dos saltos e da norma da energia,\nrespectivamente.\n\n4.form1array,form2array,form3array: as contribui\u00e7\u00f5es dos elementos, dos saltos e da\nnorma da energia, respectivamente.\n\n\n\n160 AP\u00caNDICE A. C\u00f3digo Python\n\n5. Observa\u00e7\u00e3o: O termo ? \u00b7Div(ctil) que aparece nas f\u00f3rmulas apresentadas por (VER-\nF\u00dcRTH, 2014)n\u00e3o \u00e9 necess\u00e1rio, pois fun\u00e7\u00f5es lineares s\u00e3o consideradas. Isso n\u00e3o \u00e9\numa conveni\u00eancia, mas sim uma hip\u00f3tese do problema auxiliar.\n\ndef LargeAdvectionEstimates(alpha_S,mesh,epsilon,beta,c,c1,ctil,VField):\n2\n\nn = FacetNormal(mesh);# normal vector to facet elements\n4 rk=dot(VField,grad(c?c1))+div(epsilon?grad(ctil))?beta?ctil\n\ngradot=dot((grad(ctil)),n); salt=?jump(gradot);\n6 #?????????????????????????????????????????\n\nConstants = FunctionSpace(mesh,\"DG\",0)\n8 w = TestFunction(Constants)\n\n#?????????????????????????????????????????\n10 form1 =alpha_S??2?rk??2?w?dx# form to interior contribution\n\nform2=(1.0/np.sqrt(epsilon))?avg(alpha_S)?salt??2?avg(w)?dS# form for jump contributioN\n12 form3=epsilon?(grad(ctil))??2?w?dx+beta?(ctil)??2?w?dx# the |||ctil||| energy norm\n\n#?????????????????????????????????????????\n14 form=form1+form2+form3; formarray=assemble(form)\n\nform1array=assemble(form1);form2array=assemble(form2)\n16 form3array=assemble(form3)# matrices of values\n\nreturn formarray,form1array,form2array,form3array\n\nA.2.3 C\u00f3digo para obter as estimativas residuais do problema auxiliar\n\nA fun\u00e7\u00e3o AuxiliarErrorEstimatesSpaceTime fornece as contribui\u00e7\u00f5es residuais\nrelacionadas \u00e0s estimativas\n\n1 def AuxiliarErrorEstimatesSpaceTime(formLarge,form1Large,form2Large,form3Large,dt):\nprint \u2019divide by dt to get the space estimates without time step weight\u2019\n\n3 #???????????????????????????????????????????\nLargeGeralEstimate = dt?(sum(i for i in formLarge.array()))#the spatial contribuition\n\n5 LargeInteriorEstimate = dt?(sum(i for i in form1Large.array()))# interior contribution\nLargeJumpEstimate = dt?(sum(i for i in form2Large.array()))# jump contribution\n\n7 LargeEnergyCtilEstimate= dt?(sum(i for i in form3Large.array()))#energy contribution\nreturn LargeGeralEstimate,LargeInteriorEstimate,LargeJumpEstimate,LargeEnergyCtilEstimate\n\nA.3 C\u00f3digos para as estimativas dos dados\n\nNesta se\u00e7\u00e3o, as classes e fun\u00e7\u00f5es necess\u00e1rias \u00e0s estimativas residuais associadas\naos dados do problema do transporte s\u00e3o apresentadas. Essas estimativas devem ser\nincorporadas adequadamente \u00e0s estimativas espaciais, obtidas na se\u00e7\u00e3o A.1 deste cap\u00edtulo.\n\n\n\nA.3. C\u00f3digos para as estimativas dos dados 161\n\nA.3.1 C\u00f3digo das fun\u00e7\u00f5es auxiliares para estimativas dos dados\n\nSem perda de generalidade, suponha que d = d(x,y) seja uma express\u00e3o matem\u00e1tica\nque representa a dispers\u00e3o do problema do transporte. Suponha que a representa\u00e7\u00e3o na\nmalha de elementos finitos seja dada por dh. A representa\u00e7\u00e3o anal\u00edtica de d considera uma\nmalha refinada em espa\u00e7o de elementos finitos com fun\u00e7\u00f5es lagrangeanas de ordem superior.\nA fun\u00e7\u00e3o auxiliar DiffFunction(**kargs) fornece a diferen\u00e7a entre a aproxima\u00e7\u00e3o de\nelementos finitos e a representa\u00e7\u00e3o anal\u00edtica de d.\n\n1.Uso:\n\nDiffd,mesh,mesh2=DiffFunction(C,AnalyticalExpression,\nmesh,degree,raiseDegree)\n\n2.C,AnalyticalExpression,mesh,degree,raiseDegree: espa\u00e7o de fun\u00e7\u00f5es, express\u00e3o\nanal\u00edtica, malha de elementos finitos, grau do espa\u00e7o de fun\u00e7\u00f5es e grau adicional\npara criar espa\u00e7o de grau elevado.\n\n3.Diffd,mesh,mesh2:a diferen\u00e7a entre as representa\u00e7\u00f5es e as malhas de elementos finitos,\nrespectivamente.\n\ndef DiffFunction(C,AnalyticalExpression,mesh,degree,raiseDegree):\n2 C1=C#FunctionSpace(mesh,\u2019Lagrange\u2019,degree)\n\nmesh2=mesh; deg=degree+raiseDegree\n4 C2=FunctionSpace(mesh2,\u2019Lagrange\u2019,deg)\n\ndxx1 = project(AnalyticalExpression,C);\n6 dxx2 = project(AnalyticalExpression,C2);\n\n8 class diffxx(Expression):\ndef eval( self , values, x):\n\n10 values[0]=dxx2(x[0],x[1])?dxx1(x[0],x[1])\nDiffd = diffxx(element=C2.ufl_element());\n\n12 Diffd =interpolate(Diffd,C2)\nreturn Diffd,mesh,mesh2\n\nNa fun\u00e7\u00e3o apresentada, a proje\u00e7\u00e3o pode ser substitu\u00edda por interpola\u00e7\u00e3o, a malha\nmesh2 pode ser um refinamento da malha mesh. Nesse caso, o n\u00famero de elementos na\nmalha mesh2 associado ao grau elevado afeta o tempo de c\u00e1lculo.\n\nA.3.2 C\u00f3digo para as componentes residuais dos dados\n\nA fun\u00e7\u00e3o DataResidualComponents(kargs**) fornece as componentes do estimador\nresidual dos dados do problema do transporte.\n\n\n\n162 AP\u00caNDICE A. C\u00f3digo Python\n\n1.mesh2,DK,Function,DiffGradot,DiffJump,\\\nDiffNeumann,DiffDirichlet=DataResidualComponents(C,alpha_S,\\\n\nepsilon,c1,c,dxx,dxy,dyy,AnalyticalExpression,theta,vx,vy,\\\nReactionFunc,mesh,degree,raiseDegree)\n\n2.C,alpha_S,epsilon,c1,c: o espa\u00e7o de fun\u00e7\u00f5es, o par\u00e2metro de pondera\u00e7\u00e3o ?S, epsilon=?,\na solu\u00e7\u00e3o no tempo k ? 1 e a solu\u00e7\u00e3o no tempo k, respectivamente.\n\n3.dxx,dxy,dyy,AnalyticalExpression: as dispers\u00f5es dxx,dxy e dyy, a express\u00e3o anal\u00edtica\npara a carga hidr\u00e1ulica;\n\n4.vx,vy, ReactionFunc: as componentes da velocidade vx e vy, a fun\u00e7\u00e3o que descreve as\nrea\u00e7\u00f5es do meio, respectivamente;\n\n5.theta,mesh,degree,raiseDegree: o par\u00e2metro de discretiza\u00e7\u00e3o temporal, a malha de\nelementos finitos, o grau e o n\u00famero de graus para constru\u00e7\u00e3o do espa\u00e7o de grau\nelevado.\n\n6.mesh2: a malha de elementos finitos mesh2 id\u00eantica a malha inicial. Pode-se considerar\nmalhas refinadas com adequadas modifica\u00e7\u00f5es do c\u00f3digo computacional. Aqui, apenas\nmalhas id\u00eanticas foram consideradas.\n\n7.DK,Function,DiffGradot,DiffJump,DiffNeumann,DiffDirichlet: as componentes\ndo estimador residual dos dados do problema do transporte.\n\n1 def DataResidualComponents(C,alpha_S,epsilon,c1,c,dxx,dxy,dyy,AnalyticalExpression,theta,vx,vy,\nReactionFunc,mesh,degree,raiseDegree):\nDiffdxx,mesh,mesh2=DiffFunction(C,dxx,mesh,degree,raiseDegree);\n\n3 print \u2019 First calculations \u2019\nDiffdxy,mesh,mesh2=DiffFunction(C,dxy,mesh,degree,raiseDegree);\n\n5 print \u2019Second calculations\u2019\nDiffdyx=Diffdxy#Diffdyx,mesh,mesh2=DiffFunction(dyx,mesh,degree,raiseDegree);\n\n7 print \u2019Third calculations \u2019\nDiffdyy,mesh,mesh2=DiffFunction(C,dyy,mesh,degree,raiseDegree);\n\n9 print \u2019Fourth calculations \u2019\nDiffD=as_matrix([[Diffdxx,Diffdxy],\n\n11 [Diffdyx,Diffdyy ]])\nDiffvx,mesh,mesh2=DiffFunction(C,vx,mesh,degree,raiseDegree);\n\n13 print \u2019 five calculations \u2019\nDiffvy,mesh,mesh2=DiffFunction(C,vy,mesh,degree,raiseDegree)\n\n15 print \u2019 six calculations \u2019\nDiffReactionFunc,mesh,mesh2=DiffFunction(C,ReactionFunc,mesh,degree,raiseDegree);\n\n17 print \u2019seven calculations \u2019\nDiffd,mesh,mesh2=DiffFunction(C,AnalyticalExpression,mesh,degree,raiseDegree)\n\n19 DiffV=grad(Diffd)\nprint \u2019 calculation of the velocity field \u2019\n\n21 DiffSol=theta?c+(1.0?theta)?c1 # Difference of solution with theta?schema\n# Bilinear forms and residual errors definitions\n\n23 n=FacetNormal(mesh)\nprint \u2019 calculation of components:DK,Function,DiffJump,DiffGradot,DiffJump...\u2019\n\n25 DK=?div(DiffD?grad(DiffSol))+dot(DiffV,grad(DiffSol))+DiffReactionFunc?DiffSol\nFunction=DiffD?grad(DiffSol); DiffGradot=dot(Function,n);\n\n27 DiffJump=jump(DiffGradot); DiffNeumann=DiffGradot;\nDiffDirichlet =DiffGradot;\n\n\n\nA.3. C\u00f3digos para as estimativas dos dados 163\n\n29 return mesh2,DK,Function,DiffGradot,DiffJump,DiffNeumann,DiffDirichlet\n\nA.3.3 C\u00f3digo para as contribui\u00e7\u00f5es residuais dos dados\n\nA fun\u00e7\u00e3o FormDataOneNeumann(kargs**) fornece as contribui\u00e7\u00f5es residuais dos\ndados do problema do transporte. Nesse caso, a fronteira de Neumann \u00e9 definida por uma\n\u00fanica classe, a qual pode conter v\u00e1rias partes da fronteira.\n\n1.Uso:\n\nDataInterior,DataJump,DataBoundary,\n\\DataGeral=FormDataOneNeumann(C,epsilon,degree,\nraiseDegree,beta,mesh2,DK,function,DiffGradot,\nDiffJump,DiffNeumann,DiffDirichlet)\n\n2.C,epsilon,degree,raiseDegree,beta,mesh2: o espa\u00e7o de fun\u00e7\u00f5es, epsilon=?, o grau\ndo espa\u00e7o de fun\u00e7\u00f5es, o n\u00famero de graus para a constru\u00e7\u00e3o do espa\u00e7o de grau elevado,\nbeta=? e a malha de elementos finitos;\n\n3.DK,Function,DiffGradot,DiffJump,DiffNeumann,DiffDirichlet: as componentes\ndo estimador residual dos dados do problema do transporte gerado na subse\u00e7\u00e3o\nanterior.\n\n4.DataInterior, DataJump,DataBoundary,DataGeral:as contribui\u00e7\u00f5es residuais associ-\nadas aos dados do problema do trasnporte.\n\ndef FormDataOneNeumann(C,epsilon,degree,raiseDegree,beta,mesh2,DK,function,DiffGradot,DiffJump,\nDiffNeumann,DiffDirichlet):\n\n2 C1=C#FunctionSpace(mesh,\u2019Lagrange\u2019,degree)\n#mesh2=mesh;#mesh2=refine(mesh);\n\n4 deg=degree+raiseDegree\nC2=FunctionSpace(mesh2,\u2019Lagrange\u2019,deg)\n\n6 alphaSAux=AlphaS(mesh2,epsilon,beta,C2)\n#print \"\"\"The refined mesh has%s\"\"\" % str(mesh2)\n\n8 ConstantsAux = FunctionSpace(mesh2,\"DG\",0)\nwaux= TestFunction(ConstantsAux)\n\n10 form1 =alphaSAux??2?DK??2?waux?dx(mesh2)\nform2 = (1.0/np.sqrt(epsilon))?avg(alphaSAux)?DiffJump??2?avg(waux)?dS\n\n12 form3=(1.0/np.sqrt(epsilon))?DiffGradot?waux?ds(0)\nform=form1+form2+form3\n\n14 DataInterior = assemble(form1); DataJump=assemble(form2,mesh=mesh2)\nDataBoundary = assemble(form3,mesh=mesh2); DataGeral= assemble(form,mesh=mesh2)\n\n16 return DataInterior,DataJump,DataBoundary,DataGeral\n\n\n\n164 AP\u00caNDICE A. C\u00f3digo Python\n\nA.3.4 C\u00f3digo para os indicadores residuais dos dados\n\nA fun\u00e7\u00e3o FormOneNeumannIndicator(kargs**) fornece os indicadores residuais\npara os dados do problema do transporte. Essa fun\u00e7\u00e3o pode ser \u00fatil para procedimentos\nadaptativos para os dados. Neste caso, os indicadores s\u00e3o independentes das contribui\u00e7\u00f5es\nresiduais para facilitar o processo de refinamento. No entanto, a adequada manipula\u00e7\u00e3o\ndas quantidades DataInterior,DataJump,DataBoundary,DataGeral tamb\u00e9m fornece os\nindicadores residuais dos elementos, saltos, fronteiras de Neumann e espaciais.\n\n1.Uso:\n\nDataInterior,DataJump,DataBoundary,DataGeral=\\\nFormOneNeumannIndicator(epsilon,alpha_S,mesh2,DK,\nfunction,DiffGradot,DiffJump,DiffNeumann,DiffDirichlet)\n\n2.A nota\u00e7\u00e3o \u00e9 id\u00eantica a subse\u00e7\u00e3o anterior.\n\ndef FormOneNeumannIndicator(epsilon,alpha_S,mesh2,DK,function,DiffGradot,DiffJump,DiffNeumann,\nDiffDirichlet):\n\n2 Constants = FunctionSpace(mesh2,\"DG\", 0)\nw = TestFunction(Constants)\n\n4 form1 =alpha_S??2?DK??2?w?dx\nform2 = (1.0/np.sqrt(epsilon))?avg(alpha_S)?DiffJump??2?avg(w)?dS\n\n6 # The Neumann boundary\nform3=(1.0/np.sqrt(epsilon))?DiffGradot?w?ds(0)\n\n8 form=form1+form2+form3\n\n10 DataInterior = assemble(form1); DataJump = assemble(form2)\nDataBoundary = assemble(form3); DataGeral = assemble(form)\n\n12\nDataElementIndicator=array([sqrt(i) for i in DataInterior])\n\n14 DataJumpIndicator=array([sqrt(i) for i in DataJump])\nDataBoundaryIndicator=array([sqrt(i) for i in DataBoundary])\n\n16 DataGeralIndicator=array([sqrt(i) for i in DataGeral])\nreturn DataInterior,DataJump,DataBoundary,DataGeral\n\nA.3.5 C\u00f3digo para as estimativas residuais dos dados\n\nA fun\u00e7\u00e3o DataErrorEstimateStepN(kargs**) fornece as estimativas residuais asso-\nciadas aos dados do problema. Em problemas que exigem essa estimativa, as quantidades\nrespectivas devem ser adequadamente somadas para produzir a estimativa residual.\n\n1.Uso:\n\n\n\nA.4. C\u00f3digos para as estimativas associadas ao termo de fonte 165\n\nErEstInt,ErEstJump,ErEstBound,\\\nErEstGeral=DataErrorEstimateStepN(DataInterior,\nDataJump,DataBoundary,DataGeral,dt)\n\n2.DataInterior, DataJump,DataBoundary,DataGeral,dt: as contribui\u00e7\u00f5es residuais e\no passo de tempo;\n\n3.ErEstInt,ErEstJump,ErEstBound,ErEstGeral: as estimativas residuais para os ele-\nmentos, salto, fronteiras e a estimativa espacial.\n\n1 def DataErrorEstimateStepN(DataInterior,DataJump,DataBoundary,DataGeral,dt):\nprint \u2019Divide by the time step to get estimates without time step weight\u2019\n\n3 ErEstInt = dt?(sum(i for i in DataInterior.array()))# local interior contribution to global\nErEstJump = dt?(sum(i for i in DataJump.array()))# local jump contribuition global\n\n5 ErEstBound = dt?(sum(i for i in DataBoundary.array()))# local boundaries contribuitions to global\nErEstGeral = dt?(sum(i for i in DataGeral.array()))#the spatial error contribuition\n\n7 return ErEstInt,ErEstJump,ErEstBound,ErEstGeral\n\nA.4 C\u00f3digos para as estimativas associadas ao termo de fonte\n\nA fun\u00e7\u00e3o FunctionFDataErrorEstimateStepN(kargs**) fornece as contribui\u00e7\u00f5es\nresiduais, os indicadores residuais e a estimativa residual. As contribui\u00e7\u00f5es residuais ou a\nestimativa residual podem ser inclu\u00eddas no estimador residual, enquanto que os indicadores\nresiduais podem ser utilizados em processos adaptativos envolvendo o termo de fonte.\n\n1[1.] Uso:\n\nDataFfunctionEstimate,DataFfunctionIndicator,\\\nDataFfunction=FunctionFDataErrorEstimateStepN(alpha_S,epsilon,\ntheta,Fexpression,mesh,degree,raiseDegree,dt)\n\n2.alpha_S,epsilon,theta e mesh,degree,raiseDegree,dt: o fator de pondera\u00e7\u00e3o ?S,\nepsilon=?, o par\u00e2metro de discretiza\u00e7\u00e3o temporal, a malha de elementos finitos, o\ngrau do espa\u00e7o de fun\u00e7\u00f5es, o n\u00famero de graus adicional para construir o espa\u00e7o de\nfun\u00e7\u00f5es de ordem elevada e o passo de tempo, respectivamente.\n\n3.Fexpression: a express\u00e3o anal\u00edtica do termo de fonte.\n\n4.DataFfunctionEstimate,DataFfunctionIndicator,DataFfunction: as contribui\u00e7\u00f5es\nresiduais, os indicadores residuais e a estimativa residual, respectivamente.\n\n\n\n166 AP\u00caNDICE A. C\u00f3digo Python\n\n5.Observa\u00e7\u00e3o: esta fun\u00e7\u00e3o considera malhas refinadas e fun\u00e7\u00f5es lagrangeanas de grau\nelevado. A seguir \u00e9 apresentada uma simplifica\u00e7\u00e3o deste procedimento. O objetivo \u00e9\nsimplificar a obten\u00e7\u00e3o dos indicadores de erros relacionados ao termo de fonte.\n\n1 #????THE F DATA ERROR ESTIMATE\ndef FunctionFDataErrorEstimateStepN(C,alpha_S,epsilon,theta,Fexpression,mesh,degree,raiseDegree,dt):\n\n3 print \u2019 error estimates for functions time independent\u2019\nprint \u2019Time dependent functions needs to be implemented\u2019\n\n5 from Tools.ErrorEstimatorFunctions import DiffFunction\nDiffFfunctionStepN,mesh,mesh2=DiffFunction(C,Fexpression,mesh,degree,raiseDegree)\n\n7 DiffFfunctionStepN1=DiffFfunctionStepN # the N?1 step..but function is not time depedent\n#?????RESIDUAL ERROR DEFINITIONS FOR F FUNCTION\n\n9 Constants = FunctionSpace(mesh2,\"DG\",0); w = TestFunction(Constants)\nDFN=DiffFfunctionStepN; DFN1=DiffFfunctionStepN1\n\n11 FormFunctionF=alpha_S??2?(theta??2?DFN??2+(1.0?theta)??2?DFN1??2)?w?dx(mesh2)\nDataFfunction=assemble(FormFunctionF)\n\n13 DataFfunctionIndicator=array([sqrt(i) for i in DataFfunction])\nDataFfunctionEstimate=dt?(sum(i for i in DataFfunction.array()))\n\n15 return DataFfunctionEstimate,DataFfunctionIndicator,DataFfunction\n\nA.4.1 C\u00f3digo para os indicadores associados ao termo de fonte\n\nA fun\u00e7\u00e3o FunctionFDataErrorIndicatorsStepN(kargs**) fornece os indicadores\nresiduais para processos adaptativos da fun\u00e7\u00e3o de fonte. Essa fun\u00e7\u00e3o \u00e9 uma modifica\u00e7\u00e3o da\nfun\u00e7\u00e3o FunctionFDataErrorEstimateStepN(kargs**) , mas fornece os mesmos elemen-\ntos que o item anterior. A fun\u00e7\u00e3o DiffFunction2(kargs**) considera malhas produzidas\npor meio da modifica\u00e7\u00e3o da fun\u00e7\u00e3o DiffFunction(kargs**) com mesh2=mesh e espa\u00e7o\nde fun\u00e7\u00f5es de grau elevado.\n\n1 def FunctionFDataErrorIndicatorsStepN(C,alpha_S,epsilon,theta,Fexpression,mesh,degree,raiseDegree,dt):\nprint \u2019 error estimates for functions time independent.\u2019\n\n3 print\u2019 Time dependent functions needs to be implemented\u2019\nfrom Tools.ErrorEstimatorFunctions import DiffFunction2\n\n5 DiffFfunctionStepN,mesh,mesh2=DiffFunction2(C,Fexpression,mesh,degree,raiseDegree)\nDiffFfunctionStepN1=DiffFfunctionStepN\n\n7 #????????????RESIDUAL ERROR DEFINITIONS FOR F FUNCTION\nDiffFfunctionStepN=interpolate(DiffFfunctionStepN,C)\n\n9 DFN=DiffFfunctionStepN\nDFN1=DiffFfunctionStepN1\n\n11 #???????????????????????????????????????????????????\nConstants = FunctionSpace(mesh,\"DG\",0)\n\n13 w = TestFunction(Constants)\nFormFunctionF=alpha_S??2?(theta??2?DFN??2+(1.0?theta)??2?DFN1??2)?w?dx(mesh)\n\n15 DataFfunction=assemble(FormFunctionF)\nDataFfunctionIndicator=array([sqrt(i) for i in DataFfunction])\n\n17 DataFfunctionEstimate=dt?(sum(i for i in DataFfunction.array()))\nreturn DataFfunctionEstimate,DataFfunctionIndicator,DataFfunction\n\n\n\nA.5. C\u00f3digo para as estimativas residuais das fronteiras 167\n\nA.5 C\u00f3digo para as estimativas residuais das fronteiras\n\nA fun\u00e7\u00e3o NeumanDataErrorEstimateN(kargs**) fornece as contribui\u00e7\u00f5es residuais,\nos indicadores residuais e a estimativa residual associadas \u00e0s fronteiras de Neumann.\n\n1.Uso:\n\nDataGfunctionEstimate,DataGfunction,\\\nDataGfunctionIndicator=NeumanDataErrorEstimateN(alpha_S,epsilon,\ntheta,Gexpression,mesh,degree,raiseDegree,dt,boundary_parts)\n\n2.alpha_S,epsilon,theta e mesh,degree,raiseDegree,dt: o fator de pondera\u00e7\u00e3o ?S,\nepsilon=?, o par\u00e2metro de discretiza\u00e7\u00e3o temporal, a malha de elementos finitos, o\ngrau do espa\u00e7o de fun\u00e7\u00f5es, o n\u00famero de graus adicional para construir o espa\u00e7o de\nfun\u00e7\u00f5es de ordem elevada e o passo de tempo, respectivamente.\n\n3.Gexpression: a express\u00e3o anal\u00edtica do termo de fonte.\n\n4.DataGfunctionEstimate,DataGfunction,DataGfunctionIndicator: as contribui\u00e7\u00f5es\nresiduais, os indicadores residuais e a estimativa residual, respectivamente.\n\n#????????????????????????????????????????????????\n2 def NeumanDataErrorEstimateN(alpha_S,epsilon,theta,Gexpression,mesh,degree,raiseDegree,dt,\n\nboundary_parts):\nprint \u2019 error estimates for functions time independent. Time dependent functions needs to be\nimplemented yet\u2019\n\n4 DiffGfunctionStepN,mesh,mesh2=DiffFunction(Gexpression,mesh,degree,raiseDegree)\nDiffGfunctionStepN_1=DiffGfunctionStepN# the N?1 step..but function is not time depedent\n\n6 #???????????????RESIDUAL ERROR DEFINITIONS FOR F FUNCTION\nConstants = FunctionSpace(mesh2,\"DG\",0)\n\n8 DGN=DiffGfunctionStepN; DGN_1=DiffGfunctionStepN_1\nw = TestFunction(Constants)\n\n10 FormFunctionG=alpha_S?(theta??2?DGN??2+(1.0?theta)??2?DGN_1??2)?w?ds(0)\nDataGfunction=assemble(FormFunctionG);\n\n12 DataGfunctionIndicator=array([sqrt(i) for i in DataGfunction])\nDataGfunctionEstimate=dt?epsilon??(?1.0/4.0)?(sum(i for i in DataGfunction.array()))\n\n14 return DataGfunctionEstimate,DataGfunction,DataGfunctionIndicator\n\nA.6 C\u00f3digo adicional para as estimativas\n\nA fun\u00e7\u00e3o MaxMinIndicators(kargs**) fornece os m\u00e1ximos e m\u00ednimos de cada um\ndos indicadores residuais. Essa classe pode ser \u00fatil para o c\u00e1lculo direto das quanti-\ndades m\u00e1ximas. No entanto, essas quantidades podem ser obtidas diretamente atrav\u00e9s da\nbiblioteca NumPy.\n\n\n\n168 AP\u00caNDICE A. C\u00f3digo Python\n\n1.Uso:\n\nMaxMinIndicatorArray=MaxMinIndicators(indicator_spatial,\nindicator_form1,indicator_form2,indicator_form3,indicator_time)\n\n2.indicator_spatial,indicator_form1,indicator_form2,indicator_form3 e\nindicator_time: os indicadores residuais espacial, dos elementos, dos saltos, das\nfronteiras de Neumann e temporal;\n\n3.MaxMinIndicatorArray: a matriz de m\u00e1ximos e m\u00ednimos para os indicadores residuais.\n\ndef MaxMinIndicators(indicator_spatial,indicator_form1,indicator_form2,indicator_form3,indicator_time):\n2 maxindicators = max(indicator_spatial); maxindicator1=max(indicator_form1);\n\nmaxindicator2=max(indicator_form2); maxindicator3=max(indicator_form3);\n4 maxindicatorTime=max(indicator_time);minindicators = max(indicator_spatial);\n\nminindicator1=min(indicator_form1); minindicator2=min(indicator_form2);\n6 minindicator3=min(indicator_form3); minindicatorTime=min(indicator_time);\n\n8 MaxMinIndicatorArray=np.array([maxindicators,maxindicator1,maxindicator2,maxindicator3,\nmaxindicators,maxindicatorTime,\\\n\nminindicators,minindicator1,minindicator2,minindicator3,minindicators,\nminindicatorTime])\n\n10 return MaxMinIndicatorArray\n\nA fun\u00e7\u00e3o EachStepError_Indicator_Space_Time fornece as quantidades residuais\nglobais espaciais e temporais, ou seja, as quantidades que incorporam as contribui\u00e7\u00f5es de\ntodas as entidades da malha de elementos finitos. Al\u00e9m disso, os indicadores espaciais e\ntemporais tamb\u00e9m s\u00e3o fornecidos.\n\nUso:\n\ntime_indicator2,error_each_step,error_indicator2,\\\nindicador_spatial,indicador_temporal=\\\nEachStepError_Indicator_Space_Time(time_indicator,\\\nerror_estimate_space,error_time)\n\n2.time_indicator,error_estimate_space,error_time: as contribui\u00e7\u00f5es residuais espa-\ncial e temporal.\n\n# because we nee add this terms in global error estimator\n2 def EachStepError_Indicator_Space_Time(time_indicator,error_estimate_space,error_time):\n\ntime_indicator2 = sqrt(sum(i for i in time_indicator.array()))\n4 error_each_step=error_estimate_space+error_time\n\nerror_indicator1=error_estimate_space\n6 #error_time is the weighted by time time estimate\n\n\n\nA.7. C\u00f3digo para adaptatividade da condi\u00e7\u00e3o inicial 169\n\nerror_indicator2=error_time\n8 indicador_spatial=sqrt(error_indicator1)\n\nindicador_temporal=sqrt(error_indicator2)\n10 return time_indicator2,error_each_step,error_indicator2,indicador_spatial,indicador_temporal\n\nA.7 C\u00f3digo para adaptatividade da condi\u00e7\u00e3o inicial\n\nAs fun\u00e7\u00f5es e classes apresentadas nesta se\u00e7\u00e3o fornecem as ferramentas necess\u00e1rias\npara o refinamento adaptativo da condi\u00e7\u00e3o inicial. A adaptatividade considera espa\u00e7os de\nfun\u00e7\u00f5es com graus diferentes, enquanto que a estimativa residual considera malha refinada\ne espa\u00e7o de fun\u00e7\u00f5es com grau elevado.\n\nInicialmente, as bibliotecas num\u00e9ricas s\u00e3o disponibilizadas conforme o c\u00f3digo seguinte:\n\nfrom dolfin import ?\n2 #????for adequate use of matplotlib\n#https://answers.launchpad.net/dolfin/+question/219220\n\n4 dolfin .parameters.reorder_dofs_serial = False\n#?????????????????????????????\n\n6 import numpy as np\nfrom scipy import?\n\n8 from time import time\n\nA.7.1 C\u00f3digo para estimativa do erro da condi\u00e7\u00e3o inicial\n\nA fun\u00e7\u00e3o ErrorEstimate_for_InitialCondition(kargs**) fornece as quantidades\nresiduais relacionadas \u00e0 condi\u00e7\u00e3o inicial: os indicadores, a estimativa residual devido \u00e0\nproje\u00e7\u00e3o L2 da fun\u00e7\u00e3o que determina a condi\u00e7\u00e3o inicial e o m\u00e1ximo de todos os indicadores.\n\n1.Uso:\n\nerror_indicator,L2Error_for_ICond,largest_error\\\n=ErrorEstimate_for_InitialCondition(mesh,\\\nCinit,Cinitial,degree,RaiseDegree)\n\n2.mesh,Cinit,Cinitial,degree,RaiseDegree: a malha de elementos finitos, a aproxi-\nma\u00e7\u00e3o de elementos finitos da condi\u00e7\u00e3o inicial, a express\u00e3o anal\u00edtica para a condi\u00e7\u00e3o\ninicial, o grau do espa\u00e7o de fun\u00e7\u00f5es e o n\u00famero de graus adicional do espa\u00e7o de\nfun\u00e7\u00f5es de grau superior.\n\n\n\n170 AP\u00caNDICE A. C\u00f3digo Python\n\n3.error_indicator,L2Error_for_ICond,largest_error: os indicadores residuais, a es-\ntimativa residual e o m\u00e1ximo indicador residual.\n\ndef ErrorEstimate_for_InitialCondition(mesh,Cinit,Cinitial,degree,RaiseDegree):\n2 #?define space functions\n\nmesh1=mesh\n4 C = FunctionSpace(mesh1,\u2019Lagrange\u2019,degree)\n\nC1 = FunctionSpace(mesh1, \u2019Lagrange\u2019,degree+RaiseDegree)\n6 c0linha=Cinitial(element=C.ufl_element());\n\nc0linha=project(c0linha,C1)\n8 Cinit0 = Cinitial(element=C1.ufl_element());\n\nc1linha=interpolate(Cinit0,C1)#interpolate(Cinit0,C1)\n10 #????????????????????????????????????????\n\nConstants = FunctionSpace(mesh1,\"DG\", 0)\n12 w = TestFunction(Constants)\n\nform4=(c1linha?c0linha)??2?w?dx(); indicator4=assemble(form4)\n14 error_indicator = array([sqrt(i) for i in indicator4 ])\n\nL2Error_for_ICond = sqrt(sum(i for i in indicator4.array()))#sum(i for i in indicator4.array())\n16 largest_error=max(error_indicator)\n\nprint\u2019 error estimates:L2 error(defined in ErrorEstimate_for_InitialCondition) and error indicator \u2019,\nL2Error_for_ICond,largest_error\n\n18 return error_indicator,L2Error_for_ICond,largest_error\n\nA.7.2 C\u00f3digo para refinamento adaptativo da condi\u00e7\u00e3o inicial\n\nA fun\u00e7\u00e3o RefineMesh_for_InitCond(kargs**) fornece uma malha adequada \u00e0\nrepresenta\u00e7\u00e3o da fun\u00e7\u00e3o que descreve a condi\u00e7\u00e3o inicial. Esse processo adaptativo \u00e9\nbaseado na estimativa residual para a condi\u00e7\u00e3o inicial ||C0 ??C0||2L2(?).\n\n1.Uso:\n\nRefinedMesh=RefineMesh_for_InitCond(mesh,Cinit,\nCinitial,C, tolerance,fraction,degree,RaiseDegree)\n\n2.mesh,Cinit,Cinitial,C,tolerance,fraction,degree,RaiseDegree: a malha de\nelementos finitos fornecida pelo usu\u00e1rio, a aproxima\u00e7\u00e3o de elementos finitos da\ncondi\u00e7\u00e3o inicial, a express\u00e3o anal\u00edtica para a condi\u00e7\u00e3o inicial, o espa\u00e7o de fun\u00e7\u00f5es, a\ntoler\u00e2ncia(crit\u00e9rio de parada), a fra\u00e7\u00e3o do m\u00e1ximo indicador em que um elemento \u00e9\nmarcado para refinamento, o grau das fun\u00e7\u00f5es lagrangeanas, o grau adicional para o\nespa\u00e7o de fun\u00e7\u00f5es com grau elevado.\n\n3.RefinedMesh: a malha refinada\n\ndef RefineMesh_for_InitCond(mesh,Cinit,Cinitial,C,tolerance,fraction,degree,RaiseDegree):\n2 X=ErrorEstimate_for_InitialCondition(mesh,Cinit,Cinitial,degree,RaiseDegree)\n\nerror_indicator=X[0];L2Error_for_ICond=X[1];largest_error=X[2];\n\n\n\nA.7. C\u00f3digo para adaptatividade da condi\u00e7\u00e3o inicial 171\n\n4 print \u2019the error inside loop of refine function\u2019 ,L2Error_for_ICond\nprint \u2019the largest indicator inside loop of refine function\u2019 ,largest_error\n\n6 if (X[1]>tolerance):\nprint \u2019 Initial Condition Error greater than tolerance: error=, tolerance=\u2019,X[1],tolerance\n\n8\nwhile(X[1]>tolerance):\n\n10 #mesh=mesh; Cinit = interpolate(Cinit,C)\nX=ErrorEstimate_for_InitialCondition(mesh,Cinit,Cinitial,degree,RaiseDegree)\n\n12 error_indicator=X[0];L2Error_for_ICond=X[1];largest_error=X[2];\nif X[1]>tolerance:\n\n14 print \u2019 Initial Condition Error greater than tolerance: error=, tolerance=\u2019,X[1],tolerance\nelse :\n\n16 break\nprint \u2019the error inside loop of refine function\u2019 ,L2Error_for_ICond\n\n18 print \u2019the largest indicator inside loop of refine function\u2019 ,largest_error\n\n20 cell_markers = MeshFunction(\"bool\",mesh,mesh.topology().dim())\nfor mark in cells (mesh):\n\n22 cell_markers[mark] = ((error_indicator[mark.index()] > fraction?largest_error))\nmesh=refine(mesh,cell_markers)\n\n24 plot(mesh,interactive=False)\nreturn mesh\n\nA.7.3 C\u00f3digo modificado para refinamento adaptativo da condi\u00e7\u00e3o inicial\n\nEsse caso \u00e9 uma modifica\u00e7\u00e3o da fun\u00e7\u00e3o RefineMesh_for_InitCond(kargs**) com\ncrit\u00e9rio de parada baseado no indicador residual m\u00e1ximo. Essencialmente \u00e9 o mesmo\nc\u00f3digo, mas pode ser \u00fatil na gera\u00e7\u00e3o de uma malha adaptada.\n\n1\ndef RefineMesh_for_InitCond2(mesh,Cinit,Cinitial,C,tolerance,fraction,degree,RaiseDegree):\n\n3\nX=ErrorEstimate_for_InitialCondition(mesh,Cinit,Cinitial,degree,RaiseDegree)\n\n5 error_indicator=X[0];L2Error_for_ICond=X[1];largest_error=X[2];\nprint \u2019the error inside loop of refine function\u2019 ,L2Error_for_ICond\n\n7 print \u2019the largest indicator inside loop of refine function\u2019 ,largest_error\n\n9 if (X[1]>tolerance):\nprint \u2019 Initial Condition Error greater than tolerance: error=, tolerance=\u2019,X[1],tolerance\n\n11\nwhile(X[2]>tolerance):\n\n13 #mesh=mesh; Cinit = interpolate(Cinit,C)\n\n15 X=ErrorEstimate_for_InitialCondition(mesh,Cinit,Cinitial,degree,RaiseDegree)\nerror_indicator=X[0];L2Error_for_ICond=X[1];largest_error=X[2];\n\n17\nif X[2]>tolerance:\n\n19 print \u2019maximum indicator greater than tolerance: error=, tolerance=\u2019,X[2],tolerance\nelse :\n\n21 break\n\n\n\n172 AP\u00caNDICE A. C\u00f3digo Python\n\n23 print \u2019the error inside loop of refine function\u2019 ,L2Error_for_ICond\nprint \u2019the largest indicator inside loop of refine function\u2019 ,largest_error\n\n25 cell_markers = MeshFunction(\"bool\",mesh,mesh.topology().dim())\n\n27 for mark in cells (mesh):\ncell_markers[mark] = ((error_indicator[mark.index()] > fraction?largest_error))\n\n29 mesh=refine(mesh,cell_markers)\n\n31 return mesh\n\nA.7.4 C\u00f3digo para refinamento adaptativo da fun\u00e7\u00e3o de fonte\n\nA fun\u00e7\u00e3o RefineMeshForFfunction(kargs**) fornece uma malha adequada \u00e0\nrepresenta\u00e7\u00e3o da fun\u00e7\u00e3o matem\u00e1tica que descreve o termo de fonte. Esse processo adapta-\ntivo \u00e9 baseado na estimativa residual para o termo de fonte.\n\n1.Uso:\n\nRefinedMesh=RefineMeshForFfunction(toleranceF,fractionF,\nalpha_S,epsilon,theta,Fexpression,mesh,degree,raiseDegree,dt)\n\n2.toleranceF,fractionF,alpha_S,epsilon: a toler\u00e2ncia, a fra\u00e7\u00e3o do m\u00e1ximo indicador\nem que um elemento \u00e9 marcado para refinamento, o fator de pondera\u00e7\u00e3o ?S,\nepsilon=?;\n\n3.:theta,Fexpression,mesh,degree,raiseDegree,dt: o par\u00e2metro de discretiza\u00e7\u00e3o tem-\nporal, a express\u00e3o anal\u00edtica para a fun\u00e7\u00e3o de fonte, a malha de elementos finitos, o\ngrau das fun\u00e7\u00f5es e o n\u00famero de graus adicional para o espa\u00e7o de fun\u00e7\u00f5es de grau\nelevado.\n\n4.RefinedMesh: a malha refinada\n\n1 def RefineMeshForFfunction(maxIterF,toleranceF,fractionF,epsilon,beta,theta,Fexpression,mesh,degree,\nraiseDegree,dt):\nfrom Tools.ErrorEstimatorFunctions import AlphaS\n\n3 C=FunctionSpace(mesh,\u2019Lagrange\u2019,degree)\nalpha_S=AlphaS(mesh,epsilon,beta,C)\n\n5 from Tools.ErrorEstimatorFunctions import FunctionFDataErrorEstimateStepN,\nFunctionFDataErrorIndicatorsStepN\nDataFfunctionEstimate,DataFfunctionIndicator,\\\n\n7 DataFfunction=FunctionFDataErrorEstimateStepN(C,alpha_S,epsilon,theta,Fexpression,mesh,degree,\nraiseDegree,dt)\nlargest_error=max(DataFfunctionIndicator)\n\n9 DataFfunctionErrorEstimate=sqrt(DataFfunctionEstimate)\nprint \u2019the values of largest_error and DataFfunctionErrorEstimate\u2019,largest_error,\nDataFfunctionErrorEstimate\n\n11\n\n\n\nA.8. C\u00f3digos adicionais 173\n\nif (DataFfunctionErrorEstimate>toleranceF):\n13 print \u2019 Initial Condition Error greater than tolerance: error=, tolerance=\u2019,\n\nDataFfunctionErrorEstimate,toleranceF\n\n15 while(DataFfunctionErrorEstimate>toleranceF):\nC=FunctionSpace(mesh,\u2019Lagrange\u2019,degree)\n\n17 alpha_S=AlphaS(mesh,epsilon,beta,C)\n\n19 DataFfunctionEstimate,DataFfunctionIndicator,\\\nDataFfunction=FunctionFDataErrorEstimateStepN(C,alpha_S,epsilon,theta,Fexpression,mesh,degree,\n\nraiseDegree,dt)\n21 largest_error=max(DataFfunctionIndicator)\n\nDataFfunctionErrorEstimate=sqrt(DataFfunctionEstimate)\n23 print \u2019the values of largest_error and DataFfunctionErrorEstimate\u2019,largest_error,\n\nDataFfunctionErrorEstimate\n#for i in range(maxIterF):\n\n25 if DataFfunctionErrorEstimate>toleranceF:\nprint \u2019maximum indicator greater than tolerance: error=, tolerance=\u2019,DataFfunctionErrorEstimate\n\n,toleranceF\n27 else :\n\nbreak\n29\n\nDataFfunctionEstimate2,DataFfunctionIndicator2,\\\n31 DataFfunction2=FunctionFDataErrorIndicatorsStepN(C,alpha_S,epsilon,theta,Fexpression,mesh,degree\n\n,raiseDegree,dt)\n\n33 largest_error2=max(DataFfunctionIndicator2)\n#DataFfunctionErrorEstimate2=sqrt(DataFfunctionEstimate2)\n\n35 #print \u2019largest_error,DataFfunctionEstimate,sqrt(DataFfunctionEstimate)\u2019,largest_error,\nDataFfunctionEstimate,sqrt(DataFfunctionEstimate)\n\n37 cell_markers = MeshFunction(\"bool\",mesh,mesh.topology().dim())\n\n39 for mark in cells (mesh):\ncell_markers[mark] = ((DataFfunctionIndicator2[mark.index()] > fractionF?largest_error2))\n\n41 mesh=refine(mesh,cell_markers)\n#plot(mesh,interactive=False)\n\n43 return mesh\n\nA.8 C\u00f3digos adicionais\n\nA.8.1 Avalia\u00e7\u00e3o do erro real\n\nA fun\u00e7\u00e3o MyErrorNorm(kargs**) foi criada com base nos c\u00f3digos e manuais dispon\u00edveis\nno endere\u00e7o eletr\u00f4nico do Projeto FEniCS e tem objetivo de acelerar o c\u00e1lculo do erro\nexecutado pela fun\u00e7\u00e3o error_norm do FEniCS (FENICS PROJECT, 2014). Essa fun\u00e7\u00e3o\npode ser usada para calcular o erro real do processo de aproxima\u00e7\u00e3o.\n\n\n\n174 AP\u00caNDICE A. C\u00f3digo Python\n\n1.Uso: Suponha que u e ue s\u00e3o as solu\u00e7\u00f5es num\u00e9rica e exata. O erro real, avaliado na\nnorma L2, pode ser obtido atrav\u00e9s de:\nL2Error=MyErrorNorm(u,u_e,mesh,deg,raise_degree)\n\n2.u,u_e,mesh,deg,raise_degree: a solu\u00e7\u00e3o num\u00e9rica, a solu\u00e7\u00e3o exata, a malha de ele-\nmentos finitos, o grau das fun\u00e7\u00f5es polinomiais e o n\u00famero de graus adicional para\nconstruir o espa\u00e7o de fun\u00e7\u00f5es de ordem elevada.\n\n3.Observa\u00e7\u00e3o: solu\u00e7\u00e3o exata significa uma representa\u00e7\u00e3o acurada da express\u00e3o anal\u00edtica\nno dom\u00ednio computacional.\n\n1 def MyErrorNorm(u,u_e,mesh,deg,raise_degree):\nmesh1=refine(mesh);\n\n3 C1=FunctionSpace(mesh1,\u2019Lagrange\u2019,deg+raise_degree)\nu_e=u_e(element=C1.ufl_element())\n\n5 u_e_Ve=project(u_e,C1)#interpolate(u_e,C1)\nu_Ve=project(u,C1)\n\n7\ne_Ve = Function(C1)\n\n9 # Subtract degrees of freedom for the error field\ne_Ve.vector() [:] = u_e_Ve.vector().array() ? u_Ve.vector().array()\n\n11 error = e_Ve??2?dx\nreturn sqrt(assemble(error))\n\nA.9 Reutiliza\u00e7\u00e3o das estruturas multigrid\n\nNesta se\u00e7\u00e3o, processo de reutiliza\u00e7\u00e3o das estruturas multigrid \u00e9 apresentado. Este\nm\u00f3dulo implementa uma modifica\u00e7\u00e3o no m\u00f3dulo Python blackbox, dispon\u00edvel em PyAMG\n(BELL; OLSON; SCHRODER, 2011) e no website https : //github.com/pyamg/pyamg.\nEsse m\u00f3dulo possibilita a implementa\u00e7\u00e3o dos dois esquemas de reutiliza\u00e7\u00e3o propostos\nnesta tese.\n\n1.Uso:\n\nconfig=solver_configuration(Asp,verb=True)\nfrom Dictionary import DictSA\nconfig=DictSA(Asp, max_levels,solver_configuration)\nml=solver(Asp,config)\nsolut,itera,res = solve(Asp,b,x0=c10,tol=1e-10,maxiter=400,\\\n\nexisting_solver=ml)\n\n2.config=solver_configuration(kargs**): fornece um dicion\u00e1rio de par\u00e2metros para\no m\u00e9todo multigrid alg\u00e9brico.\n\n\n\nA.9. Reutiliza\u00e7\u00e3o das estruturas multigrid 175\n\n3.DictSA(kargs**): retorna um dicion\u00e1rio de par\u00e2metros para especializa\u00e7\u00e3o do m\u00e9todo\nmultigrid alg\u00e9brico.\n\ndef DictSA(Asp,max_levels,solver_configuration):\n2 config=solver_configuration(Asp,verb=True)\n\nconfig [ \u2019symmetry\u2019]=(\u2019nonsymmetric\u2019)\n4 config [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\n\nconfig [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n6 config [ \u2019smooth\u2019] =(\u2019energy\u2019, {\u2019krylov\u2019 : \u2019bicg\u2019}, \\\n\n{\u2019 filter \u2019 : True},{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n8 config [ \u2019strength\u2019 ] =(\u2019 classical \u2019,{\u2019theta\u2019 :0.1})\n\nconfig [ \u2019max_levels\u2019]=(max_levels); config [ \u2019max_coarse\u2019]=(1000)\n10 config [ \u2019coarse_solver\u2019]=(\u2019lu\u2019) ; config [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\n\nconfig [ \u2019aggregate\u2019]=(\u2019standard\u2019)\n12 config [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\nconfig [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n14 config [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.000001e?12})\n\nconfig [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :1}) ]\n16 config [ \u2019diagonal_dominance\u2019]=(False)\n\nconfig [ \u2019keep\u2019] =(False)\n18 return config\n\n4.Asp,verb: matriz do sistema linear e vari\u00e1vel booleana.\n\n5.max_levels,solver_configuration: n\u00famero de n\u00edveis e configura\u00e7\u00e3o padr\u00e3o. Se nen-\nhuma especializa\u00e7\u00e3o \u00e9 fornecida, ent\u00e3o a fun\u00e7\u00e3o DictSA retorna a configura\u00e7\u00e3o\npadr\u00e3o do m\u00f3dulo blackbox dispon\u00edvel em PyAMG (BELL; OLSON; SCHRODER,\n2011).\n\n\"\"\"\n2 The MIT License (MIT)\n\n4 Copyright (c) 2008?2015 PyAMG Developers\n\n6 Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\n\n8 in the Software without restriction , including without limitation the rights\nto use, copy, modify, merge, publish, distribute , sublicense , and/or sell\n\n10 copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n12\nThe above copyright notice and this permission notice shall be included in all\n\n14 copies or substantial portions of the Software.\n\n16 THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\n18 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\n20 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\n22 SOFTWARE.\n\"\"\"\n\n\n\n176 AP\u00caNDICE A. C\u00f3digo Python\n\n24 __docformat__ = \"restructuredtext en\"\nimport numpy\n\n26 import scipy\nfrom scipy.sparse import isspmatrix_csr, isspmatrix_bsr, csr_matrix\n\n28 from pyamg import smoothed_aggregation_solver\nfrom pyamg.util.linalg import ishermitian, norm\n\n30 __all__ = [\u2019solve, solver, solver_configuration\u2019 ]\ndef make_csr(A):\n\n32 if not (isspmatrix_csr(A) or isspmatrix_bsr(A)):\ntry:\n\n34 A = csr_matrix(A)\nprint \u2019 Implicit conversion of A to CSR in pyamg.blackbox.make_csr\u2019\n\n36 except:\nraise TypeError(\u2019Argument A must have type csr_matrix or bsr_matrix,\\\n\n38 or be convertible to csr_matrix\u2019)\nif A.shape[0] != A.shape[1]:\n\n40 raise TypeError(\u2019Argument A must be a square\u2019)\nA = A.asfptype()\n\n42 return A\n\n44 def solver_configuration(A, B=None, verb=True):\nA = make_csr(A); config = {}\n\n46 # Detect symmetry\nif ishermitian(A, fast_check=True):\n\n48 config [ \u2019symmetry\u2019] = \u2019hermitian\u2019\nif verb:\n\n50 print \" Detected a Hermitian matrix\"\nelse :\n\n52 config [ \u2019symmetry\u2019] = \u2019nonsymmetric\u2019\nif verb:\n\n54 print \" Detected a non?Hermitian matrix\"\nif config [ \u2019symmetry\u2019] == \u2019hermitian\u2019:\n\n56 config [ \u2019smooth\u2019] =(\u2019energy\u2019, {\u2019krylov\u2019 : \u2019cg\u2019 , \u2019maxiter\u2019:3, \u2019degree\u2019 :2, \u2019weighting\u2019: \u2019 local \u2019})\nconfig [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :1})\n\n58 config [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :1})\nconfig [ \u2019strength\u2019 ] = (\u2019evolution\u2019 , {\u2019k\u2019 :2, \u2019proj_type\u2019:\u2019l2\u2019 , \u2019 epsilon \u2019 :3.0})\n\n60 else :\nconfig [ \u2019smooth\u2019] =(\u2019energy\u2019,{\u2019krylov\u2019 : \u2019gmres\u2019,\u2019maxiter\u2019:3, \u2019degree\u2019 :2, \u2019weighting\u2019: \u2019 local \u2019})\n\n62 config [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\nconfig [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019, {\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\n64 config [ \u2019strength\u2019 ] = (\u2019evolution\u2019 , {\u2019k\u2019 :2, \u2019proj_type\u2019:\u2019l2\u2019 , \u2019 epsilon \u2019 :3.0})\n# Determine near null?space modes B\n\n66 if B == None:\n# B is the constant for each variable in a node\n\n68 if isspmatrix_bsr(A) and A.blocksize[0] > 1:\nbsize = A.blocksize[0]\n\n70 config [ \u2019B\u2019] = numpy.kron(numpy.ones((A.shape[0]/bsize,1), dtype=A.dtype), \\\nnumpy.eye(bsize))\n\n72 else :\nconfig [ \u2019B\u2019] = numpy.ones((A.shape[0],1), dtype=A.dtype)\n\n74\nelif (type(B) == type(numpy.zeros((1,)))) or (type(B) == type(scipy.mat(numpy.zeros((1,))))):\n\n76 if len(B.shape) == 1:\nB = B.reshape(?1,1)\n\n78 if (B.shape[0] != A.shape[0]) or (B.shape[1] == 0):\nraise TypeError(\u2019Invalid dimensions of B, B.shape[0] must equal A.shape[0]\u2019)\n\n80 else :\n\n\n\nA.9. Reutiliza\u00e7\u00e3o das estruturas multigrid 177\n\nconfig [ \u2019B\u2019] = numpy.array(B, dtype=A.dtype)\n82 else :\n\nraise TypeError(\u2019Invalid B\u2019)\n84 if config [ \u2019symmetry\u2019] == \u2019hermitian\u2019:\n\nconfig [ \u2019BH\u2019] = None\n86 else :\n\nconfig [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n88\n\n# Set non?symmetry related parameters\n90 config [ \u2019strength\u2019 ] = (\u2019evolution\u2019 , {\u2019k\u2019 :2, \u2019proj_type\u2019:\u2019l2\u2019 , \u2019 epsilon \u2019 :3.0})\n\nconfig [ \u2019max_levels\u2019] = 15\n92 config [ \u2019max_coarse\u2019] = 1000\n\nconfig [ \u2019coarse_solver\u2019] = \u2019lu\u2019\n94 config [ \u2019aggregate\u2019] = \u2019standard\u2019\n\nconfig [ \u2019keep\u2019] = False\n96 return config\n\n98 def solver(A, config):\n# Convert A to acceptable format\n\n100 A = make_csr(A)\n# Generate smoothed aggregation solver\n\n102 try:\nreturn smoothed_aggregation_solver(A,\n\n104 B=config[\u2019B\u2019],\nBH = config[\u2019BH\u2019],\n\n106 smooth = config[\u2019smooth\u2019],\nstrength = config[\u2019strength\u2019 ],\n\n108 max_levels = config[\u2019max_levels\u2019],\nmax_coarse = config[\u2019max_coarse\u2019],\n\n110 coarse_solver = config[\u2019coarse_solver\u2019 ],\nsymmetry = config[\u2019symmetry\u2019],\n\n112 aggregate = config[\u2019aggregate\u2019 ],\npresmoother = config[\u2019presmoother\u2019],\n\n114 postsmoother = config[\u2019postsmoother\u2019],\nkeep = config[\u2019keep\u2019])\n\n116 except:\nraise TypeError(\u2019Failed generating smoothed_aggregation_solver\u2019)\n\n118 def solve(A, b, x0=None, tol=1.000000001E?08, maxiter=400,residuals=None,\nreturn_solver=False, existing_solver=None, verb=True):\n\n120 # Convert A to acceptable CSR/BSR format\nA = make_csr(A)\n\n122 # Generate solver if necessary\nif existing_solver == None:\n\n124 # Parameter dictionary for smoothed_aggregation_solver\nconfig = solver_configuration(A, B=None, verb=verb)\n\n126 # Generate solver\nexisting_solver = solver(A, config)\n\n128 else :\nif existing_solver. levels [0]. A.shape[0] != A.shape[0]:\n\n130 raise TypeError(\u2019Argument existing_solver must have level 0 matrix of same size as A\u2019)\n# Krylov acceleration depends on symmetry of A\n\n132 if existing_solver. levels [0]. A.symmetry == \u2019symmetric\u2019:\naccel = \u2019cg\u2019\n\n134 else :\naccel = None\n\n136 # Initial guess\nif x0 == None:\n\n\n\n178 AP\u00caNDICE A. C\u00f3digo Python\n\n138 x0 = numpy.array(scipy.rand(A.shape[0],), dtype=A.dtype)\nelse :\n\n140 x0=x0\n# Callback function to print iteration number\n\n142 if verb:\niteration = numpy.zeros((1,))\n\n144 print \" maxiter = %d\"%maxiter\ndef callback(x, iteration ):\n\n146 iteration [0] = iteration [0] + 1\nprint \" iteration %d\"%iteration[0]\n\n148 callback2 = lambda x : callback(x,iteration )\nelse :\n\n150 callback2 = None\n# Solve with accelerated Krylov method\n\n152 res=[]\nx = existing_solver.solve(b,accel=accel,residuals=res,tol=tol,maxiter=maxiter, callback=callback2)\n\n154 if verb:\nr0 = norm( numpy.ravel(b) ? numpy.ravel(A?x0))\n\n156 rk = norm( numpy.ravel(b) ? numpy.ravel(A?x) )\nif r0 != 0.0:\n\n158 print \" Residual reduction || r_k ||/|| r_0|| = %1.2e\"%(rk/r0)\nelse :\n\n160 print \"Residuals || r_k||, || r_0|| = %1.2e, %1.2e\"%(rk,r0)\n\n162 if return_solver:\nreturn (x.reshape(b.shape), existing_solver, config [ \u2019B\u2019]) , iteration ,res\n\n164 else :\nreturn x.reshape(b.shape),iteration ,res\n\nA.10 Nota Final\n\nPara facilitar a utiliza\u00e7\u00e3o, as classes foram separadas nos seguintes m\u00f3dulos. Por sua\nvez, cont\u00e9m as fun\u00e7\u00f5es descritas nesse ap\u00eandice.\n\nErrorEstimatorFunctions.py\n\n\u2013projectionFunction(kargs**)\n\u2013ProjectionGradient(kargs**)\n\u2013MakeSystem_and_TransformData(kargs**)\n\u2013ErrorComponents(kargs**)\n\u2013AlphaS(kargs**)\n\u2013Indicators(kargs**)\n\u2013ErrorEstimatesSpaceTime(kargs**)\n\u2013AuxiliarErrorEstimatesSpaceTime(kargs**)\n\u2013MaxMinIndicators(kargs**)\n\u2013EachStepError_Indicator_Space_Time(kargs**)\n\n\n\nA.10. Nota Final 179\n\n\u2013FormLargeAdvection(kargs**)\n\u2013LargeAdvectionEstimates(kargs**)\n\u2013DiffFunction(kargs**)\n\u2013DiffFunction2(kargs**)\n\u2013DataResidualComponents(kargs**)\n\u2013DataResidualComponents2(kargs**)\n\u2013FormDataOneNeumann(kargs**)\n\u2013FormOneNeumannIndicator(kargs**)\n\u2013DataErrorEstimateStepN(kargs**)\n\u2013FunctionFDataErrorEstimateStepN(kargs**)\n\u2013FunctionFDataErrorIndicatorsStepN(kargs**)\n\u2013NeumanDataErrorEstimateN(kargss**)\n\nPolyErrorEstimator.py\n\u2013 ErrorEstimate_for_InitialCondition(kargss**)\n\u2013RefineMesh_for_InitCond(kargss**)\n\u2013 RefineMesh_for_InitCond2(kargss**)\n\u2013 RefineMeshForFfunction(kargss**)\n\u2013 RefineMeshForData(kargss**)\n\u2013 MyErrorNorm(kargss**)\n\nEssas fun\u00e7\u00f5es, por sua vez, foram englobadas em um \u00fanico m\u00f3dulo chamado Tools.\nEsse procedimento simplifica a quantidade de informa\u00e7\u00e3o a ser gerenciada dentro de uma\nmesma pasta da plataforma Eclipse.\n\nAs demais fun\u00e7\u00f5es utilizadas foram definidas localmente no c\u00f3digo computacional. O\nap\u00eandice seguinte apresenta alguns exemplos de c\u00f3digos utilizados nesta tese.\n\n\n\n\n\n181\n\nAP\u00caNDICE B \u2013 Exemplos completos\n\nB.1 FEM e solu\u00e7\u00e3o anal\u00edtica\n\nExemplo de implementa\u00e7\u00e3o da aproxima\u00e7\u00e3o de elementos finitos com c\u00e1lculo de\nsolu\u00e7\u00e3o anal\u00edtica.\n\n1 \"\"\"Exemplo: equacao do transporte de contaminantes.\ni . aproximacao por elementos finitos.\n\n3\nObjetivo do codigo: servir de base para estudos posteriores .\n\n5 Consultar referencias para maiores detalhes.\n\n7 Referencias basicas:\n1. http:// fenicsproject .org/documentation/tutorial/index.html\n\n9 2. http:// fenicsproject .org/qa/\n3. http://matplotlib.org/\n\n11 4. http://www.numpy.org/\n5. http://www.scipy.org/\n\n13 6. R. Verfurth, Adaptive finite element methods lecture notes winter term 2007/08.\n7. https://code.google.com/p/scitools/wiki/EasyvizDocumentation\n\n15 8.WEXLER, E. Chapter b7: Applications of hydraulics analytical solutions for one?, two?\nand three?dimensional solute transport in groundwater systems with uniform flow. In:\n\n17 Techniques of Water Resources Investigations of the United State Geological Survey, Book\n3: Applications to Hydraulics. Denver, USA: U.S. Geological Survey, 1992.\n\n19 \"\"\"\n\n21 #????a biblioteca para elementos finitos\nfrom dolfin import ?\n\n23 from numpy import ?#a biblioteca para matrizes\nimport numpy as np #alternativa para evitar duplicidade\n\n25 import scipy as sp # Python Cienfifico?Scipy\nimport matplotlib as mpl #biblioteca para graficos\n\n27 import matplotlib.pyplot as plt #plot\n\n29\nfrom scipy import integrate# pacote de integracao numerica(ver manual do scipy)\n\n31 import scitools .BoxField# grafico\nimport scitools .easyviz as ev#grafico\n\n33 parameters.reorder_dofs_serial = False#evita reordenacao. Necessario para usar BoxField\n#???questao respondida em: https://answers.launchpad.net/dolfin/+question/219220\n\n35 #parametros do metodo de elementos finitos\nx0=0;y0=0;x1=3000;y1=1500;nx =100;ny = 50;\n\n37 #fronteiras da fonte, grau, esquema de discretizacao, passo de tempo tau_n, tempo final\nY1=635.0;Y2=865.0;degree=1;theta = 0.50;dt=5.0;t_stop = 4000.0;nsteps=floor(t_stop/dt);\n\n39 nsteps=int(nsteps); print \u2019the number of steps\u2019,nsteps\n#????????????????malha de elementos triangulares orientada\n\n41 mesh = RectangleMesh(x0,y0,x1,y1,nx, ny,\u2019left/right\u2019)\n#????????????????resumo da malha de elementos\n\n43 print \"%s\"%str(mesh)\n#Funcoes continuas por partes com grau=degree\n\n\n\n182 AP\u00caNDICE B. Exemplos completos\n\n45 C = FunctionSpace(mesh, \u2019Lagrange\u2019, degree)\n#========================Fronteiras\n\n47 #???Fronteira de Dirichlet 01\nu_c = Expression(\u20191.0\u2019)#funcao\n\n49 class C0Boundary(SubDomain):\ndef inside( self , x, on_boundary):\n\n51 tol = 1E?14 # tolerance for coordinate comparisons\nreturn on_boundary and (abs(x[0]) &lt;tol and abs(x[1]?750.0)<115.0)\n\n53 Gamma_0 = DirichletBC(C, u_c, C0Boundary())\n#???Fronteira de Dirichlet 02\n\n55 u_c1 = Expression(\u20190.0\u2019)\nclass C1Boundary(SubDomain):\n\n57 def inside( self , x, on_boundary):\ntol = 1E?14 # tolerance for coordinate comparisons\n\n59 return on_boundary and (abs(x[0]) &lt;tol and abs(x[1]?750.0)>115.0)\nGamma_1 = DirichletBC(C, u_c1, C1Boundary())\n\n61 #???lista de fronteiras.\n#Ex: bcs=[Gamma0,Gamma1,...,Gamma10]\n\n63 bcs=[Gamma_0,Gamma_1]\n#????????????????Fronteiras de Neumann\n\n65 #???\"marcacao do dominio das entidades do dominio\"\n#para definicao das fronteiras\n\n67 boundary_parts = MeshFunction(\"size_t\", mesh, mesh.topology().dim()?1)\n#???fronteira de neumann em y=0 e y=1500. Usar 0.0 e 1500.0\n\n69 class NeumanBoundary(SubDomain):\ndef inside( self , x, on_boundary):\n\n71 tol = 1E?14 # tolerance for coordinate comparisons\nreturn on_boundary and (abs(x[1]) &lt;tol or abs(x[1]?1500.0)<tol)\n\n73 N_0 = NeumanBoundary()\nN_0.mark(boundary_parts, 0)\n\n75 #???fronteira de neumann em y=3000.0\nclass NRightBoundary(SubDomain):\n\n77 def inside( self , x, on_boundary):\ntol = 1E?14 # tolerance for coordinate comparisons\n\n79 return on_boundary and abs(x[0] ? 3000.0) &lt;tol\nN_1 = NRightBoundary()\n\n81 N_1.mark(boundary_parts, 1)\n#========================Dados do problema definidos no espaco\n\n83 #de elementos finitos\n#???expressao para a condicao inicial\n\n85 C0=Expression(\u20190.0000000\u2019);\n#???????interpolando para o espaco de elementos finitos\n\n87 c1=interpolate(C0,C)\n#????fonte e dispersoes: expressoes\n\n89 f=Constant(\u20190.0\u2019)# fonte\ndxx=10.0; dyy=2.0;dxy=0.0;dyx=dxy;D=as_matrix([[dxx,dxy],[dyx,dyy]])\n\n91 #???velocidades em x e y. Campo de velocidades: VField\nvx=Expression(\u20190.2\u2019); vy=Expression(\u20190.0\u2019); VField=(vx,vy)\n\n93 #expressao que fornece velocidade.Aqui vx e vy sao usados\nH=Expression(\u20190.2?x[0]\u2019); H1= interpolate(H, C)\n\n95 #????reacao e vetor normal\nLambda=Constant(\u20190.0\u2019); n=FacetNormal(mesh)\n\n97 #========================Formas bilinear e linear\n#funcao tentativa e funcao teste\n\n99 c= TrialFunction(C)\nw = TestFunction(C)\n\n101 f1=f#f^n=f^{n?1}(ver verfurth nas referencias basicas)\n\n\n\nB.1. FEM e solu\u00e7\u00e3o anal\u00edtica 183\n\n#????forma bilinear e linear: s(0) e s(1) indicam fronteira Neumann?ver [1.]\n103 a = (1.0/dt)?c?w?dx + theta?inner(D?nabla_grad(c),nabla_grad(w))?dx+\\\n\ntheta?(inner(VField, nabla_grad(c)))?w?dx + theta?Lambda?c?w?dx?\\\n105 theta?inner(D?grad(c),n)?w?ds(0)?theta?inner(D?grad(c),n)?w?ds(1)\n\n#????forma linear\n107 L = ((1.0/dt)?c1?w+(theta?1.0)?inner(D?nabla_grad(c1), nabla_grad(w)))?dx+\\\n\n(theta?1.0)?inner(VField, grad(c1))?w?dx+(theta?1.0)?Lambda?c1?w?dx+(theta?f1+(1.0?theta)?f)?w?\ndx+\\\n\n109 (1.0?theta)?inner(D?grad(c1),n)?w?ds(0)+(1.0?theta)?inner(D?grad(c1),n)?w?ds(1)\n#????construindo sistema de equacoes com fronteira de neumann\n\n111 A = assemble(a, exterior_facet_domains=boundary_parts)\n# lado esquerdo. Forma indicada no manual para\n\n113 #economizar memoria\nb = None\n\n115 #????funcao\nc= Function(C);\n\n117 t = dt;contador=0;counter=0;tol=1.0E?5;\n#???marcador do tempo\n\n119 #========================incremento tempo e\n#solucao e loop no tempo\n\n121 while t&lt;t_stop+tol:\n#????construindo o lado b com fronteira de neumann\n\n123 b = assemble(L,exterior_facet_domains=boundary_parts)\n#????Fronteira de Dirichlet\n\n125 for bc in bcs:\nbc.apply(A, b)\n\n127 #????resolvendo com metodo padrao do dolfin. Calculando o tempo\n#necessario para a solucao\n\n129 from time import time\ntempo10=time()\n\n131 solve(A,c.vector(), b)\nfrom time import time\n\n133 tempo11=time()\n# Definindo temo computacional\n\n135 TempoComputcional=tempo11?tempo10\nprint\u2019O tempo computacionla\u2019,TempoComputcional\n\n137 contador+=1; print \u2019contador\u2019,contador\nc1.assign(c)\n\n139 #????salvando solucao especifica\nif contador==nsteps?1:\n\n141 print\u2019saving a time before final time step\u2019 ,t\n#salvar na mesma pasta da simulacao. Pasta diferente basta\n\n143 # fornecer o caminho\n#????np.save(): ver manual do numpy. Salva em formato .npy\n\n145 #????ler com np.read(): ver manual do numpy.\nnp.save(\u2019cReaction\u2019,c1.vector())\n\n147 t+= dt\nplot(c1,mesh=mesh,interactive=False)\n\n149 #????salva solucao para pos?processamento\n#?vetor de valores nodais da solucao numerica\n\n151 np.save(\u2019c1Reaction\u2019,c1.vector())\n#????salva figura solucao em formato .png\n\n153 p=plot(c1,mesh=mesh,interactive=False)\np.write_png(\u2019SolucaoTfinal\u2019)\n\n155\n#??????????????????????????????????????????????\n\n157 #Solucao analitica de Wexler(ver referencia 08.) para aquifero infinito e fonte nao pontual de\n\n\n\n184 AP\u00caNDICE B. Exemplos completos\n\n#contaminante\n159 print\u2019Analytical solution calculation \u2019\n\n#Dados\n161 C0=1.0; dxx=10.0;dyy=2.0;dxy=0.0;dyx=dxy;\n\nvx=0.2;vy=0.0\n163 # expressao fora da integral :Ver referencia\n\ndef Expr_out_integral(x,y):\n165 sigma=(1./sqrt(np.pi?dxx))\n\nreturn C0?x?sigma?exp((vx)?x/(2?dxx))\n167 reaction_rate=0.00\n\n169 #expressao dentro da integral:ver referencia\ndef Expr_to_integrate(z,x,y):\n\n171 # quadpack: biblioteca fortran para integracao[Ver referencia SciPy]\n#usa primeiro argumento para integrar\n\n173 exp1=(1.0/(z??3))?exp(?(((vx)??2)/(4?dxx)+reaction_rate)?(z??4)?(x??2)/(4?dxx?(z??4)))\n#fator dentro da primeira funcao erfc\n\n175 Y11=(Y1?y)/(2?(z??2)?sqrt(dyy))\n#fator dentro da segunda funcao erfc\n\n177 Y12= (Y2?y)/(2?(z??2)?sqrt(dyy))\n#definindo funcao auxiliar erfc1\n\n179 erfc1=1.0?erf(Y11)?(1.0?erf(Y12))\n\n181 return exp1?erfc1\n\n183 # Uma classe que implementa a solucao analitica: impondo\n# condicao de fronteira e executando integracao com modulo\n\n185 #integrate do QuadPack...[Ver SciPy]\n#http://www.scipy.org/\n\n187\nclass analytical (Expression):\n\n189 def eval( self , value, x):\ntol=1.0E?15\n\n191 if (abs(x[0])<tol and abs(x[1]?750.0)>115.0):\nvalue[0]=0.0\n\n193 elif (abs(x[0])<tol and abs(x[1]?750.0)<115.0):\nvalue[0]=C0\n\n195 else :\n#limite superior de integracao\n\n197 sup_z=t_stop??0.25\n#??????????????\n\n199 y,err=integrate.quad(Expr_to_integrate,0,sup_z, args=(x[0],x[1],))\ny2=Expr_out_integral(x[0],x[1])\n\n201 value[0]=y?y2\nf2= analytical(element=C.ufl_element());\n\n203 f2 = interpolate(f2,C)\n\n205 #salvando vetor de valores nodais\n#solucao analitica\n\n207 f2_exact=f2.vector()\nnp.save(\u2019c_ReactionExact.npy\u2019,f2_exact)\n\n\n\nB.1. FEM e solu\u00e7\u00e3o anal\u00edtica 185\n\nB.1.1 Compara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica, gr\u00e1ficos\n\nAs solu\u00e7\u00f5es podem ser comparadas tanto nos pontos nodais quanto em forma gr\u00e1fica.\nO c\u00f3digo seguinte apresenta um exemplo de compara\u00e7\u00e3o dos valores nodais e apresenta os\nresultados em forma gr\u00e1fica.\n\n1 \"\"\"Exemplo: Analise dos resultados obtidos no caso anterior\nComparacao de resultados e graficos com matplotlib\n\n3 Referencias basicas:\n1. http:// fenicsproject .org/documentation/tutorial/index.html\n\n5 2. http:// fenicsproject .org/qa/\n3. http://matplotlib.org/\n\n7 4. http://www.numpy.org/\n5. http://www.scipy.org/\n\n9 6. R. Verfurth, Adaptive finite element methods lecture notes winter term 2007/08.\n7. https://code.google.com/p/scitools/wiki/EasyvizDocumentation\n\n11 \"\"\"\n\n13 #????a biblioteca para elementos finitos\nfrom dolfin import ?\n\n15 #a biblioteca para matrizes\nfrom numpy import ?\n\n17 #alternativa para evitar duplicidade\nimport numpy as np\n\n19 # Python Cienfifico?Scipy\nimport scipy as sp\n\n21 import matplotlib as mpl #biblioteca para graficos\nimport matplotlib.pyplot as plt #plot\n\n23\n# pacote de integracao numerica(ver manual do scipy)\n\n25 from scipy import integrate\nimport scitools .BoxField# grafico\n\n27 import scitools .easyviz as ev#grafico\n#evita reordenacao. Necessario para usar BoxField\n\n29 parameters.reorder_dofs_serial = False\n#???questao respondida em: https://answers.launchpad.net/dolfin/+question/219220\n\n31 #========================Definindo parametros gerais\n#????????????????parametros do metodo de elementos finitos\n\n33 x0=0;y0=0;x1=3000;y1=1500;nx =100;ny = 50;\n##????????????????fronteiras da fonte, grau, esquema de discretizacao, passo de tempo tau_n,\n\ntempo final\n35 Y1=635.0;Y2=865.0;degree=1;theta = 0.50;dt=5.0;t_stop = 4000.0\n\nnsteps=floor(t_stop/dt); nsteps=int(nsteps);\n37 print \u2019the number of steps\u2019,nsteps\n\n#????????????????malha de elementos triangulares orientada\n39 mesh = RectangleMesh(x0,y0,x1,y1,nx, ny,\u2019left/right\u2019)\n\n41 C = FunctionSpace(mesh,\u2019Lagrange\u2019,degree)\n#?????????Carregando solucao numerica obtida\n\n43 c1=np.load(\u2019c1Reaction.npy\u2019)\nsolut=Function(C)\n\n45 solut .vector() [:]=c1\nc1=Function(C)\n\n47 c1.assign(solut)\n#visualizacao rapida da solucao em malha: modo inter\n\n\n\n186 AP\u00caNDICE B. Exemplos completos\n\n49 plot(c1,mesh=mesh,interactive=True)\n# Carregando solucao analitica calculada. Considerando mesmo espaco\n\n51 c_exact=np.load(\u2019c_ReactionExact.npy\u2019)\nu_e=Function(C)\n\n53 u_e.vector()[:]=c_exact\n#classe difff : diferenca entre solucoes em modulo\n\n55 class diff (Expression):\ndef eval( self , value, x):\n\n57 tol=1.0E?15\nvalor=u_e(x[0],x[1])?c1(x[0],x[1])\n\n59 value[0]=abs(valor)\ndiff = diff(element=C.ufl_element());\n\n61 diff = interpolate( diff ,C)\n\n63 class diff2 (Expression):\ndef eval( self , value, x):\n\n65 tol=1.0E?15\nvalor=u_e(x[0],x[1])?c1(x[0],x[1])\n\n67 value[0]=valor\ndiff2 = diff2(element=C.ufl_element());\n\n69 diff2 = interpolate( diff2 ,C)\n\n71 u_nodal_values = c1.vector();u_array = u_nodal_values.array()\nue_nodal_values = u_e.vector();ue_array = ue_nodal_values.array()\n\n73 diffe_array=diff.vector().array()\n\n75 #imprimindo valores na tela\ncoor = mesh.coordinates()\n\n77 maxvalue=max(diffe_array)\n# valores referentes as diferencas de solucoes\n\n79 print \u2019the maximum value for difference matrix\u2019,maxvalue\nprint\u2019the mean for diferences of errors \u2019 , mean(diffe_array)\n\n81 print\u2019the mean for diferences of errors \u2019 ,std(diffe_array)\n\n83 if coor.shape[0] == u_array.shape[0]:\nfor i in range(len(u_array)):\n\n85 if diffe_array[ i]>0.5?maxvalue:\nprint \u2019C(%.8f,%.8f) = %.8f,%.8f,%.8f\u2019 %(coor[i ][0], coor[i ][1], u_nodal_values[i],ue_nodal_values\n\n[i],diffe_array[i ])\n87\n\n# L2 norma usando FEniCS metodologia\n89 error_norm=errornorm(u_e,c1,\u2019L2\u2019,1)\n\nprint \u2019norma L2 usando FEniCS funcao=\u2019, error_norm\n91 #Graficos com a biblioteca MATPLOTLIB\n\nprint \u2019NOTA: Se degree>1 precisa projetar solucao para\\n\u2019\n93 print\u2019 espaco com degree=1. Ver funcao \"project(kargs??) do FEniCS\"\u2019\n\n#========================================================\n95 from mpl_toolkits.mplot3d import Axes3D\n\nfrom matplotlib import cm\n97 from matplotlib.ticker import LinearLocator\n\nimport matplotlib.pyplot as plt\n99 import matplotlib.tri as tri\n\nimport numpy as np\n101\n\nxy=mesh.coordinates()\n103 x=xy[:,0]; y=xy[:,1]\n\ntriangle=mesh.cells()# a nx3 matrix storing triangles conectivities\n\n\n\nB.2. Estrat\u00e9gia adaptativa 187\n\n105 triang = tri.Triangulation(x, y, triangle )\nZ1e=u_e.vector()[:]\n\n107 Z1n=c1.vector()[:]\nZ1d=diff.vector() [:]\n\n109 seq=np.linspace(0.0001,1.0,100)\n#========================================================\n\n111 plt. figure ()\nprint \u2019 plotting figure 1: curvas da analitica \u2019\n\n113 plt.gca().set_aspect(\u20191.5\u2019)\nplt. tricontour(xy [:,0], xy [:,1], Z1e,seq,linewidth=0.6,zdir=\u2019z\u2019, offset =0.0)\n\n115 plt.colorbar(); plt.grid(True)\nplt.xlabel(\u2019x\u2019); plt.ylabel(\u2019y\u2019)\n\n117 #salva resultado na pasta atual\nplt. savefig (\u2019analiticaCurvas.png\u2019)\n\n119 #??????????????????????????????\nfig1 = plt. figure ()\n\n121 print \u2019 plotting figure : numerica 3D\u2019\nax = fig1.gca(projection=\u20193d\u2019)\n\n123 ax.tick_params(axis=\u2019both\u2019, which=\u2019major\u2019, labelsize=20)\nax.tick_params(axis=\u2019both\u2019, which=\u2019minor\u2019, labelsize=20)\n\n125 ax.plot_trisurf(xy [:,0], xy [:,1], Z1n,cmap=cm.gist_heat_r,linewidth=0.2)\nax.view_init(47,?57)\n\n127 ax.set_xlim(x0,x1)\nax.set_ylim(y0,y1)\n\n129 t1=ax.set_xlabel(r\u2019$x$\u2019, fontsize =20,color=\u2019black\u2019)\nax.set_ylabel(r\u2019$y$\u2019,rotation=45,fontsize=20,color=\u2019black\u2019)\n\n131 ax.text (500.0,1400.00,0.7, r\"$C=C(x,y,t)$\",fontsize=20,color=\u2019blue\u2019)\nax.set_zlim3d(0.0, 0.10)\n\n133 ax.set_zlabel(r\"$C$\",rotation=45,fontsize=20,color=\u2019black\u2019)\nplt. savefig (\u2019numerica3D.png\u2019)\n\n135 plt.show()\n\nB.2 Estrat\u00e9gia adaptativa\n\nC\u00f3digo para malha adaptada para os dados similar ao exemplo (5.3.4.1). Malha\nn\u00e3o estruturada em campo de velocidade vari\u00e1vel. O procedimento adaptativo \u00e9 utilizado\nsequencialmente nos dados da equa\u00e7\u00e3o do transporte.\n\n1 \"\"\"\nReferencias basicas:\n\n3 1. http:// fenicsproject .org/documentation/tutorial/index.html\n2. http:// fenicsproject .org/qa/\n\n5 3. http://matplotlib.org/\n4. http://www.numpy.org/\n\n7 5. http://www.scipy.org/\n6. R. Verfurth, Adaptive finite element methods lecture notes winter term 2007/08.\n\n9 7. https://code.google.com/p/scitools/wiki/EasyvizDocumentation\n8. Zoppou, C. and Knight, J. H., Analytical solution of a spatially variable coefficient\n\n11 advection?diffusion equation in up to three dimensions,v.23,doi = {10.1016/S0307?904X(99)00005?0},\n\n\n\n188 AP\u00caNDICE B. Exemplos completos\n\nnumber = {9}, {Applied Mathematical Modelling}, year = {1999},pages = {667??685}.\n13 9. Dirk Praetorius, Ewa Weinmuller, Philipp Wissgott, A Space?Time Adaptive Algorithm for Linear\n\nParabolic Problems,\nInstitute for Analysis and Scientific Computing Vienna University of Technology ? TU Wien, ASC Report\n\n07/2008,\n15 url={ www.asc.tuwien.ac.at ISBN 978?3?902627?00?1}\n\n\"\"\"\n17\n\n#???????????????The velocity field for transport problem\n19 from scitools .std import ?\n\nfrom numpy import ?\n21 from scitools .easyviz.gnuplot_ import ?\n\nfrom dolfin import ?\n23 dolfin .parameters.reorder_dofs_serial = False\n\n#https://answers.launchpad.net/dolfin/+question/219220\n25 import numpy as np\n\nfrom scipy import?\n27 from time import time\n\nif not has_cgal():\n29 print \"DOLFIN must be compiled with CGAL to run this demo.\"\n\nexit(0)\n31\n\nx0=0.0;y0=0.0;x1=20.0;y1=20.0;nx = 20;ny = 20;degree=1;theta = 1.0; dt=0.0025;t_stop = 0.10\n33\n\n# Create empty Mesh\n35 mesh = Mesh()\n\n37 # Create list of polygonal domain vertices\ndomain_vertices = [Point(0.0, 0.0),Point(20.0, 0.0) ,Point(20.0, 20.0),Point(0.0, 20.0)]\n\n39\n# Generate mesh and plot\n\n41 PolygonalMeshGenerator.generate(mesh, domain_vertices, 0.70);\nC = FunctionSpace(mesh, \u2019Lagrange\u2019,degree)\n\n43\n#?????????????Data: Dispersions\n\n45 u0=0.1;D0=1.0;kappa=4.41;epsilon=0.01;beta=0.0\n\n47 from Tools.PolyErrorEstimator import ErrorEstimate_for_InitialCondition\nfrom Tools.PolyErrorEstimator import RefineMesh_for_InitCond,MyErrorNorm\n\n49\nC = FunctionSpace(mesh, \u2019Lagrange\u2019,degree) # defining the Function Space on the adapted mesh\n\n51\nclass dxx(Expression):\n\n53 def eval( self , values, x):\n\u2019\u2019\u2019 Defining the dxx component as a function of the velocity field that is defined over all\n\nelements in mesh...\n55 Could use the same space of fuctions for solving the flux and transport equations because the space\n\ncan be the same..\njust the coefficients for interpolating functions are differents \u2019\u2019\u2019\n\n57 values[0]=D0?u0?u0?(x[0]+1.0)?(x[0]+1.0)\ndxx1 = dxx(element=C.ufl_element());\n\n59 dxx2 = interpolate(dxx1,C)\ntoldxx=0.001;fraction=0.5;degree=1;RaiseDegree=2\n\n61 u0=0.1;D0=1.0;kappa=4.41;epsilon=0.01;beta=0.0\nmesh=RefineMesh_for_InitCond(mesh,dxx2,dxx,C,toldxx,fraction,degree=degree,RaiseDegree=RaiseDegree);\n\n63\n#atualizacao\n\n\n\nB.3. C\u00f3digo completo 189\n\n65 C = FunctionSpace(mesh, \u2019Lagrange\u2019,degree)\ndxx1 = dxx(element=C.ufl_element());\n\n67 dxx2 = interpolate(dxx1,C);\nEdxxRefine = errornorm(dxx1, dxx2,\"L2\", 3,mesh=refine(mesh));\n\n69 Edxx=errornorm(dxx1,dxx2,\"L2\",3)\nraise_degree=3\n\n71\nMyErrordxx=MyErrorNorm(dxx2,dxx,mesh,degree,raise_degree)\n\n73 print \u2019the L2 norm calculated with function\u2019,EdxxRefine,Edxx\nprint \u2019The L2 norm of the representation of dxx dispersion\u2019 ,MyErrordxx\n\n75\n\nB.3 C\u00f3digo completo\n\nEsse c\u00f3digo \u00e9 completo no sentido que incorpora: solu\u00e7\u00e3o do problema do transporte\npelo m\u00e9todo multigrid com reutiliza\u00e7\u00e3o, a solu\u00e7\u00e3o do problema auxiliar utilizando m\u00e9todo\ndo gradiente conjugado pr\u00e9-condicionado por m\u00e9todo multigrid alg\u00e9brico com reutiliza\u00e7\u00e3o,\nas estimativas residuais para o regime de grande advec\u00e7\u00e3o com parti\u00e7\u00e3o do estimador\nresidual, os indicadores residuais e respectiva transforma\u00e7\u00e3o para posterior an\u00e1lise e\napresenta\u00e7\u00e3o gr\u00e1fica.\n\n#from dolfin import ?\n2 from numpy import ?\nimport numpy as np\n\n4 from time import time\nfrom dolfin .cpp.mesh import Mesh\n\n6 #===Part I: Setup problem with Dolfin\ntry:\n\n8 from dolfin import ?\nexcept ImportError:\n\n10 raise ImportError(\u2019Problem with Dolfin Installation\u2019)\nparameters.linear_algebra_backend = \"uBLAS\"\n\n12 #=== Part II: Solve with PyAMG\nfrom scipy.sparse import csr_matrix\n\n14 from scipy.sparse import csc_matrix\nfrom pyamg import smoothed_aggregation_solver\n\n16 from numpy import intc\nfrom BlackBox2Test import solve,solver_configuration,solver\n\n18 from scipy. linalg import norm\nif not has_cgal():\n\n20 print \"DOLFIN must be compiled with CGAL to run this demo.\"\nexit(0)\n\n22\nx0=0.0;y0=0.0;x1=20.0;y1=20.0;nx =200;ny = 200;degree=1;\n\n24 theta = 1.0;dt=0.001;t_stop = 0.1; epsilon=0.5;kappa=220.5;beta=0.0;\n\n26 mesh = RectangleMesh(x0,y0,x1,y1,nx, ny,\u2019left/right\u2019)\nprint \"%s\"%str(mesh)\n\n28\n\n\n\n190 AP\u00caNDICE B. Exemplos completos\n\nC = FunctionSpace(mesh, \u2019Lagrange\u2019,degree)\n30 u_c=Constant(0.0)\n\nclass C0Boundary(SubDomain):\n32 def inside( self , x, on_boundary):\n\ntol = 1E?14\n34 return on_boundary and abs(x[0]) &lt;tol or abs(x[1])<tol\n\nGamma_0 = DirichletBC(C, u_c, C0Boundary())\n36 bcs=[Gamma_0]\n\nboundary_parts =MeshFunction(\"size_t\", mesh, mesh.topology().dim()?1)\n38 class NeumanBoundary(SubDomain):\n\ndef inside( self , x, on_boundary):\n40 tol = 1E?14 # tolerance for coordinate comparisons\n\nreturn on_boundary and (abs(x[1]?y1)<tol and abs(x[0] ? x1) &lt;tol)\n42 N_0 = NeumanBoundary()\n\nN_0.mark(boundary_parts, 0)\n44 mu2=5.0;mu1=5.0;sigma=0.50\n\nclass Cinitial (Expression):\n46 def eval( self , values, x):\n\ntol=1.0E?5\n48 values [0] = 1.0?exp(?0.5?pow(((x[1]?mu2)/sigma),2)?0.5?pow(((x[0]?mu1)/sigma),2))\n\nCinit = Cinitial(element=C.ufl_element());\n50 Cinit = interpolate(Cinit,C)\n\nc1=Cinit\n52\n\nu0=0.50\n54\n\n\u2019\u2019\u2019 Defining the velocity field based on a Fenics expression. The potential velocity\n56 definition ... as Zoppou and Knight h(x,y)=u0(x^2+y^2)/2\u2019\u2019\u2019\n\nHeadExpression=Expression(\u2019(u0/2.0)?(x[0]+1.0)?(x[0]+1.0)?(u0/2.0)?(x[1]+1.0)?(x[1]+1.0)\u2019,u0=u0)\n58 class HEAD(Expression):\n\ndef eval( self , values, x):\n60 values[0]=(u0/2.0)?(x[0]+1.0)?(x[0]+1.0)?(u0/2.0)?(x[1]+1.0)?(x[1]+1.0)\n\nhead = HEAD(element=C.ufl_element());\n62 head = interpolate(head,C)\n\nvx_e=Expression(\u2019u0?(x[0]+1.0)\u2019,u0=u0)\n64 vy_e=Expression(\u2019?u0?(x[1]+1.0)\u2019,u0=u0)\n\nh=interpolate(HeadExpression,C)\n66 V=grad(h)#campo descontinuo\n\nD0=2.0\n68 class dxx(Expression):\n\ndef eval( self , values, x):\n70 values[0]=D0?u0?u0?(x[0]+1.0)?(x[0]+1.0)\n\ndxx1 = dxx(element=C.ufl_element());\n72 dxx1 = interpolate(dxx1,C)\n\nclass dyy(Expression):\n74 def eval( self , values, x):\n\nvalues[0]=D0?u0?u0?(x[1]+1.0)?(x[1]+1.0)\n76 dyy1 = dyy(element=C.ufl_element());\n\ndyy1 = interpolate(dyy1,C)\n78\n\ndxy=dyx=Constant(0); dxx=dxx1;dyy=dyy1; D=as_matrix([[dxx,dxy],[dyx,dyy]])\n80 fc=Expression(\u20190.0\u2019)\n\nv=V;Lambda=Constant(0.0)\n82 c= TrialFunction(C)\n\nw = TestFunction(C)\n84 n=FacetNormal(mesh)\n\nf=Constant(0.0);f1=f\n\n\n\nB.3. C\u00f3digo completo 191\n\n86 a = (1.0/dt)?c?w?dx + theta?inner(D?nabla_grad(c),nabla_grad(w))?dx+\\\ntheta?(inner(v, nabla_grad(c)))?w?dx + theta?Lambda?c?w?dx?\\\n\n88 theta?inner(D?grad(c),n)?w?ds(0)#?theta?inner(D?grad(c),n)?w?ds(1)\nL = ((1.0/dt)?c1?w+(theta?1)?inner(D?nabla_grad(c1), nabla_grad(w)))?dx+\\\n\n90 (theta?1.0)?inner(v, grad(c1))?w?dx+(theta?1.0)?Lambda?c1?w?dx+(theta?f+(1.0?theta)?f)?w?dx+\\\n(1.0?theta)?inner(D?grad(c1),n)?w?ds(0)#+(1.0?theta)?inner(D?grad(c1),n)?w?ds(1)\n\n92 A = assemble(a,exterior_facet_domains=boundary_parts)\nrhs = None\n\n94\nc= Function(C)\n\n96 t = dt\ntol=1.0E?5\n\n98 contador=0\n\n100 hvalue=mesh.hmax()\nprint \u2019the size of the mesh\u2019,hvalue\n\n102 from ErrorEstimatorFunctions import AlphaS\nalpha_S=AlphaS(mesh,epsilon,beta,C)\n\n104 alpha_S=interpolate(alpha_S,C)\n\n106 arrayalphas=alpha_S.vector()\nprint \u2019valor maximo alphaS\u2019,max(arrayalphas)\n\n108 vx=vx_e;vy=vy_e;ReactionFunc=Lambda\nraiseDegree=RaiseDegree\n\n110 from Tools.ErrorEstimatorFunctions import ErrorComponents, AssembleForm_Estimates,Indicators\ntol=1.0E?5\n\n112\ndef FormErrorsDef(alpha_S,mesh,gx,rk,gradot,salt,rneuman,rdirichlet,epsilon,beta):\n\n114\nConstants = FunctionSpace(mesh,\"DG\", 0)\n\n116 w = TestFunction(Constants)\nform1 =alpha_S??2?rk??2?w?dx()# spatial interior\n\n118 form2=(1.0/np.sqrt(epsilon))?avg(alpha_S)?salt??2?avg(w)?dS# form for jump error indicator\nform3=(1.0/np.sqrt(epsilon))?alpha_S?rneuman??2?w?ds(0)#form for boundary error indicator\n\n120 form_time=epsilon?(grad(c?c1))??2?w?dx()+beta?(c?c1)??2?w?dx()# the form for time error indicators\nform= form1+form2+form3#the form for global error estimates associated to space contribuitions\n\n122 form_space=form1+form2+form3\nindicators1=assemble(form_space)\n\n124 indicators=assemble(form)\nindicator1=assemble(form1)\n\n126 indicator2=assemble(form2)\nindicator3=assemble(form3)# the form3 matrix of values\n\n128 time_indicator=assemble(form_time)\nreturn indicators1 , indicators ,indicator1,indicator2,indicator3,time_indicator\n\n130 #?????????????????\ntempoTotal0=0.0;tempoTotal1=0.0;contador=0; tol=1.0E?5;\n\n132 from time import time\nwhile t&lt;t_stop+tol:\n\n134 tempoTotal0=time()\n#???SOLVE THE TRANSIENT PROBLEM WITH AVAILABLE METHOD\n\n136 rhs = assemble(L,exterior_facet_domains=boundary_parts,tensor=rhs)\nfor bc in bcs:\n\n138 bc.apply(A, rhs)\n(row,col,data) = A.data() # get sparse data\n\n140 col = intc(col)\nrow = intc(row)\n\n142 n = A.size(0)\n\n\n\n192 AP\u00caNDICE B. Exemplos completos\n\nprint\u2019the size of the linear system\u2019,n\n144 Asp = csr_matrix( (data,col,row), shape=(n,n))\n\nb = rhs.data()\n146 c10=c1.vector()\n\nc10=c10.array()\n148\n\nfrom time import time\n150 tempo10=time()\n\nmax_levels=20\n152 if contador%1==0:\n\nprint contador\n154 config=solver_configuration(Asp,verb=True)\n\nconfig [ \u2019B\u2019] = np.ones((Asp.shape[0],1), dtype=Asp.dtype)\n156 config [ \u2019BH\u2019] = config[\u2019B\u2019].copy()\n\nconfig [ \u2019smooth\u2019] =(None,{\u2019krylov\u2019:\u2019gmres\u2019},{\u2019 iterations \u2019 :2})\n158 config [ \u2019strength\u2019 ] = [(\u2019 classical \u2019,{\u2019theta\u2019 :0.10}) ,( \u2019 classical \u2019,{\u2019theta\u2019 :0.10}) ]\n\nconfig [ \u2019max_levels\u2019]=(max_levels)\n160 config [ \u2019max_coarse\u2019]=(10000)\n\nconfig [ \u2019coarse_solver\u2019]=(\u2019gauss_seidel\u2019)\n162 config [ \u2019symmetry\u2019]=(\u2019symmetric\u2019)\n\nconfig [ \u2019aggregate\u2019]=(\u2019standard\u2019)\n164 config [ \u2019presmoother\u2019] = (\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n\nconfig [ \u2019postsmoother\u2019] = (\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019:\u2019symmetric\u2019, \u2019 iterations \u2019 :2})\n166 config [ \u2019SA_solve_args\u2019]=({\u2019cycle\u2019:\u2019V\u2019},{\u2019tol \u2019:1.0000000001e?12})\n\nconfig [ \u2019improve_candidates\u2019]=[(\u2019block_gauss_seidel\u2019,{\u2019sweep\u2019: \u2019symmetric\u2019,\u2019 iterations \u2019 :0}) ,None]\n168 config [ \u2019diagonal_dominance\u2019]=(False)\n\nconfig [ \u2019keep\u2019] =(False)\n170 ml=solver(Asp,config)\n\n172 solut , itera ,res= solve(Asp,b,x0=c10,tol=1.0000000001e?12,return_solver=False,maxiter=400,\nexisting_solver=ml)\nelse :\n\n174 solut , itera ,res = solve(Asp,b,x0=c10,tol=1.0000000001e?12,maxiter=400,return_solver=False,\nexisting_solver=ml)\nfrom time import time\n\n176 tempo11=time()\nravelizeResidualSA= np.ravel(b)?np.ravel(Asp?solut)\n\n178 residuo=norm(ravelizeResidualSA)\nprint \u2019the residual \u2019 , residuo\n\n180\nif residuo>0.0001:\n\n182 print \u2019breaking the simulation\u2019\nbreak\n\n184\nmaxResidual=0.0;minResidual=0.0\n\n186 c=Function(C)\nRaResFunc=Function(C)\n\n188\nRaResFunc.vector()[:]=abs(ravelizeResidualSA)\n\n190 c.vector() [:]= solut\nprint \u2019the residual from problem\u2019,residuo\n\n192 if max(c.vector().array())>max(c1.vector().array()):\nprint\u2019BREAKING BECAUSE METHOD INSERTING CONTAMINANT:BAD VALUE\u2019\n\n194 break\nif min(c.vector().array())<?0.00001:\n\n196 print\u2019BREAKING BECAUSE BAD NEGATIVE VALUES IN CONCENTRATIONS\u2019\nbreak\n\n\n\nB.3. C\u00f3digo completo 193\n\n198 #???DEFINE RESIDUAL COMPONENTS FOR STATIONARY DIFUSION?REACTION PROBLEM\nif contador==nsteps?1:\n\n200 from Tools.ErrorEstimatorFunctions import FormLargeAdvection\nALarge,bLarge=FormLargeAdvection(epsilon,beta,c,c1,v,mesh=mesh)\n\n202 (rowLarge,colLarge,dataLarge) = ALarge.data() # get sparse data\ncolLarge = intc(colLarge)\n\n204 rowLarge = intc(rowLarge)\nnLarge = ALarge.size(0)\n\n206 print\u2019the size of the linear system\u2019,n\nAspLarge = csr_matrix( (dataLarge,colLarge,rowLarge), shape=(nLarge,nLarge))\n\n208 bLarge = bLarge.data()\nml = smoothed_aggregation_solver(AspLarge)\n\n210 res1 = []\nx = ml.solve(bLarge,accel=\u2019cg\u2019,tol=1e?12, residuals=res1)\n\n212 ctil =Function(C)\nctil .vector() [:]=x\n\n214 plot( ctil ,mesh=mesh,interactive=False,title=\u2019auxiliar problem\u2019)\n\n216 #???COMPUTE ALL PARTS OF RESIDUAL ERROR ESTIMATOR:\n#?ETA SPATIAL, DATA ESTIMATE,\n\n218 #?TEMPORAL ESTIMATE FOR SMALL, ETA F, ESTIMATE FOR LARGE ADVECTION\n#?INTERIOR, JUMP,BOUNDARY,DATA INTERIOR,DATA JUMP, FUNTION INTERIOR,\n\n220 #?FUNCTION BOUNDARY, ENERGY SMALL, LARGE INTERIOR, LARGE JUMP.\n#?DEFINE RESIDUAL ERROR COMPONENTS\n\n222\nfrom Tools.ErrorEstimatorFunctions import ErrorEstimatesSpaceTime\n\n224 VField=V;fx=f#this is because difference is small: that is less than e?09. Could use \\PiC0 ou f\nfunction\n\nn,gx,rk,gradot,salt ,rneumann,rdirichlet=ErrorComponents(mesh,D,c,c1,VField,theta,Lambda,fx,dt)\n226 print \u2019 defining forms to residuals \u2019\n\n#???DEFINE ERROR FORMS(SMALL ADVECTION) FOR SPATIAL AND TIME WITHOUTH\nFUNCTION, DATA AND\n\n228 #?AUXILIAR ESTIMATES\nindicators1 , indicators ,indicator1,indicator2,indicator3,time_indicator=\\\n\n230 FormErrorsDef(alpha_S,mesh,gx,rk,gradot,salt,rneumann,rdirichlet,epsilon,beta)\n\n232 indicator_spatial =array([sqrt(i) for i in indicators ]) ; print np.shape(indicator_spatial)\nindicator_form1 = array([sqrt(i) for i in indicator1 ])\n\n234 indicator_form2 = array([sqrt(i) for i in indicator2 ])\nindicator_form3 = array([sqrt(i) for i in indicator3 ])\n\n236 indicator_form4 = array([sqrt(i) for i in time_indicator])\n#DEFINE ERROR ESTIMATES FOR TRANSIENT PROBLEM:\n\n238 ErrorSpace,ErrorInterior,ErrorJump,ErrorBoundary,\\\nErrorTime=ErrorEstimatesSpaceTime(indicators1,indicators,indicator1,indicator2,indicator3,\n\ntime_indicator,dt)\n240 #????????????????????????ESTIMATIVAS DOS DADOS\n\nfrom Tools.ErrorEstimatorFunctions import DataResidualComponents,FormDataOneNeumann,\\\n242 DataErrorEstimateStepN\n\nfrom Tools.ErrorEstimatorFunctions import FormOneNeumannIndicator\n244 #???????????????Required data for function DataResidualComponents\n\nvx=vx_e;vy=vy_e;ReactionFunc=Lambda;raiseDegree=RaiseDegree;H=HeadExpression\n246 #???????????????Residual error components\n\nmesh2,DK,function,DiffGradot,DiffJump,DiffNeumann,\\\n248 DiffDirichlet =DataResidualComponents(C,alpha_S,epsilon,c1,c,dxx,dxy,dyy,HeadExpression,theta,\n\n\\vx,vy,ReactionFunc,mesh,degree,raiseDegree)\n250 #???????????????Data residual matrix of residual components(indicator^2) and indicator\n\nDataInteriorForm,DataJumpForm,DataBoundaryForm,DataGeralForm=\\\n\n\n\n194 AP\u00caNDICE B. Exemplos completos\n\n252 FormDataOneNeumann(C,epsilon,degree,raiseDegree,beta,mesh2,DK,function,DiffGradot,DiffJump,\nDiffNeumann,\\\n\nDiffDirichlet )\n254 #??????????????????Indicadores dos dados\n\nDataInteriorIndicator,DataJumpIndicator,DataBoundaryIndicator,DataGeralIndicator=\\\n256 FormOneNeumannIndicator(epsilon,alpha_S,mesh2,DK,function,DiffGradot,DiffJump,DiffNeumann,\n\nDiffDirichlet)\n#???????????????Data residual evaluation :interior, jump, boundary and general\n\n258 DataInterior,DataJump,DataBoundary,DataGeral=\\\nDataErrorEstimateStepN(DataInteriorForm,DataJumpForm,DataBoundaryForm,DataGeralForm,dt)\n\n260 #???F FUNCTION ESTIMATES\nfrom Tools.ErrorEstimatorFunctions import FunctionFDataErrorEstimateStepN\n\n262 Fexpression=fc\nDataFfunctionEstimate,DataFfunctionIndicator,\\\n\n264 DataFfunction=FunctionFDataErrorEstimateStepN(C,alpha_S,epsilon,theta,Fexpression,mesh,degree,\nraiseDegree,dt)\n\n#??????????????????LARGE ADVECTION ESTIMATES\n266 from Tools.ErrorEstimatorFunctions import LargeAdvectionEstimates,\n\nAuxiliarErrorEstimatesSpaceTime\n#???LARGE ADVECTION MATRIX OF ERROR COMPONENTS\n\n268 print \u2019the solution for the linear system was calculated ... calculations of the estimates\u2019\nprint \u2019 \u2019\n\n270 formLarge,form1Large,form2Large,form3Large=LargeAdvectionEstimates(alpha_S,mesh,epsilon,beta,c,\nc1,ctil,v)\n\n272 LargeGeralEstimate,LargeInteriorEstimate,LargeJumpEstimate,\\\nLargeEnergyCtilEstimate=AuxiliarErrorEstimatesSpaceTime(formLarge,form1Large,form2Large,\n\nform3Large,dt)\n274 #???ERROR ESTIMATES FOR LARGE ADVECTION USING THE SAME CLASS USED FOR\n\n#SPATIAL ERROR\n276 LargeGeralEstimate,LargeInteriorEstimate,LargeJumpEstimate=AuxiliarErrorEstimatesSpaceTime(\n\nformLarge,\\\nform1Large,form2Large,form3Large,dt)\n\n278 #??FUNCTION ON THE NEUMANN BOUNDARY: THERE IS NO ERROR\n#???GERAL ESTIMATES\n\n280 #ESPACIAL GERAL: INICIAL+ESPACIAL+TEMPORAL+DADOS+ETAF+ETAAUXILIAR\n#LEMBRAR QUE EXISTE MULTIPLICACAO POR DT\n\n282 #INDICADOR ESPACIAL E TEMPORAL: (ESPACIAL+DADOS)^{1/2} E\n#(TEMPORAL+ETAF+ETAAUXILIAR)^{1/2}\n\n284 ErroGeral+=ErrorSpace+ErrorTime+DataGeral+DataFfunctionEstimate+LargeGeralEstimate\nRaizErroGeral=sqrt(ErroGeral)#o estimador ate aquele passo de tempo\n\n286 IndicadorEspacial=sqrt(ErrorSpace+DataGeral)\nIndicadorTemporal=sqrt(ErrorTime+DataFfunctionEstimate+LargeGeralEstimate)\n\n288 ErrorSpace,ErrorInterior,ErrorJump,ErrorBoundary,ErrorTime, DataInterior,DataJump,DataBoundary\n,DataGeral,\n\nDataFfunctionEstimate, LargeGeralEstimate,LargeInteriorEstimate,LargeJumpEstimate\n290 #Adjustment for graphical analysis and plot as FEM\n\nclass IndicForm(Expression):\n292 def eval_cell( self , value, x, ufc_cell):\n\nvalue[0] = np.sqrt(indicators[ufc_cell.index]+DataGeralForm[ufc_cell.index])\n294 IndicatorSpatial = IndicForm()\n\nIndicatorSpatial=interpolate(IndicatorSpatial,C)\n296\n\nclass IndicFormData(Expression):\n298 def eval_cell( self , value, x, ufc_cell):\n\nvalue[0] = np.sqrt(DataGeralForm[ufc_cell.index])\n300 IndicatorDataGeral = IndicFormData()\n\n\n\nB.3. C\u00f3digo completo 195\n\nIndicatorDataGeral=interpolate(IndicatorDataGeral,C)\n302 class IndicFormInteriorData(Expression):\n\ndef eval_cell( self , value, x, ufc_cell):\n304 #for cell in ufc_cell.index:\n\nvalue[0] = np.sqrt(DataInteriorForm[ufc_cell.index])\n306 IndicatorDataInterior = IndicFormInteriorData()\n\nIndicatorDataInterior=interpolate(IndicatorDataInterior,C)\n308 print \u2019saving indicatorSpatialInside \u2019\n\nclass IndicForm1(Expression):\n310 def eval_cell( self , value, x, ufc_cell):\n\nvalue[0] = np.sqrt(indicator1[ufc_cell.index]+DataInteriorForm[ufc_cell.index])\n312 IndicatorForm1 = IndicForm1()\n\nIndicatorForm1=interpolate(IndicatorForm1,C)\n314\n\nclass IndicForm2(Expression):\n316 def eval_cell( self , value, x, ufc_cell):\n\nvalue[0] = np.sqrt(indicator2[ufc_cell.index]+DataJumpForm[ufc_cell.index])\n318 IndicatorForm2 = IndicForm2()\n\nIndicatorForm2=interpolate(IndicatorForm2,C)\n320 class IndicForm3(Expression):\n\ndef eval_cell( self , value, x, ufc_cell):\n322 value[0] = np.sqrt(indicator3[ufc_cell.index]+DataBoundaryForm[ufc_cell.index])\n\nIndicatorForm3 = IndicForm3()\n324 IndicatorForm3=interpolate(IndicatorForm3,C)\n\nclass IndicFormTime(Expression):\n326 def eval_cell( self , value, x, ufc_cell):\n\nvalue[0] = np.sqrt(time_indicator[ufc_cell.index]+formLarge[ufc_cell.index])\n328 IndicatorForm4 = IndicFormTime()\n\nIndicatorForm4=interpolate(IndicatorForm4,C)\n330 contador+=1\n\n#?????????????????\n332 print \u2019contador\u2019,contador\n\nc1.assign(c)\n334 print \u2019the maximum and minimum values\u2019,max(c.vector().array()), min(c1.vector().array())\n\nif contador%10==0:\n336 plot(c1,mesh=mesh,interactive=False,title=\u2019time %s\u2019%contador)\n\nt+= dt\n338 print\u2019time\u2019, t\n\nprint\u2019saving solution transport and auxiliary\u2019\n340 np.save(\u2019c1\u2019 ,c1.vector())\n\nnp.save(\u2019 ctil \u2019 , ctil .vector())\n342\n\n\n\tFolha de rosto\n\tDedicat\u00f3ria\n\tAgradecimentos\n\tResumo\n\tAbstract\n\tLista de ilustra\u00e7\u00f5es\n\tLista de tabelas\n\tSum\u00e1rio\n\tSum\u00e1rio\n\tIntrodu\u00e7\u00e3o\n\tM\u00e9todo de elementos finitos\n\tEstimativas residuais\n\tAdaptatividade dos dados do problema do transporte\n\tM\u00e9todos multigrid\n\tComputa\u00e7\u00e3o Cient\u00edfica\n\tConsidera\u00e7\u00f5es do Cap\u00edtulo\n\n\tObjetivos\n\tObjetivo principal\n\n\tRevis\u00e3o Bibliogr\u00e1fica\n\tConceitos importantes\n\tM\u00e9todo Multigrid Geom\u00e9trico\n\tOs esquemas multigrid V-ciclo e F-ciclo\n\n\tM\u00e9todo Multigrid Alg\u00e9brico\n\tM\u00e9todo Multigrid Alg\u00e9brico baseado em agrega\u00e7\u00e3o \n\tAMG baseado em agrega\u00e7\u00e3o suavizada\n\n\tM\u00e9todo Multigrid Alg\u00e9brico Adaptativo\n\n\tMetodologia\n\tA equa\u00e7\u00e3o do transporte de solutos em meio poroso\n\tM\u00e9todo de Elementos Finitos e Estimativas Residuais\n\tCondi\u00e7\u00f5es adicionais para o estimador residual\n\tFormula\u00e7\u00e3o Variacional do Problema parab\u00f3lico\n\tSolu\u00e7\u00e3o Anal\u00edtica para Campo Uniforme\n\tSolu\u00e7\u00e3o anal\u00edtica para campo com depend\u00eancia espacial\n\n\tEstimativas Residuais\n\tClassifica\u00e7\u00e3o dos Regimes de Advec\u00e7\u00e3o\n\tContribui\u00e7\u00f5es residuais\n\tEstimativas Residuais a posteriori\n\tEstimativas Residuais Robustas\n\tEstimativas Residuais Gerais\n\tDiscuss\u00e3o Adicional sobre as Estimativas Residuais\n\t Parti\u00e7\u00e3o do Estimador Residual\n\n\tContribui\u00e7\u00f5es Residuais de cada elemento da malha\n\n\tAdaptatividade\n\tLimita\u00e7\u00e3o do Erro I\n\tAdaptatividade da Condi\u00e7\u00e3o Inicial\n\tAdaptatividade da fun\u00e7\u00e3o de fonte\n\n\tProje\u00e7\u00e3o L2 e c\u00e1lculo das constantes  e \n\tProje\u00e7\u00e3o L2\n\tC\u00e1lculo das constante  e \n\t atrav\u00e9s do c\u00e1lculo de autovalores\n\tC\u00e1lculo da Constante \n\n\n\tAMG com Reutiliza\u00e7\u00e3o de estruturas\n\tSA com Reutiliza\u00e7\u00e3o-SAReu()\n\tSA com Reutiliza\u00e7\u00e3o e autom\u00e1tico\n\tM\u00e9todo Iterativo Pr\u00e9-condicionado por SA-Reu\n\tM\u00e9todo iterativo Pr\u00e9-condicionado por SA-ReuAuto\n\tCompara\u00e7\u00e3o de resultados\n\tTempo Computacional\n\n\tNotas sobre os desenvolvimentos\n\n\tResultados\n\tM\u00e9todo de elementos finitos e Estimador Residual\n\tExemplo 01\n\tTransporte Conservativo em Campo Uniforme:=0\n\tTransporte Reativo: =0\n\n\tExemplo 02\n\tProje\u00e7\u00e3o L2\n\n\tMalhas adequadas \u00e0 representa\u00e7\u00e3o dos dados\n\tExemplo 03: Malha adequada \u00e0 Condi\u00e7\u00e3o Inicial\n\tDiscuss\u00e3o sobre as estimativas residuais\n\n\tExemplo 04: Malha adequada \u00e0 representa\u00e7\u00e3o da fun\u00e7\u00e3o de fonte\n\n\tM\u00e9todos Multigrid Acelerados\n\tBICGSTAB Pr\u00e9-Condicionado SA\n\tMalha Estruturada\n\tMalha n\u00e3o estruturada\n\n\tMultigrid Alg\u00e9brico SA e GMRES Pr\u00e9-Condicionado por SA \n\tMalha Estruturada\n\tMalha n\u00e3o estruturada: GMRES Pr\u00e9-Condicionado por SA\n\n\tMalha n\u00e3o estruturada em dom\u00ednio n\u00e3o retangular\n\tReutiliza\u00e7\u00e3o para malha adaptada aos dados em regime de grande adve\u00e7\u00e3o\n\tMalha n\u00e3o estruturada adaptada aos dados do transporte\n\n\tA reutiliza\u00e7\u00e3o para o trasporte 3D\n\n\n\tConclus\u00e3o\n\tSugest\u00f5es para Trabalhos Futuros\n\n\tRefer\u00eancias\n\tC\u00f3digo Python\n\tC\u00f3digos para o Estimador Residual\n\tC\u00f3digo para a proje\u00e7\u00e3o L2\n\tC\u00f3digo para campo gradiente cont\u00ednuo\n\tC\u00f3digo para transformar os dados\n\tC\u00f3digo para componentes do erro residual\n\tC\u00f3digo para o fator de pondera\u00e7\u00e3o S\n\tC\u00f3digo para as contribui\u00e7\u00f5es residuais\n\tC\u00f3digo para os indicadores residuais\n\tC\u00f3digo para as estimativas residuais espacial e temporal\n\n\tO regime de grande advec\u00e7\u00e3o\n\tC\u00f3digo para as formas bilinear e linear do problema auxiliar\n\tC\u00f3digo para as contribui\u00e7\u00f5es residuais do problema auxiliar\n\tC\u00f3digo para obter as estimativas residuais do problema auxiliar\n\n\tC\u00f3digos para as estimativas dos dados\n\tC\u00f3digo das fun\u00e7\u00f5es auxiliares para estimativas dos dados\n\tC\u00f3digo para as componentes residuais dos dados\n\tC\u00f3digo para as contribui\u00e7\u00f5es residuais dos dados\n\tC\u00f3digo para os indicadores residuais dos dados\n\tC\u00f3digo para as estimativas residuais dos dados\n\n\tC\u00f3digos para as estimativas associadas ao termo de fonte\n\tC\u00f3digo para os indicadores associados ao termo de fonte\n\n\tC\u00f3digo para as estimativas residuais das fronteiras\n\tC\u00f3digo adicional para as estimativas\n\tC\u00f3digo para adaptatividade da condi\u00e7\u00e3o inicial\n\tC\u00f3digo para estimativa do erro da condi\u00e7\u00e3o inicial\n\tC\u00f3digo para refinamento adaptativo da condi\u00e7\u00e3o inicial\n\tC\u00f3digo modificado para refinamento adaptativo da condi\u00e7\u00e3o inicial\n\tC\u00f3digo para refinamento adaptativo da fun\u00e7\u00e3o de fonte\n\n\tC\u00f3digos adicionais\n\tAvalia\u00e7\u00e3o do erro real\n\n\tReutiliza\u00e7\u00e3o das estruturas multigrid\n\tNota Final\n\n\tExemplos completos\n\tFEM e solu\u00e7\u00e3o anal\u00edtica\n\tCompara\u00e7\u00e3o das solu\u00e7\u00f5es num\u00e9rica e anal\u00edtica, gr\u00e1ficos\n\n\tEstrat\u00e9gia adaptativa\n\tC\u00f3digo completo"}]}}}