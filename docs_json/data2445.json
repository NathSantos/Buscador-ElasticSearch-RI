{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.06427"}, {"@name": "filename", "#text": "10970_Ramos_RafaelGuimaraes_M.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNICAMP\nRafael Guimar\u00e3es Ramos\nAmbiente Virtual de Simula\u00e7\u00e3o e Visualiza\u00e7\u00e3o do Comportamento \"de Risers\nCampinas\n2013\nUNICAMP\nUniversidade Estadual de Campinas\nFaculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o\nRafael Guimar\u00e3es Ramos\nAmbiente Virtual de Simula\u00e7ao e Visualiza\u00e7ao do Comportamento de Risers\nDisserta\u00e7\u00e3o de mestrado apresentada ao Programa de P\u00f3s-Gradua\u00e7\u00e3o em Engenharia El\u00e9trica da Faculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o da Universidade Estadual de Campinas como parte dos requisitos exigidos para a obten\u00e7\u00e3o do t\u00edtulo de Mestre em Engenharia El\u00e9trica. Area de concen-trac\u00e3o: Engenharia de Computac\u00e3o.\nOrientador: Prof. Dr. Jos\u00e9 Mario De Martino\nEste exemplar corresponde \u00e0 vers\u00e3o final da disserta\u00e7\u00e3o defendida pelo aluno Rafael Guimar\u00e3es Ramos, e orientada pelo Prof. Dr. Jose Mario De Martino\nCampinas\n2013\nRamos, Rafael Guimar\u00e3es, 1987-\nR147a\tAmbiente virtual de simula\u00e7\u00e3o e visualiza\u00e7\u00e3o do comportamento de risers /\nRafael Guimar\u00e3es Ramos. - Campinas, SP : [s.n.], 2013.\nOrientador: Jos\u00e9 Mario De Martino.\nDisserta\u00e7\u00e3o (mestrado) - Universidade Estadual de Campinas, Faculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o.\n1.\tAmbiente virtual. 2. Simula\u00e7\u00e3o computacional. 3. Estruturas mar\u00edtimas -Hidrodin\u00e2mica. 4. Visualiza\u00e7\u00e3o. I. De Martino, Jos\u00e9 Mario,1958-, II. Universidade Estadual de Campinas. Faculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o. III. T\u00edtulo.\nInforma\u00e7\u00f5es para Biblioteca Digital\nT\u00edtulo em ingl\u00eas: Virtual environment for simulation and visualization of riser behavior\nPalavras-chave em ingl\u00eas:\nVirtual environment\nComputer simulation\nMarine structures - Hydrodynamics\nVisualization\n\u00c1rea de concentra\u00e7\u00e3o: Engenharia de Computa\u00e7\u00e3o\nTitula\u00e7\u00e3o: Mestre em Engenharia El\u00e9trica\nBanca examinadora:\nJos\u00e9 Mario De Martino [Orientador]\nRenato Pavanello\nL\u00e9o Pini Magalh\u00e3es\nData de defesa: 05-06-2013\nPrograma de P\u00f3s-Gradua\u00e7\u00e3o: Engenharia El\u00e9trica\nCOMISS\u00c3O JULGADORA - TESE DE MESTRADO\nCandidato: Rafael Guimar\u00e3es Ramos\nData da Defesa: 5 de junho de 2013\nTitulo da Tese: \"Ambiente Virtual de Simula\u00e7\u00e3o e Visualiza\u00e7\u00e3o do Comportamento de Risers\"\nDedico este trabalho \u00e0 minha\nFAM\u00cdLIA E AOS MEUS AMIGOS.\nAgradecimentos\nAgrade\u00e7o,\nao Prof. Jos\u00e9 Mario De Martino pela orienta\u00e7ao e incentivo,\nao Prof. Celso Morooka e seus orientados Denis Shiguemoto, Maur\u00e9cio Suzuki e Raphael Tsu-kada, por todas as explicac\u00f5es sobre risers e pelo material de apoio,\nao Rodrigo Mologni, colega de sala, que em diversos momentos me ajudou no uso e instala\u00e7\u00f5o das ferramentas utilizadas,\naos voluntarios da avaliac\u00f5o de usabilidade, pela disponibilidade e paci\u00eancia em participar do teste,\nao CNPq pelo apoio financeiro concedido durante o per\u00e9odo de mestrado,\na FEEC/UNICAMP a otima estrutura que oferece aos estudantes e pesquisadores,\na todos os colegas de laborat\u00e9rio pelas diversas dicas e \u00e9tima conviv\u00eancia e companheirismo.\nId\u00e9ia, do grego antigo idea, por sua vez derivado de idein, ver.\nOnline Etymology Dictionary (adaptado)\nResumo\nEste trabalho apresenta um ambiente de visualiza\u00e7\u00e3o interativo em tempo-real para a simula\u00e7ao do comportamento de risers r\u00edgidos verticais. O riser \u00e9 um duto cil\u00edndrico essencial na extra\u00e7\u00e3o de oleo em \u00e9guas profundas e ultra-profundas, uma tarefa desafiadora que imp\u00e3e diversas cargas sobre a estrutura. Ondas, correntes e movimentos da plataforma s\u00e3o algumas dessas fontes de tens\u00e3o, que podem levar a danos por fadiga ou mesmo rupturas. Simulac\u00e3es computacionais sao uma ferramenta de grande valia para prevenir e diagnosticar tais problemas, mas em geral apresentam a desvantagem de produzir um grande volume de dados num\u00edericos de dif\u00edcil interpreta\u00e7ao. T\u00e9cnicas de visualiza\u00e7\u00e3o cient\u00edfica podem ser utilizadas para representar os dados de uma maneira mais intuitiva e realista. Entretanto, os sistemas identificados na literatura apresentam limita\u00e7\u00f5es quanto \u00e0 intera\u00e7\u00e3o em tempo-real. A visualizac\u00e3o \u00e9 realizada como um playback, ap\u00e9s a simula\u00e7\u00e3o ter sido completada, e sempre que os par\u00e2metros de simulac\u00e3o sao alterados o usu\u00e1rio deve esperar um tempo consider\u00e1vel enquanto os resultados sao recalculados. Neste trabalho, o ambiente desenvolvido permite a visualiza\u00e7c\u00e3ao do comportamento do riser com intera\u00e7c\u00e3ao em tempo-real, em que o novo comportamento do riser \u00ede obtido imediatamente apo\u00eds os para\u00e2metros de simula\u00e7ca\u00e3o serem alterados pelo usu\u00edario.\nPalavras-chave: Ambiente Virtual. Simula\u00e7\u00e3o Computacional. Estruturas Mar\u00edtimas - Hidrodin\u00e2mica. Visualiza\u00e7\u00e3o.\nAbstract\nThis work presents a visualization environment with real-time interaction for the simulation of vertical rigid risers. The riser is a cylindrical pipe essential for the extraction of oil in deep and ultra-deep waters, a challenging task that imposes several loads over the structure. Waves, currents and platform movements are some of these stress sources, that may lead to fatigue damage or even rupture. Computer simulations are a tool of great value for preventing and diagnosing such problems, but have usually the drawback of producing a large volume of numerical data difficult of being interpreted by the user. Scientific visualization techniques can be used to represent data in a more intuitive and realistic way. However, projects identified in the literature present limitations regarding real-time interaction. The visualization is performed as a playback, after the simulation has been completed, and whenever simulation parameters are changed, the user has to wait a considerable time for the results to be recalculated. In this work, the developed simulation environment allows visualization of riser behavior with real-time interaction, where the new riser behavior is obtained immediately after simulation parameters are changed by the user.\nKey-words: Virtual Environment. Computer Simulation. Marine Structures - Hydrodynamics. Visualization.\nLista de Figuras\n1.1\tPlataforma com Risers R\u00edgidos Verticais.......................................... 3\n1.2\tM\u00f3dulos do ambiente desenvolvido................................................. 5\n2.1\tRepresenta\u00e7\u00e3o por plots. Fonte: Simantiras e Willis 2001, p\u00f3gina 13, Figura 11.\t9\n2.2\tRepresenta\u00e7\u00e3o de vortices por imagem 2D. Adaptado de: Al-Jamal e Dalton 2004,\np\u00f3gina 88, Figura 13............................................................. 9\n2.3\tRepresenta\u00e7\u00e3o de vortices e curvatura do riser por gr\u00f3ficos 3D. Adaptado de:\nChen e Chen 2010, p\u00f3gina 5, Figura 5............................................ 10\n2.4\tOutra representa\u00e7\u00e3o de v\u00f3rtices e curvatura do riser por gr\u00e1ficos 3D. Adaptado\nde: Zhu et al. 2011, p\u00f3gina 791, Figura 3....................................... 10\n2.5\tIsosuper\u00f3ficies de press\u00e3o via gr\u00e1ficos 3D. Adaptado de: Holmes et al. 2006,\npa\u00f3gina 7, Figura 11.\t........................................................ 11\n2.6\tCores em gr\u00f3ficos 3D para representar intensidade de esfor\u00e7o sobre o tubo. Adap-\ntado de: Alexander 2007, pagina 81, Figura 27................................... 12\n2.7\tSoftware de simula\u00e7\u00e3o de riser com visualizac\u00e3o dos resultados em ambiente\ngr\u00f3fico 3D. Fonte: Petrobras et al. 2005, p\u00f3gina 39, Figura 3.2................. 12\n2.8\tAmbiente colaborativo com visualiza\u00e7c\u00e3ao animada 3D do riser. Fonte: Santos et\nal. 2011, p\u00f3gina 6, Figura 6.................................................... 13\n2.9\tOutro ambiente com visualiza\u00e7c\u00e3ao animada 3D do riser. Segundo a fonte, trata-se\nde um esbo\u00e7o da interface. Fonte: Bernardes 2004, p\u00f3gina 119, Figura 20......... 14\n2.10\tAmbiente de visualiza\u00e7\u00e3o 3D para ajuste de par\u00e1metros de simula\u00e7\u00e3o. Fonte:\nMorooka et. al. 2008, p\u00f3gina 7, Figura 7........................................ 14\n2.11\tSoftware comercial Orcaflex desenvolvido por Orcina Ltd.. Fonte: P\u00f3gina Web\nde Orcina Ltd................................................................... 15\n3.1\tRepresentac\u00e3o esquem\u00f3tica do metodo de elementos finitos........................ 18\n3.2\tFluxo do Solver RiserProd....................................................... 20\n3.3\tFluxo do Solver aprimorado para interatividade em tempo-real.................... 20\n3.4\tPipeline de Visualiza\u00e7\u00e3o. Fonte: Mologni dos Santos 2011, pagina 18, Figura 2.3.\t22\n3.5\tRepresenta\u00e7\u00e3o por esquematica da interface de visualizacao, dividida em Cena\n3D e Painel de Controle......................................................... 23\n3.6\tJanelas do VRP, interface para o RiserProd existente previamente a este trabalho. 24\n4.1\tJanela principal do ambiente de visualiza\u00e7\u00e3o..................................... 28\n4.2\tIniciando uma simula\u00e7\u00e3o: escolhe-se uma configura\u00e7\u00e3o de riser e o nUmero de\nelementos do modelo e a simula\u00e7\u00e3o est\u00e1 pronta para ser visualizada............... 28\n4.3\tE possivel explorar o ambiente virtual aplicando rotac\u00e3o, translac\u00e3o e escala. . .\t29\n4.4\tPara maior realismo e imersao, \u00e1 poss\u00e1vel optar por uma visualiza\u00e7\u00e3o com o mar\nextendendo-se at\u00e1 o horizonte, bem como utilizar visao stereo tridimensional. . .\t30\n4.5\tApontando com o mouse sobre o riser e pressionando o bot\u00e3o p, o elemento cor-\nrespondente \u00e1 marcado no ambiente de visualiza\u00e7\u00e3o (esfera vermelha) e real\u00e7ado\nna tabela da aba Results......................................................... 31\n4.6\tDiagrama com as classes principais que comp\u00e3e o Solver. Para n\u00e3o sobrecarregar\no diagrama, foram omitidas as subclasses de MyMatrix e Force..................... 31\n4.7\tDiagrama representando o fluxo de chamadas (indicado por setas) que ocorre ao\nexecutar a An\u00e1lise Est\u00e1tica para uma configura\u00e7\u00e3o TTR. O polimorfismo e a sobrecarga de m\u00e1etodos assegura que a an\u00e1alise \u00e1e executada para a configura\u00e7c\u00e3ao de riser espec\u00edfica................................................................. 33\n4.8\tDiagrama de classes do Modulo de Visualiza\u00e7ao. Como Scene cont\u00e1m muitas\nclasses, apenas algumas est\u00e3ao representadas, para na\u00e3o sobrecarregar o diagrama. 34\n4.9\tMedidas de tempo de execu\u00e7ao do Solver, tomadas em quatro etapas distintas. .\t35\n4.10\tTempo de espera a cada mudan\u00e7a de par\u00e2metros, computado como a soma das\ntr\u00eas primeiras etapas. A An\u00e1lise de Vibra\u00e7\u00e3es Livres e a Montagem de Matrizes s\u00e3ao as que mais contribuem na medida ........................................... 35\n4.11\tTaxa de quadros m\u00e1xima suportada em fun\u00e7\u00e3o do numero de elementos, tomado\ncomo o inverso das medidas da Analise Din\u00e2mica................................... 36\n4.12\tNota m\u00e9dia e desvio padr\u00e2o de cada pergunta...................................... 38\n4.13\tNotas m\u00e1dia e desvio padr\u00e2o de cada pergunta apos normaliza\u00e7\u00e3o................... 39\nLista de Tabelas\n4.1\tNotas dadas pelos volunt\u00e1rios para cada pergunta..................................\n37\nLista de Acr\u00f4nimos e Nota\u00e7\u00e3o\nKX , KY matriz de rigidez inline e transversal, respectivamente\nDX , DY matriz de amortecimento inline e transversal, respectivamente\nMX , MY matriz de massa inline e transversal, respectivamente\nFX , Fy\tvetor das for\u00e7as sobre o riser nos planos inline e transversal, respectivamente\nX, Y vetor dos deslocamentos inline e transversal, respectivamente\nX,Y\tvetor das velocidades inline e transversal, respectivamente\nX,Y\tvetor das acelera\u00e7\u00f5es inline e transversal, respectivamente\nVRP Visual Riser Prod, interface para o Solver RiserProd\no / \u2022\nSumario\n1\tIntrodu\u00e7\u00e3o\t1\n1.1\tMotiva\u00e7\u00e3o................................................................... 1\n1.2\tObjetivo.................................................................... 4\n1.3\tContribui\u00e7\u00f5es............................................................... 4\n1.4\tVis\u00e3o Geral................................................................. 5\n2\tRevis\u00e3o Bibliogr\u00e1fica\t7\n2.1\tSimula\u00e7\u00e3o de Riser.......................................................... 7\n2.2\tVisualiza\u00e7ao Cient\u00edfica..................................................... 8\n2.3\tVisualiza\u00e7ao da Simula\u00e7\u00e3o de Riser.......................................... 8\n2.4\tConsidera\u00e7\u00e3es Finais....................................................... 15\n3\tMetodologia\t17\n3.1\tSimula\u00e7\u00e3o do Riser......................................................... 17\n3.1.1\tModelo teorico ..................................................... 17\n3.1.2\tRiserProd: Uma implementa\u00e7ao j\u00e1 existente do simulador ............. 19\n3.1.3\tRequisitos para um simulador interativo em tempo-real............... 19\n3.1.4\tImplementando o simulador interativo em tempo-real a partir do RiserProd 20\n3.1.5\tAvaliando o desempenho do novo Solver............................... 21\n3.2\tVisualiza\u00e7ca\u00e3o da Simulac\u00e7\u00e3ao ............................................. 21\n3.2.1\tFundamentos ........................................................ 21\n3.2.2\tT\u00e1cnicas para Visualizar a Simula\u00e7\u00e3o................................ 22\n3.2.3\tInterface de Usu\u00e1rio ............................................... 23\n3.2.4\tImplementando o M\u00e1dulo de Visualizac\u00e3o ............................. 23\n3.2.5\tVRP: um M\u00e1dulo de Visualiza\u00e7\u00e3o j\u00e1 existente para o RiserProd........ 24\n3.2.6\tAvaliando a Visualizac\u00e3o............................................ 24\n3.3\tIntegrando Solver e Modulo de Visualiza\u00e7ao................................. 25\n3.4\tConsiderac\u00e3es Finais....................................................... 25\n4\tResultados\t27\n4.1\tProt\u00e1tipo Desenvolvido..................................................... 27\n4.2\tVis\u00e3o Geral do C\u00f3digo................................................. 30\n4.3\tAvalia\u00e7\u00e3o do Desempenho\tdo\tSolver................................... 34\n4.4\tAvalia\u00e7\u00e3o da Usabilidade do\tAmbiente de Visualiza\u00e7\u00e3o e Simula\u00e7\u00e3o...... 36\n4.5\tConsidera\u00e7\u00e3es Finais.................................................. 39\n5\tConclus\u00f5es\t40\n5.1\tLimita\u00e7\u00e3es............................................................ 41\n5.2\tTrabalhos Futuros..................................................... 42\nBibliografia\t44\nA\tQuestion\u00e1rio\tpara\tAvalia\u00e7\u00f5o\tde\tUsabilidade\t47\nB\tDocumentacao\tdo\tC\u00f3digo\tdo\tSistema\tDesenvolvido\t59\nCap\u00edtulo J__\nIntrodu\u00e7\u00e3o\n1.1\tMotiva\u00e7\u00e3o\nA explora\u00e7\u00e3o de petr\u00f3leo em \u00e1guas profundas e ultraprofundas \u00e1 uma tarefa desafiadora, sobretudo devido as condi\u00e7\u00f5es ambientais adversas a serem enfrentadas. A grande importancia deste recurso mineral no cen\u00e1rio global, entretanto, tem impulsionado essa atividade, especialmente no caso do Brasil, que possuiu aproximadamente 94% de suas reservas provadas de petr\u00e1leo em campos mar\u00edtimos (Ag\u00eancia Nacional do Petr\u00e1leo 2012).\nO processo de obtencao de petr\u00e1leo em alto mar pode ser dividido em tr\u00eas etapas1: Pros-pec\u00e7\u00e3o, Perfura\u00e7\u00e3o e Produ\u00e7\u00e3o. Na etapa de Prospeccao, \u00e1 feita a localiza\u00e7\u00e3o das reservas de petr\u00f3leo, utilizando diferentes t\u00e9cnicas, que incluem o uso de ondas de choque, medidas das varia\u00e7\u00e3es nos campos gravitacional e magn\u00e1tico, ou ainda farejadores de hidrocarbonetos. Na etapa seguinte, \u00e1e feita a perfurac\u00e7a\u00e3o do po\u00e7co utilizando-se uma broca. Por fim, na u\u00e1ltima etapa, Produc\u00e7\u00e3ao, o \u00e1oleo \u00e1e extraindo do po\u00e7co e levado at\u00e1e a plataforma.\nUma estrutura essencial nas etapas de perfura\u00e7\u00e3o e producao \u00e1 o riser (Figura 1.1), um tubo delgado cilindrico que atende a multiplas fun\u00e7oes, entre elas a de transportar o petr\u00e1leo desde o poco at\u00e1 a unidade de produ\u00e7\u00e3o. De um modo geral, existem dois tipos de riser, os r\u00edgidos e os flex\u00edveis, e a opera\u00e7\u00e3o a ser realizada determina o tipo de riser utilizado.\nExistem diversos tipos de configura\u00e7\u00e3es de riser. O Top Tension Riser (TTR) \u00e1 um tubo r\u00e1gido e vertical que tem as extremidades presas na cabe\u00e7ca do poc\u00e7o e na unidade de produ\u00e7c\u00e3ao, e deve estar sempre tracionado no topo para garantir sua estabilidade. Tamb\u00e1m r\u00edgidas e verticais s\u00e3o as configurac\u00e3es Collector, em que o tubo fica preso apenas no topo, e Tower, que possui apenas a base presa. A configura\u00e7\u00e3o Collector \u00e1 utilizada para coletar a \u00e1gua do mar, j\u00e1 o tipo Tower \u00e1 utilizado em uma configura\u00e7\u00e3o h\u00edbrida conhecida como HRT (Hybrid Riser Tower), no qual al\u00e1em do duto de a\u00e7co ha\u00e1 uma b\u00e1oia no topo do riser (topo que fica submerso) e tubos flex\u00e1veis chamados jumpers partindo do topo para a embarca\u00e7ao. Ha ainda o Steel Catenary Riser (SCR), que \u00e1 r\u00edgido e possui a forma de caten\u00e1ria, e o Subsea Pipeline, em que o duto\n1Aqui a divis\u00e3o em tr\u00eas etapas e os termos empregados foram escolhidos de forma a facilitar a compreens\u00e3o das explica\u00e7\u00e3es posteriores e evitar ambiguidades. Diferentes nomenclaturas podem ser encontradas em outras fontes. Em algumas, \u00e9 feita apenas a divisao entre Explora\u00e7\u00e3o e Produ\u00e7\u00e3o, onde por Explora\u00e7\u00e3o entende-se a prospecc\u00e3o e estudo das reservas e Produ\u00e7\u00e3o tanto a perfura\u00e7\u00e3o quanto a extra\u00e7\u00e3o do petr\u00f3leo. Utiliza-se ainda em algumas fontes o termo Explota\u00e7ca\u00e3o, designando a extra\u00e7c\u00e3ao do recurso natural, contrapondo-se a Explora\u00e7c\u00e3ao.\n\u00e9 r\u00edgido e disposto na horizontal. Todos estes s\u00e3o risers r\u00edgidos e nao podem sofrer grandes deflex\u00e3es. Ademais, TTR, Collector e Tower compoem o subgrupo dos risers r\u00edgidos verticais, j\u00e9 que al\u00e9m de serem tubos r\u00edgidos s\u00e3o utilizados na posi\u00e7ao vertical. Por fim, al\u00e9m dos risers r\u00edgidos, existe tamb\u00e9m a classe dos risers flex\u00edveis, que toleram deflex\u00e3es maiores.\nO escolha pelo uso de cada configura\u00e7\u00e3o de riser varia conforme a situac\u00e3o. Durante a etapa de perfurac\u00e3o, apenas risers r\u00edgidos podem ser utilizados. O riser tem nesta etapa a func\u00e3o de guiar a broca desde a plataforma at\u00ede a cabe\u00e7ca do po\u00e7co, bem como transportar o fluido de perfura\u00e7ca\u00e3o. O fluido de perfura\u00e7ca\u00e3o \u00ede uma mistura de \u00edagua, argila e outros compostos qu\u00edmicos que tem por fun\u00e7\u00e3o lubrificar e resfriar a broca, dar sustenta\u00e7\u00e3o ao riser e impedir que o petr\u00f3leo escape do poc\u00e7o assim que o reservato\u00edrio \u00ede atingido. O riser utilizado na perfurac\u00e7\u00e3ao possui di\u00e1metro variando entre 0,50m e 1,00m. Caso a embarcacao provoque um deslocamento horizontal (offset) acima do limite seguro para o riser, este pode ser desconectado hidraulicamente da cabe\u00e7ca do po\u00e7co.\nNa etapa de produc\u00e3o, podem ser utilizados tanto risers r\u00edgidos como flex\u00edveis. O riser nesta etapa tem a fun\u00e7ca\u00e3o de transportar os hidrocarbonetos da cabe\u00e7ca do po\u00e7co at\u00ede a embarca\u00e7ca\u00e3o. O riser r\u00edgido utilizado na produ\u00e7ao possui diametro da ordem de 0,25m, n\u00e3o pode sofrer grandes deflex\u00e3es e deve estar sempre tracionado. J\u00e9 o riser flex\u00edvel pode sofrer maiores deflex\u00e3es e durante o uso permanece suspenso na forma de uma catena\u00edria. O di\u00e1ametro do riser flex\u00edvel varia de 0,064m a 0,41m.\nDurante seu tempo de uso, o riser \u00ede submetido a carregamentos que provocam a movi-menta\u00e7ca\u00e3o da estrutura, podendo levar a fraturas ou mesmo rupturas por fadiga do material. Correnteza, ondas, movimenta\u00e7c\u00e3ao da plataforma, bem como a diferen\u00e7ca de press\u00e3ao entre a a\u00edgua do mar e o fluido interno, sa\u00e3o alguns dos principais fatores que influenciam o comportamento do riser. Outro fator importante \u00e9 a VIV (Vortex Induced Vibration), a vibrac\u00e3o induzida pelo desprendimento de v\u00edortices ao longo da parede do riser.\nA necessidade de prevenir e diagnosticar danos no riser, somado aos altos custos tanto da produ\u00e7c\u00e3ao do equipamento quanto de sua manuten\u00e7c\u00e3ao, tornam importante o uso de modelos computacionais que simulam o comportamento desta estrutura. Com o uso de um simulador, pontos de falha no riser podem ser detectados com anteced\u00e1encia, antes mesmo do riser ser fabricado. Outro caso de uso importante para um simulador \u00ede o de auxiliar no diagn\u00edostico do problema de um riser em operac\u00e7\u00e3ao. O simulador pode indicar mais precisamente o tipo e a localizac\u00e3o do problema, atenuando eventuais custos de manuten\u00e7\u00e3o. Entretanto, o grande volume de dados num\u00edericos produzido pela simula\u00e7ca\u00e3o torna dificil a interpreta\u00e7c\u00e3ao dos resultados pelo usu\u00e9rio. Uma forma de mais tornar mais intuitiva a compreens\u00e3o destes dados \u00e9 utilizar a visualiza\u00e7ao cient\u00edfica.\nA visualiza\u00e7ao cient\u00edfica \u00e9 um ramo espec\u00edfico da visualiza\u00e7\u00e3o de dados, \u00e0s vezes chamada apenas de visualizacao, e que consiste em representar dados na forma de imagens2. Prova-\n2 A rela\u00e7\u00e3o entre o que \u00e9 visualizacao e o que \u00e9 computa\u00e7\u00e3o gr\u00e1fica pode variar conforme a defini\u00e7\u00e3o de cada um dos campos, podendo haver sobreposi\u00e7\u00f5es entre as \u00e9reas. Uma distin\u00e7ao \u00e9 de que a visualizac\u00e3o trata de como representar dados, muitas vezes abstratos e sem correspondente visual obvio, numa forma visual, enquanto a computac\u00e3o gr\u00e1fica lida com as t\u00e9cnicas para se representar tais elementos gr\u00e1ficos num computador. Desta forma, a visualiza\u00e7ao em principio possuiria certa independ\u00eancia da computac\u00e3o, ao contrario da computa\u00e7\u00e3o gr\u00e1fica. Entretanto, a preponderancia do computador como ferramenta para produ\u00e7ao e manipulac\u00e3o de dados, bem como a import\u00eaancia da interatividade na visualiza\u00e7c\u00e3ao tornam forte a liga\u00e7c\u00e3ao entre visualiza\u00e7c\u00e3ao e computa\u00e7c\u00e3ao\nFigura 1.1: Plataforma com Risers R\u00edgidos Verticais.\nvelmente o exemplo mais comum de visualiza\u00e7\u00e3o seja o dos mapas meteorol\u00e1gicos, mostrados na previs\u00e3o do tempo dos jornais. A visualiza\u00e7ao tamb\u00e1m pode ser utilizada para representar modelos de engenharia, na representa\u00e7\u00e3o de \u00e1tomos e mol\u00e1culas, de dados financeiros ou estat\u00edsticas sociais, ou ainda de redes como a Internet ou uma rede el\u00e9trica. A fun\u00e7\u00e3o da visualiza\u00e7\u00e3o \u00e9 a de auxiliar o usu\u00e1rio a interpretar um conjunto de dados. T\u00e9cnicas de visualizac\u00e3o, se bem aplicadas, tem a capacidade de sintetizar grande quantidade de informacao, provendo ao usu\u00e1rio uma leitura r\u00e1pida e intuitiva da informa\u00e7\u00e3o. Esta fluidez \u00e1 ainda mais importante dentro de um contexto interativo, em que o ciclo de leitura e produ\u00e7c\u00e3ao de dados repete-se diversas vezes.\nA visualizac\u00e7a\u00e3o cient\u00e1fica trata especificamente de dados das \u00e1areas cient\u00e1ficas e de engenharia. Estes dados, sendo geralmente grandezas f\u00e1sicas, apresentam certas caracter\u00e1sticas comuns, como a de serem dados escalares, vetoriais ou tensoriais, e de estarem distribu\u00e1dos no tempo e no espaco. Sendo assim, um conjunto de t\u00e1cnicas de visualizac\u00e3o cient\u00edfica pode ser utilizado para representar uma grande variedade de aplica\u00e7\u00e3es. Dentre as t\u00e1cnicas mais comuns est\u00e1 o uso de cores para representar escalares, setas para vetores, linhas de fluxos para campos e elipso\u00e1ides para tensores.\nUtilizando a visualiza\u00e7\u00e3o cient\u00edfica, os dados de simula\u00e7\u00e3o podem ser representados numa forma mais intuitiva para o usu\u00e1rio. As multiplas grandezas do riser, como tensao, for\u00e7a e deslocamento de cada elemento, todas elas variantes no tempo, podem ser sintetizadas numa anima\u00e7\u00e3o provendo uma visao global do comportamento do riser. Tamb\u00e1m os par\u00e2metros de simula\u00e7c\u00e3ao, que determinam fatores como correnteza ou profundidade, podem ser representados visualmente na mesma cena. Um outro fator que enriquece ainda mais a compreens\u00e3o do fen\u00f4meno \u00e1e interatividade com a simula\u00e7c\u00e3ao, na qual \u00e1e permitido que o usu\u00e1ario altere as condi\u00e7c\u00e3oes\ngr\u00e1fica.\nambientais e do riser, explorando diferentes casos de estudo3. Entretanto, como ser\u00f3 visto no Cap\u00f3tulo 2, a interatividade na visualiza\u00e7ao de simula\u00e7\u00e3es de riser \u00f3 uma funcionalidade desejada e que apresenta limita\u00e7\u00e3es nos trabalhos indentificados na literatura. Nas aplica\u00e7\u00f5es mais completas em termos de visualiza\u00e7\u00e3o, a mudan\u00e7a de par\u00e2metros \u00f3 poss\u00edvel apenas interrompendo-se visualizac\u00e7a\u00e3o, que s\u00f3o pode ser retomada ap\u00f3os os resultados da simulac\u00e7a\u00e3o terem sido recomputados para o intervalo de estudo, o que acarreta um tempo de espera. Este tempo de espera, por sua vez, prejudica a fluidez da interac\u00e3o e da explora\u00e7\u00e3o.\n1.2\tObjetivo\nO objetivo deste trabalho \u00f3 especificar, desenvolver e avaliar um ambiente virtual interativo em tempo-real para simula\u00e7\u00e3o e visualiza\u00e7\u00e3o do comportamento de risers r\u00edgidos verticais. Neste sistema, o usua\u00f3rio podera\u00f3 visualizar em gr\u00f3aficos animados os dados da simulac\u00e7\u00e3ao, tanto par\u00e2metros quanto resultados, e poder\u00e1 alterar os par\u00e2metros, que correspondem \u00e0s condic\u00e3es ambientais e do riser, sem que haja interrupc\u00e7a\u00e3o da visualizac\u00e7\u00e3ao ou tempo de resposta longo a ponto de prejudicar a fluidez da intera\u00e7ca\u00e3o. E\u00f3 importante ressaltar que, neste trabalho, o tempo-real refere-se \u00e0 fluidez na interatividade, e nao que o tempo de visualiza\u00e7ao da simula\u00e7\u00e3o corresponda necessariamente ao do fen\u00e2omeno real.\n1.3\tContribui\u00e7\u00f5es\nS\u00e3o contribui\u00e7\u00f5es deste trabalho:\n\u2022\tO desenvolvimento de um m\u00f3dulo de simula\u00e7\u00e3o num\u00f3rica (Solver) apto ao uso interativo em tempo-real, a partir de uma adapta\u00e7\u00e3o do simulador RiserProd, que n\u00e3o atende os requisitos para tal tipo de intera\u00e7c\u00e3ao.\n\u2022\tO desenvolvimento de um m\u00f3odulo de visualiza\u00e7c\u00e3ao, respons\u00f3avel por representar visualmente os resultados e par\u00e2ametros do mo\u00f3dulo de simulac\u00e7a\u00e3o e de gerenciar a intera\u00e7c\u00e3ao com o usua\u00f3rio, atrav\u00f3es de uma interface que permite o ajuste dos para\u00e2metros da simula\u00e7c\u00e3ao.\n\u2022\tA integrac\u00e7\u00e3ao dos referidos m\u00f3odulos em um u\u00f3nico ambiente de simula\u00e7c\u00e3ao e visualiza\u00e7c\u00e3ao de risers.\n\u2022\tUma avalia\u00e7c\u00e3ao do desempenho do ambiente, revelando quais os limitantes para o uso interativo em tempo-real do ambiente desenvolvido.\n\u2022\tUma avalia\u00e7ca\u00e3o da usabilidade do ambiente.\n3Segundo Telea (Telea 2008), o processo de intera\u00e7\u00e3o e interpreta\u00e7\u00e3o dos dados representados visualmente pode se dar de duas formas distintas. Uma maneira \u00e9 aquela em que o usu\u00e1rio possui apriori quest\u00e3es que deseja elucidar e a visualiza\u00e7\u00e3o deve auxiliar neste processo. Encontrar os pontos de maximo e m\u00e9nimo num conjunto de dados ou verificar se os dados est\u00e3o bem distribu\u00e9dos no espa\u00e7o sao alguns exemplos dessas perguntas. Uma outra abordagem \u00e9 quando o usu\u00e1rio n\u00e3o procura por nada espec\u00e9fico, ou mesmo nao sabe o que procurar, e a visualiza\u00e7ao releva caracter\u00e9sticas interessantes e inesperadas sobre o conjunto de dados. Vale lembrar que as duas abordagens podem ocorrer simultaneamente, complementando-se.\nnovos resultados\nFigura 1.2: M\u00f3dulos do ambiente desenvolvido.\n1.4\tVis\u00e3o Geral\nSendo um ambiente de simula\u00e7\u00e3o e visualiza\u00e7\u00e3o, o sistema foi dividido em dois m\u00f3dulos, um de simula\u00e7ao (chamado de Solver) e um de visualiza\u00e7ao, que interagem compondo uma unica aplica\u00e7\u00e3o (Figura 1.2).\nNo modulo de simula\u00e7\u00e3o, o comportamento do riser \u00f3 calculado segundo as equa\u00e7\u00e3es da hidrodin\u00e2mica de estruturas offshore, utilizando a abordagem num\u00f3rica do M\u00f3todo de Elementos Finitos. Condi\u00e7\u00e3es ambientais e do riser correspondem a par\u00e2metros no modelo matem\u00f3tico, e o comportamento \u00f3 expresso em vari\u00f3veis como deslocamento, velocidade e for\u00e7a computadas pelo modelo.\nJ\u00f3 no modulo de visualiza\u00e7\u00e3o, os dados da simula\u00e7ao, tanto par\u00e2metros quanto resultados, s\u00e3o processados pelo pipeline de visualiza\u00e7ao e apresentados na forma gr\u00f3fica para o usuario. Tamb\u00e9m \u00f3 este modulo o responsavel por gerenciar a intera\u00e7\u00e3o com o usu\u00f3rio, devendo prover interfaces apropriadas para mudanca de par\u00e2metros. O m\u00f3dulo de visualiza\u00e7\u00e3o encapsula o de simula\u00e7\u00e3o, e o usu\u00f3rio n\u00e3o possui acesso ao segundo senao atrav\u00f3s do primeiro. Do ponto de vista do usu\u00f3rio, pode-se dizer que a visualiza\u00e7\u00e3o e a simula\u00e7\u00e3o.\nEste trabalho, al\u00f3m de desenvolver os dois m\u00f3dulos e integra-los numa unica aplica\u00e7\u00e3o, avaliou o ambiente desenvolvido segundo sua performance e sua usabilidade. Quanto a performance, a avalia\u00e7ao visa identificar quais os fatores limitantes para um uso interativo em tempo-real. J\u00f3 quanto a usabilidade, o objetivo \u00f3 verificar se o ambiente \u00f3 de fato \u00fatil para engenheiros trabalhando com risers.\nNos proximos cap\u00edtulos, estes e outros aspectos do trabalho s\u00e3o detalhados e discutidos.\nEm primeiro lugar, no Cap\u00f3tulo 2, Revis\u00e3o Bibliogr\u00f3fica, sao expostos resumidamente os trabalhos relacionados a este que, ou serviram de base para este trabalho, ou trataram do mesmo tema. Assim, s\u00e3o discutidos trabalhos da \u00f3rea de simula\u00e7ao de riser e tamb\u00f3m de visualiza\u00e7\u00e3o. Por fim, constata-se que, nos trabalhos identificados na literatura, a visualiza\u00e7\u00e3o da simula\u00e7ca\u00e3o com interatividade em tempo-real \u00f3e ainda limitada.\nNo Cap\u00f3tulo 3, Metodologia, \u00f3 descrito como o projeto foi realizado, desde sua modelagem matem\u00f3atica, requisitos do sistema, at\u00f3e ferramentas escolhidas. Tamb\u00f3em s\u00e3ao descritos os m\u00f3etodos escolhidos para se avaliar o Solver e a interface desenvolvidos.\nNo Cap\u00f3tulo 4, os resultados obtidos seguindo-se a metodologia do cap\u00f3tulo 3 s\u00e3o descritos. A aplica\u00e7ca\u00e3o desenvolvida \u00f3e apresentada, bem como uma vis\u00e3ao geral do c\u00f3odigo e os resultados das avaliac\u00e7\u00e3oes da interface e do Solver.\nPor fim, no Cap\u00e9tulo 5, s\u00f5o mostradas as conclus\u00f5es obtidas com esse trabalho, suas limita-c\u00e7\u00f5oes e os poss\u00e9veis trabalhos futuros.\nCap\u00edtulo ______________\nRevis\u00e3oBibliogr\u00e1fica\n2.1\tSimula\u00e7\u00e3o de Riser\nA hidrodin\u00e2mica de estruturas offshore possui uma literatura consolidada. O livro de S. K. Chakrabarti, Hydrodynamics of Offshore Structures (Chakrabarti 1987) descreve a din\u00e2mica de diversos tipos de estrutura, inclusive risers, segundo os v\u00e1rios modelos de onda existentes. Para o fenomeno de gera\u00e7\u00e3o de v\u00e1rtices, Kubota (Kubota 2003) indica que diversos modelos t\u00e2m sido propostos, utilizando as equa\u00e7\u00e3es de Navier-Stokes com depend\u00e2ncia no tempo. Tais modelos variam significativamente quanto \u00e0s considerac\u00e3es b\u00e1sicas e aproximac\u00e3es empregadas, de forma que cada modelo deve apenas ser utilizado quando tais pressupostos estiverem de acordo com a realidade.\nDevido as dificuldades em se obter solu\u00e7\u00f5es anal\u00edticas para sistemas de equa\u00e7\u00e3es diferenciais parciais como as da hidrodinamica de estruturas offshore, frequentemente modelos num\u00e1ricos s\u00e3o utilizados para o estabelecimento de solu\u00e7\u00e3es aproximadas com um grau desejado de precis\u00e3o. Uma t\u00e9cnica importante \u00e1 o M\u00e9todo de Elementos Finitos, muito utilizada para analise estrutural. Com a t\u00e1cnica, uma estrutura continua \u00e1 discretizada em um conjunto de elementos finitos interligados, sendo o sistema de equac\u00e7\u00e3oes diferenciais parciais convertido para um sistema de equa\u00e7c\u00e3oes alg\u00e1ebricas ou de equa\u00e7c\u00e3oes diferenciais ordina\u00e1rias, que pode ser solucionado por m\u00e1e-todos de \u00e1lgebra linear ou m\u00e1todos iterativos. Os livros Finite Element Procedures (Bathe 1996) e The Finite Element Method in Engineering Science (Zienkiewicz 1971) tratam do m\u00e1todo em detalhe.\nO trabalho de Ferrari e Bearman (Ferrari &amp; Bearman 1999a) estabelece um modelo matem\u00e1tico de simula\u00e7\u00e3o, sendo este o utilizado no presente trabalho. No modelo, os coeficientes hidrodin\u00e2amicos utilizados nas equa\u00e7co\u00e3es da estrutura devem ser passados como par\u00e2ametros e o M\u00e9todo de Elementos Finitos \u00e1 utilizado para obter a soluc\u00e3o aproximada. Diversos trabalhos (Morooka, Coelho, Ribeiro, Ferrari &amp; Franciss 2005, Morooka, Coelho, Kubota, Ferrari &amp; Ribeiro 2004, Morooka &amp; Tsukada 2011, Kubota 2003) seguiram-se ao de Ferrari e Bearman, aperfei\u00e7coando o modelo proposto.\n2.2\tVisualizac\u00e3o Cient\u00edfica\nAs principais t\u00e9cnicas para visualiza\u00e7\u00e3o de dados s\u00e3o tratadas no livro de Alexandru Telea, Data Visualization (Telea 2008). No livro, tanto a visualiza\u00e7ao cient\u00e9fica quanto a visualiza\u00e7ao de outras aplica\u00e7\u00e3es sao explorados, numa abordagem desvinculada de linguagens espec\u00e9ficas. Engel et al., no livro Real Time Volume-Graphics (Engel, Hadwiger, Kniss, Rezk-Salama &amp; Weiskopf 2006), tratam das t\u00e9cnicas para visualiza\u00e7ao de dados volum\u00e9tricos, importante para certas aplicac\u00e7\u00e3oes dentro da visualiza\u00e7c\u00e3ao cientifica, como visualiza\u00e7ca\u00e3o de tomografia computadorizada. J\u00e1 o livro The Visualization Toolkit, de Schroeder et al. (Schroeder, Martin &amp; Lorensen 2006), trata da biblioteca VTK para visualiza\u00e7\u00e3o, cobrindo os diversos componentes oferecidos pelo VTK para a constru\u00e7\u00e3o de aplicac\u00e3es de visualiza\u00e7\u00e3o.\n2.3\tVisualizac\u00e3o da Simula\u00e7\u00e3o de Riser\nDentre os trabalhos de simula\u00e7\u00e3o de riser s\u00e3o relativamente poucos aqueles cujo foco principal \u00e9e a visualiza\u00e7c\u00e3ao dos dados de simulac\u00e7\u00e3ao, a maioria tratando dos modelos matem\u00e9aticos de simula\u00e7c\u00e3ao. Mesmo para estes trabalhos, entretanto, existe a necessidade de representar os dados de simula\u00e7c\u00e3ao. A seguir s\u00e3ao descritas as abordagens utilizadas em diversos trabalhos, comec\u00e7ando pelas mais simples, de trabalhos cujo foco n\u00e3ao era a visualiza\u00e7c\u00e3ao, e terminando com aquelas mais completas, dos trabalhos que tinham por objeto de interesse a visualiza\u00e7c\u00e3ao em si.\nDentre as abordagens mais simples para visualizac\u00e7a\u00e3o, h\u00e9a o uso de plots 2D, em que as grandezas do riser sao representadas como curvas. O trabalho de Simantiras e Willis (Simantiras &amp; Willis 2001) \u00e9 um exemplo (Figura 2.1). Outro trabalho que utiliza plots para representar resultados de simula\u00e7\u00e3o \u00e9 o Visual RiserProd (ou apenas VRP), um modulo de visualizac\u00e3o desenvolvido para o simulador RiserProd (por ser uma interface j\u00e1 existente para o simulador utilizado neste trabalho, ela \u00e9 discutida com mais detalhes na Se\u00e7ao 3.2.5 do Cap\u00edtulo 3). Ainda restrito a gr\u00e9aficos bidimensionais, existem trabalhos que utilizam gra\u00e9ficos 2D para representar os v\u00e9rtices formados (Figura 2.2). Cada imagem representa o vortice em uma dada profundidade. Os trabalhos de Al-Jamal e Dalton (Al-Jamal &amp; Dalton 2004), Chaplin et al. (Chaplin, Bearman, Cheng, Fontaine, Graham, Herfjord, Huarte, Isherwood, Lambrakos, Larsen, Meneghini, Moe, Pattenden, Triantafyllou &amp; Willden 2005), Chain e Varyani (Chai &amp; Varyani 2002) e Zhu et al. (Zhu, Lin, Jia &amp; Yang 2010) utilizam esse tipo de representa\u00e7\u00e3o, bem como plots 2D para representar outros resultados.\nOutros trabalhos, por sua vez, fazem uso de gra\u00e9ficos tridimensionais para visualizar os resultados. O trabalho de Chen e Chen (Chen &amp; Chen 2010) \u00e9 um exemplo, onde o riser \u00e9 mostrado como um tubo curvado pela correnteza, exibindo os v\u00e9ortices em certos pontos do riser (Figura 2.3). Os v\u00e9rtices s\u00e3o representados por linhas coloridas representando os fluxos. Uma abordagem muito semelhante \u00e9e empregada por Ferrari (Flatschart, Meneghini &amp; Jr. 2004). Zhu et al. (Zhu, Ou, Lin &amp; Hu 2011), por outro lado, utilizam uma representa\u00e7\u00e3o ligeiramente diferente. O riser \u00e9e apresentado apenas como um cilindro, sem curvatura, por\u00e9em os vo\u00e9rtices s\u00e3o em alguns casos apresentados de forma cont\u00e9nua ao longo do riser e em outros apenas para certas profundidades (Figura 2.4). Entretanto, tais visualizacoes sao apenas figuras est\u00e9ticas, n\u00e3ao animac\u00e7\u00e3oes.\nFigura 2.1: Representa\u00e7\u00e3o por plots. Fonte: Simantiras e Willis 2001, p\u00e1gina 13, Figura 11.\nFigura 2.2: Representa\u00e7\u00e3o de vortices por imagem 2D. Adaptado de: Al-Jamal e Dalton 2004, p\u00e1gina 88, Figura 13.\nFigura 2.3: Representa\u00e7\u00e3o de v\u00f3rtices e curvatura do riser por gr\u00e1ficos 3D. Adaptado de: Chen e Chen 2010, pagina 5, Figura 5.\nFigura 2.4: Outra representa\u00e7\u00e3o de vortices e curvatura do riser por gr\u00e1ficos 3D. Adaptado de: Zhu et al. 2011, p\u00e1gina 791, Figura 3.\nFigura 2.5: Isosuper\u00f3ficies de press\u00e3o via gr\u00f3ficos 3D. Adaptado de: Holmes et al. 2006, pagina 7, Figura 11.\nGr\u00f3ficos 3D s\u00e3o utilizados tamb\u00e9m para outros fins al\u00e9m da representacao de v\u00f3rtices ou da curvatura do riser. Holmes et al. (Holmes, Jr. &amp; Constantinides 2006) utilizam gr\u00e1ficos tridimensionais para representar as isosuperf\u00f3cies de pressao sobre o riser (Figura 2.5), enquanto Alexander (Alexander 2003) os emprega para exibir a varia\u00e7\u00e3o de esfor\u00e7os sobre o riser (Figura 2.6). No primeiro caso, diferentes isosuperf\u00f3cies s\u00e3o exibidas em diferentes cores, enquanto no segundo as cores sa\u00e3o utilizadas para representar a intensidade do esforc\u00e7o em cada regi\u00e3ao do riser.\nTodos os trabalhos apontados acima tinham por foco a simulac\u00e3o e n\u00e3o a visualizac\u00e3o dos resultados. Os trabalhos citados a seguir apresentam um foco maior na visualizac\u00e3o da simulac\u00e3o, e combinam algumas das caracter\u00f3sticas acima descritas com outras originais.\nO sistema Anflex(Petrobras 2005), desenvolvido em conjunto pela Petrobras e pela PUC-Rio, \u00f3e um software para simula\u00e7ca\u00e3o de risers em que os resultados s\u00e3ao visualizados em um ambiente gr\u00f3fico 3D (Figura 2.7). Estes resultados podem ser visualizados apenas ap\u00f3s toda a simula\u00e7ao ter sido computada. Na visualiza\u00e7ca\u00e3o, o riser, a embarca\u00e7ca\u00e3o, a superf\u00f3cie e o fundo do mar sa\u00e3o representados de forma animada, e os esfor\u00e7cos ao longo do riser s\u00e3ao indicados atrav\u00f3es de cores.\nSantos et al. desenvolveram o Environ (Santos, Soares, Carvalho &amp; Raposo 2011), uma plataforma colaborativa para engenharia de petr\u00f3oleo que inclui visualiza\u00e7c\u00e3ao de riser (Figura 2.8). O riser \u00f3e representado em gr\u00f3aficos 3D e as for\u00e7cas e outras grandezas f\u00f3sicas sa\u00e3o exibidas\nFigura 2.6: Cores em gr\u00e1ficos 3D para representar intensidade de esforgo sobre o tubo. Adaptado de: Alexander 2007, p\u00e1gina 81, Figura 27.\nFigura 2.7: Software de simulac\u00e3o de riser com visualiza\u00e7\u00e3o dos resultados em ambiente gr\u00e1fico 3D. Fonte: Petrobras et al. 2005, p\u00e1gina 39, Figura 3.2.\nFigura 2.8: Ambiente colaborativo com visualiza\u00e7\u00e3o animada 3D do riser. Fonte: Santos et al. 2011, p\u00e1gina 6, Figura 6.\ncom cores e setas. Estes dados sao gerados previamente numa etapa de simula\u00e7\u00e3o, e s\u00e1 ent\u00e3o \u00e1e realizada a anima\u00e7ca\u00e3o. Sendo um ambiente colaborativo, diversos usua\u00e1rios podem utilizar a plataforma simultaneamente, trocar informac\u00e3es e inserir anota\u00e7\u00e3es na cena 3D.\nO trabalho de Bernardes (Bernardes 2004) tamb\u00e1m oferece um ambiente de visualiza\u00e7\u00e3o de riser, em que o riser e as grandezas f\u00edsicas s\u00e3o representadas em gr\u00e1ficos 3D (Figura 2.9). O valores s\u00e3ao computados tamb\u00e1em numa etapa anterior. O trabalho tem como diferencial a visualiza\u00e7c\u00e3ao de mu\u00e1ltiplos riser, com detecc\u00e7\u00e3ao de colis\u00e3ao entre eles.\nJa o trabalho de Morooka et al. (Morooka, Brandt, Matt &amp; Franciss 2008) realiza visualiza\u00e7\u00e3o 3D n\u00e3o dos resultados mas dos par\u00e2metros de simula\u00e7ao. Corrente, ondas e profundidade podem ser visualizados e alterados na interface (Figura 2.10). A simula\u00e7\u00e3o \u00e1 feita em seguida e os resultados exibidos em plots 2D . No trabalho, h\u00e1 um foco no realismo da cena 3D, especialmente na representa\u00e7c\u00e3ao da \u00e1agua.\nPor fim, o software OrcaFlex (Orcina 2013b) \u00e1 uma ferramenta comercial desenvolvida pela empresa Orcina que oferece simula\u00e7ao e visualiza\u00e7\u00e3o do comportamento de diversas estruturas offshore, entre elas, o riser. O usuario pode, atrav\u00e9s de um ambiente virtual (Figura 2.11), montar o cen\u00e1ario a ser simulado, adicionando e posicionando as diversas estruturas. Ap\u00e1os isto, pode-se iniciar a simula\u00e7\u00e3o num\u00e1rica. A medida que a simulac\u00e3o \u00e1 executada, a representa\u00e7\u00e3o visual da simula\u00e7\u00e3o \u00e1 atualizada com os novos dados. Concluda a simulac\u00e3o, pode-se reproduzir a anima\u00e7\u00e3o da simulac\u00e3o numa taxa de quadros mais fluida, bem como inspecionar os resultados atrav\u00e1s de gr\u00e1ficos (plots) e tabelas.\nAssim, como uma caracter\u00e1stica comum para estes trabalhos, tem-se que nenhum deles oferece simula\u00e7c\u00e3ao e visualiza\u00e7c\u00e3ao interativas em tempo-real. A visualiza\u00e7c\u00e3ao \u00e1e sempre uma etapa separada da simula\u00e7\u00e3o, o que prejudica a fluidez na interatividade, ja que a cada mudan\u00e7a de par\u00e2metros o usu\u00e1rio deve esperar pela simula\u00e7\u00e3o ser conclu\u00edda. Uma ressalva deve ser feita para o software OrcaFlex, j\u00e1a que os resultados s\u00e3ao visualizados na medida que s\u00e3ao produzidos. Entretanto, as instruc\u00e3es de uso contidas no manual do Orcaflex(Orcina 2013a) indicam que a\nFigura 2.9: Outro ambiente com visualiza\u00e7\u00e3o animada 3D do riser. Segundo a fonte, trata-se de um esbo\u00e7o da interface. Fonte: Bernardes 2004, p\u00e1gina 119, Figura 20.\nFigura 2.10: Ambiente de visualiza\u00e7\u00e3o 3D para ajuste de par\u00e2metros de simula\u00e7\u00e3o. Fonte:\nMorooka et. al. 2008, p\u00e1gina 7, Figura 7\nFigura 2.11: Software comercial Orcaflex desenvolvido por Orcina Ltd.. Fonte: Pagina Web de Orcina Ltd.\nforma de uso padr\u00e3o do programa \u00e9 esperar toda a simula\u00e7\u00e3o ser executada para ent\u00e3o visualizar os resultados.\n2.4\tConsidera\u00e7\u00f5es Finais\nComo visto neste cap\u00e9tulo, a simula\u00e7\u00e3o de risers e a visualiza\u00e7ao cient\u00e9fica sao areas de estudo j\u00e9 bastante desenvolvidas. Entretanto, a visualiza\u00e7ao de risers, combina\u00e7\u00e3o dos dois campos, apresenta ainda certas limitac\u00e3es. Dentre os trabalhos de simula\u00e7\u00e3o de riser s\u00e3o poucos aqueles que tem por foco a visualizac\u00e3o dos dados, sendo o foco da maioria dos trabalhos os modelos matem\u00e9ticos de simulac\u00e3o. Alguns dos trabalhos utilizam plots 2D para representar as grandezas f\u00e9sicas variantes e imagens bidimensionais para exibir os vortices para uma dada profundidade. Outros utilizam gr\u00e9ficos 3D, uns para visualizar os v\u00e9rtices ao longo do tubo e sua curvatura, outros para mostrar com cores as variac\u00e3es de tens\u00e3o sobre o riser. Os trabalhos mais completos de visualiza\u00e7c\u00e3ao combinam as diversas abordagens numa anima\u00e7c\u00e3ao tridimensional.\nPor\u00e9m, mesmo estes trabalhos mais completos possuem limitac\u00e3es. Um quesito importante na visualiza\u00e7\u00e3o \u00e9 a interatividade, que permite ao usu\u00e9rio explorar o conjunto de dados, auxiliando na busca por respostas espec\u00e9ficas ou ainda revelando aspectos inesperados sobre o fen\u00f4meno estudado. Os atuais trabalhos sobre visualiza\u00e7ao de riser possuem a limita\u00e7\u00e3o de que simula\u00e7c\u00e3ao e visualiza\u00e7ca\u00e3o ocorrem em etapas separadas, de forma que o usua\u00e9rio deve esperar pela simula\u00e7\u00e3o ser conclu\u00e9da toda vez que mudar os par\u00f4metros, o que compromete a fluidez na intera\u00e7c\u00e3ao. Uma poss\u00e9vel exce\u00e7c\u00e3ao \u00e9e o software comercial OrcaFlex, em que a visualizac\u00e7\u00e3ao \u00e9e atualizada a medida que os resultados da simula\u00e7ao s\u00e3o produzidos; mesmo neste caso, entretanto, o\nuso padra\u00e3o da ferramenta consiste em esperar a simula\u00e7ca\u00e3o ser conclu\u00edida para s\u00edo enta\u00e3o realizar a visualiza\u00e7\u00e3o. Assim, como dito no Cap\u00edtulo 1, este trabalho visa superar esta limita\u00e7\u00e3o, fazendo com que simula\u00e7c\u00e3ao e visualiza\u00e7c\u00e3ao ocorram concomitantemente e permitindo uma intera\u00e7ca\u00e3o que na\u00e3o interrompa este processo.\nCap\u00edtulo _____\nMetodologia\nNeste cap\u00e1tulo s\u00e3o descritos os diversos aspectos envolvidos no projeto e na implementa\u00e7\u00e3o do ambiente de visualiza\u00e7c\u00e3ao e simula\u00e7ca\u00e3o. Tais aspectos incluem os fundamentos matem\u00e1aticos da simulacao, o projeto da interface de usuario, a estrutura do software implementado e as ferramentas utilizadas. Sendo um ambiente de visualizac\u00e3o e simula\u00e7\u00e3o, o sistema desenvolvido esta estruturado em dois grandes m\u00e1dulos: o Solver e o M\u00e1dulo de Visualizac\u00e3o. O Solver \u00e9 o m\u00e1dulo que produz o comportamento do riser a partir de um modelo matem\u00e1tico x. Al\u00e1m de implementar o modelo matem\u00e1atico de simulac\u00e7\u00e3ao, o Solver deve permitir a alterac\u00e7a\u00e3o de par\u00e2a-metros de simulac\u00e7\u00e3ao em tempo-real, mantendo sempre a produ\u00e7c\u00e3ao dos resultados de simula\u00e7c\u00e3ao numa taxa compat\u00e1vel ao passo da anima\u00e7ca\u00e3o. O M\u00e1odulo de Visualiza\u00e7c\u00e3ao, por sua vez, encapsula o Solver e prov\u00e2e a visualiza\u00e7c\u00e3ao animada dos dados da simula\u00e7c\u00e3ao, tanto par\u00e2ametros quanto resultados, e gerencia a intera\u00e7c\u00e3ao com o usu\u00e1ario, provendo funcionalidades que facilitem a mudanc\u00e7a de para\u00e2metros, inspe\u00e7ca\u00e3o de resultados e demais ajustes de configura\u00e7c\u00e3ao.\n3.1\tSimula\u00e7\u00e3o do Riser\n3.1.1\tModelo te\u00f3rico\nO modelo teo\u00e1rico para simular o comportamento do riser tem por base as equa\u00e7co\u00e3es da hidrodin\u00e2mica de estruturas offshore e utiliza o m\u00e1todo de elementos finitos para obter uma solu\u00e7\u00e3o num\u00e1rica. Proposto inicialmente por Ferrari e Bearman (Ferrari &amp; Bearman 1999a), o modelo foi aprimorado por estes e outros autores em trabalhos subsequentes (Morooka et al. 2005, Mo-rooka et al. 2004, Morooka &amp; Tsukada 2011, Kubota 2003). Maiores detalhes sobre o modelo podem ser encontrados nestes trabalhos e aqui \u00e1e apresentada uma explica\u00e7ca\u00e3o simplificada.\nO riser \u00e1e considerado como um conjunto de elementos de viga interligados entre si, sob o efeito de uma carga produzida pela combina\u00e7c\u00e3ao da correnteza, onda, press\u00e3oes hidrost\u00e1aticas, movimento da plataforma e peso do pr\u00e1prio riser, conforme mostrado na Figura 3.1. Esse conjunto de for\u00e7cas no espa\u00e7co tridimensional \u00e1e decomposto em dois planos ortogonais: o plano\nxPara evitar qualquer confus\u00e3o, Solver e simulador num\u00e9rico s\u00e3o utilizados como sin\u00f4nimos neste trabalho, referindo-se exclusivamente a parte do programa que soluciona numericamente as equac\u00e3es do modelo matematico do riser.\nFigura 3.1: Representa\u00e7ao esquematica do m\u00e1todo de elementos finitos.\ninline, paralelo a correnteza, e o plano transversal, ortogonal tanto ' correnteza quanto ao fundo do mar. Esta decomposic\u00e3o simplifica o equacionamento do problema, que \u00ed representado matricialmente da seguinte forma:\nMx XX + Dx X + Kx X = Fx\n(3.1)\nMy Y + Dy Y + Ky Y = Fy\t(3.2)\nEsta e uma formulac\u00e3o similar ' utilizada para a din\u00e2mica de um corpo r\u00edgido, mas adaptada, com o uso de matrizes, para multiplos elementos. Na Equa\u00e7ao 3.1, para o caso inline, no lugar de uma massa, um coeficiente de amortecimento e um coeficiente de elasticidade, tem-se as matrizes de massa, de amortecimento e de rigidez, respectivamente Mx, Dx e Kx. X, X, XX s\u00e3o por sua vez os vetores de posi\u00e7ao, velocidade e acelera\u00e7\u00e3o de cada elemento, e Fx o vetor com as cargas sobre cada elemento. O problema transversal \u00ede representado de maneira semelhante (Equac\u00e3o 3.2), mas \u00ed importante notar que nao so as cargas, como tamb\u00edm as matrizes My, Dy e Ky podem ser diferentes do plano inline.\nPartindo-se destas equac\u00e7\u00e3oes, s\u00e3ao realizadas tr\u00e2es an\u00edalises para se determinar o comportamento do riser : analise est\u00edatica, de vibra\u00e7co\u00e3es livres e din\u00e2amica. A an\u00edalise esta\u00edtica considera a estrutura em equil\u00edbrio e visa encontrar o deslocamento e o \u00e2ngulo de inclina\u00e7\u00e3o dos elementos. Como velocidade e acelerac\u00e3o sao nulos, apenas a matriz de rigidez K \u00ed utilizada2. Como K depende,\n2Para simplificar a nota\u00e7\u00e3o, quando nao importar se o caso \u00e9 inline ou transversal, as matrizes M, D, K e o\nem parte, da posi\u00e7\u00e3o dos elementos (a chamada componente geom\u00e9trica da matriz de rigidez), \u00e9 utilizado o m\u00e9todo de Newton-Raphson, um m\u00e9todo iterativo que converge para a solu\u00e7ao do problema, refinando a cada itera\u00e7ao, a matriz K e a posi\u00e7ao. A an\u00e1lise de vibrac\u00f5es livres visa encontrar a frequ\u00eancia natural de vibracao do riser, isto \u00e9, aquela na qual o riser pode entrar em ressonancia. A analise considera apenas as matrizes de massa e rigidez, utilizando os valores calculados na an\u00e9alise anterior para a matriz de rigidez K. A frequ\u00eaencia natural \u00e9e determinada encontrando-se os autovalores do sistema. Por fim, a an\u00e1lise din\u00eamica computa o comportamento do riser para cada intervalo de tempo. Todas as matrizes M, D e K sao consideradas, sendo D computada usando M, K e as frequ\u00eancias naturais. A an\u00e1lise \u00e9 feita pela integra\u00e7ao no tempo usando o m\u00e9todo de Newmark-Beta (Newmark 1959)\n3.1.2\tRiserProd: Uma implementa\u00e7\u00e3o j\u00e1 existente do simulador\nUma implementac\u00f5o j\u00e9 existente deste modelo de simula\u00e7\u00f5o \u00e9 o programa batizado de RiserProd. Implementado na linguagem Fortran 90, com o m\u00e9dulo LAPACK para \u00e9lgebra linear em Fortran 77, o RiserProd n\u00f5o foi feito pensando-se no uso em tempo-real, nem pode ser diretamente utilizado para tal. O RiserProd realiza a simula\u00e7\u00f5o do riser para um intervalo de tempo pr\u00e9e-determinado, produzindo todos os resultados para cada time-step em arquivos, na forma de um log. Os par\u00eametros de simula\u00e7\u00f5o s\u00f5o tamb\u00e9m armazenados num arquivo, que \u00e9 lido pelo programa no in\u00edcio da simula\u00e7\u00f5o. O simulador apenas p\u00e9ra assim que todos os resultados tenham sido produzidos , de forma que, quanto maior o intervalo de estudo estipulado, mais tempo o programa leva para retornar os resultados, o que j\u00e9a \u00e9e um problema para o uso em tempo-real. Al\u00e9em disso, o uso de arquivos \u00e9e outro fator a contribuir para um tempo de execu\u00e7c\u00f5ao maior. Estas limita\u00e7\u00f5es entretanto, em nada impediram que o RiserProd fosse tomado como base para a implementa\u00e7c\u00f5ao de um novo simulador que estivesse apto ao uso em tempo-real.\n3.1.3\tRequisitos para um simulador interativo em tempo-real\nUm simulador interativo em tempo-real deve permitir que os para\u00eametros de simula\u00e7c\u00f5ao sejam alterados a qualquer momento, sem que a simula\u00e7c\u00f5ao seja interrompida e sem um tempo de resposta percept\u00e9vel toda vez que um par\u00eametro for alterado, o que prejudicaria a fluidez na intera\u00e7c\u00f5ao. Al\u00e9em disto, neste tipo de sistema na\u00f5o \u00e9e poss\u00e9vel definir o intervalo de estudo da simula\u00e7ca\u00f5o a priori, ja\u00e9 que a simula\u00e7c\u00f5ao deve prosseguir enquanto o usu\u00e9ario estiver utilizando o ambiente de visualiza\u00e7ao. Um intervalo arbitr\u00e1rio at\u00e9 poderia ser definido, sendo atualizado \u00e0 medida que a simula\u00e7c\u00f5ao \u00e9e executada, mas, ainda assim, quanto maior o intervalo estabelecido, maior o tempo para computar os dados, o que compromete o imperativo de tempo de resposta baixos na mudanc\u00e7a de par\u00eaametros. Assim, um modelo melhor para uma simulac\u00e7\u00f5ao interativa em tempo-real \u00e9e, ao inv\u00e9es de pr\u00e9e-computar os resultados antes de visualiz\u00e9a-los, calcul\u00e9a-los sob demanda, \u00e0 medida que a simula\u00e7\u00f5o for avan\u00e7ando. Para isto, entretanto, \u00e9 necessario garantir que os dados sejam produzidos numa taxa compat\u00e9vel \u00e0 frequ\u00eancia da anima\u00e7\u00f5o, por exemplo, 30 quadros por segundo.\nvetor F ser\u00e3o utilizados, para se referir tanto as do caso inline quanto do transversal. Quando houver diferen\u00e7a entre os casos, esta ser\u00e1 explicitamente indicada.\nFigura 3.2: Fluxo do Solver RiserProd.\nFigura 3.3: Fluxo do Solver aprimorado para interatividade em tempo-real.\n3.1.4\tImplementando o simulador interativo em tempo-real a partir do RiserProd\nUm simulador interativo em tempo-real foi obtido a partir do RiserProd fazendo-se algumas modifica\u00e7\u00f5es, de acordo com os requisitos apresentados na se\u00e7\u00e3o anterior. No RiserProd, uma simula\u00e7\u00e3o \u00e9 um processo indivis\u00edvel, que inicia com a passagem de um arquivo de par\u00e2metros, seguida da realizac\u00e3o das an\u00e9lise estatica, de vibrac\u00e3es livres e din\u00e2mica (para todo o intervalo de estudo), e por fim, escrevendo os resultados em arquivos de sa\u00edda, conforme mostrado na Figura 3.2.\nPara o novo simulador, esse fluxo deve ser reestruturado e o uso de arquivos eliminado, utilizando um buffer para armazenar os resultados e que pode ser compartilhado com a interface de visualizac\u00e3o. Na nova estrutura (Figura 3.3), as an\u00e9lises est\u00e9tica e de vibra\u00e7\u00f5es continuam sendo realizadas sempre e apenas quando um novo conjunto de par\u00e2metros \u00e9 passado. J\u00e9 a ana\u00edlise din\u00e2amica, ao inv\u00edes de ser realizada para todo um intervalo de estudo quando novos par\u00e2ametros s\u00e3ao passados, passa a ser realizada a cada quadro de anima\u00e7c\u00e3ao mas agora para um unico passo da simulacao. A integracao no tempo realizada na an\u00e9lise din\u00e2mica depende de certas condi\u00e7\u00e3es de contorno tais como deslocamento e velocidade dos elementos. Os valores utilizados para tais condic\u00e7\u00e3oes s\u00e3ao aqueles gerados no passo anterior, exceto na primeira vez em que a ana\u00e9lise \u00e9e executada, em que deslocamento e velocidade s\u00e3ao iguais a zero.\nAl\u00e9em destas reestrutura\u00e7c\u00e3oes, a nova implementa\u00e7c\u00e3ao difere do RiserProd por estar codificada em C++. Esta decisao ocorreu pois o Fortran, apesar de ainda popular na area de computa\u00e7\u00e3o\ncient\u00f3fica, n\u00e3ao \u00f3e mais t\u00e3ao utilizado fora deste nicho, podendo haver problemas de compatibilidade dele com recursos mais recentes (como integrac\u00e3o com a interface escrita em Python). Al\u00f3m disso, C++ \u00f3 uma linguagem que oferece orienta\u00e7\u00e3o a objetos, proporcionando um c\u00f3digo mais organizado, e conhecida por ter um alto desempenho em tempo de processamento. Quanto ao m\u00f3dulo LAPACK para algebra linear, este foi substitu\u00f3do por sua vers\u00e3o em C, o CLAPACK.\n3.1.5\tAvaliando o desempenho do novo Solver\nA capacidade do ambiente de simula\u00e7c\u00e3ao e visualiza\u00e7ca\u00e3o suportar intera\u00e7ca\u00e3o em tempo-real \u00f3e limitada pelo Solver, pois o custo computacional deste mo\u00f3dulo \u00f3e proporcional ao nu\u00f3mero do elementos do modelo de simula\u00e7c\u00e3ao. Para o caso do mo\u00f3dulo de visualiza\u00e7c\u00e3ao, na\u00e3o h\u00f3a grande varia\u00e7c\u00e3ao de desempenho. Assim, apenas o desempenho do Solver \u00f3e avaliado de maneira formal.\nO desempenho do Solver \u00f3 avaliado segundo dois m\u00f3todos: profiling pelo Visual Studio e medicao direta do tempo. A medida dos tempos \u00f3 feita utilizando a fun\u00e7\u00e3o clock() da biblioteca time.h e visa determinar o tempo de execuc\u00e3o de cada uma das analises do Solver. Para o caso da an\u00f3alise dina\u00e2mica, ela \u00f3e decomposta em duas etapas medidas separadamente, pois embora a an\u00f3alise dina\u00e2mica seja executada para cada passo da animac\u00e7\u00e3ao, certos c\u00f3alculos de matrizes realizados no come\u00e7co desta ana\u00f3lise precisam ser executados apenas quando novos par\u00e2ametros sa\u00e3o fornecidos. Assim, a medida dos tempos do Solver \u00f3e realizada para quatro etapas: An\u00f3a-lise Est\u00f3tica, An\u00f3lise de Vibrac\u00e3es Livres, Montagem de Matrizes e An\u00f3lise Dinamica (aqui referindo-se a parte que \u00f3 executada a cada passo da animac\u00e3o). Pelo profiler do Visual Studio, \u00f3 poss\u00f3vel descobrir quais os pontos espec\u00edficos do programa que contribuem com maior carga de processamento, enquanto a medida direta retorna quanto tempo durou a execuc\u00e7\u00e3ao de determinado trecho de c\u00f3digo. O Visual Studio oferece duas formas diferentes para realizar o profiling. Na primeira, chamada de CPU Sampling, o estado do programa \u00f3 capturado em diferentes momentos ao longo da execu\u00e7ca\u00e3o e a an\u00f3alise \u00f3e feita com estes dados. O outro m\u00f3etodo de profiling por sua vez realiza a contagem de quantas vezes cada fun\u00e7c\u00e3ao \u00f3e chamada e o quanto de processamento ela realiza (para distinguir fun\u00e7\u00e3es que processam dados realmente de outras que apenas chamam outras func\u00e7\u00e3oes).\n3.2\tVisualiza\u00e7ao da Simula\u00e7\u00e3o\n3.2.1\tFundamentos\nVisualizar os dados de simulac\u00e7\u00e3ao significa transformar informac\u00e7\u00e3ao num\u00f3erica em elementos visuais, como cores e formas. Segundo Telea (Telea 2008), o processo de visualiza\u00e7\u00e3o segue um conjunto bem definido de etapas, denominado de Pipeline de Visualiza\u00e7ao. S\u00e3o quatro as etapas: importa\u00e7\u00e3o, filtragem, mapeamento e renderizac\u00e3o. Na etapa de importa\u00e7\u00e3o, dados brutos s\u00e3o importados de alguma fonte externa e armazenados numa estrutura de dados apropriada \u00e0 visualizac\u00e7\u00e3ao. Na etapa de filtragem, dados desnecessa\u00f3rios s\u00e3ao eliminados, ou ainda novos dados sa\u00e3o calculados e inclu\u00f3dos no conjunto, processo chamado de enriquecimento dos dados. No mapeamento, o conjunto de dados filtrado e enriquecido \u00f3e mapeado para formas visuais bi ou tridimensionais. Por fim, na etapa de renderizac\u00e7\u00e3ao, estas formas visuais s\u00e3ao desenhadas na tela,\ndispositivo de medi\u00e7\u00e3o ou 4-simula\u00e7\u00e3o\nintrospec\u00e7\u00e3o sobre o fen\u00f3meno original\ndados brutos\nFigura 3.4: Pipeline de Visualiza\u00e7\u00e3o. Fonte: Mologni dos Santos 2011, p\u00e1gina 18, Figura 2.3.\ngerando a imagem final. A Figura 3.4 ilustra esse processo.\nNa visualiza\u00e7\u00e3o cient\u00edfica, costuma-se trabalhar com dados constitu\u00eddos de um conjunto de amostras e de suas propriedades geometricas e topol\u00f3gicas. Embora dados muitas vezes estejam dispon\u00edveis em sua forma cont\u00ednua, como uma fun\u00e7\u00e3o, a manipula\u00e7\u00e3o de dados cont\u00ednuos \u00f3 mais dif\u00edcil e lenta do que a de dados discretos. O conjunto de dados \u00f3 efetivamente uma malha, onde cada v\u00edertice \u00ede uma amostra, podendo armazenar mu\u00edltiplos valores escalares, vetoriais e tensoriais. A geometria dos dados estabelece a posi\u00e7ca\u00e3o de cada v\u00edertice, e a topologia, como os v\u00edertices conectam-se entre si.\nO VTK (Schroeder et al. 2006), sigla para The Visualization Toolkit, \u00ed um framework orientado a objetos para programac\u00e3o de aplica\u00e7\u00e3es de Visualiza\u00e7\u00e3o Cient\u00edfica. O VTK oferece classes de objetos que implementam as diversas etapas do pipeline de visualiza\u00e7\u00e3o, sendo eles componentes que devem ser conectados uns aos outros de forma a compor o pipeline. S\u00e3o fornecidas classes apropriadas para armazenar os dados em suas diversas formas intermediarias, bem como funcionalidades necessarias a maioria das aplica\u00e7c\u00e3oes graficas, como cria\u00e7ca\u00e3o de janelas e intera\u00e7\u00e3o com o mouse. O framework \u00e9 implementado em C++, utilizando OpenGL para renderizac\u00e7a\u00e3o de graficos, o que a torna bastante eficiente. Pode tambem ser utilizado em outras linguagens como Tcl/Tk, Python e Java, atraves de bindings com a implementac\u00e3o em C++.\n3.2.2\tT\u00e9cnicas para Visualizar a Simula\u00e7\u00e3o\nUma forma intuitiva de visualizar os dados de simula\u00e7\u00e3o \u00e9 criar uma cena que reproduza a situa\u00e7ao real. Partindo-se deste princ\u00edpio, aqui a simula\u00e7\u00e3o \u00e9 visualizada mostrando o riser em movimento e seu ambiente, isto e, o mar, o leito marinho e a embarca\u00e7ca\u00e3o. Assim, dados como di\u00e2metro do riser, deslocamento e velocidade de cada elemento, profundidade do oceano, ou mesmo o flutuadores dispostos ao longo do riser podem ser representados de maneira natural e intuitiva. Outros dados importantes como correnteza ou pressao do flu\u00eddo interno, embora n\u00e3o sejam normalmente vis\u00edveis na natureza, sao representados atraves de setas ou cores, duas tecnicas ja consagradas na visualiza\u00e7\u00e3o. Para grandezas vetoriais, como for\u00e7as de excita\u00e7ao sobre o riser ou a correnteza, utilizam-se setas, enquanto para grandezas escalares como pressa\u00e3o, densidade ou elasticidade do material do riser, o uso de cores mostrou-se mais adequado. Atra-ves desta abordagem, \u00e9 poss\u00edvel fornecer uma vis\u00e3o geral dos diversos aspectos da simula\u00e7\u00e3o. Detalhes e realismo na representa\u00e7ao podem, em alguns casos, ser sacrificados, buscando-se uma visualiza\u00e7c\u00e3ao mais intuitiva do todo.\nFigura 3.5: Representac\u00e3o por esquematica da interface de visualizac\u00e3o, dividida em Cena 3D e Painel de Controle.\n3.2.3\tInterface de Usu\u00e1rio\nA interface de usuario \u00f3 responsavel por realizar duas func\u00e3es: apresentar a visualizacao e receber comandos do usu\u00f3rio. Partindo desta considerac\u00e3o, a interface est\u00f3 dividida em dois elementos: uma cena 3D e um painel de controle (ver esquema da Figura 3.5). Na cena 3D, \u00f3 exibida a visualiza\u00e7ao da simulac\u00e3o, que pode ser ampliada, transladada e rotacionada pelo usu\u00f3rio. Ja no painel de controle, o principal prop\u00f3sito \u00f3 permitir ao usuario o ajuste dos par\u00e2metros da simula\u00e7\u00e3o, embora tamb\u00f3m outras configurac\u00e3es do aplicativo possam ser alteradas via painel. O grande n\u00f3mero de par\u00e2metros, uns quantitativos outros qualitativos, refor\u00e7ou a escolha pelo painel de controle como interface para ajuste de par\u00e2metros. Uma poss\u00f3vel alternativa, em que a interacao com os par\u00e2metros fosse de alguma maneira realizada na cena 3D (arraste e clique p.e.) poderia sobrecarregar a cena com muita informac\u00e3o, al\u00f3m do fato de que nem todos os par\u00e2ametros possuem representa\u00e7ca\u00e3o visual intuitiva e em algum momento, uma representa\u00e7\u00e3o textual ou num\u00f3rica seria necessaria. Um painel de controle prove uma melhor organiza\u00e7\u00e3o e os widgets s\u00e3o um recurso j\u00f3 bem estabelecido.\n3.2.4\tImplementando o Modulo de Visualiza\u00e7\u00e3o\nPara implementar o Modulo de Visualiza\u00e7\u00e3o, foi escolhida a linguagem Python e os frameworks Qt para janelas e widgets e VTK para visualizac\u00e3o. O VTK foi escolhido por implementar diversas tecnicas de visualiza\u00e7\u00e3o e ser amplamente utilizado pela comunidade de visualiza\u00e7\u00e3o cient\u00edfica. A escolha pelo VTK acabou determinando em parte a escolha das outras ferramentas. O VTK pode ser utilizado com Python e apresentou um bom desempenho na visualizac\u00e3o, alcan\u00e7ando taxas de mais de 30 quadros por segundo na anima\u00e7\u00e3o. Alem disso, Python \u00e9 uma linguagem que acelera em muito o processo de programa\u00e7\u00e3o, especialmente se comparada a C/C++. Por fim, o Qt, um framework para desenvolvimento de interfaces gr\u00e9ficas\nFigura 3.6: Janelas do VRP, interface para o RiserProd existente previamente a este trabalho.\nde usu\u00e1rio bastante difundido, possui integra\u00e7ao tanto com Python quanto com o VTK e e de f\u00e1cil utiliza\u00e7ao, possuindo um ambiente gr\u00e1fico para edi\u00e7\u00e3o dos widgets.\n3.2.5\tVRP: um Modulo de Visualiza\u00e7\u00e3o j\u00e1 existente para o RiserProd\nJa existia previamente a este trabalho um Modulo de Visualiza\u00e7ao para o RiserProd original, o VRP (DutoRisk Manual de Usu\u00e1rio (Interface e Solver) 2009), citado previamente na Sec\u00e3o\n2.3\tdo Cap\u00edtulo 2. O modulo consiste de uma interface grafica organizada em janelas e bot\u00e3es atrav\u00e1s da qual o usu\u00e1rio pode iniciar uma simula\u00e7\u00e3o e analisar os resultados. Para a simulac\u00e3o, o usu\u00e1ario pode escolher qual Solver deseja utilizar, um deles sendo o RiserProd. Como n\u00e3ao \u00e1e uma ambiente interativo em tempo-real, o usu\u00e1rio primeiramente deve entrar com os par\u00e2metros, executar a simula\u00e7\u00e3o para todo o intervalo de estudo, e so ent\u00e3o visualizar os resultados. A visualizac\u00e3o e realizada atraves de tabelas e plots 2D. Na Figura 3.6 \u00e1 mostrada uma imagem da interface. Como tanto o VRP quanto o presente trabalho utilizam o mesmo Solver, o VRP mostra-se apropriado como base de compara\u00e7c\u00e3ao para o Modulo de Visualiza\u00e7c\u00e3ao aqui proposto. Tal compara\u00e7\u00e3o e efetuada na avalia\u00e7\u00e3o de usabilidade, discutida na Subse\u00e7\u00e3o 3.2.6 a seguir.\n3.2.6\tAvaliando a Visualiza\u00e7\u00e3o\nFoi afirmado na Se\u00e7ao 1.1 do Cap\u00edtulo 1 que um simulador e util no projeto, analise e diagn\u00e1ostico de risers, e que recursos de visualiza\u00e7ca\u00e3o e intera\u00e7c\u00e3ao em tempo-real contribuem para uma compreensao mais intuitiva da simulacao; espera-se, portanto, que o ambiente desenvolvido apresente estas qualidades. Baseado nestas caracter\u00edsticas, tambem acredita-se que o ambiente se destaque mais em permitir uma vis\u00e3ao global da simulac\u00e7\u00e3ao, sintetizando seus diversos aspectos, do que na visualiza\u00e7c\u00e3ao de dados individuais.\nComo forma de avaliar a presen\u00e7a ou nao destas caracter\u00edsticas, foi elaborado um teste para ser realizado com usu\u00e1rios que tenham experi\u00e2ncia com risers. O teste consiste em colocar \u00e0 disposic\u00e3o o ambiente de visualiza\u00e7ao, bem como instru\u00e7\u00e3es explicando o seu prop\u00e1sito e a forma de uso, e pedir para que o usu\u00e1ario utilize o programa e responda um question\u00e1ario. A forma como o usua\u00e1rio deve utilizar o programa \u00e1e livre, sendo pedido apenas que execute uma ou mais simula\u00e7c\u00e3oes e explore as diversas caracter\u00e1sticas do software. As quest\u00e3oes cobrem diversos aspectos, abrangendo perguntas sobre a utilidade do ambiente para os diferentes propo\u00e1sitos de projeto, an\u00e1alise e diagn\u00e1ostico de risers, sobre a qualidade da anima\u00e7ca\u00e3o e da interatividade, e se a visualiza\u00e7ao da simulac\u00e3o \u00e1 intuitiva, entre outras. Tamb\u00e9m sao feitas algumas perguntas comparando o ambiente desenvolvido com o VRP (mencionado na Subse\u00e7ao 3.2.5). As quest\u00e3es devem ser respondidas dando notas de acordo com a escala de Likert, isto \u00e1, de 1 a 5, sendo 1 a pior e 5 a melhor nota. O volunta\u00e1rio pode adicionalmente comentar a nota dada no campo Justicativa, sendo isto opcional. O question\u00e1rio aplicado encontra-se no Ap\u00e2ndice A.\n3.3\tIntegrando Solver e Modulo de Visualiza\u00e7\u00e3o\nPor fim, \u00e1 necess\u00e1rio integrar o Solver e o M\u00e1dulo de Visualiza\u00e7\u00e3o de forma a comporem uma unica aplica\u00e7\u00e3o. A abordagem escolhida foi encapsular o Solver como m\u00e1dulo Python utilizando o SWIG e pass\u00e1a-lo ao M\u00e1odulo de Visualiza\u00e7c\u00e3ao, onde podera\u00e1 ser utilizado como um m\u00e1dulo Python. O SWIG \u00e1 uma ferramenta muito utilizada (por exemplo, pelo Google) para realizar de forma automatizada o encapsulamento e binding de programas em C/C++ com outras linguagens como Python, Ruby e PHP. Para tanto, deve-se escrever em um arquivo de extensa\u00e3o .i quais as classes e func\u00e7\u00e3oes C/C++ dever\u00e3ao estar dispon\u00e1veis para uso pela outra linguagem. Executando o SWIG com este arquivo de entrada, um header C/C++ .h e um arquivo Python .py sao gerados. Adicionando o header ao c\u00e1digo C/C++ e compilando como uma biblioteca, \u00e1 gerado um arquivo que juntamente ao arquivo .py gerado anteriormente, permite que a biblioteca seja importada como um m\u00e1odulo Python.\nAssim, os m\u00e1todos do Solver podem ser invocados dentro do codigo Python e tambem os dados do Solver podem ser lidos e escritos. Uma unica complica\u00e7\u00e3o existente \u00e1 quanto ao acesso de dados vetoriais, j\u00e1 que no C/C++ o vetor \u00e1 um ponteiro. A solu\u00e7ao para este caso \u00e1e implementar no pr\u00e1oprio arquivo .i getters e setters apropriados para esses dados, que dado o \u00e1ndice retornam o valor do elemento naquela posi\u00e7\u00e3o do vetor.\n3.4\tConsiderac\u00e3es Finais\nNeste cap\u00e1tulo, foram mostrados os diversos aspectos necess\u00e1rios no projeto e na imple-menta\u00e7ca\u00e3o do ambiente de visualiza\u00e7c\u00e3ao e simula\u00e7c\u00e3ao. Foi visto como o software do ambiente foi estruturado em dois m\u00e1odulos, um respons\u00e1avel pela simula\u00e7ca\u00e3o, o Solver, e um respons\u00e1avel pela visualizac\u00e7\u00e3ao. Da parte do Solver, ap\u00e1os expor os fundamentos matema\u00e1ticos da simula\u00e7c\u00e3ao de riser e os requisitos necess\u00e1arios para operar com interac\u00e7\u00e3ao em tempo-real, foi explicado como o RiserProd, um Solver que j\u00e1 implementava o modelo matematico descrito, p\u00e2de ser adaptado para o uso em tempo-real. Foi tamb\u00e1em descrito o m\u00e1etodo utilizado para avaliar o desempenho\ndo Solver desenvolvido. Quanto ao Modulo de Visualiza\u00e7\u00f5o, al\u00e9m de discutir o prop\u00e9sito e os fundamentos da visualiza\u00e7\u00f5o cient\u00e9fica, foram indicadas as t\u00e9cnicas escolhidas para visualizar a simulac\u00f5o de riser, bem como o design da interface de usu\u00e9rio desenvolvida para tal e as ferramentas utilizadas na implementa\u00e7ao do m\u00f3dulo. Al\u00e9m disso, foi explicado o m\u00e9todo proposto para avaliar a usabilidade do ambiente. Por fim, foi mostrado como os dois modulos que compo\u00f5em o ambiente de visualiza\u00e7c\u00f5ao e simulac\u00e7a\u00f5o puderam ser integrados em um u\u00e9nico aplicativo. No cap\u00e9tulo seguinte s\u00f5o mostrados e discutidos os resultados obtidos a partir dos m\u00e9todos descritos aqui.\nCap\u00edtulo T__\nResultados\nO ambiente de simula\u00e7\u00f5o e visualiza\u00e7\u00f5o de risers foi implementado e avaliado conforme especificado no Cap\u00e9tulo 3. No presente cap\u00e9tulo, o proto\u00e9tipo desenvolvido \u00e9e apresentado, sendo descritas suas principais caracter\u00edsticas. Tamb\u00e9m uma vis\u00f5o geral do c\u00e9digo do prot\u00e9tipo \u00e9 mostrada. Maiores detalhes do co\u00e9digo podem ser consultados na documenta\u00e7ca\u00f5o apresentada no Ap\u00eandice B. Por fim, sao apresentados e discutidos os resultados das analises de desempenho e usabilidade.\n4.1 Prot\u00f3tipo Desenvolvido\nO prot\u00e9tipo foi desenvolvido conforme especificado no Cap\u00e9tulo 3. Na Figura 4.1 \u00e9 mostrada a janela principal da aplica\u00e7\u00f5o, que \u00e9 constitu\u00e9da de duas partes principais: \u00e0 esquerda, a visualizacao em gr\u00e9ficos tridimensionais e \u00e0 direita o painel de controle. Adicionalmente, h\u00e9 tamb\u00e9em uma barra de menu na parte superior da janela.\nPara iniciar uma simulac\u00e7\u00f5ao, o usu\u00e9ario deve primeiro determinar a configura\u00e7c\u00f5ao do riser, na op\u00e7ao New->Model, na barra de menu (Figura 4.2). Em seguida, o numero de elementos do modelo de elementos finitos da simula\u00e7c\u00f5ao deve ser especificado. Feito isto, um conjunto padra\u00f5o de par\u00eaametros \u00e9e estabelecido e a simula\u00e7c\u00f5ao esta\u00e9 pronta para ser executada e visualizada. Atrav\u00e9es de um bot\u00f5ao Play, o usu\u00e9ario pode iniciar ou pausar a simula\u00e7c\u00f5ao. Com o bot\u00f5ao Reset, o riser \u00e9e recolocado em sua posi\u00e7c\u00f5ao inicial, reiniciando a simula\u00e7c\u00f5ao com o mesmo conjunto de para\u00eametros. Os par\u00eaametros podem ser alterados a qualquer momento no painel de controle, na aba Parameters. Mu\u00e9ltiplos par\u00eaametros podem ser alterados de uma vez, mas \u00e9e necessa\u00e9rio ativar o bot\u00f5o Apply para indicar que os novos par\u00eametros podem ser submetidos. Tamb\u00e9m no painel de controle outras op\u00e7co\u00f5es podem ser ajustadas.\nA visualiza\u00e7c\u00f5ao da simula\u00e7ca\u00f5o reproduz em computac\u00e7\u00f5ao gr\u00e9afica o cena\u00e9rio de opera\u00e7ca\u00f5o de um riser, onde o usu\u00e9rio pode v\u00ea-lo movimentando-se sob o efeito das cargas ambientais. Sendo uma cena 3D, \u00e9 poss\u00e9vel aplicar transformacoes de rota\u00e7\u00f5o, transla\u00e7\u00f5o e escala, como na Figura 4.3. Na cena, al\u00e9em do riser, s\u00f5ao representados as boias, a embarcac\u00e7a\u00f5o, a superf\u00e9cie e o fundo do mar. Como o objetivo do sistema \u00e9e prover uma visa\u00f5o geral e intuitiva da simula\u00e7c\u00f5ao, a rela\u00e7c\u00f5ao de escalas entre alguns elementos, como entre o riser e a embarca\u00e7c\u00f5ao, na\u00f5o segue a da realidade, pois poderia dificultar a visualiza\u00e7c\u00f5ao. Tamb\u00e9em a passagem do tempo na visualizac\u00e7\u00f5ao n\u00f5ao \u00e9e\nFigura 4.1: Janela principal do ambiente de visualiza\u00e7\u00e3o.\nFigura 4.2: Iniciando uma simulac\u00e3o: escolhe-se uma configura\u00e7\u00e3o de riser e o numero de elementos do modelo e a simula\u00e7c\u00e3ao esta\u00e9 pronta para ser visualizada.\nFigura 4.3: E possivel explorar o ambiente virtual aplicando rota\u00e7\u00e3o, transla\u00e7\u00e3o e escala.\nnecessariamente igual a da simula\u00e7ao. Sao visualizados tamb\u00e9m os diversos dados da simula\u00e7\u00e3o, tanto par\u00e2metros quanto resultados. Um conjunto de setas sobre o riser representa as for\u00e7as de excita\u00e7\u00e3o, enquanto um outro conjunto de setas dispostas um pouco afastadas do riser mostra o perfil de correnteza mar\u00edtima. Os m\u00e9ximos de deslocamento nos planos inline e transversal s\u00e3o marcados com linhas verdes. Por fim, cores s\u00e3o utilizadas sobre a parede do riser para representar diferentes dados da simula\u00e7c\u00e3ao, como coeficiente de arrasto ou pressa\u00e3o interna.\nAlguns aspectos da visualiza\u00e7\u00e3o podem ser ajustados na aba Display do painel de controle, como qual a grandeza a ser representada por cores. Tambem nesta aba \u00e9 poss\u00edvel ajustar as escalas do deslocamento e for\u00e7cas sobre o riser, ja\u00ed que estes podem ser muito pequenos para serem visualizados apropriadamente. Para facilitar este processo, atrav\u00edes do bot\u00e3ao Auto Scale \u00ede escolhido automaticamente um conjunto de escalas adequado. Objetos da visualiza\u00e7c\u00e3ao, como as linhas de ma\u00edximo deslocamento ou o modelo da embarca\u00e7c\u00e3ao, podem ser desabilitados para deixar a visualiza\u00e7c\u00e3ao menos carregada de elementos visuais. Por fim, para aumentar o realismo e a imers\u00e3o, \u00e9 poss\u00edvel optar por um estilo de visualizac\u00e3o como o da Figura 4.4, com o mar estendendo-se bem alem da embarca\u00e7\u00e3o (e n\u00e3o contido por um bounding box), e tamb\u00edm ativar o uso de vis\u00e3ao est\u00edereo tridimensional.\nAlem de visualizar os dados no ambiente de realidade virtual, \u00e9 poss\u00edvel tambem inspecionar os dados na forma numerica, na aba Results do painel de controle. Nela, uma tabela com os dados de deslocamentos, velocidades e for\u00e7cas produzidos pela simula\u00e7c\u00e3ao sa\u00e3o exibidos para cada elemento, divididos nas componentes inline e transversal. Clicando-se em um dos elementos da tabela, uma marca\u00e7ca\u00e3o e colocada sobre o riser no ambiente virtual, na posi\u00e7c\u00e3ao do elemento correspondente. Inversamente, ao colocar o mouse sobre o riser e pressionar a tecla P, o elemento daquela posi\u00e7\u00e3o \u00e9 realcado na tabela (Figura 4.5.\nFigura 4.4: Para maior realismo e imers\u00e3o, \u00e1 poss\u00edvel optar por uma visualiza\u00e7\u00e3o com o mar extendendo-se ate o horizonte, bem como utilizar vis\u00e3o stereo tridimensional.\nO Solver do prot\u00f3tipo desenvolvido reproduz exatamente os c\u00e1lculos do simulador original RiserProd. A valida\u00e7ao dos resultados do novo simulador foi feita por comparac\u00e3o de alguns casos de simula\u00e7\u00e3o executados tanto no Solver desenvolvido quanto no RiserProd. Uma valida\u00e7\u00e3o mais exaustiva e formal dos resultados do novo Solver por\u00e1m nao foi realizada neste trabalho.\n4.2\tVis\u00e3o Geral do C\u00f3digo\nUma descric\u00e3o geral do c\u00e1digo do Prot\u00e1tipo desenvolvido \u00e9 aqui apresentada. Maiores detalhes podem ser consultados na documenta\u00e7\u00e3o apresentada no Apendice B. Seguindo a arquitetura descrita no Cap\u00edtulo 3, o c\u00edodigo encontra-se dividido em dois grandes mo\u00eddulos: o co\u00eddigo do Solver em C++ e o do M\u00e1dulo de Visualizac\u00e3o em Python. Os m\u00f3dulos operam em conjunto formando uma unica aplicac\u00e3o, sendo os metodos do Solver invocados pelo M\u00e1dulo de Visualizacao. Na Figura 4.6, \u00e1 mostrado um diagrama com as classes principais do Solver, e na Figura 4.8, um diagrama das classes do M\u00e1dulo de Visualiza\u00e7\u00e3o.\nA simulacao realizada pelo Solver \u00e1 consitu\u00e1da de tr\u00eas an\u00e1lises, as An\u00e1lises Est\u00e1tica, de Vibra\u00e7\u00e3es Livres e Din\u00eamica. Cada uma destas analises encontra-se implementada como uma classe no c\u00e1digo do Solver, respectivamente nomeadas de StaticAnalysis, FreeVibrationAnalysis e DynamicAnalysis. Funcionando como uma engine, cada uma possui um metodo run, que recebendo como par\u00eametro um objeto do tipo Riser, realiza todos os c\u00e1lculos correspondentes a determinada an\u00e1lise e armazena no objeto fornecido os resultados produzidos. O tipo Riser \u00e1 definido no c\u00e1digo do Solver, assim como subclasses que definem configura\u00e7\u00e3es especificas de riser: TTR, Collector e Tower. Fazendo uso de sobrecarga de m\u00e9todo (method overloading), os\nFigura 4.5: Apontando com o mouse sobre o riser e pressionando o botao p, o elemento correspondente \u00e9 marcado no ambiente de visualiza\u00e7ao (esfera vermelha) e real\u00e7ado na tabela da aba Results.\nFigura 4.6: Diagrama com as classes principais que comp\u00f5e o Solver. Para n\u00f5o sobrecarregar o diagrama, foram omitidas as subclasses de MyMatrix e Force.\nm\u00e1etodos run das classes de ana\u00e1lise aceitam como par\u00eaametro cada um destes subtipos de Riser, realizando opera\u00e7c\u00e3oes diferentes conforme o tipo passado.\nNos ca\u00e1lculos realizados pela an\u00e1alises, sa\u00e3o calculadas e manipuladas diversas matrizes como as de Massa, Amortecimento e Rigidez, entre outras. Todas estas encontram-se definidas no c\u00e1digo do Solver como filhas da classe base MyMatrix. Estas matrizes foram definidas como classes ao inv\u00e1s de utilizar diretamente vetores (arrays) de duas dimens\u00e3es pois estas matrizes compartilham de algumas caracter\u00e1sticas n\u00e3ao usuais. Em primeiro lugar, nem todos os elementos das matrizes apresentam valores diferentes de zero, estando estes concentrados em faixas bem definidas da matriz. Assim, de forma a economizar mem\u00e1oria, \u00e1e adotado um procedimento de compressa\u00e3o da matriz, na qual apenas os valores diferentes de zero sa\u00e3o armazenados. Como um efeito disso, o acesso a elementos da matriz deixa de ser trivial, dado que \u00e1e necess\u00e1ario uma convers\u00e3o dos \u00e1ndices da matriz para a forma comprimida. Na classe base MyMatrix, encontram-se m\u00e1todos que facilitam a interac\u00e3o com a matriz, como getters e setters. Al\u00e1m disso, algumas matrizes, com a de Massa, Amortecimento e Rigidez (nomeadas no c\u00e1odigo de MassMatrix, DampingMatrix e StiffnessMatrix, respectivamente), contam com m\u00e1todos assemble, que, recebendo como par\u00eaametro um objeto de uma subclasse de Riser, calculam os valores da matriz, preparando-a para ser usada pelas ana\u00e1lises. Pelas ana\u00e1lises tamb\u00e1em s\u00e3ao utilizadas classes derivadas de Force, que implementam as cargas que atuam sobre o riser.\nA classe Riser e suas subclasses servem basicamente de cont\u00eaeiner para outros dados da simula\u00e7c\u00e3ao, tanto para\u00eametros como resultados, e s\u00e3ao passadas como argumento para diversos m\u00e1etodos. A classe Riser tamb\u00e1em cont\u00e1em m\u00e1etodos que tem func\u00e7a\u00e3o auxiliar, como calcular um certo dado do riser a partir de outros dados.\nFinalmente, tem-se a classe Solver e a classe Model. A classe Solver \u00e1e aquela que agrega as demais, funcionando como a classe principal do Solver. Possui, entre outros, os m\u00e1etodos newModel (para definir uma configura\u00e7\u00e3o de riser), staticAnalysis, freeVibrationAnalysis e dynamicAnalysis. A classe cont\u00e1m tamb\u00e1m entre seus atributos, ponteiros para objetos das classes StaticAnalysis, FreeVibrationAnalysis e DynamicAnalysis, e um ponteiro para um objeto da classe Model. Os objetos das an\u00e1alises servem obviamente para realizar as ana\u00e1lises do Solver. A classe Model por sua vez, \u00e1 uma classe que serve de intermediario entre o Solver e a classe Riser. A classe Model possui, como a classe Riser, subclasses para cada configurac\u00e7\u00e3ao de riser (TTRModel, CollectorModel, TowerModel). Cada uma possui como atributo um objeto da subclasse de Riser apropriada, bem como m\u00e1etodos staticAnalysis, freeVibrationAnalysis e dynamicAnalyis, que recebem como argumento a classe da ana\u00e1lise correspondente e chamam por sua vez o m\u00e1etodo run dela passando o objeto do subtipo de Riser apropriado. A ideia por tr\u00e1as da aparente complexidade de classes e chamadas de m\u00e1etodos \u00e1e se valer do polimorfismo e da sobrecarga de m\u00e1etodo para implementar as diversas an\u00e1alises para as diversas configura\u00e7co\u00e3es de riser sem precisar armazenar ou verificar informa\u00e7c\u00e3oes quanto ao tipo de configura\u00e7c\u00e3ao utilizada. Com esta organizac\u00e7\u00e3ao, por exemplo, a classe Solver mant\u00e1em apenas um atributo de tipo Model, sem precisar saber como qual tipo especifico est\u00e1a lidando (exceto no momento em que um \u00e1e criado, no m\u00e1todo newModel). O diagrama da Figura 4.7 ilustra esta logica, mostrando como se d\u00e1a o fluxo de chamadas de m\u00e1etodo ao realizar a an\u00e1alise est\u00e1atica para uma configura\u00e7c\u00e3ao TTR, por exemplo.\nFigura 4.7: Diagrama representando o fluxo de chamadas (indicado por setas) que ocorre ao executar a An\u00f3alise Est\u00f3atica para uma configura\u00e7c\u00e3ao TTR. O polimorfismo e a sobrecarga de m\u00f3etodos assegura que a an\u00f3alise \u00f3e executada para a configura\u00e7c\u00e3ao de riser espec\u00f3fica.\nPara o c\u00f3digo do M\u00f3dulo de Visualiza\u00e7\u00e3o, os objetos correspondem em sua grande maioria aos objetos visuais da interface de visualiza\u00e7ao, exceto pela classe principal App. Tem-se, por exemplo, a classe Interface, que implementa a janela principal e seus diversos widgets. Esta por sua vez, cont\u00e9m um objeto Scene, para a cena 3D onde \u00f3 feita a visualizac\u00e3o propriamente, e Panel, onde \u00f3 implementado o painel de controle. O objeto Scene cont\u00f3m ainda outros objetos, representando os elementos da cena, como Riser para o riser, Water para a superf\u00edcie do mar, WaterFlow, para o perfil de correnteza ou Forces, para as for\u00e7as de excita\u00e7\u00e3o representadas como setas.\nOs m\u00f3etodos destas classes s\u00e3ao va\u00f3rios e de prop\u00f3ositos bem espec\u00f3ficos, mas todas possuem tanto um m\u00f3todo construtor init\u2014 quanto um update. O m\u00f3todo init\u2014 \u00f3 chamado quando o objeto \u00f3 instanciado e cria e inicializa seus atributos. Para o caso de classes como Riser ou Water que representam elementos da visualiza\u00e7\u00e3o, o m\u00f3todo________imL_ cria os mappers, actors e\ndemais objetos do VTK que comp\u00e3em o pipeline de visualiza\u00e7\u00e3o, enquanto que para a classe Panel, o m\u00f3todo conecta os diversos widgets do painel de controle ao seus respectivos callback. O m\u00f3etodo update, por outro lado, atualiza os dados do objeto a medida que a simula\u00e7c\u00e3ao \u00f3e executada.\nPor fim, a classe App \u00f3e a classe que define como m\u00f3etodos as princiapis funcionalidades da aplica\u00e7\u00e3o, al\u00f3m de conter uma inst\u00e2ncia de Interface e uma de Solver, importado do C++ via SWIG. Entre os m\u00f3todos oferecidos pela classe tem-se newModel, para criar um novo modelo de simula\u00e7ao; generate, que invoca as an\u00f3lises est\u00f3tica e de vibra\u00e7\u00f5es livres do Solver e \u00f3 chamada sempre que novos par\u00e2metros s\u00e3o passados; play, pause e reset, para controlar a visualiza\u00e7\u00e3o da simulac\u00e7\u00e3ao, e update, que invoca um passo da analise din\u00e2amica e chama o metodo update de Interface, que chama o update de Scene e de Panel, e assim por diante. A frequ\u00e2ncia com que o metodo update e invocado e controlado por um relogio dispon\u00f3vel como classe do Qt.\nFigura 4.8: Diagrama de classes do Modulo de Visualizac\u00e3o. Como Scene cont\u00e1m muitas classes, apenas algumas esta\u00e3o representadas, para n\u00e3ao sobrecarregar o diagrama.\n4.3\tAvalia\u00e7\u00e3o do Desempenho do Solver\nOs resultados da medida dos tempos em cada uma das quatro etapas em fun\u00e7c\u00e3ao do nu\u00e1mero de elementos, de acordo com o m\u00e1todo descrito na Se\u00e7ao 3.1.5 do Cap\u00e1tulo 3, sao mostrados na Figura 4.9 a seguir. Cada um dos valores apresentados foi obtido como a m\u00e1dia de dez amostras medidas e as barras de erro nos gr\u00e1aficos representam o desvio padra\u00e3o. O nu\u00e1mero de amostras foi considerado satisfato\u00e1rio devido ao baixo desvio padra\u00e3o resultante. As medidas foram tomadas ao executar o Solver em uma m\u00e1quina com processador Intel Core i7 2.80 GHz e 12GB de memoria RAM e sistema operacional Windows 7 de 64 bits.\nA medida dos tempos permite analisar os limites para o uso interativo em tempo-real do Solver. Conforme discutido no Cap\u00e1tulo 3, sa\u00e3o dois os requisitos que devem ser assegurados para intera\u00e7c\u00e3ao em tempo-real. O primeiro \u00e1e que, ao realizar uma mudan\u00e7ca nos par\u00e2ametros da simulacao, seja pequeno o tempo de espera para se obter o novo comportamento do riser. O segundo fator \u00e1e que a taxa com que os resultados da simula\u00e7c\u00e3ao s\u00e3ao calculados deve ser adequada ao passo da animac\u00e7\u00e3ao de 30 quadros por segundo.\nO tempo de resposta ap\u00e1os a mudanc\u00e7a de par\u00e2ametros \u00e1e igual a soma das etapas de An\u00e1alise Esta\u00e1tica, Ana\u00e1lise de Vibrac\u00e7\u00e3oes Livres e Montagem de Matrizes. No gr\u00e1afico da Figura 4.9, fica evidente como a contribuic\u00e7\u00e3ao da An\u00e1alise Est\u00e1atica para o tempo total \u00e1e pouco significativa se comparada a de Vibra\u00e7c\u00e3oes Livres e a Montagem de Matrizes. O gra\u00e1fico da Figura 4.10 mostra o tempo de espera a cada mudan\u00e7ca de para\u00e2metros, em func\u00e7\u00e3ao do nu\u00e1mero de elementos. Considerando o limite de 1 segundo de resposta, o nu\u00e1mero m\u00e1aximo de elementos suportado \u00e1e de 150; para 2 segundos, o limite sobe para 200 elementos.\n10\t30\t50\t70 90 110 130 150 1 70 190 210 230 250 270 290\n\u2022An\u00e1lise Est\u00e1tica\n-\u2666-An\u00e1lise de Vibra\u00e7\u00f5es Liwes\nMontagem de Matrizes\n\u25a0\u2666An\u00e1lise Dn\u00e2mica\nEl em entos\nFigura 4.9: Medidas de tempo de execu\u00e7\u00f5o do Solver, tomadas em quatro etapas distintas.\nFigura 4.10: Tempo de espera a cada mudan\u00e7a de par\u00eametros, computado como a soma das tr\u00eas primeiras etapas. A Analise de Vibra\u00e7\u00f5es Livres e a Montagem de Matrizes s\u00f5o as que mais contribuem na medida\nElementos\nFigura 4.11: Taxa de quadros m\u00e1xima suportada em fun\u00e7\u00e3o do n\u00famero de elementos, tomado como o inverso das medidas da Analise Dinamica.\nA taxa com que os resultados sao produzidos, por sua vez, est\u00e1 relacionada ao tempo gasto numa execu\u00e7\u00e3o da Analise Dinamica. A Figura 4.11 mostra a taxa suportada em fun\u00e7\u00e3o do numero de elementos, que \u00e1 obtido pelo inverso dos tempos medidos da An\u00e1lise Dinamica. Para manter uma taxa de 30 quadros por segundo, o numero m\u00e1ximo de elementos suportado \u00e9 de 170.\nO profiling pela ferramenta do Visual Studio aponta os pontos de gargalo no processamento. As fun\u00e7\u00e3es que consomem mais tempo de processamento segundo o profiler s\u00e3o duas, uma que realiza Decomposi\u00e7\u00e3o de Gauss e outra que realiza invers\u00e3o de matriz. A primeira \u00e1 utilizada na Analise de Vibrac\u00e3es Livres enquanto a segunda \u00e1 empregada na Montagem de Matrizes, condizendo com as medidas de tempo obtidas para estas etapas (Figura 4.9), que foram bem maiores do que das outras.\n4.4\tAvalia\u00e7\u00e3o da Usabilidade do Ambiente de Visualiza\u00e7\u00e3o e Simula\u00e7\u00e3o\nA avalia\u00e7\u00e3o de usabilidade, descrita na Se\u00e7\u00e3o 3.2.6 do Cap\u00e1tulo 3, foi feita com nove usu\u00e1rios. Reconhece-se ser um numero pequeno para uma amostra, mas o fato de ser necess\u00e1rio que os volunt\u00e1rios tivessem experi\u00eancia com risers foi um grande limitante para a sele\u00e7\u00e3o de pessoal para o teste. Outra limitacao foi o fato de apenas dois volunt\u00e1rios terem ja utilizado o VRP, de forma que os demais n\u00e3ao puderam responder as quest\u00e3oes 13 a 19. Mesmo assim, o resultado dos testes revelou algumas informa\u00e7co\u00e3es interessantes.\nA Tabela 4.1 mostra o resultado das avalia\u00e7\u00e3es realizadas e o gr\u00e1fico da Figura 4.12 mostra a m\u00e1edia das notas para cada quest\u00e3ao.\nComo existe espa\u00e7co para subjetividade na hora de atribuir as notas, pois algumas pessoas tendem a evitar notas mais extremas ou evitar dar notas baixas, a m\u00e1edia simples poderia n\u00e3ao\nPerguntas /Voluntarios\t1\t2\t3\t4\t5\t6\t7\t8\t9\nCategoria Geral:\t\t\t\t\t\t\t\t\t\n1 - Para a finalidade de projeto de risers, o ambiente testado \u00e9:\t5\t3\t5\t3\t3\t5\t-\t5\t3\n2 - Para a finalidade de analise do comportamento de risers, o ambiente testado \u00e9:\t5\t4\t5\t3\t3\t5\t-\t5\t4\n3 - Para a finalidade de diagnostico de problemas em risers, o ambiente testado e:\t4\t2\t5\t3\t2\t4\t-\t4\t3\n4 - Para a finalidade de visualizar o comportamento global do riser, o ambiente testado e: (\t5\t4\t5\t3\t4\t4\t3\t4\t4\n5 - Para a finalidede de visualizar individualmente cada resultado da simulac\u00e3o, o ambiente testado e:\t5\t2\t5\t3\t4\t4\t3\t4\t4\n6 - Quanto a facilidade de uso, o ambiente testado e:\t4\t5\t4\t4\t5\t5\t4\t5\t4\n7 - Quanto \u00e0 apar\u00eancia do ambiente testado, ela e:\t5\t5\t4\t4\t4\t5\t4\t5\t4\nCategoria Visualiza\u00e7\u00e3o:\t\t\t\t\t\t\t\t\t\n8 - Quanto \u00e0 representac\u00e3o da simula\u00e7\u00e3o na forma de um ambiente de realidade virtual, ela e:\t4\t4\t5\t4\t5\t5\t3\t4\t3\n9 - Quanto \u00e0 qualidade da anima\u00e7ao (fluidez), ela e:\t4\t4\t5\t4\t5\t5\t-\t5\t4\nCategoria Interativade:\t\t\t\t\t\t\t\t\t\n10 - Quanto \u00e0 interatividade, ela e:\t5\t5\t4\t4\t5\t5\t4\t5\t4\n11 - Quanto ao tempo de resposta ao mudar par\u00eaametros, ele \u00e9: )\t5\t5\t4\t4\t4\t5\t4\t5\t5\n12 - Quanto \u00e0 organiza\u00e7\u00e3o do painel de controle, ela e:\t4\t5\t4\t4\t5\t4\t4\t5\t4\nCategoria Compara\u00e7\u00e3o com o VRP:\t\t\t\t\t\t\t\t\t\n13 - Para a finalidade de projeto de risers, o ambiente testado e: [comparado ao VRP]\t-\t-\t5\t-\t-\t5\t-\t-\t-\n14 - Para a finalidade de analise do comportamento de risers, o ambiente testado e: [comparado ao VRP]\t-\t-\t3\t-\t-\t4\t-\t-\t-\n15 - Para a finalidade de diagnostico de problemas em risers, o ambiente testado e: [comparado ao VRP]\t-\t-\t3\t-\t-\t4\t-\t-\t-\n16 - Para a finalidade de visualizar o comportamento global do riser, o ambiente testado e: [comparado ao VRP]\t-\t-\t3\t-\t-\t5\t-\t-\t-\n17 - Para a finalidede de visualizar individualmente cada resultado da simula\u00e7c\u00e3ao, o ambiente testado e: [comparado ao VRP]\t\t\t3\t\t\t4\t\t\t\n18 - Quanto a facilidade de uso, o ambiente testado e: [comparado ao VRP]\t-\t-\t5\t-\t-\t5\t-\t-\t-\n19 - Quanto \u00e0 apar\u00eancia do ambiente testado, ela e: [comparado ao VRP]\t-\t-\t5\t-\t-\t5\t-\t-\t-\nTabela 4.1: Notas dadas pelos volunt\u00e1rios para cada pergunta.\nFigura 4.12: Nota m\u00e9dia e desvio padr\u00e3o de cada pergunta.\nrepresentar adequadamente os resultados. Assim, as notas dadas por cada voluntario foram divididas pela nota m\u00e9dia dada por ele e ent\u00e3o calculadas as m\u00e9dias das notas normalizadas para cada questao (Figura 4.13).\nE f\u00e1cil notar que n\u00e3o ha muita disparidade nos gr\u00e1ficos das Figuras 4.12 e 4.13 (quanto a propor\u00e7ao entre as notas) e ambos apontam as mesmas conclus\u00e3es. O ambiente desenvolvido aparenta ser mais apto para uso no projeto e, especialmente, na an\u00e1alise de risers do que para diagn\u00e1stico de problemas. Um dos voluntarios apontou no campo Justificativa para este quesito (o da questao 3) que o ambiente 'nao leva em considera\u00e7\u00e3o criterios de falha e seguran\u00e7a do riser, sendo que o usuario deve inspecionar visualmente o resultado'. Para a finalidade de visualizar a simula\u00e7ca\u00e3o como um todo, a nota m\u00e1edia foi maior do que para a visualiza\u00e7ca\u00e3o de resultados individuais, por\u00e1m a diferen\u00e7a foi pequena, contrariando o esperado (de que fosse claramente melhor para visualiza\u00e7ao global da simulac\u00e3o), conforme discutido na Subsec\u00e3o 3.2.2 do Cap\u00edtulo\n3.\tAlguns usu\u00e1arios destacaram que seria deseja\u00e1vel representar os resultados tamb\u00e1em em gra\u00e1ficos 2D ou permitir que sejam salvos em arquivos para serem utilizados externamente. As notas de 6 a 12 mostram que o ambiente de fato apresenta os diferenciais de visualizac\u00e3o intuitiva e interativa em tempo-real e \u00e1e de f\u00e1acil uso. Nestes quesitos os comenta\u00e1rios em geral consistiam de sugest\u00e3oes de novas funcionalidades, como exibir uma janela com dados de um elemento do riser ao clicar nele. J\u00e1 as notas de 13 a 19, devido a baixa quantidade de amostras, impedem uma conclus\u00e3ao mais s\u00e1olida, mas trazem ainda alguma informac\u00e7a\u00e3o. Os resultado para estes to\u00e1picos apontam para a facilidade de uso do programa, mostrando-o como melhor que a do VRP, al\u00e1em de indicar que o programa tamb\u00e1em \u00e1e melhor que o VRP para projeto de risers, sendo equivalente\nFigura 4.13: Notas m\u00eddia e desvio padr\u00e3o de cada pergunta ap\u00f3s normaliza\u00e7\u00e3o. ao VRP nos demais aspectos.\nFinalmente, tem-se que o ambiente teve notas m\u00eddias nas perguntas sempre acima de tr\u00e2s (considerado aqui o m\u00ednimo aceit\u00e1vel), com a m\u00eddia destas notas sendo de 4,2 num m\u00e1ximo de 5, o que sugere, pelo menos baseado na opiniao dos voluntarios, a boa qualidade do ambiente desenvolvido.\n4.5\tConsidera\u00e7\u00f5es Finais\nForam discutidos neste cap\u00edtulo os resultados obtidos pela aplica\u00e7\u00e3o dos procedimentos descritos no Cap\u00edtulo 3. Em primeiro lugar, foi apresentado o prot\u00f3tipo desenvolvido, descrevendo e explicando suas principais caracter\u00edsticas e funcionalidades. Entao, foi fornecida uma vis\u00e3o geral do c\u00edodigo do proto\u00edtipo, apresentando as principais classes e como elas se relacionam entre si. Finalmente, foram mostrados os resultados das avalia\u00e7\u00f5es de desempenho e de usabilidade. A avalia\u00e7ao de desempenho revelou que o Solver suporta intera\u00e7\u00e3o em tempo-real com uma taxa de anima\u00e7\u00e3o de 30 quadros por segundo para at\u00ed 170 elementos. A avalia\u00e7ao de usabilidade sugere que, segundo os usu\u00edarios, o ambiente desenvolvido \u00ede de f\u00edacil uso, apresentando visuali-za\u00e7ao intuitiva e boa interatividade em tempo-real. Al\u00edm disso, foi revelado que o ambiente de visualizacao \u00ed mais adequado para projeto e an\u00edlise do comportamento de risers do que para diagn\u00edostico de problemas, e que \u00ede apenas ligeiramente melhor para visualizar o comportamento global do riser do que para visualizar caracter\u00edsticas espec\u00edficas.\nCap\u00edtulo ^7_\nConclus\u00f5es\nNeste trabalho, foi proposto e desenvolvido um ambiente virtual para simula\u00e7\u00f5o e visuali-za\u00e7ca\u00f5o de risers r\u00e9gidos verticais. O riser \u00e9e uma importante estrutura utilizada na perfurac\u00e7\u00f5ao e explora\u00e7\u00f5o de po\u00e7os de petroleo offshore, sendo um duto que liga o po\u00e7o a unidade de producao, e que \u00e9e respons\u00e9avel, entre outras coisas, por guiar a broca de perfura\u00e7c\u00f5ao ou escoar o petro\u00e9leo e o g\u00e9s extra\u00e9dos do poco. Devido as condic\u00f5es ambientais como ondas, correnteza e vortices induzidos sobre o duto, o riser sofre o efeito de cargas que diminuem sua vida \u00fatil. Simula\u00e7\u00f5o por computador \u00e9e uma ferramenta importante, seja para prever poss\u00e9veis problemas como para diagnosticar aqueles que ja\u00e9 ocorrem. A visualizac\u00e7\u00f5ao cient\u00e9fica \u00e9e tamb\u00e9em de grande valia, pois permite representar o grande volume de dados num\u00e9ericos produzidos por simulac\u00e7\u00f5oes em uma forma visual de mais fa\u00e9cil compreens\u00f5ao. O ambiente apresentado suporta a visualiza\u00e7c\u00f5ao de risers com o diferencial de permitir a intera\u00e7c\u00f5ao em tempo-real com a simula\u00e7ca\u00f5o. No sistema desenvolvido, o usua\u00e9rio pode alterar dados de simulac\u00e7\u00f5ao, tais como o perfil de correnteza ou a elasticidade do material do riser, e visualizar o novo comportamento imediatamente, sem precisar interromper a visualiza\u00e7c\u00f5ao ou esperar toda a simula\u00e7c\u00f5ao ser recomputada. Nos outros sistemas de visualiza\u00e7c\u00f5ao de riser identificados na literatura, \u00e9e preciso primeiro realizar toda a simula\u00e7c\u00f5ao para s\u00e9o ent\u00f5ao visualiz\u00e9a-la, o que compromete a fluidez da intera\u00e7ca\u00f5o, especialmente em casos onde o usu\u00e9ario deseja explorar sequencialmente diferentes conjuntos de para\u00eametros.\nO sistema foi desenvolvido como dois m\u00e9odulos que interagem compondo uma u\u00e9nica apli-ca\u00e7c\u00f5ao: o Solver, m\u00e9odulo respons\u00e9avel pela simula\u00e7c\u00f5ao, e o m\u00e9odulo de visualiza\u00e7ca\u00f5o. O Solver segue o modelo matema\u00e9tico de Ferrari e Bearman para a simula\u00e7c\u00f5ao, que utiliza uma abordagem de Elementos Finitos, tendo sido aperfei\u00e7coado em trabalhos posteriores e culminado no software RiserProd. Como o RiserProd original n\u00f5o est\u00e9 apto para uso com intera\u00e7ao em tempo-real, foi necess\u00e9rio aprimor\u00e9-lo para tal uso. Os resultados do novo simulador foram validados comparando-os com os do RiserProd original, para alguns casos de estudo. A visualiza\u00e7c\u00f5ao da simulac\u00e7\u00f5ao \u00e9e feita atrav\u00e9es de uma representa\u00e7c\u00f5ao virtual do riser em seu cen\u00e9ario de opera\u00e7c\u00f5ao. O tubo, o mar e a embarca\u00e7c\u00f5ao s\u00f5ao representados com aux\u00e9lio de t\u00e9ecnicas de computa\u00e7ca\u00f5o gr\u00e9afica 3D, bem como correnteza, for\u00e7as e press\u00f5es sobre o riser e outros dados da simula\u00e7\u00f5o, que s\u00f5o visualizados por meio de setas ou cores no ambiente virtual. Par\u00eaametros da simula\u00e7c\u00f5ao e outros ajustes do programa podem ser alterados atrav\u00e9es de um painel de controle.\nAl\u00e9em de desenvolver o ambiente de simulac\u00e7\u00f5ao e visualizac\u00e7\u00f5ao, foram realizadas tamb\u00e9em ava\nlia\u00e7\u00f5es de desempenho e de usabilidade. A avalia\u00e7\u00e3o de desempenho teve como objetivo medir a capacidade do Solver suportar interatividade em tempo-real, bem como identificar os gargalos no processamento. A avaliac\u00e3o de usabilidade por sua vez, visou identificar se o ambiente desenvolvido atende \u00e0quilo a que se prop\u00e3e, isto \u00ed, de ser uma ferramenta \u00fatil ao engenheiro que trabalha com risers, apresentando os diferenciais de visualiza\u00e7c\u00e3ao intuitiva e interatividade em tempo-real.\nAp\u00edos detalhar os m\u00edetodos utilizados para desenvolver o ambiente e avali\u00eda-lo, foram mostrados e discutidos os resultados obtidos. Ap\u00edos apresentar o proto\u00edtipo implementado e explicar seu funcionamento, uma vis\u00e3ao geral do co\u00eddigo foi descrita, indicando as principais classes e m\u00edetodos e como elas se relacionam. Foram apresentados tamb\u00edem os resultados das avali\u00e7c\u00e3oes realizadas. A avaliac\u00e7\u00e3ao de desempenho revelou que o Solver em seu atual estado \u00ede capaz de suportar uma interatividade em tempo-real para at\u00ed 170 elementos para uma taxa de 30 quadros por segundo para a anima\u00e7c\u00e3ao. A avaliac\u00e7\u00e3ao de desempenho indica tamb\u00edem que as etapas de maior custo sa\u00e3o aquelas associadas a invers\u00e3ao de matrizes. A avalia\u00e7ca\u00e3o de usabilidade por sua vez sugere que o ambiente desenvolvido oferece uma representac\u00e7\u00e3ao visual intuitiva do comportamento do riser e com interativadade em tempo-real satisfat\u00edoria. Revelou tamb\u00edem que o ambiente \u00ede mais adequado para o projeto e an\u00edalise do comportamento de risers do que para diagn\u00edostico de problemas.\nAssim, s\u00e3ao contribui\u00e7c\u00e3oes deste trabalho:\n\u2022\tO desenvolvimento de um m\u00f3dulo de simula\u00e7ao num\u00edrica (Solver) apto ao uso interativo em tempo-real, a partir de uma adapta\u00e7c\u00e3ao do simulador RiserProd, que n\u00e3ao \u00ede capaz de ser utilizado para tal tipo de intera\u00e7c\u00e3ao.\n\u2022\tO desenvolvimento de um m\u00edodulo de visualizac\u00e7\u00e3ao, respons\u00edavel por representar visualmente os dados do m\u00edodulo de simula\u00e7ca\u00e3o e de gerenciar a interac\u00e7\u00e3ao com o usu\u00edario, atrav\u00edes de uma interface que permite ajuste dos par\u00e2metros da simula\u00e7\u00e3o.\n\u2022\tA integrac\u00e7\u00e3ao dos referidos m\u00edodulos em um u\u00ednico ambiente de simula\u00e7ca\u00e3o e visualiza\u00e7c\u00e3ao de risers.\n\u2022\tUma avalia\u00e7ca\u00e3o do desempenho do ambiente, revelando quais os limitantes para o uso interativo em tempo-real do ambiente desenvolvido.\n\u2022\tUma avalia\u00e7c\u00e3ao da usabilidade do ambiente.\n5.1 Limita\u00e7\u00f5es\nEste trabalho possui, naturalmente, algumas limitac\u00e3es, que n\u00e3o puderam ser superadas por quest\u00e3oes de escopo do projeto ou pelo tempo e volume de trabalho adicionais que demandariam.\nUma das limita\u00e7co\u00e3es deste trabalho \u00ede o nu\u00edmero m\u00edaximo de elementos do modelo de simulac\u00e7\u00e3ao em que \u00ede possivel obter uma visualiza\u00e7ca\u00e3o interativa em tempo-real. A avalia\u00e7ca\u00e3o de desempenho mostrou que o limite maximo \u00ed de 170, acima do qual a fluid\u00e2z da intera\u00e7\u00e3o passa a ser comprometida. A princ\u00edpio, seria desejavel alcan\u00e7ar um numero da ordem de 1000 elementos, o\nque proporcionaria uma simulac\u00e7\u00e3ao precis\u00e3ao adequada. Para alcan\u00e7car este nu\u00e1mero, sa\u00e3o necess\u00e1a-rias otimizac\u00e3es no Solver, especialmente nos gargalos que limitam melhores performances. A avalia\u00e7ca\u00e3o revelou que estes est\u00e3ao ligados a etapas que realizam invers\u00e3ao de matrizes.\nAlgumas defici\u00e2encias tamb\u00e1em foram reveladas pela avalia\u00e7ca\u00e3o de usabilidade. O ambiente desenvolvido foi apontado como n\u00e3ao ta\u00e3o adequado para diagn\u00e1ostico de problemas pois n\u00e3ao apresenta recursos para aplicar os crit\u00e1erios de falha e seguran\u00e7ca de risers. Alguns usu\u00e1arios apontaram limita\u00e7c\u00e3oes no modelo de simula\u00e7ca\u00e3o, como a impossibilidade de especificar um nu\u00e1mero de elementos maior para certas regi\u00e3oes do riser, refinando a precis\u00e3ao em \u00e1areas cr\u00e1ticas. Modifica\u00e7c\u00e3oes no modelo da simula\u00e7c\u00e3ao, por\u00e1em, foram consideradas fora do escopo deste trabalho.\nPor fim, pode-se citar tamb\u00e1m o baixo numero de voluntarios utilizado na avaliac\u00e3o de usabilidade, fator que torna as an\u00e1alises derivadas dos resultados menos categ\u00e1oricas.\n5.2\tTrabalhos Futuros\nO projeto realizado e as limita\u00e7co\u00e3es apresentadas sugerem poss\u00e1veis continua\u00e7co\u00e3es para este trabalho. Uma das possibilidades \u00e1 realizar uma valida\u00e7ao mais formal e detalhada dos resultados produzidos pelo Solver desenvolvido. Outro possibilidade consiste em otimizar o Solver de forma a permitir interac\u00e7\u00e3ao em tempo-real com um nu\u00e1mero maior de elementos. Um nu\u00e1mero que conferiria precisa\u00e3o adequada seria da ordem de 1000 elementos. Pelas informa\u00e7c\u00e3oes reveladas pelo profiling do Solver, o atual gargalo no processamente sao a decomposic\u00e3o de Cholesky e a de Gauss, ambas ligadas a invers\u00e3o de matrizes, opera\u00e7\u00e3o tradicionalmente custosa em termos computacionais. Uma abordagem poss\u00edvel para otimizar estas opera\u00e7\u00e3es seria explorar o paralelismo em GPU ou multicore, pois diversos c\u00e1alculos semelhantes sa\u00e3o realizados para cada elemento do riser, o que sugere uma solu\u00e7ca\u00e3o paralela.\nAinda quanto ao Solver, alguns volunta\u00e1rios no teste de usabilidade citaram limita\u00e7co\u00e3es do modelo de simulac\u00e7\u00e3ao, como a impossibilidade de especificar diferentes nu\u00e1meros de elementos para certas regi\u00e3es especificas do riser (em geral, maior resoluc\u00e3o nas extremidades, onde os esfor\u00e7os s\u00e3o cr\u00e1ticos). Outra possibilidade \u00e1, ao inv\u00e1s de trabalhar para aprimorar o modelo atual, permitir que o m\u00e1odulo de visualizac\u00e7\u00e3ao interaja com diferentes Solvers. Para isso, al\u00e1em de implementar o m\u00e1dulo de visualizac\u00e3o de forma a ser mais flex\u00e1vel, qualquer novo Solver deve atender aos requisitos que possibilitem uso em tempo-real, conforme mostrados neste trabalho.\nTamb\u00e1em para o mo\u00e1dulo de visualiza\u00e7ca\u00e3o, \u00e1e poss\u00e1vel aprimor\u00e1a-lo acrescentando novos recursos. Alguns foram j\u00e1a sugeridos pelos volunt\u00e1arios do teste de usabilidade, como funcionalidades que apliquem os crit\u00e1erios de seguranc\u00e7a de risers, ou que mostrem numa janela popup os dados de um elemento clicado. Outra possibilidade \u00e1e oferecer mais op\u00e7c\u00e3oes para controle e representac\u00e7\u00e3ao de escalas no ambiente, tanto na dimensa\u00e3o espacial como temporal. Atualmente, a escalas dos deslocamentos e for\u00e7cas do riser podem ser alteradas, mas as dimenso\u00e3es relativas entre o riser e a embarcac\u00e7\u00e3ao, por exemplo, na\u00e3o refletem a da realidade. Embora isso ocorra para facilitar a visualiza\u00e7c\u00e3ao, oferecer op\u00e7c\u00e3oes para controlar tamb\u00e1em as escalas destes e outros elementos da visualiza\u00e7c\u00e3ao aparenta ser um recursos desej\u00e1avel.\nPor fim, \u00e1e poss\u00e1vel refinar a avalia\u00e7c\u00e3ao de usabilidade, incluindo novos volunt\u00e1arios no teste ou mesmo incluindo novas perguntas que por ventura sejam consideradas pertinentes, como\nperguntas que avaliem a imers\u00e3ao e realismo do ambiente.\nBibliografia\nAg\u00eancia Nacional do Petr\u00f3leo, G. N. e. B. (2012). Anu\u00e1rio estat\u00edstico brasileiro do petr\u00f3leo, g\u00e1s natural e biocombust\u00edveis - 2012.\nAl-Jamal, H. &amp; Dalton, C. (2004). Vortex induced vibrations using large eddy simulation at a moderate reynolds number, Journal of Fluids and Structures 79: 73-92.\nAlexander, C. R. (2003). Development of a Composite Repair System for Reinforcing Offshore Risers, PhD thesis, Texas A&amp;M University.\nBathe, K. (1996). Finite Element Procedures, Prentice-Hall Inc.\nBernardes, J. L. (2004). Desenvolvimento de um ambiente para visualiza\u00e7\u00e3o tridimensional da din\u00e2mica de risers, Master\u2019s thesis, Escola Polit\u00f3cnica da Universidade de S\u00e3o Paulo.\nChai, Y. &amp; Varyani, K. (2002). Three-dimensional lump-mass formulation of a catenary riser with bending, torsion and irregular seabed interaction effect, Ocean Engineering 29: 15031525.\nChakrabarti, S. K. (1987). Hydrodynamic of Offshore Structures, Computational Mechanics Publications, Springer Verlag.\nChaplin, J., Bearman, P., Cheng, Y., Fontaine, E., Graham, J., Herfjord, K., Huarte, F. H., Isherwood, M., Lambrakos, K., Larsen, C., Meneghini, J., Moe, G., Pattenden, R., Tri-antafyllou, M. &amp; Willden, R. (2005). Blind predictions of laboratory measurements of vortex-induced vibrations of a tension riser, Journal of Fluids and Structures 21: 25-40.\nChen, K. H. C. &amp; Chen, C. R. (2010). Vertical riser viv simulation in uniform current, Journal of Offshore Mechanics and Arctic Engineering 132: 337-341.\nDutoRisk Manual de Usu\u00e1rio (Interface e Solver) (2009). Manual Impresso, Laborat\u00f3rito de Sistemas Mar\u00edtimos de Produ\u00e7\u00e3o e Risers.\nEngel, K., Hadwiger, M., Kniss, J. M., Rezk-Salama, C. &amp; Weiskopf, D. (2006). Real-Time Volume Graphics, A K Peters/CRC Press.\nFerrari, J. A. &amp; Bearman, P. (1999a). Hydrodynamic loading and response of offshore risers, Proceedings of the 18th International Conference on Offhosre Mechanics and Arctic Engineering.\nFlatschart, R. B., Meneghini, J. R. &amp; Jr., J. A. F. (2004). Parallel simulation of a marine riser using mpi, Proceedings of OMAE04.\nHolmes, S., Jr., O. H. O. &amp; Constantinides, Y. (2006). Simulation of riser viv using fully three dimensional cfd simulations, Proceedings of OMAE2006.\nKubota, H. Y. (2003). Comportamento din\u00e2mico de um riser r\u00edgido de produ\u00e7\u00e3o, Master\u2019s thesis, Unicamp. Biblioteca Digital da Unicamp.\nMorooka, C. K., Brandt, D. M., Matt, C. G. C. &amp; Franciss, R. (2008). Features of a time domain simulation tool for rigid riser design, Anais da Rio Oil &amp; Gas Expo and Conference 2008.\nMorooka, C. K., Coelho, F. M., Kubota, H. Y., Ferrari, J. A. &amp; Ribeiro, E. J. B. (2004). Investigations on the behavior of vertical production risers, Proceedings of OMAE2004.\nMorooka, C. K., Coelho, F. M., Ribeiro, E. J. B., Ferrari, J. A. &amp; Franciss, R. (2005). Dynamic behavior of a vertical riser and service life reductu, Proceedings of OMAE2005.\nMorooka, C. K. &amp; Tsukada, R. I. (2011). Dynamic behavior of pipelines and risers due to vortex-induced vibration in time domain, Marine Systems &amp; Ocean Technology 6: 17-26.\nNewmark, N. M. (1959). A method of computation for structural dynamics, Journal of Engineering Mechanics ASCE 85, EM3 pp. 67-94.\nOrcina (2013a). Orcaflex manual, http://www.orcina.com/SoftwareProducts/OrcaFlex/ Documentation/OrcaFlex.pdf. Acessado em Junho de 2013.\nOrcina (2013b). Orcaflex website, http://www.orcina.com/SoftwareProducts/OrcaFlex/. Acessado em Junho de 2013.\nPetrobras, T.-R. (2005). Anflex multilinhas - manual do usu\u00e1rio, vers\u00e3o 6.4.1 r5.5.\nSantos, I. H. F., Soares, L. P., Carvalho, F. &amp; Raposo, A. (2011). A collaborative vr visualization environment for offshore engineering projects, Proceedings of the 10th International Conference on Virtual Reality Continuum and Its Applications in Industry.\nSchroeder, W., Martin, K. &amp; Lorensen, B. (2006). The Visualization Toolkit, Kitware.\nSimantiras, P. &amp; Willis, N. (2001). Steel catenary risers - allegheny offshore viv monitoring campagin and large scale simulation of seabed interaction, Deep Offshore Technology International.\nTelea, A. C. (2008). Data Visualization, A K Peters, Ltd.\nZhu, H. J., Ou, Z. P., Lin, Y. H. &amp; Hu, F. F. (2011). Large eddy simulations of unsteady wakes behind riser in offshore deep water, Advanced Materials Research 268 - 2 70 : 787-792.\nZhu, H., Lin, Y., Jia, Q. &amp; Yang, X. (2010). Simulations of suppressive effect of viv on marine riser with splitter plates, ICCSIT, pp. 337-341.\nZienkiewicz, O. C. (1971). The Finite Element Method in Engineering Science, McGraw-Hill Publishing Company Limited.\nAp\u00eandice 1. X___________________________________\nQuestion\u00e1rio para Avalia\u00e7\u00e3ode Usabilidade\nSegue abaixo o question\u00f3rio elaborado para a avaliacao de usabilidade do sistema desenvolvido neste trabalho, conforme exposto na Se\u00e7\u00e3o 3.2.6 do Cap\u00f3tulo 3. Os resultados do teste s\u00e3o apresentados e discutidos na Se\u00e7ao 4.4 do Cap\u00f3tulo 4.\n1\t- Introdu\u00e7\u00e3o\nO presente documento \u00e9 um question\u00e1rio para avalia\u00e7\u00e3o do ambiente de simula\u00e7\u00e3o e visualiza\u00e7\u00e3o de riser desenvolvido como parte do projeto de mestrado de Rafael Guimar\u00e3es Ramos e orientado pelo Professor Jos\u00e9 Mario De Martino, da Faculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o da Unicamp.\nO ambiente desenvolvido tem a finalidade de auxiliar o engenheiro de petr\u00f3leo no estudo de riser, bem como no projeto e no diagn\u00f3stico de problemas deste equipamento. Atrav\u00e9s do programa, o usu\u00e1rio pode realizar uma simula\u00e7\u00e3o do comportamento do riser e visualizar os dados de simula\u00e7\u00e3o num ambiente virtual em gr\u00e1ficos 3D. Os par\u00e2metros de simula\u00e7\u00e3o podem ser ajustados durante a visualiza\u00e7\u00e3o e o novo comportamento do riser \u00e9 reproduzido imediatamente.\n2\t- Instru\u00e7\u00f5es de Uso do Ambiente\n2.1 Iniciando a simula\u00e7\u00e3o\nPara iniciar uma simula\u00e7\u00e3o, ap\u00f3s iniciar o programa, o usu\u00e1rio deve primeiro criar um modelo do riser, clicando em New -> Model -> e escolhendo o modelo (Figura 1). O modelo determina se o riser \u00e9 preso no topo (Collector) , no fundo (Tower) ou em ambos (TTR). Em seguida, \u00e9 necess\u00e1rio escolher o n\u00famero de elementos do modelo (Figura 2). Quanto maior o n\u00famero de elementos maior a precis\u00e3o nos resultados, por\u00e9m a execu\u00e7\u00e3o pode ficar lenta dependendo do hardware. Nas m\u00e1quinas testadas, o ambiente manteve bom desempenho at\u00e9 180 elementos.\nFigura 1, criando novo modelo (esquerda), e Figura 2(direita), escolhendo n\u00famero de elementos\nCriado um modelo, a janela obtida deve ser semelhante a da Figura 3. Um conjunto padr\u00e3o de par\u00e2metros \u00e9 utilizado para a simula\u00e7\u00e3o, que pode ser iniciada clicando no bot\u00e3o Play no painel e pausada pelo mesmo bot\u00e3o. Por fim, para melhor visualizar, ajuste as op\u00e7\u00f5es de visualiza\u00e7\u00e3o na aba Display. Como os deslocamentos do riser s\u00e3o muito pequenos em compara\u00e7\u00e3o seu comprimento, \u00e9 necess\u00e1rio ajustar a escala destas grandezas. Clicando-se no bot\u00e3o Auto Scale dentro da aba Display, a escala \u00e9 ajustada automaticamente para melhor visualizar o deslocamento do riser. Alternativamente, estas escalas podem ser ajustadas manualmente nesta aba. Ainda na aba Display, \u00e9 poss\u00edvel escolher qual dentre certos atributos da simula\u00e7\u00e3o \u00e9 visualizado por cores.\nNew\nS x\ni5 x\nDisplay Results\nParameters\nRiser\nTube\nRiser Ends\nBottom:\nTop Tension\n500,00\nPlatform\nOcean\nFlags\nApply\nInternal Flow | Floaters | Dampinr\n1\nFigura 3 - janela do ambiente, com ambiente de visualiza\u00e7\u00e3o \u00e0 esquerda e o painel \u00e0 direita. Os bot\u00f5es Apply e Play podem ser visto na parte inferior do painel.\nA qualquer momento, com a simula\u00e7\u00e3o rodando ou pausada, \u00e9 poss\u00edvel alterar os par\u00e2metros da simula\u00e7\u00e3o. Isto \u00e9 feito na aba Parameters. Os diferentes par\u00e2metros encontram-se agrupados em grupos e subgrupos dentro desta aba. Mais de um par\u00e2metro pode ser alterada de uma \u00fanica vez, mas \u00e9 necess\u00e1rio clicar no bot\u00e3o Apply para submeter os novos valores.\n2.2 Visualiza\u00e7\u00e3o da Simula\u00e7\u00e3o\nA visualiza\u00e7\u00e3o da simula\u00e7\u00e3o cont\u00e9m diversos elementos representando os diversos aspectos da simula\u00e7\u00e3o. Primeiramente, temos o riser, representado como um tubo no centro da cena, a embarca\u00e7\u00e3o, o fundo e a superf\u00edcie do mar e os flutuadores sobre o riser. H\u00e1 tamb\u00e9m diversos elementos visuais que representam grandezas f\u00edsicas da simula\u00e7\u00e3o. Al\u00e9m do tubo (que representa o riser) se movimentar, sobre ele s\u00e3o colocadas setas que representam a for\u00e7a de excita\u00e7\u00e3o e cores para representar diferentes grandezas (conforme escolhido na aba Display). Uma unica seta apontada para cima \u00e9 utilizada para exibir a tens\u00e3o de topo e curvas na cor verde s\u00e3o tra\u00e7adas para indicar o m\u00e1ximo deslocamento do riser. Por fim, setas dispostas um pouco afastadas do riser s\u00e3o utilizadas para representar a correnteza. A Figura 4 ilustra estes elementos.\nFigura 4 - Visualiza\u00e7\u00e3o da simula\u00e7\u00e3o\nSendo uma visualiza\u00e7\u00e3o 3D, \u00e9 poss\u00edvel interagir com a cena clicando e arrastando o mouse. Clicando e arrastando com o bot\u00e3o esquerdo, \u00e9 feita a rota\u00e7\u00e3o da cena; com o do meio, a transla\u00e7\u00e3o, e com o da direita, escala (a escala tamb\u00e9m pode ser feita rolando o bot\u00e3o do meio).\nOs valores num\u00e9ricos das for\u00e7as, deslocamentos e velocidades de cada elemento s\u00e3o exibidos na aba Results. Ao clicar sobre algum destes valores na tabela, uma esfera vermelha \u00e9 colocada sobre o riser na posi\u00e7\u00e3o do elemento correspondente. Inversamente, ao colocar o mouse sobre uma parte do riser e pressionar o bot\u00e3o 'p' do teclado, o elemento na posi\u00e7\u00e3o indicada \u00e9 selecionado e real\u00e7ado na tabela.\n3\t- Instru\u00e7\u00f5es para o Question\u00e1rio\nTendo lido as instru\u00e7\u00f5es, voc\u00ea ter\u00e1 at\u00e9 10 minutos para explorar livremente o programa e se familiarizar com seu uso. Crie uma simula\u00e7\u00e3o, inicie a anima\u00e7\u00e3o, altere par\u00e2metros, interaja com a visualiza\u00e7\u00e3o, conforme a instru\u00e7\u00f5es da se\u00e7\u00e3o 2; repita quantas vezes quiser. Em caso de d\u00favida, pergunte ao supervisor presente.\nAp\u00f3s a familiariza\u00e7\u00e3o, avise o supervisor e ent\u00e3o responda o question\u00e1rio presente na se\u00e7\u00e3o 4. No question\u00e1rio s\u00e3o feitas perguntas quanto a utilidade do programa como ferramenta para auxiliar o engenheiro de petr\u00f3leo tanto no estudo do comportamento de um riser, quanto para o projeto de risers ou diagn\u00f3stico de problemas. S\u00e3o feitas tamb\u00e9m perguntas quanto a qualidade da visualiza\u00e7\u00e3o e da interatividade do programa. Por fim, h\u00e1 perguntas comparando o ambiente aqui apresentado com o VRP, um outro ambiente para visualiza\u00e7\u00e3o de risers desenvolvido na Unicamp. Caso nunca tenha utilizado o programa ou n\u00e3o lembre do seu funcionamento, n\u00e3o \u00e9 necess\u00e1rio responder esta parte do question\u00e1rio.\nAs quest\u00f5es s\u00e3o todas objetivas, e voc\u00ea dever\u00e1 marcar a op\u00e7\u00e3o que mais se adequar a sua percep\u00e7\u00e3o. No quadro Justificativa, pede-se que, se poss\u00edvel, escreva sucintamente uma justificativa quanto \u00e0 op\u00e7\u00e3o marcada. Durante o question\u00e1rio, voc\u00ea pode utilizar o ambiente sempre que achar necess\u00e1rio, para confirmar suas impress\u00f5es antes de marcar a resposta.\n4\t- Question\u00e1rio. Responda dando notas de 1 a 5 e explique sucintamente o porqu\u00ea no quadro Justificativa\nCategoria Geral\n1) Para a finalidade de projeto de risers, o ambiente testado \u00e9 :\n(1)\tnada \u00fatil\n(2)\tpouco \u00fatil\n(3)\t\u00fatil\n(4)\tmuito \u00fatil\n(5)\textremamente \u00fatil\nJustificativa:\n2)\tPara a finalidade de an\u00e1lise do comportamento de risers, o ambiente testado \u00e9 :\n(1)\tnada \u00fatil\n(2)\tpouco \u00fatil\n(3)\t\u00fatil\n(4)\tmuito \u00fatil\n(5)\textremamente \u00fatil\nJustificativa:\n3)\tPara a finalidade de diagn\u00f3stico de problemas em risers, o ambiente testado \u00e9 :\n(1)\tnada \u00fatil\n(2)\tpouco \u00fatil\n(3)\t\u00fatil\n(4)\tmuito \u00fatil\n(5)\textremamente \u00fatil\nJustificativa:\n(1)\tnada adequado\n(2)\tpouco adequado\n(3)\tadequado\n(4)\tmuito adequado\n(5)\textremamente adequado\nJustificativa:\n5)\tPara a finalidade de visualizar individualmente cada resultado da simula\u00e7\u00e3o, o ambiente testado \u00e9:\n(1)\tnada adequado\n(2)\tpouco adequado\n(3)\tadequado\n(4)\tmuito adequado\n(5)\textremamente adequado\nJustificativa:\n6)\tQuanto \u00e0 facilidade de uso, o ambiente testado \u00e9:\n(1)\tmuito dif\u00edcil\n(2)\tdif\u00edcil\n(3)\tm\u00e9dio\n(4)\tf\u00e1cil\n(5)\tmuito f\u00e1cil\nJustificativa:\n7)\tQuanto \u00e0 apar\u00eancia do ambiente testado, ela \u00e9:\n(1)\tmuito ruim\n(2)\truim\n(3)\tm\u00e9dia\n(4)\tboa\n(5)\tmuito boa\nJustificativa:\nCategoria Visualiza\u00e7\u00e3o\n8)\tQuanto a representa\u00e7\u00e3o da simula\u00e7\u00e3o na forma de um ambiente de realidade virtual, ela \u00e9:\n(1)\tnada intuitiva\n(2)\tpouco intuitiva\n(3)\tintuitiva\n(4)\tmuito intuitiva\n(5)\textremamente intuitiva\nJustificativa:\n9)\tQuanto \u00e0 qualidade da anima\u00e7\u00e3o (fluidez), ela \u00e9:\n(1)\tmuito ruim\n(2)\truim\n(3)\tm\u00e9dia\n(4)\tboa\n(5)\tmuito boa\nCategoria Interatividade\n10)\tQuanto \u00e0 interatividade, ela \u00e9:\n(1)\tmuito limitada\n(2)\tlimitada\n(3)\tm\u00e9dia\n(4)\tboa\n(5)\tmuito boa\nJustificativa:\n11)\tQuanto ao tempo de resposta ao mudar par\u00e2metros, ele \u00e9:\n(1)\tmuito inadequado\n(2)\tinadequado\n(3)\tm\u00e9dio\n(4)\tadequado\n(5)\tmuito adequado\nJustificativa:\n12)\tQuanto \u00e0 organiza\u00e7\u00e3o do painel de controle, ela \u00e9:\n(1)\tmuito confusa\n(2)\tconfusa\n(3)\tm\u00e9dia\n(4)\tintuitiva\n(5)\tmuito intuitiva\nCategoria Compara\u00e7\u00e3o com o VRP (n\u00e3o responder caso nunca tenha utilizado o VRP)\n13)\tPara a finalidade de projeto de risers, o ambiente testado \u00e9 :\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\nJustificativa:\n14)\tPara a finalidade de an\u00e1lise do comportamento de risers, o ambiente testado \u00e9 :\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\nJustificativa:\n15)\tPara a finalidade de diagn\u00f3stico de problemas em risers, o ambiente testado \u00e9:\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\n16)\tPara a finalidade de visualizar o comportamento global do riser, o ambiente testado \u00e9:\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\nJustificativa:\n17)\tPara a finalidade de visualizar individualmente cada resultado da simula\u00e7\u00e3o, o ambiente testado \u00e9:\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\nJustificativa:\n18)\tQuanto \u00e0 facilidade de uso, o ambiente testado \u00e9:\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\n19)\tQuanto \u00e0 apar\u00eancia do ambiente testado, ela \u00e9:\n(1)\tmuito pior que o VRP\n(2)\tpior que o VRP\n(3)\tt\u00e3o bom quanto o VRP\n(4)\tmelhor que o VRP\n(5)\tmuito melhor que o VRP\nJustificativa:\nAp\u00eandice J\u2014J_______________________\nDocumenta\u00e7\u00e3odo C\u00f3digo do Sistema Desenvolvido\nSegue abaixo a documenta\u00e7ca\u00f5o do co\u00e9digo do sistema desenvolvido neste trabalho. O co\u00e9digo foi desenvolvido de modo a atender a metodologia apresentada no Cap\u00e9tulo 3 e uma visa\u00f5o geral do c\u00e9digo \u00e9 apresentada na Se\u00e7ao 4.2 do Capitulo 4. Na documenta\u00e7\u00f5o a seguir, maiores detalhes sa\u00f5o fornecidos.\nDocumenta\u00e7\u00e3o do C\u00f3digo do Ambiente de Visualiza\u00e7\u00e3o e Simula\u00e7\u00e3o de Risers\nEsta \u00e9 a documenta\u00e7\u00e3o do c\u00f3digo do Ambiente de Visualiza\u00e7\u00e3o e Simula\u00e7\u00e3o de Risers desenvolvido como parte do mestrado de Rafael Guimar\u00e3es Ramos e orientado pelo professor Jos\u00e9 Mario De Martino, da Faculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o (FEEC) da Unicamp. A documenta\u00e7\u00e3o descreve as classes do c\u00f3digo e seus m\u00e9todos, explicando o prop\u00f3sito de cada uma e como se relacionam entre si. Primeiramente, apresentamos as classes do Solver e, em segundo lugar, as classes do M\u00f3dulo de Visualiza\u00e7\u00e3o.\nDocumenta\u00e7\u00e3o do Solver\nTowerModel\t\tCollectorModel\t\t\tTTRModel\n1\t\t\t\t\t1\n\t\t\t\t\t\n3\nModel\t\tSolver\nfstaticAnalysis[engine\u00a1StaticAnalysis*) +freeVibrationAnalysis(engine:FreeVibrationAnalysis* +dynamicAnalysis(engine:DynamicAnalysis*)\t\tO )\tfstaticAnalysis{) +freeVibrationAnalysis() fdynamicAnalysis()\n\t\nFigura 1 - Diagrama de classe do Solver.\nA descri\u00e7\u00e3o das classes do Solver est\u00e1 dividida em grupos de acordo com o papel que cada uma cumpre na simula\u00e7\u00e3o. Na Figura 1 s\u00e3o mostradas as principais classes do Solver, como se relacionam e os grupos a que pertencem. As classes do grupo Analysis s\u00e3o aquelas respons\u00e1veis por executar a simula\u00e7\u00e3o propriamente dita, recebendo um objeto do tipo Riser como par\u00e2metro, realizando os c\u00e1lculos de acordo com estes valores e armazenando no mesmo objeto os resultados obtidos. As classes do grupo Riser, que inclui a classe Riser mencionada acima, s\u00e3o as classes que funcionam como cont\u00eainer de dados. O grupo Matrix consiste das classes que implementam as diversas matrizes utilizadas nos c\u00e1lculos da simula\u00e7\u00e3o (matriz de rigidez, massa, etc) e o grupo Force, similarmente, os vetores de for\u00e7a aplicados sobre o riser. Por fim, o grupo Outros cont\u00e9m as demais classes, como a classe Solver, que \u00e9 a classe principal deste m\u00f3dulo e encapsula as demais.\nMarca\u00e7\u00f5es: Algumas classes e m\u00e9todos encontram-se marcados na documenta\u00e7\u00e3o com um dos seguintes sinais.\n(R) Embora corretamente implementado, \u00e9 poss\u00edvel que exista uma forma melhor de organizar a implementa\u00e7\u00e3o do m\u00e9todo/classe, entretanto isto n\u00e3o foi explorado.\nGrupo Analysis\nAs classes do grupo Analysis implementam as tr\u00eas an\u00e1lises que constituem a simula\u00e7\u00e3o: an\u00e1lise est\u00e1tica (classe StaticAnalysis), de vibra\u00e7\u00f5es livres (FreeVibrationAnalysis) e din\u00e2mica (DynamicAnalysis). A forma de uso delas \u00e9 semelhante. Basta instanciar um objeto da classe e invocar o m\u00e9todo run dela, passando o ponteiro para um objeto de uma subclasse de Riser. A an\u00e1lise \u00e9 feita de acordo com os par\u00e2metros armazenados neste objeto e os resultados s\u00e3o nele escritos.\n==StaticAnalysis==\nClasse que implementa a an\u00e1lise est\u00e1tica. A forma de uso consiste em instanciar um objeto da classe e invocar o m\u00e9todo run, passando o ponteiro de um objeto de alguma subclasse de Riser (TTR, Collector ou Tower). Os par\u00e2metros da an\u00e1lise s\u00e3o tomados a partir deste argumento, e nele s\u00e3o escritos os resultados da an\u00e1lise.\nA an\u00e1lise est\u00e1tica considera o riser como uma estrutura em equil\u00edbrio est\u00e1tico represent\u00e1vel na forma K*X = F e visa calcular a posi\u00e7\u00e3o dos elementos do riser (vetor X) para o conjunto de cargas imposta sobre a estrutura (vetor F). O m\u00e9todo utilizado \u00e9 o m\u00e9todo de Galerkin, que iterativamente estima a matriz de rigidez (o K da equa\u00e7\u00e3o), que em parte depende da posi\u00e7\u00e3o dos elementos, para estimar um vetor X, o que leva a uma nova estima de K, e assim em diante.\nStaticAnalysis();\nConstrutor da classe. N\u00e3o faz nada de adicional.\nvoid run(TTR*);\nM\u00e9todo que executa a an\u00e1lise est\u00e1tica completa, inline e transversal, para TTR. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo TTR*.\nvoid run(Tower*);\nM\u00e9todo que executa a an\u00e1lise est\u00e1tica completa, inline e transversal, para Tower. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Tower*.\nvoid run(Collector*);\nM\u00e9todo que executa a an\u00e1lise est\u00e1tica completa, inline e transversal, para Collector. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Collector*.\nvoid run(Pipeline*);\n(P) M\u00e9todo que executa a an\u00e1lise est\u00e1tica completa, inline e transversal, para Pipeline. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Pipeline*.\nTemplate que executa a an\u00e1lise est\u00e1tica no plano inline. Chama initInline para inicializar a an\u00e1lise, iterativeInlineAlgol para o algoritmo principal e finalInline para finalizar. \u00c9 utilizado um template pois, embora a an\u00e1lise seja semelhante para todas as configura\u00e7\u00f5es, a matriz de rigidez criada varia conforme a configura\u00e7\u00e3o de riser.\ntemplate&lt;class SpecificRiserType> void transAnalysis(SpecificRiserType*);\nTemplate que executa a an\u00e1lise est\u00e1tica no plano transversal. Chama initTrans para inicializar a an\u00e1lise, iterativeTransAlgol para o algoritmo principal e finalTrans para finalizar. \u00c9 utilizado um template pois, embora a an\u00e1lise seja semelhante para todas as configura\u00e7\u00f5es, a matriz de rigidez criada varia conforme a configura\u00e7\u00e3o de riser.\ntemplate&lt;class SpecificRiserType> void initInline(SpecificRiserType*);\nTemplate que aloca as estruturas usadas na an\u00e1lise est\u00e1tica inline. \u00c9 utilizado um template pois, embora a inicializa\u00e7\u00e3o seja semelhante para todas as configura\u00e7\u00f5es, a matriz de rigidez criada varia conforme a configura\u00e7\u00e3o de riser.\nvoid finalInline();\nDesaloca as estruturas criadas na an\u00e1lise est\u00e1tica inline.\ntemplate&lt;class SpecificRiserType> void iterativeInlineAlgol(SpecificRiserType*);\nRealiza o algoritmo do m\u00e9todo de Galerkin para o plano inline. \u00c9 utilizado um template pois, embora o m\u00e9todo seja semelhante para todas as configura\u00e7\u00f5es, a matriz de rigidez criada varia conforme a configura\u00e7\u00e3o de riser.\ntemplate&lt;class SpecificRiserType> void initTrans(SpecificRiserType*);\nTemplate que aloca as estruturas usadas na an\u00e1lise est\u00e1tica transversal. \u00c9 utilizado um template pois, embora a inicializa\u00e7\u00e3o seja semelhante para todas as configura\u00e7\u00f5es, a matriz de rigidez criada varia conforme a configura\u00e7\u00e3o de riser.\nvoid finalTrans();\nDesaloca as estruturas criadas na an\u00e1lise est\u00e1tica transversal.\ntemplate&lt;class SpecificRiserType> void iterativeTransAlgol(SpecificRiserType*);\nRealiza o algoritmo do m\u00e9todo de Galerkin para o plano transversal. \u00c9 utilizado um template pois, embora o m\u00e9todo seja semelhante para todas as configura\u00e7\u00f5es, a matriz de rigidez criada varia conforme a configura\u00e7\u00e3o de riser.\nvoid tension_sr(Riser*);\nCalcula a tens\u00e3o ao longo do riser. Aceita a ponteiro para classe Riser, mas \u00e9 efetivamente utilizado apenas pelas subclasses Tower e TTR.\nvoid tension_sr(Collector*);\nvoid tension_sr(Pipeline*);\n(P) Calcula a tens\u00e3o ao longo do riser, espec\u00edfico para configura\u00e7\u00e3o Pipeline.\nvoid desbf_stat();\nFun\u00e7\u00e3o auxiliar chamada pelos m\u00e9todos iterativeInlineAlgol e iterativeTransAlgol,\n==FreeVibrationAnalysis==\nClasse que implementa a an\u00e1lise de vibra\u00e7\u00f5es livres. A forma de uso consiste em instanciar um objeto da classe e invocar o m\u00e9todo run, passando o ponteiro de um objeto de alguma subclasse de Riser (TTR, Collector ou Tower). Os par\u00e2metros da an\u00e1lise s\u00e3o tomados a partir deste argumento, e nele s\u00e3o escritos os resultados da an\u00e1lise.\nA an\u00e1lise de vibra\u00e7\u00f5es livres considera o riser como uma estrutura em movimento oscilat\u00f3rio n\u00e3o amortecido sem cargas aplicadas sobre a estrutura, represent\u00e1vel na forma K*X + M*X\" = 0. Tal equa\u00e7\u00e3o leva a outra, (MA-1*K-wA2*I)*Y = 0, onde X = Y*eAiwt e w = (w1,w2,...,wn), as frequ\u00eancias naturais do sistema. A equa\u00e7\u00e3o \u00e9 solucionada encontrando os autovalores do sistema, wA2.\nFreeVibrationAnalysis();\nConstrutor da classe. N\u00e3o faz nada de adicional.\nvoid run(TTR*);\nM\u00e9todo que executa a an\u00e1lise de vibra\u00e7\u00f5es livres completa, inline e transversal, para TTR. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo TTR*.\nvoid run(Tower*);\nM\u00e9todo que executa a an\u00e1lise de vibra\u00e7\u00f5es livres completa, inline e transversal, para Tower. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Tower*.\nvoid run(Collector*);\nM\u00e9todo que executa a an\u00e1lise de vibra\u00e7\u00f5es livres completa, inline e transversal, para Collector. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Collector*.\nvoid run(Pipeline*);\n(P) M\u00e9todo que executa a an\u00e1lise de vibra\u00e7\u00f5es livres completa, inline e transversal, para Pipeline. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Pipeline*.\nRealiza a an\u00e1lise de vibra\u00e7\u00f5es livres no plano inline. Ap\u00f3s alocar as matrizes de massa e rigidez, elimina um grau de liberdade das matrizes originais(reduce), completa com os elementos sim\u00e9tricos (simetry), realiza a decomposi\u00e7\u00e3o de cholesky (choleskyInline) gerando a matriz para a qual s\u00e3o calculados os autovalores (eigen). Por fim, desaloca as estruturas.\ntemplate&lt;class SpecificRiserType> void transAnalysis(SpecificRiserType*);\nRealiza a an\u00e1lise de vibra\u00e7\u00f5es livres no plano transversal. Ap\u00f3s alocar as matrizes de massa e rigidez, elimina um grau de liberdade das matrizes originais(reduce), completa com os elementos sim\u00e9tricos (simetry), realiza a decomposi\u00e7\u00e3o de cholesky (choleskyInline) gerando a matriz para a qual s\u00e3o calculados os autovalores (eigen). Por fim, desaloca as estruturas.\nvoid elem(TTR*,int*);\nFun\u00e7\u00e3o que auxilia na redu\u00e7\u00e3o dos graus de liberdade.\nvoid elem(Tower*,int*);\nFun\u00e7\u00e3o que auxilia na redu\u00e7\u00e3o dos graus de liberdade.\nvoid elem(Collector*,int*);\nFun\u00e7\u00e3o que auxilia na redu\u00e7\u00e3o dos graus de liberdade.\nvoid elem(Pipeline*,int*);\n(P) Fun\u00e7\u00e3o que auxilia na redu\u00e7\u00e3o dos graus de liberdade.\ntemplate&lt;class SpecificRiserType> void reduce(SpecificRiserType*);\nReduz os graus de liberdade das matrizes de massa e rigidez, eliminando rota\u00e7\u00e3o e mantendo apenas transla\u00e7\u00e3o inline e transversal.\nvoid simetry(Riser*);\nGera a vers\u00e3o sim\u00e9trica das matrizes reduzidas.\nvoid choleskyInline(Riser*);\nUsando a decomposi\u00e7\u00e3o de Cholesky para invers\u00e3o de matrizes, o m\u00e9todo calcula a matriz A = MA-1*K (M e K com dimens\u00f5es reduzidas e M sim\u00e9trico) da qual ser\u00e3o calculados os autovalores. O m\u00e9todo de Cholesky \u00e9 usado pois gera uma matriz L tal que M = L*Lc (Lc sendo a transposta conjugada de L) que, por ser triangular, \u00e9 mais f\u00e1cil de ser invertida.\nvoid eigen(Riser*);\nCalcula os autovalores da matriz A = (MA-1)*K. Usa fun\u00e7\u00f5es da biblioteca CLAPACK para isso.\n==DynamicAnalysis==\nA an\u00e1lise din\u00e2mica considera o riser como uma estrutura em movimento oscilat\u00f3rio amortecido com cargas aplicadas sobre a estrutura, represent\u00e1vel na forma K*X + D*X' + M*X\" = F. A matriz de amortecimento D \u00e9 calculada a partir das matrizes M e K e das frequ\u00eancias naturais, enquanto o F \u00e9 em parte constante e em parte vari\u00e1vel no tempo. A posi\u00e7\u00e3o X do riser \u00e9 calculada nesta an\u00e1lise para cada instante de tempo, atrav\u00e9s do m\u00e9todo de Newmark-Beta.\nDynamicAnalysis();\nConstrutor da classe. Inicializa alguns atributos do objeto.\nvoid run(TTR*);\nM\u00e9todo que executa a an\u00e1lise din\u00e2mica completa, inline e transversal, para TTR. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo TTR*.\nvoid run(Tower*);\nM\u00e9todo que executa a an\u00e1lise din\u00e2mica completa, inline e transversal, para Tower. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Tower*.\nvoid run(Collector*);\nM\u00e9todo que executa a an\u00e1lise din\u00e2mica completa, inline e transversal, para Collector. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Collector*.\nvoid run(Pipeline*);\n(P) M\u00e9todo que executa a an\u00e1lise din\u00e2mica completa, inline e transversal, para Pipeline. Chama o template do m\u00e9todo inlineAnalysis e transAnalysis para o tipo Pipeline*.\nvoid reset(Riser*);\nReinicia a an\u00e1lise din\u00e2mica, colocando o riser na sua posi\u00e7\u00e3o inicial.\nvoid deleteMatrixes();\nDesaloca matrizes utilizadas na an\u00e1lise din\u00e2mica.\nReal time();\nRetorna o instante da simula\u00e7\u00e3o (n\u00e3o o tempo real que a simula\u00e7\u00e3o durou at\u00e9 o momento, mas o tempo no modelo de simula\u00e7\u00e3o).\nCria as matrizes utilizadas na an\u00e1lise din\u00e2mica. \u00c9 utilizado um template pois embora este m\u00e9todo em si n\u00e3o varie conforme a configura\u00e7\u00e3o de riser, as matrizes criadas pedem um tipo espec\u00edfico de riser.\ntemplate&lt;class SpecificRiserType> void iterativeAlgol(SpecificRiserType*);\nExecuta o algoritmo principal da an\u00e1lise din\u00e2mica. \u00c9 utilizado um template pois embora este m\u00e9todo em si n\u00e3o varie conforme a configura\u00e7\u00e3o de riser, as matrizes utilizadas pedem um tipo espec\u00edfico de riser. Chama inlineTimeAnalysis e transTimeAnalysis, que executam a an\u00e1lise para cada plano, inline e transversal.\nvoid initInlineTimeAnalysis(Riser*);\nInicializa a an\u00e1lise din\u00e2mica no plano inline, gerando as for\u00e7as nesta dire\u00e7\u00e3o.\nvoid initTransTimeAnalysis(Riser*);\nInicializa a an\u00e1lise din\u00e2mica no plano transversal, gerando as for\u00e7as nesta dire\u00e7\u00e3o.\ntemplate&lt;class SpecificRiserType> void inlineTimeAnalysis(SpecificRiserType*);\nRealiza a an\u00e1lise din\u00e2mica no plano inline.\ntemplate&lt;class SpecificRiserType> void transTimeAnalysis(SpecificRiserType*); Realiza a an\u00e1lise din\u00e2mica no plano transversal.\nvoid storePreviousValues(Riser*);\nArmazena os valores de deslocamento, velocidade e for\u00e7a atuais para poderem ser utilizados no pr\u00f3ximo time step da an\u00e1lise din\u00e2mica como \"valores anteriores\".\nvoid inLoad(Riser*,Real*,bool);\nCalcula as cargas sobre o riser no plano inline.\nUtiliza o generate de InlineForce.\nvoid trLoad(Riser*,Real*,bool);\nCalcula as cargas sobre o riser\nno plano transversal.\nUtiliza o generate de TransForce.\nGrupo Riser\nAs classes do grupo Riser implementam as classes que armazenam os par\u00e2metros e resultados da simula\u00e7\u00e3o. A classe Riser \u00e9 a classe principal deste grupo, contendo em si os diversos dados do riser como di\u00e2metro interno e externo, resist\u00eancia do material (estes, par\u00e2metros da simula\u00e7\u00e3o), bem como deslocamento, velocidade e for\u00e7a sobre os elementos do riser (resultados da simula\u00e7\u00e3o). Certos atributos de Riser s\u00e3o representados pelas outras classes do grupo, como Environment (para os dados correspondentes ao ambiente) e Platform (para dados da plataforma). A classe Riser possui quatro subclasses, TTR, Tower, Collector e Pipeline (cuja implementa\u00e7\u00e3o foi descontinuada por estar fora do escopo do trabalho). Embora\n==Riser==\nA classe Riser \u00e9 o principal cont\u00eainer de dados do Solver, contendo os par\u00e2metros e resultados da simula\u00e7\u00e3o. Suas subclasses TTR, Collector e Tower (e Pipeline, cuja implementa\u00e7\u00e3o foi descontinuada por estar fora do escopo do trabalho) definem os tipos espec\u00edficos de riser tratados na simula\u00e7\u00e3o. Objetos dessas classes s\u00e3o passados (por ponteiro) como argumento dos m\u00e9todos run das classes StaticAnalysis, FreeVibrationAnalysis e DynamicAnalysis.\nDentre os dados contidos na classe temos informa\u00e7\u00f5es do riser, como os di\u00e2metros interno e externo (inDiam e exDiam), a densidade do material (matDensity) e diversos outros. Cont\u00e9m tamb\u00e9m objetos que representam dados do ambiente (Environment), da plataforma (Platform), do flu\u00eddo interno (InternalFlow) e dos flutuadores ao longo do riser (Floaters).\nMuitos dos dados, em geral os vetores com um item para cada elemento do riser, tem seus valores gerados a partir de outros dados contidos em Riser. \u00c9 o caso, por exemplo, dos coeficiente de arrasto (CD) e massa adicional (CA), que s\u00e3o dados inicialmente para alguns pontos e interpolados para cada elemento. O m\u00e9todo enrichParameters \u00e9 respons\u00e1vel por esta etapa, de inicializar atributos de Riser a partir do valor de outros atributos do mesmo objeto (processo referido como \u201cenriquecimento\u201d dos dados).\nRiser(int,int);\nConstrutor da classe. Aloca os vetores utilizados.\n~Riser();\nDestrutor da classe. Desaloca os vetores criados antes.\nvoid defaultParameters();\n(R) Atribui um conjunto de par\u00e2metros padr\u00e3o. Ser\u00e1 removida.\nvoid enrichParameters();\nInicializa dados de Riser a partir de outros atributos do mesmo objeto. Na realidade, apenas chama outras fun\u00e7\u00f5es mais espec\u00edficas que fazem isto.\nvoid _riser();\n\"Enriquece\" dados espec\u00edficos do riser, como dimens\u00f5es dele (_dimensions), flutuadores (_floaters) e fluxo interno (_flow).\nvoid _platform();\n\"Enriquece\" dados ligados a plataforma.\nvoid _environment();\n\"Enriquece\" dados ligados ao ambiente, calculando a press\u00e3o hidrost\u00e1tica externa e chamando _current para correnteza, _waves para onda e _drag para as constantes hidrodin\u00e2micas.\nvoid _weights();\n\"Enriquece\" dados ligados ao peso do riser. Diversos pesos m\u00e9dios por elemento s\u00e3o calculados, como peso m\u00e9dio acima da \u00e1gua, peso abaixo, peso apenas da parede do riser e peso com flutuador.\nvoid _dimensions();\n\"Enriquece\" dados ligados as dimens\u00f5es, calculando o comprimento total acima e abaixo do n\u00edvel do mar e a inclina\u00e7\u00e3o do riser.\nvoid _floaters();\nInterpola para cada elemento do riser os dados dos flutuadores\nvoid _flow(Real*);\n\"Enriquece\" dados ligados ao fluxo interno, chamando a fun\u00e7\u00e3o apropriada conforme o tipo de fluido interno.\nvoid flowoil();\nChamado por _fLow, no caso de fluxo para apenas \u00f3leo.\nvoid flowog();\nChamado por _fLow, no caso de fluxo para \u00f3leo e g\u00e1s.\nvoid flownone();\nChamado por _fLow, no caso sem fluxo.\nvoid _waves();\n\"Enriquece\" dados referentes as ondas.\nvoid _current();\n\"Enriquece\" dados referentes a correnteza, interpolando para cada elemento o perfil de correnteza.\nvoid _drag();\nvoid interpolate(Profile*,Real*);\nUtilizado para interpolar as constantes hidrodin\u00e2micas (CA e CD).\nReal elemLength(int);\nRetorna o tamanho do elemento dado o \u00edndice dele.\nReal wall(int);\nRetorna o peso da parede do elemento dado o \u00edndice dele.\nReal floaters_effect(int);\nRetorna o peso do flutuador naquele elemento dado o \u00edndice dele.\nReal buoyancy(int);\nRetorna o efeito do empuxo no elemento dado o \u00edndice dele.\nReal mass(int);\nRetorna a massa do elemento dado o \u00edndice dele.\nReal weight(int);\nRetorna o peso do elemento, contando flutuador e efeito do empuxo, dado o \u00edndice do elemento.\nReal addMassInline(int);\nRetorna a massa adicional inline do elemento dado o \u00edndice dele.\nReal addMassTrans(int);\nRetorna a massa adicional transversal do elemento dado o \u00edndice dele.\nvoid print(int);\nImprime dados do riser. Apenas para debug.\n==TTR, Collector, Tower e Pipeline==\nApenas definem as classes, sem conter diferen\u00e7as nos m\u00e9todos.\n==Floater==\nA classe FLoater representa os flutuadores presos ao riser. N\u00e3o \u00e9 necess\u00e1rio um objeto desta classe para cada flutuador, mas um \u00fanico j\u00e1 \u00e9 respons\u00e1vel por armazenar todos os dados dos flutuadores (Riser possui apenas uma inst\u00e2ncia desta classe). Os vetores atributos desta classe tem tamanho igual ao n\u00famero de flutuadores, cada elemento do vetor correspondendo a um flutuador. Para o k-\u00e9simo flutuador, a posi\u00e7\u00e3o k do vetor first indica qual o primeiro elemento de riser que cont\u00e9m este flutuador, e Last o \u00faltimo. O vetor density guarda a densidade do flutuador e exDiam o di\u00e2metro externo. Estes vetores s\u00e3o alocados pelo m\u00e9todo init, cujo argumento \u00e9 o n\u00famero de flutuadores, mas os vetores devem ser preenchidos diretamente.\nvoid init(int);\nM\u00e9todo utilizado para indicar o n\u00famero de flutuadores, alocando mem\u00f3ria para eles.\nFloater();\nConstrutor da classe. Inicializa atributos.\n==Platform=\nClasse que cont\u00eam informa\u00e7\u00f5es sobre a plataforma.\nvoid defvals();\nInicializa um conjunto padr\u00e3o de par\u00e2metros.\n==Wave==\nClasse que cont\u00eam informa\u00e7\u00f5es sobre as ondas.\nvoid defvals();\nInicializa um conjunto padr\u00e3o de par\u00e2metros.\n==Current==\nClasse que cont\u00eam informa\u00e7\u00f5es sobre o perfil de correnteza. O perfil \u00e9 dado em pontos chave que depois s\u00e3o interpolados linearmente pela fun\u00e7\u00e3o _current de Riser. O vetor depth cont\u00e9m a profundidade de cada um destes pontos e current a correnteza. \u00c9 necess\u00e1rio utilizar\nCurrent();\nConstrutor da classe. Inicializa algumas vari\u00e1veis.\nvoid defvals();\nInicializa um conjunto padr\u00e3o de par\u00e2metros.\nvoid initProfile(int);\nAloca um perfil de correnteza com o n\u00famero de pontos especificado no argumento.\n==Profile==\nClasse utilizada para guardar a informa\u00e7\u00e3o do perfil de varia\u00e7\u00e3o dos coeficientes de arrasto e de massa adicional (CA e CD, tanto inline quanto transversal). Basta instanciar a classe e utilizar addPoint para incluir um novo ponto, passando a posi\u00e7\u00e3o e o valor do coeficiente. O m\u00e9todo _drag de Riser posteriormente utiliza estes dados para interpolar linearmente os coeficientes para cada elemento do riser.\nProfile();\nConstrutor da classe. Inicializa atributos.\nvoid reset();\nRemove todos os pontos do perfil.\nvoid addPoint(Real c,Real v);\nAdiciona um ponto, passando posi\u00e7\u00e3o e valor do coeficiente.\n==Environment==\nClasse que representa os dados do ambiente. Cont\u00e9m outras classes mais espec\u00edficas como Current e Wave.\nvoid defvals();\nInicializa um conjunto padr\u00e3o de par\u00e2metros.\n==InternalFlow==\nClasse que representa o fluxo interno no riser, que pode ser de \u00f3leo, \u00f3leo e g\u00e1s, ou nenhum.\nOs m\u00e9todos da classe s\u00e3o utilizados pelos m\u00e9todos flowoil, flowog e flownone da classe Riser.\nGrupo Matrix\n(R) As classes do grupo Matrix implementam as diversas matrizes utilizadas na an\u00e1lises da simula\u00e7\u00e3o. Como os elementos concentram-se em faixas bem definidas das matrizes convencionais, nestas classes s\u00e3o linearizados e armazenados em vetores unidimensionais para poupar mem\u00f3ria. As classes MyMatrix e tamb\u00e9m as derivadas desta, AsymmetricMatrix e SymmetricMatrix, implementam as funcionalidades b\u00e1sicas deste tipo de matriz. As demais implementam matrizes mais especificas, como as de massa, rigidez e amortecimento, sendo que estas mesmas possuem m\u00faltiplas vers\u00f5es (Lumped x consistente, inline x transversal).\nO conjunto de classes definidas pode ser reorganizado, talvez definindo uma classe base para matrizes na forma Lumped e na forma consistente e passando os m\u00e9todos decompGauss e decompGauss2 para elas.\n==MyMatrix==\nClasse base para as demais matrizes, implementando diversos m\u00e9todos utilizados por elas. Ao inv\u00e9s de armazenar os elementos numa matriz comum (duas dimens\u00f5es), os dados s\u00e3o linearizados e armazenados num vetor unidimensional, j\u00e1 que os valores diferentes de zero concentram-se apenas em uma faixa bem definida da matriz original. Assim, o acesso aos elementos da matriz \u00e9 feito pelos m\u00e9todos insertVaLue, addVaLue e getVaLue. O mapeamento para a forma linear \u00e9 feito pelo m\u00e9todo virtual map, que \u00e9 nesta classe apenas definido, sendo implementado nas subclasse AsymmetricMatrix e SymmetricMatrix.\nA classe disp\u00f5e de tr\u00eas construtores. Um aceita tr\u00eas par\u00e2metros: tamanho total do vetor, dimens\u00e3o original e tamanho da banda onde concentram-se os elementos. Outro aceita apenas dimens\u00e3o e banda, sendo o tamanho calculado como o produto deles. Um terceiro construtor n\u00e3o pede argumentos mas tamb\u00e9m n\u00e3o inicializa nenhum destes atributos nem aloca o vetor.\nPor fim, temos os m\u00e9todos decompGauss e decompGauss2. Os m\u00e9todos realizam a decomposi\u00e7\u00e3o de\nGauss da matriz, com a diferen\u00e7a de que o primeiro \u00e9 utilizado para matrizes na forma consistente e o segundo na forma lumped.\nMyMatrix();\nConstrutor para classe, n\u00e3o realiza nada.\nMyMatrix(int,int,int);\nConstrutor que recebe tamanho do vetor, dimens\u00e3o da matriz original e banda da matriz, alocando o vetor.\nMyMatrix(int,int);\n~MyMatrix();\nDestrutor da classe, desaloca vetor.\nbool insertValue(Real,int,int);\nInsere valor na posi\u00e7\u00e3o dada (internamente, converte o par de \u00edndices para o \u00edndice linearizado.\nbool addValue(Real,int,int);\nAdiciona valor na posi\u00e7\u00e3o dada (internamente, converte o par de \u00edndices para o \u00edndice linearizado.\nReal getValue(int,int);\nRetorna o valor da posi\u00e7\u00e3o dada (internamente, converte o par de \u00edndices para o \u00edndice linearizado.\nvoid decompGauss(Real*,Real*);\n(R) Realiza decomposi\u00e7\u00e3o gaussiana para matrizes da forma consistente. Ideal seria mover este m\u00e9todo para outra classe, talvez alguma nova que defina uma consistente gen\u00e9rica.\nvoid decompGauss2(Real*,Real*);\n(R) Realiza decomposi\u00e7\u00e3o gaussiana para matrizes da forma lumped. Ideal seria mover este m\u00e9todo para outra classe, talvez alguma nova que defina uma lumped gen\u00e9rica.\nvoid print(bool);\nImprime informa\u00e7\u00f5es sobre a matriz. Para debug.\n==SymmetricMatrix==\nSemelhante a classe base MyMatrix, acrescenta apenas a implementa\u00e7\u00e3o do m\u00e9todo map na vers\u00e3o para matriz sim\u00e9trica.\n==AsymmetricMatrix==\nSemelhante a classe base MyMatrix, acrescenta apenas a implementa\u00e7\u00e3o do m\u00e9todo map na vers\u00e3o para matriz assim\u00e9trica.\n==StiffnessMatrix==\nImplementa a matriz de rigidez na forma consistente, sendo utilizada na an\u00e1lise est\u00e1tica e na de vibra\u00e7\u00f5es livres. Nos construtores \u00e9 feita a aloca\u00e7\u00e3o da mem\u00f3ria do vetor que guarda os dados da matriz e de outras estruturas internas que variam conforme o tipo de riser. O\nStiffnessMatrix(TTR*);\nConstrutor para configura\u00e7\u00e3o TTR. Aloca vetor e outras estruturas.\nStiffnessMatrix(Tower*);\nConstrutor para configura\u00e7\u00e3o Tower. Aloca vetor e outras estruturas.\nStiffnessMatrix(Collector*);\nConstrutor para configura\u00e7\u00e3o Collector. Aloca vetor e outras estruturas.\nStiffnessMatrix(Pipeline*);\n(P) Construtor para configura\u00e7\u00e3o Pipeline. Aloca vetor e outras estruturas.\n~StiffnessMatrix();\nDestrutor da classe, desaloca estruturas.\nvirtual Real* genMatrix(TTR*);\nCalcula o valor dos elementos da matriz para a configura\u00e7\u00e3o TTR.\nvirtual Real* genMatrix(Tower*);\nCalcula o valor dos elementos da matriz para a configura\u00e7\u00e3o Tower.\nvirtual Real* genMatrix(Collector*);\nCalcula o valor dos elementos da matriz para a configura\u00e7\u00e3o Collector.\nvirtual Real* genMatrix(Pipeline*);\n(P) Calcula o valor dos elementos da matriz para a configura\u00e7\u00e3o Pipeline.\ntemplate&lt;class SpecificRiserType> void assembleMatrix(SpecificRiserType*);\nAlgoritmo principal do c\u00e1lculo da matriz. \u00c9 chamado por alguma das vers\u00f5es de genMatrix. \u00c9 um template pois o algoritmo n\u00e3o varia conforme o tipo de riser, mas geomMatrix e elastMatix sim.\nvoid geomMatrix(Riser*,int,Real[6][6]);\nCalcula um setor 6x6 do componente geom\u00e9trico da matriz. Utilizado para configura\u00e7\u00f5es diferentes de Pipeline.\nvoid geomMatrix(Pipeline*,int,Real[6][6]);\n(P) Calcula um setor 6x6 do componente geom\u00e9trico da matriz. Utilizado para configura\u00e7\u00e3o Pipeline.\nvoid elastMatrix(Riser*,int,Real[6][6]);\nCalcula um setor 6x6 do componente el\u00e1stico da matriz. Utilizado para configura\u00e7\u00f5es diferentes de Pipeline.\nvoid elastMatrix(Pipeline*,int,Real[6][6]);\nCalcula um setor 6x6 do componente el\u00e1stico da matriz. Utilizado para configura\u00e7\u00e3o Pipeline.\n==LumpedStiffnessMatrix==\nImplementa a matriz de rigidez na forma lumped, sendo utilizada na an\u00e1lise din\u00e2mica. No construtor \u00e9 feita a aloca\u00e7\u00e3o da mem\u00f3ria do vetor que guarda os dados da matriz. O m\u00e9todo genMatrix calcula os valores dos elementos da matriz a partir da vers\u00e3o consistente. Caso se chame o m\u00e9todo genMatrix sem passar o segundo argumento (que seria a matriz consistente), o m\u00e9todo cria a matriz consistente antes de prosseguir.\nvirtual Real* genMatrix(TTR*);\nGera a matriz para a configura\u00e7\u00e3o TTR. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(TTR*,StiffnessMatrix*).\nvirtual Real* genMatrix(Tower*);\nGera a matriz para a configura\u00e7\u00e3o Tower. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(Tower*,StiffnessMatrix*).\nvirtual Real* genMatrix(Collector*);\nGera a matriz para a configura\u00e7\u00e3o CoLLector. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(CoLLector*,StiffnessMatrix*).\nvirtual Real* genMatrix(Pipeline*);\n(P) Gera a matriz para a configura\u00e7\u00e3o PipeLine. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(PipeLine*,StiffnessMatrix*).\nReal* genMatrix(TTR*,StiffnessMatrix*);\nCalcula para TTR os valores da matriz de rigidez na forma Lumped a partir da forma consistente.\nReal* genMatrix(Tower*,StiffnessMatrix*);\nCalcula para Tower os valores da matriz de rigidez na forma Lumped a partir da forma consistente.\nReal* genMatrix(Collector*,StiffnessMatrix*);\nCalcula para CoLLector os valores da matriz de rigidez na forma Lumped a partir da forma consistente.\nReal* genMatrix(Pipeline*,StiffnessMatrix*);\n(P) Calcula para Pipeline os valores da matriz de rigidez na forma Lumped a partir da forma consistente.\ntemplate&lt;class SpecificRiserType> void assembleMatrix(SpecificRiserType*,StiffnessMatrix*); Algoritmo principal que calcula a matriz. Chamado por genMatrix e utiliza os m\u00e9todos que vem abaixo.\n==MassMatrix==\nImplementa a matriz de massa na forma consistente, sendo utilizada na an\u00e1lise de vibra\u00e7\u00f5es livres. Nos construtores \u00e9 feita a aloca\u00e7\u00e3o da mem\u00f3ria do vetor que guarda os dados da matriz e de outras estruturas internas que variam conforme o tipo de riser. Os m\u00e9todos genMatrix e assembLeMatrix calculam os valores dos elementos da matriz, utilizando o m\u00e9todo auxiliar LocaLMatrix, que calcula um setor 6x6 da matriz. Este m\u00e9todo \u00e9 apenas virtual, sendo implementado nas subclasses InLineMassMatrix e TransMassMatrix.\n==InlineMassMatrix==\nVer\u00e3o inLine da classe base MassMatrix, acrescentando apenas a implementa\u00e7\u00e3o do m\u00e9todo LocaLMatrix para o caso inLine.\n==TransMassMatrix==\nVer\u00e3o transversal da classe base MassMatrix, acrescentando apenas a implementa\u00e7\u00e3o do m\u00e9todo localMatrix para o caso transversal.\n==LumpedMassMatrix==\nImplementa a matriz de massa na forma lumped, sendo utilizada na an\u00e1lise din\u00e2mica. Nos construtores \u00e9 feita a aloca\u00e7\u00e3o da mem\u00f3ria do vetor que guarda os dados da matriz e de outras estruturas internas que variam conforme o tipo de riser. Os m\u00e9todos genMatrix e assembleMatrix calculam os valores dos elementos da matriz, utilizando o m\u00e9todo auxiliar localMatrix, que calcula um setor 2x2 da matriz. Este m\u00e9todo \u00e9 apenas virtual, sendo implementado nas subclasses InlineMassMatrix e TransMassMatrix.\n==LumpedInlineMassMatrix==\nVer\u00e3o inline da classe base LumpedMassMatrix, acrescentando apenas a implementa\u00e7\u00e3o do m\u00e9todo localMatrix para o caso inline.\n==LumpedTransMassMatrix==\nVer\u00e3o transversal da classe base LumpedMassMatrix, acrescentando apenas a implementa\u00e7\u00e3o do m\u00e9todo localMatrix para o caso transversal.\n==DampingMatrix, InlineDampingMatrix e TransDampingMatrix==\nImplementam a matriz de amortecimento, utilizada na an\u00e1lise din\u00e2mica, sendo a primeira a base para as outras duas, espec\u00edficas para o caso inline e transversal, respectivamente. O construtor apenas aloca a mem\u00f3ria interna necess\u00e1ria e genMatrix gera a matriz a partir das matrizes de massa e rigidez.\n==MATR1, inlineMATR1, transMATR1, MATR2, inlineMATR2, transMATR2, MATR3, inlineMATR3 e transMATR3==\nMatrizes utilizadas na an\u00e1lise din\u00e2mica, s\u00e3o calculadas a partir das matrizes de massa, rigidez e amortecimento.\nGrupo Force\n==Force==\nClasse base que representa as for\u00e7as agindo sobre o riser. O construtor aloca o vetor interno de acordo com o n\u00famero de elementos passado como par\u00e2metro. O m\u00e9todo generate, que preenche o vetor com os valores apropriados, \u00e9 apenas declarado, sendo implementado mas subclasses.\n==InlineForce==\nEsta subclasse de Force implementa a for\u00e7a no plano inline, sendo utilizada na an\u00e1lise\n==TransForce==\nEsta subclasse de Force implementa a for\u00e7a no plano transversal, sendo utilizada na an\u00e1lise din\u00e2mica. O m\u00e9todo generate invoca os m\u00e9todos viv, drag, added, que aplicam as diferentes cargas (vindo da viv, arrasto, massa adicional).\n==StaticForce==\nEsta subclasse de Force implementa a for\u00e7a sobre o riser na an\u00e1lise est\u00e1tica. Serve de base para outras duas classes mais espec\u00edficas, InlineStaticForce e TransStaticForce.\n==StaticInlineForce==\nImplementa a for\u00e7a inline para a an\u00e1lise est\u00e1tica. O m\u00e9todo generate calcula os valores apropriados.\n==StaticTransForce==\nImplementa a for\u00e7a transversal para a an\u00e1lise est\u00e1tica. O m\u00e9todo generate calcula os valores apropriados.\n==Load==\nUtilizada na an\u00e1lise est\u00e1tica, encapsula a classe StaticForce e a utiliza para calcular o vetor Q. O m\u00e9todo gen calcula este vetor, chamando por sua vez Load.\nOutros\n==Solver==\nA classe Solver \u00e9 a classe principal do simulador e \u00e9 com ela principalmente que o M\u00f3dulo de Visualiza\u00e7\u00e3o interage. O m\u00e9todo newModel cria um novo modelo de simula\u00e7\u00e3o, recebendo como par\u00e2metro o tipo de riser (na forma de string) e o n\u00famero de elementos. Com um modelo criado, \u00e9 poss\u00edvel executar as an\u00e1lises chamando as fun\u00e7\u00f5es staticAnalysis, freeVibrationAnalysis e dynamicAnalysis. O m\u00e9todo time retorna o instante da simula\u00e7\u00e3o (da an\u00e1lise din\u00e2mica) e reset reinicia a an\u00e1lise din\u00e2mica.\n==Model==\nA classe ModeL encapsula a classe Riser e como esta, possui sublclasses para cada configura\u00e7\u00e3o de riser (TTRModeL, TowerModeL, CoLLectorModeL e PipeLineModeL). Com elas \u00e9 poss\u00edvel, utilizando polimorfismo e sobrecarga de m\u00e9todo, invocar as an\u00e1lises sem precisar de vari\u00e1veis e condicionais para fazer os c\u00e1lculos de modo diferenciado conforme o tipo de riser.\nPor exemplo, ao criar um novo modelo de TTR pelo m\u00e9todo newModel de Solver, \u00e9 instanciada a subclasse de Model apropriada, TTRModel, mas que fica referenciada pelo ponteiro model de tipo Model*. Ou seja, o Solver n\u00e3o sabe qual o tipo especifico de Model est\u00e1 alocado. Ao chamar a an\u00e1lise est\u00e1tica pela classe Solver, isto \u00e9, solver->staticAnalysis, \u00e9 chamado por ela o m\u00e9todo model->staticAnalysis, que executa n\u00e3o o m\u00e9todo da classe base Model, mas da classe especifica TTRModel. Este m\u00e9todo, por fim, invoca o m\u00e9todo run do objeto staticAnalysis passado como argumento, passando para ele o objeto data de tipo TTR.\n==TTRModel, TowerModel, CollectorModel e PipelineModel==\nClasses que representam os modelos espec\u00edficos de Model.\nDocumenta\u00e7\u00e3o do M\u00f3dulo de Visualiza\u00e7\u00e3o\nA descri\u00e7\u00e3o das classes do M\u00f3dulo de Visualiza\u00e7\u00e3o est\u00e1 aqui agrupada de acordo com as classes a que pertencem. A Figura 2 mostra as principais classes do m\u00f3dulo e como se relacionam entre si. A classe principal \u00e9 a classe App, que contem as classes Interface e Solver, est\u00e1 \u00faltima importada do m\u00f3dulo Solver. A classe Interface por sua vez cont\u00e9m as classes Scene, que implementa a cena 3D onde \u00e9 visualizada a simula\u00e7\u00e3o, e Panel, que implementa o painel de controle. A cena 3D \u00e9 implementada utilizando o VTK e o painel utilizando o Qt.\nFigura 2 - classes do M\u00f3dulo de Visualiza\u00e7\u00e3o\nScene.py\nCont\u00e9m as classes que implementam a representa\u00e7\u00e3o virtual do cen\u00e1rio de opera\u00e7\u00e3o de um riser. A classe Scene atua como o cont\u00eainer para as demais classes que instanciam os elementos espec\u00edficos da visualiza\u00e7\u00e3o (riser, mar, for\u00e7as). Al\u00e9m de alguns m\u00e9todos mais espec\u00edficos, todas possuem um construtor  init  e um m\u00e9todo update. O primeiro cria e conecta os objetos VTK do pipeline de visualiza\u00e7\u00e3o e o segundo atualiza os dados de entrada do pipeline (p.e. atualizando posi\u00e7\u00f5es ou escala dos elementos).\n==Scene==\ndef __init__(self,app,iren):\nConstrutor. Cria e inicializa o renderer (fornecido pelo VTK) a ser utilizado para a visualiza\u00e7\u00e3o. Cria os demais elementos da cena e adiciona seus respectivos actors na cena.\ndef scaleToScene(self,val):\nConverte dist\u00e2ncias para a escala da cena.\ndef scaleToModel(self,val):\nFaz o processo inverso do m\u00e9todo anterior.\ndef EndPickEvent(self,obj,event):\nDetecta um pick event, utilizado para selecionar um elemento do riser.\ndef frontView(self):\nPosiciona a c\u00e2mera em vista frontal.\ndef sideView(self):\nPosiciona a c\u00e2mera em vista lateral.\ndef topView(self):\nPosiciona a c\u00e2mera em vista superior.\ndef hideShipModel(self,hide):\nOculta ou mostra o modelo da embarca\u00e7\u00e3o.\ndef showMaxDisplacements(self,show):\nOculta ou mostra os m\u00e1ximos deslocamentos.\ndef record(self):\ndef visualStyle(self,option):\nSeleciona o modo de visualiza\u00e7\u00e3o: contido no bounding box ou com o mar extenso.\ndef hideFloaters(self,hide):\nOculta ou mostra os flutuadores ao longo do riser.\ndef hideNumbers(self,hide):\nOculta ou mostra a profundidade em n\u00fameros na cena.\ndef reset(self):\nZera as linhas de m\u00e1ximo deslocamento.\ndef update(self):\nInvoca update dos elementos da cena.\n==SceneObj==\nClasse base para as demais classes que representam os elementos da visualiza\u00e7\u00e3o (riser, mar, embarca\u00e7\u00e3o, etc). Implementa funcionalidades comuns a todas, como criar o Actor do VTK.\n==Mesh==\ndef update(sel_f,timeStamp):\nAtualiza a posi\u00e7\u00e3o da embarca\u00e7\u00e3o, fazendo-a balan\u00e7ar com o movimento das ondas. No momento, apenas para prop\u00f3sito ilustrativo.\n==Terrain==\nImplementa o fundo do mar. Utiliza Perlin Noise sobre um plano para gerar a rugosidade e uma textura para maior realismo.\n==Water==\nImplementa a superficie do mar. Utiliza Perlin Noise sobre um plano para gerar as ondas e uma textura para maior realismo.\ndef __init__(sel_f,scene,app,texture=None):\ndef update(sel_f,timeStamp):\nAtualiza a posi\u00e7\u00e3o das ondas. Embora o Solver leve em conta par\u00e2metros de onda, no momento as ondas representadas n\u00e3o seguem estes par\u00e2metros, sendo apenas ilustrativas.\n==Riser==\nRepresenta o riser. Utiliza um spline para interpolar os elementos, gerando um tubo com curvatura suave. Cores s\u00e3o mapeadas sobre a superf\u00edcie do riser para representar diversos dados da simula\u00e7\u00e3o, como for\u00e7as sobre o duto ou coeficientes de arrasto.\ndef update(sel_f):\nAtualiza a posi\u00e7\u00e3o do riser e o mapeamento de cores.\n==Box==\nRepresenta o bounding box que envolve os demais elementos da cena virtual (exceto no modo sem o bounding box).\n==Force==\nRepresenta com setas ao longo do riser as for\u00e7as que agem sobre o tubo. Escala e orienta as setas de acordo com magnitude das componentes inline e transversal (isto \u00e9, as componentes n\u00e3o s\u00e3o representadas separadamente).\ndef update(sel_f):\nAtualiza a posi\u00e7\u00e3o, orienta\u00e7\u00e3o e magnitude das setas, fazendo-as acompanhar o movimento do riser.\n==TopTension==\nRepresenta com uma seta apontada para cima a tens\u00e3o de topo aplicada no riser.\n==Cursor==\nImplementa uma esfera vermelha que marca o elemento do riser selecionado (ao apontar com o mouse e pressionar a tecla P).\n==Floaters==\nRepresenta os flutuadores dispostos sobre o riser.\ndef update(sel_f):\nAtualiza a posi\u00e7\u00e3o dos flutuadores, para acompanharem o riser.\n==RefPole==\nImplementa linhas verticais, utilizadas p.e. para marcar a posi\u00e7\u00e3o inicial do riser.\n==MaxProfile==\nImplementa as linhas de m\u00e1ximo deslocamento,\nPanel.py\nO arquivo Panel.py cont\u00e9m uma \u00fanica classe, Panel, que implementa o painel de controle do m\u00f3dulo de visualiza\u00e7\u00e3o, utilizando diversos recursos do Qt. O m\u00e9todo _init_ inicia as\nestruturas do Qt utilizadas, criando o painel e as funcionalidades dos widgets. Grande parte do painel foi criada atrav\u00e9s do ambiente visual QtCreator, de modo que o c\u00f3digo apenas carrega as informa\u00e7\u00f5es contidas no arquivo Panel.ui gerado pelo QtCreator. Para atribuir as funcionalidades dos widgets, \u00e9 utilizado o m\u00e9todo connect do widget correspondente, passando-se a fun\u00e7\u00e3o a ser chamada quando o widget for utilizado. Os demais m\u00e9todos da classe Panel, de um modo geral, implementam as fun\u00e7\u00f5es chamadas pelos widgets, ou s\u00e3o m\u00e9todos auxiliares.\nInterface.py\nO arquivo Interface.py cont\u00e9m uma \u00fanica classe, Interface, que implementa a interface do m\u00f3dulo de visualiza\u00e7\u00e3o. Serve de cont\u00eainer para dois outros objetos, um da classe Panel e outro da classe Scene, que implementam respectivamente o painel de controle e a cena 3D onde \u00e9 feita a visualiza\u00e7\u00e3o. Implementa tamb\u00e9m funcionalidades da barra de menu superior.\nmain.py\nO arquivo main.py cont\u00e9m uma \u00fanica classe, App, que \u00e9 a classe principal do m\u00f3dulo. Serve de cont\u00eainer para a classe Interface e para a classe Solver, esta \u00faltima importada do m\u00f3dulo Solver."}]}}}