{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.14025"}, {"@name": "filename", "#text": "20257_texto%20completo.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "MAPAS DE VISIBILIDADE EM GRANDES\n\nTERRENOS REPRESENTADOS POR GRADES\n\nREGULARES\n\n\n\nFicha catalogr\u00e1fica preparada pela Se\u00e7\u00e3o de Cataloga\u00e7\u00e3o e\nClassifica\u00e7\u00e3o da Biblioteca Central da UFV\n\n \n\nT\n\n Ferreira, Ch\u00e1ulio de Resende, 1989-\n\nF383m\n2014\n\n        Mapas de visibilidade em grandes terrenos representados\npor grades regulares / Ch\u00e1ulio de Resende Ferreira. \u2013 Vi\u00e7osa,\nMG, 2014.\n\n         x, 69f. : il. (algumas color.) ; 29 cm.\n\n  \n\n         Texto em portugu\u00eas e ingl\u00eas.\n\n         Orientador: Marcus Vin\u00edcius Alvim Andrade.\n\n         Disserta\u00e7\u00e3o (mestrado) - Universidade Federal de Vi\u00e7osa.\n\n         Refer\u00eancias bibliogr\u00e1ficas: f. 65-69.\n\n  \n\n         1. Sistemas de informa\u00e7\u00e3o geogr\u00e1fica. 2. Visibilidade.\n3. Algoritmos computacionais. 4. Computa\u00e7\u00e3o de alto\ndesempenho. I. Universidade Federal de Vi\u00e7osa. Departamento\nde Inform\u00e1tica. Programa de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da\nComputa\u00e7\u00e3o. II. T\u00edtulo.\n\n  \n\nCDD 22. ed. 005.1\n\n \n\n\n\nCHAULIO DE RESENDE FERREIRA\n\nMAPAS DE VISIBILIDADE EM GRANDES\n\nTERRENOS REPRESENTADOS POR GRADES\n\nREGULARES\n\nDisserta\u00e7\u00e3o apresentada \u00e0 Universidade\nFederal de Vi\u00e7osa, como parte das exig\u00ean-\ncias do Programa de P\u00f3s-Gradua\u00e7\u00e3o em\nCi\u00eancia da Computa\u00e7\u00e3o, para obten\u00e7\u00e3o do\nt\u00edtulo de Magister Scientiae.\n\nVI\u00c7OSA\n\nMINAS GERAIS - BRASIL\n\n2014\n\n\n\nSum\u00e1rio\n\nLista de Figuras v\n\nLista de Tabelas vii\n\nResumo ix\n\nAbstract x\n\n1 Introdu\u00e7\u00e3o geral 1\n\n1.1 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n1.2 Resultados obtidos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n\n1.2.1 Algoritmo desenvolvido para mem\u00f3ria externa . . . . . . . . . 4\n\n1.2.2 Algoritmo desenvolvido para arquiteturas paralelas . . . . . . 5\n\n2 Uma abordagem eficiente para o c\u00e1lculo de viewshed em terrenos\n\narmazenados em mem\u00f3ria externa 7\n\n2.1 Introdu\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n\n2.2 Referencial te\u00f3rico . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\n2.2.1 Visibilidade em terrenos . . . . . . . . . . . . . . . . . . . . . 9\n\n2.2.2 Algoritmos para c\u00e1lculo de viewshed em mem\u00f3ria interna . . . 10\n\n2.2.3 Algoritmos eficientes para E/S . . . . . . . . . . . . . . . . . . 12\n\n2.2.4 O m\u00e9todo EMViewshed . . . . . . . . . . . . . . . . . . . . . 13\n\n2.3 O m\u00e9todo TiledVS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n2.4 Complexidade do algoritmo . . . . . . . . . . . . . . . . . . . . . . . 16\n\n2.5 Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n2.6 Conclus\u00f5es e trabalhos futuros . . . . . . . . . . . . . . . . . . . . . . 20\n\n3 More efficient terrain viewshed computation on massive datasets\n\nusing external memory 21\n\nii\n\n\n\n3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n3.2 Definitions and related work . . . . . . . . . . . . . . . . . . . . . . . 22\n\n3.3 TiledVS method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n3.4 Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\n3.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\n4 A fast external memory algorithm for computing visibility on\n\ngrid terrains 30\n\n4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\n4.2 Some definitions for the viewshed problem . . . . . . . . . . . . . . . 32\n\n4.3 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n\n4.3.1 Viewshed algorithms . . . . . . . . . . . . . . . . . . . . . . . 34\n\n4.3.2 External memory viewshed algorithms . . . . . . . . . . . . . 37\n\n4.4 TiledVS method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\n4.4.1 Algorithm description . . . . . . . . . . . . . . . . . . . . . . 38\n\n4.4.2 Demonstration of TiledVS effectiveness . . . . . . . . . . . . . 39\n\n4.5 TiledVS complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n4.5.1 I/O complexity . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n4.5.2 CPU complexity . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n4.6 Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n\n4.6.1 Comparison with Fishman et al. algorithms . . . . . . . . . . 44\n\n4.6.2 Comparison with EMViewshed . . . . . . . . . . . . . . . . . 46\n\n4.6.3 TiledVS scalability . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n4.6.4 The influence of compression . . . . . . . . . . . . . . . . . . . 47\n\n4.6.5 TiledMatrix compared against the OS\u2019s Virtual Memory system 48\n\n4.7 Conclusion and future work . . . . . . . . . . . . . . . . . . . . . . . 49\n\n5 A parallel sweep line algorithm for visibility computation 51\n\n5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n\n5.2 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n\n5.2.1 Terrain representation . . . . . . . . . . . . . . . . . . . . . . 52\n\n5.2.2 The viewshed problem . . . . . . . . . . . . . . . . . . . . . . 52\n\n5.2.3 Viewshed algorithms . . . . . . . . . . . . . . . . . . . . . . . 54\n\n5.2.4 Parallel programming models . . . . . . . . . . . . . . . . . . 57\n\n5.3 Our parallel sweep line algorithm . . . . . . . . . . . . . . . . . . . . 58\n\n5.4 Experimental results . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n\n5.5 Conclusions and future work . . . . . . . . . . . . . . . . . . . . . . . 61\n\niii\n\n\n\n6 Conclus\u00f5es gerais e trabalhos futuros 63\n\nRefer\u00eancias Bibliogr\u00e1ficas 65\n\niv\n\n\n\nLista de Figuras\n\n1.1 Modelos digitais de terreno. . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\n(a) TIN. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\n(b) RSG. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\n2.1 C\u00e1lculo da visibilidade em um corte vertical do terreno. O alvo T1 \u00e9\n\nvis\u00edvel a partir de O e T2 n\u00e3o \u00e9 vis\u00edvel. . . . . . . . . . . . . . . . . . . . 10\n\n2.2 Algoritmo RFVS. a exemplos de segmentos em um terreno; (b) exemplo\n\nde um corte vertical definido por um segmento. . . . . . . . . . . . . . . 12\n\n2.3 Transfer\u00eancias entre as mem\u00f3rias interna e externa gerenciadas pela\n\nclasse TiledMatrix. Em (a), uma c\u00e9lula do bloco 4 \u00e9 acessada e, como\n\nesse bloco n\u00e3o est\u00e1 na mem\u00f3ria principal, ele \u00e9 carregado, substituindo\n\no bloco 14, que foi utilizado menos recentemente. A figura (b) apresenta\n\no estado da mem\u00f3ria interna ap\u00f3s a troca do bloco 14 pelo bloco 4. . . . 16\n\n2.4 Tempos de execu\u00e7\u00e3o do EMViewshed (EMVS) e do TiledVS (TVS) uti-\n\nlizando os 3 tamanhos de blocos com melhores desempenhos e alturas de\n\n50 e 100 metros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n3.1 Target\u2019s visibility: T1 and T3 are not visible but T2 is. . . . . . . . . . . . 23\n\n3.2 Matrix partitioning. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n(a) square blocks with 3 \u00d7 3 cells. . . . . . . . . . . . . . . . . . . . 25\n\n(b) vertical bands with 3 columns. . . . . . . . . . . . . . . . . . . . 25\n\n3.3 TiledVS algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\n(a) Blocks intersected by two consecutive rays . . . . . . . . . . . . 27\n\n(b) Block B? is loaded because of ray r0, is evicted after ray rm and\n\nloaded again for ray rn. . . . . . . . . . . . . . . . . . . . . . . 27\n\n3.4 Comparing the running time of the four methods. . . . . . . . . . . . . . 29\n\n4.1 Targets\u2019 visibility: T1 and T3 are not visible but T2 is. . . . . . . . . . . . 33\n\n4.2 The rasterization of the line of sight projection. . . . . . . . . . . . . . . 33\n\nv\n\n\n\n4.3 Viewshed algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n\n(a) RFVS algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n\n(b) Van Kreveld\u2019s algorithm. . . . . . . . . . . . . . . . . . . . . . . 35\n\n4.4 Partitioning the elevation matrix into blocks and reorganizing the cells\n\nin external memory to store the cells of each block in sequence. The\n\narrows indicate the writing sequence. . . . . . . . . . . . . . . . . . . . . 39\n\n4.5 The terrain matrix partitioning. . . . . . . . . . . . . . . . . . . . . . . . 40\n\n(a) Square blocks with 3 \u00d7 3 cells. . . . . . . . . . . . . . . . . . . . 40\n\n(b) Vertical bands with 3 columns. The radius of interest ? = 10. . 40\n\n4.6 Blocks intersected by two consecutive rays. . . . . . . . . . . . . . . . . . 41\n\n4.7 Block B? is loaded because of ray r0, is evicted after rm and loaded again\n\nfor rn. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n4.8 Comparing the running time of the four methods. . . . . . . . . . . . . 45\n\n4.9 Number of cells processed per second by each method. . . . . . . . . . . 46\n\n4.10 Running time of methods EMViewshed and TiledVS. . . . . . . . . . . . 47\n\n5.1 Targets\u2019 visibility: T1 and T3 are not visible but T2 is. . . . . . . . . . . . 53\n\n5.2 The rasterization of the line of sight projection. . . . . . . . . . . . . . . 53\n\n5.3 Viewshed algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n\n(a) RFVS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n\n(b) Van Kreveld . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n\n5.4 Sector definition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n\n(a) Subdivision of the region of interest and the sector s, defined\n\nby the interval [?, ?). . . . . . . . . . . . . . . . . . . . . . . . . 58\n\n(b) The cells in the perimeter of the region of interest, the rays\n\nused to determine which cells are intersected by s and the cells\n\ninserted into Es (shaded cells). . . . . . . . . . . . . . . . . . . 58\n\n5.5 Experimental results. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n\n(a) Running times (in seconds) for the serial algorithm and the\n\nparallel algorithm with different number of threads . . . . . . . 61\n\n(b) Speedups achieved by our parallel algorithm, with different\n\nnumber of threads. . . . . . . . . . . . . . . . . . . . . . . . . . 61\n\nvi\n\n\n\nLista de Tabelas\n\n2.1 Tempos m\u00e9dios de execu\u00e7\u00e3o, em segundos, para os m\u00e9todos EMViewshed\n\n(EMVS) e TiledVS, considerando diferentes tamanhos de blocos e terre-\n\nnos e altura de 50 metros. A linha Dim. Bl. indica as dimens\u00f5es dos\n\nblocos utilizados, e a linha # Bl. indica o n\u00famero m\u00e1ximo de blocos que\n\npodem ser armazenados na mem\u00f3ria interna. . . . . . . . . . . . . . . . . 19\n\n2.2 Tempos m\u00e9dios de execu\u00e7\u00e3o, em segundos, para os m\u00e9todos EMViewshed\n\n(EMVS) e TiledVS, considerando diferentes tamanhos de blocos e terre-\n\nnos e altura de 100 metros. A linha Dim. Bl. indica as dimens\u00f5es dos\n\nblocos utilizados, e a linha # Bl. indica o n\u00famero m\u00e1ximo de blocos que\n\npodem ser armazenados na mem\u00f3ria interna. . . . . . . . . . . . . . . . . 19\n\n3.1 Running time (seconds) for io-radial2 (io-r2), io-radial3 (io-r3), io-\n\ncentrifugal (io-cent) and TiledVS with 512MiB RAM. . . . . . . . . . . 28\n\n3.2 Running time (seconds) for EMViewshed (EMVS) and TiledVS with\n\n1024MiB RAM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\n3.3 TiledVS running time (seconds) using a RAM memory with 128MiB and\n\n512MiB. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n4.1 Running time (seconds) for io-radial2 (io-r2), io-radial3 (io-r3), io-\n\ncentrifugal (io-cent) and TiledVS with 512MiB RAM. . . . . . . . . . . 45\n\n4.2 Running time (seconds) for EMViewshed (EMVS) and TiledVS with\n\n1024MiB RAM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\n4.3 TiledVS running time (seconds) with either 128MiB or 512MiB RAM. . 47\n\n4.4 Running time (seconds) of TiledVS using TiledMatrix with compression\n\nenabled (w comp.) and disabled (w/o comp.). . . . . . . . . . . . . . . . 48\n\n5.1 Running times (in seconds) for the serial algorithm and the parallel al-\n\ngorithm with different number of threads. . . . . . . . . . . . . . . . . . 60\n\nvii\n\n\n\n5.2 Speedups achieved by our parallel algorithm, with different number of\n\nthreads. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\nviii\n\n\n\nResumo\n\nFERREIRA, Chaulio de Resende, M.Sc., Universidade Federal de Vi\u00e7osa, fevereiro\nde 2014. Mapas de visibilidade em grandes terrenos representados por\ngrades regulares. Orientador: Marcus Vin\u00edcius Alvim Andrade.\n\nUma opera\u00e7\u00e3o muito comum em sistemas de informa\u00e7\u00f5es geogr\u00e1ficas (SIG) con-\n\nsiste no c\u00e1lculo de mapas de visibilidade, ou viewsheds. Um mapa de visibilidade\n\nindica quais regi\u00f5es de um terreno s\u00e3o vis\u00edveis a partir de um determinado ponto\n\nde observa\u00e7\u00e3o, normalmente chamado de observador. Este trabalho apresenta dois\n\nnovos algoritmos para c\u00e1lculo de viewshed em grandes terrenos representados por\n\ngrades regulares, ambos mais eficientes do que os demais encontrados em literatura.\n\nO primeiro algoritmo chama-se TiledVS e foi projeto especialmente para mem\u00f3ria\n\nexterna, ou seja, para reduzir o n\u00famero de opera\u00e7\u00f5es de entrada e sa\u00edda (E/S) re-\n\nalizadas. Para isso, ele utiliza uma estrutura de dados denominada TiledMatrix,\n\nque subdivide o terreno em diversos blocos retangulares e gerencia os acessos aos\n\ndados de forma eficiente. De acordo com os resultados experimentais obtidos, este\n\nalgoritmo \u00e9 mais de 4 vezes mais r\u00e1pido do que todos os outros encontrados em\n\nliteratura. O segundo algoritmo \u00e9 um algoritmo paralelo que utiliza o modelo de\n\nmem\u00f3ria compartilhada (OpenMP). Este algoritmo subdivide o terreno em diversos\n\nsetores em volta do observador, de modo que cada um destes setores possa ser pro-\n\ncessado de forma independente. Os resultados experimentais mostraram que com\n\num computador com 4 cores \u00e9 poss\u00edvel obter processamentos 4 vezes mais r\u00e1pidos\n\ndo que a vers\u00e3o sequencial do mesmo algoritmo. J\u00e1 com um computador com 16\n\ncores, foram obtidos processamentos at\u00e9 12 vezes mais r\u00e1pidos.\n\nix\n\n\n\nAbstract\n\nFERREIRA, Chaulio de Resende, M.Sc., Universidade Federal de Vi\u00e7osa, February,\n2014. Visibility maps on large terrain represented as regular square grids.\nAdviser: Marcus Vin\u00edcius Alvim Andrade.\n\nIn geographical information science (GIS) it is usual to compute the viewshed of\n\na given point on a terrain. This point is usually called observer, and its viewshed\n\nindicates which terrain regions are visible from it. In this work we present two novel\n\nalgorithms for viewshed computation on large grid terrains, both more efficient\n\nthan other approaches found in related work. The first algorithm is called TiledVS.\n\nIt was specially designed for external memory processing, that is, it performs a\n\nsmaller number of in/out (I/O) operations. To do that, it uses a special library\n\ncalled TiledMatrix, which subdivides the terrain into several rectangular blocks and\n\nefficiently manages the accesses to the terrain cells. According to our experimental\n\nresults, TiledVS is more than 4 times faster than all other previous algorithms. The\n\nsecond one is a parallel algorithm that uses the shared memory model (OpenMP).\n\nIt subdivides the terrain into several sectors around the observer, such that each\n\nsector may be processed independently. Our experimental results showed that, using\n\na personal computer with 4 cores, it is possible to compute the viewshed 4 times\n\nfaster than with the serial implementation of the same algorithm. Using a computer\n\nwith 16 cores, we obtained up to 12 times speedups.\n\nx\n\n\n\n1. Introdu\u00e7\u00e3o geral\n\nDiversas aplica\u00e7\u00f5es em ci\u00eancia da informa\u00e7\u00e3o geoespacial (CIG) envolvem quest\u00f5es\n\nde visibilidade. Exemplos s\u00e3o: determinar o n\u00famero m\u00ednimo de torres de celular\n\nnecess\u00e1rias para cobrir uma regi\u00e3o [Ben-Moshe et al., 2002], otimizar o n\u00famero e\n\na posi\u00e7\u00e3o de guardas para vigiar uma regi\u00e3o [Bespamyatnikh et al., 2001], analisar\n\nas influ\u00eancias ambientais em pre\u00e7os de propriedades em um ambiente urbano [Lake\n\net al., 1998], entre outras. Essas aplica\u00e7\u00f5es geralmente requerem o c\u00e1lculo de mapas\n\nde visibilidade, ou viewsheds, de determinados pontos (chamados de observadores)\n\nem um terreno. Mais especificamente, o viewshed de um observador O indica quais\n\nregi\u00f5es do terreno s\u00e3o vis\u00edveis a partir de O. Por exemplo, um observador pode\n\nrepresentar uma torre de telefonia celular, enquanto seu viewshed representa as\n\n\u00e1reas do terreno onde espera-se que um usu\u00e1rio do servi\u00e7o de telefonia consiga obter\n\nsinal diretamente a partir dessa torre. Neste trabalho, ser\u00e1 analisado o problema de\n\nc\u00e1lculo de mapas de visibilidade em grandes terrenos e ser\u00e3o propostos e avaliados\n\nalgoritmos mais eficientes do que os encontrados atualmente na literatura.\n\nEstas aplica\u00e7\u00f5es utilizam informa\u00e7\u00f5es sobre o terreno, principalmente relacio-\n\nnadas \u00e0 eleva\u00e7\u00e3o de sua superf\u00edcie, que geralmente s\u00e3o representadas por um modelo\n\ndigital de terreno (MDT) Segundo C\u00e2mara et al. [2001], a aquisi\u00e7\u00e3o de dados geo-\n\ngr\u00e1ficos para a gera\u00e7\u00e3o de MDTs pode ser feita atrav\u00e9s da amostragem de pontos\n\nespa\u00e7ados de forma regular ou irregular. No caso de amostras irregularmente espa\u00e7a-\n\ndas, normalmente utilizam-se estruturas de dados de malha triangular, denominadas\n\ntriangulated irregular networks (TINs). J\u00e1 no caso de amostras regularmente espa-\n\n\u00e7adas \u00e9 poss\u00edvel utilizar estruturas de dados mais simples. Assim, normalmente s\u00e3o\n\nutilizadas grades regulares (regular square grids - RSGs), que consistem em matrizes\n\nque armazenam as eleva\u00e7\u00f5es dos pontos amostrados. Estes dois formatos de MDT\n\ns\u00e3o ilustrados na Figura 1.1.\n\nNeste trabalho foi utilizada a representa\u00e7\u00e3o baseada em grades regulares, uma\n\nvez que esta \u00e9 mais simples, mais f\u00e1cil de ser analisada e atualmente existe uma\n\ngrande quantidade de dados dispon\u00edveis neste formato. Al\u00e9m disso, os algoritmos\n\npropostos neste trabalho foram baseados em outros algoritmos que tamb\u00e9m traba-\n\nlham com este formato. \u00c9 importante ressaltar que a escolha de uma forma de\n\nrepresenta\u00e7\u00e3o espec\u00edfica n\u00e3o resulta em uma restri\u00e7\u00e3o relevante na pr\u00e1tica, uma\n\nvez que existem m\u00e9todos eficientes para a convers\u00e3o entre as diversas formas de\n\n1\n\n\n\n1. Introdu\u00e7\u00e3o geral 2\n\n(a) TIN. (b) RSG.\n\nFigura 1.1: Modelos digitais de terreno.\n\nrepresenta\u00e7\u00e3o [Li et al., 2005].\n\nEntre os algoritmos para c\u00e1lculo de viewshed em grades regulares, destacam-se\n\no algoritmo RFVS [Franklin and Ray, 1994] e o proposto por Van Kreveld [1996],\n\nambos muito eficientes. Al\u00e9m destes h\u00e1 ainda o cl\u00e1ssico R3 [Shapira, 1990], menos\n\neficiente, por\u00e9m importante do ponto de vista te\u00f3rico.\n\nOs algoritmos RFVS e de Van Kreveld s\u00e3o muito eficientes, por\u00e9m podem\n\ndemandar um longo tempo de processamento dependendo das dimens\u00f5es do terreno\n\na ser processado. Por exemplo, os resultados apresentados no Cap\u00edtulo 5 mostram\n\nque o algoritmo de Van Kreveld pode demorar mais de 20 minutos para processar\n\num terreno de 3,35 GiB, mesmo utilizando-se um processador de \u00faltima gera\u00e7\u00e3o. \u00c9\n\nimportante observar que atualmente, devido aos avan\u00e7os tecnol\u00f3gicos no processo de\n\ncoleta de dados baseados em sensoriamento remoto, h\u00e1 um enorme volume de dados\n\nde alta qualidade sobre a superf\u00edcie terrestre representados na forma de grades regu-\n\nlares. Assim, os problemas envolvendo o processamento de terrenos frequentemente\n\npodem ser enquadrados na \u00e1rea de big data. Para esses problemas, torna-se neces-\n\ns\u00e1rio desenvolver novos m\u00e9todos que possam processar grandes volumes de dados\n\nde forma eficiente. Em geral, o desenvolvimento destes m\u00e9todos se baseia em duas\n\nestrat\u00e9gias: processamento em mem\u00f3ria externa e processamento paralelo.\n\nA primeira estrat\u00e9gia (processamento em mem\u00f3ria externa) consiste em de-\n\nsenvolver algoritmos para processar terrenos maiores do que a mem\u00f3ria interna\n\n(principal) do computador. Nesses casos, o n\u00famero de opera\u00e7\u00f5es de entrada/sa\u00edda\n\n\n\n1. Introdu\u00e7\u00e3o geral 3\n\n(E/S) realizadas \u00e9 t\u00e3o grande que o tempo de processamento em CPU passa a ser\n\npraticamente insignificante. Assim, \u00e9 importante o projeto de algoritmos que re-\n\nalizem menos acessos aos dados armazenados em mem\u00f3ria externa (normalmente\n\ndiscos), visto que o estes acessos s\u00e3o da ordem de 106 vezes mais lento do que os\n\nacessos feitos \u00e0 mem\u00f3ria interna [Dementiev et al., 2005].\n\nA segunda estrat\u00e9gia se baseia em desenvolver m\u00e9todos paralelos para proces-\n\nsar grandes volumes de dados. Esta estrat\u00e9gia tem atra\u00eddo cada vez mais a aten\u00e7\u00e3o\n\nde v\u00e1rios pesquisadores, principalmente porque atualmente \u00e9 poss\u00edvel adquirir, a um\n\ncusto relativamente baixo, m\u00e1quinas com grande capacidade computacional, isto \u00e9,\n\ncom grande quantidade de mem\u00f3ria interna e tamb\u00e9m v\u00e1rios n\u00facleos de processa-\n\nmento paralelo.\n\nAssim, neste trabalho ser\u00e3o apresentados dois algoritmos para c\u00e1lculo de mapa\n\nde visibilidade, ou viewshed: um primeiro algoritmo, chamado TiledVS, para pro-\n\ncessamento em mem\u00f3ria externa \u00e9 descrito nos Cap\u00edtulos 2, 3 e 4; e um segundo\n\nalgoritmo, descrito no Cap\u00edtulo 5, baseado em processamento paralelo. Conforme\n\ndemonstrado pelos resultados experimentais apresentados, ambos s\u00e3o consideravel-\n\nmente mais r\u00e1pidos do que os algoritmos mais recentes e eficientes encontrados em\n\nliteratura.\n\n1.1 Objetivos\n\nO objetivo geral deste trabalho foi o desenvolvimento de algoritmos mais eficientes\n\npara c\u00e1lculo de viewshed considerando-se grandes volumes de dados. Para alcan-\n\n\u00e7ar este objetivo geral, destacam-se alguns objetivos espec\u00edficos que precisaram ser\n\natingidos, como:\n\n\u2022 Propor e implementar um algoritmo capaz de lidar com grandes terrenos ar-\n\nmazenados em mem\u00f3ria externa;\n\n\u2022 Propor e implementar um algoritmo que utilize as modernas arquiteturas pa-\n\nralelas para realizar o processamento de forma mais eficiente;\n\n\u2022 Realizar a an\u00e1lise de complexidade dos algoritmos desenvolvidos;\n\n\u2022 Realizar revis\u00e3o bibliogr\u00e1fica e avaliar experimentalmente os algoritmos de-\n\nsenvolvidos, comparando-os com outros m\u00e9todos encontrados na literatura.\n\n\n\n1. Introdu\u00e7\u00e3o geral 4\n\n1.2 Resultados obtidos\n\nNos Cap\u00edtulos de 2 a 5 s\u00e3o apresentados os artigos que descrevem os resultados\n\nobtidos neste trabalho. Mais especificamente, os Cap\u00edtulos 2, 3 e 4 referem-se ao\n\nalgoritmo desenvolvido para c\u00e1lculo de viewshed em mem\u00f3ria externa, denominado\n\nTiledVS, enquanto o Cap\u00edtulo 5 apresenta o algoritmo desenvolvido para arquitetu-\n\nras paralelas.\n\n1.2.1 Algoritmo desenvolvido para mem\u00f3ria externa\n\nOs Cap\u00edtulos 2, 3 e 4 apresentam o algoritmo TiledVS, desenvolvido para processar\n\nterrenos armazenados em mem\u00f3ria externa de forma eficiente. Ele consiste em uma\n\nadapta\u00e7\u00e3o do algoritmo RFVS, proposto por Franklin and Ray [1994]. Para minimi-\n\nzar o n\u00famero de opera\u00e7\u00f5es de E/S realizadas durante o processamento, foi utilizada\n\numa biblioteca denominada TiledMatrix [Silveira et al., 2013], capaz de armazenar e\n\ngerenciar grandes matrizes em mem\u00f3ria externa de forma eficiente. Na pr\u00e1tica, essa\n\nbiblioteca gerencia os acessos aos dados em mem\u00f3ria externa reorganizando-os de\n\nmodo a realizar de forma eficiente os acessos aos dados que apresentem padr\u00f5es de\n\nlocalidade espacial bidimensional. Os dados da matriz s\u00e3o subdivididos em blocos\n\nretangulares e as c\u00e9lulas de um mesmo bloco s\u00e3o armazenadas de forma cont\u00edgua.\n\nQuando \u00e9 necess\u00e1rio acessar uma dessas c\u00e9lulas, o bloco inteiro que a cont\u00e9m \u00e9 copi-\n\nado para a mem\u00f3ria interna e nela continua armazenado por algum tempo. Assim,\n\na mem\u00f3ria interna \u00e9 gerenciada como uma mem\u00f3ria cache controlada pela aplica-\n\n\u00e7\u00e3o que, diferentemente do sistema de pagina\u00e7\u00e3o tradicional do sistema operacional,\n\nconsidera a localiza\u00e7\u00e3o bidimensional dos dados na matriz.\n\nUma primeira vers\u00e3o do m\u00e9todo TiledVS \u00e9 apresentada no Cap\u00edtulo 2, onde\n\n\u00e9 inclu\u00eddo o artigo \u201cUma abordagem eficiente para o c\u00e1lculo de viewshed em ter-\n\nrenos armazenados em mem\u00f3ria externa\u201d, apresentado no SEMISH 2012 (XXXIX\n\nSemin\u00e1rio Integrado de Software e Hardware) [Ferreira et al., 2012a]. Nesse artigo\n\no novo algoritmo foi comparado experimentalmente com outro m\u00e9todo para c\u00e1lculo\n\nde viewshed em mem\u00f3ria externa, tamb\u00e9m baseado no algoritmo RFVS: o m\u00e9todo\n\nEMViewshed [Andrade et al., 2011]. Os resultados mostraram que o novo algoritmo\n\nconseguiu ser mais de 4 vezes mais r\u00e1pido do que o EMViewshed. Al\u00e9m disso, nesse\n\nartigo foram realizados experimentos iniciais para tentar avaliar a influ\u00eancia dos\n\ntamanhos dos blocos utilizados na subdivis\u00e3o da matriz feita pela TiledMatrix.\n\nNo Cap\u00edtulo 3 \u00e9 apresentado o artigo \u201cMore efficient terrain viewshed compu-\n\ntation on massive datasets using external memory\u201d, apresentado no ACM SIGSPA-\n\n\n\n1. Introdu\u00e7\u00e3o geral 5\n\nTIAL 2012 (20th International Conference on Advances in Geographic Information\n\nSystems) [Ferreira et al., 2012b]. Nesse artigo o novo m\u00e9todo TiledVS foi compa-\n\nrado tamb\u00e9m com outros algoritmos para c\u00e1lculo de viewshed em mem\u00f3ria externa\n\npropostos por Fishman et al. [2009] e, mais uma vez, mostrou-se mais eficiente do\n\nque todos eles. Nesse artigo tamb\u00e9m \u00e9 apresentada uma an\u00e1lise formal do padr\u00e3o\n\nde acesso utilizado pelo algoritmo e s\u00e3o estabelecidas algumas condi\u00e7\u00f5es com rela-\n\n\u00e7\u00e3o ao tamanho dos blocos utilizados e da mem\u00f3ria interna dispon\u00edvel de modo a\n\ngarantir que o processamento seja sempre realizado de forma eficiente. Com essas\n\ncondi\u00e7\u00f5es, o algoritmo foi alterado para, com base nos par\u00e2metros de entrada, esta-\n\nbelecer automaticamente o tamanho dos blocos utilizados durante o processamento,\n\nalgo que anteriormente precisava ser escolhido explicitamente pelo usu\u00e1rio. Para\n\nfinalizar, tamb\u00e9m foram inclu\u00eddos experimentos para avaliar o comportamento do\n\nalgoritmo em condi\u00e7\u00f5es extremas como, por exemplo, o processamento de terrenos\n\nat\u00e9 320 vezes maiores do que a mem\u00f3ria interna dispon\u00edvel.\n\nO Cap\u00edtulo 4 apresenta o artigo \u201cA fast external memory algorithm for compu-\n\nting visibility on grid terrains\u201d, submetido \u00e0 revista ACM TSAS (ACM Transactions\n\non Spatial Algorithms and Systems) [Ferreira et al., 2014]. Este artigo corresponde\n\na uma vers\u00e3o estendida do artigo do Cap\u00edtulo 3, onde foi utilizada uma estrat\u00e9gia\n\nde compress\u00e3o de dados aliada \u00e0 biblioteca TiledMatrix que conseguiu reduzir os\n\ntempos de processamento em at\u00e9 42%. Mais especificamente, a biblioteca TiledMa-\n\ntrix passou a utilizar o algoritmo de compress\u00e3o extremamente r\u00e1pido LZ4 [Collet,\n\n2012] para comprimir os dados de cada bloco antes de grav\u00e1-lo no disco, e tamb\u00e9m\n\npara descomprimi-los ao acess\u00e1-los novamente. Al\u00e9m disso foram feitas as an\u00e1lises de\n\ncomplexidade de E/S e de CPU do novo algoritmo, assim como alguns experimentos\n\nanalisando a influ\u00eancia da compress\u00e3o de dados sobre os tempos de processamento.\n\n1.2.2 Algoritmo desenvolvido para arquiteturas paralelas\n\nO Cap\u00edtulo 5 apresenta o artigo \u201cA Parallel Sweep Line Algorithm for Visibility\n\nComputation\u201d, que recebeu o pr\u00eamio de melhor artigo no GeoInfo 2013 (XIV Bra-\n\nzilian Symposium on Geoinformatics) [Ferreira et al., 2013].\n\nEsse artigo descreve o algoritmo desenvolvido para c\u00e1lculo de viewshed em ar-\n\nquiteturas paralelas, que foi baseado no algoritmo sequencial proposto por Van Kre-\n\nveld [1996]. Para calcular o viewshed utilizando v\u00e1rios processadores paralelos, o\n\nalgoritmo subdivide o terreno em diversos setores em volta do observador, de forma\n\nque cada um desses setores possa ser processado independentemente dos demais se-\n\ntores. Os resultados mostraram que, com 16 processadores paralelos, este algoritmo\n\n\n\n1. Introdu\u00e7\u00e3o geral 6\n\nfoi at\u00e9 12 vezes mais r\u00e1pido do que sua vers\u00e3o sequencial. Como trabalho futuro,\n\npretende-se melhorar o algoritmo e estender o artigo, visando sua submiss\u00e3o para\n\numa revista da \u00e1rea.\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo\n\nde viewshed em terrenos armazenados\n\nem mem\u00f3ria externa1\n\nAbstract\n\nAn important GIS application is computing the viewshed of a point on\n\na DEM terrain, i.e. determining the visible region from this point. In some\n\ncases, it is not possible to process high resolution DEMs entirely in internal\n\nmemory and, thus, it is important to develop algorithms to process such data\n\nin the external memory. This paper presents an efficient algorithm for handling\n\nhuge terrains in external memory. As tests have shown, this new method is\n\nmore efficient than other methods described in the literature.\n\nResumo\n\nUma importante aplica\u00e7\u00e3o em ci\u00eancia da informa\u00e7\u00e3o geoespacial (CIG)\n\n\u00e9 o c\u00e1lculo da regi\u00e3o vis\u00edvel (viewshed) a partir de um determinado ponto em\n\num terreno representado por um modelo digital de terreno (MDT). Muitas\n\nvezes, o processamento de MDTs de alta resolu\u00e7\u00e3o n\u00e3o pode ser realizado em\n\nmem\u00f3ria interna e, portanto, \u00e9 importante o desenvolvimento de algoritmos\n\npara processar estes dados em mem\u00f3ria secund\u00e1ria. Este trabalho apresenta\n\num algoritmo para c\u00e1lculo de viewshed que \u00e9 capaz de lidar com grande volume\n\nde dados em mem\u00f3ria externa de forma eficiente. Os testes realizados indicam\n\nque o m\u00e9todo proposto \u00e9 mais eficiente do que outros m\u00e9todos descritos em\n\nliteratura.\n\n2.1 Introdu\u00e7\u00e3o\n\nOs recentes avan\u00e7os tecnol\u00f3gicos em sensoriamento remoto t\u00eam produzido uma\n\ngrande quantidade de dados de alta resolu\u00e7\u00e3o sobre a superf\u00edcie terrestre, o que\n\n1Neste cap\u00edtulo \u00e9 apresentada uma primeira vers\u00e3o do m\u00e9todo TiledVS. Nele est\u00e1 inclu\u00eddo o\nartigo \u201cUma abordagem eficiente para o c\u00e1lculo de viewshed em terrenos armazenados em mem\u00f3ria\nexterna\u201d, apresentado no SEMISH 2012 (XXXIX Semin\u00e1rio Integrado de Software e Hardware)\n[Ferreira et al., 2012a].\n\n7\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 8\n\ntem aumentado a necessidade de se desenvolver novas t\u00e9cnicas em ci\u00eancia da infor-\n\nma\u00e7\u00e3o geoespacial (CIG) para lidar com este enorme volume de dados [Laurini and\n\nThompson, 1992].\n\nUma forma muito utilizada para se representar a superf\u00edcie da Terra de forma\n\naproximada \u00e9 atrav\u00e9s de um Modelo Digital de Terreno (MDT) que armazena as\n\neleva\u00e7\u00f5es de pontos amostrados sobre a superf\u00edcie terrestre. Esses pontos podem\n\nser amostrados de maneira irregular e ser armazenados como uma rede triangular\n\nirregular (TIN - triangulated irregular network) ou de maneira regular (RSG - regular\n\nsquare grid), sendo armazenados numa matriz [Felgueiras, 2001]. Neste trabalho\n\nser\u00e1 adotada a segunda forma de representa\u00e7\u00e3o do MDT. Muitas vezes estas matrizes\n\nnecessitam de mais espa\u00e7o de armazenamento do que tem-se dispon\u00edvel na mem\u00f3ria\n\ninterna da maioria dos computadores atuais. Por exemplo, um terreno de 100km \u00d7\n\n100km mapeado com resolu\u00e7\u00e3o de 1m resulta em 1010 pontos. Supondo que sejam\n\nutilizados 2 bytes para armazenar a eleva\u00e7\u00e3o de cada ponto, s\u00e3o necess\u00e1rios mais de\n\n18 GB para representar este terreno.\n\nDesta forma, \u00e9 importante o desenvolvimento de algoritmos espec\u00edficos para\n\nprocessamento de dados armazenados em mem\u00f3ria externa. Vale ressaltar que nor-\n\nmalmente os algoritmos tradicionais de an\u00e1lise e processamento de dados geogr\u00e1ficos\n\nbuscam otimizar o tempo de processamento em CPU, sem grandes preocupa\u00e7\u00f5es com\n\no tempo de acesso \u00e0 mem\u00f3ria. Mas, por outro lado, o projeto e an\u00e1lise de algoritmos\n\npara mem\u00f3ria externa devem focar-se em minimizar os acessos a disco, uma vez que\n\nestes s\u00e3o da ordem de 106 vezes mais lentos do que os acessos \u00e0 mem\u00f3ria interna\n\n[Dementiev et al., 2005].\n\nMais especificamente, algoritmos que processam dados em mem\u00f3ria externa\n\ndevem ser projetados e analisados considerando um modelo computacional que os\n\navalie considerando as opera\u00e7\u00f5es de transfer\u00eancia de dados em vez das opera\u00e7\u00f5es\n\nde processamento interno. Um desses modelos, proposto por Aggarwal and Vitter\n\n[1988], determina a complexidade dos algoritmos com base no n\u00famero de opera\u00e7\u00f5es\n\nde E/S (entrada/sa\u00edda) executadas. Este modelo ser\u00e1 descrito com maiores detalhes\n\nna Se\u00e7\u00e3o 2.2.3.\n\nDentre as v\u00e1rias aplica\u00e7\u00f5es na \u00e1rea de CIG, h\u00e1 aquelas relacionadas a quest\u00f5es\n\nde visibilidade, como determinar o n\u00famero m\u00ednimo de torres de celular necess\u00e1rias\n\npara cobrir uma regi\u00e3o [Ben-Moshe et al., 2002], otimizar o n\u00famero e a posi\u00e7\u00e3o de\n\nguardas para vigiar uma regi\u00e3o [Bespamyatnikh et al., 2001], etc. Tais aplica\u00e7\u00f5es\n\nutilizam o conceito de observador e alvo: o observador tem o objetivo de visualizar\n\n(observar) outros objetos (os alvos) em um terreno, sendo que os observadores pos-\n\nsuem um limite m\u00e1ximo para o alcance de sua vis\u00e3o, chamado de raio de interesse.\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 9\n\nPor exemplo, uma torre de telefonia celular pode ser considerada um observador\n\ncujo raio de interesse corresponde ao alcance do sinal da torre e cujos alvos s\u00e3o os\n\nusu\u00e1rios do servi\u00e7o de telefonia. A partir desse conceito, pode-se calcular o mapa\n\nde visibilidade (viewshed) de um ponto p do terreno, que indica a regi\u00e3o do ter-\n\nreno que \u00e9 vis\u00edvel por um observador posicionado em p. H\u00e1 diversos m\u00e9todos para\n\nc\u00e1lculo de viewshed em mem\u00f3ria interna, como os propostos por Franklin and Ray\n\n[1994] e Van Kreveld [1996]. Al\u00e9m disso, h\u00e1 tamb\u00e9m alguns m\u00e9todos eficientes para\n\nprocessar terrenos armazenados em mem\u00f3ria externa, como o m\u00e9todo proposto por\n\nHaverkort and Zhuang [2007], que utiliza uma adapta\u00e7\u00e3o do m\u00e9todo de Kreveld para\n\nmem\u00f3ria externa e o m\u00e9todo EMViewshed recentemente proposto por Andrade et al.\n\n[2011], descrito na se\u00e7\u00e3o 2.2.2, que \u00e9 cerca de 6 vezes mais r\u00e1pido do que o m\u00e9todo\n\nproposto por Haverkort.\n\nEste trabalho apresenta um novo m\u00e9todo denominado TiledVS, que \u00e9 cerca\n\nde 4 vezes mais eficiente do que o m\u00e9todo EMViewshed. A id\u00e9ia b\u00e1sica deste novo\n\nm\u00e9todo consiste em adaptar o algoritmo proposto por Franklin and Ray [1994]\n\nalterando a forma como os dados em mem\u00f3ria externa s\u00e3o acessados. Para isto,\n\nfoi utilizada uma estrutura de dados que gerencia as transfer\u00eancias de dados entre\n\nas mem\u00f3rias interna e externa, buscando diminuir o n\u00famero de acessos a disco.\n\nMaiores detalhes sobre esta estrutura encontram-se na se\u00e7\u00e3o 2.3 e os resultados dos\n\ntestes da compara\u00e7\u00e3o deste novo m\u00e9todo com o EMViewshed s\u00e3o apresentados na\n\nse\u00e7\u00e3o 2.5.\n\n2.2 Referencial te\u00f3rico\n\n2.2.1 Visibilidade em terrenos\n\nUm terreno corresponde a uma regi\u00e3o da superf\u00edcie da Terra cujo relevo \u00e9 repre-\n\nsentado por uma Modelo Digital de Terreno (MDT) que pode ser representado por\n\numa malha triangular irregular (triangulated irregular network, ou TIN ), por linhas\n\nde contorno ou por uma matriz que cont\u00e9m eleva\u00e7\u00f5es de pontos posicionados em in-\n\ntervalos regularmente espa\u00e7ados. Devido \u00e0 sua simplicidade e ao grande volume de\n\ndados dispon\u00edveis na forma matricial, esta \u00e9 a representa\u00e7\u00e3o utilizada nos algoritmos\n\ndeste trabalho. \u00c9 importante observar que h\u00e1 m\u00e9todos eficientes para a convers\u00e3o\n\nentre as diferentes formas de representa\u00e7\u00e3o, e portanto, esta escolha n\u00e3o representa\n\numa restri\u00e7\u00e3o relevante [Felgueiras, 2001].\n\nUm observador \u00e9 um ponto no espa\u00e7o a partir do qual se deseja visualizar ou\n\ncomunicar com outros pontos no espa\u00e7o, chamados de alvos. As nota\u00e7\u00f5es usuais\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 10\n\npara um observador e um alvo s\u00e3o, respectivamente, O e T e estes pontos podem\n\nestar a certas alturas acima do terreno denotadas respectivamente por hO e hT . Os\n\npontos do terreno verticalmente abaixo de de O e T s\u00e3o denominados pontos-base\n\ne s\u00e3o denotados por Ob e Tb, respectivamente.\n\nO raio de interesse, ?, de um observador O representa o alcance de sua vis\u00e3o,\n\nou seja, o valor m\u00e1ximo da dist\u00e2ncia em que ele \u00e9 capaz de enxergar ou se comunicar.\n\nPor conveni\u00eancia, a dist\u00e2ncia entre um observador O e um alvo T \u00e9 definida como\n\na dist\u00e2ncia entre Ob e Tb.\n\nUm alvo T \u00e9 vis\u00edvel a partir um observador O se, e somente se, |Tb ?Ob| ? ? e\n\nn\u00e3o h\u00e1 nenhum ponto da superf\u00edcie do terreno interceptando o segmento de reta OT ,\n\nque \u00e9 chamado de linha de vis\u00e3o, ou line of sight (LOS). Um exemplo de c\u00e1lculo de\n\nvisibilidade \u00e9 mostrado na Figura 2.1: o alvo T1 \u00e9 vis\u00edvel a partir de O, mas T2 n\u00e3o\n\n\u00e9 vis\u00edvel, pois OT2 \u00e9 bloqueado por uma regi\u00e3o do terreno.\n\nFigura 2.1: C\u00e1lculo da visibilidade em um corte vertical do terreno. O alvo T1 \u00e9\nvis\u00edvel a partir de O e T2 n\u00e3o \u00e9 vis\u00edvel.\n\n\u00c9 importante ressaltar que a verifica\u00e7\u00e3o de que a linha de vis\u00e3o intercepta\n\nou n\u00e3o o terreno n\u00e3o \u00e9 trivial. O problema \u00e9 que a matriz de eleva\u00e7\u00e3o cont\u00e9m\n\ninforma\u00e7\u00f5es somente sobre alguns pontos discretos do terreno, enquanto as linhas\n\nde vis\u00e3o s\u00e3o cont\u00ednuas e geralmente passam entre pontos adjacentes, sem intercept\u00e1-\n\nlos, o que muitas vezes requer um m\u00e9todo de interpola\u00e7\u00e3o entre os pontos conhecidos\n\n[Magalh\u00e3es et al., 2011].\n\nO viewshed (ou mapa de visibilidade) de um observador O \u00e9 o conjunto de\n\npontos do terreno cujos alvos correspondentes s\u00e3o vis\u00edveis a partir de O.\n\n2.2.2 Algoritmos para c\u00e1lculo de viewshed em mem\u00f3ria\n\ninterna\n\nDados um terreno representado por uma matriz de eleva\u00e7\u00e3o de dimens\u00f5es n \u00d7 n, as\n\ncoordenadas (x, y) do observador O, o seu raio de interesse ? e as alturas hO e hT ,\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 11\n\no objetivo de um algoritmo de c\u00e1lculo do viewshed de O \u00e9 determinar, para cada\n\nc\u00e9lula da matriz, se seu alvo correspondente \u00e9 vis\u00edvel por O. Uma das maneiras\n\nde representar o viewshed calculado \u00e9 utilizando uma matriz de bits com dimens\u00f5es\n\nn\u00d7n onde um bit com valor 1 indica que o alvo T associado \u00e0quela c\u00e9lula do terreno\n\n\u00e9 vis\u00edvel por O, enquanto um bit com valor 0 indica que T n\u00e3o \u00e9 vis\u00edvel.\n\nO algoritmo proposto neste trabalho para o c\u00e1lculo do viewshed em grandes\n\nterrenos armazenados em mem\u00f3ria externa \u00e9 baseado no algoritmo para mem\u00f3ria\n\ninterna proposto por Franklin and Ray [1994], que ser\u00e1 descrito de forma resumida\n\na seguir.\n\nEste algoritmo assume que todas as c\u00e9lulas s\u00e3o inicialmente n\u00e3o vis\u00edveis e\n\nrealiza um processamento iterativo para determinar quais c\u00e9lulas s\u00e3o vis\u00edveis a partir\n\nde O. Primeiramente \u00e9 definida uma regi\u00e3o quadrangular S que envolva o c\u00edrculo\n\nde raio ? centrado em O (por exemplo, veja a figura 2.2a onde \u00e9 mostrada esta\n\nregi\u00e3o para ? = 4). Da\u00ed, s\u00e3o tra\u00e7ados 8? segmentos de reta ligando O a cada uma\n\ndas c\u00e9lulas na borda de S. Cada um destes segmentos define um corte vertical no\n\nterreno - a figura 2.2 exibe um exemplo desses segmentos e de um desses cortes.\n\nO passo seguinte consiste em determinar quais c\u00e9lulas fazem parte de cada\n\ncorte vertical. Para alguns casos, como os dos segmentos OA e OE mostrados na\n\nfigura 2.2a, \u00e9 f\u00e1cil determinar estas c\u00e9lulas. No entanto, para a maioria dos segmen-\n\ntos essa determina\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples, como \u00e9 o caso dos segmentos OB, OC e\n\nOD, onde \u00e9 necess\u00e1rio determinar quais c\u00e9lulas s\u00e3o mais relevantes para cada seg-\n\nmento. Esse problema equivale \u00e0 rasteriza\u00e7\u00e3o de segmentos e pode ser solucionado\n\nutilizando o algoritmo de Bresenham [1965], de modo que seja selecionada apenas\n\numa c\u00e9lula para cada coordenada X ou Y (dependendo da inclina\u00e7\u00e3o do segmento).\n\nAp\u00f3s a determina\u00e7\u00e3o das c\u00e9lulas de cada corte vertical, o pr\u00f3ximo passo \u00e9\n\npercorrer estas c\u00e9lulas verificando quais s\u00e3o vis\u00edveis a partir de O. Seja um segmento\n\ncomposto pelas c\u00e9lulas c0, c1, \u00b7 \u00b7 \u00b7 , ck, sendo que o observador est\u00e1 posicionado na\n\nc\u00e9lula c0 e ck \u00e9 a \u00faltima c\u00e9lula na regi\u00e3o S dentro do raio de vis\u00e3o do observador.\n\nEnt\u00e3o o processo consiste em inicialmente definir as c\u00e9lulas c0 e c1 como vis\u00edveis e\n\ninicializar \u00b5, que armazena a maior inclina\u00e7\u00e3o de uma linha de vis\u00e3o j\u00e1 processada,\n\ncom a inclina\u00e7\u00e3o da reta que passa pelos pontos c0 e c1. A partir da\u00ed, cada c\u00e9lula ci\n\u00e9 processada em ordem crescente de i, analisando-se a inclina\u00e7\u00e3o da reta que liga o\n\nobservador ao alvo que est\u00e1 posicionado acima de ci; se esta inclina\u00e7\u00e3o \u00e9 maior ou\n\nigual a \u00b5 ent\u00e3o a c\u00e9lula ci \u00e9 marcada como vis\u00edvel e \u00b5 \u00e9 atualizado com o valor da\n\ninclina\u00e7\u00e3o da reta que passa por O e ci.\n\nAplicando este algoritmo ao exemplo dado na figura 2.2b temos que os alvos\n\nposicionados acima dos pontos 0, 1, 2, 3 e 7 s\u00e3o vis\u00edveis a partir do observador posi-\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 12\n\nFigura 2.2: Algoritmo RFVS. a exemplos de segmentos em um terreno; (b) exemplo\nde um corte vertical definido por um segmento.\n\ncionado acima do ponto 0 (representado por um tri\u00e2ngulo) e os alvos posicionados\n\nacima dos pontos 4, 5 e 6 n\u00e3o s\u00e3o vis\u00edveis.\n\n2.2.3 Algoritmos eficientes para E/S\n\nDurante o processamento de grande volume de dados, a transfer\u00eancia de dados entre\n\na mem\u00f3ria interna (mais r\u00e1pida) e o armazenamento externo (mais lento) frequen-\n\ntemente torna-se o gargalo do processamento. Portanto, o projeto e an\u00e1lise de\n\nalgoritmos usados para processar esses dados precisam ser feitos sob um modelo\n\ncomputacional que avalia as opera\u00e7\u00f5es de entrada e sa\u00edda (E/S). Um modelo fre-\n\nquentemente utilizado foi proposto por Aggarwal and Vitter [1988]. Nesse modelo,\n\ncada opera\u00e7\u00e3o de E/S corresponde \u00e0 transfer\u00eancia de um bloco de tamanho B entre\n\na mem\u00f3ria externa e a mem\u00f3ria interna. O desempenho do algoritmo \u00e9 determinado\n\nconsiderando-se o n\u00famero de opera\u00e7\u00f5es de E/S executadas.\n\nA complexidade de um algoritmo \u00e9 definida com base na complexidade de\n\nproblemas fundamentais como varredura (scan) e ordena\u00e7\u00e3o (sort) de N elementos\n\ncont\u00edguos armazenados em mem\u00f3ria externa. Se M \u00e9 o tamanho da mem\u00f3ria interna\n\ndispon\u00edvel, estas complexidades s\u00e3o definidas como:\n\nscan (N) = ?\n\n(\n\nN\n\nB\n\n)\n\ne sort (N) = ?\n\n(\n\nN\n\nB\nlog( M\n\nB\n)\n\n(\n\nN\n\nB\n\n))\n\n\u00c9 importante salientar que normalmente scan(N) &lt;sort(N)&lt;&lt;N e, ent\u00e3o,\n\num algoritmo que realiza O(sort(N)) opera\u00e7\u00f5es de E/S \u00e9 significantemente mais\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 13\n\neficiente do que um que realiza O(N) opera\u00e7\u00f5es. Assim, muitos algoritmos tentam\n\nreorganizar os dados na mem\u00f3ria externa com o objetivo de diminuir o n\u00famero de\n\nopera\u00e7\u00f5es de E/S feitas.\n\n2.2.4 O m\u00e9todo EMViewshed\n\nA estrat\u00e9gia proposta por Andrade et al. [2011] consiste em gerar e armazenar\n\nem mem\u00f3ria externa uma lista com informa\u00e7\u00f5es de todas as c\u00e9lulas do terreno\n\ne orden\u00e1-la de acordo com a ordem em que estas c\u00e9lulas ser\u00e3o processadas pelo\n\nalgoritmo. Assim, o algoritmo pode percorrer esta lista sequencialmente, evitando\n\nacessos aleat\u00f3rios \u00e0 mem\u00f3ria externa.\n\nMais especificamente, o algoritmo cria uma lista Q de pares (c, i), onde c \u00e9\n\numa c\u00e9lula e i \u00e9 um \u00edndice que indica \u201cquando\u201d c deveria ser processada. Isto \u00e9,\n\nse uma c\u00e9lula c est\u00e1 associada a um \u00edndice k, ent\u00e3o c seria a k-\u00e9sima c\u00e9lula a ser\n\nprocessada.\n\nPara determinar os \u00edndices \u00e9 utilizado um processo similar ao descrito na se\u00e7\u00e3o\n\n2.2.2, onde s\u00e3o tra\u00e7adas diversas linhas de vis\u00e3o em sentido anti-hor\u00e1rio, e as c\u00e9lulas\n\nrecebem \u00edndices numerados de forma crescente em cada linha de vis\u00e3o. Uma mesma\n\nc\u00e9lula pode receber v\u00e1rios \u00edndices (e possuir v\u00e1rias c\u00f3pias em Q) j\u00e1 que ela pode ser\n\ninterceptada por m\u00faltiplas linhas de vis\u00e3o.\n\nDepois de criada, a lista Q \u00e9 ordenada usando os \u00edndices como chave de com-\n\npara\u00e7\u00e3o, e ent\u00e3o as c\u00e9lulas s\u00e3o processadas na ordem da lista ordenada por um\n\nalgoritmo similar ao de mem\u00f3ria interna que, neste caso, l\u00ea os dados de eleva\u00e7\u00e3o\n\ndiretamente de Q. Al\u00e9m disso, este algoritmo utiliza uma outra lista Q? onde as c\u00e9-\n\nlulas vis\u00edveis s\u00e3o inseridas. Ap\u00f3s o processamento de todas as c\u00e9lulas, Q? \u00e9 ordenada\n\nlexicograficamente pelas coordenadas x e y e as c\u00e9lulas vis\u00edveis s\u00e3o armazenadas em\n\num arquivo de sa\u00edda, onde as posi\u00e7\u00f5es vis\u00edveis s\u00e3o indicadas por 1 e as n\u00e3o vis\u00edveis\n\npor 0.\n\nUm ganho de efici\u00eancia no processo \u00e9 alcan\u00e7ado mantendo parte das matrizes\n\nem mem\u00f3ria interna. As c\u00e9lulas que est\u00e3o em mem\u00f3ria interna n\u00e3o s\u00e3o inseridas\n\nem Q e Q? e, quando uma c\u00e9lula precisa ser processada, o algoritmo verifica se esta\n\nc\u00e9lula est\u00e1 na mem\u00f3ria interna. Se estiver, ela \u00e9 processada normalmente; caso\n\ncontr\u00e1rio, ela \u00e9 lida de Q.\n\nPara analisar a complexidade deste algoritmo, \u00e9 necess\u00e1rio utilizar um modelo\n\ncomo o descrito na Se\u00e7\u00e3o 2.2.3. Seja T o terreno representado por uma matriz de\n\neleva\u00e7\u00e3o de dimens\u00f5es n\u00d7n, ou seja, que contenha n2 c\u00e9lulas. No primeiro passo do\n\nalgoritmo, para ler as c\u00e9lulas do terreno e criar a lista Q, s\u00e3o realizadas O(scan(?2))\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 14\n\nopera\u00e7\u00f5es de E/S. Neste passo, como mostrado na se\u00e7\u00e3o 2.2.2, o algoritmo tra\u00e7a\n\n8? linhas de vis\u00e3o, cada uma contendo ? c\u00e9lulas. Assim, a lista Q cont\u00e9m O(?2)\n\nelementos.\n\nEm seguida esta lista \u00e9 ordenada e ent\u00e3o percorrida sequencialmente para\n\nse calcular a visibilidade das c\u00e9lulas, opera\u00e7\u00f5es que apresentam complexidades\n\nO(sort(?2)) e O(scan(?2)), respectivamente.\n\nFinalmente, a lista de pontos vis\u00edveis que cont\u00e9m, no m\u00e1ximo, O(?2) c\u00e9lulas\n\n\u00e9 ordenada e o viewshed do terreno \u00e9 gravado em disco, opera\u00e7\u00f5es que apresentam\n\ncomplexidades O(sort(?2)) e O(scan(n2)), respectivamente. Como no pior caso\n\n? = O(n), temos que a complexidade do algoritmo \u00e9:\n\nO (sort (?2)) = O (sort (n2)) = O\n\n(\n\nn2\n\nB\nlog( M\n\nB\n)\n\n(\n\nn2\n\nB\n\n))\n\n2.3 O m\u00e9todo TiledVS\n\nAo analisar o algoritmo descrito na se\u00e7\u00e3o 2.3, pode-se perceber que o acesso \u00e0s\n\nposi\u00e7\u00f5es das matrizes apresenta um padr\u00e3o radial, ou seja, as c\u00e9lulas s\u00e3o acessadas\n\na partir daquela que cont\u00e9m o observador at\u00e9 cada c\u00e9lula que est\u00e1 no limite de seu\n\nraio de interesse, tra\u00e7ando diversas linhas de forma circular. Este padr\u00e3o de acessos\n\napresenta a propriedade de localidade de refer\u00eancia espacial: as c\u00e9lulas acessadas em\n\num curto espa\u00e7o de tempo est\u00e3o, na maioria das vezes, pr\u00f3ximas umas das outras\n\nna matriz. O problema \u00e9 que, em geral, uma matriz bidimensional \u00e9 armazenada\n\nde forma linear na mem\u00f3ria e, por isso, muitas vezes c\u00e9lulas que s\u00e3o vizinhas na\n\nmatriz ficam armazenadas em posi\u00e7\u00f5es distantes umas das outras na mem\u00f3ria. Como\n\nnormalmente a localidade de refer\u00eancia espacial utilizada pela hierarquia de mem\u00f3ria\n\ndo computador \u00e9 baseada no acesso sequencial [Patterson and Hennessy, 2008], esta\n\nforma de representa\u00e7\u00e3o n\u00e3o tira proveito da localidade de refer\u00eancia espacial em\n\ntermos bidimensionais, tornando o acesso ineficiente.\n\nPara aproveitar a propriedade de localidade espacial e tentar diminuir o n\u00fa-\n\nmero de acessos a disco, este trabalho prop\u00f5e um m\u00e9todo denominado TiledVS, cuja\n\nestrat\u00e9gia consiste em adaptar o m\u00e9todo RFVS, descrito na se\u00e7\u00e3o 2.2.2, de forma\n\nque todos acessos realizados \u00e0s matrizes sejam gerenciados por uma estrutura de\n\ndados denominada TiledMatrix [Silveira et al., 2013], que \u00e9 capaz de armazenar e\n\ngerenciar grandes matrizes em mem\u00f3ria externa. Mais especificamente, um objeto\n\ndo tipo TiledMatrix representa uma matriz que \u00e9 dividida em blocos menores de\n\ndimens\u00f5es fixas que s\u00e3o armazenados de forma sequencial em um arquivo na mem\u00f3-\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 15\n\nria externa. Ent\u00e3o, esta estrutura de dados gerencia a transfer\u00eancia de blocos entre\n\nas mem\u00f3rias interna e externa sempre que necess\u00e1rio. Em outras palavras, alguns\n\nblocos do terreno ficam armazenados em mem\u00f3ria interna enquanto estiverem sendo\n\nprocessados, e podem voltar \u00e0 mem\u00f3ria externa quando n\u00e3o forem mais necess\u00e1rios,\n\ndando lugar a outros blocos. Desta forma, a estrutura de dados funciona como uma\n\nmem\u00f3ria cache gerenciada pela aplica\u00e7\u00e3o, que busca predizer quais ser\u00e3o os pr\u00f3xi-\n\nmos blocos do terreno a terem posi\u00e7\u00f5es acessadas no processamento, mantendo-os\n\nna mem\u00f3ria interna.\n\nUma quest\u00e3o importante a se considerar na implementa\u00e7\u00e3o desta estrutura\n\nrefere-se \u00e0 pol\u00edtica utilizada para determinar qual bloco ser\u00e1 escolhido para ceder\n\nespa\u00e7o a novos blocos. Neste trabalho utilizou-se a estrat\u00e9gia de retirar da mem\u00f3ria\n\ninterna aquele que est\u00e1 h\u00e1 mais tempo sem ser acessado pela aplica\u00e7\u00e3o. Em outras\n\npalavras, sempre que uma c\u00e9lula de um bloco \u00e9 acessada, este bloco \u00e9 marcado com\n\num timestamp. Quando for necess\u00e1rio retirar um bloco da mem\u00f3ria interna para\n\ncarregar outro, ser\u00e1 escolhido aquele que tiver o menor timestamp. Esta estrat\u00e9gia\n\nfoi adotada baseado no fato de que h\u00e1 uma certa localidade no processamento das\n\nc\u00e9lulas pelo algoritmo. Isto \u00e9, se h\u00e1 um bloco que est\u00e1 h\u00e1 algum tempo sem ser\n\nacessado (nenhuma de suas c\u00e9lulas \u00e9 processada) ent\u00e3o h\u00e1 uma grande chance de que\n\ntodas as c\u00e9lulas daquele bloco j\u00e1 tenham sido processadas e o bloco n\u00e3o precisar\u00e1\n\nmais ser acessado.\n\nPara ilustrar este processo, considere uma matriz que foi dividida em 5 \u00d7 5\n\nblocos e uma mem\u00f3ria interna capaz de armazenar no m\u00e1ximo 5 desses blocos.\n\nSuponha que em determinado momento do processamento os blocos de n\u00fameros 8,\n\n9, 12, 13 e 14 estejam na mem\u00f3ria interna, como mostrado na Figura 2.3a. Se for\n\nrequisitado acesso a alguma c\u00e9lula que est\u00e1 contida em algum destes blocos, n\u00e3o\n\nser\u00e1 necess\u00e1rio busc\u00e1-la na mem\u00f3ria externa, e o acesso ser\u00e1 feito de forma mais\n\neficiente. Por outro lado, se for requisitado acesso a alguma c\u00e9lula de outro bloco,\n\ndiz-se que ocorreu uma cache miss, e esta c\u00e9lula dever\u00e1 ser buscada na mem\u00f3ria\n\nexterna. Por\u00e9m, por acreditar que logo em seguida ser\u00e3o requisitados acessos a\n\noutras c\u00e9lulas deste mesmo bloco, a estrutura de dados transfere e carrega para a\n\nmem\u00f3ria interna o bloco inteiro que cont\u00eam a c\u00e9lula requisitada, substituindo um\n\ndos blocos que j\u00e1 estavam carregados. Considere, por exemplo, uma requisi\u00e7\u00e3o de\n\nacesso a alguma c\u00e9lula do bloco 4, e que o bloco 14 \u00e9 o que est\u00e1 h\u00e1 mais tempo\n\nsem ser acessado dentre aqueles carregados em mem\u00f3ria interna e, portanto, \u00e9 o\n\nque dever\u00e1 ser substitu\u00eddo. Antes de realizar a substitui\u00e7\u00e3o, \u00e9 necess\u00e1rio verificar\n\nse alguma instru\u00e7\u00e3o de escrita foi executada no bloco 14 enquanto ele esteve em\n\nmem\u00f3ria interna. Se sim, seus dados devem ser atualizados na mem\u00f3ria externa.\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 16\n\nCaso contr\u00e1rio n\u00e3o \u00e9 necess\u00e1rio realizar esta atualiza\u00e7\u00e3o. Depois dessa verifica\u00e7\u00e3o,\n\no bloco 4 \u00e9 copiado para a mem\u00f3ria interna, resultando no estado representado na\n\nFigura 2.3b. Assim, para cada cache miss ocorrida, acontece exatamente um acesso\n\nde leitura e no m\u00e1ximo um acesso de escrita a um bloco na mem\u00f3ria externa.\n\nFigura 2.3: Transfer\u00eancias entre as mem\u00f3rias interna e externa gerenciadas pela\nclasse TiledMatrix. Em (a), uma c\u00e9lula do bloco 4 \u00e9 acessada e, como esse bloco n\u00e3o\nest\u00e1 na mem\u00f3ria principal, ele \u00e9 carregado, substituindo o bloco 14, que foi utilizado\nmenos recentemente. A figura (b) apresenta o estado da mem\u00f3ria interna ap\u00f3s a\ntroca do bloco 14 pelo bloco 4.\n\nAl\u00e9m de tirar proveito de dados com localidade de refer\u00eancia espacial, outra\n\ngrande vantagem de utilizar esta estrutura \u00e9 que ela proporciona uma maior facili-\n\ndade para a adapta\u00e7\u00e3o de algoritmos para mem\u00f3ria interna j\u00e1 existentes, de modo\n\nque seus desempenhos considerando dados armazenados em mem\u00f3ria externa sejam\n\nmelhorados. Basicamente, \u00e9 necess\u00e1rio somente substituir a utiliza\u00e7\u00e3o de matri-\n\nzes tradicionais pela utiliza\u00e7\u00e3o da classe TiledMatrix. Desta forma, esta estrat\u00e9gia\n\npode ser utilizada em diversas aplica\u00e7\u00f5es, n\u00e3o somente na \u00e1rea de CIG, mas sem-\n\npre que forem utilizadas matrizes maiores do que o espa\u00e7o dispon\u00edvel em mem\u00f3ria\n\ninterna e que o acesso \u00e0s posi\u00e7\u00f5es das matrizes apresente um padr\u00e3o de localidade\n\nde refer\u00eancia espacial.\n\n2.4 Complexidade do algoritmo\n\nAs dimens\u00f5es dos blocos utilizados e o n\u00famero m\u00e1ximo de blocos que a mem\u00f3ria\n\ninterna utilizada pode armazenar t\u00eam influ\u00eancia direta no desempenho do algoritmo.\n\nConsidere, por exemplo, a inicializa\u00e7\u00e3o da matriz de eleva\u00e7\u00e3o, em que uma parte\n\ndo terreno \u00e9 carregada na estrutura TiledMatrix. Mais especificamente, nesta etapa\n\ns\u00e3o copiadas para a estrutura as c\u00e9lulas que est\u00e3o contidas em um quadrado de\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 17\n\ndimens\u00f5es (2? + 1) \u00d7 (2? + 1) com centro no observador O, onde ? \u00e9 o raio de\n\ninteresse de O.\n\nPor quest\u00f5es de efici\u00eancia, \u00e9 importante que a mem\u00f3ria interna dispon\u00edvel seja\n\nsuficiente para armazenar no m\u00ednimo 2?+1\nt\n\nblocos, onde t \u00e9 a dimens\u00e3o de cada\n\nlado dos blocos. Esta condi\u00e7\u00e3o \u00e9 necess\u00e1ria para que a inicializa\u00e7\u00e3o da estrutura\n\nTiledMatrix possa ocorrer sem que seja necess\u00e1rio carregar um mesmo bloco mais de\n\numa vez, ou seja, para que n\u00e3o ocorram cache misses. Para ilustrar a necessidade\n\ndessa condi\u00e7\u00e3o, suponha que uma matriz de eleva\u00e7\u00e3o de dimens\u00f5es 50 \u00d7 50 seja\n\narmazenada em uma TiledMatrix M que a divide em blocos de dimens\u00f5es 10 \u00d7 10 e\n\nque a mem\u00f3ria interna comporte apenas 4 desses blocos. Note que, devido ao padr\u00e3o\n\nque remove o bloco menos recentemente utilizado, quando os 10 \u00faltimos elementos da\n\nprimeira linha da matriz forem copiados para M o bloco que cont\u00e9m os 10 primeiros\n\nelementos dessa linha dever\u00e1 ser removido da mem\u00f3ria interna. Por\u00e9m, ao copiar os\n\n10 primeiros elementos da pr\u00f3xima linha da matriz para M, esse bloco dever\u00e1 voltar\n\nnovamente para a mem\u00f3ria interna. Esse padr\u00e3o de acesso ocorrer\u00e1 diversas vezes\n\nem todas as linhas de M e, assim, esse processo seria ineficiente. Portanto, para\n\nrealizar a an\u00e1lise de complexidade do algoritmo, ser\u00e1 suposto que o tamanho da\n\nmem\u00f3ria interna atenda a esta restri\u00e7\u00e3o e, assim, cada bloco ser\u00e1 carregado apenas\n\numa vez durante a inicializa\u00e7\u00e3o dessa estrutura de dados.\n\nComo o algoritmo precisa carregar da matriz de eleva\u00e7\u00e3o (2? + 1) \u00d7 (2? + 1)\n\nc\u00e9lulas, a inicializa\u00e7\u00e3o do algoritmo realiza O(scan(?2)) opera\u00e7\u00f5es de E/S.\n\nDurante a etapa do algoritmo onde s\u00e3o tra\u00e7adas diversas linhas de vis\u00e3o em\n\nsentido anti-hor\u00e1rio para calcular o viewshed de O, tamb\u00e9m ser\u00e1 necess\u00e1rio carregar\n\ncada bloco do terreno uma vez, com exce\u00e7\u00e3o dos blocos que cont\u00e9m simultaneamente\n\nc\u00e9lulas das primeiras e \u00faltimas linhas de vis\u00e3o a serem processadas, que precisar\u00e3o\n\nser carregados duas vezes. Como o n\u00famero de c\u00e9lulas processadas \u00e9 O(?2) e cada\n\nc\u00e9lula \u00e9 transferida da mem\u00f3ria externa no m\u00e1ximo duas vezes, esta etapa tamb\u00e9m\n\n\u00e9 realizada em O(scan(?2)) opera\u00e7\u00f5es de E/S.\n\nDepois de calculado, o viewshed \u00e9 armazenado em um arquivo de sa\u00edda com um\n\nbit para cada c\u00e9lula do terreno. Se o terreno tiver dimens\u00f5es n \u00d7 n, ser\u00e3o efetuadas\n\nO(scan(n2)) opera\u00e7\u00f5es de E/S. Portanto, a complexidade do algoritmo TiledVS \u00e9:\n\nO (scan (n2)) = O\n\n(\n\nn2\n\nB\n\n)\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 18\n\n2.5 Resultados\n\nO m\u00e9todo TiledVS foi implementado em C++ e compilado com o g++ 4.5.2. Optou-\n\nse por realizar os testes em um computador com pouca mem\u00f3ria RAM para que\n\nfosse necess\u00e1rio realizar opera\u00e7\u00f5es de processamento em mem\u00f3ria externa mesmo\n\npara terrenos n\u00e3o t\u00e3o grandes (como os com 100002 e 200002 c\u00e9lulas). Por isso,\n\nos testes foram executados em um PC Pentium 4 com 3.6GHz, 1GB de RAM,\n\nHD Sata de 160GB e 7200RPM. O sistema operacional utilizado foi o o Linux,\n\ndistribui\u00e7\u00e3o Ubuntu 11.04 de 64bits. Dos 1024MB dispon\u00edveis em mem\u00f3ria interna,\n\nforam utilizados 800MB para armazenar os dados, e os demais foram reservados\n\npara uso do sistema.\n\nOs terrenos utilizados nos testes foram obtidos na p\u00e1gina do The Shuttle Radar\n\nTopography Mission (SRTM) [Rabus et al., 2003]. Os dados correspondem a duas\n\nregi\u00f5es distintas dos EUA amostradas em diferentes resolu\u00e7\u00f5es, gerando assim ter-\n\nrenos de diferentes tamanhos (100002, 200002, 300002, 400002 e 500002). Para cada\n\ntamanho de terreno, foi calculada a m\u00e9dia do tempo necess\u00e1rio para processamento\n\ndas duas regi\u00f5es.\n\nEm todos os testes foi considerado o pior caso, ou seja, o valor para o raio de\n\ninteresse utilizado foi grande o suficiente para cobrir todo o terreno. Para avaliar\n\na influ\u00eancia do n\u00famero de pontos vis\u00edveis no tempo de execu\u00e7\u00e3o, o observador foi\n\nposicionado em diferentes alturas acima do terreno (50 e 100 metros). Al\u00e9m disso,\n\nem todos os testes foi considerado que hO = hT , ou seja, os poss\u00edveis alvos est\u00e3o\n\nposicionados \u00e0 mesma altura que o observador. Os tempos de execu\u00e7\u00e3o do m\u00e9todo\n\nTiledVS foram comparados com os tempos do m\u00e9todo EMViewshed, uma vez que\n\neste mostrou-se mais eficiente que os demais m\u00e9todos encontrados em literatura\n\n[Andrade et al., 2011].\n\nAs Tabelas 2.1 e 2.2 mostram os tempos m\u00e9dios de execu\u00e7\u00e3o, em segundos,\n\nnecess\u00e1rios para processar cada um dos terrenos, utilizando o m\u00e9todo EMViewshed\n\n(EMVS) e o m\u00e9todo TiledVS considerando diferentes tamanhos de blocos (1002,\n\n2502, 5002, 10002, 25002 e 50002), sendo que a Tabela 2.1 refere-se aos testes com\n\nhO = hT = 50, enquanto a Tabela 2.2 refere-se aos testes com hO = hT = 100. A\n\nlinha Dim. Bl. indica o tamanhos dos blocos utilizados, e a linha # Bl. indica\n\no n\u00famero m\u00e1ximo de blocos de cada tamanho que podem ser armazenados nos\n\n800MB dispon\u00edveis na mem\u00f3ria interna, ou seja, o tamanho da cache utilizada pela\n\nTiledMatrix.\n\nPara cada tamanho de terreno, o tempo m\u00e9dio destacado em negrito indica o\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 19\n\nTabela 2.1: Tempos m\u00e9dios de execu\u00e7\u00e3o, em segundos, para os m\u00e9todos EMViewshed\n(EMVS) e TiledVS, considerando diferentes tamanhos de blocos e terrenos e altura\nde 50 metros. A linha Dim. Bl. indica as dimens\u00f5es dos blocos utilizados, e a linha\n# Bl. indica o n\u00famero m\u00e1ximo de blocos que podem ser armazenados na mem\u00f3ria\ninterna.\n\nTamanho TiledVS\ndo terreno Dim. Bl. 1002 2502 5002 10002 25002 50002 EMVS\n# c\u00e9lulas) # Bl. 27962 4473 1118 279 44 11\n\n100002 58 57 57 58 63 60 37\n200002 443 305 304 298 300 307 220\n300002 1395 828 752 729 735 752 1465\n400002 1772 1229 1179 1184 1185 1223 4709\n500002 7717 2833 2417 2334 2309 2338 8988\n\nTabela 2.2: Tempos m\u00e9dios de execu\u00e7\u00e3o, em segundos, para os m\u00e9todos EMViewshed\n(EMVS) e TiledVS, considerando diferentes tamanhos de blocos e terrenos e altura\nde 100 metros. A linha Dim. Bl. indica as dimens\u00f5es dos blocos utilizados, e a linha\n# Bl. indica o n\u00famero m\u00e1ximo de blocos que podem ser armazenados na mem\u00f3ria\ninterna.\n\nTamanho TiledVS\ndo terreno Dim. Bl. 1002 2502 5002 10002 25002 50002 EMVS\n# c\u00e9lulas) # Bl. 27962 4473 1118 279 44 11\n\n100002 64 64 63 65 65 65 37\n200002 470 333 319 311 312 318 234\n300002 1753 891 831 803 784 806 1502\n400002 2148 1407 1303 1293 1256 1293 5530\n500002 7570 2868 2437 2406 2346 2364 9839\n\nm\u00e9todo que apresentou o melhor desempenho. Os resultados mostram que, para os\n\nterrenos de dimens\u00f5es 100002 e 200002, o m\u00e9todo EMViewshed apresentou desem-\n\npenho melhor do que o TiledVS, independentemente do tamanho dos blocos. J\u00e1\n\npara os terrenos de tamanhos 300002, 400002 e 500002, o m\u00e9todo TiledVS mostrou-\n\nse mais r\u00e1pido do que o EMViewshed para praticamente todos os testes realizados,\n\ncom exce\u00e7\u00e3o do que utilizou blocos de tamanho 1002 para processar o terreno de\n\ndimens\u00f5es 300002 com altura de 100 metros.\n\n\u00c9 poss\u00edvel perceber que o tamanho dos blocos afeta diretamente o desempenho\n\nda estrutura TiledMatrix. Enquanto os testes com blocos de tamanho 1002 apre-\n\n\n\n2. Uma abordagem eficiente para o c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa 20\n\nsentaram os piores tempos, os testes com blocos de tamanho 5002, 10002, e 25002\n\napresentaram os melhores tempos entre os tamanhos testados. Os gr\u00e1ficos da Figura\n\n2.4 mostram os tempos de execu\u00e7\u00e3o do EMViewshed e do TiledVS utilizando estes\n\n3 tamanhos de blocos.\n\nFigura 2.4: Tempos de execu\u00e7\u00e3o do EMViewshed (EMVS) e do TiledVS (TVS)\nutilizando os 3 tamanhos de blocos com melhores desempenhos e alturas de 50 e 100\nmetros.\n\nCom rela\u00e7\u00e3o \u00e0 varia\u00e7\u00e3o nas alturas dos observadores e alvos, pode-se perce-\n\nber que o n\u00famero de observadores vis\u00edveis afeta o tempo de execu\u00e7\u00e3o de ambos os\n\nm\u00e9todos, uma vez que os tempos m\u00e9dios para os testes com altura de 100m s\u00e3o\n\nmaiores do que os com altura de 50m. No entanto, este aumento foi consideravel-\n\nmente maior para o m\u00e9todo EMViewshed (11,1% em m\u00e9dia) do que para o m\u00e9todo\n\nTiledVS (4,7% em m\u00e9dia).\n\n2.6 Conclus\u00f5es e trabalhos futuros\n\nNeste trabalho foi apresentado o algoritmo TiledVS para c\u00e1lculo de viewshed em\n\nterrenos armazenados em mem\u00f3ria externa que mostrou-se at\u00e9 4,4 vezes mais r\u00e1pido\n\ndo que o EMViewshed, proposto por Andrade et al. [2011], que era at\u00e9 ent\u00e3o o\n\nm\u00e9todo mais eficiente encontrado em literatura.\n\nAl\u00e9m disso, a estrat\u00e9gia utilizada no m\u00e9todo apresentado pode ser adaptada\n\npara outras aplica\u00e7\u00f5es que utilizem matrizes grandes armazenadas em mem\u00f3ria ex-\n\nterna. Como trabalhos futuros, prop\u00f5e-se a utiliza\u00e7\u00e3o da classe TiledMatrix em\n\noutras aplica\u00e7\u00f5es com este perfil, assim como um estudo para avaliar a influ\u00eancia\n\ndo tamanho dos blocos no desempenho do algoritmo e desenvolver uma estrat\u00e9gia\n\npara determinar automaticamente o tamanho mais adequado.\n\n\n\n3. More efficient terrain viewshed compu-\n\ntation on massive datasets using exter-\n\nnal memory1\n\nAbstract\n\nWe present a better algorithm and implementation for external memory\n\nviewshed computation. It is about four times faster than the most recent and\n\nmost efficient published methods. Ours is also much simpler. Since processing\n\nlarge datasets can take hours, this improvement is significant. To reduce the\n\ntotal number of I/O operations, our method is based on subdividing the terrain\n\ninto blocks which are stored in a special data structure managed as a cache\n\nmemory.\n\nThe viewshed is that region of the terrain that is visible by a fixed\n\nobserver, who may be on or above the terrain. Its applications range from\n\nvisual nuisance abatement to radio transmitter siting and surveillance.\n\n3.1 Introduction\n\nTerrain modeling has been widely used in Geographical Information Science (GIS)\n\nincluding applications in hydrology, visibility and routing. In visibility applications\n\nit is usual to compute which points can be viewed from a given point (the observer)\n\nand the region composed of such points, known as viewshed [Franklin and Ray,\n\n1994]. Some applications include minimizing the number of cellular phone towers\n\nrequired to cover a region [Ben-Shimol et al., 2007], optimizing the number and\n\nposition of guards to cover a region [Franklin and Vogt, 2006], etc.\n\nThere are various algorithms for viewshed computation but most of them\n\nwere designed assuming that the terrain data fits in internal memory. However,\n\nthe huge volume of high resolution terrestrial data available has become a challenge\n\nfor GIS since the internal memory algorithms do not run well for such volume\n\nof data on most computers. Thus, it is important to optimize the massive data\n\n1Neste cap\u00edtulo \u00e9 apresentado o artigo \u201cMore efficient terrain viewshed computation on massive\ndatasets using external memory\u201d, apresentado no ACM SIGSPATIAL 2012 (20th International\nConference on Advances in Geographic Information Systems) [Ferreira et al., 2012b].\n\n21\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 22\n\nprocessing algorithms simultaneously for computation and data movement between\n\nthe external and internal memories since processing data in external memory takes\n\nmuch more time. That is, the algorithms for external memory should be designed\n\n(and analyzed) considering a computational model where the algorithm complexity\n\nis evaluated based on I/O operations. A model often used was proposed by Aggarwal\n\nand Vitter [1988] where an I/O operation is defined as the transfer of one disk\n\nblock of size B between the external and internal memories and the performance is\n\nmeasured considering the number of such I/O operations. The internal computation\n\ntime is assumed to be comparatively insignificant. An algorithm\u2019s complexity is\n\nrelated to the number of I/O operations performed by fundamental operations such\n\nas scanning or sorting N contiguous elements. Those are scan(N) = ?(N/B) and\n\nsort(N) = ?\n(\n\nN\nB\nlogM/B\n\nN\nB\n\n)\n\nwhere M is the internal memory size.\n\nThis work presents an efficient algorithm, named TiledVS, to compute the\n\nviewshed of a point on terrains stored in external memory. The large number of\n\ndisk accesses is optimized using a new library to manage the data swap between\n\nthe external and internal memories. This new algorithm was compared against the\n\nmost recent and most efficient published methods: EMViewshed [Andrade et al.,\n\n2011] and io_radial2, io_radial3 and io_centrifugal [Fishman et al., 2009]. Our\n\nnew method is much simpler and, also, the tests showed that it is more than four\n\ntimes faster than all of them. Since processing large datasets can take hours, this\n\nimprovement is significant.\n\n3.2 Definitions and related work\n\nA terrain is a tridimensional surface ? where any vertical line intersects ? in at most\n\none point. In this paper we will consider terrains represented by regular square grids\n\n(RSGs) since they use simpler data structures, i.e., matrices storing the elevations\n\nof regularly spaced positions of the terrain.\n\nAn observer is a point in the space from where the other terrain points (the\n\ntargets) will be visualized. Both the observer and the targets can be at a given\n\nheight above the terrain, respectively indicated by ho and ht. Usually, it is assumed\n\nthat the observer has a range of vision ?, the radius of interest, which means that\n\nthe observer can see points at a given distance ?. Thus, a target T is visible from\n\nO if and only if the distance of T from O is at most ? and the straight line, the line\n\nof sight, from O to T is always strictly above the terrain. See Figure 3.1.\n\nThe viewshed of O corresponds to all points that can be seen by O. Since\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 23\n\nFigure 3.1: Target\u2019s visibility: T1 and T3 are not visible but T2 is.\n\nwe are working with regular square grids, we represent a viewshed by a square\n\n(2? + 1) \u00d7 (2? + 1) matrix of bits where 1 indicates that the corresponding point is\n\nvisible and 0 is not. By definition, the observer is in the center of this matrix.\n\nEarlier works have presented different methods for viewshed computation.\n\nAmong the methods for RSG terrains, we can point out the one proposed by\n\nVan Kreveld [1996], and the one by Franklin et al., named RFVS [Franklin and\n\nRay, 1994]. These two methods are very efficient and are particularly important\n\nin this context because they were used as the base for some very recent and effi-\n\ncient methods for the viewshed computation in external memory: Fishman et al.\n\n[2009] adapted Van Kreveld\u2019s method, and Andrade et al. [2011] adapted the RFVS\n\nmethod. This work also presents an IO-efficient adaptation of the RFVS method.\n\nTherefore, below we will give a short description of the RFVS method.\n\nIn that method, the terrain cells\u2019 visibility is computed along rays connecting\n\nthe observer to all cells in the boundary of a square of side 2? + 1 centered at the\n\nobserver where ? is the radius of interest. That is, the algorithm creates a ray\n\nconnecting the observer to a cell on the boundary of this square, and this ray is\n\ncounterclockwise rotated around the observer following the cells in that boundary\n\nand the visibility of the cells in each ray is determined following the cells on the\n\nsegment. Thus, suppose the segment is composed by cells c0, c1, \u00b7 \u00b7 \u00b7 , ck where c0\nis the observer\u2019s cell and ck is a cell in the square boundary. Let ?i be the slope\n\nof the line connecting the observer to ci and let \u00b5 be the highest slope among all\n\nlines already processed, that is, when processing cell ci, \u00b5 = max{?1, ?2, \u00b7 \u00b7 \u00b7 , ?i?1}.\n\nThus, the target on ci is visible if and only if the slope of the line from O to the\n\ntarget above ci is greater than \u00b5. If yes, the corresponding cell in the viewshed\n\nmatrix is set to 1; otherwise, to 0. Also, if ?i > \u00b5 then \u00b5 is updated to ?i. We\n\nsay that a cell ci blocks the visibility of the target above cj if cell ci belongs to\n\nthe segment c0cj and ?i is greater or equal to the slope of the line connecting the\n\nobserver to the target above cj.\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 24\n\n3.3 TiledVS method\n\nAs mentioned in section 3.2, the RFVS sweeps the terrain cells rotating a ray\n\nconnecting the observer cell to a cell in the boundary of a bounding box and the\n\ncells\u2019 visibility is processed along this ray. Thus, the matrix access pattern presents\n\na spatial locality of reference, that is, in a short time interval, the accessed cells are\n\nclose in the matrix. However, this access pattern is not efficient in external memory\n\nsince the cells which are close in the (bidimensional) matrix may not be stored close\n\nbecause, usually, a matrix is stored using a linear row-major order.\n\nTo reduce the number of non-sequential accesses, we present a new method,\n\ncalled TiledVS, where the basic idea is to adapt the RFVS algorithm to manage\n\nthe access to the matrices stored in external memory using the library TiledMatrix\n\n[Silveira et al., 2013].\n\nIn brief, this library subdivides the matrix in small rectangular blocks (tiles)\n\nwhich are sequentially stored in the external memory. When a given cell needs\n\nto be accessed, the whole block containing that cell is loaded into the internal\n\nmemory. The library keeps some of these blocks in the internal memory using a\n\ndata structure, named MemBlocks, which is managed as a \u201ccache memory\" and the\n\nreplacement policy adopted is based on least recently used - LRU. That is, when\n\na block is accessed it is labeled with a timestamp and if it is necessary to load\n\na new block into the cache (and there is no room for this block), the block with\n\nsmaller timestamp is replaced with the new block. When a block is evicted, it\n\nis checked whether that block was updated (it is particularly important for the\n\nviewshed matrix); if any cell was updated then the block is written back to the disk.\n\nNow, we will show that it is possible to define the MemBlocks size such that\n\nthe adopted matrix partitioning associated with the LRU policy can be effective for\n\nthe RFVS algorithm, that is, we will prove that this process will load a block in the\n\ncache, keep it there while it is accessed and it will be evicted only when it will be\n\nno longer needed.\n\nIn the following, we will suppose that the matrix partitioning creates square\n\nblocks with ?\u00d7? cells and these blocks are grouped in vertical bands with ? columns\n\nof cells. See figure 3.2. And, given a ray r defined by the RFVS algorithm, without\n\nloss of generality, in the demonstrations below, we will consider rays whose slope is\n\nat most 45?. For rays with greater slope just replace rows with columns.\n\nLemma 3.3.1 Any ray intersects at most ?\n?\n+ 2 bands where ? is the radius of\n\ninterest (in number of terrain cells).\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 25\n\n(a) square blocks with 3 \u00d7 3 cells. (b) vertical bands with 3 columns.\n\nFigure 3.2: Matrix partitioning.\n\nProof 3.3.2 For the viewshed computation, the RFVS algorithm defines a square\n\nbounding box of side 2?+1 with the observer on its center and creates rays connecting\n\nthe observer to the center of the cells in the square border. Since any ray whose slope\n\nis at most 45? intersects ? + 1 columns in this square, this ray intersects ??+1\n?\n? + 1\n\nvertical bands. The additional +1 is because the observer may not be in the central\n\ncolumn of a band (notice that, if the observer in Figure 3.2b is moved one cell to the\n\nright, ray r0 will cross the last band boundary and will intersect an aditional band).\n\nSince ??+1\n?\n? = ? ?\n\n?\n? + 1 then ??+1\n\n?\n? + 1 ? ?\n\n?\n+ 2.\n\nLemma 3.3.3 Let rk and rk+1 be two consecutive rays in the RFVS algorithm\n\nsweeping. Then these two rays intersect at most 2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks.\n\nProof 3.3.4 Since the RFVS algorithm uses the Bresenham rasterization method,\n\nthere is exactly one cell for each column intersected by a ray. Let lr and cr be\n\nrespectively the number of rows and columns intersected by a ray r. As the ray slope\n\nis at most 45? then lr ? cr.\n\nGiven two consecutive rays rk and rk+1, the vertical distance between them is\n\nat most one cell side - see Figure 3.3a. As, for each vertical band, they intersect ?\n\ncolumns, they can intersect at most ? + 1 rows in that band. Thus, in each band,\n\nthey can intersect at most two blocks (since the block height is ? rows). Therefore,\n\nfrom Lemma 3.3.1, rays rk and rk+1 can intersect at most 2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks.\n\nLemma 3.3.5 Let r0 be the first ray in the sweeping sequence. Given a block B\n\nnot intersected by r0, let rk and rk+1 be two consecutive rays. If rk intersects B and\n\nrk+1 doesn\u2019t, then no other ray after rk will intersect block B.\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 26\n\nProof 3.3.6 It is straightforward from the fact that the algorithm uses a radial\n\nsweeping sequence and the blocks are convex. And it doesn\u2019t work for the blocks\n\nintersected by ray r0 because, considering the radial sweeping, these blocks can be\n\nintersected again by the last rays. See Figure 3.3b.\n\nTheorem 3.3.7 Given a block B not intersected by r0, if the MemBlocks size (in\n\nnumber of blocks) is, at least, 2\n(\n\n?\n?\n+ 2\n\n)\n\nthen the LRU policy will evict block B from\n\nMemBlocks only if it is no longer needed.\n\nProof 3.3.8 Suppose that MemBlocks has 2\n(\n\n?\n?\n+ 2\n\n)\n\nslots to store the blocks. Let\n\nrk and rk+1 be two consecutive rays such that rk intersects block B. At some point\n\nduring the processing of ray rk, block B will start to be processed and it is stored in\n\nthe MemBlocks (if rk is the first ray intersecting block B then B will be loaded in\n\nMemBlocks). Now, if ray rk+1 also intersects block B, this block needs to be processed\n\nagain. But, the MemBlocks size is enough to avoid block B eviction because, let\n\nB?1, B\n?\n\n2, \u00b7 \u00b7 \u00b7 , B\n?\n\nj be the sequence of blocks that need to be processed among the twice\n\nprocessing of B, that is, it is the sequence of blocks to be processed after B in the ray\n\nrk and before B in ray rk+1. From lemma 3.3.3, j ? 2\n(\n\n?\n?\n+ 2\n\n)\n\nand since B is not\n\nincluded in the sequence then j &lt;2\n(\n\n?\n?\n+ 2\n\n)\n\n. Thus, if MemBlocks size is 2\n(\n\n?\n?\n+ 2\n\n)\n\nthen it has slots to store all blocks that need to be processed and B will not be evicted.\n\nIn other words, the LRU policy will not evict block B because the distinct blocks that\n\nneed to be accessed can be stored in MemBlocks.\n\nOn the other hand, if ray rk+1 doesn\u2019t intersect block B then, from lemma 3.3.5,\n\nno other ray after rk will intersect B and thus, it can be evicted since it is no longer\n\nneeded. There is a special situation for the blocks intersected by r0 because, after\n\nbeing evicted, they can be loaded again when processing the last rays. But notice that\n\nthese blocks can be loaded at most twice. See Figure 3.3b where block B? is loaded\n\nin the processing of r0, is evicted after the processing of rm and it is loaded again\n\nwhen processing rn.\n\nIt is possible to demonstrate that the TiledVS algorithm does ?(scan(N)) I/O\n\noperations and takes ?(N) time to process a terrain with N cells considering that\n\nthe memory can store 2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks. This complexity works even if the radius of\n\ninterest ? is large to cover the whole terrain.\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 27\n\n(a) Blocks intersected by two consecu-\ntive rays\n\n(b) Block B? is loaded because of\nray r0, is evicted after ray rm and\nloaded again for ray r\n\nn\n.\n\nFigure 3.3: TiledVS algorithm.\n\n3.4 Experimental Results\n\nThe TiledVS method was implemented in C++ and compiled with g++ 4.3.4. It\n\nwas compared against the most efficient algorithms recently described in literature:\n\nio-radial2, io-radial3 and io-centrifugal, proposed by Fishman et al. [2009], and\n\nEMViewshed, proposed by Andrade et al. [2011].\n\nLacking access to Fishman\u2019s programs, we compared our algorithm to his\n\npublished results. We executed our algorithm using the same datasets and also a\n\nsame platform as that one used by those authors, i.e. a computer with an Intel Core\n\n2 Duo E7500 2.93GHz processor, 4GiB of RAM memory, and a 5400RPM SATA\n\nHD (Samsung HD103SI) which was rebooted with 512MiB RAM. The operational\n\nsystem used was Linux, Ubuntu 10.04 32bits distribution.\n\nOur results are presented in Table 3.1 and Figure 3.4 where we reproduce the\n\ntimes presented in Fishman et al. [2009]. Notice that our algorithm is faster than\n\nthe others in all situations and, on huge terrains, it is about 4 times faster. Also, the\n\ntable includes the processing time of our algorithm on very huge terrains generated\n\nby interpolation of Region02.\n\nWe also compared our new algorithm TiledVS against our previous one\n\nEMViewshed [Andrade et al., 2011]. We used different datasets generated from\n\ntwo distinct USA regions sampled at different resolutions using 2 bytes per eleva-\n\ntion value. The results are presented in Table 3.2. Note that our new algorithm\n\nTiledVS is about 7 times faster than our previous one.\n\nTable 3.3 presents the TiledVS running time (in seconds) for different terrain\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 28\n\nTable 3.1: Running time (seconds) for io-radial2 (io-r2), io-radial3 (io-r3), io-\ncentrifugal (io-cent) and TiledVS with 512MiB RAM.\n\nDataset Terrain size io-r2 io-r3 io-cent TiledVS\ncols rows GiB\n\nCumberlands 8704 7673 0.25 72 104 35 17\nUSA DEM 6 13500 18200 0.92 2804 458 115 85\nUSA DEM 2 11000 25500 1.04 1883 735 121 98\nWashington 31866 33454 3.97 13780 3008 676 386\nSRTM1-reg03 50401 43201 8.11 37982 6644 2845 994\nSRTM1-reg04 82801 36001 11.10 \u2014 8834 5341 1347\nSRTM1-reg04 68401 111601 28.44 \u2014 26193 12186 5034\nReg02 interp. 150000 91000 50.85 \u2014 \u2014 \u2014 5079\nReg02 interp. 200000 122000 90.89 \u2014 \u2014 \u2014 12642\n\nsizes using only 128MiB and 512MiB of RAM. As can be noticed, our algorithm is\n\nscalable to data that is much bigger than the machine internal memory.\n\n3.5 Conclusion\n\nWepresentedanewalgorithmforviewshedcomputationonhugegrid terrains stored\n\nin external memory. Our new method uses a special data structure to manage the\n\ndata transference between the internal and external memories reducing the number\n\nof I/O operations. For terrains with N cells, its I/O completixy is ?(scan(N)).\n\nTable 3.2: Running time (seconds) for EMViewshed (EMVS) and TiledVS with\n1024MiB RAM.\n\nSize EMVS TiledVS\ncols \u00d7 rows GiB\n\n30 000 \u00d7 30 000 1.68 727 256\n40 000 \u00d7 40 000 2.98 3168 515\n50 000 \u00d7 50 000 4.65 5701 812\n60 000 \u00d7 60 000 6.71 8961 1265\n\nThe algorithm was compared against the most recent and efficient algorithms\n\nin the literature and, as the tests showed, it was faster than all others. In general,\n\nit was about 4 times faster and this improvement is significant because processing\n\nhuge terrains can take hours. Also, it is much simpler.\n\n\n\n3. More efficient terrain viewshed computation on massive datasets\n\nusing external memory 29\n\nTable 3.3: TiledVS running time (seconds) using a RAM memory with 128MiB and\n512MiB.\n\nTerrain Size RAM Size\ncols \u00d7 rows GiB 128MiB 512MiB\n37 000 \u00d7 37 000 5 634 604\n52 000 \u00d7 52 000 10 1277 1168\n73 500 \u00d7 73 500 20 3324 2708\n104 000 \u00d7 104 000 40 7511 5612\n\nFigure 3.4: Comparing the running time of the four methods.\n\nAddionally, the algorithm was able to process huge terrains using small RAM\n\nmemory. For example, the viewshed of a terrain of size 40 GiB, using 128 MiB RAM\n\nwas computed in 7511 seconds.\n\nThe algorithm souce code (in C++) is avalable and distributed under Creative\n\nCommon GNU GPL license at http://www.dpi.ufv.br/~marcus/TiledVS.htm\n\n\n\n4. A fast external memory algorithm for\n\ncomputing visibility on grid terrains1\n\nAbstract\n\nThis paper presents a novel external memory algorithm for terrain view-\n\nshed computation that decreases the total number of I/O operations. The\n\nalgorithm subdivides the terrain into blocks that are stored in a special data\n\nstructure managed as a cache memory, combined with a fast lossless block\n\ncompression algorithm that reduces the amount of data transfered between\n\nexternal and internal memories.\n\nComputing the viewshed, i.e., the set of points visible from a given point\n\non a terrain, is a widely used visibility application, but the amount of recently\n\navailable high resolution terrestrial data overloads traditional internal memory\n\nalgorithms.\n\nExperimentally, our algorithm is about four times faster than the most\n\nrecent and efficient published methods. This is significant since processing\n\nhuge terrains is quite compute-intensive.\n\n4.1 Introduction\n\nOne important component of terrain modeling in Geographical Information Science\n\n(GIS) is visibility, or line-of-sight, computation. That is, determining the viewshed,\n\nor set of target points that can be seen from a given observer point [Floriani et al.,\n\n1999; Franklin and Ray, 1994; Nagy, 1994]. Applications range from visual nui-\n\nsance abatement to radio transmitter siting and surveillance, such as minimizing\n\nthe number of cellular phone towers required to cover a region [Ben-Shimol et al.,\n\n2007; Camp et al., 1997; Bespamyatnikh et al., 2001], optimizing the number and\n\nposition of guards to cover a region [Franklin and Vogt, 2006; Eidenbenz, 2002;\n\nMagalh\u00e3es et al., 2011], analysing the influences on property prices in an urban en-\n\nvironment [Lake et al., 1998] and optimizing path planning [Lee and Stucky, 1998].\n\nUsing the term line of sight, Champion and Lavery [2002] present other applications.\n\n1Este cap\u00edtulo apresenta o artigo \u201cA fast external memory algorithm for computing visibility\non grid terrains\u201d, submetido \u00e0 revista ACM TSAS (ACM Transactions on Spatial Algorithms and\nSystems) [Ferreira et al., 2014].\n\n30\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 31\n\nTherearevariousalgorithms forviewshedcomputation. Howevermost of them\n\nassume that the data fits in internal memory and thus can be processed with no\n\naccess to external memory (except to load the data). Therefore, the recent increase\n\nin the volume of high resolution terrestrial data, too large for the internal memory\n\nof most computers, creates a challenge.\n\nFor example, NASA\u2019s Shuttle Radar Topography Mission (SRTM) 30 meter\n\nresolution terraindata occupies about 10 terabytes. Processing sub-meter resolution\n\ndata, perhaps from LIDAR, will be an even greater challenge. Thus, it is important\n\nto optimize the massive data processing algorithms simultaneously for computation\n\nand data movement between the external and internal memories, since external\n\nmemory accesses are about 106 times slower [Dementiev et al., 2005]. In this case,\n\nalgorithms for external memory processing should be designed and implemented to\n\nminimize the number of I/O operations for moving data between main memory and\n\ndisk.\n\nThe techniques developed for external memory algorithms are also relevant\n\nto GPU programming. A state-of-the-art NVIDIA Tesla K20x GPU accelerator\n\n[NVidia, 2012], announced in Nov 2012, has 6GB of memory and also can have\n\ndata from the host\u2019s much larger memory transferred over. However it contains\n\nfour different types of memory, with relative speeds ranging over a factor of 100.\n\nThe fastest memory is the register bank, which is quite small, with only 65536\n\nregisters shared by all the threads in the block. Therefore, exploiting such GPUs to\n\nprocess current datasets requires good parallel algorithms that, similarly to external\n\nalgorithms, optimize the movement of data across the layers of memory on a GPU.\n\nSo, external memory processing algorithms need to be designed under a ma-\n\nchine model minimizing data transfer operations instead of CPU processing. A com-\n\nmon model, proposed by Aggarwal and Vitter [1988], defines an I/O operation as\n\nthe transfer of one disk block of size ? between external and internal memories. The\n\nmeasure of performance is the number of such I/O operations. The internal compu-\n\ntation time is assumed to be comparatively insignificant (within reasonable limits).\n\nIt can be convenient to analyze an algorithm in comparison to the cost of a common\n\nlower level operation such as scanning or sorting N contiguous elements stored in\n\nexternal memory. Those are scan(N) = ? (N/?) and sort(N) = ?\n(\n\nN\n?\nlog(M/?)\n\nN\n?\n\n)\n\n,\n\nwhere M is the internal memory size.\n\nThis work presents TiledVS, an efficient method to compute the viewshed\n\nof a point on a terrain stored in external memory. TiledVS is an adaptation of\n\nRFVS an internal memory algorithm proposed by Franklin and Ray [1994]. It\n\nallows efficient manipulation of huge terrains (100 GiB or more). The large number\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 32\n\nof disk accesses is optimized using a new library to manage the data swap between\n\nexternal and internal memories. When compared to the most recent and most effi-\n\ncient published methods (namely, EMViewshed proposed by Andrade et al. [2011];\n\nand io_radial2, io_radial3 and io_centrifugal proposed by Fishman et al. [2009]),\n\nTiledVS is much simpler and faster, experimentally, by a factor of four. Since\n\nprocessing large datasets can take hours, this improvement is significant.\n\n4.2 Some definitions for the viewshed problem\n\nInwhat follows, our regionof interest is small compared to the radius of the earth, so\n\nthat for this discussion the earth can be considered to be flat. There is a horizontal\n\nreference plane ?, a section of the geoid.\n\nA terrain ? is a 21\n2\ndimensional surface where any vertical line intersects ?\n\nin at most one point. Mp is the projection of any point p onto ?. The terrain is\n\nusually represented approximately either by a triangulated irregular network (TIN)\n\nor a regular square grid (RSG) [Li et al., 2005; Floriani et al., 1999]. A TIN is a\n\npartition of the surface into planar triangles, i.e., a piecewise linear triangular spline,\n\nwhere the elevation of a point p is a bilinear interpolation onto ? of the elevations\n\nof the vertices of the triangle containing the projection of p. On the other hand, a\n\nDEM is simply a matrix storing the elevations of regularly spaced positions or posts,\n\nwhere the spacing may be either a constant number of meters or a constant angle in\n\nlatitude and longitude. In this paper, we will use the DEM representation because\n\nof its simpler data structure, ease of analysis, and ability to represent discontinuities\n\n(cliffs) more naturally. Finally, there is a huge amount of data available as DEMs.\n\nOne objection to the DEM is that it uses too much space because it does not\n\nadapt to the varying information content of different regions of the terrain. However\n\nthat could be handled by postprocessing with an adaptive compression technique,\n\nsuch as the on presented by Stookey et al. [2008]. In contrast, storing the topology\n\nin a TIN usually takes more space than it is required to store the elevations [Li\n\net al., 2005], although tradeoffs between space and data structure complexity are\n\npossible.\n\nAn observer is a point in space from where other points (the targets) will\n\nbe visualized. Both the observer and the targets can be at given heights above ?,\n\nrespectively indicated by ho and ht. We often assume that the observer can only\n\nsee targets whose distances from it are smaller than its radius of interest, ?. Thus,\n\na target T is visible from O if and only if the distance from O to T is at most ?\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 33\n\nand the straight line, the line of sight, from O to T is always strictly above ?; see\n\nFigure 4.1.\n\nO\n\nT1\n\nT2\n\nT3\n\nFigure 4.1: Targets\u2019 visibility: T1 and T3 are not visible but T2 is.\n\nThe viewshed of O is the set of all terrain points vertically below targets that\n\ncan be seen by O; formally,\n\nviewshed(O) = {p ? ? | the target above p is visible from O}\n\nwith ? implicit. The viewshed representation is a square (2? + 1) \u00d7 (2? + 1) bitmap\n\nwith the observer at the center.\n\nTheoretically, determining whether a target T is visible from O requires ver-\n\nifying all points in the line of sight connecting O to T . But since ? is represented\n\nwith a finite resolution, only points close to the rasterized line segment connecting\n\nthe projections of O and T onto the horizontal plane will be verified. The visibility\n\ndepends on the line segment rasterization method used (see Figure 4.2) and how\n\nthe elevation is interpolated on those cells where the segment does not intersect the\n\ncell center.\n\nFigure 4.2: The rasterization of the line of sight projection.\n\nConsidering that there are many alternatives for these decisions, it is usual\n\nthat different viewshed algorithms obtain slightly different results, depending on the\n\nchoices made by the programmer while implementing the algorithm. In fact, Fisher\n\n[1993] stated that \u201cthe viewshed is a fundamentally uncertain phenomenon within a\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 34\n\nGIS and is simply not repeatable across a spectrum of systems\u201d. Furthermore, since\n\nthe terrainmodel only represents approximations of the real terrain\u2019s characteristics,\n\nthe computed viewshed will also be an approximation whose accuracy is dependent\n\non the terrain model\u2019s accuracy itself.\n\n4.3 Related Work\n\n4.3.1 Viewshed algorithms\n\nDifferent terrain representations call for different algorithms. A TIN can be pro-\n\ncessed by the algorithms proposed by Cole and Sharir [1989] and Floriani and Mag-\n\nillo [2003]. For a DEM, we recommend [Van Kreveld, 1996] and RFVS, proposed\n\nand implemented by Franklin and Ray [1994]. These two algorithms are very ef-\n\nficient. Both have been recently extended to efficient external memory viewshed\n\nalgorithms. Fishman et al. [2009] adapted Van Kreveld\u2019s and Andrade et al. [2011]\n\nadapted RFVS. (This paper\u2019s contribution is a new and more efficient adaptation\n\nof RFVS).\n\nThese two algorithms differ from each other not only on their efficiency, but\n\nalso on the visibility models adopted. For instance, Van Kreveld\u2019s algorithm uses a\n\ncenter-of-cell to center-of-cell visibility, that is, a cell c is visible if and only if the ray\n\nconnecting the observer (in the center of its cell) to the center of c does not intersect\n\nthe terrain. On the other hand, RFVS uses a less restrictive approach where a cell\n\nc may be considered visible if its center is not visible but another part of c is.\n\nTherefore, the viewsheds obtained by these methods may be different. With-\n\nout knowing the application and having a model for the terrain\u2019s elevation between\n\nthe known points, it is impossible to say which one is better. Some applications\n\nmay prefer a viewshed biased in one direction or the other, while other may want\n\nto minimize error computed under some formal terrain model. For instance, the de-\n\nsigner of a surveillance or a cellphone network may consider that duplicate coverage\n\nof some regions is preferable to no coverage and so would want to underestimate\n\nviewsheds.\n\nConsidering thatboth these algorithmshavebeen recently adapted for efficient\n\nexternal memory processing, we will briefly describe them in the next sections.\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 35\n\n4.3.1.1 The RFVS algorithm\n\nRFVS [Franklin and Ray, 1994] is a fast algorithm that runs in ?(n), where n =\n\n?(?2). It computes the terrain cells\u2019 visibility along rays (line segments) connecting\n\nthe observer (in the center of a cell) to the center of all cells in the boundary of a\n\nsquare bounding box of side 2? + 1 centered at the observer (see Figure 4.3a).\n\n(a) RFVS algorithm. (b) Van Kreveld\u2019s algorithm.\n\nFigure 4.3: Viewshed algorithms.\n\nRFVS creates a ray connecting the observer to a cell on the boundary of this\n\nsquare, and then rotates it counter-clockwise around the observer to follow along\n\nthe boundary cells. The visibility of each ray\u2019s cells is determined by walking along\n\nthe segment, which is rasterized following [Bresenham, 1965]. Suppose this segment\n\nis composed of cells c0, c1, \u00b7 \u00b7 \u00b7 , ck where c0 is the observer\u2019s cell and ck is a cell in\n\nthe square boundary. Let ?i be the slope of the line connecting the observer to ci.\n\nFor each cell ci, the algorithm compares ?i against all ?j with 0 &lt;j &lt;i. If, for any\n\nsuch j, ?i ? ?j, then ci is not visible. Otherwise it is.\n\nFormally, given a terrain ? represented by an elevation matrix M, the observer\n\nposition c0 on ?, the radius of interest ?, and ho, the observer\u2019s height above the\n\nterrain, this algorithm computes the viewshed of O within a distance ? of c0, as\n\nfollows:\n\n1. Let c0\u2019s coordinates be (x0, y0). Then the observer O will be at a distance ho\n\nabove cell (x0, y0) in M.\n\n2. Imagine a square of side (2? + 1) \u00d7 (2? + 1) centered on (x0, y0).\n\n3. Iterate through the cells p of the square\u2019s perimeter.\n\na) For each p, run a straight line in M from (x0, y0) to (xp, yp).\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 36\n\nb) Find the cells intersected by that line, perhaps using Bresenham. From\n\nc0 to p, in that order, let them be c0, c1, \u00b7 \u00b7 \u00b7 ck?1, ck = p.\n\nc) Let ?i be the slope of the line from O to ci, that is,\n\n?i =\n?(ci) ? (?(c0) + ho)\n\ndist(c0, ci)\n\nwhere ?(c0) and ?(ci) are, respectively, the elevation of cells c0 and ci and\n\ndist(c0, ci) is the \u201cdistance\u201d (in number of cells) between these two cells.\n\nd) Let \u00b5 be the greatest slope seen so far along this line. Initialize \u00b5 = ??.\n\ne) Iterate along the line from c0 to p.\n\ni. For each cell ci, compute ?i.\n\nii. If ?i > \u00b5, then set ci as visible in the viewshed (which is simply a\n\n2? \u00d7 2? bitmap) and update \u00b5 = ?i.\n\n4.3.1.2 Van Kreveld\u2019s algorithm\n\nVan Kreveld\u2019s algorithm [Van Kreveld, 1996] is another fast viewshed algorithm,\n\nwhich runs in ?(n log n), also with n = ?(?2). Its basic idea is to rotate a sweep\n\nline around the observer and compute the visibility of each cell when the sweep line\n\npasses over its center (see Figure 4.3b). For that, it maintains a balanced binary\n\ntree (the agenda) that stores the slope of all cells currently being intersected by\n\nthe sweep line, keyed by their distance from the observer. When this sweep line\n\npasses over the center of a cell c, the agenda is searched to check c\u2019s visibility. More\n\nspecifically, this algorithm works as follows:\n\nFor each cell, it defines three types of events: enter, center, and exit events to\n\nindicate, respectively, when the sweep line starts to intersect the cell, passes over the\n\ncell center and stops to intersect the cell. The algorithm creates a list E containing\n\nthese three types of events for all cells inside the region of interest. The events are\n\nthen sorted according to their azimuth angle.\n\nTo compute the viewshed, the algorithm sweeps list E and for each event it\n\ndecides what to do depending on the type of the event:\n\n\u2022 If it is an enter event, the cell is inserted into the agenda.\n\n\u2022 If it is a center event of cell c, the agenda is searched to check if it contains\n\nany cell that lies closer to the observer than c and has slope greater or equal\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 37\n\nto the slope of the line of sight to c; if yes, then c is not visible, otherwise it\n\nis.\n\n\u2022 If it is an exit event, the cell is removed from the agenda.\n\nIt is important to note that the agenda is implemented as a balanced binary\n\ntree, that performs insertions, removals and queries in ?(log n), which keeps the\n\nalgorithm efficiency in ?(n log n).\n\n4.3.2 External memory viewshed algorithms\n\n4.3.2.1 EMViewshed\n\nEMViewshed [Andrade et al., 2011] is an efficient external memory algorithm based\n\non RFVS. It creates and stores in external memory a list with data about all terrain\n\ncells and sorts it according to the order that they will be processed by the RFVS\n\nalgorithm. Thus, it can sweep that list sequentially, avoiding random accesses to\n\nexternal memory.\n\nMore specifically, it creates a list Q of pairs (c, k), where c is a terrain cell and\n\nk is an index that illustrates when c will be processed. That is, if there is a pair (c, k)\n\nin Q, then c will be the k-th cell to be processed. After creating Q, the algorithm\n\nsorts Q according to these k indices using an external memory sorting algorithm\n\n[Dementiev et al., 2005]. Then it sweeps Q to calculate the viewshed, making\n\nonly sequential accesses to external memory, which guarantees the algorithm I/O\n\nefficiency.\n\nAlthough EMViewshed is a fast I/O-efficient algorithm, our experiments in\n\nSection 4.6 show that our new algorithm is about 10 times faster than it.\n\n4.3.2.2 Algorithms based on Van Kreveld\u2019s algorithm\n\nVan Kreveld\u2019s method was adapted for external memory processing by various au-\n\nthors using different strategies: ioviewshed [Haverkort et al., 2007] creates a list of\n\nevents and sorts it with an external memory sorting algorithm. These events are\n\nused to process the terrain with a sweep-line approach. This algorithm was renamed\n\nio-radial1 in [Fishman et al., 2009] where the authors describe two other algorithms\n\nalso based on Van Kreveld, io-radial2 and io-radial3. They sweep the terrain by\n\nrotating a ray around the viewpoint while maintaining the terrain profile along the\n\nray (similar to Van Kreveld). The difference between the two algorithms lies in the\n\npreprocessing step before sweeping the terrain. In io-radial2, the grid points are\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 38\n\nsorted into concentric bands around the viewpoint, while io-radial3, the grid points\n\nare sorted into sectors around the viewpoint. Fishman et al. [2009] also described\n\nanother algorithm, io-centrifugal, but it is not based on Van Kreveld. Instead, it\n\nsweeps the terrain centrifugally, growing a star-shaped region around the observer\n\nwhile maintaining an approximate visible horizon of the terrain within the swept\n\nregion.\n\nioviewshed (or io-radial1) was implemented as an add-on in GRASS (versions\n\n6.x/7.x), named r.viewshed [Toma et al., 2010]. As described in [Fishman et al.,\n\n2009], it is much slower than io-radial2 and io-radial3, which is the fastest among\n\nthese three methods but slower than io-centrifugal. Nonetheless, the tests in Sec-\n\ntion 4.6 show that the method described in this paper is about 8 times faster than\n\nio-radial3 and 4 times faster than io-centrifugal.\n\n4.4 TiledVS method\n\n4.4.1 Algorithm description\n\nIn this section, we propose a new external memory viewshed algorithm based on an\n\nadaptation of RFVS algorithm.\n\nAs described in Section 4.3.1.1, RFVS sweeps the terrain cells by rotating a\n\nray that connects the observer cell to the cells in the boundary of a square bounding\n\nbox. The cells\u2019 visibility is processed along this ray. Thus the matrix access pattern\n\npresents a spatial locality of reference, that is, in a short time interval, the accessed\n\ncells are close in the matrix. However, cells that are close in this bidimensional\n\nmatrix may not be close in memory because a matrix is usually stored using a linear\n\nrow-major order, which is inefficient when using the external memory required by\n\nhuge terrains.\n\nTo reduce the number of non-sequential accesses, we present TiledVS, a new\n\nmethod whose basic idea is to adapt RFVS to manage access to the matrices stored\n\nin external memory by using a special library, TiledMatrix [Silveira et al., 2013].\n\nTiledMatrix subdivides the matrix into small rectangular blocks (tiles) that are\n\nstored in external memory; see Figure 4.4. To access a given cell, TiledMatrix\n\ncopies the whole block containing that cell into internal memory.\n\nTo improve thematrix access efficiency, TiledMatrix keeps someof theseblocks\n\nin internal memory. It uses a data structure named MemBlocks, which is an array of\n\nblocks managed as a cache memory using the least recently used (LRU) replacement\n\npolicy. When a block is accessed it is labeled with a timestamp; and when it is\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 39\n\nnecessary to evict a block from the cache to load a new block, the block with the\n\nsmallest timestamp is replaced with the new block. When a block is evicted, it is\n\nchecked for whether it has been updated, and if so, it is written back to disk.\n\nThe blocks are stored in a file on disk. To reduce I/O, TiledMatrix uses the\n\nfast lossless compression algorithm LZ4 [Collet, 2012] to compress the blocks before\n\nwriting to disk, and to uncompress them after reading. To simplify file management,\n\neach block\u2019s reserved space on the disk is the original uncompressed size. But when\n\na block is transferred, only its compressed size (recorded in an auxiliary array) is\n\ntransferred. As detailed in Section 4.6, our tests showed that compressing reduces\n\nthe block size by 66%, on average, which reduces the amount of I/O by 2/3.\n\nFigure 4.4: Partitioning the elevation matrix into blocks and reorganizing the cells\nin external memory to store the cells of each block in sequence. The arrows indicate\nthe writing sequence.\n\nWe will show that it is possible to define the MemBlocks size such that our\n\nmatrix partitioning is very effective for RFVS. That is, we will prove that this\n\nprocess will load a block in the cache, keep it there while it is accessed and it will\n\nbe evicted only when it will be no longer needed.\n\n4.4.2 Demonstration of TiledVS effectiveness\n\nIn the following, suppose that the matrix partitioning creates square blocks (tiles)\n\nwith ? \u00d7 ? cells and these blocks are grouped in vertical bands with ? columns of\n\ncells; see Figure 4.5. Without loss of generality, consider only the rays in the first\n\nquadrant and whose slope is at most 45?, since the rest is obvious.\n\nLemma 4.4.1 Any ray intersects at most ?\n?\n+ 2 bands.\n\nProof 4.4.2 For the viewshed computation, RFVS defines a square bounding box of\n\nside 2? + 1 with the observer on its center and creates rays connecting the observer\n\nto the center of the cells in the square border; see Figure 4.3a. Since any ray whose\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 40\n\n(a) Square blocks with 3\u00d73\ncells.\n\n(b) Vertical bands with 3\ncolumns. The radius of in-\nterest ? = 10.\n\nFigure 4.5: The terrain matrix partitioning.\n\nslope is at most 45? intersects at most ?+1 columns in this square, this ray intersects\n\nat most ??+1\n?\n? + 1 vertical bands. The additional +1 is because the observer may\n\nnot be in the central column of a band (notice that, if the observer in Figure 4.5b\n\nis moved one cell to the right, ray r0 will cross the last band boundary and will\n\nintersect an additional band). As shown by Graham et al. [1994], ??+1\n?\n? = ? ?\n\n?\n? + 1,\n\nthen ??+1\n?\n? + 1 ? ?\n\n?\n+ 2.\n\nLemma 4.4.3 Let rk and rk+1 be two consecutive rays in the RFVS algorithm\n\nsweeping. Then these two rays intersect at most 2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks.\n\nProof 4.4.4 Since RFVS uses Bresenham, exactly one cell in each column is in-\n\ntersected by a ray. Let lr and cr be respectively the number of rows and columns\n\nintersected by a ray r. As the ray slope is ? 45? then lr ? cr.\n\nGiven the two consecutive rays rk and rk+1, the vertical distance between them\n\nis at most one cell side; see Figure 4.6. For each vertical band, both rays intersect\n\n? columns, then they can intersect at most ? + 1 rows in that band. Thus, in each\n\nband, the two rays can intersect at most two blocks (since the block height is ?\n\nrows). Therefore, from Lemma 4.4.1, rays rk and rk+1 can not intersect more than\n\n2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks.\n\nLemma 4.4.5 Let r0 be the first ray in the RFVS sweeping sequence, that is, r0\n\nis the horizontal ray connecting the observer to the center of the cell on the right\n\nboundary of the square; see Figure 4.5. Given a block B not intersected by r0, let\n\nrk and rk+1 be two consecutive rays. If rk intersects B and rk+1 does not, then no\n\nother ray after rk will intersect B.\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 41\n\nFigure 4.6: Blocks intersected by two consecutive rays.\n\nProof 4.4.6 It is straightforward from the fact that the algorithm uses a radial\n\nsweeping sequence and the blocks are convex. The only exception is the set of blocks\n\nintersected by r0; these blocks can be intersected again by the last rays; see Figure 4.7.\n\nTheorem 4.4.7 Given a block B not intersected by r0, if the number of blocks\n\nin MemBlocks is at least 2\n(\n\n?\n?\n+ 2\n\n)\n\nthen the LRU policy will evict block B from\n\nMemBlocks only if it is no longer needed.\n\nProof 4.4.8 Suppose that MemBlocks has 2\n(\n\n?\n?\n+ 2\n\n)\n\nslots to store the blocks. Let\n\nrk and rk+1 be two consecutive rays such that rk intersects block B. Thus, at some\n\npoint during the processing of ray rk, block B will start to be accessed and will\n\nbe stored in MemBlocks (if rk is the first ray intersecting block B then B will be\n\nloaded into MemBlocks). Now, if ray rk+1 also intersects block B, this block needs\n\nto be acessed again. But, the MemBlocks size is enough to avoid block B eviction\n\nbecause, let B?1, B\n?\n\n2, \u00b7 \u00b7 \u00b7 , B\n?\n\nj be the sequence of blocks that need to be accessed among\n\ntwo consecutive processings of B, that is, it is the sequence of blocks to be accessed\n\nafter B on ray rk and before B on ray rk+1. From Lemma 4.4.3, j ? 2\n(\n\n?\n?\n+ 2\n\n)\n\nand\n\nsince B is not included in the sequence then j &lt;2\n(\n\n?\n?\n+ 2\n\n)\n\n. Thus, if MemBlocks\n\nsize is at least 2\n(\n\n?\n?\n+ 2\n\n)\n\nthen it has enough slots to store B and all the blocks in this\n\nsequence, so B will not be evicted. In other words, in this case, the LRU policy will\n\nnot evict block B because the distinct blocks that need to be accessed can be stored in\n\nMemBlocks.\n\nOn the other hand, if ray rk+1 does not intersect block B then, from\n\nLemma 4.4.5, no other ray after rk will intersect B and thus, it can be evicted\n\nsince it is no longer needed.\n\nThere is a special situation for the blocks intersected by r0 because, after being\n\nevicted, these blocks can be loaded again when processing the last rays. But, notice\n\nthat these blocks can be loaded at most twice. See Figure 4.7 where block B? is loaded\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 42\n\nin the processing of ray r0, is evicted after the processing of rm and it is loaded again\n\nwhen processing ray rn.\n\nFigure 4.7: Block B? is loaded because of ray r0, is evicted after rm and loaded again\nfor rn.\n\n4.5 TiledVS complexity\n\n4.5.1 I/O complexity\n\nTiledVS uses two external memory matrices: the elevation matrix Elev and the\n\nviewshed matrix V . Initially, TiledVS reads the terrain from the input file and ini-\n\ntializes Elev. Then the two matrices are accessed during the viewshed computation\n\nand, finally, the matrix V is written to the output file.\n\nFrom RFVS, the matrices\u2019 dimension is (2? + 1) \u00d7 (2? + 1) and, supposing\n\nthat the block\u2019s side is ?, each matrix will be divided into at most ?2?+1\n?\n\n?\n2\nblocks.\n\nAssume that, for eachmatrix, it is createda MemBlocks withat least 2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks, and that the block size is greater than the disk block transfer size.\n\nIn the first step, matrix Elev is initialized with the elevation values and is\n\nsubdivided in blocks with ? \u00d7 ? cells that are stored in external memory. Since\n\nthe MemBlocks size is 2\n(\n\n?\n?\n+ 2\n\n)\n\nblocks, there are enough slots to store internally all\n\nthe blocks in one matrix row. Thus, the Elev initialization, subdivision and writing\n\nis done step by step as follows: ? \u00d7 (2? + 1) cells, corresponding to ?2?+1\n?\n\n? blocks,\n\nare read from the input file and are stored in MemBlocks, and then MemBlocks is\n\nswept, and each block stored in external memory. Thus, each step reads and writes\n\n?2?+1\n?\n\n? blocks from and to the external memory. Since the matrix Elev has ?2?+1\n?\n\n?\n\nrows of blocks then the whole process reads and writes ?2?+1\n?\n\n?\n2\nblocks. Therefore,\n\nthis first step does ?(scan(?2)) I/O operations.\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 43\n\nDuring the viewshed computation, as shown in Theorem 4.4.7, the blocks from\n\nthe Elev matrix intersected by the first ray are loaded from the disk at most twice\n\nand all the other blocks are loaded once. Then, all ?2?+1\n?\n\n?\n2\nblocks of this matrix are\n\nloaded once and the (?+1\n?\n\n+ 2) blocks intercepted by the first ray are loaded once\n\nmore. And, at this step, the blocks of Elev do not need to be written back to disk\n\nbecause no value of this matrix has been changed. Therefore, for Elev, ?((?/?)2)\n\nblocks are read. For the viewshed matrix V , the blocks are accessed in the same\n\norder as for Elev and so the number of block reads for this matrix is the same as\n\nfor Elev: ?((?/?)2). Additionally, the blocks of V may need to be written back to\n\ndisk as the cells\u2019 visibility is computed. In the worst case when all blocks loaded in\n\nthe internal memory are written back, there are ?((?/?)2) blocks written. In total,\n\nwe have ?((?/?)2) I/O operations, or ?(scan(?2)) as in the first step.\n\nIn the last step, matrix V is written in the disk. Again, since MemBlocks size\n\nis enough to store at least one row of blocks, this step can be done using a standard\n\nrow-major sweep in V , leading to at most ?((?/?)2) blocks swapping which means\n\n?(scan(?2)) I/O operations.\n\nTherefore, the I/O complexity of TiledVS is ?(scan(?2)) which is equivalent\n\nto ?(scan(n)) considering a terrain with n cells and the radius of interest ? big\n\nenough to cover the whole terrain.\n\nNote that the MemBlocks size constraint is not too restrictive because it al-\n\nlows processing huge terrains in computers with very small internal memory. For\n\nexample, with 512 MiB of RAM, it is possible to compute efficiently the viewshed\n\nfor terrains with more than 300 GiB.\n\n4.5.2 CPU complexity\n\nThe (2? + 1) \u00d7 (2? + 1) square centered at the observer usually contains (2? + 1)2\n\ncells, with 8? perimeter cells. (The exception is that there are fewer cells when the\n\nobserver is near the terrain border.) Since the algorithm works by shooting rays\n\nfrom the observer to the perimeter cells, it will shoot 8? rays, each one at most ?+1\n\ncells long. Therefore it will process at most 8?2 + 8? cells. Since there are (2? + 1)2\n\ndistinct cells, therefore on average, each cell will be processed 8?\n2+8?\n\n(2?+1)2\n&lt;2 times.\n\nThat is, TiledVS is linear in the number of cells; for a terrain with n cells, it takes\n\n?(n) CPU time. Since each cell must be read, at least once, that is asymptotically\n\noptimal.\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 44\n\n4.6 Experimental Results\n\nTiledVS was implemented in C++ and compiled with g++ 4.3.4. It was compared\n\nagainst the most efficient recently published algorithms: io-radial2, io-radial3 and\n\nio-centrifugal, proposed by Fishman et al. [2009], and EMViewshed, proposed by\n\nAndrade et al. [2011]. We also assessed its scalability, the influence of compressing\n\nthe blocks and compared the TiledMatrix library with the Operating System (OS)\n\nVirtual Memory Manager (VMM). In all experiments, the running time includes\n\nthe total time taken by the whole process, i.e.: loading the data, partitioning the\n\ngrid, processing the terrain and writing the output file (the viewshed). Also, in\n\nall experiments, we chose the block sizes depending on the terrain dimensions and\n\nthe memory size, such that MemBlocks was always at least as large as defined in\n\nTheorem 4.4.7, leading to efficient performances..\n\nOur current results improve on [Ferreira et al., 2012b] by 30% to 40%, mostly\n\nbecause of the new fast lossless compression strategy. There are also smaller im-\n\nprovements such as using special buffer arrays for reading the input and writing the\n\noutput.\n\n4.6.1 Comparison with Fishman et al. algorithms\n\nLacking access to the programs used by Fishman et al. [2009], we compared our\n\nalgorithm to their published results. We executed our algorithm using the same\n\ndatasets and also a similar platform as the one used by those authors. That is, while\n\nthey ran their experiments on HP 220 blade servers with an Intel Xeon 2.83GHz\n\nprocessor and a 5400RPM SATA hard drive, we used a computer with an Intel Core\n\n2 Duo E7500 2.93GHz processor, 4GiB of RAM memory, and a 5400RPM SATA\n\nHD (Samsung HD103SI) which was rebooted with 512MiB RAM. The operational\n\nsystem used was Linux, Ubuntu 10.04 32 bits distribution. Although these two\n\nplatforms are very similar, according to the benchmarks described in [Pasmark,\n\n2013], our CPU is a little slower.\n\nOur results arepresented inTable 4.1, wherewe reproduce thevaluespresented\n\nby Fishman et al. [2009] including an additional column TiledVS with the results\n\nfrom our algorithm. As it can be noticed, our algorithm is faster than the others in\n\nall situations and, in huge terrains, it is about 4 times faster (see the processing time\n\nfor SRTM-region04). We also extended the table to include the processing time of\n\nour algorithm on very large terrains generated by interpolation of the Region02; see\n\nthe last two rows.\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 45\n\nThe results from Table 4.1 are plotted in Figure 4.8, showing that the bigger\n\nthe terrain, the better is our algorithm in comparison to the other methods.\n\nTable 4.1: Running time (seconds) for io-radial2 (io-r2), io-radial3 (io-r3), io-\ncentrifugal (io-cent) and TiledVS with 512MiB RAM.\n\nDataset Terrain size io-r2 io-r3 io-cent TiledVS\ncols rows GiB\n\nCumberlands 8704 7673 0.25 72 104 35 12\nUSA DEM 6 13500 18200 0.92 2804 458 115 66\nUSA DEM 2 11000 25500 1.04 1883 735 121 80\nWashington 31866 33454 3.97 13780 3008 676 297\nSRTM1-reg03 50401 43201 8.11 37982 6644 2845 670\nSRTM1-reg04 82801 36001 11.10 \u2014 8834 5341 1027\nSRTM1-reg04 68401 111601 28.44 \u2014 26193 12186 2885\nReg02 interp. 150000 91000 50.85 \u2014 \u2014 \u2014 5198\nReg02 interp. 200000 122000 90.89 \u2014 \u2014 \u2014 9953\n\n??\n\n??\n\n???\n\n???\n\n???\n\n???\n\n???\n\n???\n\n???\n\n?? ?? ??? ??? ??? ???\n\n?\n\t\n\n\n\n\n?\n\n?\n?\n??\n\n?\n??\n?\n?\n?\n??\n?\n?\n?\n\n\n?\n?\n?\n\n?\t???????????????????\n\n?????\n?????\n\n?????\n\n\n??????\n\nFigure 4.8: Comparing the running time of the four methods.\n\nFigure4.9plots thenumberof cells processedper secondversus the terrain size.\n\nAgain, our algorithm presents a much better performance than the three others. All\n\nmethods asymptotically process a constant number of cells per second, with ours\n\nbeing about 4 times faster than their fastest one.\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 46\n\n??\n\n??\n\n??\n\n??\n\n??\n\n??\n\n??\n\n?? ?? ??? ??? ??? ???\n\n\t\n\n\n?\n?\n\n??\n?\n??\n?\n\n??\n?\n??\n\n??\n?\n\n?\n?\n?\n?\n??\n??\n?\n?\n\n\t\n??\n??????\n?????????\n\n???\n???\n????\n??\n?????\n?????\n\nFigure 4.9: Number of cells processed per second by each method.\n\n4.6.2 Comparison with EMViewshed\n\nWe also compared our new algorithm TiledVS against our previous one EMView-\n\nshed [Andrade et al., 2011]. We used some different datasets generated from two\n\nUSA regions sampled at different resolutions using 2 bytes per elevation. The al-\n\ngorithms were executed five times on each terrain. The average time is presented\n\nin Table 4.2 and in Figure 4.10. Note that TiledVS is about 10 times faster than\n\nEMViewshed. In Table 4.2, the terrains were represented with 2 bytes per cell to\n\nmatch the EMViewshed implementation.\n\nTable 4.2: Running time (seconds) for EMViewshed (EMVS) and TiledVS with\n1024MiB RAM.\n\nTerrain size EMVS TiledVS\ncols \u00d7 rows GiB\n\n10000 \u00d7 10000 0.19 29 22\n20000 \u00d7 20000 0.75 125 99\n30000 \u00d7 30000 1.68 727 172\n40000 \u00d7 40000 2.98 3168 351\n50000 \u00d7 50000 4.65 5701 525\n60000 \u00d7 60000 6.71 8961 864\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 47\n\n??\n\n??\n\n??\n\n??\n\n??\n\n??\n\n??\n\n?\t\n\n?\n\n\n??\n\n?? ???? ?? ???? ?? ???? ?? ???? ??\n\n\n?\n?\n?\n??\n?\n??\n??\n\n?\n??\n?\n?\n?\n??\n?\n?\n?\n?\n?\n?\n?\n\n???????????????? ????\n\n!\"?#??$?%??\n&amp;????#'\n\nFigure 4.10: Running time of methods EMViewshed and TiledVS.\n\n4.6.3 TiledVS scalability\n\nTable 4.3 presents the TiledVS running time (in seconds) for different terrain sizes\n\nusing small internal memory sizes: 128MiB and 512MiB. TiledVS scales to dataset\n\nsizes that are far too large to fit into internal memory. For example, it was able\n\nto compute the viewshed of a 40 GiB terrain, using only 128 MiB RAM, in 5740\n\nseconds.\n\nTable 4.3: TiledVS running time (seconds) with either 128MiB or 512MiB RAM.\n\nTerrain size RAM size\ncols\u00d7rows GiB 128MiB 512MiB\n\n37 000 \u00d7 37 000 5 369 339\n52 000 \u00d7 52 000 10 862 721\n73 500 \u00d7 73 500 20 2287 1735\n\n104 000 \u00d7 104 000 40 5740 3548\n\n4.6.4 The influence of compression\n\nSeveral experiments concerning TiledMatrix performance have been conducted by\n\nSilveira et al. [2013], who showed how compressing the blocks reduces the amount of\n\ndata thatneeds tobe transferred to/fromthedisk, withonlya small timepenalty for\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 48\n\nthe compression. To test this on TiledVS, we tested TiledMatrix with compression\n\nenabled and then disabled \u2014 see Table 4.4 \u2014 with very favorable results. The\n\nterrain blocks compressed, on average, by a factor of 3. Also, the compression\n\nreduced, on average, the processing time by 37%.\n\nTable 4.4: Running time (seconds) of TiledVS using TiledMatrix with compression\nenabled (w comp.) and disabled (w/o comp.).\n\nTerrain size TiledVS comp.\ncols \u00d7 rows GiB w comp. w/o comp. ratio\n\n10000 \u00d7 10000 0.37 26 33 2.7\n20000 \u00d7 20000 1.49 109 155 2.8\n30000 \u00d7 30000 3.36 249 345 3.0\n40000 \u00d7 40000 5.96 454 638 3.1\n\n4.6.5 TiledMatrix compared against the OS\u2019s Virtual\n\nMemory system\n\nSince our method uses a straightforward implementation of the LRU caching strat-\n\negy also used by many operating systems (OSs) such as Linux, one might suspect\n\nthat similar running times could be obtained by reorganizing the data in blocks\n\n(as shown on Figure 4.4) and allowing the OS Virtual Memory Manager (VMM)\n\nto manage the block swapping. We tested this with an implementation (named\n\nVMM_VS) that subdivides and reorganizes the terrain matrix but does not man-\n\nage the data accesses, letting the Linux VMM do that.\n\nFirst, the terrain was subdivided in blocks with 1000 \u00d7 1000 cells and the exe-\n\ncution time was compared using VMM_VS and TiledVS for a terrain with 300002\n\ncells. In this test, VMM_VS processed the terrain in 3480 seconds while TiledVS\n\nexecuted in 249 seconds.\n\nConsidering that each VMM page has 4096 bytes, each block with 1000 \u00d7\n\n1000 cells uses 977 different pages. Therefore, if the operating system loads a page\n\ncontaining a cell, there is no guarantee that all pages of this block will be loaded.\n\nOn the other hand, to verify the VMM_VS performance when each block requires\n\nonly one VMM page, the algorithms were tested using blocks with 32\u00d732 cells, that\n\nis, each block had 4096 bytes. Also, the matrix was aligned to the VMM pages,\n\nsuch that each page contained exactly one entire block. In this case, VMM_VS\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 49\n\nwas faster and executed in 1203 seconds while the TiledVS execution time was 5338\n\nseconds.\n\nSilveira et al. [2013] showed that TiledMatrix\u2019s performance decreases with\n\nsmall blocks, because transferring small bunches of data does not amortize the disk\n\nseek and latency times. When the block size is increased to 10002 cells, TiledVS\u2019s\n\nperformance improves, but the performance of VMM_VS becomes worse since each\n\nblock requires several pages, which are loaded separately by the VMM.\n\nFishman et al. [2009] obtained a similar result, concluding that, \u201cone of our\n\nfindings is that relying purely on VMM, even for a theoretically I/O-efficient data\n\naccess, is slow\u201d, and \u201cby telling the algorithms explicitly when to load a memory-\n\nsize block (and not using the VMM), we obtained significant speedups (without\n\nsacrificing I/O-efficiency for the levels of caching of which the algorithm remained\n\noblivious, and without sacrificing CPU-efficiency).\u201d\n\n4.7 Conclusion and future work\n\nWehavepresented TiledVS, a newalgorithm for viewshed computation onhuge grid\n\nterrains stored in external memory, based on an adaptation of the internal memory\n\nalgorithm RFVS [Franklin and Ray, 1994].\n\nTiledVS uses a special data structure to manage the data transfer between\n\ninternal and external memories, thereby reducing the number of I/O operations.\n\nFor terrains with n cells, its I/O complexity is ?(scan(n)).\n\nTiledVS was compared against the most recent and most efficient algorithms\n\ndescribed in the literature, and shown to be faster than all the others, by about a\n\nfactor of 4. This improvement is significant because processing huge terrains can\n\ntake hours. Additionally, TiledVS is also much simpler.\n\nTiledVS is able to process huge terrains using small amounts of internal mem-\n\nory (RAM). For example, the viewshed of a 40 GiB terrain GiB was computed in\n\n5740 seconds, using 128 MiB RAM.\n\nThere are many possible avenues for future research, the most obvious to ex-\n\nploit parallelism, such as with Graphics Processing Units (GPUs). In order to make\n\nits results more widely useful, this paper has considered only CPUs. However, a\n\nroadmap for utilizing parallelism might proceed as follows. The initial step might be\n\nto use multi-core multi-threaded shared-memory Intel CPUs. One machine avail-\n\nable to us allows 32 parallel threads by using dual 8 core Intel Xeon E5-2687W\n\nCPUs. OpenMP is an appropriate API. However this machine has so much memory\n\n\n\n4. A fast external memory algorithm for computing visibility on\n\ngrid terrains 50\n\n(128GB) that external algorithms are unnecessary. The next step would be to use\n\nthe NVIDIA Tesla K20x GPU accelerator mentioned earlier, which has 2688 CUDA\n\ncores. Although each core has only about one tenth of the computing power of one\n\nIntel thread, there are a lot of them. The problem is that efficiently using them is\n\nnot yet a totally solved problem. Nevertheless, we are pursuing this approach.\n\nOur algorithm source code (in C++) is available, as open source\n\ncode distributed under a Creative Common GNU GPL license, at\n\nhttp://www.dpi.ufv.br/?marcus/TiledVS.htm\n\n\n\n5. A parallel sweep line algorithm for visi-\n\nbility computation1\n\nAbstract\n\nVisibility map (or viewshed) computation is required for many GIS ap-\n\nplications. As terrain data continue to become available at higher resolutions,\n\nthere is a need for faster architectures and algorithms. Since the main im-\n\nprovements on modern processors come from multi-core architectures, parallel\n\nprogramming provides a promising means for developing faster algorithms. In\n\nthis paper, we describe a new parallel algorithm, based on the model proposed\n\nby Van Kreveld [1996]. Our algorithm uses the shared memory model, which\n\nis relatively cheap and supported by most current processors. Experiments\n\nhave shown that, with 16 parallel cores, it was up to 12 times faster than the\n\nserial implementation.\n\n5.1 Introduction\n\nAn important group of Geographical Information Science (GIS) applications on\n\nterrains concerns visibility, i.e., determining the set of points on the terrain that are\n\nvisible from some particular observer, which is usually located at some height above\n\nthe terrain. This set of points is known as viewshed [Franklin and Ray, 1994] and\n\nits applications range from visual nuisance abatement to radio transmitter siting\n\nand surveillance, such as minimizing the number of cellular phone towers required\n\nto cover a region [Ben-Shimol et al., 2007], optimizing the number and position\n\nof guards to cover a region [Magalh\u00e3es et al., 2011], analysing the influences on\n\nproperty prices in an urban environment [Lake et al., 1998] and optimizing path\n\nplanning [Lee and Stucky, 1998]. Other applications are presented in Champion\n\nand Lavery [2002].\n\nSince visibility computation is quite compute-intensive, the recent increase in\n\nthe volume of high resolution terrestrial data brings a need for faster platforms and\n\nalgorithms. Considering that some factors (such as processor sizes, transmission\n\n1Este cap\u00edtulo apresenta o artigo \u201cA Parallel Sweep Line Algorithm for Visibility Computa-\ntion\u201d, que recebeu o pr\u00eamio de melhor artigo no GeoInfo 2013 (XIV Brazilian Symposium on\nGeoinformatics) [Ferreira et al., 2013].\n\n51\n\n\n\n5. A parallel sweep line algorithm for visibility computation 52\n\nspeeds and economic limitations) create practical limits and difficulties for building\n\nfaster serial computers, the parallel computing paradigm has become a promising\n\nalternative for such computing-intensive applications [Barney et al., 2010]. Also,\n\nparallel architectures have recently become widely available at low costs. Thus,\n\nthey have been applied in many domains of engineering and scientific computing,\n\nallowing researchers to solve bigger problems in feasible amounts of time.\n\nIn this paper, we present a new parallel algorithm for computing the viewshed\n\nof a given observer on a terrain. Our parallel algorithm is based on the (serial)\n\nsweep line algorithm firstly proposed by Van Kreveld [1996], which is described in\n\nSection 5.2.3.3. Comparing to the original algorithm, our new algorithm achieved\n\nspeedup of up to 12 times using 16 parallel cores, and up to 3.9 times using four\n\nparallel cores.\n\n5.2 Related work\n\n5.2.1 Terrain representation\n\nIn what follows, our region of interest is small compared to the radius of the earth,\n\nthus, for this discussion the earth can be considered to be flat.\n\nA terrain ? is a 21\n2\ndimensional surface where any vertical line intersects ?\n\nin at most one point. The terrain is usually represented approximately either by\n\na triangulated irregular network (TIN) or a regular square grid (RSG) [Li et al.,\n\n2005]. A TIN is a partition of the surface into planar triangles, i.e., a piecewise\n\nlinear triangular spline, where the elevation of a point p is a bilinear interpolation\n\nof the elevations of the vertices of the triangle containing the projection of p. On\n\nthe other hand, a RSG is simply a matrix storing the elevations of regularly spaced\n\npositions or posts, where the spacing may be either a constant number of meters\n\nor a constant angle in latitude and longitude. In this paper, we will use the RSG\n\nrepresentation because of its simpler data structure, ease of analysis, and ability to\n\nrepresent discontinuities (cliffs) more naturally. Finally, there is a huge amount of\n\ndata available as RSGs.\n\n5.2.2 The viewshed problem\n\nAn observer is a point in space from where other points (the targets) will be visual-\n\nized. Both the observer and the targets can be at given heights above ?, respectively\n\nindicated by ho and ht. We often assume that the observer can see only targets that\n\n\n\n5. A parallel sweep line algorithm for visibility computation 53\n\nare closer than the radius of interest, ?. We say that all cells whose distance from\n\nO is at most ? form the region of interest of O. A target T is visible from O if and\n\nonly if the distance of T from O is, at most, ? and the straight line, the line of sight,\n\nfrom O to T is always strictly above ?; see Figure 5.1.\n\nFigure 5.1: Targets\u2019 visibility: T1 and T3 are not visible but T2 is.\n\nThe viewshed of O is the set of all terrain points vertically below targets that\n\ncan be seen by O; formally,\n\nviewshed(O) = {p ? ? | the target above p is visible from O}\n\nwith ? implicit. The viewshed representation is a square (2? + 1) \u00d7 (2? + 1) bitmap\n\nwith the observer at the center.\n\nTheoretically, determining whether a target T is visible from O requires ver-\n\nifying all points in the line of sight connecting O to T . But since ? is represented\n\nwith a finite resolution, only points close to the rasterized line segment connecting\n\nthe projections of O and T onto the horizontal plane will be verified. Which points\n\nthose might be, is one difference between competing algorithms, as the ones we will\n\ndescribe in Section 5.2.3. The visibility depends on the line segment rasterization\n\nmethod used, see Figure 5.2, and how the elevation is interpolated on those cells\n\nwhere the segment does not intersect the cell center.\n\nFigure 5.2: The rasterization of the line of sight projection.\n\nThevisibility of a target aboveacell ct canbedeterminedbychecking the slope\n\nof the line connecting O and T and the cells\u2019 elevation on the rasterized segment.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 54\n\nMore precisely, suppose the segment is composed of cells c0, c1, \u00b7 \u00b7 \u00b7 , ct where c0 and\n\nct correspond to the projections of O and T respectively. Let ?i be the slope of the\n\nline connecting O to ci, that is,\n\n?i =\n?(ci) ? (?(c0) + ho)\n\ndist(c0, ci)\n(5.1)\n\nwhere ?(c0) and ?(ci) are, respectively, the elevation of cells c0 and ci and dist(c0, ci)\n\nis the \u2018distance\u2019 (in number of cells) between these two cells. The target on ct is\n\nvisible if and only if the slope\n?(ct)+ht?(?(c0)+ho)\n\ndist(c0,ct)\nis greater than ?i for all 0 &lt;i &lt;t.\n\nIf yes, the corresponding cell in the viewshed matrix is set to 1; otherwise, to 0.\n\n5.2.3 Viewshed algorithms\n\nDifferent terrain representations call for different algorithms. A TIN can be pro-\n\ncessed by the algorithms proposed by Cole and Sharir [1989] and Floriani and Mag-\n\nillo [2003]. For a RSG, we can point out [Van Kreveld, 1996] and RFVS [Franklin\n\nand Ray, 1994], two very efficient algorithms. Another option for processing RSGs\n\nis the well-known R3 algorithm [Shapira, 1990]. Although this one is not as efficient\n\nas the other two, it has higher accuracy and may be suitable for small datasets.\n\nThese three algorithms differ from each other not only on their efficiency, but\n\nalso on the visibility models adopted. For instance, R3 and Van Kreveld\u2019s algorithms\n\nuse a center-of-cell to center-of-cell visibility, that is, a cell c is visible if and only if\n\nthe ray connecting the observer (in the center of its cell) to the center of c does not\n\nintersect a cell blocking c. On the other hand, RFVS uses a less restrictive approach\n\nwhere a cell c may be considered visible if its center is not visible but another part\n\nof c is.\n\nTherefore, the viewsheds obtained by these methods may be different. Without\n\nknowing the application and having a model for the terrain\u2019s elevation between the\n\nknown points, it is impossible to say which one is better. Some applications may\n\nprefer a viewshed biased in one direction or the other, while others may want to\n\nminimize error computed under some formal terrain model. For instance, since\n\nVan Kreveld\u2019s algorithm presents a great tradeoff between efficiency and accuracy\n\n[Fishman et al., 2009], it may be indicated for applications that require a high degree\n\nof accuracy. On the other hand, if efficiency is more important than accuracy, the\n\nRFVS algorithm could be preferred.\n\nConsidering that each one of these algorithms might be suitable for different\n\napplications, we will describe them briefly in the next sections.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 55\n\n5.2.3.1 R3 algorithm\n\nThe R3 algorithm provides a straightforward method of determining the viewshed\n\nof a given observer O with a radius of interest ?. Although it is considered to have\n\ngreat accuracy [Franklin et al., 1994], this algorithm runs in ?(n\n3\n\n2 ), where n = ?(?2).\n\nIt works as follows: for each cell c inside the observer\u2019s region of interest, it uses\n\nthe digital differential analyzer (DDA) [Ma?iorov, 1964] to determine which cells\n\nthe line of sight (from O to the center of c) intersects. Then, the visibility of c is\n\ndetermined by calculating the slope of all cells intersected by this line of sight, as\n\ndescribed in Section 5.2.2. In this process, many rules to interpolate the elevation\n\nbetween adjacent posts may be used, such as average, linear, or nearest neighbour\n\ninterpolations.\n\n5.2.3.2 RFVS algorithm\n\nRFVS [Franklin and Ray, 1994] is a fast approximation algorithm that runs in\n\n?(n). It computes the terrain cells\u2019 visibility along rays (line segments) connecting\n\nthe observer (in the center of a cell) to the center of all cells in the boundary of a\n\nsquare of side 2? + 1 centered at the observer (see Figure 5.3a). In each column,\n\nit tests the line of sight against the closest cell. Although a square was chosen for\n\nimplementation simplicity, other shapes such as a circle would also work.\n\nRFVS creates a ray connecting the observer to a cell on the boundary of this\n\nsquare, and then rotates it counter-clockwise around the observer to follow along the\n\nboundary cells (see Figure 5.3a). The visibility of each ray\u2019s cells is determined by\n\nwalking along the segment, which is rasterized following Bresenham [1965]. Suppose\n\nthe segment is composed of cells c0, c1, \u00b7 \u00b7 \u00b7 , ck where c0 is the observer\u2019s cell and ck is\n\na cell in the square boundary. Let ?i be the slope of the line connecting the observer\n\nto ci determined according to Equation (5.1) in Section 5.2.2. Let \u00b5 be the highest\n\nslope seen so far when processing ci, i.e., \u00b5 = max{?1, ?2, \u00b7 \u00b7 \u00b7 , ?i?1}. The target\n\nabove ci is visible if and only if the slope (?(ci) + ht ? (?(c0) + ho)) /dist(c0, ci) is\n\ngreater than \u00b5. If yes, the corresponding cell in the viewshed matrix is set to 1;\n\notherwise, to 0. Also, if ?i > \u00b5 then \u00b5 is updated to ?i. We say that a cell ci\n\nblocks the visibility of the target above cj if ci belongs to the segment c0cj and ?i is\n\ngreater or equal to the slope of the line connecting the observer to the target above\n\ncj.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 56\n\n5.2.3.3 Van Kreveld\u2019s algorithm\n\nVan Kreveld\u2019s algorithm [Van Kreveld, 1996] is another fast viewshed algorithm.\n\nAccording to Zhao et al. [2013], its accuracy is equivalent to the R3 algorithm\u2019s,\n\nwhile running in ?(n log n). Its basic idea is to rotate a sweep line around the\n\nobserver and compute the visibility of each cell when the sweep line passes over its\n\ncenter (see Figure 5.3b). For that, it maintains a balanced binary tree (the agenda)\n\nthat stores the slope of all cells currently being intersected by the sweep line, keyed\n\nby their distance from the observer. When this sweep line passes over the center of a\n\ncell c, the agenda is searched to check c\u2019s visibility. More specifically, this algorithm\n\nworks as follows:\n\nFor each cell, it defines three types of events: enter, center, and exit events to\n\nindicate, respectively, when the sweep line starts to intersect a cell, passes over the\n\ncell center and stops to intersect a cell. The algorithm creates a list E containing\n\nthese three types of events for all cells inside the region of interest. The events are\n\nthen sorted according to their azimuth angle.\n\nTo compute the viewshed, the algorithm sweeps the list E and for each event\n\nit decides what to do depending on the type of the event:\n\n\u2022 If it is an enter event, the cell is inserted into the agenda.\n\n\u2022 If it is an center event of cell c, the agenda is searched to check if it contains\n\nany cell that lies closer to the observer than c and has slope greater or equal\n\nto the slope of the line of sight to c; if yes, then c is not visible, otherwise it\n\nis.\n\n\u2022 If it is an exit event, the cell is removed from the agenda.\n\n(a) RFVS (b) Van Kreveld\n\nFigure 5.3: Viewshed algorithms.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 57\n\n5.2.3.4 Parallel viewshed algorithms\n\nParallel computing has become a mainstream of scientific computing and recently\n\nsome parallel algorithms for viewshed computation have been proposed. Zhao et al.\n\n[2013] proposed a parallel implementation of the R3 algorithm using Graphics Pro-\n\ncessing Units (GPUs). The RFVS algorithm was also adapted for parallel process-\n\ning on GPUs by Osterman [2012]. Chao et al. [2011] proposed a different approach\n\nfor parallel viewshed computation using a GPU, where the algorithm runs entirely\n\nwithin the GPUs visualization pipeline used to render 3D terrains. Mills et al.\n\n[1992]; Teng et al. [1993]; Gao et al. [2011]; Strnad [2011] Zhao et al. [2013] also\n\ndiscuss other parallel approaches.\n\nHowever, we have not found any previous work proposing a parallel implemen-\n\ntation of Van Kreveld\u2019s algorithm. In fact, Zhao et al. [2013] stated that \u201ca high\n\ndegree of sequential dependencies in Van Kreveld\u2019s algorithm makes it less suitable\n\nto exploit parallelism\u201d. In Section 5.3 we show how we have overcome this difficulty\n\nand describe our parallel implementation of Van Kreveld\u2019s sweep line algorithm.\n\n5.2.4 Parallel programming models\n\nThere are several parallel programming models, such as distributed mem-\n\nory/message passing, shared memory, hybrid models, among others [Barney et al.,\n\n2010]. In this work, we used the shared memory model, where the main program\n\ncreates a certain number of tasks (threads) that can be scheduled and carried out\n\nby the operating system concurrently. Each thread has local data, but the main\n\nprogram and all threads share a common address space, which can be read from\n\nand written to asynchronously. In order to control the concurrent access to shared\n\nresources, some mechanisms such as locks and semaphores may be used. An advan-\n\ntage of this model is that there is no need to specify explicitly the communication\n\nbetween threads, simplifying the development of parallel applications.\n\nFor the implementation of the algorithm, we used OpenMP (Open Multi-\n\nProcessing) [Dagum and Menon, 1998], a portable parallel programming API de-\n\nsigned for shared memory architectures. It is available for C++ and Fortran pro-\n\ngramming languages and consists of a set of compiler directives that can be added\n\nto serial programs to influence their run-time behaviour, making them parallel.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 58\n\n5.3 Our parallel sweep line algorithm\n\nAs described in Section 5.2.3.3, Van Kreveld\u2019s algorithm needs information about\n\nthe cells intersected by the sweep line. It maintains these information by processing\n\nthe enter and exit events to keep the agenda up to date as the sweep line rotates.\n\nTherefore, processing a center event is dependent upon all earlier enter and exit\n\nevents.\n\nIn order to design a parallel implementation of this algorithm, this dependency\n\nhad to be eliminated. We did that by subdividing the observer\u2019s region of interest\n\ninto S sectors around the observer, O (see Figure 5.4a, where S = 8). Our idea is\n\nto process each one of these sectors independently using Van Kreveld\u2019s sweep line\n\nalgorithm, such that it can be done in parallel.\n\nMore specifically, consider sector s defined by the interval [?, ?), where ? and ?\n\nare azimuth angles. Let a and b be the line segments connecting O to the perimeter\n\nof its region of interest, with azimuth angles ? and ?, respectively (see Figure 5.4a).\n\nTo process s, the algorithm creates rays connecting O to all cells on the perimeter of\n\nthe region of interest that are between (or intersected by) a and b (see Figure 5.4b).\n\nThese rays are rasterized using the DDA method [Ma?iorov, 1964] and the events\n\nrelated to the intersected cells are inserted into s\u2019s own list of events, Es. Since the\n\ngrid cells are convex, this process inserts into Es the events for all cells inside s or\n\nintersected by a or b. The inserted cells are shown in Figure 5.4b.\n\n(a) Subdivision of the region of interest\nand the sector s, defined by the interval\n[?, ?).\n\n(b) The cells in the perimeter of the re-\ngion of interest, the rays used to deter-\nmine which cells are intersected by s and\nthe cells inserted into E\n\ns\n(shaded cells).\n\nFigure 5.4: Sector definition.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 59\n\nThen, the algorithm sorts Es by the events\u2019 azimuth angles and sweeps it in the\n\nsame manner as Van Kreveld\u2019s algorithm. Note that, because we have distributed\n\nthe events into different lists and each list contains all events that are relevant to its\n\nsector, each sector may be processed independently, each one with its own agenda.\n\nThis allows a straightforward parallelization of such processing. Also, note that the\n\nevents of a cell may be included in more than one sector\u2019s event list and therefore\n\nsome cells may be processed twice. But that is not a problem, since this will happen\n\nonly to a few cells, and it will not affect the resulting viewshed.\n\nIt is also important to note that our algorithm might be faster than the original\n\none even with non-parallel architectures. For instance, we achieved up to 20%\n\nspeedup using only one processor (see Section 5.4). This happens because both\n\nimplementations have to sort their lists of events and, while the original (serial)\n\nalgorithm sorts a list of size n, our algorithm sorts S lists of size about n\nS\n. Since\n\nsorting can be done in ?(n logn), the latter one is faster. In practice, we empirically\n\nconcluded that, for a computer with N cores, using S > N achieved better results\n\nthan using S = N. This will be further discussed in Section 5.4, as long with our\n\nexperimental results.\n\n5.4 Experimental results\n\nWe implemented our algorithm in C++ using OpenMP. We also implemented the\n\noriginal (serial) Van Kreveld\u2019s algorithm in C++. Both algorithms were compiled\n\nwith g++ 4.6.4 and optimization level -O3. Our experimental platform was a Dual\n\nIntel Xeon E5-2687 3.1GHz 8 core. The operational system was Ubuntu 12.04 LTS,\n\nLinux 3.5 Kernel.\n\nThe tests were done using six different terrains from SRTM datasets and, in\n\nall experiments, the observer was sited in the center of the terrain, with hO = 100\n\nmeters and hT = 0. The radius of interest, ?, was set to be large enough to cover\n\nthe whole terrain.\n\nAnother important parameter for our program is the number of sectors S into\n\nwhich the region of interest will be subdivided. Changing the number of sectors\n\nmay significantly modify the algorithm\u2019s performance. Empirically, we determined\n\nthat good results are achieved when the region is subdivided such that each sector\n\ncontained about 40 cells from the perimeter of the region of interest, so we adopted\n\nthat strategy. Other strategies for choosing the number of sectors should be further\n\ninvestigated and it could be an interesting topic for future work.\n\n\n\n5. A parallel sweep line algorithm for visibility computation 60\n\nTo evaluate our algorithm\u2019s performance, we compared it to the original (serial)\n\nalgorithm. We ran several experiments limiting the number of parallel threads to\n\nthe following values: 16, 8, 4, 2 and 1. The results are given in Table 5.1 and plotted\n\nin Figure 5.5a, where the times are given in seconds and refer just to the time needed\n\nto compute the viewshed. That is, we excluded the time taken to load the terrain\n\ndata and to write the computed viewshed into disk, since it was insignificant (less\n\nthan 1% of the total time in all cases). Also, the time represents the average time\n\nfor five different runs of the same experiment.\n\nTable 5.1: Running times (in seconds) for the serial algorithm and the parallel\nalgorithm with different number of threads.\n\nTerrain size Serial\nAlg.\n\nParallel Alg.\nNumber of threads\n\n# cells GiB 16 8 4 2 1\n5 0002 0.09 24 2 4 7 13 23\n10 0002 0.37 125 11 17 32 57 105\n15 0002 0.83 252 25 41 78 165 246\n20 0002 1.49 485 52 79 144 265 464\n25 0002 2.33 891 78 128 226 427 740\n30 0002 3.35 1216 121 191 335 629 1100\n\nTable 5.2: Speedups achieved by our parallel algorithm, with different number of\nthreads.\n\nTerrain size\nParallel Alg.\n\nNumber of threads\n# cells GiB 16 8 4 2 1\n5 0002 0.09 12.00 6.00 3.43 1.85 1.04\n10 0002 0.37 11.36 7.35 3.91 2.19 1.19\n15 0002 0.83 10.08 6.15 3.23 1.53 1.02\n20 0002 1.49 9.33 6.14 3.37 1.83 1.05\n25 0002 2.33 11.42 6.96 3.94 2.09 1.20\n30 0002 3.35 10.05 6.37 3.63 1.93 1.11\n\nWe calculated our algorithm speedup compared to the original algorithm. The\n\nspeedups are presented in Table 5.2 and plotted in Figure 5.5b. Our algorithm has\n\nshown very good performance, achieving up to 12 times speedup, when running\n\n16 concurrent threads. It is also important to notice that with only four threads\n\nwe achieved a speedup of 3.9 times for two terrains and more than 3 times for all\n\n\n\n5. A parallel sweep line algorithm for visibility computation 61\n\n(a) Running times (in seconds) for the serial al-\ngorithm and the parallel algorithm with differ-\nent number of threads\n\n(b) Speedups achieved by our parallel algo-\nrithm, with different number of threads.\n\nFigure 5.5: Experimental results.\n\nother terrains. Considering that processors with four cores have become usual and\n\nrelatively cheap nowadays, these improvements may be useful for real users with\n\nregular computers. Finally, as discussed in Section 5.3, the experiments with only\n\none thread show that our strategy can be faster than the original program even with\n\nserial architectures.\n\n5.5 Conclusions and future work\n\nWe proposed a new parallel sweep line algorithm for viewshed computation, based\n\non an adaptation of Van Kreveld\u2019s algorithm. Compared to the original (serial)\n\nalgorithm, we achieved speedup of up to 12 times with 16 concurrent threads, and\n\nup to 3.9 times using four threads. Even with a single thread, our algorithm was\n\nbetter than the original one, running up to 20% faster.\n\nCompared to other parallel viewshed algorithms, ours seems to be the only\n\nto use Van Kreveld\u2019s model, which presents a great tradeoff between efficiency and\n\naccuracy [Fishman et al., 2009]. Also, most of them use other parallel models, such\n\nas distributed memory/message passing and general purpose GPU programming.\n\nOn the other hand, ours uses the shared memory model, which is simpler, requires\n\ncheaper architectures and is supported by most current computers.\n\nAs future work, we can point out the development of other strategies for\n\ndefining S, the number of sectors into which the region of interest is subdivided.\n\nWe also intend to develop another adaptation of Van Kreveld\u2019s model using GPU\n\n\n\n5. A parallel sweep line algorithm for visibility computation 62\n\nprogramming. Since GPU architectures are much more complex, this will not be a\n\nstraightforward adaptation.\n\n\n\n6. Conclus\u00f5es gerais e trabalhos futuros\n\nNeste trabalho foram apresentados dois algoritmos para c\u00e1lculo de viewshed em\n\ngrandes terrenos representados por grades regulares: um especialmente projetado\n\npara ser eficiente em terrenos maiores do que a mem\u00f3ria interna dispon\u00edvel, e ou-\n\ntro capaz de utilizar arquiteturas paralelas de forma eficiente. Como mostraram\n\nos resultados experimentais, ambos s\u00e3o mais eficientes do que algoritmos propostos\n\nanteriormente em literatura. Os ganhos (speedups) obtidos por estes dois algoritmos\n\npodem ser importantes para usu\u00e1rios de aplica\u00e7\u00f5es de visibilidade de duas diferentes\n\nmaneiras: primeiramente, com um algoritmo mais r\u00e1pido \u00e9 poss\u00edvel avaliar regi\u00f5es\n\nmaiores em tempos razo\u00e1veis; al\u00e9m disso, tamb\u00e9m \u00e9 poss\u00edvel avaliar uma determi-\n\nnada regi\u00e3o com dados em alta resolu\u00e7\u00e3o, gerando resultados cada vez mais precisos\n\nsem necessariamente aumentar o tempo de processamento.\n\nNos Cap\u00edtulos de 2 a 4 foi apresentado o algoritmo para mem\u00f3ria externa Ti-\n\nledVS. Este algoritmo consiste em uma adapta\u00e7\u00e3o do algoritmo RFVS, proposto por\n\nFranklin and Ray [1994]. Para diminuir o n\u00famero de opera\u00e7\u00f5es de E/S realizadas,\n\n\u00e9 utilizada a biblioteca especial TiledMatrix [Silveira et al., 2013], que controla os\n\nacessos \u00e0s matrizes armazenadas em mem\u00f3ria externa de forma eficiente. Para isso,\n\nesta biblioteca reorganiza os dados da matriz em mem\u00f3ria externa subdividindo-a\n\nem blocos retangulares que s\u00e3o armazenados de forma cont\u00edgua. A mem\u00f3ria interna\n\n\u00e9 ent\u00e3o gerenciada como uma mem\u00f3ria cache gerenciada pela aplica\u00e7\u00e3o, que carrega\n\nestes blocos \u00e0 medida que s\u00e3o requisitados acessos a suas c\u00e9lulas, descarregando,\n\nquando necess\u00e1rio, os blocos que est\u00e3o a mais tempo sem ser acessados. Al\u00e9m disso,\n\nna vers\u00e3o mais recente deste algoritmo (descrita no Cap\u00edtulo 4), \u00e9 utilizada tamb\u00e9m\n\numa estrat\u00e9gia de compress\u00e3o r\u00e1pida dos blocos, o que conseguiu diminuir os tem-\n\npos de processamento em at\u00e9 42%. Os resultados experimentais mostraram que este\n\nnovo algoritmo \u00e9 mais de 4 vezes mais r\u00e1pido do que todos os demais algoritmos\n\nencontrados em literatura.\n\nCom rela\u00e7\u00e3o ao algoritmo TiledVS, prop\u00f5e-se acelerar ainda mais o proces-\n\nsamento atrav\u00e9s de algoritmos paralelos, possivelmente com a utiliza\u00e7\u00e3o de placas\n\ngr\u00e1ficas (GPUs). Uma primeira abordagem seria a paraleliza\u00e7\u00e3o do algoritmo de\n\ncompress\u00e3o utilizado pela TiledMatrix, para que esta compress\u00e3o seja feita de forma\n\nainda mais r\u00e1pida. A segunda ideia seria a paraleliza\u00e7\u00e3o do processo de rota\u00e7\u00e3o da\n\nlinha de vis\u00e3o utilizado pelo algoritmo RFVS. Esta segunda abordagem representa\n\n63\n\n\n\n6. Conclus\u00f5es gerais e trabalhos futuros 64\n\numa tarefa bem mais complexa do que a primeira, uma vez que combinar processa-\n\nmento em mem\u00f3ria externa com processamento paralelo n\u00e3o \u00e9 trivial. Por\u00e9m, como\n\nZhao et al. [2013] mostraram recentemente, \u00e9 poss\u00edvel alcan\u00e7ar bons resultados.\n\nNo Cap\u00edtulo 5 foi proposto outro algoritmo para c\u00e1lculo de viewshed, neste caso\n\nbaseado em arquiteturas paralelas. O novo algoritmo utiliza o modelo de progra-\n\nma\u00e7\u00e3o paralela de mem\u00f3ria compartilhada (OpenMP), dispon\u00edvel na maioria das\n\narquiteturas atuais, mesmo em computadores pessoais relativamente simples. O\n\nnovo algoritmo subdivide o terreno em diversos setores em torno do observador e\n\nprocessa cada um destes setores de forma independente. Conforme mostrado pe-\n\nlos resultados experimentais, usando um computador com 4 cores pode-se obter\n\nresultados at\u00e9 4 vezes mais r\u00e1pidos do que o algoritmo convencional (isto \u00e9, sequen-\n\ncial). Al\u00e9m disso, com um computador com maior capacidade (por exemplo, com\n\n16 cores), \u00e9 poss\u00edvel obter processamentos at\u00e9 12 vezes mais r\u00e1pidos.\n\nA inten\u00e7\u00e3o como trabalho futuro \u00e9 adaptar este algoritmo utilizando progra-\n\nma\u00e7\u00e3o em GPUs. Por\u00e9m, esta adapta\u00e7\u00e3o n\u00e3o poder\u00e1 ser feita forma direta, uma vez\n\nque a arquitetura das GPUs apresenta diversas diferen\u00e7as com rela\u00e7\u00e3o \u00e0 arquitetura\n\nde um processador multi-core. Por exemplo, dentre as dificuldades que ser\u00e3o encon-\n\ntradas ao fazer esta adapta\u00e7\u00e3o, podemos citar o alto custo das opera\u00e7\u00f5es de c\u00f3pia\n\nde dados em uma GPU e a impossibilidade de utilizar ponteiros para implementar\n\na \u00e1rvore bin\u00e1ria balanceada utilizada pelo algoritmo de Van Kreveld. Assim, esta\n\ntarefa exigir\u00e1 um estudo mais detalhado da arquitetura das GPUs, que s\u00e3o mais\n\ncomplexas e cont\u00e9m diversas camadas de mem\u00f3ria com diferentes caracter\u00edsticas.\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas\n\nAggarwal, A. and Vitter, J. S. (1988). The input/output complexity of sorting and\n\nrelated problems. Communications of the ACM, 31(9):1116\u20131127.\n\nAndrade, M. V. A., Magalh\u00e3es, S. V. G., Magalh\u00e3es, M. A., Franklin, W. R.,\n\nand Cutler, B. M. (2011). Efficient viewshed computation on terrain in external\n\nmemory. Geoinformatica, 15(2):381\u2013397.\n\nBarney, B. et al. (2010). Introduction to parallel computing. Lawrence Livermore\n\nNational Laboratory, 6(13):10.\n\nBen-Moshe, B., Mitchell, J. S. B., Katz, M. J., and Nir, Y. (2002). Visibility\n\npreserving terrain simplification \u2014 an experimental study. In Proceedings of\n\nACM Symposium of Computational Geometry, pages 303\u2013311, Barcelona, Spain.\n\nBen-Shimol, Y., Ben-Moshe, B., Ben-Yehezkel, Y., Dvir, A., and Segal, M. (2007).\n\nAutomated antenna positioning algorithms for wireless fixed-access networks.\n\nJournal of Heuristics, 13(3):243\u2013263.\n\nBespamyatnikh, S., Chen, Z., Wang, K., and Zhu, B. (2001). On the planar two-\n\nwatchtower problem. In 7th International Computing and Combinatorics Confer-\n\nence, pages 121\u2013130. Springer-Verlag London.\n\nBresenham, J. E. (1965). An incremental algorithm for digital plotting. IBM Systems\n\nJournal, 4(1):25\u201330.\n\nC\u00e2mara, G., Davis, C., and Monteiro, A. M. (2001). Introdu\u00e7\u00e3o \u00e0 Ci\u00eancia da\n\nGeoinforma\u00e7\u00e3o. Instituto de Pesquisa Espacial- INPE, S\u00e3o Jose dos Campos, SP,\n\nBrasil,Disponivel em: http://www.dpi.inpe.br/gilberto/livro/introd/ \u2014 Aces-\n\nsado em 16 Novembro 2013.\n\nCamp, R. J., Sinton, D. T., and Knight, R. L. (1997). Viewsheds: A complementary\n\nmanagement approach to buffer zones. Wildlife Society Bulletin, 25(3):612\u2013615.\n\nChampion, D. C. and Lavery, J. E. (2002). Line of sight in natural terrain deter-\n\nmined by L1-spline and conventional methods. In 23rd Army Science Conference,\n\nOrlando, Florida.\n\n65\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas 66\n\nChao, F., Chongjun, Y., Zhuo, C., Xiaojing, Y., and Hantao, G. (2011). Parallel\n\nalgorithm for viewshed analysis on a modern GPU. International Journal of\n\nDigital Earth, 4(6):471\u2013486.\n\nCole, R. and Sharir, M. (1989). Visibility problems for polyhedral terrains. Journal\n\nof Symbolic Computation, 7(1):11\u201330.\n\nCollet, Y. (2012). Extremely fast compression algorithm.\n\nhttp://code.google.com/p/lz4/.\n\nDagum, L. and Menon, R. (1998). Openmp: an industry standard api for shared-\n\nmemory programming. Computational Science &amp; Engineering, IEEE, 5(1):46\u201355.\n\nDementiev, R., Kettner, L., and Sanders, P. (2005). Stxxl : Standard template\n\nlibrary for xxl data sets. Technical report, Fakult\u00e4t f\u00fcr Informatik, Universit\u00e4t\n\nKarlsruhe. http://stxxl.sourceforge.net/ \u2014 Acessado em 01 Dezembro 2013).\n\nEidenbenz, S. (2002). Approximation algorithms for terrain guarding. Information\n\nProcessing Letters, 82(2):99\u2013105.\n\nFelgueiras, C. A. (2001). Modelagem num\u00e9rica de terreno. In G. C\u00e2mara, C. Davis,\n\nA. M. V. M., editor, Introdu\u00e7\u00e3o \u00e0 Ci\u00eancia da Geoinforma\u00e7\u00e3o, volume 1. INPE.\n\nFerreira, C. R., Andrade, M. V., Magalhaes, S. V., and Franklin, W. R. (2014). A\n\nfast external memory algorithm for computing visibility on grid terrains. Submit-\n\nted for publication. ACM Transactions on Spatial Algorithms and Systems.\n\nFerreira, C. R., Andrade, M. V. A., Magalh\u00e3es, S. V. G., and Pompermayer, A. M.\n\n(2012a). Uma abordagem eficiente para o c\u00e1lculo de viewshed em terrenos ar-\n\nmazenados em mem\u00f3ria externa. In XXXIX Semin\u00e1rio Integrado de Software e\n\nHardware (SEMISH 2012).\n\nFerreira, C. R., Andrade, M. V. A., Magalh\u00e3es, S. V. G., Franklin, W. R., and\n\nPena, G. C. (2013). A parallel sweep line algorithm for visibility computation. In\n\nGeoInfo 2013 - XIV Brazilian Symposium on Geoinformatics, pages 85\u201396.\n\nFerreira, C. R., Magalh\u00e3es, S. V. G., Andrade, M. V. A., Franklin, W. R., and\n\nPompermayer, A. M. (2012b). More efficient terrain viewshed computation on\n\nmassive datasets using external memory. In Proceedings of the 20th International\n\nConference on Advances in Geographic Information Systems, SIGSPATIAL \u201912,\n\npages 494\u2013497, New York, NY, USA. ACM.\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas 67\n\nFisher, P. F. (1993). Algorithm and implementation uncertainty in viewshed anal-\n\nysis. International Journal of Geographical Information Science, 7(4):331\u2013347.\n\nFishman, J., Haverkort, H. J., and Toma, L. (2009). Improved visibility computation\n\non massive grid terrains. In Wolfson, O., Agrawal, D., and Lu, C.-T., editors, GIS,\n\npages 121\u2013130. ACM.\n\nFloriani, L. D. and Magillo, P. (2003). Algorithms for visibility computation on\n\nterrains: a survey. Environment and Planning B: Planning and Design, 30(5):709\u2013\n\n728.\n\nFloriani, L. D., Puppo, E., and Magillo, P. (1999). Applications of computational\n\ngeometry to geographic information systems. In J. R. Sack, J. U., editor, Handbook\n\nof Computational Geometry, pages 303\u2013311. Elsevier Science.\n\nFranklin, W. R. and Ray, C. (1994). Higher is not necessarily better: Visibility\n\nalgorithms and experiments. In Waugh, T. C. and Healey, R. G., editors, Advances\n\nin GIS Research: Sixth International Symposium on Spatial Data Handling, pages\n\n751\u2013770, Edinburgh. Taylor &amp; Francis.\n\nFranklin, W. R., Ray, C. K., Randolph, P. W., Clark, L., Ray, K., and Mehta, P. S.\n\n(1994). Geometric algorithms for siting of air defense missile batteries.\n\nFranklin, W. R. and Vogt, C. (2006). Tradeoffs when multiple observer siting on\n\nlarge terrain cells. In Riedl, A., Kainz, W., and Elmes, G., editors, Progress in\n\nSpatial Data Handling: 12th international symposium on spatial data handling,\n\npages 845\u2013861, Vienna. Springer. ISBN 978-3-540-35588-5.\n\nGao, Y., Yu, H., Liu, Y., Liu, Y., Liu, M., and Zhao, Y. (2011). Optimization for\n\nviewshed analysis on GPU. In Geoinformatics, 2011 19th International Confer-\n\nence on, pages 1\u20135. IEEE.\n\nGraham, R. L., Knuth, D. E., and Patashnik, O. (1994). Concrete Mathematics:\n\nA Foundation for Computer Science. Addison-Wesley Longman Publishing Co.,\n\nInc., Boston, MA, USA, 2nd edition.\n\nHaverkort, H. and Zhuang, Y. (2007). Computing visibility on terrains in ex-\n\nternal memory. In Proceedings of the Ninth Workshop on Algorithm Engineer-\n\ning and Experiments / Workshop on Analytic Algorithms and Combinatorics\n\n(ALENEX/ANALCO).\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas 68\n\nHaverkort, H. J., Toma, L., and Zhuang, Y. (2007). Computing visibility on terrains\n\nin external memory. In ALENEX.\n\nLake, I. R., Lovett, A. A., Bateman, I. J., and Langford, I. H. (1998). Modelling\n\nenvironmental influences on property prices in an urban environment. Computers,\n\nEnvironment and Urban Systems, 22(2):121\u2013136.\n\nLaurini, R. and Thompson, D. (1992). Fundamentals of Spatial Information Sys-\n\ntems. Academic Press.\n\nLee, J. and Stucky, D. (1998). On applying viewshed analysis for determining least-\n\ncost paths on digital elevation models. International Journal of Geographical\n\nInformation Science, 12(8):891\u2013905.\n\nLi, Z., Zhu, Q., and Gold, C. (2005). Digital Terrain Modeling \u2014 principles and\n\nmethodology. CRC Press.\n\nMa?iorov, F. (1964). Electronic digital integrating computers: digital differential\n\nanalyzers. Iliffe Books (London and New York).\n\nMagalh\u00e3es, S. V. G., Andrade, M. V. A., and Franklin, W. R. (2011). Multiple\n\nobserver siting in huge terrains stored in external memory. International Journal\n\nof Computer Information Systems and Industrial Management (IJCISIM), 3.\n\nMills, K., Fox, G., and Heimbach, R. (1992). Implementing an intervisibility analysis\n\nmodel on a parallel computing system. Computers &amp; Geosciences, 18(8):1047\u2013\n\n1054.\n\nNagy, G. (1994). Terrain visibility. Computers and Graphics, 18(6):763\u2013773.\n\nNVidia (2012). Tesla GPU high performance computing for servers. Available from:\n\nhttp://www.nvidia.com/object/tesla-servers.html.\n\nOsterman, A. (2012). Implementation of the r.cuda.los module in the open source\n\ngrass gis by using parallel computation on the NVIDIA CUDA graphic cards.\n\nELEKTROTEHNI\u00cb?SKI VESTNIK, 79(1-2):19\u201324.\n\nPasmark (2013). Cpu benchmark. http://www.cpubenchmark.net/.\n\nPatterson, D. A. and Hennessy, J. L. (2008). Computer Organization and Design,\n\nFourth Edition, Fourth Edition: The Hardware/Software Interface (The Morgan\n\nKaufmann Series in Computer Architecture and Design). Morgan Kaufmann\n\nPublishers Inc., San Francisco, CA, USA, 4th edition.\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas 69\n\nRabus, B., Eineder, M., Roth, A., and Bamler, R. (2003). The Shuttle Radar\n\nTopography Mission (SRTM). http://www2.jpl.nasa.gov/srtm/ \u2014 Acessado em\n\n14 Janeiro 2014.\n\nShapira, A. (1990). Visibility and terrain labeling. Master\u2019s thesis, Rensselaer\n\nPolytechnic Institute.\n\nSilveira, J. A., Magalh\u00e3es, S. V. G., Andrade, M. V. A., and Concei\u00e7\u00e3o, V. S.\n\n(2013). A library to support the development of applications that process huge\n\nmatrices in external memory. In Proceedings of 15th International Conference on\n\nEnterprise Information Systems (ICEIS), pages 305\u2013310, Angers, France.\n\nStookey, J., Xie, Z., Cutler, B., Franklin, W. R., Tracy, D. M., and Andrade, M. V.\n\n(2008). Parallel ODETLAP for terrain compression and reconstruction. In Aref,\n\nW. G. et al., editors, 16th ACM SIGSPATIAL International Conference on Ad-\n\nvances in Geographic Information Systems (ACM GIS 2008), Irvine CA.\n\nStrnad, D. (2011). Parallel terrain visibility calculation on the graphics processing\n\nunit. Concurrency and Computation: Practice and Experience, 23(18):2452\u20132462.\n\nTeng, Y. A., Dementhon, D., and Davis, L. S. (1993). Region-to-region visibility\n\nanalysis using data parallel machines. Concurrency: Practice and Experience,\n\n5(5):379\u2013406.\n\nToma, L., Zhuang, Y., and Richard, W. (2010). r.viewshed. https://trac.osgeo.org/\n\n/grass/browser/grass-addons/raster/r.viewshed?rev=45442.\n\nVan Kreveld, M. (1996). Variations on sweep algorithms: efficient computation\n\nof extended viewsheds and class intervals. In Proceedings of the Symposium on\n\nSpatial Data Handling, pages 15\u201327.\n\nZhao, Y., Padmanabhan, A., and Wang, S. (2013). A parallel computing approach\n\nto viewshed analysis of large terrain data using graphics processing units. Inter-\n\nnational Journal of Geographical Information Science, 27(2):363\u2013384."}]}}}