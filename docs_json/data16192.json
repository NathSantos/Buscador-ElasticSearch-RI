{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.20280"}, {"@name": "filename", "#text": "3751_333082.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DE SANTA CATARINA\nBIBLIOTECA UNIVERSITA?RIA\n\nThiago Javaroni Prati\n\nDESENVOLVIMENTO DE UMA METODOLOGIA PARA\nREALIZAC?A?O DE TESTES EM PROGRAMAS DE CLP\n\nNA INDU?STRIA DE PETRO?LEO E GA?S\n\nFloriano?polis(SC)\n\n2014\n\n\n\n\n\nThiago Javaroni Prati\n\nDESENVOLVIMENTO DE UMA METODOLOGIA PARA\nREALIZAC?A?O DE TESTES EM PROGRAMAS DE CLP\n\nNA INDU?STRIA DE PETRO?LEO E GA?S\n\nDissertac?a?o submetida ao Programa\nde Po?s-Graduac?a?o em Engenharia de\nAutomac?a?o e Sistemas para a obtenc?a?o\ndo Grau de Mestre em Engenharia de\nAutomac?a?o e Sistemas.\nOrientador: Jean-Marie Farines, Dr.Eng.\nCoorientador: Max Hering de Quei-\nroz, Dr.Eng.\n\nFloriano?polis(SC)\n\n2014\n\n\n\n\n\nThiago Javaroni Prati\n\nDESENVOLVIMENTO DE UMA METODOLOGIA PARA\nREALIZAC?A?O DE TESTES EM PROGRAMAS DE CLP\n\nNA INDU?STRIA DE PETRO?LEO E GA?S\n\nEsta Dissertac?a?o foi julgada aprovada para a obtenc?a?o do T??tulo\nde \u201cMestre em Engenharia de Automac?a?o e Sistemas\u201d, e aprovada em\nsua forma final pelo Programa de Po?s-Graduac?a?o em Engenharia de\nAutomac?a?o e Sistemas.\n\nFloriano?polis(SC), 04 de Dezembro 2014.\n\nJoa?o Ningue?m\nCoordenador\n\nMax Hering de Queiroz, Dr.Eng.\nCoorientador\n\nBanca Examinadora:\n\nPresidente da banca\nPresidente\n\nJean-Marie Farines, Dr.Eng.\nOrientador\n\nSegundo membro\n\n\n\n\n\nTerceiro membro\n\nQuarto membro\n\n\n\n\n\nA minha fam??lia e amigos\n\n\n\n\n\nAGRADECIMENTOS\n\nAgradec?o...\nA minha fam??lia que sempre esteve presente garantindo apoio\n\nemocional, por serem compreensivos e atenciosos.\nAos meus amigos com os quais eu sempre pude contar, por ga-\n\nrantirem o?timos momentos de conversa, reflexa?o e distrac?a?o.\nA?quele que, em seu olhar, nada ale?m de lealdade foi poss??vel en-\n\ncontrar, que nunca deixou de expressar seu amor inabala?vel, que sempre\nesteve la?, presente, mesmo que em seus momentos mais preguic?osos, que\nnunca recusou sequer um simples afago, que me acompanhou por mo-\nmentos extremamente importantes durante um longo tempo na minha\nvida e que, mesmo sem perceber, acabou deixando um sentimento de\nsaudade e boas recordac?o?es que sera?o eternas. Meu querido bebe?.\n\nAos meus orientadores pelas o?timas ideias dadas e discusso?es es-\nsenciais para o desenvolvimento desse trabalho, pela pacie?ncia e com-\npreensa?o que tiveram comigo.\n\n\n\n\n\nProponha-se a atingir o sol e voce? podera?\nna?o o alcanc?ar, mas sua seta voara? muito\nmais alto do que se fosse apontada para\num objeto ao mesmo n??vel de voce?.\n\nJoel Hawes\n\n\n\n\n\nRESUMO\n\nOs programas de automac?a?o na indu?stria de petro?leo e ga?s, seja o\nprograma voltado para sistemas de seguranc?a ou de uso geral, sa?o pro-\njetados com base em especificac?o?es de seguranc?a, definidas em projeto,\nque devem ser validados antes da implantac?a?o. Este documento propo?e\num me?todo para o teste automa?tico das especificac?o?es encontradas na\nMatriz Causa e Efeito e implementadas em Controladores Lo?gicos Pro-\ngrama?veis (CLPs). Para esses testes, as especificac?o?es sa?o represen-\ntadas como um conjunto de modelos de rede de Petri que observam\no comportamento do sistema controlado. O uso de um modelo for-\nmal permite composic?a?o de diferentes modelos de forma sistema?tica e\na traduc?a?o das Redes de Petri em um programa que comanda as en-\ntradas de um CLP e observa quando o comportamento do CLP segue\nou falha em seguir as especificac?o?es de seguranc?a. Uma ferramenta\nproto?tipo foi desenvolvida para executar automaticamente o teste da\nMatriz Causa e Efeito em um dado CLP. Um projeto de um forno foi\nutilizado para verificar se a metologia proposta e? fa?cil de usar e via?vel.\nPalavras-chave: Controladores Lo?gicos Programa?veis, Testes Auto-\nmatizados, Validac?a?o, redes de Petri, Sistemas Instrumentados de Se-\nguranc?a.\n\n\n\n\n\nABSTRACT\n\nThe automation programs in the oil and gas industry, be it in Safety\nInstrumented Systems (SIS) or in general purpose Programmable Lo-\ngic Controllers (PLC), are designed based on safety specifications that\nmust be validated prior to deployment. This paper proposes a method\nfor the automatic test of the Cause and Efect Matrix specifications on\nPLC systems. For such testing, the specifications are represented as\na set of Petri net models that observe the controlled system behavior.\nThe use of a formal model allows to systematically compose and trans-\nlate the Petri Nets into a program that commands the PLC inputs and\nobserves when the PLC outputs fail the safety specifications. A pro-\ntotype tool has been developed to automatically perform the test of the\nCause and Efect Matrix on a given PLC. A furnace project has been\nused to ascertain that the proposed method is easy to use and viable.\nKeywords: Programmable Logic Controllers, Automatic Testing, Va-\nlidation, Petri Nets, Safety Instrumented Systems.\n\n\n\n\n\nSUMA?RIO\n\n1 INTRODUC?A?O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.1 MOTIVAC?A?O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.2 OBJETIVOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n1.3 ESTRUTURA DA DISSERTAC?A?O . . . . . . . . . . . . . . . . . . . . . . 21\n2 MODELAGEM E VALIDAC?A?O DE PROGRAMAS\n\nDE CLP UTILIZANDO ME?TODOS FORMAIS . . . . . 23\n2.1 MODELAGEM DE SISTEMAS ATRAVE?S DE REDES DE\n\nPETRI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n2.1.1 Fundamentos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n2.1.2 Fusa?o de redes de Petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n2.1.3 Observadores baseados em Redes de Petri . . . . . . . . . 27\n2.2 VERIFICAC?A?O FORMAL POR MODEL CHECKING . . . . 27\n2.3 ABORDAGENS FORMAIS NO DESENVOLVIMENTO OU\n\nVERIFICAC?A?O DE PROGRAMAS DE CLP . . . . . . . . . . . . . 29\n2.3.1 Diagno?stico e tratamento de falhas em sistemas\n\ncr??ticos utilizando me?todos formais . . . . . . . . . . . . . . . . . 29\n2.3.2 Uma abordagem baseada em engenharia dirigida a\n\nmodelos para a verificac?a?o de programas de CLP . . 31\n2.3.3 Um conjunto de ferramentas para verificac?a?o de\n\nmodelo de programa de CLP . . . . . . . . . . . . . . . . . . . . . . . 32\n2.4 VALIDAC?A?O DE PROGRAMAS ATRAVE?S DE TESTES . . 34\n2.4.1 Testes em sistemas instrumentados de seguranc?a\n\natrave?s de equivale?ncia de classes . . . . . . . . . . . . . . . . . . 37\n2.5 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n3 METODOLOGIA DE DESENVOLVIMENTO DO SOFT-\n\nWARE DE AUTOMAC?A?O NA INDU?STRIA DE PETRO?LEO\nE GA?S . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n\n3.1 DESCRIC?A?O DE UM FORNO INDUSTRIAL PRESENTE\nEM UMA UNIDADE DE HIDROTATAMENTO DE DIESEL 41\n\n3.2 METODOLOGIA DE DESENVOLVIMENTO DE PROJETO\nDA INDU?STRIA DE PETRO?LEO E GA?S . . . . . . . . . . . . . . . . 44\n\n3.3 METODOLOGIA PARA DESENVOLVIMENTO DO SOFT-\nWARE DE CLP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n\n3.4 LIMITAC?O?ES DA METODOLOGIA ATUAL . . . . . . . . . . . . . 50\n3.5 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n4 PROPOSIC?A?O DE UMA NOVA METODOLOGIA\n\nPARA GERAC?A?O E REALIZAC?A?O DE TESTES . . . 53\n\n\n\n4.1 VISA?O GERAL DA METODOLOGIA E SUA INSERC?A?O\nNO DESENVOLVIMENTO DO PROJETO . . . . . . . . . . . . . . . 53\n\n4.2 GERAC?A?O DE OBSERVADORES . . . . . . . . . . . . . . . . . . . . . . 56\n4.2.1 Observadores ba?sicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n4.2.1.1 Entradas boleanas simples . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n4.2.1.2 Grupos de entradas boleanas . . . . . . . . . . . . . . . . . . . . . . . . . 59\n4.2.1.3 Votac?a?o de sinais de campo . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n4.2.1.4 Entradas boleanas com mu?ltiplos efeitos temporizados . . . 61\n4.2.2 Composic?a?o de observadores . . . . . . . . . . . . . . . . . . . . . . . 62\n4.3 GERAC?A?O DE TESTES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n4.3.1 Execuc?a?o dos testes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n4.4 EXECUC?A?O DOS OBSERVADORES A PARTIR DOS RE-\n\nSULTADOS DOS TESTES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n4.5 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n5 DESENVOLVIMENTO DE UMA FERRAMENTA PARA\n\nSUPORTAR A METODOLOGIA PROPOSTA . . . . . . 69\n5.1 DESENVOLVIMENTO DE UMA FERRAMENTA DE TES-\n\nTES E VALIDAC?A?O DA METODOLOGIA . . . . . . . . . . . . . . 69\n5.2 ENTRADA DE DADOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n5.3 GERAC?A?O DE OBSERVADORES . . . . . . . . . . . . . . . . . . . . . . 71\n5.4 DEFINIC?A?O DOS CASOS DE TESTE E GERAC?A?O DE\n\nCOMANDOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n5.5 INTERAC?A?O DA FERRAMENTA COM A PLANTA SI-\n\nMULADA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\n5.5.1 Limitac?o?es temporais da ferramenta desenvolvida . . 75\n5.6 UTILIZAC?A?O DOS OBSERVADORES PARA VALIDAC?A?O\n\nDOS TESTES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n5.7 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n6 AVALIAC?A?O DA METODOLOGIA PROPOSTA . . . . 79\n6.1 CO?DIGO DE AUTOMAC?A?O . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\n6.2 SIMULAC?A?O DA PLANTA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\n6.3 EXPERIMENTOS REALIZADOS E RESULTADOS OBTI-\n\nDOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n6.4 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\n7 CONCLUSA?O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\n7.1 DIRETRIZES PARA TRABALHOS FUTUROS . . . . . . . . . . . 88\nREFERE?NCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91\nAPE?NDICE A -- Co?digo Ladder Utilizado para Validac?a?o 107\n\n\n\n19\n\n1 INTRODUC?A?O\n\n1.1 MOTIVAC?A?O\n\nA complexidade dos problemas de controle industrial pode che-\ngar a grandes escalas. Na Indu?stria de Petro?leo e Ga?s, controles es-\npec??ficos podem ser usados para executar tarefas de automac?a?o que\nrequerem um elevado grau de confiabilidade, uma vez que as falhas po-\ndem levar a? danos se?rios e custosos de equipamentos, danos ambientais\ne ate? mesmo a perda de vidas humanas, como visto em (SKOGDALE;\nSMOGELI, 2011). O desenvolvimento destes sistemas de controle requer\numa grande atenc?a?o, uma vez que lida com requisitos rigorosos, que\npodem incluir restric?o?es temporais, de seguranc?a e de confiabilidade.\nPara o desenvolvimento destes projetos, as empresas costumam utilizar\nnormas que te?m como um objetivo a normalizac?a?o da construc?a?o de um\nsoftware de automac?a?o que atenda aos requisitos do projeto.\n\nNo caso da indu?stria de petro?leo e ga?s, a ana?lise da confiabilidade\ndo sistema resulta na decisa?o da utilizac?a?o ou na?o de equipamentos es-\npecializados para a automac?a?o de sistemas considerados cr??ticos. A au-\ntomac?a?o pode ser, enta?o, realizada atrave?s de lo?gica de rele?s, de disposi-\ntivos programa?veis como Controladores Lo?gicos Programa?veis (CLPs).\nExemplos de sistemas que podem vir a ser automatizados atrave?s de\nCLPs sa?o: sistema de parada de emerge?ncia (ESD-Emergency shut-\ndown); Sistema de parada de seguranc?a (Safety shutdown); Sistema de\nintertravamento de seguranc?a; Sistema de fogo e ga?s. Os sistemas uti-\nlizados devem atender a?s especificac?o?es do projeto a fim de garantir a\nseguranc?a de operac?a?o da planta.\n\nA metodologia para o desenvolvimento de sistemas de automac?a?o\natualmente adotada pela Petrobras consiste em um seque?ncia de passos\ncomec?ando a partir de especificac?o?es ba?sicas da planta a ser automa-\ntizada e termina com o desenvolvimento de um software utilizado em\num CLP para automac?a?o. Esta metodologia utiliza um conjunto de\nnormas gerais e principalmente internas, como visto em (COMISSa?O DE\nNORMAS Te?CNICAS, 2002) e (COMISSa?O DE NORMAS Te?CNICAS, 2012).\nDe acordo com essas normas, uma se?rie de documentos que contenham\ninformac?o?es relevantes ao longo do projeto sa?o criados. A Matriz de\nCausa e Efeito (matriz C&amp;E), por exemplo, e? um documento que de-\nfine a relac?a?o entre sinais de campo que indicam situac?o?es cr??ticas e\nac?o?es de seguranc?a adequadas. O documento de Teste de Aceitac?a?o de\nFa?brica (FAT) descreve como testar o programa de automac?a?o final, a\n\n\n\n20\n\nfim de validar o programa de CLP, como descrito nos documentos do\nprojeto.\n\nO desenvolvimento da aplicac?a?o presente em um sistema de au-\ntomac?a?o, seja ele implementado em um CLP ou ainda um SIS, e? cons-\ntitu??do por sequenciamentos, intertravamentos e outras lo?gicas que po-\ndem ser facilmente representadas por Sistemas a Eventos Discretos\n(SED). Estes sistemas sa?o caracterizados por um espac?o de estados\ndiscreto de valores lo?gicos cuja dina?mica e? dirigida pela ocorre?ncia de\neventos e podem ser representados por modelos formais. Em um pro-\njeto, estes SED poderiam ser desenvolvidos atrave?s de metodologias\nespec??ficas e implementados nos sistemas de automac?a?o, utilizando-\nse de linguagens das normas IEC 61131-3 e IEC 61499. Embora\na utilizac?a?o destas representac?o?es formais ja? tenham sido abordadas\nem outros trabalhos como (PAKONEN et al., 2013), (FARINES; QUEIROZ;\nCARPES, 2011) e (Ju?NIOR, 2011) para demonstrar sua efetividade no\ncumprimento dos requisitos por parte do programa, existe, ainda, uma\nbaixa aceitac?a?o na utilizac?a?o destas representac?o?es no momento do pro-\njeto da aplicac?a?o de um sistema de automac?a?o ou ainda no momento\nda validac?a?o desta aplicac?a?o.\n\nApesar da complexidade envolvida e da confiabilidade exigida em\nsistemas de automac?a?o, a validac?a?o de programas de CLP no a?mbito\nindustrial e? feita principalmente atrave?s de testes e simulac?o?es. Estas\nvalidac?o?es sa?o realizadas a partir dos requisitos presentes nos documen-\ntos ba?sicos de projeto e acabam por demandar um longo tempo para\nserem executadas, visto que sa?o manuais, e mesmo com o tempo des-\nprendido, na?o sa?o exaustivas. Consequentemente, alguns erros podem\nser negligenciados e, portanto, podem resultar em danos aos equipa-\nmentos e, a?s vezes, ameac?a aos seres humanos.\n\nDada a atual abordagem na realizac?a?o dos testes em a?mbito\nindustrial, se mostra importante a utilizac?a?o de algum me?todo que\npossibilite uma maior facilidade na realizac?a?o dos testes de programa\nde CLP. A gerac?a?o de testes automatizados, por exemplo, permite a\nexecuc?a?o dos mesmos sem a presenc?a humana, economizando tempo de\nprojeto ao poder ser realizado independentemente da supervisa?o de um\nengenheiro e pode ainda aumentar o leque de situac?o?es testadas devido\na? essa mesma economia de tempo.\n\n\n\n21\n\n1.2 OBJETIVOS\n\nO objetivo desta pesquisa e? o elaborac?a?o de uma metodologia\nque permita o desenvolvimento de sistemas mais seguros e que sigam\nas conformidades estabelecidas em projetos complexos, como aqueles\nencontrados na indu?stria de petro?leo e ga?s. Nesse sentido, defini-se\numa metodologia de gerac?a?o de testes que permite ao engenheiro da\nindu?stria do petro?leo e ga?s certificar programas a partir da conformi-\ndade destes com os documentos ba?sicos existentes no projeto. Para\napoiar a aplicac?a?o desta metodologia, desenvolve-se uma ferramenta\nque permite gerar e executar de forma automa?tica as seque?ncias de\ntestes necessa?rias para a validac?a?o.\n\nPara a validac?a?o da ferramenta, utiliza-se um cena?rio exemplo .\nNeste cena?rio, uma planta desenvolvida em ambiente de simulac?a?o e um\nsistema de controle criado baseando-se nos requisitos de projeto para\nesta planta exemplo sa?o utilizados. A ligac?a?o entre a planta simulada e\neste sistema de controle se da? desta maneira: a planta simulada recebe\ncomandos oriundos do sistema de controle e responde com valores de\nsensores gerados pela simulac?a?o. Isso deve ser tal que o sistema de\ncontrole na?o perceba a diferenc?a entre um sistema dina?mico real e a\nsimulac?a?o. Assim, condic?o?es de operac?a?o da planta que seriam dif??ceis\nde serem implementadas em uma planta real por questo?es de seguranc?a,\npor exemplo, pudem ser realizadas pelo sistema. Durante esse processo\nde simulac?a?o da planta e atuac?a?o por parte do sistema de controle\ncriado, a ferramenta obte?m os dados pertinentes para a obtenc?a?o de\nresultados.\n\n1.3 ESTRUTURA DA DISSERTAC?A?O\n\nNa seque?ncia deste cap??tulo introduto?rio, sa?o apresentadas no\ncap??tulo 2 te?cnicas para verificac?a?o e te?cnicas de teste de software, as-\nsim como alguns trabalhos da a?rea. No cap??tulo 3 e? apresentada a meto-\ndologia atual de desenvolvimento de software utilizada pela Petrobras,\njuntamente com um exemplo para melhor entendimento. Em seguida,\nno cap??tulo 4, uma nova metodologia para a realizac?a?o de testes dentro\ndo desenvolvimento de um projeto, segundo o exposto no cap??tulo 3, e?\ndesenvolvida. No cap??tulo 5, e? apresentado um estudo de caso onde sa?o\nrealizados testes utilizando um projeto da Petrobras como base para\nos mesmos. Finalmente, no cap??tulo 6, sa?o apresentadas as concluso?es\ndeste trabalho e sugesto?es para trabalhos futuros.\n\n\n\n22\n\n\n\n23\n\n2 MODELAGEM E VALIDAC?A?O DE PROGRAMAS DE\nCLP UTILIZANDO ME?TODOS FORMAIS\n\nDiversas te?cnicas podem ser utilizadas para o desenvolvimento de\nprogramas de CLP. Da mesma maneira, todo desenvolvimento de pro-\ngrama conta com a realizac?a?o de algum tipo de validac?a?o durante este\nprocesso ou ao final do mesmo. As te?cnicas para desenvolvimento po-\ndem se basear em boas pra?ticas de programac?a?o (JACOBSON et al., 1999)\nou ainda podem ser baseadas em me?todos formais. As boas pra?ticas\nde programac?a?o podem ser estipuladas tanto pela companhia que o de-\nsenvolve, quanto por pesquisadores da a?rea, enquanto as te?cnicas base-\nadas em me?todos formais baseiam-se em algum tipo de representac?a?o\nformal do sistema como: auto?matos, redes de Petri, redes Bayesianas\nou outras e te?m, como objetivo, a gerac?a?o de um programa correto por\nconstruc?a?o.\n\nJa? a validac?a?o de um programa de CLP pode se dar atrave?s de\nverificac?a?o formal ou atrave?s de testes. Assim como no desenvolvimento\nbaseado em me?todos formais, a verificac?a?o formal consiste em se uti-\nlizar uma representac?a?o formal para verificar se o programa apresenta\no comportamento esperado. Para tal, o programa e? transformado em\num modelo formal equivalente e, atrave?s de fo?rmulas, tem suas propri-\nedades verificadas. Ja? os testes se baseiam na definic?a?o de conjuntos\nde valores de entrada e de sa??da esperados e, atrave?s da inserc?a?o das\nentradas e subsequente comparac?a?o entre valores de sa??da esperados e\nos obtidos, se analisa o correto funcionamento do programa.\n\nEste cap??tulo aborda conceitos necessa?rios para o entendimento\nde futuros temas deste documento, ale?m de trabalhos relacionados. Sa?o\napresentadas redes de Petri, trabalhos relacionados que lidam tanto\ncom a modelagem de sistemas e gerac?a?o de co?digo, como com a veri-\nficac?a?o de programas de CLP atrave?s de me?todos formais e a realizac?a?o\nde testes. Sa?o apresentados os pontos mais essenciais das te?cnicas perti-\nnentes e tambe?m dos trabalhos que se utilizam dessas abordagens para\nvalidac?a?o de programas de automac?a?o.\n\n2.1 MODELAGEM DE SISTEMAS ATRAVE?S DE REDES DE PE-\nTRI\n\nRede de Petri e? uma te?cnica de modelagem que permite a repre-\nsentac?a?o de sistemas se utilizando de um formalismo matema?tico (MA-\n\n\n\n24\n\nCIEL; LINS; CUNHA, 1996), (ZURAWSKI; ZHOU, 2004), (ADAM; ATLURI;\nHUANG, 1998). Essa representac?a?o permite modelar sistemas parale-\nlos, concorrentes, ass??ncronos e na?o-determin??sticos (HAMADI; BENA-\nTALLAH, 2003), (MORALES; MELO; MIYAGI, 2007), (YOO; JEONG; CHO,\n2010).\n\nTre?s componentes definem a representac?a?o gra?fica de uma rede\nde Petri: a transic?a?o (representado por uma barra), o lugar (c??rculo)\ne o arco(seta) . Os lugares sa?o varia?veis de estado e as transic?o?es\ncorrespondem a?s ac?o?es realizadas pelo sistema (MACIEL; LINS; CUNHA,\n1996) enquanto o arco ligada os dois elementos anteriores entre si e\npodem ser u?nicos ou mu?ltiplos.\n\nLugares podem ser marcados ou na?o. Um lugar marcado e? re-\npresentado por um ou mais pontos desenhados dentro do c??rculo que\nrepresenta o lugar e sa?o chamados de fichas. A quantidade de fichas que\num lugar possui e? o que define o seu estado e e? chamada de marcac?a?o\ndeste lugar(FRANCe?S, 2003). O conjunto dos lugares da rede de Petri\nforma o conjunto das varia?veis de estado que representam o sistema\nmodelado. Assim, as marcac?o?es de todos os lugares em um dado mo-\nmento representa o estado do sistema e e? chamado de marcac?a?o da\nrede(MURATA, 1989), (ZURAWSKI; ZHOU, 2004), (XU et al., 2007).\n\nA rede de Petri permite a modelagem de diferentes tipos de mo-\ndelos, dentre eles: a sincronizac?a?o de processos, de operac?o?es concor-\nrentes e de conflitos, a ocorre?ncia de eventos ass??ncronos ou ainda com-\npartilhamento de recursos (ADAM; ATLURI; HUANG, 1998), (NASSAR et\nal., 2008), (ZURAWSKI; ZHOU, 2004). Desde sua apresentac?a?o por Carl\nAdam Petri, redes de Petri foram utilizadas na modelagem e ana?lise de\ndiferentes tipos de sistemas e aplicac?o?es como: diagno?stico e tratamento\nde falhas na?o cr??ticas (MORALES; MELO; MIYAGI, 2007) (SILVA, 2002)\n, protocolos distribu??dos (KANESHIRO et al., 2007), aplicac?o?es indus-\ntriais (NASSAR et al., 2008), fluxo de processos (KIEPUSZEWSKI; HOFS-\nTEDE; AALST, 2003), controle superviso?rio (LEE; ZHOU; HSU, 2005) e\ndiagno?stico e tratamento de falhas na?o cr??ticas (Ju?NIOR, 2011).\n\nAle?m disso, va?rias ferramentas para simulac?a?o, edic?a?o e ana?lise\nforam desenvolvidas desde a de?cada de 90( (ZURAWSKI; ZHOU, 1994)\n, (BERTHOMIEU, 2004)) e possibilitam a representac?a?o da dina?mica\ndo sistema e sua estrutura em diversos n??veis de abstrac?a?o (de acordo\ncom a complexidade do sistema (NASSAR et al., 2008)), a ana?lise das\nmodelagens e tambe?m sua simulac?a?o.\n\n\n\n25\n\n2.1.1 Fundamentos\n\nA rede de Petri ordina?ria e? uma tupla N = (P, T, I, O) associada\ncom uma descric?a?o de estado indicada por M. P = p1, p2, ..., pn e? um\nconjunto finito na?o-vazio de lugares, T = t1, t2, ..., tm e? um conjunto\nfinito na?o-vazio de transic?o?es. I:PxT? N e? a matriz de entrada que\nrelaciona transic?o?es com lugares de entrada enquanto O:PxT? N e? a\nmatriz de sa??da que relaciona transic?o?es com lugares de sa??da. As ma-\ntrizes de entrada e de sa??da conte?m, em cada elemento aij, o peso do\narco que liga o lugar pi a? transic?a?o tj se existir um arco, ou zero, caso\nna?o exista nenhum arco entre pi e tj (MURATA, 1989). Os arcos presen-\ntes na matriz de entrada (I) sa?o aqueles que saem do lugar e apontam\npara a transic?a?o correspondente, ou seja, sa?o aqueles que entram nas\ntransic?o?es. Os arcos na matriz de sa??da (O) sa?o aqueles que partem da\ntransic?a?o e apontam para o lugar, ou seja, saem das transic?o?es. M e?\num conjunto de nu?meros naturais que representa a quantidade de fichas\nnos lugares, tambe?m conhecido como marcac?a?o dos lugares. M0 indica\numa marcac?a?o inicial, isto e?, uma distribuic?a?o de fichas nos lugares\nque caracteriza o estado inicial da rede ((HAN et al., 2008), (MURATA,\n1989),(LI; ZHOU, 2008),(XU et al., 2007),(YOO; JEONG; CHO, 2010),(ZU-\nRAWSKI; ZHOU, 1994)) enquanto Mp indica o nu?mero de fichas no lu-\ngar p. Uma transic?a?o t esta? habilitada se ?p ? P, M(p) ? I(p, t) e,\numa vez habilitada, pode ser disparada. O disparo de uma transic?a?o\naltera a marcac?a?o M da rede produzindo uma marcac?a?o M\u2019, tal que\nM?p = Mp ? I(p, t) + O(p, t)?p ? P .\n\nA figura 1 apresenta um exemplo de rede de Petri exemplifi-\ncando como uma comunicac?a?o simples entre 2 servidores poderia ser\nmodelada.\n\nFigura 1: Exemplo de redes de Petri representando a comunicac?a?o entre\ndois servidores. Fonte:(OLIVEIRA, 2006)\n\n\n\n26\n\nOutro tipo de rede de Petri, o qual sera? abordado neste traba-\nlho, e? a rede de Petri temporizada. Uma rede de Petri temporizada e?,\nestruturalmente, igual a? rede de Petri ordina?ria, exceto que adiciona\na noc?a?o de tempo associada a?s transic?o?es. Uma rede de Petri tem-\nporizada e? uma tupla R = (P, T, I, O, C) onde P, T, I, O possuem as\nmesma definic?o?es ja? estabelecidas para a rede de Petri ordina?ria, en-\nquanto C : T ? NxN e? uma func?a?o que associa um intervalo de tempo\n(min,max), tal que min? 0 e max ? min, a cada transic?a?o. Para essa\nrede, o disparo de uma transic?a?o so? pode ocorrer apo?s a passagem de\nmin unidades de tempo apo?s sua habilitac?a?o e deve ser disparada em\nate? no ma?ximo max unidades de tempo apo?s sua habilitac?a?o. Outro\naspecto importante para esta modalidade de rede de Petri e? a memo?ria\nde habilitac?a?o. Apo?s o disparo de uma transic?a?o, todas as transic?o?es\nque estavam habilitadas na marcac?a?o anterior e que permanecem ha-\nbilitadas na nova marcac?a?o mante?m os valores de seus temporizado-\nres. Apenas quando uma transic?a?o e? desabilitada na nova marcac?a?o ou\nquando esta e? disparada e? que o seu tempo e? perdido.(MACIEL; LINS;\nCUNHA, 1996)\n\n2.1.2 Fusa?o de redes de Petri\n\nConsiderando um elemento de uma rede de Petri como um lugar\nou uma transic?a?o, a fusa?o de elementos de diferentes redes de Petri\npermite, de forma sistema?tica e estruturada, a construc?a?o de redes de\ngrandes dimenso?es a partir de mo?dulos menores. Esta te?cnica permite\na utilizac?a?o de diferentes abordagens para a construc?a?o de sistemas\nrepresentados em redes de Petri. Para a representac?a?o de um sistema\nqualquer em uma rede de Petri, redes menores que representam parte\ndo fluxo de informac?a?o no sistema ou ainda que representam diferentes\nfuncionalidades do sistema podem ser modeladas inicialmente e enta?o\nfusionadas. Isto significa que, a partir de pequenas redes de Petri, as\nquais podem ser facilmente analisadas, pode-se construir uma rede mais\ncomplexa que oferece as caracter??sticas de cada uma das redes iniciais\n(Go?IS, 2000).\n\nA figura 2 apresenta duas redes e a fusa?o dessas redes utilizando\na te?cnica de fusa?o de lugar. Os lugares P sa?o elementos do mesmo tipo\npertencentes a?s redes iniciais R\u2019 e R\u201d e esta?o envolvidos no processo de\nfusa?o. Nota-se que os elementos do mesmo tipo desaparecem na fusa?o,\ndando origem a um novo elemento na rede final R. A fusa?o de transic?a?o\nocorre da mesma maneira, exceto que os elementos envolvidos na fusa?o\n\n\n\n27\n\nFigura 2: Exemplo representando a fusa?o entre duas redes de Petri\nGene?ricas\n\nsa?o transic?o?es e na?o lugares.\n\n2.1.3 Observadores baseados em Redes de Petri\n\nObservadores sa?o normalmente utilizados objetivando a veri-\nficac?a?o da alcanc?abilidade de um sistema e, quando utilizados, devem\nser na?o intrusivos, ou seja, na?o devem alterar o sistema original in-\nserindo novos dados ou influindo no comportamento do sistema sendo\nobservado. Em sistemas modelados, os observadores sa?o, normalmente,\nconstru??dos com a mesma abstrac?a?o utilizada para os sistemas modela-\ndos e sa?o comuns na a?rea de verificac?a?o formal de sistemas (ABID et al.,\n2011), sendo sua func?a?o observar transic?o?es ou estados de um sistema.\n\n2.2 VERIFICAC?A?O FORMAL POR MODEL CHECKING\n\nModel checking refere-se a um conjunto de te?cnicas para a ana?lise\nautoma?tica de sistemas reativos. Pequenos erros no desenvolvimento\nde sistemas cr??ticos que utilizam te?cnicas de simulac?a?o e testes conven-\ncionais podem ser (e te?m sido) encontrados (MERZ, 2001) atrave?s da\nutilizac?a?o de me?todos formais. Como e? relativamente simples de utili-\nzar, a abordagem que envolve verificac?a?o vem sendo adotada como um\nprocedimento padra?o para a garantia da qualidade de sistemas reativos.\n(MERZ, 2001)\n\n\n\n28\n\nUma estrutura de Kripke e? uma variac?a?o de automato na?o-\ndetermin??stico proposto por Saul Kripke, utilizado no model checking\npara representar o comportamento de um sistema. E? um modelo ma-\ntema?tico que captura a ide?ia de uma ma?quina de computac?a?o, sem\nadic?a?o de complexidades desnecessa?rias. E? basicamente um grafo cu-\njos no?s representam os estados alcanc?a?veis do sistema e cujas arestas\nrepresentam as transic?o?es de estado. A func?a?o de marcac?a?o mapeia\ncada no? a um conjunto de propriedades que existem em um estado cor-\nrespondente. Lo?gicas temporais sa?o tradicionalmente interpretados em\ntermos de estruturas de Kripke\n\nAs entradas para um verificador de modelos sa?o modelos (ge-\nralmente finitos), na forma de estrutura de Kripke, do sistema a ser\nanalisado e tambe?m as propriedades a serem verificadas, geralmente\nexpressas como fo?rmulas de lo?gica temporal , que va?o ser verificadas do\nmodelo . O verificador de modelo ou confirma que as propriedades, de\nfato, existem no modelo ou afirma que essas sa?o violadas. Neste u?ltimo\ncaso , ele fornece um contra-exemplo, na forma de uma execuc?a?o de\nsistema que viola a propriedade. O usua?rio deve enta?o decidir se o\ncontra-exemplo e? um condic?a?o do modelo (causada talvez por uma su-\nper simplificac?a?o do modelo fornecido) e, talvez, fornecer um modelo\nmelhor para o verificador, ou se corresponde a um funcionamento do\nsistema real e rever o projeto do sistema para excluir o erro. Na pra?tica\num terceiro resultado poss??vel de verificac?a?o do modelo e? que a ana?lise\nexige recursos superiores aos dispon??veis(memo?ria, por exemplo). Nesse\ncaso , pode ser poss??vel analisar uma representac?a?o mais superficial do\nmodelo do sistema ou aplicar otimizac?o?es que fazem a ana?lise via?vel .\n\nExecuc?o?es bem sucedidas do verificador de modelos so? podem\nestabelecer que certa propriedade e? garantida no modelo abstrato e\nna?o no \u201dmundo real\u201dou sistema de hardware \u201dconcreto\u201dou programa.\nA inserc?a?o de erros durante a construc?a?o do modelo abstrato e? bem\ncomum e procedimentos devem sempre ser adotados (ana?lises de co?digo\npor exemplo) para garantir que a representac?a?o abstrata representa\nfielmente o comportamento do sistema real na medida do necessa?rio\npara a ana?lise das propriedades consideradas. O verificador pode ser\nde alguma ajuda ao estabelecer que o modelo abstrato, pelo menos, na?o\nexclui certas execuc?o?es.\n\n\n\n29\n\n2.3 ABORDAGENS FORMAIS NO DESENVOLVIMENTO OU\nVERIFICAC?A?O DE PROGRAMAS DE CLP\n\nNesta sec?a?o sera?o abordados alguns trabalhos que se baseiam na\nutilizac?a?o de representac?o?es formais para a construc?a?o de um programa\nde de CLP ou sua verificac?a?o. A utilizac?a?o de representac?o?es formais\nconfere ao desenvolvimento ou verificac?a?o de teste de programas de CLP\numa base matema?tica para sua execuc?a?o. Os trabalhos que se utilizam\nde tais representac?o?es te?m como objetivo garantir certas proprieda-\ndes aos programas sendo desenvolvidos ou validados. Cada trabalho\napresentado possui suas pro?prias particularidades e sera?o explicados\nindividualmente. Dentre as abordagens abordadas, sera?o utilizados os\nconceitos apresentados nesse cap??tulo.\n\n2.3.1 Diagno?stico e tratamento de falhas em sistemas cr??ticos\nutilizando me?todos formais\n\nEm (Ju?NIOR, 2011), uma abordagem para a gerac?a?o de algorit-\nmos de controle e? proposta. O princ??pio do trabalho e? a concepc?a?o de\num conjunto de procedimentos sistematizados para desenvolvimento e\nvalidac?a?o de algoritmos de controle, a partir da modelagem de func?o?es\npara diagno?stico e tratamento de falhas atrave?s da ana?lise de docu-\nmentos. A abordagem deste trabalho caracteriza-se pela construc?a?o e\nana?lise de modelos de diagno?stico e tratamento de falhas em sistemas\ncr??ticos e e? dividia em quatro etapas:\n\n\u2022 modelagem.\n\n\u2022 ana?lise.\n\n\u2022 gerac?a?o dos programas de controle\n\n\u2022 testes finais de aceitac?a?o.\n\nA etapa de modelagem e? subdividida em dois esta?gios comple-\nmentares: a modelagem do diagno?stico de falhas e a modelagem do\ntratamento e das falhas. A sistema?tica proposta utiliza como fonte\nde dados de entrada o relato?rio de ana?lise de riscos (HAZOP) e as\ninformac?o?es presentes em um dos documentos de automac?a?o (matriz\ncausa e efeito). A partir dos dados de entrada, no esta?gio da mode-\nlagem do diagno?stico de falhas, sa?o geradas redes Bayesianas para o\ndiagno?stico de falhas e, apo?s sua obtenc?a?o, essas sa?o traduzidas para\n\n\n\n30\n\nredes de Petri. Em outro esta?gio, a modelagem do tratamento e das\nfalhas, baseando-se nas falhas poss??veis para o sistema, sa?o geradas\nfunc?o?es instrumentadas de seguranc?a, as quais modelam func?o?es res-\nponsa?veis por lidar com essas poss??veis falhas(tratamento das falhas).\nEssas func?o?es sa?o modeladas utilizando-se redes de Petri. Neste mo-\nmento, existem dois grupos de modelos de redes de Petri. O responsa?vel\npelo diagno?stico e o responsa?vel pelo tratamento. De acordo com in-\nformac?o?es contidas nos documentos, as redes de Petri dos dois grupos\nsa?o relacionadas e integradas.\n\nA etapa de ana?lise investiga a interac?a?o entre os modelos de di-\nagno?stico e de tratamento de falhas cr??ticas uma vez que integrados.\nPara essa atividade, ferramentas de simulac?a?o de redes de Petri sa?o\nutilizadas. Na etapa de gerac?a?o, tem-se a gerac?a?o dos programas de\ncontrole baseados nos modelos de diagno?stico e de tratamento integra-\ndos na etapa pre?via. Estes programas sa?o gerados de acordo com a\nnorma IEC 61131-3. Finalmente, na etapa de aceitac?a?o, os testes fi-\nnais de validac?a?o sa?o executados a fim de validar se as func?o?es criadas\natendem a?s especificac?o?es te?cnicas de acordo com a norma IEC 61511.\nInformac?o?es mais detalhadas sobre este trabalho podem ser encontra-\ndas em (Ju?NIOR, 2011) A figura 3 apresenta a sistema?tica proposta.\n\nFigura 3: Sistema?tica apresentada em (Ju?NIOR, 2011)\n\n\n\n31\n\n2.3.2 Uma abordagem baseada em engenharia dirigida a mo-\ndelos para a verificac?a?o de programas de CLP\n\nEste trabalho(FARINES; QUEIROZ; CARPES, 2011) se insere no\ncontexto do projeto TOPCASED (VERNADAT et al., 2006), que visa\no desenvolvimento de um ambiente para sistemas embarcados , com\nbase em engenharia dirigida a modelos (MDE) . A plataforma apre-\nsentada, a TOPCASED, integra diferentes ferramentas de verificac?a?o\ncomo por exemplo TINA (BERTHOMIEU, 2004) e permite a utilizac?a?o\nde va?rias linguagens de modelagem de usua?rio. O FIACRE, a lin-\nguagem (BERTHOMIEU et al., 2008) concebida no projeto TOPCASED\nserve como um formato intermedia?rio entre as linguagens de usua?rio e\nde verificac?a?o de modelos formais.\n\nPrimeiramente, um metamodelo para um diagrama Ladder e?\nproposto. Regras de transformac?a?o entre elementos ba?sicos e blocos de\nfunc?a?o Ladder para FIACRE foram definidos. O resultado foi enta?o\numa sema?ntica Fiacre para programas escritos em ladder . O mo-\ndelo ladder e? traduzido para FIACRE a partir dessas regras, de tal\nforma que cada programa ladder concebido em conformidade com o\nmetamodelo ladder pode ser automaticamente traduzido para uma re-\npresentac?a?o FIACRE. A partir da linguagem FIACRE, a ferramenta\nde compilac?a?o existente FRAC pode gerar um modelo de Transic?a?o\nTempora?rio(TTS) usado pelo conjunto de ferramentas TINA para ve-\nrificac?a?o. Em seguida, as propriedades referentes ao sistema , expressas\nem LTL , podem ser verificadas no modelo TTS obtido usando o model\nchecking dispon??vel no TINA. MDE garante que a verificac?a?o e? rea-\nlizada em um modelo que e? constru??do automaticamente a partir do\nprograma ladder e em conformidade com regras de transformac?a?o de-\nfinidas, eliminando, assim, poss??veis erros inseridos pela transformac?a?o\nmanual dos modelos.\n\nEste trabalho encaixa-se no ambiente TOPCASED e utiliza uma\nmetodologia similar e algumas de suas ferramentas para construir um\nconjunto de ferramentas de verificac?a?o para os programas de PLC es-\ncritos com linguagens definidas na IEC 61131-3. Devido a? diversidade\nde linguagens existentes (como UML, SysML ou AADL ) e de fer-\nramentas de verificac?a?o dispon??veis com seus formalismos pro?prios (\ncomo redes de Petri , auto?matos ou a?lgebra de processos), o ambiente\nTOPCASED define o idioma FIACRE como um passo intermedia?rio\nna transformac?a?o do modelo. O conjunto de ferramentas de verificac?a?o\ntem, portanto, como base, dois n??veis de transformac?a?o: um n??vel de\numa linguagem para o idioma intermedia?rio FIACRE e, em seguida,\n\n\n\n32\n\num outro de FIACRE a?s linguagens de verificac?a?o formal. Dentre os\nbenef??cios da utilizac?a?o do FIACRE apresentados pelo trabalho, tem-\nse: a reduc?a?o da diferenc?a sema?ntica entre linguagens de alto n??vel e\nformalismos de baixo n??vel para ferramentas de verificac?a?o e a definic?a?o\nde uma sema?ntica exclusiva para diferentes conjuntos de ferramentas de\nverificac?a?o, o que torna mais fa?cil fa?cil a introduc?a?o de novas linguagens\nde alto n??vel e novas ferramentas de verificac?a?o. No caso do trabalho\nem questa?o, o FIACRE facilita o uso do conjunto de ferramentas de\nverificac?a?o TINA para a linguagem Ladder para CLP, sem necessidade\nde traduc?a?o direta de representac?o?es de alto formalismo como Redes\nde Petri em linguagens de baixo n??vel como Ladder.\n\nA ferramenta desenvolvida nesse projeto e? exemplificada na fi-\ngura 4 e consiste do seguinte: um editor de PLC permite a criac?a?o\nde programas Ladder e os salva em um arquivo XML. Um tradutor -\nconstru??do usando abordagem MDE e escrito em ATL (JOUAULT; KUR-\nTEV, 2006) transforma o XML resultante em FIACRE. Ao co?digo FIA-\nCRE resultante, se adiciona o modelo da planta tambe?m em FIACRE\ne obte?m-se assim o modelo FIACRE completo. Enfim, esse modelo\ncompleto e? compilado para TTS utilizando o compilador FRAC (parte\ndo TOPCASED) e pode, atrave?s do conjunto de ferramentas TINA,\nser verificado.\n\n2.3.3 Um conjunto de ferramentas para verificac?a?o de modelo\nde programa de CLP\n\nA abordagem apresentada em (PAKONEN et al., 2013) consiste\nna especificac?a?o manual de um co?digo verificador para cada bloco de\nfunc?a?o elementar utilizado em um determinado programa. A justifi-\ncativa apresentada para a definic?a?o de cada bloco manualmente foi a\nseguinte:\n\n\u2022 Em vez de usar linguagens padra?o, conforme especificado pela\nIEC 61131-3, muitos dos principais fabricantes de CLP usam blo-\ncos de func?o?es espec??ficas a cada fornecedor.\n\n\u2022 Muitas vezes, os fornecedores na?o esta?o dispostos a divulgar a\nalgoritmos de implementac?a?o reais para o blocos de func?o?es ele-\nmentares (caixa preta) por os considerarem uma propriedade in-\ntelectual da companhia. Apenas a descric?a?o funcional e? fornecida\naos clientes.\n\n\u2022 Mesmo que a lo?gica interna dos blocos fossem reveladas (caixa\n\n\n\n33\n\nFigura 4: Ferramenta desenvolvida em (FARINES; QUEIROZ; CARPES,\n2011)\n\nbranca), e? prova?vel que a implementac?a?o desses algoritmos se\nde? em linguagens como C ou Java, o que na?o costuma permitir\nrepresentac?a?o direta em algumas ferramentas de verificac?a?o.\n\nO ponto de partida na metodologia proposta neste trabalho e? a\ndescric?a?o funcional dos blocos de func?a?o elementar. O co?digo para mo-\ndel checking de cada bloco e? enta?o escrito e a verificac?a?o do modelo de\ncada bloco pode ser utilizada para assegurar que o co?digo esta? correto.\nAs propriedades a serem verificadas sa?o obtidas a partir da descric?a?o\nfuncional de cada bloco.\n\nO verificador utilizado neste trabalho foi o NuSMV, um veri-\nficador de modelo simbo?lico baseado em BDD que permite represen-\ntar ambos os sistemas de estados finitos s??ncronos e ass??ncronos, com\ndescric?a?o de tempo discreto e as propriedades podem ser especifica-\ndos usando LTL ou CTL (BAIER; KATOEN et al., 2008). A ferramenta\npermite apenas expresso?es muito ba?sicas e tipos simples de varia?veis\n(boleana, inteira, enumerac?a?o, matriz), o que significa que os blocos\nde func?o?es de algoritmos complexos (por exemplo, PID) na?o podem ser\nmodelados com precisa?o razoa?vel. Lo?gicas complexas de controle devem\nser, portanto, abstra??das, ou completamente omitidas da verificac?a?o.\n\n\n\n34\n\nFoi desenvolvida uma ferramenta de verificac?a?o de modelos para\nSimantics (KARHELA; VILLBERG; NIEMSTO?, 2012) (uma ferramenta que\noferece um ambiente de integrac?a?o entre ferramentas de simulac?a?o e de\nengenharia). Atrave?s da ferramenta desenvolvida, po?de-se construir ou\nreproduzir um programa em FBD e transformar esse diagrama para um\narquivo de entrada para o NuSMV. Atrave?s de uma entrada de texto,\ndeve-se introduzir o co?digo do bloco de func?a?o elementar ale?m da in-\nterface para o mesmo(entradas e sa??das). Atrave?s da interface gra?fica\nda ferramenta, constro?i-se uma representac?a?o FBD para o programa a\nser verificado e, com esse programa FBD, gera-se um arquivo de en-\ntrada para NuSMV contendo todos os elementos necessa?rios do modelo\n- co?digo para os blocos elementares utilizadas , bem como as ligac?o?es\nentre blocos. As propriedades a serem verificadas sa?o introduzidas no\nNuSMV atrave?s de texto.\n\n2.4 VALIDAC?A?O DE PROGRAMAS ATRAVE?S DE TESTES\n\nA atividade de testar consiste em uma ana?lise dina?mica do pro-\ngrama produzido e e? uma atividade relevante na identificac?a?o e eli-\nminac?a?o de poss??veis erros contidos no programa. A atividade de rea-\nlizar testes em programas prontos e? de grande utilizac?a?o em sistemas\nonde a operac?a?o na?o e? cr??tica, uma vez que seu mau funcionamento na?o\nresulta em grandes perdas ou desastres. Por ser a abordagem mais na-\ntural para se checar o correto funcionamento de um programa, e? muito\nutilizada na indu?stria como uma das etapas finais antes da entrega de\num programa de automac?a?o. Mesmo algumas plantas cr??ticas te?m seu\nprograma testado baseando-se em especificac?o?es iniciais e conhecimento\ninterno da equipe de engenharia responsa?vel pelo projeto.\n\nA realizac?a?o de testes de programa envolve basicamente 4 eta-\npas (BEIZER, 1990) (MYERS, 1979) (MALDONADO, 1991) (PRESSMAN,\n1997):\n\n\u2022 planejamento de testes\n\n\u2022 projeto de casos de teste\n\n\u2022 execuc?a?o\n\n\u2022 avaliac?a?o dos resultados dos testes\n\nCada uma dessas quatro etapas, que devem ser realizadas du-\nrante o desenvolvimento do programa, podem ser divididas em tre?s\n\n\n\n35\n\nfases de testes: testes de unidade(teste de cada mo?dulo do programa),\ntestes de integrac?a?o(testa o interfaceamento de cada mo?dulo) e teste\nde sistema(testa se o sistema atende aos requisitos pre?-estabelecidos)\n(BEIZER, 1990).\n\nNa realizac?a?o de testes, e? importante a definic?a?o de um conjunto\nde casos de teste, quando for impratica?vel a realizac?a?o de todos os tes-\ntes poss??veis. Como o teste tem por principal finalidade a identificac?a?o\nde erros(MYERS, 1979), um bom conjunto de casos de teste e? o con-\njunto que consegue fazer o programa em teste falhar. Para a definic?a?o\ndo conjunto de casos de teste, existem alguns crite?rios de teste. Os\nprincipais sa?o:\n\n\u2022 funcional: o requisitos do teste prove?m da especificac?a?o do pro-\ngrama\n\n\u2022 estrutural: os requisitos sa?o derivados a partir de uma imple-\nmentac?a?o espec??fica\n\n\u2022 baseado em erros: os requisitos sa?o estabelecidos a partir de er-\nros t??picos realizados durante o processo de desenvolvimento do\nprograma\n\nOs testes podem ainda ser divididos em tre?s tipos principais:\n\n\u2022 Testes de caixa-preta ou teste baseado em especificac?a?o tem por\nobjetivo inferir se o programa atinge os requisitos funcionais e na?o\nfuncionais . Dentre os testes de caixa-preta, pode-se citar parti-\ncionamento em classe de equivale?ncia (BEIZER, 1990), ana?lise do\nvalor limite, grafo de causa-efeito (BEIZER, 1990) e teste baseado\nem estado (MCGREGOR, 1994) (HOFFMAN; STROOPER, 1993)\n\n\u2022 Teste de caixa-branca ou teste baseado em programa trabalha\ncom a inspec?a?o do co?digo fonte e a selec?a?o de casos que executem\ndeterminada parte do co?digo(PERRY; KAISER, 1990)\n\n\u2022 Teste de caixa cinza implica ter conhecimento de estruturas de\ndados e algoritmos internos para fins de concepc?a?o de testes, en-\nquanto executa desses testes no n??vel de caixa-preta. O testa-\ndor na?o e? obrigado a ter pleno acesso ao co?digo-fonte do soft-\nware(PATTON, 2001).\n\nAo realizar testes de programa, e? importante destacar alguns\npontos:\n\n\u2022 A realizac?a?o de testes pode desprender muito tempo de projeto\n\n\n\n36\n\n\u2022 Testes nunca podem ser considerados exaustivos\n\n\u2022 E? necessa?rio a correta interpretac?a?o de resultados para se garantir\nque um erro na?o seja considerado como comportamento correto\nde programa\n\n\u2022 O conjunto de testes realizados pode ser parcial e dependente\ndaquele que escolhe a rotina de testes\n\nAo se realizar testes, deve-se levar em considerac?a?o suas limitac?o?es\npara evitar a inefica?cia desses. Quanto ao tempo gasto para a execuc?a?o\nde testes, existem algumas abordagens para se melhorar sua eficie?ncia.\nA seguir sera?o apresentadas algumas abordagens utilizadas durante a\nfase de testes que podem reduzir o tempo desta fase de projeto ou ainda\nmelhorar sua efica?cia na busca por falhas.\n\nParticionamento de equivale?ncia (tambe?m chamado de classe de\nequivale?ncia ou ECP (BURNSTEIN, 2003)) e? uma te?cnica de teste de pro-\ngrama que divide os dados de entrada de um programa em partic?o?es de\ndados equivalentes a partir do qual os casos de teste podem ser deri-\nvados. Em princ??pio, os casos de teste sa?o projetados para cobrir cada\npartic?a?o pelo menos uma vez. Esta te?cnica tenta definir casos de teste\npara descobrir classes de erros, reduzindo assim o nu?mero total de casos\nde teste que devem ser desenvolvidas. Uma vantagem desta abordagem\ne? a reduc?a?o no tempo necessa?rio para o ensaio de um programa, devido\nao menor nu?mero de casos de teste.\n\nAna?lise do valor limite e? uma te?cnica de teste de programa em\nque os testes sa?o projetados para incluir representantes de valores de\nlimite(MALDONADO et al., 2004). Dado que um conjunto de vetores de\nteste para testar o sistema, uma topologia pode ser definida nesse con-\njunto. Esses elementos que pertencem a? mesma classe de equivale?ncia,\ntal como definido pela teoria particionamento de equivale?ncia constro?i\na base (topologia). Dado que os conjuntos de base sa?o vizinhos, existe\numa fronteira entre eles. Os elementos de teste em ambos os lados da\nfronteira sa?o chamados valores limite. Na pra?tica, isso exige que os ele-\nmentos de teste possam ser ordenados, e que os para?metros individuais\nseguem algum tipo de ordem (ou de ordem parcial ou total).\n\nTestes all-pairs ou teste pairwise e? um me?todo combinato?rio\nde teste de programa que, para cada par de para?metros de entrada\npara um sistema, testa todas as poss??veis combinac?o?es distintas de\ntais para?metros. Usando vetores de teste escolhidos dentre todos os\npara?metros, isso pode ser feito muito mais rapidamente do que uma\nprocura exaustiva de todas as combinac?o?es de todos os para?metros, por\numa \u201dparalelizac?a?o\u201ddos testes de pares de para?metros. O racioc??nio por\n\n\n\n37\n\ntra?s dessa metodologia de testes e? a seguinte: os erros mais simples em\num programa sa?o geralmente acionados por um u?nico para?metro de\nentrada. A pro?xima categoria mais simples de erros e? constitu??do por\naqueles dependentes de interac?o?es entre os pares de para?metros, que\npodem ser capturados com teste all-pairs (BLACK, 2007). Problemas\nenvolvendo interac?o?es entre tre?s ou mais para?metros sa?o cada vez menos\ncomuns(KUHN; WALLACE; GALLO, 2004),e, ao mesmo enquanto cada\nvez mais caro para se encontrar atrave?s de testes exaustivos, que tem\ncomo limite ma?ximo, o teste exaustivo de todas as entradas poss??veis\n(KUHN; KACKER; LEI, 2010).\n\nA seguir, sera? apresentado um trabalho desenvolvido para a re-\nalizac?a?o de testes em programas de sistemas instrumentados de segu-\nranc?a.\n\n2.4.1 Testes em sistemas instrumentados de seguranc?a atrave?s\nde equivale?ncia de classes\n\nA metodologia definida em (OLIVEIRA LEANDRO DIAS DA SILVA,\n2012) consiste em quatro etapas ilustradas na figura 5 e pode ser ex-\nplicada da seguinte maneira:\n\n\u2022 A especificac?a?o do sistema e? lida e traduzida em um modelo de\nauto?mato temporizado\n\n\u2022 O modelo e? usado para gerar automaticamente um conjunto de\ncasos de teste\n\n\u2022 Para cada caso de teste, os valores de entrada e de teste sa?o\nenviados ao CLP atrave?s de OPC\n\n\u2022 A rotina no CLP e? executada gerando um conjunto de valores de\nsa??da\n\n\u2022 A sa??da do CLP e? enta?o comparado com o resultado do modelo\nobtido e um veredito e? obtido\n\nOs casos de teste sa?o gerados tendo em conta o ciclo de varredura\ndo PLC. Cada caso de teste e? gerado para ser executado em um ciclo\nde varredura. Um caso de teste e? uma tupla C = I, O, T :\n\n\u2022 I e? um conjunto de valores booleanos a?s entradas correspondentes\nvaria?vel da especificac?a?o do sistema;\n\n\n\n38\n\n\u2022 O e? um conjunto de valores booleanos correspondentes a?s varia?veis\nde sa??da da especificac?a?o que sa?o obtidos apo?s o processamento\nde I;\n\n\u2022 T e? o trac?o, ou seja, as seque?ncias de eventos de sincronizac?a?o\nexecutados para obter O de I.\n\nFigura 5: Metodologia de testes utilizando equivale?ncia de classes\n\nAo gerar os casos de teste , algumas das poss??veis combinac?o?es de\nvalores das varia?veis de entrada sa?o selecionadas para serem utilizadas.\nDois tipos de falhas foram consideradas ao selecionar os valores de\nentrada: falhas que afetam uma restric?a?o de tempo e as falhas que\nafetam a sa??da do sistema. A selec?a?o foi feita atrave?s de classes de\nequivale?ncia,e foram removidas combinac?o?es que geram casos de teste\nredundantes. Dois casos de teste sa?o redundantes se forem consideradas\nsemelhantes e na?o agregam valor para o conjunto de teste . Eles na?o\ndetectam novos erros e eles na?o fornecem uma melhor cobertura de\nteste do sistema em ana?lise.A remoc?a?o de testes redundantes teve como\nobjetivo a diminuic?a?o do tempo de realizac?a?o de testes.\n\nA selec?a?o de combinac?o?es de entrada depende dos elementos da\nespecificac?a?o do sistema . Para cada varia?vel de sa??da, duas entradas\nsa?o selecionadas, uma que a ativa e outra que a desativa . Este tipo\nde teste tem como objetivo detectar falhas que afetam a sa??da do sis-\ntema. Se o sistema tiver elementos temporizados, todas as transic?o?es de\ncada temporizador sa?o executadas pelo menos uma vez, e as entradas\nadequadas devem ser selecionadas. A verificac?a?o dos temporizadores e?\nfeita com base na entrada de cada temporizador. Portanto, para cada\ntemporizador, uma combinac?a?o de valores de entrada deve levar a en-\ntrada do temporizador para verdadeiro e outra para falso. Este tipo de\nteste objetiva a detecc?a?o de falhas que afetam restric?o?es temporais.\n\nEste trabalho propo?e, enta?o, a utilizac?a?o de um nu?mero m??nimo\nde entradas do CLP, o suficiente para ativar todas as sa??das do pro-\ngrama de CLP e tambe?m todos os temporizadores do programa. Os\n\n\n\n39\n\ncasos de teste sa?o selecionados a partir dos modelos de auto?matos. Essa\nabordagem pode trazer problemas uma vez que considerar uma u?nica\nentrada de um grupo de entradas na?o garante o correto funcionamento\nde todas as entradas. Ainda, assim como explicado no trabalho, os tes-\ntes devem poder ser realizados em um ciclo de CLP e, desta maneira,\nexclui qualquer teste que inclua uma poss??vel seque?ncia de entradas as-\nsim como uma entrada que resulta em um sequenciamento nas sa??das.\n\n2.5 COMENTA?RIOS FINAIS\n\nNeste cap??tulo foi realizada uma revisa?o bibliogra?fica sobre redes\nde Petri, verificac?a?o formal atrave?s de model-checking e tambe?m sobre\na realizac?a?o de testes em programa. Foram apresentados trabalhos que\nutilizam abordagens formais para o desenvolvimento e validac?a?o de\nprogramas de automac?a?o industrial. No pro?ximo cap??tulo, sera? apre-\nsentada a abordagem utilizada atualmente pela Petrobras para o de-\nsenvolvimento e validac?a?o dos programas de automac?a?o desenvolvidos\nem seus projetos.\n\n\n\n40\n\n\n\n41\n\n3 METODOLOGIA DE DESENVOLVIMENTO DO\nSOFTWARE DE AUTOMAC?A?O NA INDU?STRIA DE\nPETRO?LEO E GA?S\n\nA metodologia de desenvolvimento de projetos de automac?a?o\natualmente utilizada em empresas de petro?leo e ga?s, como a Petrobras\nconsiste em uma seque?ncia de etapas que partem de definic?o?es ba?sicas\nda planta a ser automatizada e culmina com o desenvolvimento do pro-\ngrama utilizado para automac?a?o de CLP. Durante o projeto, uma gama\nde documentos, cada qual contendo informac?o?es relevantes a uma ou\nva?rias etapas do projeto, e? criada. Cada etapa dessa metodologia possui\nentradas e sa??das na forma de documentos, sendo que os documentos\nna entrada de uma determinada etapa sa?o aqueles que sa?o necessa?rios\npara a gerac?a?o dos documentos de sa??da. Neste cap??tulo, a atual me-\ntodologia de desenvolvimento e os documentos sera?o explicados. Para\na exemplificac?a?o da metodologia e dos documentos utilizados na me-\ntodologia atualmente encontrada, uma planta exemplo fornecida pela\nPetrobras sera utilizada. Trata-se de uma planta de um forno industrial\ne seu funcionamento e? melhor explicado a seguir.\n\n3.1 DESCRIC?A?O DE UM FORNO INDUSTRIAL PRESENTE EM\nUMA UNIDADE DE HIDROTATAMENTO DE DIESEL\n\nPara exemplificac?a?o da metodologia atualmente utilizada por\nempresas como a Petrobras, sera? utilizada uma planta de um forno\nindustrial. Esta planta sera? utilizada tambe?m, em cap??tulos posterio-\nres para a validac?a?o da metodologia proposta neste documento. Esta\nsec?a?o na?o possui como objetivo explicar detalhadamente cada aspecto\ndo forno, mas sim, esclarecer o funcionamento dessa planta para que\npossa ser utilizada como exemplo. Maiores detalhes podem ser encon-\ntrados em (SILVA, 2009).\n\nO princ??pio de um forno e? a troca de calor e isso e? obtido pela\nqueima de um combust??vel, o que libera gases quentes e, esses, em\ncontato com uma serpentina em seu interior, fornecem calor a um flu??do.\nUm forno possui tre?s partes principais:\n\n\u2022 ca?mara de radiac?a?o: regia?o onde esta?o os queimadores (responsa?veis\npela queima do combust??vel) e uma parte da serpentina para troca\nde calor\n\n\u2022 zona de convecc?a?o: regia?o onde se encontra a outra parte da\n\n\n\n42\n\nserpentina\n\n\u2022 chamine?: trecho por onde os gases da combusta?o sa?o lanc?ados a?\natmosfera\n\nFigura 6: Forno em uma planta industrial. Fonte: (SILVA, 2009)\n\nA figura 6 ilustra um forno industrial. Dado o funcionamento\nmais ba?sico do forno, e? necessa?rio entender a composic?a?o sua ba?sica,\nseus instrumentos e sua interac?a?o no processo de gerac?a?o e troca de\ncalor. Alguns dos instrumentos pertinentes a um forno sa?o:\n\n\u2022 queimadores: sa?o os instrumentos responsa?veis pela liberac?a?o de\ncalor necessa?rio atrave?s da queima de combust??veis\n\n\n\n43\n\n\u2022 piloto: responsa?veis pela chama piloto de cada queimador. A\nfigura 7 ilustra o conjunto queimador e piloto\n\n\u2022 vaso de knock-out e? um tanque localizados a montante dos quei-\nmadores responsa?veis pela retirada de umidade presente no ga?s\npara a sua melhor queima\n\n\u2022 va?lvulas de bloqueio: duas va?lvulas anteriores ao queimador e\nposteriores ao vaso de knock-out que possuem o objetivo de na?o\npermitir o vazamento de gases\n\n\u2022 va?lvula de ventilac?a?o: presente entra as va?lvulas de bloqueio e\nresponsa?vel por eliminar qualquer pressa?o que possa existir antes\nda segunda va?lvula de bloqueio causada por qualquer vazamento\nna primeira va?lvula de bloqueio.\n\n\u2022 vapor de abafamento: vapor utilizado na purga do sistema para\nexpulsa?o de gases indesejados que poderiam causar exploso?es\n\n\u2022 damper: registro instalado na chamine? para controle de vaza?o de\ngases ou tiragem dos gases de combusta?o\n\nFigura 7: Esquema de um queimador e seu piloto.Fonte: (SILVA, 2009)\n\nOs componentes ba?sicos para o entendimento foram descritos,\nale?m disso, o forno possui um sistema para reaproveitamento de ga?s\nresidual. Por esse sistema, ga?s de purga da unidade de gerac?a?o de\nhidroge?nio sa?o reaproveitados como ga?s combust??vel no forno. Uma\nunidade de gerac?a?o de hidroge?nio recebe uma mistura de ga?s que pos-\nsui H2, CO2 e CH4 e separa o H2 dos demais gases e os envia para a\nunidade de hidrotratamento. A figura 8 ilustra os equipamentos des-\ncritos anteriormente e sua interac?a?o juntamente com uma unidade de\nhidrotratamento.\n\n\n\n44\n\nFigura 8: Esquema de um forno industrial com uma unidade de hidro-\ntratamento\n\n3.2 METODOLOGIA DE DESENVOLVIMENTO DE PROJETO DA\nINDU?STRIA DE PETRO?LEO E GA?S\n\nA metodologia implementada atualmente para o desenvolvimento\nde projeto da indu?stria de petro?leo e ga?s inclui a criac?a?o de uma se?rie\nde documentos numa determinada ordem e cada documento prove? in-\nformac?o?es importantes para o desenvolvimento do projeto. Para melhor\nexplicar esta metodologia, primeiramente, sera?o enumerados os tipos de\ndocumentos presentes em um projeto e as informac?o?es contidas em cada\num, e, em seguida, sera? apresentada a metodologia de desenvolvimento\nde projeto, ressaltando os documentos diretamente relacionados com o\nprograma de software desenvolvido para o CLP.\n\nDe acordo com normas internas a? Petrobras (COMISSa?O DE NOR-\nMAS Te?CNICAS, 2002), alguns documentos sa?o considerados essenciais\npara qualquer projeto. Os documentos que todo projeto deve possuir\nsa?o:\n\n\u2022 fluxograma de processo: o fluxograma de processo deve conter a\nrepresentac?a?o simplificada das malhas de controle, identificando\na varia?vel, func?a?o, localizac?a?o e conter, ainda, as va?lvulas de con-\n\n\n\n45\n\ntrole, seguranc?a e al??vio. A figura 9 exemplifica um fluxograma\nde uma vaso de knock-out .\n\nFigura 9: Exemplo de uma parte de um fluxograma de processo refe-\nrente a um vaso de knock-out\n\n\u2022 folhas de dados de processo: devem conter informac?o?es ba?sicas\nde processo que permitam a correta selec?a?o e dimensionamento\ndos instrumentos.\n\n\u2022 matriz causa e efeito: mostra o inter-relacionamento entre os\neventos anormais poss??veis de ocorrer durante a operac?a?o nor-\nmal da planta ou de um equipamento em particular e as ac?o?es\nque devem ser tomadas pelo sistema de seguranc?a, como tambe?m\nmanobras operacionais espec??ficas. A figura 10 apresenta algumas\nrelac?o?es referentes a? planta ja? apresentada.\n\n\u2022 lista de instrumentos preliminar: e? um guia de acesso aos do-\ncumentos de instrumentac?a?o do projeto ba?sico. Deve conter to-\ndos os instrumentos da unidade, localizando-os por fluxogramas e\ndando informac?o?es ba?sicas relativas aos instrumentos como: sua\nsituac?a?o f??sica (campo, painel, func?a?o em sistema digital, etc.).\nO documento que conte?m os dados para especifica?-lo e seu tipo\nba?sico (placa, venturi, termopar, etc.)\n\n\u2022 fluxograma de engenharia preliminar: Quanto a? instrumentac?a?o,\no Fluxograma de Engenharia deve conter as malhas de controle\n\n\n\n46\n\nFigura 10: Exemplo de relac?a?o contida na matriz causa e efeito para a\nplanta apresentada\n\nexplicitando as func?o?es dos instrumentos, sua identificac?a?o preli-\nminar usada como refere?ncia no projeto ba?sico e a localizac?a?o de\ncada instrumento. Deve conter tambe?m, notas explicativas que\nexplicitem recomendac?o?es e exige?ncias do projeto ba?sico quanto\na? instalac?a?o, a? locac?a?o detalhada ou outros requisitos ligados a?\ninstrumentac?a?o.\n\nAlguns processos, por serem processos cr??ticos necessitam de al-\nguns documentos extras. Eles sa?o:\n\n\u2022 especificac?a?o para projeto de detalhamento: deve ser emitida na\nfase inicial do projeto e apresentar os fundamentos ba?sicos de\n\n\n\n47\n\ninstrumentac?a?o que devem orientar a execuc?a?o das especificac?o?es\ne dos demais documentos do projeto de detalhamento.\n\n\u2022 memorial descritivo: deve conter informac?o?es ba?sicas que per-\nmitam a completa especificac?a?o de equipamentos e instrumentos\npara os diversos sistemas de instrumentac?a?o ale?m de sequencia-\nmentos presentes na planta. A figura 11 apresenta um exemplo\nde um sequenciamento, representado por um fluxograma, contido\nno memorial descritivo da planta utilizada como exemplo.\n\nFigura 11: Exemplo de sequenciamento encontrado em memorial des-\ncritivo\n\n\u2022 diagrama lo?gico: Deve ser baseado nos memoriais descritivos para\nos sistemas de protec?a?o, intertravamento e sinalizac?a?o-alarme e\ndeve, ainda, ser construindo utilizando a?lgebra de Boole. Este\ndocumento tem por finalidade representar toda a lo?gica de inter-\ntravamento do projeto e pode ser pensado como uma pre?via do\nprograma final do CLP. A figura 12 apresenta um trecho um um\ndiagrama lo?gico.\n\n\u2022 desenhos de instalac?a?o para itens referentes a tecnologia pro?pria\nindispensa?vel ao funcionamento do processo: neste documento\ndevem ser somente emitidos aqueles desenhos, os quais referem-\nse a instalac?a?o de instrumentos especiais, com tecnologia pro?pria,\ne que necessitam de informac?o?es destes documentos para o seu\ncorreto funcionamento.\n\n\n\n48\n\n\u2022 arranjo preliminar do painel de controle: Deve mostrar a dis-\ntribuic?a?o dos instrumentos, alarmes, chaves, la?mpadas, espac?os\nreservados e demais dispositivos instalados na parte frontal do\npainel de controle com suas respectivas identificac?o?es.\n\nFigura 12: Exemplo de diagrama lo?gico\n\n\u2022 manual de operac?a?o.\n\n\u2022 arquitetura de instrumentac?a?o.\n\n\u2022 lista de varia?veis (entradas e sa??das);\n\n\u2022 folha de dados de instrumentac?a?o para instrumentos especiais:\nquando o projeto envolver instrumentos especiais como sistemas\ntermome?tricos especiais, sistemas de n??vel de uso pouco comum\n(como sistema radioativos) ou instrumentos cuja especificac?a?o\ndeve ser espec??fica por exige?ncias de processo, estes instrumen-\ntos devem ter seus dados definidos no Projeto Ba?sico. As folhas\nde dados para este caso devem conter as informac?o?es necessa?rias\nao desenvolvimento do Projeto Executivo e a? compra de instru-\nmento.\n\n\u2022 especificac?a?o te?cnica para sistemas especiais: Quando o projeto\nenvolve sistemas pouco comuns ou que incorporem exige?ncias es-\ncritas do processo, estes devem ter sua especificac?a?o preliminar\nelaborada no projeto Ba?sico. Tal especificac?a?o deve conter as\nexige?ncias operacionais e construtivas fixadas pelo processo e to-\ndas as informac?o?es que se vincularem a? exige?ncia tecnolo?gica do\nprocesso\n\n\u2022 diagramas de controle avanc?ado.\n\n\u2022 descritivos das malhas de controle avanc?ado: Deve conter ex-\nplicac?o?es sobre o objetivo e forma de funcionamento das ma-\nlhas de controle avanc?ado, bem como explicitar as equac?o?es e\n\n\n\n49\n\npara?metros a serem ajustados nas func?o?es envolvidas nestas ma-\nlhas.\n\n\u2022 lista de varia?veis calculadas.\n\n3.3 METODOLOGIA PARA DESENVOLVIMENTO DO SOFTWARE\nDE CLP\n\nDentre os documentos descritos anteriormente, alguns esta?o mais\nligados a? criac?a?o do programa de intertravamento desenvolvido para o\nprograma de CLP que outros. Dentro dos documentos dispon??veis,\npode-se citar:\n\n\u2022 Fluxograma de processo\n\n\u2022 Matriz Causa e Efeito\n\n\u2022 Memorial descritivo\n\n\u2022 Diagrama lo?gico\n\nAinda dentro dos documentos relacionados com o programa de\nCLP, existe uma documento criado exclusivamente para testar o pro-\ngrama de intertravamento e garantir que esse apresenta um comporta-\nmento esperado. Tal documento e? o \u201dTeste de aceitac?a?o de fa?brica\u201d e\napresenta em forma textual como os testes devem ser realizados para\nque o programa de intertravamento seja aprovado.\n\nE? importante tambe?m ressaltar na?o somente quais os documen-\ntos utilizados num processo de automac?a?o ou quais sa?o utilizados na\ngerac?a?o de co?digo para o CLP, mas tambe?m como se da? sua interac?a?o\ndurante o processo de automac?a?o. Na metodologia de desenvolvimento\nda Petrobras, dentre os documentos citados na sec?a?o anterior, o pri-\nmeiro documento a ser desenvolvido e? o fluxograma de processo e, a\npartir das informac?o?es deste documento, a Matriz Causa e Efeito e o\nmemorial descritivo sa?o criados.\n\nA gerac?a?o das relac?o?es pertencentes a? matriz causa e efeito e? ba-\nseada em informac?o?es do fluxograma de processos (relac?a?o entre equi-\npamentos destinados a? seguranc?a e sinais de sensores que devem ativar\nou desativar tais equipamentos) em conjunto com os especialistas do\nprojeto. Para o memorial descritivo, sa?o utilizadas informac?o?es do flu-\nxograma de processo e tambe?m conhecimento de especialistas do pro-\njeto para definic?a?o de especificac?o?es de equipamentos e sequenciamentos\npara a planta.\n\n\n\n50\n\nA informac?a?o conjunta dos dois u?ltimos documentos (matriz\ncausa e efeito e memorial descritivo) permite a criac?a?o do diagrama\nlo?gico e do teste de aceitac?a?o de fa?brica. O diagrama lo?gico gera o pro-\ngrama de CLP e o TAF e? utilizado durante a fase de testes do programa\ndo CLP. O diagrama lo?gico conte?m as lo?gicas do futuro programa de\nCLP e, as informac?o?es que definem essas lo?gicas sa?o obtidas das des-\ncric?o?es encontradas no memorial descritivo assim como nas relac?o?es\nexistentes na matriz causa e efeito. A figura 13 apresenta esquemati-\ncamente a gerac?a?o dos documentos durante o processo de automac?a?o.\nEm geral, a programac?a?o propriamente dita do CLP e? feita por uma\nempresa terceirizada e, apo?s a entrega dos equipamentos utilizados na\nprogramac?a?o, a Petrobras realiza o teste de aceitac?a?o de fa?brica para\ndefinir se o programa gravado no CLP e? va?lido ou na?o. Caso seja\nencontrado algum erro, o CLP e? retornado para reprogramac?a?o.\n\nFigura 13: Metodologia de desenvolvimento de projetos na Petrobras\n\n3.4 LIMITAC?O?ES DA METODOLOGIA ATUAL\n\nNa metodologia atual de desenvolvimento, o resultado final, isto\ne?, o programa de CLP, e? uma traduc?a?o direta das informac?o?es contidas\nno diagrama lo?gico e na matriz causa e efeito para uma lo?gica Ladder.\n\n\n\n51\n\nOs testes realizados em seguida sa?o criados a partir de conhecimento\npre?vio de engenheiros envolvidos no projeto ale?m de informac?o?es dos\ndocumentos existentes.\n\nO per??odo reservado para a aprovac?a?o do CLP ja? programado e?\nrelativamente curto, o que resulta na necessidade de realizac?a?o de va?rios\ntestes em um curto espac?o de tempo. Isso pode resultar em testes com\nresultados incorretos caso alguma especificac?a?o no documentos de testes\nna?o seja seguida corretamente. Ainda, os testes sa?o realizados com o\nCLP ja? em ma?os da Petrobras, e, caso algum erro seja encontrado, este e?\ndevolvido a? terceirizada para correc?a?o. Esta abordagem pode provocar\natrasos por exigir o translado do CLP entre terceirizada e Petrobras\npara cada teste, ale?m de exigir o deslocamento de, pelo menos uma\npessoa, para a realizac?a?o dos testes durante as u?ltimas etapas de um\nprojeto de automac?a?o.\n\nA criac?a?o de um teste de aceitac?a?o de fa?brica deve conter, ao\nmenos, uma quantidade m??nima de testes para se validar um programa\nde CLP. Nem todos os casos de teste que um especialista pode conceber\nsa?o inseridos no documento, afinal, o tempo para a realizac?a?o dos testes\ne? uma varia?vel de grande importa?ncia e, cada teste extra, exige mais\ntempo para validac?a?o do programa de CLP. Esta abordagem portanto\ne? um teste parcial, e os problemas de configurac?a?o do CLP va?o aparecer\ndurante a partida e a operac?a?o da planta, acarretando problemas de\nseguranc?a ou paradas da produc?a?o, com altos custos.\n\n3.5 COMENTA?RIOS FINAIS\n\nNeste cap??tulo abordada-se a atual metodologia de desenvolvi-\nmento de projetos utilizada pela Petrobras. Apresenta-se os documen-\ntos utilizados nessa atual metodologia, sua interac?a?o para a gerac?a?o do\nsoftware de CLP e a realizac?a?o de testes sobre tal CLP. Ale?m disso,\ntambe?m apresenta-se limitac?o?es da metodologia como tempo despren-\ndido e nu?mero de testes realizado No pro?ximo cap??tulo, sera? apresen-\ntada uma nova metodologia baseada em redes de Petri para a gerac?a?o\ne realizac?a?o de testes baseada em um dos documentos do projeto.\n\n\n\n52\n\n\n\n53\n\n4 PROPOSIC?A?O DE UMA NOVA METODOLOGIA\nPARA GERAC?A?O E REALIZAC?A?O DE TESTES\n\nNo cap??tulo anterior, foi mostrada a metodologia atual de desen-\nvolvimento de programas em vigor na Petrobras. Neste cap??tulo, sera?\nabordada uma nova metodologia proposta para a realizac?a?o de testes\nbaseada em documentos de projeto e sua aplicac?a?o. Num primeiro mo-\nmento, a metodologia sera? explicada a partir de uma visa?o geral e em\nseguida os passos envolvidos com essa metodologia sera?o detalhados.\n\n4.1 VISA?O GERAL DA METODOLOGIA E SUA INSERC?A?O NO\nDESENVOLVIMENTO DO PROJETO\n\nO propo?sito da metodologia a ser apresentada neste cap??tulo e?\nser integrada a? metodologia de projeto ja? existente na Petrobras e,\npara tal, algumas caracter??sticas que tornam essa integrac?a?o mais su-\ntil sa?o extremamente deseja?veis pois aumentam o aceite por parte dos\nengenheiros. A introduc?a?o de uma nova fase em uma metodologia de\ndesenvolvimento de projetos ja? consolidada se apresenta como um desa-\nfio por lidar com ha?bitos ja? antigos, bem estabelecidos e transmitidos\nentre gerac?o?es de funciona?rios. Para uma boa integrac?a?o e uma boa\naceitac?a?o por parte dos desenvolvedores, as seguintes caracter??sticas\nforam buscadas:\n\n\u2022 A Metodologia deve trabalhar com informac?o?es ja? existentes\n\n\u2022 A Metodologia deve evitar o aumento do tempo de projeto\n\n\u2022 A Metodologia deve possuir uma fa?cil usabilidade\n\n\u2022 A Metodologia deve apresentar resultados facilmente entendidos\ne aproveita?veis\n\nLevando o citado em considerac?a?o, o primeiro passo para a espe-\ncificac?a?o da metodologia e? definir em que momento, durante o projeto,\nela deve ser utilizada e, em conseque?ncia, quais informac?o?es sera?o uti-\nlizadas.\n\nComo mostrado anteriormente, a metodologia atual segue a uma\nordem de desenvolvimento como demonstrado na figura 13. A proposta\ne? introduzir a nova metodologia ao fim do desenvolvimento do programa\nde CLP, para utilizac?a?o do CLP ja? programado como uma das entra-\ndas para o teste. Outra entrada sa?o as informac?o?es da matriz causa e\n\n\n\n54\n\nefeito e tambe?m uma simulac?a?o da planta. A sa??da apo?s a realizac?a?o de\ntestes e? um texto em formato de Log que apresenta os testes realizados\n(seque?ncia de ac?o?es tomadas) e os resultados - sucessos ou falhas do\nprograma. A figura14 apresenta a introduc?a?o da metodologia dentro\ndo processo de desenvolvimento de um projeto. Outra caracter??stica\nimportante ao se propor esta metodologia e? que ela pode ser imple-\nmentada em paralelo com a metodologia ja? existente. Esse paralelismo\npermite uma adere?ncia melhor ao permitir comparac?a?o entre ambas\nmetodologias.\n\nFigura 14: Inserc?a?o da metodologia no desenvolvimento do projeto.\n\nDentre os documentos descritos no cap??tulo 3, alguns possuem\numa relac?a?o direta ou quase direta com o co?digo Ladder gerado e dois\ndevem ter sua importa?ncia ressaltada: a matriz causa e efeito e o dia-\ngrama lo?gico. Ambos sa?o intimamente relacionados com o co?digo de-\nsenvolvido para o CLP e possuem uma relac?a?o direta com o co?digo\ngerado, isto e?, a informac?a?o contida nesses documentos e? traduzida\ndiretamente para co?digos Ladder sem maiores mudanc?as das lo?gicas\npresentes ou necessidade de grandes interpretac?o?es.\n\nO diagrama lo?gico, assim como exposto anteriormente, e? gerado\na partir de documentos iniciais de descric?a?o do sistema (memorial des-\ncritivo, matriz causa e efeito e fluxograma de processo). Tal aborda-\n\n\n\n55\n\ngem envolve a gerac?a?o de uma lo?gica em um documento atrave?s de\ninterac?o?es, sem teste ou verificac?o?es realizadas sobre essa mesma lo?gica\ne pode resultar em uma lo?gica com falhas. O resultado final da criac?a?o\ndo diagrama lo?gico, pode, dessa maneira, possuir erros de lo?gica ou\nainda estar incompleto. Na?o se pode enta?o, utilizar o diagrama lo?gico\ncomo especificac?a?o para a gerac?a?o de testes exatamente porque essa es-\npecificac?a?o utilizada na criac?a?o do programa Ladder pode conter erros\ne, mesmo uma verificac?a?o baseada em model checking, que utilize essa\nlo?gica como base, na?o garante o correto funcionamento do programa\nLadder.\n\nEnta?o, para a realizac?a?o dos testes, escolheu-se a matriz causa e\nefeito como ponto de partida por 2 motivos principais: esse documento\nesta? presente durante todo o projeto, acompanha todo o processo de\ndesenvolvimento e apresenta, ainda, requisitos funcionais do projeto.\nPor esse documento exibir os dados nele contidos, a relac?a?o entre sinais\nde campo e sinais para atuadores no campo, de maneira constante e\nbaseada em regras, ele possui certa formalidade. Ele na?o esta? sujeito\na representac?o?es puramente textuais, as quais, normalmente, tem a\nproblema?tica de necessitar de interpretac?a?o humana, estando sujeitas\na ambiguidade, e podem apresentar diversas variac?o?es dependendo do\nengenheiro responsa?vel por sua criac?a?o.\n\nA partir das informac?o?es contidas na matriz sa?o gerados testes\npara o programa e sa?o tambe?m criados observadores baseados em redes\nde Petri para representar o comportamento esperado para o software\nde CLP. O processo de gerac?a?o de testes resulta em uma seque?ncia de\nentradas para o CLP que e? utilizada enta?o para a realizac?a?o dos testes.\nAtrave?s de um protocolo industrial, o CLP tem seu programa execu-\ntado com suas entradas forc?adas, de acordo com aquilo estipulado na\nseque?ncia de entradas, e uma planta simulada e? utilizada como substi-\ntuta para a planta real. Os dados de sa??da do CLP, sa?o armazenados\npara posterior comparac?a?o com os observadores gerados anteriormente.\n\nOs observadores criados anteriormente sa?o enta?o utilizados como\nbase para a validac?a?o do teste. Eles conte?m o comportamento esperado\npara o sistema e sa?o executados utilizando os valores armazenados du-\nrante o teste. A partir do estado final alcanc?ado por esses observadores,\ne? poss??vel concluir se houve um erro ou na?o. Os resultados finais, ou\nseja, a presenc?a ou na?o de erros, o estado final alcanc?ado pelo obser-\nvador e os sinais envolvidos sa?o enta?o apresentados para o usua?rio. A\nfigura 15 apresenta a metodologia explicada anteriormente numa visa?o\ngeral.\n\n\n\n56\n\nFigura 15: Visa?o geral da metodologia proposta\n\n4.2 GERAC?A?O DE OBSERVADORES\n\nUm dos passos da metodologia deste documento e? a gerac?a?o de\nredes de Petri a partir das informac?o?es contidas na matriz causa e\nefeito. Escolheu-se representar as informac?o?es atrave?s de redes de Pe-\ntri por permitirem uma fa?cil modelagem de eventos paralelos e, por\nconseguir representar um grande nu?mero de diferentes estados utili-\nzando um nu?mero reduzido de lugares. A utilizac?a?o de uma abordagem\nformal bem estabelecida como as redes de Petri para a representac?a?o\ndas informac?o?es e? importante por ser bem aceita pela comunidade de\npesquisa, por facilitar a implementac?a?o de ferramentas que utilizem\nessa abordagem e ainda por permitir que os modelos criados sofram\noperac?o?es de maneira a se obter novos modelos mais completos.\n\nDentre aquilo que se deseja observar do sistema programado,\nexistem o caso de uma sa??da de CLP que deveria ser ativada mas na?o\nfoi e o caso de uma sa??da de CLP que foi ativada sem a necessidade\nde ser. Esses casos sa?o respectivamente os falsos negativos e os falsos\npositivos. Os observadores aqui tratados sa?o constru??dos para tratar\n\n\n\n57\n\ndos casos de falsos negativos, ou seja, eles sa?o utilizados para observar\nse o sistema deixou de ativar alguma sa??da quando necessa?rio.\n\nSeguindo a visa?o geral apresentada na sec?a?o 4.1, a partir do do-\ncumento inicial, seguem duas etapas que utilizam as informac?o?es desse\ndocumento. A criac?a?o de redes de Petri que representam as informac?o?es\ncontidas nesse documento e a definic?a?o dos testes que sera?o gerados.\n\nA matriz causa e efeito apresenta as informac?o?es de sensores de\ncampo em linha e de acionamentos em coluna. O objetivo das redes de\nPetri geradas e? apresentar um sistema reativo que possa ser utilizado\nmais tarde para comparac?a?o dos resultados obtidos em teste. Para a\ndefinic?a?o dessas redes de Petri, foram analisadas os diferentes tipos de\nsinais vindos do campo, sua relac?a?o com os acionamentos e suas carac-\nter??sticas que deveriam estar presente no modelo criado. As entradas\nforam dividas em grupos que possuem caracter??sticas semelhantes, os\ngrupos sa?o:\n\n\u2022 Entradas boleanas simples\n\n\u2022 Grupo de entradas boleanas\n\n\u2022 Votac?a?o de sinais de campo\n\n\u2022 Entradas boleanas com mu?ltiplos efeitos temporizados\n\nPara cada um dos tipos de entradas foram definidas redes que\napresentam algumas caracter??sticas ba?sicas:\n\n\u2022 Um sinal vindo do campo, se na?o tratado, deve caracterizar mais\ntarde uma falha no software\n\n\u2022 Se todos os passos necessa?rios para o correto tratamento do sinal\nforem realizados, a execuc?a?o com sucesso deve ser identificada\n\nA seguir as redes definidas sera?o apresentadas. Redes com mai-\nores detalhes desenvolvidas a partir de uma matriz causa e efeito real\njuntamente com uma planta exemplo selecionada para melhor compre-\nensa?o sera?o abordadas no cap??tulo 5.\n\nDado que o sistema(CLP programado) a ser testado e? um sis-\ntema do tipo caixa-preta, ou seja, somente se tem acesso a?s entradas\ne sa??das do sistema, escolheu-se trabalhar com observadores para o di-\nagno?stico de poss??veis erros. A opc?a?o por se utilizar observadores para o\ndiagno?stico de erros no programa se da? pelo fato de que o sistema (CLP\nprogramado) e? do tipo caixa-preta, e, os observadores, como explicado,\nna?o devem ser intrusivos, ou seja, na?o devem alterar o comportamento\n\n\n\n58\n\ndo sistema sendo observado. Essa caracter??stica mandato?ria do obser-\nvador esta? em concorda?ncia com o necessa?rio para o diagno?stico em\num sistema caixa-preta, uma vez que o programa do CLP na?o pode ser\nalterado.\n\nDentre as informac?o?es contidas na matriz causa e efeito, se de-\nseja poder observar se a relac?a?o estipulada entre causa e efeito foi cum-\nprida. Cada causa possui um ou mais efeitos correspondentes e sa?o\nesses efeitos que se deseja observar. As redes de Petri aqui geradas\nsa?o enta?o observadores do sistema que representam as propriedades a\nserem observadas no programa de CLP e, assim como um observador,\nna?o introduzem novas informac?o?es no sistema sendo utilizadas somente\npara se observar a presenc?a de falha ou na?o. Elas sa?o utilizadas para\ndeterminar se os valores obtidos pelo teste sa?o aqueles que deveriam\nser obtidos por um programa que segue as especificac?o?es encontradas\nna matriz causa e efeito.\n\nNo decorrer desta sec?a?o, sera?o apresentados os observadores de-\nsenvolvidos para o caso de estudo.\n\n4.2.1 Observadores ba?sicos\n\n4.2.1.1 Entradas boleanas simples\n\nO caso mais simples existente no projeto e? a relac?a?o direta en-\ntre uma entrada e uma sa??da na matriz causa e efeito. O modelo que\nrepresenta esse caso e? apresentado na figura 16 onde a entrada e? \u201dDes-\nligamento Manual\u201d e a sa??da e? \u201dVapor de abafamento\u201d. Os lugares\n\u201dDesligamento manual\u201de \u201dAbertura do vapor de abafamento\u201dindicam\no recebimento de um sinal de campo para desligamento manual e o\nenvio de um sinal para a abertura de uma va?lvula de abafamento res-\npectivamente.\n\nPara esse modelo, o comportamento esperado pode ser analisado\nda seguinte maneira: quando o comando para desligamento manual e?\nenviado ao CLP, o tempo da transic?a?o t0 passa a decorrer e, se ate?\no tempo limite t1 o lugar \u201dVapor de abafamento\u201dna?o houver recebido\numa ficha, indicando que a va?lvula de abafamento na?o foi aberta, a\ntransic?a?o time out dispara sinalizando que o sistema atingiu um estado\nindeseja?vel. Nesse caso, isso significa que o sistema na?o executou a\nac?a?o de abrir o vapor de abafamento dentro de um tempo limite t1.\nCaso a ficha seja adicionada dentro do tempo limite, a rede alcanc?a\num estado que representa enta?o o funcionamento desejado para essa\n\n\n\n59\n\nrelac?a?o espec??fica.\n\nFigura 16: Observador em redes de Petri para uma entrada boleana\nsimples\n\n4.2.1.2 Grupos de entradas boleanas\n\nUm tipo de entrada presente no documento e? a existe?ncia de um\nnu?mero m??nimo de sinais dentro de um determinado conjunto. Como\nexemplo temos \u201dtre?s ou mais queimadores sem chama\u201d, ou seja, para\ntodos os queimadores da planta, se no m??nimo tre?s deles ficarem sem\nchama, o co?digo referente a essa linha deve ser executado no programa\nde CLP. Para representar essa relac?a?o, a rede de Petri representada na\nfigura 17 foi desenvolvida. Os sinais utilizados sera?o, a t??tulo de exem-\nplificac?a?o somente, \u201dTre?s ou mais queimadores sem chama\u201de \u201dVapor de\nAbafamento\u201dcomo no exemplo anterior.\n\nEla apresenta um comportamento parecido com o ja? descrito\npara a entrada boleana simples. A diferenc?a se da? que aqui, o arco\npara o disparo da transic?a?o tem peso 3, indicando a necessidade da\nexiste?ncia de tre?s fichas (tre?s queimadores sem chama) para a execuc?a?o\n\n\n\n60\n\nda rede.\n\nFigura 17: Modelo para um grupo de entradas boleanas\n\n4.2.1.3 Votac?a?o de sinais de campo\n\nOutro caso presente na matriz causa e efeito e? a votac?a?o um de\ndois(1oo2) e a votac?a?o dois de tre?s(2oo3). Essas votac?o?es sa?o utilizadas\nquando um sinal lo?gico possui mais de um sinal f??sico no campo, isto\ne?, quando dois transdutores diferentes oferecem ao sistema de controle\num valor redundante e os dois sinais, um de cada transdutor, que che-\ngam ao CLP devem ser considerados na escolha da ac?a?o a ser tomada.\nNa votac?a?o 1oo2, dois sinais chegam do campo e, se um deles estiver\nativo, enta?o o resultado da votac?a?o deve ser considerado ativo enquanto\nna votac?a?o 2oo3, e? necessa?rio que no m??nimo 2 de 3 sinais estejam em\nconcorda?ncia(e ativos) para que o resultado da votac?a?o seja conside-\nrado. As figuras 18 e 19 mostram os casos para votac?a?o 1oo2 e 2oo3\nrespectivamente.\n\nNesses modelos os lugares \u201dsinal n\u201dcom n sendo 1, 2 ou 3 sa?o\nos lugares que representam os sinais vindo de campo, o lugar \u201drealizar\nvotac?a?o\u201dassegura que somente uma ficha seja repassada para o lugar\n\u201dresultado votac?a?o\u201d.\n\n\n\n61\n\nFigura 18: Modelo para um caso de votac?a?o 1oo2\n\n4.2.1.4 Entradas boleanas com mu?ltiplos efeitos temporizados\n\nOutro caso comum e? a existe?ncia de sequenciamentos dentro do\nsistema. Para exemplificar um sequenciamento, uma nota presente na\nmatriz causa e efeito e? apresentada na figura 20. Neste caso, a nota\napresenta tre?s passos que devem ser realizados, em ordem: e? necessa?rio\nfechar a primeira va?lvula de bloqueio, em seguida, fechar a va?lvula de\nventilac?a?o e, apo?s 5 segundos, fechar a segunda va?lvula de bloqueio. A\nrede na figura 20 possui 4 lugares que representam os sinais de entrada\ne sa??da sendo que os sinais \u201dfechar primeira va?lvula\u201d, \u201dabrir va?lvula\nde ventilac?a?o\u201de \u201dfechar segunda va?lvula\u201dsa?o sinais de sa??da do CLP e\n\u201dPressa?o muito alta no piloto\u201de? um sinal de entrada do CLP. Nesse\nmodelo o caminho composto pelas transic?o?es t1, t4, t6 e t10 represen-\ntam o caminho esperado para o funcionamento correto. As transic?o?es\nt0, t2, t5, t7, t9 e t12 apresentam poss??veis problemas na execuc?a?o do\nmodelo.\n\nt1, t4, t6 e t10 sa?o respectivamente as transic?o?es que representam\no fechamento da primeira va?lvula, a abertura da va?lvula de ventilac?a?o,\na espera de 5 segundos antes do fechamento da segunda va?lvula e o fe-\nchamento da segunda va?lvula. Ja? t0, t2, t5, t7, t9 e t12 sa?o, em ordem,\num time-out para o na?o fechamento da primeira va?lvula, a abertura\nda va?lvula de ventilac?a?o antes do fechamento da primeira va?lvula de\nbloqueio, o time out da abertura da va?lvula de bloqueio, o fechamento\nda segunda va?lvula antes da abertura da va?lvula de ventilac?a?o, o fecha-\n\n\n\n62\n\nFigura 19: Modelo para um caso de votac?a?o 2oo3\n\nmento da segunda va?lvula de bloqueio antes de passados 5 segundos e\no time out para o fechamento da segunda va?lvula de bloqueio.\n\n4.2.2 Composic?a?o de observadores\n\nUm mesmo sinal de sensor de campo pode necessitar de diferen-\ntes tratamentos de acordo com sua relac?a?o com acionamentos. Assim,\numa entrada boleana simples pode ainda ser tambe?m uma votac?a?o 1oo2\nou 2oo3. Caso o sinal seja deste tipo, e? necessa?rio uma fusa?o entre as\nredes correspondentes. Como visto na sec?a?o 2.1.2, a fusa?o de duas redes\nde Petri ou, nesse caso, observadores e? feita pela unia?o ou dos estados\nou das transic?o?es equivalentes entre esses modelos. Este me?todo per-\nmite a manutenc?a?o das caracter??sticas de modelos individuais enquanto\npermite a criac?a?o de um modelo maior e mais completo. Para exem-\nplificar a fusa?o de observadores, a figura 21 apresenta a fusa?o entre a\nvotac?a?o 1oo2 e o caso para uma entrada boleana simples apresentado\nanteriormente.\n\n4.3 GERAC?A?O DE TESTES\n\nAssim como apresentado na figura 15, paralelamente a? gerac?a?o\ndos observadores, existe a gerac?a?o dos testes a serem realizados. Os\ntestes devem ser decididos a partir das informac?o?es de sinais de campo\ne acionamentos presentes na matriz causa e efeito.\n\n\n\n63\n\nFigura 20: Modelo em redes de Petri para um caso onde uma nota\ndetermina uma ordem de execuc?a?o\n\nA quantidade total poss??vel de testes a serem realizados cresce\nde acordo com o nu?mero de entradas existentes no sistema a ser tes-\ntado. Como as entradas tratadas sa?o bina?rias podendo assumir 2\nvalores diferentes, o nu?mero total de combinac?o?es de entradas exis-\ntentes em um sistema com n entradas e? de 2n. A fim de se evitar\nesse crescimento exponencial, trabalha-se com particionamento de equi-\nvale?ncia(BEIZER, 1990) para reduzir o nu?mero de testes realizados e na?o\nlimitar a aplicac?a?o da metodologia a? pequenos projetos. Entre todas\nas combinac?o?es poss??veis que afetam um observador, opta-se por utili-\nzar as entradas que afetam somente o observador em questa?o. Desta\nmaneira, algumas regras que norteiam a escolha das entradas para os\ntestes foram definidas. Para tal, as entradas foram divididas numa ma-\nneira ana?loga aos diferentes tipos de observadores. Os diferentes testes\nsa?o apresentados em seguida.\n\nO primeiro tipo ba?sico de teste a ser realizado e? o seguinte:\n\n\u2022 Para cada Linha da matriz, forc?ar o sinal de campo correspon-\ndente a?quela linha\n\n\u2022 Comparar o desenvolvimento das sa??das do CLP de acordo com\nas redes de Petri criadas\n\n\n\n64\n\nFigura 21: Modelo para um caso de votac?a?o 1oo2, contorno pontilhado,\nfundido com uma entrada boleana simples, contorno cont??nuo.\n\nEsse primeiro teste simples permite afirmar, ao menos, que o\nprograma executa os trechos correspondentes a?s linhas da matriz causa\ne efeito corretamente.\n\nUm segundo tipo de teste gerado e? aquele correspondente a?\nvotac?a?o, isto e?, quando o sinal possui uma votac?a?o 1oo2 ou 2oo3. Para\nestes casos, sa?o gerados diferentes casos de teste. Para a votac?a?o 1oo2,\nexistem 3 diferentes testes sendo eles a ativac?a?o de somente um dos\nsinais de campo, a ativac?a?o do outro sinal de campo e a ativac?a?o si-\nmulta?nea de ambos os sinais de campo. Ja? para a votac?a?o 2oo3, existem\num total ma?ximo de quatro testes poss??veis que consistem na com-\nbinac?a?o dos tre?s sinais de campo existentes. Dados os sinais de campo\nA, B e C para o caso de votac?a?o 2oo3, os testes poss??veis consistem na\nativac?a?o das entradas: AB, AC, BC e ABC\n\nO terceiro tipo de teste gerado e? referente caso descrito na sec?a?o\n4.2.1.2, quando nu?mero m??nimo de um grupo de sinais de campo deve\nestar ativo para que se execute uma ac?a?o correspondente. Para este\ncaso, assim como para a votac?a?o 2oo3, existe uma combinac?a?o de entra-\ndas poss??veis para se realizar o teste. Dado m como o nu?mero m??nimo\nde entradas necessa?rias para ativar a execuc?a?o e t como o nu?mero total\nde sinais provenientes do campo, o nu?mero de testes pode ser dado pela\n\n\n\n65\n\ncombinac?a?o de t m a m, ou ainda Ctm = t!/(m!(t?m)!).\n\n4.3.1 Execuc?a?o dos testes\n\nOs testes gerados sa?o armazenados na forma de uma lista que\nindica, para cada caso de teste, qual entrada deve ser ativada. Durante\na execuc?a?o dos testes, o seguinte e? realizado:\n\n\u2022 Acionamento/desativac?a?o de determinada entrada especificada\nna lista de testes\n\n\u2022 Inicio do armazenamento das varia?veis e do tempo, relativo ao\nin??cio do teste, em que elas foram recebidas\n\n\u2022 Aguardo do final do caso de teste\n\n\u2022 In??cio do pro?ximo caso de teste na lista\n\n4.4 EXECUC?A?O DOS OBSERVADORES A PARTIR DOS RESUL-\nTADOS DOS TESTES\n\nAo final da realizac?a?o dos testes, existem diversos dados arma-\nzenados(correspondentes a?s entradas e sa??das do CLP). Para cada caso\nde teste realizado, os observadores equivalentes sa?o selecionadas e, uti-\nlizando um jogador de redes de Petri e as informac?o?es armazenadas do\nteste(inclusive tempo), compara-se os dados armazenados com os mo-\ndelos em redes de Petri. Um jogador de redes de Petri e? responsa?vel\npela execuc?a?o da rede de Petri e sua evoluc?a?o dada a marcac?a?o inicial.\nNo caso do jogador para esta metodologia, ale?m da marcac?a?o inicial,\nainda e? considerado a inserc?a?o de fichas de acordo com a presenc?a dos\nsinais de entrada e sa??da. O jogador funciona executando o seguinte\nciclo enquanto restarem dados armazenados para cada caso de teste:\n\n\u2022 Atualizac?a?o do tempo dos arcos\n\n\u2022 Disparo dos arcos que podem ser disparados\n\n\u2022 Atualizac?a?o dos valores das entradas e sa??das dos CLP (Inserc?a?o\nde fichas nos lugares correspondentes)\n\nAo final, com os dados armazenados, o observador e? analisado\npara verificar se um estado deseja?vel ou indeseja?vel foi alcanc?ado. Para\n\n\n\n66\n\nexemplificar a abordagem, considere a figura 22. Ela apresenta duas\nexecuc?o?es de testes diferentes, sendo que uma reconhece a existe?ncia\nde um erro enquanto outra e? um teste executado com sucesso. Es-\ntes dados sa?o referentes a? uma linha cujo modelo em redes de Petri\ncorrespondente ao ja? apresentado na figura 16.\n\nFigura 22: Dados armazenados apo?s duas execuc?o?es de testes diferentes\n\nAo seguir o ciclo estipulado anteriormente, tem-se que, para\na primeira execuc?a?o (tabela da esquerda), o lugar \u201dOk\u201dacaba com\numa ficha enquanto, para o segundo caso (tabela da direita), o lugar\n\u201dNOk\u201dacaba com uma ficha. A partir dessa ana?lise, pode-se afirmar\nque o teste referente a? tabela esquerda finalizou com sucesso enquanto,\nem contrapartida, o teste relacionado com a tabela direita, indicou fa-\nlha do programa de CLP.\n\n4.5 COMENTA?RIOS FINAIS\n\nNeste cap??tulo foram foram abordados os aspectos da metodo-\nlogia proposta para realizac?a?o de testes em projetos utilizando os do-\ncumentos ja? existentes na metodologia de desenvolvimento de projeto\nda Petrobras. Foram detalhadas as caracter??sticas componentes dessa\nabordagem bem como sua aplicac?a?o para a gerac?a?o de testes. Os obser-\nvadores abordados aqui sa?o modelados com o objetivo de verificar a pre-\nsenc?a de falsos negativos. A identificac?a?o dos falsos positivos tambe?m\ne? importante uma vez que um CLP que ativa todas as suas sa??das para\nqualquer sinal de entrada passaria no teste de falsos negativos. Para se\nadicionar a detecc?a?o de falsos positivos, novos observadores deveriam\nser modelados com essa finalidade. Eles seriam comportados pela meto-\n\n\n\n67\n\ndologia proposta, sendo necessa?rio somente sua modelagem e adic?a?o no\nprocesso de testes. Para tal modelagem, seguindo os mesmos princ??pios\ndos observadores apresentados, seria necessa?rio definir a sa??da na?o dese-\njada e relaciona?-la com um lugar na?o desejado, um \u201dNOk\u201d, numa lo?gica\ncontra?ria a?quela utilizada na definic?a?o dos observadores apresentados.\n\n\n\n68\n\n\n\n69\n\n5 DESENVOLVIMENTO DE UMA FERRAMENTA\nPARA SUPORTAR A METODOLOGIA PROPOSTA\n\nNeste cap??tulo, sera? apresentada uma ferramenta desenvolvida\npara a realizac?a?o de testes em um estudo de caso baseado no forno\nja? abordado no cap??tulo 3. Sera?o abordados os mo?dulos funcionais da\nferramenta, sua funcionalidade e tambe?m as limitac?o?es desta imple-\nmentac?a?o em questa?o.\n\n5.1 DESENVOLVIMENTO DE UMA FERRAMENTA DE TESTES\nE VALIDAC?A?O DA METODOLOGIA\n\nPara a criac?a?o da ferramenta, foi utilizada uma abordagem top-\ndown. A ferramenta foi definida partindo de viso?es gerais e enta?o,\nfoi especializada e especificada. Numa primeira interac?a?o o interfacea-\nmento mais alto n??vel da ferramenta foi definido, ou seja, a entrada dos\ndados contidos na matriz causa e efeito e a sa??da em formato de um\nLog para posterior consulta. Como pro?ximo passo, foram decididos os\naspectos ba?sicos da ferramenta e, assim, o fluxo de informac?o?es dentro\nda ferramenta foi especificado. Como entrada, tem-se as informac?o?es\nda matriz causa e efeito e, a partir dessas informac?o?es, dois principais\n\u201ditens\u201ddevem ser gerados:\n\n\u2022 Seque?ncias de inputs utilizados para execuc?a?o de seque?ncias no\nCLP\n\n\u2022 Modelos a serem utilizados para comparac?a?o da execuc?a?o real do\nprograma de CLP com a execuc?a?o esperada\n\nA seque?ncia gerada e? enta?o utilizada na troca de informac?a?o\nentre o CLP e a planta simulada. Essa troca produz uma se?rie de\nvalores(varia?veis da planta simulada e valores de sa??da do CLP), os\nquais sa?o armazenados para uso posterior.\n\nApo?s a execuc?a?o das seque?ncias criadas, os valores armazenados\nsa?o utilizados como base para comparac?a?o contra o comportamento\nesperado. Esse comportamento esperado e? obtido a partir dos modelos\ngerados no passo anterior. Da comparac?a?o, um log e? gerado e finalmente\napresentado ao usua?rio. Esta e? a abordagem ja? detalhada no cap??tulo\n4.\n\nA estrutura que compo?e a ferramenta foi subdividida em dife-\nrentes mo?dulos responsa?veis, cada um, por parte das tarefas realizadas\n\n\n\n70\n\ndurante a gerac?a?o e realizac?a?o de testes. Os mo?dulos sa?o os seguintes:\n\n\u2022 Interface: responsa?vel por permitir a entrada de dados da ma-\ntriz causa e efeito e tambe?m processamento desses dados para\nutilizac?a?o pelos mo?dulos seguintes\n\n\u2022 Gerador de observadores: realiza a transformac?a?o dos dados em\nobservadores baseados em redes de Petri para serem utilizados\npor outros mo?dulos\n\n\u2022 Gerador de comandos: gera uma lista de testes a serem realizados\nbaseado nas informac?o?es contidas na interface\n\n\u2022 Gravador de resultados do CLP: grava os dados do CLP e da\nplanta simulada durante o teste para futura comparac?a?o\n\n\u2022 Comparador dos resultados com os observadores e gerador de\nLog: utiliza dados gravados durante os testes para comparar os\ncomportamentos dos observadores e do sistema a fim de definir\nse o comportamento foi o correto\n\n\u2022 Comunicac?a?o OPC: realiza a comunicac?a?o OPC entre planta si-\nmulada e ferramenta de testes\n\nOs mo?dulos especificados interagem entre si trocando os dados\nnecessa?rios. Isso gera um fluxo dos dados e de transformac?a?o dos dados\ndentro da ferramenta desde a informac?a?o crua da matriz causa e efeito\nate? o Log final gerado. A figura 23 apresenta os mo?dulos e tambe?m sua\ninterac?a?o.\n\n5.2 ENTRADA DE DADOS\n\nO objetivo da interface e? permitir que o usua?rio insira as in-\nformac?o?es contidas matriz causa e efeito. Como visto no cap??tulo 3, a\nmatriz possui algumas informac?o?es textuais ale?m da relac?a?o direta en-\ntre sinal de campo e sinal de entrada. O usua?rio tambe?m deve ser capaz\nde inserir essas informac?o?es de maneira que elas possam ser utilizadas\nposteriormente para a criac?a?o de modelos.\n\nPara a representac?a?o dos dados, foi escolhido a transformac?a?o\nde toda a informac?a?o visual contida na matriz causa e efeito para uma\ninformac?a?o textual que possa ser facilmente analisada, transformada e\nutilizada. Este arquivo de texto conte?m a informac?a?o da matriz causa e\nefeito de uma maneira ordenada e e? dividido em duas partes principais:\n\n\n\n71\n\nFigura 23: Mo?dulos da ferramenta e fluxo de informac?a?o entre mo?dulos\n\numa se?rie de sinais que correspondem a?s colunas e, ao fim destes, uma\nse?ries de sinais que correspondem a?s linhas.\n\n5.3 GERAC?A?O DE OBSERVADORES\n\nUm dos aspectos chave da ferramenta criada e? a gerac?a?o de ob-\nservadores baseados em redes de Petri a partir das informac?o?es con-\ntidas na matriz causa e efeito. A ferramenta deve ser capaz de criar\nva?rias insta?ncias de observadores, cada um adaptado para um sinal de\ncampo(causa) e atuador(efeito) diferentes. Para atingir tal objetivo,\nforam definidas estruturas gene?ricas para as redes de Petri utilizadas\npara os observadores. Essas estruturas sa?o mais tarde especificadas\npara adequar o observador a? um conjunto de sinais espec??ficos. A fi-\ngura 24 sumariza os passos para a obtenc?a?o de observadores.\n\nO exemplo de observador dado para a figura 25 e? parte do banco\nde observadores presente na ferramenta. Os locais dessa rede possuem\nos nomes gene?ricos \u201dfromfieldsignal1\u201de \u201dtofieldsignal1\u201dpropositalmente.\nEles representam os sinais de entrada do campo e de sa??da para o\ncampo. Ao instanciar um observador, a ferramenta o torna u?nico subs-\ntituindo esses nomes pelos sinais existentes na matriz causa e efeito.\nAssim, a instanciac?a?o de um observador na ferramenta funciona da se-\n\n\n\n72\n\nFigura 24: Passos para se obter os observadores a partir do banco de\nobservadores\n\nguinte maneira: e? escolhida uma definic?a?o ja? existente, os nomes dos\nlugares sa?o substitu??dos de maneira a representar corretamente uma\nrelac?a?o na matriz causa e efeito e, em seguida, pode ser armazenada\npara posterior uso. Para o caso descrito, \u201dfromfieldsignal1\u201ddeve ser\nsubstitu??do pelo nome da varia?vel contida na linha da matriz causa\ne efeito enquanto \u201dtofieldsignal1\u201ddeve ser substitu??do pelo nome da\nvaria?vel na coluna da matriz causa e efeito. Levando-se em considerac?a?o\na primeira linha da matriz causa e efeito da planta exemplo e a se?tima\ncoluna da mesma, temos como causa o sinal \u201dPSHH-014A/B/C\u201de como\nefeito, o equipamento \u201dXY-037\u201d. Para a obtenc?a?o da primeira rede ne-\ncessa?ria para o observador correspondente, o nome \u201dfromfieldsignal1\u201de?\nsubstituido por \u201dPSHH-014A/B/C\u201denquanto o nome \u201dtofieldsignal1\u201de?\nsubstituido por \u201dXY-037\u201d. O resultado e? o visto na figura 26.\n\nUm outro caso importante na criac?a?o dos observadores e? quando\nse faz necessa?rio a fusa?o de duas redes diferentes para se obter o ob-\nservador desejado. Para tal fim, assim como descrito anteriormente, os\nobservadores ja? existentes nos bancos de observadores sa?o especificados\nde acordo com os sinais correspondentes na matriz causa e efeito e,\nenta?o, suas informac?o?es sa?o fusionadas a fim de se obter o observador\ncompleto. Para o mesmo conjunto de sinais \u201dPSHH-014A/B/C\u201de \u201dXY-\n037\u201dobserva-se que e? necessa?rio ainda a especificac?a?o de uma votac?a?o\n2oo3, assim como esta? definido na matriz causa e efeito na coluna \u201dno-\ntas\u201d. A votac?a?o 2oo3 tambe?m possui um observador ja? definido com\nnomes gene?ricos e a substituic?a?o destes nomes pelos conjuntos de sinais\n\n\n\n73\n\nFigura 25: Exemplo de observador que compo?e o banco de observadores\n\n\u201dPSHH-014A/B/C\u201de \u201dXY-037\u201dresulta na rede vista na figura 27.\nO u?ltimo passo para a obtenc?a?o do observador completo que\n\nrelaciona os sinais \u201dPSHH-014A/B/C\u201de \u201dXY-037\u201de? enta?o a fusa?o das\nduas redes apresentadas nas figuras 26 e 27. Como resultado desta\nfusa?o obte?m-se a rede de Petri apresentada na figura 28. Esta rede e? o\nobservador completo para os sinais \u201dPSHH-014A/B/C\u201de \u201dXY-037\u201d.\n\n5.4 DEFINIC?A?O DOS CASOS DE TESTE E GERAC?A?O DE CO-\nMANDOS\n\nA partir das entradas ja? lidas, a ferramenta pode, agora, defi-\nnir quais sera?o as seque?ncias impostas a?s varia?veis de acordo com a\nmetodologia explicada no cap??tulo 4. Para tal, sa?o observados tanto\nos sinais de campo(sensores) quanto poss??veis detalhes existentes que\nafetem aquele sinal. No caso da primeira linha da matriz, as entradas\n\u201dPSHH-014A\u201d, \u201dPSHH-014B\u201de \u201dPSHH-014C\u201dpossuem uma relac?a?o de\nvotac?a?o 1oo3. Isso significa, assim como visto no cap??tulo 4 que sera?o\ntestadas todas as combinac?o?es entre essas tre?s entradas. Esse mo?dulo\nda ferramenta cria uma lista com o nome das varia?veis de campo e os\nvalores que elas devem assumir de maneira a executar uma das linhas\nda matriz causa e efeito.\n\n\n\n74\n\nFigura 26: Primeiro passo no desenvolvimento do observador\n\nUm exemplo do teste gerado para as varia?veis \u201dPSHH-014A\u201d,\n\u201dPSHH-014B\u201de \u201dPSHH-014C\u201d(varia?veis da primeira linha da matriz\ncausa e efeito) e? o seguinte: \u201dPSHH-014A\u201d? 0, \u201dPSHH-014C\u201d? 0.\nIsso significa que em um dos testes gerados, as entradas \u201dPSHH-014A\u201de\n\u201dPSHH-014C\u201dseriam forc?adas para 0(0 aqui e? considerado o valor que\nativa a entrada). Da mesma maneira, para esta linha, ainda seriam\ngerados mais tre?s testes, cada um considerando uma combinac?a?o dife-\nrente para as entradas \u201dPSHH-014A\u201d, \u201dPSHH-014B\u201de \u201dPSHH-014C\u201d,\nsempre forc?ando seu valor para 0 em cada teste.\n\n5.5 INTERAC?A?O DA FERRAMENTA COM A PLANTA SIMULADA\n\nPara que os testes possam ser realizados e? necessa?rio uma si-\nmulac?a?o da planta a ser automatizada e tambe?m de comunicac?a?o com\no CLP ja? programado. De maneira a utilizar um protocolo ja? conhe-\ncido para os engenheiros, foi escolhido o OPC(OLE for Process Con-\ntrol) como ponte entre o CLP e planta simulada. OPC e? um padra?o\nde comunicac?a?o industrial entre equipamentos de diferentes fabricantes\ncriado em 1996 e oferece diferentes verso?es com objetivos espec??ficos.\n\n\n\n75\n\nFigura 27: Votac?a?o para o sinal \u201dPSHH-014A/B/C\u201d\n\nNeste trabalho foi utilizado o OPC DA(data access), que oferece uma\ninterface simplificada para acesso de varia?veis de processo atrave?s de\nidentificadores chamados de tags. E? um protocolo bem estabelecido no\nambiente industrial, muito utilizado em sistemas superviso?rios e, ale?m\nda ampla aceitac?a?o por parte da indu?stria, e? amplamente suportado\npela comunidade de desenvolvimento de software atrave?s de diferentes\nbibliotecas de acesso.\n\nApo?s os comandos definidos, a ferramenta pode iniciar a execuc?a?o\ndo teste, forc?ando cada varia?vel assim como explicado anteriormente.\nNesse momento, existe comunicac?a?o entre a planta e a ferramenta e se\nfaz necessa?rio especificar como a ferramenta e? capaz de alterar o valor\nde uma varia?vel simulada na planta.\n\nFoi definido um princ??pio para a criac?a?o de uma planta simulada\ntal que permite a? ferramenta forc?ar corretamente os valores de campo\nquando necessa?rio. Deve ser adicionada a? simulac?a?o, assim como expli-\ncitado na figura 29, uma lo?gica que de? prioridade ao valor enviado pela\nferramenta(neste caso, valor 0). Aqui pode-se ver que a planta executa\na simulac?a?o normalmente, mas o valor final da varia?vel de campo e? de-\ncidido pelo comando enviado da ferramenta quando essa deseja forc?ar\no valor a 0.\n\n5.5.1 Limitac?o?es temporais da ferramenta desenvolvida\n\nUm ciclo de CLP demora na ordem de milissegundos dependendo\ndo equipamento em questa?o enquanto um servidor OPC tem tempo de\n\n\n\n76\n\nFigura 28: Observador criado para a relac?a?o \u201dPSHH-014A/B/C\u201de\n\u201dXY-037\u201d\n\natualizac?a?o entre 0,2 segundos e alguns segundos dependendo do ser-\nvidor e configurac?o?es utilizados. Essa diferenc?a deve ser considerada\nao se estipular o tempo limite para ser considerado um time out na\nexecuc?a?o de um teste. Um tempo para time out na?o deve ser me-\nnor que o tempo m??nimo para aquisic?a?o dos dados, caso contra?rio,\npode-se encontrar uma falha onde ela, na realidade, na?o existe. Assim,\nno pior cena?rio, o tempo m??nimo para time out a partir do tempos\nde aquisic?a?o de dados e processamento do CLP pode ser calculado\nda seguinte maneira: timeout >= tempoparaescritanoservidorOCP\n+tempodeprocessamentodoCLP +tempoparaleituradoservidorOPC.\nEste tempo deve ser considerado na realizac?a?o dos testes para na?o gerar\num falso negativo como resultado.\n\n\n\n77\n\nFigura 29: Paradigma utilizado para forc?ar os valores das varia?veis de\ncampo na planta simulada\n\n5.6 UTILIZAC?A?O DOS OBSERVADORES PARA VALIDAC?A?O DOS\nTESTES\n\nEnquanto os testes sa?o realizados, uma tabela de valores lidos e?\nmontada para cada teste. Esta tabela deve conter as varia?veis utilizadas\nno teste em questa?o assim como a informac?a?o do tempo decorrido entre\nas leituras. Para isso, antes do in??cio do teste, sa?o verificadas quais\nvaria?veis sa?o pertinentes aos teste em questa?o, ou seja, a causa e o\nefeito de determinado teste. Essas varia?veis sa?o armazenadas e, a cada\nciclo, tem seus valores lidos e armazenados. Ale?m disso, em cada ciclo,\ne? obtido, a partir do sistema operacional, o tempo decorrido desde a\nu?ltima leitura.\n\nApo?s a realizac?a?o de todos os testes, resta a etapa da com-\nparac?a?o. Nesta etapa, os observadores gerados anteriormente e os\nvalores gravados durante a execuc?a?o dos testes sera?o utilizados para\ndeterminar se o programa de CLP se comportou como esperado. Neste\nmomento, existem diversos observadores gerados (um para cada relac?a?o\nda matriz causa e efeito) e diversas tabelas com valores gravados du-\nrante a execuc?a?o do teste. Para que a comparac?a?o seja executada, os\n\n\n\n78\n\nseguintes passos sa?o seguidos:\n\n\u2022 Para cada observador, relacionar a tabela de valores que trata as\nmesmas varia?veis\n\n\u2022 Executar o observador levando em considerac?a?o os valores conti-\ndos na tabela relacionada\n\n\u2022 Analisar o estado alcanc?ado, identificando uma execuc?a?o com su-\ncesso ou com falha\n\nO segundo passo, a execuc?a?o do observador, e? o verdadeiro res-\nponsa?vel pela validac?a?o do teste. Essa execuc?a?o pode ser subdividido\nda seguinte maneira:\n\n\u2022 Ler valores de uma linha das varia?veis da tabela\n\n\u2022 Alterar valores dos lugares correspondentes dos observadores (lu-\ngares referentes aos valores de campo e equipamentos)\n\n\u2022 Atualizar tempo das transic?o?es habilitadas\n\n\u2022 Disparar transic?o?es que possam ser disparadas\n\n\u2022 Passar para a pro?xima linha da tabela e repetir\n\nCom essa execuc?a?o, pode-se observar enta?o se os testes resul-\ntaram na descoberta de algum erro ou se o programa executou como\nesperado.\n\n5.7 COMENTA?RIOS FINAIS\n\nNeste cap??tulo, o desenvolvimento de uma ferramenta utilizada\nna validac?a?o da metodologia proposta no cap??tulo 4 foi apresentada.\nAqui foi explicado em detalhes como a informac?a?o e? tratada dentro\nda ferramenta e como essa informac?a?o e? utilizada dentro dos diversos\nmo?dulos nela contidos ale?m da execuc?a?o da tarefa espec??fica a? cada\nmo?dulo.\n\n\n\n79\n\n6 AVALIAC?A?O DA METODOLOGIA PROPOSTA\n\nPara a aplicac?a?o da metodologia proposta foi utilizada uma planta\nda Petrobras na realizac?a?o de testes. A planta e? a mesma de um forno\nja? descrito no cap??tulo 3. Neste cap??tulo, sera?o apresentados os to?picos\npertinentes a? validac?a?o da metodologia, sua aplicac?a?o, erros introduzi-\ndos ao co?digo, testes realizados e resultados encontrados. Sera?o apre-\nsentados os modelos desenvolvidos para este estudo de caso proposto e\nos resultados obtidos ao se aplicar a metodologia nesta planta exemplo.\n\n6.1 CO?DIGO DE AUTOMAC?A?O\n\nPara a validac?a?o da ferramenta, foi criado um co?digo Ladder\ncom o objetivo de automatizar a planta em questa?o. O co?digo foi\ncriado com respeito a? matriz causa e efeito encontrada no anexo B e\ncom a finalidade de seguir os requisitos impostos pela matriz. Para\nexemplificac?a?o, a figura 30 apresenta uma pequena parte do programa\nLadder, sua lo?gica completa pode ser vista no anexo A\n\nFigura 30: Exemplo de programa Ladder do caso de estudo\n\n\n\n80\n\nPara a criac?a?o do programa, se utilizou uma abordagem subdivi-\ndindo a matriz causa e efeito em linhas. Cada linha da matriz gerou um\ntrecho de co?digo, chamado de \u201dnet\u201d no ambiente de programac?a?o es-\npec??fico. Essa subdivisa?o em trechos distintos foi escolhida por facilitar\numa poss??vel correc?a?o de co?digo caso fosse encontrado algum erro.\n\n6.2 SIMULAC?A?O DA PLANTA\n\nPara a simulac?a?o da planta, foi utilizado o ambiente simulink do\nsoftware matlab. Essa escolha foi feita por facilitar o desenvolvimento\nda simulac?a?o da planta e possibilitar o desenvolvimento da planta no\nn??vel de abstrac?a?o necessa?rio, no entanto, outro software de simulac?a?o\npoderia ser utilizado dado que gravasse as informac?o?es de varia?veis da\nplanta simulada em servidor OPC.\n\nVisto que o programa de CLP executa uma das linhas da matriz\ncausa e efeito uma vez que um sinal correspondente e? ativado e que,\npara a realizac?a?o dos testes, e? necessa?rio a verificac?a?o dos sinais de\nsensores que chegam do campo e dos sinais enviados a? atuadores, a\nplanta simulada possui apenas algumas dina?micas cont??nuas, as quais\nsa?o importantes para a correta execuc?a?o do programa. A figura 31\napresenta uma parte do ambiente simulink com a simulac?a?o da planta.\n\nFigura 31: Exemplo de planta simulada no ambiente simulink\n\n\n\n81\n\n6.3 EXPERIMENTOS REALIZADOS E RESULTADOS OBTIDOS\n\nPara uma melhor visualizac?a?o dos testes sendo realizados, foi\ndesenvolvida uma representac?a?o gra?fica atrave?s da ferramenta WinCC.\nO objetivo deste sino?ptico desenvolvido e? apenas a visualizac?a?o, logo,\nna?o foram criadas entradas de dados ou comandos, apenas elementos de\nvisualizac?a?o foram utilizados. A figura 32 apresenta o sino?ptico criado.\n\nFigura 32: Superviso?rio criado para visualizac?a?o dos testes\n\nPara a validac?a?o da ferramenta, erros foram introduzidos no pro-\ngrama Ladder, e, em seguida, se observou se a ferramenta era capaz ou\nna?o de apontar a existe?ncia do erro. Erros foram introduzidos sistema-\nticamente em cada sec?a?o do co?digo a fim de se testar a capacidade de\nreconhecimento de diferentes erros. Para a demonstrac?a?o do funciona-\nmento da ferramenta, sera?o apresentados os erros inseridos no programa\ne em seguida o resultado gerado pela ferramenta e gravado no log.\n\n\u2022 Primeiro caso de teste: neste primeiro caso, o algoritmo res-\nponsa?vel por definir o correto funcionamento da votac?a?o 2oo3 no\nbloco de func?a?o visto na figura 30 foi alterado de acordo com o que\npode ser visto na figura 33. O resultado do teste, deve apresentar\n\n\n\n82\n\nFigura 33: Primeiro exemplo de mudanc?a realizada ao co?digo para\nrealizac?a?o de testes. A figura A representa o co?digo antes da mudanc?a\nenquanto a figura B representa a figura apo?s a mudanc?a.\n\nerro em todos os testes que envolverem a votac?a?o 2oo3. Como\nresultado no log, po?de-se observar erros nos testes que utilizavam\nas varia?veis PSHH014-A, PSHH014-B e PSHH014-C, assim como\npode ser visto na figura 34. Neste Log, cada ensaio e? utilizado\npara execuc?a?o de um observador e e? apresentado como uma si-\nmulac?a?o no Log. Cada simulac?a?o lida com um sinal de entrada\ne os respectivos sinais de sa??da como definido pela matriz C&amp;E\ne apresenta as varia?veis usadas nos testes, as entradas e sa??das,\nbem como uma breve sentenc?a relacionando o erro que ocorreu.\n\u201dPSHH\u201de? um sinal de entrada e que indica alta pressa?o, enquanto\n\u201dXY\u201dsa?o va?lvulas que devem ser fechadas ou abertas com a che-\ngada de um sinal \u201dPSHH\u201d. Os sinais PSHH- 014A, PSHH-014B\ne PSHH-014C sa?o, respectivamente, a As entradas de sinal A, B\ne C para o bloco de votac?a?o 2oo3. A partir do resultado apresen-\ntado no log, dos equipamentos envolvidos, dos sinais de campo\nenvolvidos, pode-se restringir poss??veis locais onde o co?digo falha\nem sua execuc?a?o.\n\n\u2022 Segundo caso de teste: para esse caso, utilizou-se o programa sem\na introduc?a?o de erros para se verificar se a ferramenta na?o gerava\nerros na?o existentes. O resultado do teste na?o deveria apresentar\n\n\n\n83\n\nFigura 34: Parte do log que apresenta a existe?ncia de erros na execuc?a?o\ndo teste\n\nnenhum erro gerado, apresentando somente testes realizados com\nsucesso. A figura 35 apresenta parte do log para o teste sem\nintroduc?a?o de erro.\n\n\u2022 Terceiro caso de teste: neste terceiro caso de teste, uma limitac?a?o\nexistente na metodologia sera? demonstrada. Devido ao fato de\na ferramenta trabalhar com leituras c??clicas do servidor OPC,\ne, esse realizar atualizac?o?es tambe?m c??clicas, e? poss??vel que dois\nsinais que surgem em ciclos diferentes no CLP sejam interpretados\ncomo tendo surgindo no mesmo ciclo dentro da ferramenta devido\na? alta velocidade de execuc?a?o do CLP e baixa taxa de atualizac?a?o\ndo servidor OPC. Para melhor clarificac?a?o, leva-se em relac?a?o\numa caso ja? apresentado, que encontra-se na figura 36\n\nCaso, o programa apresente um erro onde os sinais abrir \u201dven-\ntilac?a?o\u201de \u201dfechar segunda va?lvula\u201docorram dentro de um tempo\nmenor que o tempo de atualizac?a?o do servidor OPC, dois cami-\nnhos de execuc?a?o da rede de petri se abrem, permitindo que dois\nestados diferentes sejam alcanc?ados. Levando-se em considerac?a?o\nsomente os lugares P = p5, p11, abrir ventilac?a?o, fechar segunda\nva?lvula, Va?lv. 2 fechou antes da valv vent., va?lv. 2 fechou an-\ntes de 5 s, como marcac?a?o inicial M0=1,0,0,0,0,0 e ainda, que na\npro?xima leitura, a ferramenta adicione fichas de maneira a dei-\nxar o sistema com a seguinte marcac?a?o M1= 1,0,1, 1,0,0 as duas\nexecuc?o?es poss??veis sa?o:\n\n\n\n84\n\nFigura 35: Parte do log que apresenta somente testes realizados com\nsucesso\n\n\u2013 execuc?a?o da transic?a?o t12 e marcac?a?o final Mf=0 0,1,0,1,0\n\n\u2013 execuc?a?o da transic?a?o t4 levando a? marcac?a?o M2 = 0,1,0,1,0,0\ne depois da transic?a?o t9 levando o sistema a? marcac?a?o final\nMf = 0,0,0,0,0,1\n\nAmbas as marcac?o?es finais implicam erros no sistema, contudo,\ndevido ao recebimento simulta?neo dos dois sinais pelo servidor, a\nferramenta na?o pode apontar com exatida?o o erro ocorrido. Para\nesse caso, a ferramenta apresenta as duas possibilidades de erros\nao usua?rio no log. Para testar essa situac?a?o, o seguinte erro foi\nintroduzido no programa de CLP, assim como demonstrado na\nfigura 37. O resultado do log apresentado para o usua?rio pode\nser visto na figura 38.\n\n\u2022 Para que seja mantida a concisa?o do documento, na?o sera?o apre-\nsentados mais testes. Os testes escolhidos para apresentac?a?o neste\ndocumento sa?o aqueles que continham caracter??sticas pertinentes\npara a validac?a?o da ferramenta. Embora outros testes tenham\nsido realizados, eles na?o apresentam novidades relevantes de tal\nforma que sua abordagem aqui tornaria esta sec?a?o demasiada\nlonga.\n\n\n\n85\n\nFigura 36: Rede de petri correspondente a? nota 5\n\n6.4 COMENTA?RIOS FINAIS\n\nNeste cap??tulo, foi apresentada a aplicac?a?o de uma ferramenta\nconstru??da com base na metodologia proposta nesta dissertac?a?o. Foi\ntambe?m apresentado um estudo de caso utilizado para aplicar a meto-\ndologia e validar a ferramenta desenvolvida, assim como os resultados\nobtidos ao se aplicar a metodologia em questa?o ao estudo de caso. Tudo\naquilo desenvolvido para aplicac?a?o da metodologia desenvolvida, desde\no ambiente de simulac?a?o ate? a ferramenta esta?o dispon??veis em: http:\n//1drv.ms/1zfbUHv ou https://onedrive.live.com/redir?resid=\n8B54AFE170F06603!215405&amp;authkey=!AEOWYCqHbyKHato&amp;ithint=folder%\n\n2c.\n\n\n\n86\n\nFigura 37: Exemplo utilizado para o terceiro teste. A figura A re-\npresenta o co?digo antes da mudanc?a enquanto a figura B representa a\nfigura apo?s a mudanc?a.\n\nFigura 38: Parte do log para o terceiro teste.\n\n\n\n87\n\n7 CONCLUSA?O\n\nNeste trabalho foi abordado o estudo e a realizac?a?o automa?tica\nde testes em um forno utilizada na indu?stria de petro?leo e ga?s. Foi\ndesenvolvida uma nova metodologia para a realizac?a?o de testes base-\nada na utilizac?a?o de modelos formais constru??dos com redes de Petri.\nEsta abordagem se difere daquela atualmente utilizada ao definir auto-\nmaticamente os testes realizados utilizando como base os conteu?dos da\nmatriz causa e efeito, documento criado durante o desenvolvimento do\nprojeto, e executar os testes para posteriormente comparar os resulta-\ndos a?queles previstos pela matriz causa e efeito. Nesta metodologia, os\nrequisitos de projeto contidos na matriz causa e efeito sa?o transforma-\ndas em redes de Petri que tem como func?a?o a representac?a?o, atrave?s de\numa ferramenta formal, os mesmos requisitos. De posse dessas redes,\ntestes sa?o gerados e realizados de maneira a executar uma confere?ncia\ndo programa de CLP ja? existente. Os dados dos testes realizados sa?o\nutilizados para, atrave?s da execuc?a?o da rede de Petri, validar a execuc?a?o\nde cada teste. O resultado e? obtido atrave?s do estado alcanc?ado pela\nrede o que determina a correta ou na?o correta execuc?a?o por parte do\nCLP.\n\nFoi desenvolvida uma ferramenta a fim de validar a metodologia e\nrealizar testes sobre uma planta de uma forno utilizada pela Petrobras.\nCom essa ferramenta foram realizados testes sobre um CLP progra-\nmado cujo objetivo era seguir os requisitos impostos pela matriz causa\ne efeito. Esse programa de CLP podia ou na?o conter erros inseridos de\nmaneira a desrespeitar o correto funcionamento esperado. Nos testes\nrealizados, ao se inserir um erro que desrespeitava diretamente alguma\nrelac?a?o presente na matriz causa e efeito, esse erro era encontrado pela\nferramenta.\n\nAs principais contribuic?o?es deste trabalho sera?o relacionadas a\nseguir:\n\n\u2022 Definic?a?o de uma nova metodologia para realizac?a?o automa?tica\nde testes\n\n\u2022 Relacionamento entre requisitos da matriz de causa e efeito com\nmodelos em redes de petri\n\n\u2022 Desenvolvimento de uma ferramenta para validar a nova metodo-\nlogia\n\n\n\n88\n\nCom relac?a?o a utilizac?a?o de redes de Petri para se realizar tes-\ntes caixa preta de programas de CLP, vale lembrar que na?o existem\nregistros deste tipo de abordagem na literatura. A realizac?a?o de testes\nmostrou-se eficaz para encontrar erros do programa de CLP em relac?a?o\naos requisitos impostos pela matriz causa e efeito e essa metodologia\nmostra-se como uma boa aliada durante o desenvolvimento de um pro-\njeto de automac?a?o industrial podendo diminuir o tempo gasto na rea-\nlizac?a?o de testes e tambe?m evitando que um programa com erros chegue\na ser levado a campo para posterior descoberta dos erros. A utilizac?a?o\nde modelos baseados em redes de Petri adicionam um formalismo no\nprocesso de automac?a?o na?o encontrado anteriormente. Esse forma-\nlismo permitiu na?o somente o desenvolvimento da nova metodologia\ncomo permite tambe?m sua expansa?o para a aplicac?a?o de novas te?cnicas\nque se baseiam em modelos formais. Essa nova metodologia se insere\nna atual metodologia de desenvolvimento de projeto utilizada pela Pe-\ntrobras de maneira sutil, sem a alterac?a?o brusca da maneira com a qual\no projeto e? desenvolvido. Isso foi procurado para que a metodologia\npossu??sse uma maior aceitac?a?o por parte dos engenheiros responsa?veis.\nEste trabalho foi submetido para IFAC Workshop on Automatic Con-\ntrol in Offshore Oil and Gas Production sob o t??tulo:Automatic Test of\nSafety Specifications for PLC Programs in The Oil and Gas Industry\n\n7.1 DIRETRIZES PARA TRABALHOS FUTUROS\n\nA metodologia apresentada neste trabalho incluiu a utilizac?a?o\nde um dos documentos utilizados durante um projeto de automac?a?o.\nOutros documentos de grande importa?ncia ainda podem ser utilizados\nna criac?a?o e realizac?a?o de testes dos softwares de CLP. Ale?m disso,\na expansa?o do trabalho ja? realizado permite a criac?a?o de uma ferra-\nmenta mais abrangente e que pode se fazer u?til em projetos de outra\nnatureza. Levando isso em considerac?a?o, alguns temas a serem investi-\ngados futuramente, com o objetivo de se criar novos me?todos de teste\nou aperfeic?oar os testes realizados, sa?o propostos:\n\n\u2022 Expansa?o dos observadores dispon??veis a fim de se abranger mais\nprojetos.\n\n\u2022 Formalizac?a?o de outros documentos existente no projeto de au-\ntomac?a?o da Petrobras como o memorial descritivo para utilizac?a?o\nconjunta na realizac?a?o de testes.\n\n\u2022 Realizac?a?o dos testes utilizando como base, na?o o CLP progra-\n\n\n\n89\n\nmado, mas o Diagrama lo?gico para que seja realizada uma va-\nlidac?a?o pre?via a programac?a?o do CLP, utilizando ate? model chec-\nking e economizando assim, tempo de projeto.\n\n\u2022 Introduc?a?o da ferramenta em um ambiente integrado, com especi-\nalizac?o?es para a inserc?a?o de informac?o?es de projeto, de dados para\na simulac?a?o e para verificac?a?o de programas de CLP na indu?stria\nde petro?leo e ga?s.\n\n\n\n90\n\n\n\n91\n\nREFERE?NCIAS\n\nABID, N. et al. Verification of Real-Time Specification Patterns on\nTime Transition Systems. [S.l.], 2011.\n\nADAM, N. R.; ATLURI, V.; HUANG, W.-K. Modeling and analysis\nof workflows using petri nets. Journal of Intelligent Information\nSystems, Springer, v. 10, n. 2, p. 131\u2013158, 1998.\n\nBAIER, C.; KATOEN, J.-P. et al. Principles of model checking. [S.l.]:\nMIT press Cambridge, 2008.\n\nBEIZER, B. Software Testing Techniques. New York: Van Nostrand\nReinhold Company, 1990.\n\nBERTHOMIEU, B. et al. Fiacre: an intermediate language for model\nverification in the topcased environment. In: ERTS 2008. [S.l.: s.n.],\n2008.\n\nBERTHOMIEU, P.-O. R. e. F. V. B. The tool tina - construction\nof abstract state spaces for petri nets and time petri nets. European\nCongress on Embedded Real Time Software, 2004.\n\nBLACK, R. Pragmatic Software Testing: Becoming an Effective and\nEfficient Test Professional. New York: [s.n.], 2007.\n\nBURNSTEIN, I. Practical Software Testing. [S.l.]: Springer-Verlag,\n2003.\n\nCOMISSa?O DE NORMAS Te?CNICAS. Norma te?cnica N-1883. [S.l.]:\nPetrobras, 2002.\n\nCOMISSa?O DE NORMAS Te?CNICAS. Norma te?cnica N-2595. [S.l.]:\nPetrobras, 2012.\n\nFARINES, J.; QUEIROZ, M. H.; CARPES, A. M. M. A model-driven\nengineering approach to formal verification of plc programs. Emerging\nTechnologies and Factory Automation, p. 1\u20138, 2011.\n\nFRANCe?S, C. Introduc?a?o a? redes de Petri. [S.l.], 2003.\n\nGo?IS, G. M. Um Sistema Tutor Multi-Agentes no Dom??nio de Redes\nde Petri. Dissertac?a?o (Mestrado) \u2014 UFPA, Campina Grande, 2000.\n\n\n\n92\n\nHAMADI, R.; BENATALLAH, B. A. A petri net-based model for web\nservice composition. Australian Computer Society, v. 14, 2003.\n\nHAN, R. et al. A petri net theory-based method for modeling web\nservice-based systems. p. 1\u20137, 2008.\n\nHOFFMAN, D.; STROOPER, P. A case study in class testing.\nCASCON, p. 472\u2013782, 1993.\n\nJACOBSON, I. et al. The unified software development process. [S.l.]:\nAddison-Wesley Reading, 1999.\n\nJu?NIOR, R. S. Diagno?stico e tratamento de falhas cr??ticas em sistemas\ninstrumentados de seguranc?a. Dissertac?a?o (Mestrado) \u2014 USP, Sa?o\nPaulo, 2011.\n\nJOUAULT, F.; KURTEV, I. Transforming models with atl. In:\nSPRINGER. Satellite Events at the MoDELS 2005 Conference. [S.l.],\n2006. p. 128\u2013138.\n\nKANESHIRO, P. J. I. et al. Modeling of collision resolution algorithm\nin lonworks networks. p. 743\u2013749, 2007.\n\nKARHELA, T.; VILLBERG, A.; NIEMSTO?, H. Open ontology-based\nintegration platform for modeling and simulation in engineering.\nInternational Journal of Modeling, Simulation, and Scientific\nComputing, World Scientific, v. 3, n. 02, 2012.\n\nKIEPUSZEWSKI, B.; HOFSTEDE, A. H. ter; AALST, W. M.\nvan der. Fundamentals of control flow in workflows. Acta Informatica,\nSpringer, v. 39, n. 3, p. 143\u2013209, 2003.\n\nKUHN, D. R.; KACKER, R. N.; LEI, Y. Practical combinatorial\ntesting. [S.l.], 2010. v. 800, 142 p.\n\nKUHN, D. R.; WALLACE, D. R.; GALLO, J. A. Software\nfault interactions and implications for software testing. Software\nEngineering, IEEE Transactions on, IEEE, v. 30, n. 6, p. 418\u2013421,\n2004.\n\nLEE, J.-S.; ZHOU, M.-C.; HSU, P.-L. An application of petri nets\nto supervisory control for human-computer interactive systems.\nIndustrial Electronics, IEEE Transactions on, IEEE, v. 52, n. 5, p.\n1220\u20131226, 2005.\n\n\n\n93\n\nLI, Z.; ZHOU, M. Control of elementary and dependent siphons in\npetri nets and their application. Systems, Man and Cybernetics, Part\nA: Systems and Humans, IEEE Transactions on, IEEE, v. 38, n. 1, p.\n133\u2013148, 2008.\n\nMACIEL, P. R.; LINS, R. D.; CUNHA, P. R. Introduc?a?o a?s redes de\nPetri e aplicac?o?es. [S.l.]: UNICAMP-Instituto de Computacao, 1996.\n\nMALDONADO, J. C. Crite?rios potenciais usos: Uma contribuic?a?o ao\nteste estrutural de software. Tese (Doutorado), 1991.\n\nMALDONADO, J. C. et al. Introduc?ao ao teste de software. Sa?o\nCarlos, 2004.\n\nMCGREGOR, J. D. Functional testing of classes. San Francisco, 1994.\n\nMERZ, S. Model checking: A tutorial overview. In: Modeling and\nverification of parallel processes. [S.l.]: Springer, 2001. p. 3\u201338.\n\nMORALES, R. A. G.; MELO, J. G.; MIYAGI, P. E. Diagnosis and\ntreatment of faults in productive systems based on bayesian networks\nand petri net. In: IEEE. Automation Science and Engineering,\n2007. CASE 2007. IEEE International Conference on. [S.l.], 2007. p.\n357\u2013362.\n\nMURATA, T. Petri nets: Properties, analysis and applications.\nProceedings of the IEEE, IEEE, v. 77, n. 4, p. 541\u2013580, 1989.\n\nMYERS, G. J. The art of software testing. New York: Wiley, 1979.\n\nNASSAR, M. G. V. et al. Modeling and analysing of the material\nentry flow system in a pickling line process using petri net. In: ABCM\nSymposium Series in Mechatronics. [S.l.: s.n.], 2008. v. 3, p. 444\u2013453.\n\nOLIVEIRA, C. Simulac?a?o de redes de petri em ambiente java. 2006.\n\nOLIVEIRA LEANDRO DIAS DA SILVA, A. P. K. C. G. Kezia de\nV. Uma abordagem para gerac?a?o e execuc?a?o de casos de teste em\nprogramas de sistemas instrumentados de seguranc?a. CBA, 2012.\n\nPAKONEN, A. et al. A toolset for model checking of plc software.\np. 1\u20136, 2013.\n\nPATTON, R. Software testing. [S.l.]: Sams Indianapolis, 2001.\n\n\n\n94\n\nPERRY, D. E.; KAISER, G. E. Adequate testing and object-oriented\nprogramming. Journal of Object-Oriented Programming, SIGS\nPublications, v. 2, n. 5, p. 13\u201319, 1990.\n\nPRESSMAN, R. S. Software Engineering - A Practitioner?s Approach.\n[S.l.]: McGraw-Hill, 1997.\n\nSILVA, M. K. Metodologia para detecc?a?o e tratamento de falhas em\nsistemas de manufatura atrave?s de rede de Petri. Tese (Doutorado) \u2014\nUSP, Sa?o Paulo, 2002.\n\nSILVA, M. K. Pre?-Detalhamento da Instrumentac?a?o e Automac?a?o\nde um Forno Industrial de um Complexo Petroqu??mico. Dissertac?a?o\n(Mestrado) \u2014 DAS/UFSC, Floriano?polis, 2009.\n\nSKOGDALE, J. E.; SMOGELI, O. Looking Forward-Reliability of\nSafety Critical Control Systems on Offshore Drilling Vessels. [S.l.],\n2011.\n\nVERNADAT, F. et al. The topcased project-a toolkit in open-source\nfor critical applications and system development. Data Systems In\nAerospace (DASIA), Berlin, Germany, v. 22, n. 05, p. 2006\u201325, 2006.\n\nXU, X. et al. A novel modeling design method for automated storage\nand retrieval system based on petri nets. p. 2046\u20132051, 2007.\n\nYOO, T.; JEONG, B.; CHO, H. A petri nets based functional\nvalidation for services composition. Expert Systems with Applications,\nElsevier, v. 37, n. 5, p. 3768\u20133776, 2010.\n\nZURAWSKI, R.; ZHOU, M. Petri nets and industrial applications: A\ntutorial. Industrial Electronics, IEEE Transactions on, IEEE, v. 41,\nn. 6, p. 567\u2013583, 1994.\n\nZURAWSKI, R.; ZHOU, M. Software fault interactions and\nimplications for software testing. IEEE Trans. on Software\nEngineering, v. 30, 2004.\n\n\n\nAPE?NDICE A -- Co?digo Ladder Utilizado para Validac?a?o\n\n\n\n\n\n97\n\n\n\n98\n\n\n\n99\n\n\n\n100\n\n\n\n101\n\n\n\n102\n\n\n\n103\n\n\n\n104\n\n\n\n105\n\n\n\n106\n\n\n\nAPE?NDICE B -- Matriz Causa &amp; Efeito Utilizado no Estudo\nde Caso\n\n\n\n\n\n109"}]}}}