{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.11161"}, {"@name": "filename", "#text": "16363_RiserView_Final_4.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "JO\u00c3O LUIZ BERNARDES J\u00daNIOR\n\nDesenvolvimento de um ambiente para visualiza\u00e7\u00e3o\n\ntridimensional da din\u00e2mica de risers\n\nDisserta\u00e7\u00e3o apresentada \u00e0 Escola Polit\u00e9cnica da\n\nUniversidade de S\u00e3o Paulo para obten\u00e7\u00e3o do\n\nt\u00edtulo de Mestre em Engenharia.\n\n\u00c1rea de Concentra\u00e7\u00e3o: Engenharia Mec\u00e2nica\nOrientador: Prof. Dr. Cl\u00f3vis de Arruda Martins\n\nS\u00e3o Paulo\n2004\n\n\n\nFICHA CATALOGR\u00c1FICA\n\nBernardes J\u00fanior, Jo\u00e3o Luiz\nDesenvolvimento de um ambiente para visualiza\u00e7\u00e3o tridimen-\n\nsional da din\u00e2mica de risers / J.L. Bernardes J\u00fanior. -- S\u00e3o Paulo,\n2005.\n\n202 p.\n\nDisserta\u00e7\u00e3o (Mestrado) - Escola Polit\u00e9cnica da Universidade\nde S\u00e3o Paulo. Departamento de Engenharia Mec\u00e2nica.\n\nOrientador: Prof. Dr. Cl\u00f3vis de Arruda Martins\n\n1.Detec\u00e7\u00e3o de colis\u00f5es 2.Engenharia de programa\u00e7\u00e3o 3.Rea-\nlidade virtual 4.Risers 5.Vizualiza\u00e7\u00e3o cient\u00edfica 6.V\u00f3rtices\nI.Universidade de S\u00e3o Paulo. Escola Polit\u00e9cnica. Departamento\nde Engenharia Mec\u00e3nica II.t.\n\n\n\nFOLHA DE APROVA\u00c7\u00c3O\n\nJo\u00e3o Luiz Bernardes J\u00fanior\n\nDesenvolvimento de um ambiente\n\npara visualiza\u00e7\u00e3o tridimensional\n\nda din\u00e2mica de risers\n\nDisserta\u00e7\u00e3o apresentada \u00e0 Escola Polit\u00e9cnica\n\nda Universidade de S\u00e3o Paulo para obten\u00e7\u00e3o\n\ndo t\u00edtulo de Mestre em Engenharia.\n\nProf. Dr. _______________________________________________________________\n\nInstitui\u00e7\u00e3o: _______________________________ Assinatura: ____________________\n\nProf. Dr. _______________________________________________________________\n\nInstitui\u00e7\u00e3o: _______________________________ Assinatura: ____________________\n\nProf. Dr. _______________________________________________________________\n\nInstitui\u00e7\u00e3o: _______________________________ Assinatura: ____________________\n\n\n\nDEDICAT\u00d3RIA\n\nDedico este trabalho a meus pais, Jo\u00e3o Luiz e Diana,\n\npor seu amor, paci\u00eancia e apoio persistentes e inef\u00e1veis\n\nao longo dos anos, sem os quais a realiza\u00e7\u00e3o deste\n\ntrabalho, desde seu in\u00edcio, teria sido imposs\u00edvel.\n\n\n\nAGRADECIMENTOS\n\nAo Prof. Dr. Cl\u00f3vis de Arruda Martins, por todas as li\u00e7\u00f5es ao longo dos anos e por sua\n\npaci\u00eancia, camaradagem e apoio durante sua inestim\u00e1vel orienta\u00e7\u00e3o deste trabalho.\n\nAos membros do Grupo de Pesquisas de Jogos do Interlab-USP, por sua contribui\u00e7\u00e3o\n\nem diversas quest\u00f5es relacionadas a Engenharia de Software, Computa\u00e7\u00e3o Gr\u00e1fica e\n\nHardware gr\u00e1fico pertinentes \u00e0 elabora\u00e7\u00e3o deste trabalho.\n\nAo Prof. Dr. J\u00falio Romano Meneghini, por seu aux\u00edlio na \u00e1rea de din\u00e2mica dos fluidos.\n\nAo Prof. Dr. Marcelo Knorich Zuffo, por ter me introduzido a t\u00e9cnicas de visualiza\u00e7\u00e3o\n\ncient\u00edfica e principalmente ao VTK.\n\nA Escola Polit\u00e9cnica da Universidade de S\u00e3o Paulo, principalmente a seu departamento\n\nde Engenharia Mec\u00e2nica, por permitir a realiza\u00e7\u00e3o deste trabalho em seu programa de\n\nmestrado.\n\n\u00c0 Coordena\u00e7\u00e3o de Aperfei\u00e7oamento de Pessoal de N\u00edvel Superior do Minist\u00e9rio da\n\nEduca\u00e7\u00e3o, por conceder bolsa de mestrado para a realiza\u00e7\u00e3o deste trabalho.\n\n\n\nRESUMO\n\nBERNARDES JR., J. L. Desenvolvimento de um ambiente para visualiza\u00e7\u00e3o tridimensional\nda din\u00e2mica de risers. 2004. 202 f. Disserta\u00e7\u00e3o (Mestrado) - Escola Polit\u00e9cnica, Universidade\nde S\u00e3o Paulo, S\u00e3o Paulo, 2004.\n\nA import\u00e2ncia da explora\u00e7\u00e3o mar\u00edtima de petr\u00f3leo, em especial para o Brasil, \u00e9\nindiscut\u00edvel e risers s\u00e3o estruturas essenciais para essa atividade. Uma melhor\ncompreens\u00e3o da din\u00e2mica dessas estruturas e dos esfor\u00e7os a que est\u00e3o submetidas vem\nresultando de pesquisa constante na \u00e1rea, pesquisa que gera um grande volume de\ndados, freq\u00fcentemente descrevendo fen\u00f4menos de dif\u00edcil compreens\u00e3o. Este trabalho\ndescreve o desenvolvimento de um ambiente que combina t\u00e9cnicas de realidade virtual\n(como ambientes 3D, navega\u00e7\u00e3o e estereoscopia) e visualiza\u00e7\u00e3o cient\u00edfica (como\nmapeamento de cores, deforma\u00e7\u00f5es e glifos) para facilitar a visualiza\u00e7\u00e3o desses dados.\nO ambiente, batizado como RiserView, permite a montagem de cenas tridimensionais\ncompostas por risers, relevo do solo, superf\u00edcie mar\u00edtima, embarca\u00e7\u00f5es, b\u00f3ias e outras\nestruturas, cada um com sua din\u00e2mica pr\u00f3pria. Permite ainda a visualiza\u00e7\u00e3o do\nescoamento para que a forma\u00e7\u00e3o de v\u00f3rtices na vizinhan\u00e7a dos risers e a intera\u00e7\u00e3o\nfluido-mec\u00e2nica resultante possam ser estudadas. O usu\u00e1rio pode controlar par\u00e2metros\nda visualiza\u00e7\u00e3o de cada elemento e da anima\u00e7\u00e3o da cena, bem como navegar livremente\npor ela. Foi desenvolvido tamb\u00e9m um algoritmo de baixo custo computacional (gra\u00e7as a\nsimplifica\u00e7\u00f5es poss\u00edveis devido \u00e0 natureza do problema) para detec\u00e7\u00e3o e exibi\u00e7\u00e3o em\ntempo real de colis\u00f5es entre risers. O Processo Unificado foi adaptado para servir como\nmetodologia para o projeto e implementa\u00e7\u00e3o do aplicativo. O uso do VTK (API gr\u00e1fica\ne de visualiza\u00e7\u00e3o cient\u00edfica) e do IUP (API para desenvolvimento de interfaces com o\nusu\u00e1rio) simplificou o desenvolvimento, principalmente para produzir um aplicativo\nport\u00e1vel para MS-Windows e Linux. Como op\u00e7\u00f5es de projeto, a visualiza\u00e7\u00e3o cient\u00edfica\ne a velocidade na renderiza\u00e7\u00e3o das cenas s\u00e3o privilegiadas, ao inv\u00e9s do realismo e da\nagilidade na intera\u00e7\u00e3o com o usu\u00e1rio. As conseq\u00fc\u00eancias dessas escolhas, bem como\nalternativas, s\u00e3o discutidas no trabalho. O uso do VTK e, atrav\u00e9s dele, do OpenGL\npermite que o aplicativo fa\u00e7a uso dos recursos dispon\u00edveis em placas gr\u00e1ficas\ncomerciais para aumentar sua performance. Em sua vers\u00e3o atual a tarefa mais custosa\npara o RiserView \u00e9 a atualiza\u00e7\u00e3o das posi\u00e7\u00f5es de risers, principalmente descritos no\ndom\u00ednio da freq\u00fc\u00eancia, mas o trabalho discute aprimoramentos relativamente simples\npara minimizar esse problema. Apesar desses (e de outros) aprimoramentos poss\u00edveis,\ndiscutidos no trabalho, o ambiente mostra-se bastante adequado \u00e0 visualiza\u00e7\u00e3o dos\nrisers e de sua din\u00e2mica bem como de fen\u00f4menos e elementos a eles associados.\n\nPalavras-chave: Detec\u00e7\u00e3o de Colis\u00f5es. Engenharia de Programa\u00e7\u00e3o. Realidade Virtual.\nRisers. Visualiza\u00e7\u00e3o Cient\u00edfica. V\u00f3rtices.\n\n\n\nABSTRACT\n\nBERNARDES JR., J. L. Development of an environment for tridimensional\nvisualization of riser dynamics. 2004. 202 f. Dissertation (Master's) - Escola\nPolit\u00e9cnica, Universidade de S\u00e3o Paulo, S\u00e3o Paulo, 2004.\n\nThe importance of offshore oil exploration, especially to Brazil, cannot be argued and\nrisers are crucial structures for this activity. A better understanding of the dynamics of\nthese structures and of the efforts to which they are subject has been resulting from\nconstant research in the field, research that generates a large volume of data, often\ndescribing phenomena of difficult comprehension. This work describes the development\nof a software environment that combines elements of virtual reality (3D environments,\nnavigation, stereoscopy) and scientific visualization techniques (such as color mapping,\ndeformations and glyphs) to improve the understanding and visualization of these data.\nThe environment, christened RiserView, allows the composition of tridimensional\nscenes including risers, the floor and surface of the ocean and ships, buoys and other\nstructures, each with its own dynamics. It also allows the visualization of the flow in the\nneighborhood of the risers so that vortex shedding and the resulting fluid-mechanic\ninteractions may be studied. The user may control parameters of the scene animation\nand of the visualization for each of its elements, as well as navigate freely within the\nscene. An algorithm of low computational cost (thanks to simplifications possible due to\nthe nature of the problem), for the detection and exhibition of collisions between risers\nin real time, was also developed. The Unified Process was adapted to guide the\nsoftware's project and implementation. The use of VTK (a scientific visualization and\ngraphics API) and IUP (a user interface development API) simplified the development,\nespecially the effort required to build an application portable to MS-Windows and\nLinux. As project choices, scientific visualization and the speed in rendering scenes in\nreal time were given higher priority than realism and the agility in the user interaction,\nrespectively. The consequences of these choices, as well as some alternatives, are\ndiscussed. The use of VTK and, through it, OpenGL, allows the application to access\nfeatures available in most commercial graphics cards to increase performance. In its\ncurrent version, the most costly task for RiserView are the calculations required to\nupdate riser positions during animation, especially for risers described in the frequency\ndomain, but the work discusses relatively simple improvements to minimize this\nproblem. Despite these (and other) possible improvements discussed in the work, the\napplication proves quite adequate to the visualization of risers and their dynamics, as\nwell as of associate elements and phenomena.\n\nKeywords: Collision Detection. Risers. Scientific Visualization. Software Engineering. Virtual\nReality. Vortices.\n\n\n\nLISTA DE ILUSTRA\u00c7\u00d5ES\n\nFigura 1 - Entradas e sa\u00eddas do RiserView ............................................................... 19\n\nFigura 2 - Produ\u00e7\u00e3o de petr\u00f3leo no Brasil ................................................................ 28\n\nFigura 3 - Evolu\u00e7\u00e3o da produ\u00e7\u00e3o em \u00e1guas profundas .............................................. 28\n\nFigura 4 - Risers ........................................................................................................ 31\n\nFigura 5 - V\u00f3rtices .................................................................................................... 33\n\nFigura 6 - Mapeamento de cores sobre um riser no RiserView ............................... 40\n\nFigura 7 - Iso-superf\u00edcies na visualiza\u00e7\u00e3o de v\u00f3rtices .............................................. 40\n\nFigura 8 - Uso de glifos ............................................................................................ 42\n\nFigura 9 - Linhas de corrente .................................................................................... 42\n\nFigura 10 - Estereoscopia ......................................................................................... 51\n\nFigura 11 - Elementos da UML ................................................................................ 60\n\nFigura 12 - Exemplo de diagrama de classes em UML ............................................ 61\n\nFigura 13 - Uma pipeline gen\u00e9rica com quatro m\u00f3dulos .......................................... 67\n\nFigura 14 - Aliasing .................................................................................................. 72\n\nFigura 15 - Artefato: diagrama de casos de uso de cria\u00e7\u00e3o de cena ......................... 113\n\n\n\nFigura 16 - Artefato: diagrama de casos de uso de controle de exibi\u00e7\u00e3o ................. 114\n\nFigura 17 - Artefato: diagrama de casos de uso de visualiza\u00e7\u00e3o .............................. 114\n\nFigura 18 - Artefato: diagrama de casos de uso de anima\u00e7\u00e3o .................................. 115\n\nFigura 19 - Artefato: diagrama de casos de uso de navega\u00e7\u00e3o ................................. 115\n\nFigura 20 - Artefato: esbo\u00e7o de interface ................................................................. 119\n\nFigura 21 - Artefato: diagrama de subsistemas ........................................................ 123\n\nFigura 22 - Artefato: diagrama de classes do MVC ................................................. 125\n\nFigura 23 - Artefato: diagrama de classes do modelo (agrega\u00e7\u00f5es) ......................... 127\n\nFigura 24 - Artefato: diagrama de classes do modelo (generaliza\u00e7\u00f5es) ................... 127\n\nFigura 25 - Artefato: diagrama de atividades do la\u00e7o principal ............................... 129\n\nFigura 26 - Artefato: diagrama de seq\u00fc\u00eancia do la\u00e7o principal ................................ 131\n\nFigura 27 - Artefato: diagrama de classes dos pares de colis\u00e3o ............................... 133\n\nFigura 28 - Pares de colis\u00e3o ...................................................................................... 146\n\n\n\nLISTA DE TABELAS\n\nTabela 1 - Testes de stress: capacidade de processamento ....................................... 141\n\nTabela 2 - Testes de stress: processamento gr\u00e1fico ................................................... 144\n\nTabela 3 - Detec\u00e7\u00e3o de colis\u00f5es ................................................................................ 148\n\n\n\nSUM\u00c1RIO\n\n1. INTRODU\u00c7\u00c3O ..................................................................................... 16\n\n1.1. Objetivos .......................................................................................... 17\n\n1.2. Contexto e Motiva\u00e7\u00e3o ..................................................................... 20\n\n1.3. Metodologia ..................................................................................... 23\n\n1.4. Estrutura do Trabalho ................................................................... 24\n\n2. REVIS\u00c3O BIBLIOGR\u00c1FICA............................................................. 26\n\n2.1. Risers e a Explora\u00e7\u00e3o Mar\u00edtima de Petr\u00f3leo ............................... 27\n\n2.1.1. Risers............................................................................................................ 29\n\n2.1.2. V\u00f3rtices ........................................................................................................ 32\n\n2.2. Computa\u00e7\u00e3o Gr\u00e1fica e Visualiza\u00e7\u00e3o Cient\u00edfica ........................... 33\n\n2.2.1. Breve Hist\u00f3rico............................................................................................ 36\n\n2.2.2. T\u00e9cnicas de Visualiza\u00e7\u00e3o Cient\u00edfica .......................................................... 38\n\n2.2.3. Anima\u00e7\u00e3o ..................................................................................................... 43\n\n2.3. Realidade Virtual e Ambientes Virtuais....................................... 44\n\n\n\n2.3.1. Breve Hist\u00f3rico............................................................................................ 48\n\n2.3.2. Sensa\u00e7\u00e3o de Profundidade e Estereoscopia .............................................. 50\n\n2.3.3. Uso destas T\u00e9cnicas na Ind\u00fastria do Petr\u00f3leo .......................................... 52\n\n2.4. Orienta\u00e7\u00e3o a Objetos, Metodologia de Projeto e UML. ............. 54\n\n2.4.1. Orienta\u00e7\u00e3o a Objetos .................................................................................. 56\n\n2.4.2. A Unified Modeling Language (UML)...................................................... 59\n\n2.5. Padr\u00f5es de Projeto e Arquitetura ................................................. 62\n\n2.6. Portabilidade ................................................................................... 65\n\n2.7. A Pipeline de Renderiza\u00e7\u00e3o, Anti-Aliasing e Texturas ................ 66\n\n2.7.1. A Pipeline de Renderiza\u00e7\u00e3o........................................................................ 68\n\n2.7.2. Anti-Aliasing................................................................................................ 71\n\n2.7.3. Texturas ....................................................................................................... 74\n\n2.8. Detec\u00e7\u00e3o de Colis\u00e3o ........................................................................ 75\n\n3. TECNOLOGIA ..................................................................................... 80\n\n3.1. Processo Unificado.......................................................................... 81\n\n3.1.1. Vantagens e Desvantagens ......................................................................... 81\n\n\n\n3.1.2. Defini\u00e7\u00e3o e Hist\u00f3rico................................................................................... 83\n\n3.1.3. Fases, Itera\u00e7\u00f5es, Etapas e Artefatos no Processo Unificado ................... 86\n\n3.2. Bibliotecas........................................................................................ 91\n\n3.2.1. O Visualization Toolkit................................................................................ 93\n\n3.2.2. IUP - Interface com o Usu\u00e1rio Port\u00e1vel.................................................... 96\n\n3.2.3. Alternativas Pesquisadas............................................................................ 99\n\n3.3. Shaders ........................................................................................... 102\n\n4. A METODOLOGIA E O RISERVIEW ........................................... 104\n\n4.1. Customiza\u00e7\u00e3o da Metodologia..................................................... 105\n\n4.2. Itera\u00e7\u00f5es ......................................................................................... 107\n\n4.3. Captura de Requerimentos.......................................................... 108\n\n4.3.1. Descri\u00e7\u00e3o dos Requerimentos .................................................................. 109\n\n4.3.2. Atores ......................................................................................................... 111\n\n4.3.3. Diagramas de Casos de Uso ..................................................................... 112\n\n4.3.4. Descri\u00e7\u00e3o dos Casos de Uso...................................................................... 116\n\n4.3.5. Requerimentos Especiais.......................................................................... 117\n\n\n\n4.3.6. Gloss\u00e1rio .................................................................................................... 117\n\n4.3.7. Esbo\u00e7o da Interface .................................................................................. 118\n\n4.4. Projeto............................................................................................ 119\n\n4.4.1. As APIs....................................................................................................... 122\n\n4.4.2. O Padr\u00e3o Model-View-Controller........................................................... 123\n\n4.4.3. O Modelo ................................................................................................... 125\n\n4.4.4. O La\u00e7o Principal ....................................................................................... 128\n\n4.4.5. Detec\u00e7\u00e3o de Colis\u00e3o .................................................................................. 132\n\n4.5. Implementa\u00e7\u00e3o e Testes ............................................................... 134\n\n5. RESULTADOS.................................................................................... 135\n\n5.1. Testes de Caixa-Preta ................................................................... 136\n\n5.2. Testes de Stress .............................................................................. 137\n\n5.2.1. Capacidade de Processamento................................................................. 139\n\n5.2.2. Processamento Gr\u00e1fico............................................................................. 142\n\n5.3. Detec\u00e7\u00e3o de Colis\u00f5es ..................................................................... 144\n\n5.4. Portabilidade ................................................................................. 148\n\n\n\n6. CONCLUS\u00d5ES ................................................................................... 150\n\n6.1. Performance .................................................................................. 152\n\n6.1.1. Atualiza\u00e7\u00e3o dos Risers .............................................................................. 152\n\n6.1.2. Anti-Aliasing.............................................................................................. 156\n\n6.1.3. Cenas Complexas ...................................................................................... 157\n\n6.1.4. Detec\u00e7\u00e3o de Colis\u00f5es ................................................................................. 159\n\n6.1.5. Paralelismo ................................................................................................ 160\n\n6.2. Visualiza\u00e7\u00e3o e Interface ............................................................... 161\n\n6.2.1. Passo de Tempo ......................................................................................... 161\n\n6.2.2. Realismo..................................................................................................... 164\n\n6.2.3. Visualiza\u00e7\u00e3o ............................................................................................... 165\n\n6.2.4. Navega\u00e7\u00e3o .................................................................................................. 166\n\n6.3. Tecnologias .................................................................................... 167\n\nREFER\u00caNCIAS BIBLIOGR\u00c1FICAS .................................................. 170\n\nAP\u00caNDICE A - CASOS DE USO ......................................................... 176\n\nAP\u00caNDICE B - GLOSS\u00c1RIO PARA METODOLOGIA .................. 189\n\n\n\nAP\u00caNDICE C - BUGS E APRIMORAMENTOS ............................... 194\n\nC.1. Bugs ............................................................................................... 194\n\nC.2. Aprimoramentos .......................................................................... 198\n\nAP\u00caNDICE D - CONTE\u00daDOS DO CD ANEXO ................................ 201\n\n\n\n16\n\n1. INTRODU\u00c7\u00c3O\n\nComo seu t\u00edtulo explicita, este trabalho consiste no \"projeto e desenvolvimento\n\nde um ambiente para a visualiza\u00e7\u00e3o em tr\u00eas dimens\u00f5es da din\u00e2mica de risers\". Neste\n\ncap\u00edtulo inicial esta afirma\u00e7\u00e3o \u00e9 explicada de forma mais clara. Embora s\u00f3 caiba \u00e0\n\nintrodu\u00e7\u00e3o uma abordagem de teor mais geral, que \u00e9 aprofundada nos pr\u00f3ximos\n\ncap\u00edtulos, seu objetivo \u00e9 fornecer ao leitor uma imagem bem definida do que este\n\ntrabalho se prop\u00f5e a fazer, de quais s\u00e3o seus objetos de interesse, do porqu\u00ea de sua\n\nexecu\u00e7\u00e3o bem como da maneira em que esta execu\u00e7\u00e3o \u00e9 realizada.\n\nNa primeira se\u00e7\u00e3o deste cap\u00edtulo os objetivos do trabalho, que problema que este\n\nse presta a resolver, s\u00e3o mais bem detalhados. Em seguida \u00e9 descrito o contexto em que\n\neste trabalho se insere. Este contexto \u00e9 importante n\u00e3o s\u00f3 para que se compreenda\n\nalgumas das decis\u00f5es tomadas durante o projeto, como tamb\u00e9m para explicar a sua\n\nmotiva\u00e7\u00e3o.\n\nA metodologia utilizada, ou seja, o modo como o trabalho \u00e9 realizado, \u00e9\n\ndiscutida em seguida e, por fim, a estrutura do trabalho \u00e9 apresentada, explicitando a\n\nforma como seu conte\u00fado est\u00e1 organizado nos cap\u00edtulos seguintes.\n\nComo o primeiro par\u00e1grafo afirma, j\u00e1 a partir desta pr\u00f3xima se\u00e7\u00e3o (que descreve\n\nos objetivos) s\u00e3o discutidos neste cap\u00edtulo diversos temas que ser\u00e3o retomados com\n\n\n\n17\n\nmais profundidade em outros pontos do trabalho. Quando isso ocorrer, o ponto em que\n\nesta discuss\u00e3o mais aprofundada ocorre ser\u00e1 citado aqui.\n\n1.1. Objetivos\n\nO objeto de maior interesse neste trabalho s\u00e3o os risers. Embora essas estruturas\n\nsejam discutidas com mais detalhe em 2.1, a discuss\u00e3o dos objetivos e motiva\u00e7\u00e3o deste\n\ntrabalho faz necess\u00e1ria a sua defini\u00e7\u00e3o. Risers s\u00e3o estruturas tubulares utilizadas na\n\nexplora\u00e7\u00e3o mar\u00edtima de petr\u00f3leo para fazer a liga\u00e7\u00e3o entre os po\u00e7os, no solo oce\u00e2nico, e\n\nas plataformas ou navios na superf\u00edcie.\n\nDurante seu uso, essas estruturas est\u00e3o sujeitas a diversos esfor\u00e7os internos e\n\nexternos. Estes \u00faltimos s\u00e3o causados principalmente por fatores de origem ambiental,\n\ncomo ondas e correntes mar\u00edtimas, que por sua vez causam movimentos na plataforma e\n\npodem causar esteiras de v\u00f3rtices ao redor dos risers (v\u00f3rtices s\u00e3o discutidos na\n\nsubse\u00e7\u00e3o 2.1.2). Estes esfor\u00e7os a que o riser est\u00e1 submetido s\u00e3o de natureza bastante\n\ncomplexa e determinam seu projeto e sua vida \u00fatil. Al\u00e9m disso, no Brasil produz-se em\n\nprofundidades raramente alcan\u00e7adas em outras partes do mundo. Por tudo isso \u00e9\n\nnecess\u00e1ria uma intensa pesquisa para compreender e modelar a din\u00e2mica dos risers e de\n\ncomo respondem aos esfor\u00e7os a que est\u00e3o submetidos.\n\nEsta pesquisa, bem como as diversas ferramentas computacionais de an\u00e1lise dos\n\nrisers que resultam dela, geram um grande volume de dados. Dados estes de natureza\n\ntridimensional ou at\u00e9 envolvendo mais dimens\u00f5es, j\u00e1 que podem variar no tempo al\u00e9m\n\n\n\n18\n\ndo espa\u00e7o e serem grandezas n\u00e3o s\u00f3 escalares mas tamb\u00e9m vetoriais ou tensoriais. Al\u00e9m\n\ndisso, muitas vezes traduzem fen\u00f4menos n\u00e3o-lineares ou cuja compreens\u00e3o n\u00e3o \u00e9\n\nintuitiva. E \u00e9 este o problema que \u00e9 atacado por este trabalho: a dificuldade de\n\ncompreens\u00e3o dos grandes volumes de dados multidimensionais resultantes das\n\npesquisas e an\u00e1lises da din\u00e2mica de risers.\n\nPara resolver este problema, prop\u00f5e-se, como objetivo deste trabalho, o\n\ndesenvolvimento de um ambiente interativo para visualiza\u00e7\u00e3o tridimensional de risers,\n\nisoladamente ou em conjunto, comportando-se de acordo com uma din\u00e2mica calculada\n\nexternamente.\n\nSua entrada s\u00e3o os resultados de outros programas que estudam a intera\u00e7\u00e3o do\n\nriser com o escoamento onde est\u00e1 imerso, o movimento e a din\u00e2mica resultantes dessa\n\nintera\u00e7\u00e3o. O ambiente servir\u00e1 como uma sa\u00edda gr\u00e1fica para esses programas.\n\nComo risers podem trabalhar em conjunto, em diversas configura\u00e7\u00f5es espaciais,\n\no que pode levar a colis\u00f5es entre eles, o ambiente tamb\u00e9m deve permitir a detec\u00e7\u00e3o e\n\nvisualiza\u00e7\u00e3o dessas colis\u00f5es. Al\u00e9m disso, deve mostrar, tamb\u00e9m, diversos elementos\n\nassociados aos risers, como por exemplo embarca\u00e7\u00f5es, b\u00f3ias, o fundo e a superf\u00edcie do\n\noceano e v\u00f3rtices. A visualiza\u00e7\u00e3o cient\u00edfica1 da din\u00e2mica do riser deve ser privilegiada,\n\nao inv\u00e9s do realismo da cena. A visualiza\u00e7\u00e3o cient\u00edfica \u00e9 discutida com mais cuidado na\n\nse\u00e7\u00e3o 2.2.\n\n                                                \n\n1 O processo de explorar, transformar e exibir dados como imagens ou outras formas sensoriais\npara facilitar o entendimento e a percep\u00e7\u00e3o desses dados.\n\n\n\n19\n\nAl\u00e9m disso, o programa deve ser desenvolvido seguindo uma metodologia\n\nformal de projeto, deve ser eficiente, expans\u00edvel e port\u00e1vel para as plataformas MS\n\nWindows e Linux. A metodologia utilizada \u00e9 discutida brevemente na se\u00e7\u00e3o 1.3. Seus\n\naspectos te\u00f3ricos s\u00e3o discutidos em 3.1 e o quarto cap\u00edtulo \u00e9 inteiramente dedicado a\n\nmostrar como esta metodologia foi aplicada durante o desenvolvimento do projeto e\n\ncomo o software resultante \u00e9 descrito atrav\u00e9s dela. A discuss\u00e3o da quest\u00e3o da\n\nportabilidade do c\u00f3digo pode ser encontrada na se\u00e7\u00e3o 2.6 e a solu\u00e7\u00e3o adotada para esse\n\nproblema \u00e9 discutida em 3.2.\n\nEsses requisitos do projeto s\u00e3o definidos de maneira mais completa e formal no\n\ncap\u00edtulo 4. A figura 1, abaixo, ilustra os objetivos do trabalho atrav\u00e9s das entradas e\n\nprincipalmente das sa\u00eddas do aplicativo a ser desenvolvido, batizado de RiserView. Na\n\nfigura, a cena com um riser renderizado em cinza representa as tarefas de renderiza\u00e7\u00e3o.\n\nFigura 1 - Entradas e sa\u00eddas do RiserView\n\n\n\n20\n\n1.2. Contexto e Motiva\u00e7\u00e3o\n\nComo dito anteriormente, a compreens\u00e3o do contexto em que este trabalho se\n\ninsere \u00e9 importante n\u00e3o s\u00f3 para compreens\u00e3o dos fatores que o motivaram mas tamb\u00e9m\n\npara compreender algumas das decis\u00f5es tomadas durante o projeto.\n\nEm primeiro lugar \u00e9 preciso analisar a import\u00e2ncia da explora\u00e7\u00e3o mar\u00edtima de\n\npetr\u00f3leo no Brasil. Acredita-se n\u00e3o ser necess\u00e1rio discutir a import\u00e2ncia do petr\u00f3leo em\n\nsi para o mundo moderno, portanto a aten\u00e7\u00e3o aqui est\u00e1 voltada especificamente \u00e0 sua\n\nexplora\u00e7\u00e3o mar\u00edtima. Essa atividade \u00e9 de grande import\u00e2ncia para o Brasil (e tamb\u00e9m\n\npara outros pa\u00edses), tanto do ponto de vista econ\u00f4mico quanto do estrat\u00e9gico. Somente\n\n18% do petr\u00f3leo produzido no pa\u00eds, de acordo com a Petrobras (2004), \u00e9 extra\u00eddo em\n\nterra firme. Do grande volume restante, retirado do leito oce\u00e2nico, a maior parte \u00e9\n\nproduzida em \u00e1guas profundas (com profundidade acima de quatrocentos metros) onde\n\ntamb\u00e9m se encontram boa parte das reservas brasileiras ainda n\u00e3o exploradas.\n\nAl\u00e9m disso, o ritmo em que esta atividade vem evoluindo \u00e9 bastante r\u00e1pido. H\u00e1\n\napenas trinta e cinco anos essa modalidade de explora\u00e7\u00e3o tinha in\u00edcio no Brasil a uma\n\nprofundidade de menos de trinta metros. De acordo com a Petrobras (2004), ela \u00e9\n\natualmente a campe\u00e3 mundial em profundidade de explora\u00e7\u00e3o, produzindo a quase dois\n\nmil metros no campo de Roncador.\n\nO grande volume de produ\u00e7\u00e3o,  bem como a evolu\u00e7\u00e3o desta atividade, s\u00e3o ao\n\nmesmo tempo causa e conseq\u00fc\u00eancia de um grande n\u00famero de pesquisas em diversas\n\n\u00e1reas. A Escola Polit\u00e9cnica, em particular, vem realizando pesquisas nesta \u00e1rea h\u00e1 mais\n\n\n\n21\n\nde uma d\u00e9cada, envolvendo mais de um departamento e inclusive projetos tem\u00e1ticos da\n\nFAPESP, constantemente produzindo trabalhos na \u00e1rea e obtendo resultados\n\nimportantes.\n\nA exist\u00eancia de todos estes trabalhos e pesquisas \u00e9 outro importante motivador\n\npara o desenvolvimento deste trabalho em particular. S\u00e3o eles, afinal, que geram o\n\ngrande volume de dados que faz necess\u00e1rio, para sua compreens\u00e3o, o uso de uma\n\nferramenta como a que se prop\u00f5e desenvolver neste mestrado. Ali\u00e1s, este \u00e9 um dos\n\nmotivos pelos quais se faz a op\u00e7\u00e3o de projeto pela visualiza\u00e7\u00e3o cient\u00edfica, em vez do\n\nrealismo.\n\nAl\u00e9m disso, as mesmas necessidades que motivam todos estes trabalhos (n\u00e3o s\u00f3\n\na import\u00e2ncia mas a evolu\u00e7\u00e3o da explora\u00e7\u00e3o mar\u00edtima de petr\u00f3leo e suas altas\n\nprofundidades, que emprestam \u00e0 atividade no pa\u00eds caracter\u00edsticas \u00fanicas) s\u00e3o tamb\u00e9m\n\nfortes raz\u00f5es para a proposta discutida aqui.\n\nUma outra forma na qual a exist\u00eancia destes trabalhos serve como est\u00edmulo \u00e9 a\n\nseguinte: espera-se que seus desenvolvedores possam, no futuro, fazer uso do produto\n\ndeste projeto e que esse uso contribua para seus trabalhos de alguma forma. A\n\npossibilidade que a ferramenta desenvolvida venha a ser de fato \u00fatil no futuro \u00e9 um\n\ngrande motivador.\n\nA import\u00e2ncia que estas pesquisas desenvolvidas na Escola Polit\u00e9cnica t\u00eam\n\ncomo motivador para este trabalho pode ser demonstrada atrav\u00e9s de uma conseq\u00fc\u00eancia\n\ndireta delas numa decis\u00e3o de projeto. Muitas destas pesquisas, principalmente as mais\n\nrecentes, v\u00eam sendo desenvolvidas utilizando o sistema operacional Linux. Atualmente\n\n\n\n22\n\nj\u00e1 se pode contar inclusive com dois clusters de computadores, totalizando mais de\n\nduzentas m\u00e1quinas trabalhando em paralelo e utilizando este sistema, assim como um\n\nprojetor estereogr\u00e1fico. Da\u00ed a import\u00e2ncia do desenvolvimento de uma ferramenta que\n\ntamb\u00e9m possa ser utilizada sobre o Linux. Esta import\u00e2ncia foi traduzida no projeto\n\natrav\u00e9s do requisito de que a aplica\u00e7\u00e3o deveria ser multiplataforma.\n\nUm outro fator importante, de car\u00e1ter mais pessoal, que motiva o\n\ndesenvolvimento deste trabalho \u00e9 o envolvimento pr\u00e9vio do autor com as pesquisas na\n\n\u00e1rea citadas anteriormente, realizadas na Escola Polit\u00e9cnica. Desde 1995 o autor\n\nparticipa de pesquisas nessa \u00e1rea, onde espera ter adquirido um conhecimento do\n\nproblema que ser\u00e1 \u00fatil neste trabalho.\n\nDurante a pesquisa bibliogr\u00e1fica p\u00f4de-se perceber tamb\u00e9m uma defici\u00eancia\n\nacad\u00eamica com rela\u00e7\u00e3o \u00e0 visualiza\u00e7\u00e3o cient\u00edfica de dados nessa \u00e1rea em particular.\n\nAinda que o autor conhe\u00e7a mais de um software que fa\u00e7a uso destas t\u00e9cnicas para exibir\n\nseus resultados e tenha inclusive trabalhado no desenvolvimento de pelo menos um\n\ndeles, foi muito dif\u00edcil encontrar artigos discutindo este aspecto. Ao que parece, os\n\ndesenvolvedores das ferramentas de an\u00e1lise da din\u00e2mica dos risers, consideram este seu\n\nfoco principal, enquanto a visualiza\u00e7\u00e3o dos resultados \u00e9 \"apenas uma ferramenta\n\nsecund\u00e1ria\" que merece muito pouca discuss\u00e3o na literatura, se alguma. Por outro lado,\n\nh\u00e1 o desenvolvimento das t\u00e9cnicas e aplica\u00e7\u00f5es para visualiza\u00e7\u00e3o dos dados, sem a\n\npreocupar com a an\u00e1lise que os gera. Para estes os risers s\u00e3o \"apenas uma aplica\u00e7\u00e3o\"\n\npara suas t\u00e9cnicas e tamb\u00e9m recebem pouca aten\u00e7\u00e3o na literatura, que neste caso enfoca\n\nmais as t\u00e9cnicas em si. Some-se a isso o fato de que muitas dessas pesquisas s\u00e3o\n\ndesenvolvidas a servi\u00e7o da ind\u00fastria de Petr\u00f3leo de forma que as aplica\u00e7\u00f5es resultantes\n\n\n\n23\n\ns\u00e3o de uso restrito. Espera-se, com este trabalho, contribuir apresentando uma vis\u00e3o\n\nmais integrada destes dois aspectos. Ainda que o trabalho se concentre na visualiza\u00e7\u00e3o\n\ncient\u00edfica, em nenhum momento o objeto desta visualiza\u00e7\u00e3o \u00e9 esquecido ou posto de\n\nlado. Esta poss\u00edvel contribui\u00e7\u00e3o atrav\u00e9s de uma vis\u00e3o integrada da visualiza\u00e7\u00e3o\n\ncient\u00edfica e de sua aplica\u00e7\u00e3o no problema dos risers \u00e9 outro est\u00edmulo para o trabalho.\n\nA pr\u00f3pria utiliza\u00e7\u00e3o de uma metodologia formal no desenvolvimento do\n\naplicativo \u00e9 um dos objetivos deste trabalho, pelos motivos discutidos adiante.\n\n1.3. Metodologia\n\nComo pesquisa cient\u00edfica que \u00e9, este projeto deve contar fortemente com duas\n\ncaracter\u00edsticas: a boa documenta\u00e7\u00e3o do projeto bem como mecanismos que auxiliem em\n\nsua repetibilidade, ou seja, que permitam que outros pesquisadores possam alcan\u00e7ar\n\nresultados semelhantes seguindo aproximadamente os mesmos passos trilhados aqui.\n\nPara conseguir estas caracter\u00edsticas num projeto que trata, em grande parte, de\n\ndesenvolvimento de software, optou-se por utilizar uma metodologia formal para este\n\ndesenvolvimento, que norteie os passos do processo e que esteja bem clara tanto para o\n\ndesenvolvedor quanto para o leitor.\n\nOptou-se ainda por utilizar uma metodologia dentre as j\u00e1 existentes e conhecidas\n\nno mercado. Na se\u00e7\u00e3o 3.1 a quest\u00e3o do uso da metodologia, suas vantagens e\n\ndesvantagens, \u00e9 abordada com mais profundidade. Nesta se\u00e7\u00e3o o Processo Unificado\n\n(Unified Process ou UP) \u00e9 descrito de maneira breve e explica-se como foi tamb\u00e9m\n\n\n\n24\n\nanalisada outra alternativa de metodologia para este trabalho: o Extreme Programming\n\n(XP), e porque o Processo Unificado foi escolhido. Por tudo isso, a metodologia n\u00e3o\n\nser\u00e1 novamente descrita aqui.\n\nOutro aspecto importante que norteia todo o desenvolvimento do trabalho, seu\n\nprojeto e implementa\u00e7\u00e3o, e que inclusive permite que se utilize o UP, \u00e9 a decis\u00e3o de\n\nutilizar neste projeto o paradigma de programa\u00e7\u00e3o orientada a objetos, abordado na\n\nse\u00e7\u00e3o 2.4.1.\n\n1.4. Estrutura do Trabalho\n\nNeste primeiro cap\u00edtulo, Introdu\u00e7\u00e3o, \u00e9 oferecida uma r\u00e1pida vis\u00e3o panor\u00e2mica\n\ndo trabalho, seus objetivos, contexto e motiva\u00e7\u00e3o, metodologia e estrutura.\n\nO cap\u00edtulo seguinte, Revis\u00e3o Bibliogr\u00e1fica, discute com mais detalhe os\n\nprincipais t\u00f3picos envolvidos na pesquisa e execu\u00e7\u00e3o deste trabalho, baseado na\n\nliteratura, como a explora\u00e7\u00e3o mar\u00edtima de petr\u00f3leo e risers, computa\u00e7\u00e3o gr\u00e1fica e\n\nvisualiza\u00e7\u00e3o cient\u00edfica, orienta\u00e7\u00e3o a objetos e alguns t\u00f3picos relacionados a engenharia\n\nde software etc.\n\nNo cap\u00edtulo tr\u00eas, Tecnologias, a revis\u00e3o bibliogr\u00e1fica continua, por\u00e9m\n\ndiscutindo quest\u00f5es mais intrinsecamente ligadas \u00e0 tecnologias atuais e portanto, menos\n\nperenes. O Processo Unificado e as APIs utilizadas nesse trabalho s\u00e3o os principais\n\nt\u00f3picos desse cap\u00edtulo.\n\n\n\n25\n\nO quarto cap\u00edtulo, a Metodologia e o RiserView, aborda os aspectos mais\n\npr\u00e1ticos do projeto e implementa\u00e7\u00e3o do ambiente de visualiza\u00e7\u00e3o de risers. Descreve-se\n\na customiza\u00e7\u00e3o do UP para este projeto em particular, os passos que foram seguidos\n\npara atingir os resultados finais, bem como os artefatos resultantes do processo. Esta\n\ndescri\u00e7\u00e3o e estes artefatos servem tamb\u00e9m para descrever abrangentemente e de\n\ndiversas formas a aplica\u00e7\u00e3o resultante.\n\nO cap\u00edtulo cinco, Resultados, relata principalmente como foram realizados os\n\ntestes do aplicativo desenvolvido, os motivos para que fossem realizados dessa forma e\n\nos resultados obtidos.\n\nUma discuss\u00e3o do trabalho como um todo e dos resultados relatados no cap\u00edtulo\n\ncinco de forma mais aprofundada \u00e9 feita no \u00faltimo cap\u00edtulo, Conclus\u00f5es. Parte\n\nimportante deste cap\u00edtulo \u00e9 tamb\u00e9m a discuss\u00e3o de poss\u00edveis aprimoramentos pass\u00edveis\n\nde serem pesquisados e  implementados em trabalhos futuros.\n\nOs Ap\u00eandices A e B s\u00e3o resultantes da captura de requisitos realizada durante a\n\naplica\u00e7\u00e3o da metodologia ao projeto. O Ap\u00eandice C resume os resultados dos testes de\n\ncaixa-preta e o Ap\u00eandice D mostra como est\u00e3o organizados os conte\u00fados do CD que \u00e9\n\nparte integrante deste trabalho.\n\n\n\n26\n\n2. REVIS\u00c3O BIBLIOGR\u00c1FICA\n\nPara guiar a revis\u00e3o bibliogr\u00e1fica neste trabalho, \u00e9 \u00fatil ter em mente o problema\n\nque ele se presta a resolver: a visualiza\u00e7\u00e3o do grande volume de dados resultante de\n\ndiversas formas de an\u00e1lise relativas a risers em seu ambiente de trabalho. A forma como\n\nse prop\u00f5e a resolver esse problema \u00e9 atrav\u00e9s do desenvolvimento de um ambiente\n\ninterativo para visualiza\u00e7\u00e3o tridimensional de risers, isoladamente ou em conjunto,\n\nmovendo-se de acordo com uma din\u00e2mica calculada externamente, que permita tamb\u00e9m\n\na visualiza\u00e7\u00e3o das colis\u00f5es entre os risers assim como de outros elementos na cena\n\n(como embarca\u00e7\u00f5es, o fundo e a superf\u00edcie do oceano e v\u00f3rtices). Al\u00e9m disso a\n\nvisualiza\u00e7\u00e3o cient\u00edfica da din\u00e2mica do riser \u00e9 privilegiada, ao inv\u00e9s do realismo da cena.\n\nNo entanto, como Upson (1987) j\u00e1 previa, estes dois fatores (visualiza\u00e7\u00e3o cient\u00edfica e\n\nrealismo) n\u00e3o s\u00e3o necessariamente exclusivos e muitas t\u00e9cnicas utilizadas na ind\u00fastria\n\ndo entretenimento para aumentar o realismo da computa\u00e7\u00e3o gr\u00e1fica podem tamb\u00e9m ser\n\nutilizadas para facilitar a an\u00e1lise de dados cient\u00edficos. Sendo assim, alguns elementos\n\npara aumentar o realismo, ser\u00e3o detalhados mais adiante. Al\u00e9m disso, o aplicativo deve\n\nser desenvolvido seguindo uma metodologia formal de projeto, deve ser eficiente,\n\nexpans\u00edvel e port\u00e1vel para m\u00faltiplas plataformas (principalmente MS Windows e\n\nLinux). Tendo isto em mente, foi decidido tamb\u00e9m que o ambiente ser\u00e1 desenvolvido\n\nutilizando conceitos de orienta\u00e7\u00e3o a objetos.\n\n\n\n27\n\nA execu\u00e7\u00e3o destes objetivos envolve o estudo de diversos t\u00f3picos. Neste\n\ncap\u00edtulo, estes t\u00f3picos s\u00e3o apresentados de forma sucinta, organizados do geral para o\n\nespec\u00edfico. Inicialmente, s\u00e3o discutidos os objetos da visualiza\u00e7\u00e3o, os risers, e seu papel\n\nna explora\u00e7\u00e3o submarina de petr\u00f3leo. Em seguida, conceitos de visualiza\u00e7\u00e3o e de\n\nprojeto de software e por fim alguns detalhes e t\u00e9cnicas levados em conta durante a\n\nimplementa\u00e7\u00e3o.\n\n2.1. Risers e a Explora\u00e7\u00e3o Mar\u00edtima de Petr\u00f3leo\n\nA descobertas de jazidas petrol\u00edferas sob o solo dos oceanos, cada vez em\n\nmaiores profundidades, n\u00e3o s\u00f3 \u00e9 de grande import\u00e2ncia  econ\u00f4mica e estrat\u00e9gica para\n\ndiversos pa\u00edses como tamb\u00e9m exige solu\u00e7\u00f5es t\u00e9cnicas vi\u00e1veis e eficientes para sua\n\nexplora\u00e7\u00e3o. No Brasil, esta explora\u00e7\u00e3o se iniciou em 1968, a meros 30 metros de\n\nprofundidade, aproximadamente, nos litorais do Esp\u00edrito Santo e de Sergipe.\n\nAtualmente, de acordo com a Petrobras (2004),  ela \u00e9 l\u00edder mundial em explora\u00e7\u00e3o de\n\npetr\u00f3leo a grandes profundidades, produzindo a 1.853 metros de  profundidade no\n\ncampo de Roncador. O Brasil est\u00e1 entre os poucos pa\u00edses que dominam todo o ciclo de\n\nperfura\u00e7\u00e3o submarina em \u00e1guas profundas e ultraprofundas e atualmente 46% das\n\nreservas de petr\u00f3leo do pa\u00eds est\u00e3o localizados em profundidade de \u00e1gua de 400 a 1.000\n\nm e 29,9% em profundidade de \u00e1gua com mais de 1.000 m, ou seja, mais de 75% de\n\ntodas as reservas se encontram em \u00e1guas profundas e ultraprofundas. Os diagramas\n\napresentados nas figuras 2 e 3 demonstram a situa\u00e7\u00e3o atual e a evolu\u00e7\u00e3o da produ\u00e7\u00e3o de\n\npetr\u00f3leo em \u00e1guas profundas.\n\n\n\n28\n\nFigura 2 - Produ\u00e7\u00e3o de petr\u00f3leo no Brasil (fonte: Petrobras)\n\nFigura 3 - Evolu\u00e7\u00e3o da produ\u00e7\u00e3o em \u00e1guas profundas (fonte: Petrobras)\n\n\n\n29\n\nEsta evolu\u00e7\u00e3o faz necess\u00e1ria uma intensa pesquisa em diversas \u00e1reas, dentre elas\n\no comportamento de estruturas mec\u00e2nicas submetidas aos esfor\u00e7os de diferentes\n\nnaturezas que caracterizam a explora\u00e7\u00e3o em grandes profundidades. A Escola\n\nPolit\u00e9cnica vem realizando pesquisa nesta \u00e1rea h\u00e1 mais de uma d\u00e9cada, tendo produzido\n\ndiversos trabalhos e resultados importantes. Como j\u00e1 foi mencionado na introdu\u00e7\u00e3o,\n\nessas pesquisas s\u00e3o mais um fator que motiva a cria\u00e7\u00e3o do ambiente de visualiza\u00e7\u00e3o\n\nproposto neste trabalho.\n\nPara produzir petr\u00f3leo em profundidades t\u00e3o diversas como as citadas\n\nanteriormente s\u00e3o utilizadas plataformas de explora\u00e7\u00e3o, que podem ser fixas ou\n\nflutuantes. As fixas t\u00eam funda\u00e7\u00e3o no leito oce\u00e2nico e resistem melhor aos esfor\u00e7os\n\nambientais, mas est\u00e3o restritas a profundidades baixas ou intermedi\u00e1rias. J\u00e1 as\n\nplataformas flutuantes s\u00e3o constru\u00eddas sobre cascos ancorados ao fundo do mar. Al\u00e9m\n\nde poderem trabalhar em maiores profundidades, podem ser transportadas de um po\u00e7o a\n\noutro sem maiores problemas, mas s\u00e3o mais sens\u00edveis aos esfor\u00e7os ambientais.\n\nPara transportar fluidos e pot\u00eancia entre os campos de explora\u00e7\u00e3o no leito\n\noce\u00e2nico e as plataformas ou navios localizados na superf\u00edcie \u00e9 que s\u00e3o utilizados os\n\nrisers, que ser\u00e3o descritas em mais detalhe a seguir.\n\n2.1.1. Risers\n\nAo exercer sua fun\u00e7\u00e3o, ligar os po\u00e7os de explora\u00e7\u00e3o no solo oce\u00e2nico \u00e0s\n\nplataformas ou navios na superf\u00edcie, os risers ficam submersas na l\u00e2mina d'\u00e1gua em\n\n\n\n30\n\ndiversas configura\u00e7\u00f5es e s\u00e3o utilizados principalmente para perfura\u00e7\u00e3o e produ\u00e7\u00e3o.\n\nAntes de discutir estas fun\u00e7\u00f5es, no entanto, \u00e9 interessante classificar os risers em r\u00edgidos\n\ne flex\u00edveis.\n\nOs risers r\u00edgidos, quando usados como risers verticais para perfura\u00e7\u00e3o, n\u00e3o s\u00e3o\n\nprojetados para suportar grandes curvaturas, de acordo com Ferrari (1998). T\u00eam um\n\ntensionador em seu topo, para evitar a flambagem e esfor\u00e7os elevados, e uma junta\n\narticulada em sua extremidade inferior que permite deflex\u00f5es de at\u00e9 10 graus se\n\nnecess\u00e1rio. Caso o movimento da plataforma ameace causar uma deflex\u00e3o maior que\n\nesta estrutura pode suportar, o riser pode ser desconectado hidraulicamente do po\u00e7o. No\n\nentanto, risers r\u00edgidos tamb\u00e9m tem sido utilizados como uma importante solu\u00e7\u00e3o para\n\nexplora\u00e7\u00e3o em grandes profundidades, em caten\u00e1ria2.\n\nJ\u00e1 os risers flex\u00edveis s\u00e3o projetados para que esta flexibilidade auxilie a suportar\n\nos movimentos da plataforma e os esfor\u00e7os hidrodin\u00e2micos. Portanto devem ter alta\n\nrigidez axial e baixa resist\u00eancia \u00e0 flex\u00e3o.\n\nNa atividade de perfura\u00e7\u00e3o s\u00e3o utilizados os risers r\u00edgidos e verticais. Em sua\n\nextremidade s\u00e3o instaladas brocas guiadas por dispositivos na cabe\u00e7a do po\u00e7o. Nestes\n\nrisers \u00e9 injetada a Lama de Perfura\u00e7\u00e3o, um composto de argila, produtos qu\u00edmicos e\n\n\u00e1gua que tem diversas fun\u00e7\u00f5es como lubrificar e resfriar a broca, fornecer sustenta\u00e7\u00e3o\n\nao riser e  impedir a subida dos hidrocarbonetos quando atingidos.\n\n                                                \n\n2 A curva formada por um fio suspenso.\n\n\n\n31\n\nJ\u00e1 na produ\u00e7\u00e3o podem ser usados risers flex\u00edveis ou r\u00edgidos. Durante esta\n\natividade o papel do riser \u00e9 transportar os produtos fluidos do po\u00e7o at\u00e9 a plataforma.\n\nA figura 4 ilustra um riser vertical e um riser em caten\u00e1ria ligando uma\n\nplataforma ao po\u00e7o:\n\nFigura 4 - Risers\n\nSeja durante a perfura\u00e7\u00e3o ou durante a produ\u00e7\u00e3o, os risers est\u00e3o sujeitos a\n\ndiversos esfor\u00e7os internos e externos. Os internos prov\u00e9m principalmente da press\u00e3o\n\nhidrost\u00e1tica dos fluidos transportados em seu interior. Os externos s\u00e3o causados por\n\nv\u00e1rios fatores, principalmente de origem ambiental, como ondas e correntes mar\u00edtimas,\n\nque por sua vez causam movimentos na plataforma e podem causar esteiras de v\u00f3rtices\n\nao redor dos risers.\n\n\n\n32\n\n2.1.2. V\u00f3rtices\n\nBlevins (1990) conta que desde a Gr\u00e9cia antiga o fen\u00f4meno de desprendimento\n\nde v\u00f3rtices num escoamento ao redor de um corpo rombudo j\u00e1 \u00e9 conhecido. Corpos\n\nrombudos s\u00e3o aqueles em que a separa\u00e7\u00e3o do escoamento ocorre ao longo de uma\n\ngrande parcela de sua superf\u00edcie. No caso de interesse deste trabalho, os risers, com sua\n\nse\u00e7\u00e3o circular, podem ser classificados como tal. De acordo com Ferrari (1998), quando\n\na camada limite se separa formam-se duas camadas cisalhantes que se deslocam \u00e0\n\njusante do escoamento de cada um dos lados do cilindro. Estas camadas tendem a\n\nrevolver-se formando uma esteira de v\u00f3rtices \u00e0 jusante do cilindro. Gerrard (1986)\n\napud. Meneghini (1993) afirma que \u00e9 a intera\u00e7\u00e3o entre as duas camadas cisalhantes a\n\nprincipal respons\u00e1vel pela gera\u00e7\u00e3o e emiss\u00e3o destes v\u00f3rtices.\n\nJeong &amp; Hussain (1995) discutem como a pr\u00f3pria defini\u00e7\u00e3o do que constitui um\n\nv\u00f3rtice \u00e9 problem\u00e1tica e apresentam algumas alternativas, a maioria mais complexa que\n\no necess\u00e1rio para este trabalho. Citam tamb\u00e9m, no entanto, a seguinte defini\u00e7\u00e3o: um\n\nv\u00f3rtice \u00e9 um conjunto de part\u00edculas materiais que gira ao redor de um centro comum. A\n\nfigura 5, gerada pelo RiserView, ilustra o desprendimento de v\u00f3rtices \u00e0 jusante de um\n\ncilindro (em preto, visto de cima). As regi\u00f5es em rosa e verde representam v\u00f3rtices que\n\nse desprendem na periferia do cilindro e se deslocam para a direita da figura. As regi\u00f5es\n\nem rosa giram no sentido hor\u00e1rio enquanto as verdes giram no sentido contr\u00e1rio.\n\n\n\n33\n\nFigura 5 - V\u00f3rtices\n\nNa figura 5 a vari\u00e1vel que est\u00e1 mapeada em cores \u00e9 a vorticidade, uma medida\n\nlocal da rota\u00e7\u00e3o do escoamento.\n\nA forma\u00e7\u00e3o e a exist\u00eancia de uma esteira de v\u00f3rtices como esta gera for\u00e7as\n\nc\u00edclicas sobre o riser que causam o fen\u00f4meno de Vibra\u00e7\u00f5es Induzidas por V\u00f3rtices\n\n(Vortex-Induced Vibrations ou VIV). Como essas for\u00e7as contribuem para reduzir a vida\n\n\u00fatil dos risers devido \u00e0 fadiga, o estudo desse fen\u00f4meno \u00e9 considerado de grande\n\nimport\u00e2ncia para a ind\u00fastria petrol\u00edfera.\n\n2.2. Computa\u00e7\u00e3o Gr\u00e1fica e Visualiza\u00e7\u00e3o Cient\u00edfica\n\nCom o objeto da visualiza\u00e7\u00e3o, os Risers, seu contexto e import\u00e2ncia definidos, \u00e9\n\nposs\u00edvel voltar a aten\u00e7\u00e3o para a visualiza\u00e7\u00e3o em si. Esta discuss\u00e3o come\u00e7a com a \u00e1rea\n\nda Computa\u00e7\u00e3o Gr\u00e1fica.\n\nSchroeder et al. (1998) d\u00e3o uma defini\u00e7\u00e3o bastante simples de Computa\u00e7\u00e3o\n\nGr\u00e1fica. Para eles, essa \u00e1rea engloba nada mais ou menos que o processo de criar\n\n\n\n34\n\nimagens utilizando um computador. Sua defini\u00e7\u00e3o inclui tanto t\u00e9cnicas de desenho ou\n\npintura em duas dimens\u00f5es quanto t\u00e9cnicas mais sofisticadas de desenho (ou\n\nrenderiza\u00e7\u00e3o) em 3D. Foley et al. (1996) acrescentam que a \u00e1rea tamb\u00e9m engloba, al\u00e9m\n\nda cria\u00e7\u00e3o, o armazenamento e a manipula\u00e7\u00e3o de modelos e imagens de objetos.\n\nQuando se fala em imagens bidimensionais, deve-se tamb\u00e9m mencionar a \u00e1rea de\n\nProcessamento de Imagens (imaging ou image processing), que inclui t\u00e9cnicas para\n\ntransformar, analisar e aprimorar essas imagens.\n\nAngel (2000) classifica as principais aplica\u00e7\u00f5es de computa\u00e7\u00e3o gr\u00e1fica nas\n\nseguintes \u00e1reas:\n\n\u2022 Exibi\u00e7\u00e3o de Informa\u00e7\u00e3o;\n\n\u2022 Projeto;\n\n\u2022 Simula\u00e7\u00e3o;\n\n\u2022 Interfaces Homem-M\u00e1quina.\n\nDe acordo com essa classifica\u00e7\u00e3o, aplica\u00e7\u00f5es de entretenimento, por exemplo,\n\nseriam um caso particular de exibi\u00e7\u00e3o de informa\u00e7\u00e3o (onde a informa\u00e7\u00e3o seria um filme,\n\numa hist\u00f3ria, um comercial...) ou de simula\u00e7\u00e3o (como \u00e9 o caso de alguns jogos). J\u00e1 um\n\nsistema de CAD \u00e9 claramente uma aplica\u00e7\u00e3o de projeto e um simulador m\u00e9dico ou\n\nmilitar, uma aplica\u00e7\u00e3o de simula\u00e7\u00e3o.\n\nPara a aplica\u00e7\u00e3o desenvolvida nesse trabalho, fica claro que a principal \u00e1rea de\n\ninteresse \u00e9 a de exibi\u00e7\u00e3o de informa\u00e7\u00e3o. Embora seja feito uso de interfaces gr\u00e1ficas\n\n\n\n35\n\ncom o usu\u00e1rio, elas s\u00e3o apenas uma ferramenta, enquanto a exibi\u00e7\u00e3o de informa\u00e7\u00e3o \u00e9 o\n\nprincipal objetivo do trabalho.\n\nSobre essa \u00e1rea, Angel (2000) afirma que:\n\n\"T\u00e9cnicas gr\u00e1ficas cl\u00e1ssicas surgiram como um meio de transmitir informa\u00e7\u00e3o\nentre pessoas. Apesar das linguagens escrita e falada servirem a um prop\u00f3sito similar,\no sistema visual humano n\u00e3o tem paralelo tanto como um processador de dados\nquanto como um reconhecedor de padr\u00f5es.\" (Angel, 2000, p. 2, grifo nosso)\n\nCom a grande quantidade de dados que os computadores de hoje em dia\n\npermitem ser gerados por pesquisadores, cada vez mais \u00e9 necess\u00e1rio fazer uso dessa\n\nferramenta (o sistema visual humano) para assimilar e interpretar essas informa\u00e7\u00f5es.\n\nAngel conta ainda, como exemplo, que, na \u00e1rea de escoamento de fluidos, imagens\n\ngeradas pela convers\u00e3o de dados em entidades geom\u00e9tricas que podem ser exibidas t\u00eam\n\npermitido novas revela\u00e7\u00f5es sobre processos complexos.\n\nEsta \u00e9 justamente a fun\u00e7\u00e3o da \u00e1rea de Visualiza\u00e7\u00e3o Cient\u00edfica. De acordo com\n\nSchroeder et al., \"Visualiza\u00e7\u00e3o \u00e9 o processo de explorar, transformar e exibir dados\n\ncomo imagens (ou outras formas sensoriais) para ganhar entendimento e percep\u00e7\u00e3o\n\ndesses dados.\" (Schroeder et al., 1998, p. 5)\n\nKeim (2001) relata os resultados do projeto \"How Much Information\" da\n\nUniversidade da Calif\u00f3rnia que estimam que anualmente, hoje em dia, em todo mundo,\n\n\u00e9 gerado 1 Exabyte (1 milh\u00e3o de Terabytes) de dados e que praticamente 100% desses\n\ndados est\u00e1 dispon\u00edvel em forma digital. Keim concorda com Angel quando diz que a\n\nrepresenta\u00e7\u00e3o visual desses dados reduz o trabalho cognitivo necess\u00e1rio n\u00e3o s\u00f3 na\n\nassimila\u00e7\u00e3o e interpreta\u00e7\u00e3o desses dados, como tamb\u00e9m na sua busca.\n\n\n\n36\n\nEsse \u00e9 exatamente o objetivo deste trabalho. Permitindo a visualiza\u00e7\u00e3o em um\n\nambiente interativo e tridimensional dos dados gerados nas pesquisas sobre a din\u00e2mica\n\nde risers, espera-se facilitar a assimila\u00e7\u00e3o e interpreta\u00e7\u00e3o desses dados.\n\n2.2.1. Breve Hist\u00f3rico\n\nA computa\u00e7\u00e3o gr\u00e1fica come\u00e7ou, como dizem Foley et al. (1996), logo ap\u00f3s o\n\naparecimento dos computadores em si, com a exibi\u00e7\u00e3o de dados em impressoras e\n\nmonitores CRT3. T\u00e3o cedo quanto em 1950 o computador Whirlwind do MIT j\u00e1\n\nutilizava monitores CRT para sa\u00edda de dados. A origem do conceito de intera\u00e7\u00e3o com\n\ngr\u00e1ficos de computador pode ser tra\u00e7ada at\u00e9 Ivan Sutherland e seu projeto SketchPad de\n\n1963. J\u00e1 em 1964 a General Motors utilizava o sistema DAC para projeto de\n\nautom\u00f3veis auxiliado por computador.\n\nNo entanto, at\u00e9 o come\u00e7o da d\u00e9cada de 80, tratava-se de uma \u00e1rea pequena e\n\nespecializada, devido ao alto custo do hardware de que necessitava e da exist\u00eancia de\n\npoucas (e caras) aplica\u00e7\u00f5es gr\u00e1ficas de simples utiliza\u00e7\u00e3o. A partir da\u00ed, com o\n\nbarateamento e a populariza\u00e7\u00e3o dos computadores pessoais com dispositivos gr\u00e1ficos de\n\nraster (ou varredura) como os Apple Macintosh e os IBM PC, popularizou-se o uso de\n\ngr\u00e1ficos matriciais ou bitmap4 para a intera\u00e7\u00e3o entre o computador e o usu\u00e1rio. Quando\n\n                                                \n\n3 Cathode Ray Tube\n4 Um bitmap \u00e9 uma matriz retangular de pontos (ou pixels) contendo valores de cores nesses\npontos (inicialmente somente 0 e 1 para preto e branco) que representa uma imagem.\n\n\n\n37\n\nos gr\u00e1ficos matriciais se tornaram acess\u00edveis, in\u00fameras aplica\u00e7\u00f5es gr\u00e1ficas baratas e de\n\nsimples uso surgiram logo depois.\n\nDa mesma forma que gr\u00e1ficos 2D eram incomuns at\u00e9 o come\u00e7o dos anos 80\n\ndevido ao custo do hardware de que necessitavam, at\u00e9 o come\u00e7o da d\u00e9cada de 90\n\ngr\u00e1ficos 3D continuavam incomuns pelo mesmo motivo. Foi nessa \u00e9poca que\n\ncome\u00e7aram a ser produzidos chips de custo acess\u00edvel especializados em exibir e\n\niluminar objetos 3D formados por pol\u00edgonos. A partir da\u00ed a \u00e1rea de computa\u00e7\u00e3o gr\u00e1fica\n\nem tr\u00eas dimens\u00f5es popularizou-se e id\u00e9ias que eram consideradas exc\u00eantricas a menos\n\nde uma d\u00e9cada, como a busca pelo realismo, passaram a ser objeto de pesquisas\n\nrotineiras e distribu\u00eddas por todo o mundo.\n\nUm indicador desta populariza\u00e7\u00e3o da visualiza\u00e7\u00e3o em tr\u00eas dimens\u00f5es \u00e9 a\n\nprolifera\u00e7\u00e3o de APIs5 especificamente desenvolvidas com essa finalidade nos \u00faltimos\n\nanos. Para citar somente algumas das mais populares: OpenGL, VRML, Java 3D, Open\n\nScene Graph e Direct 3D. Historicamente \u00e9 preciso citar tamb\u00e9m o sistema PHIGS e o\n\nGKS-3D, desenvolvidos em 1988. Dentre estas APIs, destaca-se o OpenGL por ter se\n\ntornado atualmente um padr\u00e3o de fato do mercado, de acordo com Schroeder et al.\n\n(1998) e Angel (2000). \u00c9 interessante mencionar tamb\u00e9m a API Mesa, criada em por\n\nPaul (2004), muito semelhante ao OpenGL (utiliza a mesma sintaxe, comandos e\n\nm\u00e1quina de estados) e que, durante muito tempo ap\u00f3s sua distribui\u00e7\u00e3o pela Internet em\n\n1995, foi a \u00fanica op\u00e7\u00e3o em diversas plataformas para o uso do OpenGL.\n\n                                                \n\n5 Application Programmer Interfaces, ou seja, bibliotecas de fun\u00e7\u00f5es que fazem a interface\nentre o programador de uma aplica\u00e7\u00e3o e um sistema de mais baixo n\u00edvel, seja ele de hardware\nou software.\n\n\n\n38\n\nJ\u00e1 a Visualiza\u00e7\u00e3o Cient\u00edfica, embora tenha sido utilizada desde antes mesmo da\n\nexist\u00eancia de computadores, s\u00f3 recebeu esta denomina\u00e7\u00e3o e foi considerada uma \u00e1rea de\n\nestudo distinta da computa\u00e7\u00e3o gr\u00e1fica a partir de 1987, com o relat\u00f3rio da NSF\n\nentitulado Visualization in Scientific Computing. Mas desde o s\u00e9culo XVIII, com a\n\nchegada dos gr\u00e1ficos estat\u00edsticos, representa\u00e7\u00f5es gr\u00e1ficas de dados j\u00e1 eram criados. Os\n\nganhos recentes em mem\u00f3ria e capacidade de processamento dos computadores, no\n\nentanto, t\u00eam ao mesmo tempo popularizado e expandido as t\u00e9cnicas desta disciplina e\n\ntamb\u00e9m as tornado mais necess\u00e1rias, devido ao grande volume de dados gerados, como\n\nj\u00e1 foi mencionado.\n\n2.2.2. T\u00e9cnicas de Visualiza\u00e7\u00e3o Cient\u00edfica\n\nA visualiza\u00e7\u00e3o cient\u00edfica e sua import\u00e2ncia foram definidas, mas com base nas\n\ndefini\u00e7\u00f5es dadas at\u00e9 agora, a distin\u00e7\u00e3o entre computa\u00e7\u00e3o gr\u00e1fica, processamento de\n\nimagens ou mesmo disciplinas matem\u00e1ticas, como a gera\u00e7\u00e3o de gr\u00e1ficos estat\u00edsticos n\u00e3o\n\nfica clara.\n\nSchroeder et al. (1998) dizem que, de maneira geral, o campo da Visualiza\u00e7\u00e3o\n\nCient\u00edfica se distingue pelas seguintes caracter\u00edsticas:\n\n\u2022 Os dados tratados pela visualiza\u00e7\u00e3o t\u00eam pelo menos tr\u00eas dimens\u00f5es, e normalmente\n\nmais. Para dados de dimensionalidade menor existem muitos m\u00e9todos bem\n\nconhecidos que s\u00e3o bastante adequados e se encaixam melhor em outras \u00e1reas como\n\no processamento de imagens ou mesmo a matem\u00e1tica.\n\n\n\n39\n\n\u2022 Uma das caracter\u00edsticas principais da visualiza\u00e7\u00e3o \u00e9 a transforma\u00e7\u00e3o dos dados. Isso\n\nsignifica que a informa\u00e7\u00e3o \u00e9 repetidamente criada ou modificada para incrementar o\n\nsignificado dos dados.\n\n\u2022 A visualiza\u00e7\u00e3o \u00e9 inerentemente interativa, incluindo o elemento humano diretamente\n\nno processo de cria\u00e7\u00e3o, transforma\u00e7\u00e3o e exibi\u00e7\u00e3o dos dados.\n\nComo pode-se perceber, a visualiza\u00e7\u00e3o cient\u00edfica \u00e9 focada sobre os dados e suas\n\ntransforma\u00e7\u00f5es, e estes normalmente t\u00eam tr\u00eas ou mais dimens\u00f5es.\n\nCom base nessas caracter\u00edsticas pode-se observar que a visualiza\u00e7\u00e3o de\n\nfen\u00f4menos ligados \u00e0 explora\u00e7\u00e3o mar\u00edtima de petr\u00f3leo de fato pode ser classificada como\n\nvisualiza\u00e7\u00e3o cient\u00edfica. Em primeiro lugar, trata-se de problemas eminentemente\n\ntridimensionais (por exemplo a distribui\u00e7\u00e3o de linhas de amarra\u00e7\u00e3o ou a configura\u00e7\u00e3o\n\nde grupos de risers) variando ao longo do tempo (uma quarta dimens\u00e3o) e com dados de\n\ndiversas naturezas (escalares, vetoriais e tensoriais) associados a elementos como os\n\nrisers, as embarca\u00e7\u00f5es e a pr\u00f3pria \u00e1gua do mar.  Silveira et al. (2000) d\u00e3o um exemplo\n\npr\u00e1tico de outra aplica\u00e7\u00e3o que utiliza t\u00e9cnicas de visualiza\u00e7\u00e3o cient\u00edfica para tratar do\n\nproblema de amarra\u00e7\u00e3o. Outro exemplo interessante \u00e9 a aplica\u00e7\u00e3o de t\u00e9cnicas de\n\nvisualiza\u00e7\u00e3o cient\u00edfica para manuten\u00e7\u00e3o de reservat\u00f3rios de petr\u00f3leo, mencionado por\n\nBirken &amp; Versteeg (2000). Esta aplica\u00e7\u00e3o ser\u00e1 explorada com um pouco mais de detalhe\n\ndurante a discuss\u00e3o sobre Realidade Virtual.\n\nUma das t\u00e9cnicas mais utilizadas na Visualiza\u00e7\u00e3o Cient\u00edfica \u00e9 o mapeamento de\n\ncores (color mapping) para representar o valor de um escalar (como temperatura ou\n\npress\u00e3o, por exemplo) ao longo de uma superf\u00edcie, uma linha ou um volume. Esse\n\n\n\n40\n\nmapeamento \u00e9 feito associando cada valor poss\u00edvel para o escalar a uma cor atrav\u00e9s de\n\numa tabela (lookup table) ou de uma fun\u00e7\u00e3o de transfer\u00eancia. A figura 6 mostra o uso\n\ndo mapeamento de cores sobre um riser.\n\nFigura 6 - Mapeamento de cores sobre um riser no RiserView\n\nOutra t\u00e9cnica comunmente utilizada com esse fim \u00e9 a de curvas de n\u00edvel ou iso-\n\nsuperf\u00edcies (countouring) e um exemplo dessa t\u00e9cnica sendo usada no estudo de\n\nv\u00f3rtices pode ser visto na figura 7.\n\nFigura 7 - Iso-superf\u00edcies na visualiza\u00e7\u00e3o de v\u00f3rtices (fonte: G\u00fcnther et al., 2004)\n\n\n\n41\n\nNo ambiente desenvolvido neste trabalho, est\u00e1 prevista a visualiza\u00e7\u00e3o de\n\ndiversos campos escalares associados a uma esteira de v\u00f3rtices utilizando a t\u00e9cnica do\n\nmapeamento de cores. Outro uso para esta t\u00e9cnica \u00e9 o mapeamento de escalares, como\n\nm\u00f3dulo da tens\u00e3o total ou curvatura, ao longo dos risers.\n\nJ\u00e1 para visualizar grandezas vetoriais (por exemplo, um campo de velocidades\n\nde corrente mar\u00edtima) \u00e9 comum utilizar glifos6 (uma linha, uma seta, um tri\u00e2ngulo, um\n\ncone...) com a origem no ponto associado ao vetor, a mesma orienta\u00e7\u00e3o do vetor\n\nnaquele ponto e escala proporcional ao seu m\u00f3dulo. Como vetores est\u00e3o comunmente\n\nassociados a movimento (no caso de vetores que representam velocidades ou\n\ndeslocamentos), uma outra t\u00e9cnica bastante utilizada consiste na deforma\u00e7\u00e3o (warping)\n\nde uma geometria de acordo com o campo vetorial. Uma extens\u00e3o natural dessas\n\nt\u00e9cnicas relacionadas a movimento \u00e9 a anima\u00e7\u00e3o de uma geometria no tempo. Por fim,\n\nconectando as posi\u00e7\u00f5es de pontos ao longo dos passos de tempo de uma anima\u00e7\u00e3o pode-\n\nse obter linhas de corrente (streamlines), que \u00e9 outra t\u00e9cnica bastante utilizada.\n\nO RiserView faz extenso uso das t\u00e9cnicas de anima\u00e7\u00e3o e deforma\u00e7\u00e3o para\n\nrepresentar o movimento dos risers ao longo do tempo e permite utilizar ainda glifos\n\nanimados ao longo do tempo para representar as posi\u00e7\u00f5es e deslocamentos de v\u00f3rtices\n\ndiscretos formando uma esteira.\n\n                                                \n\n6 Glifo (Glyph): uma representa\u00e7\u00e3o 2D ou 3D tal como uma seta ou um cone orientados que\npode ter sua orienta\u00e7\u00e3o e escala modificadas, mas que ainda assim \u00e9 usada repetidamente numa\ncena.\n\n\n\n42\n\nExistem tamb\u00e9m t\u00e9cnicas para visualizar grandezas tensoriais, mas essas\n\nt\u00e9cnicas n\u00e3o foram estudadas neste trabalho.\n\nAs figuras 8 e 9 exemplificam o uso de glifos e de linhas de corrente, respectivamente.\n\nFigura 8 - Uso de glifos (fonte: PV-Wave)\n\nFigura 9 - Linhas de corrente (fonte: Gy\u00f6rgy, 2004)\n\n\n\n43\n\n2.2.3. Anima\u00e7\u00e3o\n\nAnteriormente a anima\u00e7\u00e3o foi mencionada como uma t\u00e9cnica utilizada na\n\nvisualiza\u00e7\u00e3o cient\u00edfica. No entanto, esta t\u00e9cnica \u00e9 utilizada em diversas outras \u00e1reas, da\n\nsimula\u00e7\u00e3o ao entretenimento, da educa\u00e7\u00e3o a aplica\u00e7\u00f5es industriais.\n\nDe acordo com Foley et al. (1996), a anima\u00e7\u00e3o tradicional, onde artistas\n\ndesenham cada um dos quadros que comp\u00f5em uma anima\u00e7\u00e3o, \u00e9 uma disciplina por si\n\ns\u00f3, cuja origem se confunde com a do cinema. Atualmente existem aplicativos para\n\nauxiliar essa forma de anima\u00e7\u00e3o (por exemplo interpolando posi\u00e7\u00f5es entre os quadros\n\nprincipais desenhados pelo artista).\n\nThalmann &amp; Thalmann (1990) definem anima\u00e7\u00e3o como a t\u00e9cnica atrav\u00e9s da qual\n\numa ilus\u00e3o de movimento (ou qualquer outra mudan\u00e7a din\u00e2mica, como crescimento) \u00e9\n\ncriada exibindo uma seq\u00fc\u00eancia de imagens (ou quadros) a um certo ritmo, onde cada\n\nimagem \u00e9 uma altera\u00e7\u00e3o da anterior.\n\nTipicamente, o ritmo de troca das imagens \u00e9 de 24 quadros/s ou 30 quadros/s,\n\nmas at\u00e9 ritmos t\u00e3o baixos quanto 5 quadros por segundo ainda fornecem a ilus\u00e3o de\n\nmovimento, ainda que a transi\u00e7\u00e3o entre os quadros torne-se percept\u00edvel (como \"pulos\")\n\nnesse caso.\n\nNuma anima\u00e7\u00e3o gen\u00e9rica, podem ocorrer diversas mudan\u00e7as com os objetos\n\nobservados (posi\u00e7\u00e3o, orienta\u00e7\u00e3o, tamanho, forma, cor, transpar\u00eancia), com o observador\n\n\n\n44\n\n(posi\u00e7\u00e3o, ponto de refer\u00eancia, \u00e2ngulo) e com as fontes de luz (posi\u00e7\u00e3o, intensidade, cor),\n\nou at\u00e9 com a anima\u00e7\u00e3o em si (velocidade das imagens).\n\nNo RiserView \u00e9 permitida anima\u00e7\u00e3o de tr\u00eas formas: os elementos (objetos) da\n\ncena s\u00e3o modificados para refletir suas mudan\u00e7as de estado ao longo do tempo, o\n\nusu\u00e1rio controla a posi\u00e7\u00e3o do observador e tamb\u00e9m a velocidade da anima\u00e7\u00e3o.\n\nEm aplica\u00e7\u00f5es como  neste ambiente, em que a anima\u00e7\u00e3o deve ser interativa e\n\nconviver com uma interface gr\u00e1fica com o usu\u00e1rio, surgem alguns conflitos que devem\n\nser tratados. Ao mesmo tempo que a anima\u00e7\u00e3o deve estar sendo atualizada\n\nconstantemente, as a\u00e7\u00f5es do usu\u00e1rio tamb\u00e9m devem ser constantemente monitoradas\n\npara que o software possa dar as respostas adequadas a essas a\u00e7\u00f5es.\n\n2.3. Realidade Virtual e Ambientes Virtuais\n\nN\u00e3o h\u00e1 d\u00favidas que o ambiente desenvolvido neste trabalho utiliza muitos\n\nelementos em comum com ambientes virtuais. Uma cena, ou mundo, virtual \u00e9\n\nconstru\u00edda em tr\u00eas dimens\u00f5es e o aplicativo permite que o usu\u00e1rio navegue por essa\n\ncena. O cap\u00edtulo 6 discute, inclusive, como o uso de uma forma de navega\u00e7\u00e3o t\u00edpica de\n\nambientes virtuais melhora a usabilidade desse aspecto do aplicativo. H\u00e1 ainda o\n\nrecurso de visualiza\u00e7\u00e3o estereosc\u00f3pica da cena, a anima\u00e7\u00e3o independente de seus\n\nelementos, a preocupa\u00e7\u00e3o com a realiza\u00e7\u00e3o das tarefas em tempo real e com o realismo\n\nquando este n\u00e3o interfere com a visualiza\u00e7\u00e3o cient\u00edfica.\n\n\n\n45\n\nDevido a esses pontos em comum, julga-se necess\u00e1rio uma breve exposi\u00e7\u00e3o\n\nsobre o t\u00f3pico de Realidade Virtual (RV).\n\nMas apesar disso, devido ao formalismo cient\u00edfico que se espera de um trabalho\n\ncomo este, desde seu in\u00edcio persistiu uma d\u00favida quanto \u00e0 sua natureza: o RiserView\n\ntrata-se de um ambiente virtual, de acordo com a defini\u00e7\u00e3o formal do termo? Para\n\nresponder a essa pergunta, \u00e9 preciso analisar as defini\u00e7\u00f5es de RV e Ambientes Virtuais,\n\nembora muitas vezes autores classifiquem sistemas como de RV meramente com base\n\nna presen\u00e7a de alguns dos elementos citados acima.\n\nBurdea &amp; Coiffet (1994) discutem algumas das defini\u00e7\u00f5es equivocadas (na sua\n\nopini\u00e3o) de realidade virtual. Uma das defini\u00e7\u00f5es com a qual discordam \u00e9 a que tenta\n\ndefinir a realidade virtual atrav\u00e9s das ferramentas que utiliza, como HMDs7 ou luvas,\n\npor exemplo. Burdea &amp; Coiffet d\u00e3o exemplos de outras formas de implementar\n\nambientes virtuais sem fazer uso destes dispositivos. Ao fim desta an\u00e1lise, oferecem a\n\nsua defini\u00e7\u00e3o de realidade virtual: \"Realidade Virtual \u00e9 uma interface de usu\u00e1rio de alta\n\ncomplexidade que envolve simula\u00e7\u00e3o e intera\u00e7\u00f5es atrav\u00e9s de m\u00faltiplos canais\n\nsensoriais.\" (Burdea &amp; Coiffet, 1994, p. 4) Elaboram ainda mais dizendo que a partir\n\ndesta defini\u00e7\u00e3o fica claro que um ambiente virtual deve ser imersivo (por isso os\n\nm\u00faltiplos canais sensoriais) e interativo.\n\nKirner (1998) define realidade virtual como uma t\u00e9cnica de interface com o\n\nusu\u00e1rio onde ele pode realizar imers\u00e3o, intera\u00e7\u00e3o e navega\u00e7\u00e3o em um ambiente virtual\n\ntridimensional gerado por computador, utilizando canais multi-sensoriais.\n\n\n\n46\n\nA interatividade \u00e9, de fato, considerada por todos os autores como um\n\n\"ingrediente\" essencial da realidade virtual. Sem a capacidade de alterar o mundo\n\nvirtual e ver as conseq\u00fc\u00eancias de suas a\u00e7\u00f5es, o usu\u00e1rio dificilmente tem o sentimento de\n\nimers\u00e3o.\n\nJ\u00e1 a imers\u00e3o \u00e9 mais problem\u00e1tica, principalmente porque tamb\u00e9m n\u00e3o tem uma\n\ndefini\u00e7\u00e3o clara. Burdea &amp; Coiffet definem imers\u00e3o como \"a sensa\u00e7\u00e3o de fazer parte da\n\na\u00e7\u00e3o [se desenrolando] na tela.\" (Burdea &amp; Coiffet, 1994, p. 4) E acrescentam que, ao\n\nestimular mais de um sentido, essa sensa\u00e7\u00e3o \u00e9 aumentada. J\u00e1 Vince (1995) n\u00e3o d\u00e1 uma\n\ndefini\u00e7\u00e3o exata para imers\u00e3o, mas afirma que um elemento cr\u00edtico para se obter esta\n\nsensa\u00e7\u00e3o \u00e9 um sistema gr\u00e1fico que d\u00ea ao usu\u00e1rio uma vista realista e em primeira pessoa\n\ndo mundo virtual e que seja diretamente controlada pelo usu\u00e1rio. Vince, no entanto, n\u00e3o\n\nconsidera que a imers\u00e3o seja um componente essencial para realidade virtual, como\n\npode ser visto por sua classifica\u00e7\u00e3o de sistemas de RV em imersivos, n\u00e3o-imersivos ou\n\nh\u00edbridos.\n\nPara Vince, sistemas h\u00edbridos s\u00e3o sistemas que combinam imagens do mundo\n\nreal com imagens virtuais, formando o que costuma se chamar Realidade Aumentada.\n\nJ\u00e1 a classifica\u00e7\u00e3o como imersivo ou n\u00e3o-imersivo \u00e9 feita (como condenam Burdea &amp;\n\nCoiffet) com base nos dispositivos de sa\u00edda utilizados. Quando se utilizam \"dispositivos\n\nimersivos\" (HMDs, \u00f3culos estereosc\u00f3picos, dispositivos que exibem imagens que\n\nocupam uma grande parte do campo de vis\u00e3o etc.), trata-se de um sistema imersivo.\n\nMas mesmo que se utilize meramente um monitor convencional o sistema ainda pode\n\n                                                                                                                                              \n\n7 Head Mounted Displays\n\n\n\n47\n\nser considerado um sistema de realidade virtual. \u00c9 como se o mundo virtual existisse\n\nmas pudesse ser visto somente atrav\u00e9s de uma \"janela\" (a tela do monitor).\n\nPimentel &amp; Teixeira (1995) concordam com a id\u00e9ia que um ambiente virtual\n\npode existir e ser visualizado sem nenhum dispositivo especial. Estes autores d\u00e3o uma\n\ndefini\u00e7\u00e3o mais abrangente de imers\u00e3o como uma vari\u00e1vel cont\u00ednua (ao inv\u00e9s de\n\nbooleana, imersivo ou n\u00e3o) que depende da combina\u00e7\u00e3o de diversos fatores, como\n\ninteratividade, velocidade de atualiza\u00e7\u00e3o, complexidade da imagem, som (Pimentel &amp;\n\nTeixeira n\u00e3o citam outros sentidos, mas poderiam ser encaixados aqui conforme a\n\ndefini\u00e7\u00e3o de Burdea &amp; Coiffet), resolu\u00e7\u00e3o da imagem, estereoscopia, tamanho do\n\ncampo de vis\u00e3o, sistema gr\u00e1fico, dentre outros. Sendo assim, uma aplica\u00e7\u00e3o pode ser\n\nbastante imersiva (e classificada como RV) mesmo utilizando um monitor\n\nconvencional, se os outros fatores compensarem este detalhe.\n\nContinua, no entanto, a d\u00favida quanto a este ambiente para visualiza\u00e7\u00e3o de\n\nrisers. Todos os autores d\u00e3o grande import\u00e2ncia \u00e0 interatividade como elemento\n\nfundamental para um sistema de realidade virtual, o que sugere uma an\u00e1lise um pouco\n\nmais detalhada de como \u00e9 a interatividade no ambiente em quest\u00e3o.\n\nComo j\u00e1 foi dito, o usu\u00e1rio pode controlar seu ponto de vista, navegando\n\nlivremente pela cena, assim como a velocidade da anima\u00e7\u00e3o dos objetos do mundo.\n\nPode ainda escolher quais objetos s\u00e3o exibidos ou n\u00e3o. Por isso, a aplica\u00e7\u00e3o \u00e9 sem\n\nd\u00favida interativa.\n\nNo entanto, o usu\u00e1rio n\u00e3o tem nenhum controle sobre os objetos da cena em si.\n\nEle n\u00e3o pode mudar um riser ou uma plataforma de lugar (o que n\u00e3o faria sentido, j\u00e1\n\n\n\n48\n\nque o objetivo do ambiente \u00e9 visualizar a din\u00e2mica do sistema sem essas interfer\u00eancias)\n\nnem ver o efeito ao \"furar\" uma onda com seu \"corpo virtual\". O usu\u00e1rio nem mesmo\n\ncolide com elementos da cena (isso poderia fazer com que alguns pontos de vista de\n\ninteresse fossem dif\u00edceis ou imposs\u00edveis de alcan\u00e7ar dependendo da configura\u00e7\u00e3o da\n\ncena). Ele tamb\u00e9m nunca pode ver nenhuma parte de seu \"corpo\" (um bra\u00e7o, m\u00e3o ou\n\numa face refletida em uma superf\u00edcie qualquer por exemplo). Ou seja, o usu\u00e1rio\n\nconsegue interagir com a visualiza\u00e7\u00e3o mas n\u00e3o tem nenhuma maneira de interagir\n\ndiretamente com o mundo que est\u00e1 sendo mostrado na cena. Isso, mais que qualquer\n\noutro fator, \u00e9 o que n\u00e3o permite a classifica\u00e7\u00e3o do RiserView como um ambiente\n\nvirtual, ainda que possua diversas caracter\u00edsticas em comum com um. De fato, o\n\nRiserView \u00e9 um ambiente que combina elementos de RV com Visualiza\u00e7\u00e3o Cient\u00edfica.\n\nEsta conclus\u00e3o parece concordar com a descri\u00e7\u00e3o que Hearn e Baker (1997) d\u00e3o para\n\nrealidade virtual: uma tecnologia que permite ao usu\u00e1rio adentrar uma cena e interagir\n\ncom elementos daquele ambiente.\n\nA discuss\u00e3o sobre Realidade Virtual prossegue com um breve relato de sua\n\nhist\u00f3ria. Depois disso ser\u00e1 explorada tamb\u00e9m a estereoscopia. Por fim, ser\u00e1 discutido o\n\nuso destas t\u00e9cnicas na industria de explora\u00e7\u00e3o mar\u00edtima de petr\u00f3leo.\n\n2.3.1. Breve Hist\u00f3rico\n\nDe acordo com Burdea &amp; Coiffet (1994), a origem da realidade virtual pode ser\n\ntra\u00e7ada, para surpresa dos que imaginam ser uma disciplina bastante moderna, a 1962.\n\n\n\n49\n\nEste foi o ano em que Morton Heilig (um cinemat\u00f3grafo, n\u00e3o um engenheiro) registrou\n\nseu invento, o \"Sensorama\". Tratava-se de uma esta\u00e7\u00e3o com v\u00eddeo 3D colorido\n\n(utilizando duas c\u00e2meras de 35 mm), movimento (atrav\u00e9s do assento que podia se\n\nmover e vibrar), som est\u00e9reo, aromas e at\u00e9 vento (atrav\u00e9s de pequenos ventiladores\n\npr\u00f3ximos da cabe\u00e7a do usu\u00e1rio).\n\nAntes mesmo do Sensorama, Heilig j\u00e1 havia patenteado algo similar a um HMD,\n\nmas foi Sutherland, em 1966 que criou o primeiro HMD usando dois CRTs, uma\n\nconfigura\u00e7\u00e3o que persiste at\u00e9 os dias atuais em diversas aplica\u00e7\u00f5es. Como os CRTs da\n\n\u00e9poca eram consideravelmente mais pesados que os atuais, no entanto, Sutherland teve\n\nque montar um bra\u00e7o mec\u00e2nico para suportar parte do peso. Este bra\u00e7o servia tamb\u00e9m\n\npara determinar a posi\u00e7\u00e3o da cabe\u00e7a do usu\u00e1rio (head-tracking) para que as imagens\n\nexibidas pudessem ser modificadas conforme seus movimentos. Esta t\u00e9cnica tamb\u00e9m \u00e9\n\nusada at\u00e9 os dias de hoje, mas s\u00e3o utilizados meios que n\u00e3o exigem contato para\n\ndeterminar a posi\u00e7\u00e3o (por exemplo magnetos, ultra-som, infravermelho ou laser).\n\nEm 1973 Evans e Sutherland desenvolveram o \"gerador de cenas\", o precursor\n\ndos modernos aceleradores gr\u00e1ficos, para utilizar cenas geradas por computador em vez\n\nde imagens anal\u00f3gicas provenientes de c\u00e2meras nos seus HMDs. Esse \"gerador de\n\ncenas\" era capaz de renderizar (sintetizar, iluminar e exibir) cenas com 200 a 400\n\npol\u00edgonos a aproximadamente 20 quadros/s.\n\nNas d\u00e9cadas de 70 e 80 as pesquisas na \u00e1rea foram estimuladas pelo interesse\n\nmilitar, principalmente na \u00e1rea de simuladores de v\u00f4o para treinamento de pilotos. Com\n\nfinalidade semelhante a NASA, em 1981, cria o primeiro HMD com telas de cristal\n\nl\u00edquido (LCD).\n\n\n\n50\n\nEm 1988 Fisher e Wendel criaram o primeiro hardware capaz de manipular som\n\n3D e em 1992 foi desenvolvida a primeira vers\u00e3o do \"WorldToolkit\", um pacote de\n\nsoftware comercial para o desenvolvimento de mundos virtuais que indicava que a\n\ntecnologia j\u00e1 n\u00e3o era mais t\u00e3o especializada e restrita.\n\n2.3.2. Sensa\u00e7\u00e3o de Profundidade e Estereoscopia\n\nDe acordo com Burdea &amp; Coiffet (1994), a percep\u00e7\u00e3o de profundidade pela\n\nvis\u00e3o humana pode ocorrer com um olho s\u00f3 ou com a coopera\u00e7\u00e3o de ambos. Se somente\n\num olho \u00e9 usado, essa percep\u00e7\u00e3o \u00e9 baseada em \"pistas\" (cues) inerentes \u00e0 cena, como:\n\n\u2022 Perspectiva;\n\n\u2022 Oclus\u00e3o dos objetos que est\u00e3o atr\u00e1s de outros;\n\n\u2022 N\u00edvel de detalhe percebido (que \u00e9 menor quanto maior a dist\u00e2ncia);\n\n\u2022 Paralaxe para objetos se movendo em rela\u00e7\u00e3o ao observador (objetos mais pr\u00f3ximos\n\nparecem se mover mais e mais r\u00e1pido);\n\n\u2022 Sombras (de um objeto sobre o outro).\n\nA maioria dessas pistas de profundidade j\u00e1 \u00e9 levada em conta nos sistemas\n\ngr\u00e1ficos que renderizam cenas em tr\u00eas dimens\u00f5es, embora ocasionalmente seja\n\nnecess\u00e1rio um cuidado maior com a paralaxe, e o c\u00e1lculo de sombras de um objeto\n\nsobre outro nem sempre seja fact\u00edvel em tempo real.\n\n\n\n51\n\nO mecanismo mais importante para a maioria das pessoas para percep\u00e7\u00e3o de\n\nprofundidade, no entanto, ocorre quando ambos os olhos registram imagens\n\nligeiramente diferentes para uma cena e o c\u00e9rebro interpreta a diferen\u00e7a entre essas\n\nimagens como medida de profundidade. A isto \u00e9 que chamamos estereoscopia.\n\nA figura 10 ilustra como um objeto \u00e9 visto diferentemente por cada olho. Qu\u00e3o\n\ndiferente s\u00e3o essas vistas \u00e9 fun\u00e7\u00e3o da dist\u00e2ncia entre o objeto e o observador (quanto\n\nmenor a dist\u00e2ncia, maior a diferen\u00e7a). A linha vermelha indica o centro da cena para\n\ncada olho para servir como refer\u00eancia e n\u00e3o faz parte da cena renderizada para cada\n\nolho, mas foi acrescentada posteriormente. O resultado da interpreta\u00e7\u00e3o pelo c\u00e9rebro\n\ndessas duas imagens se cada uma estivesse sendo vista ao mesmo tempo somente pelo\n\nolho correto seria um objeto com apar\u00eancia de profundidade, tridimensional, como se o\n\nnavio \"saltasse\" do papel.\n\nFigura 10 - Estereoscopia\n\n\n\n52\n\nPara reproduzir a estereoscopia normalmente \u00e9 necess\u00e1rio algum hardware\n\nespec\u00edfico para esse fim. Gerar uma imagem diferente para cada olho \u00e9 bastante\n\nsimples, basta, por exemplo, mover o observador (ou a c\u00e2mera) para a posi\u00e7\u00e3o adequada\n\ne renderizar cada cena. Fazer com que cada olho do usu\u00e1rio enxergue a cena correta, e\n\nsomente a cena correta, no entanto, faz necess\u00e1rio o uso de dispositivos como o HMD\n\nmencionado anteriormente, com uma tela para cada olho. Outra op\u00e7\u00e3o s\u00e3o \u00f3culos que,\n\nem sincronia com o sistema de exibi\u00e7\u00e3o (seja um projetor ou um monitor, por exemplo)\n\npermitam que se veja ora atrav\u00e9s de uma de suas lentes, ora atrav\u00e9s de outra. Uma\n\nsolu\u00e7\u00e3o mais barata e comum que permite separar a imagem vista por cada olho \u00e9 a\n\ngera\u00e7\u00e3o de imagens com cores diferentes para cada olho, cores que s\u00e3o filtradas por\n\n\u00f3culos com lentes coloridas usados pelo usu\u00e1rio.\n\n2.3.3. Uso destas T\u00e9cnicas na Ind\u00fastria do Petr\u00f3leo\n\nComo foi dito anteriormente, v\u00e1rios problemas nesta ind\u00fastria s\u00e3o\n\neminentemente tridimensionais e portanto podem ter sua visualiza\u00e7\u00e3o aprimorada\n\nutilizando estereoscopia. Atualmente as maiores aplica\u00e7\u00f5es de RV na ind\u00fastria de\n\npetr\u00f3leo est\u00e3o nas \u00e1reas de explora\u00e7\u00e3o de reservat\u00f3rios e projeto e constru\u00e7\u00e3o de\n\ninstala\u00e7\u00f5es para a explora\u00e7\u00e3o desses reservat\u00f3rios, embora no futuro a possibilidade do\n\nuso de RV para o monitoramento da produ\u00e7\u00e3o n\u00e3o pare\u00e7a remota.\n\nNa \u00e1rea de projeto de instala\u00e7\u00f5es, projetos como o Tanque de Provas Num\u00e9rico\n\n(2004) ilustram como a realidade virtual pode facilitar a compreens\u00e3o de fen\u00f4menos que\n\n\n\n53\n\nafetam estruturas como risers e plataformas e utilizar essa compreens\u00e3o no projeto\n\ndessas estruturas. Outro exemplo \u00e9 a aplica\u00e7\u00e3o para an\u00e1lise de amarra\u00e7\u00e3o de plataformas\n\ncitada por Silveira et al. (2000).\n\nBirken &amp; Versteeg (2000) citam uma aplica\u00e7\u00e3o interessante de m\u00e9todos\n\navan\u00e7ados de visualiza\u00e7\u00e3o cient\u00edfica que tamb\u00e9m s\u00e3o beneficiados por t\u00e9cnicas como\n\nestereoscopia, na \u00e1rea de explora\u00e7\u00e3o de reservat\u00f3rios. Trata-se da interpreta\u00e7\u00e3o de dados\n\nprovenientes de testes s\u00edsmicos 4D (ou 3D com lapso de tempo) e testes de GPR 4D8. O\n\nprinc\u00edpio destes testes \u00e9 simples. Comparando resultados de testes feitos em intervalos\n\nde tempo pequenos o suficiente de forma que n\u00e3o possa ocorrer deslocamentos\n\nsignificativos das parcelas s\u00f3lidas do solo, as diferen\u00e7as entre os testes se devem,\n\nnecessariamente, a deslocamentos de fluidos e a partir da\u00ed pode-se determinar\n\npropriedades hidrogeol\u00f3gicas do solo. De acordo com a Petrobras (2001), a\n\ninterpreta\u00e7\u00e3o dessas informa\u00e7\u00f5es por especialistas permite uma compreens\u00e3o mais clara\n\nda geometria externa bem como da arquitetura interna dos reservat\u00f3rios, permitindo n\u00e3o\n\ns\u00f3 planejar aonde, mas como explor\u00e1-los.\n\nDe acordo com Birken &amp; Versteeg (2000) os testes s\u00edsmicos que eram pioneiros\n\nno come\u00e7o da d\u00e9cada de 90 hoje j\u00e1 s\u00e3o bem conhecidos e utilizados pela ind\u00fastria de\n\npetr\u00f3leo para monitorar mudan\u00e7as nos reservat\u00f3rios de hidrocarbonos e fazer\n\nmanuten\u00e7\u00e3o desses reservat\u00f3rios. O uso de RV na interpreta\u00e7\u00e3o desses dados, conforme\n\na Petrobras (1999), permite que o tempo para a interpreta\u00e7\u00e3o desses dados para o\n\nmapeamento de reservat\u00f3rios caia de meses para meras horas. O que Birken &amp; Versteeg\n\n                                                \n\n8 Ground Penetrating Radar. O 4D refere-se \u00e0s tr\u00eas dimens\u00f5es do espa\u00e7o, mais o tempo.\n\n\n\n54\n\nprop\u00f5em \u00e9 usar a t\u00e9cnica semelhante com GPR para manuten\u00e7\u00e3o de reservat\u00f3rios\n\nsubterr\u00e2neos de \u00e1gua pot\u00e1vel.\n\n2.4. Orienta\u00e7\u00e3o a Objetos, Metodologia de Projeto e UML.\n\nNesta se\u00e7\u00e3o s\u00e3o discutidos alguns aspectos importantes para a compreens\u00e3o da\n\nmetodologia atrav\u00e9s da qual \u00e9 implementada a solu\u00e7\u00e3o (utilizando as t\u00e9cnicas de\n\nrealidade virtual e visualiza\u00e7\u00e3o cient\u00edfica discutidas acima) para o problema da\n\nvisualiza\u00e7\u00e3o da din\u00e2mica de risers. A metodologia em si \u00e9 discutida no cap\u00edtulo 3 e seu\n\nuso \u00e9 relatado no cap\u00edtulo 4. Como um dos objetivos deste trabalho \u00e9 que o\n\ndesenvolvimento do software siga uma metodologia formal, deve ser feita uma an\u00e1lise\n\ndas vantagens e desvantagens dessa decis\u00e3o para justific\u00e1-la.\n\nA maior desvantagem que \u00e9 sempre levantada contra o uso de uma metodologia\n\nformal no desenvolvimento de software \u00e9 o tempo que \u00e9 dedicado a atividades que n\u00e3o\n\ngeram sequer uma linha de c\u00f3digo. Em primeiro lugar h\u00e1 o tempo de aprendizagem do\n\nprocesso, depois o tempo de planejamento do projeto e at\u00e9 durante o desenvolvimento\n\nh\u00e1 o tempo utilizado para a documenta\u00e7\u00e3o exigida pela metodologia.\n\nJ\u00e1 algumas das principais vantagens, de acordo com Jacobson et al. (1999a), s\u00e3o\n\nas seguintes:\n\nEm projetos envolvendo equipes de programadores (e projetistas, supervisores\n\netc.), o uso de um processo bem definido permite que cada um saiba sempre exatamente\n\no que est\u00e1 fazendo e como isto se encaixa com o projeto como um todo. Os\n\n\n\n55\n\nprogramadores tamb\u00e9m podem compreender melhor o que os outros membros da equipe\n\nest\u00e3o fazendo, o que facilita, por exemplo, as tarefas de integra\u00e7\u00e3o.  Os cronogramas\n\nficam bem definidos e cada um sabe quando pode contar com outros m\u00f3dulos do\n\nsistema (ou pelo menos sabe quando ocorrem atrasos).\n\nO processo n\u00e3o s\u00f3 imp\u00f5e uma fase de planejamento como tamb\u00e9m fornece uma\n\nestrutura para apoiar e guiar este planejamento. Um planejamento bem feito n\u00e3o s\u00f3 evita\n\na necessidade de retrabalhos como facilita o reaproveitamento de c\u00f3digo (identificando\n\na priori elementos em comum que podem ser encapsulados para serem reutilizados) e\n\numa arquitetura bem planejada tipicamente \u00e9 mais facilmente expans\u00edvel. Isso vale at\u00e9\n\nmesmo para projetos envolvendo uma s\u00f3 pessoa, mas torna-se mais e mais cr\u00edtico\n\nconforme o n\u00famero de participantes aumenta (pois os retrabalhos e mudan\u00e7as de\n\narquitetura, se necess\u00e1rios, s\u00e3o muito mais complexos neste caso).\n\nA metodologia tamb\u00e9m fornece uma estrutura bem definida para a gera\u00e7\u00e3o da\n\ndocumenta\u00e7\u00e3o do projeto. Se todos os envolvidos est\u00e3o familiarizados com esta\n\nestrutura, encontrar a informa\u00e7\u00e3o de que precisam na documenta\u00e7\u00e3o torna-se simples e\n\nr\u00e1pido. Mas ainda mais importante, a estrutura tenta garantir que informa\u00e7\u00f5es\n\nimportantes n\u00e3o sejam perdidas durante o processo. Se o sistema deve ser expans\u00edvel\n\npara ser modificado no futuro, possivelmente por uma equipe diferente, uma\n\ndocumenta\u00e7\u00e3o completa e organizada \u00e9 essencial.\n\nJacobson et al. (1999) ainda citam diversas outras vantagens, como o aumento\n\nda repetibilidade do desenvolvimento (ou seja, o processo de desenvolvimento sempre\n\nsegue os mesmos passos, mesmo para projetos bastante diferentes, e esta estrutura\n\n\n\n56\n\npermite que se estime melhor os tempos e recursos necess\u00e1rios em cada etapa,\n\nbaseando-se em projetos anteriores), mas as citadas acima s\u00e3o as principais.\n\nCom base nesta an\u00e1lise, foi considerado interessante aplicar uma metodologia\n\nformal mesmo num projeto de pequena escala como o desenvolvido neste trabalho, com\n\nsomente um programador. Al\u00e9m disso, uma das caracter\u00edsticas de uma boa metodologia\n\n\u00e9 que seja adapt\u00e1vel a projetos de diferentes escalas.\n\nA metodologia escolhia e que ser\u00e1 descrita no cap\u00edtulo 3, o Processo Unificado\n\n(UP), exige a utiliza\u00e7\u00e3o da orienta\u00e7\u00e3o a objetos e da linguagem UML. Por isso, antes de\n\numa discuss\u00e3o mais detalhada do UP, \u00e9 interessante fazer uma breve exposi\u00e7\u00e3o sobre\n\nesses dois temas.\n\n2.4.1. Orienta\u00e7\u00e3o a Objetos\n\nTakahashi (1990) afirma que o paradigma de objetos \u00e9 a grande evolu\u00e7\u00e3o na \u00e1rea\n\nde desenvolvimento de software ap\u00f3s as id\u00e9ias de programa\u00e7\u00e3o estruturada da d\u00e9cada de\n\n70. Flatt et al. (1998) contam que este paradigma surgiu devido \u00e0 escala cada vez maior\n\ndos sistemas de software sendo desenvolvidos e da necessidade de se reutilizar o maior\n\nn\u00famero de componentes poss\u00edvel. O paradigma de objetos, apesar de sua origem, n\u00e3o\n\nest\u00e1 limitado \u00e0 programa\u00e7\u00e3o. Luckas &amp; D\u00f6rner (2000) exemplificam uma transposi\u00e7\u00e3o\n\ndeste paradigma para a \u00e1rea de anima\u00e7\u00e3o 3D, onde seus animation elements se\n\ncomportam como classes de objetos. Mas qual \u00e9 a diferen\u00e7a entre sistemas orientados a\n\nobjetos e sistemas convencionais?\n\n\n\n57\n\nSchroeder et al. (1998) afirmam que a maior diferen\u00e7a est\u00e1 na forma como\n\nambos abstraem os dados. Num sistema procedural esta abstra\u00e7\u00e3o est\u00e1 limitada a\n\ntipifica\u00e7\u00e3o dos dados (data typing). J\u00e1 nos sistemas orientados a objetos s\u00e3o criadas\n\nabstra\u00e7\u00f5es tanto para os dados quanto para as opera\u00e7\u00f5es que podem ser aplicadas sobre\n\neles.\n\nCom base nessa afirma\u00e7\u00e3o, pode-se definir objeto como \"uma abstra\u00e7\u00e3o que\n\nmodela o estado e o comportamento de entidades em um sistema.\" (Schroeder et al.,\n\n1998, p. 21). O estado do objeto \u00e9 definido pelos seus atributos, ou seja, os dados\n\nintr\u00ednsecos ao objeto. J\u00e1 seu comportamento \u00e9 definido por seus m\u00e9todos, que s\u00e3o as\n\nopera\u00e7\u00f5es que podem ser feitas sobre o objeto. Atributos e m\u00e9todos de um objeto\n\nanalisados em conjunto constituem as propriedades deste objeto.\n\nObjetos com as mesmas propriedades (mas ainda assim objetos distintos, pois os\n\nvalores destas propriedades podem variar) podem ser agrupados atrav\u00e9s da\n\nclassifica\u00e7\u00e3o. Uma classe de objetos, dessa forma, pode ser usada para definir as\n\npropriedades de todos os objetos daquela classe. Para utilizar um objeto de uma classe\n\ndefinida assim, cria-se uma inst\u00e2ncia desta classe. Takahashi (1990) explica que a\n\ninstancia\u00e7\u00e3o \u00e9 a \"opera\u00e7\u00e3o inversa\" da classifica\u00e7\u00e3o. Ao instanciar uma classe, cria-se\n\num objeto daquela classe com uma identidade pr\u00f3pria e valores iniciais para os seus\n\natributos.\n\nUm conceito importante da orienta\u00e7\u00e3o a objetos \u00e9 a heran\u00e7a. Atrav\u00e9s deste\n\nmecanismo, a cria\u00e7\u00e3o de novas classes que diferem pouco de classes j\u00e1 existentes \u00e9\n\nsignificativamente simplificado. Uma classe que estende ou deriva uma classe j\u00e1\n\nexistente herda as propriedades desta e s\u00f3 \u00e9 necess\u00e1rio acrescentar as propriedades que\n\n\n\n58\n\ndistinguem a nova classe da antiga, ou modificar (override) m\u00e9todos da classe antiga.\n\nAssim n\u00e3o \u00e9 necess\u00e1rio duplicar c\u00f3digo j\u00e1 existente.\n\nOrganizar objetos numa hierarquia de classes traz tamb\u00e9m o benef\u00edcio de\n\npossibilitar a altera\u00e7\u00e3o de v\u00e1rios objetos simultaneamente ao se alterar uma classe de\n\nque todos derivam. Essa hierarquia pode ser criada atrav\u00e9s dos processos de\n\nespecializa\u00e7\u00e3o (indo das classes mais gerais para as mais espec\u00edficas) ou de\n\ngeneraliza\u00e7\u00e3o (agrupando elementos de classes espec\u00edficas em classes mais gerais).\n\nPodem existir classes, inclusive, cuja \u00fanica finalidade \u00e9 servirem como superclasses na\n\nhierarquia (ou seja, terem outras classes derivadas a partir delas), sem nunca serem\n\ninstanciadas. De acordo com Schroeder et al. (1998), essas classes geralmente n\u00e3o\n\npodem ser instanciadas s\u00e3o denominadas abstratas.\n\nEsta facilidade de acrescentar novas classes ao sistema para aumentar sua\n\nfuncionalidade explica porque a orienta\u00e7\u00e3o a objetos favorece a expansibilidade do\n\nsistema.\n\nOutra caracter\u00edstica  importante da orienta\u00e7\u00e3o a objetos \u00e9 o polimorfismo.\n\nSebesta (2000) explica que classes que estendem uma classe abstrata podem\n\nimplementar seus m\u00e9todos de forma diferente. No entanto, esses m\u00e9todos continuam\n\ntendo o mesmo nome (o nome que t\u00eam na superclasse). Dessa forma, chamadas a\n\nm\u00e9todos de mesmo nome e com os mesmos par\u00e2metros podem ter comportamentos\n\ndiferentes, dependendo do tipo do objeto que est\u00e1 sendo utilizado. Isso n\u00e3o s\u00f3 pode\n\nsimplificar o c\u00f3digo mas tamb\u00e9m permite que este seja padronizado e que sua\n\ncompreens\u00e3o seja facilitada ao se usar nomes de m\u00e9todos que descrevem melhor a\n\nfun\u00e7\u00e3o que realizam. Por exemplo, no ambiente de visualiza\u00e7\u00e3o de risers classes t\u00e3o\n\n\n\n59\n\ndistintas quanto a que representa as ondas do mar e a que representa os risers t\u00eam em\n\ncomum a fun\u00e7\u00e3o \"Show\", que controla a exibi\u00e7\u00e3o destes elementos na tela.\n\nFun\u00e7\u00f5es de uma mesma classe tamb\u00e9m podem ter o mesmo nome, desde que\n\ntenham par\u00e2metros distintos (overloading). Por exemplo, duas fun\u00e7\u00f5es que movem um\n\nobjeto, uma que recebe as novas coordenadas como tr\u00eas n\u00fameros distintos e outra que\n\nas recebe como um vetor de tr\u00eas n\u00fameros, podem ambas chamar-se \"Move\".\n\n2.4.2. A Unified Modeling Language (UML)\n\nBooch et al. (1998) definem a UML como uma linguagem padr\u00e3o para cria\u00e7\u00e3o\n\nde \"plantas\" (ou modelos) de um sistema de software, da mesma forma que outras \u00e1reas\n\nda engenharia se utilizam de esquemas ou desenhos para melhor visualizar e comunicar\n\nid\u00e9ias e estruturas. Al\u00e9m disso, a UML tem uma sem\u00e2ntica bem definida, de forma que\n\num diagrama confeccionado utilizando esta linguagem pode ser interpretado de forma\n\nn\u00e3o-amb\u00edgua, inclusive por ferramentas computacionais. Outra caracter\u00edstica importante\n\n\u00e9 que a UML \u00e9 voltada especificamente para a especifica\u00e7\u00e3o e documenta\u00e7\u00e3o de\n\nsistemas de software.\n\nA UML define diversos tipos diferentes de diagrama, cada um voltado para a\n\ndescri\u00e7\u00e3o de um aspecto da arquitetura do sistema. Uma descri\u00e7\u00e3o de todos estes\n\ndiagramas (e dos elementos que os comp\u00f5em) n\u00e3o faz parte do escopo deste trabalho e \u00e9\n\ndesnecess\u00e1ria, pois \u00e9 feita de forma bastante completa por Booch et al. (1998). No\n\nentanto, dois diagramas merecem men\u00e7\u00e3o por serem os mais comuns na modelagem de\n\n\n\n60\n\nsistemas orientados a objetos. O primeiro \u00e9 o diagrama de classes, que representa um\n\nconjunto de classes, suas propriedades e inter-relacionamentos. O segundo s\u00e3o\n\ndiagramas de casos de uso, que representam as rela\u00e7\u00f5es entre conjuntos de casos de uso\n\ne atores. Os principais elementos componentes destes diagramas s\u00e3o apresentados na\n\nfigura 11.\n\nFigura 11 - Elementos da UML\n\nNessa figura, um pacote representa um conjunto de classes que implementam\n\num subconjunto do sistema. As defini\u00e7\u00f5es de classe e atributo foram dadas na se\u00e7\u00e3o\n\nanterior. Opera\u00e7\u00e3o ou fun\u00e7\u00e3o s\u00e3o outras formas de se referir aos m\u00e9todos de uma classe\n\ntamb\u00e9m explicados anteriormente. Casos de uso (e atores) s\u00e3o conceitos importantes\n\npara a metodologia escolhida mas ser\u00e3o definidos somente nos cap\u00edtulos 3 e 4 onde essa\n\n\n\n61\n\nmetodologia \u00e9 discutida. Uma associa\u00e7\u00e3o simplesmente explicita alguma rela\u00e7\u00e3o entre\n\nduas classes ou objetos e normalmente \u00e9 acompanhada de uma descri\u00e7\u00e3o. Uma\n\ngeneraliza\u00e7\u00e3o explicita a rela\u00e7\u00e3o entre uma classe e sua classe base (casos de uso\n\ntamb\u00e9m podem ser generalizados). Uma agrega\u00e7\u00e3o indica que uma classe \u00e9 formada por\n\nobjetos de outras classes (que est\u00e3o agregados a ela) e uma composi\u00e7\u00e3o \u00e9 um caso\n\nparticular de agrega\u00e7\u00e3o que indica unicidade, ou seja, a classe tem somente um\n\ncomponente daquele tipo e o componente pertence somente \u00e0quela classe. O exemplo\n\nda figura 12 \u00e9 um diagrama de classes auxilia na compreens\u00e3o desses conceitos:\n\nFigura 12 - Exemplo de diagrama de classes em UML\n\nA agrega\u00e7\u00e3o indica que uma escola conta com v\u00e1rios professores (e a\n\nmultiplicidade est\u00e1 indicada pelo \"1..n\", que poderia ser tamb\u00e9m \"1..*\"), mas a\n\ncomposi\u00e7\u00e3o indica que conta com somente um diretor. Tanto Diretor quanto Professor\n\ns\u00e3o derivados da classe mais geral, Pessoa, e existe uma associa\u00e7\u00e3o indicando que o\n\ndiretor \u00e9 o chefe dos professores.\n\nAl\u00e9m disso, ao listar atributos e opera\u00e7\u00f5es das classes indica-se se s\u00e3o p\u00fablicos,\n\nprotegidos ou privados com os seguintes sinais antepostos ao nome do elemento:\n\n\n\n62\n\n+ indica um elemento p\u00fablico;\n\n-  indica um elemento privado;\n\n# indica um elemento protegido.\n\n2.5. Padr\u00f5es de Projeto e Arquitetura\n\nJacobson et al. (1998) afirma que para desenvolver um sistema com uma boa\n\narquitetura pode-se lan\u00e7ar m\u00e3o da experi\u00eancia que outros desenvolvedores acumularam\n\nao longo dos anos ao se utilizar de algumas \"solu\u00e7\u00f5es gen\u00e9ricas\" que foram evoluindo\n\npara tratar de classes de problemas recorrentes. Essas solu\u00e7\u00f5es s\u00e3o chamados de\n\npadr\u00f5es (patterns). Padr\u00f5es de Arquitetura (Architecture Patterns), como o padr\u00e3o de\n\nCamadas (Layers) ou o MVC (Model-View-Controller) s\u00e3o solu\u00e7\u00f5es para aspectos da\n\narquitetura do sistema como um todo. J\u00e1 Padr\u00f5es de Projeto (Design Patterns) s\u00e3o\n\nsolu\u00e7\u00f5es para problemas de natureza mais espec\u00edfica e pontual que ocorrem comumente\n\ndurante o projeto de software. Exemplos destes padr\u00f5es s\u00e3o as F\u00e1bricas de Objetos\n\n(Object Factories) e Observadores (Observers).\n\nA id\u00e9ia dos padr\u00f5es surgiu na \u00e1rea de arquitetura (n\u00e3o arquitetura de software,\n\nmas a que se encarrega de casas, pr\u00e9dios etc.)  na d\u00e9cada de 70 com Alexander, que\n\nafirma:\n\n\"Cada padr\u00e3o descreve um problema que ocorre repetidamente em nosso\nambiente e ent\u00e3o descreve o cerne de uma solu\u00e7\u00e3o para aquele problema, de forma que\npode-se utilizar esta solu\u00e7\u00e3o um milh\u00e3o de vezes, sem nunca faz\u00ea-lo da mesma forma.\"\n(Alexander et al., 1977, apud. Gamma et al., 1997)\n\n\n\n63\n\nO ambiente desenvolvido neste trabalho faz uso de diversos destes padr\u00f5es, de\n\nforma expl\u00edcita ou impl\u00edcita. O padr\u00e3o de Camadas, por exemplo, est\u00e1 impl\u00edcito na\n\narquitetura do software ao se utilizar uma biblioteca para desenvolvimento da GUI9 e\n\numa biblioteca gr\u00e1fica (que por sua vez representa uma camada sobre o OpenGL). Este\n\npadr\u00e3o, como explicam Jacobson et al. (1998), organiza os componentes de um sistema\n\nem camadas, de forma que cada componente s\u00f3 pode acessar outros componentes na\n\ncamada diretamente abaixo da sua. O VTK (a biblioteca gr\u00e1fica utilizada, que ser\u00e1\n\ndiscutida com mais detalhe adiante) tamb\u00e9m se utiliza de diversos Padr\u00f5es de Projeto\n\nque precisam ser utilizados no desenvolvimento do sistema. Os padr\u00f5es de F\u00e1bricas de\n\nObjetos, Observador e Estrat\u00e9gia (Strategy) existentes no VTK, por exemplo, s\u00e3o\n\nmanipulados diretamente pelo sistema.\n\nExplicitamente o padr\u00e3o mais vis\u00edvel na arquitetura deste sistema \u00e9 o MVC. Veit\n\n&amp; Herrmann (2003) relatam que apesar deste paradigma ter se popularizado com o\n\nSmalltalk no come\u00e7o da d\u00e9cada de 80, at\u00e9 hoje o MVC \u00e9 um padr\u00e3o muito usado. Por\n\nexemplo, \u00e9 levado em conta na maioria das bibliotecas modernas de widgets para\n\ninterfaces gr\u00e1ficas. A fun\u00e7\u00e3o deste padr\u00e3o \u00e9 separar dados intr\u00ednsecos ao problema que o\n\nsoftware se disp\u00f5e a solucionar de dados necess\u00e1rios para a visualiza\u00e7\u00e3o ou interface. O\n\nModelo (Model) \u00e9 uma classe que cont\u00e9m estes dados intr\u00ednsecos \u00e0 aplica\u00e7\u00e3o, \u00e9 uma\n\nabstra\u00e7\u00e3o de uma entidade relacionada a um dom\u00ednio (uma entidade f\u00edsica, ou gr\u00e1fica,\n\nou matem\u00e1tica...) que n\u00e3o tem nenhum conhecimento da interface. Vistas (Views) s\u00e3o as\n\nrepresenta\u00e7\u00f5es do Modelo na interface. Um modelo pode ter diversas vistas. Por\n\nexemplo, numa aplica\u00e7\u00e3o hipot\u00e9tica, o modelo de um riser pode ter uma vista que \u00e9\n\n                                                \n\n9 Graphic User Interface ou Interface Gr\u00e1fica com o Usu\u00e1rio\n\n\n\n64\n\numa tabela com coordenadas e valores de escalares em alguns de seus pontos, outra\n\nvista composta por gr\u00e1ficos bidimensionais com as proje\u00e7\u00f5es do riser nos planos\n\ncartesianos e uma terceira vista com uma representa\u00e7\u00e3o do riser em tr\u00eas dimens\u00f5es,\n\ncada uma com uma interface distinta. Cada Vista \u00e9 gerenciada por um Controlador\n\n(Controller) que \u00e9 respons\u00e1vel pelas a\u00e7\u00f5es definidas na Vista com rela\u00e7\u00e3o ao modelo. O\n\ncontrolador \u00e9 que \"traduz\" mensagens de interface para a l\u00f3gica da aplica\u00e7\u00e3o. Sempre\n\nque o modelo \u00e9 modificado (seja por uma a\u00e7\u00e3o do usu\u00e1rio, seja por outro motivo\n\nqualquer) as Vistas e os Controladores devem ser modificados para se atualizarem, o\n\nque ali\u00e1s, como aponta Gamma et al. (1997) constitui um cl\u00e1ssico exemplo do padr\u00e3o\n\nde observador. O encapsulamento de informa\u00e7\u00f5es relativas \u00e0 interface nas Vistas e seu\n\ngerenciamento pelos Controladores leva a um c\u00f3digo mais limpo e elegante do modelo,\n\nque \u00e9 a base do software e s\u00f3 precisa tratar do seu dom\u00ednio.\n\nNo ambiente de visualiza\u00e7\u00e3o de risers, o Modelo cont\u00e9m os dados que\n\nrepresentam todos os objetos que fazem parte da cena. Existe uma Vista principal, que\n\nmostra a cena, mas alguns elementos da interface (como caixas de di\u00e1logo de op\u00e7\u00f5es\n\nque podem alterar dados do Modelo) podem ser consideradas Vistas secund\u00e1rias.\n\nSem entrar numa discuss\u00e3o detalhada sobre a arquitetura da aplica\u00e7\u00e3o neste\n\nponto, pode-se citar o uso de alguns padr\u00f5es de projeto no sistema em estudo:\n\n\u2022 F\u00e1bricas de Objetos para instancia\u00e7\u00e3o de classes de risers com dados de tipos\n\ndistintos (dom\u00ednio da freq\u00fc\u00eancia ou do tempo);\n\n\n\n65\n\n\u2022 Compostos (Composites) para lidar uniformemente com elementos de cena\n\n(v\u00f3rtices, solo, ondas) e com listas de elementos de cena (listas de risers, listas de\n\nmodelos);\n\n\u2022 Estado (State) para guardar os par\u00e2metros da c\u00e2mera.\n\n\u00c9 desnecess\u00e1rio descrever estes padr\u00f5es aqui, uma vez que Gamma et al. (1997)\n\nj\u00e1 catalogam estes (e diversos outros) padr\u00f5es com riqueza de detalhes.\n\n2.6. Portabilidade\n\nO termo portabilidade \u00e9 bastante abrangente. Pode aplicar-se ao c\u00f3digo (que ser\u00e1\n\nexplicada adiante), ao usu\u00e1rio (em quest\u00f5es relativas \u00e0 interface), a equipamentos (por\n\nexemplo no caso de drivers), ao programador (ao usar APIs), a dados, dentre outros.\n\nNesse trabalho, no entanto, a palavra \u00e9 usada para designar especificamente\n\nportabilidade do c\u00f3digo.\n\nLevy et al. (1996) afirmam que para maximizar a utiliza\u00e7\u00e3o e o retorno de\n\ninvestimento num software, ele deveria ser capaz de ser executado sobre diversas\n\nplataformas com um look-and-feel (a apar\u00eancia  e o comportamento que se esperam de\n\num software numa determinada plataforma) apropriado. A essa capacidade d\u00e1-se o\n\nnome de Portabilidade, que \u00e9, inclusive, um dos requisitos da aplica\u00e7\u00e3o desenvolvida\n\nneste trabalho, como citado anteriormente. Esta capacidade, no entanto, \u00e9 dif\u00edcil de se\n\nalcan\u00e7ar sem utilizar ferramentas adequadas, principalmente no caso de aplica\u00e7\u00f5es\n\ngr\u00e1ficas. Os principais fatores que dificultam a portabilidade s\u00e3o:\n\n\n\n66\n\n\u2022 diferen\u00e7as de hardware (por exemplo, ordena\u00e7\u00e3o dos bytes, endere\u00e7amento de\n\nmem\u00f3ria, resolu\u00e7\u00e3o de cores);\n\n\u2022 diferen\u00e7as entre sistemas operacionais e sistemas de arquivos (por exemplo,\n\ncapacidade de multiprocessamento, sensibilidade a mai\u00fasculas e min\u00fasculas);\n\n\u2022 diferen\u00e7as entre compiladores (por exemplo, tamanho do inteiro);\n\n\u2022 diferen\u00e7as entre as APIs (e sua complexidade) para cada sistema de interface\n\ngr\u00e1fica.\n\nDe acordo com Figueiredo et al. (1993) uma das maneiras de reduzir estes\n\nproblemas \u00e9 utilizar padr\u00f5es de fato, como ANSI C e OpenGL. Mas existem outras\n\nalternativas. Pode-se utilizar uma linguagem independente de plataforma, como Java.\n\nOu ainda lan\u00e7ar m\u00e3o de APIs que sejam elas mesmos port\u00e1veis, tornando o sistema\n\ndesenvolvido sobre elas port\u00e1vel tamb\u00e9m. \u00c9 esta \u00faltima alternativa que \u00e9 utilizada neste\n\ntrabalho, e as bibliotecas que o permitem s\u00e3o discutidas no cap\u00edtulo 3.\n\n2.7. A Pipeline de Renderiza\u00e7\u00e3o, Anti-Aliasing e Texturas\n\nComo se afirmou anteriormente, a pipeline de visualiza\u00e7\u00e3o \u00e9 um componente\n\nessencial no VTK. \u00c9 importante deixar claras as diferen\u00e7as entre este componente e a\n\npipeline de renderiza\u00e7\u00e3o. Al\u00e9m disso, agora que j\u00e1 se discutiu o objetivo que motiva\n\neste trabalho e as ferramentas que ser\u00e3o utilizadas, o momento \u00e9 oportuno para discutir\n\nalguns detalhes mais espec\u00edficos de implementa\u00e7\u00e3o. Embora este trabalho n\u00e3o\n\n\n\n67\n\nimplemente uma forma de renderiza\u00e7\u00e3o (o OpenGL se encarrega disto), \u00e9 importante\n\nconhecer as opera\u00e7\u00f5es envolvidas neste processo.\n\nEm primeiro lugar \u00e9 preciso definir o que \u00e9 um pipeline. Trata-se de um padr\u00e3o\n\nde projeto em que uma atividade \u00e9 subdividida em uma s\u00e9rie de atividades menores,\n\nmodulares, onde a sa\u00edda de cada m\u00f3dulo \u00e9 a entrada para o pr\u00f3ximo. A figura seguinte\n\nilustra esse padr\u00e3o:\n\nFigura 13 - Uma pipeline gen\u00e9rica com quatro m\u00f3dulos.\n\nJ\u00e1 renderiza\u00e7\u00e3o \u00e9 o processo que engloba as transforma\u00e7\u00f5es e opera\u00e7\u00f5es\n\nnecess\u00e1rias para exibir num dispositivo uma entidade geom\u00e9trica. De acordo com Angel\n\n(2000), as duas principais formas de implementar este processo s\u00e3o a baseada em\n\nobjetos  e a baseada na imagem.\n\nA renderiza\u00e7\u00e3o baseada em objetos itera sobre os objetos a serem exibidos\n\npara montar a imagem. Para cada objeto determina-se como ele deve ser exibido. J\u00e1 a\n\nbaseada em imagens itera sobre os elementos da imagem (os pixels). Para cada pixel\n\n\n\n68\n\nesta implementa\u00e7\u00e3o determina quais objetos influem naquele pixel e determina sua cor\n\n(implementa\u00e7\u00f5es de ray tracing podem ser exemplos desta estrat\u00e9gia).\n\nAngel afirma que a maioria das implementa\u00e7\u00f5es de renderiza\u00e7\u00e3o baseada em\n\nobjetos \u00e9 feita sob forma de uma pipeline com m\u00f3dulos distintos e interligados, sejam\n\neles de hardware ou de software, para realizar cada uma das opera\u00e7\u00f5es necess\u00e1rias. Em\n\nparticular este \u00e9 o caso de APIs importantes como o OpenGL e o Direct X. A maioria\n\ndas placas gr\u00e1ficas atuais tamb\u00e9m faz uso desta arquitetura.\n\n2.7.1. A Pipeline de Renderiza\u00e7\u00e3o\n\nAs quatro opera\u00e7\u00f5es que Angel (2000) afirma serem necess\u00e1rias para a\n\nrenderiza\u00e7\u00e3o s\u00e3o:\n\n\u2022 A modelagem da geometria a ser renderizada (normalmente feita pelo usu\u00e1rio ou\n\npor uma aplica\u00e7\u00e3o distinta do renderizador e passada para este);\n\n\u2022 Processamento Geom\u00e9trico;\n\n\u2022 Rasteriza\u00e7\u00e3o ou Scan Conversion;\n\n\u2022 Exibi\u00e7\u00e3o.\n\nA pipeline tem m\u00f3dulos que realizam cada uma destas opera\u00e7\u00f5es. Cada objeto\n\nda cena (por exemplo, pol\u00edgonos) passa por estes m\u00f3dulos em seq\u00fc\u00eancia.\n\nNo processamento geom\u00e9tricos s\u00e3o realizadas as seguintes opera\u00e7\u00f5es:\n\n\n\n69\n\n\u2022 Transforma\u00e7\u00e3o das coordenadas do objeto para o sistema do observador (ou\n\nc\u00e2mera), proje\u00e7\u00e3o (normalmente ortogonal, mas pode ser isom\u00e9trica, perspectiva\n\netc.) do objeto e normaliza\u00e7\u00e3o de suas coordenadas (Angel demonstra como a\n\nnormaliza\u00e7\u00e3o facilita a opera\u00e7\u00e3o de clipping). As transforma\u00e7\u00f5es de coordenadas e\n\nproje\u00e7\u00f5es s\u00e3o feitas atrav\u00e9s de multiplica\u00e7\u00f5es de matrizes 4x4 que normalmente s\u00e3o\n\nfeitas por hardware nas placas gr\u00e1ficas.\n\n\u2022 Culling e Clipping: Trata-se da remo\u00e7\u00e3o de objetos (ou partes de objetos) que est\u00e3o\n\nfora do campo de vis\u00e3o (normalmente uma janela retangular). Culling \u00e9 a\n\nelimina\u00e7\u00e3o de objetos por inteiro e Clipping \u00e9 uma opera\u00e7\u00e3o mais complexa que\n\n\"recorta\" os objetos deixando somente a parte contida no campo de vis\u00e3o. Embora\n\nesta opera\u00e7\u00e3o normalmente seja realizada aqui, alguns sistemas optam por execut\u00e1-\n\nla ap\u00f3s a rasteriza\u00e7\u00e3o, sobre a imagem bidimensional resultante.\n\n\u2022 Ilumina\u00e7\u00e3o dos objetos (Lighting ou Shading), ou seja, a determina\u00e7\u00e3o da cor em\n\ncada ponto do objeto com base nas fontes de luz em suas caracter\u00edsticas (sua cor em\n\ncada ponto e valores de normal, sejam estes calculados a partir da geometria ou\n\nfornecidos com o modelo). Dependendo do algoritmo utilizado, pode ser mais\n\nconveniente fazer a ilumina\u00e7\u00e3o neste ponto (ou at\u00e9 mesmo antes do Clipping) ou\n\nmais tarde, durante a rasteriza\u00e7\u00e3o. Foley et al. (1996) ilustram a diferen\u00e7a na ordem\n\ndas opera\u00e7\u00f5es em uma pipeline que utilize o algoritmo de Gouraud e uma que utilize\n\nPhong, por exemplo. No OpenGL, a ilumina\u00e7\u00e3o \u00e9 feita durante a rasteriza\u00e7\u00e3o.\n\n\u2022 Remo\u00e7\u00e3o de superf\u00edcies oclusas por outros objetos. Assim como ocorre com a\n\nilumina\u00e7\u00e3o, o local onde esta opera\u00e7\u00e3o deve ser feita depende do algoritmo\n\n\n\n70\n\nutilizado. Algoritmos que se baseiam numa ordena\u00e7\u00e3o (de tr\u00e1s para frente ou de\n\nfrente para tr\u00e1s) das superf\u00edcies para determinar quais s\u00e3o vis\u00edveis e quais est\u00e3o\n\noclusas  devem fazer esta ordena\u00e7\u00e3o antes da rasteriza\u00e7\u00e3o. O OpenGL utiliza outro\n\nalgoritmo, o z-buffer. De acordo com Angel este \u00e9 o algoritmo mais amplamente\n\nutilizado para esta tarefa, devido \u00e0 facilidade de sua implementa\u00e7\u00e3o, seja por\n\nsoftware ou por hardware, e ao fato de se adequar muito bem \u00e0 arquitetura de\n\npipelines, processando cada objeto (e cada v\u00e9rtice) na ordem que os recebe na\n\npipeline sem necessidade de ordena\u00e7\u00e3o. O z-buffer \u00e9 executado juntamente com a\n\nrasteriza\u00e7\u00e3o.\n\nAp\u00f3s o processamento geom\u00e9trico, vem a rasteriza\u00e7\u00e3o. At\u00e9 este ponto, os\n\nobjetos ainda s\u00e3o tratados como entidades geom\u00e9tricas. A rasteriza\u00e7\u00e3o \u00e9 que discretiza\n\nestas entidades em conjuntos de pixels. Normalmente se refere \u00e0 sa\u00edda da rasteriza\u00e7\u00e3o\n\ncomo o frame-buffer, que nada mais \u00e9 que uma matriz retangular onde cada elemento\n\nrepresenta um pixel da janela onde os objetos s\u00e3o renderizados e armazena o valor de\n\nsua cor. Como j\u00e1 foi dito, no OpenGL \u00e9 durante a rasteriza\u00e7\u00e3o que \u00e9 feita a remo\u00e7\u00e3o das\n\nsuperf\u00edcies oclusas e o shading das superf\u00edcies, utilizando o algoritmo de z-buffer em\n\nconjunto com a rasteriza\u00e7\u00e3o.\n\nO z-buffer \u00e9 uma matriz semelhante ao frame-buffer, com as mesmas dimens\u00f5es,\n\nmas que, ao inv\u00e9s da cor, armazena qual a profundidade na cena (em rela\u00e7\u00e3o ao\n\nobservador) do ponto que determina a cor daquele pixel. Comparando a profundidade\n\ndo ponto de um objeto que esteja passando pelo algoritmo com a profundidade\n\narmazenada no z-buffer, \u00e9 simples determinar se este ponto est\u00e1 mais pr\u00f3ximo que os\n\nque o precederam. Se estiver, o frame-buffer e o z-buffer s\u00e3o atualizados. Rogers (2001)\n\n\n\n71\n\ndemonstra como o c\u00e1lculo dos valores de profundidade armazenados no z-buffer\n\nutilizam a maior parte de sua precis\u00e3o para os objetos pr\u00f3ximos do observador. Alguns\n\nsistemas utilizam o w-buffer que procura resolver este problema. O w-buffer nada mais\n\n\u00e9 que uma lineariza\u00e7\u00e3o dos valores de profundidade no z-buffer. Essa lineariza\u00e7\u00e3o pode\n\ntrazer problemas de precis\u00e3o em alguns casos, mas n\u00e3o sacrifica tanta precis\u00e3o somente\n\npara os objetos mais pr\u00f3ximos do observador.\n\nPor fim, a opera\u00e7\u00e3o de exibi\u00e7\u00e3o consiste em passar o frame-buffer para o\n\ndispositivo que ir\u00e1 exibir esta imagem bidimensional resultante da renderiza\u00e7\u00e3o.\n\n2.7.2. Anti-Aliasing\n\nComo foi visto acima, durante a rasteriza\u00e7\u00e3o entidades geom\u00e9tricas, como\n\npol\u00edgonos ou linhas, s\u00e3o discretizados em pixels. Analisando esta opera\u00e7\u00e3o sob a \u00f3tica\n\nda \u00e1rea de processamento de sinais como fazem Foley et al. (1996), as entidades\n\ngeom\u00e9tricas podem ser vistas como sinais cont\u00ednuos no dom\u00ednio do espa\u00e7o e sua\n\ndiscretiza\u00e7\u00e3o em pixels como um processo de amostragem. Ao exibir a imagem\n\nresultante na tela, o que se est\u00e1 fazendo \u00e9 reconstruindo o sinal com base nestas\n\namostras. Sabe-se que este processo de amostragem de um sinal cont\u00ednuo e posterior\n\nreconstru\u00e7\u00e3o pode resultar em perdas e neste caso em particular as perdas s\u00e3o bem\n\nvis\u00edveis como o fen\u00f4meno conhecido como aliasing.\n\nO aliasing \u00e9 o respons\u00e1vel pelas linhas \"quebradas\", lembrando degraus,\n\nobservadas com freq\u00fc\u00eancia em gr\u00e1ficos de computador, como por exemplo na figura a\n\n\n\n72\n\nseguir. Al\u00e9m de reduzir o realismo da imagem, o aliasing ainda pode causar desconforto\n\nvisual para o observador.\n\nFigura 14 - Aliasing\n\nExistem diversas t\u00e9cnicas e algoritmos para amenizar este problema, conhecidas\n\ncomo t\u00e9cnicas de Anti-Aliasing. Schroeder et al. (1998) citam as seguintes:\n\nDurante a rasteriza\u00e7\u00e3o, a cor de um pixel vizinho aos identificados como\n\npertencentes a uma linha, por exemplo, \u00e9 influenciada pela fra\u00e7\u00e3o daquele pixel que\n\nseria ocupada pela linha se esta fosse cont\u00ednua. Esta t\u00e9cnica \u00e9 conhecida como\n\namostragem ou m\u00e9dia de \u00e1reas (area sampling ou area averaging).\n\nUma solu\u00e7\u00e3o similar envolve dividir cada pixel em subpixels (ocupando bem\n\nmais mem\u00f3ria) e fazer a rasteriza\u00e7\u00e3o normalmente, determinando a cor de cada pixel\n\npela m\u00e9dia das cores de seus subpixels. Isto equivale a renderizar uma imagem com\n\nresolu\u00e7\u00e3o maior e depois fazer uma opera\u00e7\u00e3o de redu\u00e7\u00e3o de escala.\n\nA \u00faltima t\u00e9cnica consiste em gerar diversas imagens com aliasing e combin\u00e1-las\n\nnuma imagem anti-aliased. Estas imagens s\u00e3o obtidas movendo o observador e o ponto\n\nfocal menos de um pixel em dire\u00e7\u00f5es perpendiculares \u00e0 dire\u00e7\u00e3o de proje\u00e7\u00e3o.\n\n\n\n73\n\nGlassner (1990) e Foley et al. (1996) citam ainda como poss\u00edvel solu\u00e7\u00e3o a\n\nconvolu\u00e7\u00e3o da imagem com filtros apropriados, como o gaussiano ou o c\u00fabico, filtrando\n\nos sinais de alta freq\u00fc\u00eancia que normalmente resultam de aliasing.\n\nOutra forma de aliasing que ocorre durante anima\u00e7\u00f5es (e nunca em imagens\n\nest\u00e1ticas) \u00e9 o aliasing temporal. Dachille &amp; Kaufmann (2000) descrevem este\n\nfen\u00f4meno, que ocorre por um motivo an\u00e1logo ao do aliasing espacial. Durante uma\n\nanima\u00e7\u00e3o o movimento cont\u00ednuo de uma entidade \u00e9 amostrado em quadros discretos da\n\nanima\u00e7\u00e3o. \u00c9 por causa do aliasing temporal que rodas de carro\u00e7a ou h\u00e9lices de avi\u00f5es\n\nem filmes antigos parecem rodar ao contr\u00e1rio quando atingem certas velocidades. Outra\n\nmaneira simples de perceber este fen\u00f4meno \u00e9 movendo um dedo rapidamente na frente\n\nde um monitor de computador. Neste caso a taxa de atualiza\u00e7\u00e3o do monitor s\u00f3 \u00e9\n\nsuficiente para iluminar o dedo em algumas posi\u00e7\u00f5es e o resultado s\u00e3o as imagens\n\nresiduais resultantes.\n\nAngel (2000) descreve outro motivo que pode causar aliasing temporal. Em\n\nsistemas que utilizam ray casting10, um objeto pequeno ou distante da c\u00e2mera pode se\n\nmover com uma velocidade que fa\u00e7a com que por vezes ele n\u00e3o seja atingido por\n\nnenhum dos raios. Isso faz com que o objeto fique aparecendo e desaparecendo da cena\n\nde forma bastante inc\u00f4moda.\n\nAssim como para o espacial, existem diversas solu\u00e7\u00f5es para o problema de\n\naliasing temporal. Para o problema descrito por Angel, uma solu\u00e7\u00e3o trivial \u00e9 lan\u00e7ar\n\n                                                \n\n10 Processo de renderiza\u00e7\u00e3o que ilumina os objetos de uma cena lan\u00e7ando \"raios de luz\" virtuais\ne calculando seu efeito sobre os objetos. Tipicamente lan\u00e7a-se um raio de luz por pixel.\n\n\n\n74\n\nmais raios de luz, ao inv\u00e9s de um para cada pixel. Dachille &amp; Kaufmann citam o uso de\n\nalguns filtros. Wloka et al. (1995) descrevem uma t\u00e9cnica interessante de renderizar\n\ncada quadro utilizando informa\u00e7\u00f5es do quadro anterior para acelerar o processo que tem\n\ncomo conseq\u00fc\u00eancia uma suaviza\u00e7\u00e3o do aliasing temporal.\n\nDe acordo com Angel (2000), o que todas as t\u00e9cnicas de anti-aliasing, espacial\n\nou temporal, t\u00eam em comum s\u00e3o um alto custo computacional e o fato de que, na\n\npr\u00e1tica, s\u00f3 s\u00e3o utilizadas quando uma imagem de alta qualidade \u00e9 necess\u00e1ria e n\u00e3o em\n\ntempo real. Hoje em dia, com computadores e placas gr\u00e1ficas mais poderosas, isto est\u00e1\n\ndeixando de ser verdade. Algumas placas j\u00e1 implementam algoritmos de anti-aliasing\n\nespacial por hardware.\n\nNo aplicativo desenvolvido neste trabalho, existe a op\u00e7\u00e3o de ativar ou n\u00e3o anti-\n\naliasing espacial por software, utilizando a terceira t\u00e9cnica descrita por Schroeder.\n\nDevido \u00e0s caracter\u00edsticas de escala e velocidade dos objetos que est\u00e3o sendo\n\nvisualizados, o aliasing temporal \u00e9 impercept\u00edvel e portanto n\u00e3o houve necessidade de\n\nimplementar mecanismos para elimin\u00e1-lo.\n\n2.7.3. Texturas\n\nDe acordo com Angel (2000), texturas s\u00e3o ferramentas bastante \u00fateis para\n\nfornecer um n\u00edvel de detalhe (e realismo) maior \u00e0s superf\u00edcies sem a necessidade de\n\naumentar a complexidade dos modelos geom\u00e9tricos utilizados. O uso desta ferramenta\n\nest\u00e1 previsto neste trabalho. Texturas s\u00e3o padr\u00f5es, sejam extra\u00eddos de uma imagem\n\n\n\n75\n\ndigital, seja gerados por uma fun\u00e7\u00e3o matem\u00e1tica, que podem ser aplicados (ou\n\nmapeados) sobre a geometria. A cada ponto da geometria s\u00e3o associadas coordenadas\n\nde textura que associam aquele ponto a um dos pontos do padr\u00e3o que constitui a\n\ntextura. Estas coordenadas podem ser fornecidas junto com o modelo ou determinadas\n\ncomputacionalmente a partir da geometria e de como se deseja realizar o mapeamento.\n\nDurante a renderiza\u00e7\u00e3o, a cor da textura associada a um ponto da geometria contribui na\n\ndetermina\u00e7\u00e3o de cor deste ponto.\n\n2.8. Detec\u00e7\u00e3o de Colis\u00e3o\n\nDado um conjunto de objetos onde pelo menos um destes objetos tem\n\nmovimento, podendo conter inclusive elementos est\u00e1ticos de cen\u00e1rio, o objetivo da\n\ndetec\u00e7\u00e3o de colis\u00e3o \u00e9 determinar todos os contatos geom\u00e9tricos que ocorram entre estes\n\nobjetos. Alguns autores, como Cerny (2000) definem detec\u00e7\u00e3o de colis\u00e3o como somente\n\na determina\u00e7\u00e3o de contato entre os objetos que se movem e o ambiente, mas a maioria\n\ninclui colis\u00f5es entre os objetos m\u00f3veis como importante parte desta defini\u00e7\u00e3o.\n\nDe acordo com Cohen et al. (1995), a detec\u00e7\u00e3o de colis\u00e3o \u00e9 um problema\n\nfundamental nas \u00e1reas de anima\u00e7\u00e3o por computador, simula\u00e7\u00e3o f\u00edsica, ambientes\n\nvirtuais e rob\u00f3tica. Neste trabalho, um dos objetivos \u00e9 determinar e destacar as colis\u00f5es\n\nque ocorrerem entre os risers.\n\nO m\u00e9todo trivial para detec\u00e7\u00e3o de colis\u00e3o entre geometrias formadas por\n\npol\u00edgonos, verificar se cada face de um objeto tem interfer\u00eancia com todos os outros\n\n\n\n76\n\npol\u00edgonos da cena que n\u00e3o pertencerem ao mesmo objeto, \u00e9 de complexidade O(n2) em\n\nrela\u00e7\u00e3o ao n\u00famero de pol\u00edgonos e se mostra proibitivo.\n\nChung &amp; Wang (1996) fazem uma an\u00e1lise abrangente de diversos algoritmos de\n\ndetec\u00e7\u00e3o de colis\u00e3o. A maioria discretiza a geometria dos objetos que podem colidir\n\nutilizando um volume limitante (bounding volume), ou uma hierarquia destes volumes,\n\nque circunscreve o objeto. Este volume normalmente \u00e9 um paralelep\u00edpedo alinhado com\n\no sistema de coordenadas ou uma esfera (bounding box e bounding sphere,\n\nrespectivamente). O uso destes volumes simplifica a detec\u00e7\u00e3o de colis\u00e3o, pois\n\ninicialmente s\u00f3 \u00e9 preciso checar as colis\u00f5es entre os volumes, que al\u00e9m de serem em\n\nbem menor n\u00famero que os pol\u00edgonos ainda tem formas simples que facilitam a\n\ndetec\u00e7\u00e3o. Alguns algoritmos inclusive separam o espa\u00e7o em setores, utilizando\n\noctrees11, e classificam os objetos de acordo com o setor aonde est\u00e3o para reduzir o\n\nn\u00famero de checagens, antes mesmo de checar colis\u00f5es entre volumes limitantes.\n\nNo entanto, a menos que se deseje trocar precis\u00e3o por velocidade, quando dois\n\ncorpos est\u00e3o no mesmo setor e existe colis\u00e3o entre seus volumes limitantes \u00e9 preciso\n\nutilizar algum m\u00e9todo de determina\u00e7\u00e3o exata de colis\u00e3o. Chung e Wang mencionam\n\ndiversas maneiras de acelerar esta determina\u00e7\u00e3o exata.\n\nA maioria destas estrat\u00e9gias visa determinar quais s\u00e3o as faces dos objetos\n\nenvolvidos pr\u00f3ximas do ponto de colis\u00e3o para que n\u00e3o seja necess\u00e1rio fazer a checagem\n\nde todas as faces de um objeto contra todas as faces do outro. Isto pode ser feito\n\n                                                \n\n11 Estruturas de dados que separam o espa\u00e7o em octantes cada vez menores, cada octante\nrepresentado por uma \"folha\" na estrutura de \u00e1rvore.\n\n\n\n77\n\narmazenando quais s\u00e3o os pares de faces mais pr\u00f3ximos para cada par de objetos,\n\nsubdividindo os volumes limitantes para determinar a regi\u00e3o de colis\u00e3o ou utilizando\n\nestruturas de dados adequadas para acessar os pol\u00edgonos em uma determinada posi\u00e7\u00e3o\n\nrapidamente.\n\nOutro algoritmo para determina\u00e7\u00e3o exata de colis\u00e3o entre dois objetos \u00e9\n\nencontrar um plano que separe estes objetos. Se for poss\u00edvel encontrar este plano, eles\n\nn\u00e3o colidem e a afirma\u00e7\u00e3o inversa tamb\u00e9m \u00e9 verdadeira.\n\nDois conceitos importantes explorados para acelerar diversos destes algoritmos\n\ns\u00e3o os de coer\u00eancia temporal e espacial. A coer\u00eancia temporal \u00e9 a suposi\u00e7\u00e3o de que o\n\nestado da aplica\u00e7\u00e3o n\u00e3o sofre mudan\u00e7as dr\u00e1sticas de um passo de tempo para o\n\npr\u00f3ximo. Quer dizer, os passos de tempo s\u00e3o pequenos o suficiente para que as\n\nmudan\u00e7as sofridas pelos objetos sejam pequenas. Isto se traduz na coer\u00eancia espacial,\n\numa vez que a geometria destes objetos, definida pelas posi\u00e7\u00f5es de seus v\u00e9rtices,\n\ntamb\u00e9m n\u00e3o passa por grandes altera\u00e7\u00f5es. Algoritmos que calculam dados como quais\n\ns\u00e3o os pontos mais pr\u00f3ximos entre pares de objetos, ou que planos separam estes pares,\n\npodem armazenar os dados calculados em cada passo para servirem como itera\u00e7\u00e3o\n\ninicial no c\u00e1lculo dos dados do passo seguinte, acelerando o processo.\n\nO problema que este trabalho se prop\u00f5e a solucionar, no entanto, possui duas\n\ncaracter\u00edsticas em particular que simplificam o problema consideravelmente.\n\nA primeira \u00e9 que, apesar da representa\u00e7\u00e3o do riser como um conjunto de\n\npol\u00edgonos seja conhecida, uma representa\u00e7\u00e3o mais simples (e inclusive com mais\n\nsignificado f\u00edsico) tamb\u00e9m pode ser utilizada. Trata-se de representar os risers como\n\n\n\n78\n\nconjuntos de segmentos cil\u00edndricos de raio e posi\u00e7\u00e3o conhecidos. Embora, de acordo\n\ncom Eberly (2000b), a detec\u00e7\u00e3o de colis\u00f5es entre troncos de cilindros seja um processo\n\nde alto custo computacional, a colis\u00e3o entre c\u00e1psulas12 se reduz a checar se a dist\u00e2ncia\n\nentre os segmentos de reta que as originam \u00e9 menor que a soma de seus raios. Para\n\nencontrar essa dist\u00e2ncia, Eberly (2000a) afirma que basta minimizar a fun\u00e7\u00e3o dist\u00e2ncia\n\nentre dois pontos pertencentes aos segmentos de reta. Embora esse seja um problema de\n\nminimiza\u00e7\u00e3o com fronteiras, o tratamento das fronteiras pode ser feito com um\n\nalgoritmo relativamente simples, pois Eberly (2000a) demonstra que caso os pontos de\n\nm\u00ednimo da fun\u00e7\u00e3o n\u00e3o perten\u00e7am aos segmentos de reta, o m\u00ednimo necessariamente\n\nocorre entre uma de suas extremidades e outro ponto qualquer. O algoritmo de baixa\n\ncomplexidade e custo para detec\u00e7\u00e3o de colis\u00f5es entre c\u00e1psulas descrito por Eberly\n\n(2000a) pode ser usado no RiserView uma vez que as \"tampas\" semi-esf\u00e9ricas das\n\nc\u00e1psulas s\u00f3 devem colidir com segmentos do mesmo riser, em configura\u00e7\u00f5es normais\n\ndos mesmos, e essas colis\u00f5es nunca devem ser checadas.\n\nA segunda caracter\u00edstica que simplifica o problema, para a qual n\u00e3o foi\n\nencontrado paralelo na literatura, \u00e9 que o movimento de cada riser isoladamente \u00e9\n\nconhecido a priori. Trata-se de uma ocorr\u00eancia bastante comum, pois se repete quando\n\nse est\u00e1 exibindo resultado de simula\u00e7\u00f5es pr\u00e9-calculadas, mas ainda assim n\u00e3o foram\n\nencontradas solu\u00e7\u00f5es para detec\u00e7\u00e3o de colis\u00e3o para esse caso. Como os risers n\u00e3o\n\nnecessariamente vibram com a mesma freq\u00fc\u00eancia, isso n\u00e3o significa que as intera\u00e7\u00f5es\n\nentre eles sejam conhecidas, mas traz algumas simplifica\u00e7\u00f5es ao problema (semelhantes\n\n                                                \n\n12 C\u00e1psula: O conjunto de pontos eq\u00fcidistantes de um segmento de reta. Pode ser visualizada\ncomo um cilindro limitado por semi-esferas, e n\u00e3o por planos.\n\n\n\n79\n\n\u00e0s trazidas pela coer\u00eancia temporal e espacial) que ser\u00e3o exploradas na solu\u00e7\u00e3o do\n\nproblema.\n\n\n\n80\n\n3. TECNOLOGIA\n\nEste cap\u00edtulo continua a descri\u00e7\u00e3o da revis\u00e3o bibliogr\u00e1fica iniciada no cap\u00edtulo 2.\n\nNo entanto, os t\u00f3picos aqui descritos t\u00eam uma caracter\u00edstica importante que os distingue\n\ndos discutidos anteriormente: tratam de quest\u00f5es mais intimamente ligadas a solu\u00e7\u00f5es\n\ntecnol\u00f3gicas atuais. S\u00e3o, portanto, discuss\u00f5es menos perenes que as anteriores.\n\nO pr\u00f3prio processo unificado, a metodologia escolhida para o desenvolvimento\n\ndo ambiente de visualiza\u00e7\u00e3o de risers, \u00e9 o resultado de uma evolu\u00e7\u00e3o cont\u00ednua, como\n\nser\u00e1 visto adiante, e ainda sofre constantes revis\u00f5es (o processo revisado, juntamente\n\ncom ferramentas de software para auxiliar em sua aplica\u00e7\u00e3o, \u00e9 conhecido como Rational\n\nUnified Process ou RUP). O processo descrito e utilizado nesse trabalho, no entanto,\n\ncorresponde \u00e0quele descrito por Jacobson et al. (1999). A primeira se\u00e7\u00e3o deste cap\u00edtulo\n\nfornece os conceitos necess\u00e1rios sobre esse processo para que sua customiza\u00e7\u00e3o e\n\naplica\u00e7\u00e3o, no cap\u00edtulo 4, possa ser compreendida, enquanto a UML j\u00e1 foi abrangida no\n\ncap\u00edtulo 2.\n\nO cap\u00edtulo continua com a descri\u00e7\u00e3o das APIs utilizadas no trabalho e das\n\nalternativas estudadas. Por fim s\u00e3o abordados shaders, uma forma de programa\u00e7\u00e3o para\n\nos processadores gr\u00e1ficos.\n\n\n\n81\n\n3.1. Processo Unificado\n\nAntes de uma discuss\u00e3o mais aprofundada do processo em si, deve-se analisar os\n\nmotivos para a sua escolha. Uma breve defini\u00e7\u00e3o e revis\u00e3o do hist\u00f3rico do processo vem\n\nent\u00e3o. S\u00e3o abordados com mais detalhe, por fim, alguns dos termos e conceitos que\n\nser\u00e3o utilizados no cap\u00edtulo 4.\n\n3.1.1. Vantagens e Desvantagens\n\nNo cap\u00edtulo 2, foram citadas as principais vantagens e desvantagens\n\nnormalmente associadas \u00e0 utiliza\u00e7\u00e3o de uma metodologia formal em um caso geral.\n\nAqui ser\u00e1 analisada a parcela destas vantagens e desvantagens que se aplica diretamente\n\na este projeto - um projeto de porte relativamente pequeno, com somente um\n\nprogramador.\n\nUma das vantagens \u00e9 o planejamento imposto pela metodologia, bem como a\n\nestrutura para apoiar e guiar este planejamento, reduzindo a necessidade de retrabalhos,\n\nfacilitando o reaproveitamento de c\u00f3digo e simplificando o esfor\u00e7o para se criar uma\n\narquitetura expans\u00edvel. Isso vale at\u00e9 mesmo para projetos envolvendo uma s\u00f3 pessoa.\n\nA estrutura bem definida para a gera\u00e7\u00e3o da documenta\u00e7\u00e3o do projeto \u00e9 outra\n\nvantagem que se aplica a esse projeto. Como uma de suas preocupa\u00e7\u00f5es \u00e9 que ele seja\n\nexpans\u00edvel, permitindo a continua\u00e7\u00e3o da pesquisa e o crescimento e manuten\u00e7\u00e3o do\n\n\n\n82\n\nprojeto no futuro, provavelmente por uma equipe diferente, uma documenta\u00e7\u00e3o\n\nabrangente e organizada \u00e9 essencial.\n\nN\u00e3o se pode esquecer que este projeto \u00e9, acima de tudo, um trabalho de pesquisa\n\ncient\u00edfica. Como tal, uma descri\u00e7\u00e3o precisa da metodologia usada e dos passos seguidos\n\ndurante seu desenvolvimento \u00e9 essencial, conferindo n\u00e3o s\u00f3 repetibilidade ao processo,\n\ncomo tamb\u00e9m um maior valor como fonte de conhecimento para futuros pesquisadores.\n\nO uso de uma metodologia preexistente e bem conhecida permite que o pesquisador se\n\nconcentre em seu objeto de estudo e n\u00e3o tanto no processo de desenvolvimento e\n\npermite ainda que outros pesquisadores, j\u00e1 familiarizados com a metodologia, possam\n\ncompreender sua aplica\u00e7\u00e3o com maior facilidade.\n\nQuanto \u00e0 maior desvantagem relativa ao uso deste tipo de processo, o tempo\n\ndispendido em sua aprendizagem e aplica\u00e7\u00e3o, pode-se afirmar que uma das\n\ncaracter\u00edsticas de uma boa metodologia \u00e9 que seja adapt\u00e1vel a projetos de diferentes\n\nescalas. Jacobson et al. (1998) afirmam que o UP, deve ser customizado para cada\n\nprojeto, dependendo de fatores como escala do projeto, familiaridade da equipe com as\n\ntecnologias utilizadas, dentre outras. Smith (2002) detalha mais essa customiza\u00e7\u00e3o ao\n\ncomparar o Unified Process a outra metodologia, o Extreme Programming (XP). Smith\n\ncita, por exemplo, que para projetos de pequeno porte e baixo risco, as fases de\n\nconcep\u00e7\u00e3o e elabora\u00e7\u00e3o (que ser\u00e3o estudadas em mais detalhe adiante) podem ser muito\n\nmais curtas, partindo mais rapidamente para a fase de constru\u00e7\u00e3o. Esta customiza\u00e7\u00e3o,\n\nconsiderada essencial no UP, pode reduzir em muito o tempo utilizado com a aplica\u00e7\u00e3o\n\nda metodologia.\n\n\n\n83\n\nEsta adaptabilidade do Processo Unificado, confirmada por Smith (2002), foi o\n\nprincipal fator que levou \u00e0 sua escolha. O uso da metodologia Extreme Programming\n\n(XP), que tem muitos elementos similares ao UP, tamb\u00e9m foi levada em conta,\n\nprincipalmente por ser recomendada para projetos de menor porte. No entanto,\n\nconforme Beck (2000) apud Smith (2002), o XP \u00e9 um processo bem menos flex\u00edvel,\n\nestando limitado a equipes com no m\u00e1ximo 10 a 20 programadores. Outros fatores que\n\ninfluenciaram na escolha do UP foram o fato de ser uma metodologia voltada para a\n\norienta\u00e7\u00e3o a objetos e que utiliza a Unified Modeling Language (UML) como\n\nferramenta, uma ferramenta com a qual o autor j\u00e1 tinha alguma familiaridade.\n\nCom isto em mente, pode-se passar \u00e0 uma discuss\u00e3o mais aprofundada do\n\nprocesso em si.\n\n3.1.2. Defini\u00e7\u00e3o e Hist\u00f3rico\n\nDe acordo com Jacobson et al. (1998), o processo unificado \u00e9 uma metodologia\n\nque combina contribui\u00e7\u00f5es  de diversas fontes, tanto de desenvolvedores quanto de\n\nusu\u00e1rios dos processos envolvidos, come\u00e7ando com o processo da Ericsson de 1967,\n\nque descreve a arquitetura de um sistema como diagramas de blocos que representavam\n\nos componentes do sistema e interfaces. Em 1976 o CCITT, um \u00f3rg\u00e3o internacional de\n\npadroniza\u00e7\u00e3o na ind\u00fastria de telecomunica\u00e7\u00f5es institui a SDL (Specification and\n\nDescription Language) uma precursora da UML. Em 1987 Jacobson cria o processo\n\n\"Objectory\" que formaliza a utiliza\u00e7\u00e3o dos casos de uso (conceito que ser\u00e1 explicado\n\n\n\n84\n\nem seguida). Em 1995 a Rational Software Corp. compra o Objectory e a ele acrescenta\n\nalgumas de suas marcas, como a \u00eanfase na arquitetura e o desenvolvimento iterativo,\n\nlan\u00e7ando em 1997 o Rational Objectory Process (ROP). Neste per\u00edodo a Rational\n\nadquiriu diversas outras empresas cujas pr\u00e1ticas foram somadas ao ROP causando sua\n\nevolu\u00e7\u00e3o no que se chamou Processo Unificado. Novas evolu\u00e7\u00f5es da metodologia s\u00e3o\n\nenglobadas no Rational Unified Process e recentemente a Rational \u00e9 adquirida pela\n\nIBM.\n\nJacobson et al. come\u00e7am a definir o UP dizendo que n\u00e3o se trata de um \u00fanico\n\nprocesso, mas de uma Framework que pode (e deve) ser especializada para diversos\n\ntipos de projetos diferentes. No entanto, os tr\u00eas termos que definem o UP na opini\u00e3o de\n\nseus criadores s\u00e3o:\n\n\u2022 guiado por casos de uso;\n\n\u2022 centrado na arquitetura;\n\n\u2022 iterativo e incremental\n\nCasos de uso s\u00e3o maneiras formais de se descrever os requisitos funcionais de\n\num sistema. Nas palavras de Jacobson et al.:\n\n\"Casos de uso s\u00e3o descri\u00e7\u00f5es de conjuntos de seq\u00fc\u00eancias de a\u00e7\u00f5es, incluindo\n\nvariantes, que um sistema realiza e que resultam num resultado observ\u00e1vel e com valor\n\npara um dado ator.\" (Jacobson et al., 1998, p. 432)\n\nNesta defini\u00e7\u00e3o ator significa um usu\u00e1rio do caso de uso (e n\u00e3o necessariamente\n\num usu\u00e1rio do software, um ator pode ser, por exemplo, um subsistema). Ou seja, um\n\n\n\n85\n\ncaso de uso nada mais \u00e9 que uma descri\u00e7\u00e3o de uma conjunto de a\u00e7\u00f5es que, juntas,\n\nrealizam uma fun\u00e7\u00e3o de valor observ\u00e1vel para um usu\u00e1rio (o ator). No cap\u00edtulo seguinte\n\nser\u00e3o levantados os casos de uso deste projeto em espec\u00edfico e o conceito deve tornar-se\n\nmais claro.\n\nA arquitetura de um sistema \u00e9 a organiza\u00e7\u00e3o deste sistema, quais (e como) s\u00e3o\n\nseus componentes e as interfaces entre estes componentes, como eles se combinam para\n\nformar sistemas maiores, como o sistema ser\u00e1 usado e todas estas decis\u00f5es que definem\n\na forma do software sob pontos de vista distintos sem se preocupar com detalhes de\n\nimplementa\u00e7\u00e3o.\n\nA \u00faltima express\u00e3o, \"iterativo e incremental\" significa que o UP se desenvolve\n\nem itera\u00e7\u00f5es bem definidas, cada uma adicionando mais funcionalidade ao sistema.\n\nCada uma destas itera\u00e7\u00f5es se encaixa em uma das fases do projeto, como ser\u00e1 visto\n\nadiante.\n\nOutras caracter\u00edsticas do UP s\u00e3o o fato do sistema sendo desenvolvido ser\n\ndescrito como componentes que se comunicam por interfaces e o uso da UML para\n\ndescrever o sistema de software graficamente, como as plantas e desenhos usados nas\n\noutras \u00e1reas da engenharia.\n\nCom uma imagem do UP se formando mais claramente, pode-se discutir alguns\n\ntermos e conceitos mais espec\u00edficos que ser\u00e3o necess\u00e1rios no cap\u00edtulo 4.\n\n\n\n86\n\n3.1.3. Fases, Itera\u00e7\u00f5es, Etapas e Artefatos no Processo Unificado\n\nNo Processo Unificado, o desenvolvimento do projeto est\u00e1 dividido em 4 fases.\n\nCada uma destas fases tem um foco diferente, bem como objetivos diferentes.\n\nCada fase, por sua vez, pode ser composta por uma ou mais itera\u00e7\u00f5es. No\n\nprocesso unificado, o conceito de itera\u00e7\u00e3o \u00e9 muito importante, pois define a forma como\n\nesta metodologia \u00e9 implementada incrementalmente. Uma itera\u00e7\u00e3o \u00e9 um \"mini-projeto\"\n\ncujo resultado final necessariamente traz um incremento na funcionalidade do que est\u00e1\n\nsendo desenvolvido. As itera\u00e7\u00f5es s\u00e3o normalmente feitas de forma seq\u00fcencial, mas\n\ntarefas relativamente independentes podem ser desenvolvidas em paralelo, desde que as\n\ndecis\u00f5es de arquitetura quanto \u00e0 interface entre seus produtos j\u00e1 tenham sido tomadas e\n\nque estas itera\u00e7\u00f5es em paralelo sejam seguidas em algum momento por um itera\u00e7\u00e3o para\n\na integra\u00e7\u00e3o destes produtos. O conceito de itera\u00e7\u00e3o dentro do Processo Unificado deve\n\ntornar-se mais claro ao se descrever as itera\u00e7\u00f5es em que \u00e9 dividida a etapa de\n\nConstru\u00e7\u00e3o neste trabalho.\n\nCada itera\u00e7\u00e3o divide-se em etapas, seguidas sempre na mesma ordem. Cada\n\netapa descreve um conjunto de atividades do \"mini-projeto\" que \u00e9 a itera\u00e7\u00e3o bem como\n\nartefatos que devem ser gerados.\n\nAs fases que se repetem no UP, sempre nesta ordem, s\u00e3o: Concep\u00e7\u00e3o,\n\nElabora\u00e7\u00e3o, Constru\u00e7\u00e3o e Transi\u00e7\u00e3o. Cada uma tem foco e objetivos distintos, indo\n\ndo mais geral para o mais espec\u00edfico. Ao fim de cada uma delas deve ser atingido um\n\n\n\n87\n\nmilestone, um artefato ou conjunto de artefatos (distintos para cada fase e cada projeto)\n\nque demonstram que os objetivos daquela fase foram cumpridos.\n\nA fase de Concep\u00e7\u00e3o tem como principal preocupa\u00e7\u00e3o determinar a viabilidade\n\ndo projeto, esbo\u00e7ando somente partes importantes do sistema como casos de uso e\n\ntentativas de arquitetura para determinar se o projeto \u00e9 economicamente fact\u00edvel. Ao fim\n\ndesta fase, o escopo do projeto deve estar definido e deve-se ter elaborado um estudo\n\nt\u00e9cnico e econ\u00f4mico quanto \u00e0 viabilidade do projeto, estimando os recursos e prazos\n\nnecess\u00e1rios e outros fatores desta natureza.\n\nA fase de Elabora\u00e7\u00e3o detalha mais o modelo criado na concep\u00e7\u00e3o para\n\ndeterminar a infra-estrutura econ\u00f4mica necess\u00e1ria para o projeto. Isso inclui a\n\nidentifica\u00e7\u00e3o e redu\u00e7\u00e3o de riscos, estimativa de custos e recursos necess\u00e1rios e\n\nplanejamento detalhado do projeto (incluindo cronogramas, por exemplo). Somente\n\nap\u00f3s esta fase \u00e9 que se pode fazer, por exemplo, uma proposta comercial detalhada\n\nrelacionada ao projeto.\n\nA fase de Constru\u00e7\u00e3o \u00e9 onde o projeto toma corpo de fato. Ainda que nas fases\n\nanteriores os requisitos e a arquitetura do projeto tenham sido esbo\u00e7adas com certo\n\ndetalhe para permitir uma an\u00e1lise do projeto como um todo, \u00e9 nesta fase que estes\n\nrequisitos e arquitetura s\u00e3o definidos com todos os seus detalhes e ent\u00e3o implementados\n\nsob forma de c\u00f3digo e execut\u00e1veis.\n\nPor fim, a fase de Transi\u00e7\u00e3o preocupa-se principalmente com a corre\u00e7\u00e3o de\n\ndefeitos e problemas n\u00e3o identificados durante as fases anteriores, bem como com um\n\n\"ajuste fino\" do software aos usu\u00e1rios. Realiza-se quando os usu\u00e1rios (ou um grupo\n\n\n\n88\n\nseleto mas significativo deles) j\u00e1 est\u00e3o utilizando uma vers\u00e3o beta do software. Isto n\u00e3o\n\nsignifica que todo o software deva ser testado somente nesta fase! Pelo contr\u00e1rio, em\n\ncada itera\u00e7\u00e3o, dentro de cada fase, devem ser feitos testes para determinar a\n\nfuncionalidade do que est\u00e1 sendo desenvolvido e devem-se corrigir os eventuais erros.\n\nA fase de transi\u00e7\u00e3o trata dos erros que persistem apesar destes testes (tipicamente\n\ncausados por grande n\u00famero de usu\u00e1rios concorrentes, grandes per\u00edodos de utiliza\u00e7\u00e3o,\n\nutiliza\u00e7\u00e3o do programa para analisar um grande volume de dados, ou dados muito\n\ncomplexos, ou seja, condi\u00e7\u00f5es custosas para se testar durante a implementa\u00e7\u00e3o) e das\n\nquest\u00f5es e melhorias que inevitavelmente s\u00e3o levantadas pelos usu\u00e1rios mas que n\u00e3o\n\ntinham sido previstas nas fases anteriores.\n\nCada itera\u00e7\u00e3o apresenta as etapas de Captura de Requerimentos, An\u00e1lise,\n\nProjeto, Implementa\u00e7\u00e3o e Testes. Cada um destas etapas tem mais ou menos \u00eanfase\n\ndependendo principalmente da fase em que se encontra o projeto.\n\nA etapa de Captura de Requerimentos traduz como casos de uso e outros\n\nartefatos os requisitos ou requerimentos do software. Ou seja, o que o produto deve\n\nfazer \u00e9 especificado de uma maneira formal nesta etapa. Embora formais, casos de uso\n\ndescrevem os requisitos de forma bastante simples. Cada caso de uso descreve uma a\u00e7\u00e3o\n\niniciada por um ator e que traz benef\u00edcios ou resultados observ\u00e1veis. Nesta etapa\n\nnormalmente a interface de usu\u00e1rio tamb\u00e9m \u00e9 esbo\u00e7ada.\n\nDurante a etapa de An\u00e1lise, um subconjunto dos casos de uso mais significativos\n\npara o software \u00e9 detalhado, assim como as classes mais importantes utilizadas na\n\nrealiza\u00e7\u00e3o de cada um dos casos de uso escolhidos. Trata-se de um refinamento dos\n\nrequerimentos capturados na etapa anterior, assim como um primeiro passo no projeto\n\n\n\n89\n\ndo sistema. O projeto \u00e9 dividido em pacotes ou subsistemas e generaliza\u00e7\u00f5es entre\n\nclasses s\u00e3o identificadas. Jacobson et al. (1998), no entanto, afirmam que o modelo\n\nobtido na an\u00e1lise nem sempre precisa ser mantido nas outras etapas do projeto e que,\n\npara projetos de pequeno porte, esta etapa pode ser inclusive eliminada (na verdade,\n\nabsorvida pelas etapas de requerimentos, projeto e implementa\u00e7\u00e3o).\n\nNa etapa de Projeto o programa toma forma. \u00c9 aqui que \u00e9 definida em detalhe a\n\narquitetura do software que \u00e9 capaz de atender de forma eficiente aos requisitos\n\ndefinidos anteriormente. Aqui tamb\u00e9m s\u00e3o decididas outras \"condi\u00e7\u00f5es de contorno\" do\n\nprojeto, como por exemplo APIs utilizadas no sistema. O modelo obtido durante esta\n\netapa \u00e9 uma abstra\u00e7\u00e3o da implementa\u00e7\u00e3o do sistema.\n\n\u00c9 na etapa de Implementa\u00e7\u00e3o que a arquitetura, os requerimentos e sua\n\nrealiza\u00e7\u00e3o deixam de ser abstra\u00e7\u00f5es e s\u00e3o traduzidos em c\u00f3digo compil\u00e1vel.\n\nPor fim, na etapa de Testes \u00e9 testado o que foi implementado. Os testes s\u00e3o\n\nplanejados de acordo com uma estrat\u00e9gia. Nesta etapa tamb\u00e9m s\u00e3o criados v\u00e1rios\n\nartefatos necess\u00e1rios para a realiza\u00e7\u00e3o dos testes como por exemplo:\n\n\u2022 casos de uso para descrever procedimentos de teste;\n\n\u2022 arquivos ou bases de dados necess\u00e1rias para rodar os testes;\n\n\u2022 ferramentas que automatizem parte destes testes.\n\nEm cada uma dessas etapas podem ser gerados diversos artefatos que\n\ndescrevem o resultado do trabalho realizado. Um artefato \u00e9 conjunto de informa\u00e7\u00f5es\n\nque representa, \u00e0 sua forma, o software ou uma parte do software sendo desenvolvido.\n\n\n\n90\n\nO objetivo aqui \u00e9 deixar bem claro o conceito de artefato, e n\u00e3o descrever cada artefato\n\ndo Processo Unificado. A descri\u00e7\u00e3o do subconjunto de artefatos utilizados neste projeto\n\nser\u00e1 feita no cap\u00edtulo 4.\n\nPara compreender melhor o conceito de artefato, \u00e9 \u00fatil fazer uso de uma\n\nmet\u00e1fora, utilizando a constru\u00e7\u00e3o civil como objeto de compara\u00e7\u00e3o. Imagine que um\n\nprojeto de uma obra possa ser completamente descrito (ainda que com alguma\n\nredund\u00e2ncia) atrav\u00e9s das seguintes formas:\n\n\u2022 Uma descri\u00e7\u00e3o verbal que registre os desejos do cliente que est\u00e1 contratando aquela\n\nobra;\n\n\u2022 Um esbo\u00e7o de um artista traduzindo esta descri\u00e7\u00e3o;\n\n\u2022 Uma maquete;\n\n\u2022 Uma planta arquitet\u00f4nica mostrando as paredes, portas, janelas, ambientes e outros\n\nelementos que comp\u00f5em o espa\u00e7o f\u00edsico da obra;\n\n\u2022 Uma planta do sistema el\u00e9trico da obra;\n\n\u2022 Uma planta do sistema de encanamentos de \u00e1gua e esgoto da obra;\n\n\u2022 Uma planta do sistema de ventila\u00e7\u00e3o e ar-condicionado da obra.\n\nCada uma destas formas de descrever a obra seria um artefato. Cada uma\n\ndescreve a obra \u00e0 sua maneira, com foco em aspectos diferentes, elaborada e destinada a\n\nser vista por pessoas diferentes. Os esbo\u00e7os e maquetes s\u00e3o mais destinados \u00e0\n\nobserva\u00e7\u00e3o dos clientes ou dos arquitetos que partir\u00e3o daquele conceito para detalhar a\n\n\n\n91\n\nobra, por exemplo, enquanto as plantas mais detalhadas, como a el\u00e9trica, s\u00e3o elaboradas\n\ne destinadas aos profissionais que projetam e implementam estas partes da obra.\n\nNenhum destes artefatos \u00e9 mais importante que o outro (embora cada um possa ter uma\n\nimport\u00e2ncia maior em determinada fase do projeto ou etapa de uma itera\u00e7\u00e3o) e todos\n\ndescrevem a obra, cada um \u00e0 sua maneira.\n\nDa mesma forma, as descri\u00e7\u00f5es dos casos de uso (um artefato criado na etapa de\n\ncaptura de requerimentos), por exemplo, s\u00e3o uma descri\u00e7\u00e3o t\u00e3o importante para um\n\nprojeto de software quanto os diagramas de classe (outro artefato que descreve a\n\narquitetura e a estrutura do software) ou quanto os c\u00f3digos compil\u00e1veis e comentados.\n\nCada um destes artefatos oferece uma vis\u00e3o com maior ou menor grau de detalhe e de\n\num \"\u00e2ngulo\" diferente. Cada um \u00e9 mais adequado a determinada situa\u00e7\u00e3o. Mas todos\n\ndescrevem o produto de alguma forma.\n\nAo descrever cada etapa do desenvolvimento deste projeto, ser\u00e3o descritos\n\ntamb\u00e9m os artefatos que ser\u00e3o gerados naquela etapa e ent\u00e3o o pr\u00f3prio artefato gerado \u00e9\n\nregistrado.\n\n3.2. Bibliotecas\n\nJ\u00e1 foi definido anteriormente o que \u00e9 uma API ou biblioteca no contexto de\n\nprograma\u00e7\u00e3o, e tamb\u00e9m j\u00e1 foi destacada a import\u00e2ncia que essas ferramentas t\u00eam no\n\ndesenvolvimento de aplica\u00e7\u00f5es port\u00e1veis. No entanto esta n\u00e3o \u00e9 a maior vantagem que o\n\nuso de bibliotecas traz no desenvolvimento de software. Pode-se dizer que a maior\n\n\n\n92\n\nvantagem desta pr\u00e1tica \u00e9 permitir que os desenvolvedores se concentrem na\n\nimplementa\u00e7\u00e3o da aplica\u00e7\u00e3o que t\u00eam em mente, ao inv\u00e9s de se preocupar com detalhes\n\nperif\u00e9ricos (como handlers de janelas ou pipelines de renderiza\u00e7\u00e3o). E permite ainda\n\nque se utilize da experi\u00eancia de especialistas em cada uma destas \u00e1reas perif\u00e9ricas \u00e0\n\naplica\u00e7\u00e3o sendo desenvolvida, ao inv\u00e9s de se \"reinventar a roda\".\n\nO uso de APIs traz tamb\u00e9m algumas desvantagens. A principal \u00e9 que se cria uma\n\ndepend\u00eancia entre a aplica\u00e7\u00e3o e a biblioteca utilizada. Se a biblioteca p\u00e1ra de evoluir e\n\nse atualizar com os avan\u00e7os de software e hardware, por exemplo, torna-se dif\u00edcil\n\natualizar a aplica\u00e7\u00e3o. Outra desvantagem \u00e9 que justamente por encapsular alguns\n\nconhecimentos (sua fun\u00e7\u00e3o), a API pode acabar por isolar o desenvolvedor de\n\ninforma\u00e7\u00f5es que lhe seriam \u00fateis no desenvolvimento do software ou na compreens\u00e3o\n\ndo sistema e de seu comportamento. Esta segunda desvantagem pode ser facilmente\n\ncontornada com um estudo dos conhecimentos em quest\u00e3o, sem a necessidade de\n\nimplementar cada detalhe.\n\nA seguir ser\u00e3o discutidas as duas principais bibliotecas utilizadas no\n\ndesenvolvimento deste trabalho, o VTK e o IUP e depois ser\u00e3o apresentadas algumas\n\nalternativas a estas bibliotecas que foram descartadas. Antes disto, por\u00e9m, faz-se uma\n\nbreve exposi\u00e7\u00e3o sobre o processo de sele\u00e7\u00e3o destas bibliotecas.\n\nTanto o VTK quanto o IUP s\u00e3o bibliotecas gratuitas (mas que n\u00e3o exigem que\n\nprodutos que as utilizem tamb\u00e9m o sejam), com c\u00f3digo fonte dispon\u00edvel e excelente\n\ndocumenta\u00e7\u00e3o, al\u00e9m de serem port\u00e1veis para diversas plataformas e atualizadas com\n\nboa freq\u00fc\u00eancia.\n\n\n\n93\n\nO VTK \u00e9 orientado a objetos, baseado em OpenGL, e tem um n\u00famero t\u00e3o\n\nelevado de recursos que por vezes n\u00e3o \u00e9 t\u00e3o simples saber qual utilizar para realizar uma\n\ntarefa. Dentre estes recursos destaca-se a possibilidade de paralelismo, que ser\u00e1\n\ndiscutida mais a fundo adiante.\n\nO IUP, apesar de n\u00e3o ser orientado a objetos, tem como pontos fortes (al\u00e9m da\n\nexcelente documenta\u00e7\u00e3o j\u00e1 citada) a grande simplicidade de utiliza\u00e7\u00e3o e a facilidade de\n\ncria\u00e7\u00e3o de janelas usando o seu layout abstrato.\n\n3.2.1. O Visualization Toolkit\n\nDe acordo com Schroeder et al. (2000), o Visualization Toolkit (VTK) \u00e9 um\n\nsistema de software open-source, port\u00e1vel e orientado a objetos para computa\u00e7\u00e3o\n\ngr\u00e1fica em 3D, visualiza\u00e7\u00e3o cient\u00edfica e processamento de imagens. \u00c9 implementado em\n\nC++ mas tamb\u00e9m suporta Tcl, Python e Java. Por ser open-source e largamente\n\nutilizado, est\u00e1 em constante atualiza\u00e7\u00e3o. Sua p\u00e1gina oficial (Kitware, 2004)\n\ndisponibiliza at\u00e9 uma vers\u00e3o atualizada diariamente (a \"nightly release\"), al\u00e9m da\n\nvers\u00e3o oficial.\n\nSchroeder et al. (1996) afirmam que devido \u00e0 sua variedade de recursos e ao fato\n\nde ser open-source, docentes em diversas universidades utilizam o VTK como\n\nferramenta de ensino e de pesquisa. Ahrens et al. (2000) relatam como o Laborat\u00f3rio de\n\nLos Alamos adaptou o VTK para processamento paralelo de grande escala, gra\u00e7as ao\n\nseu modelo de visualization pipeline, que facilita a paraleliza\u00e7\u00e3o. Law et al. (2001)\n\n\n\n94\n\ndescrevem inclusive uma aplica\u00e7\u00e3o de grande escala (simula\u00e7\u00e3o de clima) que faz uso\n\ndesta ferramenta. Esta vers\u00e3o paralela do VTK chama-se ParaView e tamb\u00e9m se\n\nencontra dispon\u00edvel como open-source. Al\u00e9m disso o VTK \u00e9 usado em projetos\n\ncomerciais nas \u00e1reas de visualiza\u00e7\u00e3o m\u00e9dica e de volumes, explora\u00e7\u00e3o de petr\u00f3leo,\n\nac\u00fastica, CFD (Computational Fluid Dynamics), an\u00e1lise de elementos finitos e\n\nreconstru\u00e7\u00e3o de superf\u00edcies a partir de medidas com LASER.\n\nDiversos padr\u00f5es de projeto (design patterns) bem conhecidos, como f\u00e1brica de\n\nobjetos, s\u00e3o utilizados nesse toolkit para garantir sua portabilidade e extensibilidade.\n\nO VTK \u00e9 composto principalmente por dois subsistemas, o modelo gr\u00e1fico e a\n\nVisualization Pipeline. O modelo gr\u00e1fico \u00e9 uma camada abstrata sobre a linguagem\n\ngr\u00e1fica. Atualmente, o VTK s\u00f3 suporta o OpenGL como linguagem gr\u00e1fica, j\u00e1 que ele\n\nfoi adotado como padr\u00e3o pela ind\u00fastria. No entanto, outras linguagens j\u00e1 foram\n\nsuportadas e, mantendo esse modelo gr\u00e1fico abstrato, \u00e9 poss\u00edvel atualizar o VTK sem\n\nproblemas de compatibilidade com vers\u00f5es antigas se outros padr\u00f5es forem adotados no\n\nfuturo.\n\nA Visualization Pipeline (ou rede de visualiza\u00e7\u00e3o) transforma dados em formas\n\nque podem ser exibidas pelo sistema gr\u00e1fico (imagens 2D, pol\u00edgonos ou volumes). Ela \u00e9\n\nconstru\u00edda conectando objetos de dados e objetos de processo (tamb\u00e9m chamados de\n\nfiltros).\n\nObjetos de dados representam informa\u00e7\u00e3o como um campo (um vetor de\n\nvetores) contendo informa\u00e7\u00f5es geom\u00e9tricas (as coordenadas dos pontos) e,\n\nopcionalmente, informa\u00e7\u00f5es topol\u00f3gicas (como os pontos est\u00e3o conectados, formando\n\nlinhas, faces etc.) Al\u00e9m disso, objetos de dados podem armazenar atributos para cada\n\n\n\n95\n\nponto. Esses atributos podem ser escalares (como a temperatura em um ponto), vetores\n\n(por exemplo, velocidade), tensores, normais, ou texturas (o \"ou\" n\u00e3o \u00e9 exclusivo, um\n\nmesmo ponto pode ter mais de um atributo de tipos diferentes, mas somente um atributo\n\nde cada tipo).\n\nObjetos de processo operam sobre objetos de dados, seja gerando dados a partir\n\nde uma equa\u00e7\u00e3o ou arquivo, transformando-os em outros tipos de dados (por exemplo,\n\nVTKContourFilter transforma dados volum\u00e9tricos em pol\u00edgonos) ou conectando esses\n\ndados ao sistema gr\u00e1fico para que possam ser exibidos. Os objetos de processo que\n\ngeram dados s\u00e3o chamados de Sources (fontes). Os que transformam dados s\u00e3o\n\nchamados de Filters (filtros) e os que conectam a pipeline ao sistema gr\u00e1fico s\u00e3o\n\nchamados de Mappers (mapeadores). Mappers tamb\u00e9m podem, ao inv\u00e9s de exibir o\n\nobjeto, salv\u00e1-lo num arquivo.\n\nA execu\u00e7\u00e3o dessa pipeline \u00e9 controlada cuidadosamente para garantir a\n\nfidelidade dos dados e evitar opera\u00e7\u00f5es desnecess\u00e1rias. Filtros s\u00f3 s\u00e3o re-executados se\n\nhouver uma mudan\u00e7a em seus par\u00e2metros ou em sua entrada. Cada objeto no VTK tem\n\num time-stamp interno que \u00e9 alterado toda vez que o objeto em si sofre alguma\n\nmudan\u00e7a. Objetos de dados e de processos tem adicionalmente um time-stamp\n\nrelacionado com sua execu\u00e7\u00e3o dentro da pipeline. O sistema compara esses tempos para\n\ndeterminar quais objetos est\u00e3o desatualizados e, portanto, que parte da pipeline deve ser\n\nre-executada. Dessa forma, o controle da execu\u00e7\u00e3o dessas opera\u00e7\u00f5es est\u00e1 distribu\u00eddo\n\nentre os objetos. Muitos sistemas de visualiza\u00e7\u00e3o utilizam uma fun\u00e7\u00e3o centralizada para\n\ncontrolar essa execu\u00e7\u00e3o, o que se torna um gargalo em aplica\u00e7\u00f5es altamente\n\nparalelizadas.\n\n\n\n96\n\n3.2.2. IUP - Interface com o Usu\u00e1rio Port\u00e1vel\n\nA motiva\u00e7\u00e3o para o desenvolvimento do IUP/LED, contam Levy et al. (1996),\n\nfoi criar uma ferramenta para constru\u00e7\u00e3o de interfaces que fosse de f\u00e1cil aprendizado e\n\nde uso eficiente. Para tanto, as seguintes caracter\u00edsticas figuraram entre os requisitos de\n\nprojeto dessa ferramenta:\n\n\u2022 Derivar aplica\u00e7\u00f5es para m\u00faltiplas plataformas a partir de uma \u00fanica especifica\u00e7\u00e3o e\n\nutilizando o mesmo ambiente de desenvolvimento, por\u00e9m mantendo a apar\u00eancia e\n\ncomportamento (look-and-feel) de cada plataforma.\n\n\u2022 Permitir a prototipa\u00e7\u00e3o r\u00e1pida de interfaces e a r\u00e1pida incorpora\u00e7\u00e3o de modifica\u00e7\u00f5es\n\n\u00e0s mesmas.\n\n\u2022 Minimizar a quantidade de fun\u00e7\u00f5es ou ferramentas que devem ser conhecidas pelo\n\nusu\u00e1rio antes que ele se torne produtivo.\n\n\u2022 Ser expans\u00edvel.\n\n\n\n97\n\nConclui-se que um UIT13 port\u00e1vel que suportasse um modelo de layout\n\nabstrato14 das interfaces e que permitisse (mas n\u00e3o impusesse) a interpreta\u00e7\u00e3o de\n\ndescri\u00e7\u00f5es da interface em tempo de execu\u00e7\u00e3o seria uma boa base para atender a esses\n\nrequisitos. Com isso em mente, o IUP/LED foi desenvolvido com as seguintes\n\ncaracter\u00edsticas:\n\n\u2022 Uma linguagem simples para descri\u00e7\u00e3o das interfaces (LED) de r\u00e1pido aprendizado.\n\nA descri\u00e7\u00e3o da interface no LED \u00e9 feita atrav\u00e9s da fun\u00e7\u00e3o de seus elementos. A\n\nespecifica\u00e7\u00e3o da apar\u00eancia desses elementos \u00e9 opcional.\n\n\u2022 Um toolkit \"virtual\" (pois converte a especifica\u00e7\u00e3o para outros toolkits, como SDK\n\nou Motif) de suporte ao LED, o IUP. O IUP conta com fun\u00e7\u00f5es que convertem\n\nespecifica\u00e7\u00f5es em LED para objetos de interface nativos, associam a\u00e7\u00f5es do usu\u00e1rio\n\nsobre a interface com fun\u00e7\u00f5es da aplica\u00e7\u00e3o e obt\u00e9m e modificam atributos de\n\nelementos da interface. Como simplicidade \u00e9 um objetivo, o IUP tem um conjunto\n\npequeno de fun\u00e7\u00f5es (apenas 40).\n\n\u2022 Um modelo simples de especifica\u00e7\u00e3o da interface utilizando layout abstrato.\n\n                                                \n\n13 User Interface Toolkits: Biblioteca de objetos de interface que implementam diferentes\nt\u00e9cnicas de intera\u00e7\u00e3o com o usu\u00e1rio. Tipicamente incluem formas para simplificar a descri\u00e7\u00e3o e\ncomposi\u00e7\u00e3o das interfaces, que v\u00e3o desde uma linguagem a editores gr\u00e1ficos. Exemplos s\u00e3o\nSDK do MS Windows, OSF/Motif, XView e Macintosh Toolbox.\n14 O Layout concreto define a posi\u00e7\u00e3o e tamanho exatos de cada componente da interface,\nenquanto o layout abstrato define as posi\u00e7\u00f5es relativas entre esses objetos, sem a necessidade de\ncalcular coordenadas exatas. O layout abstrato tipicamente \u00e9 mais simples para ser especificado\ne permite que a interface se reconfigure para se adaptar a mudan\u00e7as de tamanho (por exemplo\nquando o usu\u00e1rio maximiza uma janela).\n\n\n\n98\n\n\u2022 Look-and-feel nativo (aquele que o usu\u00e1rio de uma determinada plataforma espera,\n\nindicado para usu\u00e1rios que usam diversos programas em uma mesma plataforma) ou\n\nfixo (imposto pelo aplicativo, indicado no caso de o usu\u00e1rio utilizar o mesmo\n\naplicativo em diversas plataformas distintas).\n\n\u2022 Interpreta\u00e7\u00e3o do LED em tempo de execu\u00e7\u00e3o com overhead m\u00ednimo, para\n\nprototipa\u00e7\u00e3o r\u00e1pida, permitindo modificar-se a interface sem a necessidade de\n\nrecompilar todo o c\u00f3digo. A interface tamb\u00e9m pode ser criada diretamente no\n\nc\u00f3digo, sem utilizar ou interpretar LED, utilizando o IUP.\n\n\u2022 Port\u00e1vel para diversas plataformas, sem que o programador seja obrigado a ter\n\nconhecimento de cada uma dessas plataformas.\n\n\u2022 Expans\u00edvel.\n\n\u2022 Permite acesso direto ao elemento de interface nativo do sistema (atrav\u00e9s de\n\nhandlers do MS-Windows, por exemplo).\n\n\u2022 Utiliza o modelo de fun\u00e7\u00f5es callback para integra\u00e7\u00e3o da interface com a aplica\u00e7\u00e3o.\n\nComo j\u00e1 foi mencionado, essas caracter\u00edsticas tiveram sucesso em tornar o IUP\n\numa ferramenta bastante flex\u00edvel e ao mesmo tempo simples de se utilizar. Mas de\n\nacordo com Levy et al. (1996) essa ferramenta ainda apresenta algumas defici\u00eancias,\n\ncomo:\n\n\u2022 N\u00e3o \u00e9 orientado a objetos.\n\n\n\n99\n\n\u2022 Falta de suporte para help sens\u00edvel a contexto e opera\u00e7\u00f5es com a \u00e1rea de\n\ntransfer\u00eancia (cut-and-paste).\n\n\u2022 N\u00e3o suporta MDI (Multiple Document Interface).\n\nEssas duas funcionalidades podem ser implementadas utilizando o IUP/LED\n\n(por exemplo utilizando um Canvas, um objeto do IUP sobre o qual se pode desenhar,\n\npara desenhar os m\u00faltiplos documentos), por\u00e9m seria um processo razoavelmente\n\ncomplexo, ao contr\u00e1rio da simplicidade exibida pela ferramenta para realizar as outras\n\nfun\u00e7\u00f5es.\n\n3.2.3. Alternativas Pesquisadas\n\nDentre as alternativas ao uso do VTK pesquisadas, destacam-se:\n\n\u2022 Performer: A Silicon Graphics, Inc. (2002) descreve o Performer como uma API\n\ngr\u00e1fica (tamb\u00e9m com base no OpenGL) voltada para renderiza\u00e7\u00e3o de cenas\n\ncomplexas e realistas em tempo real. Originalmente essa API era desenvolvida\n\nsomente para o ambiente IRIX, mas recentemente (final de 2002) tornou-se\n\ncompat\u00edvel com os ambientes Linux e Windows NT, 2000 e XP. Sua arquitetura\n\nprev\u00ea e facilita paraleliza\u00e7\u00e3o de c\u00f3digo. Utiliza uma pipeline para renderiza\u00e7\u00e3o e\n\ngrafos (scene graphs) para modelar as cenas. \u00c9 software propriet\u00e1rio da SGI15.\n\n                                                \n\n15 Silicon Graphics, Inc.\n\n\n\n100\n\nApesar do Performer ser uma biblioteca bastante poderosa e flex\u00edvel e tamb\u00e9m\n\ndispon\u00edvel na Escola Polit\u00e9cnica, foi preterido pelo VTK pois este tem mais recursos\n\nde visualiza\u00e7\u00e3o cient\u00edfica e \u00e9 open-source ao inv\u00e9s de propriet\u00e1rio como era o\n\nPerformer no in\u00edcio do trabalho.\n\n\u2022 Java 3D: Esta biblioteca para Java desenvolvida pela Sun tamb\u00e9m conta com um\n\ngrande n\u00famero de recursos para exibi\u00e7\u00e3o, navega\u00e7\u00e3o e intera\u00e7\u00e3o com a cena e,\n\nassim como o Java, \u00e9 gratuita e independente de plataforma. Em sua homepage,\n\nconsultada em 2004, encontra-se uma documenta\u00e7\u00e3o bastante completa. O uso da\n\ncombina\u00e7\u00e3o Java/Java 3D tornaria desnecess\u00e1rio o uso do IUP, uma vez que o Java\n\nj\u00e1 conta com ferramentas para desenvolvimento de interface e que, mais uma vez,\n\nn\u00e3o dependem de plataforma. O Java 3D tamb\u00e9m utiliza scene graphs ou grafos de\n\ncena para abstrair a modelagem das cenas e \u00e9 de uso relativamente simples. No\n\nentanto atribuir dados sobre a estrutura de pol\u00edgonos usada pelo Java 3D n\u00e3o \u00e9\n\ntrivial, o que dificulta o uso de t\u00e9cnicas de Visualiza\u00e7\u00e3o Cient\u00edfica. Al\u00e9m disso,\n\nainda que a efici\u00eancia seja uma preocupa\u00e7\u00e3o importante no desenvolvimento desta\n\nAPI, n\u00e3o deixa de ser uma linguagem interpretada e, portanto, \u00e9 mais lenta e\n\ndemanda mais mem\u00f3ria que um programa compilado. Embora para muitas\n\naplica\u00e7\u00f5es esta diferen\u00e7a n\u00e3o seja percept\u00edvel com a velocidade e capacidade de\n\nmem\u00f3ria das m\u00e1quinas atuais, este n\u00e3o \u00e9 o caso neste trabalho. Recentemente, em\n\n2004, o Java 3D passou a ser um projeto open-source.\n\n\u2022 VRML: A VRML (Virtual Reality Modeling Language) \u00e9 uma linguagem para\n\ndescri\u00e7\u00e3o de mundos 3D, voltada para exibi\u00e7\u00e3o destes mundos na Internet. Seu uso\n\n\u00e9 bastante simples, por\u00e9m n\u00e3o conta com um grande n\u00famero de recursos. Pode ser\n\n\n\n101\n\ncombinada, de forma limitada, com JavaScript ou Java para aumentar suas\n\ncapacidades. No entanto, tamb\u00e9m \u00e9 uma linguagem interpretada e n\u00e3o conta com um\n\ninterpretador \u00fanico que obede\u00e7a a todos os detalhes de sua especifica\u00e7\u00e3o, como \u00e9 o\n\ncaso da m\u00e1quina virtual do Java. O interpretador mais popular, por exemplo, o\n\nCosmo, n\u00e3o tem capacidade de lidar com estereoscopia. Outros interpretadores\n\nfazem isso, mas n\u00e3o conseguem interpretar c\u00f3digo em Java ou Java 3D embedded\n\nno VRML. Por esse motivo a especifica\u00e7\u00e3o do VRML foi abandonada em favor de\n\numa nova especifica\u00e7\u00e3o, a X3D, que ainda estava em desenvolvimento durante a\n\nexecu\u00e7\u00e3o deste trabalho, mas recentemente teve uma primeira vers\u00e3o conclu\u00edda.\n\nPode-se encontrar mais informa\u00e7\u00f5es sobre o VRML e o X3D na homepage do\n\nWeb3D Consortium, consultada em 2004.\n\n\u2022 Open Inventor: De acordo com Bicho et al.(2002), trata-se de uma toolkit orientada\n\na objetos para o desenvolvimento de aplica\u00e7\u00f5es interativas gr\u00e1ficas 3D em C/C++,\n\nconstru\u00edda sobre o OpenGL, tamb\u00e9m baseada no conceito de grafos de cena (como o\n\nJava 3D) e que disp\u00f5e tamb\u00e9m de um formato de arquivo de dados 3D padr\u00e3o para\n\ntroca de informa\u00e7\u00f5es entre aplica\u00e7\u00f5es e plataformas. Criado pela SGI, \u00e9 open-source\n\ne independente de plataforma. N\u00e3o conta, no entanto, com recursos para\n\nvisualiza\u00e7\u00e3o cient\u00edfica como o VTK, apesar de ser uma excelente alternativa para\n\noutras aplica\u00e7\u00f5es.\n\nSem d\u00favida existem outras alternativas que poderiam ter sido pesquisadas mais a\n\nfundo, como o Open Scene Graph, no entanto ao longo desta pesquisa o VTK foi se\n\nmostrando cada vez mais adequado e por fim foi adotado.\n\n\n\n102\n\nDa mesma forma, o IUP se adequou t\u00e3o bem \u00e0s necessidades do projeto que n\u00e3o\n\nfoi feita uma pesquisa aprofundada de alternativas para essa API. Tai (2004) e a pr\u00f3pria\n\ndocumenta\u00e7\u00e3o do IUP, entretanto, fazem um levantamento de diversas alternativas.\n\nEmbora as informa\u00e7\u00f5es nesta homepage nem sempre estejam completas (como \u00e9 o caso\n\nda informa\u00e7\u00e3o sobre as plataformas suportadas pelo IUP), ela serve como um \u00f3timo\n\nponto de partida para quem se dispuser a fazer uma an\u00e1lise de alternativas mais\n\ndetalhada. A pr\u00f3pria documenta\u00e7\u00e3o do IUP cita alternativas ao seu uso.\n\n3.3. Shaders\n\n\u00c9 oportuno fazer aqui uma exposi\u00e7\u00e3o dos conceitos b\u00e1sicos relativos a shaders,\n\npois esses conceitos s\u00e3o utilizados em diversos pontos do cap\u00edtulo 6, ao se discutir\n\ntrabalhos futuros, ainda que esse recurso n\u00e3o seja usado em outros pontos neste\n\ntrabalho, pelo motivo que ser\u00e1 discutido adiante.\n\nDe acordo com Kessenich et al. (2004), Shaders s\u00e3o programas simples que\n\npoder ser executados diretamente nas placas gr\u00e1ficas, nos dois pontos da pipeline que\n\ns\u00e3o program\u00e1veis no hardware mais recente: Vertex Shaders s\u00e3o programas que agem\n\nsobre todos os v\u00e9rtices que s\u00e3o enviados \u00e0 pipeline e Pixel ou Fragment Shaders agem\n\nsobre os pixels antes que sejam exibidos. De acordo com Barrera (2004), shaders est\u00e3o\n\ndispon\u00edveis no OpenGL desde 2002, pouco ap\u00f3s o surgimento de hardware gr\u00e1fico\n\nprogram\u00e1vel, atrav\u00e9s de duas de suas extens\u00f5es. Era necess\u00e1rio, no entanto, program\u00e1-\n\nlos em Assembly, o que dificultava e limitava consideravelmente seu uso. Ap\u00f3s o\n\nsurgimento, mais recente, de linguagens de alto n\u00edvel para shaders como a HLSL da\n\n\n\n103\n\nMicrosoft e a Cg da NVidia, foi desenvolvida tamb\u00e9m uma linguagem de shading para\n\no OpenGL, na tentativa de se estabelecer um padr\u00e3o. Essa linguagem, a GLSL (GL\n\nShading Language), s\u00f3 passou a ser suportada por hardware na segunda metade de\n\n2004, pelos drivers da s\u00e9rie 60 da NVidia e pelas placas GeForce da s\u00e9rie FX. Barrera\n\nconta que esses programas podem ser usados para implementar diretamente no\n\nprocessador gr\u00e1fico diversos efeitos como modelos mais realistas de ilumina\u00e7\u00e3o, bump-\n\nmapping, sombras entre muitos outros. Como o suporte de hardware para a GLSL s\u00f3\n\nsurgiu quando este trabalho j\u00e1 estava em sua fase de conclus\u00e3o, esse recurso n\u00e3o \u00e9\n\nusado, exceto na discuss\u00e3o de trabalhos futuros.\n\n\n\n104\n\n4. A METODOLOGIA E O RISERVIEW\n\nEste cap\u00edtulo tem uma dupla finalidade. Em primeiro lugar discute a\n\nmetodologia usada no desenvolvimento do RiserView - o ambiente de visualiza\u00e7\u00e3o de\n\nrisers. Mas vai al\u00e9m disso. A metodologia \u00e9 exposta atrav\u00e9s de sua aplica\u00e7\u00e3o neste\n\nprojeto e, dessa forma, o pr\u00f3prio projeto \u00e9 exposto, atrav\u00e9s das diversas vistas\n\noferecidas por ela. Este \u00e9 o segundo objetivo deste cap\u00edtulo: oferecer uma vis\u00e3o do\n\nRiserView que vai desde o geral at\u00e9 um grau maior de detalhe. \u00c9 um cap\u00edtulo de\n\naspecto mais pr\u00e1tico, em sua maior parte. Embora todos os aspectos te\u00f3ricos discutidos\n\nanteriormente tenham sido, necessariamente, levados em considera\u00e7\u00e3o durante todo o\n\nprocesso, este cap\u00edtulo n\u00e3o se preocupa em descrever como, mas sim em exibir o\n\nprocesso de projeto e implementa\u00e7\u00e3o do Ambiente bem como o Ambiente em si.\n\nPrimeiramente s\u00e3o detalhadas e justificadas as customiza\u00e7\u00f5es feitas \u00e0\n\nmetodologia para o projeto do RiserView. Em seguida a parte mais importante do\n\ncap\u00edtulo exibe como cada passo desta metodologia customizada \u00e9 aplicado e\n\nimplementado, oferecendo n\u00e3o s\u00f3 uma vis\u00e3o da metodologia como v\u00e1rias vis\u00f5es do\n\nRiserView.\n\n\n\n105\n\n4.1. Customiza\u00e7\u00e3o da Metodologia\n\nConforme j\u00e1 se espera ter deixado claro, o Processo Unificado n\u00e3o se trata de\n\numa \u00fanica metodologia, mas sim de uma framework completa que pode ser adaptada\n\ncomo metodologia para projetos com escalas e caracter\u00edsticas bastante distintas. Por isso\n\nconta com uma grande variedade e quantidade de artefatos, para que tenha esta\n\nadaptabilidade. Assim sendo, a adapta\u00e7\u00e3o ou customiza\u00e7\u00e3o da metodologia para um\n\ndeterminado projeto, a escolha do subconjunto de artefatos mais significativos, \u00e9 um\n\ntrabalho necess\u00e1rio para seu uso. Al\u00e9m disso, adequando o processo \u00e0 escala do projeto\n\nreduz-se em muito o desperd\u00edcio de tempo com a cria\u00e7\u00e3o e manuten\u00e7\u00e3o de artefatos\n\ndesnecess\u00e1rios.\n\nEnquanto at\u00e9 agora neste cap\u00edtulo tenha sido necess\u00e1rio discutir o Processo\n\nUnificado de uma maneira mais geral, a partir de agora passa-se a discutir sua aplica\u00e7\u00e3o\n\nno projeto em quest\u00e3o.\n\nA primeira simplifica\u00e7\u00e3o feita na metodologia para este projeto est\u00e1 relacionada\n\n\u00e0s suas fases. De acordo com Smith (2002), as fases de concep\u00e7\u00e3o e elabora\u00e7\u00e3o, por\n\nexemplo, podem ser bastante reduzidas em projetos de pequena escala e baixo risco.\n\nEstas fases foram percorridas (o projeto, inicialmente, foi especificado suficientemente\n\npara que se pudesse analisar a viabilidade de execut\u00e1-lo com o tempo e os recursos\n\nf\u00edsicos e humanos dispon\u00edveis, foi feito um cronograma para o projeto etc.), mas isto foi\n\nfeito de forma bastante abreviada, n\u00e3o s\u00f3 devido \u00e0 escala do projeto, como tamb\u00e9m\n\nporque o foco deste trabalho s\u00e3o os aspectos t\u00e9cnicos de projeto e arquitetura de\n\nsoftware, computa\u00e7\u00e3o gr\u00e1fica, visualiza\u00e7\u00e3o cient\u00edfica e outros pontos discutidos no\n\n\n\n106\n\ncap\u00edtulo anterior e n\u00e3o aspectos econ\u00f4micos. Desta forma, propositadamente n\u00e3o est\u00e3o\n\nregistradas neste trabalho as fases de concep\u00e7\u00e3o e elabora\u00e7\u00e3o do projeto. J\u00e1 a fase de\n\ntransi\u00e7\u00e3o s\u00f3 ser\u00e1 iniciada com o fim deste trabalho e a libera\u00e7\u00e3o do programa para um\n\nmaior n\u00famero de usu\u00e1rios e portanto tamb\u00e9m n\u00e3o pode ser descrita aqui. Daqui em\n\ndiante este trabalho tratar\u00e1, portanto, unicamente da fase de constru\u00e7\u00e3o.\n\nOutra simplifica\u00e7\u00e3o importante est\u00e1 relacionada com as itera\u00e7\u00f5es do processo. O\n\ndesenvolvimento deste projeto foi dividido em tr\u00eas itera\u00e7\u00f5es incrementais, que ser\u00e3o\n\ndiscutidas na pr\u00f3xima se\u00e7\u00e3o. No entanto, ao inv\u00e9s de discutir as etapas de cada uma\n\ndestas itera\u00e7\u00f5es separadamente, elas ser\u00e3o discutidas de uma s\u00f3 vez. Os artefatos\n\nregistrados s\u00e3o o resultado de todas as itera\u00e7\u00f5es. Como as itera\u00e7\u00f5es s\u00e3o incrementais, os\n\nartefatos tamb\u00e9m crescem com cada itera\u00e7\u00e3o. Ao inv\u00e9s de mostrar os artefatos gerados\n\nem cada uma - o que iria requerer um trabalho adicional e gerar mais redund\u00e2ncia nestes\n\nartefatos - s\u00e3o exibidos os artefatos finais, resultantes da \u00faltima itera\u00e7\u00e3o.\n\nSendo assim, a descri\u00e7\u00e3o do projeto pode ser feita como o registro de uma \u00fanica\n\nseq\u00fc\u00eancia de etapas e dos artefatos produzidos em cada uma delas. \u00c9 desta forma que\n\neste cap\u00edtulo \u00e9 estruturado a partir da pr\u00f3xima se\u00e7\u00e3o.\n\nComo j\u00e1 se chamou \u00e0 aten\u00e7\u00e3o, Jacobson et al. (1998) afirmam que o modelo\n\nobtido na etapa de an\u00e1lise nem sempre precisa ser mantido nas outras etapas do projeto\n\ne que, para projetos de pequeno porte, esta etapa pode ser inclusive eliminada (na\n\nverdade, absorvida pelas etapas de requerimentos, projeto e implementa\u00e7\u00e3o). Esta\n\nsimplifica\u00e7\u00e3o tamb\u00e9m foi adotada neste projeto.\n\n\n\n107\n\nPor fim, em cada uma das etapas que ser\u00e3o descritas a seguir foi escolhido um\n\nsubconjunto de artefatos adequados. Este subconjunto e as raz\u00f5es para sua escolha est\u00e3o\n\nlistados em cada etapa.\n\n4.2. Itera\u00e7\u00f5es\n\nUma das principais caracter\u00edsticas do Processo Unificado \u00e9 se tratar de um\n\nprocesso iterativo. Cada uma de suas fases \u00e9 composta por uma ou mais itera\u00e7\u00f5es. J\u00e1 foi\n\nafirmado que, neste trabalho, as fases de concep\u00e7\u00e3o e elabora\u00e7\u00e3o foram feitas\n\nabreviadamente em somente uma itera\u00e7\u00e3o. A fase de constru\u00e7\u00e3o, que ser\u00e1 detalhada\n\naqui, no entanto, \u00e9 composta por tr\u00eas itera\u00e7\u00f5es principais:\n\n i. Na primeira itera\u00e7\u00e3o a preocupa\u00e7\u00e3o \u00e9 exibir e animar em tr\u00eas dimens\u00f5es objetos de\n\ninteresse, a princ\u00edpio separadamente, com base em arquivos de dados descrevendo\n\nao longo do tempo os estados dos diversos objetos (principalmente risers, mas\n\ntamb\u00e9m v\u00f3rtices representados discretamente ou por campos de escalares, a\n\nsuperf\u00edcie da l\u00e2mina d'\u00e1gua, o fundo oce\u00e2nico e modelos para representar\n\nembarca\u00e7\u00f5es ou outras estruturas r\u00edgidas). A navega\u00e7\u00e3o do usu\u00e1rio pelas cenas\n\nexibindo estes objetos tamb\u00e9m \u00e9 implementada nesta fase, bem como a ilumina\u00e7\u00e3o\n\nda cena, aplica\u00e7\u00e3o de texturas e anti-aliasing.\n\n ii. A segunda itera\u00e7\u00e3o \u00e9 mais relacionada com a interface de usu\u00e1rio do programa.\n\nNesta itera\u00e7\u00e3o \u00e9 elaborada a interface e \u00e9 integrada \u00e0 ela a visualiza\u00e7\u00e3o de cada um\n\ndos objetos, que tinha sido desenvolvida na itera\u00e7\u00e3o anterior. Tamb\u00e9m s\u00e3o\n\n\n\n108\n\nimplementados mecanismos para controle da anima\u00e7\u00e3o (parar, avan\u00e7ar, voltar,\n\nquadro a quadro, acelerada...) e de detalhes da visualiza\u00e7\u00e3o (cores, texturas, anti-\n\naliasing, vistas, o que exibir etc.).\n\n iii. Por fim, na \u00faltima itera\u00e7\u00e3o foi implementada a detec\u00e7\u00e3o de colis\u00f5es entre risers.\n\nComo j\u00e1 se disse, embora em cada uma destas itera\u00e7\u00f5es tenha-se tratado de um\n\nsubconjunto dos casos de uso e se preocupado com somente parte da arquitetura, o que\n\nser\u00e1 apresentado neste cap\u00edtulo ser\u00e1 o resultado completo e final do trabalho, sem a\n\npreocupa\u00e7\u00e3o de registrar aqui os artefatos gerados em cada uma das itera\u00e7\u00f5es.\n\n4.3. Captura de Requerimentos\n\nConforme indicado na se\u00e7\u00e3o anterior, com as simplifica\u00e7\u00f5es feitas na etapa de\n\ncustomiza\u00e7\u00e3o do Processo Unificado para este projeto, sua descri\u00e7\u00e3o pode ser feita\n\ncomo um registro de uma \u00fanica seq\u00fc\u00eancia das seguintes etapas: Captura de\n\nRequerimentos, Projeto, Implementa\u00e7\u00e3o e Testes. Estas etapas ser\u00e3o descritas\n\nprincipalmente por um conjunto de artefatos gerados em cada uma delas. Cada um\n\ndestes artefatos, deve-se lembrar, oferece uma vista do RiserView. Nesta se\u00e7\u00e3o\n\ndescreve-se a primeira destas etapas, a Captura de Requerimentos.\n\nComo esta \u00e9 a etapa que vai nortear todo o trabalho daqui por diante, deve ser\n\nfeita da maneira mais cuidadosa poss\u00edvel. Um erro nesta etapa pode causar uma grande\n\nquantidade de retrabalho no projeto. Por isso, esta \u00e9 a etapa que conta, neste projeto,\n\ncom o maior n\u00famero de artefatos: diagramas de casos de uso, uma lista de atores, uma\n\n\n\n109\n\nlista de casos de uso com uma descri\u00e7\u00e3o textual de cada caso, uma lista de\n\nrequerimentos especiais (n\u00e3o associados a um caso de uso espec\u00edfico), uma descri\u00e7\u00e3o\n\ntextual dos requerimentos como um todo, um gloss\u00e1rio e um prot\u00f3tipo da interface com\n\no usu\u00e1rio.\n\n4.3.1. Descri\u00e7\u00e3o dos Requerimentos\n\nEste primeiro artefato nada mais \u00e9 que uma descri\u00e7\u00e3o textual dos requerimentos\n\ndo software, menos detalhada que os casos de uso. \u00c9 um primeiro esbo\u00e7o de\n\nespecifica\u00e7\u00e3o do software, serve para nortear os pr\u00f3ximos passos bem como para\n\nfornecer uma r\u00e1pida vis\u00e3o panor\u00e2mica do RiserView.\n\nO software desenvolvido neste trabalho deve ser capaz de exibir cenas em tr\u00eas\n\ndimens\u00f5es compostas por diversos objetos distintos. Os objetos de maior interesse s\u00e3o\n\nos risers. Outros objetos que podem compor a cena s\u00e3o representa\u00e7\u00f5es de v\u00f3rtices, da\n\nsuperf\u00edcie da l\u00e2mina d'\u00e1gua, do fundo e modelos r\u00edgidos para representar embarca\u00e7\u00f5es\n\nou estruturas. Exceto pelo fundo, cada um destes objetos tem sua din\u00e2mica pr\u00f3pria,\n\nque deve ser mostrada utilizando anima\u00e7\u00e3o e outras t\u00e9cnicas de visualiza\u00e7\u00e3o cient\u00edfica.\n\nA descri\u00e7\u00e3o dos objetos e de sua din\u00e2mica \u00e9 dada por arquivos com formatos\n\ndefinidos, que s\u00e3o selecionados pelo usu\u00e1rio para montar a cena. Para facilitar a\n\ngera\u00e7\u00e3o de cenas, deve ser poss\u00edvel salvar arquivos que associem mais de um objeto\n\nem um s\u00f3 arquivo.\n\n\n\n110\n\nO usu\u00e1rio deve ser capaz de navegar pela cena utilizando mouse e teclado,\n\naproximando-se ou afastando-se dela, girando a cena ou a arrastando em qualquer\n\ndire\u00e7\u00e3o. A navega\u00e7\u00e3o, no entanto, deve ser restrita a vistas verticais ou horizontais.\n\nO usu\u00e1rio tamb\u00e9m deve ser capaz de controlar a anima\u00e7\u00e3o, interrompendo e\n\nretomando seu fluxo a qualquer momento (desde que haja algo para animar), avan\u00e7ando\n\nou voltando um quadro por vez, ou, ao contr\u00e1rio, em velocidade acelerada. Quando n\u00e3o\n\nacelerada, a anima\u00e7\u00e3o deve ocorrer em tempo real, se poss\u00edvel. A interface deve exibir\n\num mostrador com o tempo atual da anima\u00e7\u00e3o, em segundos.\n\nO controle da exibi\u00e7\u00e3o ou n\u00e3o de cada tipo de objeto tamb\u00e9m deve ser permitido\n\npela interface. Para os v\u00f3rtices, deve ser permitido escolher se devem ser exibidos\n\nv\u00f3rtices discretos ou campos escalares. O usu\u00e1rio deve tamb\u00e9m ser capaz de controlar\n\nos par\u00e2metros de exibi\u00e7\u00e3o dos risers (n\u00famero de faces no cilindro e fatores de\n\namplifica\u00e7\u00e3o para o di\u00e2metro e para o movimento), as cores do fundo da tela, dos\n\nmodelos do solo e da superf\u00edcie oce\u00e2nica, bem como as texturas e coordenadas de\n\ntextura para o solo e a superf\u00edcie. Outras op\u00e7\u00f5es que podem ser controladas pelo usu\u00e1rio\n\ns\u00e3o a ativa\u00e7\u00e3o ou n\u00e3o de anti-aliasing, estereoscopia e detec\u00e7\u00e3o de colis\u00f5es entre risers.\n\nO usu\u00e1rio deve ser capaz de salvar estas op\u00e7\u00f5es em arquivo e recuper\u00e1-las\n\nposteriormente.\n\nCaso a detec\u00e7\u00e3o de colis\u00f5es seja ativada, a amplifica\u00e7\u00e3o dos di\u00e2metros e dos\n\nmovimentos dos risers \u00e9 desativada e, cada vez que ocorre uma colis\u00e3o, a cor dos risers\n\nenvolvidos \u00e9 modificada na vizinhan\u00e7a do ponto de colis\u00e3o, uma mensagem de alerta \u00e9\n\nmostrada pela interface e a anima\u00e7\u00e3o \u00e9 interrompida, de forma a permitir que o usu\u00e1rio\n\npossa registrar o momento e local da colis\u00e3o.\n\n\n\n111\n\n4.3.2. Atores\n\nA lista de atores \u00e9 um artefato auxiliar, que tipicamente serve como refer\u00eancia\n\npara os diagramas e descri\u00e7\u00f5es dos casos de uso. No contexto dos casos de uso,\n\nJacobson et al. (1998) definem um ator como \"um conjunto coerente de pap\u00e9is que um\n\nusu\u00e1rio dos casos de uso desempenha quando interagindo com estes casos de uso\". Por\n\nexemplo, num sistema de leil\u00f5es pela Internet, podem existir 3 atores: o comprador\n\n(representando todos que fazem ofertas por um item), o vendedor (dono atual do item) e\n\no leiloeiro. Nem todos os atores precisam ser humanos. No caso anterior, o leiloeiro\n\npode ser um subsistema que interage com casos de uso do sistema de leil\u00f5es. No caso\n\ndo RiserView, ao menos para esta vers\u00e3o, s\u00f3 existe um ator, o usu\u00e1rio, definido abaixo:\n\nUsu\u00e1rio: O usu\u00e1rio final do programa \u00e9 o \u00fanico ator do sistema e s\u00f3 existe\n\num tipo de usu\u00e1rio. Este ator acessa todas as capacidades do programa, podendo\n\ncriar cenas a partir de arquivos com dados dos objetos de interesse, controlar a\n\nexibi\u00e7\u00e3o de elementos da cena, sua visualiza\u00e7\u00e3o e anima\u00e7\u00e3o e tamb\u00e9m navegar pela\n\ncena.\n\n\n\n112\n\n4.3.3. Diagramas de Casos de Uso\n\nEste artefato tem como finalidade exibir de uma maneira gr\u00e1fica e r\u00e1pida os\n\ncasos de uso que ser\u00e3o detalhados em outro artefato. Como o n\u00famero de casos de uso de\n\num sistema tende a ser muito grande, muitas vezes torna-se \u00fatil agrup\u00e1-los numa forma\n\nque agilize sua identifica\u00e7\u00e3o visual. Isto \u00e9 especialmente verdadeiro em sistemas mais\n\ncomplexos, com maior n\u00famero de atores se relacionando de maneiras distintas com os\n\ncasos de uso, mas vale mesmo para sistemas mais simples. Nos diagramas de casos de\n\nuso tamb\u00e9m podem ser exibidas outras rela\u00e7\u00f5es entre eles, como relacionamentos ou\n\ngeneraliza\u00e7\u00f5es (analogamente aos relacionamentos entre classes, descritos no cap\u00edtulo\n\nanterior).\n\nNo caso espec\u00edfico do projeto do RiserView, os diagramas de casos de uso\n\nservem a dois prop\u00f3sitos principais:\n\nPrimeiro, classificar os casos de uso de acordo com as fun\u00e7\u00f5es que realizam,\n\ndividindo-os em subgrupos de mais f\u00e1cil compreens\u00e3o e permitindo ver quais s\u00e3o todos\n\nos casos de uso relacionados \u00e0quela fun\u00e7\u00e3o com uma consulta bastante r\u00e1pida ao\n\ndiagrama. Os cinco subgrupos em que os casos de uso est\u00e3o divididos s\u00e3o: Cria\u00e7\u00e3o de\n\nCena, Controle de Exibi\u00e7\u00e3o, Visualiza\u00e7\u00e3o, Anima\u00e7\u00e3o e Navega\u00e7\u00e3o.\n\nO segundo objetivo \u00e9 exibir algumas generaliza\u00e7\u00f5es utilizadas. Para simplificar a\n\ndescri\u00e7\u00e3o dos casos de uso e evitar redund\u00e2ncias, alguns casos de uso que s\u00e3o muito\n\nsemelhantes para elementos diferentes da cena (por exemplo, adicionar riser, modelo,\n\n\n\n113\n\nondas etc.) foram generalizados em um \u00fanico caso, que \u00e9 o que est\u00e1 descrito. Todos os\n\ncasos e estas generaliza\u00e7\u00f5es, no entanto, est\u00e3o listados nos diagramas a seguir.\n\nNa figura 15 est\u00e1 o diagrama dos casos de uso de cria\u00e7\u00e3o de cena. Estes\n\nprimeiros casos de uso permitem ao usu\u00e1rio adicionar elementos \u00e0 cena ou, em\n\ncontrapartida, eliminar todos os seus elementos. Neste diagrama, os casos Adicionar\n\nRiser, Adicionar V\u00f3rtices, Adicionar Ondas, Adicionar Fundo e Adicionar Modelo s\u00e3o\n\nextens\u00f5es do caso Adicionar Objeto. Listas permitem ao usu\u00e1rio adicionar mais de um\n\nobjeto \u00e0 cena com somente uma opera\u00e7\u00e3o.\n\nFigura 15 - Artefato: diagrama de casos de uso para cria\u00e7\u00e3o de cena\n\nOs casos de uso na figura 16 permitem ao usu\u00e1rio escolher quais elementos s\u00e3o\n\nexibidos ou n\u00e3o na cena, bem como ativar ou n\u00e3o algumas caracter\u00edsticas do software\n\n(estereoscopia, anti-aliasing, colis\u00f5es). Mais uma vez a generaliza\u00e7\u00e3o \u00e9 utilizada para\n\nexibir ou n\u00e3o os objetos, exceto no caso dos v\u00f3rtices, que tem um tratamento especial.\n\n\n\n114\n\nFigura 16 - Artefato: diagrama de casos de uso de controle de exibi\u00e7\u00e3o\n\nO diagrama da figura 17 agrupa os casos de uso que permitem ao usu\u00e1rio\n\nmodificar a visualiza\u00e7\u00e3o da cena. Al\u00e9m disso, as op\u00e7\u00f5es escolhidas pelo usu\u00e1rio podem\n\nser salvas em arquivo para serem usadas em outras cenas, posteriormente.\n\nFigura 17 - Artefato: diagrama de casos de uso de visualiza\u00e7\u00e3o\n\n\n\n115\n\nNo diagrama da figura 18 est\u00e3o reunidos os casos de uso que permitem que o\n\nusu\u00e1rio controle a anima\u00e7\u00e3o.\n\nFigura 18 - Artefato: diagrama de casos de uso de anima\u00e7\u00e3o\n\nPor fim, a figura 19 cont\u00e9m os casos de uso que permitem que o usu\u00e1rio navegue\n\npela cena.\n\nFigura 19 - Artefato: diagrama de casos de uso de navega\u00e7\u00e3o\n\n\n\n116\n\n4.3.4. Descri\u00e7\u00e3o dos Casos de Uso\n\nEste artefato \u00e9 possivelmente o mais importante nesta etapa. A captura dos\n\nrequerimentos como casos de uso \u00e9 um dos pontos centrais do Processo Unificado (bem\n\ncomo de muitas outras metodologias). Casos de uso, que j\u00e1 foram discutidos no cap\u00edtulo\n\nanterior, s\u00e3o uma forma relativamente simples de capturar requerimentos funcionais,\n\numa vez que sempre descrevem uma a\u00e7\u00e3o que desempenhe algo de valor para seu ator\n\nou usu\u00e1rio. Num desenvolvimento guiado pelos casos de uso, sempre se est\u00e1\n\nacrescentando funcionalidade ao software. Al\u00e9m disso, a descri\u00e7\u00e3o dos casos de uso se\n\npresta como um \u00f3timo guia para a realiza\u00e7\u00e3o de testes do tipo \"caixa-preta\" (ou seja,\n\ntestes em que se est\u00e1 preocupado somente com a funcionalidade e n\u00e3o se tem\n\nconhecimento da implementa\u00e7\u00e3o), durante a etapa de testes.\n\nNeste trabalho a descri\u00e7\u00e3o dos casos de uso est\u00e1 isolada no Ap\u00eandice A. A\n\ndecis\u00e3o de registrar os casos de uso num Ap\u00eandice n\u00e3o quer dizer que sejam de menor\n\nimport\u00e2ncia, muito pelo contr\u00e1rio. Foi tomada simplesmente porque este artefato \u00e9\n\nrelativamente extenso e inclu\u00ed-lo no corpo deste cap\u00edtulo poderia interferir no fluxo do\n\ntexto e das id\u00e9ias.\n\n\n\n117\n\n4.3.5. Requerimentos Especiais\n\nApesar de sua import\u00e2ncia e utilidade, os casos de uso, pela sua pr\u00f3pria\n\ndefini\u00e7\u00e3o, n\u00e3o s\u00e3o capazes de traduzir todos os requisitos de um sistema. Como sempre\n\ntraduzem uma a\u00e7\u00e3o que realize algo de valor para o usu\u00e1rio, os casos de uso s\u00f3 podem\n\ncapturar os requisitos funcionais do sistema. No entanto, existem outros requisitos que\n\ndevem ser ent\u00e3o registrados em outro artefato, o de requerimentos especiais. A seguir \u00e9\n\nlistado os \u00fanicos requerimentos especiais do RiserView.\n\n4.3.6. Gloss\u00e1rio\n\nEste artefato \u00e9 bastante \u00fatil, n\u00e3o para apresentar uma vista do projeto, mas para\n\npermitir que todos os envolvidos falem a mesma linguagem.\n\nO gloss\u00e1rio utilizado ao longo deste projeto pode ser encontrado no Ap\u00eandice B.\n\nDeve-se ter em mente que, embora muitos dos termos referidos no gloss\u00e1rio possam ser\n\n i. software deve rodar sobre o MS-Windows e o X-Windows, minimamente.\n\n ii. A navega\u00e7\u00e3o pela cena deve ser restrita a permanecer sempre numa vista ou\n\nvertical ou horizontal.\n\n\n\n118\n\nutilizados em outros cap\u00edtulos deste trabalho, o gloss\u00e1rio do Ap\u00eandice B aplica-se a este\n\ncap\u00edtulo, \u00e0 metodologia.\n\n4.3.7. Esbo\u00e7o da Interface\n\nEste \u00faltimo artefato, um esbo\u00e7o da interface com o usu\u00e1rio, tipicamente \u00e9 criado\n\nna etapa de captura de requerimentos. Neste projeto, isto foi feito durante a segunda\n\nitera\u00e7\u00e3o, j\u00e1 que na primeira a interface n\u00e3o era uma preocupa\u00e7\u00e3o.\n\nO uso do IUP, como discutido no cap\u00edtulo anterior, facilitou consideravelmente a\n\nconfec\u00e7\u00e3o deste artefato, uma vez que simplifica a cria\u00e7\u00e3o de um prot\u00f3tipo da interface.\n\nEste prot\u00f3tipo foi feito de forma bastante r\u00e1pida e continha todos os elementos da\n\ninterface, mas sem funcionalidade.\n\nA interface do RiserView \u00e9 bastante simples. Consiste principalmente de uma\n\njanela onde o usu\u00e1rio pode navegar pela cena (para compreens\u00e3o de como \u00e9 feita a\n\nnavega\u00e7\u00e3o, ver a descri\u00e7\u00e3o dos casos de uso relacionados). A barra de ferramentas\n\ncont\u00e9m fun\u00e7\u00f5es \u00fateis durante a visualiza\u00e7\u00e3o da cena, como limpar a cena, controle da\n\nanima\u00e7\u00e3o e da c\u00e2mera. na barra de ferramentas \u00e9 exibido ainda o tempo atual da\n\nsimula\u00e7\u00e3o. Por fim, a interface conta com menus para permitir que o usu\u00e1rio inicie a\n\nmaioria dos casos de uso detalhados anteriormente. A figura 20 mostra o prot\u00f3tipo da\n\ninterface num ambiente MS-Windows. Gra\u00e7as ao IUP o RiserView tem o look-and-feel\n\nde cada ambiente em que \u00e9 executado, por isso esta mesma interface num ambiente\n\nLinux, por exemplo, seria similar mas n\u00e3o id\u00eantica.\n\n\n\n119\n\nFigura 20 - Artefato: esbo\u00e7o da interface\n\nNo manual do usu\u00e1rio, um outro artefato gerado durante a etapa de\n\nimplementa\u00e7\u00e3o, cada um destes bot\u00f5es da barra de tarefas, menus e seus submenus, bem\n\ncomo as caixas de di\u00e1logo utilizadas no programa s\u00e3o exibidos e explicados em detalhe.\n\nEmbora todos estes elementos tenham sido prototipados nesta etapa, esta informa\u00e7\u00e3o\n\nn\u00e3o ser\u00e1 repetida aqui para evitar redund\u00e2ncia no texto.\n\n4.4. Projeto\n\nEsta \u00e9 a etapa em que a arquitetura do projeto \u00e9 definida, desde as APIs a serem\n\nutilizadas at\u00e9 a estrutura de classes detalhada que ser\u00e1 implementada na etapa seguinte.\n\nEsta se\u00e7\u00e3o est\u00e1 organizada de uma forma diferente da anterior. Enquanto na se\u00e7\u00e3o de\n\ncaptura de requerimentos cada artefato era uma subse\u00e7\u00e3o, aqui \u00e9 feita uma divis\u00e3o em\n\nt\u00f3picos relativos \u00e0 arquitetura, organizados do geral para o espec\u00edfico, que quando\n\n\n\n120\n\nanalisados em conjunto devem ser capazes de conferir ao leitor uma vis\u00e3o bastante clara\n\nda arquitetura, da estrutura e do funcionamento do RiserView (embora um\n\nentendimento completo deve necessariamente passar por uma an\u00e1lise mais profunda das\n\nAPIs utilizadas, o IUP e o VTK, cuja exposi\u00e7\u00e3o com maior detalhe que o conferido no\n\ncap\u00edtulo anterior foge ao escopo deste trabalho).\n\nPrimeiramente \u00e9 apresentado um diagrama de subsistemas mostrando como o\n\nsoftware se relaciona com as APIs utilizadas em seu desenvolvimento. Embora o\n\nRiserView em si seja composto por somente um pacote, as APIs nas camadas de\n\nmiddleware e de sistema podem ser consideradas como seus subsistemas.\n\nEm seguida a estrutura de classes \u00e9 mostrada por meio de diagramas com\n\nalgumas simplifica\u00e7\u00f5es importantes: os construtores, destrutores e as fun\u00e7\u00f5es de acesso\n\naos atributos das classes nunca s\u00e3o exibidos nesses diagramas, nem tampouco s\u00e3o\n\nmostrados os m\u00e9todos herdados de uma superclasse, mesmo quando s\u00e3o redefinidos.\n\nPor fim, em muitas classes os atributos que correspondem a elementos da pipeline de\n\nvisualiza\u00e7\u00e3o do VTK s\u00e3o omitidos. Todas essas simplifica\u00e7\u00f5es visam facilitar a\n\nvisualiza\u00e7\u00e3o dos diagramas, privilegiando a compreens\u00e3o da arquitetura do aplicativo e\n\nn\u00e3o seus detalhes (que podem ser melhor analisados no c\u00f3digo fonte).\n\nO primeiro diagrama de classes, mais simples, mostra como o padr\u00e3o Model-\n\nView-Controller (MVC, discutido no cap\u00edtulo anterior) est\u00e1 implementado no\n\nRiserView. A classe de controle, embora seja bastante extensa, com um grande n\u00famero\n\nde m\u00e9todos, \u00e9 tamb\u00e9m bastante simples. A grande maioria desses m\u00e9todos trata das\n\nopera\u00e7\u00f5es com menus e outros elementos da interface, chamando m\u00e9todos adequados\n\ndo modelo ou da vista ou simplesmente atribuindo um valor a uma vari\u00e1vel de estado do\n\n\n\n121\n\nsistema. Por isso, o controle \u00e9 retratado de forma simplificada, visto que nestes\n\ndiagramas n\u00e3o se deseja passar este n\u00edvel de detalhe.\n\nOs pr\u00f3ximos diagramas de classes mostram o Modelo em mais detalhe. O \u00faltimo\n\ndiagrama de classes detalha a estrutura utilizada para armazenar dados utilizados\n\ndurante a detec\u00e7\u00e3o de colis\u00e3o entre risers.\n\nAntes da discuss\u00e3o sobre detec\u00e7\u00e3o de colis\u00e3o, no entanto, o la\u00e7o principal do\n\nprograma \u00e9 detalhado por meio de dois diagramas. O diagrama de atividades \u00e9 um\n\nsimples fluxograma ilustrando este la\u00e7o de forma simplificada. O diagrama de\n\nseq\u00fc\u00eancia \u00e9 um diagrama um pouco mais complexo, mostrando os objetos e mensagens\n\nenvolvidos durante a atualiza\u00e7\u00e3o da cena. Este diagrama de seq\u00fc\u00eancia tamb\u00e9m auxilia\n\nna compreens\u00e3o de como o padr\u00e3o MVC \u00e9 implementado, mostrando as mensagens\n\ntrocadas entre o modelo, a vista, o controle e os objetos que o comp\u00f5em durante a\n\natualiza\u00e7\u00e3o da cena.\n\nEm conjunto, estes diagramas mostram praticamente a totalidade das classes\n\ndesenvolvidas, com exce\u00e7\u00e3o de algumas classes auxiliares de menor import\u00e2ncia.\n\nJuntamente com os coment\u00e1rios que os acompanham, \u00e9 poss\u00edvel compreender com\n\nclareza a estrutura e o funcionamento do RiserView. Poderiam ser criados diversos\n\noutros diagramas, por exemplo diagramas de atividades e seq\u00fc\u00eancia para cada um dos\n\ncasos de uso. No entanto, da mesma forma que nos diagramas de classe as fun\u00e7\u00f5es mais\n\nsimples do controle, relativas somente \u00e0 interface, foram suprimidas por serem detalhes\n\nde menor import\u00e2ncia, acredita-se que estes diagramas tamb\u00e9m n\u00e3o contribuiriam\n\nconsideravelmente para um melhor entendimento do RiserView. A maioria dessas\n\nopera\u00e7\u00f5es \u00e9 bastante simples e os casos de uso j\u00e1 est\u00e3o detalhados suficientemente. Para\n\n\n\n122\n\nverificar detalhes da implementa\u00e7\u00e3o, uma vez que a estrutura do programa tenha sido\n\nassimilada, pode-se recorrer \u00e0s suas fontes comentadas.\n\n4.4.1. As APIs\n\nConforme discutido no cap\u00edtulo anterior, a utiliza\u00e7\u00e3o de APIs adequadas no\n\ndesenvolvimento do RiserView foi uma decis\u00e3o tomada desde o in\u00edcio do projeto. Estas\n\nAPIs t\u00eam uma dupla fun\u00e7\u00e3o neste projeto: reduzir a preocupa\u00e7\u00e3o com quest\u00f5es relativas\n\n\u00e0s plataformas sobre as quais o programa deveria rodar bem como evitar a necessidade\n\nda implementa\u00e7\u00e3o de fun\u00e7\u00f5es gr\u00e1ficas de baixo n\u00edvel, permitindo que se concentre a\n\naten\u00e7\u00e3o no desenvolvimento da aplica\u00e7\u00e3o em quest\u00e3o e nos conceitos de mais alto n\u00edvel\n\nenvolvidos no seu desenvolvimento, como a visualiza\u00e7\u00e3o cient\u00edfica e a metodologia de\n\nprojeto. Naquele cap\u00edtulo discute-se as principais caracter\u00edsticas do VTK e do IUP,\n\nlevadas em conta durante sua sele\u00e7\u00e3o.\n\nEssa sele\u00e7\u00e3o baseou-se em diversos fatores, como disponibilidade, quantidade de\n\nrecursos dispon\u00edvel, freq\u00fc\u00eancia de atualiza\u00e7\u00e3o da biblioteca, orienta\u00e7\u00e3o a objetos,\n\nefici\u00eancia (por exemplo se a API utilizava uma linguagem interpretada ou n\u00e3o),\n\nsimplicidade de uso e qualidade da documenta\u00e7\u00e3o dispon\u00edvel. Este \u00faltimo quesito \u00e9\n\nbastante importante, pois pouco auxilia uma biblioteca com um sem n\u00famero de recursos\n\nmas nenhuma indica\u00e7\u00e3o de como utiliz\u00e1-los.\n\nA figura 21 mostra o diagrama de subsistemas do RiserView, mostrando estas\n\nAPIs como subsistemas do programa e indicando as rela\u00e7\u00f5es de depend\u00eancia entre esses\n\n\n\n123\n\nsubsistemas. Este diagrama ilustra tamb\u00e9m como um dos padr\u00f5es de arquitetura\n\ndiscutidos no cap\u00edtulo 2, o padr\u00e3o de camadas, est\u00e1 impl\u00edcito na arquitetura do sistema\n\ndevido ao uso destas APIs. Este padr\u00e3o organiza os componentes de um sistema em\n\ncamadas, de forma que cada componente s\u00f3 pode acessar outros componentes na\n\ncamada diretamente abaixo da sua.\n\nFigura 21 - Artefato: diagrama de subsistemas\n\n4.4.2. O Padr\u00e3o Model-View-Controller\n\nEste padr\u00e3o \u00e9 utilizado neste projeto para separar os dados e opera\u00e7\u00f5es do\n\nModelo de preocupa\u00e7\u00f5es com a interface. Recordando o que foi dito quanto ao MVC no\n\ncap\u00edtulo 2, sua fun\u00e7\u00e3o \u00e9 justamente separar dados intr\u00ednsecos ao problema que o\n\nsoftware se disp\u00f5e a solucionar de dados necess\u00e1rios para a visualiza\u00e7\u00e3o ou interface. O\n\nModelo (Model) \u00e9 uma classe que cont\u00e9m estes dados intr\u00ednsecos \u00e0 aplica\u00e7\u00e3o, \u00e9 uma\n\nabstra\u00e7\u00e3o de uma entidade relacionada a um dom\u00ednio (uma entidade f\u00edsica, ou gr\u00e1fica,\n\nou matem\u00e1tica...) que n\u00e3o tem nenhum conhecimento da interface. Vistas (Views) s\u00e3o as\n\n\n\n124\n\nrepresenta\u00e7\u00f5es do Modelo na interface. Cada Vista \u00e9 gerenciada por um Controlador\n\n(Controller) que \u00e9 respons\u00e1vel pelas a\u00e7\u00f5es definidas na Vista com Rela\u00e7\u00e3o ao modelo.\n\nO controlador \u00e9 que \"traduz\" mensagens de interface para a l\u00f3gica da aplica\u00e7\u00e3o. Sempre\n\nque o modelo \u00e9 modificado (seja por uma a\u00e7\u00e3o do usu\u00e1rio, seja por outro motivo\n\nqualquer) as Vistas e Controladores devem ser notificados para se atualizarem. O\n\nencapsulamento de informa\u00e7\u00f5es relativas \u00e0 interface nas Vistas e seu gerenciamento\n\npelos Controladores leva a um c\u00f3digo mais limpo e elegante do Modelo, que \u00e9 a base do\n\nsoftware e s\u00f3 precisa tratar do seu dom\u00ednio.\n\nNo RiserView, o Modelo representa a cena e seus elementos, est\u00e1ticos ou\n\ndin\u00e2micos: risers, o fundo do oceano, sua superf\u00edcie, representa\u00e7\u00f5es de v\u00f3rtices, corpos\n\nr\u00edgidos modelando objetos como navios, plataformas, \"\u00e1rvores de natal\" etc. O\n\nprograma conta com uma \u00fanica Vista, uma renderiza\u00e7\u00e3o desta cena em tr\u00eas dimens\u00f5es\n\nque permite que o usu\u00e1rio navegue por ela.\n\nA figura 22 ilustra, atrav\u00e9s de um diagrama de classes, como este padr\u00e3o est\u00e1\n\nimplementado no RiserView, quais classes correspondem ao Modelo, \u00e0 Vista e ao\n\nControle e como estas classes se relacionam. A classe com o mesmo nome da aplica\u00e7\u00e3o\n\nserve como um container para as classes de Modelo, Vista e Controle.\n\nConforme foi dito, a classe de modelo \u00e9 bastante complexa e ser\u00e1 detalhada nos\n\npr\u00f3ximos diagramas e a classe de controle, apesar de bastante extensa por tratar de todas\n\nas diversas mensagens de usu\u00e1rios, sua intera\u00e7\u00e3o com menus, janelas etc., \u00e9\n\nrazoavelmente simples e seu detalhamento n\u00e3o \u00e9 de vital import\u00e2ncia para a\n\ncompreens\u00e3o da arquitetura. Por isso estas duas classes aparecem de maneira\n\nsimplificada neste diagrama.\n\n\n\n125\n\nA notifica\u00e7\u00e3o da Vista sobre as mudan\u00e7as feitas no Modelo \u00e9 feita atrav\u00e9s da\n\npipeline de visualiza\u00e7\u00e3o do VTK, discutida no cap\u00edtulo 2. Da mesma forma, as a\u00e7\u00f5es do\n\nusu\u00e1rio passam da Vista para o Controle atrav\u00e9s das fun\u00e7\u00f5es de callback do IUP\n\n(fun\u00e7\u00f5es globais associadas a elementos da Vista que por sua vez chamam fun\u00e7\u00f5es do\n\nControle).\n\nFigura 22 - Artefato: diagrama de classes do MVC\n\n4.4.3. O Modelo\n\nComo j\u00e1 foi dito, o Modelo representa a cena e seus elementos. Nele\n\nest\u00e3o armazenadas as estruturas de dados que descrevem a geometria e a din\u00e2mica de\n\ncada um destes elementos que comp\u00f5em a cena. Devido \u00e0 complexidade dessa classe e\n\ndessas estruturas, elas est\u00e3o representadas em dois diagramas complementares. O\n\n\n\n126\n\ndiagrama da figura 23 mostra principalmente as agrega\u00e7\u00f5es que comp\u00f5em o modelo. J\u00e1\n\nna figura 24 s\u00e3o representadas principalmente as generaliza\u00e7\u00f5es utilizadas.\n\nOs elementos de cena representados nos diagramas 23 e 24, bem como as classes\n\nutilizadas em sua implementa\u00e7\u00e3o, s\u00e3o:\n\n\u2022 Risers: os principais objetos da visualiza\u00e7\u00e3o s\u00e3o implementados atrav\u00e9s da classe\n\nRiser, que se especializa em duas outras classes, RiserFreq e RiserTime, para\n\nimplementar risers cuja din\u00e2mica \u00e9 descrita seja no dom\u00ednio da freq\u00fc\u00eancia ou no do\n\ntempo. Como a cena pode conter diversos risers, a classe RiserCol agrupa estes\n\nobjetos. Por fim, a classe RiserFactory \u00e9 a respons\u00e1vel pela cria\u00e7\u00e3o ora de um\n\nobjeto do tipo RiserFreq ora do tipo RiserTime. Este padr\u00e3o, onde uma classe\n\ndistinta \u00e9 respons\u00e1vel pela cria\u00e7\u00e3o de objetos que podem ser de classes diferentes,\n\nfoi discutido no cap\u00edtulo anterior e \u00e9 conhecido como \"F\u00e1brica de Objetos\". A classe\n\nRiserCol \u00e9 ainda respons\u00e1vel por gerenciar a detec\u00e7\u00e3o de colis\u00e3o, que ser\u00e1 discutida\n\nmais adiante.\n\n\u2022 Representa\u00e7\u00f5es de V\u00f3rtices: no RiserView as esteiras de v\u00f3rtices que se formam a\n\njusante dos risers podem ser representadas como conjuntos de v\u00f3rtices discretos ou\n\ncomo campos de grandezas escalares, como press\u00e3o, m\u00f3dulo da velocidade ou\n\nvorticidade. Ambas estas representa\u00e7\u00f5es s\u00e3o planas, mas podem ser mostradas em\n\ndiversos planos em diferentes alturas do riser para ilustrar o fen\u00f4meno\n\ntridimensional. A classe RVVortex cont\u00e9m os dados referentes a essas\n\nrepresenta\u00e7\u00f5es.\n\n\n\n127\n\nFigura 23 - Artefato: diagrama de classes do modelo (agrega\u00e7\u00f5es)\n\nFigura 24 - Artefato: diagrama de classes do modelo (generaliza\u00e7\u00f5es)\n\n\n\n128\n\n\u2022 Superf\u00edcie do Oceano: a din\u00e2mica da superf\u00edcie pode ser representada neste\n\nprograma atrav\u00e9s da classe RVWaves.\n\n\u2022 Solo Oce\u00e2nico: O relevo do solo tamb\u00e9m pode ser representado, de maneira est\u00e1tica,\n\nno RiserView. A classe que armazena essa geometria \u00e9 a RVBottom.\n\n\u2022 Corpos R\u00edgidos: Diversos corpos r\u00edgidos podem compor a cena e podem inclusive\n\npossuir din\u00e2mica pr\u00f3pria. Atualmente, estes corpos s\u00e3o importados como modelos\n\ndo 3D Studio, com um arquivo auxiliar separado que descreve sua din\u00e2mica. A\n\nclasse RV3DSModel armazena os dados de geometria e din\u00e2mica desses corpos.\n\nAssim como no caso dos risers, uma classe agrupa todos os elementos deste tipo\n\nque podem fazer parte da cena. Esta classe \u00e9 a RV3DSModels.\n\nOutro aspecto ao qual se deve atentar nesses diagramas \u00e9 o uso da generaliza\u00e7\u00e3o\n\nno caso dos elementos da cena e das cole\u00e7\u00f5es de elementos, que derivam,\n\nrespectivamente, das classes RVObject e RVObjectList.\n\n4.4.4. O La\u00e7o Principal\n\nNo cap\u00edtulo 2 discutiu-se que anima\u00e7\u00f5es que podem ser manipuladas\n\ndinamicamente exigem um tratamento especial no que se refere ao la\u00e7o principal do\n\nprograma. Tipicamente em aplica\u00e7\u00f5es que seguem o paradigma de janelas e ponteiros,\n\neste la\u00e7o se inicia com o in\u00edcio da aplica\u00e7\u00e3o e roda at\u00e9 que ela se encerre, aguardando\n\npor entradas do usu\u00e1rio, capturando, interpretando e traduzindo estas mensagens em\n\na\u00e7\u00f5es do programa.\n\n\n\n129\n\nFigura 25 - Artefato: diagrama de atividades do la\u00e7o principal\n\nDurante uma anima\u00e7\u00e3o, no entanto, \u00e9 necess\u00e1rio que exista um outro la\u00e7o que\n\ntamb\u00e9m \u00e9 executado ao longo de toda a dura\u00e7\u00e3o da anima\u00e7\u00e3o, atualizando a posi\u00e7\u00e3o de\n\nseus objetos em cada instante de tempo.\n\nO modo como estes dois la\u00e7os coexistem no RiserView \u00e9 ilustrado na figura 25\n\natrav\u00e9s de um diagrama de atividades, ou um fluxograma.\n\n\n\n130\n\nDeve-se notar, neste diagrama, que a prioridade \u00e9 dada a anima\u00e7\u00e3o, e n\u00e3o ao\n\ntratamento das mensagens do programa. Primeiramente, quando a anima\u00e7\u00e3o est\u00e1\n\nativada, a cena \u00e9 atualizada e renderizada e s\u00f3 ent\u00e3o, no tempo que sobra, as mensagens\n\ns\u00e3o tratadas. Esta anima\u00e7\u00e3o ocorre em tempo real, ou seja, o tempo do Modelo avan\u00e7a\n\nno mesmo ritmo que o tempo real, a n\u00e3o ser que a atualiza\u00e7\u00e3o da cena n\u00e3o consiga ser\n\nfeita no per\u00edodo de tempo entre dois quadros da anima\u00e7\u00e3o. Nesse caso, a anima\u00e7\u00e3o\n\nocorre com atraso.\n\nO diagrama da figura 26 ilustra, atrav\u00e9s de um diagrama de seq\u00fc\u00eancia, um passo\n\ndeste la\u00e7o, mostrando como as mensagens de atualiza\u00e7\u00e3o se propagam entre o Controle,\n\na Vista e o Modelo, bem como os elementos que o comp\u00f5em, de acordo com o padr\u00e3o\n\nMVC. Cada elemento, ao ser modificado, cuida de se marcar como tal, para que a Vista,\n\nao renderizar a cena, saiba quais partes da pipeline de visualiza\u00e7\u00e3o devem ser re-\n\nexecutadas. A fun\u00e7\u00e3o IupLoopStep \u00e9 a que trata a pr\u00f3xima mensagem na fila. Deve-se\n\nnotar que ap\u00f3s este passo, \u00e9 preciso renderizar a cena novamente.\n\nNo diagrama de seq\u00fc\u00eancia, os objetos envolvidos numa opera\u00e7\u00e3o s\u00e3o\n\nrepresentados como os ret\u00e2ngulos no topo do diagrama, com os nomes e tipos do objeto,\n\norganizados da esquerda para a direita em ordem de subordina\u00e7\u00e3o. As mensagens\n\ntrocadas entre estes objetos s\u00e3o representadas pelas setas entre eles. As mensagens s\u00e3o\n\norganizadas de cima para baixo em ordem cronol\u00f3gica. A seta tracejada representa um\n\nretorno de fun\u00e7\u00e3o. As linhas tracejadas verticais s\u00e3o chamadas de lifelines e representam\n\na exist\u00eancia do objeto (por exemplo, se uma mensagem de destrui\u00e7\u00e3o fosse mandada\n\npara um objeto, a linha tracejada seria interrompida naquele ponto) e os ret\u00e2ngulos finos\n\n\n\n131\n\nverticais representam per\u00edodos em que os objetos est\u00e3o ativos realizando atividades\n\nrelacionadas com a opera\u00e7\u00e3o que o diagrama ilustra.\n\nFigura 26 - Artefato: diagrama de seq\u00fc\u00eancia do la\u00e7o principal\n\n\n\n132\n\nEm particular no diagrama mostrado na figura 26, todas as mensagens s\u00e3o do\n\ntipo s\u00edncrono, ou seja, chamadas de fun\u00e7\u00f5es.\n\n4.4.5. Detec\u00e7\u00e3o de Colis\u00e3o\n\nA detec\u00e7\u00e3o de colis\u00f5es entre risers, nesse aplicativo, na verdade \u00e9 feita entre os\n\nsegmentos que comp\u00f5em os risers, e nunca entre segmentos do mesmo riser. No\n\ncap\u00edtulo 2 s\u00e3o citadas algumas caracter\u00edsticas particulares que simplificam problema de\n\ndetec\u00e7\u00e3o de colis\u00f5es no RiserView. Uma delas \u00e9 a de que o comportamento de cada\n\nriser j\u00e1 \u00e9 conhecido antes da anima\u00e7\u00e3o.\n\nO modo como esta caracter\u00edstica simplifica o problema \u00e9 o seguinte: como a\n\namplitude m\u00e1xima dos deslocamentos de cada segmento j\u00e1 \u00e9 conhecida, essa amplitude\n\npode ser usada para criar uma envolt\u00f3ria ao redor dos segmentos (e do riser) que pode\n\nser usada com um volume limitante para uma primeira aproxima\u00e7\u00e3o da detec\u00e7\u00e3o de\n\ncolis\u00f5es. Dessa forma, \u00e9 poss\u00edvel, atrav\u00e9s de um pr\u00e9-processamento realizado no\n\nmomento em que cada riser \u00e9 adicionado \u00e0 cena, determinar, para cada segmento do\n\nnovo riser, com quais segmentos dos risers j\u00e1 presentes na cena existe a possibilidade\n\nde haver colis\u00e3o. Esse pr\u00e9-processamento utiliza o mesmo algoritmo para detec\u00e7\u00e3o de\n\ncolis\u00e3o entre c\u00e1psulas usado para determinar a colis\u00e3o exata entre os risers, basta somar\n\nao raio de cada segmento a amplitude de seu movimento. Sua envolt\u00f3ria tem tamb\u00e9m o\n\nformato de uma c\u00e1psula. Para cada riser, os resultados do pr\u00e9-processamento s\u00e3o\n\narmazenados na estrutura de dados mostrada na figura 27.\n\n\n\n133\n\nFigura 27 - Artefato: diagrama de classes dos pares de colis\u00e3o\n\nA figura mostra como cada riser armazena uma lista de com quais outros risers\n\nele pode colidir atrav\u00e9s de uma inst\u00e2ncia da classe RiserCollisions. Essa classe \u00e9 uma\n\nagrega\u00e7\u00e3o de objetos SegmentCollision que, al\u00e9m de guardar o \u00edndice do riser com o\n\nqual a colis\u00e3o ocorre, guardam uma lista dos pares de segmentos que podem colidir (os\n\npares de colis\u00e3o), representados por objetos da classe CollisionPair.\n\nDessa forma, em cada passo da anima\u00e7\u00e3o, somente esses pares de colis\u00e3o (para\n\nos quais existe alguma possibilidade de colis\u00e3o de acordo com o pr\u00e9-processamento)\n\nprecisam ser checados. Essa checagem \u00e9 feita utilizando o algoritmo descrito por Eberly\n\n(2000a) e abordado em 2.8. A classe que gerencia essas checagens de colis\u00e3o entre os\n\nrisers \u00e9 a classe RiserCol atrav\u00e9s da fun\u00e7\u00e3o CheckCollisions.\n\n\n\n134\n\n4.5. Implementa\u00e7\u00e3o e Testes\n\nAs fontes comentadas e o execut\u00e1vel do aplicativo, bem como um manual do\n\nusu\u00e1rio em HTML, encontram-se no CD anexo a este trabalho. Estes tr\u00eas s\u00e3o os\n\nprincipais artefatos gerados durante a etapa de implementa\u00e7\u00e3o\n\nJ\u00e1 na etapa de testes foram realizados testes para verificar cada um dos casos de\n\nuso e dos requerimentos especiais do projeto, assim como testes de stress com grandes\n\nn\u00fameros de pol\u00edgonos para verificar o comportamento do programa. Os arquivos\n\nutilizados nestes testes tamb\u00e9m est\u00e3o no CD anexo e s\u00e3o os \u00fanicos artefatos gerados\n\nnesta etapa. Os resultados dos testes ser\u00e3o discutidos no cap\u00edtulo seguinte. Uma lista de\n\ndefeitos (ou bugs) encontrados tamb\u00e9m \u00e9 gerada e utilizada durante o procedimento dos\n\ntestes, mas estes defeitos v\u00e3o sendo corrigidos a medida que s\u00e3o encontrados portanto\n\nesta lista \u00e9 um artefato de cunho tempor\u00e1rio, que embora tenha sido utilizado n\u00e3o fica\n\nregistrado neste trabalho.\n\nCom esta se\u00e7\u00e3o encerra-se o cap\u00edtulo de metodologia. Acredita-se que n\u00e3o s\u00f3 foi\n\nposs\u00edvel demonstrar como o Processo Unificado foi aplicado como metodologia deste\n\nprojeto, mas tamb\u00e9m que o conjunto de artefatos gerados durante este processo\n\n(gloss\u00e1rio; descri\u00e7\u00e3o dos requerimentos, atores e casos de uso; listagem dos\n\nrequerimentos especiais; esbo\u00e7o da interface; diagramas de casos de uso, subsistemas,\n\nclasses, atividades e seq\u00fc\u00eancia; fontes comentadas; programa execut\u00e1vel; manual do\n\nusu\u00e1rio e conjunto de arquivos de teste) contribuam para uma compreens\u00e3o facilitada do\n\nRiserView bem como constituam uma documenta\u00e7\u00e3o completa do projeto. No pr\u00f3ximo\n\ncap\u00edtulo s\u00e3o discutidos os resultados obtidos nos testes do programa.\n\n\n\n135\n\n5. RESULTADOS\n\nNeste cap\u00edtulo s\u00e3o apresentados, principalmente, os resultados dos testes\n\nrealizados sobre o RiserView. Uma discuss\u00e3o mais aprofundada desses resultados e de\n\neventuais solu\u00e7\u00f5es para os problemas encontrados ser\u00e1 feita somente no cap\u00edtulo 6. No\n\nentanto, onde for necess\u00e1rio, ser\u00e3o discutidos aqui alguns pontos para justificar a forma\n\ncomo os testes foram feitos.\n\nTodos os testes foram realizados num sistema com a seguinte configura\u00e7\u00e3o:\n\n\u2022 Processador Pentium 4 de 1,7GHz\n\n\u2022 Mem\u00f3ria RAM de 512MB\n\n\u2022 Placa Gr\u00e1fica GeForce FX 5200 com 128MB de mem\u00f3ria\n\n\u2022 Capacidade Nominal de Processamento de 6?107 v\u00e9rtices/segundo\n\n\u2022 AGP-8X (a placa m\u00e3e, no entanto, \u00e9 somente AGP-4X)\n\n\u2022 Driver vers\u00e3o 61.77\n\n\u2022 Sistema Operacional: Windows XP Pro Vers\u00e3o 2002 com o Service Pack 2\n\n\n\n136\n\nAl\u00e9m disso, durante os testes o RiserView era o \u00fanico aplicativo (exceto pelos\n\nprocessos do sistema operacional) sendo executado no sistema, que estava desconectado\n\nde qualquer tipo de rede e com antiv\u00edrus e  firewall desativados.\n\nEste cap\u00edtulo est\u00e1 estruturado da seguinte forma: Em primeiro lugar s\u00e3o\n\ndiscutidos brevemente os testes de \"caixa-preta\". A pr\u00f3xima se\u00e7\u00e3o relata como foram\n\nrealizados os testes de stress do aplicativo e os resultados obtidos. Em seguida o sistema\n\nde detec\u00e7\u00e3o de colis\u00f5es entre risers \u00e9 analisado. Por fim, a portabilidade do c\u00f3digo para\n\no Linux \u00e9 discutida.\n\nTestes de usabilidade16 para verificar a adequa\u00e7\u00e3o da interface n\u00e3o foram\n\nrealizados de maneira formal, por isso n\u00e3o s\u00e3o relatados aqui. Ainda assim, atrav\u00e9s da\n\nutiliza\u00e7\u00e3o do aplicativo por diferentes usu\u00e1rios p\u00f4de-se chegar a algumas conclus\u00f5es\n\ninteressantes quanto a esse aspecto, que ser\u00e3o discutidas no pr\u00f3ximo cap\u00edtulo.\n\n5.1. Testes de Caixa-Preta\n\nDurante esses testes, o objetivo \u00e9 verificar se a funcionalidade do aplicativo\n\nequivale \u00e0 sua especifica\u00e7\u00e3o, sem uma preocupa\u00e7\u00e3o com a implementa\u00e7\u00e3o do software.\n\nComo discutido no cap\u00edtulo anterior, os casos de uso obtidos para o RiserView s\u00e3o\n\nutilizados como guia para esses testes. Cada caso de uso, bem como cada varia\u00e7\u00e3o de\n\n                                                \n\n16 A efetividade, efici\u00eancia e satisfa\u00e7\u00e3o com a qual os usu\u00e1rios podem realizar tarefas em um\nsistema. Alta usabilidade significa que o sistema \u00e9: simples de se usar e aprender, eficiente,\nvisualmente agrad\u00e1vel e r\u00e1pido ao se recuperar de erros. (fonte: Free Online Dictionary of\nComputing).\n\n\n\n137\n\num caso, \u00e9 reproduzido utilizando o aplicativo e desvios em rela\u00e7\u00e3o \u00e0 especifica\u00e7\u00e3o s\u00e3o\n\nregistrados.\n\nEsses testes foram realizados ao longo de todo o desenvolvimento. Muitos dos\n\nerros identificados foram corrigidos nesse processo, mas a identifica\u00e7\u00e3o e corre\u00e7\u00e3o\n\ndesses erros n\u00e3o foi registrada. O que est\u00e1 registrado neste trabalho s\u00e3o os bugs que\n\npermaneceram na vers\u00e3o  do aplicativo entregue como anexo.\n\nA lista de bugs resultante, com as explica\u00e7\u00f5es necess\u00e1rias para cada um, bem\n\ncomo uma lista de melhorias simples para a interface sugeridas por usu\u00e1rios do\n\nRiserView, est\u00e1 registrada no Ap\u00eandice C, meramente para preservar a continuidade do\n\ntexto deste cap\u00edtulo.\n\n5.2. Testes de Stress\n\nO objetivo deste conjunto de testes \u00e9 determinar quais os limites do aplicativo.\n\nPara tanto, por\u00e9m, \u00e9 necess\u00e1rio separar e identificar que partes do sistema est\u00e3o\n\nsubmetidas ao esfor\u00e7o imposto pelos testes, n\u00e3o s\u00f3 para conhecer os reais limites do\n\naplicativo como tamb\u00e9m para permitir conclus\u00f5es mais precisas sobre esses limites.\n\nTr\u00eas fatores, em particular, foram identificados antes da realiza\u00e7\u00e3o dos testes\n\ncomo poss\u00edveis limitantes no aplicativo:\n\n i. Capacidade de processamento: com isso deseja-se especificar o uso do processador\n\nprincipal do sistema, e n\u00e3o o processador gr\u00e1fico (que \u00e9 tratado como um fator\n\n\n\n138\n\ndistinto). Apesar do RiserView n\u00e3o realizar nenhuma forma de simula\u00e7\u00e3o ou\n\nan\u00e1lise f\u00edsica, uma vez que a din\u00e2mica de todos os elementos da cena \u00e9 pr\u00e9-\n\ncalculada por outros aplicativos, algumas das tarefas que realiza s\u00e3o custosas em\n\ntermo de processamento. A principal destas tarefas \u00e9 a determina\u00e7\u00e3o, em cada\n\npasso da anima\u00e7\u00e3o, da posi\u00e7\u00e3o e do comprimento de cada um dos segmentos\n\ncil\u00edndricos que comp\u00f5em os risers, com base nas posi\u00e7\u00f5es de suas extremidades.\n\nAs coordenadas das extremidades devem ser convertidas em dois \u00e2ngulos que\n\nser\u00e3o usados para rotacionar o segmento e a dist\u00e2ncia entre elas passa a ser seu\n\ncomprimento. \u00c9 necess\u00e1rio recalcular o comprimento uma vez que o aplicativo se\n\nutiliza da t\u00e9cnica de deforma\u00e7\u00e3o da estrutura ao amplificar os movimentos dos\n\nrisers para permitir sua visualiza\u00e7\u00e3o. Outra tarefa, ainda mais custosa (mas n\u00e3o t\u00e3o\n\nnecess\u00e1ria), \u00e9 o anti-aliasing da cena feito por software. A detec\u00e7\u00e3o de colis\u00f5es\n\nentre risers \u00e9 uma terceira tarefa com custo para o processador, mas ser\u00e1 discutida\n\nseparadamente na pr\u00f3xima se\u00e7\u00e3o.\n\n ii. Mem\u00f3ria: inicialmente havia a preocupa\u00e7\u00e3o de que a mem\u00f3ria consumida pelas\n\nestruturas de dados relativamente complexas utilizadas pelo VTK e pela\n\narquitetura do RiserView pudesse tamb\u00e9m ser um limitante de sua performance.\n\nAinda que atualmente se possa contar com uma quantidade relativamente alta de\n\nmem\u00f3ria virtual, o acesso a essa mem\u00f3ria \u00e9 muito mais lento e poderia\n\nimpossibilitar a renderiza\u00e7\u00e3o de cenas em tempo real. Durante a realiza\u00e7\u00e3o de\n\ntodos os testes, no entanto, pode-se constatar que muito antes de o aplicativo\n\nocupar uma parcela significativa da mem\u00f3ria dispon\u00edvel, ora o processamento, ora\n\n\n\n139\n\no processamento gr\u00e1fico alcan\u00e7avam seu limite. Sendo assim, n\u00e3o foram realizados\n\nmais testes espec\u00edficos para analisar o consumo de mem\u00f3ria do RiserView.\n\n iii. Processamento Gr\u00e1fico: a preocupa\u00e7\u00e3o ao tratar desse fator \u00e9 diferenciar que parte\n\ndo processamento \u00e9 realizada pela placa gr\u00e1fica e que parte \u00e9 realizada pela CPU.\n\nA solu\u00e7\u00e3o encontrada foi a renderiza\u00e7\u00e3o de uma cena bastante complexa (com uma\n\nquantidade de pol\u00edgonos pr\u00f3xima do limite do sistema gr\u00e1fico utilizado) mas que\n\nfosse resultado de poucos c\u00e1lculos ou outras formas de manipula\u00e7\u00e3o de dados pelo\n\nprocessador principal. Esse cuidado ainda n\u00e3o permite, no entanto, determinar que\n\nparte do sistema gr\u00e1fico atingiu seu limite. Para determinar, por exemplo, se o\n\nlimitante durante os testes foi a comunica\u00e7\u00e3o de dados para a placa gr\u00e1fica ou o\n\nprocessamento desses dados foi necess\u00e1ria uma an\u00e1lise mais complexa.\n\nTendo isso em mente, ser\u00e3o discutidos com mais detalhe os testes de stress tanto\n\npara a capacidade de processamento como para o processamento gr\u00e1fico.\n\n5.2.1. Capacidade de Processamento\n\nPara testar a capacidade de processamento, foi decido utilizar cenas compostas\n\npor n\u00fameros cada vez maiores de risers com sua din\u00e2mica descrita no dom\u00ednio da\n\nfreq\u00fc\u00eancia. Isso porque cenas com um n\u00famero de pol\u00edgonos relativamente baixo\n\nformadas somente por esses risers s\u00e3o consideravelmente pesadas em termos de\n\nprocessamento. Para cada segmento, em cada passo de tempo, \u00e9 preciso realizar as\n\nseguintes opera\u00e7\u00f5es:\n\n\n\n140\n\n\u2022 Calcular a posi\u00e7\u00e3o atual das extremidades (atualmente envolve o c\u00e1lculo de 6\n\ncosenos).\n\n\u2022 Calcular a dist\u00e2ncia entre essas extremidades (envolve uma raiz quadrada) e\n\nmodificar o comprimento do segmento para que se torne igual a essa dist\u00e2ncia.\n\n\u2022 Calcular os dois \u00e2ngulos necess\u00e1rios para rotacionar o segmento (envolve o c\u00e1lculo\n\nde dois arco-senos, um coseno e uma checagem para corrigir o quadrante dos\n\n\u00e2ngulos).\n\n\u2022 Transladar e Rotacionar o segmento.\n\nSomente o \u00faltimo item \u00e9 responsabilidade do processador gr\u00e1fico. E os c\u00e1lculos\n\nde cosenos, arco-senos e ra\u00edzes quadradas s\u00e3o feitos utilizando as fun\u00e7\u00f5es da biblioteca\n\npadr\u00e3o de matem\u00e1tica do C, que utiliza m\u00e9todos iterativos para obter esses valores com\n\nalta precis\u00e3o.\n\nPor isso esses risers foram considerados os mais adequados para testar a\n\ncapacidade de processamento. Foram gerados (automaticamente atrav\u00e9s de um\n\nprograma que translada e rotaciona um riser original) 144 arquivos de risers descritos\n\nno dom\u00ednio da freq\u00fc\u00eancia, cada um com somente 11 segmentos. Para diferentes valores\n\nde passo de tempo da anima\u00e7\u00e3o e de n\u00famero de pol\u00edgonos na cena (que podia variar\n\nconforme a discretiza\u00e7\u00e3o dos segmentos cil\u00edndricos), esses risers foram sendo\n\nacrescentados \u00e0 cena at\u00e9 que o RiserView n\u00e3o fosse mais capaz de calcular e renderizar\n\nos  risers em tempo real, no passo de tempo pedido. O aplicativo fornece uma indica\u00e7\u00e3o\n\nvisual quando n\u00e3o pode renderizar a cena em tempo real - o mostrador de tempo na\n\n\n\n141\n\nbarra de ferramentas passa de azul para vermelho. Durante esses testes, anti-aliasing,\n\nestereoscopia e detec\u00e7\u00e3o de colis\u00f5es estavam desativados.\n\nPara um passo de tempo de 50ms, no sistema utilizado para os testes, foi\n\nposs\u00edvel atualizar e renderizar em tempo real somente 36 risers de 11 segmentos cada.\n\nIsso equivale a calcular quase 8 mil segmentos por segundo, com todas as opera\u00e7\u00f5es\n\nmencionadas anteriormente.\n\nNessas condi\u00e7\u00f5es, o processador gr\u00e1fico trabalha bem abaixo de sua capacidade.\n\nInicialmente, o teste foi realizado com somente 18 v\u00e9rtices por cilindro, o que resultava\n\nem aproximadamente 140 mil v\u00e9rtices/s (bem abaixo dos 60 milh\u00f5es de capacidade da\n\nplaca utilizada). Foi poss\u00edvel aumentar em 5 vezes o n\u00famero de v\u00e9rtices por segmento\n\n(de 18 para 90) antes que fosse percept\u00edvel uma queda em performance, o que confirma\n\no fato de que o limitante \u00e9 o processamento num\u00e9rico, n\u00e3o o gr\u00e1fico.\n\nCom um passo de tempo duas vezes maior, de 100ms, foi poss\u00edvel renderizar\n\npouco mais que o dobro de risers, 76. A tabela 1 resume esses resultados:\n\nTabela 1 - Testes de stress: capacidade de processamento\n\nPasso de Tempo (ms) 50 50 100\n\nN\u00famero de Quadros por Segundo 20 20 10\n\nN\u00famero de Risers 36 36 76\n\nN\u00famero de Segmentos por Riser 11 11 11\n\nN\u00famero de V\u00e9rtices por Segmento 18 90 90\n\nN\u00famero de Segmentos por Segundo 7.920 7.920 8.360\n\nN\u00famero de V\u00e9rtices por Segundo 1,43E+05 7,13E+05 7,52E+05\n\n\n\n142\n\nO anti-aliasing por software, mesmo com um n\u00famero pequeno de risers (entre 1\n\ne 5), s\u00f3 pode ser feito com um passo de tempo de 200ms.\n\n5.2.2. Processamento Gr\u00e1fico\n\nPara renderizar uma cena com um grande n\u00famero de pol\u00edgonos mas que taxasse\n\npouco o processador principal do sistema, decidiu-se utilizar um elemento est\u00e1tico - o\n\nsolo do oceano - discretizado em um n\u00famero cada vez maior de pol\u00edgonos at\u00e9 que a\n\ncena n\u00e3o mais pudesse ser renderizada no passo de tempo desejado.\n\nDurante a realiza\u00e7\u00e3o dos testes foi necess\u00e1rio ter o cuidado de exibir toda a cena\n\nna janela, para evitar que o processo de culling (discutido no Cap\u00edtulo 2) eliminasse\n\npara o resto da pipeline os v\u00e9rtices que estivessem fora do campo de vis\u00e3o. No entanto,\n\na varia\u00e7\u00e3o de performance entre os testes com somente uma pequena parte da cena\n\nsendo exibida e aqueles em que ela era exibida em sua totalidade foi pequena, o que\n\nleva a crer que o fator limitante n\u00e3o foi o processamento da cena em si, mas sim a\n\npassagem de dados para o processador gr\u00e1fico (que acontece antes do culling). Outra\n\nexplica\u00e7\u00e3o, menos plaus\u00edvel, \u00e9 um sistema de culling mau implementado.\n\nPara analisar esse aspecto de transfer\u00eancia de dados, \u00e9 necess\u00e1rio estimar o\n\ntamanho de um v\u00e9rtice em bytes. Cada v\u00e9rtice cont\u00e9m suas tr\u00eas coordenadas, tr\u00eas\n\nvalores para codificar sua cor, um para sua transpar\u00eancia, tr\u00eas valores para parametrizar\n\nsua normal e dois para coordenadas de textura. Com uma precis\u00e3o de 32 bits para esses\n\nvalores, obt\u00e9m-se um tamanho de 48 bytes para cada v\u00e9rtice, sem levar em conta a\n\n\n\n143\n\ntransmiss\u00e3o de informa\u00e7\u00e3o topogr\u00e1fica (como os v\u00e9rtices est\u00e3o ligados para formar os\n\npol\u00edgonos).\n\nPara um passo de tempo de 100ms, a maior cena que se p\u00f4de renderizar tinha\n\naproximadamente um milh\u00e3o e meio de v\u00e9rtices (o arquivo \"stress.btm\" cont\u00e9m a\n\ngrande maioria desses v\u00e9rtices). Com 15 milh\u00f5es de v\u00e9rtices por segundo, essa cena\n\ncorresponde a somente 25% da capacidade nominal da placa. Isso equivale, no entanto,\n\na aproximadamente 725MB/s, o que est\u00e1 bem mais pr\u00f3ximo do topo de performance, de\n\nacordo com MSI (2004), para o modo de transfer\u00eancia AGP-4X, que \u00e9 de at\u00e9 1GB/s. O\n\naplicativo tamb\u00e9m foi testado (menos formalmente) em outros sistemas, incluindo um\n\nsistema com AGP-8X, onde mostrou performance notavelmente superior. Esse sistema,\n\nno entanto, tinha tamb\u00e9m capacidade de processamento num\u00e9rico e gr\u00e1fico superiores\n\nao descrito no in\u00edcio desse cap\u00edtulo, de forma que a compara\u00e7\u00e3o dos resultados obtidos\n\nnos dois sistemas \u00e9 problem\u00e1tica.\n\nA cena foi renderizada com de um at\u00e9 oito risers descritos no dom\u00ednio da freq\u00fc\u00eancia e\n\nsomente a partir da\u00ed pode-se perceber uma queda na performance. Durante esses testes,\n\no software ocupava apenas aproximadamente 70MB da mem\u00f3ria RAM.\n\nA tabela 2 resume os resultados desses testes:\n\n\n\n144\n\nTabela 2 - Testes de stress: processamento gr\u00e1fico\n\nN\u00famero de V\u00e9rtices 1.500.000 1.500.000\n\nPasso de Tempo (ms) 100 100\n\nN\u00famero de Quadros por Segundo 10 10\n\nN\u00famero de Risers 1 8\n\nN\u00famero de Segmentos por Segundo 110 880\n\nN\u00famero de V\u00e9rtices por Segundo (c/ Risers) 1,50E+07 1,51E+07\n\nTamanho de um V\u00e9rtice (Bytes) 48 48\n\nTaxa de Transfer\u00eancia (Bytes/s) 7,24E+08 7,25E+08\n\n5.3. Detec\u00e7\u00e3o de Colis\u00f5es\n\nOs testes do sistema detec\u00e7\u00e3o de colis\u00f5es entre risers tinham como objetivo\n\ndeterminar tr\u00eas pontos principais:\n\n i. Se as colis\u00f5es de fato eram sempre detectadas, se falsas colis\u00f5es eram detectadas e\n\nse, ao detectar as colis\u00f5es, o RiserView se comportava conforme descrito no caso\n\nde uso 7 (ver Ap\u00eandice A).\n\n ii. Qual o pior caso para o sistema, ou seja, a condi\u00e7\u00e3o em que \u00e9 feito o maior n\u00famero\n\nde checagens de colis\u00e3o entre os risers.\n\n iii. No pior caso, qual a performance do aplicativo quando a detec\u00e7\u00e3o est\u00e1 ativa.\n\n\n\n145\n\nDurante os testes, todas as colis\u00f5es foram detectadas. Foram detectadas tamb\u00e9m\n\ncolis\u00f5es que visualmente parecem falsas. Isso se deve ao fato de as colis\u00f5es serem\n\ndetectadas entre os segmentos cil\u00edndricos que formam os risers, e n\u00e3o entre sua\n\nrepresenta\u00e7\u00e3o por pol\u00edgonos (o que, como j\u00e1 foi discutido, n\u00e3o s\u00f3 \u00e9 mais simples como\n\ntamb\u00e9m mais preciso). Colis\u00f5es falsas de fato n\u00e3o ocorreram. O funcionamento do\n\nsistema correspondeu ao especificado pelos casos de uso.\n\nEntre dois risers, o pior caso detectado foi quando n\u00e3o s\u00f3 cada riser estava\n\nincluso na envolt\u00f3ria do outro, mas tamb\u00e9m eram divididos em segmentos de maneira\n\nigual e estavam colocados em paralelo. Nessa configura\u00e7\u00e3o, o pr\u00e9-processamento indica\n\na possibilidade de colis\u00e3o de cada segmento com o seu equivalente no outro riser, bem\n\ncomo com os segmentos imediatamente adjacentes a ele. Isso porque o comprimento\n\ndos segmentos era sempre bem maior que o seu deslocamento (subdividir os risers em\n\nsegmentos ainda menores fazia muito pouca diferen\u00e7a na visualiza\u00e7\u00e3o e enquanto o\n\ncomprimento dos risers \u00e9 medido em centenas de metros, os deslocamentos s\u00e3o\n\nmedidos em unidades). Assim, nessa configura\u00e7\u00e3o, s\u00e3o gerados pouco menos que tr\u00eas\n\npares de colis\u00e3o para cada segmento do riser. A figura 28 ilustra essa configura\u00e7\u00e3o. Na\n\nfigura, o segmento em azul pode colidir com os tr\u00eas segmentos em vermelho. Em cinza\n\nest\u00e1 indicada a envolt\u00f3ria que inclui o segmento azul em qualquer posi\u00e7\u00e3o que esse\n\npossa assumir.\n\n\n\n146\n\nFigura 28 - Pares de colis\u00e3o\n\nQuando os segmentos t\u00eam o mesmo tamanho mas n\u00e3o est\u00e3o paralelos entre si,\n\nmuitas vezes s\u00f3 existe a possibilidade de colis\u00e3o do segmento com dois outros ao inv\u00e9s\n\nde tr\u00eas. E quando t\u00eam tamanhos diferentes, muitas vezes um segmento menor s\u00f3 pode\n\ncolidir com um dos segmentos maiores.\n\nDeterminar uma configura\u00e7\u00e3o espacial e de deslocamentos de mais de dois risers\n\nque gere o maior n\u00famero de colis\u00f5es, no entanto, \u00e9 mais complexo. Para que o n\u00famero\n\nde pares de colis\u00e3o seja maximizado, \u00e9 importante que os risers estejam paralelos.\n\nNesse caso, com risers em caten\u00e1ria, o pior caso encontrado foi com risers lado a lado,\n\ncom deslocamentos maiores que a espessura dos segmentos de forma que cada riser\n\npoderia colidir n\u00e3o s\u00f3 com os imediatamente adjacentes mas tamb\u00e9m com os pr\u00f3ximos.\n\nPara risers verticais existem possibilidades mais complexas, como arranjos circulares\n\nconc\u00eantricos dos risers.\n\n\n\n147\n\nPor fim, para verificar a performance do aplicativo ao realizar a detec\u00e7\u00e3o de\n\ncolis\u00f5es, foi utilizado um passo de 50ms. Risers id\u00eanticos, exceto pela posi\u00e7\u00e3o, foram\n\nacrescentados um ao lado do outro de forma que cada um s\u00f3 pudesse colidir com os\n\ndois imediatamente adjacentes, at\u00e9 que o aplicativo n\u00e3o fosse mais capaz de executar a\n\nanima\u00e7\u00e3o e as checagens de colis\u00e3o em tempo real. Nenhuma colis\u00e3o era de fato\n\ndetectada para que a anima\u00e7\u00e3o nunca fosse interrompida. Para esses risers e\n\nconfigura\u00e7\u00e3o em particular, com 11 segmentos cada, foram obtidos 29 pares de colis\u00e3o\n\npara cada par de risers.\n\nUma hip\u00f3tese que teve que ser respeitada durante os testes foi a de que os\n\ndeslocamentos de cada segmento em um passo de tempo sempre fossem menores que a\n\nmenor dimens\u00e3o de um segmento. Isso porque o sistema testa somente a colis\u00e3o entre os\n\nsegmentos, e n\u00e3o entre as trajet\u00f3rias que percorrem, como discutido anteriormente. Caso\n\nessa hip\u00f3tese n\u00e3o seja respeitada, podem ocorrer colis\u00f5es entre segmentos que n\u00e3o s\u00e3o\n\ndetectadas, pois eles se atravessam ao passar de um passo de tempo para o pr\u00f3ximo mas\n\nnunca est\u00e3o colidindo em um mesmo passo.\n\n\u00c9 importante notar que, nesse teste, \u00e9 imposs\u00edvel isolar quanto do processamento\n\nest\u00e1 sendo usado para a detec\u00e7\u00e3o de colis\u00f5es e quanto est\u00e1 sendo usado para a\n\natualiza\u00e7\u00e3o das posi\u00e7\u00f5es dos risers. \u00c9 poss\u00edvel, no entanto, comparar esses resultados\n\ncom os descritos em 5.2.1.\n\nO n\u00famero m\u00e1ximo de risers que foi poss\u00edvel acrescentar \u00e0 cena foi de 24 risers\n\n(enquanto sem a checagem de colis\u00e3o esse n\u00famero, para o mesmo passo de tempo, foi\n\nde 36), o que significa a atualiza\u00e7\u00e3o da posi\u00e7\u00e3o de 5280 segmentos por segundo e a\n\nchecagem de mais de 13 mil colis\u00f5es por segundo. A tabela 3 resume esses resultados:\n\n\n\n148\n\nTabela 3 - Detec\u00e7\u00e3o de colis\u00f5es\n\nPasso de Tempo (ms) 50\n\nN\u00famero de Quadros por Segundo 20\n\nN\u00famero de Risers 22\n\nN\u00famero de Segmentos por Riser 11\n\nPares de Colis\u00e3o entre 2 Risers 29\n\nChecagens de Colis\u00e3o por Segundo 13.340\n\nN\u00famero de Segmentos por Segundo 5.280\n\n5.4. Portabilidade\n\nPortar o c\u00f3digo para o Linux foi um processo relativamente simples. Como j\u00e1\n\nera esperado, as \u00fanicas mudan\u00e7as necess\u00e1rias foram na classe RVView, na fun\u00e7\u00e3o\n\nInitialize que, entre outras tarefas, estabelece a interface entre o VTK e o IUP. O tipo\n\ndas vari\u00e1veis que no MS Windows era HWND passa a ser Widget e o tipo da vari\u00e1vel\n\npRenWin deixa de ser vtkWin32OpenGLRenderWindow e passa a ser\n\nvtkXMesaRenderWindow. A instru\u00e7\u00e3o de #include para o cabe\u00e7alho da classe de render\n\nwindow teve que ser trocado da mesma forma.\n\nAo inv\u00e9s de gerar um makefile manualmente foi usada a ferramenta KDevelop\n\npara gerenciar o projeto, o que tornou a tarefa bastante simples.\n\nA compila\u00e7\u00e3o tanto do IUP quanto do VTK tamb\u00e9m foi facilitada pelo uso das\n\nferramentas recomendadas por seus desenvolvedores, respectivamente, TecMake e\n\n\n\n149\n\nCMake. A documenta\u00e7\u00e3o do IUP, em particular, discute em detalhe como compilar a\n\nAPI no Linux e us\u00e1-la nesse sistema.\n\nExceto pelo look-and-feel nativo do Linux o aplicativo se comportou da mesma\n\nforma que no MS Windows. Os testes de Stress n\u00e3o foram repetidos nesse sistema.\n\n\n\n150\n\n6. CONCLUS\u00d5ES\n\nAntes mesmo de se discutir pontos espec\u00edficos levantados por esse trabalho,\n\npode-se afirmar que a principal conclus\u00e3o a que se p\u00f4de chegar foi a de que ele se trata\n\napenas dos primeiros passos na pesquisa e no desenvolvimento de um ambiente de\n\nvisualiza\u00e7\u00e3o como este.\n\nAcredita-se que, na forma em que se encontra, o RiserView j\u00e1 \u00e9 uma ferramenta\n\n\u00fatil para auxiliar na pesquisa da din\u00e2mica de risers, permitindo que outros\n\npesquisadores possam se concentrar na modelagem dos sistemas envolvidos e em sua\n\nsimula\u00e7\u00e3o mas que ainda assim possam contar com uma visualiza\u00e7\u00e3o que facilite a\n\ncompreens\u00e3o dos resultados que obt\u00e9m.\n\nA pesquisa realizada para o desenvolvimento deste ambiente, por si s\u00f3, pode ser\n\nconsiderada de interesse para a \u00e1rea, principalmente pelo seu car\u00e1ter multi-disciplinar.\n\nNo in\u00edcio do trabalho o autor estava familiarizado com aspectos da modelagem e\n\nsimula\u00e7\u00e3o da din\u00e2mica de risers e com programa\u00e7\u00e3o orientada a objetos, principalmente\n\npara a plataforma Windows e sem uma preocupa\u00e7\u00e3o com uma metodologia de projeto.\n\nA esses conhecimentos foi poss\u00edvel, de fato necess\u00e1rio, acrescentar conceitos sobre\n\nv\u00f3rtices, incluindo m\u00e9todos para sua simula\u00e7\u00e3o, engenharia de software, computa\u00e7\u00e3o\n\ngr\u00e1fica, realidade virtual e visualiza\u00e7\u00e3o cient\u00edfica, dentre outros. Durante a elabora\u00e7\u00e3o\n\n\n\n151\n\ndeste texto houve a preocupa\u00e7\u00e3o de, devido justamente a esse car\u00e1ter multi-disciplinar,\n\nexplicar de forma clara, ainda que por vezes necessariamente breve, os conceitos\n\nb\u00e1sicos das \u00e1reas envolvidos no trabalho - explica\u00e7\u00f5es que possivelmente seriam\n\ndesnecess\u00e1rias em um trabalho de escopo mais estreito. Espera-se que com isso seja\n\nposs\u00edvel facilitar e at\u00e9 estimular futuras pesquisas nessa linha.\n\nApesar disso tudo, ficou claro durante a reda\u00e7\u00e3o desse texto, o uso do aplicativo\n\ne a realiza\u00e7\u00e3o dos testes que restam ainda diversas melhorias importantes a serem feitas\n\nno trabalho. At\u00e9 mesmo durante o desenvolvimento, diversas vezes foram levantados\n\nposs\u00edveis aperfei\u00e7oamentos e nem todos foram implementados ou pesquisados devido a\n\nrestri\u00e7\u00f5es de tempo. Embora muitas dessas mudan\u00e7as sejam relativamente simples,\n\ncomo as listadas no Ap\u00eandice C, nesse cap\u00edtulo ser\u00e3o discutidas algumas de car\u00e1ter\n\nmais profundo e menos imediato. \u00c9 por isso, tamb\u00e9m, que se afirma que esse trabalho \u00e9\n\napenas um primeiro passo.\n\nIsto posto, s\u00e3o tratados em seguida alguns pontos espec\u00edficos. Para cada ponto,\n\nquando conveniente, discute-se poss\u00edveis futuros trabalhos a ele relacionados. Ao\n\ncontr\u00e1rio dos outros cap\u00edtulos, essa discuss\u00e3o apresenta diversas conjecturas sem a\n\npreocupa\u00e7\u00e3o de demonstr\u00e1-las, pois embora seja plaus\u00edvel extrapolar os efeitos que\n\nesses futuros trabalhos possam ter, ou mesmo a sua necessidade, com base nos\n\nconhecimentos atuais, \u00e9 imposs\u00edvel oferecer provas para essas conjecturas antes que os\n\ntrabalhos sejam de fato realizados.\n\nEm primeiro lugar s\u00e3o tratadas quest\u00f5es relativas \u00e0 performance do software,\n\nincluindo a detec\u00e7\u00e3o de colis\u00e3o. Diversas quest\u00f5es referentes \u00e0 visualiza\u00e7\u00e3o v\u00eam ent\u00e3o e\n\nnesse item algumas quest\u00f5es relativas \u00e0 interface tamb\u00e9m s\u00e3o discutidas. Por fim o uso\n\n\n\n152\n\ndas principais tecnologias no desenvolvimento (as APIs IUP e VTK e a pr\u00f3pria\n\nmetodologia, o Processo Unificado), s\u00e3o abordadas.\n\n6.1. Performance\n\nOs principais t\u00f3picos que merecem discuss\u00e3o com refer\u00eancia \u00e0 performance s\u00e3o\n\na atualiza\u00e7\u00e3o dos risers, anti-aliasing, a renderiza\u00e7\u00e3o de cenas complexas, detec\u00e7\u00e3o de\n\ncolis\u00f5es entre risers e, por fim, a possibilidade de paralelizar o c\u00f3digo.\n\n6.1.1. Atualiza\u00e7\u00e3o dos Risers\n\nUma das principais conclus\u00f5es dos testes de stress foi a confirma\u00e7\u00e3o de como a\n\natualiza\u00e7\u00e3o dos risers, principalmente quando descritos no dom\u00ednio da freq\u00fc\u00eancia, \u00e9\n\ncustosa em termos de processamento. A 20 quadros por segundo, um valor\n\nrelativamente baixo para uma anima\u00e7\u00e3o, s\u00f3 foi poss\u00edvel renderizar 36 desses risers no\n\nsistema utilizado para os testes, e com somente 11 segmentos cada. Tratam-se de\n\nn\u00fameros pequenos, principalmente se for levado em conta o fato de que foram obtidos\n\nsem a inclus\u00e3o de nenhum outro elemento na cena e sem detec\u00e7\u00e3o de colis\u00f5es.\n\nComparando o n\u00famero de v\u00e9rtices utilizados nesses testes com os limites do hardware,\n\nou mesmo com os testes relatados em 5.2.2, pode-se concluir que a opera\u00e7\u00e3o cr\u00edtica \u00e9,\n\nde fato, a atualiza\u00e7\u00e3o da posi\u00e7\u00e3o dos risers, e n\u00e3o sua renderiza\u00e7\u00e3o. E embora seja\n\nposs\u00edvel lan\u00e7ar m\u00e3o de sistemas com maior capacidade de processamento e essa\n\n\n\n153\n\ncapacidade aumente rapidamente com o tempo, conclui-se ser necess\u00e1rio reduzir o custo\n\ndessa tarefa, mesmo porque podem ser encontrados outros usos para o processamento\n\ndispon\u00edvel (como alguns mencionados nesse cap\u00edtulo). Al\u00e9m disso, como \u00e9 discutido a\n\nseguir, essa redu\u00e7\u00e3o pode ser atingida de maneiras relativamente simples.\n\nTanto os risers descritos no dom\u00ednio da freq\u00fc\u00eancia quanto os descritos no\n\ndom\u00ednio do tempo t\u00eam a necessidade de utilizar fun\u00e7\u00f5es trigonom\u00e9tricas, para converter\n\na descri\u00e7\u00e3o das coordenadas das extremidades de seus segmentos de um sistema\n\ncartesiano para um sistema polar, permitindo a defini\u00e7\u00e3o das rota\u00e7\u00f5es que o segmento\n\ndeve sofrer bem como de seu comprimento. Para os risers descritos no dom\u00ednio da\n\nfreq\u00fc\u00eancia, no entanto, esse problema \u00e9 agravado, uma vez que cada uma das tr\u00eas\n\ncoordenadas das extremidades de seus segmentos \u00e9 definida a partir do c\u00e1lculo de um\n\ncoseno. Converter uma descri\u00e7\u00e3o no dom\u00ednio da freq\u00fc\u00eancia para o dom\u00ednio do tempo \u00e9\n\num processo trivial e, por isso, poderia ser levantada a hip\u00f3tese de se abandonar, no\n\nRiserView, o tratamento do dom\u00ednio da freq\u00fc\u00eancia, convertendo qualquer riser para\n\numa descri\u00e7\u00e3o no dom\u00ednio do tempo e utilizando somente essa descri\u00e7\u00e3o durante a\n\nanima\u00e7\u00e3o (essa foi a solu\u00e7\u00e3o utilizada, por exemplo, para descrever a din\u00e2mica da\n\nsuperf\u00edcie da \u00e1gua). Essa modifica\u00e7\u00e3o, no entanto, n\u00e3o \u00e9 interessante pelos seguintes\n\nmotivos.\n\nA descri\u00e7\u00e3o de risers no dom\u00ednio da freq\u00fc\u00eancia \u00e9 v\u00e1lida para literalmente\n\nqualquer instante no tempo e portanto independente do passo utilizado, podendo ser\n\nutilizada com facilidade em sistemas com passo de tempo vari\u00e1vel. Descri\u00e7\u00f5es no\n\ndom\u00ednio do tempo s\u00e3o v\u00e1lidas para um \u00fanico passo de tempo. Al\u00e9m disso, descri\u00e7\u00f5es no\n\ndom\u00ednio do tempo exigem o uso de mais mem\u00f3ria para armazenar cada riser, bem como\n\n\n\n154\n\nde arquivos maiores e mais lentos para serem lidos. Determinar a envolt\u00f3ria utilizada\n\npara detec\u00e7\u00e3o de colis\u00e3o tamb\u00e9m se torna mais custoso nesse dom\u00ednio. Como\n\naprimoramentos simples (discutidos adiante) podem reduzir drasticamente o overhead\n\nna atualiza\u00e7\u00e3o de risers no dom\u00ednio da freq\u00fc\u00eancia, as vantagens dessa descri\u00e7\u00e3o tornam\n\npouco atraente a op\u00e7\u00e3o de elimin\u00e1-la.\n\nUma dessas otimiza\u00e7\u00f5es simples para o c\u00e1lculo da posi\u00e7\u00e3o de risers no dom\u00ednio\n\nda freq\u00fc\u00eancia est\u00e1 em separar o c\u00e1lculo de cada parcela do coseno na determina\u00e7\u00e3o das\n\ncoordenadas de seus pontos. Cada coordenada para um ponto i \u00e9 calculada a partir de\n\numa equa\u00e7\u00e3o semelhante a:\n\n)t.cos(Ax iii ?+?=\n\nComo a fase ? i n\u00e3o varia com o tempo, mas somente com cada ponto, poderiam\n\nser armazenados nas estruturas de dados os valores de seno e coseno dessa fase, ao\n\ninv\u00e9s de seu valor, e utilizar a seguinte equa\u00e7\u00e3o para o c\u00e1lculo das coordenadas:\n\n[ ])sen()t.sen()cos()t.cos(Ax iiii ?????=\n\nE dessa forma seria necess\u00e1rio calcular o coseno e seno de ?t uma \u00fanica vez\n\npara cada riser em um passo de tempo, ao inv\u00e9s de calcular um coseno para cada um de\n\nseus segmentos, uma vez que as parcelas relativas \u00e0 fase estariam pr\u00e9-calculadas e\n\narmazenadas.\n\nEmbora essa mudan\u00e7a melhore o desempenho da atualiza\u00e7\u00e3o da posi\u00e7\u00e3o dos\n\nrisers, mesmo com ela ainda restam os c\u00e1lculos de dois arco-senos, um coseno e uma\n\nraiz quadrada para determinar as rota\u00e7\u00f5es e o comprimento de cada segmento,\n\n\n\n155\n\nindependente de como o riser \u00e9 descrito. Uma solu\u00e7\u00e3o relativamente simples para\n\nreduzir o custo desses c\u00e1lculos \u00e9 gerar tabelas para essas duas fun\u00e7\u00f5es trigonom\u00e9tricas e\n\nusar a interpola\u00e7\u00e3o dessas tabelas ao inv\u00e9s das fun\u00e7\u00f5es padr\u00e3o do C. Como essas\n\nfun\u00e7\u00f5es est\u00e3o sendo usadas para determinar posi\u00e7\u00f5es para serem renderizadas (com\n\nprecis\u00e3o limitada pela defini\u00e7\u00e3o do dispositivo de sa\u00edda utilizado), e como o c\u00e1lculo n\u00e3o\n\n\u00e9 iterativo, n\u00e3o havendo ac\u00famulo de erros de um passo de tempo para o pr\u00f3ximo, n\u00e3o h\u00e1\n\na necessidade da precis\u00e3o que \u00e9 fornecida pelas fun\u00e7\u00f5es do C. Dependendo da precis\u00e3o\n\ndas tabelas utilizadas, uma simples interpola\u00e7\u00e3o linear poderia ser suficiente.\n\nDeterminar uma combina\u00e7\u00e3o de precis\u00e3o das tabelas e de ordem de sua interpola\u00e7\u00e3o e\n\nimplementar essa mudan\u00e7a \u00e9 outra possibilidade interessante para futuros trabalhos.\n\nAinda outra alternativa que inclusive remove a necessidade de calcular ra\u00edzes\n\nquadradas durante a anima\u00e7\u00e3o, mas que se aplica somente para o dom\u00ednio do tempo e\n\nmais uma vez aumenta o consumo de mem\u00f3ria \u00e9 pr\u00e9-calcular a posi\u00e7\u00e3o e o tamanho de\n\ncada segmento para cada passo de tempo (por exemplo, quando os arquivos s\u00e3o\n\ncarregados) e armazenar esses valores. N\u00e3o \u00e9 poss\u00edvel substituir as coordenadas das\n\nextremidades dos segmentos pela sua posi\u00e7\u00e3o e tamanho, pois essas coordenadas s\u00e3o\n\nusadas durante a detec\u00e7\u00e3o de colis\u00e3o. Todas essas informa\u00e7\u00f5es precisariam ser\n\narmazenadas.\n\n\n\n156\n\n6.1.2. Anti-Aliasing\n\nOutra tarefa, ainda mais custosa que a atualiza\u00e7\u00e3o da posi\u00e7\u00e3o dos risers, \u00e9 a de\n\nanti-aliasing. Muitas das placas gr\u00e1ficas atuais tem a op\u00e7\u00e3o de anti-aliasing por\n\nhardware. No in\u00edcio dos testes, no entanto, os efeitos desse recurso eram impercept\u00edveis\n\n(ao menos para placas da NVidia, que foram as \u00fanicas testadas). Com os novos drivers\n\npara essas placas, no entanto, \u00e9 poss\u00edvel perceber uma melhoria significativa na\n\nqualidade da imagem ao se ativar esse recurso. Mas al\u00e9m de ele n\u00e3o estar presente em\n\ntodas as placas, sua ativa\u00e7\u00e3o ou n\u00e3o de maneira independente do aplicativo deve ser\n\nfeita antes que o aplicativo em quest\u00e3o seja executado e mudan\u00e7as em tempo de\n\nexecu\u00e7\u00e3o n\u00e3o t\u00eam efeito. Por esses motivos foi decidido manter a op\u00e7\u00e3o de anti-aliasing\n\npor software presente no RiserView. Mesmo com seu alto custo, pelo menos em rela\u00e7\u00e3o\n\n\u00e0 capacidade dos sistemas atuais, o anti-aliasing do RiserView mostrou-se \u00fatil em\n\ndiversos momentos, como para visualiza\u00e7\u00e3o de cenas simples com um passo de tempo\n\nmaior (como 200ms), ou quando n\u00e3o havia preocupa\u00e7\u00e3o com a exig\u00eancia de sincronia\n\nda anima\u00e7\u00e3o com o tempo real, ou mesmo para obter capturas de tela de cenas com a\n\nanima\u00e7\u00e3o parada.\n\nEm placas gr\u00e1ficas com o recurso de anti-aliasing, cada aplicativo pode ativar\n\nou n\u00e3o esse recurso atrav\u00e9s de comandos do OpenGL, por exemplo. Uma melhoria\n\ninteressante para o RiserView seria estudar como determinar se um sistema gr\u00e1fico tem\n\nou n\u00e3o essa capacidade e utiliz\u00e1-la, ao inv\u00e9s do anti-aliasing por software, quando o\n\nusu\u00e1rio ativa essa op\u00e7\u00e3o no aplicativo. O anti-aliasing por software seria mantido para\n\nos casos em que o hardware n\u00e3o possu\u00edsse esse recurso. \u00c9 interessante notar que, em\n\n\n\n157\n\nsua vers\u00e3o atual (4.2), o VTK, apesar de atrav\u00e9s do OpenGL aproveitar bem os recursos\n\ndas placas gr\u00e1ficas, n\u00e3o o faz no caso do anti-aliasing. Se com futuras atualiza\u00e7\u00f5es do\n\nVTK ou do OpenGL isso mudar, essa preocupa\u00e7\u00e3o pode deixar de ser importante para o\n\nRiserView.\n\nUma outra alternativa interessante \u00e9 estudar o uso de shaders com o VTK. O uso\n\ndesse recurso para obter mais realismo ser\u00e1 discutido mais adiante, mas Pixel Shaders,\n\nem particular, podem ser usados para implementar anti-aliasing. Como pode ser\n\nverificado em Kessenich et al. (2004), a GLSL possui fun\u00e7\u00f5es para estimar as derivadas\n\nparciais de propriedades dos pixels (HLDL e Cg tamb\u00e9m contam com esse recurso) e\n\ncom as derivadas da cor \u00e9 poss\u00edvel implementar um algoritmo simples e eficiente de\n\nanti-aliasing. Essa op\u00e7\u00e3o se torna ainda mais atrativa se shaders forem tamb\u00e9m usados\n\npara realizar outras fun\u00e7\u00f5es no aplicativo. \u00c9 importante lembrar, no entanto, que pelo\n\nmenos atualmente esse ainda n\u00e3o \u00e9 um recurso comum.\n\n6.1.3. Cenas Complexas\n\nO limite de 15 milh\u00f5es de v\u00e9rtices por segundo que foi atingido durante os\n\ntestes, bem abaixo da capacidade nominal do processador gr\u00e1fico, a princ\u00edpio n\u00e3o\n\nparece um ponto preocupante: esse n\u00famero de v\u00e9rtices \u00e9 suficiente para gerar cenas\n\ncomplexas mesmo com passos de tempo pequenos (como por exemplo 25ms - nesse\n\npasso de tempo seria poss\u00edvel renderizar cenas com aproximadamente 200 mil\n\ntri\u00e2ngulos). E como os testes nos levam a concluir que o fator limitante \u00e9 a taxa de\n\n\n\n158\n\ncomunica\u00e7\u00e3o, o uso de AGP-8X mais do que dobra esse n\u00famero. Caso a comunica\u00e7\u00e3o\n\nde dados para o processador gr\u00e1fico se torne um problema no futuro, entretanto, existem\n\nalgumas alternativas para contorn\u00e1-lo.\n\nA pipeline de visualiza\u00e7\u00e3o do VTK est\u00e1 otimizada, no RiserView, para\n\nrenderizar cenas com grande n\u00famero de pol\u00edgonos que se modificam em cada quadro,\n\npois julga-se que, numa cena t\u00edpica, a maior parte de seus elementos ser\u00e1 din\u00e2mica.\n\nCaso cenas muito complexas sejam utilizadas, mas que contenham um grande n\u00famero\n\nde v\u00e9rtices que n\u00e3o mudam de um quadro para o outro, essa parametriza\u00e7\u00e3o da pipeline\n\npode ser mudada para permitir que mais v\u00e9rtices sejam guardados na mem\u00f3ria da placa\n\ngr\u00e1fica e n\u00e3o precisem ser comunicados a cada quadro.\n\nOutro recurso que n\u00e3o est\u00e1 presente no RiserView mas que seria um acr\u00e9scimo\n\ninteressante - e que \u00e9 indispens\u00e1vel para a renderiza\u00e7\u00e3o de cenas de alta complexidade -\n\n\u00e9 o tratamento de n\u00edveis de detalhe (LOD, ou level of detail). Trata-se de um recurso que\n\najusta a complexidade de cada objeto da cena (ou at\u00e9 de partes de objetos) \u00e0 dist\u00e2ncia\n\nentre esse objeto e o observador, de forma que objetos mais distantes sejam\n\napresentados com um menor n\u00famero de pol\u00edgonos, j\u00e1 que n\u00e3o podem ser vistos em\n\ndetalhe daquela dist\u00e2ncia. Reduzindo o n\u00edvel de detalhe de objetos distantes \u00e9 reduzido\n\ntamb\u00e9m o n\u00famero de v\u00e9rtices que \u00e9 preciso comunicar ao processador gr\u00e1fico.\n\n\n\n159\n\n6.1.4. Detec\u00e7\u00e3o de Colis\u00f5es\n\nQuanto \u00e0 detec\u00e7\u00e3o de colis\u00f5es entre risers, a principal conclus\u00e3o que p\u00f4de ser\n\natingida ao longo do trabalho \u00e9 o quanto as simplifica\u00e7\u00f5es que foram utilizadas, com\n\nbase no conhecimento dos objetos sujeitos \u00e0 colis\u00e3o, reduziram o custo de uma tarefa\n\ngeralmente cara sem a necessidade de algoritmos complexos. A possibilidade de montar\n\nos pares de colis\u00e3o num pr\u00e9-processamento, e n\u00e3o durante a anima\u00e7\u00e3o, que se deve ao\n\nconhecimento pr\u00e9vio que se tem da din\u00e2mica de cada riser, elimina a necessidade de\n\nusar outros filtros para detec\u00e7\u00e3o (como por exemplo setores ou bounding volumes). Por\n\nse saber a geometria do riser \u00e9 poss\u00edvel fazer a detec\u00e7\u00e3o exata com cilindros e n\u00e3o entre\n\npol\u00edgonos, o que \u00e9 outro fator que reduz o n\u00famero de checagens necess\u00e1rias, e \u00e9\n\nposs\u00edvel tamb\u00e9m decis\u00e3o de utilizar c\u00e1psulas ao inv\u00e9s de troncos de cilindro na\n\ndetec\u00e7\u00e3o, o que permite que se use um algoritmo com custo computacional bem menor.\n\nPor fim, o conhecimento da coer\u00eancia espacial e temporal do sistema permite que n\u00e3o\n\nseja necess\u00e1rio checar a colis\u00e3o entre as trajet\u00f3rias percorridas pelos segmentos em um\n\npasso de tempo.\n\nPor tudo isso, o autor n\u00e3o \u00e9 capaz de levantar possibilidades de trabalhos futuros\n\npara aprimorar esse recurso do RiserView. Ainda assim, durante os testes houve uma\n\nqueda no n\u00famero de risers que podiam ser atualizados em tempo real de quase 35% ao\n\nse ativar a detec\u00e7\u00e3o de colis\u00e3o. Deve-se ter em mente, por\u00e9m, que esses testes foram\n\nrealizados para o pior caso de colis\u00e3o, com o maior n\u00famero de pares de colis\u00e3o poss\u00edvel\n\ne resultando em mais de 13 mil checagens de colis\u00e3o por segundo al\u00e9m da cara\n\natualiza\u00e7\u00e3o dos risers. Essa condi\u00e7\u00e3o dificilmente ser\u00e1 reproduzida durante o uso\n\n\n\n160\n\nnormal do aplicativo para simular situa\u00e7\u00f5es reais (de outra forma, ocorreria um grande\n\nn\u00famero de colis\u00f5es entre risers a todo instante na realidade). E ao se comparar mesmo\n\nesse pior caso para o algoritmo utilizado com a detec\u00e7\u00e3o de colis\u00e3o por \"for\u00e7a bruta\"\n\n(ou seja, checar a colis\u00e3o de cada objeto com todos os outros) o algoritmo\n\nimplementado se mostra muito superior. Enquanto no pior caso, para dois risers com n\n\nelementos, o RiserView realiza no m\u00e1ximo 3n checagens de colis\u00e3o a cada quadro, por\n\nfor\u00e7a bruta seria necess\u00e1rio fazer n2 checagens. O custo dessa performance \u00e9 o pr\u00e9-\n\nprocessamento necess\u00e1rio para montar os pares de colis\u00e3o. Mesmo para grandes\n\nn\u00fameros de risers (da ordem de 100), no entanto, esse tempo de pr\u00e9-processamento foi\n\npraticamente impercept\u00edvel durante os testes.\n\n6.1.5. Paralelismo\n\nUma das vantagens do VTK citadas no cap\u00edtulo 3 foi a facilidade da sua\n\nutiliza\u00e7\u00e3o (na verdade do ParaView, uma API derivada do VTK) para tirar vantagem de\n\nprocessamento em paralelo. De fato, sabendo do custo de atualiza\u00e7\u00e3o dos risers desde o\n\nin\u00edcio, uma futura paraleliza\u00e7\u00e3o do c\u00f3digo, ao menos para essa tarefa, parecia atraente.\n\nAt\u00e9 mesmo o balan\u00e7o de carga entre processadores poderia ser estimado, a princ\u00edpio,\n\npelo n\u00famero de segmentos passado para cada um. Com base nos resultados obtidos,\n\nentretanto, acredita-se que, implementando alguns dos aprimoramentos mais simples\n\nsugeridos em 6.1.1 o RiserView seja capaz de lidar com cenas complexas e com grande\n\nn\u00famero de risers sem a necessidade do multiprocessamento. Mesmo o anti-aliasing\n\npode ser utilizado atrav\u00e9s da sua implementa\u00e7\u00e3o por hardware com placas gr\u00e1ficas mais\n\n\n\n161\n\navan\u00e7adas e esse e outros aprimoramentos para aumentar o realismo da cena podem ser\n\nimplementados com o uso de shaders. Essas op\u00e7\u00f5es permitem que o RiserView seja\n\nutilizado em um n\u00famero maior de sistemas (placas gr\u00e1ficas program\u00e1veis s\u00e3o bem mais\n\ncomuns que multiprocessamento) e, sendo assim, a paraleliza\u00e7\u00e3o do c\u00f3digo passa a ser\n\num \u00faltimo recurso, provavelmente s\u00f3 necess\u00e1rio se forem implementadas alguns dos\n\nrecursos mais avan\u00e7ados para aumentar o realismo ou algumas das visualiza\u00e7\u00f5es mais\n\ncomplexas citadas adiante.\n\n6.2. Visualiza\u00e7\u00e3o e Interface\n\nOs primeiros t\u00f3picos a serem discutidos nessa se\u00e7\u00e3o, que j\u00e1 foram inclusive\n\ncitados anteriormente, s\u00e3o relativos ao passo de tempo da anima\u00e7\u00e3o. Em seguida, a\n\nquest\u00e3o do realismo \u00e9 discutida. Novas formas de visualiza\u00e7\u00e3o, e a visualiza\u00e7\u00e3o\n\ncient\u00edfica de outros objetos tamb\u00e9m s\u00e3o abordados. Por fim, discute-se uma conclus\u00e3o\n\ninteressante relativa \u00e0 navega\u00e7\u00e3o pela cena, que foi atingida apesar de n\u00e3o terem sido\n\nrealizados testes formais de usabilidade do sistema. A pr\u00f3pria realiza\u00e7\u00e3o desses testes\n\nconstitui uma possibilidade interessante de um futuro trabalho.\n\n6.2.1. Passo de Tempo\n\nNessa primeira vers\u00e3o do RiserView, o passo de tempo da anima\u00e7\u00e3o \u00e9 fixo.\n\nAl\u00e9m disso, o usu\u00e1rio n\u00e3o tem controle sobre ele. O passo \u00e9 determinado pelos\n\n\n\n162\n\nelementos da anima\u00e7\u00e3o. Cada um (exceto o relevo do solo, que \u00e9 est\u00e1tico, e os risers\n\ndescritos no dom\u00ednio da freq\u00fc\u00eancia) tem um passo de tempo associado pois s\u00e3o\n\ndescritos atrav\u00e9s de seq\u00fc\u00eancias de posi\u00e7\u00f5es em pontos discretos no tempo. Idealmente,\n\nas simula\u00e7\u00f5es de todos os elementos que comp\u00f5em uma cena s\u00e3o feitas de forma\n\ncompat\u00edvel e geram arquivos descrevendo esses elementos com os mesmos passos de\n\ntempo. Essa condi\u00e7\u00e3o era, inclusive, necess\u00e1ria nas vers\u00f5es iniciais do RiserView\n\ndurante o desenvolvimento. Na vers\u00e3o atual, os passos de tempo podem ser diferentes e\n\no menor deles \u00e9 adotado, mas n\u00e3o h\u00e1 nenhuma interpola\u00e7\u00e3o de posi\u00e7\u00e3o dos elementos,\n\nde forma que em cenas compostas por elementos descritos com passos de tempo\n\ndistintos, ocorrem discrep\u00e2ncias na posi\u00e7\u00e3o relativa dos elementos em alguns quadros\n\nda anima\u00e7\u00e3o.\n\nPermitir que o usu\u00e1rio determine o passo \u00e9 trivial. No entanto, caso isso seja\n\nimplementado sem a interpola\u00e7\u00e3o de posi\u00e7\u00f5es, tem pouca utilidade e torna-se mais um\n\nfator capaz de gerar discrep\u00e2ncias na visualiza\u00e7\u00e3o. Cada elemento continuar\u00e1 a ser\n\natualizado no seu pr\u00f3prio passo (a menos que o usu\u00e1rio escolha um passo de tempo\n\nmaior que o que descreve o elemento).\n\nAl\u00e9m de permitir que o usu\u00e1rio escolha um passo para a anima\u00e7\u00e3o e mitigar as\n\ndiscrep\u00e2ncias que ocorrem entre elementos cuja din\u00e2mica \u00e9 descrita com passos\n\ndiferentes, a interpola\u00e7\u00e3o das posi\u00e7\u00f5es dos elementos entre duas posi\u00e7\u00f5es estabelecidas\n\npela descri\u00e7\u00e3o de sua din\u00e2mica permite que duas grandezas que s\u00e3o de fato distintas\n\nsejam assim tratadas pelo RiserView: o passo de tempo da anima\u00e7\u00e3o e o passo (ou\n\npassos) de tempo que descreve a din\u00e2mica dos elementos da cena. Atualmente essas\n\ngrandezas est\u00e3o vinculadas, mas seria interessante que fossem independentes.\n\n\n\n163\n\nPrincipalmente porque passos de tempo que podem ser pequenos o suficiente para\n\nalgumas simula\u00e7\u00f5es e para descrever a din\u00e2mica de objetos (como 150ms ou 200ms)\n\ns\u00e3o grandes demais para uma anima\u00e7\u00e3o suave. Assim sendo, a interpola\u00e7\u00e3o de posi\u00e7\u00f5es\n\n\u00e9 um poss\u00edvel futuro trabalho relativamente simples, mas capaz de promover uma\n\nmelhoria significativa no aplicativo.\n\nUm trabalho mais complexo, mas que vale a pena ser mencionado, \u00e9 a\n\nimplementa\u00e7\u00e3o de uma op\u00e7\u00e3o de passo de tempo adaptativo. Atualmente, conforme\n\ndescrito no cap\u00edtulo 4, o la\u00e7o principal do programa d\u00e1 m\u00e1xima prioridade \u00e0 atualiza\u00e7\u00e3o\n\ne renderiza\u00e7\u00e3o da cena em tempo real, usando um passo de tempo fixo, e o tratamento\n\nde mensagens de interface \u00e9 feito apenas com o tempo que sobra (mas pelo menos uma\n\nmensagem \u00e9 tratada em cada passo de tempo). Embora isso garanta uma atualiza\u00e7\u00e3o\n\nmais precisa da cena, para cenas complexas (seja devido \u00e0 atualiza\u00e7\u00e3o dos risers ou ao\n\nn\u00famero de pol\u00edgonos) a navega\u00e7\u00e3o pela cena fica dif\u00edcil, \"saltada\" e desagrad\u00e1vel. Por\n\nisso, determinar um meio termo entre priorizar a atualiza\u00e7\u00e3o da cena ou o tratamento de\n\nmensagens \u00e9 um trabalho interessante. Um modo de se implementar esse meio termo\n\nseria com um passo de tempo adaptativo para a anima\u00e7\u00e3o que tente sempre manter sua\n\nqualidade mas tamb\u00e9m tratar as mensagens de usu\u00e1rio. Esse recurso depende, \u00e9 claro, da\n\nimplementa\u00e7\u00e3o da interpola\u00e7\u00e3o de posi\u00e7\u00f5es.\n\n\n\n164\n\n6.2.2. Realismo\n\nNos cap\u00edtulos anteriores foi deixado clara uma op\u00e7\u00e3o de projeto deste trabalho:\n\nembora esses dois fatores nem sempre estejam em conflito, sempre que o realismo\n\nprejudicasse a visualiza\u00e7\u00e3o cient\u00edfica dos elementos da cena, a visualiza\u00e7\u00e3o seria\n\nprivilegiada. Um exemplo \u00e9 o mapeamento de escalares com cores sobre os risers ao\n\ninv\u00e9s do uso de texturas e bump-mapping. Essa op\u00e7\u00e3o est\u00e1 de acordo com os principais\n\nobjetivos do trabalho e n\u00e3o se mostrou inadequada. O realismo, no entanto, tamb\u00e9m\n\nfacilita a assimila\u00e7\u00e3o da cena e, em pontos em que n\u00e3o tem efeito sobre a visualiza\u00e7\u00e3o,\n\npoderia ser bastante aprimorado no RiserView.\n\nAlgumas desses poss\u00edveis aprimoramentos s\u00e3o: a inclus\u00e3o de sombras, de um\n\nc\u00e9u, inclusive com nuvens, e de horizontes, tanto para o c\u00e9u quanto para a superf\u00edcie da\n\n\u00e1gua (quando o observador est\u00e1 submerso); a renderiza\u00e7\u00e3o de uma superf\u00edcie da \u00e1gua\n\nmais realista, inclusive com efeitos de espuma; efeitos de bump-mapping,\n\nprincipalmente para o solo; o teste de modelos de ilumina\u00e7\u00e3o mais complexos; dentre\n\noutros. O uso de shaders pode facilitar, ou at\u00e9 viabilizar, a implementa\u00e7\u00e3o de alguns\n\ndesses recursos.\n\nOutra possibilidade a ser estudada nessa linha, em trabalhos futuros, \u00e9 a do uso\n\nde t\u00e9cnicas de realidade aumentada (a combina\u00e7\u00e3o de imagens renderizadas e reais) para\n\naumentar o realismo da cena. Esse recurso poderia ser utilizado, por exemplo, para\n\ninclus\u00e3o de estruturas, como plataformas, na cena.\n\n\n\n165\n\n6.2.3. Visualiza\u00e7\u00e3o\n\nA visualiza\u00e7\u00e3o de v\u00f3rtices da forma como est\u00e1 implementada atualmente no\n\nRiserView est\u00e1 intrinsecamente ligada a duas formas de simula\u00e7\u00e3o num\u00e9rica\n\nespec\u00edficas: m\u00e9todos de v\u00f3rtices discretos (que levam ao uso de glifos para represent\u00e1-\n\nlos) e m\u00e9todos de elementos finitos ou diferen\u00e7as finitas em malhas estruturadas ou n\u00e3o\n\n(que podem ser representados aqui somente atrav\u00e9s dos campos escalares). Al\u00e9m disso,\n\nas estruturas de dados prev\u00eaem somente essas simula\u00e7\u00f5es em planos e n\u00e3o em tr\u00eas\n\ndimens\u00f5es, apesar de haver a possibilidade de utilizar v\u00e1rios desses planos numa mesma\n\ncena para estudar efeitos tridimensionais. Mesmo com essas limita\u00e7\u00f5es, ainda \u00e9 poss\u00edvel\n\nfornecer, em futuros trabalhos, outras formas de visualiza\u00e7\u00e3o para o escoamento, como\n\nlinhas de corrente e glifos com tamanho e dire\u00e7\u00e3o vari\u00e1veis (como setas) para\n\nrepresentar grandezas vetoriais.\n\nMais interessante, no entanto, \u00e9 a renderiza\u00e7\u00e3o de v\u00f3rtices como estruturas\n\ntridimensionais atrav\u00e9s, por exemplo, do uso de iso-superf\u00edcies como sugerem Jeong &amp;\n\nHussain (1995). O pr\u00f3prio VTK conta com mais de um algoritmo para a tessela\u00e7\u00e3o (a\n\ngera\u00e7\u00e3o de superf\u00edcies atrav\u00e9s da justaposi\u00e7\u00e3o de pol\u00edgonos) de iso-superf\u00edcies baseada\n\nem  conjuntos volum\u00e9tricos de dados, de forma que o maior desafio t\u00e9cnico desse\n\ntrabalho se encontra na gera\u00e7\u00e3o desses dados e na escolha das vari\u00e1veis e valores usados\n\nna gera\u00e7\u00e3o das superf\u00edcies, e n\u00e3o tanto nos algoritmos para a visualiza\u00e7\u00e3o em si. A\n\nanima\u00e7\u00e3o e gera\u00e7\u00e3o em tempo real dessas superf\u00edcies (ainda que com base em dados\n\npr\u00e9-calculados), pode ser uma tarefa suficientemente pesada para justificar seu\n\nmultiprocessamento.\n\n\n\n166\n\nUma limita\u00e7\u00e3o, atualmente, da visualiza\u00e7\u00e3o no RiserView \u00e9 que risers e v\u00f3rtices\n\ns\u00e3o os \u00fanicos elementos da cena que contam com esses recursos. Outro trabalho\n\nposs\u00edvel \u00e9 estudar a visualiza\u00e7\u00e3o cient\u00edfica para outros elementos, como por exemplo\n\npara mostrar a configura\u00e7\u00e3o das correntes mar\u00edtimas (longe dos risers) ou para a\n\nvisualiza\u00e7\u00e3o da din\u00e2mica da superf\u00edcie da \u00e1gua.\n\n6.2.4. Navega\u00e7\u00e3o\n\nUma observa\u00e7\u00e3o interessante feita durante o desenvolvimento, apesar da n\u00e3o\n\nrealiza\u00e7\u00e3o de testes formais de usabilidade, \u00e9 relativa \u00e0 navega\u00e7\u00e3o pela cena.\n\nInicialmente essa navega\u00e7\u00e3o era implementada de forma que toda cena era encarada\n\ncomo um \u00fanico objeto (como se fosse um globo) que podia ser afastado, aproximado,\n\nrotacionado ou arrastado em v\u00e1rias dire\u00e7\u00f5es para facilitar sua visualiza\u00e7\u00e3o. Apesar de\n\nintuitiva para o autor, essa forma de navega\u00e7\u00e3o mostrou muitas vezes ir diretamente\n\ncontra a intui\u00e7\u00e3o de v\u00e1rios usu\u00e1rios, que esperavam navegar pela cena como se\n\nestivessem imersos nela, como \u00e9 tradicionalmente feito em ambientes virtuais ou jogos.\n\nA substitui\u00e7\u00e3o do estilo de navega\u00e7\u00e3o anterior por este aparentemente aumentou\n\nconsideravelmente a usabilidade deste aspecto da interface.\n\nOutro ponto relativo \u00e0 navega\u00e7\u00e3o est\u00e1 relacionado aos tipos de atores no sistema.\n\nNo cap\u00edtulo 4 afirma-se que o RiserView tem somente um tipo de ator, respons\u00e1vel\n\ntanto pela navega\u00e7\u00e3o das cenas quanto por sua cria\u00e7\u00e3o. Pode ser interessante separar\n\nessas responsabilidades para dois atores distintos e refletir essa separa\u00e7\u00e3o na interface\n\n\n\n167\n\n(com um m\u00f3dulo de cria\u00e7\u00e3o de cenas e um de navega\u00e7\u00e3o, por exemplo). Se no futuro\n\nfor implementado um meio de expandir o sistema sem a necessidade de criar extens\u00f5es\n\ndo c\u00f3digo e recompil\u00e1-lo, com o uso de scripts por exemplo, um terceiro tipo de ator\n\npode surgir, respons\u00e1vel pela inclus\u00e3o desses scripts.\n\n6.3. Tecnologias\n\nNesta se\u00e7\u00e3o procura-se analisar as principais vantagens e desvantagens do uso\n\ndas principais tecnologias do trabalho: o Processo Unificado (UP), o VTK e o IUP.\n\nUma das primeiras observa\u00e7\u00f5es que se pode fazer a respeito do uso do UP \u00e9 o\n\nquanto o trabalho de customiza\u00e7\u00e3o do framework para adequ\u00e1-lo ao projeto e \u00e0 sua\n\nescala de fato simplificou o uso da metodologia. Basta comparar os passos relatados no\n\ncap\u00edtulo 4 e o n\u00famero de artefatos gerados com a descri\u00e7\u00e3o do processo por Jacobson et\n\nal. (1998). Ainda assim, o uso do UP resultou em uma documenta\u00e7\u00e3o mais completa e\n\nem uma arquitetura mais elegante. Na verdade, o processo s\u00f3 foi selecionado e aplicado\n\ndepois que a primeira itera\u00e7\u00e3o descrita no cap\u00edtulo 4 j\u00e1 havia sido conclu\u00edda, pois no\n\nin\u00edcio do trabalho havia uma maior preocupa\u00e7\u00e3o com a viabilidade do uso do VTK e do\n\n\u00e2mbito do projeto do que com a metodologia, e o autor tinha pouco conhecimento da\n\n\u00e1rea de engenharia de software. Uma vez que o processo foi aplicado, a arquitetura que\n\nj\u00e1 existia p\u00f4de ser consideravelmente aprimorada atrav\u00e9s do uso de padr\u00f5es de projeto e\n\nde generaliza\u00e7\u00f5es que ficaram claras com o uso da metodologia. Outra benef\u00edcio\n\nbastante vis\u00edvel do uso do UP foi a possibilidade de usar os casos de uso como guia para\n\nos testes de caixa-preta, como relatado no cap\u00edtulo 5.\n\n\n\n168\n\nQuanto ao uso do VTK, essa API forneceu uma infra-estrutura orientada a\n\nobjetos que n\u00e3o existiria caso o OpenGL tivesse sido usado diretamente. Mas os\n\nmaiores benef\u00edcios obtidos com seu uso foram a portabilidade do c\u00f3digo e a\n\ndisponibilidade em um \u00fanico pacote de algoritmos para diversas tarefas de visualiza\u00e7\u00e3o\n\ncient\u00edfica, anti-aliasing e estereoscopia. Durante os testes foi poss\u00edvel observar ainda\n\ncomo o VTK, atrav\u00e9s do OpenGL, faz uso dos recursos dispon\u00edveis nas placas gr\u00e1ficas\n\natuais. Embora no cap\u00edtulo 5 tenha sido registrado o conjunto de testes mais formal\n\nsomente, testes menos formais foram realizados em plataformas sem acelera\u00e7\u00e3o gr\u00e1fica\n\ne que utilizavam placas gr\u00e1ficas com diferentes performances (TNT 2, GeForce 2 e\n\nGeForce 4, al\u00e9m da GeForce FX citada no cap\u00edtulo 5) e a diferen\u00e7a de performance\n\nentre esses sistemas foi bem vis\u00edvel. Uma observa\u00e7\u00e3o interessante foi a de como, para o\n\nanti-aliasing, o VTK ainda n\u00e3o aproveita os recursos dispon\u00edveis em hardware.\n\nA portabilidade do c\u00f3digo n\u00e3o foi conseq\u00fc\u00eancia unicamente do VTK. O uso do\n\nIUP no desenvolvimento da interface tamb\u00e9m permitiu que isso ocorresse. Al\u00e9m disso,\n\na simplicidade dessa API permitiu que a interface fosse desenvolvida de forma bastante\n\nr\u00e1pida.\n\nA principal desvantagem do uso do VTK foi que o acesso a recursos do OpenGL\n\ndiretamente torna-se mais complicado, de forma que para fazer uso de tecnologias mais\n\nrecentes torna-se necess\u00e1rio um trabalho maior (como a biblioteca \u00e9 open-source\n\nsempre \u00e9 poss\u00edvel extend\u00ea-la por conta pr\u00f3pria e, apesar de complexa, sua arquitetura e\n\nboa documenta\u00e7\u00e3o simplificam esse trabalho de extens\u00e3o), ou ent\u00e3o aguardar uma nova\n\nvers\u00e3o da API. J\u00e1 a principal desvantagem do uso do IUP foi a necessidade de violar a\n\norienta\u00e7\u00e3o a objetos para o tratamento de suas mensagens, uma vez que a API n\u00e3o segue\n\n\n\n169\n\nesse paradigma. Uma desvantagem importante do uso dessas duas bibliotecas em\n\nconjunto \u00e9 que n\u00e3o se conseguiu implementar uma forma de visualiza\u00e7\u00e3o em tela-cheia\n\n(fullscreen) para o aplicativo (embora faz\u00ea-lo separadamente no IUP ou no VTK \u00e9\n\ntrivial). Isso torna a estereoscopia, por exemplo, bem menos acess\u00edvel e prejudicou os\n\ntestes desse recurso, pois atualmente placas capazes de renderizar cenas estereosc\u00f3picas\n\ndentro de janelas s\u00e3o muito mais caras que as que o fazem em modo de tela-cheia.\n\nApesar dessas desvantagens pode-se afirmar que, sem o uso dessa bibliotecas, ou\n\nao menos de similares (e nesse caso existem bem mais APIs similares ao IUP que ao\n\nVTK), esse trabalho n\u00e3o poderia ter atingido a complexidade e os objetivos que atingiu,\n\nde forma que considera-se seu uso plenamente justificado.\n\n\n\n170\n\nREFER\u00caNCIAS BIBLIOGR\u00c1FICAS17\n\nAHRENS, J. et al. A Parallel Approach for Efficiently Visualizing Extremely Large\nTime-Varying Datasets. Los Alamos National Laboratory, 2000. (Technical Report -\nLAUR-00-1620).\n\nANGEL, E. Interactive Computer Graphics: A top-down approach with OpenGL.\n2nd. Ed. Addison-Wesley, 2000. 612 p.\n\nBARRERA, B. Introdu\u00e7\u00e3o ao OpenGL Shading Language. JogosPRO e-MAGAZINE,\nn. 1, p. 20-22, set. 2004. Dispon\u00edvel em: http://www.jogospro.com.br. Acesso em: 20\nout. 2004.\n\nBICHO, A. et al. Programa\u00e7\u00e3o Gr\u00e1fica 3D com OpenGL, Open Inventor e Java 3D.\nREIC, v. 2, n. 1, p. 1-43, March 2002.\n\nBIRKEN, R. &amp; Versteeg, R. Use of four-dimensional ground penetrating radar and\nadvanced visualization methods to determine subsurface fluid migration. Journal of\nApplied Geophysics. n. 43, p. 215-226, 2000.\n\nBLEVINS, R. Flow-Induced Vibration. 2nd. Ed. New York : Van Nostrand Reinhold,\n1990. 451 p.\n\nBOOCH, G.; Rumbaugh, J &amp; Jacobson, I. The Unified Modeling Language User\nGuide. Addison-Wesley, 1999. 482 p.\n\nBURDEA, G. &amp; Coiffet, P. Virtual Reality Technology. Wiley-Interscience, 1994.\n400 p.\n\n                                                \n\n17 De acordo com: ASSOCIA\u00c7\u00c3O BRASILEIRA DE NORMAS T\u00c9CNICAS. NBR 6023:\ninforma\u00e7\u00e3o e documenta\u00e7\u00e3o: refer\u00eancias: elabora\u00e7\u00e3o. Rio de Janeiro, 2002.\n\n\n\n171\n\nCERNY, D. &amp; Sochor, J. Collision Detection with Extended Fixed Direction Hulls. In:\nWORKSHOP DE REALIDADE VIRTUAL, 3, 2000. Anais... SBC, 2000. p. 205-213.\n\nCHUNG, K. &amp; Wang, W. Quick Collision Detection of Polytopes in Virtual\nEnvironments. ACM Symposium on Virtual Reality Software and Technology, 1996.\nAnais... ACM, 1996. pp. 1-4.\n\nCOHEN, J. et al. I-Collide: An Interactive and Exact Collision Detection System for\nLarge-Scale Environments. SYMPOSIUM ON INTERACTIVE 3D GRAPHICS, 1995.\nAnais... ACM, 1995. p. 183-191.\n\nDACHILE, F. &amp; Kaufman, A. High Degree Temporal Antialiasing. In: COMPUTER\nANIMATION 2000. Anais... 2000. p. 49-55.\n\nEBERLY, D. Distance Between Two Line Segments in 3D. 2000. Dispon\u00edvel em:\nhttp://www.magic-software.com. Acesso em: 20 out. 2004.\n\nEBERLY, D. Intersection of Cylinders. 2000. Dispon\u00edvel em: http://www.magic-\nsoftware.com. Acesso em: 20 out. 2004.\n\nFERRARI, J. A. Hydrodynamic Loading and Response of Offshore Risers. 1999.\n254 p. Tese de Doutorado - Imperial College of Science, Technology and Medicine,\nLondon.\n\nFIGUEIREDO, L. H. Uma estrat\u00e9gia de portabilidade para aplica\u00e7\u00f5es gr\u00e1ficas\ninterativas. In: SIBIGRAPI, 6, 1993. Anais... SBC, 1993. p. 203-211.\n\nFLATT, M.; Krishamurthi, S &amp; Felleisen, M. Classes and Mixins. In: ACM\nSIGPLANSIGACT SYMPOSIUM ON PRINCIPLES OF PROGRAMMING\nLANGUAGES, 25, 1998. Anais... ACM, 1998. p. 171-183.\n\nFOLDOC - Free Online Dictionary of Computing. Dispon\u00edvel em:\nhttp://foldoc.doc.ic.ac.uk/foldoc/index.html. Acesso em: 20 out. 2004.\n\nFOLEY, J. et al. Computer Graphics: Principles and Practice. 2nd. ed. Addison-\nWesley, 1996. 1175 p.\n\nGAMMA, E. Design Patterns: elements of reusable object-oriented software. Addison-\nWesley, 1995. 395 p.\n\n\n\n172\n\nGLASSNER, A. S. (Ed.). Graphic Gems. Academic Press, 1990. 833 p.\n\nG\u00dcNTHER, G. et al. Non-local Methods for Vortex Extraction from Vector Data. in\nSCIENTIFIC VISUALIZATION CONFERENCE, Dagstuhl 2000. Anais... 2000.\n\nGY\u00d6RGY, K. Advection in the von K\u00e1rm\u00e1n vortex street and in the field of the\nleapfrogging vortex pairs Dispon\u00edvel em: http://www.me.bme.hu/munkatrs/karolyi/.\nAcesso em: 20 out. 2004.\n\nIUP - Portable User Interface. Dispon\u00edvel em: http://www.tecgraf.puc-rio.br/iup. Acesso\nem: 20 out. 2004.\n\nJACOBSON, I.; Booch, G. &amp; Rumbaugh, J. The Unified Software Development\nProcess. Addison-Wesley, 1999. 463 p.\n\nJAVA Technology. Dispon\u00edvel em: http://java.sun.com. Acesso em: 20 out. 2004.\n\nJEONG, J. &amp; Hussain, F. On the identification of a vortex. Journal of Fluid\nMechanics, v. 285, p. 69-94, 1995.\n\nKESSENICH, J.; Baldwin, D. &amp; Rost, R. The OpenGL Shading Language. Language\nVersion 1.10, rev. 59, April 2004. Dispon\u00edvel em: http://www.opengl.org. Acesso em:\n20 out. 2004.\n\nKITWARE VTK. Dispon\u00edvel em: http://www.kitware.com/vtk. Acesso em: 20 out.\n2004.\n\nKEIM, D. Visual Exploration of Large Data Sets. Communications of the ACM. v. 44,\nn. 8, p. 38-44, August 2001.\n\nKIRNER, C. &amp; Pinho, M. Introdu\u00e7\u00e3o \u00e0 Realidade Virtual. Apostila do Minicurso\nministrado na XV JAI, durante o XVI Congresso da SBC, Recife, PE, agosto de 1996,\n60 pp.\n\nLAW, C.; Henderson, A &amp; Ahrens, J. An Application Architecture for Large Data\nVisualization: A Case Study. In: IEEE 2001 SYMPOSIUM ON PARALLEL AND\nLARGE-DATA VISUALIZATION AND GRAPHICS. IEEE, 2001. p. 85-92.\n\n\n\n173\n\nLEVY, C. H. et al. IUP/LED: A Portable User Interface Development Tool. Software:\nPractice and Experience. June 1996, p. 737-762.\n\nLUCKAS, V. &amp; D\u00f6rner, R.: Experiences from the Future: Using Object-Oriented\nConcepts for 3D Visualization and Validation of Industrial Cenarios. ACM Computing\nSurveys. v. 32, n. 1, March 2000. Article No. 38.\n\nMAHONEY, D. P. Modeling for Virtual Reality. Computer Graphics World. v. 18, n.\n10, p. 1-3, 1995.\n\nMENEGHINI, J. Numerical simulation of bluff body flow control using a discrete\nvortex method. 1993. Tese de Doutorado - Faculty of Engineering of the University of\nLondon.\n\nPAUL, B. Mesa Homepage. Dispon\u00edvel em: http://www.mesa3d.org/. Acesso em: 20\nout. 2004.\n\nPETROBRAS. Dispon\u00edvel em: http://www.petrobras.com.br. Acesso em: 20 out. 2004.\n\nPETROBRAS Magazine, 7, 26, pp. 20-23, 1999.\n\nPETROBRAS Magazine, 7, 33, pp. 14-17, 2001.\n\nPIMENTEL, K. &amp; Teixeira, K. Virtual Reality: Through the Looking Glass. 2nd. Ed.\nNew York: Intel, 1995. 438 p.\n\nPV-WAVE. Dispon\u00edvel em: http://www.sv.vt.edu/classes/ESM4714/Student_Proj/\nclass97/vlachos/pvlachos/pvwave.htm. Acesso em: 20 out. 2004.\n\nROGERS, D. Z-buffering, Interpolation and More W-buffering. Dispon\u00edvel em:\nhttp://developer.nvidia.com/object/Z_Buff.html. Acesso em: 20 out. 2004.\n\nSCHIRSKI, M. et al. ViSTA FlowLib: A Framework for Interactive Visualization and\nExploration of Unsteady Flows in Virtual Environments. WORKSHOP ON VIRTUAL\nENVIRONMENTS, 2003. Anais... 2003. p. 77-85.\n\nSCHROEDER, W.; Avila, L. &amp; Hoffman, W. Visualizing with VTK: A Tutorial. IEEE\nComputer Graphics and Applications. October 2000, p. 20-27.\n\n\n\n174\n\nSCHROEDER, W. et al. The Design and IMplementation of an Object-Oriented Toolkit\nfor 3D Graphics and Visualization. In: CONFERENCE ON VISUALIZATION, 7,\n1996. Anais... ACM, 1996. p. 93-101.\n\nSCHROEDER, W.; Martin, K &amp; Lorensen, B. The Visualization Toolkit. 2nd. Ed.\nPrentice Hall, 1998. 645 p.\n\nSGI - Open Inventor. Dispon\u00edvel em: http://www.sgi.com/software/inventor. Acesso\nem: 20 out. 2004.\n\nSGI - OpenGL Performer. Dispon\u00edvel em: http://www.sgi.com/software/performer.\nAcesso em: 20 out. 2004.\n\nSGI. OpenGL Performer: Real-Time 3D Rendering for High-Performance and\nInteractive Graphics Applications. SGI, 2002. (White Paper).\n\nSILVEIRA, E. et al. Um sistema computacional integrado para an\u00e1lise din\u00e2mica  n\u00e3o-\nlinear geom\u00e9trica de linhas de ancoragem. In: IBERIAN LATIN-AMERICAN\nCONGRESS ON COMPUTATIONAL METHODS IN ENGINEERING, 21, 2000.\nAnais... 2000. v. 7, p. 26.1-26.20.\n\nSMITH, J. A Comparision of RUP and XP. Rational Software, 2002. (White Paper)\n\nTAI, L. The GUI Toolkit, Framework Page. Dispon\u00edvel em:\nhttp://www.atai.org/guitool. Acesso em: 20 out. 2004.\n\nTAKAHASHI, T.; Liesenberg, H. K. &amp; Xavier, D. T. Programa\u00e7\u00e3o orientada a\nobjetos: uma vis\u00e3o integrada do paradigma de objetos. IME-USP, 1990. 335 p.\n\nTANQUE de Provas Num\u00e9rico. Dispon\u00edvel em: http://not.poli.usp.br/. Acesso em: 20\nout. 2004.\n\nTHALMANN, D. &amp; Thalmann, N. M. Computer Animation: Theory and Pratice. 2nd.\nEd. Springer-Verlag, 1990. 240 p.\n\nUPSON, C. et al. The Physical Simulation and Visual Representation of Natural\nPhenomena. Computer Graphics, v. 21, n. 4, p. 335-336, 1987.\n\n\n\n175\n\nVAN LIERE, R.; Harkes, J. &amp; Leeuw, W. A Distributed Blackboard Architecture for\nInteractive Data Visualization. In: CONFERENCE ON VISUALIZATION, 1998.\nAnais... IEEE, 1998, p. 225-231, 537.\n\nVEIT, M. &amp; Herrmann, S. Model-View-Controller and Object Teams: A Perfect Match\nof Paradigms. In: INTERNATIONAL CONFERENCE ON ASPECT-ORIENTED\nSOFTWARE DEVELOPMENT, 2, 2003. Anais... 2003, p. 140-149.\n\nWEB3D Consortium. Dispon\u00edvel em: http://www.web3d.org. Acesso em: 20 out. 2004.\n\nWLOKA, M.; Zeleznik, R. &amp; Miller, T. Practically Frameless Rendering. 1995.\n(Relat\u00f3rio T\u00e9cnico Brown University, CS-95-06).\n\n\n\n176\n\nAP\u00caNDICE A - CASOS DE USO\n\n1. Adicionar Objeto\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\nadicionar um objeto \u00e0 cena. O objeto pode ser um riser, uma representa\u00e7\u00e3o de v\u00f3rtices,\n\nda superf\u00edcie da l\u00e2mina d'\u00e1gua, do solo ou um modelo r\u00edgido para representar\n\nembarca\u00e7\u00f5es ou estruturas. O objeto \u00e9 gerado a partir de um arquivo de dados contendo\n\nseu comportamento ao longo do tempo, escolhido pelo usu\u00e1rio atrav\u00e9s de uma caixa de\n\ndi\u00e1logo que deve exibir inicialmente somente os arquivos do tipo correto. O nome do\n\narquivo aberto deve ser armazenado para permitir que se gere uma lista dos arquivos\n\nusados na cena. No caso de risers e modelos, o objeto \u00e9 simplesmente adicionado \u00e0 uma\n\ncole\u00e7\u00e3o de objetos semelhantes. J\u00e1 a superf\u00edcie, o fundo e v\u00f3rtices s\u00e3o \u00fanicos para cada\n\ncena, de forma que um novo objeto substitui o anterior ao ser adicionado. O objeto\n\nadicionado \u00e9 exibido na tela, e a c\u00e2mera \u00e9 deslocada para uma posi\u00e7\u00e3o adequada.\n\nObjetos din\u00e2micos (todos exceto o fundo), ao serem adicionados, liberam o controle da\n\nanima\u00e7\u00e3o para o usu\u00e1rio. Caso a anima\u00e7\u00e3o tenha sido iniciada anteriormente, novos\n\nobjetos s\u00e3o adicionados na posi\u00e7\u00e3o correspondente ao tempo atual da anima\u00e7\u00e3o.\n\nVaria\u00e7\u00f5es: Caso o arquivo escolhido pelo usu\u00e1rio seja inv\u00e1lido, a interface deve gerar\n\numa mensagem de erro e o processo \u00e9 interrompido.\n\n\n\n177\n\nCaso o passo de tempo contido no arquivo seja diferente do utilizado pelos\n\noutros objetos, a interface deve gerar uma mensagem de alerta.\n\n2. Adicionar Lista de Objetos\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\ncarregar um arquivo contendo uma lista de arquivos descrevendo a din\u00e2mica de objetos\n\nque devem ser adicionados \u00e0 cena. Estes objetos podem ser risers, uma representa\u00e7\u00e3o de\n\nv\u00f3rtices, da superf\u00edcie da l\u00e2mina d'\u00e1gua, do solo ou modelos r\u00edgidos para representar\n\nembarca\u00e7\u00f5es ou estruturas. O nome de todos os arquivos constantes da lista devem ser\n\narmazenados para permitir que se gere uma nova lista dos arquivos usados na cena. No\n\ncaso de risers e modelos, os novos objetos s\u00e3o simplesmente adicionado a uma cole\u00e7\u00e3o\n\nde objetos semelhantes. J\u00e1 a superf\u00edcie, o fundo e v\u00f3rtices s\u00e3o \u00fanicos para cada cena, de\n\nforma que um novo objeto substitui o anterior ao ser adicionado. Os objetos adicionados\n\ns\u00e3o exibidos na tela, e a c\u00e2mera \u00e9 deslocada para uma posi\u00e7\u00e3o adequada. Objetos\n\ndin\u00e2micos (todos exceto o fundo), ao serem adicionados, iniciam a anima\u00e7\u00e3o, caso n\u00e3o\n\ntenha sido iniciada ainda, e liberam o controle da mesma para o usu\u00e1rio. Caso a\n\nanima\u00e7\u00e3o j\u00e1 tenha sido iniciada, novos objetos s\u00e3o adicionados na posi\u00e7\u00e3o\n\ncorrespondente ao tempo atual da anima\u00e7\u00e3o.\n\nVaria\u00e7\u00f5es: Caso o arquivo escolhido pelo usu\u00e1rio seja inv\u00e1lido, a interface deve gerar\n\numa mensagem de erro e o processo \u00e9 interrompido.\n\n\n\n178\n\nCaso o passo de tempo contido num arquivo seja diferente do utilizado pelos\n\noutros objetos, a interface deve gerar uma mensagem de alerta.\n\nCaso qualquer um dos arquivos da lista seja inv\u00e1lido (por exemplo, foi apagado\n\nap\u00f3s a gera\u00e7\u00e3o da lista), a interface deve gerar uma mensagem de erro, mas o processo\n\ndeve continuar para os outros objetos.\n\n3. Gravar Lista de Objetos\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\nsolicitar que seja gravado um arquivo contendo a lista de arquivos que descrevem a\n\ndin\u00e2mica dos objetos que comp\u00f5em a cena atual. Dessa forma a cena pode ser\n\nreconstru\u00edda no futuro com somente uma opera\u00e7\u00e3o. A interface deve permitir que o\n\nusu\u00e1rio escolha o nome e diret\u00f3rio do arquivo a ser salvo, bem como alert\u00e1-lo se j\u00e1\n\nexistir um arquivo com o mesmo nome, antes de sobrescrev\u00ea-lo.\n\nVaria\u00e7\u00f5es: Caso haja um erro na grava\u00e7\u00e3o do arquivo (por exemplo, disco cheio ou\n\nusu\u00e1rio sem autoriza\u00e7\u00e3o para gravar o arquivo no local escolhido) a interface deve gerar\n\numa mensagem de erro.\n\n\n\n179\n\n4. Limpar Cena\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\nsolicitar que a cena atual seja apagada. Isso significa remover todos os objetos da cena,\n\nfazendo as reinicializa\u00e7\u00f5es necess\u00e1rias para que uma nova cena possa ser criada com\n\nnovos objetos, limpar a lista de arquivos utilizados, parar e desabilitar a anima\u00e7\u00e3o\n\nenquanto n\u00e3o h\u00e1 objetos ativos na cena e zerar o tempo de anima\u00e7\u00e3o.\n\nAntes desta opera\u00e7\u00e3o ser realizada, o programa pergunta ao usu\u00e1rio se deseja\n\nsalvar a lista de objetos que comp\u00f5es a cena, bem como as op\u00e7\u00f5es atuais.\n\n5. Exibir/Esconder Objeto\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\nescolher quais objetos ser\u00e3o exibidos ou n\u00e3o. No caso de Risers e Modelos, todos os\n\nobjetos deste tipo s\u00e3o exibidos ou ocultos com este comando. Ondas e fundo s\u00e3o \u00fanicos\n\npara cada cena e portanto tamb\u00e9m s\u00e3o exibidos ou ocultos como um todo. Mesmo que\n\nn\u00e3o haja nenhum objeto na cena ainda, a exibi\u00e7\u00e3o ou n\u00e3o de objetos daquele tipo pode\n\nser definida e \u00e9 v\u00e1lida para objetos adicionados \u00e0 cena posteriormente. V\u00f3rtices s\u00e3o um\n\ncaso especial, tratado abaixo.\n\n\n\n180\n\n6. Exibir V\u00f3rtices ou Campos\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\nescolher qual representa\u00e7\u00e3o dos v\u00f3rtices deve ser exibida. O usu\u00e1rio pode escolher n\u00e3o\n\nexibir nenhuma representa\u00e7\u00e3o, exibir conjuntos de v\u00f3rtices discretos ou campos\n\nescalares (por exemplo press\u00e3o, vorticidade ou m\u00f3dulo da velocidade). A op\u00e7\u00e3o de\n\nexibir campos s\u00f3 \u00e9 habilitada caso o arquivo atual de dados de v\u00f3rtices contenha uma\n\ndescri\u00e7\u00e3o desta representa\u00e7\u00e3o. Independente da  op\u00e7\u00e3o escolhida, v\u00f3rtices s\u00e3o exibidos\n\nem planos horizontais e portanto s\u00f3 podem ser visualizados se a vista atual for\n\nhorizontal.\n\n7. Mostrar Colis\u00f5es\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para ativar\n\nou n\u00e3o a exibi\u00e7\u00e3o de colis\u00f5es entre os risers. A amplifica\u00e7\u00e3o dos di\u00e2metros e dos\n\nmovimentos dos risers \u00e9 desativada e cada vez que uma colis\u00e3o acontece a cor dos\n\nrisers envolvidos \u00e9 modificada na vizinhan\u00e7a do ponto de colis\u00e3o, uma mensagem de\n\nalerta \u00e9 mostrada pela interface e a anima\u00e7\u00e3o p\u00e1ra, de forma a permitir que o usu\u00e1rio\n\npossa registrar o momento e local da colis\u00e3o.\n\n\n\n181\n\n8. Ativar Estereoscopia\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para ativar\n\na estereoscopia, ou quando a tecla \"3\" \u00e9 pressionada durante a navega\u00e7\u00e3o. O programa\n\npassa a gerar pares de imagens estereosc\u00f3picas at\u00e9 que esta op\u00e7\u00e3o seja desativada.\n\nVaria\u00e7\u00f5es: Caso o sistema gr\u00e1fico n\u00e3o seja capaz de exibir imagens estereosc\u00f3picas,\n\nesta op\u00e7\u00e3o deve permanecer desabilitada.\n\n9. Ativar Anti-Aliasing\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para ativar\n\na op\u00e7\u00e3o de anti-aliasing. A cena \u00e9 exibida com uma menor intensidade dos efeitos de\n\naliasing espacial (discutido no cap\u00edtulo 2) at\u00e9 que a op\u00e7\u00e3o seja desativada.\n\n10. Modificar Visualiza\u00e7\u00e3o dos Risers\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface de op\u00e7\u00f5es\n\npara os risers. A interface deve permitir ao usu\u00e1rio modificar o n\u00famero de faces com\n\nque o perfil circular do riser deve ser discretizado, bem como fatores de amplifica\u00e7\u00e3o\n\n\n\n182\n\npara o di\u00e2metro e para o movimento dos risers. Estes fatores existem para facilitar a\n\nvisualiza\u00e7\u00e3o da cena como um todo, uma vez que os risers s\u00e3o estruturas muito\n\ndelgadas e seus movimentos tipicamente s\u00e3o muito pequenos em rela\u00e7\u00e3o a seu\n\ncomprimento.\n\n11. Aplicar Texturas\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface de op\u00e7\u00f5es\n\nde texturas. A interface deve permitir ao usu\u00e1rio selecionar um arquivo do tipo BMP\n\npara servir como textura para o fundo oce\u00e2nico, e um para servir como textura para a\n\nsuperf\u00edcie da l\u00e2mina d'\u00e1gua. Deve ainda permitir ao usu\u00e1rio determinar quantas vezes a\n\ntextura deve ser repetida ao longo das superf\u00edcies.\n\n12. Definir Cores\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface de op\u00e7\u00f5es\n\nde cores. A interface deve permitir que o usu\u00e1rio selecione cores para o fundo da cena, o\n\nleito oce\u00e2nico e para a superf\u00edcie da l\u00e2mina d'\u00e1gua.\n\n\n\n183\n\n13. Importar Op\u00e7\u00f5es\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para\n\nselecionar um arquivo contendo um conjunto de op\u00e7\u00f5es pr\u00e9-definidas para serem\n\naplicadas \u00e0 cena. Este arquivo deve conter op\u00e7\u00f5es para visualiza\u00e7\u00e3o dos risers, cores, e\n\ntexturas.\n\nVaria\u00e7\u00f5es: Caso o arquivo escolhido pelo usu\u00e1rio seja inv\u00e1lido, a interface deve gerar\n\numa mensagem de erro e o processo \u00e9 interrompido.\n\n14. Exportar Op\u00e7\u00f5es\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu da interface para gravar\n\num arquivo contendo o conjunto de op\u00e7\u00f5es utilizadas na cena atual. Este arquivo deve\n\nconter op\u00e7\u00f5es para visualiza\u00e7\u00e3o dos risers, cores e texturas.\n\nVaria\u00e7\u00f5es: Caso haja um erro na grava\u00e7\u00e3o do arquivo (por exemplo, disco cheio ou\n\nusu\u00e1rio sem autoriza\u00e7\u00e3o para gravar o arquivo no local escolhido) a interface deve gerar\n\numa mensagem de erro.\n\n\n\n184\n\n15. Parar Anima\u00e7\u00e3o\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para parar a anima\u00e7\u00e3o. Esta op\u00e7\u00e3o s\u00f3 \u00e9 habilitada se houver\n\npelo menos um objeto ativo na cena. Os objetos din\u00e2micos cessam seu movimento e o\n\ncontador de tempo tamb\u00e9m p\u00e1ra. A navega\u00e7\u00e3o pela cena \u00e9 permitida.\n\n16. Come\u00e7ar Anima\u00e7\u00e3o\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para come\u00e7ar a anima\u00e7\u00e3o. Esta op\u00e7\u00e3o s\u00f3 \u00e9 habilitada se houver\n\npelo menos um objeto ativo na cena. Os objetos ativos da cena passam a se mover\n\nnovamente de acordo com sua din\u00e2mica em tempo real (se o hardware permitir), a\n\npartir do momento em que estavam parados. O contador de tempo volta a correr\n\ntamb\u00e9m.\n\n\n\n185\n\n17. Voltar Quadro\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para voltar um quadro na anima\u00e7\u00e3o. Esta op\u00e7\u00e3o s\u00f3 \u00e9 habilitada\n\nse houver pelo menos um objeto ativo na cena e se o tempo atual da anima\u00e7\u00e3o for maior\n\nque zero (valores de tempo negativos n\u00e3o s\u00e3o permitidos). A anima\u00e7\u00e3o volta para o\n\nquadro anterior e p\u00e1ra. O contador de tempo recua um passo de tempo (o tamanho do\n\npasso \u00e9 definido nos arquivos de dados).\n\n18. Avan\u00e7ar Quadro\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para avan\u00e7ar um quadro na anima\u00e7\u00e3o. Esta op\u00e7\u00e3o s\u00f3 \u00e9\n\nhabilitada se houver pelo menos um objeto ativo na cena. A anima\u00e7\u00e3o avan\u00e7a um\n\nquadro e p\u00e1ra. O contador de tempo avan\u00e7a um passo de tempo (o tamanho do passo \u00e9\n\ndefinido nos arquivos de dados).\n\n\n\n186\n\n19. Voltar Acelerado\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para avan\u00e7ar um quadro na anima\u00e7\u00e3o. Esta op\u00e7\u00e3o s\u00f3 \u00e9\n\nhabilitada se houver pelo menos um objeto ativo na cena e se o tempo atual da anima\u00e7\u00e3o\n\nfor maior que zero (valores de tempo negativos n\u00e3o s\u00e3o permitidos). A anima\u00e7\u00e3o\n\nacontece voltando no tempo em velocidade acelerada, acompanhada pelo marcador de\n\ntempo, at\u00e9 que o usu\u00e1rio d\u00ea outro comando para manipular a anima\u00e7\u00e3o, ou at\u00e9 que o\n\ntempo atinja zero.\n\n20. Avan\u00e7ar Acelerado\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para avan\u00e7ar um quadro na anima\u00e7\u00e3o. Esta op\u00e7\u00e3o s\u00f3 \u00e9\n\nhabilitada se houver pelo menos um objeto ativo na cena. A anima\u00e7\u00e3o avan\u00e7a no tempo\n\nem velocidade acelerada, acompanhada pelo marcador de tempo, at\u00e9 que o usu\u00e1rio d\u00ea\n\noutro comando para manipular a anima\u00e7\u00e3o.\n\n\n\n187\n\n21. Alternar Vista\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para alternar entre as vistas vertical ou horizontal, ou quando\n\npressiona a barra de espa\u00e7o durante a navega\u00e7\u00e3o. A posi\u00e7\u00e3o da cena em cada vista deve\n\nser armazenada, de forma que ao alternar entre vistas esta posi\u00e7\u00e3o n\u00e3o seja perdida.\n\n22. Enquadrar Cena\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio utiliza o menu ou a barra de\n\nferramentas da interface para enquadrar a cena. A cena \u00e9 reposicionada para que todos\n\nos elementos possam ser vistos na tela.\n\n23. Avan\u00e7ar/Recuar\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio pressiona (ou mant\u00e9m pressionadas)\n\nas teclas de seta para cima ou para baixo, movendo-se para frente ou para tr\u00e1s na\n\ndire\u00e7\u00e3o em que est\u00e1 vendo a cena, em velocidade constante.\n\n\n\n188\n\n24. Virar para a Esquerda ou Direita\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio pressiona  (ou mant\u00e9m pressionadas)\n\nas teclas de seta para esquerda ou direita, rotacionando a posi\u00e7\u00e3o do observador da cena,\n\nou seja, a dire\u00e7\u00e3o em que ele visualiza a cena.\n\n25. \"Strafe\"\n\nParticipantes: Usu\u00e1rio\n\nDescri\u00e7\u00e3o: Este caso \u00e9 iniciado quando o usu\u00e1rio pressiona (ou mant\u00e9m pressionada)\n\nqualquer uma das setas direcionais juntamente com a tecla \"shift\". O observador se\n\nmove para os lados, para cima ou para baixo sem mudar a dire\u00e7\u00e3o em que a cena esta\n\nsendo visualizada.\n\n\n\n189\n\nAP\u00caNDICE B - GLOSS\u00c1RIO PARA METODOLOGIA\n\nAnima\u00e7\u00e3o: t\u00e9cnica atrav\u00e9s da qual uma ilus\u00e3o de movimento (ou qualquer outra\n\nmudan\u00e7a din\u00e2mica, como crescimento) \u00e9 criada exibindo uma seq\u00fc\u00eancia de imagens a\n\num certo ritmo, onde cada imagem \u00e9 uma altera\u00e7\u00e3o da anterior. Tipicamente, o ritmo de\n\ndas imagens \u00e9 de 24 quadros/s ou 30 quadros/s, mas at\u00e9 ritmos t\u00e3o baixos quanto 5\n\nquadros por segundo ainda fornecem a ilus\u00e3o de movimento, ainda que a transi\u00e7\u00e3o entre\n\nos quadros torne-se percept\u00edvel (como \"pulos\") nesse caso. Numa anima\u00e7\u00e3o gen\u00e9rica,\n\npodem ocorrer diversas mudan\u00e7as com os objetos observados (posi\u00e7\u00e3o, orienta\u00e7\u00e3o,\n\ntamanho, forma, cor, transpar\u00eancia), com o observador (posi\u00e7\u00e3o, ponto de refer\u00eancia,\n\n\u00e2ngulo) e com as fontes de luz (posi\u00e7\u00e3o, intensidade, cor), ou at\u00e9 com a anima\u00e7\u00e3o em si\n\n(velocidade das imagens).\n\nAnti-aliasing: t\u00e9cnicas e algoritmos utilizados para amenizar o problema de aliasing\n\nque surge devido \u00e0 discretiza\u00e7\u00e3o de imagens e entidades geom\u00e9tricas em pixels,\n\nnormalmente percebida como linhas \"quebradas\", lembrando degraus, observadas com\n\nfreq\u00fc\u00eancia em gr\u00e1ficos de computador.\n\nAPIs: Application Programmer Interfaces, ou seja, bibliotecas de fun\u00e7\u00f5es que fazem a\n\ninterface entre o programador de uma aplica\u00e7\u00e3o e um sistema de mais baixo n\u00edvel, seja\n\nele de hardware ou software.\n\n\n\n190\n\nAplica\u00e7\u00e3o, Aplicativo: um software ou programa que realiza diretamente uma ou mais\n\ntarefas para o usu\u00e1rio (ao contr\u00e1rio de bibliotecas, por exemplo, que podem ser\n\nutilizadas para facilitar a cria\u00e7\u00e3o de aplica\u00e7\u00f5es mas n\u00e3o realizam tarefas por si s\u00f3).\n\nBarra de Ferramentas: elemento da interface composto por um conjunto de bot\u00f5es\n\nalinhados horizontalmente lado a lado (ou, menos comunmente, verticalmente um sobre\n\no outro) que permitem ao usu\u00e1rio um r\u00e1pido acesso a algumas das fun\u00e7\u00f5es mais\n\nutilizadas de um software.\n\nCampos: neste trabalho esta palavra normalmente se refere a campos escalares, ou seja,\n\nregi\u00f5es do espa\u00e7o ao longo das quais uma grandeza escalar assume valores de forma\n\ncont\u00ednua.\n\nCena: imagem exibida pelo programa, composta por um conjunto de objetos com\n\ndin\u00e2micas pr\u00f3prias.\n\nCursor: pequeno \u00edcone que indica a posi\u00e7\u00e3o do mouse e, eventualmente, sua fun\u00e7\u00e3o.\n\nEstereoscopia: mecanismo mais importante para a maioria das pessoas para percep\u00e7\u00e3o\n\nde profundidade, onde ambos os olhos registram imagens ligeiramente diferentes para\n\numa cena e o c\u00e9rebro interpreta a diferen\u00e7a entre essas imagens como medida de\n\nprofundidade. Para reproduzir este mecanismo criando uma ilus\u00e3o de profundidade com\n\nimagens projetadas numa tela plana, gera-se uma imagem diferente para cada olho e\n\nfaz-se uso de algum mecanismo para separa o que \u00e9 enxergado por cada olho.\n\n\n\n191\n\nFundo: no contexto deste projeto, refer\u00eancias a \"Fundo\" normalmente est\u00e3o\n\nrelacionadas ao leito oce\u00e2nico, ao solo. Quando a palavra for usada com outro\n\nsignificado (por exemplo, a cor de fundo da tela), isto ser\u00e1 explicitado no texto.\n\nInterface: neste trabalho esta palavra \u00e9 usada normalmente em refer\u00eancia \u00e0 interface\n\ngr\u00e1fica entre o programa e o usu\u00e1rio, ou seja, o conjunto de elementos gr\u00e1ficos que\n\npodem ser manipulados pelo usu\u00e1rio para lhe permitir controle sobre o programa.\n\nQuando a palavra for usada com outro significado (por exemplo, a interface entre os\n\ncomponentes de um programa) isto ser\u00e1 explicitado no texto.\n\nIUP: biblioteca gratuita e multiplataforma para cria\u00e7\u00e3o de interfaces de usu\u00e1rio.\n\nMenu: elemento comum da interface composto por um conjunto de palavras alinhadas\n\nhorizontalmente lado a lado, normalmente no topo da janela da aplica\u00e7\u00e3o. Cada palavra\n\npode estar associada a um submenu (um novo conjunto an\u00e1logo de palavras alinhadas\n\nverticalmente uma sobre a outra) ou acessar uma fun\u00e7\u00e3o da aplica\u00e7\u00e3o.\n\nNavega\u00e7\u00e3o: manipula\u00e7\u00e3o da cena de modo a permitir que o usu\u00e1rio a visualize de\n\n\u00e2ngulos diferentes.\n\nObjeto: neste projeto, objeto normalmente se refere a um elemento da cena. Um riser,\n\numa representa\u00e7\u00e3o da superf\u00edcie da l\u00e2mina d'\u00e1gua, do fundo ou de v\u00f3rtices ou modelos\n\nr\u00edgidos para representar .\n\nObjeto Ativo: objetos que t\u00eam uma din\u00e2mica pr\u00f3pria e n\u00e3o s\u00e3o necessariamente\n\nest\u00e1ticos. No caso desta aplica\u00e7\u00e3o, todos os objetos, exceto o fundo.\n\n\n\n192\n\nOndas: outro nome usado para se referir \u00e0 superf\u00edcie da l\u00e2mina d'\u00e1gua neste projeto, em\n\nrefer\u00eancia a seu movimento.\n\nOpenGL: API gr\u00e1fica para renderiza\u00e7\u00e3o de cenas em tr\u00eas dimens\u00f5es que atualmente se\n\ntornou um padr\u00e3o de fato no mercado.\n\nPasso de Tempo: quantidade de tempo utilizada para discretizar uma simula\u00e7\u00e3o ou\n\nanima\u00e7\u00e3o.\n\nPixels: Picture Element, ou elemento de imagem, a m\u00ednima unidade de \u00e1rea em que\n\nimagens s\u00e3o discretizadas nos dispositivos de exibi\u00e7\u00e3o.\n\nQuadro: imagem est\u00e1tica que, junto ao outros quadros, comp\u00f5e a anima\u00e7\u00e3o.\n\nRisers: estruturas tubulares que ligam os po\u00e7os de explora\u00e7\u00e3o no solo oce\u00e2nico \u00e0s\n\nplataformas ou navios na superf\u00edcie.\n\nTextura: padr\u00f5es, sejam extra\u00eddos de uma imagem digital, seja gerados por uma fun\u00e7\u00e3o\n\nmatem\u00e1tica, que podem ser aplicados (ou mapeados) sobre a geometria. Texturas s\u00e3o\n\nferramentas bastante \u00fateis para fornecer um n\u00edvel de detalhe (e realismo) maior \u00e0\n\nsuperf\u00edcies sem a necessidade de aumentar a complexidade dos modelos geom\u00e9tricos\n\nutilizados.\n\nUIT: User Interface Toolkits, ou bibliotecas de objetos de interface que implementam\n\ndiferentes t\u00e9cnicas de intera\u00e7\u00e3o com o usu\u00e1rio. Tipicamente incluem formas para\n\nsimplificar a descri\u00e7\u00e3o e composi\u00e7\u00e3o das interfaces, que v\u00e3o desde uma linguagem a\n\neditores gr\u00e1ficos. Exemplos s\u00e3o SDK do MS Windows, OSF/Motif, XView e\n\nMacintosh Toolbox.\n\n\n\n193\n\nVista: plano no qual a cena \u00e9 visualizada. O ambiente de visualiza\u00e7\u00e3o desenvolvido\n\nneste trabalho s\u00f3 permite que o usu\u00e1rio navegue por vistas verticais ou horizontais.\n\nV\u00f3rtices: \u00c1reas num fluxo onde o fluido adquire um movimento circular devido ao\n\ndesprendimento da camada limite \u00e0 jusante de um corpo presente no fluxo. V\u00f3rtices\n\ninduzem varia\u00e7\u00f5es de press\u00e3o e velocidade ao longo do fluxo e podem gerar esfor\u00e7os\n\nc\u00edclicos sobre o corpo inserido nele.\n\nVTK: sistema de software open-source, port\u00e1vel e orientado a objetos para computa\u00e7\u00e3o\n\ngr\u00e1fica em 3D, visualiza\u00e7\u00e3o cient\u00edfica e processamento de imagens, baseado no\n\nOpenGL. \u00c9 implementado em C++ mas tamb\u00e9m suporta Tcl, Python e Java.\n\n\n\n194\n\nAP\u00caNDICE C - BUGS E APRIMORAMENTOS\n\nEsse ap\u00eandice re\u00fane os bugs, ou defeitos, conhecidos da vers\u00e3o atual do\n\nRiserView, a maioria descoberta durante os testes de caixa preta, bem como pequenas\n\nmelhorias, principalmente na interface, sugeridas por usu\u00e1rios ou planejadas mas n\u00e3o\n\nimplementadas por quest\u00f5es de tempo. O ap\u00eandice est\u00e1 dividido em duas se\u00e7\u00f5es,\n\ndescrevendo bugs e aprimoramentos, respectivamente.\n\nC.1. Bugs\n\nNesta se\u00e7\u00e3o, os bugs est\u00e3o agrupados conforme o caso de uso (ver Ap\u00eandice A)\n\na que se referem. No final da se\u00e7\u00e3o s\u00e3o relatados os problemas que n\u00e3o se referem a um\n\ncaso de uso em particular. Quando poss\u00edvel, explica\u00e7\u00f5es quanto a poss\u00edveis causas do\n\nproblema e sugest\u00f5es para sua solu\u00e7\u00e3o s\u00e3o tamb\u00e9m mencionados.\n\nCASO DE USO 1 - ADICIONAR OBJETO\n\n\u2022 Com a vers\u00e3o mais atual do IUP (2.2.2) e o sistema operacional Windows XP (e\n\npossivelmente tamb\u00e9m em outros sistemas operacionais), as caixas de di\u00e1logo para\n\nabrir ou salvar arquivo n\u00e3o mostram mais a extens\u00e3o correta dos arquivos daquele\n\ntipo, mostrando ao inv\u00e9s disso arquivos de todos os tipos (*.*). Poss\u00edvel causa: a\n\nfun\u00e7\u00e3o IupGetFile, usada para exibir a caixa de di\u00e1logo para abrir ou salvar\n\n\n\n195\n\narquivos, n\u00e3o se comporta mais de acordo com a documenta\u00e7\u00e3o, pelo menos nesse\n\nsistema. A fun\u00e7\u00e3o recebe como par\u00e2metro uma string com a extens\u00e3o do tipo de\n\narquivo, mas esse par\u00e2metro parece n\u00e3o ter efeito. Em vers\u00f5es anteriores isso n\u00e3o\n\nocorria.\n\n\u2022 Tentar importar um arquivo de modelo inv\u00e1lido gera uma janela de erro do VTK e\n\npor vezes pode \"travar\" a aplica\u00e7\u00e3o que deve, ent\u00e3o, ser fechada. O problema das\n\nmensagens de erro do VTK \u00e9 um problema mais geral: nesse trabalho n\u00e3o se\n\ndeterminou uma maneira de evitar com que essas janelas sejam exibidas e, ao inv\u00e9s\n\ndisso, que se permita que o RiserView, e n\u00e3o o VTK, trate os erros e mande as\n\nmensagens necess\u00e1rias. A forma de contornar esse problema foi tentando prever o\n\nm\u00e1ximo poss\u00edvel de erros antes que sejam enviados ao VTK. Sendo assim, uma\n\nposs\u00edvel solu\u00e7\u00e3o intermedi\u00e1ria para reduzir esse problema seria inserir um\n\nidentificador (uma tag no arquivo) para que o RiserView possa detectar se o arquivo\n\nde modelo \u00e9 v\u00e1lido ou n\u00e3o. Os arquivos de modelo (.mdl), no entanto, s\u00e3o\n\nconstitu\u00eddos por duas partes: uma descri\u00e7\u00e3o do movimento do modelo e o nome do\n\narquivo do 3D Studio (.3DS) que cont\u00e9m as informa\u00e7\u00f5es geom\u00e9tricas. A mudan\u00e7a\n\nsugerida s\u00f3 soluciona o problema de o usu\u00e1rio escolher um arquivo .mdl inv\u00e1lido, e\n\nn\u00e3o a possibilidade de o arquivo .3DS ser inv\u00e1lido. Al\u00e9m disso, uma das sugest\u00f5es\n\nde aprimoramento da interface envolve a separa\u00e7\u00e3o dessas informa\u00e7\u00f5es, como ser\u00e1\n\nvisto adiante, o que inviabiliza essa solu\u00e7\u00e3o.\n\n\u2022 Durante a leitura de arquivos de v\u00f3rtice (.vtx) o RiserView exibe uma caixa de\n\ndi\u00e1logo mostrando o progresso da leitura do arquivo, uma vez que esse tipo de\n\narquivo costuma ter tamanho relativamente grande e leitura demorada. Nessa caixa\n\n\n\n196\n\nde di\u00e1logo h\u00e1 um bot\u00e3o que permite ao usu\u00e1rio cancelar a leitura do arquivo. A\n\nfuncionalidade desse bot\u00e3o n\u00e3o est\u00e1 implementada.\n\nCASO DE USO 2 - ADICIONAR LISTA DE OBJETOS\n\n\u2022 Ao abrir uma lista de objetos que n\u00e3o contenha nenhum objeto ativo mas contenha\n\num arquivo com a descri\u00e7\u00e3o do solo, o RiserView atualmente permite a anima\u00e7\u00e3o, e\n\nn\u00e3o deveria (a anima\u00e7\u00e3o s\u00f3 deve ser permitida se a cena cont\u00e9m ao menos um objeto\n\nativo).\n\nCASO DE USO 8 - ATIVAR ESTEREOSCOPIA\n\n\u2022 Atualmente o RiserView n\u00e3o detecta se um sistema \u00e9 capaz ou n\u00e3o de mostrar\n\nimagens estereosc\u00f3picas para ativar ou n\u00e3o essa op\u00e7\u00e3o do menu. A op\u00e7\u00e3o, assim,\n\nfica sempre desativada. Resta ainda a op\u00e7\u00e3o de ativar a estereoscopia pelo teclado,\n\napertando a tecla \"3\", op\u00e7\u00e3o que gera uma mensagem de erro do VTK caso o\n\nsistema n\u00e3o seja capaz de exibir esse tipo de imagem. O fato de o RiserView n\u00e3o ter\n\na op\u00e7\u00e3o fullscreen, como j\u00e1 foi discutido, limita os sistemas que podem exibir\n\nimagens estereosc\u00f3picas geradas por ele.\n\nCASO DE USO 17 - VOLTAR QUADRO\n\n\u2022 Algumas vezes, devido a problemas de arredondamento, o aplicativo permite que o\n\nusu\u00e1rio volte o quadro uma vez a mais, mesmo quando o tempo zero j\u00e1 foi atingido,\n\nao contr\u00e1rio do que estabelece o caso de uso. Isso n\u00e3o acarreta tempo negativo (o\n\ntempo \u00e9 simplesmente zerado mais uma vez) mas \u00e9 um comportamento indesejado.\n\n\n\n197\n\nA solu\u00e7\u00e3o \u00e9 utilizar uma toler\u00e2ncia para a compara\u00e7\u00e3o do tempo com zero (como \u00e9\n\nutilizado, por exemplo, na implementa\u00e7\u00e3o da classe RVModel).\n\nCASO DE USO 21 - ALTERNAR VISTA\n\n\u2022 As informa\u00e7\u00f5es de c\u00e2mera n\u00e3o s\u00e3o armazenadas ao se alternar entre as duas vistas\n\ncomo manda o caso de uso.\n\nOUTROS PROBLEMAS\n\n\u2022 A implementa\u00e7\u00e3o do mapeamento de cores para a visualiza\u00e7\u00e3o de escalares sobre\n\nrisers e sobre campos escalares para a visualiza\u00e7\u00e3o de v\u00f3rtices trouxe um problema\n\npara a interface n\u00e3o previsto no projeto. Como cada riser pode estar exibindo uma\n\ngrandeza diferente mapeada sobre si, e os v\u00f3rtices ainda outra grandeza, a exibi\u00e7\u00e3o\n\ndas escalas de cores para todas essas grandezas atrapalha consideravelmente a\n\nvisualiza\u00e7\u00e3o. Embora a mera exibi\u00e7\u00e3o dessas escalas seja trivial (basta acrescentar\n\numa inst\u00e2ncia de vtkScalarBarActor \u00e0 cena e parametriz\u00e1-la corretamente), a\n\nescolha de quais escalas exibir e onde provou ser mais complexa. Atualmente,\n\nnenhuma dessas escalas \u00e9 mostrada. Uma op\u00e7\u00e3o seria exibir a escala somente para\n\nobjetos selecionados pelo usu\u00e1rio, com o mouse por exemplo, mas isso depende da\n\nimplementa\u00e7\u00e3o de picking (ver pr\u00f3xima se\u00e7\u00e3o). Outra solu\u00e7\u00e3o \u00e9 uma caixa de\n\ndi\u00e1logo que reuna todas as grandezas mapeadas na cena e permita que o usu\u00e1rio\n\nescolha qual deve ser exibida. Somente nos objetos que exibem aquela grandeza o\n\nmapeamento de cores seria feito e somente uma escala mostrada. Embora isso n\u00e3o\n\nseja propriamente um bug, est\u00e1 listado aqui pois considera-se que exibir o\n\n\n\n198\n\nmapeamento de cores para escalares sem exibir uma escala para essas cores constitui\n\nde fato um erro, pois reduz drasticamente a utilidade do mapeamento.\n\nC.2. Aprimoramentos\n\nAo contr\u00e1rio das mudan\u00e7as discutidas no cap\u00edtulo 6, os aprimoramentos listados\n\naqui s\u00e3o mais simples e geralmente relacionados a detalhes da interface, ou n\u00e3o t\u00e3o\n\nurgentes quanto, por exemplo, as otimiza\u00e7\u00f5es para a atualiza\u00e7\u00e3o dos risers.\n\nUma das mudan\u00e7as j\u00e1 mencionadas \u00e9 a separa\u00e7\u00e3o, na interface e no formato de\n\narquivo, dos arquivos que descrevem a din\u00e2mica de um modelo de corpo r\u00edgido e do\n\narquivo do 3D Studio que descreve sua geometria e apar\u00eancia. Atualmente, um \u00fanico\n\narquivo \u00e9 aberto pelo usu\u00e1rio (.mdl) que cont\u00e9m as informa\u00e7\u00f5es do movimento do corpo\n\nbem como o nome do arquivo do 3D Studio. Com essa mudan\u00e7a, o usu\u00e1rio poderia\n\nutilizar o mesmo arquivo de movimento com diferentes modelos sem a necessidade de\n\ncriar diversos arquivos .mdl. A importa\u00e7\u00e3o de outros tipos de arquivos suportados pelo\n\nVTK, como por exemplo arquivos VRML, tamb\u00e9m \u00e9 simples e interessante.\n\nAtualmente o aplicativo n\u00e3o checa, ao salvar um arquivo de lista ou de op\u00e7\u00f5es,\n\nse aquele arquivo foi salvo com a extens\u00e3o adequada (e muitas vezes o arquivo \u00e9 salvo\n\npelo usu\u00e1rio, por engano, sem extens\u00e3o). Embora n\u00e3o seja recomendado for\u00e7ar o\n\nusu\u00e1rio a utilizar uma extens\u00e3o, emitir um alerta quando o arquivo tiver uma extens\u00e3o\n\ndiferente da padr\u00e3o, ou acrescentar a extens\u00e3o padr\u00e3o caso o arquivo n\u00e3o tenha extens\u00e3o\n\nalguma, podem ser mudan\u00e7as \u00fateis.\n\n\n\n199\n\nA sele\u00e7\u00e3o de cores, atualmente, \u00e9 feita escolhendo valores entre 0 e 255 para as\n\ncomponentes RGB da cor de cada elemento. Sugere-se a cria\u00e7\u00e3o de uma interface mais\n\namig\u00e1vel, que permita que o usu\u00e1rio escolha a cor desejada visualmente.\n\nNos cap\u00edtulo 6 discute-se como a troca do modo de navega\u00e7\u00e3o melhorou a\n\nusabilidade nesse aspecto para a maioria dos usu\u00e1rios, mas uma alternativa n\u00e3o\n\nimplementada e interessante seria manter ambos os modos e permitir sua escolha em\n\ntempo de execu\u00e7\u00e3o atrav\u00e9s da interface.\n\nImplementar o picking ou sele\u00e7\u00e3o de objetos da cena com cliques do mouse \u00e9\n\ntrivial (o VTK j\u00e1 prev\u00ea essa opera\u00e7\u00e3o), exceto para risers e modelos de corpos r\u00edgidos,\n\nporque s\u00e3o, na verdade, formados por v\u00e1rios outros objetos. Esses elementos da cena,\n\nprincipalmente os risers, no entanto, s\u00e3o justamente os que t\u00eam mais necessidade desse\n\nrecurso, por exemplo para a mudan\u00e7a de op\u00e7\u00f5es de exibi\u00e7\u00e3o de objetos individuais da\n\ncena ou para a exibi\u00e7\u00e3o da escala de cores mapeadas sobre cada riser como discutido\n\nanteriormente.\n\nA classe de riser pode ser usada sem o menor problema, tamb\u00e9m, para\n\nrepresentar em parte a amarra\u00e7\u00e3o de embarca\u00e7\u00f5es (visualmente representa\u00e7\u00f5es de fios,\n\ntubos ou cabos n\u00e3o t\u00eam diferen\u00e7a). Seria necess\u00e1rio fazer modifica\u00e7\u00f5es na classe de\n\nmodelo e na interface, no entanto, para tratar os objetos de maneira distinta (por\n\nexemplo separando suas op\u00e7\u00f5es de visualiza\u00e7\u00e3o), mas s\u00e3o modifica\u00e7\u00f5es simples.\n\nPor fim, como o RiserView \u00e9 um projeto open source, a tradu\u00e7\u00e3o da interface e\n\ndos coment\u00e1rios para o ingl\u00eas bem como o uso de uma ferramenta de software para\n\n\n\n200\n\ncontrole de vers\u00f5es poderiam respectivamente aumentar a base de desenvolvedores que\n\npoderiam contribuir com o projeto bem como facilitar a integra\u00e7\u00e3o dessas contribui\u00e7\u00f5es.\n\n\n\n201\n\nAP\u00caNDICE D - CONTE\u00daDOS DO CD ANEXO\n\nA estrutura de diret\u00f3rios do CD anexo, que \u00e9 parte integrante deste trabalho, bem\n\ncomo seus conte\u00fados, s\u00e3o descritos nesse ap\u00eandice. Diret\u00f3rios e subdiret\u00f3rios s\u00e3o\n\ndescritos hierarquicamente como itens e sub-itens na lista abaixo.\n\n\u2022 Software: Diret\u00f3rio contendo o RiserView e as ferramentas necess\u00e1rias para sua\n\ncompila\u00e7\u00e3o e uso.\n\n\u2022 Windows\n\n\u2022 RiserView_Fonte: Fontes comentadas do projeto. O arquivo de projeto \u00e9 um\n\narquivo do MS Visual Studio 6 que provavelmente dever\u00e1 ser modificado\n\npara refletir a nova estrutura de diret\u00f3rios do projeto, especialmente a\n\nlocaliza\u00e7\u00e3o do IUP e do VTK.\n\n\u2022 RiserView: Execut\u00e1vel compilado (para release) e demais arquivos\n\nnecess\u00e1rios para sua execu\u00e7\u00e3o.\n\n\u2022 VTK: Instala\u00e7\u00e3o da vers\u00e3o do VTK usada no RiserView.\n\n\u2022 IUP: Instala\u00e7\u00e3o da vers\u00e3o do IUP usada no RiserView.\n\n\n\n202\n\n\u2022 Linux\n\n\u2022 RiserView_Fonte: Fontes comentadas do projeto, sem um makefile ou\n\narquivo de projeto.\n\n\u2022 VTK: Fontes compil\u00e1veis da vers\u00e3o do VTK usada no RiserView e a\n\nferramenta CMake para auxiliar na compila\u00e7\u00e3o.\n\n\u2022 IUP: Fontes compil\u00e1veis da vers\u00e3o do IUP usada no RiserView e a\n\nferramenta TecMake para auxiliar na compila\u00e7\u00e3o.\n\n\u2022 Entradas: Diversos arquivos de entrada usados durante os testes ou como\n\nexemplos.\n\n\u2022 Docs: Manual do usu\u00e1rio do RiserView em HTML (Man.html e arquivos do\n\nsubdiret\u00f3rio Man), c\u00f3pia eletr\u00f4nica dessa disserta\u00e7\u00e3o (RiserView.pdf) e do artigo\n\nem ingl\u00eas entregue com ela e publicado no SVR 2004 (RiserView_Paper.pdf).\n\n\u2022 VTK: Documenta\u00e7\u00e3o e fontes da vers\u00e3o do VTK utilizada.\n\n\u2022 IUP: Documenta\u00e7\u00e3o da vers\u00e3o do IUP utilizada."}]}}}