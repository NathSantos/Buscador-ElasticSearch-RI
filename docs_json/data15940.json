{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.19187"}, {"@name": "filename", "#text": "26308_DISSERTA%c3%87%c3%83O%20Bruno%20Pessoa%20Neves.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "DESENVOLVIMENTO DE UM N\u00daCLEO ARITM\u00c9TICO  \n\nH\u00cdBRIDO EM HARDWARE RECONFIGUR\u00c1VEL  \n\nPARA IMAGEAMENTO S\u00cdSMICO SEGUNDO  \n\nO ALGORITMO RTM  \n\n \n\n \n\nBruno Pess\u00f4a Neves \n\nDisserta\u00e7\u00e3o de Mestrado \n\n \n\n \n\n \nUNIVERSIDADE FEDERAL DE PERNAMBUCO \n\nposgraduacao@cin.ufpe.br \n\nwww.cin.ufpe.br/~posgraduacao \n\n \n\nRECIFE \n\n2015\n\n \n\n\n\n \n\n \n\n \n \n\n \n\n \n\nBruno Pess\u00f4a Neves \n\n \n\n \n\n \n\nDESENVOLVIMENTO DE UM N\u00daCLEO ARITM\u00c9TICO H\u00cdBRIDO EM \n\nHARDWARE RECONFIGUR\u00c1VEL PARA IMAGEAMENTO S\u00cdSMICO \n\nSEGUNDO O ALGORITMO RTM  \n\n \n\n \n\n \n\n \n\nDisserta\u00e7\u00e3o de Mestrado apresentada \u00e0 Universidade \n\nFederal de Pernambuco, como parte das exig\u00eancias \n\ndo Programa de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da \n\nComputa\u00e7\u00e3o, para obten\u00e7\u00e3o do T\u00edtulo de Mestre. \n\n \n\n \n\nOrientador: Manoel Eus\u00e9bio de Lima \n\n \n\n \n\n \n\n \n\nRECIFE \n\n2015 \n\n   \n\n\n\n \n\n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n                  \n\n \nCataloga\u00e7\u00e3o na fonte \n\nBibliotec\u00e1ria Jane Souto Maior, CRB4-571 \n \n\n  \n \n\nN518d Neves, Bruno Pessoa                               \n Desenvolvimento de um n\u00facleo aritm\u00e9tico h\u00edbrido em \n\nhardware reconfigur\u00e1vel para imageamento s\u00edsmico segundo o \nalgoritmo RTM / Bruno Pessoa Neves \u2013 Recife: O Autor, 2015. \n\n   131 f.: il., fig., tab. \n \n  Orientador: Manoel Eus\u00e9bio de Lima. \n  Disserta\u00e7\u00e3o (Mestrado) \u2013 Universidade Federal de \n\nPernambuco. CIn, Ci\u00eancia da Computa\u00e7\u00e3o, 2015. \n                   Inclui refer\u00eancias e anexo. \n \n\n       1. Engenharia da computa\u00e7\u00e3o.  2. FPGA.  3. Computa\u00e7\u00e3o \ncient\u00edfica. 4. Computa\u00e7\u00e3o de alto desempenho. I. Lima, Manoel \nEus\u00e9bio de (orientador).  II. T\u00edtulo. \n \n      621.39              CDD (23. ed.)          UFPE- MEI 2015-185 \n \n       \n\n \n \n\n \n\n \n\n\n\n \n\n \n\nDisserta\u00e7\u00e3o de Mestrado apresentada por Bruno Pessoa Neves \u00e0 P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia \n\nda Computa\u00e7\u00e3o do Centro de Inform\u00e1tica da Universidade Federal de Pernambuco, sob o \n\nt\u00edtulo \u201cDesenvolvimento de um N\u00facleo Aritm\u00e9tico em Hardware Reconfigur\u00e1vel para \n\nImageamento S\u00edsmico Segundo o Algoritmo RTM\u201d orientada pelo Prof. Manoel Eusebio \n\nde Lima e aprovada pela Banca Examinadora formada pelos professores: \n\n \n\n \n\n    __________________________________________________ \n\n                                        Profa. Edna Natividade da Silva Barros \n\n                                        Centro de Inform\u00e1tica/UFPE \n\n \n\n \n\n                                       __________________________________________________ \n\n                                       Prof. Abner Corr\u00eaa Barros \n\n                                       Departamento de Estat\u00edstica e Inform\u00e1tica / UFRPE \n\n                                   \n\n            \n\n                                       __________________________________________________ \n\n                                       Prof. Manoel Eusebio de Lima \n\n                                       Centro de Inform\u00e1tica / UFPE \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nVisto e permitida a impress\u00e3o. \n\nRecife, 19 de agosto de 2015. \n\n \n\n \n\n___________________________________________________ \n\nProfa. Edna Natividade da Silva Barros \nCoordenadora da P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o do  \n\nCentro de Inform\u00e1tica da Universidade Federal de Pernambuco. \n\n \n\n \n\n \n\n\n\n \n\n \n\nAgradecimentos \n\n Agrade\u00e7o a minha fam\u00edlia, que me deu suporte e apoio desde o in\u00edcio. A minha m\u00e3e, \n\nGertrudes, e meu pai, Jan\u00f4r, por sempre servirem como refer\u00eancia para meu aprendizado e me \n\norientarem. Minhas irm\u00e3s, Amanda e J\u00e9ssica, pelo apoio, carinho e companheirismo. Minhas \n\ntias Giovana e Giovanilza pelo apoio, carinho e for\u00e7a. \n\n Gostaria de agradecer ao professor Manoel Eus\u00e9bio de Lima, que desde o in\u00edcio \n\nesteve presente em meu curso de gradua\u00e7\u00e3o e p\u00f3s-gradua\u00e7\u00e3o. Agrade\u00e7o pelo apoio e \n\nincentivo. \n\n Agrade\u00e7o a meus amigos da \u00e9poca de gradua\u00e7\u00e3o Jo\u00e3o Paulo (JP) e Severino Jos\u00e9 \n\n(Biu). Ambos estiveram presentes desde o in\u00edcio do curso e tamb\u00e9m compartilharam dos \n\npercal\u00e7os da p\u00f3s-gradua\u00e7\u00e3o e trabalho. Sou eternamente grato pela amizade, paci\u00eancia e pelos \n\nconselhos amigos. \n\n               Gostaria de agradecer aos amigos que est\u00e3o ou passaram pelo grupo HPCIn do \n\nCentro de Inform\u00e1tica da UFPE, o qual estive presente durante grande parte da gradua\u00e7\u00e3o e \n\nparte da p\u00f3s-gradua\u00e7\u00e3o. Nesse grupo ocorreu grande parte da pesquisa e dos testes necess\u00e1rios \n\n\u00e0 realiza\u00e7\u00e3o deste trabalho. Tamb\u00e9m a Rodrigo Camarotti, ex-integrante do grupo e amigo, \n\npelo apoio. Sou grato a Abner Barros pelo apoio e pelas aulas sobre aritm\u00e9tica de ponto \n\nflutuante.  \n\n Sou grato a todos os colegas de trabalho do grupo Lincs e demais membros do \n\nCETENE que tamb\u00e9m compartilharam, nos mais diversos graus, dos momentos que fizeram \n\nesta disserta\u00e7\u00e3o se concretizar.  \n\n Agrade\u00e7o a meus amigos Marcelo, Gleybson e Elisvan pela for\u00e7a, amizade e \n\npaci\u00eancia prestadas durante essa etapa. Tamb\u00e9m pelas trilhas cicl\u00edsticas percorridas com o \n\ngrupo Polecats, fonte de muita inspira\u00e7\u00e3o para avan\u00e7ar em meus percursos. \n\n Reservo um singular agradecimento a Nathalia Gaspar pelo aux\u00edlio, apoio e carinho a \n\nmim reservados durante a elabora\u00e7\u00e3o deste trabalho. Sou grato pela presen\u00e7a e constante \n\ncompanheirismo, minha querida. \n\n Sou grato ao Cenpes e \u00e0 Petrobras pelo incentivo a pesquisa feito junto ao projeto \n\nHPCIn do Centro de Inform\u00e1tica da UFPE. \n\n Agrade\u00e7o a comunidade do Centro de Inform\u00e1tica da UFPE, o qual foi objeto de \n\nanos de dedica\u00e7\u00e3o. Aos professores, funcion\u00e1rios, pesquisadores e demais integrantes do \n\ncentro, os quais fizeram parte de minha forma\u00e7\u00e3o acad\u00eamica e humana durante essa \n\nimportante etapa de minha vida. \n\n\n\n \n\n \n\nResumo \n\n \nA computa\u00e7\u00e3o de alto desempenho est\u00e1 presente em diversos setores do \n\nconhecimento humano. Ela busca atender a demanda por solu\u00e7\u00f5es para problemas em \u00e1reas \n\ncomo bioinform\u00e1tica, petroqu\u00edmica, climatologia, dentre outros. Sabe-se que a grande maioria \n\ndessas \u00e1reas trabalha com quantidades massivas de dados, o que representa um desafio que a \n\ncomputa\u00e7\u00e3o deve constantemente superar. Dentre algumas solu\u00e7\u00f5es atualmente adotadas, \n\npodemos citar os Field Programmable Gate Arrays (FPGAs). Esses dispositivos permitem \n\nexplorar a computa\u00e7\u00e3o paralela com menor consumo de energia quando comparados a \n\nCentral Process Units (CPUs) e Graphic Process Units (GPUs). Al\u00e9m disso, os FPGAs \n\npermitem explorar o reuso de dados, o que possibilita o desenvolvimento de arquiteturas \n\ncomputacionais mais eficientes. Essas caracter\u00edsticas fazem dos FPGAs uma op\u00e7\u00e3o atraente \n\npara se desenvolver solu\u00e7\u00f5es para problemas que possuem uma alta demanda por \n\nprocessamento, como em aplica\u00e7\u00f5es cient\u00edficas. Essas aplica\u00e7\u00f5es normalmente fazem uso \n\nmassivo de n\u00fameros em ponto flutuante. Em 1977 o Institute of Electrical and Electronics \n\nEngineers (IEEE) prop\u00f5e a cria\u00e7\u00e3o do padr\u00e3o IEEE-754 para a implementa\u00e7\u00e3o da aritm\u00e9tica \n\nde ponto flutuante em base bin\u00e1ria. No entanto, o padr\u00e3o s\u00f3 foi conclu\u00eddo e lan\u00e7ado mais \n\ntarde, em 1985. Esse padr\u00e3o num\u00e9rico permite ao mesmo tempo tanto uma grande precis\u00e3o, \n\nquanto uma grande capacidade de representa\u00e7\u00e3o. O padr\u00e3o IEEE-754 passou a ser seguido \n\npelos fabricantes de computadores e desenvolvedores de software no tratamento da aritm\u00e9tica \n\nbin\u00e1ria computacional. A ind\u00fastria petrol\u00edfera faz uso massivo da aritm\u00e9tica de ponto \n\nflutuante para o mapeamento e gera\u00e7\u00e3o de imagem das camadas do subsolo para detec\u00e7\u00e3o de \n\npo\u00e7os de hidrocarbonetos. Um dos m\u00e9todos de imageamento s\u00edsmico que tem apresentando \n\nmelhores resultados em \u00e1reas com litologias mais complexas, tais como no pr\u00e9-sal, \u00e9 o \n\nalgoritmo Reverse Time Migration (RTM). Esse m\u00e9todo faz uso de uma aproxima\u00e7\u00e3o da \n\nequa\u00e7\u00e3o de onda por meio dos operadores de diferen\u00e7as finitas. Isso permite o mapeamento da \n\nvaria\u00e7\u00e3o dos campos de press\u00e3o e com isso se estimar as caracter\u00edsticas litol\u00f3gicas das \n\ncamadas em subsuperf\u00edcie. Contudo, o custo do RTM \u00e9 bastante elevado em termos \n\ncomputacionais. Por esse motivo, aplica\u00e7\u00f5es que otimizam desempenho ganham import\u00e2ncia \n\nno cen\u00e1rio de mapeamento s\u00edsmico do subsolo realizado pelas ind\u00fastrias petrol\u00edferas. Esta \n\ndisserta\u00e7\u00e3o aborda o desenvolvimento de um n\u00facleo aritm\u00e9tico h\u00edbrido capaz de resolver a \n\nequa\u00e7\u00e3o de diferen\u00e7as finitas presentes no algoritmo de RTM, em FPGA. Foram \n\ndesenvolvidos duas vers\u00f5es, uma totalmente em ponto flutuante padr\u00e3o IEEE-754 e outra \n\ntamb\u00e9m com nota\u00e7\u00e3o de ponto fixo para ganho de desempenho.  \n\n \n\nPalavras-chave: IEEE-754. HPC. RTM. FPGA.  \n\n \n\n\n\n \n\n \n\nAbstract \n\n \nThe high-performance computing is present in different sectors of human knowledge. \n\nIt seeks to meet the demand for solutions to problems in areas such as bioinformatics, \n\npetrochemical, climatology, among others. It is known that the vast majority of these areas \n\nwork with massive amounts of data, which is a challenge that the computational field should \n\nconstantly overcome. Among some currently adopted solutions, we can mention the Field \n\nProgrammable Gate Arrays (FPGAs). These devices allow exploit parallel computing with \n\nlower power consumption when compared to Central Process Units (CPUs) and Graphic \n\nProcess Units (GPUs). Furthermore, FPGAs allow explore the data reuse, which enables the \n\ndevelopment of more efficient computing architectures. These characteristics make FPGAs an \n\nattractive option to develop solutions to problems that have a high demand for processing, \n\nsuch as in scientific applications. These applications typically make heavy use of floating \n\npoint numbers. In 1977 the Institute of Electrical and Electronics Engineers (IEEE) proposes \n\nthe creation of the IEEE-754 standard for implementing floating-point arithmetic in binary \n\nbase. However, the standard was completed and released later in 1985. This numerical pattern \n\nallows the same time both a high precision, as a large capacity representation. The IEEE-754 \n\nstandard then began to be followed by software developers and computer makers in the \n\ntreatment of computer binary arithmetic. The oil industry makes massive use of floating-point \n\narithmetic for mapping and generating image of the subsurface layers to detect hydrocarbon \n\nwells. One of seismic imaging methods that have presented better results in areas with more \n\ncomplex lithologies, such as the pre-salt, is the Reverse Time Migration algorithm (RTM). \n\nThis method makes use of an approximation to the wave equation through the finite \n\ndifference operator. This allows mapping the variation of pressure fields and thereby estimate \n\nthe lithological characteristics of the layers in the subsurface. However, the cost of the RTM \n\nis computationally quite high. Therefore, applications that optimize performance gain \n\nimportance in the underground seismic mapping scenario performed by the oil industry. This \n\npaper discusses the development of a hybrid arithmetic core able to solve the equation of \n\nfinite differences present in the RTM algorithm in FPGA. Two versions, a fully floating point \n\nIEEE-754 standard and also with other fixed-point notation for performance gain were \n\ndeveloped. \n\n \n\nKeywords: HPC. IEEE-754. FPGA \n\n \n\n \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n\u00cdndice de Figuras \n \n\nFigura 1 - Ilustra\u00e7\u00e3o das camadas geol\u00f3gicas em subsuperf\u00edcie at\u00e9 a camada pr\u00e9-sal. ............ 17 \n\nFigura 2 - Ve\u00edculo de explora\u00e7\u00e3o marciana com dispositivos reconfigur\u00e1veis embarcados. ... 24 \n\nFigura 3 \u2013 Vis\u00e3o geral da arquitetura de uma FPGA ............................................................... 26 \n\nFigura 4 - Estrutura de um bloco l\u00f3gico ALM em um FPGA .................................................. 27 \n\nFigura 5 - Matriz de roteamento, Switch Matrix. ..................................................................... 28 \n\nFigura 6 - Representa\u00e7\u00e3o de n\u00fameros em ponto flutuante padr\u00e3o IEEE-754. ......................... 30 \n\nFigura 7 - Representa\u00e7\u00e3o adotada em Ponto Fixo. ................................................................... 32 \n\nFigura 8 - M\u00e9todo de reflex\u00e3o s\u00edsmica ..................................................................................... 47 \n\nFigura 9 - Simula\u00e7\u00e3o da propaga\u00e7\u00e3o de um pulso s\u00edsmico por um campo de press\u00e3o. ............ 49 \n\nFigura 10 - Equa\u00e7\u00e3o de propaga\u00e7\u00e3o da onda e suas respectivas matrizes de processamento .. 50 \n\nFigura 11 - Dados de entrada da equa\u00e7\u00e3o de diferen\u00e7as finitas no RTM ................................. 51 \n\nFigura 12 - Arquitetura de multiplica\u00e7\u00e3o de matrizes proposta por Young Dou. .................... 54 \n\nFigura 13 - Estrutura de Pipeline dos multiplicadores e acumuladores. .................................. 55 \n\nFigura 14 - Arquitetura e Pipe-line do Sistema de Barros A. C. .............................................. 58 \n\nFigura 15 - Fluxograma do processamento de dados s\u00edsmicos em (ROCHA, 2010). .............. 59 \n\nFigura 16 - Disposi\u00e7\u00e3o dos dados para processamento s\u00edsmico implementado por (ROCHA, \n\n2010). ........................................................................................................................................ 61 \n\nFigura 17 - Diagrama de blocos do N\u00facleo de Processamento Particionado utilizado por \n\n(ROCHA, 2010). ...................................................................................................................... 62 \n\nFigura 18 - Tempo de processamento da plataforma e do software compilado no Visual Studio \n\n2008 para o modelo de Marmousi obtidos por Rocha (2010). ................................................. 63 \n\nFigura 19 - Janela de Opera\u00e7\u00e3o em Hardware para 4 PE\u00b4s ...................................................... 68 \n\nFigura 20 - Plataforma ProcStarIV ........................................................................................... 69 \n\nFigura 21 - Vis\u00e3o geral da arquitetura dos PE\u00b4s. ...................................................................... 73 \n\nFigura 22 - Fluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o do PE .............................. 75 \n\nFigura 23 - Fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o do PE. ...................................... 76 \n\nFigura 24- Fluxo de execu\u00e7\u00e3o do normalizador_arredondador do PE. .................................... 78 \n\nFigura 25 - Fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de quadrado do PE. ............................................. 79 \n\nFigura 26 - N\u00famero de bits presentes na nota\u00e7\u00e3o half-float que armazena o termo de \n\nvelocidade. ................................................................................................................................ 82 \n\nFigura 27 - Arquitetura geral do BlocoMultiplica1. ................................................................. 83 \n\nFigura 28 - Arquitetura geral do BlocoVelFat.......................................................................... 85 \n\n\n\n \n\n \n\nFigura 29 - Arquitetura geral do BlocoMultiplica. ................................................................... 85 \n\nFigura 30 - Arquitetura geral do BlocoSomadorNormalizador. ............................................... 86 \n\nFigura 31 - Arquitetura geral do Bloco1 .................................................................................. 87 \n\nFigura 32 - Arquitetura geral do BlocoSomadorBijk. .............................................................. 89 \n\nFigura 33 - Arquitetura geral do BlocoSomadorBijk2 ............................................................. 90 \n\nFigura 34 - Representa\u00e7\u00e3o de -90 em ponto flutuante com o bit impl\u00edcito. ............................. 91 \n\nFigura 35 - Arquitetura geral do Bloco2 no PE Float............................................................... 92 \n\nFigura 36 - Representa\u00e7\u00e3o de 2 em ponto flutuante com o bit impl\u00edcito. ................................. 93 \n\nFigura 37 - Arquitetura geral do BlocoMultiplica2. ................................................................. 94 \n\nFigura 38 - Arquitetura geral do BlocoMultiplicaAbs. ............................................................ 95 \n\nFigura 39 - Arquitetura geral do BlocoMultiplica2Abs. .......................................................... 96 \n\nFigura 40 - Arquitetura geral do BlocoQuadradoAbs. ............................................................. 97 \n\nFigura 41 - Arquitetura do Bloco3 ........................................................................................... 98 \n\nFigura 42 - Fluxograma geral do Conversor_Float_Fixo. ...................................................... 102 \n\nFigura 43 - Fluxograma geral do M1Soma. ........................................................................... 103 \n\nFigura 44 - Fluxograma geral do M16Soma. ......................................................................... 104 \n\nFigura 45 - Representa\u00e7\u00e3o de -90 na nota\u00e7\u00e3o de ponto fixo utilizada. ................................... 104 \n\nFigura 46 - Fluxograma geral de execu\u00e7\u00e3o do M90. .............................................................. 105 \n\nFigura 47 - Fluxograma geral de execu\u00e7\u00e3o do MSoma1_16_90. ........................................... 105 \n\nFigura 48 - Arquitetura do Bloco2 do PE H\u00edbrido ................................................................. 107 \n\nFigura 49 - Metodologia de Verifica\u00e7\u00e3o................................................................................. 108 \n\nFigura 50 \u2013 Vis\u00e3o geral da arquitetura de testes. .................................................................... 113 \n\nFigura 51 - Vis\u00e3o geral da arquitetura do PE H\u00edbrido. ........................................................... 128 \n\nFigura 52 - Vis\u00e3o geral da arquitetura do PE Float ................................................................ 129 \n\nFigura 53 - Vis\u00e3o geral da arquitetura da Plataforma 3D para RTM em FPGA. ................... 130 \n\n \n\n  \n\n\n\n \n\n \n\nLista de Tabelas \n \n\nTabela 1 - Representa\u00e7\u00e3o de alguns n\u00fameros em ponto fixo. .................................................. 33 \n\nTabela 2 - Representa\u00e7\u00e3o de alguns n\u00fameros em ponto flutuante ........................................... 38 \n\nTabela 3 - Operandos em ponto flutuante separados em componentes para soma e subtra\u00e7\u00e3o.\n\n .................................................................................................................................................. 38 \n\nTabela 4 - Representa\u00e7\u00e3o de alguns n\u00fameros em ponto flutuante ........................................... 41 \n\nTabela 5 - Operandos em ponto flutuante separados em componentes para multiplica\u00e7\u00e3o ..... 41 \n\nTabela 6 - Representa\u00e7\u00e3o de valores especiais no padr\u00e3o IEEE-754 ....................................... 46 \n\nTabela 7 - Resultado de S\u00edntese do PE Float e PE H\u00edbrido para Stratix IV. .......................... 115 \n\nTabela 8 - Recursos utilizados pela plataforma RTM para uma Stratix IV. .......................... 116 \n\nTabela 9 - Recursos utilizados pela plataforma RTM em termos percentuais para uma Stratix \n\nIV. ........................................................................................................................................... 117 \n\n \n\n \n\n  \n\n\n\n \n\n \n\nSUM\u00c1RIO \n\n1. Introdu\u00e7\u00e3o ........................................................................................................................ 15 \n\n1.1. Motiva\u00e7\u00e3o ................................................................................................................. 17 \n\n1.2. Objetivos desta disserta\u00e7\u00e3o ..................................................................................... 20 \n\n1.3. Estrutura da Disserta\u00e7\u00e3o ......................................................................................... 21 \n\n2. Fundamenta\u00e7\u00e3o Te\u00f3rica ................................................................................................. 22 \n\n2.1 Computa\u00e7\u00e3o de alto desempenho em Hardware Reconfigur\u00e1vel. ...................... 23 \n\n2.2 FPGAs ....................................................................................................................... 25 \n\n2.3 Aritm\u00e9tica de Ponto Flutuante e Ponto Fixo ......................................................... 28 \n\n2.3.1 Padr\u00e3o IEEE-754 ................................................................................................ 29 \n\n2.3.2 Formato de representa\u00e7\u00e3o dos dados .................................................................. 30 \n\n2.3.3 Nota\u00e7\u00e3o de Ponto Fixo ....................................................................................... 31 \n\n2.3.4 Algoritmos de Soma e Subtra\u00e7\u00e3o em Ponto Fixo ............................................... 33 \n\n2.3.5 Algoritmo de Multiplica\u00e7\u00e3o em Ponto Fixo ....................................................... 34 \n\n2.3.6 Algoritmo de Arredondamento em Ponto Fixo .................................................. 36 \n\n2.3.7 Nota\u00e7\u00e3o de Ponto Flutuante ................................................................................ 36 \n\n2.3.8 Algoritmos de Soma e Subtra\u00e7\u00e3o em Ponto Flutuante ....................................... 37 \n\n2.3.9 Algoritmo de Multiplica\u00e7\u00e3o em Ponto Flutuante ............................................... 40 \n\n2.3.10 Algoritmo de Normaliza\u00e7\u00e3o ............................................................................... 43 \n\n2.3.11 Algoritmo de Arredondamento ........................................................................... 44 \n\n2.3.12 Representa\u00e7\u00e3o de valores especiais .................................................................... 45 \n\n2.4 Algoritmo de An\u00e1lises S\u00edsmicas do Solo - RTM .................................................... 46 \n\n2.5 Conclus\u00f5es ................................................................................................................ 51 \n\n3. Trabalhos relacionados ................................................................................................... 53 \n\n3.1 64 bit Floating Point FPGA Matrix Multiplication - Dou, Yong; Vassiliadis, S.; \n\nKuzmanov (2005). ............................................................................................................... 54 \n\n3.1.1 Conclus\u00f5es .......................................................................................................... 56 \n\n3.2 Implementa\u00e7\u00e3o em FPGA de um modulo multiplicador aritm\u00e9tico de alto \n\ndesempenho para n\u00fameros de ponto flutuante de dupla precis\u00e3o, padr\u00e3o IEEE-754 \u2013 \n\nBarros A. C., Barbosa J. e Lima M. E (2008) ................................................................... 56 \n\n3.2.1 Conclus\u00f5es .......................................................................................................... 58 \n\n\n\n \n\n \n\n3.3 Modelagem de uma Plataforma Reconfigur\u00e1vel para modelagem 2D, em \n\nS\u00edsmica, Utilizando FPGA - Rocha, Rodrigo C. F. (2010). ............................................. 59 \n\n3.3.1 Conclus\u00f5es .......................................................................................................... 63 \n\n3.4 Trabalhos relacionados gerais. ............................................................................... 64 \n\n3.5 Conclus\u00f5es ................................................................................................................ 65 \n\n4. Plataforma para modelagem 3D do algoritmo de RTM em FPGA ............................ 66 \n\n4.1 Ambiente de implementa\u00e7\u00e3o ................................................................................... 67 \n\n5. Um N\u00facleo aritm\u00e9tico para execu\u00e7\u00e3o de um operador de diferen\u00e7as finitas em \n\nFPGA ....................................................................................................................................... 70 \n\n5.1 Vis\u00e3o Geral ............................................................................................................... 71 \n\n5.1.1 Conversor ........................................................................................................... 73 \n\n5.1.2 Somador .............................................................................................................. 74 \n\n5.1.3 Multiplicador ...................................................................................................... 75 \n\n5.1.4 Normalizador_Arredondador ............................................................................. 77 \n\n5.1.5 Quadrado ............................................................................................................ 78 \n\n5.1.6 Arredondador ...................................................................................................... 80 \n\n5.1.7 FIFOs .................................................................................................................. 80 \n\n5.2 PE Float .................................................................................................................... 80 \n\n5.2.1 Bloco1 ................................................................................................................. 81 \n\n5.2.1.1 BlocoMultiplica1 ............................................................................................ 82 \n\n5.2.1.2 BlocoVelFat .................................................................................................... 84 \n\n5.2.1.3 BlocoMultiplica .............................................................................................. 84 \n\n5.2.1.4 BlocoSomadorNormalizador .......................................................................... 86 \n\n5.2.2 Bloco2 ................................................................................................................. 88 \n\n5.2.2.1 BlocoSomadorBijk .......................................................................................... 88 \n\n5.2.2.2 BlocoSomadorBijk2 ........................................................................................ 89 \n\n5.2.2.3 BlocoMultiplica90 .......................................................................................... 90 \n\n5.2.2.4 BlocoSomadorNormalizador .......................................................................... 91 \n\n5.2.3 Bloco3 ................................................................................................................. 92 \n\n5.2.3.1 BlocoMultiplica2 ............................................................................................ 93 \n\n5.2.3.2 BlocoMultiplicaAbs ........................................................................................ 94 \n\n5.2.3.3 BlocoMultiplica2Abs ...................................................................................... 95 \n\n5.2.3.4 BlocoQuadradoAbs ......................................................................................... 96 \n\n\n\n \n\n \n\n5.2.3.5 BlocoMultiplica .............................................................................................. 97 \n\n5.2.3.6 BlocoSomadorNormalizador .......................................................................... 99 \n\n5.3 PE H\u00edbrido ................................................................................................................ 99 \n\n5.3.1 Bloco2 ............................................................................................................... 100 \n\n5.3.1.1 Conversor_Float_Fixo .................................................................................. 100 \n\n5.3.1.2 M1Soma ........................................................................................................ 102 \n\n5.3.1.3 M16Soma ...................................................................................................... 103 \n\n5.3.1.4 M90 ............................................................................................................... 104 \n\n5.3.1.5 MSoma1_16_90 ............................................................................................ 105 \n\n5.3.1.6 Conversor_Fixo_Float .................................................................................. 106 \n\n5.4 Metodologia de Desenvolvimento ......................................................................... 107 \n\n5.4.1 Modelo Can\u00f4nico ............................................................................................. 108 \n\n5.4.2 Modelo de Linguagem de Alto N\u00edvel ............................................................... 109 \n\n5.4.3 Modelo em Linguagem HDL ............................................................................ 110 \n\n5.4.4 Testbench .......................................................................................................... 111 \n\n5.5 Conclus\u00f5es .............................................................................................................. 113 \n\n6. Resultados ...................................................................................................................... 114 \n\n6.1 Resultados de S\u00edntese para uma FPGA Stratix IV da Altera ............................ 115 \n\n6.2 Resultados obtidos na plataforma para modelagem 3D do algoritmo de RTM \n\nem FPGA ........................................................................................................................... 116 \n\n7. Conclus\u00f5es e Trabalhos Futuros .................................................................................. 119 \n\n8. Refer\u00eancias. .................................................................................................................... 122 \n\n9. Anexos. ........................................................................................................................... 127 \n\n9.1    ANEXO I - Arquitetura do PE H\u00edbrido ................................................................. 128 \n\n9.2    ANEXO II - Arquitetura do PE Float .................................................................... 129 \n\n9.3    ANEXO III - Arquitetura do RTM............................................................................ 130 \n\n  \n\n\n\n \n\n \n\nLista de Abreviaturas e Siglas \n\n \n\nALM  Adaptative Logic Module    \n\nALUT  Adaptative Look-Up Table    \n\nASIC  Application Specific Integrated  Circuits    \n\nCENPES  Centro de Pesquisas e Desenvolvimento da Petrobras  \n\nCIN  Centro de Inform\u00e1tica da UFPE  \n\nCLB  Configurable Logic Block    \n\nCPU  Central Process Unit    \n\nDSP  Digital Signal Processor    \n\nDUV  Device Under Verification    \n\nEEPROM  Electrically-Erasable Programmable Read-Only Memory    \n\nFIFO  Firs in, First Out    \n\nFIR  Finite Impulse Response    \n\nFPGA  Field Programmable Gate Arrays     \n\nFPU  Floating Point Unit    \n\nGFLOPS  Giga Floating-Point Operations Per Second   \n\nGPU  Graphic Processing Unit      \n\nHDL  Hardware Description Language     \n\nHPC  High Performance Computing    \n\nHPCIn  High Performance Computing CIn-UFPE     \n\nIEEE  Institute of Electrical and Electronics Engineers   \n\nLUT  Look Up Table    \n\nMAC  Multiplier And Accumulator      \n\nMLAB  Memory Logic Array Block    \n\nNAN  Not A Number     \n\nOpenCL  Open Computing Language     \n\nPE  Process Element      \n\nPLL  Phase-Locked Loop    \n\nRAM  Random Access Memory    \n\nROM  Read-Only Memory     \n\nRTL  Resistor\u2013transistor logic     \n\nRTM  Reverse Time Migration     \n\nSNR  Signal-to-Noise Ratio     \n\n\n\n \n\n \n\nSPMD  Single Program Multiple Data    \n\nSRAM  Static Random Access Memory   \n\nUFPE  Universidade Federal de Pernambuco   \n\nUQI  Universal Quality Index   \n\nVHDL  VHSIC Hardware Description Language   \n\nVHSIC  Very High Speed Integrated Circuit   \n\nXOR  Exclusive OR  \n\n       \n\n       \n\n \n\n \n\n\n\n15 \n\n \n\n \n\n \n\n \n\nCap\u00edtulo \n\n1 \n1. Introdu\u00e7\u00e3o \n\n \n\n \n\nEste cap\u00edtulo contextualiza o tema abordado nesta disserta\u00e7\u00e3o, no campo da  \n\ncomputa\u00e7\u00e3o cient\u00edfica, e seu impacto no desenvolvimento de arquiteturas computacionais \n\ncustomizadas, em problemas que  requeiram processamento aritm\u00e9tico com precis\u00e3o e  alto \n\ndesempenho computacional, com \u00eanfase a problemas de imageamento s\u00edsmico utilizando o \n\nalgoritmo RTM (Reverse Timing Migration). \n\n \n\n \n\n  \n\n\n\n16 \n\n \n\n \n\nA ind\u00fastria petrol\u00edfera ainda \u00e9 uma das mais atuantes e estrat\u00e9gicas como fonte \n\nenerg\u00e9tica em todo o mundo. Sua mat\u00e9ria prima, o petr\u00f3leo, pode ser encontrada em \n\ndiferentes \u00e1reas do planeta, seja em terra ou nas profundezas de nossos oceanos, com \n\ndiferentes n\u00edveis de dificuldades de capta\u00e7\u00e3o. Com a demanda crescente pelo consumo, custos \n\noscilantes no mercado internacional, a necessidade por se dominar a tecnologia de prospec\u00e7\u00e3o \n\ndeste min\u00e9rio se torna estrat\u00e9gica para pa\u00edses continentais como o Brasil.  Esta tecnologia \n\nenvolve n\u00e3o s\u00f3 equipamentos de perfura\u00e7\u00e3o e retirada de petr\u00f3leo, mas sobretudo ferramentas \n\ncomputacionais que permitem, com precis\u00e3o, estabelecer a localiza\u00e7\u00e3o correta destes \n\nreservat\u00f3rios.  \n\n  Particularmente no processo de descoberta de reservat\u00f3rios de \u00f3leo e g\u00e1s, atrav\u00e9s \n\ndo uso de t\u00e9cnicas de imageamento e modelagem em s\u00edsmica, por exemplo, \u00e9 poss\u00edvel se \n\nmapear com precis\u00e3o, camadas geol\u00f3gicas de uma determinada regi\u00e3o em busca destes \n\ncomponentes. Por\u00e9m, para que este estudo detalhado do subsolo ocorra da melhor maneira \n\nposs\u00edvel, faz-se necess\u00e1ria a aquisi\u00e7\u00e3o e a an\u00e1lise de uma grande quantidade de dados, com \n\nqualidade e em tempo h\u00e1bil.  \n\nO tratamento inadequado de imagens s\u00edsmicas pode promover a perfura\u00e7\u00e3o de po\u00e7os \n\nem regi\u00f5es equivocadas, acarretando um preju\u00edzo de milh\u00f5es de d\u00f3lares para as empresas \n\nexploradores. O fator tempo tamb\u00e9m \u00e9 importante, desde que a inclus\u00e3o de um novo po\u00e7o na \n\nlinha de produ\u00e7\u00e3o garante a oferta e a estabilidade do produto no mercado. Portanto, a \n\nprecis\u00e3o com que os dados s\u00e3o tratados e o poder computacional para process\u00e1-los, tornam-se \n\nfatores cruciais para o desenvolvimento da ind\u00fastria e da explora\u00e7\u00e3o de \u00f3leo e g\u00e1s. \n\nCom a demanda cada vez maior pelo mercado consumidor, a ser suprida por \n\ncombust\u00edveis fosseis, tornou-se necess\u00e1rio a busca por po\u00e7os cada vez mais distantes, em \n\n\u00e1reas  com uma geologia, muitas vezes,  bem mais complexa que as at\u00e9 ent\u00e3o exploradas. No \n\nBrasil, por exemplo, tal fen\u00f4meno aconteceu com a descoberta de dep\u00f3sitos de \n\nhidrocarbonetos como a do pr\u00e9-sal\n1\n, feitas pela Petrobras (2015), a profundidades de at\u00e9 \n\n7000m. Tal descoberta, embora parecesse resolver todos os problemas de abastecimento,  \n\nexigia no entanto,  uma s\u00e9rie de investimentos, seja em equipamentos de prospec\u00e7\u00e3o, seja na \n\nforma de tratar matematicamente os novos  modelos geol\u00f3gicos que agora se faziam \n\npresentes. Tinha-se camadas geol\u00f3gicas bem diferentes das dos po\u00e7os anteriores; camadas \n\nespessas de sal,  forma\u00e7\u00f5es rochosas irregulares, etc. Como tratar tudo isso de maneira precisa \n\ne na velocidade desejada de mercado foi sem d\u00favida o grande desafio para empresas como a \n\n                                                 \n1\n O pr\u00e9-sal \u00e9 uma sequ\u00eancia de rochas sedimentares formadas h\u00e1 mais de 100 milh\u00f5es de anos sob uma camada \n\nde sal rica em hidrocarbonetos (petr\u00f3leo e g\u00e1s natural). PETROBRAS. 2015.  \n\n\n\n17 \n\n \n\n \n\nPetrobras (PETROBRAS, 2015).  A figura 1 ilustra simplificadamente, um corte geol\u00f3gico \n\ncom as camadas de subsuperf\u00edcie mais externas at\u00e9 a camada do pr\u00e9-sal. \n\n \n\nFigura 1 - Ilustra\u00e7\u00e3o das camadas geol\u00f3gicas em subsuperf\u00edcie at\u00e9 a camada pr\u00e9-sal. \n\n \n\n \n\nFonte: G1, 2010. \n\n  \n\n Do ponto de vista de investimento e de mercado, n\u00e3o adianta ter-se equipamentos \n\nsofisticados de perfura\u00e7\u00e3o de po\u00e7os, se n\u00e3o h\u00e1 uma precis\u00e3o adequada de onde est\u00e3o estes \n\npo\u00e7os comercialmente interessantes, que garantem retorno financeiro adequado. Neste sentido \n\n\u00e9 fundamental o desenvolvimento de algoritmos de modelagem s\u00edsmica que garantam com \n\nprecis\u00e3o as posi\u00e7\u00f5es a serem consideradas na perfura\u00e7\u00e3o destes po\u00e7os.  \n\n  \n\n1.1. Motiva\u00e7\u00e3o \n\n \n\n A modelagem s\u00edsmica \u00e9 um processo computacional, desenvolvido a partir de \n\nalgoritmos complexos que, em geral, requer o processamento de uma grande quantidade de \n\ndados. Tal caracter\u00edstica a torna uma opera\u00e7\u00e3o computacionalmente custosa, exigindo \n\nexpertise no tratamento, precis\u00e3o e processamento destes dados, para se obter uma an\u00e1lise \n\nconsistente de seus resultados.   \n\nQuanto mais precisa a opera\u00e7\u00e3o, mais probabilidade de se encontrar um novo po\u00e7o \n\npromissor para explora\u00e7\u00e3o. Quanto mais recursos computacionais mais possibilidade de se \n\nrefinar o processo, atacar maiores \u00e1reas de explora\u00e7\u00e3o e de visualiza\u00e7\u00e3o do terreno e reduzir \n\ntempo de processamento. \n\n\n\n18 \n\n \n\n \n\n Como dito acima, a medida que se vai explorando regi\u00f5es mais profundas, como a \n\nque encontramos na  regi\u00e3o do pr\u00e9-sal, novas abordagens precisam ser feitas para se garantir \n\nprecis\u00e3o nos resultados da modelagem. Observou-se que algoritmos de modelagem existentes, \n\nque processavam de forma adequada terrenos de menor profundidade e com uma geologia \n\nmais regular que o do pr\u00e9-sal, n\u00e3o eram adequados ao processamento deste novo desafio.   \n\nEntre os algoritmos tradicionais utilizados na modelagem s\u00edsmica podemos destacar: Pre-stack \n\nKirchhoff Time Migration (PSTM), Phase Shift Plus Interpolation (PSPI) e o Reverse Time Migration \n\n(RTM) (BARROS, 2014).  \n\n O algoritmo PSTM permite o imageamento de camadas abaixo da superf\u00edcie com \n\numa qualidade aceit\u00e1vel e a um custo computacional bem mais acess\u00edvel que o algoritmo  \n\nRTM. Esse custo de execu\u00e7\u00e3o \u00e9 cerca de 15 vezes menor que o RTM (SANTOS, 2012). No \n\nentanto, os algoritmos baseados em Kirchhoff n\u00e3o s\u00e3o adequados para regi\u00f5es que possuem \n\nestruturas geol\u00f3gicas muito complexas (PGS, 2007).  \n\n O algoritmo RTM, por outro lado, \u00e9 o algoritmo que tem apresentado os melhores \n\nresultados em regi\u00f5es de litologia mais complexa, como no pr\u00e9-sal, raz\u00e3o pela qual vem sendo  \n\namplamente utilizado na explora\u00e7\u00e3o de petr\u00f3leo nestas regi\u00f5es (SANTOS, 2012) (MEDEIROS, \n\n2013). Este algoritmo resolve diretamente a equa\u00e7\u00e3o da onda ac\u00fastica/el\u00e1stica, com resultados \n\nbem mais precisos em terrenos complexos (ROCHA, 2010). Seu processamento requer, no \n\nentanto, uma alta capacidade computacional e de armazenamento de dados, bem superior aos \n\ndemais modelos. Gra\u00e7as a evolu\u00e7\u00e3o e oferta de supercomputadores e processamento massivo \n\nem grids, este tipo de abordagem em modelagem s\u00edsmica, seja 2D ou 3D se torna uma \n\nrealidade. Uma discuss\u00e3o detalhada deste algoritmo \u00e9 realizada no cap\u00edtulo 2 desta \n\ndisserta\u00e7\u00e3o. \n\nA computa\u00e7\u00e3o cient\u00edfica de alto desempenho vem cada vez mais sendo explorada e \n\ndifundida em diferentes tecnologias e estilos de projeto. Nesse tipo de computa\u00e7\u00e3o, \n\narquiteturas totalmente customizadas como ASICs (Smith, 1997), program\u00e1veis, como Multi-\n\ncore (Intel, 2015) e GPUs (NVIDIA, 2015) e reconfigurareis como  FPGAs (NAVABI, 2007), \n\nencontram grande espa\u00e7o para aplica\u00e7\u00f5es, cada qual com sua caracter\u00edsticas,  vantagens e \n\ndesvantagens. Dentre elas, a tecnologia FPGA tem ganho destaque, devido a sua capacidade \n\nde reconfigura\u00e7\u00e3o, explora\u00e7\u00e3o de paralelismo e possibilidade de desenvolvimento de n\u00facleos \n\nde processamento, que realizam opera\u00e7\u00f5es customizadas, e de alto desempenho.  \n\nParticularmente, com rela\u00e7\u00e3o ao uso dos FPGAs para o processamento de dados \n\ns\u00edsmicos, diversos trabalhos publicados nestes \u00faltimos anos t\u00eam buscado destacar suas \n\nvantagens. Esses trabalhos destacam os benef\u00edcios no desempenho de execu\u00e7\u00e3o de algoritmos \n\n\n\n19 \n\n \n\n \n\ne no consumo de energia, pela ado\u00e7\u00e3o de padr\u00f5es especiais na representa\u00e7\u00e3o num\u00e9rica de \n\ndados (BARROS et al., 2011; MEDEIROS et al., 2013; BRAGAN\u00c7A\n \net al., 2013). Isso \n\ndemonstra a relev\u00e2ncia que a representa\u00e7\u00e3o num\u00e9rica adotada possui para a computa\u00e7\u00e3o de \n\nalto desempenho.  \n\nA representa\u00e7\u00e3o num\u00e9rica em geral adotada em problemas de modelagem em \n\ns\u00edsmica \u00e9 aquela presente na nota\u00e7\u00e3o em ponto flutuante, segundo o padr\u00e3o IEEE-754. Esse \n\npadr\u00e3o determina como s\u00e3o operados e representados os n\u00fameros reais em sistemas \n\ncomputacionais. Ele ficou conhecido como padr\u00e3o de n\u00fameros em ponto-flutuante devido \u00e0 \n\nmaneira como esses n\u00fameros s\u00e3o representados (BARROS, 2008).  \n\nNo entanto, n\u00e3o s\u00f3 as opera\u00e7\u00f5es com n\u00fameros em ponto flutuante encontram espa\u00e7o \n\nnos sistemas computacionais. N\u00fameros em ponto fixo e suas opera\u00e7\u00f5es aritm\u00e9ticas tamb\u00e9m \n\npodem ser utilizados a depender das restri\u00e7\u00f5es de precis\u00e3o e custo computacional. Isso ocorre \n\nporque algumas opera\u00e7\u00f5es aritm\u00e9ticas em nota\u00e7\u00e3o de ponto fixo s\u00e3o menos custosas quando \n\ncomparadas a opera\u00e7\u00f5es em ponto flutuante.  \n\nDe fato, pode-se ainda, visando requisitos tais como: redu\u00e7\u00e3o de \u00e1rea f\u00edsica de \n\nelementos de processamento, dissipa\u00e7\u00e3o de pot\u00eancia, precis\u00e3o customizada, desenvolver \n\nelementos de processamento h\u00edbridos, customizados, com o melhor das caracter\u00edsticas das \n\nnota\u00e7\u00f5es aritm\u00e9ticas acima mencionadas.  \n\nNeste contexto, tecnologias reconfigur\u00e1veis, como as fornecidas pelas FPGAs, \n\npermitem que se tenha, para cada nova abordagem do usu\u00e1rio, uma nova configura\u00e7\u00e3o \n\ncustomizada para seus elementos de processamento. \n\nEste novo paradigma \u00e9 completamente diferente daqueles encontradas em \n\ntecnologias multi-core, em CPUs de prop\u00f3sito geral, ou em GPUs, onde estes possuem \n\nn\u00facleos aritm\u00e9ticos com funcionalidades fixas, com diversos tipos de opera\u00e7\u00f5es aritm\u00e9ticas \n\ndiferentes, previamente implementadas, sem customiza\u00e7\u00f5es program\u00e1veis em hardware.   \n\nFazer uso de unidades aritm\u00e9ticas customizadas para atender um problema \n\nespec\u00edfico permite, em um primeiro momento, reduzir-se a quantidade de componentes de \n\nhardware que s\u00e3o usados para sua implementa\u00e7\u00e3o. No caso de n\u00facleos aritm\u00e9ticos \n\ndesenvolvidos para um algoritmo espec\u00edfico, em FPGA, provoca a economia de hardware por \n\nn\u00facleo e por consequ\u00eancia, a gera\u00e7\u00e3o de uma maior quantidade de n\u00facleos por dispositivo. \n\nIsso aumenta a quantidade de opera\u00e7\u00f5es que podem ser feitas em paralelo e, por conseguinte, \n\no desempenho computacional final do algoritmo.  \n\nEste aumento no n\u00famero de n\u00facleos de processamento pode acarretar por\u00e9m,  alguns \n\nproblemas n\u00e3o desej\u00e1veis, como o limite de acesso a mem\u00f3ria dispon\u00edvel, etc. Este aspecto, \n\n\n\n20 \n\n \n\n \n\nal\u00e9m da an\u00e1lise do consumo de energia dos elementos de processamento n\u00e3o s\u00e3o abordados \n\nnesta disserta\u00e7\u00e3o.   \n\nO estudo das nota\u00e7\u00f5es aritm\u00e9ticas de ponto flutuante e de ponto fixo, associado \u00e0 \n\npossibilidade de se desenvolver um hardware customizado, permitiu a implementa\u00e7\u00e3o de um \n\nn\u00facleo aritm\u00e9tico espec\u00edfico, em hardware, utilizando a tecnologia FPGA, capaz de resolver a \n\nequa\u00e7\u00e3o de modelagem s\u00edsmica 3D,  pelo m\u00e9todo RTM. Otimiza\u00e7\u00f5es nesses n\u00facleos levaram \n\nem conta o processamento de dados em ambas as representa\u00e7\u00f5es aritm\u00e9ticas citadas acima, \n\nsem, no entanto, acarretar perda de precis\u00e3o para o problema da s\u00edsmica. Este esfor\u00e7o resultou \n\nna redu\u00e7\u00e3o de \u00e1rea ocupada por cada n\u00facleo aritm\u00e9tico, e consequentemente, um maior \n\nn\u00famero de n\u00facleos pode ser alocado no FPGA.  Esta estrat\u00e9gia permitiu um maior paralelismo \n\nna execu\u00e7\u00e3o do algoritmo e redu\u00e7\u00e3o de tempo em sua execu\u00e7\u00e3o. \n\n \n\n1.2. Objetivos desta disserta\u00e7\u00e3o \n\n \n\nO objetivo desta disserta\u00e7\u00e3o \u00e9 o desenvolvimento de um n\u00facleo aritm\u00e9tico h\u00edbrido \n\ncapaz de calcular a aproxima\u00e7\u00e3o da equa\u00e7\u00e3o de onda utilizada no algoritmo de RTM, abordada \n\nem (Medeiros, 2013), em um FPGA. Esse n\u00facleo deve trabalhar com n\u00fameros em formato de \n\nponto flutuante padr\u00e3o IEEE-754.  \n\nA fim de comparar desempenho, foram desenvolvidos dois n\u00facleos aritm\u00e9ticos. O \n\nprimeiro deles realiza opera\u00e7\u00f5es aritm\u00e9ticas de acordo com as normas definidas para o ponto \n\nflutuante no padr\u00e3o IEEE-754. A segunda vers\u00e3o, a vers\u00e3o h\u00edbrida do n\u00facleo aritm\u00e9tico, \n\nefetua internamente opera\u00e7\u00f5es na nota\u00e7\u00e3o de ponto flutuante e em nota\u00e7\u00e3o de ponto fixo. As \n\nvers\u00f5es ser\u00e3o comparadas tanto em rela\u00e7\u00e3o ao custo de ocupa\u00e7\u00e3o de elementos l\u00f3gicos \n\ndispon\u00edveis para FPGA, quanto \u00e0 precis\u00e3o dos resultados num\u00e9ricos apresentados. A vers\u00e3o \n\nh\u00edbrida deve obedecer aos crit\u00e9rios de precis\u00e3o exigidos para o algoritmo e, com isso, ser \n\ncapaz de substituir a vers\u00e3o em ponto flutuante no algoritmo de RTM sem perda de precis\u00e3o \n\nsignificativa\n2\n. \n\nOs n\u00facleos aritm\u00e9ticos, em suas duas vers\u00f5es, foram implementados na arquitetura \n\nproposta pelo projeto HPCIn, do Centro de Inform\u00e1tica da UFPE, em parceria com o Centro \n\nde Pesquisa e Desenvolvimento da Petrobras (CENPES). O projeto HPCIn teve como \n\nobjetivo, gerar imagens das camadas do subsolo para explora\u00e7\u00e3o de \u00f3leo e g\u00e1s atrav\u00e9s da \n\nexecu\u00e7\u00e3o do algoritmo de an\u00e1lises s\u00edsmicas RTM 3D. A arquitetura proposta foi \n\n                                                 \n2\n A precis\u00e3o definida para o modelo do algoritmo RTM exigido pelo Centro de pesquisa da Petrobr\u00e1s (CENPES) \n\nno projeto HPCIN, do Centro de Inform\u00e1tica da UFPE foi da ordem de 10\n-6\n\n \n\n\n\n21 \n\n \n\n \n\nimplementada em uma linguagem de descri\u00e7\u00e3o de hardware, System Verilog () para \n\ndispositivos reconfigur\u00e1veis, FPGAs. \n\n \n\n1.3. Estrutura da Disserta\u00e7\u00e3o \n\n \n\nInicialmente, no cap\u00edtulo 1, foi feita uma contextualiza\u00e7\u00e3o do tema da disserta\u00e7\u00e3o e \n\ndiscutidos os t\u00f3picos que motivaram seu desenvolvimento.  No cap\u00edtulo 2 s\u00e3o abordados os \n\nfundamentos te\u00f3ricos necess\u00e1rios para a compreens\u00e3o deste trabalho. O cap\u00edtulo 3 \u00e9 dedicado \n\n\u00e0 discuss\u00e3o de trabalhos relacionados ao tema do projeto, suas vantagens, desvantagens, \n\nlimites e compara\u00e7\u00f5es. No cap\u00edtulo 4 \u00e9 apresentado em detalhes as arquiteturas das duas \n\nvers\u00f5es de n\u00facleos de processamento; a totalmente implementada na vers\u00e3o padr\u00e3o  ponto-\n\nflutuante e a versa h\u00edbrida. Neste cap\u00edtulo tamb\u00e9m s\u00e3o discutidos todos os m\u00f3dulos e sub-\n\nm\u00f3dulos dos n\u00facleos aritm\u00e9ticos, metodologia de testes e desenvolvimento, al\u00e9m dos \n\nresultados de s\u00edntese para uma FPGA que foi usada para valida\u00e7\u00e3o destes  n\u00facleos aritm\u00e9ticos. \n\nNo cap\u00edtulo 5 \u00e9 apresentado o caso de uso no qual os n\u00facleos aritm\u00e9ticos foram utilizados, a \n\nsaber: a modelagem s\u00edsmica 3D utilizando o algoritmo RTM. O cap\u00edtulo 6 apresenta as \n\nconclus\u00f5es e futuros trabalhos. As refer\u00eancias bibliogr\u00e1ficas s\u00e3o elencadas no cap\u00edtulo 7. O \n\ncap\u00edtulo 8 corresponde aos anexos do projeto, que dizem respeito as estruturas dos m\u00f3dulos \n\nda arquitetura. \n\n \n\n \n\n \n\n \n\n \n\n\n\n22 \n\n \n\n \n\nCap\u00edtulo \n\n2 \n2. Fundamenta\u00e7\u00e3o Te\u00f3rica \n\n \n\n \n\nEsta se\u00e7\u00e3o discute os conhecimentos b\u00e1sicos que nortearam a elabora\u00e7\u00e3o deste \n\ntrabalho. Aqui foi realizada uma revis\u00e3o sobre computa\u00e7\u00e3o de alto desempenho com \u00eanfase \n\nnas aplica\u00e7\u00f5es com FPGAs, na plataforma de desenvolvimento utilizada. Tamb\u00e9m \u00e9 abordada \n\na padroniza\u00e7\u00e3o aritm\u00e9tica e o formato de ponto flutuante utilizado no m\u00f3dulo de \n\nprocessamento. \n\n \n\n \n\n  \n\n\n\n23 \n\n \n\n \n\n2.1 Computa\u00e7\u00e3o de alto desempenho em Hardware Reconfigur\u00e1vel. \n\n \n\nDispositivos capazes de realizar computa\u00e7\u00e3o est\u00e3o cada vez mais presentes em nosso \n\ncotidiano. Esses dispositivos s\u00e3o gradativamente mais exigidos em termos de capacidade de \n\nprocessamento com o avan\u00e7o natural da tecnologia e suas aplica\u00e7\u00f5es. Essa tend\u00eancia se \n\nmant\u00e9m tamb\u00e9m quando falamos em computa\u00e7\u00e3o de alto desempenho.  \n\nA demanda por maior velocidade e efici\u00eancia em aplica\u00e7\u00f5es com opera\u00e7\u00f5es \n\nmassivas de dados exige cada vez mais dos equipamentos que as realizam. A computa\u00e7\u00e3o de \n\nalto desempenho est\u00e1 diretamente relacionada com as aplica\u00e7\u00f5es que requerem m\u00e1quinas com \n\nalto poder computacional e mem\u00f3ria, tais como: biotecnologia, climatologia, economia, \n\nind\u00fastria aeron\u00e1utica, petroqu\u00edmica, processamento gr\u00e1fico, entre outras.  \n\nV\u00e1rias arquiteturas t\u00eam sido utilizadas no desenvolvimento de solu\u00e7\u00f5es visando \n\nprocessamento de alto desempenho. Pode-se destacar os dispositivos l\u00f3gicos reconfigur\u00e1veis, \n\nos FPGAs como uma arquitetura voltada para explora\u00e7\u00e3o de alto desempenho.  \n\nOs FPGAs possuem car\u00e1ter intrinsecamente paralelo e permitem explorar uma \n\ngrande capacidade computacional. Essas duas caracter\u00edsticas, juntamente com a \n\nbaixa frequ\u00eancia em que operam, permitem explorar diversas aplica\u00e7\u00f5es a um baixo \n\ncusto energ\u00e9tico. Contudo, o desenvolvimento de aplica\u00e7\u00f5es em FPGA ainda \u00e9 \n\ncustoso em termos de tempo de desenvolvimento, muitas vezes se tornando \n\nincompat\u00edvel com a necessidade da ind\u00fastria (MEDEIROS, 2013). \n\nDe maneira similar aos FPGAs, os Application Specific Integrated Circuits (ASIC) \n\nimplementam as fun\u00e7\u00f5es l\u00f3gicas como componentes diretamente implementadas em hardware \n\n(SMITH, 1997). Os ASICs s\u00e3o dispositivos desenvolvidos e otimizados para apenas um \u00fanico \n\nprop\u00f3sito. Em geral, estes dispositivos possuem um custo por unidade menor quando feitos \n\nem larga escala e podem atingir frequ\u00eancias de opera\u00e7\u00e3o mais altas, ou seja, permitem uma \n\nmaior velocidade na execu\u00e7\u00e3o de uma tarefa espec\u00edfica. Eles podem ser utilizados para alguns \n\nproblemas em computa\u00e7\u00e3o de alto desempenho, levando-se em considera\u00e7\u00e3o que s\u00e3o \n\notimizados para a execu\u00e7\u00e3o de um conjunto espec\u00edfico de tarefas. Por\u00e9m, justamente por \n\nserem voltados para a execu\u00e7\u00e3o de um conjunto restrito de opera\u00e7\u00f5es, n\u00e3o possuem um \n\nm\u00ednimo de flexibilidade que muitas aplica\u00e7\u00f5es computacionais exigem. Como exemplo de \n\numa aplica\u00e7\u00e3o onde os ASIC\u00b4s possuem seu uso limitado, pode-se citar um ve\u00edculo de \n\n\n\n24 \n\n \n\n \n\nexplora\u00e7\u00e3o de Marte denominado Curiosity da NASA\n3\n. Esse ve\u00edculo possui uma demanda por \n\naltera\u00e7\u00f5es de programa\u00e7\u00e3o e atualiza\u00e7\u00f5es em n\u00edvel de hardware mesmo depois de \n\ndesembarcado em solo marciano, o que se tornaria imposs\u00edvel com o uso de ASIC\u00b4s. Com \n\nisso, o ve\u00edculo foi equipado com FPGAs da Xilinx que podiam ser reprogramadas de acordo \n\ncom a necessidade da miss\u00e3o (XILINX, 2015). A figura 2 a seguir mostra o ve\u00edculo de \n\nexplora\u00e7\u00e3o marciana Curiosity.  \n\n \n\nFigura 2 - Ve\u00edculo de explora\u00e7\u00e3o marciana com dispositivos reconfigur\u00e1veis embarcados. \n\n \n\n \n\n \n\nO FPGA permite o melhor dos dois mundos, ASIC\u00b4s e CPU\u00b4s. Eles podem ser \n\najustados para atender demandas espec\u00edficas e tamb\u00e9m podem ser modificados para atender \u00e0s \n\nvaria\u00e7\u00f5es das aplica\u00e7\u00f5es. Eles possuem um tempo de desenvolvimento e um time-to-market\n4\n \n\nmenor quando comparado a projetos de ASICs (DUTRA, 2010).  \n\nAl\u00e9m disso, conseguem explorar o uso de opera\u00e7\u00f5es de maneira simult\u00e2nea com \n\nbaixo consumo de energia quando comparados a CPU\u00b4s, o que prov\u00ea uma boa solu\u00e7\u00e3o para a \n\nefici\u00eancia computacional (MEDEIROS, 2013).  \n\nNovas iniciativas para desenvolvimento de padr\u00f5es de linguagens que permitem \n\nexplorar alto desempenho est\u00e3o em andamento, como a Open Computing Language\n5\n \n\n                                                 \n3\n National Aeronautics and Space Administration (NASA) \u00e9 o \u00f3rg\u00e3o do governo dos Estados Unidos respons\u00e1vel \n\npelo programa espacial civil, bem como aeron\u00e1utico al\u00e9m da investiga\u00e7\u00e3o aeroespacial. NASA. Acesso em 31 \n\nago. 2015. Dispon\u00edvel em&lt;https://www.nasa.gov/>. \n4\n Corresponde a quantidade de tempo que leva para se projetar e fabricar um produto antes que ele esteja \n\ndispon\u00edvel para a compra. Dictionary Cambridge. Acesso em: 31 ago. 2015. Dispon\u00edvel em: \n\n<http://dictionary.cambridge.org/pt/dicionario/ingles/time-to-market>. \n5\n \u00c9 um padr\u00e3o multi-plataforma para programa\u00e7\u00e3o paralela de processadores encontrados em computadores \n\npessoais, servidores e dispositivos que melhora a velocidade e capacidade de resposta para um amplo espectro de \n\naplica\u00e7\u00f5es. OpenCL. Acesso em: 29 jul. 2015. Dispon\u00edvel em:&lt;https://developer.nvidia.com/opencl> . \n\nhttps://developer.nvidia.com/opencl\n\n\n25 \n\n \n\n \n\n(OpenCL). Esse padr\u00e3o busca o desenvolvimento de uma linguagem aberta para multi-\n\nplataformas, incluindo-se CPUs, GPU e FPGAs (OPENCL, 2015). \n\n \n\n2.2 FPGAs \n\n \n\nOs FPGAs foram lan\u00e7ados no ano de 1985 pela Xilinx e podem ser descritos como \n\ndispositivos l\u00f3gicos reconfigur\u00e1veis implementados em hardware, capazes de serem \n\nreprogramados de acordo com as necessidades do desenvolvedor (XILINX, 2015). Isso \u00e9 \n\nposs\u00edvel devido \u00e0 maneira como sua estrutura foi concebida, abrigando elementos de \n\nmem\u00f3ria, de entrada e sa\u00edda, bem como de l\u00f3gica combinacional e sequencial.  \n\nDe maneira geral, uma FPGA moderna \u00e9 formada por um array bi-dimensional de \n\nelementos computacionais. Esses elementos correspondem a blocos de l\u00f3gica combinacional \n\n(CLBs) e sequencial (Flip-Flops), elementos de entrada e sa\u00edda, bancos de mem\u00f3ria, blocos \n\nDSP, transceivers de alta velocidade, blocos de PLLs, entre outros.  \n\nAl\u00e9m disso, uma FPGA possui elementos de roteamento que permitem a conex\u00e3o \n\nadequada de todos estes componentes. Esses elementos tem sua funcionalidade determinada \n\npor um conjunto de bits que define como eles devem ser interconectados. A esse conjunto de \n\nbits d\u00e1-se o nome de bitstream.  A figura 3 exibe alguns desses componentes que est\u00e3o \n\npresentes no dispositivo. \n\nOs FPGAs possuem algumas caracter\u00edsticas que, a depender da aplica\u00e7\u00e3o, s\u00e3o tidas \n\ncomo vantagens sobre processadores de prop\u00f3sito geral. Pode-se destacar, por exemplo, que \n\nos FPGAs podem ser usados para aplica\u00e7\u00f5es customizadas dedicadas, ou seja, s\u00e3o otimizados \n\npara a resolu\u00e7\u00e3o de um problema espec\u00edfico. Isso faz com que toda a estrutura presente no \n\ndispositivo esteja voltada apenas para a execu\u00e7\u00e3o das tarefas para o qual foi programada. O \n\nmesmo n\u00e3o pode ser dito de um processador de prop\u00f3sito geral, pois esse implementa \n\ndiversas instru\u00e7\u00f5es que podem n\u00e3o ser utilizadas por uma aplica\u00e7\u00e3o espec\u00edfica. \n\nOutra vantagem significativa sobre os processadores de prop\u00f3sito geral \u00e9 sua \n\nopera\u00e7\u00e3o em frequ\u00eancias baixas, quando comparadas \u00e0s aplicadas as CPUs, permitindo, \n\nassim, um baixo consumo de energia, o que, para grandes clusters de computadores, implica \n\nem uma economia consider\u00e1vel de energia (MEDEIROS et al., 2013). \n\n   \n\n\n\n26 \n\n \n\n \n\nFigura 3 \u2013 Vis\u00e3o geral da arquitetura de uma FPGA \n \n\n \n\n \n\nOs blocos l\u00f3gicos possuem uma regi\u00e3o para a implementa\u00e7\u00e3o da l\u00f3gica \n\ncombinacional, bem como possuem latchs ou flip-flops para implementa\u00e7\u00e3o de l\u00f3gica \n\nsequencial (XILINX, 2015). A sa\u00edda dos blocos l\u00f3gicos pode ser selecionada entre o da l\u00f3gica \n\ncombinacional e o da l\u00f3gica sequencial, vinda do flip-flop por um multiplexador de sa\u00edda. \n\nPode-se observar uma estrutura de um bloco l\u00f3gico ALM (Adaptive Logic Module) da Altera \n\nna figura 4 (ALTERA, 2015).  \n\n A maneira mais comum de implementar a l\u00f3gica combinacional \u00e9 atrav\u00e9s do uso de \n\nLUTs (look-up tables), abordado em Altera (2015), que, conceitualmente, pode ser explicada \n\ncomo sendo um grande multiplexador para c\u00e9lulas de mem\u00f3ria. Uma LUT \u00e9, basicamente, \n\numa mem\u00f3ria pr\u00e9-programada que prov\u00ea uma sa\u00edda l\u00f3gica em fun\u00e7\u00e3o do valor do vetor das \n\nvari\u00e1veis de entrada. Com isso, as LUTs operam como uma mem\u00f3ria de N linhas de endere\u00e7o \n\npara 2\nN\n locais de mem\u00f3ria. As LUTs, por usarem tecnologia de mem\u00f3rias Randomic Access \n\nMemory (RAM), s\u00e3o vol\u00e1teis, perdem seu conte\u00fado em caso de falta de energia el\u00e9trica. No \n\nentanto, \u00e9 poss\u00edvel armazenar informa\u00e7\u00f5es de programa\u00e7\u00e3o do dispositivo em mem\u00f3rias n\u00e3o \n\nvol\u00e1teis. Isso \u00e9 feito utilizando-se, por exemplo, mem\u00f3rias FLASH EEPROM (Electrically \n\nErasable Programmable Read Only Memory), capazes de carregar automaticamente as \n\nc\u00e9lulas de armazenamento ao in\u00edcio de sua utiliza\u00e7\u00e3o. \n\n\n\n27 \n\n \n\n \n\nOs blocos l\u00f3gicos da Altera, os ALMs possuem duas unidades somadoras que podem \n\natuar como somadores de dois bits (ALTERA, 2015). Al\u00e9m disso, possuem dois registradores \n\nna sa\u00edda, respons\u00e1veis pelo armazenamento dos estados dos sinais, ou seja, a parte da l\u00f3gica \n\nsequencial. Para selecionar os caminhos e sinais dentro dos ALMs, existem diversos \n\nMultiplexadores configurados de acordo com a necessidade de uso do bloco.  \n\n  \n\nFigura 4 - Estrutura de um bloco l\u00f3gico ALM em um FPGA \n \n\n \n\n \n\nOutros m\u00f3dulos de interesse presentes em FPGAs Altera s\u00e3o os DSP (Digital Signal \n\nProcessing), visto em Altera (2015). Os blocos DSP consistem em uma combina\u00e7\u00e3o de \n\nelementos dedicados que realizam multiplica\u00e7\u00e3o, adi\u00e7\u00e3o, subtra\u00e7\u00e3o, acumula\u00e7\u00e3o e opera\u00e7\u00f5es \n\ndin\u00e2micas de deslocamento (shift). Esses blocos podem ser utilizados para operar n\u00fameros em \n\nponto fixo. Como exemplo, podemos citar uma FPGA StratixIII da Altera (2015), onde seus \n\nDSPs d\u00e3o suporte nativamente a tamanhos de palavras de 9 bits, 12 bits, 18 bits e 36 bits, \n\nal\u00e9m de multiplicadores de 18x18 bits, o que otimiza a realiza\u00e7\u00e3o de opera\u00e7\u00f5es aritm\u00e9ticas.  \n\nOs FPGAs possuem elementos de roteamento chamados de Switch Matrix. Eles \n\nest\u00e3o dispostos em forma de linhas e colunas compondo uma grande matriz de trilhas que \n\npercorrem toda a FPGA. Eles podem ser utilizados para a defini\u00e7\u00e3o do roteamento de sinais \n\npelas linhas horizontais e verticais durante a programa\u00e7\u00e3o do circuito. Na figura 5, podemos \n\nvisualizar um elemento de roteamento presente na intersec\u00e7\u00e3o das trilhas, chamado de matriz \n\nde roteamento. Ele possui seis chaves program\u00e1veis que, quando ativadas, permitem a \n\npassagem de corrente de uma trilha para outra. De acordo com o vetor de bits de \n\nconfigura\u00e7\u00e3o, as seis chaves podem assumir diversas combina\u00e7\u00f5es diferentes, provendo \n\n\n\n28 \n\n \n\n \n\nversatilidade no roteamento dos sinais. Dessa maneira, \u00e9 poss\u00edvel a propaga\u00e7\u00e3o de um sinal de \n\numa regi\u00e3o para outra e se torna poss\u00edvel a comunica\u00e7\u00e3o entre blocos l\u00f3gicos distantes. \n\n \n\nFigura 5 - Matriz de roteamento, Switch Matrix. \n\n \n\n \n\n \n\n Os FPGAs Altera possuem blocos de mem\u00f3ria TriMatrix incorporados, fornecendo \n\ntr\u00eas tamanhos diferentes de mem\u00f3ria Static Randomic Access Memory (RAM) embutidas: \n\nMLAB, M9K e M144k. As mem\u00f3rias MLAB s\u00e3o otimizadas para se implementar linhas de \n\natraso de filtros, FIFOs pequenas e registradores de deslocamento. Os blocos M9K podem ser \n\nutilizados para aplica\u00e7\u00f5es de mem\u00f3ria para fins gerais. Os blocos M144K s\u00e3o ideais para \n\narmazenamento de c\u00f3digo de processamento e armazenamento de frames de v\u00eddeo. Cada \n\nbloco de mem\u00f3ria embutida pode ser configurado independentemente para atuar como um \n\ndual-port RAM ou ROM. Al\u00e9m disso, v\u00e1rios blocos do mesmo tipo tamb\u00e9m podem ser \n\ncombinados para se produzir mem\u00f3rias maiores. Essas mem\u00f3rias do tipo SRAM podem operar \n\na uma frequ\u00eancia m\u00e1xima de 600 MHz, o que representa uma \u00f3tima frequ\u00eancia em se tratando \n\nde FPGAs (ALTERA, 2015). \n\n \n\n2.3 Aritm\u00e9tica de Ponto Flutuante e Ponto Fixo \n\n \n\nDevido \u00e0 presen\u00e7a dos n\u00fameros reais na computa\u00e7\u00e3o cient\u00edfica e sua grande \n\ndiversidade de representa\u00e7\u00e3o, que variava conforme o fabricante no in\u00edcio da d\u00e9cada de \n\noitenta do s\u00e9culo vinte, tornou-se necess\u00e1ria a cria\u00e7\u00e3o de um padr\u00e3o. Esse padr\u00e3o formalizou \n\num modelo de representa\u00e7\u00e3o de dados a ser seguido pelos desenvolvedores de processadores. \n\n\n\n29 \n\n \n\n \n\nProcessadores esses que realizavam opera\u00e7\u00f5es aritm\u00e9ticas sobre o conjunto dos n\u00fameros reais \n\nem computadores. \n\nCom o desenvolvimento do co-processador aritm\u00e9tico i8087 em 1980, a Intel \n\nconseguiu atender a todos os requisitos de confiabilidade e portabilidade exigidos pelos \n\nprogramadores da \u00e9poca, (BARROS, 2008).  \n\nEsse componente realizava v\u00e1rias opera\u00e7\u00f5es aritm\u00e9ticas tais como: soma, subtra\u00e7\u00e3o, \n\ndivis\u00e3o, multiplica\u00e7\u00e3o, raiz quadrada, tangente, exponencial, entre outras. Atualmente, esse \n\npapel foi ocupado pelas Floating Point Units (FPUs) integradas a quase todos os \n\nprocessadores.  \n\nAp\u00f3s a formaliza\u00e7\u00e3o de um padr\u00e3o para aritm\u00e9tica dos n\u00fameros reais em \n\ncomputadores, a computa\u00e7\u00e3o cient\u00edfica ganhou replicabilidade e mais confiabilidade em seus \n\nresultados. \n\nA seguir, ser\u00e1 apresentado o padr\u00e3o seguido pela comunidade cient\u00edfica e industrial \n\npara ponto flutuante com sua respectiva representa\u00e7\u00e3o de dados e de ponto flutuante.  \n\n \n\n2.3.1 Padr\u00e3o IEEE-754  \n\n \n\nCriado em 1977 e lan\u00e7ado em 1985, o padr\u00e3o IEEE-754 surgiu para tentar \n\nsolucionar os problemas causados pelas diferentes formas de representa\u00e7\u00e3o e opera\u00e7\u00e3o de \n\nn\u00fameros reais em sistemas computacionais (IEEE-754, 1985).   \n\nO IEEE-754 definiu os requisitos m\u00ednimos a serem seguidos para implementa\u00e7\u00e3o \n\naritm\u00e9tica desses n\u00fameros em uma base bin\u00e1ria, padr\u00e3o que se tornou o mais usado pelos \n\ncomputadores at\u00e9 os dias atuais.  \n\nDentre seus requisitos t\u00eam-se: \n\n? Formato de representa\u00e7\u00e3o dos dados: define quatro tipos de representa\u00e7\u00e3o para \n\ndados, denominados Double, Float, Double Extended  e Float Extended.  \n\n? Opera\u00e7\u00f5es aritm\u00e9ticas: Devem constar as opera\u00e7\u00f5es aritm\u00e9ticas de soma, subtra\u00e7\u00e3o, \n\nmultiplica\u00e7\u00e3o, divis\u00e3o e raiz quadrada para os tipos de dados suportados em uma \n\nimplementa\u00e7\u00e3o completa do padr\u00e3o. \n\n? Arredondamento: Est\u00e3o definidos quatro tipos de arredondamentos para as \n\nopera\u00e7\u00f5es aritm\u00e9ticas: arredondamento para o mais pr\u00f3ximo ou par (round to nearest \n\nor even); arredondamento para o zero (round to zero); arredondamento para infinito \n\n\n\n30 \n\n \n\n \n\npositivo (round to +infinity); e arredondamento para infinito negativo (round to \u2013\n\ninfinity).   \n\n? Normaliza\u00e7\u00e3o: Garante a coer\u00eancia dos dados gerados de opera\u00e7\u00f5es aritm\u00e9ticas com \n\no pr\u00f3prio padr\u00e3o atrav\u00e9s do ajuste dos vetores de bits, para garantir a unicidade da \n\nsua representa\u00e7\u00e3o. Assegura que o digito mais significativo deve ser diferente de \n\nzero. \n\n? Exce\u00e7\u00f5es: Define as exce\u00e7\u00f5es geradas durante o processo de soma/subtra\u00e7\u00e3o, \n\nmultiplica\u00e7\u00e3o e demais opera\u00e7\u00f5es. As principais exce\u00e7\u00f5es definidas s\u00e3o: Underflow, \n\nOverflow, NAN (n\u00fameros inv\u00e1lidos), Infinito positivo, Infinitivo negativo e \n\ndenormal.    \n\n \n\nOs n\u00fameros s\u00e3o representados como vetores de bits separados em tr\u00eas subconjuntos \n\nde acordo com suas caracter\u00edsticas: sinal, expoente e mantissa. A extens\u00e3o desse vetor \n\ndepende do tipo de precis\u00e3o adotada. O primeiro termo corresponde ao sinal, o segundo ao \n\nexpoente e o terceiro a mantissa. Podemos observar a representa\u00e7\u00e3o e o n\u00famero de bits de \n\ncada termo dos n\u00fameros em ponto flutuante de acordo com sua precis\u00e3o na figura 6.  \n\n \n\nFigura 6 - Representa\u00e7\u00e3o de n\u00fameros em ponto flutuante padr\u00e3o IEEE-754. \n\n \n\n \n\n \n\n2.3.2 Formato de representa\u00e7\u00e3o dos dados \n\n \n\n Um n\u00famero no padr\u00e3o IEEE-754 obedece \u00e0 seguinte regra de defini\u00e7\u00e3o de \n\npar\u00e2metros: \n\n\n\n31 \n\n \n\n \n\n? p = N\u00famero de bits do significando. \n\n? Em\u00e1x = Expoente m\u00e1ximo. \n\n? Emin = Expoente m\u00ednimo. \n\n? Bias = Valor de refer\u00eancia do expoente. \n\n Dessa maneira, pode-se representar um n\u00famero em ponto flutuante utilizando-se a \n\nseguinte express\u00e3o: \n\n?1\ns\n? d.ddd ? d ? ?\n\ne\n  (2.1) \n\n \n\n? s : Bit de sinal. \n\n? d.ddd...d : Os p d\u00edgitos do significando. \n\n?  ? : Representa a base num\u00e9rica. No caso do padr\u00e3o IEEE-754 a base adotada \u00e9 bin\u00e1ria, \n\nportanto ? = 2. \n\n? e : Representa o expoente do n\u00famero na base adotada. Seu valor est\u00e1 contido na regi\u00e3o \n\ndefinida por Emin\n6\n ? e ? Emax\n\n7\n \n\n \n\n2.3.3 Nota\u00e7\u00e3o de Ponto Fixo \n\n \n\n Nesse tipo de nota\u00e7\u00e3o, busca-se representar tanto a parte inteira do n\u00famero como sua \n\nparte fracion\u00e1ria. Dessa maneira, os d\u00edgitos utilizados para a representa\u00e7\u00e3o se dividem em \n\ndois grupos separados por um \u201cponto separador\u201d. O ponto separador serve apenas para manter \n\no padr\u00e3o de nota\u00e7\u00e3o dos n\u00fameros reais, que possuem parte inteira e parte fracion\u00e1ria. Os \n\nd\u00edgitos a esquerda do ponto correspondem \u00e0 parte inteira do n\u00famero, enquanto que os d\u00edgitos \n\nda direita representam a parte fracion\u00e1ria. \n\n Para saber o valor num\u00e9rico representado, basta realizar um somat\u00f3rio de cada d\u00edgito \n\nponderado pela base, isso de acordo com o posicionamento relativo do d\u00edgito em sua \n\nrepresenta\u00e7\u00e3o. Assim, se obt\u00e9m a seguinte f\u00f3rmula para representa\u00e7\u00e3o:   \n\n \n\n\u00b1 ? ?? ? ???1??               (2.2)\n?\n\n?=1\n \n\n \n\n                                                 \n6\n Corresponde ao expoente m\u00ednimo representado. \n\n7\n Corresponde ao expoente m\u00e1ximo representado. \n\n\n\n32 \n\n \n\n \n\n Nesta f\u00f3rmula, n representa o n\u00famero de d\u00edgitos, sendo k d\u00edgitos reservados para a \n\nrepresenta\u00e7\u00e3o da parte fracion\u00e1ria. Na nota\u00e7\u00e3o utilizada, d representa o n\u00famero de d\u00edgitos e di \n\no d\u00edgito de posi\u00e7\u00e3o i. O ? representa a base adotada, no caso a bin\u00e1ria. \n\n A precis\u00e3o de um n\u00famero nessa nota\u00e7\u00e3o depende da quantidade de bits dispon\u00edveis \n\npara representa-lo. Quanto maior a quantidade de bits dispon\u00edveis, maior a precis\u00e3o, quanto \n\nmenor a quantidade de bits dispon\u00edveis, menor a precis\u00e3o. \n\nPara se chegar ao n\u00edvel de precis\u00e3o a ser utilizado na nota\u00e7\u00e3o de ponto fixo, foi feito \n\num estudo do impacto da quantidade de m\u00ednima de bits necess\u00e1rios \u00e0 opera\u00e7\u00e3o do RTM em \n\nFPGA. Essa quantidade n\u00e3o podia levar a perdas significativas de qualidade do resultado do \n\nalgoritmo. Como o RTM \u00e9 utilizado para o processo de imageamento s\u00edsmico, seu resultado \n\ncaracter\u00edstico final \u00e9 justamente uma imagem das camadas do solo a ser estudado.  \n\nO processo de compara\u00e7\u00e3o de imagens no RTM, apesar de levar em conta medidas \n\ncomo Signal to Noise Ratio (SNR)\n8\n e o Universal Quality Index (UQI)\n\n9\n, proposta em Wang \n\n(2002), ainda apresenta um forte car\u00e1ter subjetivo, a interpreta\u00e7\u00e3o humana. Com isso, n\u00e3o h\u00e1 \n\numa defini\u00e7\u00e3o clara do n\u00edvel de precis\u00e3o num\u00e9rica que os algoritmos s\u00edsmicos exigem (FU et \n\nal., 2009).  \n\nA pesquisa dessa disserta\u00e7\u00e3o fez parte de um projeto de pesquisa mais amplo, \n\nfirmado entre o Centro de inform\u00e1tica da UFPE e a Petrobras, com isso, a palavra final para o \n\nn\u00edvel de qualidade de imagem foi dada pelos pesquisadores do pr\u00f3prio CENPES. A refer\u00eancia \n\nadotada para qualidade de imagem \u00e9 dada pelo algoritmo RTM, utilizando um n\u00facleo de \n\nprocessamento em ponto flutuante.  \n\nA representa\u00e7\u00e3o m\u00ednima em ponto fixo que apresentou os resultados mais pr\u00f3ximos \n\ndos resultados obtidos com a representa\u00e7\u00e3o em ponto flutuante foi a com 9 bits na parte \n\ninteira e 27 bits na parte fracion\u00e1ria. A representa\u00e7\u00e3o adotada pode ser observada na figura 7 a \n\nseguir. \n\nFigura 7 - Representa\u00e7\u00e3o adotada em Ponto Fixo. \n\n9 27\n\nParte Inteira Parte Fracion\u00e1ria\n \n\n \n\n                                                 \n8\n A rela\u00e7\u00e3o SNR \u00e9 uma rela\u00e7\u00e3o adimensional da pot\u00eancia do sinal com a pot\u00eancia do ru\u00eddo. Essa rela\u00e7\u00e3o sinal -\n\nru\u00eddo parametriza o desempenho dos sistemas de processamento de sinais ideais. Scholarpedia. Acesso em 14 \n\nset. 2015. Dispon\u00edvel em:&lt;http://www.scholarpedia.org/article/Signal-to-noise_ratio>. \n9\n M\u00e9trica que busca mensurar o grau de semelhan\u00e7a entre imagens do ponto de vista da percep\u00e7\u00e3o humana do \n\nbrilho, contraste e artefatos presentes nas imagens (BARROS, A. B).  \n\n\n\n33 \n\n \n\n \n\nCom essa nota\u00e7\u00e3o, \u00e9 poss\u00edvel representar n\u00fameros que variam de 255 a - 255 devido \n\naos 9 bits da parte inteira, com precis\u00e3o de cerca de 2\n-27\n\n, que equivale a, aproximadamente, \n\n7,45x10\n-9\n\n.  \n\n \n\n \n\n2.3.4 Algoritmos de Soma e Subtra\u00e7\u00e3o em Ponto Fixo \n\n \n\nNa representa\u00e7\u00e3o em ponto fixo, os algoritmos de soma e subtra\u00e7\u00e3o s\u00e3o mais \n\nsimples dos que os realizados em ponto flutuante. Como n\u00e3o h\u00e1 a presen\u00e7a de um expoente na \n\nrepresenta\u00e7\u00e3o do n\u00famero, uma soma ou subtra\u00e7\u00e3o direta entre o conjunto inteiro de bits pode \n\nser aplicada. \n\nPara se realizar essa opera\u00e7\u00e3o, \u00e9 importante que o ponto separador entre a parte \n\ninteira e a parte fracion\u00e1ria dos dois operandos estejam alinhados. Isso implica que bits com \n\nos mesmos valores de fra\u00e7\u00f5es de dois s\u00e3o operados entre si. Caso contr\u00e1rio, valores em partes \n\ndo vetor de bits ser\u00e3o somados com valores errados e um resultado incorreto ser\u00e1 gerado. No \n\ncaso desta arquitetura, os tamanhos das entradas a serem somadas em ponto fixo s\u00e3o iguais. \n\nOu seja, como as entradas a serem somadas possuem o mesmo n\u00famero de bits total e de parte \n\ninteira, os n\u00fameros podem ser somados diretamente sem preocupa\u00e7\u00e3o com alinhamentos do \n\nponto separador. \n\nAo final da opera\u00e7\u00e3o, \u00e9 feito um arredondamento para garantir que n\u00e3o h\u00e1 mais bits \n\ndo que o exigido pela representa\u00e7\u00e3o adotada do n\u00famero. O arredondamento feito nas \n\nopera\u00e7\u00f5es em ponto fixo dessa arquitetura corresponde ao arredondamento para baixo (round \n\ndown), que ser\u00e1 explicado nas se\u00e7\u00f5es a seguir. \n\nComo exemplo, pode-se realizar a opera\u00e7\u00e3o de soma exposta abaixo: \n\n  \n\n72.875 + 12.125 = 85  \n\n \n\nNa tabela 1 a seguir, observa-se a representa\u00e7\u00e3o dos operandos no formato de ponto \n\nfixo. Os operandos foram nomeados como A, B e C para facilitar sua descri\u00e7\u00e3o. \n\n \n\nTabela 1 - Representa\u00e7\u00e3o de alguns n\u00fameros em ponto fixo. \n\n \n\nOperando Valor Parte Inteira Parte Fracion\u00e1ria \n\nA 72.87510 0010010002 1110000000000000000000000002 \n\n\n\n34 \n\n \n\n \n\nB 12.12510 0000011002 0010000000000000000000000002 \n\nC 8510 0010101012 0000000000000000000000000002 \n\n \n\nPode-se observar, na tabela 1, que o operando B j\u00e1 se encontra com a nota\u00e7\u00e3o de \n\ncomplemento a dois e com o ponto separador alinhado, ou seja, j\u00e1 se encontra pronto para a \n\nsoma. \n\nRealizando-se a soma dos operandos A e B, obt\u00e9m-se o seguinte resultado exposto \n\nabaixo: \n\n \n\n001010101.0000000000000000000000000002   \n\n \n\nEsse resultado j\u00e1 corresponde ao valor 85 em ponto fixo de base bin\u00e1ria exposto na \n\ntabela 1. \n\n \n\n2.3.5 Algoritmo de Multiplica\u00e7\u00e3o em Ponto Fixo  \n\n \n\nA opera\u00e7\u00e3o de multiplica\u00e7\u00e3o de n\u00fameros em ponto fixo corresponde a uma simples \n\nopera\u00e7\u00e3o de multiplica\u00e7\u00e3o em n\u00fameros bin\u00e1rios, observando-se algumas exce\u00e7\u00f5es.  \n\nEssa opera\u00e7\u00e3o \u00e9 bem mais econ\u00f4mica do que a executada em n\u00fameros em ponto \n\nflutuante em FPGAs, por exemplo. Isso ocorre pois em ponto fixo os n\u00fameros n\u00e3o s\u00e3o \n\nrepresentados com expoente. \u00c9 justamente a presen\u00e7a desse expoente na nota\u00e7\u00e3o de ponto \n\nflutuante que introduz uma maior conjunto de opera\u00e7\u00f5es durante uma c\u00e1lculo. Com isso \n\nopera\u00e7\u00f5es aritm\u00e9ticas em ponto fixo s\u00e3o menos custosas computacionalmente do que me \n\nponto flutuante. \n\nO padr\u00e3o de ponto flutuante necessita que m\u00f3dulos de hardware espec\u00edficos sejam \n\nimplementados. Para que esses m\u00f3dulos sejam gerados, recursos dispon\u00edveis de l\u00f3gica ser\u00e3o \n\nconsumidos, o que pode limitar o n\u00famero de m\u00f3dulos aritm\u00e9ticos instanciados e reduzir sua \n\nfrequ\u00eancia de opera\u00e7\u00e3o (BARROS, 2014). Sabe-se que o desempenho em FPGAs est\u00e1 \n\ndiretamente ligado ao grau de paralelismo e \u00e0 frequ\u00eancia de trabalho dos m\u00f3dulos \n\nimplementados. Como esses dois par\u00e2metros dependem da quantidade de recursos dispon\u00edveis \n\ndo FPGA, a escolha pelo padr\u00e3o de ponto fixo pode significar um ganho de desempenho \n\nsignificativo (GUO et al., 2004). \n\n\n\n35 \n\n \n\n \n\nUma particularidade das multiplica\u00e7\u00f5es em ponto fixo, nesse projeto, \u00e9 que elas s\u00e3o \n\nfeitas com n\u00fameros constantes. Isso ocorre porque a equa\u00e7\u00e3o utilizada no m\u00e9todo RTM \n\nmultiplica pesos, que correspondem a n\u00fameros inteiros, por alguns de seus termos a n\u00fameros \n\nque s\u00e3o somados em seguida (MEDEIROS, 2013).  \n\nA multiplica\u00e7\u00e3o por constantes torna poss\u00edvel a realiza\u00e7\u00e3o de otimiza\u00e7\u00f5es para se \n\neconomizar recursos do FPGA. Dessa maneira, a arquitetura desenvolvida nesse projeto n\u00e3o \n\nchega a realizar multiplica\u00e7\u00f5es de maneira esperada para n\u00fameros em ponto fixo. Essa \n\nopera\u00e7\u00e3o corresponde a um conjunto de manipula\u00e7\u00f5es alg\u00e9bricas sobre o vetor de bits em \n\nnota\u00e7\u00e3o de ponto fixo que, matematicamente, equivale a multiplica\u00e7\u00f5es por n\u00fameros \n\nconstantes. \n\nAs constantes operadas dentro da arquitetura proposta em ponto fixo s\u00e3o: -1, 16 e -\n\n90. Algumas observa\u00e7\u00f5es s\u00e3o feitas a seguir sobre essas multiplica\u00e7\u00f5es.  \n\nA multiplica\u00e7\u00e3o por -1 equivale, apenas, a uma opera\u00e7\u00e3o de complemento a dois ao \n\nfinal do conjunto de soma de elementos da equa\u00e7\u00e3o. Ou seja, n\u00e3o \u00e9 necess\u00e1rio realizar, de \n\nfato, a multiplica\u00e7\u00e3o nesse caso.  \n\nA multiplica\u00e7\u00e3o por 16 tamb\u00e9m possui uma particularidade. Devido ao fato de o \n\nn\u00famero ser uma pot\u00eancia de dois, a multiplica\u00e7\u00e3o se resume a uma opera\u00e7\u00e3o de deslocamento \n\npara a esquerda (Shift Left). Sabe-se que cada deslocamento para a esquerda em nota\u00e7\u00e3o \n\nbin\u00e1ria equivale a uma multiplica\u00e7\u00e3o por 2. Com isso, para se multiplicar um n\u00famero em \n\nponto fixo por 16 basta realizar o deslocamento do vetor de bits quatro vezes para a esquerda. \n\nEssa opera\u00e7\u00e3o pode ser ainda mais simplificada fazendo-se uma concatena\u00e7\u00e3o de quatro bits \n\nde valor zero ao final do vetor. Ou seja, assim como no caso da multiplica\u00e7\u00e3o por -1, a \n\nmultiplica\u00e7\u00e3o por 16 em ponto fixo, na verdade, n\u00e3o corresponde a uma multiplica\u00e7\u00e3o de fato, \n\ne sim a uma simples manipula\u00e7\u00e3o de bits. \n\nDiferentemente das duas anteriores, na multiplica\u00e7\u00e3o por -90, n\u00e3o h\u00e1 grandes \n\notimiza\u00e7\u00f5es. A multiplica\u00e7\u00e3o direta de uma vari\u00e1vel de entrada por esse n\u00famero \u00e9 feita. Um \n\ndetalhe importante ao se realizar uma multiplica\u00e7\u00e3o \u00e9 a quantidade de bits necess\u00e1rios para o \n\narmazenamento da resposta sem perda de precis\u00e3o. Como toda multiplica\u00e7\u00e3o de \u2018n\u2019 d\u00edgitos \n\ngeram \u20182n\u2019 d\u00edgitos, a cada multiplica\u00e7\u00e3o realizada o n\u00famero de bits armazenado dobra, o que \n\nexige que um arredondamento seja feito.  \n\n \n\n \n\n\n\n36 \n\n \n\n \n\n2.3.6 Algoritmo de Arredondamento em Ponto Fixo \n\n \n\nPara que as opera\u00e7\u00f5es aritm\u00e9ticas encadeadas em ponto fixo n\u00e3o se tornem \n\ndemasiadamente custosas em termos de recursos do FPGA, \u00e9 necess\u00e1rio realizar \n\narredondamentos. Esses arredondamentos limitam a quantidade de bits ocupados em FPGA \n\npelos n\u00fameros ao final de opera\u00e7\u00f5es aritm\u00e9ticas, como multiplica\u00e7\u00f5es e somas.  \n\nComo dito anteriormente, multiplica\u00e7\u00f5es entre dois n\u00fameros com a mesma \n\nquantidade de bits gera um n\u00famero de resposta com o dobro de bits. Opera\u00e7\u00f5es de soma entre \n\nn\u00fameros com \u2018n\u2019 d\u00edgitos geram n\u00fameros com \u2018n+1\u2019 d\u00edgitos de resposta. O que implicaria em \n\numa constante expans\u00e3o da quantidade de bits a serem utilizados para se armazenar um \n\nn\u00famero a cada opera\u00e7\u00e3o aritm\u00e9tica. \n\nPor exemplo, com opera\u00e7\u00f5es de multiplica\u00e7\u00e3o realizadas seguidamente, a quantidade \n\nde bits necess\u00e1ria para armazenar um n\u00famero se tornaria proibitiva. Com isso, surge a \n\nnecessidade dos arredondamentos.  \n\nO arredondamento utilizado nesta arquitetura para n\u00fameros em ponto fixo consiste \n\nem um arredondamento para zero, ou truncamento. Essa escolha foi feita devido \u00e0 economia \n\nde recursos de hardware dispon\u00edveis em FPGA, visto que \u00e9 a maneira mais simples de se \n\nrealizar arredondamento. \n\n \n\n2.3.7 Nota\u00e7\u00e3o de Ponto Flutuante \n\n \n\nA nota\u00e7\u00e3o de ponto flutuante, apesar de ser semelhante \u00e0 de ponto fixo, possui uma \n\ndiferen\u00e7a significativa: a adi\u00e7\u00e3o de um grupo de d\u00edgitos de expoente. A jun\u00e7\u00e3o da parte inteira \n\ne da parte fracion\u00e1ria do n\u00famero \u00e9 denominada de significando.  \n\nPor defini\u00e7\u00e3o os n\u00fameros nessa nota\u00e7\u00e3o est\u00e3o normalizados, ou seja, a parte inteira \n\ndo significando nessa nota\u00e7\u00e3o \u00e9 representada por um d\u00edgito diferente de zero.  \n\nA f\u00f3rmula que representa um n\u00famero em ponto flutuante segue na equa\u00e7\u00e3o 2.5: \n\n \n\n\u00b1 ? ?? ? ????+ ????????\n?\n\n?=0\n             (2.3) \n\n  \n\nNessa equa\u00e7\u00e3o, n corresponde ao n\u00famero total de d\u00edgitos utilizados para se \n\nrepresentar um n\u00famero e k corresponde \u00e0 quantidade de d\u00edgitos reservados para a \n\nrepresenta\u00e7\u00e3o da parte fracion\u00e1ria do n\u00famero. \n\n\n\n37 \n\n \n\n \n\nA parte relativa ao campo de expoente pode assumir tanto valores negativos quanto \n\npositivos. \u00c9 importante destacar que, no padr\u00e3o de ponto flutuante IEEE-754, o expoente zero \n\n\u00e9 um valor de refer\u00eancia denominado de Bias\n10\n\n, onde os valores positivos de expoente se \n\nencontram acima do Bias e valores negativos, abaixo. Com isso, o valor real de um n\u00famero \n\ndeve levar em considera\u00e7\u00e3o a diferen\u00e7a entre os valores contidos no campo expoente e o valor \n\ndo Bias (BARROS, 2014). \n\nDevido ao acr\u00e9scimo do campo de expoente, a representa\u00e7\u00e3o de ponto flutuante \n\ntornou poss\u00edvel manipular a posi\u00e7\u00e3o do \u201cponto separador\u201d do significando e, dessa forma, \n\nagregou-se mais expressividade \u00e0 nota\u00e7\u00e3o anterior de ponto fixo. \n\n \n\n2.3.8 Algoritmos de Soma e Subtra\u00e7\u00e3o em Ponto Flutuante \n\n \n\n Pode-se assumir que as opera\u00e7\u00f5es aritm\u00e9ticas de soma e subtra\u00e7\u00e3o possuem um \n\nmesmo algoritmo. Esse algoritmo possui os seguintes passos: \n\n \n\n? Prepara\u00e7\u00e3o dos operandos: Opera\u00e7\u00e3o que verifica a diferen\u00e7a entre os expoentes e ajusta o \n\nsignificando de acordo com essa diferen\u00e7a. Nesse passo, tamb\u00e9m \u00e9 feita a opera\u00e7\u00e3o de \n\ncomplemento a dois. \n\n? Execu\u00e7\u00e3o da Soma/Subtra\u00e7\u00e3o: Etapa onde ocorre a soma dos n\u00fameros bin\u00e1rios. \n\n? Normaliza\u00e7\u00e3o: Etapa de ajuste do resultado da soma para a representa\u00e7\u00e3o definida pelo \n\npadr\u00e3o com apenas um bit antes do ponto separador. O bit deve ser diferente de zero. \n\n? Arredondamento: Etapa onde o n\u00famero obtido \u00e9 mapeado para o valor represent\u00e1vel mais \n\npr\u00f3ximo. \n\n \n\nA etapa de prepara\u00e7\u00e3o dos operandos serve para alinhar os bits dos significandos \n\nentre si. Esse alinhamento garante que os operandos possuam os mesmos expoentes ao serem \n\nsomados ou subtra\u00eddos. O alinhamento ocorre quando os \u201cpontos separadores\u201d dos dois \n\nn\u00fameros est\u00e3o na mesma posi\u00e7\u00e3o em seu respectivo vetores de bits.  Isso \u00e9 feito de maneira \n\nque a opera\u00e7\u00e3o de soma ou subtra\u00e7\u00e3o ocorra somente entre bits que estejam sendo associados \n\na pesos equivalentes. \n\nComo exemplo, pode-se realizar a opera\u00e7\u00e3o de soma dos seguintes n\u00fameros: 9.807 e \n\n3.1415, que corresponde a 12.9485, demonstrada abaixo. \n\n                                                 \n10\n\n Para n\u00fameros em ponto flutuante de precis\u00e3o simples o bias corresponde a 127. \n\n\n\n38 \n\n \n\n \n\n \n\n9.807 + 3.1415 =  12.9485 \n\n \n\nA tabela 2 a seguir demonstra a representa\u00e7\u00e3o dos operandos no formato IEEE-754. \n\nOs operandos foram nomeados como A, B e C para facilitar sua descri\u00e7\u00e3o. \n\n \n\n \n\nTabela 2 - Representa\u00e7\u00e3o de alguns n\u00fameros em ponto flutuante \n\n \n\nOperando Nota\u00e7\u00e3o Decimal Nota\u00e7\u00e3o bin\u00e1ria padr\u00e3o IEEE-754 \n\nA 9.8070010 010000000100100100001111110101002 \n\nB 3.14159 10 010000010001110011101001011110012 \n\nC 12.9485910 010000010100111100101101011011102 \n\n       \n\nA tabela 3 a seguir demonstra os componentes dos n\u00fameros demonstrados, \n\nseparados em sinal, expoente e mantissa. \n\n \n\nTabela 3 - Operandos em ponto flutuante separados em componentes para soma e subtra\u00e7\u00e3o. \n\n \n\nOperando Sinal(S) Expoente(E) Mantissa(M) \n\nA 0 100000102 1.00111001110100101111001* \n\nB 0 100000002 1.10010010000111111010100* \n\n C 0 100000102 1.10011110010110101101110* \n\n*As mantissas encontram-se representadas com o bit impl\u00edcito no algarismo mais significativo pois os n\u00fameros \n\npor padr\u00e3o s\u00e3o representados como j\u00e1 normalizados. \n\n \n\nObserva-se, na tabela 3, que os expoentes de A e B s\u00e3o diferentes. Portanto, para se \n\nrealizar a opera\u00e7\u00e3o de soma, \u00e9 necess\u00e1rio que os operandos sejam manipulados de forma que \n\nestejam alinhados de acordo com a posi\u00e7\u00e3o do ponto separador. Com isso, deve-se realizar um \n\najuste nas mantissas de acordo com a diferen\u00e7a entre os expoentes (EA - EB). A representa\u00e7\u00e3o \n\ndessa equa\u00e7\u00e3o pode ser observada a seguir: \n\n \n\nEA - EB = 100000102 - 100000002 = 000000102 = 210    \n\n \n\nObserva-se, na equa\u00e7\u00e3o acima, que o vetor de bits em base bin\u00e1ria \u201c00000010\u201d \n\nequivale ao valor 2 em nota\u00e7\u00e3o decimal. \n\n\n\n39 \n\n \n\n \n\nDevido a essa diferen\u00e7a entre os expoentes, \u00e9 necess\u00e1rio realizar dois deslocamentos \n\npara a direita do significando do n\u00famero de menor expoente. No exemplo dado acima, esse \n\nn\u00famero corresponde ao significando do operando \u2018B\u2019. Isso ocorre porque cada deslocamento \n\npara a direita corresponde a uma divis\u00e3o pela base num\u00e9rica adotada, no caso, a base bin\u00e1ria. \n\nA cada deslocamento realizado, o expoente deve ser incrementado. Com os dois \n\ndeslocamentos para a direita do significando, o seu expoente \u00e9 incrementado duas vezes, \n\ntornando-se, igual ao expoente do primeiro operando, \u2018A\u2019. O resultado da respectiva opera\u00e7\u00e3o \n\nest\u00e1 expresso abaixo: \n\n \n\nSB = 0.011001001000011111101012   \n\n \n\nAp\u00f3s a etapa de alinhamento dos significandos realiza-se a soma direta bit a bit dos \n\nmesmos. A representa\u00e7\u00e3o dessa equa\u00e7\u00e3o est\u00e1 exposta na equa\u00e7\u00e3o 2.4: \n\n \n\nSA + SB = 1.001110011101001011110012 + 0.011001001000011111101012  =               \n\n1.1001111001011010110111002  (2.4) \n\n \n\nAo final da soma bit a bit, o significando deve ser normalizado para que possua \n\napenas um bit antes do ponto separador. Por conven\u00e7\u00e3o do padr\u00e3o IEEE-754, todo n\u00famero em \n\nponto flutuante deve ser armazenado em sua nota\u00e7\u00e3o normalizada. O padr\u00e3o de normaliza\u00e7\u00e3o \n\nadotado exige que s\u00f3 haja um bit antes do ponto separador e que esse seja diferente de zero. A \n\nopera\u00e7\u00e3o de ajuste do n\u00famero para que se encaixe nessa situa\u00e7\u00e3o descrita \u00e9 denominada de \n\nnormaliza\u00e7\u00e3o. No caso de exemplo citado, o n\u00famero j\u00e1 est\u00e1 normalizado e n\u00e3o necessita \n\npassar por esta opera\u00e7\u00e3o. \n\nA etapa seguinte \u00e0 normaliza\u00e7\u00e3o \u00e9 a etapa de arredondamento. No caso do exemplo \n\ncitado, o significando resultante possui vinte e cinco bits, dos quais vinte e tr\u00eas s\u00e3o da nota\u00e7\u00e3o \n\npadr\u00e3o para ponto flutuante e os demais resultantes da opera\u00e7\u00e3o aritm\u00e9tica realizada. \n\nInicialmente, a expans\u00e3o dos bits se faz necess\u00e1ria pois, como dito anteriormente, a \n\nsoma de n\u00fameros com \u2018n\u2019 d\u00edgitos gera uma resposta com \u2018n+1\u2019 d\u00edgitos. Portanto, a resposta \n\nprecisa de mais bits para n\u00e3o perder precis\u00e3o. Por\u00e9m, para se manter a nota\u00e7\u00e3o exigida pelo \n\npadr\u00e3o, a mantissa do resultado deve possuir apenas os vinte e tr\u00eas bits. Com isso, faz-se \n\nnecess\u00e1rio um processo de arredondamento. \n\n Apesar de o padr\u00e3o IEEE-754 definir quatro formas de arredondamento, a mais usual  \n\n\u00e9 o arredondamento para o mais pr\u00f3ximo ou par. Nesta disserta\u00e7\u00e3o, para garantir uma maior \n\n\n\n40 \n\n \n\n \n\nprecis\u00e3o no resultado e uma conformidade absoluta com o que foi estabelecido pelo IEEE, \n\nesse foi o padr\u00e3o utilizado.  \n\nDessa maneira, o significando do resultado (SR) assume a seguinte forma exposta \n\nabaixo: \n\n \n\nSR = 1.100111100101101011011102  \n\n \n\n Observa-se que, com essa opera\u00e7\u00e3o, o bit menos significativo foi truncado. O n\u00famero \n\nresultante dessa opera\u00e7\u00e3o \u00e9 o mais pr\u00f3ximo do resultado visto na equa\u00e7\u00e3o 2.4 para um vetor \n\nde bits de tamanho menor em um bit. Caso o n\u00famero visto na equa\u00e7\u00e3o 2.4 fosse arredondado \n\npara o seguinte vetor de bits \u201c1.10011110010110101101111\u201d, o erro introduzido com a \n\naproxima\u00e7\u00e3o desse n\u00famero seria maior do que o visto no significando SR exposto acima. Com \n\nisso, o n\u00famero foi \u201carredondado para baixo\u201d, foi truncado. \n\nO significando resultante, j\u00e1 sem o bit expandido gerado pelo processo de soma, \n\nencontra-se exposto a seguir. Esse valor equivale ao significando do n\u00famero \u201c12.94859\u201d, \n\nexposto na tabela 2: \n\nSR = 1.100111100101101011011102   \n\n \n\n A \u00faltima etapa envolve apenas a retirada do bit impl\u00edcito para o retorno a nota\u00e7\u00e3o de \n\nvinte e tr\u00eas bits de mantissa. \n\n \n\n2.3.9 Algoritmo de Multiplica\u00e7\u00e3o em Ponto Flutuante \n\n \n\nA opera\u00e7\u00e3o de multiplica\u00e7\u00e3o, diferentemente da opera\u00e7\u00e3o de soma e subtra\u00e7\u00e3o, n\u00e3o \n\nexige que os operandos passem por ajustes antes de serem operados. Isso ocorre porque n\u00e3o \n\nh\u00e1 a necessidade de alinhamento dos pontos separadores dos n\u00fameros a serem operados. Com \n\nisso, os significandos dos n\u00fameros j\u00e1 podem ser operados diretamente.  \n\nBasicamente, o algoritmo de multiplica\u00e7\u00e3o segue o seguinte padr\u00e3o: \n\n? Soma dos expoentes: Nessa etapa, ocorre a soma dos expoentes de entrada entre si para gerar \n\no expoente resultante. \n\n? Multiplica\u00e7\u00e3o dos significandos: Os significandos devem passar por um processo de \n\nmultiplica\u00e7\u00e3o normal entre si. O n\u00famero de bits resultante dessa opera\u00e7\u00e3o corresponde \u00e0 soma \n\ndos n\u00fameros de bits de cada um dos significandos. \n\n? Normaliza\u00e7\u00e3o: Etapa de ajuste do resultado da multiplica\u00e7\u00e3o para a representa\u00e7\u00e3o padr\u00e3o. \n\n? Arredondamento: Etapa onde o n\u00famero obtido \u00e9 ajustado para se retornar \u00e0 nota\u00e7\u00e3o com o \n\nmesmo n\u00famero de bits iniciais. \n\n\n\n41 \n\n \n\n \n\n? Defini\u00e7\u00e3o do sinal de resposta: O sinal resultante da opera\u00e7\u00e3o \u00e9 feito realizando-se uma \n\nopera\u00e7\u00e3o de XOR, ou \u201cOU EXCLUSIVO\u201d com os sinais dos operandos. \n\n \n\n              Como exemplo, pode-se realizar a multiplica\u00e7\u00e3o dos respectivos n\u00fameros: -2.4 e 9.8, \n\nque corresponde a -23.52, demonstrada abaixo: \n\n \n\n?2.4 ? 9.8 =  ?23.52               \n\n \n\nA tabela 4 a seguir demonstra a representa\u00e7\u00e3o dos operandos no formato IEEE-754. \n\nOs operandos foram nomeados como A, B e C para facilitar sua descri\u00e7\u00e3o.  \n\nA tabela 5 a seguir apresenta os operandos separados em sinal, expoente e mantissa. \n\n \n\nTabela 4 - Representa\u00e7\u00e3o de alguns n\u00fameros em ponto flutuante \n\n \n\nOperando Nota\u00e7\u00e3o Decimal Nota\u00e7\u00e3o bin\u00e1ria padr\u00e3o IEEE-754 \n\nA -2.410 110000000001100110011001100110102 \n\nB 9.810 010000010001110011001100110011012 \n\nC -23.5210 110000011011110000101000111101112 \n\n               \n\nTabela 5 - Operandos em ponto flutuante separados em componentes para multiplica\u00e7\u00e3o \n\n \n\nOperando Sinal (S) Expoente (E) Mantissa (M) \n\nA 1 100000002  1.001100110011001100110102* \n\nB 0 100000102  1.001110011001100110011012* \n\nC 1 100000112  1.011110000101000111101112* \n\n*As mantissas encontram-se representadas com o bit impl\u00edcito no algarismo mais significativo, pois os n\u00fameros por padr\u00e3o \n\ns\u00e3o representados como j\u00e1 normalizados. \n\n \n\nComo dito anteriormente, a primeira etapa corresponde \u00e0 soma dos expoentes. \u00c9 \n\nimportante destacar que, ap\u00f3s a etapa de soma dos expoentes, \u00e9 necess\u00e1rio se realizar uma \n\nsubtra\u00e7\u00e3o nesse resultado. Essa subtra\u00e7\u00e3o corresponde ao valor do bias para n\u00fameros em \n\nponto flutuante em precis\u00e3o simples. O valor do bias corresponde a 127 para n\u00fameros em \n\nponto flutuante em precis\u00e3o simples. Isso ocorre porque ambos os n\u00fameros a serem somados \n\nj\u00e1 possuem implicitamente esse bias j\u00e1 somados a seus expoentes. Portanto, quando somados, \n\nteriam seus bias tamb\u00e9m somados, gerando um n\u00famero incorreto. Para sanar essa \n\nirregularidade, a subtra\u00e7\u00e3o de um dos bias \u00e9 necess\u00e1ria. A opera\u00e7\u00e3o de soma do expoente do \n\nprimeiro operando (EA) e a do segundo operando (EB) pode ser observada a seguir: \n\n\n\n42 \n\n \n\n \n\n \n\nEA + EB = 100000002 + 100000102 - 011111112 = 100000112   \n\n \n\nEm seguida, os significandos devem ser multiplicados. Ao multiplic\u00e1-los, o n\u00famero \n\nresultante ter\u00e1 o n\u00famero de bits correspondente \u00e0 soma do n\u00famero de bits dos dois \n\nsignificandos. Esse n\u00famero expandido deve ser preservado para n\u00e3o se perder precis\u00e3o at\u00e9 \n\nque a devida etapa de arredondamento seja executada. Pode-se observar o resultado da \n\nmultiplica\u00e7\u00e3o dos dois significandos (SA e SB) a seguir: \n\n \n\nSA * SB = 1.001100110011001100110102 * 1.001110011001100110011012 = \n\n1.01111000010100011110110011111010111000010100102   \n\n \n\nObserva-se que o significando do resultado (SR) tem a seguinte forma: \n\n \n\nSR = 1.01111000010100011110110   011111010111000010100102 \n\n \n\nO significando resultante exposto acima possui os vinte e tr\u00eas \u00faltimos bits separados \n\ndos vinte e quatro bits mais significativos. A op\u00e7\u00e3o por essa representa\u00e7\u00e3o \u00e9 meramente \n\ndid\u00e1tica e visa simplificar o processo de entendimento do arredondamento.  \n\nOs \u00faltimos bits do significando resultante s\u00e3o necess\u00e1rios apenas para crit\u00e9rios de \n\narredondamento. \u00c9 feita uma verifica\u00e7\u00e3o para se saber qual o n\u00famero represent\u00e1vel mais \n\npr\u00f3ximo do significando resultante com a quantidade de bits exigida pelo padr\u00e3o. Com isso, o \n\narredondamento procura minimizar o erro introduzido por esse processo. Isso implica que o \n\nbit menos significativo dos vinte e quatro bits mais significativos deve ter seu valor somado \n\ncom um. Eventuais estouros resultantes dessa soma devem ser propagados ao longo dos \n\ndemais bits.  \n\nO significando resultante, j\u00e1 com a soma gerada pelo processo de arredondamento, \n\nse encontra exposto a seguir. Esse valor equivale ao significando de -23.52 em base decimal, \n\nexposto na tabela 4. \n\n \n\nSR = 1.011110000101000111101112    \n\n \n\nA \u00faltima etapa envolve apenas a retirada do bit impl\u00edcito para o retorno a nota\u00e7\u00e3o de \n\nvinte e tr\u00eas bits de mantissa. \n\n \n\n\n\n43 \n\n \n\n \n\n2.3.10  Algoritmo de Normaliza\u00e7\u00e3o \n \n\nOs n\u00fameros em ponto flutuante representados no padr\u00e3o IEEE-754 encontram-se \n\nnormalizados. Eles possuem um bit impl\u00edcito, diferente de zero, na parte mais significativa de \n\nsua mantissa.  \n\nPara que um n\u00famero bin\u00e1rio em ponto flutuante esteja no padr\u00e3o, \u00e9 necess\u00e1rio que \n\nocorra uma etapa de normaliza\u00e7\u00e3o ao final de suas opera\u00e7\u00f5es aritm\u00e9ticas. Essa etapa visa \n\najustar o significando para que possua um \u00fanico bit, que seja diferente de zero, antes do ponto \n\nseparador. Isso faz com que seja necess\u00e1rio fazer uma verifica\u00e7\u00e3o da quantidade de bits antes \n\ndo ponto separador ao fim das opera\u00e7\u00f5es.  \n\nAo final de alguma opera\u00e7\u00e3o aritm\u00e9tica, caso haja mais de um bit a esquerda do \n\nponto separador, \u00e9 necess\u00e1rio se realizar uma normaliza\u00e7\u00e3o. Se esses bits forem diferentes de \n\nzero, efetuam-se deslocamentos para direita do significando at\u00e9 que haja apenas um bit antes \n\ndo ponto separador. Como um deslocamento \u00e0 direita, nesse caso, equivale a uma divis\u00e3o por \n\ndois, deve-se somar ao expoente o n\u00famero de deslocamentos realizados para n\u00e3o ocorrer uma \n\nperda de representa\u00e7\u00e3o.  \n\nCaso o bit antes do ponto seja igual a zero, tamb\u00e9m \u00e9 necess\u00e1rio realizar uma \n\nopera\u00e7\u00e3o de normaliza\u00e7\u00e3o. Nesse caso, deve-se deslocar o significando para a esquerda at\u00e9 \n\nque o bit antes do ponto se torne diferente de zero. Como um deslocamento para a esquerda \n\ncorresponde a uma multiplica\u00e7\u00e3o pela base, deve-se subtrair do expoente o n\u00famero de \n\ndeslocamentos realizados. Isso ocorre para que n\u00e3o haja perda de representa\u00e7\u00e3o num\u00e9rica. \n\nBasicamente, pode-se dizer que o algoritmo de normaliza\u00e7\u00e3o segue os seguintes \n\npassos: \n\n1. Identifica\u00e7\u00e3o do posicionamento do primeiro bit igual a um do significando. \n\n2. C\u00e1lculo da dist\u00e2ncia desse bit at\u00e9 a posi\u00e7\u00e3o do bit impl\u00edcito. Caso esteja \u00e0 \n\nesquerda, a dist\u00e2ncia \u00e9 positiva; caso esteja \u00e0 direita, a dist\u00e2ncia \u00e9 negativa. \n\n3. Realiza\u00e7\u00e3o do deslocamento dos bits do significando at\u00e9 que o bit impl\u00edcito se \n\ntorne diferente de zero. \n\n4. Ajuste do expoente de acordo com o n\u00famero de deslocamentos realizados no \n\nsignificando. Soma-se a dist\u00e2ncia obtida no segundo passo ao expoente. \n\n5. O n\u00famero obtido \u00e9 verificado quanto \u00e0 necessidade de arredondamento. \n\n \n\n \n\n\n\n44 \n\n \n\n \n\n2.3.11  Algoritmo de Arredondamento \n\n \n\nDe acordo com BARROS (2008, p. 27): \n\n \nO termo arredondamento segundo o padr\u00e3o IEEE 754 \u00e9 o processo de ajustar ou \n\nencaixar um n\u00famero tido como \u201cinfinitamente preciso\u201d em um formato de menor \n\nprecis\u00e3o, que n\u00e3o disp\u00f5e de todos os d\u00edgitos necess\u00e1rios a sua representa\u00e7\u00e3o com a \n\nprecis\u00e3o original. \n\n \n\nConsequentemente, ao realizar opera\u00e7\u00f5es aritm\u00e9ticas com n\u00fameros em ponto \n\nflutuante, haver\u00e1 sempre a introdu\u00e7\u00e3o de um erro inerente ao processo de arredondamento. \n\nEsse erro de arredondamento \u00e9 algo caracter\u00edstico da aritm\u00e9tica computacional e j\u00e1 gerou \n\ndiversos problemas (COE, 1996).  \n\nO padr\u00e3o IEEE-754 estabelece alguns algoritmos de arredondamento para seus \n\nn\u00fameros. Nesse caso, entende-se, por arredondamento, o processo de redu\u00e7\u00e3o do n\u00famero de \n\nbits de um n\u00famero para a quantidade de bits definida pelo padr\u00e3o. Naturalmente, apesar de \n\nprovocar a perda de representa\u00e7\u00e3o num\u00e9rica, essa etapa se faz necess\u00e1ria, caso contr\u00e1rio, \n\npoder-se-ia ter n\u00fameros de representa\u00e7\u00e3o infinita de bits, o que \u00e9 absurdo, dadas as limita\u00e7\u00f5es \n\ndos recursos computacionais.   \n\nAs formas de arredondamento s\u00e3o: \n\n? Arredondamento em dire\u00e7\u00e3o ao infinito positivo: Nesse caso, os n\u00fameros positivos devem \n\nser arredondados para o mais pr\u00f3ximo em dire\u00e7\u00e3o ao infinito positivo. Os n\u00fameros negativos \n\ns\u00e3o arredondados em dire\u00e7\u00e3o do zero. \n\n?  Arredondamento em dire\u00e7\u00e3o ao infinito negativo: Nesse caso, os n\u00fameros negativos \n\ndevem ser arredondados para o mais pr\u00f3ximo em dire\u00e7\u00e3o ao infinito negativo. Os n\u00fameros \n\npositivos s\u00e3o arredondados em dire\u00e7\u00e3o do zero. \n\n? Arredondamento em dire\u00e7\u00e3o ao zero: Tamb\u00e9m denominada de truncamento, essa forma \n\nconsiste apenas em arredondar o n\u00famero para o mais pr\u00f3ximo represent\u00e1vel em dire\u00e7\u00e3o ao \n\nzero.  \n\n? Arredondamento em dire\u00e7\u00e3o ao mais pr\u00f3ximo ou par: Esse modo arredonda o n\u00famero \n\npara o mais pr\u00f3ximo represent\u00e1vel do valor original. Para os casos onde o n\u00edvel de \n\nproximidade \u00e9 o mesmo entre dois n\u00fameros, arredonda-se para o pr\u00f3ximo par por conven\u00e7\u00e3o.  \n\nDentre as formas de arredondamento citadas acima, a recomenda\u00e7\u00e3o dada pelo IEEE \n\n\u00e9 a \u00faltima: arredondamento em dire\u00e7\u00e3o ao mais pr\u00f3ximo ou par. Isso ocorre porque esta forma \n\nde arredondamento apresenta a menor taxa de erro entre as t\u00e9cnicas citadas. Com isso, esse se \n\ntornou o modo de arredondamento mais utilizado nas implementa\u00e7\u00f5es que usam o padr\u00e3o \n\n\n\n45 \n\n \n\n \n\nIEEE-754. \u00c9 importante destacar que, apesar de essa ser a forma mais eficiente em termos de \n\nprecis\u00e3o, \u00e9 a mais custosa em termos de recursos computacionais.  \n\n \n\n2.3.12   Representa\u00e7\u00e3o de valores especiais \n\n \n\nOs valores ditos especiais correspondem a uma s\u00e9rie de n\u00fameros que, caso n\u00e3o \n\nsejam tratados de maneira distinta, podem gerar incongru\u00eancias. Alguns, inclusive, n\u00e3o \n\npossuem representa\u00e7\u00e3o num\u00e9rica, apenas simb\u00f3lica e conceitual. Alguns desses casos tamb\u00e9m \n\npossuem apenas uma formaliza\u00e7\u00e3o de um n\u00famero que n\u00e3o se encaixa na representa\u00e7\u00e3o bin\u00e1ria \n\nutilizada. \n\nA seguir, est\u00e3o expostos os principais casos especiais: \n\n? Infinito: Nota\u00e7\u00e3o que demonstra que um determinado n\u00famero \u00e9, em m\u00f3dulo, maior que o \n\nmaior n\u00famero represent\u00e1vel pelo padr\u00e3o. Surge como resultado de algumas opera\u00e7\u00f5es na \n\naritm\u00e9tica padr\u00e3o, como a divis\u00e3o de um n\u00famero diferente de zero pelo pr\u00f3prio zero. Possui \n\numa representa\u00e7\u00e3o positiva e negativa. \n\n? Zero: \u00c9 representado como um conjunto de bits zero, desconsiderando-se o bit de sinal. O \n\nzero tamb\u00e9m possui sinal positivo e negativo, afim de preservar o sentido de aproxima\u00e7\u00e3o da \n\nfun\u00e7\u00e3o. \n\n? NaN: Nota\u00e7\u00e3o que, traduzida do ingl\u00eas \u201cNot a Number\u201d, literalmente corresponde a um \u201cn\u00e3o \n\nn\u00famero\u201d. Essa representa\u00e7\u00e3o surge em casos onde a aritm\u00e9tica padr\u00e3o n\u00e3o consegue \n\nrepresenta\u00e7\u00e3o nos n\u00fameros reais. Dentre elas, pode-se citar a divis\u00e3o de zero por zero, a raiz \n\nde menos um e a soma de infinito positivo com infinito negativo. Essa representa\u00e7\u00e3o, \n\ndiferentemente das anteriores, n\u00e3o necessita de nota\u00e7\u00e3o de sinal, podendo assumir qualquer \n\nvalor sem gerar impacto para as opera\u00e7\u00f5es. Qualquer n\u00famero operado com um NaN deve \n\ngerar outro NaN, fazendo com que o resultado da opera\u00e7\u00e3o tamb\u00e9m seja invalidado.  \n\n? Denormal: Corresponde a uma faixa de valores de n\u00fameros ditos muito \n\npequenos. Como correspondem a n\u00fameros que est\u00e3o al\u00e9m da precis\u00e3o necess\u00e1ria para sua \n\nrepresenta\u00e7\u00e3o, n\u00e3o \u00e9 poss\u00edvel represent\u00e1-los devidamente em modo normalizado. Comumente, \n\ns\u00e3o tratados como zero para economia de recursos. \n\n \n\nA tabela 6 a seguir exp\u00f5e a representa\u00e7\u00e3o num\u00e9rica bin\u00e1ria dos casos especiais \n\npresentes no padr\u00e3o.  \n\n \n\n\n\n46 \n\n \n\n \n\nTabela 6 - Representa\u00e7\u00e3o de valores especiais no padr\u00e3o IEEE-754 \n\n \n\nTipo Sinal Expoente Fra\u00e7\u00e3o do significando \n\n+ Infinito 0 11111111 00000000000000000000000 \n\n- Infinito 1 11111111 00000000000000000000000 \n\nZero +/- 00000000 00000000000000000000000 \n\nNaN           +/- 11111111 xxxxxxxxxxxxxxxxxxxxxxx \n\nDenormal +/- 00000000 xxxxxxxxxxxxxxxxxxxxxxx \n\n \n\nNa tabela 6, os algarismos representados com \u201cx\u201d denotam uma palavra bin\u00e1ria na \n\nqual pelo menos um dos seus bits \u00e9 diferente de zero. Os casos de \u201czero\u201d, \u201cNaN\u201d e \n\n\u201cDenormal\u201d podem vir  sinalizados tanto com o sinal positivo quanto de negativo.  \n\n\u00c9 importante destacar que, no caso das fra\u00e7\u00f5es dos significandos dos NaN\u00b4s e dos \n\nn\u00fameros ditos denormais, os bits podem assumir qualquer valor ap\u00f3s o ponto sem que isso \n\nafete sua classifica\u00e7\u00e3o como valor especial. Por\u00e9m, ao menos um desses bits tem que ser \n\ndiferente de zero, caso contr\u00e1rio, o n\u00famero cairia na representa\u00e7\u00e3o de outro caso especial, \n\ncomo o de infinito, por exemplo. \n\n \n\n2.4 Algoritmo de An\u00e1lises S\u00edsmicas do Solo - RTM \n\n \n\nPara se realizar a explora\u00e7\u00e3o de camadas geol\u00f3gicas, faz-se necess\u00e1rio o uso de \n\nalgum m\u00e9todo de an\u00e1lise do solo, ou m\u00e9todo s\u00edsmico. Esses m\u00e9todos permitem a identifica\u00e7\u00e3o \n\ndas camadas do solo em subsuperf\u00edcie.  \n\nDentre as aplica\u00e7\u00f5es dos m\u00e9todos s\u00edsmicos, pode-se destacar a sismologia de \n\nexplora\u00e7\u00e3o. Essa \u00e1rea \u00e9 respons\u00e1vel pela explora\u00e7\u00e3o e produ\u00e7\u00e3o de hidrocarbonetos em \n\nprofundidades de at\u00e9 10km. Essa \u00e1rea lida com os m\u00e9todos de explora\u00e7\u00e3o e produ\u00e7\u00e3o de \n\npetr\u00f3leo e g\u00e1s (ROCHA, 2010). \n\nA s\u00edsmica de reflex\u00e3o \u00e9 a t\u00e9cnica de explora\u00e7\u00e3o geol\u00f3gica mais comum na ind\u00fastria \n\npetrol\u00edfera. Nela, inicialmente, \u00e9 escolhido um local onde ser\u00e1 posicionada uma malha de \n\nreceptores (hidrofones ou geofones). Em seguida, \u00e9 posicionada e detonada uma carga capaz \n\nde gerar ondas s\u00edsmicas. Estas ondas percorrem o meio e tem parte de sua energia propagada \n\nsob forma de reflex\u00e3o. Essas reflex\u00f5es ocorrem com mais intensidade nas interfaces entre as \n\ncamadas geol\u00f3gicas. Isso ocorre porque diferentes camadas de solo possuem diferentes \n\ncaracter\u00edsticas de propaga\u00e7\u00e3o e densidade. Essas caracter\u00edsticas provocam modifica\u00e7\u00f5es nos \n\n\n\n47 \n\n \n\n \n\ntempos de propaga\u00e7\u00e3o e amplitude das ondas refletidas que, por usa vez, s\u00e3o captadas pelos \n\nreceptores posicionados na superf\u00edcie (ROCHA, 2010).  \n\nA figura 8 a seguir exp\u00f5e, simplificadamente, como funciona o m\u00e9todo de reflex\u00e3o \n\ns\u00edsmica para uma carga no mar. \n\n \n\nFigura 8 - M\u00e9todo de reflex\u00e3o s\u00edsmica \n\n \n\n \n\n \n\nO algoritmo de an\u00e1lises s\u00edsmicas implementado nessa disserta\u00e7\u00e3o foi o RTM. Para \n\nresolver o m\u00e9todo de reflex\u00e3o s\u00edsmica atrav\u00e9s desse algoritmo, \u00e9 necess\u00e1rio analisar a equa\u00e7\u00e3o \n\nde onda, visto que \u00e9 atrav\u00e9s delas que \u00e9 feita a an\u00e1lise geol\u00f3gica nesse caso. Para isso, pode-se \n\nfazer uso de estrat\u00e9gias matem\u00e1ticas que solucionam essa equa\u00e7\u00e3o. \n\nA an\u00e1lise s\u00edsmica utiliza um m\u00e9todo matem\u00e1tico que resolve a equa\u00e7\u00e3o de onda \n\nassumindo que os campos de press\u00e3o podem se propagar a partir de um pulso s\u00edsmico inicial. \n\nInicialmente, se considera que eles se propagam da fonte de ondas s\u00edsmicas para receptores \n\ncomo hidrofones ou geofones, etapa denominada modelagem. Em seguida, considera-se que \n\neles se propagam dos receptores para a fonte de ondas s\u00edsmicas, etapa denominada migra\u00e7\u00e3o \n\n(ROCHA, 2010). \n\nA equa\u00e7\u00e3o de onda ac\u00fastica mais simples no espa\u00e7o 3D \u00e9 mostrada abaixo: \n\n \n\n?2?(?,?,?,?)\n\n??2\n+\n\n?2?(?,?,?,?)\n\n??2\n+\n\n?2?(?,?,?,?)\n\n?? 2\n?\n\n1\n\n?2(?,?,?)\n\n?2?(?,?,?,?)\n\n??2\n= 0,              (2.5) \n\n \n\n\n\n48 \n\n \n\n \n\nOnde: \n?2?(?,?,?,?)\n\n??2\n,\n\n?2?(?,?,?,?)\n\n??2\n,\n\n?2?(?,?,?,?)\n\n?? 2\n ? \n\n?2?(?,?,?,?)\n\n??2\n s\u00e3o, respectivamente, as \n\nderivadas de segunda ordem em rela\u00e7\u00e3o ao eixo x, eixo y, eixo z e ao tempo t e v(x,y,z) \n\nrepresenta a velocidade de propaga\u00e7\u00e3o da onda no ponto de coordenadas x, y e z, que \n\ncorrespondem \u00e0s coordenadas espaciais horizontal, vertical e de profundidade. \n\nDevido ao fato da equa\u00e7\u00e3o 2.5 ser uma equa\u00e7\u00e3o diferencial sem uma resolu\u00e7\u00e3o \n\nalg\u00e9brica para sistemas com grandes varia\u00e7\u00f5es de velocidade, o algoritmo RTM faz uso de \n\numa resolu\u00e7\u00e3o constru\u00edda atrav\u00e9s de um operador de diferen\u00e7as finitas\n11\n\n (BARROS, 2014). \n\nA modelagem s\u00edsmica via RTM \u00e9 feita atrav\u00e9s da resolu\u00e7\u00e3o da equa\u00e7\u00e3o de diferen\u00e7as \n\nfinitas para cada ponto do modelo ao longo de determinados espa\u00e7os de tempo. Isso resulta \n\nem um modelo s\u00edsmico em tr\u00eas dimens\u00f5es para o m\u00e9todo de migra\u00e7\u00e3o reversa no tempo. \n\nPara se resolver a equa\u00e7\u00e3o de diferen\u00e7as finitas, s\u00e3o utilizadas tr\u00eas matrizes de \n\npress\u00e3o ac\u00fastica exercida por um pulso s\u00edsmico propagado por um sismograma\n12\n\n. Uma delas \n\npara modelar a press\u00e3o ac\u00fastica no tempo atual, outra para modelar a press\u00e3o ac\u00fastica no \n\ntempo anterior, e a terceira para modelar a press\u00e3o ac\u00fastica no tempo futuro.  \n\nEm cada etapa da simula\u00e7\u00e3o, essas tr\u00eas matrizes de campos de press\u00e3o se sobrep\u00f5em \n\numas as outras. Com isso, a matriz do tempo futuro se torna a matriz do tempo presente e a \n\nmatriz do tempo presente se torna a matriz do tempo anterior. Pode-se observar o esbo\u00e7o \n\ndessa simula\u00e7\u00e3o na figura 9 a seguir. \n\nEm seguida, substitui-se o pulso s\u00edsmico pela propaga\u00e7\u00e3o inversa da onda, ou seja, a \n\npropaga\u00e7\u00e3o ocorre em sentido contr\u00e1rio ao pulso inicialmente gerado. Ao final, os dados \n\nobtidos com essas simula\u00e7\u00f5es geram uma matriz que \u00e9 convertida em uma imagem. Nessa \n\nimagem, espera-se que sejam destacadas as interfaces das camadas em subsuperf\u00edcie \n\n(SANTOS, 2012). \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n                                                 \n11\n\n O m\u00e9todo de diferen\u00e7as finitas consiste na substitui\u00e7\u00e3o das derivadas presentes na equa\u00e7\u00e3o em estudo, por \n\naproxima\u00e7\u00f5es alg\u00e9bricas de diferen\u00e7as obtidas a partir da expans\u00e3o em s\u00e9rie de Taylor. (SANTOS, 2012). \n12\n\n Um sismograma \u00e9 o registro da atividade s\u00edsmica ocorrida em uma determinada regi\u00e3o. (BARROS, 2014). \n\n\n\n49 \n\n \n\n \n\nFigura 9 - Simula\u00e7\u00e3o da propaga\u00e7\u00e3o de um pulso s\u00edsmico por um campo de press\u00e3o. \n\n \n\n \n\nFonte: BARROS, 2014, P. 40 \n\n \n\nA equa\u00e7\u00e3o de diferen\u00e7as finitas para esse modelo \u00e9 apresentada abaixo: \n\n \n\n???? =  2.0 ? ???? ? (???? ? ???? ? ???? ) + (???? ? ???? ? ???? )\n2\n\n? {??? ? ??? ? ???\n\n? [?1 ? (????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2) + 16\n\n? (????1? + ???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1) ?  90 ? (????   )]\n\n? ???? }                 (2.6) \n\n \n\nOnde ????, ???? e ???? representam o elemento localizado na posi\u00e7\u00e3o i, j e k das \n\nmatrizes. Essas vari\u00e1veis representam o campo de press\u00e3o nos tempos n-1, n e n+1 e modelam \n\na propaga\u00e7\u00e3o da onda ac\u00fastica tanto no espa\u00e7o quanto no tempo. \n\nO termo ??? representa a velocidade da propaga\u00e7\u00e3o do pulso s\u00edsmico da onda \n\natrav\u00e9s do meio. Essa \u00e9 uma caracter\u00edstica das camadas geol\u00f3gicas que est\u00e3o sendo modeladas \n\ne depende da composi\u00e7\u00e3o do terreno.  \n\nO termo ??? corresponde a uma constante de calibra\u00e7\u00e3o da equa\u00e7\u00e3o que \u00e9 calculada \n\nlevando-se em conta alguns par\u00e2metros escolhidos na execu\u00e7\u00e3o do RTM. Dentre eles, pode-se \n\ndestacar o espa\u00e7amento entre os pontos da malha e a frequ\u00eancia de corte da onda s\u00edsmica que \n\nser\u00e1 propagada no modelo. \n\nA Figura 10 a seguir ilustra a associa\u00e7\u00e3o das matrizes utilizadas para suprir a \n\nequa\u00e7\u00e3o de propaga\u00e7\u00e3o de onda discretizada utilizadas pelo RTM. Nessa figura, observa-se o \n\nmodelo de velocidades utilizado, o Marmousi (1988).  \n\n\n\n50 \n\n \n\n \n\n \n\nFigura 10 - Equa\u00e7\u00e3o de propaga\u00e7\u00e3o da onda e suas respectivas matrizes de processamento \n\n \n\n \n\nFonte: MEDEIROS, 2013, P. 14 \n\n \n\nPara calcular o ponto ???? da matriz do campo de onda no tempo n+1, s\u00e3o \n\nnecess\u00e1rios pontos das matrizes ????, ????, como visto na equa\u00e7\u00e3o 2.6.  \n\nNa figura 11 a seguir, pode-se observar a estrutura e a disposi\u00e7\u00e3o dos dados \n\nnecess\u00e1rios para o c\u00e1lculo do ponto de interesse.  \u00c9 importante salientar que os elementos da \n\nmatriz B, ilustrados na figura 11, s\u00e3o vistos sob uma perspectiva de duas dimens\u00f5es apenas, \n\nisso foi feito para facilitar a observa\u00e7\u00e3o dos demais elementos.  \n\nComo exposto na equa\u00e7\u00e3o 2.6, a matriz B possui tr\u00eas dimens\u00f5es. Foi com base nessa \n\nrepresenta\u00e7\u00e3o da equa\u00e7\u00e3o que foi elaborada a arquitetura em hardware para a solu\u00e7\u00e3o do \n\nm\u00e9todo s\u00edsmico. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n51 \n\n \n\n \n\n \n\nFigura 11 - Dados de entrada da equa\u00e7\u00e3o de diferen\u00e7as finitas no RTM \n\n \n\n \n\n \n\n2.5 Conclus\u00f5es \n \n\nNeste cap\u00edtulo, foi feita a fundamenta\u00e7\u00e3o de alguns dos temas abordados nesse \n\ntrabalho. Essa etapa adquire grande import\u00e2ncia quando se leva em considera\u00e7\u00e3o o car\u00e1ter \n\nabrangente em temas da \u00e1rea computacional presentes nessa disserta\u00e7\u00e3o. \n\nInicialmente, foi feito um debate sobre computa\u00e7\u00e3o de alto desempenho, fazendo-se \n\numa breve compara\u00e7\u00e3o entre ASIC\u00b4s, CPU\u00b4s e FPGA\u00b4s. Em seguida, foi feita uma melhor \n\nexplana\u00e7\u00e3o sobre a constitui\u00e7\u00e3o dos FPGA\u00b4s e seu funcionamento. \n\nAp\u00f3s essas descri\u00e7\u00f5es, realizou-se uma introdu\u00e7\u00e3o \u00e0 aritm\u00e9tica em ponto flutuante e \n\nsua presen\u00e7a na computa\u00e7\u00e3o atual. Em seguida, foi debatido, de maneira introdut\u00f3ria, o \n\npadr\u00e3o IEEE-754 para n\u00fameros bin\u00e1rios em ponto flutuante. Durante essa explica\u00e7\u00e3o, foram \n\nabordados desde a nota\u00e7\u00e3o utilizada at\u00e9 a maneira recomendada de ser realizar algumas \n\nopera\u00e7\u00f5es aritm\u00e9ticas e tratar casos especiais. Essa se\u00e7\u00e3o mostrou-se uma das mais \n\n\n\n52 \n\n \n\n \n\nimportantes, visto que o foco desse trabalho est\u00e1 no desenvolvimento de um m\u00f3dulo \n\naritm\u00e9tico capaz de obedecer aos crit\u00e9rios determinados por esse padr\u00e3o.  \n\nPor fim, foi abordado o algoritmo de an\u00e1lises s\u00edsmicas do solo utilizado pela \n\nind\u00fastria petrol\u00edfera para descobrir po\u00e7os de hidrocarbonetos. \u00c9 justamente uma parte deste \n\nalgoritmo, no caso o n\u00facleo aritm\u00e9tico, que \u00e9 o foco desta disserta\u00e7\u00e3o e foi prototipada para a \n\nFPGA. \n\n \n\n  \n\n\n\n53 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n3 \n3. Trabalhos relacionados \n\n \n\n \n\n Esse cap\u00edtulo tem, por objetivo, discutir e apresentar trabalhos relacionados ao tema \n\ndesta disserta\u00e7\u00e3o. Dentre os t\u00f3picos a serem analisados, o foco se d\u00e1 na implementa\u00e7\u00e3o de \n\ncores aritm\u00e9ticos em FPGA. \n\n \n\n  \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n  \n\n\n\n54 \n\n \n\n \n\n3.1 64 bit Floating Point FPGA Matrix Multiplication - Dou, Yong; Vassiliadis, \n\nS.; Kuzmanov (2005). \n\n \n\nNeste trabalho \u00e9 descrito em detalhes a implementa\u00e7\u00e3o de um multiplicador e \n\nacumulador em ponto flutuante de precis\u00e3o dupla. O foco dado por Dou (2005) est\u00e1 na \n\narquitetura desenvolvida para a realiza\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes densas. Essa \n\narquitetura implementa o reuso e explora a localidade de dados, reduzindo, assim, o \n\nthroughput de acesso \u00e0  mem\u00f3ria. Para tanto foi implementado um pipeline\n13\n\n de 12 est\u00e1gios, \n\nbem como, uma arquitetura de controle e acesso a dados. \n\nNesse trabalho \u00e9 proposta uma arquitetura mista do tipo Single Program Multiple \n\nData (SPMD). Para isso, um processador de prop\u00f3sito geral prov\u00ea os dados e controle a \n\nprocessadores de prop\u00f3sito espec\u00edfico, no caso, os multiplicadores e acumuladores.  \n\nPode-se observar uma vis\u00e3o geral da arquitetura proposta por Yong Dou na figura \n\n12, a seguir. Nela existem 39 processadores de prop\u00f3sito espec\u00edfico, respons\u00e1veis por realizar \n\no produto interno de uma linha, de uma matriz, pela coluna da outra matriz de entrada. \n\n \n\nFigura 12 - Arquitetura de multiplica\u00e7\u00e3o de matrizes proposta por Young Dou. \n\n \n\n \n\n                                                 \n13\n\n T\u00e9cnica de hardware que disp\u00f5es as instru\u00e7\u00f5es a serem executadas em uma fila de mem\u00f3ria dentro do \n\nprocessador. Assim que uma instru\u00e7\u00e3o termina um est\u00e1gio, segue para o est\u00e1gio posterior e a pr\u00f3xima instru\u00e7\u00e3o \n\nj\u00e1 ocupa seu est\u00e1gio. \n\n\n\n55 \n\n \n\n \n\n Na figura 13 a seguir est\u00e1 exposta a estrutura de pipeline do multiplicador \n\nacumulador desenvolvido. Observa-se que as unidades de multiplica\u00e7\u00e3o possuem 9 \n\nmultiplicadores de 18 por 18 bits, o que implica em uma l\u00f3gica de particionamento do \n\nsignificando de acordo com os multiplicadores dispon\u00edveis na placa utilizada. Foi utilizada \n\numa \u00e1rvore de somas para as opera\u00e7\u00f5es dos produtos parciais gerados pela unidade de \n\nmultiplica\u00e7\u00e3o. Nota-se a presen\u00e7a de uma unidade de soma para lidar com o resultado das \n\n\u00e1rvores de soma e com um n\u00famero advindo da mem\u00f3ria. As demais unidades incluem uma \n\nunidade de leading zeros, para contagem de zeros da normaliza\u00e7\u00e3o e, posteriormente, seu \n\narredondamento. \n\n \n\nFigura 13 - Estrutura de Pipeline dos multiplicadores e acumuladores. \n\n \n\n \n\n Dentre os resultados obtidos por Dou, t\u00eam-se um desempenho de 15,6 Gflops, uma \n\nfrequ\u00eancia de 177Mhz e a ocupa\u00e7\u00e3o de 1419 slices em uma Xilinx Virtex II Pro XCV2P125. \n\n\n\n56 \n\n \n\n \n\n3.1.1 Conclus\u00f5es \n\n \n\nO trabalho de (DOU, 2005) exp\u00f5e um n\u00facleo aritm\u00e9tico para FPGA no padr\u00e3o IEEE-\n\n754. Apesar da aplica\u00e7\u00e3o e da precis\u00e3o adotadas por Dou (2005), serem diferentes da \n\naplica\u00e7\u00e3o proposta para esse trabalho, ambos fazem uso de opera\u00e7\u00f5es aritm\u00e9ticas padr\u00e3o \n\nIEEE-754 para FPGA\u00b4s.  \n\nO particionamento das opera\u00e7\u00f5es aritm\u00e9ticas ao longo de uma estrutura de pipeline \n\nfeito por DOU (2005), permitiu o aumento da frequ\u00eancia de opera\u00e7\u00e3o de seu n\u00facleo \n\naritm\u00e9tico. A estrat\u00e9gia de quebra de opera\u00e7\u00f5es em etapas menores e o armazenamento em \n\nregistradores de pipeline foi a mesma utilizada no n\u00facleo aritm\u00e9tico desta disserta\u00e7\u00e3o, apesar \n\ndas diferen\u00e7as de implementa\u00e7\u00e3o. \n\nO trabalho de Dou, assim como est\u00e1 disserta\u00e7\u00e3o, tamb\u00e9m faz uso de uma unidade de \n\ncontagem de zeros (leading zeros) durante a etapa de normaliza\u00e7\u00e3o. Por\u00e9m, (DOU, 2005) opta \n\npor particionar o processo de contagem em quatro est\u00e1gios de pipeline para ganho de \n\nfrequ\u00eancia de opera\u00e7\u00e3o. Enquanto o n\u00facleo aritm\u00e9tico apresentado nesta disserta\u00e7\u00e3o faz uso \n\nde uma etapa de l\u00f3gica combinacional (multiplexador\n14\n\n) e uma de l\u00f3gica sequencial (case) \n\npara a contagem dos zeros. O algoritmo de contagem (DOU, 2005) se mostra mais eficiente \n\nem FPGAs com menos recursos dispon\u00edveis como era seu caso com uma Xilinx Virtex II Pro \n\nXCV2P125. No entanto, para FPGAs mais modernas e com bem mais l\u00f3gica dispon\u00edvel, o \n\ngasto com a l\u00f3gica combinacional e mais vantajoso devido ao ganho na frequ\u00eancia de \n\nopera\u00e7\u00e3o. \n\n  \n\n3.2 Implementa\u00e7\u00e3o em FPGA de um modulo multiplicador aritm\u00e9tico de alto \n\ndesempenho para n\u00fameros de ponto flutuante de dupla precis\u00e3o, padr\u00e3o \n\nIEEE-754 \u2013 Barros A. C., Barbosa J. e Lima M. E (2008)  \n\n \n\nEste trabalho aborda o desenvolvimento de um m\u00f3dulo que atua como \n\ncoprocessador de aplica\u00e7\u00e3o espec\u00edfica para multiplica\u00e7\u00e3o de matrizes densas. O trabalho \n\napresenta uma unidade aritm\u00e9tica do tipo multiplicador e acumulador (MAC). Essa unidade \n\nfoi implementada em FPGA e faz uso do padr\u00e3o IEEE 754 para n\u00fameros em ponto flutuante \n\nde dupla precis\u00e3o. A arquitetura proposta foca na completa aplica\u00e7\u00e3o desse padr\u00e3o IEEE. Para \n\n                                                 \n14\n\n Dispositivo que seleciona dados de duas ou mais fontes de entrada em um \u00fanico canal de sa\u00edda. \n\n\n\n57 \n\n \n\n \n\ntanto, est\u00e3o presentes as etapas de opera\u00e7\u00f5es aritm\u00e9ticas, de normaliza\u00e7\u00e3o, arredondamento, \n\nbem como, os tratamentos das exce\u00e7\u00f5es previstos pelo citado padr\u00e3o IEEE. \n\nComo se pode observar na figura 14 a seguir, o MAC foi dividido em 11 est\u00e1gios de \n\npipeline. Ao longo de seu pipeline, destacam-se algumas estruturas, como uma unidade de \n\nsoma para a acumula\u00e7\u00e3o dos produtos parciais da multiplica\u00e7\u00e3o e unidades de compara\u00e7\u00e3o de \n\nexpoente, necess\u00e1rias para realiza\u00e7\u00e3o dos algoritmos de soma e multiplica\u00e7\u00e3o. Al\u00e9m disso, \n\nest\u00e3o presentes unidades para deslocamento ou shifts e complemento a dois, para modifica\u00e7\u00e3o \n\ndos n\u00fameros de entrada que est\u00e3o na nota\u00e7\u00e3o de sinal, expoente e mantissa. Observa-se ao \n\nlongo de todo o pipeline, uma unidade para tratamento de exce\u00e7\u00f5es. Esta unidade trata as \n\nexce\u00e7\u00f5es como a representa\u00e7\u00e3o para n\u00fameros infinitos e NaN\u00b4s. Isso \u00e9 feito atrav\u00e9s da an\u00e1lise \n\ndos n\u00fameros na entrada do MAC, bem como, da verifica\u00e7\u00e3o dos sinais gerados pelas demais \n\nestruturas presentes na arquitetura do pipeline.  \n\nEsse projeto foi realizado para se aproveitar o paralelismo entre as opera\u00e7\u00f5es \n\naritm\u00e9ticas. Com isso, opera\u00e7\u00f5es como a de soma parciais da multiplica\u00e7\u00e3o ocorrem \n\nsimultaneamente a soma de expoentes. Isso permite um maior n\u00famero de opera\u00e7\u00f5es por ciclo \n\nde rel\u00f3gio. \n\nO algoritmo de normaliza\u00e7\u00e3o utilizado foi leading zeros, que conta o n\u00famero de \n\nzeros antes do primeiro bit \u20181\u2019 encontrado. Esse n\u00famero de zeros \u00e9 utilizado para se realizar o \n\ndeslocamento do vetor a ser normalizado. Caso o deslocamento seja realizado para a esquerda \n\n\u00e9 feita uma subtra\u00e7\u00e3o do n\u00famero de zeros encontrados no expoente. Caso o deslocamento seja \n\nrealizado para a direita \u00e9 feita uma soma do n\u00famero de zeros encontrados no expoente. \n\nO algoritmo de arredondamento utilizado foi o arredondamento para o mais pr\u00f3ximo \n\nou par (round to nearest). Esse arredondamento apesar de mais custoso apresenta um menor \n\nerro em rela\u00e7\u00e3o ao n\u00famero original. Com isso, a precis\u00e3o utilizada nessa opera\u00e7\u00e3o foi a \n\nm\u00e1xima prevista pelo padr\u00e3o IEEE-754.   \n\nO projeto do MAC foi sintetizado para um dispositivo da Xilinx, denominado Virtex \n\nII XC2V6000. Dentre os resultados obtidos, pode-se citar uma frequ\u00eancia de opera\u00e7\u00e3o de \n\n69.44 Mhz. O MAC, juntamente com uma interface de barramento PCI, ocuparam cerca de \n\n14% da l\u00f3gica dispon\u00edvel do dispositivo. Com isso, o autor espera que o dispositivo suporte \n\nat\u00e9 7 unidades de ponto flutuante de 64 bits semelhantes na FPGA utilizada. \n\n \n\n\n\n58 \n\n \n\n \n\nFigura 14 - Arquitetura e Pipe-line do Sistema de Barros A. C. \n\n \n\n \n\n3.2.1 Conclus\u00f5es \n\n \n\nO trabalho proposto por Barros (2008) mostrou a implementa\u00e7\u00e3o de um multiplicador \n\ne acumulador (MAC) padr\u00e3o IEEE-754 para FPGAs. Ao contr\u00e1rio desta disserta\u00e7\u00e3o que tem \n\numa aplica\u00e7\u00e3o para o algoritmo de RTM, o MAC foi desenvolvido para trabalhar na \n\nmultiplica\u00e7\u00e3o de matrizes. No entanto, por tamb\u00e9m ser um n\u00facleo aritm\u00e9tico padr\u00e3o IEEE-\n\n754 implementado em FPGA, compartilha uma mesma tem\u00e1tica. \n\nA divis\u00e3o das opera\u00e7\u00f5es aritm\u00e9ticas de maneira a se explorar o paralelismo entre as \n\nintru\u00e7\u00f5es permitiu a Barros o melhor aproveitamento dos recursos dispon\u00edveis no FPGA. Essa \n\nestrat\u00e9gia foi a mesma utilizada no n\u00facleo aritm\u00e9tico desta disserta\u00e7\u00e3o, o que permitiu uma \n\nmelhoria na execu\u00e7\u00e3o do algoritmo. \n\n\n\n59 \n\n \n\n \n\nEm Barros (2008), assim como nesta disserta\u00e7\u00e3o, se faz uso do algoritmo de \n\narredondamento recomendado pelo IEEE, para o mais pr\u00f3ximo ou par. Para tanto, fez-se uso \n\nde uma opera\u00e7\u00e3o de l\u00f3gica de \u201cOU\u201d para determina\u00e7\u00e3o do Stick bit\n15\n\n, que foi a mesma \n\nestrat\u00e9gia adota nesta disserta\u00e7\u00e3o para a implementa\u00e7\u00e3o do arredondamento em FPGA. \n\n \n\n3.3 Modelagem de uma Plataforma Reconfigur\u00e1vel para modelagem 2D, em \n\nS\u00edsmica, Utilizando FPGA - Rocha, Rodrigo C. F. (2010).  \n\n \n\nA pesquisa feita por Rocha (2010) realiza a implementa\u00e7\u00e3o do problema de \n\nmodelagem s\u00edsmica 2D em FPGA . Para tanto, desenvolveu-se uma plataforma reconfigur\u00e1vel \n\nbaseada em FPGA que utiliza uma plataforma da GiDEL, denominada PROCe-III (GIDEL, \n\n2015). O trabalho de Rocha adota um modelo co-design, que utiliza uma unidade de software \n\nrepresentada por uma CPU e, um FPGA, representando o componente de hardware, como um \n\ncoprocessador. \n\nTamb\u00e9m \u00e9 exposto no trabalho de Rocha (2010) os processos envolvidos nas etapas de \n\nmodelagem e migra\u00e7\u00e3o presentes no algoritmo de RTM.  \n\nNa figura 15 a seguir observa-se o fluxograma do processamento de dados s\u00edsmicos \n\nutilizado. Inicialmente \u00e9 feita a etapa de modelagem e os dados resultantes desse passo s\u00e3o \n\narmazenados. Em seguida, ap\u00f3s a execu\u00e7\u00e3o da modelagem, a migra\u00e7\u00e3o se inicia e cada passo \n\nde processamento dos dados gerados pela modelagem s\u00e3o correlacionados com os dados que \n\ns\u00e3o gerados pela migra\u00e7\u00e3o. Por fim, o resultado da etapa de migra\u00e7\u00e3o corresponde a uma \n\nimagem do terreno de interesse e suas camadas de subsuperf\u00edcie. \n\n \n\nFigura 15 - Fluxograma do processamento de dados s\u00edsmicos em (ROCHA, 2010). \n\n  \nFonte: (ROCHA, 2010, P. 12.) \n\n                                                 \n15\n\n Bit utilizado para representar se um determinado conjunto de bits \u00e9 maior do que zero. \n\n\n\n60 \n\n \n\n \n\nA equa\u00e7\u00e3o de diferen\u00e7as finitas utilizada por Rocha (2010) que faz uma aproxima\u00e7\u00e3o \n\nda equa\u00e7\u00e3o de onda ac\u00fastica pode ser vista na equa\u00e7\u00e3o 3.1 a seguir. Ela corresponde \u00e0 \n\nresolu\u00e7\u00e3o da equa\u00e7\u00e3o de diferen\u00e7as finitas, para cada ponto do modelo, ao longo dos passos \n\nde tempo (ou passos de processamento).  \n\n \n\nCi,j = 2 ? Bi,j ? Ai,j\n\n? {Veli,j\n2 ? fat\n\n? [16 ? (Bi,j+1 + Bi,j?1 + Bi+1,j + Bi?1,j) ? 1\n\n? (Bi,j+2 + Bi,j?2 + Bi+2,j + Bi?2,j) ? 60 ? Bi,j]}           (3.1)  \n\n \n\nOnde os elementos ??,? , ??,? e ??,? representam, respectivamente, a localiza\u00e7\u00e3o da \n\nposi\u00e7\u00e3o i,j nas matrizes, que representam o campo de onda, no tempo n-1, n e n+1. O termo \n\n????,? corresponde a velocidade da propaga\u00e7\u00e3o da onda na posi\u00e7\u00e3o i,j da matriz que representa \n\no modelo do terreno. O termo ??? corresponde a constante que \u00e9 calculada em fator de \n\npar\u00e2metros escolhidos para a execu\u00e7\u00e3o do RTM, como o espa\u00e7amento entre os pontos da \n\nmalha e outros. \n\nPara se realizar essa opera\u00e7\u00e3o Rocha (2010), fez uso da implementa\u00e7\u00e3o do operador \n\nde diferen\u00e7as finitas presente em Fernandes (2010). O operador faz uso do padr\u00e3o IEEE-754 \n\npara n\u00fameros em ponto flutuante para realizar suas opera\u00e7\u00f5es aritm\u00e9ticas. Ambos os trabalhos \n\nforam desenvolvidos dentro de um projeto de conv\u00eanio de coopera\u00e7\u00e3o entre o Centro de \n\nInform\u00e1tica da UFPE e a Petrobras. \n\nO n\u00facleo aritm\u00e9tico implementado lida com o ru\u00eddo gerado quando a propaga\u00e7\u00e3o da \n\nonda s\u00edsmica atinge as bordas do modelo. Para isso uma nova vers\u00e3o do operador de \n\ndiferen\u00e7as finitas foi utilizada.  \n\nA vers\u00e3o do operador de diferen\u00e7as finitas utilizada por Rocha (2010) e \n\nimplementada por Fernandes (2011) introduziu novos coeficientes (Bl e Bi) que simulam a \n\ncontinuidade da onda quando o processamento dos dados alcan\u00e7ar as bordas da matriz. A \n\nequa\u00e7\u00e3o 3.2 exp\u00f5e esses novos coeficientes. \n\n \n\n \n\n\n\n61 \n\n \n\n \n\n. Ci,j = 2 ? (Bl ? Bi) ? Bi,j ? (Bl ? Bi)\n2 ? Ai,j ?  (Bl ? Bi)\n\n2 ? {Veli,j\n2 ? fat ?\n\n[16 ? (Bi,j+1 + Bi,j?1 + Bi+1,j + Bi?1,j) ? 1 ? (Bi,j+2 + Bi,j?2 + Bi+2,j + Bi?2,j) ? 60 ? Bi,j]}  \n\n(3.2) \n\nOs valores de Bl e Bi est\u00e3o dispostos em matrizes e s\u00e3o fornecidos durante o \n\nprocessamento s\u00edsmico. A figura 16 a seguir exp\u00f5e a disposi\u00e7\u00e3o dos dados de entrada para o \n\nn\u00facleo aritm\u00e9tico utilizado por Rocha (2010). A matriz \u2018A\u2019 cont\u00e9m os dados calculados no \n\ntempo t-1, a matriz \u2018B\u2019 cont\u00e9m os dados presentes no tempo \u2018t\u2019 e a matriz C cont\u00e9m os dados \n\nno tempo t+1. A matriz \u2018V\u2019 possui as informa\u00e7\u00f5es sobre a velocidade de propaga\u00e7\u00e3o nas \n\ncamadas do subsolo. \n\n \n\nFigura 16 - Disposi\u00e7\u00e3o dos dados para processamento s\u00edsmico implementado por (ROCHA, 2010). \n\n  \nFonte: (FERNANDES, 2010, P. 22.) \n\n \n\nA vers\u00e3o particionada do n\u00facleo aritm\u00e9tico com 36 est\u00e1gios de pipeline utilizado por \n\nRocha pode ser observada na figura 16 a seguir. As letras de \u2018A\u2019 at\u00e9 \u2018V\u2019 colocadas como \n\nentrada dos primeiros blocos adicionadores e multiplicadores representam os n\u00fameros \n\npresentas na equa\u00e7\u00e3o (3.2), assim como os coeficientes Bl e Bi na figura apresentados. \n\nObserva-se na figura 17 a op\u00e7\u00e3o por usar uma unidade de tratamento das exce\u00e7\u00f5es \n\nprevistas no padr\u00e3o IEEE-754 que percorre em paralelo a execu\u00e7\u00e3o de todo o pipeline. \n\n \n\n\n\n62 \n\n \n\n \n\nFigura 17 - Diagrama de blocos do N\u00facleo de Processamento Particionado utilizado por (ROCHA, 2010). \n\n \nFonte: (FERNANDES, 2010, P. 52.) \n\n  \n\nUm dos casos de uso utilizados por Rocha (2010) utiliza o modelo de velocidades de \n\nMarmousi (1988). A figura 18 a seguir ilustra um comparativo dos tempos de processamento \n\nda plataforma proposta por (2010) e de um modelo de referencia em software. Para tanto, \n\nvariou-se o n\u00famero de colunas na matriz de Marmousi e mediram-se os tempos de execu\u00e7\u00e3o. \n\n\n\n63 \n\n \n\n \n\nFigura 18 - Tempo de processamento da plataforma e do software compilado no Visual Studio 2008 para o modelo de \n\nMarmousi obtidos por Rocha (2010). \n\n Fonte: (ROCHA, 2010, P.106.) \n\nObserva-se na figura 18 que os tempos de processamento em hardware foram \n\nmenores do que os em software. O ganho de velocidade m\u00e9dia de processamento foi de cerca \n\nde  4,5 vezes. \n\n \n\n3.3.1 Conclus\u00f5es \n\n \n\nO trabalho de Rocha (2010) mostrou a implementa\u00e7\u00e3o de uma plataforma capaz de \n\nrealizar a etapa de modelagem do algoritmo de RTM em FPGA. Para tanto fez uso da \n\nimplementa\u00e7\u00e3o do n\u00facleo aritm\u00e9tico implementado em Fernandes (2010) que opera com \n\nn\u00fameros em ponto flutuante no padr\u00e3o IEEE-754. \n\nEsse trabalho juntamente com o n\u00facleo aritm\u00e9tico de Fernandes (2011) serviu como \n\numa das principais refer\u00eancias por abordar a implementa\u00e7\u00e3o do RTM em FPGA. \n\nA disposi\u00e7\u00e3o das opera\u00e7\u00f5es aritm\u00e9ticas de maneira a se aproveitar o paralelismo de \n\nexecu\u00e7\u00e3o ocorreu de maneira semelhante \u00e0 feita nesta disserta\u00e7\u00e3o. Esta disserta\u00e7\u00e3o tamb\u00e9m \n\nfaz uso de uma arquitetura em pipeline para ganho de desempenho. \n\n \n\n600 800 1000 1200 1400 1600 1800 2000 2200 2300\n\ntempo de\nprocessamento do hw(s)\n\n33,711 44,931 56,151 67,371 78,593 89,812 101,021 112,250 123,469 129,078\n\ntempo de\nprocessamento do sw(s)\n\n149,433 201,468 254,150 308,259 361,206 412,737 465,028 513,956 567,239 592,167\n\n0,000\n\n100,000\n\n200,000\n\n300,000\n\n400,000\n\n500,000\n\n600,000\n\n700,000\nTe\n\nm\np\n\no\n d\n\ne\n p\n\nro\nce\n\nss\na\n\nm\ne\n\nn\nto\n\n (\ns)\n\n \nCompara\u00e7\u00e3o de Desempenho \n\n\n\n64 \n\n \n\n \n\n\u00c9 importante destacar, que o n\u00facleo aritm\u00e9tico implementado por (FERNANDES, \n\n2010) resolve a equa\u00e7\u00e3o de diferen\u00e7as finitas para uma modelagem em duas dimens\u00f5es \n\napenas. Isso difere da equa\u00e7\u00e3o utilizada nesta disserta\u00e7\u00e3o que possui tr\u00eas dimens\u00f5es espaciais. \n\nOutro ponto de diferen\u00e7a no n\u00facleo aritm\u00e9tico utilizado em (ROCHA, 2010) e esta \n\ndisserta\u00e7\u00e3o \u00e9 a maneira como ocorre o tratamento de exce\u00e7\u00f5es. No utilizado por (ROCHA, \n\n2010) h\u00e1 uma unidade de tratamento de exce\u00e7\u00f5es que percorre todo o pipeline realizando \n\nverifica\u00e7\u00f5es paralelamente a execu\u00e7\u00e3o. Nesta disserta\u00e7\u00e3o, o tratamento de exce\u00e7\u00f5es \u00e9 feito \n\ninternamente aos m\u00f3dulos aritm\u00e9ticos antes de se realizar a opera\u00e7\u00e3o. Isso foi feito para se \n\neconomizar recursos utilizados no processo de roteamento dos dados dos m\u00f3dulos.  \n\n \n\n3.4  Trabalhos relacionados gerais. \n\n \n\nAl\u00e9m dos trabalhos j\u00e1 citados, outros tamb\u00e9m contribu\u00edram, ainda que em menor \n\ngrau, para o desenvolvimento dessa disserta\u00e7\u00e3o. \n\nOs trabalhos de Wilson et al. (2014), Ramesh et al. (2013), Amaricai et al. (2013) \n\nabordam implementa\u00e7\u00f5es de opera\u00e7\u00f5es aritm\u00e9ticas com n\u00fameros em ponto flutuante em \n\nFPGA. Pode-se observar a implementa\u00e7\u00e3o de opera\u00e7\u00f5es de multiplica\u00e7\u00e3o, soma, raiz \n\nquadrada e no caso de Amaricai (2013) de n\u00fameros em nota\u00e7\u00e3o de ponto fixo. Esses trabalhos \n\ncontribu\u00edram para essa disserta\u00e7\u00e3o na metodologia de desenvolvimento de alguns m\u00f3dulos da \n\narquitetura e disposi\u00e7\u00e3o das opera\u00e7\u00f5es ao longo da execu\u00e7\u00e3o do pipeline. \n\nEm Govindo et al. (2005) \u00e9 exposta uma biblioteca no padr\u00e3o IEEE-754  contendo as \n\nopera\u00e7\u00f5es de soma, subtra\u00e7\u00e3o, divis\u00e3o, multiplica\u00e7\u00e3o e raiz quadrada para n\u00fameros em ponto \n\nflutuante. Os diagramas funcionais com a indica\u00e7\u00e3o dos m\u00f3dulos internos s\u00e3o apresentados e \n\nbem descritos, por\u00e9m n\u00e3o apresentados detalhes internos de implementa\u00e7\u00e3o.  \n\nO trabalho presente em Barros (2014) prov\u00ea um extenso estudo da precis\u00e3o num\u00e9rica \n\nnecess\u00e1ria \u00e0 implementa\u00e7\u00e3o do algoritmo de RTM. Ele contribuiu com esta disserta\u00e7\u00e3o \n\ndurante a etapa de desenvolvimento dos n\u00facleos em ponto fixo e na defini\u00e7\u00e3o do n\u00famero de \n\nbits necess\u00e1rios para sua representa\u00e7\u00e3o. \n\nA pesquisa desenvolvida por Santos (2012) compara as etapas de modelagem da \n\nequa\u00e7\u00e3o de onda e a migra\u00e7\u00e3o reversa no tempo (RTM), utilizando os m\u00e9todos das diferen\u00e7as \n\nfinitas (MDF) e elementos finitos (MEF). Esse trabalho prov\u00ea fundamenta\u00e7\u00e3o matem\u00e1tica \n\npara a aproxima\u00e7\u00e3o da equa\u00e7\u00e3o de onda pelo m\u00e9todo de diferen\u00e7as finitas. \n\n \n\n\n\n65 \n\n \n\n \n\n3.5 Conclus\u00f5es \n\n \n\nEste cap\u00edtulo apresentou alguns trabalhos que possuem rela\u00e7\u00e3o com essa disserta\u00e7\u00e3o. \n\nA estrat\u00e9gia de quebra do fluxo de opera\u00e7\u00f5es ao longo de um pipeline presente em \n\nDou (2005) permitiu o aumento da frequ\u00eancia de opera\u00e7\u00e3o do n\u00facleo aritm\u00e9tico. Tamb\u00e9m foi \n\nutilizado nessa disserta\u00e7\u00e3o um n\u00facleo de contagem de zeros durante a normaliza\u00e7\u00e3o, apesar de \n\no algoritmo utilizado por Dou (2005) ter sido diferente. \n\nNessa disserta\u00e7\u00e3o utilizou-se a mesma estrat\u00e9gia de arredondamento e divis\u00e3o das \n\nopera\u00e7\u00f5es aritm\u00e9ticas ao longo de um pipeline feitas por Barros (2008). Elas foram \n\nimplementadas de maneira a se explorar o paralelismo entre as instru\u00e7\u00f5es o que permitiu uma \n\nmelhoria na execu\u00e7\u00e3o do algoritmo.  \n\nO n\u00facleo aritm\u00e9tico desenvolvido em Fernandes (2010) e implementado por Rocha \n\n(2010) serviu com inspira\u00e7\u00e3o para o desenvolvimento do n\u00facleo aritm\u00e9tico deste trabalho. No \n\nentanto, a aproxima\u00e7\u00e3o da equa\u00e7\u00e3o de onda desta disserta\u00e7\u00e3o \u00e9 uma extens\u00e3o da utilizada por \n\nRocha (2010), visto que trabalha com as tr\u00eas dimens\u00f5es espaciais ao inv\u00e9s de apenas duas. \n\nOs trabalhos Wilson et al. (2014), Ramesh et al. (2013), Amaricai et al. (2013), \n\nGovindo et al (2005), Barros (2014), Santos (2012) tamb\u00e9m possuem rela\u00e7\u00e3o com as \n\ntem\u00e1ticas de aritm\u00e9tica de ponto flutuante e RTM e apresentaram contribui\u00e7\u00e3o para essa \n\ndisserta\u00e7\u00e3o. \n\nApesar dos diversos trabalhos correlatos a esta disserta\u00e7\u00e3o, n\u00e3o foram encontrados \n\nprojetos que abordassem a implementa\u00e7\u00e3o de um n\u00facleo aritm\u00e9tico, padr\u00e3o IEEE-754, capaz \n\nde resolver o operador de diferen\u00e7as finitas do algoritmo RTM em tr\u00eas dimens\u00f5es para \n\nFPGAs.  \n\n   \n\n\n\n66 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n4 \n\n4. Plataforma para modelagem 3D do algoritmo de \n\nRTM em FPGA \n\n \n\n \n\n Esse cap\u00edtulo descreve a plataforma desenvolvida pelo projeto HPCIn em parceria \n\ncom o CENPES no Centro de Inform\u00e1tica da UFPE para a etapa de modelagem do algoritmo \n\nde an\u00e1lises s\u00edsmicas, RTM 3D, para hardware reconfigur\u00e1vel, FPGA. \n\n \n\n  \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n  \n\n\n\n67 \n\n \n\n \n\n4.1 Ambiente de implementa\u00e7\u00e3o \n\n \n\nOs m\u00f3dulos aritm\u00e9ticos desenvolvidos nesse trabalho foram utilizados para resolver \n\na equa\u00e7\u00e3o de ondas s\u00edsmicas que comp\u00f5em o m\u00e9todo de RTM. Para solucionar o m\u00e9todo de \n\navalia\u00e7\u00e3o do solo por essa t\u00e9cnica, foi feita uma arquitetura capaz de funcionar em FPGA. \n\nA etapa de modelagem do m\u00e9todo de RTM foi escolhida como exemplo por \n\napresentar menor complexidade de implementa\u00e7\u00e3o do que a etapa de migra\u00e7\u00e3o.  \n\nNa etapa de modelagem ocorre o processamento direto da equa\u00e7\u00e3o de onda atrav\u00e9s \n\nde um campo de velocidades do solo. Este implementado em parceria com o CENPES no \n\nprojeto HPCIn do CIn da UFPE (2014). \n\nA arquitetura desenvolvida pode ser observada no anexo III. Nela est\u00e3o presentes os \n\nm\u00f3dulos que fazem comunica\u00e7\u00e3o com os dados nas mem\u00f3rias externas ao FPGA, \n\nregistradores de deslocamento, m\u00f3dulos de leitura e escrita, de gera\u00e7\u00e3o de pulso, entre outros. \n\nAl\u00e9m desses m\u00f3dulos, est\u00e3o presentes componentes de l\u00f3gica de controle e at\u00e9 componentes \n\nl\u00f3gicos comuns, como multiplexadores e portas l\u00f3gicas.  \n\nEssa arquitetura em hardware foi desenvolvida para se explorar o paralelismo das \n\nopera\u00e7\u00f5es. Em um primeiro momento, foi explorado o paralelismo que trata do n\u00famero de \n\ninstru\u00e7\u00f5es simult\u00e2neas executadas, ou seja, quantas janelas de processamento s\u00e3o executadas \n\nem paralelo. A janela de processamento utilizada foi implementada com o PE e a arquitetura \n\ndesenvolvida d\u00e1 suporte a 4 desses PE\u00b4s. Com isso, t\u00eam-se 4 opera\u00e7\u00f5es realizadas por ciclo de \n\nrel\u00f3gio.  \n\nInicialmente, foi utilizado o PE Float como par\u00e2metro de compara\u00e7\u00e3o durante a \n\nexecu\u00e7\u00e3o do fluxo da arquitetura. Em seguida, o mesmo foi feito com o PE H\u00edbrido. Ao final, \n\no PE H\u00edbrido foi escolhido para integrar a arquitetura, pois o mesmo gera uma economia de \n\nblocos l\u00f3gicos do FPGA. \n\nNa figura 19, pode-se observar a maneira como os 4 PEs operam. Eles percorrem \n\numa matriz tridimensional do campo de press\u00e3o atual. Primeiramente, a matriz \u00e9 percorrida no \n\nsentido da coordenada z, depois no sentido da coordenada y, e por \u00faltimo, no sentido do eixo \n\nx. \n\n \n\n\n\n68 \n\n \n\n \n\nFigura 19 - Janela de Opera\u00e7\u00e3o em Hardware para 4 PE\u00b4s \n\n \n \n\nPode-se observar, tamb\u00e9m, na figura 19, os termos de opera\u00e7\u00e3o citados na arquitetura \n\ndo PE. Esses termos correspondem \u00e0s entradas para o n\u00facleo aritm\u00e9tico desenvolvido, sendo \n\nBijk o termo central, Bijk-1,Bij-1k e Bi-1jk os termos diretamente adjacentes, e os termos Bijk-\n\n2, Bij-2k e Bi-2jk com dist\u00e2ncia 2 do termo central. Os quatro PEs presentes na figura 19 \n\ncomp\u00f5em um time step, ou passo temporal de execu\u00e7\u00e3o.  \n\nNessa arquitetura implementada em FPGA, tamb\u00e9m \u00e9 explorado um paralelismo \n\ntemporal de opera\u00e7\u00f5es. Cada grupo de 4 PEs opera sobre um time step gerando resultados que \n\ns\u00e3o armazenados em FIFOs internas. Essas FIFOS cont\u00eam, ent\u00e3o, os dados que servem de \n\nentrada para o segundo grupo de 4 PEs e assim por diante. Esse fluxo segue at\u00e9 se chegar ao \n\nquarto grupo, onde sua sa\u00edda passa a ser escrita na mem\u00f3ria. Com isso, nesse algoritmo est\u00e1 \n\npresente um conjunto com 16 PEs, que processam ao mesmo tempo 4 time steps, cada passo \n\nprocessando 4 janelas de processamento. \n\nA plataforma de desenvolvimento em FPGA corresponde a ProcStarIV, da Gidel \n\n(2014), que \u00e9 equipada com 4 FPGAs Stratix IV da Altera (Altera, 2015). Cada FPGA \u00e9 \n\nalimentada por um m\u00f3dulo de mem\u00f3ria com 512MB DDR2, al\u00e9m de dois slots para mem\u00f3rias \n\nDDR2 que podem chegar at\u00e9 a 4GB. No caso de uso, utilizou-se dois m\u00f3dulos de 4GB para \n\ncada um dos FPGAs. Para a gera\u00e7\u00e3o de componentes de integra\u00e7\u00e3o na placa foi utilizada a \n\nferramenta ProcWizard (Gidel, 2015). \n\n\n\n69 \n\n \n\n \n\nO sismograma gerado ao final dessa opera\u00e7\u00e3o opera com matrizes de tamanho \n\nm\u00e1ximo 2048x2048x2048, fornecendo assim, 32 GB de n\u00fameros em ponto flutuante de \n\nprecis\u00e3o simples. Devido a grande quantidade de dados, o problema foi dividido em parti\u00e7\u00f5es \n\nque cabiam na FPGA utilizada, de tamanho 2048X48X48. Ao final de execu\u00e7\u00e3o de uma \n\nparti\u00e7\u00e3o desse tamanho, uma nova fatia da matriz de entrada de mesmo tamanho \u00e9 executada. \n\nIsso ocorre at\u00e9 que todas as parti\u00e7\u00f5es da matriz sejam executadas.  \n\nNa figura 20 a seguir, pode-se observar a plataforma de desenvolvimento utilizada \n\npara a aplica\u00e7\u00e3o do caso de uso em FPGAs.  \n\n \n\nFigura 20 - Plataforma ProcStarIV \n\n \n\n \n\n  \n\n\n\n70 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n5 \n \n\n5. Um N\u00facleo aritm\u00e9tico para execu\u00e7\u00e3o de um operador \n\nde diferen\u00e7as finitas em FPGA \n\n \n\n \n\nNesta se\u00e7\u00e3o aborda-se o desenvolvimento de um n\u00facleo aritm\u00e9tico capaz de calcular \n\no operador de diferen\u00e7as finitas presente no algoritmo de RTM. \n\n \n\n \n\n \n\n \n\n \n\n \n\n  \n\n\n\n71 \n\n \n\n \n\n5.1 Vis\u00e3o Geral \n\n \n\nNessa se\u00e7\u00e3o est\u00e1 exposta a arquitetura desenvolvida para se calcular o operador de \n\ndiferen\u00e7as finitas para a equa\u00e7\u00e3o de onda presente no mapeamento s\u00edsmico do solo via RTM.  \n\nAs solu\u00e7\u00f5es desenvolvidas recebem, como entrada, n\u00fameros em formato de ponto \n\nflutuante padr\u00e3o IEEE-754 e geram, em sua sa\u00edda, n\u00fameros no mesmo formato.  \n\nInicialmente, foi feita uma vers\u00e3o que soluciona a equa\u00e7\u00e3o do operador de \n\ndiferen\u00e7as finitas, para n\u00fameros em ponto flutuante no padr\u00e3o IEEE-754. Essa vers\u00e3o foi \n\ndenominada de PE Float.. \n\nEm seguida, foi feita outra vers\u00e3o visando \u00e0 redu\u00e7\u00e3o da quantidade de elementos \n\nl\u00f3gicos utilizados em FPGA para a implementa\u00e7\u00e3o do m\u00f3dulo. Essa vers\u00e3o foi denominada de \n\nPE H\u00edbrido. Esse m\u00f3dulo opera tanto com n\u00fameros em ponto flutuante quanto em ponto fixo.  \n\nIsso foi feito porque a nota\u00e7\u00e3o em ponto fixo \u00e9 mais econ\u00f4mica, tanto em custos de \n\n\u00e1rea, quanto em complexidade de c\u00e1lculos. No entanto, isso s\u00f3 foi poss\u00edvel devido \u00e0 natureza \n\ndos n\u00fameros utilizados em algumas das vari\u00e1veis de entrada, pois a nota\u00e7\u00e3o em ponto fixo \u00e9 \n\nbem mais limitada em rela\u00e7\u00e3o ao alcance de representa\u00e7\u00e3o num\u00e9rica. Esse m\u00f3dulo aritm\u00e9tico \n\nfoi otimizado em rela\u00e7\u00e3o \u00e0 \u00e1rea utilizada sem ter impactos significativos quanto \u00e0 precis\u00e3o \n\nesperada para o resultado. \n\nAmbos os PE\u00b4s desenvolvidos fazem uso de uma arquitetura em pipeline. Isso foi \n\nfeito tanto para se aumentar a frequ\u00eancia de opera\u00e7\u00e3o do n\u00facleo aritm\u00e9tico quanto para que \n\nhouvesse a execu\u00e7\u00e3o de mais de uma instru\u00e7\u00e3o simultaneamente.  \n\nO PE Float e o PE H\u00edbrido compartilham diversos m\u00f3dulos. Ambos s\u00e3o divididos \n\nem tr\u00eas grandes blocos, denominados de Bloco1, Bloco2 e Bloco3.  \n\nOs Bloco1 e Bloco3 s\u00e3o id\u00eanticos em ambas as arquiteturas, pois esses m\u00f3dulos n\u00e3o \n\nsofreram modifica\u00e7\u00f5es de nota\u00e7\u00e3o da representa\u00e7\u00e3o adotada. Com isso, a diferen\u00e7a entre o PE \n\nFloat e o PE H\u00edbrido reside, basicamente, no Bloco2, tamb\u00e9m denominado de \u00e1rvore de \n\nsomas. No PE Float, esse bloco opera com os n\u00fameros em ponto flutuante, j\u00e1 no PE H\u00edbrido, \n\no bloco opera com n\u00fameros representados em ponto fixo. \n\n  Com a finalidade de simplificar esse documento, o Bloco1 e o Bloco3 s\u00e3o \n\nexplicados apenas na parte que aborda o PE Float, visto que s\u00e3o iguais nas duas arquiteturas. \n\nNo entanto, o Bloco2 \u00e9 explicado tanto na descri\u00e7\u00e3o do PE Float, quanto na do PE H\u00edbrido, \n\ndevido \u00e0s suas diferen\u00e7as em cada PE. \n\n\n\n72 \n\n \n\n \n\nA estrutura dos PEs foram desenvolvidas para se calcular a equa\u00e7\u00e3o do operador de \n\ndiferen\u00e7as finitas descrita abaixo:  \n\n \n\n???_? ? ???_? ? ???_? ? (2.0 ? ???? + ???? ? ???? ? ???? ? (??? ? ??? ? ??? ? (?1 ?\n\n(????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2)  + 16 ? (????1? + ???+1? +\n\n ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1) +  (?90 ? ????   )) ? ????  ))                       (4.1) \n\n \n\nEssa equa\u00e7\u00e3o teve sua estrutura alterada para operar de maneira mais eficiente em \n\nhardware. Essa manipula\u00e7\u00e3o matem\u00e1tica permite reuso de opera\u00e7\u00f5es e abre caminho para \n\notimiza\u00e7\u00f5es. A equa\u00e7\u00e3o assume, ent\u00e3o, a seguinte forma representada abaixo: \n\n \n\n(2.0 ? ???? ? ???? ? ???? ? ???? ) + ((???? ? ???? ? ???? )\n2\n\n? (??? ? ??? ? ??? ?\n\n(?1 ? (????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2)  + 16 ? (????1? +\n\n???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1) +  (?90 ? ????   )) ? ????  ))           (4.2) \n\n  \n\nOs PE\u00b4s implementam a equa\u00e7\u00e3o 4.2, com isso eles s\u00f3 precisam realizar a \n\nmultiplica\u00e7\u00e3o entre as vari\u00e1veis ???? , ???? , ????  uma \u00fanica vez antes de sua resposta seguir \n\npelo pipeline. Seu resultado \u00e9 propagado atrav\u00e9s de registradores de deslocamento. \n\nCom a manipula\u00e7\u00e3o da equa\u00e7\u00e3o 4.1 para a 4.2 introduziu-se uma opera\u00e7\u00e3o de \n\nquadrado com o termo (???? ? ???? ? ???? )\n2\n\n. Isso permitiu que mais opera\u00e7\u00f5es fossem feitas \n\nem paralelo a um custo relativamente baixo, pois a opera\u00e7\u00e3o de quadrado \u00e9 uma opera\u00e7\u00e3o \n\nmais simples do que uma multiplica\u00e7\u00e3o padr\u00e3o em ponto flutuante.  \n\nA figura 21 a seguir ilustra em alto n\u00edvel a arquitetura dos PE\u00b4s implementados. \n\nPode-se observar a presen\u00e7a dos tr\u00eas grandes blocos que comp\u00f5em todo o pipeline da \n\narquitetura. \n\nObserva-se na figura 21 que o Bloco2 recebe como entradas os termos:  \n\n???? , ????2? ,  ???+2? ,  ???2?? ,  ??+2?? \n ,  ?????2\n\n \n ,  ????+2 , ????1? , ???+1? ,  ???1?? , ??+1?? \n\n, ?????1\n \n\n \n\ne ????+1. \n\nPode-se observar tamb\u00e9m na figura 21 que o Bloco1 opera com os termos: ???,  \n\n???, ??? e ????. \n\nA figura 21 ilustra tamb\u00e9m que o Bloco3 opera com os termos: ???? , ???? , ????  e \n\n????. \n\n\n\n73 \n\n \n\n \n\n O Bloco1 tamb\u00e9m recebe como entrada o resultado advindo do Bloco2. O Bloco3 \n\nrecebe tamb\u00e9m como entrada o resultado advindo do Bloco1.  A sa\u00edda final do n\u00facleo de \n\nprocessamento em ambos os PE\u00b4s (PE Float e PE H\u00edbrido) se d\u00e1 atrav\u00e9s da sa\u00edda do Bloco3.  \n\n \n\nFigura 21 - Vis\u00e3o geral da arquitetura dos PE\u00b4s. \n\n \n\n \n\nToda a arquitetura esta disposta em um grande pipeline. Com isso, os tr\u00eas blocos \n\npodem operam simultaneamente enquanto processam seus dados. A sincroniza\u00e7\u00e3o dos dados \n\nentre os blocos \u00e9 feita atrav\u00e9s de registradores de deslocamento presentes dentro da estrutura \n\ndo pipeline.  \n\nComo o PE Float e o PE H\u00edbrido possuem a mesma estrutura dos Bloco1 e Bloco2, \n\nseus subcomponentes b\u00e1sicos ser\u00e3o explicados logo nesta se\u00e7\u00e3o. Os subcomponentes que s\u00e3o \n\nexclusivos do PE H\u00edbrido, ou seja, os que integram o Bloco2 ser\u00e3o descritos na se\u00e7\u00e3o que \n\nexp\u00f5e a arquitetura do PE H\u00edbrido. \n\nA seguir s\u00e3o descritos alguns dos m\u00f3dulos internos b\u00e1sicos que s\u00e3o instanciados \n\nin\u00fameras vezes por blocos maiores tanto do PE Float quanto PE H\u00edbrido.  \n\n5.1.1 Conversor \n\n \n\nEsse componente \u00e9 respons\u00e1vel por ajustar os n\u00fameros do formato IEEE-754 de \n\ntrinta e dois bits, para uma nota\u00e7\u00e3o interna com mais bits. Essa nota\u00e7\u00e3o aplica um bit \n\nimpl\u00edcito na parte mais significativa da mantissa e ajusta o expoente para ser operado \n\ninternamente. O bit impl\u00edcito \u00e9 adicionado pois o padr\u00e3o assume que os n\u00fameros em ponto \n\n\n\n74 \n\n \n\n \n\nflutuante est\u00e3o normalizados. Para se realizar as opera\u00e7\u00f5es aritm\u00e9ticas subsequentes com um \n\nn\u00famero em ponto flutuante o mesmo deve ser operado j\u00e1 com o bit impl\u00edcito, caso contr\u00e1rio a \n\nopera\u00e7\u00e3o \u00e9 tida como incorreta  \n\nEsse m\u00f3dulo possui um \u00fanico est\u00e1gio de pipeline. \n\n5.1.2 Somador \n\n \n\nEsse componente realiza uma opera\u00e7\u00e3o de soma para n\u00fameros em uma nota\u00e7\u00e3o \n\nestendida. Essa nota\u00e7\u00e3o \u00e9 resultado de opera\u00e7\u00f5es pr\u00e9vias no PE, em que foi necess\u00e1rio o \n\naumento do n\u00famero de bits para se preservar a precis\u00e3o da opera\u00e7\u00e3o. Esse fen\u00f4meno \n\nacontece, por exemplo, ap\u00f3s uma opera\u00e7\u00e3o de multiplica\u00e7\u00e3o, que possui a resposta com uma \n\nquantidade de bits equivalente as somas das quantidades de bits das vari\u00e1veis de entrada. No \n\ncaso da soma, o significando de resposta deve possuir uma quantidade de bits equivalente \u00e0 \n\nquantidade de bits dos significandos de entrada mais um.  \n\n No primeiro est\u00e1gios do pipeline dessa unidade, \u00e9 feita uma verifica\u00e7\u00e3o das exce\u00e7\u00f5es \n\nprevistas no padr\u00e3o IEEE. Isso se faz necess\u00e1rio, pois a opera\u00e7\u00e3o com n\u00fameros desta natureza \n\ngera um resultado inconsistente sob o ponto de vista do padr\u00e3o. As verifica\u00e7\u00f5es feitas s\u00e3o \n\nquanto a infinitos positivos e negativos, NANs e zeros. Al\u00e9m desses, \u00e9 verificada a presen\u00e7a \n\nde n\u00fameros denormais. No entanto, para fins de economia de recursos de hardware, esses \n\nn\u00fameros, que, por natureza, s\u00e3o muito pequenos, foram arredondados para zero. Ap\u00f3s essa \n\netapa, segue-se com o algoritmo padr\u00e3o de soma para n\u00fameros com nota\u00e7\u00e3o de sinal e \n\nmagnitude.  \n\n As exce\u00e7\u00f5es geram um c\u00f3digo interno de exce\u00e7\u00e3o no somador que ao longo dos \n\ndemais est\u00e1gios do pipeline s\u00e3o verificados para n\u00e3o serem operados da mesma maneira que \n\num n\u00famero normal. Por exemplo, ao se identificar um NaN no primeiro est\u00e1gio esse deve ser \n\npropagado ao longo dos demais est\u00e1gios de pipeline, pois qualquer soma de um n\u00famero com \n\num n\u00e3o v\u00e1lido gera como resposta o pr\u00f3prio n\u00famero n\u00e3o v\u00e1lido (NaN). \n\nNo segundo est\u00e1gio \u00e9 feita a convers\u00e3o para uma nota\u00e7\u00e3o de complemento a dois \n\npara que os n\u00fameros sigam para a etapa seguinte para serem somados.  \n\nAinda no segundo est\u00e1gio \u00e9 feito o c\u00e1lculo da diferen\u00e7a entre os expoentes de entrada \n\nparalelamente a opera\u00e7\u00e3o de complemento a dois. \n\nNo est\u00e1gio seguinte realiza-se um deslocamento dos n\u00fameros complementados a dois \n\nde acordo com a diferen\u00e7a obtida entre os expoentes no est\u00e1gio anterior. Esse deslocamento \u00e9 \n\nfeito para a direita no significando do operando que tem o menor expoente. Essa etapa \n\n\n\n75 \n\n \n\n \n\nacontece para que os pontos separadores estejam alinhados e bits de mesma magnitude sejam \n\nsomados entre si.  \n\nA opera\u00e7\u00e3o de deslocamento de um n\u00famero \u00e0 direita equivale a dividi-lo pela base \n\nnum\u00e9rica adotada.  A fim de manter o valor originalmente representado pelo significando que \n\nest\u00e1 sendo deslocado, a cada deslocamento deve-se incrementar o valor do expoente \n\nassociado. \n\nNo \u00faltimo est\u00e1gio realiza-se a opera\u00e7\u00e3o de soma entre os significandos que foram \n\nconvertidos para a nota\u00e7\u00e3o de complemento a dois nos est\u00e1gios anteriores. \n\n Essa unidade ao todo possui quatro est\u00e1gios de pipeline.  \n\n Pode-se observar o fluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o na figura \n\n22 a seguir. Nesta figura n\u00e3o est\u00e3o indicados os registradores de pipeline para facilitar seu \n\nentendimento. Por\u00e9m, os mesmos est\u00e3o presentes e o leitor deve estar consciente de sua \n\nexist\u00eancia. \n\nFigura 22 - Fluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o do PE \n\n \n\n \n\nA etapa de normaliza\u00e7\u00e3o e arredondamento s\u00e3o feitas em um outro m\u00f3dulo que \u00e9 \n\ndescrito mais adiante.  \n\n5.1.3 Multiplicador \n\n \n\n\n\n76 \n\n \n\n \n\nEsse componente realiza uma opera\u00e7\u00e3o de multiplica\u00e7\u00e3o de acordo com o padr\u00e3o \n\nIEEE-754, em ponto flutuante. Essa unidade recebe dois n\u00fameros na nota\u00e7\u00e3o de sinal e \n\nmagnitude, e gera uma resposta com uma nota\u00e7\u00e3o de bits expandida.  \n\nAssim como descrito no somador, \u00e9 necess\u00e1ria a verifica\u00e7\u00e3o de n\u00fameros que \n\nrepresentam exce\u00e7\u00f5es no in\u00edcio de suas opera\u00e7\u00f5es. Esses n\u00fameros s\u00e3o identificados, e a \n\nopera\u00e7\u00e3o entre eles \u00e9 ajustada para se gerar um resultado esperado pelo padr\u00e3o. Ap\u00f3s a etapa \n\nde verifica\u00e7\u00e3o inicial de exce\u00e7\u00f5es, segue-se com o algoritmo de multiplica\u00e7\u00e3o.  \n\nNo est\u00e1gio seguinte os expoentes s\u00e3o somados entre si e em paralelo \u00e9 feita a \n\nopera\u00e7\u00e3o de multiplica\u00e7\u00e3o dos significandos de entrada.   \n\nAp\u00f3s esse est\u00e1gios o bias \u00e9 subtra\u00eddo do resultado da opera\u00e7\u00e3o de soma de \n\nexpoentes. Os expoentes j\u00e1 est\u00e3o cada um com um bias e, portanto, quando somados, geram \n\num n\u00famero que possui dois bias, o que seria um resultado incorreto.  \n\nEm paralelo a subtra\u00e7\u00e3o do bias \u00e9 feita uma opera\u00e7\u00e3o l\u00f3gica de XOR (exclusive OR) \n\nentre os sinais de entrada para a gera\u00e7\u00e3o dos sinais de sa\u00edda. \n\nEssa unidade ao todo possui tr\u00eas est\u00e1gios de pipeline. \n\nPode-se observar o fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o na figura 23. \n\nNesta figura n\u00e3o est\u00e3o indicados os registradores de pipeline para facilitar seu entendimento. \n\nPor\u00e9m, os mesmos est\u00e3o presentes e o leitor deve estar consciente de sua exist\u00eancia. \n\n \n\nFigura 23 - Fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o do PE. \n\n \n\nAssim como no somador, a etapa de normaliza\u00e7\u00e3o e arredondamento \u00e9 feita em um \n\noutro m\u00f3dulo que \u00e9 descrito mais adiante. \n\n\n\n77 \n\n \n\n \n\n5.1.4 Normalizador_Arredondador \n\n \n\nEssa unidade \u00e9 respons\u00e1vel por realizar a normaliza\u00e7\u00e3o dos n\u00fameros depois das \n\nopera\u00e7\u00f5es aritm\u00e9ticas e, em seguida, realizar seu arredondamento.  \n\nUma das opera\u00e7\u00f5es que esse m\u00f3dulo precisa realizar para se normalizar um n\u00famero \n\n\u00e9 uma contagem de zeros na parte mais significativa do vetor de bits. Essa etapa identifica a \n\nquantidade de deslocamentos que ser\u00e3o necess\u00e1rias para se normalizar o n\u00famero.  \n\nO deslocamento \u00e9 feito de maneira que, ao final, haja um n\u00famero \u20181\u2019 na primeira \n\nposi\u00e7\u00e3o a esquerda do ponto separador. Caso essa dist\u00e2ncia esteja \u00e0 esquerda da posi\u00e7\u00e3o \n\nesperada a dist\u00e2ncia \u00e9 considerada positiva, caso esteja a direita a dist\u00e2ncia \u00e9 considerada \n\nnegativa. \u00c9 importante destacar que qualquer deslocamento feito na mantissa, seja ele para \n\nesquerda ou direita, implica em uma altera\u00e7\u00e3o no valor armazenado no expoente.  \n\nA etapa seguinte ao processo de normaliza\u00e7\u00e3o, a ser realizada nesse m\u00f3dulo, \u00e9 o \n\narredondamento. Os bits que excedem a nota\u00e7\u00e3o de 22 bits de mantissa prevista pelo IEEE \n\ndevem ser retirados do significando.  \n\nO arredondamento utilizado foi para o pr\u00f3ximo ou par. Caso alguns dos bits \n\nexcedentes do significando apresentem valor diferente de zero, o n\u00famero deve ser \n\narredondado para o pr\u00f3ximo. Isso \u00e9 feito somando-se \u20181\u2019 ao significando. \n\nSe nenhum valor diferente de zero \u00e9 encontrado nos bits excedentes do significando, \n\no n\u00famero pode ser simplesmente truncado, ou seja, \u00e9 realizado um arredondamento para zero.  \n\nA etapa final \u00e9 a de verifica\u00e7\u00e3o de exce\u00e7\u00f5es. Essa etapa serve para sinalizar as \n\nexce\u00e7\u00f5es previstas no padr\u00e3o IEEE para os pr\u00f3ximos m\u00f3dulos do PE. \n\nAo final das opera\u00e7\u00f5es o n\u00famero estar\u00e1 na nota\u00e7\u00e3o de ponto flutuante 32 bits \n\nprevista no padr\u00e3o IEEE-754, \n\nEsse m\u00f3dulo apresenta quatro est\u00e1gios de pipeline. \n\nPode-se observar o fluxograma geral de execu\u00e7\u00e3o do normalizador e arredondador \n\nna figura 24 a seguir. Os deslocadores de deslocamento (FIFOs) respons\u00e1veis pela sincronia \n\ndos sinais internos foram omitidos para simplifica\u00e7\u00e3o da ilustra\u00e7\u00e3o.  \n\n\n\n78 \n\n \n\n \n\nFigura 24- Fluxo de execu\u00e7\u00e3o do normalizador_arredondador do PE. \n\n \n\n5.1.5 Quadrado \n\n \n\nEste m\u00f3dulo \u00e9 respons\u00e1vel por realizar a multiplica\u00e7\u00e3o de um n\u00famero por ele \n\nmesmo, ou seja, a opera\u00e7\u00e3o de quadrado.  \n\nPara ser realizar a opera\u00e7\u00e3o de quadrado, \u00e9 feita, inicialmente, uma verifica\u00e7\u00e3o de \n\nexce\u00e7\u00f5es no primeiro ciclo do modulo. Esses n\u00fameros s\u00e3o identificados para n\u00e3o interferirem \n\nnos resultados esperados pelo m\u00f3dulo. O caso do zero, por exemplo, exige que a resposta \n\ngerada pelo m\u00f3dulo seja tamb\u00e9m zero, n\u00e3o sendo necess\u00e1rio o c\u00e1lculo para se obter essa \n\nresposta. \n\n \n\nNo segundo est\u00e1gio \u00e9 feito o c\u00e1lculo do expoente de resposta. Para tanto, seria \n\nnecess\u00e1rio a realiza\u00e7\u00e3o de uma soma de expoentes, seguindo o algoritmo de multiplica\u00e7\u00e3o \n\nnormal. Contudo, como t\u00eam-se uma soma de expoentes iguais, a opera\u00e7\u00e3o na verdade \n\nequivale a dobra-se o valor desse expoente. A multiplica\u00e7\u00e3o por dois em base bin\u00e1ria equivale \n\na um deslocamento para a esquerda (shift left) de uma posi\u00e7\u00e3o no vetor de bits que representa \n\no expoente. Para simplificar ainda mais esse processo, o deslocamento para a esquerda foi \n\nsubstitu\u00eddo por um mapeamento dos bits mais significativos do expoente de tamanho \u2018n\u2019 em \n\num expoente de resposta de tamanho \u2018n+1\u2019. Com isso um bit zero \u00e9 adicionado na parte \n\nmenos significativa desse novo expoente.  \n\n\n\n79 \n\n \n\n \n\nO mapeamento do expoente foi incorporado ao primeiro ciclo de pipeline do m\u00f3dulo \n\nquadrado. Essa estrat\u00e9gia equivale a se deslocar o vetor de bits para a esquerda sem perda de \n\nbits no deslocamento. Esse expoente com mais bits passa pelo m\u00f3dulo de quadrado sendo \n\ntratado fora dele. \n\n\u00c9 importante destacar que a soma de dois expoentes exige uma subtra\u00e7\u00e3o do bias. \n\nIsso \u00e9 necess\u00e1rio pois os dois expoentes somados j\u00e1 tem o bias embutido em cada um de seus \n\nvalores e sua soma geraria uma n\u00famero com dois bias embutido, o que n\u00e3o \u00e9 previsto pelo \n\npadr\u00e3o IEEE-754. \n\nO processo de subtra\u00e7\u00e3o do bias do expoente \u00e9 feito no segundo est\u00e1gio desse \n\nm\u00f3dulo. \n\nNo segundo est\u00e1gio tamb\u00e9m ocorre em paralelo a multiplica\u00e7\u00e3o dos significandos. A \n\nquantidade de bits resultante dessa opera\u00e7\u00e3o, especificamente, deve ser o dobro da quantidade \n\nde bits do significando inicial. Isso se faz necess\u00e1rio porque a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o \n\nprecisa de mais bits de resposta para n\u00e3o perder precis\u00e3o. O significando de resposta sai com \n\nessa nota\u00e7\u00e3o de bits expandida. O processo de arredondamento desse significando \u00e9 tratado \n\nfora desse m\u00f3dulo em um m\u00f3dulo denominado de arredondador. \n\nA defini\u00e7\u00e3o do sinal no m\u00f3dulo quadrado \u00e9 uma constante e possui valor zero. Isso \n\nse torna evidente porque, devido \u00e0 natureza da opera\u00e7\u00e3o de quadrado, os resultados ser\u00e3o \n\nsempre positivos ou nulos.  \n\nEssa unidade possui apenas dois est\u00e1gios de pipeline. \n\nPode-se observar o fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de quadrado na figura 25 a \n\nseguir. \n\nFigura 25 - Fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de quadrado do PE. \n\n \n\n\n\n80 \n\n \n\n \n\n5.1.6 Arredondador \n\n \n\nEssa unidade \u00e9 respons\u00e1vel por arredondar os valores que saem do m\u00f3dulo quadrado. \n\nO arredondamento utilizado nessa unidade \u00e9 o arredondamento para o pr\u00f3ximo ou par \n\ndefinido pelo padr\u00e3o IEEE-754. \n\nNo primeiro est\u00e1gio de pipeline desse m\u00f3dulo verifica-se se os bits excedentes do \n\nsignificando s\u00e3o maiores do que zero. Entende-se por bits excedentes aqueles que est\u00e3o al\u00e9m \n\nda representa\u00e7\u00e3o de 23 bits do significando normalizado definido no padr\u00e3o IEEE. \n\nOs bits excedentes quando maiores do que zero implicam que o significando deve ser \n\narredondado para cima, pois essa opera\u00e7\u00e3o introduz um menor erro do que o gerado caso o \n\nn\u00famero fosse arredondado para baixo. Esse arredondamento para cima \u00e9 feito realizando-se a \n\nsoma do significando com \u20181\u2019. \n\n O segundo est\u00e1gio faz as verifica\u00e7\u00f5es e ajustes no expoente.  \n\n \u00c9 feito no segundo est\u00e1gio o processo de arredondamento do expoente de entrada \n\npara a diminui\u00e7\u00e3o de um bit em sua nota\u00e7\u00e3o. Para tanto \u00e9 tratado se esse processo estoura a \n\ncapacidade m\u00e1xima de representa\u00e7\u00e3o do expoente de 8 bits, padr\u00e3o para o ponto flutuante de \n\nprecis\u00e3o simples IEEE-754.  \n\n5.1.7 FIFOs \n\n \n\nAs unidades denominadas de FIFOs (First in, Firs Out) s\u00e3o apenas registradores de \n\ndeslocamento ao longo do pipeline.  \n\n O tamanho das FIFOs varia de acordo com o m\u00f3dulo no qual ela est\u00e1 inserida. \n\n Essas unidades est\u00e3o presentes ao longo de todo o pipeline dos PE\u00b4s e servem para \n\ngarantir a devida sincronia entre seus sinais. \n\n \n\n5.2 PE Float \n\n \n\nO PE Float opera com n\u00fameros em ponto flutuante no padr\u00e3o IEEE-754. As \n\nopera\u00e7\u00f5es aritm\u00e9ticas implementadas nesse PE obedecem \u00e0s normas previstas no padr\u00e3o. \n\nDentre essas normas destaca-se o tratamento de exce\u00e7\u00f5es, arredondamento e normaliza\u00e7\u00e3o. \n\nApesar de operar com n\u00fameros em ponto flutuante, o PE Float internamente \n\nmodifica essa representa\u00e7\u00e3o para que as opera\u00e7\u00f5es aritm\u00e9ticas sejam realizadas. Cada termo \n\ndo n\u00famero em ponto flutuante, sinal, expoente e mantissa s\u00e3o operados separadamente. Ao \n\n\n\n81 \n\n \n\n \n\nfinal de suas respectivas opera\u00e7\u00f5es aritm\u00e9ticas os n\u00fameros retornam a nota\u00e7\u00e3o padr\u00e3o em \n\nponto flutuante.  \n\nPara que o grande n\u00famero de opera\u00e7\u00f5es presentes na equa\u00e7\u00e3o 4.2 fosse realizado, foi \n\nnecess\u00e1ria a reparti\u00e7\u00e3o das opera\u00e7\u00f5es em m\u00f3dulos menores. Essa divis\u00e3o em componentes \n\nobedeceu aos crit\u00e9rios de similaridades das subopera\u00e7\u00f5es da equa\u00e7\u00e3o. Isso foi feito \n\nprocurando-se preservar um subconjunto de somas em um mesmo m\u00f3dulo e um subconjunto \n\nde multiplica\u00e7\u00f5es em outro m\u00f3dulo. Com isso, a equa\u00e7\u00e3o de diferen\u00e7as finitas pode ser \n\nimplementada em hardware de maneira mais eficiente.  \n\nPode-se observar na figura 53 do anexo II, o diagrama em blocos com a estrutura \n\ngeral do PE3D Float. \n\nComo dito anteriormente, o PE Float est\u00e1 dividido em tr\u00eas m\u00f3dulos principais \n\ndenominados Bloco1, Bloco2 e Bloco3. Os componentes desses m\u00f3dulos principais est\u00e3o \n\ndivididos em blocos menores para opera\u00e7\u00f5es espec\u00edficas e s\u00e3o descritos a seguir.   \n\n \n\n5.2.1 Bloco1 \n \n\nO Bloco1 \u00e9 respons\u00e1vel por realizar o seguinte trecho da equa\u00e7\u00e3o de diferen\u00e7as \n\nfinitas. \n\n(??? ? ??? ? ??? ? (?????2??? ) ? ????  )          (4.3) \n\n \n\nEsse bloco recebe, como entrada, os n\u00fameros ???, ???, ?????2_??? e ???? . Todas \n\nas suas entradas, com exce\u00e7\u00e3o da advinda do Bloco2, s\u00e3o de regi\u00f5es externas ao PE. Com \n\nexce\u00e7\u00e3o do temo ???, todas as entradas est\u00e3o na representa\u00e7\u00e3o padr\u00e3o IEEE-754 de 32 bits.  \n\nA entrada Bloco2_out representa a sa\u00edda do Bloco2, que \u00e9 necess\u00e1ria para a opera\u00e7\u00e3o \n\ndo Bloco1. Nesta vers\u00e3o da arquitetura, o PE Float, essa sa\u00edda encontra-se na nota\u00e7\u00e3o de \n\nponto flutuante padr\u00e3o IEEE-754 com 32 bits, visto que, ap\u00f3s a opera\u00e7\u00e3o no Bloco2, os \n\nn\u00fameros s\u00e3o normalizados e arredondados para a nota\u00e7\u00e3o adotada. \n\nPara se operar com os n\u00fameros que representam a velocidade de propaga\u00e7\u00e3o da onda \n\nac\u00fastica no meio, o VEL, \u00e9 necess\u00e1ria uma etapa de convers\u00e3o. Essa etapa \u00e9 importante, pois o \n\nn\u00famero est\u00e1 em nota\u00e7\u00e3o de half-precision, ou seja, com apenas 16 bits, um n\u00famero menor do \n\nque os 32 bits previstos no padr\u00e3o.  \n\nOs n\u00fameros em nota\u00e7\u00e3o de half-precision possuem os mesmos termos de um \n\nn\u00famero em ponto flutuante de 32 bits, sinal, expoente e mantissa. A diferen\u00e7a entre as duas \n\n\n\n82 \n\n \n\n \n\nnota\u00e7\u00f5es se encontra apenas no n\u00famero de bits utilizados, o que modifica o alcance de \n\nrepresenta\u00e7\u00e3o num\u00e9rica e a precis\u00e3o dessa representa\u00e7\u00e3o. \n\nNa figura 26 a seguir pode-se observar a distribui\u00e7\u00e3o dos bits na nota\u00e7\u00e3o half-float. \n\nEssa nota\u00e7\u00e3o possui \u20181\u2019 bit para sinal, \u20185\u2019 bits para expoente e \u201810\u2019 bits para mantissa.  \n\nCom essa nota\u00e7\u00e3o \u00e9 poss\u00edvel se representar n\u00fameros com valores at\u00e9 2\n15\n\n, ou seja, \n\n32.768 com uma precis\u00e3o m\u00e1xima de 2\n-10\n\n, ou seja, 0,0009765625. \n\n \n\nFigura 26 - N\u00famero de bits presentes na nota\u00e7\u00e3o half-float que armazena o termo de velocidade. \n\n \n\n \n\nA op\u00e7\u00e3o pela representa\u00e7\u00e3o do termo ??? em nota\u00e7\u00e3o half-float foi motivada devido \n\na menor varia\u00e7\u00e3o de amplitude e precis\u00e3o deste n\u00famero em rela\u00e7\u00e3o aos demais termos da \n\nequa\u00e7\u00e3o 4.2. Nos casos de uso fornecido pelo CENPES (PETROBRAS, 2015) para o grupo \n\nHPCIn (HPCIN, 2014) os campos de velocidade n\u00e3o ultrapassavam o limiar de velocidade \n\nm\u00e1xima de 2\n15\n\n. Tampouco os limiares de velocidade ultrapassavam a precis\u00e3o de 2\n-10\n\n. Com \n\nisso, foi poss\u00edvel representar os n\u00fameros do termo ??? da equa\u00e7\u00e3o 4.2 com metade dos bits \n\ndos n\u00fameros em ponto flutuante padr\u00e3o de 32 bits. \n\nEssa foi uma exig\u00eancia ditada pela arquitetura de controle e comunica\u00e7\u00e3o presentes \n\nno algoritmo de RTM que foi implementado em FPGA pelo grupo HPCIn, mas que fogem ao \n\nescopo desta disserta\u00e7\u00e3o.  \n\nDevido \u00e0 presen\u00e7a do half-float foi necess\u00e1rio o acr\u00e9scimo de um conversor para a \n\nnota\u00e7\u00e3o de 32 bits na entrada do Bloco2 para o termo ???. Com isso, ap\u00f3s essa etapa o \n\nn\u00famero se torna um ponto flutuante de 32 bits e segue sendo operado normalmente. Os \n\ndetalhes sobre essa opera\u00e7\u00e3o ser\u00e3o discutidos a seguir, na descri\u00e7\u00e3o do m\u00f3dulo respons\u00e1vel \n\npor essa fun\u00e7\u00e3o. \n\nO Bloco1 \u00e9 composto por quatro grandes unidades: BlocoMultiplica1, BlocoVelFat, \n\nBlocoMultiplica, BlocoSomadorNormalizador. Esses m\u00f3dulos s\u00e3o descritos a seguir. \n\nPodse-se observar a arquitetura do Bloco1 na figura 31. \n\n \n\n5.2.1.1 BlocoMultiplica1 \n\n \n\nEsse m\u00f3dulo \u00e9 respons\u00e1vel pela multiplica\u00e7\u00e3o do termo ???? por \u2018-1\u2019. \n\n\n\n83 \n\n \n\n \n\nEssa opera\u00e7\u00e3o exige apenas uma simples mudan\u00e7a de sinal do n\u00famero. Isso \u00e9 feito \n\ninvertendo-se o primeiro bit do n\u00famero de entrada do m\u00f3dulo, bit esse que corresponde ao \n\nsinal. \n\nO BlocoMultiplica1 apresenta no in\u00edcio um m\u00f3dulo conversor, j\u00e1 descrito \n\nanteriormente. Ele acrescenta o bit impl\u00edcito no n\u00famero de entrada, garantindo que o \n\nsignificando esteja na representa\u00e7\u00e3o prevista no padr\u00e3o IEEE-754.  \n\nO outro componente presente nesse m\u00f3dulo \u00e9 um registrador de deslocamento \n\n(FIFO) que tem a fun\u00e7\u00e3o de propagar o n\u00famero ao longo dos est\u00e1gios de pipeline para \n\ngarantir a sincronia dos sinais do m\u00f3dulo. \n\nEsse m\u00f3dulo apresenta 30 est\u00e1gios de pipeline ao todo. \n\nPode-se observar a estrutura geral do BlocoMultiplica1 na figura 27 a seguir: \n\n \n\nFigura 27 - Arquitetura geral do BlocoMultiplica1. \n\n \n\n \n\n\n\n84 \n\n \n\n \n\n5.2.1.2 BlocoVelFat \n\n \n\nEsse bloco \u00e9 respons\u00e1vel por realizar a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o do termo ???, \n\npelo quadrado do termo ???.  \n\nPara realizar essas opera\u00e7\u00f5es os n\u00fameros s\u00e3o inicialmente modificados no m\u00f3dulo \n\nConversor para receberem o bit impl\u00edcito e possu\u00edrem a quantidade de bits esperada para o \n\nsignificando. \n\nO termo ??? segue ent\u00e3o para o m\u00f3dulo Quadrado para ser operado e logo em \n\nseguido para o m\u00f3dulo Arredondador para ser ajustado. \n\nComo o termo ??? passou pelo arredondamento e retornou a nota\u00e7\u00e3o de 32 bits, ele \n\nnecessita passar novamente pelo conversor para ganhar o bit impl\u00edcito e compor o \n\nsignificando. \n\nEm paralelo as opera\u00e7\u00f5es do ???, o ??? \u00e9 propagado ao longo do pipeline por \n\nregistradores de deslocamento (FIFO) para ent\u00e3o receber o bit impl\u00edcito no m\u00f3dulo conversor. \n\nEm seguida \u00e9 feita a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o dos termos ???\n2\n e ???. Ao final \n\ndessa opera\u00e7\u00e3o a resposta segue para ser normaliza e arredonda no m\u00f3dulo seguinte. \n\nA resposta dessa opera\u00e7\u00e3o j\u00e1 normalizada e arredondada \u00e9 propagada pelo pipeline \n\npor um registrador de deslocamento (FIFO) de 13 est\u00e1gios. Isso \u00e9 feito para garantir a \n\nsincronia do sinal com a sa\u00edda do Bloco2, que tamb\u00e9m \u00e9 uma das entradas do Bloco1. \n\nAo todo esse m\u00f3dulo possui 26 ciclos. \n\nPode-se observar a estrutura geral do m\u00f3dulo BlocoVelFat na figura 28. \n\n \n\n5.2.1.3 BlocoMultiplica \n\n \n\nEsse m\u00f3dulo \u00e9 respons\u00e1vel por realizar a multiplica\u00e7\u00e3o da sa\u00edda do BlocoVelFat com \n\na sa\u00edda advinda do Bloco2. \n\nEm sua entrada h\u00e1 dois blocos conversores para adicionar os bits impl\u00edcitos aos dois \n\noperandos a serem multiplicados.  \n\nEm seguida, os operandos seguem para o bloco Multiplicador para serem \n\nmultiplicados entre si.  \n\nO BlocoMultiplica est\u00e1 presente em outras etapas de processamento do PE, visto que \n\n\u00e9 o respons\u00e1vel pela opera\u00e7\u00e3o de multiplica\u00e7\u00e3o, que \u00e9 bastante presentes na equa\u00e7\u00e3o 4.2. \n\nEssas etapas ser\u00e3o descritas nos demais blocos a seguir. \n\n\n\n85 \n\n \n\n \n\nEsse m\u00f3dulo possui ao todo 4 est\u00e1gios de pipeline. Pode-se observar sua estrutura \n\ngeral na figura 29. \n\n \n\nFigura 28 - Arquitetura geral do BlocoVelFat. \n\n \n\n \n\nFigura 29 - Arquitetura geral do BlocoMultiplica. \n\n \n\n\n\n86 \n\n \n\n \n\n5.2.1.4 BlocoSomadorNormalizador \n\n \n\nEsse m\u00f3dulo \u00e9 respons\u00e1vel realizar uma opera\u00e7\u00e3o de soma seguida de normaliza\u00e7\u00e3o \n\ne arredondamento. \n\nNo Bloco1 essa unidade \u00e9 a encarregada por realizar a soma dos termos ????? por \n\n??? ? ??? ? ??? ? (?????2??? ). \n\nInicialmente \u00e9 feita a opera\u00e7\u00e3o de soma dos termos de entrada no bloco Somador. \n\nEsse m\u00f3dulo j\u00e1 foi descrito na se\u00e7\u00e3o 4.1.2. Em seguida a resposta segue para o m\u00f3dulo \n\nNormalizador_Arredondador que \u00e9 a sa\u00edda do Bloco1, tamb\u00e9m descrito anteriormente na \n\nse\u00e7\u00e3o 4.1.4.. \n\nO BlocoSomadorNormalizador tamb\u00e9m \u00e9 instanciando em outros pontos da \n\narquitetura geral dos PE\u00b4s. Isso acontece porque essa unidade \u00e9 a respons\u00e1vel pelas opera\u00e7\u00f5es \n\nde soma ao longo do pipeline do PE e como observado na equa\u00e7\u00e3o 4.2 a soma \u00e9 uma opera\u00e7\u00e3o \n\ncomum dentro do operador de diferen\u00e7as finitas. \n\nAo final de todas as opera\u00e7\u00f5es a sa\u00edda desse m\u00f3dulo j\u00e1 est\u00e1 na nota\u00e7\u00e3o de magnitude \n\ne sinal de ponto flutuante de 32 bits definido no padr\u00e3o IEEE-754. \n\nAo todo esse bloco possui 8 est\u00e1gios de pipeline. Sendo 4 est\u00e1gios para o bloco \n\nsomador e 4 est\u00e1gios para o bloco Normalizador_Arredondador. \n\nSua estrutura geral pode ser observada na figura 30 a seguir. \n\n \n\nFigura 30 - Arquitetura geral do BlocoSomadorNormalizador. \n\n \n\n \n\n \n\n \n\n\n\n87 \n\n \n\n \n\n  \n\nFigura 31 - Arquitetura geral do Bloco1 \n\n \n\n\n\n88 \n\n \n\n \n\n5.2.2 Bloco2 \n\n \n\nEste bloco \u00e9 respons\u00e1vel por realizar o seguinte trecho da equa\u00e7\u00e3o de diferen\u00e7as \n\nfinitas: \n\n \n\n?1 ? (????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2)  + 16 ? (????1? +\n\n???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1) +  (?90 ? ????  )           (4.4) \n\n \n\nEste m\u00f3dulo, diferentemente dos outros dois grandes m\u00f3dulos, recebe como entrada, \n\napenas n\u00fameros advindos de uma regi\u00e3o externa da arquitetura. Os n\u00fameros recebidos est\u00e3o \n\ntodos no padr\u00e3o IEEE-754 precis\u00e3o simples. \n\nBasicamente, esse bloco opera com os n\u00fameros da matriz B do operador de \n\ndiferen\u00e7as finitas, descrito na equa\u00e7\u00e3o 4.2, que representam o campo de press\u00e3o atual no \n\nalgoritmo de RTM.  \n\nDentre essas entradas, est\u00e3o o ponto central ????, e os pontos vizinhos deste, com \n\ndist\u00e2ncia de um (????1? + ???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1) e com dist\u00e2ncia \n\nde dois (????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2). Os n\u00fameros s\u00e3o \n\nmultiplicados pelos valores -90, 16 e -1, respectivamente de acordo com o operador de \n\ndiferen\u00e7as finitas utilizado no algoritmo de RTM (SANTOS, 2012).  \n\nOs valores multiplicados decaem conforme se distanciam do valor central ???? . Com \n\nisso, a equa\u00e7\u00e3o se torna uma soma ponderada, onde os valores a serem multiplicados decaem \n\nem m\u00f3dulo conforme se afastam do valor central ????.  \n\nO Bloco2 \u00e9 composto dos seguintes componentes: BlocoSomadorBijk, \n\nBlocoSomadorBijk2, BlocoMultiplica90, BlocoSomadorNormalizador. \n\nPode-se observar sua arquitetura geral na figura 35. \n\n \n\n5.2.2.1 BlocoSomadorBijk \n\n \n\nEsse bloco \u00e9 o respons\u00e1vel por realizar a soma de seis n\u00fameros recebidos na entrada \n\nentre si. \n\nNo Bloco2 esse m\u00f3dulo \u00e9 instanciado duas vezes. Uma vez para se realizar a soma \n\ndos termos ????1? + ???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1 e um outra vez para se \n\n\n\n89 \n\n \n\n \n\nrealizar a soma dos termos ????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2 da \n\nmatriz B. \n\nEsse bloco \u00e9 composto das seguintes unidades: Conversor, Somador e registradores \n\nde deslocamento (FIFOs). \n\nInicialmente \u00e9 adicionado os bits impl\u00edcitos dos n\u00fameros a serem operados no bloco \n\nConversor. Em seguida \u00e9 feita a soma dois a dois dos termos, sendo realizada tr\u00eas somas dois \n\na dois entre os seis termos, em seguida uma soma com o resultado da duas primeiras e por fim \n\numa soma com esse resultado e o dos dois \u00faltimos termos de entrada. \n\nCom isso ao final da opera\u00e7\u00e3o do m\u00f3dulo t\u00eam-se os seis n\u00fameros iniciais somados. \n\nO BlocoSomadorBijk possui ao todo 13 est\u00e1gios de pipeline e pode se observador na \n\nfigura 32 a seguir. \n\nFigura 32 - Arquitetura geral do BlocoSomadorBijk. \n\n \n\n \n\n5.2.2.2 BlocoSomadorBijk2 \n\n \n\nEsse m\u00f3dulo realiza a multiplica\u00e7\u00e3o das entradas por -1 e por 16 e em seguida realiza \n\numa opera\u00e7\u00e3o de soma entre os resultados dessas opera\u00e7\u00f5es. \n\nNo Bloco2 esse m\u00f3dulo \u00e9 respons\u00e1vel por realizar a multiplica\u00e7\u00e3o por -1 com \n\nresultado da opera\u00e7\u00e3o de soma dos termos ????1? + ???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +\n\n ????+1, assim como a multiplica\u00e7\u00e3o por 16 com o resultado da opera\u00e7\u00e3o de soma dos termos \n\n????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2, ambos advindos do \n\nBlocoSomadorBijk. \n\n\n\n90 \n\n \n\n \n\nInicialmente o bloco denominado Multiplica_1 realiza a multiplica\u00e7\u00e3o de sua entrada \n\npor -1. Para tanto, faz apenas uma invers\u00e3o do sinal de entrada, n\u00e3o realizando de fato uma \n\nopera\u00e7\u00e3o de multiplica\u00e7\u00e3o sobre o n\u00famero.  \n\nEm paralelo a multiplica\u00e7\u00e3o por -1 \u00e9 feita a multiplica\u00e7\u00e3o do outro operando de \n\nentrada por 16 no m\u00f3dulo Multiplica_16. Para realizar essa opera\u00e7\u00e3o esse m\u00f3dulo realiza \n\napenas a soma do expoente do n\u00famero de entrada com 4. Essa opera\u00e7\u00e3o equivale a quatro \n\nopera\u00e7\u00f5es de deslocamentos para a esquerda (shift left), que por sua equivalem a opera\u00e7\u00e3o de \n\nmultiplica\u00e7\u00e3o de um n\u00famero de base bin\u00e1ria por 16. As exce\u00e7\u00f5es s\u00e3o verificadas na entrada \n\ndesse m\u00f3dulo para que n\u00e3o sejam tratadas como n\u00fameros normais. \n\nEm seguida, \u00e9 feita uma opera\u00e7\u00e3o de soma entre as sa\u00eddas dos dois m\u00f3dulos de \n\nmultiplica\u00e7\u00e3o descritos no par\u00e1grafo anterior. Ao final dessa opera\u00e7\u00e3o o n\u00famero resultante \n\nsegue para a sa\u00edda do BlocoSomadorBijk2. \n\nEsse bloco possui 5 est\u00e1gios de pipeline e sua arquitetura geral pode ser observada na \n\nfigura 33 a seguir. \n\n \n\nFigura 33 - Arquitetura geral do BlocoSomadorBijk2 \n\n \n\n \n\n5.2.2.3 BlocoMultiplica90 \n\n \n\nEsse m\u00f3dulo realiza a multiplica\u00e7\u00e3o do n\u00famero de entrada por -90. No Bloco2 esse \n\nm\u00f3dulo recebe o termo ???? \n\nInicialmente o n\u00famero de entrada \u00e9 propagado por 16 est\u00e1gios de pipeline atrav\u00e9s de \n\nregistradores de deslocamento (FIFOs). Isso \u00e9 feito para se garantir a devida sincronia das \n\nopera\u00e7\u00f5es entre os outros m\u00f3dulos do PE. \n\nO n\u00famero segue ent\u00e3o para o m\u00f3dulo Multiplica_90 para ser operado. Esse \u00e9 o \n\nm\u00f3dulo que vai multiplica-lo por -90. \n\n\n\n91 \n\n \n\n \n\nO primeiro est\u00e1gio do Multiplica_90 faz uma verifica\u00e7\u00e3o de exce\u00e7\u00f5es. Essa etapa \u00e9 \n\nimportante para garantir que n\u00fameros tidos como exce\u00e7\u00f5es pelo padr\u00e3o IEEE n\u00e3o sejam \n\noperados como n\u00fameros comuns. As exce\u00e7\u00f5es s\u00e3o ent\u00e3o detectadas e devidamente \n\nsinalizadas.  \n\nO segundo est\u00e1gio do Multiplica_90 realiza a opera\u00e7\u00e3o aritm\u00e9tica esperada para o \n\nm\u00f3dulo. Para isso realiza-se a soma do expoente do n\u00famero menos -90 com o expoente do \n\ntermo de entrada do m\u00f3dulo e realiza-se a multiplica\u00e7\u00e3o do significando de -90 tamb\u00e9m pelo \n\nsignificando do termo de entrada. Pode-se observar a representa\u00e7\u00e3o de -90 na nota\u00e7\u00e3o de \n\nponto flutuante, j\u00e1 com o bit impl\u00edcito, na figura 34 a seguir. \n\n \n\nFigura 34 - Representa\u00e7\u00e3o de -90 em ponto flutuante com o bit impl\u00edcito. \n\n \n\n \n\n \u00c9 importante destacar que a soma dos expoentes feita no m\u00f3dulo n\u00e3o ocorre \n\npropriamente com o expoente do n\u00famero -90, que equivale a 133 em nota\u00e7\u00e3o decimal. Isso \n\nn\u00e3o pode ocorrer pois o expoente da figura 34 est\u00e1 com o bias j\u00e1 adicionado, o que geraria a \n\nnecessidade da subtra\u00e7\u00e3o de um bias, visto que o expoente do n\u00famero de entrada tamb\u00e9m j\u00e1 \n\npossui o bias embutido. Com isso, o termo correto a ser adicionado ao expoente \u00e9 133 menos \n\n127 (bias), o que equivale a 6. \n\n A multiplica\u00e7\u00e3o entre os significandos ocorre em paralelo a opera\u00e7\u00e3o com os \n\nexpoentes.  \n\n Ao final do segundo est\u00e1gio do Multiplica_90 j\u00e1 se t\u00eam a resposta do \n\nBlocoMultiplica90. \n\n O BlocoMultiplica90 possui ao todo 18 est\u00e1gios de pipeline. \n\n \n\n5.2.2.4 BlocoSomadorNormalizador \n\n \n\nO Bloco2 possui internamente um BlocoSomadorNormalizador para a soma seguida \n\nde normaliza\u00e7\u00e3o dos resultados advindos dos BlocoSomadorBijk2 e BlocoMultiplica90. \n\nEsse bloco j\u00e1 foi descrito na se\u00e7\u00e3o 4.2.1, portanto n\u00e3o ser\u00e1 detalhado novamente \n\nnesta se\u00e7\u00e3o. \n\n \n\n\n\n92 \n\n \n\n \n\nFigura 35 - Arquitetura geral do Bloco2 no PE Float \n\nBlocoMultiplica90\n\nFIFO16\n\nMultiplica_90\n(2 ciclos)\n\nBlocoSomadorBijk2\n\nB_ijk\n\nMultiplica_16\n(1 ciclo)\n\nNorm_Arrd\n(4 ciclos)\n\nBlocoSomadorNormalizador\n\nMultiplica_1\n(1 ciclo)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nBlocoSomadorBijk\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nFIFO4\n(4 ciclos)\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nB_ijk_1 B_ijk_1 B_ijk_1 B_ijk_1 B_ijk_1\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nBlocoSomadorBijk\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nSomador_Simples\n(4 ciclos)\n\nFIFO4\n(4 ciclos)\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nB_ijk_16\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nConversor\n(1 ciclo)\n\nB_ijk_16 B_ijk_16 B_ijk_16 B_ijk_16 B_ijk_16B_ijk_1\n\nBLOCO 2\n(26 ciclos)  \n\n  \n\n5.2.3 Bloco3 \n\n \n\n As opera\u00e7\u00f5es realizadas no Bloco3 correspondem ao seguinte trecho da equa\u00e7\u00e3o de \n\ndiferen\u00e7as finitas: \n\n \n\n(2.0 ? ???? ? ???? ? ???? ? ???? ) + ((???? ? ???? ? ???? )\n2\n\n? (?????1))     (4.5) \n\n \n\nEsse bloco realiza a multiplica\u00e7\u00e3o entre os tr\u00eas valores de ???, ???? e dois. Al\u00e9m \n\ndisso, Al\u00e9m disso, realiza a opera\u00e7\u00e3o de quadrado do resultado da multiplica\u00e7\u00e3o dos termos \n\n???.  \n\nNesse modulo, tamb\u00e9m \u00e9 feita a multiplica\u00e7\u00e3o do resultado da opera\u00e7\u00e3o de quadrado \n\ncom os valores de ??? e o resultado advindo do Bloco1. Nessa etapa de opera\u00e7\u00e3o da equa\u00e7\u00e3o \n\nde diferen\u00e7as finitas, todos os seus n\u00fameros de entrada est\u00e3o no padr\u00e3o de ponto flutuante de \n\ntrinta e dois bits do padr\u00e3o IEEE.  \n\nO Bloco3 \u00e9 composto pelos seguintes blocos: BlocoMultiplica2, \n\nBlocoMultiplicaAbs, BlocoMultiplica2Abs, BlocoQuadradoAbs, BlocoMultiplicaAbs, \n\nBlocoMultiplica. \n\nPode-se observar a arquitetura geral do Bloco3 na figura 41 a seguir. \n\n\n\n93 \n\n \n\n \n\n5.2.3.1 BlocoMultiplica2 \n\n \n\nEsse bloco \u00e9 respons\u00e1vel por realizar a multiplica\u00e7\u00e3o de sua entrada por dois. No \n\nBloco3 ele recebe o termo ????como entrada. \n\nInicialmente \u00e9 feita a multiplica\u00e7\u00e3o do operando de entrada por dois no bloco \n\nMultiplica_2. Para tanto \u00e9 feita uma verifica\u00e7\u00e3o das exce\u00e7\u00f5es de entrada no primeiro ciclo \n\ndeste m\u00f3dulo, caso o operando de entrada n\u00e3o seja caracterizado como exce\u00e7\u00e3o \u00e9 feita sua \n\nmultiplica\u00e7\u00e3o. Essa opera\u00e7\u00e3o tamb\u00e9m \u00e9 feita no primeiro ciclo desse m\u00f3dulo. \n\nA representa\u00e7\u00e3o do n\u00famero dois em nota\u00e7\u00e3o de ponto flutuante j\u00e1 com o bit \n\nimpl\u00edcito pode ser observada na figura 36 a seguir. \n\n \n\nFigura 36 - Representa\u00e7\u00e3o de 2 em ponto flutuante com o bit impl\u00edcito. \n\n \n\n \n\nA multiplica\u00e7\u00e3o de um n\u00famero por dois equivale a soma do expoente do operando \n\nde entrada pelo expoente do termo dois em ponto flutuante. Essa soma deve desconsiderar o \n\nbias presente no expoente na representa\u00e7\u00e3o do n\u00famero dois em ponto flutuante. Com isso \n\ntem-se o expoente 128 menos o 127 (bias), que equivale e 1.  \n\nA opera\u00e7\u00e3o de multiplica\u00e7\u00e3o a ser realizada no m\u00f3dulo se torna uma soma de uma \n\nconstante no expoente, o que economiza os recursos dispon\u00edveis em FPGA caso uma \n\nmultiplica\u00e7\u00e3o padr\u00e3o fosse feita.   \n\nA resposta do Multiplica_2 segue para registradores de deslocamento (FIFOs) que \n\ngarante a sincronia desse sinal com os demais sinais presentes ao longo do pipeline do PE. A \n\nFIFO no BlocoMultiplica2 possui 15 est\u00e1gios de pipeline. \n\nAo todo, o BlocoMultiplica2 possui 16 est\u00e1gios de pipeline. Pode-se observar a \n\narquitetura desse bloco na figura 37 a seguir. \n\n\n\n94 \n\n \n\n \n\nFigura 37 - Arquitetura geral do BlocoMultiplica2. \n\n \n\n \n\n5.2.3.2 BlocoMultiplicaAbs \n\n \n\nEsse m\u00f3dulo realiza a multiplica\u00e7\u00e3o de tr\u00eas operandos recebidos como entrada entre \n\nsi. No Bloco3 ele realiza a multiplica\u00e7\u00e3o dos termos  ????, ????  e ???? entre si. \n\nInicialmente \u00e9 feita a convers\u00e3o dos termos ???? e ???? para a nota\u00e7\u00e3o com o bit \n\nimpl\u00edcito. Em seguida seus resultados seguem para o bloco Multiplicador para serem \n\noperados. O resultado segue ent\u00e3o para o bloco Normalizador_Arredondador. \n\nEm paralelo a multiplica\u00e7\u00e3o dos termos ???? e ???? o termo ???? \u00e9 propagado ao \n\nlongo de um registrador de deslocamento (FIFO) de 8 est\u00e1gios de pipeline. Essa FIFO garante \n\na sincronia entre os sinais de resposta da multiplica\u00e7\u00e3o de ????  e ???? com o termo ???? . Ao \n\nsair da FIFO \u00e9 feita a convers\u00e3o desse termo para a nota\u00e7\u00e3o com o bit impl\u00edcito. \n\nSeguindo o fluxo do pipeline desse modulo tem-se ent\u00e3o a multiplica\u00e7\u00e3o de ????  \n\ncom o resultado da multiplica\u00e7\u00e3o das outras duas entradas desse m\u00f3dulo. Assim como \n\ndescrito anteriormente, essa opera\u00e7\u00e3o \u00e9 feita no m\u00f3dulo Multiplicador e seu resultado segue \n\npara o m\u00f3dulo Normalizador_Arredondador.  \n\nAp\u00f3s a etapa de normaliza\u00e7\u00e3o e arredondamento o n\u00famero sai do \n\nBlocoMultiplicaAbs para entrar no seguinte e seguir o pipeline do PE.  \n\nEsse bloco possui ao todo 16 ciclos de pipeline. \n\n\n\n95 \n\n \n\n \n\nPode-se observar a arquitetura geral do BlocoMultiplicaAbs na figura 38 a seguir. \n\n \n\nFigura 38 - Arquitetura geral do BlocoMultiplicaAbs. \n\n \n\n \n\n5.2.3.3 BlocoMultiplica2Abs \n\n \n\nEsse bloco \u00e9 respons\u00e1vel por realizar a multiplica\u00e7\u00e3o dos dois operandos recebidos \n\ncomo entrada.  \n\nNo Bloco3 esse m\u00f3dulo \u00e9 respons\u00e1vel por realizar a multiplica\u00e7\u00e3o dos termos \n\nadvindos do BlocoMultiplica2 e do BlocoMultiplicaAbs. \n\nOs dois termos de entrada s\u00e3o convertidos para a nota\u00e7\u00e3o com o bit impl\u00edcito logo \n\nno primeiro est\u00e1gio desse bloco. Em seguida, os termos seguem para serem operados no bloco \n\nMultiplicador. \n\nA sa\u00edda do bloco Multiplicador \u00e9 propagada ao longo de uma cadeia de registradores \n\nde deslocamento (FIFO) por 22 est\u00e1gios de pipeline. Isso garante a sincronia da sa\u00edda do \n\nMultiplicador com o restante dos m\u00f3dulos do PE. \n\nAo todo esse m\u00f3dulo possui 26 est\u00e1gios de pipeline. \n\n\n\n96 \n\n \n\n \n\nPode-se observar a arquitetura geral do BlocoMultiplica2Abs na figura 39 a seguir. \n\n \n\nFigura 39 - Arquitetura geral do BlocoMultiplica2Abs. \n\n \n\n \n\n5.2.3.4 BlocoQuadradoAbs \n\n \n\nNesse m\u00f3dulo \u00e9 feita a opera\u00e7\u00e3o de quadrado com o operando recebido como \n\nentrada. No Bloco1 a entrada desse bloco corresponde a sa\u00edda advinda do \n\nBlocoMultiplicaAbs. \n\nInicialmente \u00e9 feita a propaga\u00e7\u00e3o do operando de entrada ao longo de registradores \n\nde deslocamento (FIFOs) para devida sincronia dos sinais dentro do PE. Logo em seguida \u00e9 \n\nfeita a convers\u00e3o do n\u00famero recebido como entrada para a nota\u00e7\u00e3o interna com bit impl\u00edcito \n\nno m\u00f3dulo Conversor. \n\nO n\u00famero j\u00e1 nota\u00e7\u00e3o com bit impl\u00edcito segue para o m\u00f3dulo Quadrado para ser \n\noperado. O bloco Quadrado foi descrito na se\u00e7\u00e3o 4.1.5 e n\u00e3o ser\u00e1 novamente descrito nesta \n\nse\u00e7\u00e3o.  \n\n\n\n97 \n\n \n\n \n\nA sa\u00edda do bloco Quadrado segue para o bloco Arredondador onde ter\u00e1 seu n\u00famero \n\nde bits reduzido de acordo com a opera\u00e7\u00e3o de arredondamento para o pr\u00f3ximo ou par \n\nrecomendada pelo IEEE. O m\u00f3dulo Arredondador foi descrito na se\u00e7\u00e3o 4.1.6.  \n\nA sa\u00edda do Arredondador j\u00e1 corresponde a sa\u00edda do BlocoQuadradoAbs e se encontra \n\nna nota\u00e7\u00e3o de ponto flutuante de 32 bits. \n\nAo todo esse m\u00f3dulo possui 22 ciclos de pipeline. \n\nPode-se observa a arquitetura geral do BlocoQuadradoAbs na figura 40 a seguir. \n\n \n\nFigura 40 - Arquitetura geral do BlocoQuadradoAbs. \n\n \n\n \n\n5.2.3.5 BlocoMultiplica \n\n \n\nEsse bloco, como descrito na se\u00e7\u00e3o 4.2.1.3 deste documento, realiza a multiplica\u00e7\u00e3o \n\nentre dois n\u00fameros de entrada. \n\n\n\n98 \n\n \n\n \n\nNo Bloco3 ele recebe como entrada a sa\u00edda do BlocoQuadradoAbs e a sa\u00edda advinda \n\ndo Bloco1. A sa\u00edda do Multiplicador presente nesse bloco corresponde j\u00e1 a sa\u00edda do \n\nBlocoMultiplica. \n\n \n\nFigura 41 - Arquitetura do Bloco3 \n\n \n\n \n\n\n\n99 \n\n \n\n \n\n5.2.3.6 BlocoSomadorNormalizador \n\n \n\nEsse \u00e9 o m\u00f3dulo que realiza a soma dos resultados advindos do BlocoMultiplica2Abs \n\ne do Bloco Multiplica e em seguida faz uma normaliza\u00e7\u00e3o e arredondamento de seu resultado. \n\nEsse bloco j\u00e1 foi descrito na se\u00e7\u00e3o portanto n\u00e3o ser\u00e1 descrito novamente nesta se\u00e7\u00e3o. \n\nA sa\u00edda do BlocoSomadorNormalizador presente no Bloco3 corresponde a sa\u00edda \n\nfinal do PE Float, ou seja, corresponde ao resultado do operador de diferen\u00e7as finitas. \n\nA sa\u00edda do Bloco3 se encontra na nota\u00e7\u00e3o de ponto flutuante de 32 bits padr\u00e3o IEEE-\n\n754, mantendo assim a congru\u00eancia com a representa\u00e7\u00e3o dos n\u00fameros de entrada do PE Float. \n\n \n\n5.3 PE H\u00edbrido \n\n \n\nO PE H\u00edbrido possui, basicamente, a mesma estrutura do PE Float apresentado \n\nanteriormente. Pode-se observar sua estrutura geral na figura 51 no anexo I deste documento. \n\nEsse PE se encontra dividido nos mesmos tr\u00eas m\u00f3dulos que o PE Float est\u00e1 dividido. \n\nEssa divis\u00e3o se deu da mesma maneira que o PE Float, e foi feita de acordo com a ordem das \n\nopera\u00e7\u00f5es e simplifica\u00e7\u00e3o da equa\u00e7\u00e3o utilizada. \n\nPortanto, o PE H\u00edbrido possui as mesmas funcionalidades do PE Float e realiza a \n\nmesma opera\u00e7\u00e3o, gerando os mesmos resultados matem\u00e1ticos, observada a precis\u00e3o esperada. \n\nO PE H\u00edbrido surgiu da necessidade de redu\u00e7\u00e3o da \u00e1rea ocupada na FPGA pelo PE \n\nFloat. Isso foi feito para que fosse poss\u00edvel se instanciar mais n\u00facleos aritm\u00e9ticos na FPGA e, \n\nportanto, aumentar a quantidade de dados poss\u00edveis de serem operados. \n\nEssa arquitetura faz uso de uma convers\u00e3o entre a representa\u00e7\u00e3o em ponto flutuante \n\npara a representa\u00e7\u00e3o em ponto fixo. Apesar da perda de precis\u00e3o inerente a essa convers\u00e3o, a \n\nmargem de erro obtida n\u00e3o gerou impacto significativo na arquitetura\n16\n\n. Por outro lado, o \n\nganho de \u00e1rea obtido foi significativo. \n\nO PE H\u00edbrido ocupa uma menor \u00e1rea da FPGA, pois as opera\u00e7\u00f5es de soma, em \n\nponto fixo, ocorrem de maneira bem mais simples do que em ponto flutuante. Isso implica \n\nque menos m\u00f3dulos s\u00e3o necess\u00e1rios para se realizar a mesma opera\u00e7\u00e3o e, consequentemente, \n\nmenos hardware \u00e9 ocupado. \n\nO m\u00f3dulo que realiza uma grande sequ\u00eancia de somas e multiplica\u00e7\u00f5es por \n\nconstantes \u00e9 o Bloco2. Nesse bloco os n\u00fameros em ponto flutuante s\u00e3o convertidos para ponto \n\n                                                 \n16\n\n Os resultados obtidos operam dentro da precis\u00e3o da ordem de 10\n-6\n\n exigida para o modelo do algoritmo RTM \n\npelo Centro de pesquisa da Petrobr\u00e1s (CENPES) no projeto HPCIN, do Centro de Inform\u00e1tica da UFPE  \n\n\n\n100 \n\n \n\n \n\nfixo, s\u00e3o operados, e ao final s\u00e3o convertidos para a nota\u00e7\u00e3o de ponto flutuante novamente. \n\nComo a sa\u00edda desse bloco \u00e9 um n\u00famero em ponto flutuante, ela se encontra equivalente \u00e0 \n\nsa\u00edda do Bloco2 do PE Float. Desse momento em diante no fluxo de execu\u00e7\u00e3o, os PE\u00b4s \n\ndesenvolvidos s\u00e3o iguais. \n\nO Bloco1 e Bloco3 foram explicados na se\u00e7\u00e3o anterior, portanto n\u00e3o ser\u00e3o \n\nexplicados novamente nessa se\u00e7\u00e3o, apesar de tamb\u00e9m fazerem parte do PE H\u00edbrido. Com isso, \n\na seguir, encontra-se apenas a explica\u00e7\u00e3o do Bloco2.  \n\n \n\n5.3.1 Bloco2 \n \n\nComo dito anteriormente, este bloco \u00e9 respons\u00e1vel por realizar o trecho da equa\u00e7\u00e3o \n\nde diferen\u00e7as finitas presente na equa\u00e7\u00e3o 4.4 deste cap\u00edtulo \n\nEsse bloco recebe, como entrada, n\u00fameros que s\u00e3o advindos apenas de regi\u00f5es \n\nexternas ao PE e est\u00e3o na nota\u00e7\u00e3o padr\u00e3o do IEEE com trinta e dois bits de representa\u00e7\u00e3o. No \n\nentanto, no PE H\u00edbrido, esses n\u00fameros s\u00e3o convertidos em uma nota\u00e7\u00e3o de ponto fixo antes \n\nde sua opera\u00e7\u00e3o. Isso \u00e9 feito para economizar a \u00e1rea ocupada em FPGA pelo PE. Ap\u00f3s essa \n\netapa de convers\u00e3o na entrada, os n\u00fameros podem ser operados normalmente. Ao final de \n\ntodas as opera\u00e7\u00f5es desse bloco, os n\u00fameros devem ser convertidos novamente para nota\u00e7\u00e3o \n\nde ponto flutuante para seguirem com as demais opera\u00e7\u00f5es. \n\nPode-se notar atrav\u00e9s da an\u00e1lise desse trecho da equa\u00e7\u00e3o, que a maior parte das \n\nopera\u00e7\u00f5es realizadas nesse m\u00f3dulo s\u00e3o de soma. Apesar de haver tr\u00eas multiplica\u00e7\u00f5es, essas \n\ns\u00e3o feitas com n\u00fameros que s\u00e3o constantes, ou seja, n\u00e3o s\u00e3o entradas do m\u00f3dulo e, portanto, \n\npodem ser otimizados na opera\u00e7\u00e3o. Com isso, o Bloco2 \u00e9 tamb\u00e9m denominado de \u00e1rvore de \n\nsomas. \n\nO Bloco2 no PE H\u00edbrido \u00e9 composto por cinco grandes blocos: M1Soma, \n\nM16Soma, M90, MSoma1_16_90, Conversor_Fixo_Float, Conversor_Float_Fixo. \n\nA seguir s\u00e3o detalhadas suas arquiteturas. \n\n \n\n5.3.1.1 Conversor_Float_Fixo \n \n\nEssa unidade \u00e9 respons\u00e1vel pela convers\u00e3o dos dados recebidos em formato de ponto \n\nflutuante de 32 bits IEEE-754 para a nota\u00e7\u00e3o de ponto fixo utilizada no PE H\u00edbrido. A \n\nnota\u00e7\u00e3o padr\u00e3o adotada para a representa\u00e7\u00e3o do n\u00famero em ponto fixo \u00e9 de 9 bits para parte \n\ninteira e 27 para a parte fracion\u00e1ria, como debatido do cap\u00edtulo 2 desta disserta\u00e7\u00e3o. \n\n\n\n101 \n\n \n\n \n\nO primeiro ciclo de pipeline desse m\u00f3dulo apenas verifica as exce\u00e7\u00f5es previstas no \n\npadr\u00e3o IEEE e as sinaliza para as demais opera\u00e7\u00f5es. \n\nO segundo ciclo desse m\u00f3dulo faz uma opera\u00e7\u00e3o sobre o expoente do n\u00famero de \n\nentrada. Para tanto, \u00e9 necess\u00e1rio se subtrair o bias presente no expoente do n\u00famero em ponto \n\nflutuante. Como dito no cap\u00edtulo 2, o bias nesse caso possui valor de 127.  \n\nO valor obtido ap\u00f3s a subtra\u00e7\u00e3o do bias corresponde a medida de deslocamento para \n\no valor da mantissa ainda em float.  \n\nN\u00fameros menores do que 2 em ponto flutuante possuem o seu expoente igual ou \n\nmenor ao valor do bias. Com isso, a subtra\u00e7\u00e3o do expoente com o bias nesses casos gera zero \n\nou um n\u00famero negativo. J\u00e1 os n\u00fameros maiores do que 2, possuem o expoente maior do que o \n\nbias, portanto a subtra\u00e7\u00e3o por 127 gerar\u00e1 sempre um n\u00famero positivo. \n\nEssa condi\u00e7\u00e3o \u00e9 tratada de maneira que a subtra\u00e7\u00e3o pelo bias sempre gera um \n\nresultado positivo. Isso \u00e9 feito apenas realizando-se uma compara\u00e7\u00e3o do expoente com 127. \n\nCaso seja maior, \u00e9 feita a subtra\u00e7\u00e3o e deve-se realizar um deslocamento para a direita com o \n\nsignificando pelo n\u00fameros de vezes obtido com a subtra\u00e7\u00e3o. Caso seja menor, \u00e9 feita a \n\nsubtra\u00e7\u00e3o e deve-se realizar um deslocamento para a esquerda com o significando pelo \n\nn\u00fameros de vezes obtido com a subtra\u00e7\u00e3o. Caso seja igual, n\u00e3o \u00e9 necess\u00e1rio se realizar \n\ndeslocamentos no significando. \n\nO terceiro ciclo desse m\u00f3dulo recebe os valores e a dire\u00e7\u00e3o dos deslocamentos a \n\nserem realizados no significando do n\u00famero e apenas realiza tal opera\u00e7\u00e3o. \n\nO quarto ciclo, faz uma opera\u00e7\u00e3o de complemento a dois do n\u00famero, invertendo \n\ntodos os bits do significando e somando-se 1. \n\nAo final dessa opera\u00e7\u00e3o t\u00eam-se o n\u00famero em representa\u00e7\u00e3o de ponto fixo e em \n\nnota\u00e7\u00e3o de complemento a dois j\u00e1 preparado para se realizar as opera\u00e7\u00f5es aritm\u00e9ticas no PE \n\nH\u00edbrido.  \n\nPode-se observar o fluxograma geral do Conversor_Float_Fixo na figura 42 a seguir. \n\nEsse m\u00f3dulo possui ao todo quatro est\u00e1gios de pipeline. \n\n \n\n\n\n102 \n\n \n\n \n\nFigura 42 - Fluxograma geral do Conversor_Float_Fixo. \n\n \n\n \n\n5.3.1.2 M1Soma \n \n\nEsse bloco \u00e9 respons\u00e1vel por realizar o seguinte trecho da equa\u00e7\u00e3o do operador de \n\ndiferen\u00e7as finitas na nota\u00e7\u00e3o de ponto fixo: \n\n \n\n?1 ? (????2? + ???+2? +  ???2?? +  ??+2?? \n +   ?????2\n\n \n +  ????+2)          (4.6) \n\n \n\n Para se realizar essa opera\u00e7\u00e3o, as somas foram separadas em somas de dois termos, \n\napenas. Com isso, foram somadas as duplas ???2??   e ??+2?? \n, ????2?  e ???+2?, e tamb\u00e9m a \n\ndupla ?????2\n \n\n e ????+2. Essas tr\u00eas somas foram feitas em paralelo em apenas um ciclo de \n\nrel\u00f3gio.  \n\nAp\u00f3s a primeira rodada de somas, \u00e9 feita a soma de seus resultados entre si. Essa \n\nopera\u00e7\u00e3o \u00e9 feita no terceiro e \u00faltimo ciclo desse m\u00f3dulo. \n\nTamb\u00e9m no \u00faltimo ciclo desse m\u00f3dulo \u00e9 feita uma opera\u00e7\u00e3o equivalente a \n\nmultiplica\u00e7\u00e3o por -1 ao resultado da soma final. Essa opera\u00e7\u00e3o equivale a um complemento a \n\ndois, uma opera\u00e7\u00e3o de invers\u00e3o dos bits e em seguida a soma de 1. \n\n\n\n103 \n\n \n\n \n\nFigura 43 - Fluxograma geral do M1Soma. \n\n \n\n  \n\n5.3.1.3 M16Soma \n \n\n\u00c9 o componente do Bloco2 que \u00e9 respons\u00e1vel por realizar o seguinte trecho da \n\nequa\u00e7\u00e3o do operador de diferen\u00e7as finitas, em ponto fixo: \n\n \n\n16 ? (????1? + ???+1? +  ???1?? +  ??+1?? \n +  ?????1\n\n \n  +  ????+1)        (4.7) \n\n \n\n Assim como o bloco M1Soma descrito anteriormente, esse trecho de equa\u00e7\u00e3o foi \n\nseparado em tr\u00eas somas de dois elementos. Com isso, foram somadas as duplas \n\n???1??   e ??+1?? \n, ????1?  e ???+1?, e tamb\u00e9m a dupla ?????1 \n\n e ????+1. Essas tr\u00eas opera\u00e7\u00f5es s\u00e3o \n\nfeitas em paralelo em um \u00fanico ciclo.  \n\nNo ciclo seguinte, seus valores s\u00e3o adicionados e a multiplica\u00e7\u00e3o por 16 \u00e9 realizada. \n\nUma otimiza\u00e7\u00e3o foi feita para se realizar essa multiplica\u00e7\u00e3o. Como o n\u00famero a ser \n\nmultiplicado \u00e9 constante e corresponde a 2\n4\n, significa que a opera\u00e7\u00e3o pode ser substitu\u00edda por \n\num deslocamento para a esquerda (shift left) de quatro posi\u00e7\u00f5es.  \n\nPode-se observar o fluxograma geral do M16Soma na figura 44 a seguir. \n\n Essa unidade possui ao todo tr\u00eas est\u00e1gios de pipeline.  \n\n\n\n104 \n\n \n\n \n\nFigura 44 - Fluxograma geral do M16Soma. \n\n \n\n \n\n5.3.1.4 M90 \n \n\n\u00c9 o componente do Bloco2 do PE H\u00edbrido que \u00e9 respons\u00e1vel por realizar o seguinte \n\ntrecho da equa\u00e7\u00e3o do operador de diferen\u00e7as finitas em ponto fixo: \n\n \n\n  ?90 ? ????     \n\n \n\n Inicialmente \u00e9 feita a identifica\u00e7\u00e3o de exce\u00e7\u00f5es do n\u00famero recebido. Essa opera\u00e7\u00e3o \u00e9 \n\nfeita no primeiro ciclo de pipeline do m\u00f3dulo  \n\nDiferentemente dos subcomponentes do Bloco2 descritos anteriormente, essa \n\nunidade n\u00e3o possui somas, mas apenas uma multiplica\u00e7\u00e3o por uma constante. Pode-se \n\nobservar a representa\u00e7\u00e3o de -90 na nota\u00e7\u00e3o de ponto fixo utilizada na figura 45. \n\nNo segundo ciclo, \u00e9 feita a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o e, no seguinte, uma opera\u00e7\u00e3o \n\nde arredondamento. Por fins de economia de recurso de hardware, optou-se por se realizar um \n\ntruncamento do resultado, sem acarretar em perdas significativas de precis\u00e3o.  \n\n \n\nFigura 45 - Representa\u00e7\u00e3o de -90 na nota\u00e7\u00e3o de ponto fixo utilizada. \n\n \n\n \n\n\n\n105 \n\n \n\n \n\nPode-se observar o fluxo geral de execu\u00e7\u00e3o do m\u00f3dulo M90 na figura 46 a seguir. \n\nAo todo, o bloco M90 possui 3 est\u00e1gios de pipeline. \n\n \n\nFigura 46 - Fluxograma geral de execu\u00e7\u00e3o do M90. \n\n \n\n \n\n5.3.1.5 MSoma1_16_90 \n \n\n\u00c9 a unidade integrante do Bloco2 respons\u00e1vel por realizar a soma dos resultados \n\nadvindos dos blocos: M1Soma, M16Soma, M90, em formato de ponto fixo.  \n\nEsse m\u00f3dulo basicamente realiza as duas somas entre essas tr\u00eas entradas. Essa \n\nopera\u00e7\u00e3o \u00e9 feita em um ciclo de rel\u00f3gio, apenas. Especificamente, essa opera\u00e7\u00e3o \u00e9 feita no \n\nsegundo est\u00e1gio do pipeline do m\u00f3dulo. \n\nO primeiro est\u00e1gio do pipeline desse m\u00f3dulo \u00e9 respons\u00e1vel pela verifica\u00e7\u00e3o de \n\nexce\u00e7\u00f5es. Observa-se o fluxograma de execu\u00e7\u00e3o desse m\u00f3dulo na figura 47. \n\n \n\nFigura 47 - Fluxograma geral de execu\u00e7\u00e3o do MSoma1_16_90. \n\n \n\n\n\n106 \n\n \n\n \n\n5.3.1.6 Conversor_Fixo_Float \n \n\nEsse componente realiza a convers\u00e3o de n\u00fameros no formato de ponto fixo para \n\nponto flutuante IEEE-754. \n\nInicialmente, no primeiro ciclo de pipeline \u00e9 feita a verifica\u00e7\u00e3o quanto as exce\u00e7\u00f5es \n\nprevistas pelo padr\u00e3o IEEE.  \n\nEm seguida, no segundo ciclo, \u00e9 feita uma opera\u00e7\u00e3o de complemento a dois, pois o \n\nn\u00famero em ponto fixo precisa ser representado na nota\u00e7\u00e3o de magnitude e sinal. \n\nAp\u00f3s essa etapa, \u00e9 feita uma contagem de bits da esquerda para a direita, at\u00e9 o \n\nprimeiro bit \u20181\u2019 ser encontrado. Essa contagem serve indica a quantidade de deslocamentos a \n\nserem realizados no n\u00famero, em ponto fixo.  \n\nPara a correta representa\u00e7\u00e3o em ponto flutuante o n\u00famero deve estar normalizado, \n\nou seja, s\u00f3 deve haver um \u00fanico bit antes do ponto separador e esse deve ter valor 1.  \n\nCaso a quantidade de deslocamentos seja maior do que o tamanho da parte inteira do \n\nn\u00famero em ponto fixo, no caso 9, significa que o n\u00famero em ponto fixo \u00e9 menor do que 1 e, \n\nportanto, s\u00f3 possui parte fracion\u00e1ria. Portanto, deve ter sua parte inteira e fracion\u00e1ria \n\ndeslocadas para a esquerda pelo n\u00famero de vezes equivalente a subtra\u00e7\u00e3o da contagem do \n\nest\u00e1gio anterior por 9.  \n\nCaso a quantidade de deslocamentos seja menor do que 9, significa que o n\u00famero \u00e9 \n\nmaior ou igual a 1 e possui parte inteira diferente de 0. Portanto, deve ter sua parte inteira e \n\nfracion\u00e1ria deslocadas para a direita pelo n\u00famero de vezes equivalente a subtra\u00e7\u00e3o de 9 pelo \n\nresultado da contagem no est\u00e1gio anterior. \n\nAtrav\u00e9s dessa quantidade de deslocamento \u00e9 feita uma l\u00f3gica para se adicionar ou \n\nsubtrair um determinado valor ao bias, gerando assim o expoente em ponto flutuante do \n\nn\u00famero.  \n\nSubtrai-se ent\u00e3o do bias (127) o valor encontrado, caso tenha ocorrido um \n\ndeslocamento para a esquerda ou soma-se o valor encontrado, caso tenha ocorrido um \n\ndeslocamento para a direita.  \n\nCasos especiais devem ser tratados a parte, como \u00e9 o caso do zero, identificado ao \n\nlongo das opera\u00e7\u00f5es dentro do m\u00f3dulo, para que ocorra sua correta representa\u00e7\u00e3o no padr\u00e3o \n\nIEEE. \n\n \n\n \n\n\n\n107 \n\n \n\n \n\nOs subcomponentes presentes nesse bloco ser\u00e3o descritos a fundo no decorrer deste \n\ncap\u00edtulo. \n\nPode-se observar a estrutura do Bloco 2 na figura 48 a seguir. \n\n \n\nFigura 48 - Arquitetura do Bloco2 do PE H\u00edbrido \n\n \n\n \n\n5.4 Metodologia de Desenvolvimento \n\n \n\nPara o desenvolvimento de um m\u00f3dulo aritm\u00e9tico capaz de calcular o operador de \n\ndiferen\u00e7as finitas utilizado no RTM em hardware reconfigur\u00e1vel, foi necess\u00e1ria a realiza\u00e7\u00e3o de \n\nalgumas etapas pr\u00e9vias. Essas etapas de desenvolvimento incremental definiram, tamb\u00e9m, \n\nmetodologia de verifica\u00e7\u00e3o dos m\u00f3dulos desenvolvidos. \n\nDevido \u00e0 complexidade da equa\u00e7\u00e3o e dos algoritmos aritm\u00e9ticos em ponto flutuante, \n\nfoi necess\u00e1ria a cria\u00e7\u00e3o de vers\u00f5es de solu\u00e7\u00f5es da equa\u00e7\u00e3o em diferentes n\u00edveis de abstra\u00e7\u00e3o \n\nde programa\u00e7\u00e3o. Essa abstra\u00e7\u00e3o das camadas de hardware, objetivo final deste trabalho, \n\nseguiu do alto n\u00edvel at\u00e9 chegar, finalmente, na vers\u00e3o definitiva em FPGA. \n\nA cria\u00e7\u00e3o de modelos em mais alto n\u00edvel do m\u00f3dulo se fez necess\u00e1ria por permitir \n\num estudo pr\u00e9vio das estrat\u00e9gias de implementa\u00e7\u00e3o. Essa etapa envolve tanto a escolha do \n\npadr\u00e3o de representa\u00e7\u00e3o num\u00e9rica a ser adotado, quanto a verifica\u00e7\u00e3o dos efeitos desta \n\nescolha sobre o resultado do processamento.   \n\n\n\n108 \n\n \n\n \n\nOutro ponto significativo nesta etapa \u00e9 a gera\u00e7\u00e3o de modelos de refer\u00eancia \n\nconfi\u00e1veis para a verifica\u00e7\u00e3o e valida\u00e7\u00e3o dos m\u00f3dulos aritm\u00e9ticos em desenvolvimento.  Em \n\nespecial quando tais m\u00f3dulos devem operar sobre tipos de dados que n\u00e3o possuem \n\nrepresenta\u00e7\u00e3o direta nas linguagens de descri\u00e7\u00e3o de hardware. Com isto, fez-se necess\u00e1ria a \n\nado\u00e7\u00e3o de uma metodologia que permita a cria\u00e7\u00e3o de modelos de refer\u00eancia capazes de \n\nmapear os resultados obtidos em software com os resultados obtidos no padr\u00e3o de \n\nrepresenta\u00e7\u00e3o num\u00e9rica adotado em hardware. \n\nA metodologia de desenvolvimento obedeceu \u00e0 seguinte ordem: \n\n1. Gera\u00e7\u00e3o de um Modelo Can\u00f4nico. \n\n2. Gera\u00e7\u00e3o de um Modelo de Alto N\u00edvel em Software. \n\n3. Convers\u00e3o do Modelo em Alto N\u00edvel em Software para um Modelo em linguagem de \n\ndescri\u00e7\u00e3o de hardware. \n\n4. Testbench. \n\nPode-se observar na figura 49 o fluxograma do desenvolvimento adotado. A seguir, \n\ns\u00e3o explicados cada uma das etapas citadas. \n\n \n\nFigura 49 - Metodologia de Verifica\u00e7\u00e3o \n\n \n\n \n\n5.4.1 Modelo Can\u00f4nico \n \n\nEsse modelo foi desenvolvido com o objetivo de gerar um conjunto de dados de \n\nrefer\u00eancia que reflete o comportamento esperado do n\u00facleo aritm\u00e9tico em uma situa\u00e7\u00e3o real \n\nde uso. \n\n\n\n109 \n\n \n\n \n\nPara tanto, uma vers\u00e3o em software, implementada em C++, foi desenvolvida. Essa \n\nvers\u00e3o opera com entradas geradas aleatoriamente pelo algoritmo que ent\u00e3o calcula as sa\u00eddas. \n\nEssas respostas s\u00e3o armazenadas para serem utilizadas em etapas posteriores de verifica\u00e7\u00e3o. \n\nO gerador de entradas imp\u00f5e limites ao alcance dos n\u00fameros. Isso \u00e9 feito para que os \n\nn\u00fameros gerados estejam pr\u00f3ximos dos que podem ser encontrados em situa\u00e7\u00f5es de \n\nprocessamento real. A varia\u00e7\u00e3o m\u00e9dia dos n\u00fameros coletados pelo algoritmo de an\u00e1lises \n\ns\u00edsmicas foi validada pelo Cenpes (2015) em parceria com o projeto HPCIn (2014) da UFPE.  \n\nComo exemplo, pode-se citar a varia\u00e7\u00e3o das velocidades de propaga\u00e7\u00e3o dos campos \n\nde press\u00e3o que n\u00e3o excedem a velocidade de 2\n15\n\n km/h nos modelos adotados. Essa \n\ncaracter\u00edstica da velocidade, juntamente com a dos demais par\u00e2metros do operador de \n\ndiferen\u00e7as finitas, foi simulada pelo gerador de entradas que alimenta a vers\u00e3o do n\u00facleo \n\naritm\u00e9tico em alto n\u00edvel. \n\nA vers\u00e3o em software possui etapas de convers\u00e3o de n\u00fameros inteiros para a \n\nrepresenta\u00e7\u00e3o em magnitude e sinal dos n\u00fameros em ponto flutuante. Isso gera os n\u00fameros j\u00e1 \n\ncom os componentes de sinal, expoente e mantissa. Esses elementos s\u00e3o operados \n\nseparadamente, j\u00e1 seguindo o fluxo de opera\u00e7\u00e3o do padr\u00e3o IEEE-754 e, ao final, tem seu \n\nresultado reagrupado para a vers\u00e3o de sa\u00edda do formato desejado. \n\nNo modelo can\u00f4nico a equa\u00e7\u00e3o do operador de diferen\u00e7as finitas do RTM \u00e9 realizada \n\nde maneira mais direta poss\u00edvel, sem o particionamento da equa\u00e7\u00e3o em blocos. Dessa \n\nmaneira, os n\u00fameros gerados aleatoriamente apenas alimentam a equa\u00e7\u00e3o para se conhecer e \n\nguardar a sa\u00edda correspondente do operador para aquele determinado conjunto de dados de \n\nentrada. \n\nO objetivo desse modelo tamb\u00e9m \u00e9 ser de natureza simples, tanto de implementa\u00e7\u00e3o, \n\nquanto de verifica\u00e7\u00e3o. Caso contr\u00e1rio, um novo sistema de verifica\u00e7\u00e3o teria que ter sido \n\nimplementado para esse m\u00f3dulo. \n\n \n\n5.4.2 Modelo de Linguagem de Alto N\u00edvel \n \n\nO objetivo desse modelo \u00e9 a implementa\u00e7\u00e3o de uma vers\u00e3o de mais baixo n\u00edvel do \n\nmodelo can\u00f4nico, utilizando a camada de mais alto n\u00edvel da linguagem de System Verilog\n17\n\n. \n\nCom isso, uma camada intermedi\u00e1ria entre a vers\u00e3o em software e a vers\u00e3o em hardware foi \n\ngerada. \n\n                                                 \n17\n\n System Verilog. Acesso em: jul. 2015. Dispon\u00edvel em:&lt;http://www.eda.org/sv/SystemVerilog_3.1a.pdf> \n\n\n\n110 \n\n \n\n \n\nFoi nesse modelo em alto n\u00edvel que se iniciou o particionamento do m\u00f3dulo \n\naritm\u00e9tico em blocos. Esse particionamento foi feito de acordo com as depend\u00eancias dos \n\nn\u00fameros no fluxo de execu\u00e7\u00e3o do operador de diferen\u00e7as finitas no RTM. Isto \u00e9, procurou-se \n\nagrupar em um bloco os n\u00fameros que podiam ser melhor operados de maneira paralela. Isso \n\ngerou a reorganiza\u00e7\u00e3o da equa\u00e7\u00e3o do operador de diferen\u00e7as finitas que levou a divis\u00e3o do PE \n\nem tr\u00eas grandes blocos. \n\nAssim como no modelo can\u00f4nico, os blocos operam internamente com os n\u00fameros \n\nj\u00e1 na nota\u00e7\u00e3o de sinal, expoente e mantissa. No entanto, diferentemente do modelo can\u00f4nico \n\nque n\u00e3o esmi\u00fa\u00e7a as opera\u00e7\u00f5es, o modelo em alto n\u00edvel realiza as opera\u00e7\u00f5es aritm\u00e9ticas em \n\nv\u00e1rias etapas. Essas etapas s\u00e3o as correspondentes aos passos descritos no cap\u00edtulo dois dessa \n\ndisserta\u00e7\u00e3o para a soma, subtra\u00e7\u00e3o e multiplica\u00e7\u00e3o dos n\u00fameros em ponto flutuante. Com isso \n\nos n\u00fameros s\u00e3o operados de maneira semelhante a como s\u00e3o operados diretamente no \n\nhardware. \n\nIsso permitiu realizar as opera\u00e7\u00f5es aritm\u00e9ticas com as restri\u00e7\u00f5es impostas pelo \n\npadr\u00e3o IEEE-754 com os n\u00fameros no software. Devido a isso, foi poss\u00edvel fazer a simula\u00e7\u00e3o \n\ndas etapas das opera\u00e7\u00f5es aritm\u00e9ticas em alto n\u00edvel, permitindo a identifica\u00e7\u00e3o de erros de \n\nimplementa\u00e7\u00e3o antes da aplica\u00e7\u00e3o direta em hardware. \n\nO modelo em alto n\u00edvel recebe como entrada os n\u00fameros gerados no modelo \n\ncan\u00f4nico. Esses n\u00fameros s\u00e3o operados pelos blocos e ao final seus resultados s\u00e3o comparados \n\ncom os resultados do modelo can\u00f4nico previamente armazenados. O modelo can\u00f4nico atua \n\ncomo uma refer\u00eancia para a corretude dos algoritmos do modelo em alto n\u00edvel. Portanto, os \n\ndois modelos devem apresentar as mesmas respostas dadas as mesmas entradas.  \n\nNesta etapa do projeto tamb\u00e9m foram definidos os padr\u00f5es de representa\u00e7\u00e3o \n\nnum\u00e9rica adotados, ponto flutuante e ponto fixo, bem como, a precis\u00e3o num\u00e9rica dos \n\noperandos, dos operadores aritm\u00e9ticos utilizados e dos resultados.   \n\n \n\n5.4.3 Modelo em Linguagem HDL \n \n\nNessa fase da metodologia, o modelo obtido na etapa anterior \u00e9, ent\u00e3o, traduzido da \n\nlinguagem de alto n\u00edvel para uma linguagem de descri\u00e7\u00e3o de hardware (HDL).  \n\nPara tanto, \u00e9 mantida a estrutura de grandes blocos e m\u00f3dulos menores definidos nas \n\netapas anteriores para simplificar o desenvolvimento do projeto.  \n\n\n\n111 \n\n \n\n \n\nNessa fase, o c\u00f3digo em linguagem de hardware propriamente dito foi feito. Tendo \n\ntodos os testes sido feitos para os estudos nas etapas anteriores, essa etapa n\u00e3o apresenta \n\ngrandes mudan\u00e7as de fluxo de opera\u00e7\u00f5es aritm\u00e9ticas. \n\nEsse c\u00f3digo foi feito com a parte sintetiz\u00e1vel da linguagem System Verilog, a \n\ncamada mais pr\u00f3xima do hardware dessa linguagem. Isso exigiu ajustes na codifica\u00e7\u00e3o feita \n\nna etapa de modelagem em alto n\u00edvel, modificando-se as camadas que n\u00e3o podiam ser \n\nimplementadas diretamente em FPGA para camadas implement\u00e1veis. \n\nDurante essa fase, \u00e9 observada a utiliza\u00e7\u00e3o de termos aritm\u00e9ticos de multiplica\u00e7\u00e3o e \n\nsoma que podem ser inferidos durante o processo de s\u00edntese em elementos l\u00f3gicos de presen\u00e7a \n\nlimitada na FPGA, como os DSPs. Isso implica um cuidado durante a programa\u00e7\u00e3o e a \n\nfragmenta\u00e7\u00e3o de determinados trechos de c\u00f3digo para que a ferramenta de s\u00edntese espalhe as \n\nopera\u00e7\u00f5es na l\u00f3gica da FPGA, economizando blocos DSPs, por exemplo.  \n\nO modelo de refer\u00eancia em alto n\u00edvel serve como modelo de corretude dos \n\nresultados para o modelo em linguagem HDL. Ao longo do desenvolvimento do modelo de \n\nmais baixo n\u00edvel o resultado do operador de diferen\u00e7as finitas deve ser o mesmo do modelo de \n\nalto n\u00edvel. \n\nAo final desta etapa, o m\u00f3dulo em hardware foi desenvolvido e se encontra \n\nfuncional para seguir para a etapa de testes exaustivos. \n\n \n\n5.4.4 Testbench \n \n\n Para garantir a confiabilidade dos m\u00f3dulos desenvolvidos durante o desenvolvimento \n\nda arquitetura uma estrutura de testes foi elaborada. Esse modelo de testes foi utilizado dentro \n\ndo projeto HPCIn (2014) dentro do Centro de Inform\u00e1tica da UFPE.  \n\nO modelo de testes desenvolvido foi aplicado tanto \u00e0 arquitetura como um todo, \n\nquanto a seus m\u00f3dulos menores. \n\n A arquitetura de testes tamb\u00e9m foi desenvolvida em linguagem System Verilog, que \n\npermite certa abstra\u00e7\u00e3o de implementa\u00e7\u00e3o de elementos do hardware, mas, ao mesmo tempo, \n\nest\u00e1 pr\u00f3xima o bastante do modelo a ser testado. \n\n  A estrutura do Testbench \u00e9 composta dos seguintes m\u00f3dulos: \n\n? Source: M\u00f3dulo de entrada do Testbench, respons\u00e1vel pela gera\u00e7\u00e3o dos est\u00edmulos de teste. \n\nNele s\u00e3o definidos o alcance num\u00e9rico dos testes, a frequ\u00eancia de amostras de casos \n\nespec\u00edficos a serem gerados e a dura\u00e7\u00e3o dos testes.  \n\n\n\n112 \n\n \n\n \n\n? TDriver: Esse m\u00f3dulo \u00e9 respons\u00e1vel pela interface dos n\u00fameros gerados no Source com o \n\nmodelo a ser testado (DUV). Ele \u00e9 capaz de receber os est\u00edmulos de entrada e gerar os sinais \n\nnecess\u00e1rios ao controle do DUV no formato adequado para seu funcionamento. \n\n? DUV: Corresponde ao Device Under Verification (DUV) ou Dispositivo a ser verificado. \n\nNesse m\u00f3dulo est\u00e3o encapsulados os PE\u00b4s desenvolvidos e que precisam ser verificados \n\nquanto a sua corretude. Ele recebe os sinais advindos do TDriver, j\u00e1 com pulso de rel\u00f3gio \n\n(clock) adequado, e gera uma  sa\u00edda num\u00e9rica da mesma maneira que seu funcionamento \n\nnormal. \n\n? Monitor: Respons\u00e1vel por receber os sinais de sa\u00edda e fazer a verifica\u00e7\u00e3o dos resultados \n\ngerados pelo DUV. Esse m\u00f3dulo tamb\u00e9m monitora os demais sinais gerados pelo DUV, que \n\ncorrespondem a fun\u00e7\u00f5es de controle, como exce\u00e7\u00f5es, por exemplo. Ele tamb\u00e9m \u00e9 respons\u00e1vel \n\npor realizar a interface com o m\u00f3dulo de checagem de resultados e preparar a sa\u00edda do DUV \n\npara ser compat\u00edvel com a entrada desse m\u00f3dulo de checagem.  \n\n? Checker: Esse componente \u00e9 respons\u00e1vel por verificar a corretude dos resultados gerados \n\npelo DUV. Essa corretude engloba aspectos como precis\u00e3o, varia\u00e7\u00e3o do alcance num\u00e9rico, \n\ncorreto tratamento de exce\u00e7\u00f5es. Em suma, esse m\u00f3dulo certifica-se de que a sa\u00edda num\u00e9rica \n\ndo DUV corresponde a gerada pelo modelo de refer\u00eancia (RefMod).  \n\n? RefMod: Modelo de refer\u00eancia em linguagem de mais alto n\u00edvel, do que o dispositivo sob \n\nverifica\u00e7\u00e3o. Esse m\u00f3dulo recebe os est\u00edmulos num\u00e9ricos gerados pelo Source e executa o \n\nalgoritmo a ser desenvolvido pelo DUV. Ao fim de sua execu\u00e7\u00e3o, tem-se um conjunto de \n\ndados num\u00e9ricos de refer\u00eancia. Esses dados servem como entrada para o m\u00f3dulo de checagem \n\nque tamb\u00e9m recebe a sa\u00edda do DUV e realiza a compara\u00e7\u00e3o entre eles. \n\nA figura 50 a seguir exp\u00f5e a vis\u00e3o geral da arquitetura de testes desenvolvida para se \n\nverificar a corretude dos resultados dos PE\u2019s. Nela, pode-se observar todos os m\u00f3dulos que \n\ncomp\u00f5em a arquitetura de testes, bem como suas interconex\u00f5es. \n\n \n\n\n\n113 \n\n \n\n \n\nFigura 50 \u2013 Vis\u00e3o geral da arquitetura de testes. \n\n \n\n \n\n \n\n5.5 Conclus\u00f5es \n\n \n\nEste cap\u00edtulo apresentou as arquiteturas essenciais desenvolvidas para este trabalho.  \n\nFoi exposta inicialmente uma vis\u00e3o geral da arquitetura com seus m\u00f3dulos mais \n\nutilizlados e a estrutura em tr\u00eas grandes blocos. Em seguida, foram expostos os componentes \n\ndo PE Float. Por fim, o PE H\u00edbrido foi exposto bem como todos os seus m\u00f3dulos menores. \n\nAl\u00e9m de expor os detalhes das arquiteturas dos PE\u00b4s, tamb\u00e9m foi exposta toda a \n\nmetodologia adotada para seu desenvolvimento, a qual foi a mesma utilizada para todas as \n\nsuas vers\u00f5es, das mais simples \u00e0s mais complexas. \n\n \n\n  \n\n\n\n114 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n6 \n6. Resultados \n\n \n\n \n\nNeste cap\u00edtulo ser\u00e3o discutidos os resultados obtidos com o n\u00facleo de \n\nprocessamento aritm\u00e9tico desenvolvido em FPGA bem como os resultados obtidos na \n\nplataforma de RTM 3D. \n\n \n\n \n\n \n\n \n\n  \n\n\n\n115 \n\n \n\n \n\n6.1 Resultados de S\u00edntese para uma FPGA Stratix IV da Altera \n\n \n\nNesta se\u00e7\u00e3o, est\u00e3o expostos os resultados obtidos pelos respectivos PE\u00b4s \n\nimplementados para FPGA. Esses resultados foram obtidos em n\u00edvel de s\u00edntese pela \n\nferramenta Quartus II da Altera e fazem parte de seu relat\u00f3rio de s\u00edntese. \n\n \n\nA tabela 7 a seguir cont\u00e9m os resultados de s\u00edntese do PE3D Float utilizados como \n\nbase para compara\u00e7\u00e3o, bem como, os resultados do PE H\u00edbrido. A s\u00edntese foi feita para um \n\nStratix IV EP4SE530H35C2, na ferramenta Quartus II (ALTERA, 2014). \n\n  \nTabela 7 - Resultado de S\u00edntese do PE Float e PE H\u00edbrido para Stratix IV. \n\nDispositivo PE FLOAT PE H\u00edbrido Total dispon\u00edvel \n\nALUTs 12.370  8.611  424.960 \n\nBlocos DSP\u00b4s 36  40  1.024 \n\nRegistradores 10.341 8.105  424.960 \n\n \n\nAnalisando-se a tabela acima, pode-se observar que a \u00e1rea ocupada por cada PE em \n\ntemos de l\u00f3gica (ALUTs) foi bem reduzida em rela\u00e7\u00e3o \u00e0 \u00e1rea total dispon\u00edvel em FPGA.  \n\nDo total de DSP\u00b4s dispon\u00edveis na Stratix IV apenas uma fra\u00e7\u00e3o foi utilizada por cada \n\nPE. No entanto, os PE\u00b4s desenvolvidos consomem relativamente mais DSP\u00b4s, cerca de 4% do \n\nque ALUT\u00b4s, de 2% at\u00e9 3% aproximadamente. Isso implica que o limitante para uma maior \n\npresen\u00e7a de PE\u00b4s dentro da FPGA s\u00e3o os blocos DSP\u00b4s.  \n\n Os DSP\u00b4s s\u00e3o de suma import\u00e2ncia, pois s\u00e3o otimizados para alguns processos \n\naritm\u00e9ticos como multiplica\u00e7\u00f5es, melhorando a frequ\u00eancia geral dos m\u00f3dulos aritm\u00e9ticos. No \n\nentanto, esse \u00e9 um recurso mais limitado para alguns FPGA do que a l\u00f3gica, como se observa \n\nna tabela 7. Parte da computa\u00e7\u00e3o que deveria ser realizada nos DSP\u00b4s, se distribui ao longo da \n\n\u00e1rea l\u00f3gica do FPGA, como os ALUTs, deixando apenas os segmentos priorit\u00e1rios de \n\ncomputa\u00e7\u00e3o para os DSP\u2019s. \n\nEm um caso te\u00f3rico assumindo-se o pior dos limitantes de recursos, o n\u00famero de \n\nDSP\u00b4s, poderia-se instanciar 28 PE\u00b4s Float e 25 PE\u00b4s H\u00edbridos em uma Stratix IV.  \n\nCaso outro modelo de FPGA, com n\u00famero de DSP\u00b4s abundante fosse utilizado, o \n\nlimitante seria a quantidade de ALUT\u00b4s consumidas por cada PE. Sob esse ponto de vista \n\nseria poss\u00edvel se instanciar 34 PE\u00b4s Float e 49 PE\u00b4s H\u00edbridos. \n\nAnalisando-se esses n\u00fameros pode-se perceber que o PE H\u00edbrido \u00e9 mais econ\u00f4mico \n\nem termos de l\u00f3gica e mais oneroso em termos de DSP\u00b4s. Isso ocorre pois parte de trechos \n\n\n\n116 \n\n \n\n \n\ndos m\u00f3dulos que utilizam recursos de l\u00f3gica do PE Float passaram a serem feitos em blocos \n\nDSP\u00b4s. \n\nO PE h\u00edbrido foi pensando para se economizar l\u00f3gica da FPGA e portanto atingiu \n\nseu objetivo economizando cerca de 30% das ALUT\u00b4s.  \n\nImplementa\u00e7\u00f5es do operador de diferen\u00e7as finitas do RTM em FPGA cuja a presen\u00e7a \n\nde DSP\u00b4s \u00e9 escassa podem fazer uso do PE Float. Sua economia em termos de DSP\u00b4s \n\ncomparados ao PE H\u00edbrido foi de cerca de 10%. \n\nA etapa de redu\u00e7\u00e3o de \u00e1rea com o PE H\u00ecbrido gerou, portanto, resultados \n\nsatisfat\u00f3rios sem afetar significativamente na precis\u00e3o esperada.  \n\nFazendo a an\u00e1lise de timing com a ferramenta TimeQuest Timing Analyser do \n\nQuartusII (Altera, 2015), as frequ\u00eancias de opera\u00e7\u00e3o obtidas, a n\u00edvel de s\u00edntese, foram 208.78 \n\nMHz para o PE Float e 198.33 MHz para o PE H\u00edbrido, respectivamente. \n\n \n\n6.2 Resultados obtidos na plataforma para modelagem 3D do algoritmo de \n\nRTM em FPGA \n\n \n\nNessa se\u00e7\u00e3o, est\u00e3o presentes os resultados obtidos com o caso de uso desenvolvido. \n\nO FPGA utilizado foi o Stratix IV, refer\u00eancia EP4SE530H35C2. A plataforma de s\u00edntese \n\nutilizada foi o QuartusII  vers\u00e3o 14.1 de 64 bits da Altera. \n\n O caso de uso deste trabalho foi operado e testado tamb\u00e9m em hardware, ou seja, \n\ncom toda a arquitetura presente em FPGA. Os resultados de s\u00edntese obtidos em n\u00edvel de Place \n\nand Route na plataforma citada est\u00e3o presentes na tabela 8, a seguir: \n\n \n\nTabela 8 - Recursos utilizados pela plataforma RTM para uma Stratix IV. \n\nTotal PE Float PE H\u00edbrido \n\nALUTs 238,607 196,879 \n\nLogic Registers 303,098 283,646 \n\nDSP\u00b4s 684 748 \n\nFrequ\u00eancia 154.44 MHz 154.92 MHz \n\n \n\n Pode-se observar na tabela 8 que a arquitetura com o PE Float ocupou 238.607 \n\nALUTs. A arquitetura com o PE H\u00edbrido ocupou 196.879 ALUTs, ou seja, uma redu\u00e7\u00e3o de \n\ncerca de 17,49% da l\u00f3gica ocupada em rela\u00e7\u00e3o ao PE Float.  \n\n\n\n117 \n\n \n\n \n\nEm termos de n\u00famero de DSP\u00b4s utilizados, a arquitetura com o PE Float ocupou 684, \n\ne a com o PE H\u00edbrido, o que representa um aumento de cerca de 8,56% do uso de DSPs em \n\nrela\u00e7\u00e3o ao PE Float. \n\n Na plataforma de modelagem 3D a FPGA utilizada possui um bom n\u00famero de blocos \n\nDSP\u00b4s, 1024 ao total, que n\u00e3o s\u00e3o utilizados pelos demais componentes da arquitetura do \n\nRTM. O mesmo n\u00e3o ocorre com a l\u00f3gica dispon\u00edvel em FPGA, que \u00e9 utilizado pelos \n\ncomponentes da plataforma e, portanto, tinha que ser economizada pelo n\u00facleo de \n\nprocessamento. Com isso o n\u00famero de DSP\u00b4s utilizados pelo n\u00facleo aritm\u00e9tico n\u00e3o possu\u00ed \n\nimpacto significativo na arquitetura geral e o PE H\u00edbrido se torna mais eficiente em termos de \n\nrecursos utilizados. \n\nAs frequ\u00eancias obtidas nas duas arquiteturas foram as mesmas e pr\u00f3ximas de \n\n154MHz. Isso demonstra que o PE H\u00edbrido, al\u00e9m de ocupar menor \u00e1rea em FPGA, n\u00e3o teve \n\nsua frequ\u00eancia de opera\u00e7\u00e3o degradada. \n\nA tabela 9 a seguir exp\u00f5e os resultados em termos percentuais, o que torna mais f\u00e1cil \n\na an\u00e1lise dos ganhos entre os PE H\u00edbrido e PE Float.  \n\n \n\nTabela 9 - Recursos utilizados pela plataforma RTM em termos percentuais para uma Stratix IV. \n\n PE Float PE H\u00edbrido Total \n\nALUTs 56,15% 46,79% 424,960  \n\nLogic Registers 71,32% 66,75% 424,960 \n\nDSP\u00b4s 66,79% 73,14% 1024 \n\nTotal Pins 98% 98% 744 \n\nLogic Utilization 100% 79% 100% \n\n \n\nAnalisando-se a tabela 9, t\u00eam-se os resultados obtidos com o PE H\u00edbrido. Nota-se a \n\nredu\u00e7\u00e3o no n\u00famero de ALUT\u00b4s de 56,15% para 46,79%. Esse \u00e9 resultado \u00e9 importante, pois \n\nquanto menos \u00e1rea o PE ocupa, mais PE\u00b4s poder\u00e3o estar presentes na arquitetura.  \n\nOutro fator relevante \u00e9 que o peso da \u00e1rea ocupada pelo PE em rela\u00e7\u00e3o aos demais \n\ncomponentes da arquitetura tornou-se menor, liberando, assim, espa\u00e7o no FPGA para a \n\ninser\u00e7\u00e3o de novos componentes da plataforma 3D. \n\n Pode-se notar que o n\u00famero de DSP\u00b4s utilizados sofreu um leve aumento, pois parte \n\nda l\u00f3gica utilizada, que antes era espalhada em ALUT\u00b4s, migrou para o uso de DSP\u00b4s. Devido \n\nao fato de os DSP\u00b4s presentes na placa n\u00e3o serem essenciais para os demais componentes da \n\narquitetura, o PE ficou livre para usar esse recurso sem grandes restri\u00e7\u00f5es. \n\n\n\n118 \n\n \n\n \n\n Outro recurso utilizado que merece destaque \u00e9 o n\u00famero de pinos da FPGA. Pode-se \n\nobservar que ambas as arquiteturas utilizaram quase que a totalidade dos pinos dispon\u00edveis \n\npara comunica\u00e7\u00e3o do FPGA. Isso demonstra que a plataforma 3D desenvolvida estava \n\noperando no limite da comunica\u00e7\u00e3o dispon\u00edvel para o FPGA utilizada. Al\u00e9m disso, mostra o \n\nquanto o projeto foi otimizado para utilizar o m\u00e1ximo de recursos dispon\u00edveis no FPGA. Com \n\nisso, mesmo que os componentes n\u00e3o ocupassem a totalidade da \u00e1rea dispon\u00edvel, n\u00e3o seria \n\nposs\u00edvel se instanciar mais componentes sem uma mudan\u00e7a na arquitetura. Um FPGA com \n\numa maior quantidade de pinos permitiria um maior n\u00famero de componentes instanciados, ao \n\ncusto de mudan\u00e7as na arquitetura final.  \n\n Por fim, na tabela 9, pode-se notar que o total de l\u00f3gica utilizada foi de 100% com o \n\nPE Float para 79% com o PE H\u00edbrido. A Altera descreve essa m\u00e9trica como uma medida para \n\no qu\u00e3o cheio um dispositivo est\u00e1 baseado em componentes utilizados. Assim, observa-se que \n\no FPGA encontrava-se saturado na plataforma 3D, sem nenhuma folga dispon\u00edvel quando da \n\nutiliza\u00e7\u00e3o do PE Float.  \n\nPor outro lado, na vers\u00e3o com o PE H\u00edbrido, o uso de l\u00f3gica caiu consideravelmente, \n\nliberando espa\u00e7o para eventuais ajustes na arquitetura, na adi\u00e7\u00e3o de outros m\u00f3dulos, seus \n\nposicionamentos e roteamento de novas redes. \n\n \n\n  \n\n\n\n119 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n7 \n7. Conclus\u00f5es e Trabalhos Futuros \n\n \n\n \n\nNeste cap\u00edtulo, est\u00e3o expostas as conclus\u00f5es obtidas com o desenvolvimento deste \n\ntrabalho. \n\n \n\n \n\n \n\n \n\n  \n\n\n\n120 \n\n \n\n \n\n Esse trabalho abordou o desenvolvimento de um m\u00f3dulo aritm\u00e9tico, padr\u00e3o IEEE-\n\n754 para dispositivos reconfigur\u00e1veis, FPGAs. O m\u00f3dulo realiza a parte aritm\u00e9tica do \n\nalgoritmo de S\u00edsmica RTM (2010), que faz uso de um operador de diferen\u00e7as finitas para \n\naproxima\u00e7\u00e3o da equa\u00e7\u00e3o de onda utilizada no mapeamento s\u00edsmico do solo (Santos, 2012). \n\n Inicialmente foi feita uma revis\u00e3o sobre diversos temas relevantes ao trabalho. \n\nDentre eles, pode-se citar: Computa\u00e7\u00e3o de alto desempenho, FPGA, padr\u00e3o IEEE-754, \n\nAritm\u00e9tica de Ponto Fixo, o algoritmo de mapeamento s\u00edsmico, RTM, entre outros. \n\nNa se\u00e7\u00e3o seguinte, foram avaliados trabalhos relacionados ao tema dessa disserta\u00e7\u00e3o, \n\nque envolvem n\u00facleos aritm\u00e9ticos em ponto flutuante para FPGAs. Dentre esses trabalhos, \n\nest\u00e3o presentes os de Yong Dou (2005), Abner Barros (2008), Rodrigo Rocha (2010), que s\u00e3o \n\nmais relevantes para essa disserta\u00e7\u00e3o.  \n\nAl\u00e9m desses trabalhos pode-se citar tamb\u00e9m os de Amaricai (2013), Wilson (2014) e \n\nRamesh (2013) que tamb\u00e9m apresentarem contribui\u00e7\u00f5es ainda que em menor grau. \n\nNo cap\u00edtulo 4 foi abordada a plataforma para resolu\u00e7\u00e3o do algoritmo de an\u00e1lises \n\ns\u00edsmicas RTM 3D para uma FPGA Stratix IV. O n\u00facleo aritm\u00e9tico desenvolvido foi \n\nincorporado nessa arquitetura para c\u00e1lculo da etapa de modelagem do RTM. Utilizou-se a \n\netapa de modelagem do RTM por crit\u00e9rios de simplicidade de implementa\u00e7\u00e3o.  \n\nA plataforma de s\u00edsmica utilizada foi a desenvolvida em parceria com a Petrobras \n\n(CENPES) no projeto HPCIn do CIn-UFPE (2014). Essa arquitetura completa foi \n\nimplementada fisicamente em FPGA e fez uso do PE H\u00edbrido e do PE Float, bem como, dos \n\ndemais blocos necess\u00e1rios ao funcionamento de seu algoritmo. Os PE\u00b4s desenvolvidos \n\ncomportaram-se de maneira esperada na plataforma do RTM e atingiram os objetivos \n\nprevistos nos testes. \n\n As duas arquiteturas desenvolvidas para a resolu\u00e7\u00e3o do operador de diferen\u00e7as finitas \n\nforam abordadas no cap\u00edtulo 5. Uma delas operando com os algoritmos aritm\u00e9ticos para \n\nn\u00fameros em ponto flutuante. A outra, com entradas e sa\u00eddas em ponto flutuante e \n\ninternamente com trechos com aritm\u00e9tica de ponto fixo. A primeira arquitetura foi \n\ndenominada de PE Float e a segunda de PE H\u00edbrido.  \n\n O PE Float atingiu os objetivos de precis\u00e3o e frequ\u00eancia esperados. Conseguiu-se, \n\nportanto, realizar o papel de n\u00facleo aritm\u00e9tico do RTM. O PE H\u00edbrido reduziu parte da l\u00f3gica \n\nem FPGA para a implementa\u00e7\u00e3o do n\u00facleo aritm\u00e9tico sem afetar no resultado do c\u00e1lculo do \n\noperador de diferen\u00e7as finitas. Dessa forma, um nova arquitetura capaz de realizar a mesma \n\nopera\u00e7\u00e3o que o PE Float e com precis\u00e3o semelhante foi feita. \n\n\n\n121 \n\n \n\n \n\nO PE H\u00edbrido opera em frequ\u00eancia semelhante ao PE Float, com uma economia de \n\nunidades l\u00f3gicas de 17,49%. Os resultados de s\u00edntese obtidos para o FPGAs Stratix IV foram \n\napresentados no cap\u00edtulo 6. \n\n Na plataforma do RTM 3D, observou-se uma redu\u00e7\u00e3o de 56,15% para 46,79% do \n\nn\u00famero total de ALUT\u00b4s, utilizadas em uma FPGA Stratix IV, pela plataforma de s\u00edsmica da \n\nvers\u00e3o PE Float para a vers\u00e3o PE H\u00edbrido. Portanto, o PE H\u00edbrido liberou espa\u00e7o presente em \n\nFPGA para o uso de mais componentes de processamento.  \n\nApesar dessa economia de l\u00f3gica na FPGA com o PE H\u00edbrido, n\u00e3o foi poss\u00edvel se \n\ninstanciar mais PE\u00b4s al\u00e9m dos 16 presentes na plataforma de RTM 3D. Isso ocorre visto que o \n\nn\u00famero de pinos dispon\u00edveis e utilizados na Stratix IV \u00e9 limitado.  \n\nUm fator de destaque do PE H\u00edbrido, \u00e9 que mesmo com o ganho de \u00e1rea obtido, n\u00e3o \n\nhouve impacto na frequ\u00eancia de opera\u00e7\u00e3o da plataforma de s\u00edsmica, que se manteve em cerca \n\nde 150 MHz.  \n\nDiante disso, o presente trabalho atingiu os objetivos inicialmente previstos. Tanto \n\nem termos de confiabilidade de resultados, quanto em termos de efici\u00eancia. A vers\u00e3o final do \n\nPE H\u00edbrido atendeu os requisitos de uso e se tornou funcional na plataforma de S\u00edsmica do \n\nprojeto HPCIn. \n\nComo poss\u00edveis trabalhos futuros, pode-se citar o estudo do impacto da redu\u00e7\u00e3o de \n\nbits da representa\u00e7\u00e3o em ponto flutuante, com o objetivo de ganho de \u00e1rea em FPGA. Seria \n\nnecess\u00e1rio verificar at\u00e9 onde a redu\u00e7\u00e3o do n\u00famero de bits afetaria a precis\u00e3o final do \n\nresultado. Al\u00e9m disso, verificar tamb\u00e9m, se este resultado final estaria dentro dos limites de \n\nprecis\u00e3o e opera\u00e7\u00e3o esperados para a plataforma s\u00edsmica 3D, para o algoritmo RTM. \n\n  \n\n\n\n122 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n8 \n8. Refer\u00eancias. \n\n \n\n \n\nNeste cap\u00edtulo, est\u00e3o expostas as refer\u00eancias relevantes para a elabora\u00e7\u00e3o desta \n\ndisserta\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n  \n\n\n\n123 \n\n \n\n \n\nALTERA. ALM. Acesso em: 29 jul. 2015. Dispon\u00edvel em:&lt;https://www.altera.com/ \n\nproducts/fpga/features/stx-architecture.html>. \n\n \n\nALTERA. DSP. Acesso em: 29 jul. 2015. Dispon\u00edvel em:&lt;https://www.altera.com/ \n\nproducts/fpga/features/stx-dsp-block.html>. \n\n \n\nALTERA. LUT. Acesso em: 29 jul. 2015. Dispon\u00edvel em: &lt;https://www.altera.com/ \n\nproducts/general/fpga/stratix-fpgas/stratix-ii/stratix-ii/features/architecture/st2-lut.html>. \n\n \n\nALTERA. Overview Stratix III. Acesso em: 29 jul. 2015. Dispon\u00edvel em:&lt;https://www. \n\naltera.com/content/dam/altera_www/global/en_US/pdfs/literature/hb/stx3/stx3_siii51001.pdf>\n\n.  \n\nALTERA. Overview StratixIV. Acesso em: 16 jul. 2015. Dispon\u00edvel em: &lt;https://www. \n\naltera.com/products/fpga/stratix-series/stratix-iv/overview.html>. \n\n \n\nALTERA. QuartusII. Acesso em: 16 jul. 2015. Dispon\u00edvel em: &lt;http://www.altera. com/ \n\nliterature/manual/intro_to_quartus2.pdf> . \n\n \n\nALTERA. Stratix III Handbook.  Acesso em: 29 jul. 2015. Dispon\u00edvel em: &lt;http://www. \n\naltera.com/literature/hb/stx3/stx3_siii5v1.pdf>.  \n\n \n\nALTERA. TimeQuest Timing Analyser. Acesso em: 16 jul. 2015. Dispon\u00edvel em:&lt;https:// \n\nwww.altera.com/support/support-resources/design-examples/design-software/timequest/sof-\n\nqts-timequest.html>. \n\n \n\nAMARICAI, A. et al.. FPGA Implementation of Hybrid Fixed Point Floating Point \n\nMultiplication. Mixed Design of Integrated Circuits and Systems (MIXDES), 2013 \n\nProceedings of the 20th International Conference, 2013, pp. 243-246. \n\n \n\nBARROS, A. C., Barbosa J. e Lima M. E. Implementation of a double-precision multiplier  \n\naccumulator  with  exception  treatment to  a dense  matrix multiplier module in FPGA, \n\n21nd Symposium on Integrated Circuits and Systems Design (SBCCI), pp. 40-45, Gramado, \n\nRio Grande do Sul,2008. \n\n \n\nBARROS, A. B. Uma Metodologia Para a Determina\u00e7\u00e3o Da Precis\u00e3o Num\u00e9rica \n\nNecess\u00e1ria \u00e0 Implementa\u00e7\u00e3o do Algoritmo RTM. 2014. Tese de Doutorado \u2014 CIn UFPE. \n\nPernambuco: Centro de Inform\u00e1tica da Universidade Federal de Pernambuco. \n\n \n\nBARROS, A. C. et al. Performance evaluation model based on precision reduction and \n\nFPGAs applied to seismic modeling. In: SIMP\u00d3SIO EM SISTEMAS COMPUTACIONAIS \n\n(WSCAD-SSC)\u201e Petr\u00f3polis, RJ. New York. Proceedings. . . IEEE, 2011. p. 2\u20132. \n\n \n\nBRAGAN\u00c7A, R. et al. Seismic Modeling and RTM Migration on unconventional \n\nHardware. In: INTERNATIONAL CONGRESS OF BRAZILIAN GEOPHYSICAL \n\nSOCIETY &amp; EXPOGEF, 13. Rio de Janeiro, 2013. \n\n \n\nBRITANNICA ENCYCLOPAEDIA. ENIAC. Acesso em: 7 jul. 2015, Dispon\u00edvel em: \n\n<http://global.britannica.com/technology/ENIAC>. \n\n \n\nhttps://www.altera.com/products/fpga/stratix-series/stratix-iv/overview.html\nhttps://www.altera.com/products/fpga/stratix-series/stratix-iv/overview.html\nhttp://www.altera.com/literature/manual/intro_to_quartus2.pdf\nhttp://www.altera.com/literature/manual/intro_to_quartus2.pdf\nhttps://www.altera.com/support/support-resources/design-examples/design-software/timequest/sof-qts-timequest.html\nhttps://www.altera.com/support/support-resources/design-examples/design-software/timequest/sof-qts-timequest.html\nhttps://www.altera.com/support/support-resources/design-examples/design-software/timequest/sof-qts-timequest.html\n\n\n124 \n\n \n\n \n\nBROCK, David C. Understanding Moore\u00b4s Law. 1.ed. Chemical Heritage Foundation, \n\n2006. p.82. \n\n \n\nCOE, T. Inside the Pentium Fdiv bug. Dr. Dobbs Journal (April 1996), pp. 129\u2013135. \n\n \n\nCLCBIO. Acesso em: 29 jun. 2015. Dispon\u00edvel em:&lt;http://www.clcbio.com/index.php>. \n\n \n\nDOU, Yong. et al. 64-bit floating-point FPGA matrix multiplication. 2005. \n\n \n\nDURBANO, J. P. et al. FPGA-Based Acceleration of the 3D Finite-Difference Time-\n\nDomain Method. IEEE Symposium on Field-Programmable Custom Computing Machines, \n\n2004. \n\n \n\nDUTRA Bruno. H. Desenvolvimento de Uma Plataforma com uma Arquitetura Escal\u00e1vel \n\npara Multiplica\u00e7\u00e3o de Matrizes Densas em Sistemas Reconfigur\u00e1veis Matrizes Densas \n\nem Sistemas Reconfigur\u00e1veis de Alto Desempenho. 2010. Disserta\u00e7\u00e3o de Mestrado \u2014 CIn \n\nUFPE. Pernambuco: Centro de Inform\u00e1tica da Universidade Federal de Pernambuco. \n\n \n\nFERNANDES, J. P. B. Implementa\u00e7\u00e3o do operador de diferen\u00e7as finitas em sistemas de \n\nComputa\u00e7\u00e3o Reconfigur\u00e1vel para modelagem s\u00edsmica. 2010. Trabalho de Gradua\u00e7\u00e3o \u2014 \n\nCIn UFPE. Pernambuco: Centro de Inform\u00e1tica da Universidade Federal de Pernambuco. \n\n \n\nFU, H. Application-Specific Number Representation. 2009. Tese de Doutorado \u2014 Imperial \n\nCollege London Department of Computing Application-Specific. \n\n \n\nFU, H. et al. Accelerating seismic computations using customized number \n\nrepresentations on FPGAs. EURASIP Journal on Embedded Systems, [S.l.], v. 2009, n. 3, p. \n\n382983, Jan. 2009. \n\n \n\nGIDEL. Plataforma PROCe III.. Acesso em: 16 jul. 2015. Dispon\u00edvel em:&lt;http://www. \n\ngidel.com/PROCe%20III.htm> \n\n \n\nGIDEL. Plataforma PROCe IV. Acesso em: 16 jul. 2015. Dispon\u00edvel em:&lt;http://www. \n\ngidel.com/pdf/PROCStarIV%20Product%20Brief.pdf> \n\n \n\nGIDEL. ProcWizard. Acesso em: 16 jul. 2015. Dispon\u00edvel em:&lt;http://www.altera.com/ \n\nliterature/manual/intro_to_quartus2.pdf>. \n\n \n\nGONZALEZ, Rafael; WOODS, Richard. Digital Image Processing. 2. ed. Prentice Hall, \n\n2002. \n\n \n\nGUO, Z. et al. A Quantitative Analysis of the Speedup Factors of FPGAs over \n\nProcessors. In: ACM/SIGDA 12TH INTERNATIONAL SYMPOSIUM ON FIELD \n\nPROGRAMMABLE GATE ARRAYS, 2004., New York, NY, USA. Proceedings... ACM, \n\n2004. p. 162\u201370. (FPGA \u201904). \n\n \n\nHENNESSY, John L.; PATTERSON, David A. Computer architecture: A quantitative \n\napproach. 4 ed. Boston: Morgan Kaufmann, 2007. \n\n \n\nhttp://www.clcbio.com/index.php\nhttp://www.gidel.com/PROCe%20III.htm\nhttp://www.gidel.com/PROCe%20III.htm\nhttp://www.altera.com/literature/manual/intro_to_quartus2.pdf\nhttp://www.altera.com/literature/manual/intro_to_quartus2.pdf\n\n\n125 \n\n \n\n \n\nHPCIN. HPCIn. Acesso em: 15 jul. 2015. Dispon\u00edvel em:&lt;http://www.cin.ufpe.br/~ \n\nhpcin/hpcin.php>. \n\n \n\nINTEL. PENTIUM 4. Acesso em: 7 jul. 2015. Dispon\u00edvel em:&lt;http://www.intel.com. \n\nbr/content/www/br/pt/intelligent-systems/previous-generation/embedded-pentium-iv.html>. \n\n \n\nINSTITUTE, A. N. S. (Ed.). ANSI/IEEE 754-1985, Standard for Binary Floating-Point \n\nArithmetic. [S.l.]: pub-IEEE-STD, 1985.  \n\n \n\nOPENCL. KHRONOS.  Acesso em 08 de nov. 2015. Dispon\u00edvel em: &lt;https://www. \n\nkhronos.org/opencl/> \n\n \n\nMARMOUSI. Proposto pelo IFP (Institut Fran\u00e7ais du P\u00e9trole) em 1988. Citado em IRONS, \n\nT. 2008. Marmousi Model. Dispon\u00edvel em:&lt;http://www.reproducibility.org/ RSF/ book/ \n\ndata/marmousi/paper_html/>. \n\n \n\nMEDEIROS, V. W. C. de. fastRTM: Um Ambiente Integrado para Desenvolvimento \n\nR\u00e1pido da Migra\u00e7\u00e3o Reversa no Tempo (RTM) em Plataformas FPGA de Alto \n\nDesempenho. 2013. Tese de Doutorado \u2014 CIn UFPE. Pernambuco: Centro de Inform\u00e1tica \n\nda Universidade Federal de Pernambuco. \n\n \n\nMEDEIROS, V. et al. High Performance Implementation of RTM Seismic Modeling on \n\nFPGAs: architecture, arithmetic and power issues. In: VANDERBAUWHEDE, W.; \n\nBENKRID, K. (Ed.). High-Performance Computing Using FPGAs. New York: Springer, \n\n2013. p. 305\u201334. \n\n \n\nMENEZES, G. et al. Energy Estimation Tool FPGA-based Approach for Petroleum \n\nIndustry. In:INTERNATIONAL CONFERENCE ON PARALLEL PROCESSING \n\nWORKSHOPS (ICPPW),2012, 41., Pittsburgh, PA. New York. Proceedings... [S.l.: s.n.], \n\n2012. p. 600\u20131. \n\n \n\nMOORE, G.E. The microprocessor: Engine of the technology Revolution. In: \n\nCommunications of the ACM, 1997.  \n\n \n\nNASA. Curiosity. Acesso em: 31 ago. 2015. Dispon\u00edvel em:&lt;https://www.nasa. gov/ \n\nmission_pages/msl/overview/index.html>.  \n\n \n\nNAVABI, Zainalabedin. Embedded Core Design with FPGAs. 1. ed. Boston, 2007. \n\n \n\nNVIDIA. GPU. Acesso em: 15 jul. 2015.  Dispon\u00edvel em: &lt;http://www.nvidia.com/ object/ \n\nwhat-is-gpu-computing.html>. \n\n \n\nPALMER, John. The Intel 8087 Numeric Processor, ACM. 1980. \n\n \n\nPETROBRAS. TECNOLOGIAS. Acesso em: 31 ago. 2015. Dispon\u00edvel em:&lt;http://presal. \n\nhotsitespetrobras.com.br/tecnologias-pioneiras/#3>.  \n\n \n\nPETROBRAS. PR\u00c9-SAL. Acesso em: 31 ago. 2015. Dispon\u00edvel em:&lt;http://www.petrobras. \n\ncom.br/pt/energia-e-tecnologia/fontes-de-energia/petroleo/presal/>.  \n\nhttp://www.cin.ufpe.br/~hpcin/hpcin.php\nhttp://www.cin.ufpe.br/~hpcin/hpcin.php\nhttps://www.khronos.org/opencl/\nhttps://www.khronos.org/opencl/\nhttps://www.nasa.gov/mission_pages/msl/overview/index.html\nhttps://www.nasa.gov/mission_pages/msl/overview/index.html\n\n\n126 \n\n \n\n \n\nPGS. Reverse Time Migration. In: Tech Link, A Publication of Petroleum Geo-Service Vol. \n\n7, No. 1, 2007. \n\n \n\nROCHA, Rodrigo Camarotti Ferreira. Desenvolvimento de uma Plataforma \n\nReconfigur\u00e1vel para modelagem 2D, em S\u00edsmica, Utilizando FPGA. Disserta\u00e7\u00e3o de \n\nMestrado. Universidade Federal de Pernambuco, Recife-PE, 2010. \n\n \n\nSANTOS, J. L. R. dos. Modelagem da equa\u00e7\u00e3o da onda ac\u00fastica aplicada ao \n\nimageamento de estruturas geol\u00f3gicas. 2012. Disserta\u00e7\u00e3o de Mestrado - Coppe UFRJ. Rio \n\nde Janeiro: Instituto Alberto Luiz Coimbra de P\u00f3s-Gradua\u00e7\u00e3o e Pesquisa de Engenharia. \n\n \n\nSMITH, M. J. S. Application-Specific Integrated Circuits, Addison-Wesley, 1997. \n\nTOP 500.Org.. TOP500. Acesso em: 27de Ago. 2015. Dispon\u00edvel em:&lt;http://www. \n\ntop500.org>.  \n\n \n\nWANG, Z.; BOVIK, A. C. A universal image quality index. IEEE Signal Processing \n\nLetters, [S.l.], v. 9, n. 3, p. 81\u20134, Mar. 2002. \n\n \n\nWILSON. Jose, A.R. Silva, H.C. Neto, M.P. V\u00e9stias. Efficient implementation of a single-\n\nprecision floating-point arithmetic unit on FPGA. IEEE, in Proc. FPL, 2014, pp.1-4. \n\n \n\nXILINX. FPGA. Acesso em: 3 set. 2015. Dispon\u00edvel em: &lt;http://www.xilinx.com/fpga/>. \n\n \n\nXILINX. Mars Exploration Rovers. Acesso em: 31 ago. 2015. Dispon\u00edvel em:&lt;http://www. \n\nxilinx.com/about/customer-innovation/aerospace-and-defense/mars-exploration-rovers.html>. \n\n \n\nXILINX. Virtex-6 Overview. Acesso em: 31 ago. 2015. Dispon\u00edvel em:&lt;http://www.xilinx. \n\ncom/support/documentation/data_sheets/ds150.pdf>. \n\n \n\n \n\n  \n\nhttp://www.xilinx.com/support/documentation/data_sheets/ds150.pdf\nhttp://www.xilinx.com/support/documentation/data_sheets/ds150.pdf\n\n\n127 \n\n \n\n \n\n \n\nCap\u00edtulo \n\n9 \n9. Anexos. \n\n \n\n \n\nNeste cap\u00edtulo, est\u00e3o expostos os anexos relevantes para a elabora\u00e7\u00e3o desta \n\ndisserta\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n  \n\n\n\n128 \n\n \n\n \n\n9.1    ANEXO I - Arquitetura do PE H\u00edbrido \n\nFigura 51 - Vis\u00e3o geral da arquitetura do PE H\u00edbrido. \n\nP\nE\n\n_3\nD\n\n_H\nib\n\nrid\no\n\nFIFO\n2\n\n9\n\nA\n_\n\ni_\nj_\n\nk\n\nN\no\n\nrm\n_\n\nA\nrrd\n\nFIFO\n1\n\n0\n\nV\ne\n\nl\n\nFIFO\n8\n\nFa\nt\n\n(4\n ciclo\n\ns) Q\nu\n\nad\nra\n\nd\no\n\n(2\n ciclo\n\ns)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n1\n\nA\nrre\n\nd\no\n\nn\nd\n\na\nd\n\no\nr\n\n(2\n ciclo\n\ns)\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nB\nlo\n\nco\nV\n\ne\nlF\n\nat\n(2\n\n6\n ciclo\n\ns)\n\n(3 ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nB\nLO\n\nC\nO\n\n1\n(3\n\n8\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)M\n\nu\nltip\n\nlica\nd\n\no\nr\n\n(3\n ciclo\n\ns)\n\nA\nb\n\ns_\ni\n\nB\n_\n\ni_\nj_\n\nk\nA\n\nb\ns_\n\nj\nA\n\nb\ns_\n\nk\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nFIFO\n8\n\nFIFO\n1\n\n7\n\nQ\nu\n\nad\nra\n\nd\no\n\n(2\n ciclo\n\ns)\n\nA\nrre\n\nd\no\n\nn\nd\n\na\nd\n\no\nr\n\n(2\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\n_\n2\n\nFIFO\n1\n\n5\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n2\n\nFIFO\n2\n\n1\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\n(1\n ciclo\n\n)\n\n(1\n6\n\n ciclo\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns) B\nlo\n\nco\nQ\n\nu\na\n\nd\nrad\n\no\nA\n\nb\ns\n\n(2\n2\n\n ciclo\ns)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\nA\n\nb\ns\n\n(1\n6\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)M\n\nu\nltip\n\nlica\nd\n\no\nr\n\n    (3\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n2\n\nA\nb\n\ns\n(2\n\n6\n ciclo\n\ns)\n\nB\nLO\n\nC\nO\n\n3\n(5\n\n0\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\n_\n9\n\n0\n\n(3\n ciclo\n\ns)\n\nB\n_\n\nijk\n\nM\nS\n\no\nm\n\na\n1\n\n_\n1\n\n6\n_\n\n9\n0\n\n(2\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFix\no\n\n_\nFlo\n\na\nt\n\nFIFO\n1\n\n2\n\n(5\n ciclo\n\ns)\n\nB\nLO\n\nC\nO\n\n 2\n(2\n\n6\n ciclo\n\ns)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nM\n1\n\nS\no\n\nm\na\n\n(3\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nM\n1\n\n6\nS\n\no\nm\n\na\n(3\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr \n\nFlo\na\n\nt_\nFix\n\no\n(4\n\n ciclo\ns)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n\nB\nlo\n\nco\nSo\n\nm\na\n\nd\no\n\nrN\no\n\nrm\naliza\n\nd\no\n\nr\n\n \n\n \n\n \n\n\n\n129 \n\n \n\n \n\n9.2    ANEXO II - Arquitetura do PE Float \n\nFigura 52 - Vis\u00e3o geral da arquitetura do PE Float \n\nFIFO\n2\n\n9\n\nA\n_\n\ni_\nj_\n\nk\n\nN\no\n\nrm\n_\n\nA\nrrd\n\nFIFO\n1\n\n0\n\nV\ne\n\nl\n\nFIFO\n8\n\nFa\nt\n\n(4\n ciclo\n\ns) Q\nu\n\nad\nra\n\nd\no\n\n(2\n ciclo\n\ns)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n1\n\nA\nrre\n\nd\no\n\nn\nd\n\na\nd\n\no\nr\n\n(2\n ciclo\n\ns)\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nB\nlo\n\nco\nV\n\ne\nlF\n\nat\n(2\n\n6\n ciclo\n\ns)\n\n(3 ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nB\nLO\n\nC\nO\n\n1\n(3\n\n8\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nP\nE\n\n_3\nD\n\n_F\nlo\n\na\nt\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n9\n\n0\n\nFIFO\n1\n\n6\n\nM\nu\n\nltip\nlica\n\n_\n9\n\n0\n(2\n\n ciclo\ns)\n\nB\nlo\n\nco\nSo\n\nm\na\n\nd\no\n\nrB\nijk2\n\nB\n_\n\nijk\n\nM\nu\n\nltip\nlica\n\n_\n1\n\n6\n(1\n\n ciclo\n)\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nB\nlo\n\nco\nSo\n\nm\na\n\nd\no\n\nrN\no\n\nrm\naliza\n\nd\no\n\nr\n\nM\nu\n\nltip\nlica\n\n_\n1\n\n6\n(1\n\n ciclo\n)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nB\nlo\n\nco\nSo\n\nm\na\n\nd\no\n\nrB\nijk\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)S\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)So\nm\n\na\nd\n\no\nr_\n\nS\nim\n\np\nle\n\ns\n(4\n\n ciclo\ns)\n\nFIFO\n4\n\n(4\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nB\n_\n\nijk\n_\n\n1\nB\n\n_\nijk\n\n_\n1\n\nB\n_\n\nijk\n_\n\n1\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nB\nlo\n\nco\nSo\n\nm\na\n\nd\no\n\nrB\nijk\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)S\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)So\nm\n\na\nd\n\no\nr_\n\nS\nim\n\np\nle\n\ns\n(4\n\n ciclo\ns)\n\nFIFO\n4\n\n(4\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nB\n_\n\nijk\n_\n\n1\n6\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nB\n_\n\nijk\n_\n\n1\n6\n\nB\n_\n\nijk\n_\n\n1\n6\n\nB\n_\n\nijk\n_\n\n1\n6\n\nB\n_\n\nijk\n_\n\n1\n6\n\nB\n_\n\nijk\n_\n\n1\n6\n\nB\n_\n\nijk\n_\n\n1\n\nB\nLO\n\nC\nO\n\n 2\n(2\n\n6\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)M\n\nu\nltip\n\nlica\nd\n\no\nr\n\n(3\n ciclo\n\ns)\n\nA\nb\n\ns_\ni\n\nB\n_\n\ni_\nj_\n\nk\nA\n\nb\ns_\n\nj\nA\n\nb\ns_\n\nk\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nFIFO\n8\n\nFIFO\n1\n\n7\n\nQ\nu\n\nad\nra\n\nd\no\n\n(2\n ciclo\n\ns)\n\nA\nrre\n\nd\no\n\nn\nd\n\na\nd\n\no\nr\n\n(2\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\n_\n2\n\nFIFO\n1\n\n5\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n2\n\nFIFO\n2\n\n1\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\n(1\n ciclo\n\n)\n\n(1\n6\n\n ciclo\ns)\n\nS\no\n\nm\na\n\nd\no\n\nr_\nS\n\nim\np\n\nle\ns\n\n(4\n ciclo\n\ns)\n\nN\no\n\nrm\n_\n\nA\nrrd\n\n(4\n ciclo\n\ns) B\nlo\n\nco\nQ\n\nu\na\n\nd\nrad\n\no\nA\n\nb\ns\n\n(2\n2\n\n ciclo\ns)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\nA\n\nb\ns\n\n(1\n6\n\n ciclo\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)M\n\nu\nltip\n\nlica\nd\n\no\nr\n\n    (3\n ciclo\n\ns)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\n\nC\no\n\nn\nve\n\nrso\nr\n\n(1\n ciclo\n\n)\nC\n\no\nn\n\nve\nrso\n\nr\n(1\n\n ciclo\n)\n\nM\nu\n\nltip\nlica\n\nd\no\n\nr\n(3\n\n ciclo\ns)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n2\n\nA\nb\n\ns\n(2\n\n6\n ciclo\n\ns)\n\nB\nLO\n\nC\nO\n\n3\n(5\n\n0\n ciclo\n\ns)\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n\nB\nlo\n\nco\nM\n\nu\nltip\n\nlica\n\nB\nlo\n\nco\nSo\n\nm\na\n\nd\no\n\nrN\no\n\nrm\naliza\n\nd\no\n\nr\n\n \n\n \n\n\n\n130 \n\n \n\n \n\n9.3    ANEXO III - Arquitetura do RTM \nFigura 53 - Vis\u00e3o geral da arquitetura da Plataforma 3D para RTM em FPGA."}]}}}