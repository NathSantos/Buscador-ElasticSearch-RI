{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.12821"}, {"@name": "filename", "#text": "18554_PFC-20121-MarcosCesarBragagnolo.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Event-triggered control: application to\nmobile robots\n\nMonografia submetida a? Universidade Federal de Santa Catarina\n\ncomo requisito para a aprovac?a?o da disciplina:\n\nDAS 5511: Projeto de Fim de Curso\n\nMarcos Cesar Bragagnolo\n\nFloriano?polis, Julho 2012\n\n\n\nEvent-triggered control: application to mobile robots\n\nMarcos Cesar Bragagnolo\n\nEsta monografia foi julgada no contexto da disciplina\nDAS 5511: Projeto de Fim de Curso\n\ne aprovada na sua forma final pelo\nCurso de Engenharia de Controle e Automac?a?o Industrial\n\nBanca Examinadora:\n\nDr Romain Postoyan\nOrientador do Laborato?rio\n\nProfessor Eugenio de Bona Castelan Neto, Dr.\nOrientador do curso\n\n\n\nAcknowledge\n\nI would like to thank my family for being so supportive during these months while\n\nI was doing this project. To stay for such a long time away from the people we love is\n\nnot an easy task. Thank you all for the support.\n\nI would also like to thank both my supervisors, Prof. Eugenio de Bona Castelan\n\nand Dr. Romain Postoyan. Without their help, I would still be there trying to figure out\n\nwhat to do next. It was pleasure working with you.\n\nI would also like to thank my girlfriend, Thaise Damo. Your support during the\n\nlast weeks was amazing, and helped me keep going. I\u2019m looking forward to see what\n\nthe future has to offer. I love you.\n\nAt last, but not least, I would like to thank all my friends. The new ones I\u2019ve made\n\nduring my internship, the ones that showed up at my presentation, and even the ones\n\nthat couldn\u2019t make it. You all very important to me.\n\nThis project is dedicated to all of you.\n\n\n\nAbstract\n\nThis document presents the implementation of the event-triggered control ap-\nproach to a mobile robot with a nonholonomic system. Event-triggered control is a\ntopic with great interest in the research community. Even so, there are few articles\nconcerning event-triggered control applied to trajectory tracking of nonlinear systems.\nIn this document we show this implementation, called event-triggered tracking control.\n\nAt first, we introduce the concept of a mobile robot with a nonholonomic sys-\ntem, explaining what a nonholonomic system is and providing the system model used\nduring the project. We then define the reference system and present three different tra-\njectories used during the simulations and the experiments at SAMI Benchmark. Later,\nwe provide a bibliography study on nonholonomic systems and present Jiang and Nij-\nmeijer\u2019s controller, the nonlinear controller used in this project. We provide simulations\nresults that shows the asymptotical convergence to the origin.\n\nThe main focus of this document is given to the event-triggered control. We start\nby showing a quick presentation of the event-triggered approach. Instead of using a\ncontinuous system, we define a hybrid system where the dynamics of the robot remain\ncontinuous but the control inputs are sampled. This occurs because the controller is\ndigitally implemented and communicate with the robot via a wireless network. With\nthe hybrid system, we proceed to the design of the triggering condition using Jiang\nand Nijmeijer\u2019s Lyapunov function. Then, we show the proof that system does not\nasymptotically converge to the origin, but to a neighbourhood of the origin whose size\ndepends of the parameter ?. We show the simulation results for the event-triggered\napproach validating our proof.\n\nWe finish this document providing experimental results to the control proposed.\nFirst, a time-triggered approach is implemented to serve as reference to the event-\ntriggered approach. Later, we show the event-triggered results as well as comparison\nbetween different values of ?, showing that the event-triggered approach has a good\ntracking capability with much less transmissions.\n\n\n\nResumo Estendido\n\nA utilizac?a?o de sistemas de controle torna-se cada dia mais indispensa?vel. Seja\n\nem uma planta qu??mica, uma plataforma de prospecc?a?o de petro?leo ou em um sistema\n\nembarcado, controladores sa?o usados para garantir uma operac?a?o esta?vel e aprimorar\n\na performance, em comparac?a?o a? sistemas malha aberta.\n\nAtualmente, a grande maioria dos controladores no mercado sa?o implementa-\n\ndos digitalmente. Esses controladores geralmente usam um modelo perio?dico, onde\n\ntanto as medic?o?es quanto o sinal de controle sa?o atualizados a cada T segundos.\n\nEssa abordagem tornou-se dominante pois possui ana?lises e teoria extensivas, garan-\n\ntindo assim robustez e performance. Ha?, no entanto, uma alternativa a esse me?todo\n\nchamada Event-Triggered Control (ETC).\n\nEvent-triggered control e? uma abordagem diferente do tradicional time-triggered\n\ncontrol pois os instantes em que o controle e? atualizado na?o sa?o mais ditados por um\n\nper??odo, mas sim por um evento. Esse evento pode ser sinalizado de diversas manei-\n\nras, como por exemplo: a diferenc?a entre a varia?vel atual e o valor desejado, chegada\n\nde uma informac?a?o no sensor ou perturbac?o?es no sistema. Em geral, a grande maio-\n\nria dos artigos que se utilizam do ETC abordam sistemas lineares, e utilizam o event-\n\ntriggered control como um regulador de setpoint ou para seguimento de refere?ncia.\n\nO escopo desse projeto, no entanto, e? o uso do event-triggered para seguimento de\n\nrefere?ncia de robo?s na?o holono?micos.\n\nNo in??cio desse projeto foi realizada uma pesquisa bibliogra?fica, inicialmente\n\nsobre o controle de robo?s mo?veis na?o holono?micos. O objetivo dessa pesquisa ini-\n\ncial serviu para encontrar na literatura um controlador que pudesse ser adaptado a?\n\nabordagem do ETC. Foi adotado enta?o o controlador projetado por Jiang e Nijmeijer,\n\nonde utilizamos uma mudanc?a nas varia?veis do sistema para transformar o problema\n\nde seguimento da trajeto?ria em um problema de estabilizac?a?o dos estados do sistema.\n\nEsse controlador foi escolhido por garantir globalmente a converge?ncia dos estados do\n\nrobo? para a refere?ncia e por ter uma func?a?o de Lyapunov expl??cita, a qual ajudaria na\n\nimplementac?a?o do event-triggered. O controlador foi testado em simulac?a?o, provando\n\n\n\na converge?ncia global dos estados do robo? para a refere?ncia.\n\nCom o controlador escolhido, a atenc?a?o se voltou para o projeto de uma trig-\n\ngering condition. Novamente, uma pesquisa bibliogra?fica foi realizada para auxiliar no\n\nprojeto de uma triggering condition. Para tanto, realizar uma mudanc?a no nosso sis-\n\ntema, considerando-lo um sistema h??brido. O nosso sistema se torna h??brido devido\n\na amostragem dos estados do robo?. Escolheu-se enta?o usar duas condic?o?es para\n\ndecidir o evento. A primeira utiliza-se da func?a?o V? , comparando-a com uma func?a?o ?.\n\nA segunda condic?a?o compara uma func?a?o ? com uma constante ? definida durante o\n\nprojeto. Embora essa condic?a?o na?o assegura converge?ncia assintotica para a origem,\n\npodemos garantir a converge?ncia para uma regia?o pro?xima a origem.\n\nAo te?rmino do projeto, foi a realizada a implementac?a?o das te?cnicas de controle\n\nestudadas. O controlador projetado por Jiang e Nijmeijer foi implementado e testado\n\nno SAMI Benchmark, e posteriormente a abordagem proposta pelo event-triggered\n\ncontrol foi implementada. Percebeu-se enta?o, uma relac?a?o entre o nu?mero de trans-\n\nmisso?es e o valor da constante ?, onde o aumento do valor ? provoca uma diminuic?a?o\n\nna transmissa?o com o trade off de um erro maior no seguimento da refere?ncia.\n\n\n\nContents\n\nList of Figures 9\n\nList of Tables 11\n\n1 Introduction 12\n\n1.1 Motivation and objectives . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n1.1.1 Trajectory tracking . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n1.1.2 Event-triggered control . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n1.2 Methodology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n1.3 Control and Automation Engineering Course Context . . . . . . . . . . . 14\n\n1.4 Laboratory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n1.5 Document Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n2 Tracking control of mobile robots 17\n\n2.1 System Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n2.1.1 Robot Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n2.1.2 The desired trajectory . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n2.1.2.1 The reference system . . . . . . . . . . . . . . . . . . . 18\n\n2.1.2.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n2.2 Bibliographic Study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n2.2.1 Stabilization of an equilibrium point . . . . . . . . . . . . . . . . . 22\n\n2.2.2 Stabilization of time-varying trajectory . . . . . . . . . . . . . . . 22\n\n2.3 Jiang and Nijmeijer\u2019s controllers [1] . . . . . . . . . . . . . . . . . . . . . 22\n\n\n\n2.3.1 Error system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n\n2.3.2 Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\n2.4 Simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n2.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\n3 Event-triggered tracking control 28\n\n3.1 Presentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\n3.2 Design of the triggering condition . . . . . . . . . . . . . . . . . . . . . . 29\n\n3.2.1 Hybrid model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n3.2.2 The triggering condition . . . . . . . . . . . . . . . . . . . . . . . 30\n\n3.3 Simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n\n3.4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n\n4 Implementation and experimental results 37\n\n4.1 The SAMI benchmark . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n\n4.1.1 Robot: Khepera III . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n\n4.1.2 Controller-robot communication . . . . . . . . . . . . . . . . . . . 38\n\n4.1.2.1 Orientation and Position measurement . . . . . . . . . 38\n\n4.1.2.2 Control input . . . . . . . . . . . . . . . . . . . . . . . . 39\n\n4.1.3 Motion Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n\n4.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n\n4.3 Time-triggered controller . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n\n4.4 Event-triggered controller . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n4.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n5 Conclusions and perspectives 48\n\nReferences 49\n\n\n\nAppendix A -- Lemmas 51\n\nA.1 Barbalat\u2019s lemma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n\nA.2 Lemma 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n\nAppendix B -- Definitions 52\n\nB.1 L1 definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n\nAppendix C -- Equations 53\n\nC.1 Equations of vr and wr for the lemniscate trajectory . . . . . . . . . . . . 53\n\n\n\nList of Figures\n\n1.1 Cran Logo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n2.1 A nonholonomic mechanical system . . . . . . . . . . . . . . . . . . . . 18\n\n2.2 A diagram showing the circular trajectory . . . . . . . . . . . . . . . . . 19\n\n2.3 A diagram showing the ellipsoidal trajectory . . . . . . . . . . . . . . . . 20\n\n2.4 A diagram showing the lemniscate trajectory . . . . . . . . . . . . . . . 21\n\n2.5 Trajectory and control for the circular trajectory . . . . . . . . . . . . . . 26\n\n2.6 Trajectory and control for the ellipsoidal trajectory . . . . . . . . . . . . . 26\n\n2.7 Trajectory and control for the lemniscate trajectory . . . . . . . . . . . . 26\n\n3.1 Trajectory for the circular and the ellipsoidal trajectory using ETC . . . . 34\n\n3.2 Control inputs for the circular and the ellipsoidal trajectory using ETC . . 34\n\n3.3 Triggering condition for the circular and the ellipsoidal trajectory using ETC 35\n\n3.4 Trajectory and control for the lemniscate trajectory using ETC . . . . . . 35\n\n3.5 Triggering condition for the lemniscate trajectory . . . . . . . . . . . . . 35\n\n4.1 Khepera III . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\n4.2 Communication setup for the Khepera III . . . . . . . . . . . . . . . . . . 39\n\n4.3 Diagram showing the time sequence of the controller . . . . . . . . . . . 40\n\n4.4 Plot of the robot states (xe, ye, ?) of the lemniscate trajectory . . . . . . 42\n\n4.5 Trajectory and control inputs for the circular trajectory using time-triggered\n\ncontrol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n4.6 Trajectory and control inputs for the ellipsoidal trajectory using time-\n\ntriggered control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n\n\n4.7 Trajectory and control inputs for the lemniscate trajectory using time-\n\ntriggered control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n4.8 Trajectory for the circular and the ellipsoidal trajectory using ETC . . . . 45\n\n4.9 Control inputs for the circular and the ellipsoidal trajectory using ETC . . 45\n\n4.10 Triggering condition for the circular and the ellipsoidal trajectory using ETC 46\n\n4.11 Trajectory and control for the lemniscate trajectory using ETC . . . . . . 46\n\n4.12 Triggering condition for the lemniscate trajectory . . . . . . . . . . . . . 47\n\n\n\nList of Tables\n\n2.1 Simulation parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n3.1 Simulation parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n\n4.1 Time-triggered control parameters . . . . . . . . . . . . . . . . . . . . . 41\n\n4.2 Usage of the wireless transmission channel . . . . . . . . . . . . . . . . 44\n\n\n\n12\n\n1 Introduction\n\nControl systems are indispensable in many high-tech systems. Whether the ap-\n\nplication is a copier, electron microscope or oil cracker, controllers are used to guaran-\n\ntee stable operation and enhance performance with respect to the uncontrolled, open-\n\nloop system. The main benefits of closing the control loop are disturbance rejection\n\nand tracking of setpoints.\n\nNowadays, control systems are typically digitally implemented. Mostly, time-\n\ntriggered implementations are used, in which the control task is executed periodically\n\nin time, since for this class of control systems an extensive analysis and design theory\n\nis available and robustness and performance criteria are well developed. Together\n\nwith the presence of programming and scheduling techniques on real-time hardware\n\nplatforms, this has become the dominating framework for digital control systems. An\n\nalternative to this time-triggered control setup can be found in event-triggered control\n\nsystems.\n\nIn this case, signals are sampled or new control inputs are generated after the\n\noccurrence of events, rather than after the elapse of a certain amount of time. The\n\nunderlying idea to update the control input only when it is needed. In that way, the\n\nneed for communication is expected to be significantly reduced compared to a periodic\n\nsetup. In general, the source of such an event can be based on anything. This project\n\npresents a triggering condition based on a Lyapunov function provided by Jiang and\n\nNijmeijer\u2019s controller [1] for the trajectory tracking of a nonholonomic robot.\n\nIn this chapter, the motivation and the objectives of this project are presented, as\n\nwell as the methodology used. Then, a brief description of the laboratory is provided\n\nalong with an explanation of which classes of the Control and Automation Engineer-\n\ning Course were essential to this project. At the end of this chapter, we provide an\n\nexplanation on how this document is organized.\n\n\n\n13\n\n1.1: Motivation and objectives\n\nIn the following subsections we will talk about the main topics that have motivated\n\nthis project starting with the trajectory tracking of a mobile robot. In the sequel, we talk\n\nabout the communication constraint problem and after that the main topic of interest in\n\nthis project: the event-triggered control.\n\n1.1.1: Trajectory tracking\n\nThe control of mechanical systems with nonholonomic constraints is of great\n\nimportance for numerous practical applications, especially in the robotics field where\n\nnonholonomics systems describe the dynamics of mobile robots and robot manipu-\n\nlators. The control of nonholonomic systems has been the subject of considerable\n\nresearch effort over the years. There are three main reasons for this trend:\n\n\u2022 There are a large number of mechanical systems such as robot manipulators,\nmobile robots, wheeled vehicles, and space and underwater robots which can be\n\nmodeled by nonholonomic dynamics;\n\n\u2022 There is considerable challenge in the synthesis of control laws for nonholonomic\nsystems;\n\n\u2022 Nonholonomic systems cannot be stabilized by continuous time-invariant control\nlaws.\n\nConcerning the trajectory tracking of mobile robots, our objective is to apply\n\nJiang and Nijmeijer\u2019s controller [1] to the practical experiment.\n\n1.1.2: Event-triggered control\n\nAs technology evolves, we need to use more sensors and more actuators in a\n\nnetwork resulting in a increase of the required bandwidth. The classical implementation\n\nin digital controllers uses a periodic strategy, receiving data from sensors and updating\n\nthe control every T units of time. This approach usually leads to an excessive usage\n\nof the communication channel, which could be used more efficiently. It would be better\n\nto close the feedback loop when needed according to the plant\u2019s state, an approach\n\ncalled event-triggered control, rather than send the control input every T units of time.\n\n\n\n14\n\nThe main objective of this project is the implementation of the event-triggered\n\ntracking control (ETTC) in a real nonholonomic robotic system. Using the event-\n\ntriggered approach leads to:\n\n\u2022 Less transmissions required to stablize the system;\n\n\u2022 Reduction in energy consumption;\n\n\u2022 Reduce network load.\n\n1.2: Methodology\n\nThe methodology used in the developing of this project was:\n\n\u2022 Study of papers on Event-Triggered Control and on the tracking control of mobile\nrobots with nonholonomic models;\n\n\u2022 Selection of a nonlinear feeback law and design of the associated event-triggering\ncondition;\n\n\u2022 Validation of the results on simulations using Matlab;\n\n\u2022 Implementation of the Event-Triggered Control on the mobile robot Khepera III;\n\n\u2022 Results analysis.\n\nThe program that will be used to run the simulations is MATLAB. The interface\n\nused to communicate with the mobile robot is implemented via a MATLAB file, making\n\nit simpler to transfer the control used on the simulations to the real system.\n\n1.3: Control and Automation Engineering Course Con-\ntext\n\nSeveral classes were important during the execution of this project. The control\n\nclasses like signals and linear systems, feedback systems and nonlinear systems were\n\nvery important during the study of the nonholonomic systems and the event-triggered\n\ncontrol, providing concepts for the development of a triggering condition and the imple-\n\nmentation of a nonlinear controller.\n\n\n\n15\n\nDuring the implementation phase, disciplines like Computer Networks for Indus-\n\ntrial Automation and Distributed Systems were essential for the understanding of the\n\ncommunication between the robot and the computer. Disciplines like Introduction to\n\nIndustrial Robotics helped the understanding of the behavior of the robot and in the\n\nfield of trajectory tracking.\n\n1.4: Laboratory\n\nThe internship took place in the laboratory CRAN - Centre de Recherche en\n\nAutomatique de Nancy - with the supervision of Dr. Romain Postoyan, from Febru-\n\nary 2012 to July 2012. In this section we will present some informations about the\n\nlaboratory.\n\nFigure 1.1: Cran Logo\n\nCreated in 1980, the CRAN is a mixed unity of research, common to the Henri\n\nPoincare? University, to the National Polytechnic Institute of Lorraine - INPL - and to the\n\nCNRS - Centre National de la Recherche Scientifique - and it is located in the city of\n\nVandoeuvre, at the region of Nancy, France. Due to its multidisciplinary characteristics,\n\nits installations are spread in several units [2].\n\nThe main lines of research at CRAN are the science of the modeling, analysis,\n\ncommand and supervision of dynamic systems, signal treatment and informatics en-\n\ngineering as well as studies in healthy engineering and system security. Today, the\n\nlaboratory has 76 professors, 6 researchers, 71 PhD students and 23 engineers.\n\n1.5: Document Organization\n\nIn this section, the organization of this document is going to be presented.\n\n\n\n16\n\nIn Chapter 2 we present the trajectory tracking control of mobile robots. In this\n\nchapter the robot model is presented, as well as the theory behind nonholonomic sys-\n\ntems, the bibliographic survey concerning linear and nonlinear controllers as well as\n\nthe theory supporting our chosen controller. Last, the simulations results of the chosen\n\ncontroller are presented and commented.\n\nIn Chapter 3 the Event-Triggered Control is presented. We provide a biblio-\n\ngraphic study concerning ETC as well as the design of the triggering condition. At\n\nthe end of this chapter, simulations of the system using event-triggered control are\n\npresented.\n\nIn Chapter 4 we present the implementation of the time-triggered and the event-\n\ntriggered approaches and compare them. We then give an overview of the hardware\n\nand software used. We will present informations about the robot used, the type of com-\n\nmunication implemented between the robot and the computer as well as the software\n\nand hardware used for the motion analysis of the robot. Later in this chapter, the results\n\nof the time-triggered and event-triggered approachs are presented and compared.\n\nIn the last chapter, a conclusion for this report is provided.\n\n\n\n17\n\n2 Tracking control of mobile\nrobots\n\nThe objective of this chapter is to provide some information about the trajectory\n\ntracking control of mobile robots. In the first section, we present the system model i. e.\n\nthe robot model and the reference system which generates the desired trajectory. In\n\nthe subsequent section, we propose a brief bibliographic study on the existing methods\n\nfor the tracking control of nonholonomic systems. Afterwards, we present the selected\n\ncontrol strategy and we give the main lines of the technical proof. We will end this\n\nsection with some conclusions as well as some simulation results.\n\n2.1: System Models\n\n2.1.1: Robot Model\n\nThe robot dynamics are described by the following dynamical equations (as in\n\n[3] for instance):\n\nx? = v cos(?)\n\ny? = v sin(?)\n\n?? = w,\n\n(2.1)\n\nwhere (x,y) are the Cartesian coordinates and ? is the angle between the heading\n\ndirection and the x-axis. The control inputs are (v,w) and respectively represents the\n\nlinear and angular velocities. A diagram of the system is depicted in Figure 2.1.\n\nSystem (2.1) is said to be nonholonomic as the controllable degrees of freedom\n\n(DoF) are less than the total degrees of freedom of the system. That means that the\n\nrobot cannot move in a arbitrary direction because the displacement is bounded by the\n\norientation.\n\n\n\n18\n\nFigure 2.1: A nonholonomic mechanical system\n\n2.1.2: The desired trajectory\n\n2.1.2.1: The reference system\n\nOur objective is to make the states of the system (2.1) track a given trajectory.\n\nWe focus on trajectories which satisfy the robot dynamics (2.1) in order to be able to\n\nensure asymptotic tracking properties. In that way, the desired trajectory needs to be\n\na solution of the following system, which we call the reference system:\n\nx?r = vr cos(?r)\n\ny?r = vr sin(?r)\n\n??r = wr.\n\n(2.2)\n\nIn practice, the desired trajectory is usually given as xr(t), yr(t). To show that the\n\ntrajectory satisfies (2.2), we need to find appropriate vr(t) and wr(t). With the functions\n\nof (xr,yr) we can find their velocities (x?r, y?r) (provided they are differentiable) which\n\nare vectors aligned with the x-axis and the y-axis respectively. The linear velocity vr is\n\nfound using the Pythagorean theorem, seeing that the linear velocity is the hypotenuse\n\nwhile (x?r, y?r) are the sides of the triangle. We can find ?r as a arctan() function of x?r\nand y?r while wr is the time derivative of ?r. This is summarized below.\n\n\n\n19\n\n?r(t) = arctan(\ny?r\nx?r\n\n)\n\nvr(t) =\n?\nx?2r + y?\n\n2\nr\n\nwr(t) = ??r,\n\n(2.3)\n\n2.1.2.2: Examples\n\nWe now provide examples of reference trajectories which will be considered in\n\nthe sequel.\n\n\u2022 Circle\n\nFigure 2.2: A diagram showing the circular trajectory\n\nWe consider a circular trajectory given as xr = xc + R sin(et) and yr = yc ?\nR cos(et) where (xc,yc) are the coordinates of the center, R is the radius of the circle,\n\ne is a parameter which controls the speed of the trajectory. It can be shown that the\n\ntrajectory (2.4) satisfies the equations (2.2) with\n\n\n\n20\n\nxr(t) = xc + R sin(et)\n\nyr(t) = yc ?R cos(et)\n?r(t) = et\n\nvr(t) = eR\n\nwr(t) = e.\n\n(2.4)\n\n\u2022 Ellipse\n\nFigure 2.3: A diagram showing the ellipsoidal trajectory\n\nFor the ellipse trajectory, we consider the following equations: xr = xc + b sin(?t)\n\nand yr = yc ?a cos(?t) where (xc,yc) are the coordinates of the center of the trajectory,\na and b are parameters used to define the semi-axis of the ellipse and ? is a parameter\n\nrelated to the speed of the trajectory. We can notice that if a = b the resulting function\n\nis the same as the circular trajectory. We can see in (2.5) the remaining equations of\n\nthe ellipse:\n\nxr(t) = xc + b sin(?t)\n\nyr(t) = yc ?a cos(?t)\n?r(t) = arctan(a sin(?t)/b cos(?t))\n\nvr(t) =\n?\n\n(a2?2 sin(?t)2 + ?2b2 cos(?t)2)\n\nwr(t) =\n?b\na\n\n+\n?b cos(?t)2\n\na sin(?t)2\n\nb2 cos(?t)2\n\na2 sin(?t)2\n+1\n\n.\n\n(2.5)\n\n\n\n21\n\n\u2022 Lemniscate\n\nFigure 2.4: A diagram showing the lemniscate trajectory\n\nFor the lemniscate (infinite loop) we used the following equations to represent the\n\ndesired position: xr = xc + (a sin(?t))/(1 + sin2(?t)) and yr = yc + (a sin(?t) cos(?t))/(1 +\n\nsin2(?t)) where (xc,yc) are the coordinates of the center of the trajectory, a is a parame-\n\nter used to define the size of the lemniscate and ? related to the speed of the trajectory.\n\nThe full equations of vr and wr can be seen at Appendix C.1.\n\nxr(t) = xc +\na sin(?t)\n\n1+sin2(?t)\n\nyr(t) = yc +\na sin(?t) cos(?t)\n\n1+sin2(?t)\n\n?r(t) = arctan(\ny?r(?t)\nx?r(?t)\n\n)\n\nvr(t) = g1(t)\n\nwr(t) = g2(t).\n\n(2.6)\n\n2.2: Bibliographic Study\n\nA large number of researchers have proposed control strategies for the stabi-\n\nlization of the system (2.8) during the last decades. We can distinguish the works\n\naddressing the case where the reference trajectory is the origin of system (2.1), and\n\nthe case where the desired trajectory is time-varying, which is the case in this project.\n\n\n\n22\n\n2.2.1: Stabilization of an equilibrium point\n\nIn some particular papers, the main objective is the stabilization of an equilibrium\n\npoint. The robot variables should thus converge to a reference position, meaning that\n\nxr, yr and ?r are constants. It has been shown that this cannot be achieved by means\n\nof a continuous feedback, see [4], when xr,yr,?r = 0. As a consequence, a number\n\nof techniques based on time-varying controllers and discontinuous feedbacks have\n\nbeen proposed, see [5], [6], [7] and the references therein. We do not consider these\n\ntechniques because we are interested in tracking of time-varying trajectories.\n\n2.2.2: Stabilization of time-varying trajectory\n\nWhile studying the existing works on the stabilization of time-varying trajecto-\n\nries, it appears that a large number of articles are available (see [8], [9], [10] and the\n\nreferences therein). However, very few ensures global properties (i.e. the convergence\n\nof the robot (2.8) towards the reference system (2.2) is guaranteed for every initial\n\ncondition) together with an explicit Lyapunov function [11], [1]. We have chosen to\n\nconsider the technique in [1] because its Lyapunov-based analysis seems to be more\n\nappropriate for the design of event-triggering condition compared to [11].\n\n2.3: Jiang and Nijmeijer\u2019s controllers [1]\n\n2.3.1: Error system\n\nAs our objective is to ensure the convergence of (x,y,?) towards (xr,yr,?r), we\n\nnaturally introduce the error variables (x?xr,y ? yr,? ? ?r). It has been shown in [4]\nthat the following change of coordinates may help for designing the controller:\n\n?\n???\n\nxe\n\nye\n\n?e\n\n?\n??? =\n\n?\n???\n\ncos(?) sin(?) 0\n\n?sin(?) cos(?) 0\n0 0 1\n\n?\n???\n?\n???\n\nxr ?x\nyr ?y\n?r ??\n\n?\n??? . (2.7)\n\n\n\n23\n\nIn that way, we derive the error system:\n\nx?e = wye ?v + vr cos(?e)\ny?e = ?wxe + vr sin(?e)\n??e = wr ?w.\n\n(2.8)\n\nNote that to write the problem using the coordinates (xe,ye,?e) is equivalent to\n\n(xr,yr,?r) since the transformation matrix in 2.7 is invertible. On the other hand, our\n\ntracking problem for system (2.1) has now become a stabilization one for the time-\n\nvarying system (2.8) since when (xe,ye,?e) = 0, we have x = xr, y = yr and ? = ?r.\n\nWith that in mind, we will stabilize the system (2.8).\n\n2.3.2: Controller\n\nBefore we can find a suitable controller, some variable changes are needed.\n\nFirst, we define a new variable called x?e:\n\nx?e := xe ? c3wye, (2.9)\n\nwhere c3 is a positive constant. With this new variable, we have in view of (2.8) and\n\n(2.9)\n\n??xe = wye ?v + vr cos(?e) ? c3w?ye ? c3w(?wxe + vr sin(?e)). (2.10)\n\nFor notational simplicity, we introduce a new variable called v1:\n\nv1 := wye + vr cos(?e) ? c3w?ye ? c3w(?wxe + vr sin(?e)). (2.11)\n\nWe can now focus on the Lyapunov function. Let consider the following function\n\n[1, equation (37)] with ? > 0:\n\nV (t,xe,ye,?e) =\n1\n\n2\nx?2e +\n\n1\n\n2\ny2e +\n\n1\n\n2?\n?2e. (2.12)\n\nAlong the solution of (2.8) and (2.10), we have:\n\nV? (t) = ?c3w2y2e + x?e(?yew + v1 ?v) +\n1\n\n?\n?e[?yevr\n\nsin(?e)\n\n?e\n+ wr ?w]. (2.13)\n\n\n\n24\n\nWe can choose (v,w) as:\n\nv = v1 + yew + c4x?e, (2.14)\n\nw = wr ??yevr\nsin(?e)\n\n?e\n+ c5??e, (2.15)\n\nwhere c4,c5 > 0 are some design parameters. We therefore have:\n\nV? (t) = ?c3w2y2e ? c4x?\n2\ne ? c5?\n\n2\ne. (2.16)\n\nWe cannot use (2.16) to directly conclude about the stability of the origin of\n\nsystem (2.8) as V? is not strictly negative when (xe,ye,?e) 6= 0.\n\nWe need to make the following assumption.\n\nAssumption 1 Assume that vr, v?r, wr, and w?r are bounded on [0,?). Furthermore,\nvr(t) does not converge to zero or wr(t) does not converge to zero.\n\nIt has to be noticed that Assumption 1 is satisfied by the three examples of\n\nreference trajectories given in Section 3.1.2.2.\n\nWe can notice that (2.16) yields the property that w(t)2ye(t)2, x?e(t)2, ?e(t)2 ?\nL1(0,?) (see Appendix B.1). By assumption, the derivatives of these signals are\nbounded. Hence w(t)2ye(t)2, x?e(t)2 and ?e(t)2 are uniformly continuous on [0,?). With\nthe help of Barbalat\u2019s lemma (see Appendix A.1), it follows that w(t)ye(t), x?e(t) and ?e(t)\n\nconverges to 0 as t goes to ?. From the definition of x?e in (2.9), it follows that xe(t)\ngoes to 0.\n\nIt remains to prove that ye(t) goes to 0. Setting ?1(t) = sin(?e(t))/?e(t), we have\n\n?1(t) going to 1 when ?e = 0. In the closed-loop system , the ?e system equation\n\nbecomes\n\n?e = ?c5??e ??ye(t)vr(t)?1(t). (2.17)\n\nA direct application of Lemma 2 (see Appendix A.2) gives that ?ye(t)vr(t)?1(t) tends to\n\n0. Then, we conclude that ye(t) must converge to 0.\n\nWe can then state the following proposition.\n\nProposition 1 (Proposition 2 in [1]) Consider system 2.8 and suppose Assumption\n\n1 holds. Then the closed-loop solutions converge to zero i.e.\n\n\n\n25\n\nlim\nt??\n\n(|xe(t)| + |ye(t)| + |?e(t)|) = 0. (2.18)\n\n2.4: Simulations\n\nWe provide simulation results to illustrate the efficiency of the controllers pre-\n\nsented in Section 2.3.2. The parameters shown in this section are the same ones used\n\nin Chapter 4 for the implementation. The reason of this choice is to make it easier for\n\nthe reader to compare the simulations with the practical results.\n\nCircle Ellipse Lemniscate\n\ntf 35 s 45 s 90 s\n\n? 0 0.2 rad/s 0.1 rad/s\n\nR 0.6 m 0 0\n\ne 0.2 rad/s 0 0\n\na 0 0.8 m 1.2 m\n\nb 0 0.5 m 0\n\n(xc,yc) (0, 0.66) (0, 0) (0, 0)\n\n(x(0),y(0),?(0)) (0, 0, 0.1) (0,?0.96, 0.1) (0, 0, 0.1)\n(xr(0),yr(0),?r(0)) (0, 0.066, 0) (0,?0.8, 0) (0, 0, 0.7854)\n\n(?,c3,c4,c5) (1, 0.7, 0.5, 0.8) (1, 0.7, 0.5, 0.8) (1, 0.7, 0.5, 0.8)\n\nTable 2.1: Simulation parameters\n\nAs we can see in Figures 2.5, 2.6 and 2.7 the states of the robot (2.1) do asymp-\n\ntotically converge to the considered reference trajectory as ensured by Proposition 1.\n\nIn all cases we can see the control inputs (v,w) converge towards the reference veloc-\n\nities (vr,wr).\n\n\n\n26\n\nFigure 2.5: Trajectory and control for the circular trajectory\n\nFigure 2.6: Trajectory and control for the ellipsoidal trajectory\n\nFigure 2.7: Trajectory and control for the lemniscate trajectory\n\n\n\n27\n\n2.5: Conclusion\n\nIn this chapter, we have presented details about the trajectory tracking control\n\nof class of nonholonomic systems. In the first section, the robot model was presented\n\nalong with the trajectory model and the error model, which turned the tracking prob-\n\nlem into a stabilization problem of a time-varying system. In the subsequent section,\n\nwe have presented the bibliographic study for the trajectory tracking control problem,\n\nshowing later the controller chosen and how it was designed. At the end of this chap-\n\nter, we have shown the simulations results of this controller for three different reference\n\ntrajectories.\n\n\n\n28\n\n3 Event-triggered tracking control\n\nIn this chapter, we present the triggering condition we have developed for the\n\ntracking control of mobile robots. In the first section, we recall the main idea of event-\n\ntriggered control and we provide a brief survey. In the subsequent section, we present\n\nthe hybrid model of the system and the triggering condition. We end this section with\n\nsome simulation results as well as some conclusions.\n\n3.1: Presentation\n\nEvent-triggered control (ETC) consists in closing the loop according to a state-\n\ndependent criterion. The idea is to update the control input when it is needed, as\n\nopposed to the traditional periodic implementation. In that way, it is expected to signif-\n\nicantly reduce the amount of transmissions needed for stabilizing the system. When\n\nthe event-triggering mechanism is designed properly, this ensures that control tasks\n\nare executed only when necessary. Therefore, we can decrease the load in certain\n\nresources, like a wireless network, while maintaining a desired level of performance.\n\nBeing a topic of great interest lately, ETC has been investigated for linear and nonlin-\n\near systems in [12], [13], [14], [15] [16], [17]. There are fewer results which propose\n\na solution for the trajectory tracking problem, which is the main focus of this project.\n\nUntil this date, we are only aware of the work in [18]. As a consequence, we need to\n\ndevelop an appropriate triggering condition for our problem. To solve this, we will rely\n\non the following articles [19], [20], [21].\n\n\n\n29\n\n3.2: Design of the triggering condition\n\n3.2.1: Hybrid model\n\nIn Chapter 2, we considered the trajectory tracking control of a nonholonomic\n\nsystem assuming that the control input is continuously updated. However, due to the\n\nfacts that the controller is implemented on a computer and communicate with the robot\n\nvia a wireless network, transmissions will only occur at some instants. We then have\n\na hybrid system i.e. a dynamical system which exhibits both continuous and discrete\n\ndynamics. In our case, the dynamics of the robot depicted in Chapter 2 remain con-\n\ntinuous, but the control inputs are sampled. Considering the sampling of the control\n\ninputs at the instant t1, i ? Z > 0, the equation (2.8) turns into\n\nx?e(t) = w(ti)ye(t) ?v(ti) + vr(t) cos(?e(t))\ny?e(t) = ?w(ti)xe(t) + vr(t) sin(?e(t)) ?t ? [ti, ti+1] .\n??e(t) = wr(t) ?w(ti).\n\n(3.1)\n\nThe errors on the control input caused by the network are modelled by the following\n\nvariable\n\nev := v(ti) ?v(t) ?t ? [ti, ti+1]\new := w(ti) ?w(t).\n\n(3.2)\n\nWe can now write equation (3.1) as a full system, taking in account the dynamics\n\nof the error (ev,ew) caused by the network:\n\nx?e = (w + ew)ye ?v ?ev + vr cos(?e)\ny?e = ?(w + ew)xe + vr sin(?e)\n??e = wr ?w ?ew ?t ? [ti, ti+1]\ne?v = g1(t,xe,ye)\n\ne?w = g2(t,ye,?e),\n\n(3.3)\n\nwhere g1 and g2 can be deduced using (3.1) and (3.2). Traditionally, the sequence\n\n{ti}i???0 is defined periodically. In this project, we define it accordly to a state-dependent\ncriterion.\n\nWhen an event is triggered, the system states (xe,ye,?e) stay the same but the\n\nerrors ev and ew on the control input are set to 0. This means an update of the control\n\n\n\n30\n\ninput. We can see this on the following equations:\n\nxe(t\n+\ni+1) = xe(ti+1)\n\nye(t\n+\ni+1) = ye(ti+1)\n\n?e(t\n+\ni+1) = ?e(ti+1)\n\nev(t\n+\ni+1) = 0\n\new(t\n+\ni+1) = 0.\n\n(3.4)\n\n3.2.2: The triggering condition\n\nTo find the triggering condition for our system we now consider the hybrid system\n\n(3.3). Consider the same function as in (2.12)\n\nV (xe,ye,?e) =\n1\n\n2\nx?2e +\n\n1\n\n2\ny2e +\n\n1\n\n2?\n?2e, (3.5)\n\nwhere, as in (2.9)\n\nx?e = xe ? c3wye, (3.6)\n\nwhere c3 is a positive constant. In view of (2.10) and (3.3), we have, for t ? [ti, ti+1]\n\n??xe = wye + ewye ?v ?ev + vr cos(?e) ? c3w?ye ? c3w(?wxe ?ewxe + vr sin(?e)). (3.7)\n\nFor notational simplicity, we are introduce the v1:\n\nv1 = wye + vr cos(?e) + c3w?ye ? c3w(?wxe + vr sin(?e)) (3.8)\n\nWe have, along solutions to (3.3)-(3.4), for t ? [ti, ti+1]\n\nV? (t) = ?c3w2y2e + x?e(?yew + v1 ?v) +\n1\n?\n?e[?yevr\n\nsin(?e)\n?e\n\n+ wr ?w]\n+x?e(ewye ?ev + c3wew(x?e) + c3wye) ?yeew(x?e + c3wye) ? 1??eew\n+x?ec3ye(?ewxe?vr sin(?e)/(?e) ?ew?yevr((?e cos(?e) ? sin(?e))/?2e + c5?)\n\n(3.9)\n\nwhere (v,w) are defined by v = v1 ?yew + c4x?e and w = wr + ?yevr\nsin(?e)\n?e\n\n+ c5??e as in\n\n(2.14) and (2.15) where c4,c5 > 0 are some design parameters.\n\n\n\n31\n\nV? (t) = ?c3w2y2e ? c4x?2e ? c5?2e + c23w2x?eyeew ?evx?e ?\n1\n?\n?eew ? c3wewy2e + c3wewx?2e\n\n+x?ec3ye(?ewxe?vr sin(?e)/(?e) ?ew?yevr((?e cos(?e) ?sin(?e))/?2e + c5?)).\n(3.10)\n\nIn this chapter, we want to ensure the convergence of xe, ye, ?e towards a neigh-\n\nborhood of the origin. That is why we want to have V which always strictly decreases\n\nexcept on a neighborhood of the origin. We do not aim at ensuring an asymptotic con-\n\nvergence property towards the origin because the errors induced by the network on\n\nthe terms vr and wr prevent us from it as explained in [22]. Therefore, we define the\n\ntriggering condition as:(\nV? ? ?(x?e,w,ye,?e)\n\n)\nand\n\n(\n?(t, x?e,ye,?e,ev,ew) ? ?\n\n)\n, (3.11)\n\nwhere ?(x?e,w,ye,?e) := ?(?c3w2y2e ?c4x?2e ?c5?2e) and ? ? (0, 1), ?(t, x?e,ye,?e,ev,ew) :=\nc23w\n\n2x?eyeew?evx?e?1??eew?c3wewy\n2\ne +c3wewx?\n\n2\ne+x?ec3ye(?ewxe?vr sin(?e)/(?e)?ew?yevr((?e\n\ncos(?e) ? sin(?e))/?2e + c5?)) and ? > 0 is a design parameter. In that way, every time\nV? becomes equal or bigger than ? and ? is bigger than ?, an event is triggered and ew\nand ev are reset to 0. The transmission instants are thus defined as\n\nti+1 = inf\n{\nt > ti : V? (t) ? ?(x?e(t),w(t),ye(t),?e(t))\n\nand ?(t, x?e(t),ye(t),?e(t),ev(t),ew(t)) ? ?\n}\n.\n\n(3.12)\n\nAs in Chapter 2, we make the following assumption on the reference trajectory.\n\nAssumption 2 The signals wr,vr, v?r, w?r are bounded on [0,?) by M > 0.\n\nWe are now able to state the following theorem.\n\nTheorem 1 Consider the system (3.3)-(3.4) with the jump times defined by (3.12) and\n\nsuppose Assumption 2 holds. Then the system is forward complete i.e. solutions are\n\ndefined for all time and for any initial conditions and the states are bounded. Moreover\n\nxe(t),wye(t),?e(t) are ultimately bounded by ?(?) where ? is a class K? function which\nis independent of ?.\n\nProof. We start by proving that the states of the system are always bounded on the\n\ntime interval where the solutions are defined. Afterwards, we show that there always\n\n\n\n32\n\nexists a minimum amount of time between two jumps. Then, we show that the system\n\nis forward complete. Finally, we prove that the desired convergence property holds.\n\nLet t0 ? R?0 be the initial time and (xe(t0),ye(t0),?e(t0),ev(t0),ew(t0)) ? R5 be the\ninitial conditions. Solutions are then defined for all t ? [t0, t?] where t? ? R?0 ?{?}.\nConsider ? > 0 such that |(xe(t0),ye(t0),?e(t0))| ? ?. According to (3.12), we have\nthat, for t ? [ti, ti+1] ? [t0, t?] with i ? Z?0 (we write ? as a function of the time for the\npurpose of convenience only)\n\nV? (t) ? max{?(t),??1?(t) + ?}\n? max{?(t), ?(t) + ?} = ?(t) + ?.\n\n(3.13)\n\nHence, since V (t+i ) = V (ti) for ti ? [0, t\n?], the variables x?e, ye and ?e asymptotically\n\nconverge towards the set S := {(xe,w,ye,?e,ev,ew) : |?(x?e,w,ye,?e)| ? ?}. As a\nconsequence, x?e, ye and ?e are bounded on [t0, t?] by a constant which depends on\n\n? and ?. By invoking the definition of w and Assumption 2, we obtain that w is also\n\nbounded by a constant ?? which depends on ?, ? and M (the bound on vr and wr).\n\nAs a consequence, since ew = w(ti) ? w(t), we have that ew is always bounded by\n2??. Hence, by using the facts that v?r and w?r are also bounded by M, we then deduce\n\nthat v is bounded by some constant ?? which depends on ?, ? and M and so ev is\n\nalways bounded by 2?? in view of its definition. In that way, we have shown that for any\n\nt ? [0, t?], the states of the system (3.3)-(3.4) with the jump times defined by (3.12) are\nbounded.\n\nWe now prove that there always a minimum inter-execution time ??,? > 0 be-\n\ntween two jumps. First, note that t? is necessarily strictly bigger t1 and t2 as the sys-\n\ntem cannot explode before. We note that after the jump at t1, ?(t\n+\n1 ) = 0. Hence,\n\nthe next jump cannot not occur before ? increases from 0 to ?. By using the fact\n\nthat ? is continuously differentiable and that wr, w?r,vr, v?r are bounded by M and that\n\nxe,ye,?e,w,v,ew,ev are all bounded by a constant N which depends on ?, ? and M,\n\nwe deduce that there exists N? which also depends on ?, ? and M such that for all\n\nt ? [t1, t2]\n|??(t)| ? N?. (3.14)\n\nIn that way, we see that the jump at t2 cannot occur before ??,? := N?? seconds have\n\nelapsed. In other words, t2 ? t1 ? N??. By iteration, we deduce that ti+1 ? ti ? ??,? for\nall ti+1 ? t?.\n\nWe can then show by contradiction that the system is forward complete as no\n\n\n\n33\n\nZeno phenomenon can occur and all the states of the system are bounded.\n\nUsing the fact that lim\nt??\n\nsup|?(t)| ? ?, we derive, from the definition of x?e, that\n|xe(t)|, |wye(t)|, |?e(t)| are ultimately bounded by ?(?) where ? is a class K? function\nwhich is independent of ?. 2\n\nIt has to be noted that Theorem 1 does not guarantee the convergence of ye\ntowards a neighborhood of the origin which depends on ?. We conjecture that is true\n\nbut proving it requires further investigations.\n\n3.3: Simulations\n\nWe provide simulation results to illustrate the efficiency of the controllers using\n\nthe event-triggered condition presented in Section 3.2.2. The parameters are the same\n\nas those used in Chapters 2 and 4, see Table 3.1. The reason of this choice is to make\n\nit easier for the reader to compare the simulations with the experimental results. As\n\nin practice, we will not have acess to the states of the robot at any instant, we verify\n\nthe triggering condition every T = 30 ms only, as in Chapter 4, but we only update\n\nthe control input when 3.11 holds. We acknowledge that there is a lack in our analysis.\n\nHowever, the efficiency of our approach has been verified in simulations and in practice.\n\nCircle Ellipse Lemniscate\n\ntf 35 s 45 s 90 s\n\n? 0.00015 0.00015 0.00015\n\n? 0 0.2 rad/s 0.1 rad/s\n\n? 0.5 0.5 0.5\n\nR 0.6 m 0 0\n\ne 0.2 rad/s 0 0\n\na 0 0.8 m 1.2 m\n\nb 0 0.5 m 0\n\n(xc,yc) (0, 0.66) (0, 0) (0, 0)\n\n(x(0),y(0),?(0)) (0, 0, 0.1) (0,?0.96, 0.1) (0, 0, 0.1)\n(xr(0),yr(0),?r(0)) (0, 0.066, 0) (0,?0.8, 0) (0, 0, 0.7854)\n\n(?,c3,c4,c5) (1, 0.7, 0.5, 0.8) (1, 0.7, 0.5, 0.8) (1, 0.7, 0.5, 0.8)\n\nTable 3.1: Simulation parameters\n\n\n\n34\n\nAs we can see in Figures 3.1 and 3.4, the states of the robot (2.1) do asymptot-\n\nically converge to the considered reference trajectory. We can see on Figures 3.2 and\n\n3.4 that the control inputs (v,w) are held until the next event. Figures 3.3 and 3.5 show\n\nthe instant when the transmission are triggered.\n\nFigure 3.1: Trajectory for the circular and the ellipsoidal trajectory using ETC\n\nFigure 3.2: Control inputs for the circular and the ellipsoidal trajectory using ETC\n\n\n\n35\n\nFigure 3.3: Triggering condition for the circular and the ellipsoidal trajectory using ETC\n\nFigure 3.4: Trajectory and control for the lemniscate trajectory using ETC\n\nFigure 3.5: Triggering condition for the lemniscate trajectory\n\n\n\n36\n\n3.4: Conclusion\n\nIn this chapter, we have presented details of the event-triggering condition for\n\nthe trajectory control of a mobile robot. In the first section, the main idea of event-\n\ntriggered technique was presented, and some relevant references were provided. In\n\nthe subsequent sections, we have presented the new hybrid system, showing later\n\nthe triggering condition we designed. At the end of this chapter, we have shown the\n\nsimulations results of our technique for three different reference trajectories. We are\n\nready to implement our event-triggered controller on the SAMI benchmark.\n\n\n\n37\n\n4 Implementation and\nexperimental results\n\nIn this chapter, we show the experimental results we have obtained. In the first\n\nsection, we present the robot, Khepera III, and its communication setup. In the next\n\nsection, we present details about the implementation, such as the time sequence of\n\nthe program executions. The next sections present the results of the time-triggered\n\nand event-triggered approaches. We end this chapter with a comparison between\n\nthese approaches and some conclusions as well.\n\n4.1: The SAMI benchmark\n\n4.1.1: Robot: Khepera III\n\nThe robot we consider is the Khepera III, produced by K-Team Corporation, a\n\nSwiss company. This robot is available in the SAMI Benchmark for educational and\n\nresearch activities [3] for quite some time, proving itself to be reliable and easy to use.\n\nThis type of robot is used in more than five hundred universities and research centers\n\ndue to its modularity and multiple possibilities for control.\n\nThe model used at the ENSEM has two independent motors, five ultrasonic sen-\n\nsors, a camera, a wireless card and a battery. We can see the details of the assembly\n\nin Figure 4.1. Each DC motor is equipped with an incremental encoder for speed sen-\n\nsoring and is locally driven by a PID controller (responsible for tracking a given speed\n\nreference) implemented in a PIC18F4431, using a PWM (pulse width modulation) out-\n\nput.\n\nThe main controller (in charge of the trajectory tracking control, see Chapter 3) of\n\nthe robot is implemented on a remote computer using Matlab. This is possible thanks\n\nto a middleware, a software layer between the operating system and the applications\n\n\n\n38\n\nFigure 4.1: Khepera III\n\non each side of a network. Using a MATLAB class called @Khepera3, the position\n\nand the orientation of the robot are retrieved and we can set the linear and angular\n\nvelocities of the robot. In the next subsection, we explain how the remote controller\n\nand the robot communicate.\n\n4.1.2: Controller-robot communication\n\nThe communication between the robot and the controller happens in two dif-\n\nferent ways, whether measurements or control inputs are transmitted. The setup is\n\ndepicted in Figure 4.2.\n\n4.1.2.1: Orientation and Position measurement\n\nThe sampling of the position and the orientation of the robot occurs in real\n\ntime and is sent to the controller via Ethernet and stored in a buffer (see Figure 4.2).\n\nThis buffer is located in the computer where the remote controller which we have de-\n\nsigned is located and can be acessed whenever it is required via the functions my-\n\n\n\n39\n\nRobot.GetXYPosition() and myRobot.GetOrientation(). This operation usually takes\n\nless than 4 milliseconds to return the value. Given that this is actually very fast, we\n\nconsider the operating time of this function as instanteneous.\n\n4.1.2.2: Control input\n\nThe control input (which consists of the linear velocity and angular velocity) is\n\nsent to the robot via a Wi-Fi connection. This is done by calling the function myRobot.\n\n-SetVelocity(v,w) on MATLAB. The robot then receives new values for v and w and\n\nsends an acknowledgement to the computer allowing it to continue it is execution. The\n\nmain problem of this kind of transmission is that it is highly sensitive to interferences,\n\ncollisions and errors in the message.\n\nFigure 4.2: Communication setup for the Khepera III\n\n\n\n40\n\n4.1.3: Motion Analysis\n\nThe robot variables (Position and Orientation) are measured thanks to the po-\n\nsitioning system which consists of six digital cameras (called Eagle) and the motion\n\ncapture software Cortex. The software provides an interface with the cameras, allow-\n\ning the user to set up an environment, calibrate it and capture the motion in real-time.\n\nThe system provides a three dimensional coordinate of a marker - a high reflective\n\nobject located in the body of interest. Using the Cortex software, we can identify a set\n\nof markers and track them in real time. The coordinates of the robot are relative to the\n\norigin defined in the calibration step.\n\n4.2: Implementation\n\nAs shown on Section 4.1.2, the robot and the computer have two methods of\n\ncommunication. Asking for the position and the orientation of the robot takes almost\n\nno time, while sending the control inputs to the robot takes some time. In practice, the\n\nexecution of the program on the computer is kept in a holding state until an acknowl-\n\nedge is received. Because of this situation, we have a soft real time implementation,\n\nin the sense that we cannot assure that each interation of the program will be finished\n\nbefore a given deadline. To counter this, we measure the time elapsed between two\n\ninteractions of the program, so we can find the time elapsed between ti and ti+1, where\n\nti is the instant when a interaction of the program start and ti+1 the instant when this\n\ninteraction ends and another starts, even if it was not defined beforehand. Figure 4.3\n\nshows a diagram representing this process. We consider that the start of a new inter-\n\nation ti is also the instant where the acknowledge was received.\n\nFigure 4.3: Diagram showing the time sequence of the controller\n\n\n\n41\n\n4.3: Time-triggered controller\n\nIn this section we have implemented the Jiang and Nijmeijer\u2019s controller pre-\n\nsented in Chapter 2 and in a classical time-triggered fashion. The parameters used\n\nduring the experiment can be found in Table 4.1. We can see on Figures 4.5, 4.6 and\n\n4.7 that the results obtained during the practical part are similar to the simulations in\n\nSection 2.4.\n\nCircle Ellipse Lemniscate\n\ntf 35 s 45 s 90 s\n\n? 0 0.2 rad/s 0.1 rad/s\n\nR 0.6 m 0 0\n\ne 0.2 rad/s 0 0\n\na 0 0.8 m 1.2 m\n\nb 0 0.5 m 0\n\n(xc,yc) (0, 0.66) (0, 0) (0, 0)\n\n(xr(0),yr(0),?r(0)) (0, 0.066, 0) (0,?0.8, 0) (0, 0, 0.7854)\n(?,c3,c4,c5) (1, 0.7, 0.5, 0.8) (1, 0.7, 0.5, 0.8) (1, 0.7, 0.5, 0.8)\n\nTable 4.1: Time-triggered control parameters\n\nOnce again, we can see on Figures 4.5, 4.6 and 4.7 that the states of the robot\n\n(xe,ye,?e) asymptotically converge to a neighbourhood of the reference trajectory. We\n\ncan see in the plots to the right of Figures 4.5, 4.6 and 4.7 that the control inputs have\n\na lot of noise. This happens because of a measurement noise which we can see in\n\nFigure 4.4 for the robot states (xe, ye, ?).\n\n\n\n42\n\nFigure 4.4: Plot of the robot states (xe, ye, ?) of the lemniscate trajectory\n\nFigure 4.5: Trajectory and control inputs for the circular trajectory using time-triggered\ncontrol\n\n\n\n43\n\nFigure 4.6: Trajectory and control inputs for the ellipsoidal trajectory using time-\ntriggered control\n\nFigure 4.7: Trajectory and control inputs for the lemniscate trajectory using time-\ntriggered control\n\n4.4: Event-triggered controller\n\nIn this section, we present the results given by the event-triggered controller de-\n\nsigned in Chapter 3. The parameters used can be found in Table 4.1 with the exception\n\nof the triggering condition parameter ?. As defined in Section 3.2.2, the parameter ?\n\nacts on the amount of transmission where ? ? (0, 1). As ? gets closer to 1 we expect\nmore transmissions compared to the case where ? is close to 0. In order to compare\n\nthe number of transmissions between each value, we define the following equation\n\n\n\n44\n\nusage =\nnumber of transmissions\n\ntime length\n. (4.1)\n\nIn Table 4.2 we can see the usage values for different ? and the values of usage\n\nin the time-triggered implementation\n\nCircle (tf = 35 s) Ellipse (tf = 45 s) Lemniscate (tf = 90 s)\n\nTime-triggered 18.4571 8.8222 10.2000\n\n? = 0.1 0.6571 1.0889 1.4889\n\n? = 0.5 0.8000 1.1111 2.1000\n\n? = 0.9 0.9143 1.0667 2.2778\n\nTable 4.2: Usage of the wireless transmission channel\n\nEvery real system is prone to noise, and this is the case here. In this case we\n\nhave a measurement noise (see Figure 4.4) and even though this noise does not keep\n\nthe controller from tracking the reference trajectory, it may cause unnecessary updates\n\nof the control inputs (v,w). On the other hand, the event-triggered approach proved to\n\nbe less affected by the noises because our triggering condition ?(t, x?e,ye,?e,ev,ew) ? ?\ndefined in Equation 3.11 allows us to be less sensitive to noises.\n\nWe can see in Table 4.2 that the usage grows bigger as ? approaches 1. We can\n\nalso see that the relation between the parameter ? and the usage depends highly on\n\nthe trajectory. The circular trajectory was less affected by this parameter change than\n\nthe lemniscate trajectory. The practical results provided below (Figures 4.8 and 4.11)\n\nuses ? = 0.9 and shows a similar response compared to the time-triggered control,\n\ncorrectly tracking the reference trajectory. We can also verify that the control inputs are\n\nsimilar to the ones obtained during the simulations.\n\n\n\n45\n\nFigure 4.8: Trajectory for the circular and the ellipsoidal trajectory using ETC\n\nFigure 4.9: Control inputs for the circular and the ellipsoidal trajectory using ETC\n\n\n\n46\n\nFigure 4.10: Triggering condition for the circular and the ellipsoidal trajectory using\nETC\n\nFigure 4.11: Trajectory and control for the lemniscate trajectory using ETC\n\n\n\n47\n\nFigure 4.12: Triggering condition for the lemniscate trajectory\n\nIn Table 4.2 we show a comparison between the four different implementations\n\nof each trajectory. We can observe that the event-triggered approach presents the best\n\nresults regarding the usage of the wireless transmission while still maintaining a good\n\ntracking of the reference trajectory as seen is Figures 4.8 and 4.11.\n\n4.5: Conclusion\n\nIn this chapter, we have presented the implementation and the results for both\n\nthe time-triggered and the event-triggered implementation of Jiang and Nijmeijer\u2019s con-\n\ntroller. In the first section, we have introduce the robot, and its details used during the\n\nimplementations. In subsequent sections, we have presented both the time-triggered\n\nas well as the event-triggered controller. At the end of this chapter, we compare the\n\ndifferent values of the usage equation for each trajectory, showing the advantages of\n\nthe event-triggered approach over the time-triggered approach.\n\n\n\n48\n\n5 Conclusions and perspectives\n\nThis document has presented the implementation of the event-triggered con-\n\ntroller for a nonholonomic mobile robot on the SAMI Benchmark. The experimentation\n\nresults showed that we can maintain a good tracking property of the reference trajec-\n\ntory with less use of the transmission channel. The triggering condition also proved to\n\nbe less sensitive to the measurement noise present at the experimentation, compared\n\nto the time-triggered approach.\n\nTo the author of this document, the research activities developed during this\n\nproject were extremely useful to give an insight in the research world. At the start of\n\nthis project, event-triggered control was a new concept that was never treated before\n\nduring the Control and Automation Engineering Course. The same thing can be said\n\nabout the trajectory tracking control. Even though the author of this report had some\n\nexperience with path following of robotic manipulators, applying the trajectory tracking\n\ncontrol in a mobile robot presented its challenges.\n\nThe perspective of future work, in short term, is to redesign the triggering condi-\n\ntion using a model-based approach. This approach was supposed to be studied during\n\nthe project, but because of the time limit of the project this approach will be studied in\n\na future work.\n\nAnother possible future project is to apply the knowledge acquired in this project\n\nto the trajectory tracking control of the AR.Drone Parrot, also available at the SAMI\n\nBenchmark. The AR.Drone Parrot is a quadricopter capable of hovering at small\n\nheights, making it possible to track a 3 dimensional trajectory. Giving its flight ca-\n\npabilities, the robot model would be a more complex one with model uncertainties.\n\nThe addition of more mobile robots, turning the system into a multi-agent system,\n\ncould also provide a good background for future works. Multiple robots sharing the\n\nsame communication channel could give a useful insight on how an event-triggered\n\napproach manages a busy multi-agent system.\n\n\n\n49\n\nReferences\n\n[1] JIANG, Z.-P.; NIJMEIJER, H. Tracking control of mobile robots: a case study in\nbackstepping. Automatica, v. 33, n. 7, p. 1393\u20131399, 1997.\n\n[2] CRAN, w. Serveur du CRAN. 2012. Available from internet:&lt;http://www.cran.uhp-\nnancy.fr/index.html>.\n\n[3] PIRES, L. C. A Mutiple Mobile Robots Testbed and a Game Theory Approach for\nCooperative Problems. 2010. UFSC.\n\n[4] KANAYAMA, Y. et al. A stable tracking control method for an autonomous mobile\nrobot. In: ICRA (IEEE International Conference on Robotics and Automation). [S.l.:\ns.n.]. p. 384\u2013389.\n\n[5] KOLMANOVSKY, I.; MCCLAMROCH, N. Developments in nonholonomic control\nproblems. Control Systems, IEEE, v. 15, n. 6, p. 20\u201336, 1995.\n\n[6] BLOCH, A.; MCCLAMROCH, N.; REYHANOGLU, M. Controllability and stabiliz-\nability properties of a nonholonomic control system. In: CDC (IEEE Conference on\nDecision and Control) Honolulu, U.S.A. [S.l.: s.n.]. p. 1312\u20131314.\n\n[7] HESPANHA, J.; LIBERZON, D.; MORSE, A. S. Towards the supervisory control\nof uncertain nonholonomic systems. In: American Control Conference. [S.l.: s.n.],\n1999. p. 3520\u20133524.\n\n[8] BICCHI, A. et al. Closed loop smooth steering of unicycle-like vehicles. In: CDC\n(IEEE Conference on Decision &amp; Control. Lake Buena Vista, FL: [s.n.], 1994. p.\n2455\u20132458.\n\n[9] AGUIAR, A.; ATASSI, A. N.; PASCOAL, A. M. Regulation of a nonholonomic dy-\nnamic wheeled mobile robot with parametric modeling uncertainty using lyapunov\nfunctions. In: CDC (IEEE Conference on Decision &amp; Control. Sydney, Australia:\n[s.n.], 2000. p. 1\u20136.\n\n[10] PANTELEY, E. et al. Exponential tracking control of a mobile car using a cascaded\napproach. In: IFAC Workshop on Motion Control, Grenoble, France. [S.l.: s.n.]. p.\n221\u2013226.\n\n[11] LEE, T.-C. et al. Tracking control of unicycle-modeled mobile robots using a satu-\nration feedback controller. IEEE Transactions on Control Systems Technology, v. 9,\nn. 2, p. 305\u2013318, 2001.\n\n[12] ARZE?N, K. A simple event-based PID controller. In: 14th IFAC World Congress,\nBeijing, China. [S.l.: s.n.], 1999.\n\n\n\n50\n\n[13] ASTROM, K.; BERNHARDSSON, B. Comparison of Riemann and Lebesgue\nsampling for first order stochastic systems. In: CDC (IEEE Conference on Decision\nand Control), Las Vegas, U.S.A. [S.l.: s.n.], 2002.\n\n[14] HEEMELS, W.; SANDEE, J.; BOSCH, P. van den. Analysis of event-driven con-\ntrollers for linear systems. International Journal of Control, v. 81, n. 4, p. 571\u2013590,\n2009.\n\n[15] OTANEZ, G.; MOYNE, J.; TILBURY, D. Using deadbands to reduce communica-\ntion in networked control systems. In: ACC (American Control Conference). [S.l.:\ns.n.], 2002.\n\n[16] TABUADA, P. Event-triggered real-time scheduling of stabilizing control tasks.\nIEEE Transactions on Automatic Control, v. 52, n. 9, p. 1680\u20131685, 2007.\n\n[17] WANG, X.; LEMMON, M. Event design in event-triggered feedback control sys-\ntems. In: ACC (American Control Conference) Seattle, U.S.A. [S.l.: s.n.], 2008. p.\n3139\u20133144.\n\n[18] TALLAPRAGADA, P.; CHOPRA, N. On event triggered trajectory tracking for\ncontrol affine nonlinear systems. In: Decision and Control and European Control\nConference (CDC-ECC), 2011 50th IEEE Conference on. [S.l.: s.n.], 2011. p. 5377\n\u2013 5382.\n\n[19] ANTA, A.; TABUADA, P. Exploiting isochrony in self-triggered control. Provisionally\naccepted for publication. arXiv 1009.5208, 2011.\n\n[20] FORNI, F. et al. Lazy sensors for the scheduling of measurement samples trans-\nmission in linear closed loops over networks. In: Decision and Control (CDC), 2010\n49th IEEE Conference on. [S.l.: s.n.], 2010. p. 6469 \u2013 6474.\n\n[21] POSTOYAN, R. et al. A unifying Lyapunov-based framework for the event-\ntriggered control of nonlinear systems. In: CDC / ECC (IEEE Conference on Decision\nand Control and European Control Conference) Orlando, U.S.A. [S.l.: s.n.], 2011.\n\n[22] POSTOYAN, R. et al. Emulation-based tracking solutions for nonlinear networked\ncontrol systems. In: CDC (IEEE Conference on Decision and Control). Hawai,\nU.S.A.: [s.n.], 2012.\n\n\n\n51\n\nAPPENDIX A -- Lemmas\n\nA.1: Barbalat\u2019s lemma\n\nLemma 1 If ? : R+ ? R is uniformly continuous and if the limit of the integral\nt?\n\n0\n\n?(?)d?\n\nexists as t ?? and is finite then\n\nlim\nt??\n\n?(t) = 0. (A.1)\n\nProof 1 See Popov (1973,p. 211).\n\nA.2: Lemma 2\n\nLemma 2 Consider a scalar system\n\nx? = ?cx + p(t), (A.2)\n\nwhere c > 0 and p(t) is a bounded and uniformly continuous function. If, for any initial\n\ntime t0 ? 0 and any initial condition x(t0), the solution x(t) is bounded and converges\nto 0 as t ?? then\n\nlim\nt??\n\np(t) = 0. (A.3)\n\nProof 2 See Jiang and Nijmeijer (1996).\n\n\n\n52\n\nAPPENDIX B -- Definitions\n\nB.1: L1 definition\n\nDefinition 1 The set L1[0,?) = L1 consists of all functions f : R+ ? R(R+ = [0,?)),\nwhich are measurable and satisfy\n\n? ?\n0\n\n|f(t)|1 dt &lt;? (B.1)\n\n\n\n53\n\nAPPENDIX C -- Equations\n\nC.1: Equations of vr and wr for the lemniscate trajectory\n\n\n\n54\n\nv\nr\n(t\n\n)\n=\n\n? (\na\n?\n\nsi\nn(\n?\nt)\n\n2\n\nsi\nn(\n?\nt)\n\n2\n+\n\n1\n?\n\na\n?\n\nc\no\ns(\n?\nt)\n\n2\n\nsi\nn(\n?\nt)\n\n2\n+\n\n1\n+\n\n2\na\n?\n\nc\no\ns(\n?\nt)\n\n2\nsi\n\nn(\n?\nt)\n\n2\n\n(s\nin\n\n(?\nt)\n\n2\n+\n\n1\n)2\n\n) 2 +\n( a?\n\nc\no\ns(\n?\nt)\n\nsi\nn(\n?\nt)\n\n2\n+\n\n1\n?\n\n2\na\n?\n\nc\no\ns(\n?\nt)\n\nsi\nn(\n?\nt)\n\n2\n\n(s\nin\n\n(?\nt)\n\n2\n+\n\n1\n)2\n\n) 2\n\nw\nr\n(t\n\n)\n=\n\n8\na\n?\n2\nc\no\ns(\n?\nt\n)\n3\ns\nin\n(\n?\nt\n)\n3\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)3\n\n?\n4\na\n?\n2\n\nc\no\ns(\n?\nt\n)\ns\nin\n(\n?\nt\n)\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n\n+\n6\na\n?\n2\n\nc\no\ns(\n?\nt\n)\ns\nin\n(\n?\nt\n)\n3\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n?\n6\na\n?\n2\nc\no\ns(\n?\nt\n)\n3\n\ns\nin\n(\n?\nt\n)\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\na\n?\n\nc\no\ns(\n?\nt\n)\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\n\n2\na\n?\n\nc\no\ns(\n?\nt\n)\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?a\n?\n\ns\nin\n(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\na\n?\n\nc\no\ns(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n\n+\n2\na\n?\n\nc\no\ns(\n?\nt\n)\n2\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?2\n? ?a\n\n?\nc\no\ns(\n?\nt\n)\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\n\n2\na\n?\n\nc\no\ns(\n?\nt\n)\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?2\n+\n\n1\n\n+\n\n? ?a\n?\n\ns\nin\n(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\na\n?\n\nc\no\ns(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n\n+\n2\na\n?\n\nc\no\ns(\n?\nt\n)\n2\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?? ?\n2\na\n?\n2\ns\nin\n(\n?\nt\n)\n3\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n?\na\n?\n2\n\ns\nin\n(\n?\nt\n)\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n\n+\n8\na\n?\n2\nc\no\ns(\n?\nt\n)\n2\ns\nin\n(\n?\nt\n)\n3\n\n(s\nin\n(\na\nlp\n\nh\na\nt\n)\n2\n+\n1\n)3\n\n?\n6\na\n?\n2\nc\no\ns(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?\n? ?a\n\n?\nc\no\ns(\n?\nt\n)\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\n\n2\na\n?\n\nc\no\ns(\n?\nt\n)\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?2\n? ?a\n\n?\ns\nin\n(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\na\n?\n\nc\no\ns(\n?\nt\n)\n2\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n\n+\n2\na\n?\n\nc\no\ns(\n?\nt\n)\n2\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?2\n? ?a\n\n?\nc\no\ns(\n?\nt\n)\n\ns\nin\n(\n?\nt\n)\n2\n+\n1\n?\n\n2\na\n?\n\nc\no\ns(\n?\nt\n)\ns\nin\n(\n?\nt\n)\n2\n\n(s\nin\n(\n?\nt\n)\n2\n+\n1\n)2\n\n? ?2\n+\n\n1\n\n.\n\n(C\n.1\n\n)"}]}}}