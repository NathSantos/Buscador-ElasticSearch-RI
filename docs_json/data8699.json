{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.11964"}, {"@name": "filename", "#text": "17400_PFC_20132-HenriqueBehr.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Desenvolvimento Solu\u00e7\u00e3o MES para \n\nunidade de A\u00e7os Longos \n\n \n\n \n\n \n\nRelat\u00f3rio submetido \u00e0 Universidade Federal de Santa Catarina \n\ncomo requisito para a aprova\u00e7\u00e3o na disciplina \n\nDAS 5511: Projeto de Fim de Curso \n\nHenrique Borba Behr \n\nFlorian\u00f3polis, Agosto de 2013\n\n\n\n \n\n 2 \n\n \n\n \n\nDesenvolvimento Solu\u00e7\u00e3o MES para unidade de A\u00e7os \n\nLongos \n\n \nHenrique Borba Behr \n\nEsta monografia foi julgada no contexto da disciplina  \n\nDAS5511: Projeto de Fim de Curso  \ne aprovada na sua forma final pelo \n\nCurso de Engenharia de Controle e Automa\u00e7\u00e3o \n\n \n\n \n\n \n\n \n\n \n\n \n\nMax Hering de Queiroz \n\n_______________________ \nAssinatura do Orientador \n\n\n\n \n\n 3 \n\n \n\n \n\nBanca Examinadora: \n\n \n\nWislann Alves dos Santos \nOrientador na Empresa \n\n \n \n\nMax Hering de Queiroz \nOrientador no Curso \n\n \n \n\nWislann Alves dos Santos \nOrientador na Empresa \n\n \n \n\nJos\u00e9 Eduardo Ribeiro Cury \nAvaliador \n\n \n \n\nGuilherme Bencke Teixeira da Silva \nJuliano Norio Marcondes Toda \n\nDebatedores \n \n\n \n\n\n\n \n\n 4 \n\nAgradecimentos \n\nAgrade\u00e7o: \n\nAo professor Max Hering de Queiroz pela orienta\u00e7\u00e3o.  \n\nAos engenheiros de controle e automa\u00e7\u00e3o Jo\u00e3o Zaiden e Wislann Alves dos \n\nSantos e a Engenheira de Software Turah Xavier de Almeida pela supervis\u00e3o do \n\nmeu trabalho. \n\n\u00c0 equipe de desenvolvimento do MES A\u00e7os Longos pelo suporte e auxilio. \n\n\u00c0 Beatriz Gietner pelo apoio e revis\u00e3o da monografia. \n\n \n\n \n\n\n\n \n\n 5 \n\nResumo \n\nEste PFC foi desenvolvido na empresa Radix Engenharia e Software, sendo \n\nesta uma empresa de servi\u00e7os que se prop\u00f5e a oferecer ao mercado servi\u00e7os e \n\nsolu\u00e7\u00f5es de engenharia e software. Sua principal participa\u00e7\u00e3o no mercado sempre \n\nfoi o de presta\u00e7\u00e3o de servi\u00e7os para a ind\u00fastria de petr\u00f3leo e petroqu\u00edmicas, \n\nentretanto existem tamb\u00e9m clientes das mais variadas \u00e1reas, os quais demandam \n\noutras solu\u00e7\u00f5es de engenharia, como: siderurgia, minera\u00e7\u00e3o, entretenimento, \n\nalimentos e transporte.  \n\nEsta monografia registra o desenvolvimento de um sistema de execu\u00e7\u00e3o de \n\nmanufatura (MES) para uma nova f\u00e1brica de A\u00e7os Longos em constru\u00e7\u00e3o. O projeto \n\nfoi feito em cima de uma plataforma web que ser\u00e1 acessado pelo navegador Internet \n\nExplorer. Para isso foram utilizadas diferentes ferramentas, as quais se destacam: a \n\nlinguagem de programa\u00e7\u00e3o C#, o framework web ASP .Net MVC3 (para construir o \n\nservidor onde est\u00e3o implementadas), o sistema gerenciador de banco de dados \n\nrelacional SQL Server (realiza\u00e7\u00e3o da persist\u00eancia dos dados), as linguagens Html, \n\nJavascript e jQuery (para exibir os dados e interagir com o usu\u00e1rio), requisi\u00e7\u00f5es \n\nAJAX (realizar comunica\u00e7\u00e3o entre o browser e o servidor), WebService e o protocolo \n\nPI (realizar a comunica\u00e7\u00e3o com o SAP) e um WebService com o protocolo XQI (para \n\ncomunica\u00e7\u00e3o com o n\u00edvel dois e demais sistemas perif\u00e9ricos).  \n\nO trabalho de desenvolvimento do MES envolve um meio termo entre o n\u00edvel \n\ndois (PLC?s, Scada, controles de m\u00e1quinas) e o n\u00edvel superior de controle de vendas \n\ne produ\u00e7\u00e3o, al\u00e9m de uma s\u00e9rie de informa\u00e7\u00f5es para serem controladas e \n\narmazenadas internamente. O MES inclui diversas funcionalidades, entre as \n\nprincipais destacam-se: programa\u00e7\u00e3o e controle da produ\u00e7\u00e3o, controle de estoques \n\nintermedi\u00e1rio e final, contabiliza\u00e7\u00e3o de uso dos equipamentos para a manuten\u00e7\u00e3o, \n\ncontrole de paradas da f\u00e1brica, inspe\u00e7\u00f5es e decis\u00f5es de qualidade, turno e \n\nrastreabilidade de lotes. \n\n\n\n \n\n 6 \n\nAbstract  \n\nThis project was developed in \u201cRadix Engenharia e Software\u201d, which is a \n\nservice company that intends to offer to the market services and engineering \n\nsolutions and software. Its main market share has always been to provide services \n\nfor the oil and petrochemical industry, however there are also clients from many \n\nareas, which require other engineering solutions: Steel, Mining, Entertainment, Food \n\nand Transportation, for example. \n\nThis monograph records the development of a manufacturing execution \n\nsystem (MES) for a new factory in Long Steel construction. The project was done \n\nover a web platform that will be accessed by Internet Explorer browser. For this we \n\nused different tools C# Programming Language ASP.Net MVC3 (framework) to build \n\nthe server where they are implemented, SQL Server (management system relational \n\ndatabase) to perform data persistence. Using Html, Javascript and jQuery to display \n\ndata and interact with the user. AJAX requests to communicate with the server \n\nbrowser. WebService and the IP protocol to perform communication with the SAP \n\nand a WebService with XQI protocol to communicate with the two levels. \n\nThe MES's development work revolves around a relation between the level \n\ntwo (PLC, SCADA, Controls Machines) and the higher level of sales and production \n\ncontrol, and a lot of information to be tracked and stored internally. The MES \n\nincludes several features, among the principal we can highlight: scheduling and \n\nproduction control, inventory control, intermediate and final accounting of use of the \n\nequipment for maintenance, control charts of factory inspections and quality \n\ndecisions, shift and traceability batch. \n\n\n\n \n\n 7 \n\nSum\u00e1rio:  \n\nAgradecimentos ................................................................................................ 4 \n\nResumo ............................................................................................................ 5 \n\nAbstract ............................................................................................................ 6 \n\nSum\u00e1rio: ........................................................................................................... 7 \n\nSimbologia ...................................................................................................... 10 \n\nCap\u00edtulo 1: Introdu\u00e7\u00e3o .................................................................................... 11 \n\n1.1: Contextualiza\u00e7\u00e3o com o Curso ............................................................ 13 \n\nCap\u00edtulo 2: Empresa ....................................................................................... 14 \n\n2.1: Radix Engenharia e Software .............................................................. 14 \n\n2.2: Sider\u00fargica ........................................................................................... 15 \n\n2.2.1: Aciaria: .......................................................................................... 16 \n\n2.2.2: Lamina\u00e7\u00e3o: .................................................................................... 19 \n\n2.2.3: Acabamento: ................................................................................. 20 \n\n2.3: Lugar do MES na fabrica\u00e7\u00e3o: .............................................................. 20 \n\nCap\u00edtulo 3: Fundamenta\u00e7\u00e3o te\u00f3rica ............................................................... 24 \n\n3.1: Ambiente de Desenvolvimento Integrado (IDE): .................................. 24 \n\n3.1.1: Ambiente do Projeto ...................................................................... 25 \n\n3.2: Linguagem Programa\u00e7\u00e3o ..................................................................... 25 \n\n3.2.1: Reutiliza\u00e7\u00e3o ................................................................................... 26 \n\n3.2.2: Vantagens da Orienta\u00e7\u00e3o a Objetos ............................................. 26 \n\n3.2.3: Linguagem Utilizada - C# .............................................................. 27 \n\n3.3: JavaScript ............................................................................................ 27 \n\n3.3.1: jQuery ............................................................................................ 28 \n\n\n\n \n\n 8 \n\n3.4: Modelo de dados ................................................................................. 29 \n\n3.4.1: Tecnologia Utilizada ...................................................................... 31 \n\n3.4.2: Documenta\u00e7\u00e3o e Constru\u00e7\u00e3o do Modelo ...................................... 31 \n\n3.5: Framework ........................................................................................... 32 \n\n3.5.1: Framework Radix .......................................................................... 32 \n\n3.5.2: Framework .NET ........................................................................... 34 \n\n3.5.3: Arquitetura MVC ............................................................................ 35 \n\n3.5.4: ASP .NET MVC ............................................................................. 36 \n\n3.6: Filosofias de Desenvolvimento: ........................................................... 39 \n\n3.6.1: Modelo Cascata ............................................................................ 40 \n\n3.6.2: Modelo Prototipa\u00e7\u00e3o ..................................................................... 41 \n\n3.6.3: Modelo Iterativo ............................................................................. 42 \n\n3.6.4: Desenvolvimento \u00c1gil de Software \u2013 Radix ................................... 42 \n\n3.6.5: Clean Code, C\u00f3digo Limpo: .......................................................... 44 \n\nCap\u00edtulo 4: Estrutura do Projeto ..................................................................... 48 \n\n4.1: Sistemas de Informa\u00e7\u00e3o necess\u00e1rios: ................................................. 48 \n\n4.2: Projeto MES ......................................................................................... 49 \n\n4.2.1: An\u00e1lise de Requisitos .................................................................... 50 \n\n4.2.2: Desenvolvimento ........................................................................... 51 \n\n4.2.3: Homologa\u00e7\u00e3o ................................................................................ 58 \n\nCap\u00edtulo 5: Descri\u00e7\u00e3o da Implementa\u00e7\u00e3o, M\u00f3dulo de Produ\u00e7\u00e3o: ................... 60 \n\n5.1: CRUD ................................................................................................... 60 \n\n5.2: Modulo de Programa\u00e7\u00e3o da Produ\u00e7\u00e3o ................................................ 62 \n\n5.2.1: Programa\u00e7\u00e3o Aciaria ..................................................................... 62 \n\n5.2.2: Programa\u00e7\u00e3o da Lamina\u00e7\u00e3o/Acabamento .................................... 63 \n\n5.3: Acompanhamento Produ\u00e7\u00e3o da Aciaria: ............................................. 64 \n\n\n\n \n\n 9 \n\n5.3.1: Casos de Uso ................................................................................ 64 \n\n5.3.2: Descri\u00e7\u00e3o da Implementa\u00e7\u00e3o ........................................................ 66 \n\nCap\u00edtulo 6: Conclus\u00f5es e Perspectivas .......................................................... 81 \n\nBibliografia: ..................................................................................................... 83 \n\n \n\n \n\n \n\n\n\n \n\n 1\n\n0 \n\nSimbologia \n\n \n\nA seguir: \n\nPFC \u2013 Projeto Final de Curso. \n\nMES \u2013 Sistema de execu\u00e7\u00e3o da Manufatura. \n\nSQL \u2013 Structured Query Language \n\nHTML \u2013 Hyper Text Markup Language. \n\nPLC \u2013 Controlador l\u00f3gico Program\u00e1vel. \n\nJS - JavaScript \n\nAJAX \u2013 Assynchronous Javascript and XML. \n\nSCADA \u2013 Supevisory Control and Data Acquisition. \n\njQuery  - Biblioteca de Javascript, usada para facilitar o desenvolvimento e \n\nmelhorar a interoperabilidade entre navegadores e vers\u00f5es diferentes. \n\nERP \u2013 Enterprise resource planning \n\nSAP \u2013 Implementa\u00e7\u00e3o de um ERP, mundialmente famosa e aceita. \n\nSGBD - Sistema de gerenciamento de banco de dados. \n\nOO \u2013 Orientado a Objetos. \n\nIDE \u2013 Ambiente de desenvolvimento Integrado. \n\n.NET \u2013 Dot Net Framework. \n\nCLR \u2013 Common Language Runtime \n\nMVC \u2013 Model View Controller \n\nCRUD - Create, read, update, delete \n\nSAP - Systeme, Anwendungen und Produkte in der Datenverarbeitung \n\n(Sistemas, Aplicativos e Produtos para Processamento de Dados). \n\n\n\n \n\n 1\n\n1 \n\nCap\u00edtulo 1: Introdu\u00e7\u00e3o \n\nA ind\u00fastria do a\u00e7o brasileira \u00e9 uma das mais competitivas do mundo. Vem \n\ngerando anualmente mais de R$ 45 bilh\u00f5es em valor adicionado para o Brasil \n\n(sendo respons\u00e1vel por um saldo comercial acima de US$ 4 bilh\u00f5es) o que significa \n\naproximadamente 18% do saldo comercial total do pa\u00eds. Al\u00e9m da grande \n\nmovimenta\u00e7\u00e3o de capital, vale ressaltar que as ind\u00fastrias de a\u00e7os empregam \n\natualmente cerca de 110 mil pessoas. O a\u00e7o est\u00e1 presente em diversos segmentos \n\nda ind\u00fastria, entre os quais: Automotivo, Constru\u00e7\u00e3o Civil, Embalagens, Linha \n\nBranca e OEM. \n\nExiste tamb\u00e9m uma grande competitividade de mercado, e esta tem exigido que \n\nas ind\u00fastrias aumentem cada vez mais sua efici\u00eancia de opera\u00e7\u00e3o, ao mesmo \n\ntempo reduzindo os custos e acelerando o ciclo produtivo sem comprometer a \n\nqualidade final do produto.  \n\nA fim de atingir tais objetivos, sistemas industriais de controle j\u00e1 s\u00e3o largamente \n\nempregados, assim como sistemas corporativos. Apesar de todo o avan\u00e7o nesses \n\nsistemas, a camada intermedi\u00e1ria entre o ch\u00e3o de f\u00e1brica e gest\u00e3o de neg\u00f3cios \u00e9, \n\npor vezes, ineficiente. Se, por um lado, os sistemas corporativos focam nas \n\nopera\u00e7\u00f5es financeiras, cont\u00e1beis e log\u00edsticas, os sistemas supervis\u00f3rios e de \n\ncontrole atuam na gest\u00e3o da opera\u00e7\u00e3o dos equipamentos e processos ao n\u00edvel do \n\nch\u00e3o de f\u00e1brica. O sistema MES surge ent\u00e3o como uma importante ferramenta para \n\nmonitorar o processo produtivo, auxiliando na resolu\u00e7\u00e3o de problemas de produ\u00e7\u00e3o \n\ne na melhoria cont\u00ednua do desempenho.  \n\nA integra\u00e7\u00e3o com os sistemas de automa\u00e7\u00e3o e corporativos permite ao MES \n\ncoletar todas as informa\u00e7\u00f5es relevantes ao gerenciamento da produ\u00e7\u00e3o e registr\u00e1-\n\nlas em um \u00fanico local e de modo organizado. O registro pode ser feito de modo \n\nmanual, atrav\u00e9s de telas de apontamento ou automaticamente a partir de interfaces \n\ncom sistemas PLC, Supervis\u00f3rios, PIMS, LIMS e SAP, entre outros. Os dados \n\ncoletados s\u00e3o processados pelo MES, ficando dispon\u00edveis para consultas futuras e \n\npara a gera\u00e7\u00e3o de indicadores para uma gest\u00e3o da produ\u00e7\u00e3o mais eficaz. Este \u00e9, \n\nportanto, um dos pontos diferenciais em termos de benef\u00edcios do sistema MES, j\u00e1 \n\n\n\n \n\n 1\n\n2 \n\nque ele fornece informa\u00e7\u00f5es para tomada de decis\u00e3o ou para investimentos em \n\na\u00e7\u00f5es que busquem melhorias cont\u00ednuas. Na pr\u00e1tica, tem se mostrado de grande \n\nvalia para o processo de melhoria cont\u00ednua e para uma gest\u00e3o eficiente da \n\nprodu\u00e7\u00e3o.  \n\nH\u00e1 funcionalidades t\u00edpicas comumente encontradas em sistemas MES. A \n\nespecifica\u00e7\u00e3o completa de um MES depende, no entanto, dos processos \n\ncaracter\u00edsticos de cada neg\u00f3cio.  \n\nDe maneira geral, o MES deve auxiliar os gestores da produ\u00e7\u00e3o no \n\ngerenciamento de recursos, metas, custos e qualidade, de forma a maximizar \n\nganhos e produtividade. O MES deve interagir com a programa\u00e7\u00e3o fina, \n\naumentando a velocidade de rea\u00e7\u00e3o a mudan\u00e7as na produ\u00e7\u00e3o e provendo \n\ninforma\u00e7\u00f5es confi\u00e1veis e em tempo real que melhorem a qualidade das decis\u00f5es.  \n\nO MES deve criar uma vis\u00e3o geral do fluxo de manufatura e aumentar n\u00e3o s\u00f3 a \n\nvelocidade do ciclo de produ\u00e7\u00e3o como tamb\u00e9m sua efici\u00eancia, a partir da \n\nidentifica\u00e7\u00e3o e redu\u00e7\u00e3o de tempos de fila, tempos mortos de processo, estoques e \n\nparadas de equipamentos. \n\nEste trabalho visa mostrar como foi realizado o projeto de desenvolvimento do \n\nMES para uma nova f\u00e1brica de a\u00e7os longos em constru\u00e7\u00e3o, sempre focando na \n\nparte do projeto que se relaciona ao curso de Engenharia de Controle e Automa\u00e7\u00e3o \n\ncom o objetivo de consolidar os conhecimentos adquiridos durante o curso. \n\nO primeiro cap\u00edtulo desta monografia trata da contextualiza\u00e7\u00e3o do projeto \n\ndesenvolvido na RADIX dentro do curso de Engenharia de Controle e Automa\u00e7\u00e3o. \n\nEm seguida, no segundo cap\u00edtulo, \u00e9 apresentada uma vis\u00e3o geral sobre a empresa \n\nem que o trabalho foi desenvolvido, o cliente e a f\u00e1brica onde a solu\u00e7\u00e3o ser\u00e1 \n\nimplantada. J\u00e1 no cap\u00edtulo tr\u00eas h\u00e1 o desenvolvimento da explica\u00e7\u00e3o acerca de \n\nmetodologias de desenvolvimento utilizadas, framework e ferramentas. No quarto \n\ncap\u00edtulo est\u00e1 sucintamente exibida a estrutura do projeto e o trabalho das diversas \n\nequipes que fizeram o software. Para terminar, no quinto cap\u00edtulo encontra-se o \n\ndetalhamento das funcionalidades mais importantes que foram desenvolvidas por \n\nmim no projeto. \n\n \n\n\n\n \n\n 1\n\n3 \n\n1.1: Contextualiza\u00e7\u00e3o com o Curso \n\nO projeto desenvolvido se enquadra em diversas \u00e1reas do curso de \n\nEngenharia e Controle e Automa\u00e7\u00e3o: \n\n? Boas pr\u00e1ticas de programa\u00e7\u00e3o, modulariza\u00e7\u00e3o de c\u00f3digo, boa legibilidade \n\ndo c\u00f3digo e separa\u00e7\u00e3o de fun\u00e7\u00f5es (dados, controladores, views) s\u00e3o \n\nalguns dos assuntos aprendidos nas disciplinas de base, como em \n\nIntrodu\u00e7\u00e3o \u00e0 Inform\u00e1tica para Automa\u00e7\u00e3o e Fundamentos da Estrutura da \n\nInforma\u00e7\u00e3o; \n\n? An\u00e1lise de requisitos, aplica\u00e7\u00e3o de metodologias de desenvolvimento e \n\nprograma\u00e7\u00e3o orientada a objetos foram estudados em Metodologia para \n\nDesenvolvimento de Sistemas; \n\n? Conceitos de programa\u00e7\u00e3o concorrente vistos na disciplina de Inform\u00e1tica \n\nIndustrial II; \n\n? Conceitos da disciplina de Processos de Fabrica\u00e7\u00e3o Metal-mec\u00e2nica  \n\ncomo fundi\u00e7\u00e3o e lamina\u00e7\u00e3o de a\u00e7o. Tamb\u00e9m houve um conhecimento \n\nmais amplo sobre a \u00e1rea de controle de manufatura, planejamento de \n\nprodu\u00e7\u00e3o e qualidade, conceitos estes estudados em Sistemas Integrados \n\nde Manufatura;  \n\n? T\u00e9cnicas de interoperabilidade entre sistemas aprendidos na disciplina de \n\nIntegra\u00e7\u00e3o de Sistemas Corporativos. \n\n \n\n\n\n \n\n 1\n\n4 \n\nCap\u00edtulo 2: Empresa \n\nNeste cap\u00edtulo ser\u00e3o apresentadas a empresa onde o projeto foi \n\ndesenvolvido, um pouco sobre o processo de fabrica\u00e7\u00e3o do cliente e a planta onde o \n\nprojeto vai ser executado. \n\n \n\n2.1: Radix Engenharia e Software \n\n \n\nA Radix foi fundada no Rio de Janeiro em 2010, com estimativa de somar 100 \n\nfuncion\u00e1rios j\u00e1 no primeiro ano de atua\u00e7\u00e3o. Ela nasceu como uma empresa \n\nespecializada em servi\u00e7os e solu\u00e7\u00f5es de TI e engenharia para ind\u00fastrias de \n\nprocesso (principalmente \u00f3leo e g\u00e1s, petroqu\u00edmicas e qu\u00edmicas), mas ao longo \n\ndesses 3 anos de funcionamento, devido a excel\u00eancia de seus projetos, conseguiu \n\numa gama de clientes dos mais variados setores dos quais alguns principais: \n\n\u00d3leo e g\u00e1s/Petroqu\u00edmica: Petrobras, AkerSolutions, OGX e Queiroz Galv\u00e3o. \n\nSiderurgia e Minera\u00e7\u00e3o: CSN e Vale. \n\nEntretenimento: Rede Globo e iMusica. \n\nQu\u00edmica: FosBrasil. \n\nFarmac\u00eautica: Laborvida. \n\nTransporte: Supervia. \n\nCom apenas tr\u00eas anos de mercado, j\u00e1 \u00e9 uma empresa posicionada fortemente \n\nno mercado de engenharia. Suas principais \u00e1reas de atua\u00e7\u00e3o s\u00e3o: \n\n? Projetos de Engenharia: projetos conceituais, avalia\u00e7\u00f5es t\u00e9cnico-\n\necon\u00f4micas de unidades de processo. Simula\u00e7\u00e3o e otimiza\u00e7\u00e3o de \n\nprocessos.   \n\n? TI Industrial: servi\u00e7os para informa\u00e7\u00e3o e automa\u00e7\u00e3o de unidades \n\nindustriais. Auditoria e sintonia de malhas de controle, controle \n\n\n\n \n\n 1\n\n5 \n\navan\u00e7ado, gerenciamento de alarme, planejamento da produ\u00e7\u00e3o, \n\ngerenciamento de dados. \n\n \n\n? Software: solu\u00e7\u00f5es tecnol\u00f3gicas sob demanda para diversos \n\nsegmentos, como ind\u00fastrias, portais, m\u00eddia e entretenimento. Aplica\u00e7\u00f5es \n\nWeb, aplicativos m\u00f3veis nativos (iOS, Android) e Web responsivos, \n\nal\u00e9m de servi\u00e7os de especifica\u00e7\u00e3o de requisitos, testes e avalia\u00e7\u00e3o de \n\nseguran\u00e7a da informa\u00e7\u00e3o. \n\n \n\nFigura 1 - \u00c1reas de Atua\u00e7\u00e3o da Radix \n\n \n\n2.2: Sider\u00fargica \n\n \n\nO presente trabalho se situa no segmento de a\u00e7os longos, numa das maiores \n\nempresas do setor, fundada em 1941 pelo ent\u00e3o presidente Get\u00falio Vargas. Sua \n\nprincipal f\u00e1brica est\u00e1 situada na cidade de Volta Redonda, RJ. \n\nA sider\u00fargica \u00e9 uma empresa de capital aberto, que atua no segmento e em \n\ndiversos outros setores ligados \u00e0 siderurgia (minera\u00e7\u00e3o, cimento, log\u00edstica e \n\n\n\n \n\n 1\n\n6 \n\nenergia). Ela teve no ano de 2012 um faturamento de aproximadamente 16 Bilh\u00f5es \n\nde reais. \n\nEla abrange (na \u00e1rea de siderurgia) toda a cadeia produtiva do a\u00e7o, desde a \n\nextra\u00e7\u00e3o do min\u00e9rio de ferro at\u00e9 a produ\u00e7\u00e3o e comercializa\u00e7\u00e3o de uma diversificada \n\nlinha de produtos sider\u00fargicos de alto valor agregado. \n\nNo ano de 2012, a usina produziu 4,8 milh\u00f5es de toneladas de a\u00e7o bruto, \n\nenquanto comparativamente a produ\u00e7\u00e3o de laminados atingiu 4,7 milh\u00f5es de \n\ntoneladas. \n\nA empresa vem trabalhando na diversifica\u00e7\u00e3o de suas atividades sider\u00fargicas \n\ncom a entrada no segmento de a\u00e7os longos por meio da constru\u00e7\u00e3o de uma \n\nunidade em Volta Redonda, tendo esta capacidade de produ\u00e7\u00e3o de 500 mil \n\ntoneladas anuais (abrangendo desde vergalh\u00f5es a fios-m\u00e1quina).  \n\nA seguir ser\u00e1 exposta a estrutura de produ\u00e7\u00e3o de uma f\u00e1brica de a\u00e7os \n\nlongos, onde o MES ser\u00e1 implantado. \n\n \n\n2.2.1: Aciaria: \n\n \n\nAciaria \u00e9 a unidade de uma usina sider\u00fargica onde existem m\u00e1quinas e \n\nequipamentos voltados para o processo de fundi\u00e7\u00e3o do ferro gusa e sucatas. \n\nNo processo de aciaria el\u00e9trica \u00e9 produzido o a\u00e7o fundido que \u00e9 utilizado na \n\nprodu\u00e7\u00e3o de tarugos, os quais s\u00e3o produtos semiacabados que ir\u00e3o posteriormente \n\nser transformados nos produtos finais por outras unidades. \n\n \n\nFigura 2 - Interior de uma Aciaria \n\n\n\n \n\n 1\n\n7 \n\n2.2.1.1: Forno el\u00e9trico a Arco \n\nO processo se inicia quando sucata \u00e9 misturada ao ferro-gusa e ent\u00e3o s\u00e3o \n\nambos inseridos no forno el\u00e9trico a arco com o objetivo de serem fundidos por meio \n\nde um arco el\u00e9trico.  \n\nNo forno el\u00e9trico, tr\u00eas eletrodos de grafite formam um arco el\u00e9trico cuja \n\nenergia transferida \u00e9 capaz de aquecer a carga met\u00e1lica e promover sua completa \n\nfus\u00e3o. Ap\u00f3s a fus\u00e3o, inicia-se o tratamento do metal l\u00edquido e alguns elementos \n\nindesej\u00e1veis s\u00e3o removidos como, por exemplo, o f\u00f3sforo.  \n\n \n\nFigura 3 - Forno el\u00e9trico a Arco \n\n2.2.1.2: Forno Panela: \n\nAp\u00f3s a fus\u00e3o e in\u00edcio do processo de refino no forno el\u00e9trico a arco, o a\u00e7o \n\nl\u00edquido \u00e9 transferido para uma panela. No forno-panela \u00e9 poss\u00edvel controlar a \n\ntemperatura do metal l\u00edquido e, mediante inje\u00e7\u00e3o de um g\u00e1s inerte, propiciar \n\n\n\n \n\n 1\n\n8 \n\ncondi\u00e7\u00f5es controladas de agita\u00e7\u00e3o. Assim, ocorre a homogeneiza\u00e7\u00e3o t\u00e9rmica do \n\nmetal e de todas as ferro-ligas adicionadas para atingir a composi\u00e7\u00e3o qu\u00edmica \n\ndesejada do a\u00e7o. \n\n \n\nFigura 4 - Forno Panela \n\n2.2.1.3: Lingotamento Continuo: \n\nO a\u00e7o refinado passa pelo pr\u00f3ximo processo de lingotamento cont\u00ednuo: o a\u00e7o \n\nliquido \u00e9 for\u00e7ado por moldes de resfriamento para se solidificar e ent\u00e3o atravessa \n\num cortador onde adquire o formato final de tarugo. O tarugo \u00e9 um produto \n\nsemiacabado, que j\u00e1 pode ser vendido dependendo das condi\u00e7\u00f5es do mercado, ou \n\nser usado para abastecer as pr\u00f3ximas unidades para produzir um produto final de \n\nmaior valor agregado. \n\n\n\n \n\n 1\n\n9 \n\n \n\nFigura 5 - Lingotamento Continuo \n\n2.2.1.4: P\u00e1tio de Tarugos: \n\nComo processo intermedi\u00e1rio, os tarugos s\u00e3o armazenados no p\u00e1tio at\u00e9 a \n\nhora de serem abastecidos na unidade de lamina\u00e7\u00e3o. \n\n \n\n2.2.2: Lamina\u00e7\u00e3o: \n\nOs tarugos que v\u00eam do p\u00e1tio s\u00e3o abastecidos na unidade de lamina\u00e7\u00e3o. O \n\nprocesso de lamina\u00e7\u00e3o inicia com o reaquecimento do tarugo em um forno que \n\neleva sua temperatura at\u00e9 uma faixa entre 1000 e 1200 \u00b0C. \n\nPara a elabora\u00e7\u00e3o dos produtos longos o a\u00e7o passa por um trem de \n\nlamina\u00e7\u00e3o. L\u00e1 ele \u00e9 espremido entre canais cada vez mais finos de cilindros \n\nalocados horizontalmente e verticalmente. No fim do processo s\u00e3o produzidos \n\ndiferentes tipos de a\u00e7o vergalh\u00f5es/feixes com formas de acordo com a \n\nespecifica\u00e7\u00e3o, ou o a\u00e7o \u00e9 enrolado para produzir bobinas. \n\n \n\n\n\n \n\n 2\n\n0 \n\n \n\nFigura 6 - Processo de Lamina\u00e7\u00e3o \n\n \n\n \n\nFigura 7 - Bobinas produzidas na fase de lamina\u00e7\u00e3o \n\n2.2.3: Acabamento: \n\n \n\nPor \u00faltimo, os feixes e as bobinas produzidos podem ainda passar pelo \n\nprocesso final de acabamento onde ent\u00e3o aqueles podem vir a passar por um \n\nprocesso de dobragem e estes a passar pelas m\u00e1quinas de endireitadeira j\u00e1 no \n\nsetor final de acabamento. \n\n \n\n2.3: Lugar do MES na fabrica\u00e7\u00e3o: \n\n \n\nO MES \u00e9 um sistema que visa coletar e agrupar informa\u00e7\u00f5es de sistemas de \n\nprodu\u00e7\u00e3o (n\u00edvel 2). Ele \u00e9 capaz de organizar e armazenar dados para ent\u00e3o \n\n\n\n \n\n 2\n\n1 \n\ndisponibiliz\u00e1-los aos supervisores da produ\u00e7\u00e3o que, por sua vez, ir\u00e3o analisar o \n\ndesempenho e tomar uma decis\u00e3o mais precisa. Em seguida agrupam-se os dados \n\nda produ\u00e7\u00e3o para envia-los para um n\u00edvel acima, denominado sistema de \n\nplanejamento e vendas \u201cERP\u201d.  \n\nO MES tamb\u00e9m realiza o caminho inverso: ele recebe informa\u00e7\u00f5es gen\u00e9ricas \n\nde produ\u00e7\u00e3o do sistema de planejamento e possibilita aos operadores montar a \n\nprograma\u00e7\u00e3o que ser\u00e1 realizada a cada instante e envia essa informa\u00e7\u00e3o ao n\u00edvel 2, \n\n(que ir\u00e1 produzir de acordo com a programa\u00e7\u00e3o). \n\nAl\u00e9m destas, o sistema tem outra gama de funcionalidades pr\u00f3prias que s\u00e3o \n\nnecess\u00e1rias para o bom funcionamento da f\u00e1brica: \n\n? Cadastros Gerais: s\u00e3o as informa\u00e7\u00f5es gerais usadas pelos demais \n\nm\u00f3dulos da aplica\u00e7\u00e3o e tamb\u00e9m informa\u00e7\u00f5es que o n\u00edvel 2 precisa por\u00e9m \n\nn\u00e3o tem como cadastrar, como por exemplo: locais, equipamentos de \n\nlaborat\u00f3rio e justificativas de paradas. \n\n? Seguran\u00e7a: contempla l\u00f3gicas de seguran\u00e7a da aplica\u00e7\u00e3o, assim como \n\ncontrole de permiss\u00f5es e acesso com autentica\u00e7\u00e3o via rede. \n\n? Hist\u00f3rico de banco de dados: todos os dados da aplica\u00e7\u00e3o tem que \n\nficarem salvos no banco de produ\u00e7\u00e3o, os quais de tempos em tempos \n\nser\u00e3o migrados do banco operacional para um banco hist\u00f3rico com o \n\nobjetivo de garantir o bom desempenho. \n\n? Auditoria: onde todas as mudan\u00e7as realizadas no banco pelo usu\u00e1rio do \n\nsistema dever\u00e3o ser registradas. \n\n? M\u00f3dulo de produ\u00e7\u00e3o: contempla as funcionalidades de programa\u00e7\u00e3o e \n\nreprograma\u00e7\u00e3o da produ\u00e7\u00e3o das \u00e1reas de aciaria, lamina\u00e7\u00e3o e \n\nacabamento, al\u00e9m de ser poss\u00edvel observar tamb\u00e9m o acompanhamento \n\nda produ\u00e7\u00e3o. \n\n? Rastreabilidade da produ\u00e7\u00e3o: possibilita ao usu\u00e1rio consultar os dados de \n\num lote antigo. Com essa funcionalidade \u00e9 poss\u00edvel rastrear e mostrar \n\ncada insumo utilizado para se produzir um lote e os seus dados de \n\nqualidade apontados no MES. \n\n\n\n \n\n 2\n\n2 \n\n? Apontamento de produ\u00e7\u00e3o: \u00e9 poss\u00edvel apontar as entradas (insumos, \n\nmat\u00e9rias-primas) e as sa\u00eddas (produtos) para cada fase da produ\u00e7\u00e3o. \n\n? Comparativo realizado x programado: poder\u00e1 ser comparado o que est\u00e1 \n\nde fato sendo produzido com o que est\u00e1 sendo programado. \n\n? Tratamento de ocorr\u00eancias: essa funcionalidade contempla o registro e \n\nconsulta das ocorr\u00eancias de anormalidades nas opera\u00e7\u00f5es de produ\u00e7\u00e3o, \n\nas quais tamb\u00e9m ser\u00e3o usadas para fins de rastreabilidade da produ\u00e7\u00e3o. \n\n? Reclassifica\u00e7\u00e3o de a\u00e7o: o sistema permite a reclassifica\u00e7\u00e3o de lotes da \n\naciaria para materiais diferentes daqueles no qual estavam primeiramente \n\nprogramados. \n\n? Controle de sucata: nesta funcionalidade \u00e9 poss\u00edvel o apontamento de \n\nsucatas geradas em cada opera\u00e7\u00e3o da produ\u00e7\u00e3o para todas as \u00e1reas, \n\ncomo tamb\u00e9m o envio destes ser enviados ao SAP para consolida\u00e7\u00e3o dos \n\ncustos de produ\u00e7\u00e3o. \n\n? Apontamento/Inspe\u00e7\u00e3o de qualidade dos produtos: an\u00e1lises de produtos \n\nintermedi\u00e1rios e finais. Tamb\u00e9m \u00e9 poss\u00edvel o posterior lan\u00e7amento de uma \n\ninspe\u00e7\u00e3o com o objetivo de averiguar se o bloqueio de material deve ser \n\nmantido. \n\n? Gest\u00e3o de an\u00e1lise laboratorial: apontamento manual e a importa\u00e7\u00e3o \n\nautom\u00e1tica (sistemas de automa\u00e7\u00e3o e SAP) de an\u00e1lises laboratoriais \n\nexecutadas para posterior verifica\u00e7\u00e3o de seus resultados \n\n? M\u00f3dulo de paradas: \u00e9 respons\u00e1vel pela gest\u00e3o das paradas de \n\nequipamentos ocorridas no ambiente de produ\u00e7\u00e3o, existe tanto na vers\u00e3o \n\nmanual quanto autom\u00e1tica. \n\n? M\u00f3dulo de manuten\u00e7\u00e3o (Campanha): neste m\u00f3dulo est\u00e3o as fun\u00e7\u00f5es de \n\ngerenciamento da manuten\u00e7\u00e3o de equipamentos de campanha, cilindros e \n\noutros consum\u00edveis. \n\n? M\u00f3dulo de invent\u00e1rios (estoques e expedi\u00e7\u00e3o): fun\u00e7\u00f5es de gerenciamento \n\nde estoques e expedi\u00e7\u00e3o do sistema. \n\n\n\n \n\n 2\n\n3 \n\n? Emiss\u00e3o / Reimpress\u00e3o de etiquetas: etiquetas de produtos intermedi\u00e1rios \n\ne finais numa impressora Zebra. \n\n? Relat\u00f3rios: dentre os principais destacam-se o relat\u00f3rio de produ\u00e7\u00e3o e o \n\nrelat\u00f3rio de rendimento. \n\n  \n\n\n\n \n\n 2\n\n4 \n\nCap\u00edtulo 3: Fundamenta\u00e7\u00e3o te\u00f3rica \n\nNo escopo do projeto de desenvolvimento de MES para sider\u00fargica foram \n\nusados diversos conte\u00fados das disciplinas na \u00e1rea de software do curso de \n\nEngenharia de Controle e Automa\u00e7\u00e3o. Neste cap\u00edtulo ser\u00e3o apresentados t\u00f3picos \n\nreferentes \u00e0 \u00e1rea de programa\u00e7\u00e3o e TI industriais que auxiliar\u00e3o no entendimento \n\ndeste projeto.  \n\n \n\n3.1: Ambiente de Desenvolvimento Integrado (IDE):  \n\n \n\nPreocupados com o aumento da competitividade no mercado de software, \n\nempresas competitivas aderiram aos IDEs como ferramentas indispens\u00e1veis de \n\nprodu\u00e7\u00e3o. O IDE \u00e9 um programa de computador utilizado para aumentar a \n\nprodutividade dos desenvolvedores de software bem como a qualidade desses \n\nprodutos. Alguns dos melhores IDEs possuem diversas ferramentas embutidas, as \n\nquais ajudam o desenvolvedor, por exemplo:  \n\n? Editor: edita o c\u00f3digo fonte e usa uma gama de cores para diferenciar: \n\nclasses, fun\u00e7\u00f5es, vari\u00e1veis, melhorando a visualiza\u00e7\u00e3o e o \n\nentendimento. Capaz de indicar erros no programa antes mesmo de \n\nele ser compilado. \n\n? Compilador: tem como principal fun\u00e7\u00e3o fazer a tradu\u00e7\u00e3o do c\u00f3digo \n\nfonte em um formato que o compilador pode entender. \n\n? Linker: liga o c\u00f3digo objeto \u00e0s bibliotecas e transforma tudo em um \n\n\u00fanico execut\u00e1vel. \n\n? Carregador: carrega o programa na mem\u00f3ria e executa com apenas \n\num clique para facilitar o trabalho. \n\n? Depurador: ajuda o programador na verifica\u00e7\u00e3o e corre\u00e7\u00e3o de erros. \n\n? Distribui\u00e7\u00e3o: auxilia o processo de cria\u00e7\u00e3o do instalador. \n\n\n\n \n\n 2\n\n5 \n\n? Refatora\u00e7\u00e3o: combina poderosas ferramentas de refatora\u00e7\u00e3o que \n\npermite substituir nomes em diferentes arquivos de diferentes projetos \n\ncom um clique. \n\n \n\n3.1.1: Ambiente do Projeto \n\n \n\nO ambiente de desenvolvimento utilizado na codifica\u00e7\u00e3o do software foi o \n\nMicrosoft Visual Studio 2010, sendo este um ambiente integrado de \n\ndesenvolvimento constru\u00eddo pela Microsoft. O Visual Studio \u00e9 flex\u00edvel, possibilitando \n\ndesenvolver desde aplica\u00e7\u00f5es de console, aplica\u00e7\u00f5es com interface gr\u00e1fica e at\u00e9 \n\nwebsites (aplica\u00e7\u00f5es e servi\u00e7os web). Ele suporta diferentes linguagens, como as \n\nb\u00e1sicas C e C++, at\u00e9 linguagens mais complexas orientadas a objeto, como Visual \n\nBasic, C# e F#. Uma das vantagens de se utilizar o ambiente de desenvolvimento \n\ndo Visual Studio \u00e9 a facilidade de integra\u00e7\u00e3o com os outros servi\u00e7os da Microsoft: \n\nbanco de dados, usu\u00e1rios da rede da MS e tamb\u00e9m a exporta\u00e7\u00e3o de dados para o \n\nExcel. \n\n \n\n3.2: Linguagem Programa\u00e7\u00e3o \n\n \n\nO advento do computador pessoal deu o impulso definitivo \u00e0 \u00e1rea de \n\ncomputa\u00e7\u00e3o. Hoje em dia \u00e9 indiscut\u00edvel a presen\u00e7a e a import\u00e2ncia dos sistemas \n\ncomputadorizados no mundo todo, tanto no setor produtivo quanto para uso \n\npessoal.  \n\nPara atender as necessidades do mercado, sistemas complexos com \n\nmilhares de linhas de c\u00f3digo s\u00e3o produzidos todos os anos. Tornou-se imperativo \n\nlidar com a crescente complexidade do desenvolvimento de software.  O paradigma \n\nda Orienta\u00e7\u00e3o a Objetos (OO) \u00e9 um dos maiores avan\u00e7os na \u00e1rea de software, \n\nsendo tamb\u00e9m uma evolu\u00e7\u00e3o natural da programa\u00e7\u00e3o estruturada. Com seu \n\nadvento, foi poss\u00edvel visualizar um programa como sendo uma rede de \n\n\n\n \n\n 2\n\n6 \n\nrelacionamento entre objetos, dividindo a complexidade do sistema em pequenas \n\nunidades l\u00f3gicas, que, por sua vez, tornou-as mais facilmente gerenci\u00e1veis.  \n\nA programa\u00e7\u00e3o orientada a objetos \u00e9 uma solu\u00e7\u00e3o mais natural e intuitiva \n\nporque no mundo f\u00edsico cada objeto tem um papel definido (por exemplo um garfo \n\nou uma caneta). Podemos dizer que todo objeto tem uma ou mais finalidades e \n\ncaracter\u00edsticas f\u00edsicas representadas na programa\u00e7\u00e3o orientada a objetos como \n\nm\u00e9todos e atributos, respectivamente.  \n\n3.2.1: Reutiliza\u00e7\u00e3o \n\nA reutiliza\u00e7\u00e3o est\u00e1 baseada na padroniza\u00e7\u00e3o, sendo esta adotada h\u00e1 longa \n\ndata em toda ind\u00fastria moderna, indo desde o projeto de carros at\u00e9 televisores, \n\ncomputadores, etc. A padroniza\u00e7\u00e3o traz in\u00fameras vantagens, entre elas citam-se: \n\n? redu\u00e7\u00e3o de custo;  \n\n? aumento da confiabilidade; \n\n? facilidade de reparo e manuten\u00e7\u00e3o. \n\n3.2.2: Vantagens da Orienta\u00e7\u00e3o a Objetos \n\n? H\u00e1 maior facilidade para reutiliza\u00e7\u00e3o de c\u00f3digo (esta \u00e9 a principal \n\nvantagem da programa\u00e7\u00e3o orientada a objetos).  \n\n? Possibilita a agrega\u00e7\u00e3o de m\u00f3dulos prontos porque estes podem ser \n\nagregados ao longo do projeto (atrav\u00e9s da importa\u00e7\u00e3o de suas \n\nfuncionalidades) mesmo tendo seu desenvolvimento separado. \n\n? Possibilita ao desenvolvedor trabalhar em um n\u00edvel mais elevado de \n\nabstra\u00e7\u00e3o. \n\n? Exige um menor custo de desenvolvimento (pode-se desenvolver mais \n\npor menos). Os m\u00f3dulos j\u00e1 prontos podem ser agregados a novos \n\nprojetos. \n\n\n\n \n\n 2\n\n7 \n\n3.2.3: Linguagem Utilizada - C# \n\nA linguagem C# faz parte do conjunto de ferramentas oferecidas na \n\nplataforma .NET (explicada posteriormente em 3.5.2:) e surge como uma linguagem \n\nsimples, robusta, orientada a objetos, fortemente tipada e altamente escal\u00e1vel (a fim \n\nde permitir que uma mesma aplica\u00e7\u00e3o possa ser executada em diversos dispositivos \n\nde hardware, independentemente destes serem PCs ou um  dispositivo m\u00f3vel). \n\n O C# tem ra\u00edzes em C, C++ e Java, adaptando os melhores recursos de cada \n\nlinguagem e acrescentando novas capacidades pr\u00f3prias. Ele fornece os recursos \n\nque s\u00e3o mais importantes para os programadores, como programa\u00e7\u00e3o orientada a \n\nobjetos, strings, elementos gr\u00e1ficos, componentes de interface com o usu\u00e1rio (GUI), \n\ntratamento de exce\u00e7\u00f5es, m\u00faltiplas linhas de execu\u00e7\u00e3o, multim\u00eddia (\u00e1udio, imagens, \n\nanima\u00e7\u00e3o e v\u00eddeo), processamento de arquivos, estruturas de dados pr\u00e9-\n\nempacotadas, processamento de banco de dados, redes cliente/servidor com base \n\nna internet e computa\u00e7\u00e3o distribu\u00edda. \n\n   \n\n3.3: JavaScript \n\nJavaScript (JS) \u00e9 uma linguagem de programa\u00e7\u00e3o interpretada (n\u00e3o precisa \n\nser compilada) que roda diretamente nos navegadores web, permitindo que scripts \n\npossam ser executados do lado do cliente e interajam com o usu\u00e1rio sem a \n\nnecessidade deste script passar pelo servidor. O JS tem a capacidade de controlar o \n\nnavegador, enviar requisi\u00e7\u00f5es ass\u00edncronas para o servidor e alterar o conte\u00fado do \n\ndocumento exibido.  \n\n\u00c9 atualmente a principal linguagem para programa\u00e7\u00e3o cliente-side em \n\nnavegadores web. Foi concebida para ser uma linguagem script com orienta\u00e7\u00e3o a \n\nobjetos baseada em prot\u00f3tipos e din\u00e2mica. Criada em 1995 com o nome de \n\nLiveScript, foi primeiramente lan\u00e7ada para o navegador Netscape. Este j\u00e1 n\u00e3o se \n\nencontra mais ativo, por\u00e9m o JavaScript adquiriu ampla aceita\u00e7\u00e3o como linguagem \n\nde navegador.  \n\nAs principais caracter\u00edsticas desta linguagem s\u00e3o: \n\n\n\n \n\n 2\n\n8 \n\n? Tipagem din\u00e2mica: tipos s\u00e3o associados como valor e n\u00e3o como \n\nvari\u00e1veis. Por exemplo, a vari\u00e1vel \u201cx\u201d pode ser associada a um n\u00famero \n\ne mais tarde associada a uma cadeia de caracteres. \n\n? Baseada em objetos: objetos JS s\u00e3o arrays associativos, aumentados \n\ncom prot\u00f3tipos. Os objetos tamb\u00e9m s\u00e3o din\u00e2micos, suas propriedades e \n\nseus valores podem ser adicionados, alterados ou destru\u00eddos em tempo \n\nde execu\u00e7\u00e3o.  \n\nO uso prim\u00e1rio do JS \u00e9 o de escrever fun\u00e7\u00f5es que ser\u00e3o inclu\u00eddas nas p\u00e1ginas \n\nHTML, e essas fun\u00e7\u00f5es ir\u00e3o interagir com o usu\u00e1rio de diversas formas como \n\nabrindo uma nova janela (pop-up), validando valores de um formul\u00e1rio para garantir \n\nque s\u00e3o aceit\u00e1veis antes de enviar ao servidor, mudando imagens e melhorando a \n\ninterface gr\u00e1fica. O fato do JS rodar localmente no navegador do usu\u00e1rio, e n\u00e3o em \n\num servidor remoto, possui dois benef\u00edcios: o usu\u00e1rio tem uma resposta muito mais \n\n\u00e1gil do que se tivesse que esperar a resposta do servidor, e o servidor fica com uma \n\ncarga menor, garantindo maior velocidade. \n\n  \n\n3.3.1: jQuery \n\nAntigamente escrever c\u00f3digo em JavaScript era uma tarefa tediosa e \n\ncustosa, resultando em altos custos para se desenvolver uma pequena \n\nfuncionalidade. Com o passar do tempo, diversos programadores desenvolveram \n\nbibliotecas de auxilio \u00e0 programa\u00e7\u00e3o. A jQuery \u00e9 uma das mais famosas bibliotecas \n\nque se tem no mercado. Ela foi criada por John Resig em 2006, e ele definiu sua \n\ncria\u00e7\u00e3o assim: \u201co foco principal da biblioteca jQuery \u00e9 a simplicidade. Por que \n\nsubmeter os desenvolvedores ao mart\u00edrio de escrever longos e complexos c\u00f3digos \n\npara criar simples efeitos?\u201d. \n\nO jQuery \u00e9 uma maneira simples e f\u00e1cil de escrever aplica\u00e7\u00f5es JavaScipt. As \n\nprincipais vantagens do uso de jQuery sobre o JavaScipt tradicional s\u00e3o: \n\n? C\u00f3digo \u201copen source\u201d (gratuito). \n\n? Mundialmente utilizado em diversos sites e solu\u00e7\u00f5es web. \n\n\n\n \n\n 2\n\n9 \n\n? Acesso direto a qualquer componente da p\u00e1gina, ou seja, n\u00e3o h\u00e1 \n\nnecessidade de v\u00e1rias linhas de c\u00f3digo para acessar determinados \n\nobjetos. Duas compara\u00e7\u00f5es s\u00e3o feitas na Tabela 1 - Compara\u00e7\u00e3o Sintaxe \n\nJavascript vs jQuerya primeira mostra como selecionar todos os \n\nelementos da p\u00e1gina com o mesmo nome (um elemento pode ser um \n\nbot\u00e3o, uma linha de uma tabela, entre outros) e a segunda mostra como \u00e9 \n\nf\u00e1cil alterar um atributo de um elemento.   \n\n? Manipula\u00e7\u00e3o de conte\u00fados com algumas poucas linhas de c\u00f3digo. \n\n? Suporte para toda a gama de eventos de intera\u00e7\u00e3o com o usu\u00e1rio sem \n\nlimita\u00e7\u00f5es impostas pelos navegadores. \n\n? Possiblidade de inserir uma grande variedade de efeitos de anima\u00e7\u00e3o com \n\numa simples linha de c\u00f3digo. \n\n? Simplifica\u00e7\u00e3o na cria\u00e7\u00e3o de scripts. \n\n? Emprego cross-browser. A mais poderosa ferramenta do jQuery \u00e9 abstrair \n\no desenvolvedor do navegador para o qual se est\u00e1 programando. Suas \n\nfun\u00e7\u00f5es tem o mesmo resultado, embora por baixo a biblioteca adeque \n\nseu funcionamento de acordo com o navegador em que foi aberto e \n\nvers\u00e3o em que se encontra.  \n\n \n\nSintaxe JavaScript Sintaxe jQuery \n\ndocument.getElementsByTagName(\"p\") $(\"p\") \n\ndocument.getElementById(\u201cum\u201d).setAttribute(\u201cclass\u201d, \u201ccor\u201d) $(\"#um\").attr(\"class\", \"cor\") \n\nTabela 1 - Compara\u00e7\u00e3o Sintaxe Javascript vs jQuery \n\n \n\n3.4: Modelo de dados \n\n \n\nEm muitos sistemas informatizados \u00e9 necess\u00e1rio armazenar informa\u00e7\u00f5es em \n\nbancos de dados, e pode-se constatar isso ao observar que nas \u00faltimas d\u00e9cadas o \n\nbanco de dados se tornou o cora\u00e7\u00e3o de muitos sistemas. A informa\u00e7\u00e3o \u00e9 muitas \n\n\n\n \n\n 3\n\n0 \n\nvezes a coisa mais valiosa das empresas e mant\u00ea-las e poder acess\u00e1-las sempre \n\nque necess\u00e1rio \u00e9 primordial para a tomada de decis\u00f5es importantes.  \n\nAl\u00e9m disso, \u00e9 important\u00edssimo controlar o acesso a essas informa\u00e7\u00f5es e n\u00e3o \n\ndeixar que elas vazem. Evitar a perda de informa\u00e7\u00f5es, fazendo backups peri\u00f3dicos \n\n\u00e9 uma forma de garantir que as informa\u00e7\u00f5es relevantes n\u00e3o sejam perdidas.  \n\nO gerenciamento de um banco de dados \u00e9 uma pe\u00e7a fundamental para \n\najudar a empresa a ter sucesso, mas tamb\u00e9m pode lev\u00e1-la ao fracasso. Para \n\ngarantir a consist\u00eancia dos dados \u00e9 preciso controlar o acesso e manter os dados \n\nseguros. Com essa finalidade foram criados os Sistemas de Gerenciamento de \n\nBancos de Dados (SGBD). \n\n \n\nFigura 8 - Modelo de funcionamento de Banco de dados \n\n \n\n\n\n \n\n 3\n\n1 \n\n3.4.1: Tecnologia Utilizada \n\nDevido aos requisitos, por parte do cliente, usou-se o SGBD (desenvolvido \n\npela Microsoft) SQL Server. \n\n \n\n3.4.2: Documenta\u00e7\u00e3o e Constru\u00e7\u00e3o do Modelo \n\nDevido \u00e0 alta utiliza\u00e7\u00e3o de banco de dados relacionais na imensa maioria das \n\nsolu\u00e7\u00f5es de TI e Automa\u00e7\u00e3o pelo mundo todo, encontram-se no mercado de \n\nsoftware diversos programas de auxilio \u00e0 constru\u00e7\u00e3o e documenta\u00e7\u00e3o de um banco \n\nde dados. \n\nUsa-se de interface gr\u00e1fica para montar as tabelas, construir as rela\u00e7\u00f5es 1x1, \n\n1xN \u201cForeign Keys\u201d e declarar \u201cUnique Keys\u201d, e atrav\u00e9s disso o programa constr\u00f3i \n\nautomaticamente o c\u00f3digo na linguagem SQL. Esses softwares reduzem o custo de \n\ndesenvolvimento se tornando essencial utilizar um desses para qualquer projeto de \n\nm\u00e9dia a alta complexidade.  \n\nNo projeto foi utilizado o software \u201cEnterprise Architect\u201d, desenvolvido pela \n\nempresa Sparx Systems, sendo esta uma empresa australiana especializada em \n\ndesenvolver software de aux\u00edlio a projetos. \n\n \n\n \n\nFigura 9 - Interface Gr\u00e1fica do EA para cria\u00e7\u00e3o das tabelas de Banco de \n\nDados \n\n\n\n \n\n 3\n\n2 \n\n \n\n3.5: Framework \n\n \n\nUm dos principais objetivos da Engenharia de Software \u00e9 o reuso. Atrav\u00e9s da \n\nreutiliza\u00e7\u00e3o de software obt\u00e9m-se o aumento da qualidade e redu\u00e7\u00e3o do esfor\u00e7o de \n\ndesenvolvimento. A orienta\u00e7\u00e3o a objetos fornece funcionalidades para que classes \n\npossam ser reutilizadas, bem como m\u00e9todos, por meio de seus mecanismos de \n\nheran\u00e7a e polimorfismo. Componentes de software definem unidades reutiliz\u00e1veis \n\nque oferecem servi\u00e7os atrav\u00e9s de interfaces bem definidas. \u201cPadr\u00f5es de projeto\u201d \u00e9 \n\noutra abordagem mais abstrata que objetiva a reutiliza\u00e7\u00e3o de projetos de solu\u00e7\u00f5es \n\npara problemas recorrentes.  \n\nAl\u00e9m destas formas de reutiliza\u00e7\u00e3o, a tecnologia de frameworks possibilita que \n\numa fam\u00edlia de produtos seja gerada a partir de uma \u00fanica estrutura que captura os \n\nconceitos mais gerais da fam\u00edlia de aplica\u00e7\u00f5es.  \n\nUm framework \u00e9 um projeto de software abstrato que fornece a outro projeto \n\ndiversas funcionalidades, reduzindo o esfor\u00e7o computacional e facilitando o trabalho \n\ndo programador que ir\u00e1 usar o framework, assim ele n\u00e3o precisa entender a \n\nimplementa\u00e7\u00e3o, al\u00e9m de ter a sua disponibilidade uma gama de funcionalidades \n\namplamente testadas. \n\n3.5.1: Framework Radix \n\n \n\nAs empresas produtoras de softwares enfrentam como principais desafios a \n\nnecessidade de garantir uma alta qualidade do software gerado, aumentar a \n\nprodutividade dos desenvolvedores, diminuir os custos e prazos de \n\ndesenvolvimento, sempre com o objetivo de garantir a satisfa\u00e7\u00e3o e preservar a sua \n\nrela\u00e7\u00e3o com seus clientes. \n\nA solu\u00e7\u00e3o encontrada pela Radix para que as necessidades sejam atendidas \n\nfoi o desenvolvimento de um framework orientado a objetos. Trata-se de uma \n\nferramenta que agrupa funcionalidades comuns a diversas aplica\u00e7\u00f5es possibilitando \n\n\n\n \n\n 3\n\n3 \n\na solu\u00e7\u00e3o de uma fam\u00edlia de problemas recorrentes em desenvolvimento de \n\nsoftware. Os pilares do framework consistem em: \n\n \n\n? Reutiliza\u00e7\u00e3o de c\u00f3digo: possibilita o aumento da produtividade e, de \n\nmaneira geral, a redu\u00e7\u00e3o de prazos e cistos, visto que evita o gasto de \n\ntempo de trabalho implementando funcionalidades previamente \n\ndesenvolvidas. H\u00e1 tamb\u00e9m uma confiabilidade maior do c\u00f3digo j\u00e1 que \n\neste foi usado, testado e aprimorado em diversos projetos passados \n\n(diminui\u00e7\u00e3o de bugs). \n\n? Design Patterns: s\u00e3o t\u00e9cnicas consagradas de solu\u00e7\u00e3o de problemas. \n\nEmpregar um design pattern na confec\u00e7\u00e3o de um c\u00f3digo implica adicionar \n\num n\u00edvel de abstra\u00e7\u00e3o a ele de modo que detalhes particulares de \n\nimplementa\u00e7\u00e3o sejam isolados do resto do c\u00f3digo. Assim, caso seja \n\nnecess\u00e1rio, pode-se propag\u00e1-lo para todos os blocos que reutilizam este \n\nc\u00f3digo. Verifica-se, portanto, que o emprego de design patterns possibilita \n\numa melhor manuten\u00e7\u00e3o do c\u00f3digo. Vale a pena ressaltar que muitas \n\ndessas fun\u00e7\u00f5es vieram de projetos antigos, que nada tinham a ver com \n\numa f\u00e1brica de A\u00e7os Longo. Estas melhorias feitas no Framework ser\u00e3o \n\npropagadas para projetos futuros. \n\n? Arquitetura de Tr\u00eas Camadas: organiza\u00e7\u00e3o l\u00f3gica do software em m\u00f3dulos \n\nindependentes, mas que s\u00e3o conectados entre si. Tipicamente se usa um \n\nmodelo de camadas onde s\u00e3o envolvidas: camada de apresenta\u00e7\u00e3o (faz a \n\ninterface com o usu\u00e1rio); camada de neg\u00f3cios (controle) onde s\u00e3o \n\narmazenadas as regras de neg\u00f3cios do processo produtivo do cliente; \n\ncamada de dados (onde s\u00e3o armazenados os dados envolvidos nos \n\nprocesso). O objetivo de usar a arquitetura em tr\u00eas camadas \u00e9 desacoplar \n\na l\u00f3gica de neg\u00f3cios dos dados e da apresenta\u00e7\u00e3o, de maneira que \n\naltera\u00e7\u00f5es em cada uma destas duas \u00faltimas camadas se processem de \n\nmaneira transparente \u00e0s outras camadas, facilitando a manuten\u00e7\u00e3o do \n\nsistema.  \n\n \n\n\n\n \n\n 3\n\n4 \n\n \n\nFigura 10 - Estrutura de Camadas \n\n \n\n3.5.2: Framework .NET \n\nO .Net, ou dotnet, \u00e9 uma plataforma para desenvolvimento de aplica\u00e7\u00f5es  que \n\nfoi criada pela Microsoft em 1999. Essa plataforma disponibiliza uma vasta biblioteca \n\nde funcionalidades e componentes, fornecendo interoperabilidade com uma gama \n\nde linguagens de alto n\u00edvel. \n\nA interoperabilidade do ambiente \u00e9 semelhante \u00e0 plataforma Java pois usa de \n\numa m\u00e1quina virtual independente da linguagem. A linguagem Java possui a JVM \n\n(Java Virtual Machine), e para .NET temos a m\u00e1quina virtual chamada Common \n\nLanguage Runtime (CRL). Isso permite ao desenvolvedor n\u00e3o se preocupar com o \n\ndispositivo ao qual est\u00e1 destinada sua aplica\u00e7\u00e3o, o que, por sua vez, resulta em um \n\naumento da efici\u00eancia. Atualmente a CLR permite rodar a mesma aplica\u00e7\u00e3o em \n\nv\u00e1rios dispositivos como smartphones, tabletes, Xbox, computadores desktops e \n\nservidores. \n\nO framework .Net abstrai do desenvolvedor a necessidade de usar apenas \n\numa \u00fanica linguagem, j\u00e1 que hoje em dia t\u00eam-se mais de 30 op\u00e7\u00f5es destas, sendo \n\nalgumas: C#, C++, Boo, F#, COBOL, Python, Pascal e Visual Basic. \n\nAs aplica\u00e7\u00f5es programadas em cima do framework .NET s\u00e3o duplamente \n\ncompiladas. A primeira faz para uma linguagem intermedi\u00e1ria, Common Intermediate \n\nLanguage, o que permite a integra\u00e7\u00e3o entre projetos de diferentes linguagens. No \n\nfinal s\u00e3o compiladas para a linguagem m\u00e1quina, conforme apresentado na Figura 1. \n\nDentre as vantagens do framework .Net  destacam-se:  \n\n\n\n \n\n 3\n\n5 \n\n? Interoperabilidade: possibilidade de executar funcionalidades a partir de \n\nqualquer linguagem disponibilizada; \n\n? Seguran\u00e7a: trata diversas vulnerabilidades comuns e fornece um modelo \n\nde seguran\u00e7a integrado para as aplica\u00e7\u00f5es. \n\n? Biblioteca de funcionalidades comuns: existem v\u00e1rias funcionalidades \n\ndispon\u00edveis independentes da linguagem que esteja sendo utilizada, \n\ndesde manipula\u00e7\u00e3o de arquivos, acesso a base de dados, criptografia, \n\nf\u00f3rmulas matem\u00e1ticas, processamento gr\u00e1fico at\u00e9 gerenciamento paralelo \n\nde aplica\u00e7\u00f5es. \n\n \n\n \n\nFigura 11 - Compila\u00e7\u00e3o framework .NET \n\n \n\n3.5.3: Arquitetura MVC \n\nA arquitetura padr\u00e3o MVC fornece uma maneira de dividir a funcionalidade \n\nenvolvida na manuten\u00e7\u00e3o e apresenta\u00e7\u00e3o dos dados de uma aplica\u00e7\u00e3o. Na \n\narquitetura MVC o modelo representa os dados da aplica\u00e7\u00e3o e as regras de neg\u00f3cio \n\n\n\n \n\n 3\n\n6 \n\nque governam o acesso e a modifica\u00e7\u00e3o dos dados. O modelo mant\u00e9m o estado \n\npersistente do neg\u00f3cio e fornece ao controlador a capacidade de acessar as \n\nfuncionalidades da aplica\u00e7\u00e3o encapsuladas pelo pr\u00f3prio modelo. \n\nUm controlador define o comportamento da aplica\u00e7\u00e3o, \u00e9 ele que interpreta as \n\na\u00e7\u00f5es do usu\u00e1rio e as mapeia para chamadas do modelo. Em um cliente de \n\naplica\u00e7\u00f5es web essas a\u00e7\u00f5es de usu\u00e1rio poderiam ser cliques de bot\u00f5es ou sele\u00e7\u00f5es \n\nde menus. As a\u00e7\u00f5es realizadas incluem ativar processos de neg\u00f3cio ou alterar o \n\nestado do modelo.  \n\nCom base na a\u00e7\u00e3o do usu\u00e1rio e no resultado do processamento do modelo, o \n\ncontrolador seleciona uma visualiza\u00e7\u00e3o a ser exibida como parte da resposta \u00e0 \n\nsolicita\u00e7\u00e3o do usu\u00e1rio. H\u00e1 normalmente um controlador para cada conjunto de \n\nfuncionalidades, e no sistema MES existe um controlador para cada tela da \n\naplica\u00e7\u00e3o. \n\n \n\n3.5.4: ASP .NET MVC \n\n \n\nO ASP.NET MVC \u00e9 uma implementa\u00e7\u00e3o da arquitetura MVC para o \n\nframework .NET com o objetivo de criar aplica\u00e7\u00f5es Web no padr\u00e3o MVC. O \n\nframework ASP.NET MVC fornece um ambiente de qualidade e leve que est\u00e1 \n\nintegrado com os recursos do .NET. \u00c9 uma evolu\u00e7\u00e3o do framework que agrega \n\nnovas funcionalidades para programar um projeto na arquitetura Web. \n\nAs vantagens de se usar este framework s\u00e3o:  \n\n? Pode-se fazer a divis\u00e3o da aplica\u00e7\u00e3o em camadas, o que facilita o \n\nentendimento e a manuten\u00e7\u00e3o das aplica\u00e7\u00f5es. \n\n? Um desenvolvimento front-end (interface) mais simples, f\u00e1cil de \n\nintegrar no projeto com os designers gr\u00e1fico. As p\u00e1ginas (View) \n\npossuem apenas o HTML e a marca\u00e7\u00e3o dos valores din\u00e2micos (mas \n\nn\u00e3o tem l\u00f3gicas de aplica\u00e7\u00e3o embutidas). \n\n? Possuir um controle sobre a interface, pois isso garante controle total \n\nsobre o HTML gerado e os arquivos de CSS. \n\n\n\n \n\n 3\n\n7 \n\n? F\u00e1cil integra\u00e7\u00e3o com bibliotecas JavaScript e jQuery. \n\n? Escalabilidade. \n\n \n\n3.5.4.1: Fluxo Execu\u00e7\u00e3o da Aplica\u00e7\u00e3o ASP.NET MVC \n\n \n\nAs requisi\u00e7\u00f5es que vem do usu\u00e1rio, como por exemplo acessar uma p\u00e1gina \n\npelo browser (URL), s\u00e3o enviadas para o servidor. No servidor o framework do ASP \n\n.NET MVC faz o roteamento da requisi\u00e7\u00e3o para o controlador correto. O controlador \n\ninvoca a camada de modelo e no final renderiza o html da tela, ent\u00e3o retorna para o \n\nbrowser e atualiza a tela do usu\u00e1rio. \n\n \n\nSimbologia CSS - URL \n\n \n\nFigura 12 - Funcionamento Arquitetura ASP .NET MVC \n\n3.5.4.2: Razor \n\nASP.NET Razor \u00e9 uma view engine, ou seja, \u00e9 uma ferramenta para escrever \n\nvisualiza\u00e7\u00f5es (p\u00e1ginas) em aplica\u00e7\u00f5es web. Com ela \u00e9 poss\u00edvel integrar os dados da \n\naplica\u00e7\u00e3o com as p\u00e1ginas em Html e montar no servidor antes de enviar ao usu\u00e1rio. \n\n\n\n \n\n 3\n\n8 \n\nA caracter\u00edstica funcional mais importante do Razor \u00e9 a de se usar um c\u00f3digo limpo \n\ne leg\u00edvel, onde \u00e9 poss\u00edvel construir p\u00e1ginas extremamente elaboradas (ricas em \n\nconte\u00fado com c\u00f3digo organizado e limpo) gerando assim facilidade no processo de \n\nmanuten\u00e7\u00e3o.  \n\nAs imagens a seguir demonstram um pouco o poder da ferramenta ao criar \n\numa tabela com uma lista de entidades. \n\n \n\n \n\nFigura 13 - Parte de um arquivo Razor para preencher as linhas de uma tabela \n\n \n\nFigura 14 - Figura 14 arquivo html gerado pelo Razor enviado ao browser \n\n \n\n\n\n \n\n 3\n\n9 \n\n \n\n3.6: Filosofias de Desenvolvimento: \n\nConforme descrito por [ 3 ] V.B. Mazzola e J-M Farines, \u201cMetodologias de \n\nConcep\u00e7\u00e3o de Software e de Sistemas\u201d, nos anos 40, quando se iniciou a evolu\u00e7\u00e3o \n\ndos sistemas computadorizados, grande parte dos esfor\u00e7os, e consequentes custos, \n\nera concentrada no desenvolvimento do hardware, em raz\u00e3o, principalmente das \n\nlimita\u00e7\u00f5es e dificuldades encontradas na \u00e9poca. \u00c0 medida que a tecnologia de \n\nhardware foi sendo dominada, as preocupa\u00e7\u00f5es se voltaram, no in\u00edcio dos anos 50, \n\npara o desenvolvimento dos sistemas operacionais, onde surgiram ent\u00e3o as \n\nprimeiras realiza\u00e7\u00f5es destes sistemas, assim como das chamadas linguagens de \n\nprograma\u00e7\u00e3o de alto n\u00edvel (como FORTRAN, COBOL, e seus respectivos \n\ncompiladores). A tend\u00eancia da \u00e9poca foi de poupar cada vez mais o usu\u00e1rio de um \n\ncomputador de conhecer profundamente as quest\u00f5es relacionadas ao \n\nfuncionamento interno da m\u00e1quina, permitindo que aquele pudesse concentrar seus \n\nesfor\u00e7os na resolu\u00e7\u00e3o dos problemas computacionais em lugar de preocupar-se \n\ncom os problemas relacionados ao funcionamento do hardware. Uma consequ\u00eancia \n\ndeste crescimento foi a necessidade, cada vez maior, de desenvolver grandes \n\nsistemas de software em substitui\u00e7\u00e3o aos pequenos programas aplicativos utilizados \n\nat\u00e9 ent\u00e3o. Desta necessidade surgiu um problema nada trivial devido \u00e0 falta de \n\nexperi\u00eancia e a n\u00e3o adequa\u00e7\u00e3o dos m\u00e9todos de desenvolvimento existentes para \n\npequenos programas, o que foi caracterizado, ainda na d\u00e9cada de 60, como a \"crise \n\ndo software\", mas que, por outro lado, permitiu o nascimento do termo \"Engenharia \n\nde Software\".  \n\nAtualmente, apesar da constante queda dos pre\u00e7os dos equipamentos, o \n\ncusto de desenvolvimento de software n\u00e3o obedece a esta mesma tend\u00eancia. Pelo \n\ncontr\u00e1rio, corresponde a uma percentagem cada vez maior no custo global de um \n\nsistema informatizado. A principal raz\u00e3o para isto \u00e9 que a tecnologia de \n\ndesenvolvimento de software implica, ainda, em grande carga de trabalho, como \n\ntamb\u00e9m os projetos de grandes sistemas de software envolvendo, em regra geral, \n\num grande n\u00famero de pessoas num prazo relativamente longo de desenvolvimento. \n\nO desenvolvimento destes sistemas \u00e9 realizado, na maior parte das vezes, de forma \n\n\n\n \n\n 4\n\n0 \n\n\"ad-hoc\", conduzindo a frequentes desrespeitos de cronogramas e acr\u00e9scimos de \n\ncustos de desenvolvimento. \n\nNa busca por reduzir os custos e prazos de constru\u00e7\u00e3o dos softwares, as \n\nempresas de desenvolvimento tem se utilizado de metodologias pr\u00e9-definidas para \n\nsua constru\u00e7\u00e3o. A seguir s\u00e3o explicados os modelos mais comumente utilizados e \n\ntamb\u00e9m como funciona o modelo utilizado pela Radix. Logo ap\u00f3s \u00e9 feita uma \n\npequena compara\u00e7\u00e3o entre os modelos tradicionais de desenvolvimento.  \n\n3.6.1: Modelo Cascata \n\nEste modelo foi o primeiro a ser criado e \u00e9 tamb\u00e9m o mais simples de \n\ndesenvolvimento de software, estabelecendo uma ordena\u00e7\u00e3o linear na realiza\u00e7\u00e3o \n\ndas tarefas. Como mostra a Figura 15, o ponto de partida se d\u00e1 na Engenharia de \n\nSistemas, onde o objetivo \u00e9 ter uma vis\u00e3o global do sistema como um todo \n\n(hardware, software e usu\u00e1rios) como forma de definir o papel do software. Em \n\nseguida vem a etapa de An\u00e1lise de Requisitos que vai permitir uma clara defini\u00e7\u00e3o \n\ndos requisitos de software, sendo que o resultado de um passo \u00e9 usado como \n\nrefer\u00eancia para as etapas posteriores (Projeto, Codifica\u00e7\u00e3o, Teste e Manuten\u00e7\u00e3o). \n\n \n\nOper a\u00e7\u00e3o e\n\nManuten\u00e7\u00e3o\n\nCodifica\u00e7\u00e3o\n\nPr ojeto\n\nAn\u00e1lise de\n\nRequisitos\n\nTeste e\n\nIntegr a\u00e7\u00e3o\n\nEngenhar ia de\n\nSistemas\n\n \n\nFigura 15 - Modelo Cascata \n\n\n\n \n\n 4\n\n1 \n\n \n\nO modelo cascata define em uma ordem linear as etapas de \n\ndesenvolvimento. No fim de cada etapa, um mecanismo de certifica\u00e7\u00e3o \u00e9 \n\nimplementado, validando se o que est\u00e1 saindo de cada etapa \u00e9 relacionado com a \n\nsa\u00edda da anterior. \n\n \n\n3.6.2: Modelo Prototipa\u00e7\u00e3o \n\nA grande inova\u00e7\u00e3o deste modelo \u00e9 eliminar a pol\u00edtica de \u201cgongelamento\u201d dos \n\nrequisitos antes do projeto do sistema. Ele foi feito atrav\u00e9s da confec\u00e7\u00e3o de um \n\nprot\u00f3tipo com base no conhecimento dos requisitos iniciais para o sistema. O \n\ndesenvolvimento do prot\u00f3tipo \u00e9 feito obedecendo as diferentes etapas mencionadas \n\nanteriormente s\u00f3 que de maneira mais r\u00e1pida e sem muita formalidade. \n\nO prot\u00f3tipo pode ser oferecido ao cliente em duas diferentes formas: \n\nprot\u00f3tipo em papel ou modelo execut\u00e1vel em PC retratando a interface gr\u00e1fica, \n\ncapacitando ao cliente compreender como ele ir\u00e1 interagir com o software. Colocado \n\n\u00e0 disposi\u00e7\u00e3o do cliente, o prot\u00f3tipo vai ajud\u00e1-lo a melhor compreender o que ser\u00e1 o \n\nsistema de desenvolvimento. Atrav\u00e9s da manipula\u00e7\u00e3o do prot\u00f3tipo \u00e9 poss\u00edvel validar \n\nou reformular os requisitos para as etapas seguintes.  \n\nAn\u00e1lise de\nRequisitos\n\nProj eto\n\nCodifica\u00e7\u00e3o\n\nTeste\n\nProj eto Codifica\u00e7\u00e3o Teste\n\nAn\u00e1lise de\nRequisitos  \n\nFigura 16 - Modelo Prot\u00f3tipo  \n\nOs prot\u00f3tipos n\u00e3o s\u00e3o sistemas completos e deixam normalmente a desejar.  \n\nA experi\u00eancia adquirida durante a constru\u00e7\u00e3o do prot\u00f3tipo ajuda nas etapas \n\n\n\n \n\n 4\n\n2 \n\nposteriores do desenvolvimento real, permitindo manter o que foi bem concebido e \n\nrepensar o que ficou trabalhoso ou mal projetado. \n\n3.6.3: Modelo Iterativo \n\nEste terceiro modelo foi concebido para combinar as vantagens dos modelos \n\nanteriormente citados. O funcionamento do modelo iterativo, ilustrado na Error! \n\nReference source not found., \u00e9 o de que um sistema deve ser desenvolvido de \n\nforma incremental sendo que cada incremento vai adicionando ao sistema novas \n\nfuncionalidades at\u00e9 a obten\u00e7\u00e3o do sistema final, sendo que a cada passo \n\nmodifica\u00e7\u00f5es podem ser introduzidas. \n\nUma vantagem \u00e9 a facilidade de realizar os testes do sistema, uma vez que \n\nfazer isso em cada n\u00edvel \u00e9 mais f\u00e1cil do que realizar todos os testes de um sistema \n\ninteiro depois de um grande tempo de desenvolvimento. \n\nCada itera\u00e7\u00e3o do modelo de Desenvolvimento Iterativo consiste em avan\u00e7ar \n\num passo na dire\u00e7\u00e3o do projeto completo, atrav\u00e9s da realiza\u00e7\u00e3o das tr\u00eas etapas: \n\nprojeto, codifica\u00e7\u00e3o e an\u00e1lise. O ciclo se repete at\u00e9 convergir para o software final. \n\nPode-se alterar componentes anteriores em raz\u00e3o de erros ou problemas \n\ndetectados em alguma an\u00e1lise. \n\n \n\nProj eto\n\nImplementa\u00e7\u00e3o\n\nAn\u00e1lise\n\n1\n\nProj eto\n\nImplementa\u00e7\u00e3o\n\nAn\u00e1lise\n\n0\n\nProj eto\n\nImplementa\u00e7\u00e3o\n\nAn\u00e1lise\n\nN\n\n \n\nFigura 17 - Modelo Desenvolvimento Iterativo \n\n3.6.4: Desenvolvimento \u00c1gil de Software \u2013 Radix \n\nDesenvolvimento \u00e1gil (tamb\u00e9m conhecido como m\u00e9todo \u00e1gil) \u00e9 um conjunto \n\nde metodologias de desenvolvimento de software. Tal como as outras metodologias, \n\nprovidencia uma estrutura conceitual para reger projetos de engenharia de software. \n\n\n\n \n\n 4\n\n3 \n\nA maioria dos m\u00e9todos \u00e1geis tenta minimizar o risco pelo desenvolvimento do \n\nsoftware em curtos per\u00edodos chamados de \u201citera\u00e7\u00e3o\u201d. Cada itera\u00e7\u00e3o \u00e9 um projeto de \n\nsoftware dentro de si mesmo e inclui todas as tarefas: an\u00e1lise de requisitos, projeto, \n\ncodifica\u00e7\u00e3o, teste e documenta\u00e7\u00e3o. Enquanto em um processo convencional cada \n\nitera\u00e7\u00e3o n\u00e3o necessariamente adiciona um novo conjunto significativo de \n\nfuncionalidades, um projeto de software \u00e1gil busca a capacidade de implantar uma \n\nnova vers\u00e3o do software ao fim de cada itera\u00e7\u00e3o. \n\nM\u00e9todos \u00e1geis tendem a enfatizar mais a comunica\u00e7\u00e3o em tempo real, \n\npreferencialmente face-a-face, no lugar de documentos escritos. A maioria dos \n\ncomponentes de um grupo \u00e1gil deve estar agrupada em uma sala. Isso inclui todas \n\nas pessoas necess\u00e1rias para o desenvolvimento de software: programadores, \n\nclientes (que definem os requisitos), testadores e gerentes. \n\nComo descrito em [ 4 ] B. Boehm. Balancing \u201cAgility and Discipline: A Guide \n\nfor the Perplexed\u201d. os princ\u00edpios que o desenvolvimento \u00e1gil valoriza s\u00e3o: \n\n? Garantir a satisfa\u00e7\u00e3o do cliente ao entregar rapidamente e \n\ncontinuamente softwares funcionais; \n\n? Softwares funcionais entregues frequentemente (semanas); \n\n? Softwares funcionais s\u00e3o a principal medida de progresso; \n\n? Coopera\u00e7\u00e3o constante entre pessoas que entendem do \u201eneg\u00f3cio? e \n\ndesenvolvedores; \n\n? Design do software que zela pela excel\u00eancia t\u00e9cnica; \n\n? Simplicidade; \n\n? R\u00e1pida adapta\u00e7\u00e3o \u00e0s mudan\u00e7as; \n\n? Prefer\u00eancia: pelo software funcional \u00e0 documenta\u00e7\u00e3o extensa, pela \n\ncolabora\u00e7\u00e3o com clientes \u00e0 negocia\u00e7\u00e3o de contratos e por gera\u00e7\u00e3o de \n\nmudan\u00e7as ao seguir um plano. \n\nOs m\u00e9todos \u00e1geis surgiram como uma rea\u00e7\u00e3o aos m\u00e9todos antigos \n\n\u201cpesados\u201d (que tinham regulamenta\u00e7\u00f5es r\u00edgidas). O processo originou-se da vis\u00e3o \n\nque o modelo em cascata era burocr\u00e1tico, lento e n\u00e3o condizia com a forma usual \n\nque os programadores trabalham. \n\n\n\n \n\n 4\n\n4 \n\nHoje em dia, empresas que prestam servi\u00e7o de tecnologia quase que em sua \n\ntotalidade adotam a maioria dos princ\u00edpios de desenvolvimento \u00e1geis. Na Radix n\u00e3o \n\n\u00e9 diferente. Apesar de nesse projeto n\u00e3o seguir nenhum m\u00e9todo espec\u00edfico de \n\ndesenvolvimento \u00e1gil (como o Scrum, programa\u00e7\u00e3o extrema, etc) seguem-se seus \n\nprinc\u00edpios, fazendo uso de entregas frequentes de softwares funcionais, constante \n\nconversa e valida\u00e7\u00e3o do que se est\u00e1 sendo feito, pouca documenta\u00e7\u00e3o, maior foco \n\nno software e \u00e0s rea\u00e7\u00f5es entre diversas trocas de c\u00f3digo. \n\n3.6.4.1: Compara\u00e7\u00e3o com o Desenvolvimento Iterativo \n\nOs m\u00e9todos \u00e1geis compartilham a \u00eanfase no desenvolvimento iterativo e \n\nincremental para constru\u00e7\u00f5es de vers\u00f5es funcionais do software em curtos per\u00edodos \n\nde tempo. Os m\u00e9todos \u00e1geis diferem do m\u00e9todo iterativo porque seus per\u00edodos de \n\ntempo s\u00e3o medidos em semanas, ao inv\u00e9s de meses, e a realiza\u00e7\u00e3o \u00e9 efetuada de \n\numa maneira altamente colaborativa e com menos documentos formais escritos. \n\n \n\n \n\nFigura 18 M\u00e9todo Incremental x Iterativo \n\n \n\n3.6.5: Clean Code, C\u00f3digo Limpo: \n\nNesta \u00e9poca de desenvolvimentos \u00e1geis de software, o foco est\u00e1 em colocar \n\no produto rapidamente no mercado, ou, no caso da Radix, entregar o produto mais \n\n\n\n \n\n 4\n\n5 \n\nr\u00e1pido poss\u00edvel para o cliente. Deseja-se que a ind\u00fastria funcione em velocidade \n\nm\u00e1xima na produ\u00e7\u00e3o de software, e, por causa disso, muitas metodologias de \n\ndesenvolvimento \u00e1gil tentam transformar o desenvolvimento em uma linha de \n\nmontagem.  \n\nDe acordo com a filosofia de c\u00f3digo Limpo de Robert C. Martin [ 5 ] R. C. \n\nMartin \u2013 \u201cC\u00f3digo Limpo, Habilidades Pr\u00e1ticas do Agile Software\u201d., assim como na \n\nind\u00fastria automobil\u00edstica, a maior parte do trabalho n\u00e3o est\u00e1 na fabrica\u00e7\u00e3o, mas na \n\nmanuten\u00e7\u00e3o e preven\u00e7\u00e3o. Em software, 80% ou mais do que se faz \u00e9 chamado de \n\n\u201cmanuten\u00e7\u00e3o\u201d: o ato de reparar. Em vez de focar-se na produ\u00e7\u00e3o, dever-se-ia \n\npensar mais como um pedreiro ou mec\u00e2nico, o qual ir\u00e1 reparar o produto e mant\u00ea-lo \n\nfuncionando. Na \u00e1rea de manufatura foi criada uma abordagem japonesa chamada \n\nManuten\u00e7\u00e3o Produtiva Total utilizando dos chamados cinco princ\u00edpios (5S). A \n\nfilosofia de C\u00f3digo Limpo tenta trazer esses princ\u00edpios de organiza\u00e7\u00e3o e disciplina \n\nda manufatura para a engenharia de software.   \n\n3.6.5.1: Princ\u00edpios do C\u00f3digo Limpo: \n\nOs princ\u00edpios do c\u00f3digo limpo s\u00e3o os mesmos que da filosofia 5S adaptados \n\npara a engenharia de software. Eles s\u00e3o listados a seguir:  \n\n? Seiri, ou \u201cOrganiza\u00e7\u00e3o\u201d: saber onde est\u00e3o as coisas e usar abordagens com \n\nnomes adequados \u00e9 crucial. \n\n? Seiso, ou \u201cArruma\u00e7\u00e3o\u201d: h\u00e1 um antigo ditado americano que diz: \u201cum lugar \n\npara tudo e tudo em seu lugar\u201d. Um peda\u00e7o de c\u00f3digo deve estar onde voc\u00ea o \n\nespera encontrar. \n\n? Seiso, ou \u201cLimpeza\u201d: manter o local de trabalho limpo. N\u00e3o encher o c\u00f3digo \n\nde coment\u00e1rios que informam o passado ou os desejos para o futuro. \n\n? Seiketsu, ou \u201cPadroniza\u00e7\u00e3o\u201d: a equipe toda tem que se esfor\u00e7ar para manter \n\no c\u00f3digo limpo. \n\n? Shutsuke, ou \u201cDisciplina\u201d: para manter o c\u00f3digo limpo \u00e9 necess\u00e1rio manter a \n\ndisciplina, seguir as pr\u00e1ticas e repetir frequentemente isso no trabalho. \n\n\n\n \n\n 4\n\n6 \n\n3.6.5.2: Por que usar a t\u00e9cnica de C\u00f3digo Limpo: \n\nNa \u00e1rea de programa\u00e7\u00e3o um problema muito comum enfrentado por todos \u00e9 \n\no de ao ter que mexer no c\u00f3digo confuso de outra pessoa, ou no seu pr\u00f3prio \n\nc\u00f3digo antigo. Conforme o projeto evolui, as equipes que trabalhavam rapidamente \n\nno in\u00edcio come\u00e7am a perceber que o mesmo est\u00e1 indo a passos de tartaruga. Cada \n\npequena altera\u00e7\u00e3o feita no c\u00f3digo causa uma falha em duas ou tr\u00eas partes do \n\nmesmo c\u00f3digo. Mudan\u00e7a n\u00e3o \u00e9 trivial, cada adi\u00e7\u00e3o ou modifica\u00e7\u00e3o exige que \n\nrestaura\u00e7\u00f5es e remendos sejam entendidos para poder incluir outra.  Com o tempo \n\na bagun\u00e7a se acumula e a produtividade da equipe diminui assintoticamente \n\naproximando-se de zero. \n\n \n\nFigura 19 - Produtividade vs Tempo \n\n \n\n3.6.5.3: O que \u00e9 um C\u00f3digo Limpo: \n\nAo programar, passa-se muito mais tempo lendo c\u00f3digo o j\u00e1 existente com o \n\nobjetivo de saber se uma mudan\u00e7a feita n\u00e3o ir\u00e1 afetar nenhuma outra parte do \n\nprojeto, ou se n\u00e3o est\u00e1 replicando as linhas do c\u00f3digo em si. Ent\u00e3o, para melhorar a \n\nhabilidade como programadores, deve-se deixar o c\u00f3digo de f\u00e1cil leitura.  \n\n A principal t\u00e9cnica usada para melhorar a qualidade do c\u00f3digo \u00e9 a escolha de \n\nbons nomes para as classes, fun\u00e7\u00f5es e vari\u00e1veis, nomes representativos que \n\neliminem a necessidade do uso de coment\u00e1rios. \n\n\n\n \n\n 4\n\n7 \n\n Outras boas pr\u00e1ticas de programa\u00e7\u00e3o incluem: deixar as fun\u00e7\u00f5es as menores \n\nposs\u00edveis e n\u00e3o deixar uma fun\u00e7\u00e3o que o leitor tenha que scrollar a tela para poder \n\nl\u00ea-la inteira. \n\n O uso adequado de coment\u00e1rios serve para compensar o fracasso em \n\nexpressar-se no c\u00f3digo, portanto evita-se ao m\u00e1ximo us\u00e1-los. Deve-se sempre \n\ntentar manifestar-se pelo c\u00f3digo, nomeando vari\u00e1veis e fun\u00e7\u00f5es. \n\n Na figura a seguir tem-se um peda\u00e7o de c\u00f3digo do projeto. Como se pode \n\nobservar, n\u00e3o foi necess\u00e1rio nenhum coment\u00e1rio no c\u00f3digo para demonstrar o que \n\nocorre em sua execu\u00e7\u00e3o. Esta \u00e9 uma fun\u00e7\u00e3o pequena, n\u00e3o tendo mais que 15 \n\nlinhas. Todos os nomes de fun\u00e7\u00e3o e vari\u00e1veis t\u00eam um significado. Apesar de \n\nsempre ser poss\u00edvel realizar uma melhoria na legibilidade do c\u00f3digo, a fun\u00e7\u00e3o \n\natende todos os requisitos de um c\u00f3digo limpo e pode ser entendida sem muito \n\ntrabalho. \n\n \n\n \n\nFigura 20 - Exemplo de um c\u00f3digo limpo do projeto \n\n \n\n \n\n  \n\n\n\n \n\n 4\n\n8 \n\nCap\u00edtulo 4: Estrutura do Projeto \n\nNesse cap\u00edtulo ser\u00e1 descrito como o projeto surgiu, sua estrutura e suas \n\nfases, dando \u00eanfase \u00e0s partes onde tive intensa participa\u00e7\u00e3o. O MES a\u00e7os longos \u00e9 \n\num projeto consideravelmente extenso que foi produzido por diversas pessoas, \n\nent\u00e3o se fez necess\u00e1ria uma distin\u00e7\u00e3o entre as partes que mais interessava a este \n\ntrabalho.   \n\n \n\n4.1: Sistemas de Informa\u00e7\u00e3o necess\u00e1rios: \n\n \n\nPara controlar a produ\u00e7\u00e3o da f\u00e1brica de a\u00e7os longos, a arquitetura de TI foi \n\ndividida em tr\u00eas subsistemas, os quais recolhem informa\u00e7\u00f5es do processo de \n\nprodu\u00e7\u00e3o e as comunicam entre si (cada um no seu n\u00edvel de abstra\u00e7\u00e3o). \n\n A camada de n\u00edvel mais elevado, conhecida como Enterprise resource \n\nplanning (ERP), \u00e9 respons\u00e1vel por controlar as vendas e a quantidade de cada \n\nmaterial que vai ser produzida num determinado per\u00edodo de tempo, como tamb\u00e9m \n\nos custos gerais de produ\u00e7\u00e3o. J\u00e1 a camada de n\u00edvel dois faz o papel de controlar os \n\natuadores do processo e medir as vari\u00e1veis de processo. A camada de n\u00edvel \n\nintermedi\u00e1rio \u00e9 a mais importante porque realiza muitas fun\u00e7\u00f5es: desempenha o \n\nmeio campo da comunica\u00e7\u00e3o entre as duas outras camadas, \u00e9 respons\u00e1vel por \n\nregistrar os consumos do processo e da produ\u00e7\u00e3o, controla o estoque e o fluxo da \n\nqualidade, estima a \u201cvida\u201d dos equipamentos da produ\u00e7\u00e3o, programa a produ\u00e7\u00e3o da \n\nf\u00e1brica para que atinja os objetivos gerados pelo ERP, contabiliza as paradas do \n\nprocesso, e disponibiliza diversas informa\u00e7\u00f5es e hist\u00f3rico do processo para a \n\ntomada de decis\u00e3o.  \n\n\n\n \n\n 4\n\n9 \n\n \n\nFigura 21 Arquitetura de n\u00edveis do sistema \n\n \n\n4.2: Projeto MES \n\nO projeto do MES como um todo come\u00e7ou em meados de outubro de 2012 \n\ncom a parte de negocia\u00e7\u00e3o, da \u00e1rea comercial e a parte de planejamento do projeto. \n\nComo vimos nos m\u00e9todos de desenvolvimento \u00e1gil, a constru\u00e7\u00e3o do software e a \n\nespecifica\u00e7\u00e3o dos requisitos \u00e9 feita em paralelo com o desenvolvimento conforme \n\npode-se observar o no cronograma do projeto. \n\n \n\n\n\n \n\n 5\n\n0 \n\n \n\nFigura 22 - Cronograma geral do Projeto \n\n4.2.1: An\u00e1lise de Requisitos \n\nA an\u00e1lise de requisitos \u00e9 um aspecto importante no projeto porque \u00e9 \n\nrespons\u00e1vel por coletar dados indispens\u00e1veis e necess\u00e1rios, j\u00e1 que s\u00e3o exig\u00eancias \n\nvisadas pelo usu\u00e1rio para solucionar um problema e alcan\u00e7ar seus objetivos (assim \n\ncomo determinar as expectativas de um usu\u00e1rio para determinado produto). \n\nA an\u00e1lise de requisitos \u00e9 vital para o desenvolvimento do sistema, pois o \n\ndocumento de especifica\u00e7\u00e3o ser\u00e1 a refer\u00eancia para validar o produto final, e isso \u00e9 \n\nimportante porque estabelece uma ponte entre os pensamentos abstratos de como \n\no cliente imagina o software e como o software realmente far\u00e1. \n\nA an\u00e1lise consiste nos 5 princ\u00edpios, conforme descrito por [ 1 ] FILGUEIRAS, \n\nDra. L\u00facia V. L.; MELNIKOFF, Dra. Selma Shin Shimizu, \u201cEngenharia de Software\u201d: \n\n? Reconhecer o problema: entender as necessidades do cliente e o que ele \n\ndeseja. \n\n? Avaliar o problema e a s\u00edntese da solu\u00e7\u00e3o: compreender o problema, \n\nidentificar as informa\u00e7\u00f5es que ser\u00e3o necess\u00e1rias ao usu\u00e1rio e propor a \n\nmelhor solu\u00e7\u00e3o poss\u00edvel. \n\n\n\n \n\n 5\n\n1 \n\n? Modelar um recurso para o suporte da s\u00edntese da solu\u00e7\u00e3o. \n\n? Especificar: consolida fun\u00e7\u00f5es, interfaces, desempenho e as regras de \n\nneg\u00f3cio do sistema. \n\n? Revisar: juntos, cliente e Radix, avaliar\u00e3o o objetivo do projeto visando \n\neliminar inconsist\u00eancias e omiss\u00f5es do sistema.  \n\nComo o projeto \u00e9 feito usando os m\u00e9todos \u00e1geis descritos na se\u00e7\u00e3o 3.6.4:, \u00e9 \n\nproduzido um documento de requisito para cada itera\u00e7\u00e3o do projeto. Na abordagem \n\nusada pela empresa, nossa equipe de requisitos tem um contato di\u00e1rio com um \n\ncliente, estando alocado no escrit\u00f3rio deles. Isso permite uma f\u00e1cil valida\u00e7\u00e3o das \n\nfuncionalidades do software e readequa\u00e7\u00e3o dos requisitos, caso alguma demanda \n\nseja alterada, com o menor retrabalho poss\u00edvel. \n\n \n\n4.2.1.1: Tipos de Requisitos: \n\nDentro da especifica\u00e7\u00e3o do software existem diferentes tipos de requisitos, os \n\nfuncionais e os n\u00e3o funcionais: \n\no Funcionais: estabelece como o sistema vai agir e o que deve fazer as \n\nfuncionalidades e servi\u00e7os. \n\no N\u00e3o funcionais: definem as propriedades do sistema e suas restri\u00e7\u00f5es, \n\nconfiabilidade, tempo de resposta, espa\u00e7o em disco, seguran\u00e7a. \n\n \n\n \n\n4.2.2: Desenvolvimento \n\n \n\nA equipe de desenvolvimento \u00e9 respons\u00e1vel por criar o c\u00f3digo da aplica\u00e7\u00e3o, \n\nespecificando os requisitos detalhadamente de modo que uma m\u00e1quina possa \n\nexecut\u00e1-las. Tendo em m\u00e3os o documento de especifica\u00e7\u00e3o, \u00e9 trabalho da equipe \n\nde desenvolvimento montar a estrutura do banco de dados e a arquitetura do \n\n\n\n \n\n 5\n\n2 \n\nprojeto, programarem as funcionalidades do software e a montar a interface com os \n\nusu\u00e1rios (seja ele um operador humano ou outro sistema). \n\nO trabalho de programa\u00e7\u00e3o foi dividido entre os desenvolvedores de modo \n\nque cada um ficou respons\u00e1vel por programar diferentes funcionalidades do \n\nsistema. No caso do MES, cada programador ficou respons\u00e1vel por desenvolver um \n\nconjunto de telas separadamente. Tamb\u00e9m era papel deles programar todas as \n\nfuncionalidades para a tela funcionar corretamente, desde o front-end (p\u00e1gina web, \n\nJavaScript) at\u00e9 o controlador que processaria as diferentes requisi\u00e7\u00f5es do usu\u00e1rio, a \n\ncamada de neg\u00f3cios e a persist\u00eancia. Neste trabalho ser\u00e1 dada uma \u00eanfase no \n\nm\u00f3dulo de produ\u00e7\u00e3o, onde se encontram diferentes telas de produ\u00e7\u00e3o. \n\n Como n\u00e3o estamos produzindo um software pr\u00f3prio para a empresa e sim \n\npara um cliente, ficamos amarrados. Todas as tecnologias utilizadas s\u00e3o \n\nespecificadas antes de come\u00e7ar o trabalho de programa\u00e7\u00e3o. Os itens listados \n\nabaixo se referem \u00e0s tecnologias e requisitos necess\u00e1rios para suportar as camadas \n\nde apresenta\u00e7\u00e3o, neg\u00f3cios e persist\u00eancia: \n\n\u2022 Internet Information Service (IIS) 7.5: IIS \u00e9 o servidor de aplicativos da Web \n\ne Microsoft e deve ser instalado e configurado no servidor do sistema; \n\n\u2022 Banco de Dados SQL Server 2012: Sistema Gerenciador de Banco de \n\nDados; \n\n\u2022 Internet Explorer (IE): navegador web para acessar as funcionalidades do \n\nsistema. O sistema ser\u00e1 desenvolvido para funcionar na vers\u00e3o do IE 8.0; \n\n\u2022 Framework .NET 4.0: Framework Microsoft para suportar a aplica\u00e7\u00e3o; \n\n\u2022 ASP.NET: Linguagem web que as p\u00e1ginas da Web s\u00e3o desenvolvidas; \n\n\u2022 C#: linguagem em que o c\u00f3digo \u00e9 escrito no servidor; \n\n \n\nBibliotecas utilizadas pela aplica\u00e7\u00e3o: \n\n\u2022 ASP.NET MVC 3.0: Framework. NET para desenvolvimento web que \n\nimplementa o padr\u00e3o MVC; \n\n\u2022 MSEL - Unity Application Block: Biblioteca utilizada para realiza\u00e7\u00e3o de \n\ninje\u00e7\u00e3o de depend\u00eancia e intercepta\u00e7\u00e3o de tipos. \n\n\n\n \n\n 5\n\n3 \n\n\u2022 MSEL - DataAccessApplication Block: Incorpora funcionalidades padr\u00f5es \n\nde banco de dados nas aplica\u00e7\u00f5es (como acesso a dados) e retornam dados \n\nem uma variedade de formatos, o que simplifica a codifica\u00e7\u00e3o e conex\u00e3o com \n\nbanco de dados. \n\n\u2022 Log4Net: biblioteca para gera\u00e7\u00e3o de logs de informa\u00e7\u00e3o e erros do sistema; \n\n\u2022 NPOI: Biblioteca para gera\u00e7\u00e3o de relat\u00f3rios no formato Excel. \n\n\u2022 NUnit: Framework para realiza\u00e7\u00e3o de testes unit\u00e1rios. \n\n \n\nMecanismos de apresenta\u00e7\u00e3o: \n\n\u2022 Razor: Otimizador de sintaxe para HTML que utiliza uma abordagem focada \n\nna codifica\u00e7\u00e3o de templates. Faz parte do Microsoft MVC 3.0. \n\n\u2022 JQuery: Cole\u00e7\u00e3o de ferramentas Javascript para manipula\u00e7\u00e3o e exibi\u00e7\u00e3o de \n\ndados do cliente. \n\n\u2022 Knockout JS: Biblioteca Javascript que trabalha em conjunto com JQuery \n\npara implementa\u00e7\u00e3o de padr\u00e3o MVVM, ajudando a criar uma visualiza\u00e7\u00e3o \n\nrica de dados com um modelo limpo e eficiente de codifica\u00e7\u00e3o. \n\n \n\n4.2.2.1: Sistema de controle de vers\u00e3o \n\n \n\nUm sistema de controle de vers\u00e3o (SVN), ou versionamento, \u00e9 um software \n\ncom a finalidade de gerenciar diferentes vers\u00f5es no desenvolvimento de um \n\nsoftware, para controlar as diferentes vers\u00f5es e hist\u00f3rico do desenvolvimento de \n\nc\u00f3digo fonte e da documenta\u00e7\u00e3o. Presente em v\u00e1rias empresas que trabalham em \n\ndesenvolvimento, \u00e9 tamb\u00e9m utilizado para o desenvolvimento de software livre.  \n\nA efic\u00e1cia do controle de vers\u00e3o do software \u00e9 comprovada por ser uma \n\nexig\u00eancias do desenvolvimento de certifica\u00e7\u00f5es como a CMMI (Capability Maturity \n\nModel Integration). As principais vantagens de se utilizar um sistema de controle \n\ns\u00e3o: \n\n? Controle do hist\u00f3rico: facilidade em desfazer altera\u00e7\u00f5es e analisar o \n\nhist\u00f3rico do desenvolvimento, como tamb\u00e9m facilidade no resgate de \n\nvers\u00f5es antigas e est\u00e1veis. \n\n\n\n \n\n 5\n\n4 \n\n? Trabalho em equipe: um sistema de controle de vers\u00e3o permite que \n\ndiversas pessoas trabalhem sobre o mesmo conjunto de documentos e \n\ndesenvolvam a mesma aplica\u00e7\u00e3o.  \n\n? Ramifica\u00e7\u00e3o do projeto em linhas de desenvolvimento. \n\n? Marca\u00e7\u00e3o e resgaste de vers\u00f5es est\u00e1veis. \n\nO software usado para fazer o controle de vers\u00e3o do projeto \u00e9 o TortoiseSVN. \n\nDe tempos em tempos, conforme dita a filosofia de m\u00e9todos \u00e1geis, sobe-se uma \n\nvers\u00e3o para o cliente. O TortoiseSVN salva uma c\u00f3pia da vers\u00e3o est\u00e1vel, como uma \n\nfotografia do c\u00f3digo no dia, chamado de Tag.  \n\n \n\n \n\nFigura 23 - Vers\u00f5es Entregues  \n\n \n\n4.2.2.2: Arquitetura Utilizada \n\n O MES do projeto possuir\u00e1 uma arquitetura Web Componetizada (.NET) \n\ndivida em tr\u00eas camadas: persist\u00eancia, neg\u00f3cios e apresenta\u00e7\u00e3o. Esta arquitetura \n\nsegue o padr\u00e3o MVC e facilita a separa\u00e7\u00e3o entre as funcionalidades da tela e dos \n\nservi\u00e7os, resultando no maior desacoplamento entre as camadas de neg\u00f3cio e \n\napresenta\u00e7\u00e3o, o que torna o software organizado, f\u00e1cil de manter e atualizar.  \n\nA Figura 24 mostra como o padr\u00e3o MVC do framework .NET se encaixa na \n\narquitetura de 3 camadas do framework da Radix. \n\n\n\n \n\n 5\n\n5 \n\n \n\nFigura 24 - MVC e arquitetura 3 camadas \n\n4.2.2.3: Camada de Apresenta\u00e7\u00e3o \n\nA camada de apresenta\u00e7\u00e3o \u00e9 respons\u00e1vel por: fazer a l\u00f3gica de constru\u00e7\u00e3o \n\ndas p\u00e1ginas para serem exibidas pelos usu\u00e1rios, tratar os eventos do browser (como \n\ncliques) e gerenciar o fluxo de execu\u00e7\u00e3o do MES. Para isso, a camada de \n\napresenta\u00e7\u00e3o conta com as partes de Controle e Visualiza\u00e7\u00e3o do padr\u00e3o MVC.  \n\nA parte de l\u00f3gica da camada de apresenta\u00e7\u00e3o ser\u00e1 divida entre o cliente \n\n(browser do usu\u00e1rio) e o servidor. No cliente ser\u00e1 utilizado JavaScript para valida\u00e7\u00e3o \n\nde dados e Razor para constru\u00e7\u00e3o din\u00e2mica da p\u00e1gina, assim como AJAX para \n\nrealizar requisi\u00e7\u00f5es de partes da p\u00e1gina ao servidor sem que seja preciso recarregar \n\na p\u00e1gina inteira. Esta funcionalidade permitir\u00e1 um melhor desempenho e usabilidade \n\nda aplica\u00e7\u00e3o. \n\n \n\n4.2.2.4: Camada de Neg\u00f3cios \n\n \n\nA camada de neg\u00f3cios \u00e9 respons\u00e1vel por: implementar a l\u00f3gica do dom\u00ednio \n\nda aplica\u00e7\u00e3o, expor esta l\u00f3gica para a camada de apresenta\u00e7\u00e3o por meio de uma \n\n\n\n \n\n 5\n\n6 \n\ninterface bem definida e obter as informa\u00e7\u00f5es necess\u00e1rias acessando as diferentes \n\nfontes de dados disponibilizadas atrav\u00e9s das camadas de Persist\u00eancia e Servi\u00e7os. \n\nTodos os c\u00e1lculos necess\u00e1rios para controlar e garantir a qualidade do fluxo \n\nde produ\u00e7\u00e3o ser\u00e3o desenvolvidos na camada de Neg\u00f3cios. \n\n \n\n4.2.2.5: Camada de Persist\u00eancia \n\n \n\nA camada de Persist\u00eancia \u00e9 respons\u00e1vel pela l\u00f3gica de acesso ao banco de \n\ndados e pelo mapeamento do modelo relacional. Essa camada recebe as \n\nrequisi\u00e7\u00f5es da camada de neg\u00f3cios, retornando informa\u00e7\u00f5es ou persistindo \n\ninforma\u00e7\u00f5es no banco de dados. \n\n \n\n4.2.2.6: Camada de Dados \n\n \n\nA camada de dados \u00e9 respons\u00e1vel pelo armazenamento f\u00edsico dos dados \n\nrepresentativos das entidades do sistema. \u00c9 representada pelo banco de dados \n\nescolhido: SQLServer.  \n\n \n\n \n\n4.2.2.7: Camada de Servi\u00e7os \n\nA Camada de Servi\u00e7os \u00e9 composta por servi\u00e7os que acessam ou fornecem \n\ninforma\u00e7\u00f5es para os sistemas de terceiros, como o SAP e XQI (Sistemas N\u00edvel 2, \n\nLIMS, SIG e WINOE). Essa camada interage com a Camada de Neg\u00f3cios para \n\nbuscar ou armazenar informa\u00e7\u00e3o no MES. Cada servi\u00e7o ir\u00e1 fazer a convers\u00e3o de \n\ndados necess\u00e1ria de/para a estrutura MES ao enviar ou recuperar dados de \n\nsistemas terceiros. Todos os servi\u00e7os ser\u00e3o implementados com o uso de \n\nWebServices para realizar consultas a sistemas de terceiros atrav\u00e9s de SOA, ou \n\n\n\n \n\n 5\n\n7 \n\nprover interfaces que podem ser usados por outros aplicativos para acessar dados \n\ndo MES.  \n\n \n\n4.2.2.8: Modulariza\u00e7\u00e3o \n\n \n\nO Desenvolvimento de sistemas sem uma metodologia geralmente resulta \n\nem um software com v\u00e1rios erros e com alto custo de desenvolvimento que, \n\nconsequentemente, exige um custo elevado para sua manuten\u00e7\u00e3o futura. A \n\nmodulariza\u00e7\u00e3o de programas, juntamente com outras t\u00e9cnicas de programa\u00e7\u00e3o, \n\nintegra o ferramental para a elabora\u00e7\u00e3o de softwares altamente complexo, sem \n\nperder aspectos fundamentais como confiabilidade, legibilidade, f\u00e1cil manuten\u00e7\u00e3o e \n\nflexibilidade. \n\nA solu\u00e7\u00e3o MES deste projeto contempla o desenvolvimento/manuten\u00e7\u00e3o dos \n\nm\u00f3dulos apresentados nas pr\u00f3ximas se\u00e7\u00f5es: \n\n\u2022 M\u00f3dulo Central: \u00e9 respons\u00e1vel por organizar a solu\u00e7\u00e3o MES, al\u00e9m de \n\nconcentrar as funcionalidades gerais da aplica\u00e7\u00e3o. \n\n\u2022 M\u00f3dulo de Produ\u00e7\u00e3o: este m\u00f3dulo foca na gest\u00e3o de capacidades de \n\nprodu\u00e7\u00e3o; tamb\u00e9m mant\u00e9m o registro da posi\u00e7\u00e3o das bobinas na planta de \n\nprodu\u00e7\u00e3o. \n\n\u2022 M\u00f3dulo de Programa\u00e7\u00e3o: este m\u00f3dulo cobre as funcionalidades de \n\nprograma\u00e7\u00e3o da produ\u00e7\u00e3o. \n\n\u2022 M\u00f3dulo de Qualidade: neste m\u00f3dulo tem as funcionalidades relativas ao \n\ncontrole de qualidade. \n\n\u2022 M\u00f3dulo de Campanha: este m\u00f3dulo \u00e9 respons\u00e1vel pelas fun\u00e7\u00f5es de controle \n\nde manuten\u00e7\u00e3o. \n\n \n\n \n\n\n\n \n\n 5\n\n8 \n\n4.2.3: Homologa\u00e7\u00e3o \n\n \n\nA atividade de desenvolvimento de software torna-se cada vez mais \n\ncomplexa \u00e0 medida que usu\u00e1rios sentem a necessidade de interagir com sistemas \n\npara realiza\u00e7\u00e3o de diversas tarefas, da forma mais automatizada, confort\u00e1vel e \n\nfuncional poss\u00edvel. A fim de atender essas necessidades dos usu\u00e1rios, tornou-se \n\nessencial orientar o desenvolvimento do software com foco na qualidade do produto. \n\nPor\u00e9m, para garantir a qualidade de um produto de software, \u00e9 necess\u00e1rio \n\nidentificar as exig\u00eancias impl\u00edcitas e expl\u00edcitas para, posteriormente, avalia-lo. \n\nInfelizmente, o processo de identifica\u00e7\u00e3o de exig\u00eancias ainda \u00e9 bastante complexo \n\nem um software em fase de concep\u00e7\u00e3o. \n\nEnquanto desenvolve-se um software, realizam-se diversos testes, para \n\nsaber se o que foi feito est\u00e1 correto. Alguns testes unit\u00e1rios (como se subentende, \n\numa fun\u00e7\u00e3o apenas) e outros testes integrados (onde se liga a aplica\u00e7\u00e3o e roda-se \n\npasso a passo como se fosse um usu\u00e1rio testando tudo, aplica\u00e7\u00e3o, interface gr\u00e1fica \n\ne banco de dados). Entretanto, os testes de desenvolvedor geralmente est\u00e3o \n\n\u201cviciados\u201d, al\u00e9m de apenas testar pequenas funcionalidades.  \n\nPara garantir a qualidade do software, enquanto desenvolve-o, tem-se uma \n\nequipe especializada em homologa\u00e7\u00e3o respons\u00e1vel por fazer um meio campo entre \n\no desenvolvimento e a especifica\u00e7\u00e3o. Se houve garantia de que o que foi \n\nespecificado \u00e9 o que est\u00e1 sendo desenvolvido (ao mesmo tempo em que se procura \n\nos \u201cbugs\u201d nos softwares e as inconsist\u00eancias no que foi especificado), ent\u00e3o o \n\nretorno \u00e9 positivo. \n\n \n\n4.2.3.1: Trac Integraded SCM &amp; Project Management: \n\n \n\nUsando da filosofia de desenvolvimentos \u00e1geis, tem-se a equipe de \n\nhomologa\u00e7\u00e3o que trabalha concomitantemente \u00e0 equipe de desenvolvimento. As \n\nduas equipes tamb\u00e9m tem conversas face-a-face todos os dias, com o objetivo de \n\nsanar d\u00favidas e trocar ideias. Por\u00e9m, faz-se necess\u00e1rio utilizar algum m\u00e9todo de \n\n\n\n \n\n 5\n\n9 \n\ncontrole de erros e corre\u00e7\u00f5es. No projeto usa-se do software trac, uma abordagem \n\nweb que qualquer pessoa pode acessar pelo navegador porque \u00e9 programa \n\nintegrado com interface para o controle de Subversion.  \n\nNo trac o homologador abre tickets para a equipe de desenvolvimento como \n\nse fosse um pequeno post-it para avisar e ficar gravado o que os desenvolvedores \n\nprecisam fazer. O software tem uma gama de possibilidades para categorizar, \n\nseparando os tickets por vers\u00e3o, prioridades, tipos (defeito, sugest\u00e3o de melhoria, \n\naltera\u00e7\u00e3o de requisito).  \n\n \n\nFigura 25 - P\u00e1gina do Trac Tickets abertos, vis\u00e3o de um desenvolvedor. \n\nO software do track ainda permite tamb\u00e9m aos gerentes e coordenadores \n\nterem uma ideia melhor de como est\u00e1 o desenvolvimento, quem est\u00e1 fazendo o que \n\ne quantos bugs em m\u00e9dia est\u00e3o sendo encontrados. \n\n \n\n\n\n \n\n 6\n\n0 \n\nCap\u00edtulo 5: Descri\u00e7\u00e3o da Implementa\u00e7\u00e3o, M\u00f3dulo de \n\nProdu\u00e7\u00e3o: \n\nComo j\u00e1 foram descritas a infraestrutura do software, as ferramentas usadas \n\ne os modelos de desenvolvimento adotados para que se pudesse desenvolver a \n\naplica\u00e7\u00e3o do M\u00caS, pode-se neste cap\u00edtulo pontuar as partes do software \n\ndesenvolvidas por mim, os quais s\u00e3o os resultados obtidos na confec\u00e7\u00e3o deste PFC. \n\nPrimeiramente ser\u00e1 apresentada uma breve introdu\u00e7\u00e3o aos cadastros do sistema, \n\nem seguida os as telas de produ\u00e7\u00e3o da aciaria, e posteriormente s\u00e3o apresentados \n\na parte de produ\u00e7\u00e3o da lamina\u00e7\u00e3o. No fim se apresenta a parte do Acabamento. \n\n \n\n5.1:   CRUD \n\n \n\nPara o MES poder funcionar de forma correta, s\u00e3o necess\u00e1rios diversos tipos \n\nde informa\u00e7\u00f5es: materiais produzidos, grau de a\u00e7o, an\u00e1lises de qualidade \n\nnecess\u00e1rias, insumos e mat\u00e9ria-prima utilizados na produ\u00e7\u00e3o, informa\u00e7\u00f5es \n\nreferentes a dep\u00f3sitos e baias onde ser\u00e3o guardados a produ\u00e7\u00e3o, entre muitos \n\noutros. \n\nEssas informa\u00e7\u00f5es poderiam ser levantadas e colocadas diretamente no \n\nc\u00f3digo (pr\u00e1tica conhecida como \u201chard coding\u201d). Apesar de esta ser a maneira mais \n\neficiente em tempo de processamento, ela \u201cengessa\u201d o c\u00f3digo de uma forma que se \n\nprecisasse alterar alguma informa\u00e7\u00e3o (como inserir um novo material para ser \n\nproduzido ou alterar algum limite de qualidade de inspe\u00e7\u00e3o) seria necess\u00e1ria abrir o \n\nc\u00f3digo, fazer as altera\u00e7\u00f5es e homologar novamente em um ambiente especifico. \n\nIsso se traduz em um alto custo para a empresa porque s\u00f3 depois de tudo isso feito \n\n\u00e9 levado o novo programa para o ambiente de produ\u00e7\u00e3o.  \n\nVisando a flexibilidade do sistema e a redu\u00e7\u00e3o dos custos de manuten\u00e7\u00e3o, \n\ntodas essas informa\u00e7\u00f5es do processo s\u00e3o salvas no banco de dados e carregadas \n\nquando necess\u00e1rias. Para facilitar o trabalho, para cada tabela de informa\u00e7\u00e3o no \n\n\n\n \n\n 6\n\n1 \n\nbanco de dados foi criada uma tela de \u201ccreate, read, update, delete\u201d (CRUD, o que \n\nsignifica criar, ler, atualizar e apagar), ou seja, apenas as fun\u00e7\u00f5es b\u00e1sicas de \n\npersist\u00eancia dos dados. Sendo assim, n\u00e3o \u00e9 necess\u00e1rio escrever diretamente no \n\nbanco de dados essas informa\u00e7\u00f5es, mas se criar via o sistema. O que possibilita \n\nvalidar se os dados est\u00e3o coerentes, por exemplo, limite superior maior que o \n\ninferior, nomes n\u00e3o repetidos entre outras inconsist\u00eancias de dados. Que viram \n\ncausar inconsist\u00eancias e \u201cbugs\u201d no sistema. \n\nO MES utilizado no projeto pela Radix \u00e9 um sistema relativamente grande \n\nque inclui mais de 40 diferentes CRUDs. Na Figura 26 pode-se ver um exemplo de \n\numa tela de CRUD do sistema. Neste caso foi a tela de dep\u00f3sito, mas todas as \n\noutras telas seguem o mesmo padr\u00e3o que \u00e9: uma aba superior para filtrar os \n\nresultados, uma tabela com as caracter\u00edsticas e os dados que est\u00e3o no banco, uma \n\nlinha cada linha \u00e9 um registro do banco de dados, um bot\u00e3o para abrir a modal de \n\nedi\u00e7\u00e3o e outro para apagar o registro e um bot\u00e3o embaixo da tabela para adicionar \n\nnovas entidades. Para o sistema funcionar todos os dados tem que estar \n\ncadastrados no sistema. \n\n \n\nFigura 26 - Exemplo de Tela de CRUD - Dep\u00f3sito \n\n \n\n\n\n \n\n 6\n\n2 \n\n5.2: Modulo de Programa\u00e7\u00e3o da Produ\u00e7\u00e3o \n\n \n\nApesar dessa parte n\u00e3o ser o foco principal do trabalho \u00e9 necess\u00e1rio \n\napresentar uma breve explica\u00e7\u00e3o para se entender o fluxo de produ\u00e7\u00e3o no sistema.   \n\nA decis\u00e3o de quais e em que quantidades os materiais ser\u00e3o produzidos na \n\nsider\u00fargica n\u00e3o \u00e9 uma decis\u00e3o no n\u00edvel do sistema MES, ela \u00e9 resolvida a n\u00edvel \n\ngerencial e comercial onde se avaliam diversos fatores da economia, pedidos de \n\nclientes e pe\u00e7as em estoques. Em posse dos dados do que se devem produzir, \n\nestes s\u00e3o inseridos no sistema SAP (Systeme, Anwendungen und Produkte in der \n\nDatenverarbeitung, em portugu\u00eas: Sistemas, Aplicativos e Produtos para \n\nProcessamento de Dados). O SAP no final de cada m\u00eas envia os dados de quais \n\nmateriais dever\u00e3o ser produzidos no m\u00eas seguinte para a aciaria. Esses dados no \n\nsistema s\u00e3o chamados de ordem de produ\u00e7\u00e3o. A produ\u00e7\u00e3o da lamina\u00e7\u00e3o e do \n\nacabamento \u00e9 enviada no meio durante o m\u00eas corrente. \n\nDe posse dessas informa\u00e7\u00f5es o operador da programa\u00e7\u00e3o do MES, por meio \n\nda interface web, organiza e ordena a produ\u00e7\u00e3o dos pr\u00f3ximos dias com tempos \n\nte\u00f3ricos de produ\u00e7\u00e3o. Essas informa\u00e7\u00f5es ser\u00e3o enviadas para o n\u00edvel dois e ficar\u00e3o \n\nvis\u00edveis para os operadores de produ\u00e7\u00e3o para que estes possam por fim realizar a \n\nprodu\u00e7\u00e3o. \n\n \n\n5.2.1: Programa\u00e7\u00e3o Aciaria \n\n \n\nNa aciaria recebe-se a informa\u00e7\u00e3o de quais materiais dever\u00e3o ser produzidos \n\nno m\u00eas inteiro. A partir disso o programador pode montar a programa\u00e7\u00e3o repetindo \n\nos materiais que foram pedidos at\u00e9 o fim do m\u00eas. Conforme ele cria uma \n\nprograma\u00e7\u00e3o de n toneladas, o sistema MES cria um n\u00famero de corridas suficiente \n\npara produzir essas n toneladas (j\u00e1 que o peso produzido por corrida \u00e9 um \n\npar\u00e2metro ajust\u00e1vel no sistema).  \n\n \n\n\n\n \n\n 6\n\n3 \n\n \n\nFigura 27 - Programador da Aciaria \n\n \n\n5.2.2: Programa\u00e7\u00e3o da Lamina\u00e7\u00e3o/Acabamento \n\n \n\nDiferente da aciaria (que recebe as ordens dos materiais por m\u00eas), a \n\nlamina\u00e7\u00e3o e o acabamento recebem as ordens no decorrer do m\u00eas. Cada ordem de \n\nprodu\u00e7\u00e3o fica dispon\u00edvel na tela de programa\u00e7\u00e3o para ser ordenada pelo \n\nprogramador, e para isso o usu\u00e1rio conta com uma funcionalidade de drag and drop, \n\ntoda desenvolvida via JavaScript.   \n\nCom essas informa\u00e7\u00f5es se tem as ordens em que os materiais ser\u00e3o \n\nproduzidos, no ch\u00e3o de f\u00e1brica.  \n\n\n\n \n\n 6\n\n4 \n\n \n\nFigura 28 - Programador da Lamina\u00e7\u00e3o \n\n \n\n \n\n5.3: Acompanhamento Produ\u00e7\u00e3o da Aciaria: \n\n \n\nO ciclo de produ\u00e7\u00e3o de uma aciaria para a ind\u00fastria sider\u00fargica de a\u00e7os \n\nlongos foi previamente explicado no capitulo 2.2.1:. O ferro-gusa e a sucata s\u00e3o \n\njogados numa panela onde s\u00e3o fundidos no Forno El\u00e9trico a Arco. Depois o a\u00e7o \n\nl\u00edquido \u00e9 levado para o forno panela e fica um tempo at\u00e9 atingir propriedades \n\nqu\u00edmicas ideais. Por fim o a\u00e7o l\u00edquido \u00e9 despejado no lingotador (onde solidifica e \u00e9 \n\ncortado tomando a forma do tarugo), e \u00e9 posteriormente enviado ao p\u00e1tio ou \n\ndiretamente para a pr\u00f3xima etapa do processo. \n\n \n\n5.3.1: Casos de Uso \n\n \n\nCasos de uso s\u00e3o narrativas das funcionalidades de um sistema ou parte \n\ndele do ponto de vista do usu\u00e1rio. Nesse diagrama n\u00e3o s\u00e3o aprofundados os \n\ndetalhes t\u00e9cnicos de como o sistema ir\u00e1 realizar as fun\u00e7\u00f5es, ele apenas descreve \n\nqual deve ser o comportamento do sistema no caso do usu\u00e1rio realizar uma a\u00e7\u00e3o. \n\n\n\n \n\n 6\n\n5 \n\nPara a produ\u00e7\u00e3o da Aciaria temos apenas um ator, que \u00e9 o apontador de produ\u00e7\u00e3o, \n\ncomo exemplificado na Figura 29. \n\n \n\n uc Acompanhamento da Produ\u00e7\u00e3o\n\nUC02-02 - Visualizar \n\nProgramas\n\nUC02-15 - Apontar \n\nprodu\u00e7\u00e3o\n\nRF02-07 - Registrar \n\nManualmente o Consumo \n\nde Insumos e Utilidades\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-01 - Exibir Lista de \n\nCorridas\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-02 - Exibir Detalhes da \n\nCorrida\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-05 - Exibir \n\nInforma\u00e7\u00f5es de Consumo de \n\nInsumos e Utilidades\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-06 - Alterar Consumo \n\nde Insumos e Utilidades\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-08 - Exibir Vari\u00e1veis \n\nCr\u00edticas de Processo\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-09 - Exibir Ocorr\u00eancias \n\npor Lote\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-14 - Apontar \n\nReclassifica\u00e7\u00e3o\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-13 - Re-enquadrar \n\nProdu\u00e7\u00e3o\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-15 - Apontar Bloqueio\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-16 - Apontar Produ\u00e7\u00e3o\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-17 - Apontar Perdas \n\nde Processo e Sucatas de \n\nProduto\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-19 - Calcular T otais de \n\nProdu\u00e7\u00e3o\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-03 - Registrar Eventos \n\nda Produ\u00e7\u00e3o\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-04 - Exibir \n\nComparativo de Realizado x \n\nProgramado na Produ\u00e7\u00e3o\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nUC02-13 - Iniciar \n\nEquipamento\n\nUC02-14 - Finalizar \n\nEquipamento\n\nRF02-22 - Iniciar \n\nEquipamento\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-23 - Finalizar \n\nEquipamento\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF03-01 - Exibir Lista de \n\nPrograma\u00e7\u00f5es\n\n(from Modulo de Programa\u00e7\u00e3o)\n\nRF03-06 - Exibir detalhes do \n\nprograma\n\n(from Modulo de Programa\u00e7\u00e3o)\n\nUC02-03 - Visualizar \n\nDetalhes do Programa\n\nUC02-04 - Visualizar \n\nDetalhes do Lote\n\nUC02-05 - Visualizar \n\nPropriedades do Lote\n\nUC02-06 - Visualizar \n\nConsumos do Lote\n\nUC02-08 - Visualizar \n\nParadas do Lote\n\nUC02-09 - Visualizar \n\nOcorr\u00eancias de Lote\n\nUC02-10 - Visualizar \n\nPrograma de Lote\n\nUC02-11 - Visualizar \n\nQualidade de Lote\n\nUC02-12 - Visualizar \n\nVari\u00e1v eis Cr\u00edticas de \n\nLote\n\nRF02-24 - Exibir Paradas por \n\nLote\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-25 - Exibir Detalhes do \n\nPrograma por Lote\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nRF02-26 - Exibir Detalhes de \n\nQualidade Por Lote\n\n(from Modulo de Produ\u00e7\u00e3o)\n\nUC02-07 - Editar \n\nConsumos do Lote\n\nA05 - Apontador \n\nProdu\u00e7\u00e3o\n(from \n\nAtores)\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb\n\n\u00abextend\u00bb\n\n\u00abtrace\u00bb\n\n\u00abtrace\u00bb \u00abtrace\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb \u00abextend\u00bb\n\n\u00abextend\u00bb\n\n\u00abextend\u00bb\n\n \n\nFigura 29 - Casos de uso do Acompanhamento de produ\u00e7\u00e3o da Aciaria \n\nDiagrama UML \n\n\n\n \n\n 6\n\n6 \n\n \n\n5.3.2: Descri\u00e7\u00e3o da Implementa\u00e7\u00e3o \n\n \n\nUma vez descrita a infraestrutura criada para que se pudessem desenvolver o \n\nMES de maneira simples e objetiva, neste cap\u00edtulo ser\u00e3o apresentadas um resumo \n\ndas funcionalidades desenvolvidas para atender aos requisitos e casos de uso \n\nespecificados com o cliente. Os mesmos s\u00e3o os resultados obtidos na confec\u00e7\u00e3o \n\ndeste PFC.  \n\n \n\n5.3.2.1: Visualizar Programa\u00e7\u00e3o \n\n \n\nO objetivo de dessa funcionalidade \u00e9 o de permitir a visualiza\u00e7\u00e3o dos programas \n\nde produ\u00e7\u00e3o e suas informa\u00e7\u00f5es, possibilitando a filtragem dos mesmos por:  \n\n? Per\u00edodo (Data In\u00edcio e Data Fim), \n\n? C\u00f3digo do programa, \n\n? Material programado, \n\n? Grau do a\u00e7o programado, \n\n? Situa\u00e7\u00e3o do programa. \n\n? Lote. \n\n \n\nComo essa \u00e9 uma das funcionalidades mais simples do acompanhamento da \n\nprodu\u00e7\u00e3o, ser\u00e1 descrito um passo-a-passo do fluxo de informa\u00e7\u00e3o do programa real. \n\nO objeto do filtro \u00e9 criado dinamicamente via JavaScript (JS) no navegador do \n\nusu\u00e1rio. O usu\u00e1rio escolhe o alcance da sua busca preenchendo os campos da \n\ninterface gr\u00e1fica (Figura 30). Quando o usu\u00e1rio acabar o preenchimento dos dados \n\nde sua busca, confirma a opera\u00e7\u00e3o clicando no bot\u00e3o buscar. Esse evento de clique \n\n\n\n \n\n 6\n\n7 \n\ndo bot\u00e3o ativa uma fun\u00e7\u00e3o do JS que monta um objeto de filtro, criando uma \n\nrequisi\u00e7\u00e3o AJAX e a envia para o servidor da aplica\u00e7\u00e3o. \n\n \n\nFigura 30 - Interface gr\u00e1fica para filtro de Programa\u00e7\u00f5es \n\n \n\nA requisi\u00e7\u00e3o \u00e9 direcionada via URL na seguinte rota: servidor, aplica\u00e7\u00e3o e \n\ncontrolador. O objeto criado \u00e9 uma string serializada que pode ser interpretada por \n\nqualquer linguagem de programa\u00e7\u00e3o. Na Figura 31 \u00e9 poss\u00edvel ver como foi \n\nconstru\u00edda a requisi\u00e7\u00e3o lan\u00e7ada pelo navegador. Para criar a imagem foi utilizado o \n\nnavegador Google Chrome, o que mostra a flexibilidade e robustez do sistema ao \n\nser utilizado em plataformas diferentes da especificada (Internet Explorer 8).  \n\n \n\n \n\nFigura 31 - Requisi\u00e7\u00e3o HTTP Post feita pelo navegador \n\n  \n\n A requisi\u00e7\u00e3o chega ao servidor IIS (onde podem estar rodando diversas \n\naplica\u00e7\u00f5es) que redireciona a requisi\u00e7\u00e3o para a aplica\u00e7\u00e3o chamada, neste caso, de \n\nMESACOSLONGOSHML (ambiente de homologa\u00e7\u00e3o do sistema). O framework \n\n\n\n \n\n 6\n\n8 \n\nASP .NET inicializa o controlador chamado \u201cProdu\u00e7\u00e3oAciaria\u201d, deserializa os \n\npar\u00e2metros passados e realiza a chamada da fun\u00e7\u00e3o \u201cFilter\u201d com seus respectivos \n\npar\u00e2metros. Na Figura 32 podemos ver o resultado da deserializa\u00e7\u00e3o com a fun\u00e7\u00e3o \n\ndo controlador correspondente sendo invocada. \n\n  \n\n \n\nFigura 32 - Requisi\u00e7\u00e3o AJAX chegando no controlador \n\n \n\nO controlador por sua vez chama a aplica\u00e7\u00e3o de neg\u00f3cios, requisitando a lista \n\nde programa\u00e7\u00f5es. Como a fun\u00e7\u00e3o de listar n\u00e3o tem nenhuma regra de neg\u00f3cio \n\nassociada \u00e0 camada de neg\u00f3cios, esta simplesmente redireciona a requisi\u00e7\u00e3o para \n\na camada de persist\u00eancia, sendo que a camada de persist\u00eancia, auxiliada pelos \n\nframeworks de acesso ao banco (Radix e .NET), injeta a query no banco de dados. \n\nA camada de persist\u00eancia recupera os registros do banco os mapeia para as \n\nclasses da nossa aplica\u00e7\u00e3o, no caso uma lista de programa\u00e7\u00f5es (Entidade da Figura \n\n33). A lista de programa\u00e7\u00f5es da aciaria volta os n\u00edveis em que entrou: aplica\u00e7\u00e3o -> \n\nneg\u00f3cios -> controlador; o controlador, de posse da lista, retorna uma nova tabela \n\nem HTML renderizada via razor.  \n\nNa Figura 34 temos a resposta da requisi\u00e7\u00e3o, uma com arquivo em HTML, que \n\nvia jQuery carregamos no lugar da tabela que estava anteriormente. Na Figura 42 \n\npodemos ver a interface gr\u00e1fica para o usu\u00e1rio final. \n\n\n\n \n\n 6\n\n9 \n\n \n\nFigura 33 - Entidade Programa\u00e7\u00e3o Aciaria \n\n  \n\n \n\nFigura 34 - Resposta da Requisi\u00e7\u00e3o AJAX \n\n \n\n\n\n \n\n 7\n\n0 \n\n \n\nFigura 35 - Resultado da Busca do Operador \n\n \n\n5.3.2.2: Visualizar Lotes  \n\n \n\nPermite a visualiza\u00e7\u00e3o dos detalhes de um determinado lote. Cada \n\nprograma\u00e7\u00e3o \u00e9 composta por \u201cn\u201d corridas da aciaria (Figura 36). O usu\u00e1rio \n\napontador de produ\u00e7\u00e3o seleciona a programa\u00e7\u00e3o que ele quer abrir os detalhes e \n\numa lista das corridas programadas \u00e9 aberta para visualiza\u00e7\u00e3o (o esquema de \n\nchamada \u00e9 o mesmo).  \n\n  \n\nFigura 36 - Entidade Corrida \n\n \n\n\n\n \n\n 7\n\n1 \n\nNessa tabela o operador, ou o supervisor da \u00e1rea, pode ver a quantidade de \n\ncorridas programadas, qual o lote que elas geraram o material que vai ser \n\nproduzido, e ent\u00e3o fazer uma compara\u00e7\u00e3o gr\u00e1fica de qual grau a\u00e7o foi produzido, \n\nqual grau foi programado, qual foi \u00e0 produ\u00e7\u00e3o programada e quanto foi efetivamente \n\nproduzido. Al\u00e9m disso, ele pode ver a dura\u00e7\u00e3o de cada corrida. No bot\u00e3o \u00e0 direita \n\nest\u00e1 o cora\u00e7\u00e3o do apontamento de produ\u00e7\u00e3o (ele abre a janela de acompanhamento \n\nde produ\u00e7\u00e3o).  \n\n \n\n \n\nFigura 37 - Tabela de detalhes dos lotes \n\n \n\n5.3.2.3: Modal Acompanhamento da Corrida \n\n5.3.2.3.1: Aba Propriedades \n\n \n\nCada corrida da aciaria passa pelos tr\u00eas equipamentos de produ\u00e7\u00e3o desta: \n\nforno el\u00e9trico a arco, forno panela e lingotamento cont\u00ednuo. \u00c9 fundamental para o \n\nacompanhamento da produ\u00e7\u00e3o saber os tempos de funcionamento de cada \n\nequipamento e onde a corrida se encontra. Esses dados devem ser adicionados \n\nmanualmente nessa aba, ou podem ser recebidos do sistema de n\u00edvel dois. Eles \n\ns\u00e3o salvos no banco de dados e podem ser acompanhados enquanto a corrida est\u00e1 \n\nem execu\u00e7\u00e3o, ou at\u00e9 meses depois que ela terminou. Al\u00e9m disso, disp\u00f5e ao \n\noperador diversas informa\u00e7\u00f5es como a numera\u00e7\u00e3o do lote e a panela utilizada no \n\nprocesso (ambas s\u00e3o recebidas do N2 ou inseridas manualmente) . \n\nPara se salvar o status da corrida da aciaria criou-se uma tabela \n\nindependente do banco de dados (Figura 38), onde \u00e9 poss\u00edvel saber qual o estado \n\n\n\n \n\n 7\n\n2 \n\nda corrida em determinado data e em qual equipamento de produ\u00e7\u00e3o ela se \n\nencontra. O fluxo de inicializa\u00e7\u00e3o e finaliza\u00e7\u00e3o de equipamentos \u00e9 importante, pois \n\nest\u00e1 relacionado com o m\u00f3dulo de qualidade. Para cada equipamento que \u00e9 iniciado \n\ns\u00e3o criadas as amostras necess\u00e1rias para a equipe de qualidade. \n\n \n\nFigura 38 - Entidade utilizada para representar o estado da corrida \n\n   \n\n\n\n \n\n 7\n\n3 \n\n \n\nFigura 39 - Aba de Propriedades \n\n \n\n5.3.2.3.1.1: Integra\u00e7\u00e3o com M\u00f3dulo de Qualidade  \n\n \n\nAp\u00f3s o operador iniciar a corrida no forno el\u00e9trico a arco (sua requisi\u00e7\u00e3o \u00e9  \n\nenviada at\u00e9 a classe respons\u00e1vel pelas regras de neg\u00f3cio), primeiramente \u00e9 feito \n\num tratamento de erro onde verifica-se a consist\u00eancia dos dados em rela\u00e7\u00e3o ao \n\nestado atual do sistema. Caso encontre um erro (por exemplo o programador \n\ncancelou essa corrida), retorna uma mensagem de erro ao usu\u00e1rio. Caso n\u00e3o tenha \n\nnada de errado nessa mensagem, s\u00e3o duas regras de neg\u00f3cios que tem que ser \n\ncumpridas: atualizar o novo estado do sistema e acessar a classe do m\u00f3dulo de \n\nparadas respons\u00e1vel por inserir as amostras. A consist\u00eancia dos dados \u00e9 garantida \n\natrav\u00e9s de transa\u00e7\u00f5es no banco de dados. O Framework da Radix trata as \n\ntransa\u00e7\u00f5es de forma praticamente autom\u00e1tica, e com ao auxilio da biblioteca: \n\n\u201cUnity.InterceptionExtension\u201d conseguimos capturar todas as invoca\u00e7\u00f5es aos \n\nm\u00e9todos da camada de neg\u00f3cios.  \n\nPara isso basta atribuir um atributo ao m\u00e9todo chamado para garantir que \n\ntodas as escritas no banco se encontrem dentro de uma mesma transa\u00e7\u00e3o, \n\nconforme Figura 40. \n\n\n\n \n\n 7\n\n4 \n\n \n\nFigura 40 - Avisando ao Framework que \u00e9 necess\u00e1rio abrir uma transa\u00e7\u00e3o \n\npara essa fun\u00e7\u00e3o. \n\nO uso de interceptadores (Figura 41) tamb\u00e9m \u00e9 usado para centralizar a \n\nescrita do log de erros na aplica\u00e7\u00e3o, que \u00e9 toda exce\u00e7\u00e3o n\u00e3o tratada (try/catch). Seu \n\nuso est\u00e1 de acordo com as filosofias de desenvolvimento \u00e1geis adotada pela Radix, \n\nporque diminui o tempo necess\u00e1rio para desenvolver uma funcionalidade, reduz a \n\nduplica\u00e7\u00e3o do c\u00f3digo, acrescenta uma grande melhoria para a qualidade da \n\naplica\u00e7\u00e3o, garantindo que todas as fun\u00e7\u00f5es rodar\u00e3o aquela parte do c\u00f3digo de \n\nescrita no log e de abertura de transa\u00e7\u00e3o, incrementa consideravelmente a \n\nqualidade do c\u00f3digo tornando-o mais limpo (v\u00e3o ter apenas as regras de neg\u00f3cio), \n\nn\u00e3o precisando se preocupar com abertura de transa\u00e7\u00f5es e tratamento de erros no \n\nmeio do c\u00f3digo. \n\n  \n\n \n\nFigura 41 - Interceptadores \n\n \n\n5.3.2.3.1.2: Integra\u00e7\u00e3o com o N\u00edvel Dois \n\n \n\nDiversos dados da aba de propriedades s\u00e3o informa\u00e7\u00f5es que s\u00e3o \n\nprocessadas no n\u00edvel dois. Para ser poss\u00edvel a comunica\u00e7\u00e3o entre dois sistemas \n\ndiferentes \u00e9 necess\u00e1rio escolher um padr\u00e3o, e o padr\u00e3o adotado pelo cliente para \n\n\n\n \n\n 7\n\n5 \n\nfazer a comunica\u00e7\u00e3o entre os seus sistemas \u00e9 o padr\u00e3o XQI (XML Query Interface), \n\nj\u00e1 que o objetivo de adotar um padr\u00e3o \u00e9 de minimizar o trabalho dos \n\ndesenvolvedores. O meio de campo \u00e9 feito por um servi\u00e7o da pr\u00f3pria empresa, que \n\ngarante a entrega da mensagem. \n\n \n\n \n\nFigura 42 - Vis\u00e3o Geral Integra\u00e7\u00e3o XQI \n\nO padr\u00e3o XQI consiste em dois grupos de tabela: uma para mensagens que o \n\nsistema ira receber (IN) e outro que o sistema ir\u00e1 enviar (OUT). Cada grupo \u00e9 \n\ncomposto por 3 tabelas, sendo a primeira de cabe\u00e7alho chamado \n\n(XQI_(IN/OUT)_HEADER, a segunda contendo as informa\u00e7\u00f5es da mensagem \n\n(XQI_(IN/OUT)_BODY e uma terceira usada para fazer o log dos erros \n\n(XQI_(IN/OUT)_ERRORLOG). Os dois grupos de tabela anteriores est\u00e3o dispon\u00edveis \n\nem ambos sistemas, ent\u00e3o quando o MES deseja enviar uma mensagem ao n\u00edvel \n\ndois ele escreve na tabela XQI_OUT_HEADER e XQI_OUT_BODY, informando no \n\ncabe\u00e7alho que o destinat\u00e1rio \u00e9 o sistema de n\u00edvel dois. Consequentemente, o \n\nservi\u00e7o XQI entrega a mensagem para as tabelas XQI_IN_HEADER e \n\nXQI_IN_BODY  do banco do n\u00edvel 2. \n\nS\u00e3o estes os campos da tabela: \n\n? XQI_*_HEADER (campos de endere\u00e7amento e informa\u00e7\u00f5es de gerais): \n\no Source foi quem enviou a mensagem, por exemplo: \n\n\"PROCOM_ALVR_EAF\u201d (forno el\u00e9trico). \n\no Message_Id significa identificador \u00fanico. \n\n\n\n \n\n 7\n\n6 \n\no Target \u00e9 quem ir\u00e1 receber a mensagem MES_LONGOS_VR. \n\no Message_Type: diz qual mensagem \u00e9, por exemplo \"EAF_HETD\u201d significa \n\n\u201ct\u00e9rmino da produ\u00e7\u00e3o do forno el\u00e9trico\u201d. \n\no Expiration_Time: data de validade da mensagem. \n\no Msg_Status Flag: para sinalizar erros no processamento. \n\no Date_Time_In: data/hora de recebimento da mensagem. \n\no Date_Time_Proc: data/hora que o sistema realmente processou a \n\nmensagem. \n\no Retry_Count: n\u00famero de tentativas de processamento. O padr\u00e3o XQI \n\ntenta processar a mensagem automaticamente 5 vezes, se n\u00e3o h\u00e1 \n\nsucesso em nenhuma dessas cinco tentativas ele marca a mensagem \n\ncomo erro. \n\n? XQI_*_BODY (corpo da mensagem): onde diz que os dados realmente s\u00e3o \n\nenviados, e cada mensagem pode ter uma ou mais linhas de corpo: \n\no Source e Message_Id s\u00e3o ambos iguais ao Header, ele associaa o \n\ncabe\u00e7alho ao corpo. \n\no Field_Seq: identificador \u00fanico. \n\no Feature: o campo, por exemplo, \u201cBEGIN_TIME\u201d da mensagem \n\n\u201cEAF_HETD\u201d \u00e9 o tempo de inicio do forno el\u00e9trico. \n\no Value: valor do campo (feature) passado. Cada campo de cada \n\nmensagem \u00e9 salvo como uma cadeia de caracteres, permitindo passar \n\nqualquer tipo de dado. \u00c9 combinado a priori com os desenvolvedores de \n\nambas aplica\u00e7\u00f5es o formato que campo vai ser escrito. No exemplo acima \n\n\n\n \n\n 7\n\n7 \n\no campo begin time \u00e9 passado como: \u201cYYYYMMDD hhmmss\u201d  (ano, m\u00eas, \n\ndia, espa\u00e7o em branco, hora minuto, segundo). \n\n \n\nFigura 43 - Tabelas de Entrada e Sa\u00edda do padr\u00e3o XQI \n\n \n\nO servi\u00e7o XQI do cliente \u00e9 um servi\u00e7o passivo que copia o que est\u00e1 na tabela \n\nde sa\u00edda de um sistema para a tabela de entrada do outro sistema. Para o MES \n\npoder processar os dados, foi necess\u00e1rio o desenvolvimento de um servi\u00e7o \n\nWindows chamado de XQIMapperService. O trabalho do servi\u00e7o \u00e9 o mais simples, \n\nele l\u00ea a tabela de entrada do sistema, v\u00ea se tem algo novo, l\u00ea a mensagem \n\nnovamente e se a mensagem estiver mapeada, chama a fun\u00e7\u00e3o da camada de \n\nneg\u00f3cios especifica para process\u00e1-la. Caso ocorra algum erro no processo, escreve-\n\nse no log (arquivo .txt e na tabela XQI_*_LOGGER). Se o n\u00famero de \n\nreprocessamento da mensagem bateu no limite, ent\u00e3o a mensagem \u00e9 marcada \n\ncomo erro (no campo MSG_STATUS). Se a mensagem for processada sem \n\n\n\n \n\n 7\n\n8 \n\nproblemas, marca-se que j\u00e1 foi processada (para n\u00e3o precisar processar \n\nnovamente). \n\n \n\n5.3.2.3.2: Aba Qualidade, Ocorr\u00eancias e Paradas: \n\n \n\nEssas abas fazem interface com outros m\u00f3dulos do sistema. Elas fornecem \n\ninforma\u00e7\u00f5es para o operador da planta (s\u00e3o apenas para leitura).  \n\nO m\u00f3dulo de paradas \u00e9 um modulo onde s\u00e3o registradas todas as paradas \n\ndo sistema, tanto as programadas (para manuten\u00e7\u00e3o) quanto as n\u00e3o programadas \n\n(falhas de equipamento). \n\n O m\u00f3dulo de qualidade \u00e9 onde ocorre toda a inspe\u00e7\u00e3o do a\u00e7o a fim de \n\ngarantir que ele tenha as propriedades qu\u00edmicas necess\u00e1rias (como \u201ccomposi\u00e7\u00e3o de \n\ncarbono\u201d).  \n\nJ\u00e1 o modulo de ocorr\u00eancias registra ocorr\u00eancias gen\u00e9ricas do sistema (essas \n\ninforma\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis apenas para leitura). \n\n \n\n \n\nFigura 44 - Interface com o resultado das an\u00e1lises de qualidade da corrida \n\n  \n\n5.3.2.3.3: Aba Apontamento de Produ\u00e7\u00e3o \n\n \n\n\n\n \n\n 7\n\n9 \n\nDepois de a corrida terminar (ou seja, ela ter passado por todos os \n\nequipamentos), as amostras da qualidade s\u00e3o confirmadas pelo respons\u00e1vel. O \n\noperador da aciaria passa pelo processo final de confirmar a produ\u00e7\u00e3o. Neste \n\nm\u00f3dulo ele \u00e9 respons\u00e1vel por informar ao MES quantas pe\u00e7as foram produzidas e \n\nde quanto foram as perdas de produto e/ou processo que ocorreu. Por\u00e9m, a mais \n\nimportante responsabilidade \u00e9 decidir qual o destino das pe\u00e7as. O operador tem tr\u00eas \n\nescolhas: ele pode colocar as pe\u00e7as em livre utiliza\u00e7\u00e3o, ele pode bloquear elas ou \n\nent\u00e3o reclassificar a localiza\u00e7\u00e3o f\u00edsica (dep\u00f3sito/baia) das mesmas. \n\nSe as pe\u00e7as estiverem liberadas, ser\u00e1 poss\u00edvel utiliz\u00e1-la no processo \n\nposterior, a lamina\u00e7\u00e3o. Se alguma delas estiver bloqueada, esta ser\u00e1 enviada para a \n\nequipe de qualidade que ter\u00e1 o trabalho de decidir o destino: ou a pe\u00e7a vira sucata \n\nou o lote de pe\u00e7as \u00e9 liberado. \n\n \n\nFigura 45 - Aba de Apontamento de Produ\u00e7\u00e3o \n\n \n\n \n\n \n\n\n\n \n\n 8\n\n0 \n\n \n\n\n\n \n\n 8\n\n1 \n\nCap\u00edtulo 6: Conclus\u00f5es e Perspectivas \n\nO trabalho desenvolvido durante o est\u00e1gio na Radix foi uma \u00f3tima \n\noportunidade de crescimento profissional porque permitiu o contato com o mercado \n\nde trabalho, como tamb\u00e9m foi poss\u00edvel poder sair como engenheiro com uma \n\nexcelente experi\u00eancia em um projeto expressivo na \u00e1rea de Engenharia.  \n\nA ind\u00fastria sider\u00fargica \u00e9 uma \u00e1rea muito interessante para a engenharia. \n\nCom processos bastante complexos, \u00e9 necess\u00e1ria a utiliza\u00e7\u00e3o das mais recentes \n\ntecnologias para a \u00e1rea de TI visando poder competir de frente com um mercado \n\ncada vez mais seletivo.  \n\nO interesse pela \u00e1rea de software e programa\u00e7\u00e3o despertado em mim \n\ndurante a gradua\u00e7\u00e3o tornou-se ainda mais acentuado durante o per\u00edodo de est\u00e1gio. \n\nA experi\u00eancia de participar t\u00e3o expressivamente de um projeto de grande porte foi \n\nmuito gratificante. Foi enorme o conhecimento adquirido, n\u00e3o s\u00f3 na \u00e1rea t\u00e9cnica, \n\nmas tamb\u00e9m estar junto e presenciar como se planeja e se organiza equipes para \n\nconstru\u00e7\u00e3o de softwares relativamente complexos.  \n\nAo fim dessa parte do projeto, considero que tanto o meu trabalho em \n\nparticular como o trabalho da equipe de desenvolvimento que participei foram um \n\nsucesso.  \n\nFalando individualmente, entrei no projeto sem saber nada sobre as \n\nlinguagens utilizadas e com um conhecimento muito raso sobre a estrutura de \n\nprograma\u00e7\u00e3o utilizada. Comecei apenas programando telas de Cadastro, as mais \n\nsimples do sistema. No entanto, tive uma curva de aprendizado alta e j\u00e1 no meio do \n\nprojeto fiquei respons\u00e1vel por telas de alta complexidade e import\u00e2ncia para o \n\nsistema (as telas de produ\u00e7\u00e3o). \n\nEm n\u00edvel de equipe foi feito um \u00f3timo projeto, cumprimos os prazos de \n\nentrega corretamente. Tanto nosso modelo de dados como o software foi sempre \n\nvalidado sem muito estresse, e mesmo tendo algumas altera\u00e7\u00f5es no requisito em \n\ntempo de projeto conseguimos executa-las sem estragar ou atrasar o que estava \n\nsendo desenvolvido.  \n\n\n\n \n\n 8\n\n2 \n\nMas o projeto ainda n\u00e3o est\u00e1 terminado, ainda temos alguns meses de testes \n\nreais de integra\u00e7\u00e3o com os outros sistemas, e alguns meses de opera\u00e7\u00e3o assistida \n\ndos quais espero poder participar.  \n\nPara a Radix o sucesso em projetos desse tipo tem grande import\u00e2ncia. A \n\nrealiza\u00e7\u00e3o de projetos com qualidade, dentro do prazo e do or\u00e7amento aumenta a \n\nvisibilidade e o reconhecimento da empresa junto aos seus clientes. O sucesso em \n\nprojetos nessa \u00e1rea permitiu \u00e0 Radix expandir seu portfolio de clientes para muito \n\nal\u00e9m da \u00e1rea de petr\u00f3leo e g\u00e1s (no qual muitas empresas de engenharia ainda s\u00e3o \n\nextremamente dependentes). \n\nNovos projetos de desenvolvimento dessa \u00e1rea est\u00e3o por vir nos quais irei \n\nparticipar ativamente com engenheiro.  \n\n\n\n \n\n 8\n\n3 \n\nBibliografia: \n\n[ 1 ] FILGUEIRAS, Dra. L\u00facia V. L.; MELNIKOFF, Dra. Selma Shin Shimizu, \n\n\u201cEngenharia de Software\u201d  \n\n[ 2 ] Site RI  \n\nhttp://www.mzweb.com.br/csn/web/default_pt.asp?idioma=0&amp;conta=28 \n\n[ 3 ] V.B. Mazzola e J-M Farines, \u201cMetodologias de Concep\u00e7\u00e3o de Software e \n\nde Sistemas\u201d \n\n[ 4 ] B. Boehm. Balancing \u201cAgility and Discipline: A Guide for the Perplexed\u201d. \n\n[ 5 ] R. C. Martin \u2013 \u201cC\u00f3digo Limpo, Habilidades Pr\u00e1ticas do Agile Software\u201d. \n\n \n\nhttp://www.mzweb.com.br/csn/web/default_pt.asp?idioma=0&amp;conta=28"}]}}}