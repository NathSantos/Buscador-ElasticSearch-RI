{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.20257"}, {"@name": "filename", "#text": "3729_PFC-20121-BrunoMartinsRahal.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Desenvolvimento de um Sistema de \nMonitora\u00e7\u00e3o e Valida\u00e7\u00e3o para \u00e1reas \n\nde Transfer\u00eancia e Estocagem de \numa Refinaria de Petr\u00f3leo \n\n \n\n \n\nRelat\u00f3rio submetido \u00e0 Universidade Federal de Santa Catarina \n\ncomo requisito para a aprova\u00e7\u00e3o da disciplina: \n\nDAS 5511: Projeto de Fim de Curso \n\nBruno Martins Rahal \n\nFlorian\u00f3polis, Agosto de 2012 \n\n  \n\n\n\n2 \n\n \n\n \n\nDesenvolvimento de um Sistema de Monitora\u00e7\u00e3o e \nValida\u00e7\u00e3o para \u00e1reas de Transfer\u00eancia e Estocagem de \n\numa Refinaria de Petr\u00f3leo \n\n \nBruno Martins Rahal \n\nEste relat\u00f3rio foi julgado no contexto da disciplina  \nDAS 5511: Projeto de Fim de Curso \n\ne aprovado na sua forma final pelo \nCurso de Engenharia de Controle e Automa\u00e7\u00e3o \n\n \nBanca Examinadora: \n \n\n \nEng. Diogo Ferreira Pacheco, Me. \n\nOrientador Radix \n \n\n \nProfessor R\u00f4mulo Silva de Oliveira, Dr. \n\nOrientador acad\u00eamico \n \n\n \nProfessor Ricardo Jos\u00e9 Rabelo, Dr. \n\nRespons\u00e1vel pela disciplina \n \n\n \nProfessor Max Hering de Queiroz, Dr. \n\nAvaliador \n \n\n \nFernando Corteccioni Nu\u00f1ez Del Prado \n\nDebatedor \n \n\n \nT\u00e1rik Medeiros Siqueira \n\nDebatedor \n \n \n\n\n\n3 \n\n \n\nAgradecimento \n\n \n\n \n\n \n\n \n\n \n\nAos meus pais, \n\ncomo se dissesse \u00e1gua. \n\n\n\n4 \n\n \n\nResumo \n\nUm sistema de automa\u00e7\u00e3o \u00e9 um termo gen\u00e9rico e amplo, podendo englobar \n\nsistemas simples que realizam opera\u00e7\u00f5es antes operadas por humanos com for\u00e7a \n\nbruta (como abrir e fechar um port\u00e3o) at\u00e9 gigantecos sistemas fabris. Estes podem, \n\ninclusive, ser monitorados remotamente. Nestas opera\u00e7\u00f5es, diversos tipos e uma \n\nenorme quantidade de dados s\u00e3o gerados. Mant\u00ea-los e saber utiliz\u00e1-los com \n\ndestreza \u00e9 fundamental para otimizar uma opera\u00e7\u00e3o. \n\nNeste sentido, este trabalho buscou desenvolver um sistema de monitora\u00e7\u00e3o \n\nde dados de uma refinaria de petr\u00f3leo, validando-os, para torn\u00e1-los mais confi\u00e1veis e \n\nconsistentes ao processo. Al\u00e9m disso, um centralizador de dados foi desenvolvido \n\npara o projeto, que busca evitar que sistemas se comuniquem com diversos outros, \n\ntornando um emaranhado de comunica\u00e7\u00e3o. Assim, os sistemas recorrem a esta \n\nfonte \u00fanica de dados, quando necessitam de informa\u00e7\u00e3o. \n\nAs atividades neste projeto fazem parte do escopo da disciplina DAS5511 \u2013 \n\nProjeto de Fim de Curso, do curso de gradua\u00e7\u00e3o em Engenharia de Controle e \n\nAutoma\u00e7\u00e3o da Universidade Federal de Santa Catarina. Al\u00e9m disso, foi desenvolvido \n\nna empresa Radix \u2013 Engeharia e Software. \n\nInicialmente, s\u00e3o apresentadas a empresa, um motivador do projeto, al\u00e9m de \n\nobjetivos e metodologia de trabalho. Ap\u00f3s isso, conceitos b\u00e1sicos s\u00e3o apresentados, \n\ncom toda a fundamenta\u00e7\u00e3o base do trabalho. Por fim, \u00e9 apresentada a solu\u00e7\u00e3o, \n\ndetalhando alguns aspectos do sistema, baseada na teoria previamente \n\napresentada. \n\n \n\n \n\nPalavras-chave: monitora\u00e7\u00e3o, valida\u00e7\u00e3o, automa\u00e7\u00e3o. \n\n\n\n5 \n\n \n\nAbstract  \n\nAn automation system is a generic and wide term, which can refer itself to \n\nsimple systems that just do brute force operations, which was made by humans (like \n\nopening and closing a gate), but can also refer to huge manufacturing systems, that \n\ncan even be remotely operated. Several kinds and an enormous quantity of data are \n\ngenerated in processes. Maintaining and knowing how to use them smartly is \n\nessential to optimize an operation. \n\nIn this sense, this paper describes the development of a monitoring system to \n\nthe data of an oil refinery. This data is also validated, being more reliable and \n\nconsistent with the process. Moreover, a data centralizer was developed, which aims \n\nto avoid that systems communicate with others systems, when some data is needed. \n\nThey must, now,  appeal to this unique data source, becoming a non-mazy system. \n\nThe activities in this project are part of the scope of the DAS5511 \u2013 Projeto de \n\nFim de Curso class, of the Control and Automation degree course of the Santa \n\nCatarina Federal University. The project was developed in Radix \u2013 Engineering and \n\nSoftware company, \n\nIn the document, it is first presented the company, an appeal to the project, as \n\nwell its objectives and work methodology. After that, basic concepts are shown, with \n\nall the theory and basis fundamentation of the work. Finally, the solution is presented, \n\ndetailing some system aspects, based on the theory presented before. \n\n \n\n \n\n \n\nKeywords: monitoring, validation, automation. \n\n\n\n6 \n\n \n\nSum\u00e1rio  \n\n \nAgradecimento ................................................................................................. 3 \n\nResumo ............................................................................................................ 4 \n\nAbstract ............................................................................................................ 5 \n\nSum\u00e1rio ............................................................................................................ 6 \n\nLista de Figuras e Tabelas ............................................................................... 8 \n\nCap\u00edtulo 1: Introdu\u00e7\u00e3o ...................................................................................... 9 \n\n1.1: Institucional .......................................................................................... 10 \n\n1.2: Metodologia de Trabalho ..................................................................... 12 \n\n1.2.1: Objeto de Estudo e Objetivos ........................................................ 12 \n\n1.2.2: Desenvolvimento do Projeto .......................................................... 13 \n\n1.2.3: O trabalho no contexto da Engenharia de Controle e Automa\u00e7\u00e3o . 14 \n\nCap\u00edtulo 2: Fundamentos para Solu\u00e7\u00e3o ......................................................... 16 \n\n2.1: OPC ..................................................................................................... 16 \n\n2.2: C# .NET ............................................................................................... 18 \n\n2.2.1: Framework Radix .......................................................................... 19 \n\n2.2.2: Banco de dados ............................................................................. 21 \n\n2.3: Ferramenta Automatizadora de Procedimentos ................................... 21 \n\n2.3.1: Codifica\u00e7\u00e3o em Lua ....................................................................... 23 \n\n2.3.2: Gera\u00e7\u00e3o de Fluxogramas e Defini\u00e7\u00e3o de Atributos de Classes..... 23 \n\n2.3.3: Servidor de Execu\u00e7\u00e3o ................................................................... 24 \n\nCap\u00edtulo 3: Desenvolvimento .......................................................................... 25 \n\n3.1: BDTR ................................................................................................... 25 \n\n3.1.1: Servidor OPC DA .......................................................................... 26 \n\n\n\n7 \n\n \n\n3.1.2: Servidor OPC A&amp;E ........................................................................ 29 \n\n3.2: Monitora\u00e7\u00e3o e Valida\u00e7\u00e3o de Sinais ...................................................... 33 \n\n3.2.1: Algoritmos de Valida\u00e7\u00e3o ................................................................ 35 \n\n3.3: Monitora\u00e7\u00e3o em C# .............................................................................. 38 \n\n3.3.1: Modelo de Dados .......................................................................... 39 \n\n3.3.2: Interface......................................................................................... 41 \n\n3.3.3: Implementa\u00e7\u00e3o das Regras de Neg\u00f3cio ........................................ 43 \n\n3.4: Monitora\u00e7\u00e3o na Ferramenta Automatizadora de Procedimentos ......... 47 \n\n3.4.1: Codifica\u00e7\u00e3o .................................................................................... 47 \n\n3.4.2: Configura\u00e7\u00e3o da Planta ................................................................. 48 \n\n3.4.3: Gera\u00e7\u00e3o dos Fluxogramas ............................................................ 49 \n\n3.4.4: Opera\u00e7\u00e3o e Aplica\u00e7\u00e3o: Execu\u00e7\u00e3o .................................................. 51 \n\n3.4.5: Interface......................................................................................... 52 \n\nCap\u00edtulo 4: Resultados ................................................................................... 53 \n\n4.1: Resultados da Monitora\u00e7\u00e3o ................................................................. 53 \n\n4.1.1: Escopo do Teste ............................................................................ 53 \n\n4.1.2: Cen\u00e1rios de Teste ......................................................................... 54 \n\n4.1.3: Resultados dos Testes .................................................................. 56 \n\n4.2: Plano de Testes ................................................................................... 57 \n\n4.3: Discuss\u00e3o sobre os testes ................................................................... 59 \n\nCap\u00edtulo 5: Conclus\u00f5es e Perspectivas .......................................................... 61 \n\nBibliografia: ..................................................................................................... 62 \n\n \n\n \n\n  \n\n\n\n8 \n\n \n\nLista de Figuras e Tabelas \n\nFigura 1 - \u00c1reas de Atua\u00e7\u00e3o da Radix ................................................................................. 11 \n\nFigura 2 - Campo, Servidor OPC e Clientes OPC ................................................................ 17 \n\nFigura 3 - Fluxo dos Dados OPC ......................................................................................... 18 \n\nFigura 4 \u2013 Duas representa\u00e7\u00f5es de modelo MVC ................................................................ 20 \n\nFigura 5 \u2013 Arquitetura da Ferramenta Automatizadora de Procedimentos ........................... 22 \n\nFigura 6 \u2013 Interface Excel da BDTR ..................................................................................... 27 \n\nFigura 7 \u2013 BDTR executando ............................................................................................... 28 \n\nFigura 8 \u2013 Chamadas S\u00edncrona, Ass\u00edncrona e por Subscri\u00e7\u00e3o, respectivamente ................ 29 \n\nFigura 9 - Eventos disparados pela BDTR ........................................................................... 30 \n\nFigura 10 - Alarmes emitidos pela BDTR, sem reconhecimento .......................................... 30 \n\nFigura 11 - Alarmes emitidos pela BDTR, sendo reconhecidos ........................................... 30 \n\nFigura 12 - Alarmes emitidos pela BDTR ............................................................................. 31 \n\nFigura 13 \u2013 Divis\u00e3o por espa\u00e7os de \u00e1rea e de eventos do servidor OPC A&amp;E..................... 32 \n\nFigura 14 - Software de Monitora\u00e7\u00e3o e da BDTR unificada.................................................. 34 \n\nFigura 15 - Diagrama de Caso de Uso - Valida\u00e7\u00e3o de Sinal ................................................ 39 \n\nFigura 16 \u2013 Modelo de Dados - Valida\u00e7\u00e3o de Sinal ............................................................. 40 \n\nFigura 17 - Filtragem de Configura\u00e7\u00f5es ............................................................................... 41 \n\nFigura 18 - Cria\u00e7\u00e3o de Configura\u00e7\u00e3o Anal\u00f3gica ................................................................... 42 \n\nFigura 19 - Cria\u00e7\u00e3o de Configura\u00e7\u00e3o Anal\u00f3gica Feita pelo Webdesigner............................. 42 \n\nFigura 20 \u2013 Implementa\u00e7\u00e3o da M\u00ednima Varia\u00e7\u00e3o em C# ...................................................... 46 \n\nFigura 21 - Implementa\u00e7\u00e3o da M\u00ednima Varia\u00e7\u00e3o em Lua ..................................................... 48 \n\nFigura 22 \u2013 Configura\u00e7\u00e3o e Inser\u00e7\u00e3o de Par\u00e2metros para TAGs Anal\u00f3gicas ....................... 49 \n\nFigura 23 \u2013 Resumo das configura\u00e7\u00f5es inseridas ................................................................ 49 \n\nFigura 24 - Fluxo de TAG Anal\u00f3gica .................................................................................... 50 \n\nFigura 25 - Fluxo de TAG Digital .......................................................................................... 50 \n\nFigura 26 - Servidor da ferramenta executando ................................................................... 51 \n\nFigura 27 \u2013 Interface IHM para a Monitora\u00e7\u00e3o e Valida\u00e7\u00e3o de Sinais .................................. 52 \n\n \n\nTabela 1 \u2013 Tipos de TAG e seus algoritmos ........................................................................ 35 \n\nTabela 2 \u2013 Cen\u00e1rios de Teste da Monitora\u00e7\u00e3o..................................................................... 55 \n\nTabela 3 \u2013 Resultados dos Cen\u00e1rios de Teste..................................................................... 57 \n\nTabela 4 \u2013 Resultado de uma Valida\u00e7\u00e3o.............................................................................. 58 \n\n\n\n9 \n\n \n\nCap\u00edtulo 1: Introdu\u00e7\u00e3o \n\nNo s\u00e9culo XIX, quando o primeiro po\u00e7o de petr\u00f3leo foi descoberto, pouco \n\ntalvez se soubesse do qu\u00e3o importante seria esta descoberta para o futuro. A \n\nrevolu\u00e7\u00e3o industrial, ocorrida pouco depois, impulsionou o uso de energia para a \n\nmanufatura e buscou-se v\u00e1rias alternativas para o carv\u00e3o, a primeira fonte de \n\nenergia das revolu\u00e7\u00f5es industriais. \n\nO petr\u00f3leo \u00e9 uma fonte de energia n\u00e3o-renov\u00e1vel e seu interesse comercial \n\ncresceu vertiginosamente desde sua descoberta. Este foi, inclusive, a raz\u00e3o de \n\ncrises e guerras, cujo vencedor buscava formas de dominar a explora\u00e7\u00e3o em certas \n\n\u00e1reas. \n\nNo Brasil, a primeira sondagem ocorreu ainda no final do s\u00e9culo XIX, em S\u00e3o \n\nPaulo. Esta foi frustrada, tendo a perfura\u00e7\u00e3o apenas encontrado \u00e1gua sulfurosa. \n\nApenas em 1939, na Bahia, \u00e9 que se encontrou petr\u00f3leo em terras brasileiras. Com \n\no objetivo de monopolizar a explora\u00e7\u00e3o de petr\u00f3leo no Brasil, a Petrobras \u2013 Petr\u00f3leo \n\nBrasileiro S/A foi criada, em 1953 [2]. Hoje, diversas empresas atuam na explora\u00e7\u00e3o \n\nde petr\u00f3leo e de energia, sendo a estatal brasileira uma das refer\u00eancias mundiais \n\npara explora\u00e7\u00e3o em \u00e1guas profundas.  \n\nA explora\u00e7\u00e3o de petr\u00f3leo e seu tratamento para ser um produto comerci\u00e1vel, \n\ncriou diferentes ramos de atua\u00e7\u00e3o, com diversas empresas atuando em cada um \n\ndesses lucrativos neg\u00f3cios: explora\u00e7\u00e3o, produ\u00e7\u00e3o, refino, comercializa\u00e7\u00e3o e \n\ntransporte de petr\u00f3leo e seus derivados. \n\nO uso de petr\u00f3leo e seus derivados \u00e9 vasto. Al\u00e9m de gerar gasolina, \n\ncombust\u00edvel para motores de combust\u00e3o interna, v\u00e1rios outros derivados do petr\u00f3leo \n\npodem ser produzidos: parafina, g\u00e1s natural, GLP, asfalto, nafta, querosene, \n\nsolventes, \u00f3leos combust\u00edveis, \u00f3leos lubrificantes, diesel e combust\u00edvel de avia\u00e7\u00e3o. \n\nA explora\u00e7\u00e3o do petr\u00f3leo, comandada por uma \u00fanica empresa, produzindo \n\nsua tecnologia, desde a explora\u00e7\u00e3o at\u00e9 o transporte \u00e9 dif\u00edcil. Assim, muitas \n\nempresas de presta\u00e7\u00e3o de servi\u00e7o existem ao redor destas gigantes exploradoras de \n\n\n\n10 \n\n \n\npetr\u00f3leo. Desde a extra\u00e7\u00e3o at\u00e9 o transporte, muitos servi\u00e7os s\u00e3o terceirizados em \n\nbusca de um produto final de qualidade. \n\nEm 2007, uma enorme quantidade de petr\u00f3leo em po\u00e7os na camada de pr\u00e9-\n\nsal foi descoberto no mar brasileiro. Devido a crise mundial que teve in\u00edcio em 2008, \n\na explora\u00e7\u00e3o dos estimados 80 bilh\u00f5es de barris de petr\u00f3leo e g\u00e1s no pr\u00e9-sal n\u00e3o \n\nteve tanto investimento quanto esperado. Com o parecer do reestabelecimento da \n\n\u201cnormalidade\u201d na economia mundial, a explora\u00e7\u00e3o desta \u00e1rea come\u00e7ou a receber \n\ngrandes investimentos. Com o aumento da extra\u00e7\u00e3o, as outras \u00e1reas de trabalho \n\nrelacionadas com o petr\u00f3leo, tamb\u00e9m est\u00e3o sofrendo expans\u00e3o.  \n\nEste trabalho, ser\u00e1 desenvolvido no contexto do refino do petr\u00f3leo \n\ndesenvolvendo um sistema de valida\u00e7\u00e3o e de um banco de dados para uma \n\nrefinaria. A Radix - Engenharia e Software \u00e9 respons\u00e1vel por produzir estes sistemas \n\nque ir\u00e3o gerir os dados da planta da refinaria, al\u00e9m de monitorar e valid\u00e1-los. \n\n \n\n1.1: Institucional \n\nA Radix \u2013 Engenharia e Software, como pode ser visto na refer\u00eancia [3], foi \n\nfundada em abril de 2010, pelo ex-CEO da Chemtech, Luiz Rubi\u00e3o e outros ex-\n\nfuncion\u00e1rios da Chemtech, que se tornaram s\u00f3cios-diretores e s\u00f3cios gerentes na \n\nRadix: Fl\u00e1vio Guimar\u00e3es, Jo\u00e3o Chachamovitz, Alexander Cramer, Maur\u00edcio Miele, \n\nFl\u00e1vio Waltz e Paulo Rego. Outros funcion\u00e1rios foram recrutados, alguns da \n\nChemtech (tamb\u00e9m empresa de engenharia e software) e, no in\u00edcio, menos de 50 \n\nfuncion\u00e1rios estavam trabalhando na Radix. Sua sede est\u00e1 localizada no Rio de \n\nJaneiro \u2013 RJ, possuindo tamb\u00e9m um escrit\u00f3rio em Belo Horizonte \u2013 MG. \n\nHoje, dois anos depois, a empresa conta com mais de 200 funcion\u00e1rios, \n\naltamente capacitados, e um faturamento maior que 20 milh\u00f5es de reais. A miss\u00e3o \n\nda empresa \u00e9: \u201cOferecer servi\u00e7os de engenharia e software diferenciados pela \n\nexcel\u00eancia t\u00e9cnica e \u00e9tica e com independ\u00eancia tecnol\u00f3gica, ampliando os valores \n\ngerados para clientes, funcion\u00e1rios e s\u00f3cios, a partir de um compromisso de longo \n\nprazo firmado com a sociedade, o Pa\u00eds e o meio ambiente\u201d. \n\n\n\n11 \n\n \n\nA empresa considera que um dos seus principais patrim\u00f4nios \u00e9 sua equipe. \n\nIsto \u00e9 reconhecido pelos funcion\u00e1rios, haja visto que a Radix foi eleita a melhor \n\nempresa para se trabalhar no Brasil e a 4\u00aa melhor da Am\u00e9rica Latina. Al\u00e9m disso, \n\ntem satisfa\u00e7\u00e3o completa de seus clientes, contando tamb\u00e9m com certifica\u00e7\u00f5es ISO. \n\n \n\nFigura 1 - \u00c1reas de Atua\u00e7\u00e3o da Radix \n\nNa figura acima, est\u00e3o as \u00e1reas de atua\u00e7\u00e3o da empresa. Como pode-se \n\nnotar, h\u00e1 uma multidisciplinariedade nos campos apresentados, exigindo equipes \n\ntamb\u00e9m multidisciplinares e especializadas, capazes de atender as exig\u00eancias dos \n\nseus clientes com agilidade e compet\u00eancia t\u00e9cnica. Alguns dos clientes da Radix, \n\nneste dois anos de empresa, s\u00e3o e foram: CSN, AkerSolutions, Keppel, TV Globo, \n\nQueiroz Galv\u00e3o, Transpetro, Petrobras e Monsanto. \n\nAl\u00e9m disso, a Radix considera essencial manter um relacionamento pr\u00f3ximo \n\ncom as institui\u00e7\u00f5es acad\u00eamicas brasileiras, ajudando e patrocinando diversos \n\neventos acad\u00eamicos. Na UFSC, a empresa patrocina a equipe Vento Solar e em \n\noutras universidades patrocina tamb\u00e9m eventos como BAJA SAE e eventos de \n\nrob\u00f3tica. \n\n \n\n \n\n \n\n\n\n12 \n\n \n\n1.2: Metodologia de Trabalho \n\nNesta se\u00e7\u00e3o, ser\u00e3o descritos como o trabalho se desenvolveu, o que foi \n\nestudado e o cronograma, al\u00e9m de como um engenheiro de controle e automa\u00e7\u00e3o se \n\nsitua na \u00e1rea. A Radix foi contratada para prestar servi\u00e7os para uma refinaria e \u00e9 \n\nneste contexto que o trabalho ocorreu, mais precisamente para a \u00e1rea de \n\nTransfer\u00eancia e Estocagem (TE) de uma refinaria. \n\n1.2.1: Objeto de Estudo e Objetivos \n\nNa refinaria, e como diversas ind\u00fastrias, n\u00e3o se disp\u00f5e de uma ferramenta \n\ncentralizada para armazenagem, monitora\u00e7\u00e3o e valida\u00e7\u00e3o de dados, em tempo real. \n\nIsto reduz a confiabilidade dos dados disponibilizados pelas v\u00e1rias fontes de \n\ninforma\u00e7\u00e3o da planta, podendo comprometer informa\u00e7\u00f5es geradas. Como n\u00e3o \u00e9 \n\nposs\u00edvel classificar a qualidade dos dados, poucas a\u00e7\u00f5es podem ser realizadas no \n\nsentido de minimizar a propaga\u00e7\u00e3o de erros. Al\u00e9m disso, existe a necessidade de \n\numa padroniza\u00e7\u00e3o no tratamento e disponibiliza\u00e7\u00e3o das vari\u00e1veis de processo (valor \n\ne qualidade) para outras aplica\u00e7\u00f5es. \n\nIsto implica que os softwares da refinaria monitorem as entidades necess\u00e1rias \n\npara automa\u00e7\u00e3o e suporte operacional das \u00e1reas, obtendo dados diretamente da \n\nplanta. Essa monitora\u00e7\u00e3o n\u00e3o \u00e9 padronizada. Cada aplica\u00e7\u00e3o (isoladamente) \u00e9 \n\nrespons\u00e1vel pela valida\u00e7\u00e3o de seus dados. A padroniza\u00e7\u00e3o e unifica\u00e7\u00e3o das \n\nmonitora\u00e7\u00f5es s\u00e3o dificultadas, pois existem diversos bancos de dados na refinaria.  \n\nIdealmente, as aplica\u00e7\u00f5es ou sistemas instalados devem utilizar um \u00fanico \n\nBanco de Dados de Tempo Real como fonte de dados, a BDTR. A partir do \n\ndesenvolvimento desta base centralizada, a monitora\u00e7\u00e3o e valida\u00e7\u00e3o dos sinais \n\nser\u00e3o padronizadas e unificadas. \n\nO software de monitora\u00e7\u00e3o faz parte do conjunto de aplica\u00e7\u00f5es projetadas \n\npara auxiliar as opera\u00e7\u00f5es da refinaria, se comunicando essencialmente com a \n\nBDTR. A solu\u00e7\u00e3o permitir\u00e1: uma valida\u00e7\u00e3o unificada e centralizada dos sinais \n\n(dados); a monitora\u00e7\u00e3o de outras aplica\u00e7\u00f5es (componentes e servi\u00e7os); e o \n\nmonitoramento dos estados da planta.  \n\n\n\n13 \n\n \n\nA partir deste acompanhamento e dos alertas emitidos pelo sistema \n\n(dispon\u00edveis para outras aplica\u00e7\u00f5es), problemas poder\u00e3o ser identificados e \n\nsolucionados com anteced\u00eancia, aumentando a produtividade da \u00e1rea, a \n\nconfiabilidade dos dados disponibilizados e minimizando a propaga\u00e7\u00e3o de erros. \n\nUma efici\u00eancia maior para o processo em geral ser\u00e1 alcan\u00e7ada. \n\nA base de dados (BDTR) receber\u00e1 os dados da planta e de seus SDCD\u2019s \n\n(Sistema Digital de Controle Distribu\u00eddo) atrav\u00e9s do protocolo OPC, portanto se \n\nconfigurando como um cliente OPC. O SDCD, por sua vez, colher\u00e1 os dados da \n\nplanta, e se comunicar\u00e1, idealmente, \u00fanica e exclusivamente com a BDTR.  \n\nEste sistema centralizado disponibilizar\u00e1 dados para os sistemas de n\u00edveis \n\nacima deste, tamb\u00e9m via protocolo OPC. Portanto, a BDTR tamb\u00e9m ser\u00e1 um \n\nservidor OPC, atuando como cliente e servidor, neste protocolo. Assim, os sistemas \n\nde mais alto n\u00edveis n\u00e3o buscar\u00e3o dados diretamente na planta (nos SDCD\u2019s), e sim \n\npassar\u00e3o a ter a BDTR como fonte de dados. \n\nO software de monitora\u00e7\u00e3o ser\u00e1 um cliente OPC que consumir\u00e1 dados da \n\nBDTR, executar\u00e1 diversos algoritmos para valida\u00e7\u00e3o destes dados e os \n\ndisponibilizar\u00e1 novamente na BDTR. Os diversos clientes da BDTR poder\u00e3o obter \n\nestes dados validados ou os dados originais, colhidos da planta. A aplica\u00e7\u00e3o destes \n\nalgoritmos, entretanto, garantem dados mais confi\u00e1veis, mais robustos e com menor \n\npropaga\u00e7\u00e3o de erros para quem quiser consum\u00ed-los. Alguns destes algoritmos \n\nprev\u00eaem a exclus\u00e3o de valores com erros grosseiros, aplica\u00e7\u00e3o de filtros e outras \n\nvalida\u00e7\u00f5es de sinais. \n\n1.2.2: Desenvolvimento do Projeto \n\nPara a obten\u00e7\u00e3o de resultados conclusivos, as atividades ser\u00e3o \n\ndesenvolvidas com supervis\u00e3o do orientador do projeto na Radix, Diogo Pacheco, e \n\ntamb\u00e9m sob orienta\u00e7\u00e3o do professor Dr. R\u00f4mulo Silva de Oliveira.  \n\nAl\u00e9m disso, diversoss documentos gerados para o desenvolvimento do \n\nprojeto foram estudados. Assim, antes do in\u00edcio do desenvolvimento ocorreu a \n\nrevis\u00e3o bibliogr\u00e1fica para entendimento do problema e da solu\u00e7\u00e3o proposta. \n\n\n\n14 \n\n \n\nEstes documentos definem a fun\u00e7\u00e3o de um sistema de software e foram uma \n\nboa documenta\u00e7\u00e3o que garante o desenvolvimento de um software de qualidade. \n\nS\u00e3o exemplos destes documentos: requisitos funcionais e n\u00e3o funcionais do projeto, \n\narquitetura da solu\u00e7\u00e3o, regras de neg\u00f3cio e casos de uso..  \n\nAp\u00f3s estudada a bibliografia, a execu\u00e7\u00e3o da solu\u00e7\u00e3o ser\u00e1 executada. Isto \n\nenvolve a programa\u00e7\u00e3o do sistema em si, a partir das regras de neg\u00f3cio e casos de \n\nuso, respeitando a arquitetura projetada. A princ\u00edpio, o projeto previa 12 meses (um \n\nano) para sua conclus\u00e3o. Entretanto, devido diversos fatores fizeram com que o \n\nprazo inicial fosse reestipulado. \n\nEntretanto, para testar a viabilidade do projeto, uma parte m\u00ednima do sistema \n\nfoi desenvolvida e entregue para testes na refinaria. Esta primeira parte envolve a \n\nvalida\u00e7\u00e3o de sinais da BDTR e a pr\u00f3pria BDTR.  \n\nCom o seguimento do projeto, embora atrasados no prazo inicial, as demais \n\nfuncionalidades ser\u00e3o agregadas e implementados na solu\u00e7\u00e3o. Entre eles, sistemas \n\nintegra\u00e7\u00e3o de qualidade, monitora\u00e7\u00e3o de tanques de armazenamento e identifica\u00e7\u00e3o \n\nde movimenta\u00e7\u00e3o err\u00f4nea, entre outros. \n\nPor fim, a documenta\u00e7\u00e3o necess\u00e1ria, tanto para documenta\u00e7\u00e3o do projeto \n\nquanto para a disciplina DAS5511 \u2013 Projeto de Fim de Curso, \u00e9 gerada. Entre os \n\ndocumentos est\u00e3o: casos de teste para as funcionalidades implementadas (com \n\nresultados esperados, resultados do teste) para documentar a execu\u00e7\u00e3o do projeto e \n\nrelat\u00f3rios executivos e monografia para a gradua\u00e7\u00e3o. \n\n1.2.3: O trabalho no contexto da Engenharia de Controle e Automa\u00e7\u00e3o  \n\nDurante toda a gradua\u00e7\u00e3o, disciplinas foram cursadas e podem ser aplicadas \n\nde maneira direta ou indireta ao projeto, algumas sendo vitais ao seguimento deste, \n\noutras apenas como auxiliares. Para iniciar citando disciplinas, este trabalho se \n\ndesenvolveu no contexto da disciplina DAS5511 \u2013 Projeto de Fim de Curso. O \n\nprofessor Doutor R\u00f4mulo Silva de Oliveira participa como orientador acad\u00eamico e \n\ncomo visto abaixo, ministra para o trip\u00e9 de inform\u00e1tica industrial da gradua\u00e7\u00e3o. \n\nAlgumas das disciplinas que tiveram conte\u00fados aplicados de maneira direta \n\nno desenvolvimento global do projeto s\u00e3o as ligadas ao cerne de inform\u00e1tica \n\n\n\n15 \n\n \n\nindustrial e foram fundamentais para a execu\u00e7\u00e3o do projeto. Al\u00e9m disso, as \n\ndisciplinas de automa\u00e7\u00e3o foram importantes para o entendimento da arquitetura do \n\nplanta e da escolha da melhor solu\u00e7\u00e3o: \n\n? DAS5305 e DAS5306 \u2013 Inform\u00e1tica Industrial I e II: CLPs, arquiteturas \n\nde automa\u00e7\u00e3o, programa\u00e7\u00e3o concorrente, sistemas de tempo real. \n\n? INE5225 \u2013 Fundamentos de Sistema de Banco de Dados: modelagem \n\nde dados, estruturas de armazenamento, requisitos funcionais. \n\n? DAS5314 \u2013 Redes de Computadores para Automa\u00e7\u00e3o Industrial: n\u00edveis \n\nhier\u00e1rquicos no modelo CIM, redes industriais, projetos de \n\npadroniza\u00e7\u00e3o. \n\n? DAS5315 \u2013 Sistemas Distribu\u00eddos para Automa\u00e7\u00e3o Industrial: \n\narquiteturas de sistemas distribu\u00eddos, CORBA, webservices. \n\n? DAS5316 \u2013 Integra\u00e7\u00e3o de Sistemas Corporativos: sistemas CIM; \n\nsistemas de informa\u00e7\u00e3o e de armazenamento: banco de dados e web-\n\nservers; interopera\u00e7\u00e3o de sistemas: CORBA &amp; DCOM; interopera\u00e7\u00f5es \n\nde dados: XML. \n\nOutras disciplinas puderam ter conte\u00fados aproveitados, quando enfocadas \n\npara o contexto do projeto, e propiciaram a base para o desenvolvimento, como dito, \n\nprincipalmente as ligadas a inform\u00e1tica industrial, que apresentaram os fundamentos \n\nde programa\u00e7\u00e3o. Al\u00e9m das disciplinas citadas, tamb\u00e9m devem ser lembradas todas \n\nas que foram de pr\u00e9-requisito para estas, haja visto que forneceram uma base s\u00f3lida \n\npara a elabora\u00e7\u00e3o e execu\u00e7\u00e3o do projeto. \n\n\n\n16 \n\n \n\nCap\u00edtulo 2: Fundamentos para Solu\u00e7\u00e3o \n\nNeste cap\u00edtulo s\u00e3o apresentadas as t\u00e9cnicas que embasam a solu\u00e7\u00e3o, assim \n\ncomo a teoria que permite assegurar que a solu\u00e7\u00e3o \u00e9 vi\u00e1vel e poss\u00edvel de ser \n\nimplementada. Ser\u00e1 apresentado primeiramente, como a comunica\u00e7\u00e3o deve ser \n\nfeita, via OPC. Ap\u00f3s isso, ser\u00e1 apresentado como essa comunica\u00e7\u00e3o ser\u00e1 utilizada e \n\nprogramada para assegurar que os requisitos funcionais sejam implementados. \n\n2.1: OPC \n\nDiversos protocolos existem hoje para controle e comunica\u00e7\u00e3o nas plantas \n\nindustriais. Cada um destes protocolos possuem vantagens e desvantagens que, em \n\nbaixo n\u00edvel, em n\u00edvel de planta, contribuem para um melhor desempenho global da \n\nopera\u00e7\u00e3o. Entretanto, diversos padr\u00f5es e protocolos de comunica\u00e7\u00e3o acabaram \n\ngerando sistemas de automa\u00e7\u00e3o de grande complexidade, compostas por redes que \n\npouco interoperam entre si.  \n\nPor cada protocolo ter tamb\u00e9m vantagens em rela\u00e7\u00f5es a outros, a \n\nespecifica\u00e7\u00e3o da solu\u00e7\u00e3o da planta industrial com produtos de um \u00fanico fabricante \u00e9 \n\ndif\u00edcil. Al\u00e9m de ser virtualmente imposs\u00edvel em alguns casos, tal abordagem n\u00e3o \u00e9 \n\ndesej\u00e1vel do ponto de vista de mercado, pela depend\u00eancia que se cria de um \n\nmesmo fornecedor. \n\nDada a necessidade, entretanto, de haver a troca de informa\u00e7\u00f5es nas mais \n\ndiversas camadas de aplica\u00e7\u00e3o como tamb\u00e9m de diferentes protocolos, um \n\nprotocolo aberto e padronizado foi desenvolvido. O OPC (inicialmente denominada \n\nOLE for Process Control, baseada em tecnologia Microsoft, hoje, chamado de Open \n\nProcess Control) surge neste sentido. Este protocolo foi desenvolvido por um grupo \n\nde fabricantes em conjunto com a Microsoft, com objetivo de possibilitar a troca \n\ntransparente de dados entre diversos tipos de aplica\u00e7\u00f5es, integrando redes \n\nheterog\u00eaneas, no modelo Cliente/Servidor. Hoje, o protocolo OPC \u00e9 mantido por \n\ndiversas empresas e suas especifica\u00e7\u00f5es podem ser encontradas no website da \n\nfunda\u00e7\u00e3o OPC [4]. \n\n\n\n17 \n\n \n\nUm servidor OPC se conecta a um outro dispositivo como um Controlador \n\nL\u00f3gico Program\u00e1vel (CLP), Unidade de Terminal Remoto (RTU), Sistema Digital de \n\nControle Distribu\u00eddo (SDCD) ou outra fonte de dados como um banco de dados ou \n\ninterface com usu\u00e1rio. Ao receber esta informa\u00e7\u00e3o, o dado \u00e9 transformado para o \n\nformato padronizado do OPC. A interoperabilidade \u00e9 garantida via cria\u00e7\u00e3o e \n\nmanuten\u00e7\u00e3o de padr\u00f5es abertos. \n\nDessa forma, um cliente OPC pode se conectar a este servidor e ler e \n\nescrever dados de e para dispositivios. Dispositivos clientes s\u00e3o, por exemplo, IHM \n\n(Interfaces Humano-M\u00e1quina), aplica\u00e7\u00f5es desenvolvidas ou um historiador de log. A \n\npadroniza\u00e7\u00e3o faz com que a necessidade de programar um cliente espec\u00edfico para \n\ncada dispositivo de campo n\u00e3o exista mais, com a troca de dados ocorrendo de \n\nmaneira comum, com uma interface padr\u00e3o e de maneira f\u00e1cil de ser reutilizada. \n\n \n\nFigura 2 - Campo, Servidor OPC e Clientes OPC \n\nA figura acima mostra o servidor OPC conectado a diferentes dispositivos no \n\ncampo. Estes dipositivos podem ser de diferentes fabricantes e que se comunicam \n\nentre outros dispositivos de campo com seu protocolo propriet\u00e1rio. O servidor OPC \n\nrecebe esses dados e disponibiliza a seus clientes de maneira padronizada. Por \n\nexemplo, se modificarmos o servidor OPC, de um desenvolvedor para outro, todo o \n\nsistema deve continuar a funcionar, sem maiores problemas.  \n\n\n\n18 \n\n \n\nNote, por\u00e9m, que pode haver duas formas de comunica\u00e7\u00e3o: o SDCD ou o \n\nCLP \u00e9 um provedor de dados OPC para aplica\u00e7\u00f5es clientes, sendo j\u00e1 um servidor \n\nOPC ou este prov\u00ea um driver para que um servidor OPC obtenha os dados de suas \n\nentradas e sa\u00eddas, com os valores de campo. \n\n \n\nFigura 3 - Fluxo dos Dados OPC \n\nExistem diversas especifica\u00e7\u00f5es OPC atualmente, j\u00e1 desenvolvidas ou em \n\ndesenvolvimento. As principais s\u00e3o OPC DA (Data Access) e OPC A&amp;E (Alarms &amp; \n\nEvents) e que s\u00e3o as utilizadas neste trabalho. O OPC DA \u00e9 a especifica\u00e7\u00e3o original: \n\nusada para mover dados em tempo real de CLPs, SDCDs, e outros dispositivos de \n\ncontrole como IHMs e aplica\u00e7\u00f5es cliente. Atualmente, a vers\u00e3o 3.0 \u00e9 a utilizada, \n\npermitindo alterar dados do sinal OPC, como qualidade do sinal e timestamp. \n\nO OPC A&amp;E disponibiliza alarmes e eventos sob demanda (em contraste com \n\na troca de dados cont\u00ednua do OPC DA). As informa\u00e7\u00f5es trocadas neste protocolo \n\ns\u00e3o alarmes disparados pelo processo, a\u00e7\u00f5es do operador, mensagens adicionais e \n\nmensagens de acompanhamento e auditoria. \n\nOutros protocolos que desenvolvidos ou est\u00e3o em desenvolvimento s\u00e3o: OPC \n\nBatch, OPC Data eXchange, OPC Historical Data Access, OPC Security e OPC \n\nXML-DA. O OPC Unified Architecture (UA) \u00e9 a pr\u00f3xima gera\u00e7\u00e3o de padr\u00f5es OPC \n\nque prover\u00e1 uma plataforma coesa, segura e confi\u00e1vel para acessar dados e \n\neventos hist\u00f3ricos e em tempo real. \n\n2.2: C# .NET \n\nC# \u00e9 uma linguagem de programa\u00e7\u00e3o fortemente tipada, orientada a objetos, \n\nimperativa, declarativa e funcional [1]. Foi desenvolvida pela Microsoft dentro da \n\nplataforma .NET. A linguagem C# almeja ser simples, moderna, de prop\u00f3sito geral \n\ncom orienta\u00e7\u00e3o a objetos. A primeira solu\u00e7\u00e3o buscada para a monitora\u00e7\u00e3o e \n\n\n\n19 \n\n \n\nvalida\u00e7\u00e3o de sinais foi desenvolvida em C#. Houve algum progresso, mas nunca, de \n\nfato, chegou-se a concluir. A Microsoft mant\u00e9m um website [7], com f\u00f3runs, \n\ndiscuss\u00f5es e documenta\u00e7\u00f5es, que facilita o acesso a informa\u00e7\u00f5es para \n\ndesenvolvedores. \n\n2.2.1: Framework Radix \n\nO Framework Radix foi desenvolvido por funcion\u00e1rios da empresa com intuito \n\nde agilizar e tornar mais eficiente e padronizado o desenvolvimento de software. Ele \n\n\u00e9 mantido tamb\u00e9m pelos funcion\u00e1rios e j\u00e1 foi aplicado a diversos projetos de \n\ndiferentes clientes. \n\nUm framework cont\u00e9m v\u00e1rias implementa\u00e7\u00f5es que s\u00e3o corriqueiras nos \n\nsistemas. Obviamente, os sistemas s\u00e3o diferentes uns dos outros, mas pode se \n\nabstrair a\u00e7\u00f5es que s\u00e3o comuns, como acesso a dados, inser\u00e7\u00e3o, exclus\u00e3o e edi\u00e7\u00e3o \n\n(CRUD \u2013 Create, Read, Update and Delete). Esta \u00e9 uma vantagem do framework \n\nque, se tomado para desenvolver do in\u00edcio, poderia levar meses para se atingir o \n\nobjetivo. \n\nO framework Radix est\u00e1 baseado no modelo MVC (Model-View-Controller), \n\nem que diferentes camadas s\u00e3o desenvolvidas, independentemente das outras. \n\nAssim, o sistema ganha escalabilidade, podendo cada uma das camadas ser \n\nexecutada em diferentes m\u00e1quinas, por exemplo. Al\u00e9m disso, havendo a \n\nnecessidade de retrabalho de c\u00f3digo, com substitui\u00e7\u00e3o de uma tecnologia por outra \n\n(por exemplo, de C# para Java), apenas a camada pode ser substitu\u00edda, sendo \n\ntransparente para as outras o que ocorre neste meio. Basta, para isso, editar as \n\ninterfaces para que sejam ligadas novamente \u00e0s diferentes camadas. \n\nA camada de modelo (Model) \u00e9 a que persiste e gerencia os dados e as \n\nestruturas de dados que ser\u00e3o utilizados pelo sistema. Representa a informa\u00e7\u00e3o que \n\na aplica\u00e7\u00e3o opera.  \n\nA camada de vis\u00e3o (View) exibe os dados para um operador ou transfere os \n\ndados para outra aplica\u00e7\u00e3o, sendo a sa\u00edda do sistema. Pode haver mais de uma \n\ncamada de vis\u00e3o desenvolvida para o sistema; uma em sistemas desktop, outra em \n\nsmartphones e tablets e outra em ambiente web. Entretanto, todas tem a mesma \n\n\n\n20 \n\n \n\nrepresenta\u00e7\u00e3o de dados (Model) e processam a informa\u00e7\u00e3o da mesma maneira \n\n(Controller). \n\nComo dito no par\u00e1grafo anterior, a camada de controlador (Controller) recebe \n\nas entradas externas (do operador ou de outro software), busca as informa\u00e7\u00f5es \n\nnecess\u00e1rias da camada de modelo e realiza opera\u00e7\u00f5es sobre estas informa\u00e7\u00f5es, \n\ngerando uma nova informa\u00e7\u00e3o para ser representada na camada de vis\u00e3o e \n\npersistindo novos dados na camada de modelo.  \n\nDiferentes alternativas para este modelo foram propostas e s\u00e3o utilizadas, \n\nprincipalmente no que se refere ao que cada um pode ou n\u00e3o fazer e com quais \n\ncamadas se comunica. Em alguns modelos uma camada pode ser desmembrada \n\nem duas, mas, ainda, s\u00e3o baseadas no modelo MVC. \n\n \n\nFigura 4 \u2013 Duas representa\u00e7\u00f5es de modelo MVC \n\nNo desenvolvimento C#, com utiliza\u00e7\u00e3o do framework, as camadas MVC \n\nforam mantidas, sendo inseridas interfaces entre elas para fazer a liga\u00e7\u00e3o entre as \n\ncamadas. Uma ou outra funcionalidade tamb\u00e9m foi transferida para a interface, mas \n\na id\u00e9ia geral \u00e9 manter as camadas MVC e suas liga\u00e7\u00f5es. \n\n\n\n21 \n\n \n\n2.2.2: Banco de dados \n\nO sistema de banco de dados persiste as informa\u00e7\u00f5es do sistema. Dessa \n\nforma, ao buscar uma informa\u00e7\u00e3o necess\u00e1ria para a sua execu\u00e7\u00e3o, esta \u00e9 buscada \n\nno sistema de banco de dados. \n\nO Sistema Gerenciador de Bancos de Dados (SGBD) utilizado neste projeto \u00e9 \n\no Microsoft SQL Server. Existem diversos SGBDs atualmente no mercado, sendo o \n\nOracle o dominante. Estes sistemas gerenciadores armazenam, por vezes, dados de \n\ndiversos bancos de dados e permitem que a informa\u00e7\u00e3o desejada pelo sistema seja \n\nrequisitada no momento que a informa\u00e7\u00e3o deve ser exibida para o usu\u00e1rio. No \n\nmodelo MVC, representa a camada de Model. \n\nA chamada para busca de informa\u00e7\u00f5es, pode ser feita dentro da linguagem de \n\ndesenvolvimento, no caso C#. Definido em linguagem de marca\u00e7\u00e3o, a chamada ao \n\nsistema de banco de dados pode ser feita de maneira transparente no c\u00f3digo, \n\nfacilitando a programa\u00e7\u00e3o e evitando que v\u00e1rias interfaces sejam implementadas em \n\nprogramas diferentes. \n\nA necessidade de armazenar informa\u00e7\u00f5es \u00e9 evidente em qualquer sistema e \n\no uso de SQL (Structured Query Language) \u00e9 explicado por ser um grande padr\u00e3o \n\nde banco de dados, al\u00e9m de ser simples e f\u00e1cil de usar. O SQL foi baseado em \n\n\u00e1lgebra relacional e permite que a forma do resultado seja especificado e n\u00e3o a\u00e9nas \n\ncaminho para chegar at\u00e9 ele. Seu uso foi difundido, por ser mais simples e mais \n\nconfi\u00e1vel do que armazenar estas informa\u00e7\u00f5es em arquivos na m\u00e1quina e realizar \n\nbuscas nestes. \n\n2.3: Ferramenta Automatizadora de Procedimentos \n\nDiversos ambientes de desenvolvimento para diversas linguagens de \n\nprograma\u00e7\u00e3o existem, atualmente, no mercado. Alguns tem finalidades mais \n\nespec\u00edficas e est\u00e3o intimamente ligadas a uma linguagem (como MQL e Metatrader, \n\npara opera\u00e7\u00f5es de bolsa de valores), outros s\u00e3o gen\u00e9ricos e de prop\u00f3sito geral (C#). \n\nUma ferramenta desenvolvida em Lua, linguagem de script, \u00e9 utilizada em \n\nalgumas refinarias. Esta ferramenta tem algumas caracter\u00edsticas que facilitam a \n\nopera\u00e7\u00e3o e automa\u00e7\u00e3o desses ambientes, como: escalabilidade; arquitetura \n\n\n\n22 \n\n \n\ndistribu\u00edda, no modelo cliente-servidor; ser de f\u00e1cil entendimento, por possuir parte \n\nde sua programa\u00e7\u00e3o visual; eficiente, por utilizar script Lua, um dos mais r\u00e1pidos \n\nscripts existentes atualmente; extensibilidade, sendo o desenvolvedor capaz de \n\nincorporar novas funcionalidades de acordo com as diferentes necessidades dos \n\nambientes de automa\u00e7\u00e3o. \n\nEsta ferramenta, com aplica\u00e7\u00e3o em refinarias, \u00e9 utilizada para automa\u00e7\u00e3o de \n\nprocedimentos como partida e parada de equipamentos, execu\u00e7\u00e3o de c\u00e1lculos \n\nsequencialmente e repetidamente, tendo seu desempenho satisfat\u00f3rio em diversos \n\ncasos. A comunica\u00e7\u00e3o OPC \u00e9 utilizada por esta ferramenta para atuar em SDCDs e \n\nalterar e inserir valores em servidores OPC. \n\nO desenvolvimento de fun\u00e7\u00f5es e da estrutura de dados \u00e9 feito em Lua, na \n\netapa que chamaremos de \u201ccodifica\u00e7\u00e3o\u201d. Estando as diversas funcionalidades \n\ndesenvolvidas (por exemplo, c\u00e1lculos, automatismos, defini\u00e7\u00f5es de dados), estas \n\ns\u00e3o importadas na ferramenta. \n\nAssim, a l\u00f3gica do programa fica dispon\u00edvel em blocos funcionais e opera\u00e7\u00f5es \n\nde tomadas de decis\u00e3o, que podem ser graficamente dispostos para realizar uma \n\nfun\u00e7\u00e3o, como se fossem um fluxograma. \n\nO operador insere os par\u00e2metros na estrutura de dados e endere\u00e7os de TAGs \n\nOPC que ser\u00e3o lidos de um servidor OPC, durante a execu\u00e7\u00e3o do fluxograma. \n\nEssa etapa de configura\u00e7\u00e3o \u00e9 feita em uma interface gr\u00e1fica, que, na \n\narquitetura cliente-servidor, \u00e9 o cliente. Por fim, a opera\u00e7\u00e3o e aplica\u00e7\u00e3o do que foi \n\nconfigurado \u00e9 realizada por um servidor da ferramenta. \n\n \n\nFigura 5 \u2013 Arquitetura da Ferramenta Automatizadora de Procedimentos \n\nEste servidor, \u00e9 um interpretador Lua, que com os c\u00f3digos desenvolvidos na \n\ncodifica\u00e7\u00e3o e a configura\u00e7\u00e3o (que tamb\u00e9m \u00e9 salva em arquivo Lua) realizar\u00e1 \n\n\n\n23 \n\n \n\nopera\u00e7\u00f5es de leitura e escrita OPC, al\u00e9m das a\u00e7\u00f5es programadas. Note, que este \n\nservidor que interpreta os c\u00f3digos Lua \u00e9 um cliente OPC para a opera\u00e7\u00e3o. \n\n2.3.1: Codifica\u00e7\u00e3o em Lua \n\nA primeira etapa no processo de utiliza\u00e7\u00e3o da ferramenta \u00e9 a codifica\u00e7\u00e3o. \n\nEsta consiste na defini\u00e7\u00e3o da estrutura de dados (classes), al\u00e9m de fun\u00e7\u00f5es de \n\nprop\u00f3sito geral. Tudo isto \u00e9 desenvolvido em Lua, para posterior disponibiliza\u00e7\u00e3o no \n\ncliente da ferramenta, quando os c\u00f3digos s\u00e3o importados, para a forma\u00e7\u00e3o dos \n\nfluxos. A linguagem de script Lua possui um manual de refer\u00eancia online [8] que \n\nfacilita o acesso de informa\u00e7\u00f5es a programadores. \n\nA estrutura de dados define atributos (vari\u00e1veis ou par\u00e2metros) e m\u00e9todos. Os \n\ndados s\u00e3o separados em classes de opera\u00e7\u00e3o, com cada classe tendo uma \n\nfinalidade espec\u00edfica no sistema. Os atributos identificam um ponto de controle que \n\nser\u00e1 utilizado no processo, isto \u00e9, um ponto OPC ou ent\u00e3o caracter\u00edsticas inseridas \n\npelo operador, referentes as classes de opera\u00e7\u00e3o. Os m\u00e9todos realizam opera\u00e7\u00f5es \n\nsobre os atributos destas classes, obtendo e salvando valores nos itens OPC e \n\nrealizando opera\u00e7\u00f5es, conforme dados dos par\u00e2metros inseridos pelo operador. \n\nAs fun\u00e7\u00f5es de prop\u00f3sito geral, s\u00e3o fun\u00e7\u00f5es que ser\u00e3o disponibilizadas para a \n\ngera\u00e7\u00e3o dos fluxogramas. Tantos estas quanto os m\u00e9todos ser\u00e3o executadas no \n\nfluxo para a obten\u00e7\u00e3o do fim desejado.  \n\n2.3.2: Gera\u00e7\u00e3o de Fluxogramas e Defini\u00e7\u00e3o de Atributos de Classes \n\nDesenvolvidos os c\u00f3digos, temos que realizar duas configura\u00e7\u00f5es na \n\naplica\u00e7\u00e3o cliente da ferramenta: configura\u00e7\u00e3o das classes de opera\u00e7\u00e3o e \n\nconfigura\u00e7\u00e3o dos fluxogramas. As fun\u00e7\u00f5es desenvolvidas na codifica\u00e7\u00e3o s\u00e3o \n\ndisponibilizadas em blocos funcionais, que s\u00e3o organizados nos fluxos. As classes \n\nde opera\u00e7\u00e3o tem seus atributos configurados e mapeados com os respectivos \n\npontos OPC. Ent\u00e3o, podem ser feitos os fluxogramas que ser\u00e3o executados. \n\nA configura\u00e7\u00e3o das classes de opera\u00e7\u00f5es consiste na especifica\u00e7\u00e3o dos \n\nsinais e itens OPC que ser\u00e3o utilizados para a execu\u00e7\u00e3o e par\u00e2metros de execu\u00e7\u00e3o. \n\nDiferentes classes, em diferentes quantidades e com diferentes finalidades podem \n\n\n\n24 \n\n \n\nser criados. Os atributos dispon\u00edveis para um classe de opera\u00e7\u00e3o \u00e9 definido na \n\ncodifica\u00e7\u00e3o. \n\nOs pontos OPC representam um ponto l\u00f3gico, no servidor OPC (podendo ser \n\num equipamento f\u00edsico, como sensores). Existem quatro tipos b\u00e1sicos de pontos: \n\nbooleano, real, inteiro e textual. Estes pontos de controle precisam ter refer\u00eancias \n\nv\u00e1lidas para que a execu\u00e7\u00e3o n\u00e3o cause erros na execu\u00e7\u00e3o. Portanto, estes itens \n\ndevem ser criados no servidor OPC (note que os tipos b\u00e1sicos s\u00e3o os mesmos \n\npermitidos no padr\u00e3o OPC). \n\nA configura\u00e7\u00e3o dos fluxogramas determinam a execu\u00e7\u00e3o dos procedimentos. \n\nA linguagem visual de fluxograma permite um entendimento mais simples do que em \n\nc\u00f3digo escrito, o que pode ser uma vantagem para programadores iniciantes. Note, \n\nentretanto, a necessidade de ter os blocos funcionais que compor\u00e3o o fluxo \n\npreviamente definidos na codifica\u00e7\u00e3o. Assim, o fluxo estabelece a sequ\u00eancia de \n\na\u00e7\u00f5es e decis\u00f5es a serem executados durante o procedimento. \n\n2.3.3: Servidor de Execu\u00e7\u00e3o \n\nO Servidor de Execu\u00e7\u00e3o, como dito, possui um interpretador Lua, que, de \n\nacordo com os fluxogramas, faz as chamadas de fun\u00e7\u00f5es desenvolvidas na \n\ncodifica\u00e7\u00e3o. Al\u00e9m disso, \u00e9 este servidor que se comunica com o processo, via OPC, \n\nsendo, portanto, um cliente OPC. Este \u00e9 o elemento central da ferramenta, que, de \n\nfato, executa as opera\u00e7\u00f5es sobre as classes de opera\u00e7\u00e3o cadastradas, de maneira \n\nautomatizada, interagindo com um servidor OPC para manipular seus pontos OPC. \n\nA arquitetura do sistema permite que o servidor seja executado em uma \n\nm\u00e1quina diferente da aplica\u00e7\u00e3o de configura\u00e7\u00e3o. Al\u00e9m disso, diversos servidores de \n\nexecu\u00e7\u00e3o (podendo ser em apenas uma m\u00e1quina) podem se comunicar com \n\ndiferentes servidores OPC. Isto prov\u00ea uma flexibilidade ao sistema. O servidor de \n\nexecu\u00e7\u00e3o carrega as informa\u00e7\u00f5es de classes de opera\u00e7\u00e3o e fun\u00e7\u00f5es de prop\u00f3sito \n\ngeral (da codifica\u00e7\u00e3o), os dados configurados e fluxos (do ambiente de configura\u00e7\u00e3o) \n\ne interpreta os fluxogramas fazendo as chamadas de m\u00e9todos das classes de \n\nopera\u00e7\u00e3o. \n\n\n\n25 \n\n \n\nCap\u00edtulo 3: Desenvolvimento \n\nNeste cap\u00edtulo ser\u00e1 apresentado o que foi desenvolvido para obter a solu\u00e7\u00e3o, \n\nenglobando todo o contexto do projeto. Partiremos da solu\u00e7\u00e3o do servidor OPC e \n\nsua conex\u00e3o com o SDCD, at\u00e9 chegarmos as solu\u00e7\u00f5es propostas para a \n\nmonitora\u00e7\u00e3o e valida\u00e7\u00e3o de sinais.  \n\n\u00c9 importante ressaltar, entretanto, que o autor deste relat\u00f3rio n\u00e3o foi o  \n\nrespons\u00e1vel pelo desenvolvimento da BDTR (se\u00e7\u00e3o 3.1). Esta foi desenvolvida em \n\nparalelo com a monitora\u00e7\u00e3o. O desenvovimento da BDTR foi apenas acompanhado \n\npelo autor, dando suporte, quando necess\u00e1rio, auxiliando e realizando testes desta. \n\nA monitora\u00e7\u00e3o e valida\u00e7\u00e3o de sinais (se\u00e7\u00e3o 3.2) foi a parte do projeto em que \n\no autor realmente esteve envolvido e, de fato, implementou. Tanto as solu\u00e7\u00f5es para \n\na monitora\u00e7\u00e3o em C# .NET, quanto na ferramenta automatizadora de procedimentos \n\ns\u00e3o apresentadas. Os algoritmos validam e monitoram sinais anal\u00f3gicos, digitais e \n\nmultiestado. \n\n\u00c9 importante ressaltar a supervis\u00e3o e orienta\u00e7\u00e3o tanto de Diogo Pacheco, \n\norientador na empresa e de Dr. R\u00f4mulo S. de Oliveira, orientador acad\u00eamico, que \n\nauxiliaram todo este desenvolvimento quanto a documenta\u00e7\u00e3o do processo. \n\nOutros dois estagi\u00e1rios estiveram envolvidos em solu\u00e7\u00f5es que compor\u00e3o, \n\ntamb\u00e9m, a solu\u00e7\u00e3o final, com mais a\u00e7\u00f5es incorporadas a monitora\u00e7\u00e3o de dados, \n\ncomo c\u00e1lculos referentes a tanques. \n\n3.1: BDTR \n\nO processo de refino possui diversos sistemas divididos por funcionalidades e \n\nque precisam obter dados a todo instante e com garantia de recebimento. Dessa \n\nforma, a solu\u00e7\u00e3o de uma Base de Dados em Tempo Real (BDTR) para o processo \n\nvisa suprir a necessidade de dados, executando as tarefas solicitadas pelos \n\nsistemas da refinaria em um tempo r\u00edgido e eficiente. \n\nApesar da exist\u00eancia de v\u00e1rios padr\u00f5es para comunica\u00e7\u00e3o, a manuten\u00e7\u00e3o das \n\ninforma\u00e7\u00f5es precisa ser otimizada, r\u00e1pida e confi\u00e1vel. Os dados das ordens e \n\n\n\n26 \n\n \n\nmovimenta\u00e7\u00f5es contidos no banco de dados de transfer\u00eancia e estocagem precisam \n\nser acessados por diversos sistemas, al\u00e9m de outros precisarem acessar os pontos \n\ndiretamente no servidor OPC do SDCD. Dessa forma, um sistema que possui uma \n\nbase de dados que, ao mesmo tempo, centraliza e garante a troca de informa\u00e7\u00f5es \n\nem tempo real foi proposto. \n\nDessa forma, a BDTR ser\u00e1 composta por um Servidor de dados OPC \n\ncomposto por OPC DA e A&amp;E,  de modo que clientes OPCs,  aplicativos de banco \n\nde dados e Web Services sejam capazes de acess\u00e1-la e auxiliem as opera\u00e7\u00f5es da \n\nrefinaria. Assim, a BDTR deve prover e receber dados de e para qualquer software \n\nde suporte \u00e0 automa\u00e7\u00e3o que venha a necessitar de dados de processo. \n\nO Servidor OPC da BDTR prover\u00e1 dados \u00e0s aplica\u00e7\u00f5es de suporte a \n\nautoma\u00e7\u00e3o da refinaria. Como o protocolo OPC segue normas padr\u00e3o, qualquer \n\noutro servidor OPC poderia prover estes dados. Por\u00e9m o desenvolvimento permite \n\nque funcionais adicionais as da especifica\u00e7\u00e3o sejam adicionadas. Assim, conex\u00f5es \n\ncom alguns softwares j\u00e1 existentes (caso do software de otimiza\u00e7\u00e3o de misturas e \n\nmovimenta\u00e7\u00f5es) s\u00e3o providas. Al\u00e9m disso, acesso a outros bancos de dados da \n\nrefinaria e emiss\u00e3o de alarmes via WebService s\u00e3o providos na solu\u00e7\u00e3o da BDTR, \n\nfuncionalidades n\u00e3o previstas na norma. Um toolkit (da Softing GmbH) foi utilizado \n\nno desenvolvimento, provendo um ponto de partida para a aplica\u00e7\u00e3o. \n\n3.1.1: Servidor OPC DA \n\nO Servidor OPC DA (Data Access) \u00e9 quem mant\u00e9m os dados [5]. Para cada \n\ndado \u00e9 mantido um r\u00f3tulo (TAG). Os dados mantidos podem ser de quatro tipos: \n\nreal, inteiro, booleano ou textutal. Al\u00e9m disso, o dado possui consigo dois outros \n\natributos al\u00e9m do valor: qualidade e estampa de tempo (timestamp).  \n\nO tipo do dado \u00e9 configurado pelo engenheiro de TAG na cria\u00e7\u00e3o da TAG. No \n\nescopo deste projeto, tamb\u00e9m foi desenvolvido uma interface em Excel, com \n\nprograma\u00e7\u00e3o em Visual Basic, para a cria\u00e7\u00e3o e configura\u00e7\u00e3o de TAGs. Assim, cada \n\nTAG ser\u00e1 configurada com informa\u00e7\u00f5es como endere\u00e7o da TAG, endere\u00e7o de \n\nconex\u00e3o com SDCD, valores m\u00ednimos e valores m\u00e1ximos, entre outros. Ap\u00f3s \n\nfinalizada a configura\u00e7\u00e3o, esta \u00e9 exportada para a BDTR na pr\u00f3pria interface. \n\n\n\n27 \n\n \n\nA exporta\u00e7\u00e3o usa um pipe nomeado. Este pipe nomeado \u00e9 um canal que \u00e9 \n\ncriado entre dois processos e facilita a comunica\u00e7\u00e3o entre estes. Por exemplo, ao \n\ninv\u00e9s de exportar para um arquivo externo e, posteriormente, importar na BDTR, o \n\npipe nomeado faz a \u201ctransfer\u00eancia\u201d do arquivo diretamente, por este canal, podendo \n\no canal ser fechado ap\u00f3s o seu uso. \n\n \n\nFigura 6 \u2013 Interface Excel da BDTR \n\nUm aspecto importante da BDTR \u00e9 a conex\u00e3o com SDCD. A conex\u00e3o com \n\nSDCD \u00e9 realizada para itens da BDTR que possuem sinais ligados \u00e0 planta. Podem \n\nser sinais de n\u00edvel, vaz\u00e3o, temperatura, entre outros. Entretanto, nem todos os itens \n\ncadastrados na BDTR possuem uma conex\u00e3o com um SDCD. Alguns podem \n\napenas estar presentes na BDTR e, por exemplo, ser resultado de c\u00e1lculos \n\nrealizados por outros softwares que \u00e9 exatamente o princ\u00edpio da valida\u00e7\u00e3o de sinal, \n\ncomo mostrado na Figura 14 - Software de Monitora\u00e7\u00e3o e da BDTR unificada. \n\nNote que a BDTR prev\u00ea que o SDCD seja tamb\u00e9m um servidor OPC, \n\nrecorrendo a seus dados por chamadas OPC. O SDCD, no entanto, converte dados \n\nde campo para o padr\u00e3o OPC. Estes dados podem ser Modbus e Profibus e a \n\nconvers\u00e3o para o padr\u00e3o OPC consiste na inclus\u00e3o de qualidade e timestamp, por \n\nexemplo, al\u00e9m do meio f\u00edsico de comunica\u00e7\u00e3o ser diferente.  \n\n\n\n28 \n\n \n\nAl\u00e9m disso, \u00e9 atrav\u00e9s da conex\u00e3o com o SDCD que a atua\u00e7\u00e3o no campo \n\nocorrer\u00e1 e dados de campo poder\u00e3o ser fornecidos. Como a BDTR prev\u00ea que \n\nm\u00faltiplos clientes podem estar conectados a ela ao mesmo tempo, a escrita para \n\nvalores de campo podem ter diversas fontes e a BDTR atua apenas como \n\ntransmissor da informa\u00e7\u00e3o. \n\nA informa\u00e7\u00e3o de qualidade e de estampa de tempo \u00e9 essencial para outros \n\nsistemas saberem se a informa\u00e7\u00e3o que \u00e9 fornecida a eles \u00e9 \u00fatil e pode-se fazer uso \n\ndaquele dado. As principais qualidades s\u00e3o: \u201cboa\u201d, \u201cincerta\u201d e \u201cruim\u201d. A informa\u00e7\u00e3o \n\nde qualidade ser\u00e1 de fundamental import\u00e2ncia para a valida\u00e7\u00e3o de sinais, que \u00e9 o \n\nfoco deste trabalho. A espefici\u00e7\u00e3o 3.00 \u00e9 a que permitiu que clientes OPC \n\nescrevessem em qualidade e timestamp nos servidores OPC. \n\nOs dados referentes aos TAGs s\u00e3o mantidos na mem\u00f3ria da BDTR e \n\nretransmitidos aos sistemas conforme sua necessidade. Entretanto, para iniciar sua \n\nexecu\u00e7\u00e3o, a configura\u00e7\u00e3o dos TAGs \u00e9 mantida n\u00e3o em um banco de dados mas em \n\narquivos XML, que mant\u00e9m tudo o que \u00e9 necess\u00e1rio para a cria\u00e7\u00e3o de determinada \n\nTAG. Este arquivo tamb\u00e9m pode ser exportado da interface Excel. Assim, a BDTR j\u00e1 \n\nest\u00e1 apta a manter dados para todos os sistemas. \n\n \n\nFigura 7 \u2013 BDTR executando \n\n Os clientes podem adquirir dados atrav\u00e9s de tr\u00eas tipos de chamada, \n\nbasicamente: s\u00edncrona, ass\u00edncrona e por subscri\u00e7\u00e3o. \n\nA chamada s\u00edncrona \u00e9 uma chamada bloqueante para o cliente. Este solicita \n\no dado para a BDTR e n\u00e3o executa nenhuma a\u00e7\u00e3o at\u00e9 que a resposta com o dado \n\nseja provido. A chamada ass\u00edncrona \u00e9 n\u00e3o-bloqueante para o cliente, permitindo que \n\noutras execu\u00e7\u00f5es sejam efetuadas enquanto a resposta da BDTR n\u00e3o ocorra.  \n\n\n\n29 \n\n \n\nA \u00faltima, por subscri\u00e7\u00e3o, permite que o cliente fa\u00e7a uma \u201cassinatura\u201d junto a \n\nBDTR. Assim, de tempos em tempos, havendo uma mudan\u00e7a no valor junto a BDTR \n\numa mensagem com o valor \u00e9 enviado ao cliente que tem sua subscri\u00e7\u00e3o ativa \n\n(dataChange). Se nenhuma altera\u00e7\u00e3o ocorre no intervalo at\u00e9 a pr\u00f3xima mensagem \n\nser enviada, uma mensagem de keepAlive \u00e9 encaminhada para o cliente, apenas \n\npara que o cliente saiba que o servidor ainda est\u00e1 em opera\u00e7\u00e3o. \n\nA vantagem da subscri\u00e7\u00e3o \u00e9 que diminui significativamente o tr\u00e1fego de \n\ndados na rede e tamb\u00e9m n\u00e3o mant\u00e9m o cliente bloqueado aguardando um dado. \n\nEntretanto, exige que o cliente seja capaz de receber e tratar este dado que pode \n\nchegar, a princ\u00edpio, a qualquer instante. \n\n             \n\nFigura 8 \u2013 Chamadas S\u00edncrona, Ass\u00edncrona e por Subscri\u00e7\u00e3o, respectivamente \n\n3.1.2: Servidor OPC A&amp;E \n\nO servidor OPC A&amp;E (Alarms and Events) monitorar\u00e1 acontecimentos e \n\ncondi\u00e7\u00f5es sobre TAGs armazenadas na BDTR [6]. Eventos s\u00e3o mensagens \n\nenviadas aos operadores para que este tenha ci\u00eancia de que algo ocorreu, \n\nentretanto, sem que este tenha que intervir e informar ao sistema que recebeu a \n\nmensagem. Alguns eventos, por exemplo, s\u00e3o: \u201cA TAG XXXXX alterou seu valor de \n\nAAA para BBB\u201d ou \u201cA TAG YYYYY foi criada\u201d. O sistema continua funcionando sem \n\nnenhum problema por estas mensagens serem perdidas. \n\n\n\n30 \n\n \n\n \n\nFigura 9 - Eventos disparados pela BDTR \n\nAlarmes, entretanto, precisam que o operador reconhe\u00e7a seu estado, pois \n\nestas s\u00e3o situa\u00e7\u00f5es mais cr\u00edticas. Alarmes, normalmente, s\u00e3o emitidos quando \n\nTAGs est\u00e3o fora de seus valores normais de opera\u00e7\u00e3o, atingindo valores baixos \n\n(LO), muito baixos (LO-LO) ou altos (HI) e muito altos (HI-HI). Assim, o operador, ao \n\nverificar a condi\u00e7\u00e3o anormal do sistema, pode tomar provid\u00eancias para assegurar \n\nque o sistema volte ao seu  funcionamento adequado e, assim, marcar o alarme \n\ncomo reconhecido. Caso o alarme seja reconhecido, mas a condi\u00e7\u00e3o anormal do \n\nsistema ainda ocorre (como um valor fora do normal) o alarme continuar\u00e1 ativo.  \n\n \n\nFigura 10 - Alarmes emitidos pela BDTR, sem reconhecimento \n\n \n\nFigura 11 - Alarmes emitidos pela BDTR, sendo reconhecidos \n\n\n\n31 \n\n \n\nNote, entretanto, que mesmo que uma condi\u00e7\u00e3o anormal de funcionamento \n\nocorra e volte ao normal no curso normal de opera\u00e7\u00e3o do sistema, um alarme ainda \n\nestar\u00e1 presente e aguardando reconhecimento. Isto porque a condi\u00e7\u00e3o anormal \n\nprecisa ser conhecida para que poss\u00edveis provid\u00eancias sejam tomadas. Por fim, seu \n\nreconhecimento eliminar\u00e1 o alarme. \n\nAl\u00e9m disso, \u00e9 importante reparar que tanto alarmes quanto eventos tem uma \n\nseveridade associada (que pode assumir valores inteiros de 1 a 1000) que pode ser \n\nutilizada para filtros e rastreabilidade dentro do sistema. \n\n \n\nFigura 12 - Alarmes emitidos pela BDTR \n\nOutro aspecto a ser apresentado da emiss\u00e3o de alarmes e eventos \u00e9 sua \n\ndivis\u00e3o por espa\u00e7os de \u00e1rea e espa\u00e7os de eventos. O espa\u00e7o de \u00e1rea se refere a \n\ndefini\u00e7\u00e3o OPC de \u00e1rea e fonte. O espa\u00e7o de eventos se refere a defini\u00e7\u00e3o OPC de \n\ncategoria. \n\nTodo alarme e evento emitido tem associado uma fonte a ele, que \u00e9 quem \n\ncausou este disparo. Esta fonte pode ou n\u00e3o ter uma ou mais \u00e1reas associada a ela. \n\nUma \u00e1rea \u00e9, tipicamente, um agrupamento dos equipamentos da planta.  \n\nTamb\u00e9m, todo alarme e evento emitido tem associado uma categoria a ele. \n\nEste conceito se refere ao tipo de disparo que foi efetuado. Por exemplo, podem ser \n\ndisparos de categorias padr\u00f5es como \u201cDevice Failure\u201d ou \u201cSystem Message\u201d ou \n\nainda outras categorias podem ser criadas como \u201cMonitora\u00e7\u00e3o Planta\u201d. \n\nUm determinado operador pode estar interessado em receber eventos e \n\nalarmes de apenas uma \u00e1rea, que \u00e9 a \u00e1rea que ele atua. Assim, diversas \u00e1reas \n\npodem ser especificadas. Outro operador, entretanto, pode estar interessado em \n\n\n\n32 \n\n \n\nalarmes e eventos referentes a apenas algum processo, recebendo apenas \n\nmensagens sobre este processo, como Monitora\u00e7\u00e3o da Planta, na Figura 13. \n\n \n\nFigura 13 \u2013 Divis\u00e3o por espa\u00e7os de \u00e1rea e de eventos do servidor OPC A&amp;E \n\nUm alarme e/ou evento emitido sempre vai ter associado a ele uma categoria \n\ne uma fonte. Uma ou mais \u00e1reas podem ser especificadas.  \n\n Entretanto, a BDTR s\u00f3 est\u00e1 preparada para efetuar alguns tipos de alarmes e \n\neventos, como extrapola\u00e7\u00e3o e mudan\u00e7a de valores. H\u00e1 casos em que se deseja \n\nefetuar disparos por outros softwares, como \u00e9 o caso da monitora\u00e7\u00e3o e valida\u00e7\u00e3o de \n\nsinais, foco deste trabalho. \n\n A primeira solu\u00e7\u00e3o desenvolvida para atender estes disparos por chamadas \n\nexternas foi com o uso de banco de dados. Todos as inser\u00e7\u00f5es que ocorressem no \n\nbanco de dados eram lidas, disparadas e, posteriormente, apagadas. Assim, definia-\n\nse os par\u00e2metros no banco de dados como fonte, categoria, \u00e1rea(s), severidade. Ao \n\nler os valores, a BDTR efetuava o disparo, como se fosse originado por ele mesmo. \n\n Entretanto, embora tenha funcionado, outra solu\u00e7\u00e3o foi de fato mantida na \n\nsolu\u00e7\u00e3o final: uso de WebService. Assim, os softwares que necessitam realizar um \n\ndisparo de alarme e/ou evento fazem a chamada direta \u00e0 BDTR, que possue esta \n\n\n\n33 \n\n \n\ninterface para chamada de aplica\u00e7\u00f5es externas. Na chamada, s\u00e3o passados os \n\nmesmos par\u00e2metros que eram armazenados no banco de dados e o disparo \u00e9 \n\nefetuado. \n\n3.2: Monitora\u00e7\u00e3o e Valida\u00e7\u00e3o de Sinais \n\nO sistema de monitora\u00e7\u00e3o e valida\u00e7\u00e3o de sinais atuar\u00e1 sobre dados mantidos \n\nna BDTR. Estes dados passar\u00e3o por c\u00e1lculos e verifica\u00e7\u00f5es de modo a garantir \n\ndados mais confi\u00e1veis para que outras aplica\u00e7\u00f5es possam realizar suas opera\u00e7\u00f5es \n\nde maneira mais segura e eficaz. C\u00e1lculos sobre TAGs de valores anal\u00f3gicos, \n\ndigitais e multiestado s\u00e3o realizados. A este sistema, ainda ser\u00e3o incorporados \n\ndiversos outros algoritmos e m\u00e9todos que ainda precisam ser forma\u00e7ozadps e \n\nimplementados. Alguns dos m\u00e9todos que s\u00e3o escopo da continua\u00e7\u00e3o do projeto s\u00e3o: \n\nbalan\u00e7o de massa, monitorar estados de alinhamento, integra\u00e7\u00e3o de qualidade e \n\nc\u00e1lculos de atributos de tanques. \n\nAs regras criadas para validar os dados, s\u00e3o, em sua maioria, para que \n\naspectos emp\u00edricos de opera\u00e7\u00e3o de campo sejam formalizados e aplicados de \n\nmaneira sistem\u00e1tica. Estas regras s\u00e3o descritas no documento de Regras de \n\nNeg\u00f3cio, que se refere a um documento de levantamento de requisitos do sistema. \n\nUm exemplo desse empiritismo trazido a pr\u00e1tica: dada uma tubula\u00e7\u00e3o, temos \n\numa v\u00e1lvula com controle digital (aberta ou fechada) e ap\u00f3s essa v\u00e1lvula, h\u00e1 um \n\nmedidor de fluxo, de valores anal\u00f3gicos. Assim, considere que estamos interessados \n\nno valor do fluxo. Existe um algoritmo (chamado de TAG Condicional) que verificar\u00e1 \n\no valor da v\u00e1lvula: aberta ou fechada. Se esta tiver aberta, o valor lido para o fluxo \n\npode estar v\u00e1lido. Entretanto, se a v\u00e1lvula estiver fechada, qualquer valor lido para o \n\nfluxo \u00e9 err\u00f4neo e, muito provavelmente, proviente de ru\u00eddos. \n\nObviamente, um valor para o fluxo sempre ser\u00e1 lido e n\u00e3o faz sentido que seja \n\nescrito, for\u00e7adamente, um valor que consideramos v\u00e1lido no valor lido do sensor. \n\nAli\u00e1s, espera-se, neste caso, que o valor do fluxo seja configurado na sua \n\nconfigura\u00e7\u00e3o como somente leitura, pois n\u00e3o faz sentido alterar um valor de um \n\nsensor. Entretanto, pode haver casos (como o da v\u00e1lvula) que podemos ler e \n\nescrever. O software de monitora\u00e7\u00e3o n\u00e3o faz isso, pois seu foco n\u00e3o \u00e9 a atua\u00e7\u00e3o e \n\nsim prover informa\u00e7\u00f5es para softwares de suporte a automa\u00e7\u00e3o tomar decis\u00f5es e \n\n\n\n34 \n\n \n\natuar no sistema. Pode ocorrer, ainda, que alguns softwares n\u00e3o queiram os dados \n\nvalidados e sim os dados originais, sem nenhuma altera\u00e7\u00e3o da valida\u00e7\u00e3o. \n\nDessa forma, para que seja mantido a informa\u00e7\u00e3o original e ainda provermos \n\numa valida\u00e7\u00e3o do sinal que \u00e9 lido do campo, uma TAG OPC, mantida tamb\u00e9m na \n\nBDTR, adjacente a original, ser\u00e1 criada. Para diferenci\u00e1-las, um sufixo ser\u00e1 \n\nacrescentado a endere\u00e7o textual de cada TAG validada, com a base da TAG \n\noriginal. A figura 14 apresenta a estrutura geral de como a BDTR e o sistema de \n\nmonitora\u00e7\u00e3o ir\u00e3o interagir. Esta estrutura de automa\u00e7\u00e3o e como os sistemas \n\ninteragir\u00e3o est\u00e3o descritas nos Documentos de Vis\u00e3o dos respectivos sistemas que \n\napresentam requisitos funcionais e n\u00e3o funcionais que um software deve possuir. \n\n \n\nFigura 14 - Software de Monitora\u00e7\u00e3o e da BDTR unificada \n\nOs tipos de valores armazenados na BDTR, como previamente apresentados, \n\ns\u00e3o: digital (booleano), anal\u00f3gico (real), multiestado (inteiro) e textual (string). Os \n\nalgoritmos de valida\u00e7\u00e3o aplicados em um tipo de TAG n\u00e3o ser\u00e3o aplicados em outro \n\ntipo. N\u00e3o parece fazer o menor sentido verificar se o valor 13 \u00e9 verdadeiro. Por isso, \n\ncada tipo de TAG ter\u00e1 o seu conjunto de algoritmos espec\u00edficos. \n\nComo dito, a id\u00e9ia \u00e9 que estes algoritmos formalizem algum tipo de empiritismo \n\nda opera\u00e7\u00e3o, tamb\u00e9m respeitando o tipo das vari\u00e1veis em que estes s\u00e3o aplicados. \n\n\n\n35 \n\n \n\n3.2.1: Algoritmos de Valida\u00e7\u00e3o \n\nOs algoritmos de valida\u00e7\u00e3o, como dito no t\u00f3pico anterior, separam-se por tipo \n\nda TAG. Estes est\u00e3o apresentados na tabela abaixo. \n\nOs algoritmos foram levantados de acordo com especifica\u00e7\u00f5es do sistema e \n\nest\u00e3o bem descritos nos diversos documentos levantados na descri\u00e7\u00e3o do sistema, \n\ncomo o de Documento de Vis\u00e3o, Regra de Neg\u00f3cios  e Casos de Uso. Estes \n\ndocumentos s\u00e3o parte da Engenharia de Requisitos do software, respons\u00e1vel por \n\nespecificar os detalhes do software que toda boa pr\u00e1tica de desenvolvimento deve \n\nrealizar. \n\nA leitura dos dados e sua escrita na BDTR e demais fun\u00e7\u00f5es auxiliares s\u00e3o \n\npadronizadas e comuns, independente do tipo de TAG. Assim, a diferencia\u00e7\u00e3o de \n\num tipo de TAG para outro se d\u00e1 basicamente pelos seus algoritmos. \n\nAnal\u00f3gica Digital Multiestado Textual \n\nM\u00ednima Varia\u00e7\u00e3o Congelamento Congelamento N\u00c3O SE APLICA \n\nTAG Condicional TAG Condicional TAG Condicional  \n\nLimite Inferior \nTaxa de Varia\u00e7\u00e3o \n\nDigital \n\nTaxa de Varia\u00e7\u00e3o \n\nde Estado \n\nLimite Superior Filtro Digital Filtro de Estado \n\nTaxa de Varia\u00e7\u00e3o \n\nM\u00e1xima \n\n \n\nM\u00e9dia M\u00f3vel com \n\nDesvio Padr\u00e3o \n\nFiltro de Sinal \n\nTabela 1 \u2013 Tipos de TAG e seus algoritmos \n\nUm aspecto importante \u00e9 a frequ\u00eancia de valida\u00e7\u00e3o que define o intervalo \n\nentre duas valida\u00e7\u00f5es subsequentes. Esta frequ\u00eancia (em segundos) deve ser maior \n\nque 60 (um minuto). Muitos algoritmos utilizar\u00e3o os valores antigos (validados \n\n\n\n36 \n\n \n\nanteriormente), os valores lidos (que est\u00e3o em campo), com suas estampas de \n\ntempo e intervalos de valida\u00e7\u00e3o para realizar c\u00e1lculos. \n\nNote que os algoritmos s\u00e3o aplicados em sequ\u00eancia e um valor lido pode \n\nsofrer altera\u00e7\u00e3o em um algoritmo e ser entrada para outro algoritmo. Al\u00e9m disso, n\u00e3o \n\n\u00e9 aplicado nenhum algoritmo para o tipo textual, uma string. A seguir, ser\u00e1 descrito \n\nde maneira sucinta o que cada algoritmo foi especificado a realizar. \n\n3.2.1.1: Algoritmos de Valida\u00e7\u00e3o de TAG Anal\u00f3gica \n\nOs algoritmos para TAGs anal\u00f3gicas realizam c\u00e1lculos e verifica\u00e7\u00f5es sobre \n\nvalores do tipo real. Estes podem assumir, em teoria, qualquer valor no espectro de \n\nmenos infinitio a mais infinito. Sabemos, entretanto, que cada equipamento possui \n\nsuas limita\u00e7\u00f5es e valores esperados e isto \u00e9 configurado na BDTR. Assim, os \n\nvalores s\u00e3o limitados e basta, para a monitora\u00e7\u00e3o, a aplica\u00e7\u00e3o dos algoritmos.  \n\nO algoritmo de M\u00ednima Varia\u00e7\u00e3o atua no sentido de validar o sinal que sofre \n\nvaria\u00e7\u00e3o acima de uma banda morta. Assim, ser\u00e3o v\u00e1lidos os sinais que, entre uma \n\nvalida\u00e7\u00e3o e outra, sofreram algum tipo de incremento ou decremento acima do valor \n\nconfigurado de banda morta. \n\nO algoritmo de TAG Condicional verifica se existe alguma condi\u00e7\u00e3o, \n\nproveniente de uma TAG condicionante (e n\u00e3o a que est\u00e1 sendo validada), para que \n\no valor que est\u00e1 sendo validado seja ignorado. Se tal condi\u00e7\u00e3o ocorrer, nenhum \n\noutro algoritmo \u00e9 aplicado e o valor lido \u00e9 atribu\u00eddo ao valor validado. \n\nOs algoritmos de Limite Inferior e Limite Superior tornam v\u00e1lidos os valores \n\nque estejam compreendidos entre os valores configurados para estes limites. \n\nO algoritmo de Taxa de Varia\u00e7\u00e3o M\u00e1xima verifica se a diferen\u00e7a entre dois \n\nvalores dividida pelo intervalo entre duas valida\u00e7\u00f5es extrapola um valor determinado, \n\nvalidando o sinal que n\u00e3o extrapolar. \n\nO algoritmo de M\u00e9dia M\u00f3vel com Desvio Padr\u00e3o mant\u00e9m uma janela de \n\ndados com valores, qualidade e estampas de tempo e calcula o desvio padr\u00e3o \n\ndestes valores armazenados. Se o desvio padr\u00e3o calculado for menor que um valor \n\nde refer\u00eancia, a m\u00e9dia m\u00f3vel entre os valores \u00e9 calculada e este ser\u00e1 o valor do \n\nsinal validado. \n\n\n\n37 \n\n \n\nO algoritmo de Filtro de Sinal aplica um filtro digital de primeira ordem, com \n\nbase no valor lido e no \u00faltimo valor validado. \n\nNote que em caso das condi\u00e7\u00f5es verificadas tornarem os sinais inv\u00e1lidos, \n\nvalores de restri\u00e7\u00e3o pr\u00e9-definidos pelo operador ou pelo algoritmo ser\u00e3o atribu\u00eddos \n\nao valor atribu\u00eddo. Entretanto, a qualidade deste sinal deixar\u00e1 de ser uma qualidade \n\nBOA e ser\u00e1 considerada INCERTA ou ainda RUIM. \n\n3.2.1.2: Algoritmos de Valida\u00e7\u00e3o de TAG Digital \n\nOs algoritmos para TAGs digitais realizam c\u00e1lculos e verifica\u00e7\u00f5es sobre \n\nvalores do tipo booleano. Estes podem assumir verdadeiros ou falsos, ligados ou \n\ndesligados, abertos ou fechados, dependendo do equipamento. \n\nO algoritmo de Congelamento torna v\u00e1lido o sinal que cuja diferen\u00e7a entre os \n\ntimestamps dos sinais validado anteriormente e lido \u00e9 inferior ou igual ao tempo de \n\ncongelamento, par\u00e2metro configurado. Assim, este algoritmo busca identificar TAGs \n\nque devem ser atualizadas e n\u00e3o s\u00e3o, podendo haver erros na transmiss\u00e3o dos \n\nsensores, por exemplo. Poderia-se pensar como o an\u00e1logo \u00e0 M\u00ednima Varia\u00e7\u00e3o para \n\na TAG Anal\u00f3gica, mas, como a TAG Digital s\u00f3 pode possuir valores discretos, o \n\nalgoritmo de Congelamento foi especificado. \n\nO algoritmo de TAG Condicional tem a mesma id\u00e9ia de aplica\u00e7\u00e3o que para \n\nTAGs anal\u00f3gicas, por\u00e9m o valor atribu\u00eddo \u00e0 TAG validada \u00e9 digital. \n\nO algoritmo de Taxa de Varia\u00e7\u00e3o Digital pretende n\u00e3o manter o mesmo valor \n\npara um sinal por intervalos muito longos. Assim, os valores s\u00e3o lidos e sendo do \n\nmesmo valor, um contador \u00e9 incrementado com a diferen\u00e7a de tempo entre duas \n\nvalida\u00e7\u00f5es subsequentes. Estando este contador acima de um patamar configurado, \n\no sinal \u00e9 invalidado, sendo v\u00e1lido apenas quando este troca de valor ou enquanto \n\nestiver abaixo do intervalo de tempo configurado. Neste \u00faltimo caso, o sinal validado \n\nrecebe o valor do sinal lido. \n\nO algoritmo de Filtro Digital faz a mesma verifica\u00e7\u00e3o que o algoritmo de taxa \n\nde varia\u00e7\u00e3o digital. Entretanto, estando este valor abaixo do patamar de tempo \n\nconfigurado para este algoritmo, nada \u00e9 realizado. Se o valor \u00e9 extrapolado, a TAG \n\nvalidada recebe o valor lido. \n\n\n\n38 \n\n \n\nNote que em caso das condi\u00e7\u00f5es verificadas tornarem os sinais inv\u00e1lidos, \n\nvalores de restri\u00e7\u00e3o pr\u00e9-definidos pelo operador ou pelo algoritmo ser\u00e3o atribu\u00eddos \n\nao valor atribu\u00eddo. Entretanto, a qualidade deste sinal deixar\u00e1 de ser uma qualidade \n\nBOA e ser\u00e1 considerada INCERTA ou ainda RUIM. \n\n3.2.1.3: Algoritmos de Valida\u00e7\u00e3o de TAG Multiestado \n\nOs algoritmos para TAGs multiestado realizam c\u00e1lculos e verifica\u00e7\u00f5es sobre \n\nvalores do tipo inteiro. Estes valores podem ter associa\u00e7\u00f5es textuais, como, por \n\nexemplo, para um TAG o valor 13 aceitar o valor \u201caberto\u201d e o 28 \u201cfechado\u201d. \n\nEntretanto, o valor para o TAG mantido na BDTR \u00e9 o valor num\u00e9rico. Essa \n\nassocia\u00e7\u00e3o textual-valor \u00e9 feita pela BDTR que converte o valor textual para o \n\ninteiro. \n\nO algoritmo de Congelamento tem a mesma id\u00e9ia de aplica\u00e7\u00e3o que para \n\nTAGs digitais. O algoritmo de TAG Condicional tem a mesma id\u00e9ia de aplica\u00e7\u00e3o para \n\nTAGs anal\u00f3gicas, por\u00e9m o valor atribu\u00eddo \u00e0 TAG validada \u00e9 multiestado. \n\nJ\u00e1 os algoritmos de Taxa de Varia\u00e7\u00e3o de Estado e Filtro de Estado s\u00e3o \n\nan\u00e1logos aos algoritmos de Taxa de Varia\u00e7\u00e3o Digital e Filtro Digital, por\u00e9m, valores \n\ninteiros s\u00e3o representados. Assim como os outros algoritmos, um sinal inv\u00e1lido tem \n\nvalores de restri\u00e7\u00e3o aplicados e qualidade alterados de acordo com o algoritmo \n\naplicado. \n\nNa verdade, na implementa\u00e7\u00e3o da BDTR, a TAG digital \u00e9 apenas uma TAG \n\nmultiestado com dois estados. Entretanto, para a aplica\u00e7\u00e3o dos algoritmos sua \n\ndiferencia\u00e7\u00e3o foi necess\u00e1ria para adequa\u00e7\u00e3o ao que era esperado no levantamento \n\ndo sistema, como nas regras de neg\u00f3cio. \n\n3.3: Monitora\u00e7\u00e3o em C# \n\nA monitora\u00e7\u00e3o em C# .NET foi a primeira solu\u00e7\u00e3o proposta e chegou a ser \n\ndesenvolvida por um curto per\u00edodo, at\u00e9 ser deixada de lado para a solu\u00e7\u00e3o com a \n\nferramenta automatizadora de procedimentos. Entretanto, esta solu\u00e7\u00e3o n\u00e3o est\u00e1 \n\ntotalmente descartada para o produto final, em que fun\u00e7\u00f5es ser\u00e3o incorporadas a \n\nmonitora\u00e7\u00e3o e valida\u00e7\u00e3o de sinais. Esta \u00faltima \u00e9 o foco desta disserta\u00e7\u00e3o,. \n\n\n\n39 \n\n \n\nO desenvolvimento utilizando a plataforma C# .NET foi facilitado pelo uso do \n\nframework da Radix, j\u00e1 citado neste documento. O modelo MVC \u00e9 o utilizado neste \n\nframework.  \n\n3.3.1: Modelo de Dados \n\nPara a cria\u00e7\u00e3o do modelo de dados, foi usado o Enterprise Architect, uma \n\nferramenta utilizada para documenta\u00e7\u00e3o de projetos. Tamb\u00e9m foi criado neste \n\nsoftware o diagrama de casos de uso, diagrama de classes e outros tipos de \n\ndocumenta\u00e7\u00e3o. A vantagem deste software \u00e9 gerar o script SQL para a gera\u00e7\u00e3o do \n\nbanco de dados automaticamente a partir do modelo de dados. O Microsoft SQL \n\nServer 2008 \u00e9 o banco de dados utilizado na solu\u00e7\u00e3o apresentada. \n\n O modelo de dados mant\u00e9m a configura\u00e7\u00e3o da valida\u00e7\u00e3o de sinais. Esta \n\nconfigura\u00e7\u00e3o \u00e9 mantida no banco de dados e \u00e9 descrita pelo caso de uso espec\u00edfico \n\n(na figura abaixo, \u201cInserir, Visualizar, Editar, Excluir Valida\u00e7\u00e3o de Sinal\u201d). O \n\nengenheiro de TAGs ou engenheiro processista gerar\u00e1 a configura\u00e7\u00e3o de acordo \n\ncom o funcionamento adequado esperado para a opera\u00e7\u00e3o. O sistema, utilizando-se \n\ndessa configura\u00e7\u00e3o, far\u00e1 a valida\u00e7\u00e3o do sinal em si (\u201cMonitorar e Validar Sinal\u201d), \n\nlendo os valores do servidor OPC e reescrevendo valores. Abaixo, est\u00e3o o diagrama \n\nde casos de uso e modelo de dados para o sistema de monitora\u00e7\u00e3o e valida\u00e7\u00e3o de \n\nsinais. \n\n \n\nFigura 15 - Diagrama de Caso de Uso - Valida\u00e7\u00e3o de Sinal \n\nPara a monitora\u00e7\u00e3o e valida\u00e7\u00e3o de sinais, duas tabelas s\u00e3o necess\u00e1rias: uma \n\nque mant\u00e9m as TAGs OPC (que se relacionar\u00e3o com diversas outras tabelas, \n\nquando novas fun\u00e7\u00f5es forem incorporadas) e uma que mant\u00e9m a configura\u00e7\u00e3o de \n\ncada algoritmo da monitora\u00e7\u00e3o. Assim, a chave prim\u00e1ria da tabela das TAGs OPC \n\n\n\n40 \n\n \n\nser\u00e1 chave estrangeira para diversas outras tabelas, inclusive a de monitora\u00e7\u00e3o e \n\nvalida\u00e7\u00e3o de sinais. \n\nNa tabela de configura\u00e7\u00e3o, cada algoritmo ter\u00e1 seus par\u00e2metros para \n\nexecu\u00e7\u00e3o. Ser\u00e3o valores como flags (booleanos identificando a execu\u00e7\u00e3o ou n\u00e3o de \n\ncada algoritmo), inteiros (tipo de crit\u00e9rios e identificadores), strings (endere\u00e7os) e \n\nreais (valores). \n\n \n\nFigura 16 \u2013 Modelo de Dados - Valida\u00e7\u00e3o de Sinal \n\nAs entradas da tabela de configura\u00e7\u00e3o se remetem aos algoritmos de \n\nvalida\u00e7\u00e3o descrito na se\u00e7\u00e3o 3.2.1:. Outras mant\u00eam no banco de dados o valor e o \n\nvalor validado das TAGs OPC que ser\u00e3o lidos do servidor OPC. Estes s\u00e3o \n\narmazenados no banco de dados para futura apresenta\u00e7\u00e3o ao usu\u00e1rio, assim como \n\na qualidade e o timestamp.  \n\nNesta camada, cada tipo de TAG ter\u00e1 uma classe de modelo em C# que far\u00e1 \n\na vincula\u00e7\u00e3o do banco de dados com a inst\u00e2ncia da configura\u00e7\u00e3o armazenada nele. \n\nAssim, estas configura\u00e7\u00f5es estar\u00e3o dispon\u00edveis para a aplica\u00e7\u00e3o. Dessa forma, tem-\n\nse o que \u00e9 necess\u00e1rio para realizar a valida\u00e7\u00e3o.  \n\nDo modelo MVC, o Model \u00e9 apresentado como descrito acima. Restam ser \n\ndescritos View e Controller que ser\u00e3o apresentados a seguir. \n\n\n\n41 \n\n \n\n3.3.2: Interface \n\nNesta solu\u00e7\u00e3o, para o usu\u00e1rio manter e inserir a configura\u00e7\u00e3o dos sinais, foi \n\nescolhida uma interface Web. Esta consiste na camada View do modelo MVC. Al\u00e9m \n\nde ser a camada que apresentar\u00e1 as configura\u00e7\u00f5es e permitir\u00e1 ao usu\u00e1rio inserir \n\nnovas configura\u00e7\u00f5es, o valor dos sinais original e validados tamb\u00e9m ser\u00e3o exibidos.  \n\nPrimeiramente, a interface foi desenvolvida para testes e verificar a \n\nfuncionalidade do sistema. Um webdesigner fez, posteriormente, uma vers\u00e3o \n\nmelhorada do que seria o sistema. Entretanto, o sistema foi deixado de lado para a \n\nutiliza\u00e7\u00e3o da ferramenta automatizadora de procedimentos, como dito. \n\nA implementa\u00e7\u00e3o das interfaces se deu diretamente em c\u00f3digo HTML, \n\nutilizando CSS para altera\u00e7\u00e3o do estilo. Scripts para interatividade com o usu\u00e1rio \n\ntamb\u00e9m foram necess\u00e1rios, como Javascript. Ap\u00f3s a cria\u00e7\u00e3o dos elementos na tela, \n\nbastou relacionar os elementos com itens da programa\u00e7\u00e3o em C#. O framework faz \n\ntodo o trabalho de fazer esta liga\u00e7\u00e3o, sendo necess\u00e1rio apenas passar como \n\npar\u00e2metro o nome do elemento no c\u00f3digo. \n\nAbaixo, est\u00e3o algumas imagens da interface desenvolvidas. \n\n \n\nFigura 17 - Filtragem de Configura\u00e7\u00f5es \n\n\n\n42 \n\n \n\n \n\nFigura 18 - Cria\u00e7\u00e3o de Configura\u00e7\u00e3o Anal\u00f3gica \n\n \n\nFigura 19 - Cria\u00e7\u00e3o de Configura\u00e7\u00e3o Anal\u00f3gica Feita pelo Webdesigner \n\n\n\n43 \n\n \n\nNote que os elementos apresentados na tela tamb\u00e9m se remetem aos \n\nalgoritmos de valida\u00e7\u00e3o apresentados na se\u00e7\u00e3o 3.2.1:. Estes items ser\u00e3o \n\narmazenados no banco de dados, apresentado na se\u00e7\u00e3o 3.3.1: Modelo de Dados. \n\nPor exemplo, ao inserir valores para a M\u00ednima Varia\u00e7\u00e3o, estando a check box \n\nselecionada, Watchdog Min. Var. com valor 10 e Banda Morta Min. Var. com valor 2 \n\numa inser\u00e7\u00e3o na tabela \u201cT_CONFIG_VLD_SINAL\u201d ocorrer\u00e1. Uma nova linha ser\u00e1 \n\ninserida com os valores para os par\u00e2metros \u201cFL_MIN_VARIACAO\u201d = true, \n\n\u201cQT_WATCHDOG_MIN_VAR\u201d = 10, \u201cQT_BANDA_MORA_MIN_VAR\u201d = 2.  \n\nEntretanto, diversos outros valores deveriam ser inseridos por n\u00e3o poderem \n\nser nulos na tabela, como o \u201cID_TAG_VALIDACAO\u201d. Outros valores t\u00eam valores \n\nlimitados, como \u201cFREQUENCIA_VLD\u201d deve ser maior que 60. Todas estas \n\nlimita\u00e7\u00f5es poderiam ser trabalhadas ap\u00f3s a inser\u00e7\u00e3o, retornando um erro se n\u00e3o \n\nestivessem adequadas. Por\u00e9m, haveria um processamento extra por parte do \n\nservidor. O uso de scripts poderiam alertar o usu\u00e1rio destas condi\u00e7\u00f5es e a inser\u00e7\u00e3o \n\nenviada para o servidor j\u00e1 estar de acordo com uma configura\u00e7\u00e3o correta.  \n\nA camada View \u00e9, por fim, aquela em que o usu\u00e1rio interage com o sistema. \n\nApresenta os valores que est\u00e3o mantidos no banco de dados e est\u00e3o tamb\u00e9m no \n\nservidor OPC. \n\n3.3.3: Implementa\u00e7\u00e3o das Regras de Neg\u00f3cio \n\nNa camada de Controller \u00e9 onde o processamento da valida\u00e7\u00e3o acontece. As \n\nRegras de Neg\u00f3cio definem o que foi apresentado na se\u00e7\u00e3o 3.2.1 e, nesta camada \n\ns\u00e3o codificadas, para posterior compila\u00e7\u00e3o e execu\u00e7\u00e3o adequada do sistema. \n\nAbaixo, vamos exemplificar a Regra de Neg\u00f3cio para o algoritmo de M\u00ednima \n\nVaria\u00e7\u00e3o: \n\nAlgoritmo de Valida\u00e7\u00e3o (AV) \u2013 M\u00ednima Varia\u00e7\u00e3o \n\nPara calcular a m\u00ednima varia\u00e7\u00e3o, s\u00e3o necess\u00e1rios os valores do sinal \n\nanteriormente validado e do sinal original. Estes valores s\u00e3o comparados com o \n\nvalor de banda morta, para a m\u00ednima varia\u00e7\u00e3o, seguindo a seguinte f\u00f3rmula: |Valor \n\ndo sinal anteriormente validado \u2013 valor do sinal| > banda morta. \n\n\n\n44 \n\n \n\nAlgoritmo de Valida\u00e7\u00e3o \u2013 M\u00ednima Varia\u00e7\u00e3o \u2013 Banda morta maior que a \n\ndiferen\u00e7a dos valores dos sinais \n\nSe a diferen\u00e7a absoluta, dos valores dos sinais validado e original, for \n\nsuperior a banda morta, o valor original do sinal \u00e9 v\u00e1lido. Este valor \u00e9 ent\u00e3o atribu\u00eddo \n\nao valor do sinal validado e o temporizador referente a este AV \u00e9 reinicializado. \n\nAlgoritmo de Valida\u00e7\u00e3o \u2013 M\u00ednima Varia\u00e7\u00e3o \u2013 Banda morta menor ou igual \n\nque a diferen\u00e7a dos valores dos sinais \n\nSe a diferen\u00e7a absoluta, dos valores dos sinais validado e original, for \n\nsuperior a banda morta, um temporizador \u00e9 incrementado. Este temporizador recebe \n\no valor de tempo, em minutos, da diferen\u00e7a entre duas execu\u00e7\u00f5es subsequentes do \n\nAV \u2013 M\u00ednima Varia\u00e7\u00e3o. \n\nAlgoritmo de Valida\u00e7\u00e3o \u2013 M\u00ednima Varia\u00e7\u00e3o \u2013 Temporizador maior que \n\ntempo associado ao Watchdog \n\nQuando o temporizador possuir valor superior ao tempo associado ao \n\nWatchdog o sinal \u00e9 inv\u00e1lido. O valor do sinal validado recebe o valor conforme \n\ndefinido nas op\u00e7\u00f5es de sa\u00edda de um AV, definidos na Regra de Neg\u00f3cio \u2013 Classificar \n\nSa\u00edda Inv\u00e1lida. \n\nAlgoritmo de Valida\u00e7\u00e3o \u2013 M\u00ednima Varia\u00e7\u00e3o \u2013 Sa\u00edda Inv\u00e1lida e Valor de \n\nRestri\u00e7\u00e3o \n\nCaso a op\u00e7\u00e3o de sa\u00edda, definido pela Regra de Neg\u00f3cio \u2013 Classificar Sa\u00edda \n\nInv\u00e1lida, seja o valor de restri\u00e7\u00e3o, ao valor do sinal validado \u00e9 atribu\u00eddo um valor \n\nigual do sinal original somado ou subtra\u00eddo da banda morta, de modo que este valor \n\nesteja compreendido entre os valores lidos.  \n\nAlgoritmo de Valida\u00e7\u00e3o \u2013 M\u00ednima Varia\u00e7\u00e3o \u2013 Sa\u00edda Inv\u00e1lida e Qualidade \n\nde Restri\u00e7\u00e3o \n\nCaso a op\u00e7\u00e3o de sa\u00edda, definido pela Regra de Neg\u00f3cio \u2013 Classificar Sa\u00edda \n\nInv\u00e1lida, seja o valor de restri\u00e7\u00e3o, a qualidade do sinal segue a restri\u00e7\u00e3o de sub-\n\nstatus de qualidade limitada inferior, quando ao sinal original foi adicionado o valor \n\nde banda morta,  ou superior, quando ao sinal original foi subtra\u00eddo o valor de banda \n\nmorta. \n\n\n\n45 \n\n \n\n \n\nAcima, est\u00e3o descritas diversas regras de neg\u00f3cio que comp\u00f5em o que ser\u00e1 \n\nusado para validar o algoritmo de m\u00ednima varia\u00e7\u00e3o. Note que pode haver refer\u00eancia \n\npara outras regras de neg\u00f3cio (Regra de Neg\u00f3cio \u2013 Classificar Sa\u00edda Inv\u00e1lida, n\u00e3o \n\napresentada). Em uma codifica\u00e7\u00e3o \u201cportugu\u00eas estruturado\u201d, por exemplo, podemos \n\napresentar o algoritmo de M\u00ednima Varia\u00e7\u00e3o da seguinte maneira: \n\nAlgoritmo de Valida\u00e7\u00e3o \u2013 M\u00ednima Varia\u00e7\u00e3o \n\nO algoritmo de m\u00ednima varia\u00e7\u00e3o recebe os seguintes par\u00e2metros: \n\n? Watch dog: valor em minutos; \n\n? Banda morta: valor em unidade de engenharia (UE). \n\nA execu\u00e7\u00e3o \u00e9 composta pelos seguintes passos: \n\n1. Ler o valor da TAG Original e anterior (TAG validada); \n\n2. Calcular a diferen\u00e7a (atual - anterior), comparando com a banda morta \n\n(absoluta); \n\n3. Se a diferen\u00e7a (modulo) for superior \u00e0 banda morta ent\u00e3o: \n\na. Sinal do TAG v\u00e1lido; \n\nb. Zerar o contador; \n\nc. TAG Validada recebe valor atual. \n\n4. Sen\u00e3o incrementa o contador com o intervalo entre valida\u00e7\u00f5es para a \n\nTAG; \n\n5. Se o contador for superior ao watch dog ent\u00e3o: \n\na. Sinal do TAG inv\u00e1lido; \n\nb. TAG Validada recebe o valor conforme definido nas op\u00e7\u00f5es de \n\nsa\u00edda de um AV; \n\nc. Caso a op\u00e7\u00e3o de sa\u00edda seja o valor de restri\u00e7\u00e3o, deve ser igual ao \n\nvalor atual (anterior) somado (subtra\u00eddo) com a banda morta. Atente \n\nque este valor deve estar entre os valores lidos e deve seguir a \n\nrestri\u00e7\u00e3o de sub-status de qualidade (limitada inferior ou superior). \n\n6. Se o contador for superior ao watch dog ent\u00e3o: \n\nNote que esta n\u00e3o \u00e9 a defini\u00e7\u00e3o da Regra de Neg\u00f3cio para o algoritmo de \n\nM\u00ednima Varia\u00e7\u00e3o, por n\u00e3o possuir diversas caracter\u00edsticas que uma Regra de \n\n\n\n46 \n\n \n\nNeg\u00f3cio deveria possuir: atomicidade, independ\u00eancia tecnol\u00f3gica, n\u00e3o fazer men\u00e7\u00e3o \n\na implementa\u00e7\u00e3o. Entretanto, nos d\u00e1 um bom ponto de partida do que deve ser \n\nimplementado. \n\n \n\nFigura 20 \u2013 Implementa\u00e7\u00e3o da M\u00ednima Varia\u00e7\u00e3o em C# \n\nAcima, est\u00e1 o c\u00f3digo do algoritmo de M\u00ednima Varia\u00e7\u00e3o em C#, para a camada \n\nde Controller. Este \u00e9 apenas um dos algoritmos. Embora a parte do sistema da \n\nvalida\u00e7\u00e3o de sinais, em si, estivesse bem encaminhada no desenvolvimento em C#, \n\nainda falta a codifica\u00e7\u00e3o que conectaria este sistema com o servidor OPC. \n\nAssim, quando o projeto se encaminhava para o desenvolvimento deste \n\n\u201cconector\u201d, a id\u00e9ia de continuarmos com a implementa\u00e7\u00e3o em C# foi abandonada e \n\npartimos para uma solu\u00e7\u00e3o j\u00e1 existente, que j\u00e1 era capaz de fazer essa conex\u00e3o \n\ncom o servidor OPC e tamb\u00e9m capaz de ter implementados os algoritmos de \n\nvalida\u00e7\u00e3o: a ferramenta automatizadora de procedimentos. \n\n\n\n47 \n\n \n\n3.4: Monitora\u00e7\u00e3o na Ferramenta Automatizadora de Procedimentos \n\nA Monitora\u00e7\u00e3o e Valida\u00e7\u00e3o de Sinais desenvolvida na ferramenta \n\nautomatizadora de procedimentos foi a solu\u00e7\u00e3o que foi implementada que teve seu \n\nfuncionamento testado. Algumas vantagens j\u00e1 foram apresentadas previamente e \n\npode-se citar: a ferramenta foi desenvolvida especificamente para uso em refinarias \n\ne aplica\u00e7\u00f5es ligadas ao petr\u00f3leo. Outra vantagem \u00e9 a comunica\u00e7\u00e3o OPC j\u00e1 estar \n\nimplementada e incorporada na ferramenta, j\u00e1 que esta \u00e9 a forma que a ferramenta \n\nse comunica com a planta. Assim, basta realizar o desenvolvimento das classes de \n\nopera\u00e7\u00e3o, a codifica\u00e7\u00e3o e os fluxogramas. \n\n3.4.1: Codifica\u00e7\u00e3o \n\nAssim como a camada de Controller no modelo MVC, \u00e9 na codifica\u00e7\u00e3o onde \n\ns\u00e3o mantidas as regras de neg\u00f3cio do sistema. Entretanto, a coordena\u00e7\u00e3o l\u00f3gica das \n\nchamadas das fun\u00e7\u00f5es, no caso do que foi desenvolvido, n\u00e3o s\u00e3o mantidas por \n\nc\u00f3digo (como seria em C#). A coordena\u00e7\u00e3o l\u00f3gica \u00e9 mantida pelos fluxogramas, \n\nsendo cada fun\u00e7\u00e3o do c\u00f3digo disponibilizado em um bloco funcional no fluxograma. \n\nFazendo a analogia com o modelo MVC, a camada de Model \u00e9 an\u00e1loga, em \n\npartes, com a Configura\u00e7\u00e3o, mantendo toda a configura\u00e7\u00e3o que ser\u00e1 instanciada (no \n\nFluxograma, durante a execu\u00e7\u00e3o) e utilizada nos c\u00e1lculos de valida\u00e7\u00e3o de sinais. Na \n\ncodifica\u00e7\u00e3o tamb\u00e9m s\u00e3o criadas as estruturas de classes de opera\u00e7\u00e3o e seus \n\natributos, que ser\u00e3o instanciadas. \n\nAbaixo, vemos a implementa\u00e7\u00e3o do algoritmo de valida\u00e7\u00e3o para M\u00ednima \n\nVaria\u00e7\u00e3o. A estrutura para emiss\u00e3o de alarmes e eventos para a BDTR A&amp;E tamb\u00e9m \n\n\u00e9 mantida na codifica\u00e7\u00e3o. A mensagem \u00e9 montada e a chamada \u201calerta:alertar()\u201d faz \n\ncom que um evento seja emitido pela BDTR A&amp;E. \n\n \n\n\n\n48 \n\n \n\n \n\nFigura 21 - Implementa\u00e7\u00e3o da M\u00ednima Varia\u00e7\u00e3o em Lua \n\nAssim, cada fun\u00e7\u00e3o implementada aqui estar\u00e1 apta a ser chamada no \n\nFluxograma. Al\u00e9m disso, diversos atributos foram criados para estarem dispon\u00edveis \n\nna configura\u00e7\u00e3o. \n\n3.4.2: Configura\u00e7\u00e3o da Planta \n\nA estrutura das classes de opera\u00e7\u00e3o, criada na codifica\u00e7\u00e3o, deve ser \n\npreenchida na configura\u00e7\u00e3o pelo engenheiro de processo ou engenheiro de TAG. \n\nAssim, todos os par\u00e2metros que estavam no modelo de dados foram criados nas \n\nclasses. \n\nAl\u00e9m disso, h\u00e1 uma TAG de Origem de uma TAG de Destino que s\u00e3o, \n\nrespectivamente, as que ser\u00e3o lidas para serem validadas e as validadas. Cada \n\nalgoritmo representa uma classe de opera\u00e7\u00e3o diferente. Cada valida\u00e7\u00e3o de sinal ter\u00e1 \n\numa \u00e1rea espec\u00edfica para que seus atributos tenham valor, conforme a opera\u00e7\u00e3o \n\ndesejada. \n\nAssim, note que as strings TAG Origem e TAG Destino s\u00e3o os endere\u00e7os da \n\nBDTR DA e devem possuir exatamente o mesmo texto desta.  \n\n\n\n49 \n\n \n\n \n\nFigura 22 \u2013 Configura\u00e7\u00e3o e Inser\u00e7\u00e3o de Par\u00e2metros para TAGs Anal\u00f3gicas \n\n \n\nFigura 23 \u2013 Resumo das configura\u00e7\u00f5es inseridas \n\nEstando todas as configura\u00e7\u00f5es prontas, os algoritmos podem ser criados nos \n\nfluxogramas. \n\n3.4.3: Gera\u00e7\u00e3o dos Fluxogramas \n\nOs fluxogramas mant\u00eam a coordena\u00e7\u00e3o l\u00f3gica da execu\u00e7\u00e3o. Abaixo, est\u00e3o os \n\nfluxos para as valida\u00e7\u00f5es das TAGs Anal\u00f3gica e TAGs Digital. Novamente, nos \n\nremetemos as regras de neg\u00f3cio para saber quais algoritmos devem ser executados \n\ne qual a ordem de execu\u00e7\u00e3o. \n\nAssim, cada fluxo executar\u00e1 em um loop infinito, ap\u00f3s serem instanciados. A \n\nestrutura \u00e9 de f\u00e1cil entendimento por ser extremamente parecido com um flograma. \n\nOs losangos representam pontos de decis\u00e3o, retornando a compara\u00e7\u00e3o verdadeira \n\nou falsa. Os ret\u00e2ngulos s\u00e3o pontos de a\u00e7\u00e3o, que executam fun\u00e7\u00f5es definidas na \n\ncodifica\u00e7\u00e3o. Note o algoritmo de M\u00ednima Varia\u00e7\u00e3o no fluxo de TAG Anal\u00f3gica. \n\nOs fluxos de TAG Digital e TAG Multiestado s\u00e3o muito semelhantes, como \n\npode ser visto pelas descri\u00e7\u00f5es das regras de neg\u00f3cio, j\u00e1 na se\u00e7\u00e3o 3.2.1. Assim, a \n\nfigura do fluxo de TAG Multiestado foi suprimida. \n\n\n\n50 \n\n \n\n \n\nFigura 24 - Fluxo de TAG Anal\u00f3gica \n\n \n\nFigura 25 - Fluxo de TAG Digital \n\n\n\n51 \n\n \n\n3.4.4: Opera\u00e7\u00e3o e Aplica\u00e7\u00e3o: Execu\u00e7\u00e3o \n\nFeita toda configura\u00e7\u00e3o, estando a BDTR executando, basta conectarmos o \n\nservidor da ferramenta automatizadora de procedimentos (cliente OPC) \u00e0 BDTR \n\n(servidor OPC).  \n\n \n\nFigura 26 - Servidor da ferramenta executando \n\nAssim, conectando o cliente da ferramenta ao servidor desta e exportando os \n\nfluxogramas para o servidor, estamos aptos para realizar a valida\u00e7\u00e3o de sinais. Toda \n\na configura\u00e7\u00e3o feita ser\u00e1 avaliada e os valores ser\u00e3o escritos na BDTR para que, \n\nenfim, estejam dispon\u00edveis para outras aplica\u00e7\u00f5es. \n\nDessa forma, caso o fluxograma selecionado para executar seja o Fluxo de \n\nTAG Anal\u00f3gica. Todas as inst\u00e2ncias (com base nas linhas das tabelas da \n\nConfigura\u00e7\u00e3o) ser\u00e3o criadas. Cada inst\u00e2ncia executar\u00e1 o loop do fluxo.  \n\nPrimeiramente, s\u00e3o lidos os valores da TAG Origem do servidor OPC. Se n\u00e3o \n\nhouver nenhum erro na leitura, o fluxo seguir\u00e1 para a execu\u00e7\u00e3o dos algoritmos. \n\nSupondo que o algoritmo de M\u00ednima Varia\u00e7\u00e3o esteja ativado na Configura\u00e7\u00e3o (\u201cFlag \n\nde M\u00ednima Valida\u00e7\u00e3o\u201d = true), o algoritmo definido na codifica\u00e7\u00e3o ser\u00e1 invocado e \n\nexecutado. Os outros algoritmos ser\u00e3o executados e, por fim, o valor validado ser\u00e1 \n\nsalvo. Aquela inst\u00e2ncia esperar\u00e1 sua pr\u00f3xima execu\u00e7\u00e3o, definida pelo valor de \n\nfrequ\u00eancia de valida\u00e7\u00e3o, e reiniciar\u00e1 o loop. \n\n \n\n \n\n \n\n \n\n\n\n52 \n\n \n\n3.4.5: Interface \n\nPara permitir que valores da configura\u00e7\u00e3o sejam alterados durante a \n\nexecu\u00e7\u00e3o, uma interface simples foi criada. Esta realiza altera\u00e7\u00f5es nas inst\u00e2ncias e \n\npermite que o operador verifique o que est\u00e1 ocorrendo na planta. Assim, para \n\nrealiza\u00e7\u00e3o dos testes, esta interface foi satisfat\u00f3ria. \n\n \n\nFigura 27 \u2013 Interface IHM para a Monitora\u00e7\u00e3o e Valida\u00e7\u00e3o de Sinais \n\n \n\n\n\n53 \n\n \n\nCap\u00edtulo 4: Resultados \n\nOs resultados apresentados neste cap\u00edtulo referem-se \u00e0 Monitora\u00e7\u00e3o e \n\nValida\u00e7\u00e3o de Sinais apresentados no cap\u00edtulo anterior, desenvolvido na ferramenta \n\nautomatizadora de procedimentos. Estes resultados foram utilizados para justificar \n\nque a ferramenta seria capaz de operar nas condi\u00e7\u00f5es de campo. Ap\u00f3s \n\ndesenvolvidas as funcionalidades, diversos testes foram feitos para verificar \n\ndesempenho e funcionamento correto, testados em diferentes cen\u00e1rios e condi\u00e7\u00f5es.  \n\nOs cen\u00e1rios foram levantados pelo autor deste texto e por Diogo Pacheco \n\n(orientador da empresa). Os resultados apresentados foram obtidos no ambiente \n\nRadix e n\u00e3o no \u00e2mbito de opera\u00e7\u00e3o. Estes testes permitiram avaliar a viabilidade da \n\nferramenta proposta. \n\n4.1: Resultados da Monitora\u00e7\u00e3o \n\nNesta se\u00e7\u00e3o, foi avaliado a efici\u00eancia e a funcionalidade do sistema em \n\ncondi\u00e7\u00f5es extremas, verificando sua robustez. Assim, situa\u00e7\u00f5es acima da condi\u00e7\u00e3o \n\nde opera\u00e7\u00e3o foram utilizadas nos testes.  \n\nAl\u00e9m disso, \u00e9 importante ressaltar que a ferramenta automatizadora de \n\nprocedimentos pode operar de diversas maneiras, como por exemplo: leitura e \n\nescrita s\u00edncronas e ass\u00edncronas, como j\u00e1 citado anteriormente neste documento; \n\nleitura e escrita em blocos, fazendo uma chamada OPC para opera\u00e7\u00f5es de diversas \n\nTAGs ou uma chamada por TAG; operar de maneira distribu\u00edda ou local. \n\nNote que, como citado, estes testes ocorreram em ambiente corporativo, com \n\nm\u00e1quinas desktops de uso cotidiano. Para a opera\u00e7\u00e3o, foi sugerido a aquisi\u00e7\u00e3o de \n\numa m\u00e1quina dedicada para execu\u00e7\u00e3o da monitora\u00e7\u00e3o e valida\u00e7\u00e3o de sinais e da \n\nBDTR, com desempenho muito melhor que as de uso comum. \n\n4.1.1: Escopo do Teste \n\nPara a realiza\u00e7\u00e3o dos testes, foram criadas diversas TAGs Anal\u00f3gicas, \n\nDigitais e Multiestados. Outras configura\u00e7\u00f5es foram necess\u00e1rias tamb\u00e9m para que o \n\n\n\n54 \n\n \n\nsistema operasse de maneira correta, como endere\u00e7o para chamada de alarmes e \n\nregistros em arquivos. Al\u00e9m disso, testes referentes a tanques (da monitora\u00e7\u00e3o \n\ntotal), que j\u00e1 estavam implementadas a esta altura foram acrescentados nos testes. \n\nAssim, no total, est\u00e3o sendo validadas cerca de 11000 TAGs digitais, 5000 \n\nTAGs anal\u00f3gicas e 750 TAGs multiestado. Esses valores foram feitos baseados em \n\nlevantamentos de campo, nas refinarias, e a estrutura utilizada \u00e9 bem semelhante a \n\nque existiria em campo. Al\u00e9m destes, foram feitos c\u00e1lculos para 200 tanques, \n\nutilizando as TAGs criadas. \n\nUm mecanismo de barreira foi implementado de maneira que garante que em \n\num determinado ponto do fluxo todas as execu\u00e7\u00f5es lan\u00e7adas em paralelo pela \n\nferramenta estariam finalizadas. Tamb\u00e9m foram implementadas chamadas para \n\nabertura de arquivo de log e chamada de alerta (utilizando banco de dados), que \n\nforam executadas ou n\u00e3o, de acordo com o cen\u00e1rio de teste espec\u00edfico. \n\nNeste teste, n\u00e3o verificou-se se a realiza\u00e7\u00e3o da valida\u00e7\u00e3o estava sendo \n\nefetivamente correta pois busca-se exatamente a for\u00e7a bruta do sistema. A corretude \n\nda opera\u00e7\u00e3o ser\u00e1 verificada na se\u00e7\u00e3o de plano de testes (se\u00e7\u00e3o 4.2). \n\n4.1.2: Cen\u00e1rios de Teste \n\nDefiniram-se alguns cen\u00e1rios para submeter aos testes. Tais cen\u00e1rios \n\ncontemplam as formas de configura\u00e7\u00e3o do sistema. Com isso, espera-se identificar \n\nas condi\u00e7\u00f5es que inviabilizam a monitora\u00e7\u00e3o, bem como aquelas que tendem a ser \n\nmais eficientes. Na tabela abaixo s\u00e3o listados os cen\u00e1rios submetidos aos testes: \n\nCen\u00e1rio Instalala\u00e7\u00e3o Configura\u00e7\u00e3o Concorr\u00eancia LOGs Alertas \n\n1 Local Com blocos Sim N\u00e3o N\u00e3o \n\n2 Local Com blocos N\u00e3o N\u00e3o N\u00e3o \n\n3 Local Sem blocos Sim N\u00e3o N\u00e3o \n\n4 Local Sem blocos N\u00e3o N\u00e3o N\u00e3o \n\n5 Remoto Com blocos Sim N\u00e3o N\u00e3o \n\n6 Remoto Com blocos N\u00e3o N\u00e3o N\u00e3o \n\n\n\n55 \n\n \n\n7 Remoto Sem blocos Sim N\u00e3o N\u00e3o \n\n8 Remoto Sem blocos N\u00e3o N\u00e3o N\u00e3o \n\n9 Local Com blocos Sim Sim N\u00e3o \n\n10 Local Com blocos Sim Sim Sim \n\n11 Remoto Com blocos Sim Sim Sim \n\n \n\nExtra Remoto Com blocos Sim Sim N\u00e3o \n\nTabela 2 \u2013 Cen\u00e1rios de Teste da Monitora\u00e7\u00e3o \n\nCom rela\u00e7\u00e3o \u00e0s formas de configura\u00e7\u00e3o, a instala\u00e7\u00e3o pode ser Local ou \n\nRemota: isso se refere a instala\u00e7\u00e3o do servidor OPC e a execu\u00e7\u00e3o da ferramenta \n\nautomatizadora de procedimentos. Se est\u00e3o executando na mesma m\u00e1quina, a \n\nexecu\u00e7\u00e3o \u00e9 Local; se em m\u00e1quinas distintas, Remoto.  \n\nAl\u00e9m disso, a ferramenta pode habilitar a comunica\u00e7\u00e3o em blocos ou n\u00e3o. A \n\nutiliza\u00e7\u00e3o de blocos em leituras e escritas pode melhorar, significantemente, o \n\ndesempenho global da aplica\u00e7\u00e3o nos casos em que o tempo de resposta de uma \n\nleitura ou escrita de um \u00fanico TAG \u00e9 elevado. H\u00e1 servidores que podem demandar \n\nmais de 2 segundos numa escrita enquanto outros o fazem quase que \n\ninstantaneamente. Para a monitora\u00e7\u00e3o, esta configura\u00e7\u00e3o \u00e9 sens\u00edvel por haver um \n\nn\u00famero muito grande de TAGs, sendo que cada d\u00e9cimo de segundo gasto em uma \n\n\u00fanica TAG pode representar, globalmente, v\u00e1rios segundos. \n\nCriaram-se ainda cen\u00e1rios para estressar o sistema a partir das inclus\u00f5es de: \n\n? Escritas de logs em um arquivo local \u00e0 instala\u00e7\u00e3o da monitora\u00e7\u00e3o; \n\n? Registro de alertas em uma base de dados; \n\n? Acesso concorrente ao servidor OPC a partir de escritas cont\u00ednuas de outro \n\ncliente, executado em uma terceira m\u00e1quina (simulando a conex\u00e3o com o \n\nSDCD). \n\nA ferramenta utilizada \u00e9 um sistema monothread, isto \u00e9, apenas uma \n\nopera\u00e7\u00e3o do sistema ocorre em um dado instante de tempo, n\u00e3o havendo espa\u00e7o \n\npara execu\u00e7\u00e3o de diversos cen\u00e1rios concorrentemente. Os sistemas operacionais \n\n\n\n56 \n\n \n\natuais permitem a execu\u00e7\u00e3o multithread, podendo v\u00e1rias execu\u00e7\u00f5es ocorrerem em \n\nparalelo.  \n\nDessa forma, o cen\u00e1rio apresentado como \u201cExtra\u201d se refere a uma \n\nparaleliza\u00e7\u00e3o da opera\u00e7\u00e3o da ferramenta, onde v\u00e1rias inst\u00e2ncias desta, cada uma \n\ncom uma fra\u00e7\u00e3o do sistema, executa de maneira paralela no Sistema Operacional. \n\nAs fra\u00e7\u00f5es se referem a execu\u00e7\u00e3o da valida\u00e7\u00e3o dos TAGs Anal\u00f3gicos, da dos TAGs \n\nDigitais e da dos TAGs Multiestados. Sendo assim, o tempo de execu\u00e7\u00e3o deixa de \n\nser a soma dos tempos individuais de cada fun\u00e7\u00e3o, mas o maior dos tempos de \n\nexecu\u00e7\u00e3o. \n\n4.1.3: Resultados dos Testes \n\nPara cada cen\u00e1rio definido foram executados 5 ciclos consecutivos. Este \n\nn\u00famero foi definido empiricamente ap\u00f3s observar-se poucas varia\u00e7\u00f5es na dura\u00e7\u00e3o \n\ndos ciclos ap\u00f3s a inicializa\u00e7\u00e3o (1\u00ba ciclo). Os testes foram repetidos pelo menos tr\u00eas \n\nvezes, verificando altera\u00e7\u00f5es m\u00ednimas entre as bateladas de teste. Por esta raz\u00e3o, \n\nos detalhes trazem informa\u00e7\u00f5es de apenas um teste (5 ciclos) por cen\u00e1rio. Al\u00e9m \n\ndisso, para contabilizar a m\u00e9dia dos resultados, o primeiro ciclo foi ignorado, por n\u00e3o \n\nrepresentar a opera\u00e7\u00e3o cont\u00ednua do sistema e sim seu start-up. \n\nNa tabela abaixo s\u00e3o apresentados os tempos gastos para executar cada \n\nciclo de todos os cen\u00e1rios testados. \u00c9 poss\u00edvel notar uma pequena perda de \n\ndesempenho quando n\u00e3o se utiliza opera\u00e7\u00f5es em bloco. Por outro lado, o fato do \n\nservidor OPC ser concorrido por outro cliente n\u00e3o implicou em altera\u00e7\u00f5es de \n\ndesempenho. Nos cen\u00e1rios em que se adicionou logs, cerca de 43 mil mensagens \n\ndurante 5 ciclos foram registradas, com uma adi\u00e7\u00e3o m\u00e9dia de 2 segundos por ciclo. \n\nNos cen\u00e1rios com banco de dados, aproximadamente 40 mil inser\u00e7\u00f5es num banco \n\nde dados com informa\u00e7\u00f5es dos alertas foram realizadas ao longo de todos os ciclos. \n\nCiclo \n Cen\u00e1rios (tempos em segundos) \n\n1 2 3 4 5 6 7 8 9 10 11  Extra \n\n1 25 29 35 33 27 27 135 136 29 36 76  31 \n\n2 14 14 18 16 15 14 33 35 17 22 33  11 \n\n\n\n57 \n\n \n\n3 14 14 19 18 15 14 38 36 16 18 31  11 \n\n4 14 13 23 16 15 15 42 33 16 18 34  12 \n\n5 13 16 20 17 15 15 35 33 17 24 32  11 \n\nM\u00e9dia 14 14 20 17 15 15 37 34 17 21 33  11 \n\nTabela 3 \u2013 Resultados dos Cen\u00e1rios de Teste \n\nO software de monitora\u00e7\u00e3o foi submetido a testes com carga suficiente para \n\nemular os cen\u00e1rios de produ\u00e7\u00e3o da refinaria. Os testes abrangeram cen\u00e1rios \n\nexplorando as formas de comunica\u00e7\u00e3o da monitora\u00e7\u00e3o e cen\u00e1rios que, lentamente, \n\nforam degradando o ambiente com outras funcionalidades concorrentes que n\u00e3o o \n\ncerne da monitora\u00e7\u00e3o. \n\nO tempo m\u00e9dio de execu\u00e7\u00e3o em todos os cen\u00e1rios pr\u00e1ticos \u00e9 inferior a 0,5 \n\nminuto. A monitora\u00e7\u00e3o n\u00e3o realizar\u00e1 verifica\u00e7\u00f5es em intervalos inferiores a 1 minuto, \n\ncomo definido nos documentos de especifica\u00e7\u00e3o. Com isso, mesmo se o sistema \n\nfosse degradado em 100%, este ainda conseguiria executar as funcionalidades \n\ndentro do intervalo limite estipulado. Ressalta-se ainda que o ambiente de execu\u00e7\u00e3o \n\nde testes utilizou m\u00e1quinas de uso di\u00e1rio e que os valores encontrados podem ser \n\nmelhorados quando realizados no servidor espec\u00edfico para seu fim dentro do \n\nambiente controlado da refinaria. \n\nPelos resultados apresentados, considera-se que a implementa\u00e7\u00e3o do \n\nsoftware de monitora\u00e7\u00e3o atendeu satisfatoriamente aos testes de desempenho aos \n\nquais foi submetida. \n\n4.2: Plano de Testes \n\nComo dito, os testes apresentados acima buscaram analisar a performance \n\ndo sistema, aplicando a for\u00e7a bruta. Entretanto, n\u00e3o se garantia que o funcionamento \n\nadequado estavisse ocorrendo. Ali\u00e1s, valores aleat\u00f3rios eram geradas e n\u00e3o tinham \n\nvalor real para o sistema. Deseja-se, por\u00e9m, confirmar que o sistema funcione de \n\nmaneira adequada.  \n\nAssim, um plano de testes foi criado, com diversos casos de teste que \n\nbuscam confirmar e corroborar com as regras de neg\u00f3cio, evidenciando a corretude \n\n\n\n58 \n\n \n\ndo sistema. A id\u00e9ia \u00e9 que os casos de testes sirvam tamb\u00e9m como um guia para que \n\no funcionamento adequado fosse verificado e o sistema desenvolvido homologado. \n\nO resultado de um algoritmo depende muito da condi\u00e7\u00e3o do sistema, com \n\nseus valores que s\u00e3o lidos, al\u00e9m da configura\u00e7\u00e3o em si, sendo dif\u00edcil explicitar todas \n\nas poss\u00edveis situa\u00e7\u00f5es em que o sistema poderia estar. Assim, apenas algumas \n\nforam criadas. \n\nPor exemplo, um teste para o algoritmo de M\u00ednima Varia\u00e7\u00e3o \u00e9 apresentado na \n\ntabela abaixo: \n\nEstado de Opera\u00e7\u00e3o do Sistema Configura\u00e7\u00e3o do \n\nAlgoritmo \n\nReultado \n\nEsperado \nTAG Original TAG Validada \n\nValor = 375 Valor = 380 Frequ\u00eancia de \n\nValida\u00e7\u00e3o = 60 \n\nTAG Validada pelo \n\nCiclo com Valor = \n\n374 e qualidade = \n\nINCERTA. A \n\nestampa de tempo \n\n\u00e9 feita no momento \n\nda escrita pelo \n\nservidor OPC. \n\nQualidade = BOA Qualidade = BOA Flag M\u00ednima \n\nVaria\u00e7\u00e3o = TRUE \n\nEstampa de tempo \n\n= 10:15:00 \n\nEstampa de tempo \n\n= 10:00:00 \n\nWatchdog de M\u00edn. \n\nVaria\u00e7\u00e3o = 900 \n\n Banda Morta de \n\nM\u00edn. Varia\u00e7\u00e3o = 6 \n\nSa\u00edda padr\u00e3o = 3 \n\nTabela 4 \u2013 Resultado de uma Valida\u00e7\u00e3o \n\n Al\u00e9m de casos de testes para os algoritmos, casos de testes para a inser\u00e7\u00e3o \n\nda configura\u00e7\u00e3o foram gerados, explicando o que cada entrada no sistema \n\nrepresentava e seus tipos adequados.  \n\n Tudo isso, contribuiu para evidenciar que o sistema de Monitora\u00e7\u00e3o e \n\nValida\u00e7\u00e3o de Sinais efetivamente est\u00e1 de acordo com as especifica\u00e7\u00f5es. \n\n\n\n59 \n\n \n\n4.3: Discuss\u00e3o sobre os testes \n\nA fase de teste \u00e9 de fundamental import\u00e2ncia para o sucesso de um projeto. \n\nApesar de n\u00e3o existir softwares 100% livres de erros (em termos matem\u00e1ticos), uma \n\nboa estrat\u00e9gia de teste pode garantir confiabilidade e seguran\u00e7a em n\u00edveis \n\ndesej\u00e1veis aos sistemas. \n\nPara a verificar a completude funcional e o atendimento aos requisitos, foi \n\nrealizada logo ap\u00f3s o desenvolvimento, em um ambiente interno da Radix, uma \n\nbatelada de testes conhecidos como Testes Internos. Os resultados apresentados \n\nnas se\u00e7\u00f5es anteriores se referem a  estes resultados. \n\nEntretanto, durante o desenvolvimento, diversos testes foram realizados (nem \n\nsempre com a profundidade e a acur\u00e1cia dos testes aqui apresentados) sem serem \n\ndocumentados, muitas vezes, apenas para testar funcionalidades locais, como de \n\numa ou outra fun\u00e7\u00e3o. Nestes testes \u201cpontuais\u201d, alguns problemas foram encontrados \n\ne foram solucionados conforme apareciam. \n\nAlguns problemas, comum no desenvolvimento de softwares, decorreram de \n\nm\u00e1 implementa\u00e7\u00e3o foram prontamente resolvidos. Outros, por\u00e9m, levaram algum \n\nestudo e envolvimento de outros grupos e pessoas, inclusive dos desenvolvedores \n\nda ferramenta automatizadora de procedimentos. \n\nO primeiro problema encontrado foi quanto ao tempo de ciclos. Nas mesmas \n\ncondi\u00e7\u00f5es dos testes apreentados, os ciclos levavam cerca de 180 segundos para \n\ncompletarem. Isto estava totalmente fora das especifica\u00e7\u00f5es e, com certeza, n\u00e3o \n\natenderia as condi\u00e7\u00f5es de opera\u00e7\u00e3o (que exige menos de 60 segundos por ciclo).  \n\nRevisando c\u00f3digos, buscando solu\u00e7\u00f5es descobriu-se que o problema estava \n\nna primeira solu\u00e7\u00e3o para emiss\u00e3o de alarmes, utilizando um banco de dados. A \n\nconex\u00e3o era aberta e fechada a cada nova emiss\u00e3o de alarme o que causava um \n\noverhead, um processamento extra, que n\u00e3o deveria existir. A solu\u00e7\u00e3o encontrada, \n\nfoi abrir a conex\u00e3o com o banco de dados e n\u00e3o fech\u00e1-la at\u00e9 que todos os ciclos \n\nestivessem terminado seu fluxo. \n\n\n\n60 \n\n \n\nIsto foi descoberto no laborat\u00f3rio onde a ferramenta automatizadora de \n\nprocedimentos foi desenvolvida, onde o autor deste texto e orientador estiveram \n\npara levantar poss\u00edveis problemas que estavam causando o alto processamento. \n\nOutro problema que envolveu a equipe da ferramenta foi quanto \u00e0 ponte OPC. \n\nOs dados passados pela BDTR s\u00e3o obtidos pelo cliente por subscri\u00e7\u00e3o. A \n\nferramenta estava com problema para armezenar estes dados para serem utilizados \n\nposteriormente e n\u00e3o no momento de recebimento dos dados. Al\u00e9m disso, \n\nproblemas com escrita em blocos foram encontrados. \n\nOs problemas descritos no par\u00e1grafo passado levou algum tempo a mais para \n\nserem descobertos pois n\u00e3o dependiam do desenvolvimento da equipe Radix e sim \n\nde terceiros. A cada erro encontrado na ferramenta, uma nova vers\u00e3o de instala\u00e7\u00e3o \n\nera gerada e os testes eram refeitos para garantir o funcionamento do sistema. \n\nConseguiu-se, por fim, resolver os problemas de maneira progressiva e, enfim, obter \n\numa solu\u00e7\u00e3o que atendia as especifica\u00e7\u00f5es. \n\nApresentados os resultados dos testes, a ida de uma equipe Radix para a \n\n\u00e1rea de opera\u00e7\u00f5es foi aprovada. O autor deste texto ficou dando suporte a equipe \n\nque se dirigiu \u00e0 campo, na refinaria. \n\nEntretanto, por problemas de seguran\u00e7a de TI na refinaria, a BDTR n\u00e3o \n\nconseguiu se comunicar com SDCDs e tamb\u00e9m com clientes OPC. Assim, grosso \n\nmodo, apenas se repetiu os testes internos realizados na Radix com outro servidor \n\nOPC na refinaria para a comprova\u00e7\u00e3o da efic\u00e1cia e corretude do sistema. \n\n\n\n61 \n\n \n\nCap\u00edtulo 5: Conclus\u00f5es e Perspectivas \n\nNeste trabalho, discutiu-se sobre a implementa\u00e7\u00e3o de um sistema de \n\nmonitora\u00e7\u00e3o de dados que fornece dados validados para outros sistemas, a partir de \n\numa s\u00e9rie de regras. Al\u00e9m disso, apresentou-se um sistema de banco de dados em \n\ntempo real que centralizava toda a informa\u00e7\u00e3o produzida pelo sistema de \n\ntransfer\u00eancia e estocagem de uma refinaria de petr\u00f3leo, que tamb\u00e9m mant\u00e9m os \n\ndados validados. \n\nAp\u00f3s a informa\u00e7\u00e3o ser colhida e armazenada nesse sistema de banco de \n\ndados, algoritmos de valida\u00e7\u00e3o atuam de maneira a \u201cmelhorar\u201d o dado, evitando \n\ndados incongruentes e n\u00e3o corretos para o sistema. Assim, notadamente, o que se \n\nespera do sistema de valida\u00e7\u00e3o n\u00e3o \u00e9 apenas produzir dados mas produzir dados \n\ncontribuam com a produ\u00e7\u00e3o, fornecendo informa\u00e7\u00f5es \u00fateis para aumentar a \n\nefici\u00eancia do processo. \n\nNeste sentido, \u00e9 interessante citar Bill Gates: \"A primeira regra de qualquer \n\ntecnologia utilizada nos neg\u00f3cios \u00e9 que a automa\u00e7\u00e3o aplicada a uma opera\u00e7\u00e3o \n\neficiente aumentar\u00e1 a efici\u00eancia. A segunda \u00e9 que a automa\u00e7\u00e3o aplicada a uma \n\nopera\u00e7\u00e3o ineficiente aumentar\u00e1 a inefici\u00eancia\u201d. \n\nAssim, operadores sabem como melhorar e otimizar um processo. Entretanto, \n\nn\u00e3o podem faz\u00ea-lo de maneira constante e id\u00eantica, sistematicamente. Como as \n\nregras s\u00e3o, de certa forma, emp\u00edricas, o aspecto humano atuando de maneira a \n\notimizar o processo na planta \u00e9 evidente.  \n\nEntretanto, o sistema desenvolvido \u00e9 apenas uma parcela desse sistema de \n\n\u201crefinamento de informa\u00e7\u00f5es\u201d, validando-se uma s\u00e9rie de dados generalistas. \n\nDiversas outras fun\u00e7\u00f5es ainda ser\u00e3o agregadas a solu\u00e7\u00e3o, que ainda devem ser \n\ndesenvolvidas, com c\u00e1lculos mais intr\u00ednsecos ao neg\u00f3cio, como ligados a tanques. \n\n\u00c9 importante ressaltar que o sistema desenvolvido foi aplicado em refinaria, \n\ndevido a uma necessidade espec\u00edfica. Por\u00e9m, a aplica\u00e7\u00e3o dessas regras poderiam \n\nser repassadas para diversos segmentos industriais, melhorando o desempenho e \n\nefici\u00eancia dos processos, como sider\u00fargicas, processos de manufatura e outros. \n\n\n\n62 \n\n \n\nBibliografia: \n\n[1] Wikipedia, a enciclop\u00e9dia livre, www.wikipedia.org (acessado em Junho de 2012) \n\n[2] R. Sousa, Hist\u00f3ria do Petr\u00f3leo no Brasil, www.brasilescola.com (acessado em \n\nJunho de 2012) \n\n[3] Radix \u2013 Engenharia e Software, www.radixeng.com.br (acessado em Junho de \n\n2012) \n\n[4] OPC Foundation, www.opcfoundation.org (acessado em Junho de 2012) \n\n[5] OPC Data Access 3.00 Specification, OPC Foundation, Version 3.00, Mar\u00e7o de \n\n2003 \n\n[6] OPC Alarms &amp; Events Specification, OPC Foundation, Version 1.02, Novembro \n\nde 1999 \n\n[7] Visual C# Developer Center, www.msdn.microsoft.com/vcsharp (acessado em \n\nJunho de 2012) \n\n[8] R. Ierusalimschy, L. H. de Figueiredo, W. Celes, \u201cLua 5.0 Reference Manual\u201d, \n\nPUC-Rio, 2003"}]}}}