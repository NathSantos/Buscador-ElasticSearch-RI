{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.14654"}, {"@name": "filename", "#text": "21016_244514.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DE SANTA CATARINA \nPROGRAMA DE P\u00d3S-GRADUA\u00c7\u00c3O EM CI\u00caNCIA DA \n\nCOMPUTA\u00c7\u00c3O \n \n\n \n \n\n \nFabio Alexandre Spanhol \n\n \n \n \n \nUma Aplica\u00e7\u00e3o de XML para Auxiliar na Ger\u00eancia de \n\nRedes \n  \n\n \n \n \nDisserta\u00e7\u00e3o submetida \u00e0 Universidade Federal de Santa Catarina como parte dos \nrequisitos para a obten\u00e7\u00e3o do grau de Mestre em Ci\u00eancia da Computa\u00e7\u00e3o \n\n  \n \n \n \n \n\nProf. Dr. Carlos Becker Westphall, Orientador \n  \n\n \n \n \n \n \n \n \n \n \n\nFlorian\u00f3polis, dezembro de 2002 \n\n\n\nii \n\n  \nUma Aplica\u00e7\u00e3o de XML para Auxiliar na Ger\u00eancia de Redes  \n\n \n \n\nFabio Alexandre Spanhol \n  \n \n\nEsta Disserta\u00e7\u00e3o foi julgada adequada para a obten\u00e7\u00e3o do t\u00edtulo de Mestre em \n\nCi\u00eancia da Computa\u00e7\u00e3o, \u00c1rea de Concentra\u00e7\u00e3o Sistemas de Computa\u00e7\u00e3o e aprovada em \n\nsua forma final pelo Programa de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o. \n\n  \n \n\n  \n \n\nProf. Fernando A. Ostuni Gauthier, Dr.  \nCoordenador \n\n  \n \n \nBanca Examinadora:  \n\n \nProf. Carlos Becker Westphall, Dr.  \n\nPresidente \n  \n\n \nProfa. Carla Merkle Westphall, Dra. \n\n  \n \n\nProf. M\u00e1rio Antonio Ribeiro Dantas, Dr. \n \n\n \nProf. Roberto Willrich, Dr. \n\n  \n\n\n\niii \n\n  \n\n\u201cPara ser grande, s\u00ea inteiro: nada \n\nTeu exagera ou exclui. \n\nS\u00ea todo em cada coisa. P\u00f5e quanto \u00e9s \n\nNo m\u00ednimo que fazes. \n\nAssim em cada lago a lua toda \n\nBrilha, porque alta vive\u201d. \n\n \n\n(Ricardo Reis, um dos heter\u00f4nimos de Fernando Pessoa) \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\u201dEstudai como se viv\u00easseis para sempre, vivei como se f\u00f4sseis morrer amanh\u00e3\u201d \n\n(Santo Isidoro De Sevilha) \n\n \n\n\n\niv \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nAos meus queridos pais Alcino Spanhol e Deisy do Carmo Bah\u00fa Spanhol, por todos os \n\nanos de apoio, dedica\u00e7\u00e3o e esmero; mostrando-me sempre como superar de maneira \n\ndigna as mesquinharias e injusti\u00e7as que permeiam nossa ef\u00eamera peregrina\u00e7\u00e3o por este \n\nmundo.  \n\n\u00c0 minha amada esposa Claudiana Soerensen e ao meu precioso filho Marcus Vin\u00edcius \n\nSoerensen Spanhol, que constitu\u00edram minha fortaleza em suas singelas fragilidades. \n\n\n\nv \n\nAGRADECIMENTOS \n\nAo Criador Supremo, onipresente e onisciente, simultaneamente particular e \n\nc\u00f3smico. Inspira\u00e7\u00e3o e fonte primeira de todo conhecimento. \n\nCarinhosamente \u00e0 minha amada esposa, Claudiana Soerensen, sempre amorosa \n\ncompanheira, pelas preciosas horas de nosso conv\u00edvio tolhidas pelo presente trabalho.  \n\nA Marcus Vin\u00edcius Soerensen Spanhol, o Vini, meu filho amado. Um pequenino \n\nastro que trouxe aos meus dias um novo \u00e2nimo. Pe\u00e7o perd\u00e3o pelas minhas muitas \n\naus\u00eancias, tanto f\u00edsicas como mentais. Espero poder despender mais tempo para viver e \n\ncompartilhar esses preciosos e \u00fanicos momentos de sua inf\u00e2ncia. \n\nAos meus pais, Alcino Spanhol e Deisy do Carmo Bah\u00fa Spanhol, pelo modelo de \n\nretid\u00e3o de car\u00e1ter transmitido desde os meus tenros anos. \n\nAos meus irm\u00e3os, Ana Cl\u00e1udia Spanhol, M\u00e1rcio Rog\u00e9rio Spanhol e Silvia Let\u00edcia \n\nSpanhol, pelo apoio em muitos pequenos embara\u00e7os do cotidiano. \n\nEspecialmente ao meu orientador, professor Carlos Becker Westphall, que me \n\nacolheu em um momento bastante conturbado do curso e incentivou-me a concluir esse \n\ntrabalho. \n\nA professora Carla Merkle Westphall e Cleverson Alessandro Veronez, membros \n\nda banca do meu Trabalho Individual, pelas observa\u00e7\u00f5es e apontamentos inestim\u00e1veis \n\npara a conclus\u00e3o deste trabalho. \n\nAos colegas da p\u00f3s-gradua\u00e7\u00e3o Wagner Tatsuya Watanabe e Luis Marco C\u00e1ceres \n\nAlvarez, por mostrarem-se em in\u00fameras ocasi\u00f5es n\u00e3o apenas colegas, mas verdadeiros \n\namigos. \n\nAo meu colega de gradua\u00e7\u00e3o e amigo Jefferson Gustavo Martins, por suportar-me \n\ncomo \u201dh\u00f3spede regular\u201d do seu apartamento em Florian\u00f3polis. \n\nAo amigo e confidente de muitas horas Ivonei Freitas da Silva, pelos muitos \n\n\u201cconselhos\u201d e direcionamentos. \n\n\n\nvi \n\nAo grande amigo professor Ivanor Luis Guarnieri, pela contagiante sede de \n\nconhecimento, sem d\u00favida um inspirador e escasso modelo de intelectual. \n\nAos bons professores do curso de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o da \n\nUFSC, por constitu\u00edrem um verdadeiro modelo de profissional que sempre tento (e \n\ntentarei) imitar em minha atua\u00e7\u00e3o di\u00e1ria. Aprendi muito com voc\u00eas nesse curto espa\u00e7o \n\nde tempo e algumas empolgantes aulas ficaram registradas firmemente em minha \n\nmem\u00f3ria. \n\nA Vera L\u00facia Sodr\u00e9 Teixeira, a Verinha, secret\u00e1ria da P\u00f3s-Gradua\u00e7\u00e3o, pela sua \n\nsimpatia e aten\u00e7\u00e3o habituais. \n\n \n\n \n\n\n\nvii \n\nRESUMO \n\nXML (eXtensible Markup Language) apresenta como principais caracter\u00edsticas a \n\ndistin\u00e7\u00e3o entre interface, processos e dados; provendo flexibiliza\u00e7\u00e3o no interc\u00e2mbio de \n\ndados; customiza\u00e7\u00e3o de linguagens de marca\u00e7\u00e3o; autodescri\u00e7\u00e3o de dados, estrutura\u00e7\u00e3o e \n\nintegra\u00e7\u00e3o dos dados. Essa dissocia\u00e7\u00e3o entre a estrutura da apresenta\u00e7\u00e3o e o conte\u00fado \n\ndo documento, permite que um mesmo documento possa ser apresentado em diferentes \n\nformatos. \n\nRecentemente, o emprego de XML para definir modelos de informa\u00e7\u00e3o de \n\ngerenciamento e processar informa\u00e7\u00e3o nas aplica\u00e7\u00f5es de ger\u00eancia vem se tornando \n\natrativo. \n\nNesse contexto, este trabalho apresenta uma aplica\u00e7\u00e3o de XML no modelo de \n\ngerenciamento SNMP, como forma de produzir documentos de informa\u00e7\u00e3o de ger\u00eancia \n\nque sejam estruturados, consistentes, autodescritivos e possam ser facilmente \n\napresentados em formatos diversos, podendo tamb\u00e9m alimentar outros sistemas de \n\ninforma\u00e7\u00e3o. \n\n \n\n \n\n\n\nviii \n\nABSTRACT \n\nXML (eXtensible Markup Language) presents as main characteristics the \n\ndistinction between interface, processes and data; providing flexibility on data \n\ninterchange; customization of marking languages; self-describle of data, structuration \n\nand integration of the data. This disjoin between the structure of the presentation and \n\nthe content of the document, allows that one exactly document can be presented in \n\ndifferent formats.  \n\nRecently, the qpplication of XML to define models of management information \n\nand to process information in the management applications is becomes attractive. \n\nIn this context, this work presents the application of XML in SNMP management \n\nmodel, for produce management information documents structuralized, consistents, self-\n\ndescrible and can easily be showed in diverse formats, also being able to feed other \n\ninformation systems.  \n\n \n\n \n\n\n\nix \n\nSUM\u00c1RIO \n1. INTRODU\u00c7\u00c3O ........................................................................................................................................................ 1 \n\n1.1 OBJETIVOS ................................................................................................................................................................ 5 \n1.1.1 Objetivo Geral ........................................................................................................................................................ 5 \n\n1.1.2 Objetivos Espec\u00edficos ......................................................................................................................................... 6 \n1.2 TRABALHOS CORRELATOS............................................................................................................................................. 6 \n1.3 ESTRUTURA\u00c7\u00c3O DO TRABALHO .................................................................................................................................... 7 \n\n2. VIS\u00c3O GERAL DE XML ....................................................................................................................................... 9 \n2.1 INTRODU\u00c7\u00c3O: MARCA\u00c7\u00c3O ............................................................................................................................................ 9 \n\n2.1.1 Marca\u00e7\u00e3o procedimental........................................................................................................................................ 9 \n2.1.2 Codifica\u00e7\u00e3o Gen\u00e9rica........................................................................................................................................... 11 \n\n2.2 SGML........................................................................................................................................................................... 12 \n2.3 HTML .......................................................................................................................................................................... 13 \n2.4 XML............................................................................................................................................................................. 15 \n\n2.4.1 Origens ................................................................................................................................................................. 16 \n2.4.2 Defini\u00e7\u00e3o de XML................................................................................................................................................. 16 \n2.4.3 Facilidades XML .................................................................................................................................................. 17 \n2.4.4 Estrutura de Documentos XML ............................................................................................................................ 19 \n2.4.4 Documentos XML bem formados ......................................................................................................................... 23 \n2.4.5 Documentos XML V\u00e1lidos .................................................................................................................................... 24 \n2.4.6 Esquemas XML ..................................................................................................................................................... 24 \n\n2.4.6.1 DTD ............................................................................................................................................................... 25 \n2.4.6.1.1 Declara\u00e7\u00f5es de Elemento ....................................................................................................................... 26 \n2.4.6.1.2 Declara\u00e7\u00e3o de Atributos ......................................................................................................................... 29 \n2.4.6.1.3 Declara\u00e7\u00e3o de Tipo de Documento ........................................................................................................ 30 \n2.4.6.1.4 DTD interna e externa ............................................................................................................................ 30 \n\n2.4.6.2 XML Schema ................................................................................................................................................. 30 \n2.4.7 Folhas de Estilo em XML ..................................................................................................................................... 31 \n\n2.4.7.1 CSS ................................................................................................................................................................ 33 \n2.4.7.2 XSL................................................................................................................................................................ 35 \n\n2.4.8 Xlinks e Xpointers ................................................................................................................................................. 39 \n2.4.9 An\u00e1lise de Dados XML:SAX e DOM.................................................................................................................... 41 \n2.4.10 Consulta a Documentos XML com XPath.......................................................................................................... 43 \n2.4.11 Padr\u00f5es de Mercado Oriundos de XML ............................................................................................................ 43 \n\n3. LINGUAGEM JAVA............................................................................................................................................. 46 \n3.1 ORIGENS ....................................................................................................................................................................... 46 \n3.2 CARACTER\u00cdSTICAS ....................................................................................................................................................... 47 \n\n3.2.1 Simples .................................................................................................................................................................. 47 \n3.2.2 Orientada a Objetos ............................................................................................................................................. 48 \n3.2.3 Interpretada e Independente de Plataforma ........................................................................................................ 49 \n3.2.4 Robusta ................................................................................................................................................................. 50 \n3.2.5 Din\u00e2mica............................................................................................................................................................... 51 \n3.2.6 Segura ................................................................................................................................................................... 51 \n3.2.7 Multi-linha (multithreaded).................................................................................................................................. 52 \n\n3.3 CONSIDERA\u00c7\u00d5ES FINAIS DO CAP\u00cdTULO ....................................................................................................................... 52 \n4. OBJETOS DISTRIBU\u00cdDOS E A ARQUITETURA CORBA ............................................................................ 53 \n\n4.1 OBJETOS  DISTRIBU\u00cdDOS .............................................................................................................................................. 53 \n4.2 A Arquitetura CORBA ............................................................................................................................................. 54 \n4.3 Modelo de objetos CORBA...................................................................................................................................... 56 \n4.1.1 Sem\u00e2ntica dos Objetos do CORBA ...................................................................................................................... 57 \n\n4.1.1.1 Objeto ............................................................................................................................................................ 57 \n4.1.1.2 Requisi\u00e7\u00e3o ..................................................................................................................................................... 57 \n4.1.1.3 Refer\u00eancia a objeto ........................................................................................................................................ 58 \n4.1.1.4 Cria\u00e7\u00e3o e destrui\u00e7\u00e3o de objetos ..................................................................................................................... 58 \n4.1.1.5 Tipos .............................................................................................................................................................. 58 \n4.1.1.6 Interface ......................................................................................................................................................... 60 \n4.1.1.7 Opera\u00e7\u00e3o ........................................................................................................................................................ 60 \n4.1.1.8 Atributos ........................................................................................................................................................ 61 \n\n4.1.2 Implementa\u00e7\u00e3o de Objetos no CORBA ................................................................................................................ 61 \n4.1.2.1 Modelo de execu\u00e7\u00e3o ...................................................................................................................................... 62 \n4.1.2.2 Modelo de Constru\u00e7\u00e3o................................................................................................................................... 62 \n\n4.2 ORB.......................................................................................................................................................................... 62 \n4.2.1 IDL (Interface Definition Language) ................................................................................................................... 63 \n4.2.2 Servi\u00e7os................................................................................................................................................................. 65 \n\n\n\nx \n\n4.2.2 Estrutura do ORB ................................................................................................................................................. 67 \n4.2.3 Interoperabilidade entre ORBs ............................................................................................................................ 70 \n\n4.3 SERVI\u00c7OS CORBA....................................................................................................................................................... 72 \n5 A API ADVENTSNMP E O PROTOCOLO SNMP ............................................................................................ 74 \n\n5.1 DIFERENTES VERS\u00d5ES DO SNMP ................................................................................................................................ 74 \n5.2 PANORAMA HIST\u00d3RICO................................................................................................................................................ 75 \n5.3 VANTAGENS PROPICIADAS PELO SNMP...................................................................................................................... 76 \n5.4 COMPONENTES B\u00c1SICOS DO SNMP ............................................................................................................................. 77 \n\n5.4.1 Dispositivo de Rede .............................................................................................................................................. 78 \n5.4.2 Agente ................................................................................................................................................................... 78 \n5.4.3 Gerente ................................................................................................................................................................. 79 \n5.4.4 Comunica\u00e7\u00e3o entre o Gerente e o Agente............................................................................................................ 79 \n5.4.5 Estrutura ............................................................................................................................................................... 81 \n\n5.4.5.1 Management Information Base (MIB) .......................................................................................................... 81 \n5.4.5.1.1 MIB OSI ................................................................................................................................................. 82 \n5.4.5.1.2 MIB Internet ........................................................................................................................................... 83 \n\n5.4.5.2 OID ................................................................................................................................................................ 87 \n5.4.5.3 SMI e vers\u00f5es SMI ........................................................................................................................................ 88 \n5.4.5.4 SMI Data Types............................................................................................................................................. 88 \n5.4.5.5 Tipos de Dados MIB SMIv1 ......................................................................................................................... 89 \n5.4.5.6 Tipos de Dados MIB SMIv2 ......................................................................................................................... 91 \n\n5.4.6 Opera\u00e7\u00f5es SNMP B\u00e1sicas .................................................................................................................................... 92 \n5.4.6.1 Recupera\u00e7\u00e3o de Dados .................................................................................................................................. 92 \n5.4.6.2 Altera\u00e7\u00e3o de Vari\u00e1veis .................................................................................................................................. 93 \n5.4.6.3 Recebimento de Mensagens N\u00e3o Solicitadas................................................................................................ 93 \n\n5.4.7 Formato das Mensagens SNMP ........................................................................................................................... 93 \n6. DOM\u00cdNIO DA APLICA\u00c7\u00c3O ............................................................................................................................... 96 \n\n6.1 FERRAMENTAS UTILIZADAS ........................................................................................................................................ 98 \n6.2 VARI\u00c1VEIS MONITORADAS.......................................................................................................................................... 99 \n6.3 ARQUITETURA DA APLICA\u00c7\u00c3O DE COLETA DE DADOS GERENCIAIS ........................................................................ 100 \n6.4 ARQUITETURA DO AMBIENTE HIPOT\u00c9TICO UTILIZANDO CORBA............................................................................. 103 \n\n7. CONCLUS\u00d5ES .................................................................................................................................................... 104 \n7.1 CONCLUS\u00c3O ............................................................................................................................................................... 104 \n7.2 TRABALHOS FUTUROS ............................................................................................................................................... 106 \n\nREFER\u00caNCIAS BIBLIOGR\u00c1FICAS ................................................................................................................... 107 \nANEXO A \u2013 C\u00d3DIGO-FONTE JAVA .................................................................................................................. 113 \nANEXO B \u2013 DOCUMENTO XML GERADO PELA APLICA\u00c7\u00c3O .................................................................. 118 \nANEXO C \u2013 XMLSCHEMA COM A ESTRUTURA DO DOCUMENTO XML COLETADO....................... 119 \n\n \n \n\n\n\nxi \n\n \n\nLISTA DE FIGURAS \n \n\nFIGURA 2.1A \u2013 DOCUMENTO FORMATADO EM RTF ................................................................................................................................ 10 \nFIGURA 2.1B \u2013 APRESENTA\u00c7\u00c3O DE DOCUMENTO RTF NO MS-WORD2000 .............................................................................................. 10 \nFIGURA 2.2A \u2013 DOCUMENTO CODIFICADO EM HTML ............................................................................................................................ 13 \nFIGURA 2.2B \u2013 APRESENTA\u00c7\u00c3O DE DOCUMENTO NO MS-INTERNET EXPLORER 6 .................................................................................. 14 \nFIGURA 2.3 \u2013 UM DOCUMENTO XML SIMPLES........................................................................................................................................ 20 \nFIGURA 2.4 \u2013 ESTRUTURA DE UM DOCUMENTO XML............................................................................................................................. 21 \nFIGURA 2.5 \u2013 DIAGRAMA EM \u00c1RVORE DE UM DOCUMENTO XML ......................................................................................................... 23 \nFIGURA 2.6 \u2013 EMPREGO DE INDICADORES DE OCORR\u00caNCIA DTD .......................................................................................................... 28 \nFIGURA 2.7 \u2013 EMPREGO DE CONECTORES DTD....................................................................................................................................... 29 \nFIGURA 2.8 \u2013 DOCUMENTO XML SERTOES.XML ...................................................................................................................................... 32 \nFIGURA 2.9 \u2013 BROWSER MS-INTERNET EXPLORER APRESENTANDO UM DOCUMENTO XML SEM FOLHA DE ESTILO ASSOCIADA......... 33 \nFIGURA 2.10 \u2013 FOLHA DE ESTILO ESTILO.CSS PARA O DOCUMENTO SERTOES.XML .................................................................................. 34 \nFIGURA 2.11 \u2013 LIGA\u00c7\u00c3O DA FOLHA DE ESTILO ESTILO.CSS COM O DOCUMENTO XML SERTOES.XML .................................................... 35 \nFIGURA 2.12 \u2013 BROWSER MS-INTERNET EXPLORER APRESENTANDO DOCUMENTO XML FORMATADO POR FOLHA DE ESTILO CSS ...... 35 \nFIGURA 2.13 \u2013 INTERA\u00c7\u00c3O DO DOCUMENTO XML COM AS FOLHAS DE ESTILO XSL ............................................................................ 37 \nFIGURA 2.14 \u2013 UM DOCUMENTO XML E SEQ\u00dc\u00caNCIA DE EVENTOS SAX ............................................................................................... 42 \nFIGURA 3.1 \u2013 ESQUEMA DE COMPILA\u00c7\u00c3O JAVA ..................................................................................................................................... 50 \nFIGURA 4.1 \u2013 ARQUITETURA DE GERENCIAMENTO DE OBJETOS (OMA). .............................................................................................. 55 \nFIGURA 4.2 \u2013 TIPOS DO MODELO DE OBJETOS CORBA........................................................................................................................... 59 \nFIGURA 4.3 \u2013 CLIENTE ENVIANDO REQUISI\u00c7\u00c3O ATRAV\u00c9S DO ORB........................................................................................................ 63 \nFIGURA 4.4 \u2013 IDL PROV\u00ca INDEPEND\u00caNCIA DE LINGUAGEM DE PROGRAMA\u00c7\u00c3O ENTRE OS OBJETOS. .................................................... 64 \nFIGURA 4.5 \u2013 ESTRUTURA B\u00c1SICA DE UM ORB. ..................................................................................................................................... 68 \nFIGURA 4.6 \u2013 RELACIONAMENTOS DE PROTOCOLOS ENTRE ORBS......................................................................................................... 72 \nFIGURA 5.1 \u2013 COMPONENTES B\u00c1SICOS DO MODELO SNMP ..................................................................................................................... 78 \nFIGURA 5.2 \u2013 CONFIGURA\u00c7\u00c3O DE UM AGENTE PROXY ............................................................................................................................ 81 \nFIGURA 5.3 \u2013 FRAGMENTO DA ESTRUTURA DE UMA MIB....................................................................................................................... 85 \nFIGURA 5.4 \u2013 FORMATO DAS PDUS SNMP ............................................................................................................................................. 94 \nFIGURA 6.1 \u2013 PONTOS DE PRESEN\u00c7A DA INTRANET PARAN\u00c1 ........................................................................................................... 97 \nFIGURA 6.2 \u2013 ROTEADOR MONITORADO ................................................................................................................................................. 98 \nFIGURA 6.3 \u2013 ARQUITETURA DA APLICA\u00c7\u00c3O DE COLETA DE DADOS GERENCIAIS.............................................................................. 101 \nFIGURA 6.4 \u2013 INTERFACE PRINCIPAL DA APLICA\u00c7\u00c3O DE COLETA DE DADOS ...................................................................................... 102 \nFIGURA 6.5 \u2013 MODELO L\u00d3GICO DO AMBIENTE APLICANDO CORBA .................................................................................................. 103 \n \n\n \n\n \n\n \n\n\n\nxii \n\nLISTA DE TABELAS \nTABELA 4.1 \u2013 SERVI\u00c7OS CORBA............................................................................................................................................................ 66 \nTABELA 5.1 \u2013  GRUPOS DA MIB-II .......................................................................................................................................................... 86 \nTABELA 5.2 \u2013 TIPOS DE DADOS SMI ....................................................................................................................................................... 89 \nTABELA 5.3 \u2013 DESCRI\u00c7\u00c3O DOS CAMPOS DA PDU SNMP ....................................................................................................................... 94 \n \n\n \n\n \n\n\n\nxiii \n\nLISTA DE ACR\u00d4NIMOS \n\nASCII \u2013 American Standard Code for Information Interchange \n\nASN.1 \u2013 Abstract Syntax Notation .1 \n\nASP \u2013 Active Server Pages \n\nCERN \u2013 Centro \n\nCGI \u2013 Common Gateway Interface \n\nCMIP \u2013 Commom Management Information Protocol \n\nCORBA \u2013 Commom Obeject Request Broker Architecture \n\nCSS \u2013 Cascading Style Sheets \n\nDoD \u2013 Department of Defense \n\nDOM \u2013 Document Object Model \n\nDII \u2013 Dynamic Invocation Interface \n\nDSI \u2013 Dynamic Skeleton Interface \n\nDSSSL \u2013 Document Style Semantics and Specification Language \n\nDTD \u2013 Document Type Definition \n\nESIOP  Environment-Specific Inter-ORB Protocol \n\nEWS  Embedded Web Server \n\nGI \u2013 Generic Identifier \n\nGIOP \u2013 Generic Inter-ORB Protocol \n\nHTML \u2013 Hyper Text Markup Language \n\nIAB \u2013 Internet Activities Board \n\nIBM \u2013 International Business Machines \n\nIDL \u2013 Interface Definition Language \n\nIEEE \u2013 Institute of Electical and Electronics Engineers \n\nIIOP \u2013 Internet Inter-ORB Protocol \n\n\n\nxiv \n\nINRIA \u2013 Instituit National de Recherche em Informatique et em Automatique \n\nIP \u2013 Internet Protocol \n\nISO \u2013 International Organization for Standardization \n\nJIT \u2013 Just In-Time \n\nMIB \u2013 Management Information Base \n\nMIT \u2013 Massachussets Institut Of Technology \n\nMS \u2013 Microsoft Corporation \n\nOID \u2013 Object Identifier \n\nOMG \u2013 Object Management Group \n\nORB \u2013 Object Request Broker \n\nOSF \u2013 Open Software Foundation \n\nOSI \u2013 Open Systems Interconection \n\nPDU \u2013 Protocol Data Unit \n\nPOA \u2013 Portable Object Adapter \n\nPI \u2013 Processing Instructions  \n\nRFC \u2013 Request For Comments \n\nRTF \u2013 Rich Text Format \n\nSAX \u2013 Simple Application programming interface for Xml \n\nSNMP \u2013 Simple Network Management Protocol \n\nSGML \u2013 Standard Generalized Markup Language \n\nTCP \u2013 Transmission Control Protocol \n\nUDP \u2013 User Datagram Protocol \n\nUFSC \u2013 Universidade Federal de Santa Catarina \n\nUNIOES\nTE \n\n\u2013 Universidade Estadual do Oeste do Paran\u00e1 \n\nW3C \u2013 World Wide Web Consortium \n\n\n\nxv \n\nWWW \u2013 World Wide Web \n\nXML \u2013 Extensible Markup Language \n\nXSL \u2013 Extensible Style Language \n\nXSL \u2013 XSL Transformations \n\n \n\n \n\n \n\n \n\n\n\n1. Introdu\u00e7\u00e3o \n\nAs redes de computadores foram inicialmente concebidas como um meio de \n\ncompartilhar dispositivos e perif\u00e9ricos mais dispendiosos como impressoras laser, \n\nmodems velozes e outros. Contudo, os benef\u00edcios proporcionados por estas redes \n\nestimularam uma expans\u00e3o crescente, e ainda cont\u00ednua, das mesmas nos mais diversos \n\nsegmentos da atividade humana, relegando assim o seu objetivo inicial (o simples \n\ncompartilhamento de dispositivos) a um plano de import\u00e2ncia secund\u00e1ria. Essa \n\nexpans\u00e3o demanda manuten\u00e7\u00e3o e planejamento futuro, a denominada ger\u00eancia de redes. \n\nO gerenciamento de redes de computadores tem como objetivos controlar, \n\nadministrar e monitorar eficientemente os recursos de hardware e software em um \n\nambiente computacionalmente distribu\u00eddo. N\u00e3o se consegue gerenciar uma rede com \n\nesfor\u00e7os humanos isolados. A complexidade de uma rede, devido \u00e0 quantidade e \n\nheterogeneidade de equipamentos e fornecedores, exige o uso de automa\u00e7\u00e3o no \n\ngerenciamento de rede [STALLINGS 00]. A velocidade com que o estado da rede varia, \n\na necessidade de const\u00e2ncia no monitoramento e a necessidade de executar a\u00e7\u00f5es de \n\ncontrole e manuten\u00e7\u00e3o implicam na utiliza\u00e7\u00e3o de um sistema computacional din\u00e2mico \n\nde supervis\u00e3o, as chamadas aplica\u00e7\u00f5es de ger\u00eancia. Tais aplica\u00e7\u00f5es requerem interfaces \n\npadronizadas para trocar informa\u00e7\u00e3o entre os sistemas de gerenciamento, possuindo \n\ncapacidade de extens\u00e3o para tratar mudan\u00e7as de forma r\u00e1pida e fornecimento de meios \n\npara o gerenciamento de grandes redes [HAGGERTY 98].  \n\nMais recentemente, a Internet expandiu-se, extrapolando os dom\u00ednios de \n\naplica\u00e7\u00f5es acad\u00eamicas, militares e de pesquisa para inserir-se no \u00e2mbito \n\ncomercial/corporativo e at\u00e9 mesmo dom\u00e9stico. Considerando a dissemina\u00e7\u00e3o das redes \n\ne da Internet, constata-se que \u00e9 cada vez mais freq\u00fcente a utiliza\u00e7\u00e3o de aplica\u00e7\u00f5es sobre \n\na arquitetura TCP/IP pela grande maioria dos usu\u00e1rios de tais redes. Nesse aspecto, \n\nsistemas de informa\u00e7\u00e3o est\u00e3o se integrando com servidores Web1 com o objetivo de \n\ntransformar consultas realizadas por usu\u00e1rios em resultados a serem exibidos em \n\nbrowsers Web [DEROSE 99], [GRAHAM 00]. Assim, a Internet, notadamente a Web, \n                                                                  \n\n1 Software de servidor que utiliza o protocolo HTTP para fornecer documentos HTML e quaisquer \narquivos e scripts associados quando solicitados por uma aplica\u00e7\u00e3o cliente, como um browser Web. A \nconex\u00e3o entre o cliente e o servidor \u00e9 geralmente rompida ap\u00f3s o fornecimento do documento ou arquivo \nsolicitado. Os servidores HTTP s\u00e3o usados em sites da Web e de intranets. \n\n\n\n 2\n\nest\u00e1 se configurando numa infra-estrutura para distribui\u00e7\u00e3o de informa\u00e7\u00e3o essencial para \n\nqualquer organiza\u00e7\u00e3o [THOMPSON 98] [BERG 99]. E uma das possibilidades \n\nproporcionadas pela Web \u00e9 o acesso e tratamento de informa\u00e7\u00f5es de gerenciamento de \n\nredes [BARILLAUD 97]. \n\nTodavia, as pessoas e organiza\u00e7\u00f5es que disponibilizam informa\u00e7\u00f5es na rede \n\nestruturam essas informa\u00e7\u00f5es de maneiras particulares. Estrutura\u00e7\u00f5es distintas da \n\ninforma\u00e7\u00e3o n\u00e3o causam problemas enquanto tais informa\u00e7\u00f5es s\u00e3o empregadas de forma \n\nisolada, pelo indiv\u00edduo ou organiza\u00e7\u00e3o que as gerou. Por\u00e9m, na medida em que a \n\ninforma\u00e7\u00e3o precisa ser compartilhada com outras pessoas ou organiza\u00e7\u00f5es, a car\u00eancia de \n\numa estrutura padronizada acarreta empecilhos, principalmente a incompatibilidade \n\nentre o sistema receptor e o sistema emissor da informa\u00e7\u00e3o.  \n\nSomando-se a essa consider\u00e1vel dissemina\u00e7\u00e3o de microcomputadores e esta\u00e7\u00f5es \n\nde trabalho, o aumento nas suas capacidades de processamento, e o surgimento de redes \n\nde comunica\u00e7\u00e3o com grande largura de banda, nota-se o desenvolvimento cada vez \n\nmaior de aplica\u00e7\u00f5es distribu\u00eddas. A import\u00e2ncia de sistemas distribu\u00eddos tamb\u00e9m tem \n\ncrescido devido, principalmente, as tend\u00eancias organizacionais tais como downsizing2, \n\nque demandam o interc\u00e2mbio de informa\u00e7\u00e3o dentro da pr\u00f3pria organiza\u00e7\u00e3o e entre \n\norganiza\u00e7\u00f5es cooperantes.  \n\nOs sistemas distribu\u00eddos apresentam vantagens advindas da distribui\u00e7\u00e3o tais como \n\ndisponibilidade, desempenho, otimiza\u00e7\u00e3o de custos, dentre outras. Entretanto, \n\napresentam tamb\u00e9m as caracter\u00edsticas de afastamento, concorr\u00eancia, falta de estado \n\nglobal, ocorr\u00eancia de falhas parciais, assincronismo, heterogeneidade, autonomia, \n\nevolu\u00e7\u00e3o e mobilidade [ISO 95]. \n\nDiversos modelos e arquiteturas distribu\u00eddas t\u00eam sido propostos, oferecendo \n\nconceitos e implementa\u00e7\u00f5es que auxiliam no tratamento das caracter\u00edsticas de \n\ndistribui\u00e7\u00e3o citadas anteriormente. Notadamente a caracter\u00edstica de heterogeneidade \n\nimp\u00f5e a necessidade de especifica\u00e7\u00f5es abertas, com interfaces padronizadas e p\u00fablicas, \n\nlevando ao desenvolvimento de middlewares abertos. De modo geral, um middleware \n\n                                                                  \n2 \u00c9 a migra\u00e7\u00e3o de sistemas de grande porte/centralizados (mainframe) para a computa\u00e7\u00e3o distribu\u00edda, \nredes no esquema Cliente/Servidor, ou seu gerenciamento (j\u00e1 n\u00e3o possuem servidor) \n\n\n\n 3\n\npode ser definido como sendo uma camada de software, residente acima do sistema \n\noperacional e do substrato de comunica\u00e7\u00e3o, que oferece abstra\u00e7\u00f5es de alto n\u00edvel, com \n\nobjetivo de facilitar a codifica\u00e7\u00e3o de aplica\u00e7\u00f5es distribu\u00eddas. As abstra\u00e7\u00f5es \n\ndisponibilizadas fornecem uma vis\u00e3o uniforme na utiliza\u00e7\u00e3o de recursos heterog\u00eaneos \n\nexistentes nas camadas de sistema operacional e redes. \n\nO conceito de sistemas abertos aborda um significante leque de tecnologias e \n\nespecifica\u00e7\u00f5es, envolvendo a quest\u00e3o de interoperabilidade de uma variedade de \n\nsistemas baseados em padr\u00f5es formais ou de fato. De forma diversa dos ambientes \n\npropriet\u00e1rios, os ambientes de sistemas abertos permitem aos usu\u00e1rios optarem dentre \n\num vasto grupo de computadores e tecnologias, quais se adequam \u00e0s suas necessidades. \n\nEsses sistemas oferecem tamb\u00e9m uma crescente interoperabilidade, escalabilidade e \n\nportabilidade, permitindo sistemas distintos conviverem juntos, e o software \n\nimplementado em uma plataforma espec\u00edfica ser executado em outra com m\u00ednimas \n\nadapta\u00e7\u00f5es. \n\nApesar de in\u00fameras vantagens na sua utiliza\u00e7\u00e3o, o advento de sistemas abertos \n\ntorna mais complexo o processo de desenvolvimento de novas tecnologias e ades\u00e3o \u00e0s \n\nespecifica\u00e7\u00f5es abertas. A solu\u00e7\u00e3o dessa problem\u00e1tica, preservando as vantagens da \n\ncomputa\u00e7\u00e3o heterog\u00eanea, tem levado ao surgimento de diversas organiza\u00e7\u00f5es e \n\ncons\u00f3rcios tais como OMG (Object Management Group)3, X/OPEN4 e OSF (Open \n\nSoftware Foundation)5. \n\nA organiza\u00e7\u00e3o OMG estabeleceu a arquitetura CORBA (Common Object Request \n\nBroker Architecture) [OMG 01] como uma forma de especificar um middleware aberto \n\ncomposto de objetos distribu\u00eddos. CORBA define um tipo de \"barramento de software\" \n\npermitindo que componentes de software sejam acoplados, formando um sistema coeso. \n\nOs conceitos utilizados nos componentes de software s\u00e3o similares aos dos \n\ncomponentes de hardware, e s\u00e3o implementados na arquitetura CORBA atrav\u00e9s do \n\nparadigma da orienta\u00e7\u00e3o a objetos. \n\n                                                                  \n3 www.omg.org \n4 www.opengroup.org \n5 www.osf.org \n\n\n\n 4\n\nNessa conjuntura, CORBA j\u00e1 vem sendo utilizada sobre a infraestrutura Web \n\n[BARILLAUD 97] como uma ferramenta para permitir a implementa\u00e7\u00e3o de um sistema \n\nde gerenciamento de rede distribu\u00eddo [BAROTTO 98], [BAROTTO 00] entre as \n\nm\u00e1quinas que comp\u00f5em a rede, independente de plataforma e com mecanismo de \n\ninstala\u00e7\u00e3o autom\u00e1tica, visto que estar\u00e1 dispon\u00edvel atrav\u00e9s de browsers Web. \n\nNeste trabalho, \u00e9 discutida a ado\u00e7\u00e3o da tecnologia XML (eXtensible Markup \n\nLanguage), especificamente em sistemas de gerenciamento de redes, propondo uma \n\nflexibiliza\u00e7\u00e3o e estrutura\u00e7\u00e3o no interc\u00e2mbio de informa\u00e7\u00f5es gerenciais. XML \u00e9 uma \n\nmetalinguagem que possibilita a defini\u00e7\u00e3o de linguagens de marca\u00e7\u00e3o personalizadas, \n\npermitindo a especifica\u00e7\u00e3o da sintaxe e a valida\u00e7\u00e3o de documentos nessa linguagem \n\npersonalizada [CASTRO 01], chamada aplica\u00e7\u00e3o XML. A abordagem de XML, com \n\nclara separa\u00e7\u00e3o entre os dados, a estrutura e a maneira como ser\u00e3o apresentados tais \n\ndados, permite que sejam implementados programas que extraiam dados de documentos \n\nXML, transforme-os, unifique-os a outras fontes e disponibilize-os para apresenta\u00e7\u00e3o \n\nem v\u00e1rios formatos distintos. \n\nAs caracter\u00edsticas de XML tornam-na uma ferramenta ideal para representar \n\ndados, apoiando na defini\u00e7\u00e3o de um modelo de conte\u00fado padronizado, em uma \n\nplataforma aberta, independente de fabricantes e em uma linguagem neutra [JU 02]. \n\nFocando a ger\u00eancia de redes, o emprego de XML para definir modelos de \n\ninforma\u00e7\u00e3o de gerenciamento e processar informa\u00e7\u00e3o nas aplica\u00e7\u00f5es de ger\u00eancia vem se \n\ntornando atrativo [LEWIS 01]. Nesse aspecto, XML e suas tecnologias correlatas \n\napresentam vantagens como [MARTIN-FLATIN 00]: \n\n\u2022 melhor integra\u00e7\u00e3o dos dados gerenciados \n\n\u2022 liga\u00e7\u00e3o mais flex\u00edvel entre o objeto gerenciado e aplica\u00e7\u00e3o gerente; \n\n\u2022 interoperabilidade entre aplica\u00e7\u00f5es de gerenciamento de diferentes \n\nfabricantes; \n\n\u2022 apresenta\u00e7\u00e3o das informa\u00e7\u00f5es gerenciais facilidade e estendida para uma \n\nampla variedade de formatos; \n\n\n\n 5\n\n\u2022 possibilidade de transforma\u00e7\u00e3o autom\u00e1tica das informa\u00e7\u00f5es de \n\ngerenciamento originais, agregando valor decis\u00f3rio nas novas informa\u00e7\u00f5es \n\nproduzidas; \n\n\u2022 valida\u00e7\u00e3o dos dados de gerenciamento autom\u00e1tica e centralizada. \n\nPara demonstrar a possibilidade do uso de XML na ger\u00eancia de redes, ser\u00e1 \n\nconsiderado um ambiente de rede existente na Unioeste (Universidade Estadual do \n\nOeste do Paran\u00e1), Paran\u00e1. Para tanto, ser\u00e1 implementado um aplicativo de \n\ngerenciamento que extraia informa\u00e7\u00f5es gerenciais de um dispositivo de rede dotado de \n\nagente SNMP. O aplicativo deve comunicar-se com o agente SNMP do dispositivo \n\natrav\u00e9s de consultas SNMP e gerar documentos XML a partir das respostas recebidas. \n\nTais documentos poder\u00e3o ser processados por ferramentas XML para serem \n\nexportados/apresentados em diferentes formatos. \n\nTamb\u00e9m, pretende-se sugerir um modelo para unir a arquitetura CORBA, o \n\npadr\u00e3o de gerenciamento SNMP e as tecnologias XML. \n\n1.1 Objetivos \n\nNessa se\u00e7\u00e3o ser\u00e3o apresentados os objetivos que este trabalho pretende atingir. \n\n1.1.1 Objetivo Geral \n\nO objetivo geral deste trabalho \u00e9 apresentar um estudo da aplica\u00e7\u00e3o de tecnologias \n\nde distribui\u00e7\u00e3o e interopera\u00e7\u00e3o de sistemas utilizando XML para apresenta\u00e7\u00e3o de \n\ninforma\u00e7\u00f5es gerenciais em browsers Web. Para proporcionar o estudo ser\u00e1 \n\nimplementado um prot\u00f3tipo de um sistema distribu\u00eddo destinado ao gerenciamento de \n\ndispositivos conectados em um ambiente de rede operando sob a arquitetura TCP/IP. \n\nTal sistema de gerenciamento deve suportar o protocolo de ger\u00eancia SNMP e estruturar-\n\nse de maneira distribu\u00edda. Tamb\u00e9m ser\u00e1 proposto um modelo de arquitetura que se ap\u00f3ie \n\n\n\n 6\n\nno modelo CORBA/IIOP para prover objetos distribu\u00eddos e agentes de ger\u00eancia \n\nmultiplataforma. \n\n1.1.2 Objetivos Espec\u00edficos \n\nA fim de atingir a meta descrita no objetivo geral, foram estipulados os seguintes \n\nobjetivos espec\u00edficos: \n\n Estudo dos principais padr\u00f5es e ferramentas relacionados com a tecnologia \n\nWeb, enfocando a integra\u00e7\u00e3o de SNMP e CORBA com tal tecnologia para \n\nprover um ambiente de gerenciamento de redes de computadores acess\u00edvel via \n\nWeb; \n\n implementa\u00e7\u00e3o de uma aplica\u00e7\u00e3o que extraia informa\u00e7\u00f5es das MIBs, \n\nutilizando o protocolo SNMP e gere documentos XML; \n\n implementa\u00e7\u00e3o de um prot\u00f3tipo que demonstre a manipula\u00e7\u00e3o dos \n\ndocumentos XML, construindo p\u00e1ginas XML que possam ser visualizadas \n\npelos administradores de rede em browsers Web compat\u00edveis com XML, \n\npossibilitando um acesso remoto \u00e0s informa\u00e7\u00f5es de ger\u00eancia filtradas, \n\nsumarizadas e tratadas; \n\n teste e avalia\u00e7\u00e3o dos resultados obtidos, estabelecendo um panorama de \n\nperspectivas futuras para aplica\u00e7\u00e3o integrada das tecnologias SNMP, XML e \n\nCORBA para prover gerenciamento distribu\u00eddo de redes. \n\n1.2 Trabalhos Correlatos \n\nEm [BAROTTO 98] e [BAROTTO 00] \u00e9 apresentada a implementa\u00e7\u00e3o de um \n\nsistema distribu\u00eddo de gerenciamento aplicado a um cluster6 de esta\u00e7\u00f5es de alta \n\nperformance existente na UFSC (Universidade Federal de Santa Catarina). Tal sistema \n\n                                                                  \n6 conjunto de esta\u00e7\u00f5es \n\n\n\n 7\n\nopera sobre os protocolos SNMP e IIOP/CORBA, utilizando browsers Web como \n\ninterface com o usu\u00e1rio final. \n\nUma nova arquitetura de gerenciamento \u00e9 apresentada em [JU 02], combinando \n\nEWS (Embedded Web Server) com XML, DOM (Document Object Model) e XPath \n\npara unificar elementos gerenciados com o gerenciamento de redes. A tecnologia XML \n\n\u00e9 usada para modelar a informa\u00e7\u00e3o de gerenciamento e a comunica\u00e7\u00e3o gerente-agente. \n\nA arquitetura proposta pressup\u00f5e a disponibilidade de EWS nos dispositivos \n\ngerenciados. Um EWS pode ser caracterizado como sendo um servidor Web embutido \n\nem um dispositivo de rede com prop\u00f3sito de gerenciamento, provendo aos usu\u00e1rios uma \n\ninterface de gerenciamento baseada nas tecnologias comuns em browsers Web [JU 01].  \n\n1.3 Estrutura\u00e7\u00e3o do Trabalho \n\nEste trabalho est\u00e1 organizado como segue: \n\n O cap\u00edtulo 2 apresenta uma vis\u00e3o geral das linguagens de marca\u00e7\u00e3o, \n\nenfocando XML e tecnologias inter-relacionadas. \n\n O cap\u00edtulo 3 descreve de forma sucinta a linguagem Java e a motiva\u00e7\u00e3o \n\npara sua escolha como ferramenta de programa\u00e7\u00e3o para o prot\u00f3tipo \n\nproposto. \n\n No cap\u00edtulo 4 \u00e9 descrita, de maneira n\u00e3o exaustiva, a arquitetura CORBA. \n\n No cap\u00edtulo 5 \u00e9 apresentada a API AdventSNMP, implementa\u00e7\u00e3o Java de \n\numa biblioteca de gerenciamento de redes que opera sobre o protocolo \n\nSNMP, padr\u00e3o de gerenciamento em redes TCP/IP. O modelo de \n\ngerenciamento de redes SNMP tamb\u00e9m \u00e9 apresentado nesse cap\u00edtulo. \n\n O cap\u00edtulo 6 apresenta o ambiente de rede estudado e o prot\u00f3tipo da \n\naplica\u00e7\u00e3o para demonstrar um emprego de XML nas tarefas de ger\u00eancia de \n\nredes. Tamb\u00e9m \u00e9 discutido um poss\u00edvel uso integrado de CORBA para \n\nprover uma caracter\u00edstica de distribui\u00e7\u00e3o ao gerenciamento de redes. \n\n\n\n 8\n\n Finalmente, o cap\u00edtulo 7 descreve os resultados alcan\u00e7ados e os percal\u00e7os \n\nenfrentados, avaliando as vantagens e desvantagens da utiliza\u00e7\u00e3o conjunta \n\ndas tecnologias para o gerenciamento de redes. Propostas futuras tamb\u00e9m \n\ns\u00e3o discutidas, seguidas pelo referencial bibliogr\u00e1fico consultado. \n\n \n\n\n\n2. Vis\u00e3o Geral de XML \n\n2.1 Introdu\u00e7\u00e3o: Marca\u00e7\u00e3o \n\nA marca\u00e7\u00e3o originou-se, j\u00e1 h\u00e1 bastante tempo, na ind\u00fastria gr\u00e1fica. Essa t\u00e9cnica \n\nda editora\u00e7\u00e3o tradicional consistia em anotar na obra manuscrita um conjunto de \n\ninstru\u00e7\u00f5es para o compositor [BOSAK 99]. Tais anota\u00e7\u00f5es, tamb\u00e9m manuscritas, \n\ndenominavam-se marca\u00e7\u00e3o (mark-up) [MARCHAL 00], sendo uma etapa distinta, ap\u00f3s \n\na escrita e antecedendo a composi\u00e7\u00e3o gr\u00e1fica, da obra a ser impressa. \n\nSimilarmente, linguagens de marca\u00e7\u00e3o s\u00e3o mecanismos que permitem especificar \n\na forma como um certo documento deve ser interpretado ou apresentado pelos mais \n\ndiferentes tipos de software. \n\n 2.1.1 Marca\u00e7\u00e3o procedimental \n\nFreq\u00fcentemente, processadores de texto requerem que o usu\u00e1rio especifique a \n\napar\u00eancia do documento que est\u00e1 sendo editado, como selecionar um certo trecho do \n\ntexto para ser apresentado em uma determinada fonte gr\u00e1fica em negrito ou ainda o \n\nposicionamento de um certo par\u00e1grafo na p\u00e1gina do documento. Tais informa\u00e7\u00f5es de \n\nformata\u00e7\u00e3o s\u00e3o denominadas marca\u00e7\u00e3o (markup code), e em geral s\u00e3o armazenadas \n\njuntamente com o documento [GRAHAM 00], [MARCHAL 00]. \n\nDo ponto de vista metodol\u00f3gico, a tarefa do usu\u00e1rio \u00e9 identificar os elementos \n\nsignificativos do texto que devem receber a formata\u00e7\u00e3o e selecionar um conjunto de \n\ncomandos que produzir\u00e1 o resultado de formata\u00e7\u00e3o desejado. An\u00e1logo ao processo de \n\neditora\u00e7\u00e3o gr\u00e1fica tradicional existe um conjunto de instru\u00e7\u00f5es de marca\u00e7\u00e3o anexado ao \n\ntexto. Um exemplo t\u00edpico de marca\u00e7\u00e3o procedimental encontra-se no formato RTF \n\n(Rich Text Format), desenvolvido pela Microsoft Corporation (MS) e suportado por \n\nsoftwares de v\u00e1rias outras empresas para interc\u00e2mbio de documentos. O RTF indica \n\ncomo um processador de texto deve apresentar um documento gravado em tal formato. \n\n\n\n 10\n\nNa fig. 2.1a \u00e9 mostrado um documento formatado em RTF. J\u00e1 na fig. 2.1b \u00e9 apresentada  \n\na correspondente exibi\u00e7\u00e3o do documento no processador de textos MS-Word 2000. \n\n{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1046{\\fonttbl{\\f0\\fnil\\fcharset0 Times \n\nNew Roman;}}\\viewkind4\\uc1\\pard\\ul\\b\\f0\\fs20 RTF\\ulnone\\b0\\par} \n\nFIGURA 2.1A \u2013 DOCUMENTO FORMATADO EM RTF \n\nFIGURA 2.1B \u2013 APRESENTA\u00c7\u00c3O DE DOCUMENTO RTF NO MS-WORD2000 \n\nA abordagem de marca\u00e7\u00e3o procedimental adotada pelo formato RTF enseja tr\u00eas \n\ngrandes problemas [MARCHAL 00]: \n\n Aus\u00eancia da estrutura do documento. Percebemos que o usu\u00e1rio deduz a \n\napar\u00eancia do documento a partir da estrutura do mesmo, mas apenas o \n\nresultado do processo \u00e9 gravado. As informa\u00e7\u00f5es que levaram esse usu\u00e1rio \n\na um dado conjunto de marca\u00e7\u00e3o n\u00e3o est\u00e1 dispon\u00edvel; \n\n Inflexibilidade. Qualquer mudan\u00e7a nas regras de formata\u00e7\u00e3o implicar\u00e1 \n\nnuma altera\u00e7\u00e3o manual do documento. Al\u00e9m disso, a marca\u00e7\u00e3o \u00e9 em maior \n\n\n\n 11\n\nou menor grau dependente do sistema, baseando-se em fontes ou \n\ndispositivos de sa\u00edda particulares, reduzindo a portabilidade;  \n\n Lentid\u00e3o no processo. Por sua pr\u00f3pria natureza o processo \u00e9 lento e \n\npropenso a erros, sendo relativamente f\u00e1cil formatar incorretamente um \n\ndocumento.   \n\n 2.1.2 Codifica\u00e7\u00e3o Gen\u00e9rica \n\nA codifica\u00e7\u00e3o gen\u00e9rica pode ser vista como marca\u00e7\u00e3o envolvida por codifica\u00e7\u00e3o  \n\ncom a introdu\u00e7\u00e3o de macros. Tais macros substituem os controles por chamadas de \n\nprocedimentos externos de formata\u00e7\u00e3o. Um identificador gen\u00e9rico (Generic Identifier - \n\nGI) ou tag \u00e9 anexado a cada elemento de texto e, al\u00e9m disso,  regras de formata\u00e7\u00e3o s\u00e3o \n\nassociadas a cada tag. Um m\u00f3dulo de formata\u00e7\u00e3o processa o texto e produz um \n\ndocumento no formato do dispositivo de sa\u00edda.  \n\nPara efeito de ilustra\u00e7\u00e3o podemos citar o TeX. [MARCHAL 00]. O TeX consiste \n\nde um compilador7 que processa um arquivo com extens\u00e3o .TEX contendo o documento \n\nescrito em algum formato TeX v\u00e1lido (os formatos mais usados s\u00e3o o Plain TeX e \n\nL\u00e1tex). O processo de compila\u00e7\u00e3o gera um arquivo com extens\u00e3o DVI, contendo o \n\ndocumento pronto para ser visualizado na tela do computador ou impresso. Necessita-se \n\num editor de texto para escrever o arquivo TeX. Est\u00e3o dispon\u00edveis v\u00e1rios editores que se \n\nacomodam muito bem na edi\u00e7\u00e3o de documentos TeX, como por exemplo TeXnic \n\nCenter, TeXshell, WinShell, Winedt, (X)Emacs, TeXtures [KOPKA 99]. \n\nOs benef\u00edcios da codifica\u00e7\u00e3o gen\u00e9rica sobre a marca\u00e7\u00e3o procedimental podem ser \n\nsumarizados em duas caracter\u00edsticas principais [MARCHAL 00]: \n\n A portabilidade e flexibilidade s\u00e3o aumentadas. Para alterar a apar\u00eancia de \n\num documento basta adaptar as macros a ele associadas. A mudan\u00e7a das \n\nmacros reflete-se automaticamente no documento, n\u00e3o sendo necess\u00e1rio \n\num trabalho manual de recodifica\u00e7\u00e3o da marca\u00e7\u00e3o aplicada no texto; \n                                                                  \n\n7 compilador pode ser grosseiramente definido como um programa que processa um arquivo texto escrito \nseguindo regras gramaticais de uma linguagem espec\u00edfica, gerando um \u201carquivo-resultado\u201d \n\n\n\n 12\n\n A marca\u00e7\u00e3o descreve a estrutura.  \n\n2.2 SGML \n\nEm 1986 foi publicado pela ISO (International Standardization for Organization) \n\no padr\u00e3o ISO 8879 [ISO 86], definindo a SGML (Standard Generalized Markup \n\nLanguage), um sistema de marca\u00e7\u00e3o generalizada, baseado nos trabalhos feitos pelo Dr. \n\nCharles Goldfarb, da IBM. A SGML oferece um esquema de marca\u00e7\u00e3o simples, \n\nindependente de plataforma e extremamente flex\u00edvel, ela \u00e9 simplesmente uma maneira \n\nde representar documentos [IBM 01]. \n\nAnalogamente, SGML aproxima-se da codifica\u00e7\u00e3o gen\u00e9rica, por\u00e9m acrescida de \n\nduas caracter\u00edsticas [MARCHAL 00]: \n\n a marca\u00e7\u00e3o descreve a estrutura do documento, n\u00e3o sua apar\u00eancia e  \n\n a marca\u00e7\u00e3o \u00e9 coerente com um modelo, semelhante a um esquema de \n\nbanco de dados. Sendo assim, a marca\u00e7\u00e3o pode ser processada por um \n\nsoftware ou armazenada em uma base de dados.  \n\nA abordagem da SGML n\u00e3o \u00e9 impor um conjunto pr\u00f3prio de tags, mas propor \n\numa linguagem para autores descreverem a estrutura de seus documentos e format\u00e1-los \n\nde forma coerente [MARCHAL 00].  \n\nComo j\u00e1 fora comentado no primeiro par\u00e1grafo dessa se\u00e7\u00e3o, a grande diferen\u00e7a \n\nentre a codifica\u00e7\u00e3o gen\u00e9rica e a SGML \u00e9 o fato de que nesta \u00faltima, a marca\u00e7\u00e3o \n\ndescreve a estrutura do documento. Assim, a SGML n\u00e3o \u00e9 uma linguagem, mas uma \n\nferramenta para definir linguagens [NAKHIMOVSKY 00]. Nesta caracter\u00edstica, muito \n\npr\u00f3xima a muitas linguagens de programa\u00e7\u00e3o, encontra-se o poder da SGML, tornando-\n\na extremamente flex\u00edvel e aberta para novas aplica\u00e7\u00f5es.  \n\nA estrutura do documento \u00e9 escrita em um DTD (Document Type Definition), \n\nalgumas vezes referenciado como aplica\u00e7\u00e3o SGML. Um DTD especifica os elementos, \n\nseus relacionamento e o conjunto tags que efetuam a marca\u00e7\u00e3o do documento. Este \n\n\n\n 13\n\noutro diferencial da SGML com rela\u00e7\u00e3o \u00e0 codifica\u00e7\u00e3o gen\u00e9rica: na SGML a marca\u00e7\u00e3o \n\nobedece a um modelo. \n\nApesar de extremamente poderosa e flex\u00edvel, a SGML \u00e9 muito gen\u00e9rica, extensa e \n\ncomplexa: somente o documento de especifica\u00e7\u00e3o da linguagem possui 500 p\u00e1ginas \n\nacrescidas de mais 100 p\u00e1ginas de anexo [HOLZNER 01]. Aplica\u00e7\u00f5es reais passaram a \n\nexigir deriva\u00e7\u00f5es da SGML mais reduzidas e mais facilmente implement\u00e1veis.   \n\n2.3 HTML  \n\nCertamente a aplica\u00e7\u00e3o mais conhecida, e efetivamente utilizada, da SGML \u00e9 a \n\nHTML (Hyper Text Markup Language). Na WWW (World Wide Web), a linguagem de \n\nmarca\u00e7\u00e3o HTML \u00e9 amplamente empregada para descrever como os browsers Web8 \n\ndevem exibir os documentos, criada por Tim Berners Lee e Robert Caillau no CERN. \n\nFormalmente, HTML \u00e9 uma aplica\u00e7\u00e3o da SGML, isto \u00e9, um conjunto de tags que \n\nseguem as regras da SGML. O conjunto de tags definidos pela HTML \u00e9 adaptado para a \n\nestrutura de documentos hipertexto.  \n\nA fig. 2.2a apresenta um documento codificado em HTML. Na fig. 2.2b \u00e9 mostra \n\nsua respectiva exibi\u00e7\u00e3o no browser Web MS-Internet Explorer 6.  \n\n<html> \n\n<head> \n\n<title>Texto Formatado em HTML</title> \n\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"> \n\n</head> \n\n \n\n<body bgcolor=\"#FFFFFF\"> \n\n<font face=\"Times New Roman, Times, serif\"><u><b>HTML&lt;/b></u></font>  \n\n</body> \n\n</html> \n\nFIGURA 2.2A \u2013 DOCUMENTO CODIFICADO EM HTML \n\n                                                                  \n8 Uma aplica\u00e7\u00e3o cliente que permite ao usu\u00e1rio visualizar documentos HTML contidos na World Wide \nWeb, em outra rede ou no computador do usu\u00e1rio, acompanhar os v\u00ednculos de hipertexto e transferir \narquivos. \n\n\n\n 14\n\nFIGURA 2.2B \u2013 APRESENTA\u00c7\u00c3O DE DOCUMENTO NO MS-INTERNET EXPLORER 6 \n\nA HTML n\u00e3o encoraja nenhum tipo de estrutura r\u00edgida. Na verdade, for\u00e7a uma \n\nestrutura\u00e7\u00e3o muito fraca.  \n\nHistoricamente, a HTML foi desenvolvida em duas dire\u00e7\u00f5es contradit\u00f3rias. \n\nPrimeiramente, muitas tags de marca\u00e7\u00e3o foram introduzidas, mas atualmente HTML \u00e9 \n\nde certa forma uma linguagem de marca\u00e7\u00e3o procedimental. Tags nesta categoria \n\nincluem&lt;CENTER> e &lt;FONT>. Tais tags s\u00e3o utilizadas para expressar a apresenta\u00e7\u00e3o, n\u00e3o \n\nsomente a estrutura. Ao mesmo tempo, atributos de classe e folhas de estilo (style \n\nsheets) foram adicionados ao HTML, tornando-a parcialmente uma linguagem de \n\ncodifica\u00e7\u00e3o gen\u00e9rica. Assim, a HTML, do ponto de vista sem\u00e2ntico da marca\u00e7\u00e3o, \u00e9 uma \n\nlinguagem impura, reunindo componentes apenas de marca\u00e7\u00e3o (par\u00e1grafos, cabe\u00e7alhos, \n\ndivis\u00f5es e outros) mesclados a componentes que especificam a apar\u00eancia do documento \n\n(cor do texto, tipo de fonte e outros) [GRAHAM 00]. \n\n Ao longo dos anos, para acomodar sua popularidade crescente, a HTML foi \n\nestendida v\u00e1rias vezes. A primeira vers\u00e3o possu\u00eda pouco mais de uma dezena de tags, ao \n\npasso que a vers\u00e3o atual possui mais de 100 tags, n\u00e3o considerando as tags espec\u00edficas \n\ndos diferentes browsers Web. Al\u00e9m disso, muitas tecnologias, desenvolvidas pelo W3C \n\n\n\n 15\n\n(World Wide Web Consortium)9 ou pela pr\u00f3pria ind\u00fastria, foram introduzidas sendo \n\nexemplos not\u00e1veis JavaScript10, Java, Flash, CGI (Common Gateway Interface)11, \n\nASP12 (Active Server Pages), streamming13 de v\u00eddeo, MP314 dentre outras. O W3C \u00e9 um \n\ngrupo respons\u00e1vel pela normatiza\u00e7\u00e3o da Web, composto por mais de 400 organiza\u00e7\u00f5es \n\nmembro interessadas na Web est\u00e1 baseado no MIT (Massachussets Institut Of \n\nTechnology), no INRIA (Instituit National de Recherche em Informatique et em \n\nAutomatique) e na Universidade de Keio, Campus Shonan Fujisawa, Jap\u00e3o. \n\nEssas adi\u00e7\u00f5es tornaram HTML uma linguagem complexa. A combina\u00e7\u00e3o de tags \n\n\u00e9 quase infinita e o resultado de uma combina\u00e7\u00e3o particular pode ser diferente de um \n\nbrowser para outro. Como agravante, desponta a necessidade da cria\u00e7\u00e3o de novas tags  \n\npara atender \u00e0s especificidades das aplica\u00e7\u00f5es emergentes como com\u00e9rcio eletr\u00f4nico \n\n(electronic commerce) e streaming de \u00e1udio e v\u00eddeo [MARCHAL 00]. \n\nUm outro problema, tamb\u00e9m relacionado, \u00e9 o emprego excessivo de tags para \n\nformatar um documento HTML. N\u00e3o \u00e9 incomum encontrar-se documentos que possuem \n\nsignificativamente mais marca\u00e7\u00e3o que conte\u00fado, acarretando em um acr\u00e9scimo de \n\ntempo para as opera\u00e7\u00f5es de download e exibi\u00e7\u00e3o de tais documentos [MARCHAL 00].   \n\nEssas limita\u00e7\u00f5es j\u00e1 citadas e outras mais v\u00eam se evidenciando, levando alguns a \n\nconsiderar um momento de colapso para a HTML. Tal problem\u00e1tica, somada a grande \n\ninser\u00e7\u00e3o e aceita\u00e7\u00e3o da linguagem HTML como meio de publica\u00e7\u00e3o de documentos na \n\nWeb, motivou o W3C a desenvolver XML.   \n\n2.4 XML \n\n                                                                  \n9 Todas as especifica\u00e7\u00f5es do W3C est\u00e3o publicadas em HTML (e, recentemente XHTML) no site \nhttp://www.w3c.org \n10 Linguagem de cria\u00e7\u00e3o de scripts desenvolvida pela Netscape Communications e pela Sun \nMicrosystems, Inc., que \u00e9 ligeiramente relacionada \u00e0 Java. \n11 A especifica\u00e7\u00e3o que define a comunica\u00e7\u00e3o entre servidores de comunica\u00e7\u00e3o (como servidores HTTP) e \nrecursos no computador host do servidor, como bancos de dados e outros programas \n12 uma linguagem para gera\u00e7\u00e3o de p\u00e1ginas HTML dinamicamente atrav\u00e9s de um servidor \n13 \u00e9 um mecanismo para enviar conte\u00fado multim\u00eddia (v\u00eddeo, \u00e1udio, anima\u00e7\u00f5es) atrav\u00e9s de uma rede \ncorporativa ou Internet., onde tais conte\u00fados podem ser visualizados pelo cliente na medida em que s\u00e3o \nrecebidos  \n14 MPEG-1 Layer 3, um padr\u00e3o internacional para alta compress\u00e3o de arquivos de sons sem perda \nsignificativa de qualidade \n\n\n\n 16\n\n2.4.1 Origens \n\nJon Bosak, engenheiro da Sun Microsystems e grande conhecedor da SGML, ap\u00f3s \n\nter transferido para um sistema on-line as 150 mil p\u00e1ginas de documenta\u00e7\u00e3o do Novell \n\nNetware, da Novell, utilizando exclusivamente a SGML, prop\u00f4s ao W3C, o estudo de \n\numa forma de aproveitar o poder da SGML para aplica\u00e7\u00f5es voltadas \u00e0 Web.  \n\nDos trabalhos de Bosak, Tim Bray e Sperberg McQueen especialistas em SGML \n\nna Sun MicroSystems, em 1996 foi definido um sistema de codifica\u00e7\u00e3o denominado \n\nXML (Extensible Markup Language) baseado no SGML para permitir a distribui\u00e7\u00e3o de \n\ninforma\u00e7\u00e3o heterog\u00eanea atrav\u00e9s da Web. Muitos dos recursos SGML tiveram de ser \n\nabolidos para que a XML fosse leve e pequena o suficiente para se tornar eficaz e \n\nmenos complexa. Em fevereiro de 1998, a XML tornou-se uma especifica\u00e7\u00e3o formal, \n\nreconhecida pelo W3C. \n\n2.4.2 Defini\u00e7\u00e3o de XML \n\nXML n\u00e3o \u00e9 em si mesma uma linguagem, mas um conjunto de regras para \n\nprojetar linguagens de marca\u00e7\u00e3o [RAY 01]. Tecnicamente, XML \u00e9 considerada uma \n\nmetalinguagem baseada em um subconjunto da SGML [HOLZNER 01]. \n\nMetalinguagem \u00e9 uma linguagem que permite a especifica\u00e7\u00e3o de outra linguagem \n\n[SEBESTA 00]. Neste texto, XML ser\u00e1 referenciada com o termo linguagem. A XML \n\noferece o panorama de uma ampla variedade de aplica\u00e7\u00f5es, cada uma servindo a uma \n\nfun\u00e7\u00e3o em particular e usando a WEB como uma infra-estrutura de distribui\u00e7\u00e3o. \n\nSegundo [MCGRATH 99], XML surgiu como resultado de uma longa e \n\ncuidadosa an\u00e1lise, do real significado do termo \"documento\" no meio digital, que de \n\numa forma geral, \u00e9 composto de tr\u00eas elementos distintos:  \n\n conte\u00fado de dados \u2013 as palavras propriamente ditas;  \n\n estrutura \u2013 corresponde ao tipo de documento e a organiza\u00e7\u00e3o de seus \n\nelementos, a ordem com que eles aparecem; e finalmente  \n\n\n\n 17\n\n apresenta\u00e7\u00e3o \u2013 a forma com que as informa\u00e7\u00f5es s\u00e3o mostradas ao leitor, \n\nou seja, na tela atrav\u00e9s de um browser Web, por voz, em um aparelho de \n\ntelefone celular, em um computador port\u00e1til, entre outros. \n\nConforme discutido na se\u00e7\u00e3o 2.3, HTML \u00e9 uma aplica\u00e7\u00e3o da SGML com um \n\nobjetivo particular: exibir documentos hipertexto na Web. XML, por sua vez, \u00e9 um \n\nperfil da SGML e pode dar suporte a uma infinidade de outras aplica\u00e7\u00f5es diferentes da \n\nHTML. Para o W3C [W3C 01b] XML define \"um dialeto de SGML extremamente \n\nsimples, o qual \u00e9 completamente descrito na Especifica\u00e7\u00e3o XML. O objetivo \u00e9 habilitar \n\no SGML padr\u00e3o para que ele possa ser distribu\u00eddo, recebido e processado na Web, da \n\nmesma forma que hoje isso \u00e9 poss\u00edvel com o HTML\". Por essa raz\u00e3o, XML foi \n\nprojetado para apresentar facilidade de implementa\u00e7\u00e3o e interoperabilidade com ambos, \n\nSGML e HTML. \n\nA grande revolu\u00e7\u00e3o da XML est\u00e1 na sua caracter\u00edstica principal que \u00e9 a \n\ndissocia\u00e7\u00e3o entre a estrutura da apresenta\u00e7\u00e3o e o conte\u00fado do documento, permitindo, \n\nassim, que um mesmo documento possa ser apresentado atrav\u00e9s de v\u00e1rias formas: um \n\nmonitor de um computador pessoal, uma pequena tela de um telefone celular ou at\u00e9 \n\nmesmo que ela seja transformada em voz para utiliza\u00e7\u00e3o dos deficientes visuais. \n\n2.4.3 Facilidades XML \n\nDesde a publica\u00e7\u00e3o da linguagem XML, seu emprego vem se expandindo de \n\nforma bastante vigorosa. Nesta se\u00e7\u00e3o s\u00e3o apresentadas algumas facilidades oferecidas \n\npela XML: \n\n Distin\u00e7\u00e3o entre interface, processos e dados. Um dos grandes atrativos do \n\nXML \u00e9 a separa\u00e7\u00e3o mantida entre dados e interface com o usu\u00e1rio. Por \n\nexemplo, HTML especifica como os dados ser\u00e3o exibidos no browser \n\n[GRAHAM 00]; XML, por sua vez, simplesmente define o conte\u00fado, \n\nvalendo-se de delimitadores simplesmente para descri\u00e7\u00e3o de dados \n\n(\u00edndices econ\u00f4micos, dados bibliogr\u00e1ficos). Para definir o modo de \n\napresenta\u00e7\u00e3o em browsers de dados descritos em XML, existem \n\n\n\n 18\n\nstylesheets como a XSL (Extensible Style Language) e a CSS (Cascading \n\nStyle Sheets) - desta forma, o desenvolvedor tem a liberdade de definir a \n\ninterface e o processamento dos dados, bastando utilizar diferentes \n\nstylesheets e aplica\u00e7\u00f5es. Tal separa\u00e7\u00e3o entre dados e apresenta\u00e7\u00e3o traz \n\nconsigo uma nova funcionalidade - a integra\u00e7\u00e3o de dados oriundos de \n\ndiferentes fontes. As diferentes informa\u00e7\u00f5es de interesse podem ser \n\nconvertidas para o formato XML em uma camada intermedi\u00e1ria (por \n\nexemplo, um servidor de aplica\u00e7\u00f5es), permitindo um interc\u00e2mbio de dados \n\nt\u00e3o simples quanto \u00e0 exibi\u00e7\u00e3o de p\u00e1ginas HTML. Esses dados, j\u00e1 \n\ncodificados em XML, podem ser distribu\u00eddos diretamente \u00e0 m\u00e1quina \n\ncliente, utilizando o formato HTTP15 (j\u00e1 suportado) e sem a necessidade de \n\nnovas requisi\u00e7\u00f5es aos dados legados da esta\u00e7\u00e3o servidora; \n\n Flexibiliza\u00e7\u00e3o no interc\u00e2mbio de dados: Em [HOLZNER 01], os formatos \n\nde dados patenteados ou propriet\u00e1rios s\u00e3o apontados como empecilhos \n\npara a troca de dados entre organiza\u00e7\u00f5es ou mesmo aplica\u00e7\u00f5es distintas. \n\nEm XML, tanto os dados, como suas respectivas marca\u00e7\u00f5es, s\u00e3o \n\narmazenados em formato texto, provendo f\u00e1cil acesso. Linguagens de \n\nmarca\u00e7\u00e3o padronizadas permitem que documentos sejam utilizados para \n\ndiferentes prop\u00f3sitos; \n\n Personaliza\u00e7\u00e3o das linguagens de marca\u00e7\u00e3o: XML possibilita a cria\u00e7\u00e3o de \n\nlinguagens de marca\u00e7\u00e3o espec\u00edficas [FURGERI 01]. Diversas linguagens \n\npersonalizadas est\u00e3o sendo padronizadas tais como a CBL (Common \n\nBuiness Library), a IFX (Financial Exchange), a BITS (Banking Industry \n\nTechnology Secretariat), a TIM (Telecommunications Interchange \n\nMarkup), a CML (Chemical Markup Language) e muitas outras. \n\n Autodescri\u00e7\u00e3o de dados: Documentos XML, s\u00e3o, grosso modo, \n\nautodocumentados. As tags, em geral, s\u00e3o mnem\u00f4nicas e explicitam em si \n\nmesmas o tipo de informa\u00e7\u00e3o que est\u00e1 sendo relacionada. A grande \n                                                                  \n\n15 Hypertext Transfer Protocol (HTTP) \u00e9 um procolo que executa em n\u00edvel de aplica\u00e7\u00e3o para distribui\u00e7\u00e3o \nde documentos hiperm\u00edda em sistemas de informa\u00e7\u00e3o. A caracter\u00edstica do HTTP de negociar a \nrepresenta\u00e7\u00e3o dos dados a serem transmitidos possibilita a independ\u00eancia dos sistemas com rela\u00e7\u00e3o aos \ndados a serem transferidos \n\n\n\n 19\n\nrevolu\u00e7\u00e3o advinda do uso da XML \u00e9 o uso da marca\u00e7\u00e3o para definir o que \n\n\u00e9 a informa\u00e7\u00e3o e n\u00e3o como ele deve ser mostrada [BOSAK 99]. \n\n Estrutura\u00e7\u00e3o e integra\u00e7\u00e3o dos dados: XML possui uma \u00eanfase forte na \n\nexatid\u00e3o dos documentos. XML imp\u00f5e um rigor na codifica\u00e7\u00e3o \n\ndocumentos, evitando pr\u00e1ticas desleixadas. Um browser XML pode \n\nverificar se um documento XML \u00e9 um documento bem formado (well-\n\nformed document) e se o mesmo \u00e9 v\u00e1lido. Os conceitos de boa forma\u00e7\u00e3o e \n\nvalidade de um documento XML ser\u00e3o apresentados na se\u00e7\u00e3o 2.4.5 e \n\n2.4.6, respectivamente.  \n\n2.4.4 Estrutura de Documentos XML  \n\nUm documento XML \u00e9 um documento que possui uma estrutura hier\u00e1rquica com \n\nduas se\u00e7\u00f5es: Pr\u00f3logo (Prolog) e Corpo (Body). O documento XML inicia com um \n\nPr\u00f3logo opcional, constitu\u00eddo de declara\u00e7\u00f5es XML, PIs (Processing Instructions), \n\nDTDs e coment\u00e1rios. A fig. 2.3 apresenta um documento XML bastante simples. \n\nElementos dividem o documento em suas partes constituintes. Tais elementos \n\npodem conter texto, outros elementos, ou ambos.  No documento da fig. 2.3, Agency \u00e9 o \n\nelemento raiz, com BankAccount, Number, Name, Type, OpenDate e Balance, sendo \n\nseus elementos filho. Elementos s\u00e3o delimitados por uma tag de in\u00edcio (ex:&lt;Type>) e \n\numa tag de fim (</Type>). Em HTML as tags de fim n\u00e3o s\u00e3o necess\u00e1rias, devido ao \n\ntratamento especial implementado pelos browsers, mas XML \u00e9 r\u00edgida e exige que todas \n\nas tags sejam apropriadamente fechadas. As tags tamb\u00e9m devem ser aninhadas \n\ncorretamente. A seq\u00fc\u00eancia&lt;A><B><C></C></B></A> \u00e9 v\u00e1lida, mas \n\n<A><B><C></B></C></A> n\u00e3o o \u00e9. Sobreposi\u00e7\u00e3o de tags n\u00e3o \u00e9 permitida. \n\nFinalmente, documentos XML s\u00e3o case-sensitive, isto \u00e9, existe distin\u00e7\u00e3o entre \n\ncaracteres mai\u00fasculos e min\u00fasculos.  \n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> \n\n<?xml-stylesheet type=\u201dtext/css\u201d href=\u201destilo.css\u201d?> \n\n<!-- Defini\u00e7\u00e3o da DTD do documento--> \n\n<!DOCTYPE Agency [ \n\n\n\n 20\n\n&lt;!ELEMENT Agency (BankAccount+)> \n\n&lt;!ELEMENT BankAccount (Number, Name, Type, OpenDate, Balance)> \n\n&lt;!ELEMENT Number (#PCDATA)> \n\n&lt;!ELEMENT Name (#PCDATA)> \n\n&lt;!ELEMENT OpenDate (#PCDATA)> \n\n&lt;!ELEMENT Type (#PCDATA)> \n\n&lt;!ELEMENT Balance (#PCDATA)> \n\n]> \n\n<!--Exemplo de um documento XML --> \n\n<Agency> \n\n&lt;BankAccount> \n\n &lt;Number>721174</Number> \n\n &lt;Name>Carlos Westphall</Name> \n\n &lt;Type>Pagamento</Type> \n\n &lt;OpenDate>25/07/1986</OpenDate> \n\n &lt;Balance>25382.20</Balance> \n\n&lt;/BankAccount> \n\n&lt;BankAccount> \n\n &lt;Number>1709459</Number> \n\n &lt;Name>Fabio Spanhol</Name> \n\n &lt;Type>Corrente</Type> \n\n &lt;OpenDate>30/08/1993</OpenDate> \n\n &lt;Balance>1432.62</Balance> \n\n&lt;/BankAccount> \n\n</Agency> \n\nFIGURA 2.3 \u2013 UM DOCUMENTO XML SIMPLES \n\nElementos tamb\u00e9m podem possuir atributos, os quais s\u00e3o, simplificando, pares de \n\nnome e valor em tags iniciais, como por exemplo,&lt;Student RollNo=\"2\">, onde RollNo \n\n\u00e9 o nome do atributo e \u201c2\u201d seu valor associado. XML requer que todos os atributos \n\nestejam envolvidos por caracteres \u2018 ou \u201c. Atributos s\u00e3o usados, principalmente, com o \n\nprop\u00f3sito de modificar o comportamento de um elemento e n\u00e3o para armazenar dados \n\n[RAY 01].  \n\nExistem atualmente cinco caracteres que possuem sem\u00e2ntica especial. Tais \n\ncaracteres s\u00e3o&lt;, >, ', \", e &amp;. Caso seja necess\u00e1rio utilizar algum destes caracteres \n\ndiretamente como conte\u00fado do documento, e n\u00e3o como marca\u00e7\u00e3o, deve-se utilizar os \n\nc\u00f3digos de escape &amp;lt;, &amp;gt;, &amp;apos;,&amp;quot;, e &amp;amp; respectivamente. \n\n\n\n 21\n\nNa fig. 2.4 est\u00e3o destacadas as se\u00e7\u00f5es XML (pr\u00f3logo e corpo) presentes no \n\ndocumento apresentado na fig. 2.3. \n\nf\n\na\n\nb\nc\n\nd\n\n \n\nP\nr\n\u00f3\nl\no\ng\no\n\n \n\nC\no\nr\np\no\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<?xml-stylesheet type=\u201dtext/css\u201d href=\u201destilo.css\u201d?>\n<!-- Defini\u00e7\u00e3o da DTD do documento-->\n<!DOCTYPE Agency [\n\n<!ELEMENT Agency (BankAccount+)>\n<!ELEMENT BankAccount (Number, Name, Type, OpenDate,\n\nBalance)>\n<!ELEMENT Number (#PCDATA)>\n<!ELEMENT Name (#PCDATA)>\n<!ELEMENT OpenDate (#PCDATA)>\n<!ELEMENT Type (#PCDATA)>\n<!ELEMENT Balance (#PCDATA)>\n\n]>\n<!--Exemplo de um documento XML -->\n<Agency>\n\n<BankAccount>\n<Number>721174</Number>\n<Name>Carlos Westphall</Name>\n<Type>Pagamento</Type>\n<OpenDate>25/07/1986</OpenDate>\n<Balance>25382.20</Balance>\n\n</BankAccount>\n<BankAccount>\n\n<Number>1709459</Number>\n<Name>Fabio Spanhol</Name>\n<Type>Corrente</Type>\n<OpenDate>30/08/1993</OpenDate>\n<Balance>1432.62</Balance>\n\n</BankAccount>\n</Agency>\n\ne\n\n \n\nFIGURA 2.4 \u2013 ESTRUTURA DE UM DOCUMENTO XML \n\nCaso um documento XML possua a declara\u00e7\u00e3o xml (fig. 2.4a), ela deve ser a \n\nprimeira linha do documento, n\u00e3o sendo precedida por nenhum espa\u00e7o em branco. Essa \n\ndeclara\u00e7\u00e3o identifica o documento como sendo um documento XML e possui tr\u00eas \n\natributos: version (obrigat\u00f3rio), encoding e standalone (ambos opcionais).  \n\nDocumentos XML s\u00e3o documentos texto (text). O termo \u201ctexto\u201d aqui n\u00e3o se refere \n\nao ASCII (American Standard Code for Information Interchange), mas sim ao Unicode. \n\nO uso do Unicode permite que os documentos XML sejam produzidos em diferentes \n\nidiomas, com os mais variados conjuntos de caracteres e s\u00edmbolos. Os caracteres reais \n\nde um documento s\u00e3o armazenados na verdade utilizando c\u00f3digos num\u00e9ricos e o W3C \n\nn\u00e3o utiliza o ASCII como conjunto de caracteres padr\u00e3o para XML, mas sim o Unicode. \n\nEssa escolha deve-se a limita\u00e7\u00e3o do conjunto ASCII, que utiliza um byte, permitindo \n\n\n\n 22\n\nsomente de 0 a 255 c\u00f3digos de caractere, quantidade insuficiente para representar todos \n\nos caracteres e ideogramas presentes em documentos tibetanos, cir\u00edlicos, ar\u00e1bicos, \n\nhebraicos, tailandeses e outros. O Unicode, por sua vez, utiliza 2 bytes, permitindo de 0 \n\na 65.535 c\u00f3digos de caractere, independentes de plataforma ou linguagem [UC 01], \n\nestando atualmente cerca de 40.000 c\u00f3digos j\u00e1 reservados [HOLZNER 01]. \n\nO atributo encoding na declara\u00e7\u00e3o XML especifica qual codifica\u00e7\u00e3o est\u00e1 sendo \n\nutilizada para representar os caracteres no documento, por padr\u00e3o os processadores \n\nXML assumem que a codifica\u00e7\u00e3o utilizada \u00e9 a UTF-8.  \n\nFinalmente, o atributo standalone pode possuir os valores \"yes\", indicando ao \n\nprocessador se o documento XML depende de refer\u00eancias externas, ou \"no\" , quando \n\ndocumento n\u00e3o possui referencias externas. Na fig. 2.4a, a declara\u00e7\u00e3o xml define o \n\natributo obrigat\u00f3rio version com o valor 1.0 (a vers\u00e3o atualmente dispon\u00edvel de XML). \n\nAs instru\u00e7\u00f5es de processamento (fig. 2.4b) especificamente par\u00e2metros adicionais \n\npara o processador XML, sendo iniciadas por&lt;? e finalizadas por ?>. Como o suporte \n\n\u00e0s PI \u00e9 dependente do processador XML, o conte\u00fado das PI n\u00e3o est\u00e1 especificado na \n\nrecomenda\u00e7\u00e3o XML do W3C [HOLZNER 01]. \n\nOs coment\u00e1rios em XML (Fig. 2.4c e 2.4e) assemelham-se aos coment\u00e1rios em \n\nHTML, provendo uma descri\u00e7\u00e3o \u00fatil para manuten\u00e7\u00e3o de documentos complexos e uma \n\neficiente documenta\u00e7\u00e3o inline. S\u00e3o iniciados por&lt;!\u2014e finalizados com --> \n\n[HOLZNER 01]. \n\nA \u00faltima parte apresentada no pr\u00f3logo indicado na fig. 2.4 \u00e9 a declara\u00e7\u00e3o de tipo \n\nde documento. \u00c9 onde se especifica uma s\u00e9rie de par\u00e2metros tais como: declara\u00e7\u00f5es de \n\nentidade, a DTD que ser\u00e1 usada para validar o documento, e o nome do elemento raiz. \n\nA DTD (fig. 2.4d), permite ao processador XML comparar a inst\u00e2ncia do documento \n\ncom um modelo de documento, um processo chamado validity checking. A checagem \n\nde validade do documento \u00e9 opcional, mas quando aplicada, garante que o documento \n\nsegue padr\u00f5es pr\u00e9-determinados e inclui dados requeridos [RAY 01]. As DTD ser\u00e3o \n\ndiscutidas mais detalhadamente na se\u00e7\u00e3o 2.4.6. \n\n\n\n 23\n\nComo descrito anteriormente, um documento XML possui uma estrutura \n\nhier\u00e1rquica e o diagrama de \u00e1rvore \u00e9 uma forma bastante adequada para representar o \n\nrelacionamento entre as partes do documento em quest\u00e3o. A fig. 2.5 apresenta o \n\ndocumento da fig. 2.3 em um diagrama de \u00e1rvore. Cada um dos ret\u00e2ngulos da fig. 2.5 \u00e9 \n\num nodo da \u00e1rvore. Ainda na fig. 2.5, os ret\u00e2ngulos pretos representam os elementos, \n\nenquanto os ret\u00e2ngulos brancos, denominados folhas, representam o conte\u00fado real do \n\ndocumento. Documentos XML possuem um, e somente um, elemento raiz (root \n\nelement), tamb\u00e9m denominado elemento documento (document element), pois ele inclui \n\ntodos os outros elementos, definindo assim os limites do documento [RAY 01]. Todos \n\nos outros elementos s\u00e3o filhos do elemento raiz. O elemento raiz da \u00e1rvore da fig. 2.5 \n\nest\u00e1 identificado pelo r\u00f3tulo Agency.  \n\nAgency\n\nBank Acount\n\nNumber Name Type OpenDate Balance\n\n721174 Carlos\nWestphall\n\nPagamento 25/07/1986 25382.20\n\nBank Acount\n\nNumber Name Type OpenDate Balance\n\n1709459 Fabio\nSpanhol\n\nCorrente 30/08/1993 1432.62\n\nFIGURA 2.5 \u2013 DIAGRAMA EM \u00c1RVORE DE UM DOCUMENTO XML \n\n2.4.4 Documentos XML bem formados \n\nTodo documento XML possui uma estrutura l\u00f3gica e f\u00edsica. Fisicamente, o \n\ndocumento \u00e9 composto por unidades denominadas entidades. Entidades s\u00e3o \n\ncomposi\u00e7\u00f5es formadas por seq\u00fc\u00eancias de caracteres (texto) ou padr\u00f5es bin\u00e1rios, mas \n\nn\u00e3o ambos. O termo entidade define a unidade de armazenamento de dados em XML \n\n[HOLZNER 01].  \n\nUma entidade pode referenciar-se a outra entidade para efetuar a inclus\u00e3o desta no \n\ndocumento. Um documento inicia com um elemento raiz (root) ou entidade document. \n\nLogicamente, o documento \u00e9 composto por declara\u00e7\u00f5es, elementos, coment\u00e1rios, \n\nrefer\u00eancias de caractere, e instru\u00e7\u00f5es de processamento, todos os quais s\u00e3o indicados no \n\n\n\n 24\n\ndocumento por uma marca\u00e7\u00e3o expl\u00edcita. As estruturas l\u00f3gicas e f\u00edsicas devem estar \n\ncorretamente aninhadas  [W3C 01b]. \n\nInformalmente, um documento bem formado \u00e9 um documento que cont\u00e9m um ou \n\nmais elementos, e o elemento raiz, cont\u00e9m todos os elementos restantes [HOLZNER \n\n01]. Formalmente, o W3C define que um objeto textual \u00e9 bem formado se: \n\n tomado como um todo, ele corresponde \u00e0 produ\u00e7\u00e3o intitulada document; \n\n tal documento atende a todas as restri\u00e7\u00f5es de boa forma\u00e7\u00e3o dadas na \n\nespecifica\u00e7\u00e3o XML [W3C 01b]; \n\n Cada uma das entidades analisadas, referenciada direta ou indiretamente \n\ndentro do documento, \u00e9 bem formada; \n\n2.4.5 Documentos XML V\u00e1lidos \n\nUm documento XML \u00e9 v\u00e1lido se possuir uma DTD associada a ele, al\u00e9m de \n\nobedecer \u00e0s regras expressas na declara\u00e7\u00e3o [W3C 01b].  \n\nA sintaxe correta de um documento \u00e9 especificada na DTD, que pode estar \n\ndefinida no pr\u00f3prio documento ou armazenada em arquivos separados. Formalmente a \n\nDTD define a gram\u00e1tica para uma classe de documentos. \n\nExistem ferramentas chamadas validadores que permitem verificar se um \n\ndocumento XML \u00e9 bem formado e v\u00e1lido. Alguns exemplos s\u00e3o o W3CXML \n\nValidator16, STG XML Validation17 e o validador18 do Language Technology Group, da \n\nUniversidade de Edinburgh. \n\n2.4.6 Esquemas XML  \n\n                                                                  \n16 Dispon\u00edvel em validator.w3.org/ \n17 Dispon\u00edvel em www.stg.brown.edu/service/xmlvalid/ \n18 Dispon\u00edvel em www.ltg.ed.uk/~richard/xml-check.html \n\n\n\n 25\n\nExiste um conflito potencial entre facilidade de uso e flexibilidade. De maneira \n\ngeral, solu\u00e7\u00f5es mais flex\u00edveis s\u00e3o mais trabalhosas e solu\u00e7\u00f5es espec\u00edficas s\u00e3o otimizadas \n\npara certas tarefas. Construindo um paralelo entre HTML e XML destaca-se esse fato. \n\nAmbas s\u00e3o utilizadas para publicar documentos na Web (apesar de XML aplicar-se a \n\numa s\u00e9rie de outros prop\u00f3sitos). HTML possui um conjunto fixo de tags e os softwares \n\nque a manipulam podem ser otimizados, como, por exemplo, os editores HTML que \n\noferecem templates, edi\u00e7\u00e3o visual, preview do documento e outras facilidades \n\n[MARCHAL 00]. XML, por outro lado \u00e9 uma solu\u00e7\u00e3o flex\u00edvel. Ele n\u00e3o predefine tags, \n\nmas auxilia na estrutura\u00e7\u00e3o dos documentos. Logo, editores XML devem aceitar \n\nqualquer tipo de estrutura de documento e os documentos XML obedecem a uma \n\nsintaxe definida pelo criador do documento. Mas, uma vez definida uma estrutura, o \n\ndocumento deve obedec\u00ea-la para ser v\u00e1lido.  \n\nUm documento XML para ser considerado v\u00e1lido deve obedecer a um conjunto de \n\nregras sint\u00e1ticas denominado esquema [HOLZNER 01]. O esquema descreve um \n\nmodelo para uma classe de documentos [VLIST 01]. No processo de valida\u00e7\u00e3o \u00e9 \n\nrealizada a compara\u00e7\u00e3o de um documento XML com seu esquema correspondente, \n\nsendo um documento XML considerado v\u00e1lido caso sua sintaxe tenha sido comparada \n\ncom sucesso na valida\u00e7\u00e3o [CASTRO 01]. Assim, os esquemas especificam a estrutura e \n\na sintaxe do documento XML e n\u00e3o seu conte\u00fado.  \n\nUm esquema tamb\u00e9m pode ser visto como um acordo sobre um vocabul\u00e1rio \n\ncomum para uma aplica\u00e7\u00e3o particular que envolve a troca de documentos [VLIST 01]. \n\n Esquemas podem ser escritos em dois sistemas distintos o XML Schema, padr\u00e3o \n\nrecente desenvolvido pelo W3C; e DTD (Document Type Definition), um sistema de \n\nregras antiquado, embora amplamente utilizado. \n\nMuitos dos analisadores XML, como o embutido no browser MS-Internet \n\nExplorer, exigem que um documento XML seja bem formado, mas n\u00e3o necessariamente \n\nv\u00e1lido. Contudo, caso um esquema esteja dispon\u00edvel ele ser\u00e1 utilizado para validar o \n\ndocumento. \n\n2.4.6.1 DTD \n\n\n\n 26\n\nA DTD \u00e9 um sistema para defini\u00e7\u00e3o de esquemas antigo, mas ainda amplamente \n\nutilizado. Baseado em regras, possui uma sintaxe peculiar, embora bastante limitada \n\n[CASTRO 01]. \n\nDTD apresenta uma s\u00e9rie de desvantagens se comparada a XML Schema. \n\nPrimeiramente, a pr\u00f3pria sintaxe DTD possui pouca rela\u00e7\u00e3o com XML e n\u00e3o pode ser \n\nvalidada por um parser XML. Al\u00e9m disso, as declara\u00e7\u00f5es DTD s\u00e3o globais, impedindo \n\na exist\u00eancia de nomes id\u00eanticos, mesmo em contextos distintos. Finalmente, DTDs n\u00e3o \n\npodem controlar o tipo de informa\u00e7\u00e3o que um determinando elemento ou atributo do \n\ndocumento XML pode conter [CASTRO 01]. \n\n2.4.6.1.1 Declara\u00e7\u00f5es de Elemento \n\nA DTD \u00e9 um mecanismo para descrever todo objeto (elemento, atributo e outros) \n\nque pode aparecer no documento. Para declarar um elemento numa DTD utilizam-se \n\nregras que obedecem a seguinte sintaxe:&lt;!ELEMENT NOME \n\nMODELO_CONTE\u00daDO>. O lado direito dessa regra (MODELO_CONTE\u00daDO) define \n\no lado esquerdo (NOME). Em outras palavras, o modelo de conte\u00fado \n\n(MODELO_CONTE\u00daDO) lista todas deriva\u00e7\u00f5es aceit\u00e1veis no elemento.   \n\nPara a maioria dos elementos, MODELO_CONTE\u00daDO \u00e9 uma lista de elementos. \n\nTamb\u00e9m podem ser empregas as seguintes palavras-chave:   \n\n #PCDATA (Parsed Character Data) indica que o elemento deve \n\narmazenar apenas texto puro, n\u00e3o contendo marca\u00e7\u00e3o. #PCDATA \u00e9 \n\nfreq\u00fcentemente, mas n\u00e3o apenas, empregado em elementos folha. \n\nElementos folha s\u00e3o elementos que n\u00e3o possuem elementos filho. \n\n EMPTY representa um elemento vazio, sempre indicando um elemento \n\nfolha.   \n\n ANY indica que um elemento pode conter outro elemento declarado na \n\nDTD. \u00c9 raramente utilizada, pois carrega pouca informa\u00e7\u00e3o sobre a \n\n\n\n 27\n\nestrutura. ANY \u00e9 utilizada, em geral, durante o desenvolvimento da DTD, \n\nantes que uma regra precisa tenha sido escrita. Os elementos devem estar \n\ndeclarados na DTD. \n\nO modelo de conte\u00fado que aceita tanto #PCDATA quanto outros elementos \u00e9 \n\ndenominado modelo de conte\u00fado misto. J\u00e1 modelos de conte\u00fado que cont\u00eam apenas \n\nelementos s\u00e3o denominados modelo de conte\u00fado de elemento.   \n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n\n<!DOCTYPE memo [ \n\n<!ELEMENT memo (de, para, cc, data, conteudo) > \n\n<!ELEMENT de (#PCDATA) > \n\n<!ELEMENT para (#PCDATA) > \n\n<!ELEMENT cc (#PCDATA) > \n\n<!ELEMENT data (#PCDATA) > \n\n<!ELEMENT conteudo (p+) > \n\n<!ELEMENT p (#PCDATA) > \n\n]> \n\n<memo> \n\n<de><Francisco</de> \n\n<para>Jo\u00e3o da Silva</para> \n\n<cc>Luis Alberto</cc> \n\n<data>18 de novembro de 1999.</data> \n\n<conteudo><p>Este exemplo mostra a declara\u00e7\u00e3o da DTD e dos elementos que \n\ncomp\u00f5em a estrutura.</p></conteudo> \n\n<p>A XML \u00e9 muito rigorosa quanto as endtags, deve-se ter o cuidado de n\u00e3o \n\nesquece-las</p> \n\n</conteudo> \n\n</memo> \n\nComo citado anteriormente, um elemento pode conter v\u00e1rios filhos. O W3C \n\ndefiniu para as DTDs uma sintaxe bastante pr\u00f3xima das express\u00f5es regulares para \n\ndefinir como se dar\u00e1 esse relacionamento. Essa sintaxe \u00e9 composta de s\u00edmbolos \n\ndenominados indicadores de ocorr\u00eancia e conectores [MARCHAL 00], [HOLZNER \n\n01].  \n\nOs indicadores de ocorr\u00eancia especificam a quantidade de vezes que um elemento \n\nfilho pode aparecer no documento. Os indicadores s\u00e3o o asterisco (*), o sinal de adi\u00e7\u00e3o \n\n(+) e o sinal de interroga\u00e7\u00e3o (?). A sem\u00e2ntica dos indicadores \u00e9 a seguinte: \n\n\n\n 28\n\n um elemento que n\u00e3o seja seguido por um indicador de ocorr\u00eancia deve \n\nocorrer uma, e somente uma, vez  no elemento definido; \n\n um elemento seguido por um indicador + deve ocorrer uma ou mais vezes \n\nno elemento definido. O elemento pode repetir-se; \n\n um elemento seguido por um indicador * pode ocorrer nenhuma ou v\u00e1rias \n\nvezes no elemento definido. O elemento \u00e9 opcional, e se inclu\u00eddo, pode \n\nrepetir-se indefinidamente; \n\n um elemento seguido por um indicador ? pode ocorrer nenhuma ou apenas \n\numa vez no elemento definido. O elemento \u00e9 opcional, e se inclu\u00eddo, n\u00e3o \n\npode repetir-se. \n\nNa fig. 2.6 \u00e9 mostrado o uso de indicadores de ocorr\u00eancia. Os elementos-filho \n\npermitidos para o elemento entry s\u00e3o name, address, tel, faz e email. Com exce\u00e7\u00e3o de \n\nname, os outros filhos s\u00e3o opcionais e podem repetir-se, pois foram sufixados por um \n\nindicador *. J\u00e1 para o elemento address os elementos-filho poss\u00edveis s\u00e3o street, region, \n\npostal-code, locality e country. Nenhum desses elementos-filho pode repetir, mas \n\nregion \u00e9 opcional. \n\n \n\n<!ELEMENT entry (name,address*,tel*,fax*,email*)> \n\n<!ELEMENT address (street,region?,postal-code,locality,country)> \n\nFIGURA 2.6 \u2013 EMPREGO DE INDICADORES DE OCORR\u00caNCIA DTD \n\nOs conectores determinam a ordem na qual os elementos filhos podem aparecer \n\nno documento. Os conectores s\u00e3o os caracteres barra vertical ou pipe (|) e a v\u00edrgula (,). \n\nA sem\u00e2ntica dos conectores \u00e9 a seguinte: \n\n O caractere \u201c,\u201d indica que ambos os elementos, do lado esquerdo e direito \n\nda v\u00edrgula, devem aparecer na mesma ordem no documento.   \n\n O caractere  \u201c|\u201d indica que somente um dos elementos, do lado esquerdo \n\nou direito da barra vertical deve estar presente no documento. \n\n\n\n 29\n\nA fig. 2.7 apresenta um exemplo do uso de conectores, definindo os elementos \n\nname e address. Observando o fragmento de c\u00f3digo da fig. 2.7 e a sem\u00e2ntica dos \n\nconectores apresentada anteriormente, nota-se que elementos-filho poss\u00edveis para o \n\nelemento name s\u00e3o #PCDATA ou first_name ou last_name, isto \u00e9, apenas um dos \n\nelementos listados. Todo o modelo pode-se repetir pelo emprego do indicador de \n\nocorr\u00eancia *. Ainda com rela\u00e7\u00e3o a fig. 2.7, elementos-filho aceit\u00e1veis para address s\u00e3o \n\nstreet, region, postal-code, locality e country, nesta ordem exata. \n\n<!ELEMENT name (#PCDATA | first_name | last_name)*> \n\n<!ELEMENT address (street,region?,postal-code,locality,country)> \n\nFIGURA 2.7 \u2013 EMPREGO DE CONECTORES DTD \n\n\u00c9 v\u00e1lido ressaltar que os v\u00e1rios componentes de um modelo de conte\u00fado misto \n\ndevem sempre estar separados por uma \u201c|\u201d e o modelo deve repetir [MARCHAL 00]. \n\nAssim, uma regra da forma&lt;!ELEMENT name (#PCDATA, fname, lname)> est\u00e1 \n\nincorreta e deve ser substitu\u00edda por&lt;!ELEMENT name (#PCDATA | fname | lname)*>. \n\nCaso as DTDs tornem-se extensas e complexas, a especifica\u00e7\u00e3o XML permite a \n\ninclus\u00e3o de coment\u00e1rios dentro das DTDs. Os coment\u00e1rios na DTD s\u00e3o os mesmos \n\nutilizados nos documentos XML, isto \u00e9, a marca\u00e7\u00e3o&lt;!\u2014coment\u00e1rio -->. \n\n2.4.6.1.2 Declara\u00e7\u00e3o de Atributos \n\nComo j\u00e1 fora discutido, os atributos (Attributes) s\u00e3o pares especiais nome e valor \n\nque podem ser empregados em tags de in\u00edcio e tags vazias para oferecer informa\u00e7\u00f5es \n\nadicionais sobre um elemento. O uso de atributos permite um detalhamento mais claro \n\nna descri\u00e7\u00e3o dos elementos que comp\u00f5em o documento, possibilitando definir nessa \n\ndescri\u00e7\u00e3o algum aspecto do comportamento do elemento ou criar um subtipo [RAY 01].   \n\nPara que um documento XML que utilize atributos seja v\u00e1lido, tais atributos \n\ntamb\u00e9m devem ser declarados em uma DTD. Elementos atributo s\u00e3o declarados com a \n\ncl\u00e1usula ATTLIST. Por exemplo, a declara\u00e7\u00e3o&lt;!ATTLIST tel preferred (true | false) \n\n\u201cfalse\u201d> especifica que a marca\u00e7\u00e3o ATTLIST possui um elemento tel, um atributo \n\n\n\n 30\n\npreferred associado ao tipo (true|false) e um valor padr\u00e3o \u201cfalse\u201d. Para elementos que \n\npossui mais de um atributo, as declara\u00e7\u00f5es podem ser agrupadas como em&lt;!ATTLIST \n\nemail href CDATA #REQUIRED preferred (true | false) \u201cfalse\u201d> [MARCHAL 00]. \n\nApesar de poderem estar dispostos em qualquer posi\u00e7\u00e3o na DTD, para facilitar a \n\nlegibilidade, \u00e9 aconselh\u00e1vel que os atributos estejam imediatamente ap\u00f3s a declara\u00e7\u00e3o \n\ndo elemento correspondente.   \n\nA DTD prov\u00ea um controle mais apurado sobre o conte\u00fado de atributos que sobre \n\no conte\u00fado de elementos. De modo geral os atributos s\u00e3o divididos em tr\u00eas categorias: \n\n String: Cont\u00eam texto&lt;!ATTLIST email href CDATA #REQUIRED> \n\n2.4.6.1.3 Declara\u00e7\u00e3o de Tipo de Documento \n\nA declara\u00e7\u00e3o de tipo de documento (document type declaration) liga uma DTD ao \n\ndocumento. Apesar de similares, os termos  declara\u00e7\u00e3o de tipo de documento (document \n\ntype declaration) e a DTD n\u00e3o representam os mesmos conceitos [MARCHAL 00], \n\n[RAY 01]. A declara\u00e7\u00e3o de tipo de documento possui a seguinte forma:&lt;!DOCTYPE \n\nelemento_raiz uri_da_DTD [ subconjunto_interno ]>. \n\n2.4.6.1.4 DTD interna e externa \n\nAs DTD podem ser internas ou externas. A DTD interna \u00e9 inserida no pr\u00f3prio \n\ndocumento, enquanto que a DTD externa aponta para uma entidade externa. As DTD \n\nexternas e internas diferem na defini\u00e7\u00e3o de par\u00e2metros. A DTD interna \u00e9 inclu\u00edda entre \n\ncolchetes na defini\u00e7\u00e3o de tipo do documento. J\u00e1 a DTD externa \u00e9 armazenada em uma \n\nentidade separada e referenciada atrav\u00e9s da defini\u00e7\u00e3o de tipo do documento. \n\n2.4.6.2 XML Schema \n\n\n\n 31\n\nO modelo DTD apresenta uma s\u00e9rie de desvantagens se comparada a XML \n\nSchema. Primeiramente, a pr\u00f3pria sintaxe DTD possui pouca rela\u00e7\u00e3o com XML e n\u00e3o \n\npode ser validada por um parser XML. Al\u00e9m disso, as declara\u00e7\u00f5es DTD s\u00e3o globais, \n\nimpedindo a exist\u00eancia de nomes id\u00eanticos, mesmo em contextos distintos. Finalmente, \n\nDTDs n\u00e3o podem controlar o tipo de informa\u00e7\u00e3o que um determinando elemento ou \n\natributo do documento XML pode conter. \n\nA modelo XML Schema foi proposto pelo W3C como alternativa para as \n\nlimita\u00e7\u00f5es das DTDs, tendo sido aprovada como recomenda\u00e7\u00e3o em maio de 2001. \n\nEscrita em XML, XML Schema permite tanto elementos globais, como elementos \n\nlocais. Disponibiliza ainda um sistema de tipos de dados, permitindo especificar qual \n\ntipo um determinado elemento deve conter [CASTRO 01]. Muitos dos analisadores \n\nXML, como o embutido no browser MS-Internet Explorer, exigem que um documento \n\nXML seja bem formado, mas n\u00e3o necessariamente v\u00e1lido. Contudo, caso um esquema \n\nesteja dispon\u00edvel ele ser\u00e1 utilizado para validar o documento. \n\n \n\n2.4.7 Folhas de Estilo em XML \n\nA \u00eanfase na cria\u00e7\u00e3o de documentos XML \u00e9 definir uma estrutura para as \n\ninforma\u00e7\u00f5es nele contidas. Assim, os documentos n\u00e3o cont\u00eam nenhum tipo de \n\ninforma\u00e7\u00e3o referente \u00e0 apresenta\u00e7\u00e3o das informa\u00e7\u00f5es, apenas a estrutura e a sem\u00e2ntica \n\n[HOLZNER 01]. Para que, por exemplo, um browser  apresente um documento XML \n\ncorretamente deve ser fornecida uma folha de estilo (stylesheet), respons\u00e1vel pela \n\napar\u00eancia que o documento XML deve ter quando exibido [RAY 01], \n\n[NAKHIMOVSKY 00]. Basicamente, para a cria\u00e7\u00e3o de folhas de estilos pode-se \n\nutilizar modelos de formata\u00e7\u00e3o da CSS19 (Cascading Style Sheets), que \u00e9 a linguagem \n\nde folhas de estilos que surgiu no final de 1996 e \u00e9 utilizada por HTML; ou a XSL20 \n\n(Extensible Style Language), proposta pelo W3C para suprir a car\u00eancia de um modelo \n\nde apresenta\u00e7\u00e3o dos documentos XML.  \n                                                                  \n\n19 O endere\u00e7o http://www.w3.org/Style/CSS/ apresenta a programa\u00e7\u00e3o CSS segundo a vis\u00e3o do W3C \n20 Especificada em http://www.w3.org/Style/XSL/ \n\n\n\n 32\n\nA fig. 2.8 mostra  um documento XML que cont\u00e9m o trecho inicial da obra \u201cOs \n\nSert\u00f5es\u201d, do escritor brasileiro Euclides da Cunha21 e na fig. 2.9 \u00e9 apresentada a \n\nvisualiza\u00e7\u00e3o do documento no browser MS-Internet Explorer 5.5, sem o aux\u00edlio de uma \n\nfolha de estilo. \n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> \n\n<DOCUMENT> \n\n<TITLE>Os Sert&amp;#x00f5;es</TITLE> \n\n&lt;AUTHOR>Euclides da Cunha</AUTHOR> \n\n&lt;SECTION>Nota preliminar</SECTION> \n\n&lt;P> \n\n  Escrito nos raros intervalos de folga de uma carreira fatigante, \n\neste livro, que a princ&amp;#x00ed;pio se resumia &amp;#x00e0; hist&amp;#x00f3;ria da \n\nCampanha de Canudos, perdeu toda a atualidade, remorada a sua \n\npublica&amp;#x00e7;&amp;#x00e3;o em virtude de causas que temos por escusado apontar. \n\n&lt;/P> \n\n&lt;P> Demos lhe, por isto, outra fei&amp;#x00e7;&amp;#x00e3;o, tomando apenas \n\nvariante de assunto geral o tema, a princ&amp;#x00ed;pio dominante, que o sugeriu. \n\n&lt;/P>  \n\n&lt;P> Intentamos esbo&amp;#x00e7;ar, palidamente embora, ante o olhar de \n\nfuturos historiadores, os tra&amp;#x00e7;os atuais mais expressivos das sub-\n\nra&amp;#x00e7;as sertanejas do Brasil. E faz&amp;#x00ea;mo-lo porque a sua \n\ninstabilidade de complexos de fatores m&amp;#x00fa;ltiplos e diversamente \n\ncombinados, aliada &amp;#x00e0;s vicissitudes hist&amp;#x00f3;ricas e \n\ndeplor&amp;#x00e1;vel situa&amp;#x00e7;&amp;#x00e3;o mental em que jazem, as tomam talvez \n\nef&amp;#x00ea;meras, destinadas a pr&amp;#x00f3;ximo desaparecimento ante as \n\nexig&amp;#x00ea;ncias crescentes da civiliza&amp;#x00e7;&amp;#x00e3;o e a \n\nconcorr&amp;#x00ea;ncia material intensiva das correntes migrat&amp;#x00f3;rias que \n\ncome&amp;#x00e7;am a invadir profundamente a nossa terra. \n\n&lt;/P>  \n\n<P> O jagun&amp;#x00e7;o destemeroso, o tabar&amp;#x00e9;u ing&amp;#x00ea;nuo e o \n\ncaipira simpl&amp;#x00f3;rio ser&amp;#x00e3;o em breve tipos relegados &amp;#x00e0;s \n\ntradi&amp;#x00e7;&amp;#x00f5;es evanescentes, ou extintas. \n\n&lt;/P>  \n\n</DOCUMENT> \n\nFIGURA 2.8 \u2013 DOCUMENTO XML SERTOES.XML \n\n                                                                  \n21 Dispon\u00edvel em \nhttp://www.bibvirt.futuro.usp.br/acervo/literatura/autores/euclidesdacunha/sertoes/sertoes.html  \n\n\n\n 33\n\n \n\nFIGURA 2.9 \u2013 BROWSER MS-INTERNET EXPLORER APRESENTANDO UM DOCUMENTO XML \nSEM FOLHA DE ESTILO ASSOCIADA \n\n2.4.7.1 CSS \n\nAs folhas de estilo CSS (Cascading Style Sheets) s\u00e3o constitu\u00eddas por listas de \n\nregras de estilo [HOLZNER 01], sendo tal lista ligada a um documento para indicar \n\ncomo os elementos contidos no documento devem ser apresentados. Uma regra consiste \n\nem um seletor, especificando o elemento ou elementos aos quais a regra deve ser \n\naplicada e a regra propriamente dita. Tal regra \u00e9 delimitada entre chaves, isto \u00e9, { e }; \n\nsendo composta por propriedades a serem estilizadas  e os valores que devem ser \n\naplicados na estiliza\u00e7\u00e3o. Um seletor pode possuir v\u00e1rias propriedades estilizadas numa \n\n\u00fanica linha de comando, bastando para isso separar cada propriedade com um caractere \n\nde \"ponto-e-v\u00edrgula\". A fig. 2.10, apresenta estilo.css, uma folha de estilo para formatar \n\no documento XML mostrado na fig. 2.8, da se\u00e7\u00e3o 2.4.7. \n\n\n\n 34\n\nTITLE {display: block; font-family: sans-serif; font-size: 34 pt; font-weight: \n\nbold; Text-align: center; text-decoration: underline; background-color: \n\n#ddffff} \n\nAUTHOR {display: block; font-size: 18 pt; font-weight: bold; \n\n Text-align: center } \n\nSECTION {display: block; font-size: 16 pt; font-weight: bold; \n\n Text-align: center; font-style: italic} \n\nP {display: block; margin-top: 10} \n\nFIGURA 2.10 \u2013 FOLHA DE ESTILO ESTILO.CSS PARA O DOCUMENTO SERTOES.XML \n\nA folha de estilo (arquivo css) deve ser ligada ao documento XML. Essa liga\u00e7\u00e3o \u00e9 \n\nfeita atrav\u00e9s da instru\u00e7\u00e3o de processamento&lt;?xml-stylesheet?>, setando-se o atributo \n\ntype para \u201ctext/css\u201d e o atributo href como o URI da folha de estilo, conforme destacado \n\nna fig. 2.11. \n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> \n\n<?xml-stylesheet type=\u201dtext/css\u201d href=\u201destilo.css\u201d?> \n\n<DOCUMENT> \n\n<TITLE>Os Sert&amp;#x00f5;es</TITLE> \n\n&lt;AUTHOR>Euclides da Cunha</AUTHOR> \n\n&lt;SECTION>Nota preliminar</SECTION> \n\n&lt;P> Escrito nos raros intervalos de folga de uma carreira fatigante, \n\neste livro, que a princ&amp;#x00ed;pio se resumia &amp;#x00e0; hist&amp;#x00f3;ria da \n\nCampanha de Canudos, perdeu toda a atualidade, remorada a sua \n\npublica&amp;#x00e7;&amp;#x00e3;o em virtude de causas que temos por escusado apontar. \n\n&lt;/P> \n\n&lt;P> Demos lhe, por isto, outra fei&amp;#x00e7;&amp;#x00e3;o, tomando apenas \n\nvariante de assunto geral o tema, a princ&amp;#x00ed;pio dominante, que o sugeriu. \n\n&lt;/P>  \n\n&lt;P> Intentamos esbo&amp;#x00e7;ar, palidamente embora, ante o olhar de \n\nfuturos historiadores, os tra&amp;#x00e7;os atuais mais expressivos das sub-\n\nra&amp;#x00e7;as sertanejas do Brasil. E faz&amp;#x00ea;mo-lo porque a sua \n\ninstabilidade de complexos de fatores m&amp;#x00fa;ltiplos e diversamente \n\ncombinados, aliada &amp;#x00e0;s vicissitudes hist&amp;#x00f3;ricas e eplor&amp;#x00e1;vel \n\nsitua&amp;#x00e7;&amp;#x00e3;o mental em que jazem, as tomam talvez ef&amp;#x00ea;meras, \n\ndestinadas a pr&amp;#x00f3;ximo desaparecimento ante as exig&amp;#x00ea;ncias \n\ncrescentes da civiliza&amp;#x00e7;&amp;#x00e3;o e a concorr&amp;#x00ea;ncia material \n\nintensiva das correntes migrat&amp;#x00f3;rias que come&amp;#x00e7;am a invadir \n\nprofundamente a nossa terra. \n\n&lt;/P> \n\n\n\n 35\n\n&lt;P> O jagun&amp;#x00e7;o destemeroso, o tabar&amp;#x00e9;u ing&amp;#x00ea;nuo e o \n\ncaipira simpl&amp;#x00f3;rio ser&amp;#x00e3;o em breve tipos relegados &amp;#x00e0;s \n\ntradi&amp;#x00e7;&amp;#x00f5;es evanescentes, ou extintas. \n\n&lt;/P>  \n\n</DOCUMENT> \n\nFIGURA 2.11 \u2013 LIGA\u00c7\u00c3O DA FOLHA DE ESTILO ESTILO.CSS COM O DOCUMENTO XML \nSERTOES.XML \n\n \n\nFIGURA 2.12 \u2013 BROWSER MS-INTERNET EXPLORER APRESENTANDO DOCUMENTO XML \nFORMATADO POR FOLHA DE ESTILO CSS \n\n2.4.7.2 XSL \n\nA abordagem CSS \u00e9 ideal para controlar como os diferentes elementos de um \n\ndocumento s\u00e3o apresentados, mas n\u00e3o prov\u00ea um controle satisfat\u00f3rio sobre o que ser\u00e1 \n\nexibido e em que ordem. Para tratar essa car\u00eancia o W3C definiu XSL (Extensible Style \n\n\n\n 36\n\nLanguage), uma linguagem que permite transformar documentos XML, estando apta a \n\nadicionar, remover ou reordenar elementos desses documentos [NAKHIMOVSKY 00]. \n\n De modo geral,  XSL foi projetada para controlar a produ\u00e7\u00e3o de um documento \n\nXML para a tela, p\u00e1gina impressa ou qualquer outro esquema de exibi\u00e7\u00e3o \n\nbidimensional. A filosofia da XSL baseia-se na \u201cliga\u00e7\u00e3o tardia\u201d do conte\u00fado de um \n\ndocumento e sua \u201crenderiza\u00e7\u00e3o\u201d22, que preferencialmente deve ocorrer no momento da \n\napresenta\u00e7\u00e3o do documento [MCGRATH 98]. A fig. 2.13 mostra a intera\u00e7\u00e3o que ocorre \n\nentre o documento XML e as folhas de estilo, definindo que tipo de sa\u00edda ser\u00e1 produzida \n\n[MCGRATH 98].  \n\nA abordagem de \u201cliga\u00e7\u00e3o tardia\u201d entre conte\u00fado/apresenta\u00e7\u00e3o adotada pela XSL \n\npossui benef\u00edcios significantes, tais como [MCGRATH 98]: \n\n Incremento de produtividade e capacidade de manuten\u00e7\u00e3o, pois, a \n\napar\u00eancia de um documento (ou milhares de documentos) pode ser \n\nfacilmente modificada simplesmente alterando-se uma \u00fanica folha de \n\nestilo; \n\n Flexibilidade, sendo permitidas m\u00faltiplas formas de apresenta\u00e7\u00e3o \n\nbaseadas em um \u00fanico documento fonte. S\u00e3o poss\u00edveis, at\u00e9 mesmo, \n\nrearranjos do conte\u00fado para a gera\u00e7\u00e3o de vis\u00f5es diferenciadas da \n\ninforma\u00e7\u00e3o; \n\n Facilidade ancorada na independ\u00eancia existente entre o conte\u00fado de \n\num documento e sua forma de apresenta\u00e7\u00e3o. Opera\u00e7\u00f5es tais como \n\npesquisa, coleta ou rearranjo do conte\u00fado podem ser executadas sem \n\npreocupa\u00e7\u00e3o pertinente \u00e0 como a informa\u00e7\u00e3o de formata\u00e7\u00e3o estaria \n\nmesclada ao conte\u00fado. \n\n                                                                  \n22 Produzir uma imagem gr\u00e1fica a partir de um arquivo de dados em um dispositivo de sa\u00edda, como um \nmonitor de v\u00eddeo ou impressora \n\n\n\n 37\n\nDocumento(s)\nXML\n\nFolha de\nEstilo XSL\n\nProcessador\nXSL\n\nHTML\n\nRTF\n\nTeX\n\n...\n\n \n\nFIGURA 2.13 \u2013 INTERA\u00c7\u00c3O DO DOCUMENTO XML COM AS FOLHAS DE ESTILO XSL \n\nApesar folhas de estilo CSS serem bastante populares, principalmente no meio \n\nHTML, a XML \u00e9 mais flex\u00edvel e poderosa, sendo as pr\u00f3prias folhas de estilo XSL \n\ndocumentos XML bem formados. Ao contr\u00e1rio da CSS, que permite apenas a defini\u00e7\u00e3o \n\ndo formato e posicionamento dos elementos, a XSL pode reordenar completamente os \n\nelemento de um documento, exibindo ou ocultando, selecionando estilos com base nos \n\nelementos, seus atributos e localiza\u00e7\u00e3o. A core expression language da XSL \u00e9 \n\nextremamente flex\u00edvel, baseada na linguagem Scheme  (um dialeto da linguagem LISP), \n\npossuindo recursos para c\u00e1lculos, teste de condi\u00e7\u00f5es e outros. \n\nA sem\u00e2ntica da maior parte dos elementos de XSL \u00e9 baseada em uma combina\u00e7\u00e3o \n\nda DSSSL (Document Style Semantics and Specification Language), definida pelo \n\npadr\u00e3o ISO/IEC 10179:1996 e das CSS.  \n\nBasicamente, a XSL pode ser tratada como a uni\u00e3o de duas linguagens, que \n\npodem ser empregadas de forma independente, a linguagem de transforma\u00e7\u00e3o e a \n\nlinguagem de formata\u00e7\u00e3o. \n\n\n\n 38\n\nA linguagem de transforma\u00e7\u00e3o \u00e9 normalmente referenciada como XSLT (XSL \n\nTransformations) e tornou-se uma recomenda\u00e7\u00e3o W3C desde novembro de 199923. \n\nContudo, como \u00e9 uma especifica\u00e7\u00e3o relativamente recente e ainda em desenvolvimento, \n\no suporte XSLT oferecido pelos muitos dos browsers \u00e9 limitado.    \n\nAs marca\u00e7\u00f5es de um documento XML podem ser inteiramente manipuladas com a \n\nXSLT. O processo de transforma\u00e7\u00e3o XSLT envolve dois documentos: o documento a \n\nser transformado e a folha de estilo que determina as transforma\u00e7\u00f5es a serem aplicadas. \n\nA transforma\u00e7\u00e3o em si pode ocorrer de tr\u00eas modos distintos: \n\n Server side. Uma aplica\u00e7\u00e3o executando no servidor, como um servlet java, \n\npode aplicar automaticamente uma folha de estilo transformando um \n\ndocumento e fornecendo esse documento transformado aos clientes.  \n\n Client side. Uma aplica\u00e7\u00e3o cliente, como um browser, pode realizar a \n\ntransforma\u00e7\u00e3o, lendo a folha de estilo e aplicando-a ao documento que est\u00e1 \n\nsendo carregado para exibi\u00e7\u00e3o. \n\n Stand alone. Aplica\u00e7\u00f5es independentes (n\u00e3o embutidas num browser), \n\ngeralmente escritas em java, efetuam a transforma\u00e7\u00e3o. \n\nXSL \u00e9 composta por tr\u00eas \u00e1reas modulares:  \n\na) padr\u00f5es XSL: define uma sintaxe de padr\u00f5es, os quais identificam nodos dentro \n\nde um documento XML, fornecendo um recurso semelhante \u00e0 cl\u00e1usula where da \n\nStructured Query Language (SQL) definida no padr\u00e3o ISO/IEC 9075:1999.  \n\nb) \u201cxsl\u201d namespace : as transforma\u00e7\u00f5es de XSL s\u00e3o expressas como um espa\u00e7o \n\nde nomes XML, o qual controla a materializa\u00e7\u00e3o dos resultados da consulta como um \n\ndocumento XML;  \n\nc) \u201cfo\u201d namespace : os recursos de formata\u00e7\u00e3o de XSL s\u00e3o expressos como uma \n\ngram\u00e1tica XML.  \n\n                                                                  \n23 Dispon\u00edvel em www.w3.org/TR/xslt \n\n\n\n 39\n\nA sintaxe dos padr\u00f5es XSL \u00e9 simples, embora forne\u00e7a poderosos recursos de \n\nconsulta. O seu objetivo \u00e9 identificar um subconjunto de um documento XML, baseado \n\nem cadeias de ascend\u00eancia, caracteres coringa (wildcards) e qualificadores, tais como os \n\nvalores de testes dos atributos. A sintaxe \u00e9 concisa e modelada por meio de m\u00e9todos \n\nfamiliares de navega\u00e7\u00e3o em diret\u00f3rios. Sendo uma sintaxe baseada em strings, ela reside \n\ndentro dos valores dos atributos, linguagens de script e URLs.  \n\nO namespace xsl define um conjunto de comandos que permite a materializa\u00e7\u00e3o \n\ndos resultados da consulta como XML \u2013 na mesma gram\u00e1tica, em uma gram\u00e1tica \n\ndiferente ou em uma gram\u00e1tica de apresenta\u00e7\u00e3o, tal como HTML. Um documento XSL \n\ncont\u00e9m elementos do namespace xsl, que podem:  \n\na) definir um modelo (template) para constru\u00e7\u00e3o de uma parte do documento de \n\nsa\u00edda;  \n\nb) preencher o modelo com dados da fonte XML;  \n\nc) associar esse modelo a uma consulta;  \n\nd) agrupar um conjunto dessas associa\u00e7\u00f5es consulta-modelo juntos para aninhar \n\num processamento recursivo  \n\ne) filtrar e classificar os resultados das consultas.  \n\nOs recursos de formata\u00e7\u00e3o de XSL s\u00e3o expressos por uma gram\u00e1tica XML \u2013 o \n\nnamespace fo \u2013 totalmente independente do processo de transforma\u00e7\u00e3o.  \n\n2.4.8 Xlinks e Xpointers \n\nUm dos fatores de sucesso naturais da Web est\u00e1 na sua capacidade natural de \n\nliga\u00e7\u00e3o de recursos. Por\u00e9m, a estrutura de liga\u00e7\u00e3o simples e unidirecional da Web n\u00e3o \u00e9 \n\nsuficiente para atender os novos requisitos advindos de XML. Isso motivou o W3C a \n\npropor uma solu\u00e7\u00e3o de liga\u00e7\u00e3o em XML denominada XLink (XML Linking Language). \n\n\n\n 40\n\nAs especifica\u00e7\u00f5es XPointer e XLinks, atualmente em desenvolvimento, \n\nintroduzem um modelo de liga\u00e7\u00e3o para XML. Em XLink, um link expressa um \n\nrelacionamento entre recursos, que podem ser qualquer local (um elemento, o seu \n\nconte\u00fado, ou uma parte do seu conte\u00fado, por exemplo) que \u00e9 endere\u00e7\u00e1vel em link. A \n\nnatureza exata do relacionamento entre os recursos dependente da aplica\u00e7\u00e3o que \n\nprocessa o link e da informa\u00e7\u00e3o sem\u00e2ntica fornecida. O objetivo do XPointer \u00e9 apontar \n\npara o elemento correto no documento XML alvo. \n\nOs links XML permitem que o usu\u00e1rio controle a conduta muito mais estritamente \n\ne fornecendo suporte para links de m\u00e3o dupla e multidirecionais por meio do conceito \n\nout-of-line. \n\nA XML-Link foi constru\u00edda a partir de id\u00e9ias do HTML, por isso n\u00e3o h\u00e1 nem um \n\nproblema em incluir um link a um documento XML dentro de uma p\u00e1gina HTML. \n\nAmbos os links t\u00eam a mesma apar\u00eancia conforme mostrado abaixo: \n\n&lt;a href=http://www.anothersite.org/pub/doc3.xml> \n<a href=http://www.anothersite.org/pub/doc3.xml#section2> \n\nA especifica\u00e7\u00e3o do atributo HREF da XML \u00e9 projetada para interoperar com a \n\nHTML. Ela consiste em uma URL, opcionalmente seguida de ? ou uma query, ou ainda \n\num # ou / e um identificador fragmentado, cuja interpreta\u00e7\u00e3o depende do tipo de recurso \n\nreferido pelo URL. \n\nDentre as caracter\u00edsticas destac\u00e1veis do XML-link pode-se citar a facilidade de \n\nqualquer elemento indicar a exist\u00eancia de um link, fornece r\u00f3tulos intelig\u00edveis para \n\nm\u00e1quinas e seres humanos.  \n\nEspecificando condutas para quando os links s\u00e3o exibidos e processados ou ainda \n\natravessados. \n\nAceitando grupos de links estendidos e com canais m\u00faltiplos finais. \n\nUma aplica\u00e7\u00e3o importante est\u00e1 em sistemas de hipertexto (hypertext). \n\nXLinks podem residir dentro ou fora dos documentos em que os recursos residam. \n\n\n\n 41\n\n2.4.9 An\u00e1lise de Dados XML:SAX e DOM \n\nA chave para processar qualquer dado XML \u00e9 o parser XML, o software que l\u00ea \n\ndados XML e disponibiliza tais dados para outros softwares. O parser prov\u00ea uma API \n\nque permite ao programador adicionar c\u00f3digo para manipular os dados, geralmente \n\nestruturados como uma \u00e1rvore [GRAHAM 00], [NAKHIMOVSKY 00]. \n\nExistem basicamente dois tipos de parsers XML: validadores e n\u00e3o-validadores. \n\nOs validadores l\u00eaem tanto o documento XML quanto o DTD associado, testando a \n\nestrutura de marca\u00e7\u00e3o do documento com rela\u00e7\u00e3o \u00e0s regras gramaticais definidas no \n\nDTD. Documentos inconsistentes com o DTD ser\u00e3o recusados e o processamento \n\nabortado. J\u00e1 os parsers n\u00e3o-validadores n\u00e3o utilizam DTD e n\u00e3o validam o documento \n\nXML, apenas checam se o documento \u00e9 bem formado. Tecnicamente, um parser n\u00e3o- \n\nvalidador n\u00e3o ignora completamente o conte\u00fado de um DTD associado a um documento \n\nXML. Na verdade, o parser n\u00e3o-validador processar\u00e1 o conte\u00fado do DTD que ele \n\npuder, ignorando apenas as partes que ele n\u00e3o consiga analisar. \n\nNormalmente browsers Web que podem processar XML possuem parsers n\u00e3o-\n\nvalidadores embutidos ou sen\u00e3o s\u00e3o equipados com parsers que podem trabalhar tanto \n\nno modo validador quanto n\u00e3o-validador. \n\nDada a exist\u00eancia do parser XML, surge a problem\u00e1tica da integra\u00e7\u00e3o do mesmo \n\ncom a aplica\u00e7\u00e3o XML, que realmente far\u00e1 uso dos dados XML disponibilizados pelo \n\nparser.  \n\nDuas interfaces de programa\u00e7\u00e3o v\u00eam polarizando a escrita de parsers XML, \n\nsendo cada uma dessas solu\u00e7\u00f5es voltada para uma classe espec\u00edfica de problemas. Tais \n\ninterfaces s\u00e3o SAX (Simple Application programming interface for Xml) e DOM \n\n(Document Object Model). \n\nSAX foi projetado por David Megginson24, fora do W3C. SAX \u00e9 simples, \n\nconstituindo uma ferramenta comum para processamento XML, sendo amplamente \n\nsuportado por v\u00e1rios softwares XML comerciais e n\u00e3o-comerciais. A filosofia do SAX \n                                                                  \n\n24 www.megginson.com \n\n\n\n 42\n\nest\u00e1 baseada em eventos: o parser reporta eventos diretamente para a aplica\u00e7\u00e3o atrav\u00e9s \n\nde fun\u00e7\u00f5es de callback registradas. As fun\u00e7\u00f5es de callback atuam como manipuladores \n\nde evento (event handlers) para diferentes eventos, similarmente ao que ocorre com \n\nmanipuladores de evento em interfaces gr\u00e1ficas que respondem \u00e0s a\u00e7\u00f5es do \n\nusu\u00e1rio.Como ilustra\u00e7\u00e3o, a fig. 2.14, detalhe (a), exibe um documento XML bastante \n\nsimples e a fig. 2.14, detalhe (b), a seq\u00fc\u00eancia de eventos reportados por uma aplica\u00e7\u00e3o \n\nbaseada em SAX. \n\n(a) \n\n<?xml version=\u201d1.0\u201d encoding=\u201disso-8859-1\u201d?> \n\n<PRINCIPAL> \n\n<PARTE> Uma parte&lt;/PARTE> \n\n<\u00daNICO/> \n\n</PRINCIPAL> \n\n(b) \n\nEvento: In\u00edcio do documento \n\nEvento: Elemento inicial:&lt;PRINCIPAL> \n\nEvento: texto string [\\0a] \n\nEvento: texto string [ ] \n\nEvento: Elemento inicial:&lt;PARTE> \n\nEvento: texto string [Uma parte] \n\nEvento: Elemento final:&lt;PARTE> \n\nEvento: texto string [\\0a] \n\nEvento: texto string [ ] \n\nEvento: Elemento inicial:&lt;UNICO> \n\nEvento: Elemento final:&lt;UNICO> \n\nEvento: texto string [\\0a] \n\nEvento: Elemento final:&lt;PRINCIPAL> \n\nEvento: Fim do documento \n\nFIGURA 2.14 \u2013 UM DOCUMENTO XML E SEQ\u00dc\u00caNCIA DE EVENTOS SAX \n\nA abordagem orientada a eventos do SAX \u00e9 \u00fatil para processamento de uma \u00fanica \n\npassagem no documento XML, mas n\u00e3o \u00e9 ideal para manipula\u00e7\u00e3o repetitiva dos dados \n\ndo documento em mem\u00f3ria. Nesse aspecto, o DOM25, padronizado pelo W3C, \n\nespecifica um meio para tratar um documento XML como uma \u00e1rvore de n\u00f3s carregada \n\nem mem\u00f3ria para processamento. No modelo DOM, cada item de dado discreto \u00e9 \n\nconsiderado um n\u00f3 e os elementos filho ou o texto inclu\u00eddo tornam-se sub-n\u00f3s \n                                                                  \n\n25 www.w3.org/DOM \n\n\n\n 43\n\n[HOLZNER 01]. DOM permite a reconstru\u00e7\u00e3o completa de um documento XML de \n\nentrada e prov\u00ea acesso a qualquer parte do documento, suportando m\u00e9todos \n\npadronizados manipular e modificar o documento original. \n\nClaramente, o DOM \u00e9 mais poderoso que SAX, contudo aplica\u00e7\u00f5es baseadas em \n\nDOM tendem a consumir mais recursos de mem\u00f3ria do computador e executam mais \n\nlentamente quando comparadas a aplica\u00e7\u00f5es SAX [GRAHAM 00], principalmente se o \n\ndocumento XML de entrada for grande, visto que DOM mant\u00e9m o documento inteiro \n\nem mem\u00f3ria.  \n\n\u00c9 interessante notar que uma abordagem pode ser implementada utilizando os \n\nrecursos fornecidos por outra: eventos SAX podem ser gerados pelo caminhamento em \n\num objeto DOM assim como um objeto DOM pode ser gerado pela manipula\u00e7\u00e3o \n\napropriada de eventos SAX [NAKHIMOVSKY 00]. \n\n2.4.10 Consulta a Documentos XML com XPath \n\nOs parsers discutidos na se\u00e7\u00e3o anterior proporcionam um meio b\u00e1sico para \n\nacessar informa\u00e7\u00f5es em documentos XML. Contudo, para muitas aplica\u00e7\u00f5es necessita-\n\nse de um m\u00e9todo mais poderoso para extra\u00e7\u00e3o dessas informa\u00e7\u00f5es. Assim, XPath prov\u00ea \n\numa linguagem estendida de consulta para extrair partes de documentos XML. As \n\nconsultas XPath descrevem um \u201ccaminho\u201d na estrutura de \u00e1rvore gerada pelo parser \n\nDOM a partir do documento XML original. \n\nPara exemplificar, a consulta /descendant::ds::Service[@rdf:about=ID] seleciona \n\numa certa descri\u00e7\u00e3o de elemento em um documento XML. O eixo descendant indica \n\nque a pesquisa deve ocorrer em qualquer dire\u00e7\u00e3o abaixo do n\u00f3 atual (nesse caso o n\u00f3 \n\nraiz). Ap\u00f3s ::  segue-se o nome do n\u00f3 desejado, nessa consulta Service. Finalmente, \n\nenvolto por colchetes tem-se um predicado de filtro, indicando para selecionar apenas \n\nn\u00f3s com o atributo rdf:about que tenham um valor ID. \n\n2.4.11 Padr\u00f5es de Mercado Oriundos de XML \n\n\n\n 44\n\nXML \u00e9 uma sintaxe de baixo n\u00edvel para representa\u00e7\u00e3o de dados estruturados. \n\nLogo, essa simples sintaxe pode ser empregada para suportar uma grande variedade de \n\naplica\u00e7\u00f5es espec\u00edficas. Atualmente, existe uma s\u00e9rie de padr\u00f5es de mercado, \n\ndesenvolvidos a partir de XML, visando estabelecer um formato \u00fanico e uma interface \n\npadronizada para troca de documentos entre diferentes institui\u00e7\u00f5es pertencentes aos \n\nmais diversos segmentos de atividade [FURGERI 01]. Como n\u00e3o h\u00e1 um controle \n\nefetivo, muitos acr\u00f4nimos foram adotados por segmentos mercadol\u00f3gicos distintos, \n\ngerando conflitos, como por exemplo MML.  \n\nFora do \u00e2mbito da W3C, muitos grupos tamb\u00e9m se dedicam \u00e0 defini\u00e7\u00e3o de novos \n\nformatos para troca de informa\u00e7\u00f5es. O n\u00famero de aplica\u00e7\u00f5es XML cresce rapidamente, \n\nem diversas \u00e1reas como finan\u00e7as, assuntos governamentais, telecomunica\u00e7\u00f5es e \n\nmedicina, dentre outras.  Alguns dos padr\u00f5es definidos s\u00e3o: \n\n MathML \u2013 Mathematical Markup Language utilizada para descri\u00e7\u00e3o de \n\nf\u00f3rmulas matem\u00e1ticas; \n\n SVG  - Scalable Vector Graphics define um conjunto de delimitadores XML \n\npara gr\u00e1ficos, projetados para inclus\u00e3o em HTML e outros documentos. De \n\nmodo similar, outros conjuntos de delimitadores padr\u00e3o XML para aplica\u00e7\u00f5es \n\nespec\u00edficas tamb\u00e9m s\u00e3o candidatas a inclus\u00e3o em documentos HTML; \n\n MML \u2013 Medic Markup Language utilizada para a troca de informa\u00e7\u00f5es entre \n\ndiferentes instiui\u00e7\u00f5es; \n\n MML \u2013 Music Markup Language para eventos musicais; \n\n SMIL - Linguagem de Integra\u00e7\u00e3o de Multim\u00eddia Sincronizada (SMIL) \u00e9 uma \n\naplica\u00e7\u00e3o XML consistindo de uma linguagem declarativa para planejar \n\napresenta\u00e7\u00f5es multim\u00eddia pela Web; \n\n CML \u2013 Chimical Markup Language para descri\u00e7\u00e3o textual e gr\u00e1fica de \n\nf\u00f3rmulas qu\u00edmicas; \n\n ComicsML \u2013 Comics Markup Language, padr\u00f5es de cria\u00e7\u00e3o de hist\u00f3rias em \n\nquadrinhos; \n\n\n\n 45\n\n AML - Astronomical  Markup Language  para padroniza\u00e7\u00e3o de elementos \n\nastron\u00f4micos; \n\n RDF - Resource Description Format desenvolvido pelo grupo de trabalho de \n\natividades em metadados da W3C. Ele utiliza um modelo de dados simples \n\nexpresso em sintaxe XML como a base de uma linguagem para representar \n\npropriedades de recursos na Web, como imagens, documentos e \n\nrelacionamentos mantidos entre estes. A Plataforma para Sele\u00e7\u00e3o de Conte\u00fado \n\nna Internet (PICS) foi redefinida em RDF. A estrutura da PICS fornece um \n\nm\u00e9todo para inser\u00e7\u00e3o de r\u00f3tulos a diferentes materiais (indicando, por \n\nexemplo, se aquele conte\u00fado \u00e9 apropriado para crian\u00e7as). \n\n \n\n\n\n 46\n\n3. Linguagem Java \n\nJava \u00e9 uma linguagem concisa e port\u00e1vel, implementando recursos de imagens \n\ngr\u00e1ficas, GUI (Graphical User Interface), tratamento de exce\u00e7\u00e3o, multithreading, \n\nmultim\u00eddia, acesso a banco de dados, computa\u00e7\u00e3o distribu\u00edda e rede cliente/servidor \n\nbaseada na Internet e World Wide Web(WWW). Java vem se solidificando no mercado \n\ncomo uma das principais linguagens de programa\u00e7\u00e3o de prop\u00f3sito geral [DEITEL 01]. \n\nLinguagens que fornecem suporte a programa\u00e7\u00e3o orientada a objetos (OO) \n\nestabeleceram uma posi\u00e7\u00e3o de destaque em meados da d\u00e9cada de 90. Java \u00e9 uma das  \n\nlinguagens recentes projetadas para suportar OO [ECKEL 01], que apesar de n\u00e3o aceitar \n\noutros paradigmas, ainda emprega algumas estruturas b\u00e1sicas e possui similaridades \n\ncom as linguagens imperativas das quais descende [SEBESTA 00].  \n\n3.1 Origens \n\nJava, similarmente ao que aconteceu com uma s\u00e9rie de outras linguagens de \n\nprograma\u00e7\u00e3o, foi projetada para ser aplicada em um dom\u00ednio de problema que parecia \n\nn\u00e3o possuir ainda uma linguagem de programa\u00e7\u00e3o adequada [SEBESTA 00]. Esse \n\ndom\u00ednio consistia em sistemas embutidos (embedded systems) para dispositivos \n\neletr\u00f4nicos de consumo em massa [GOSLING 96], como fornos microondas e sistemas \n\nde TV interativos. A confiabilidade era considerada uma quest\u00e3o importante para o \n\nsoftware dos produtos eletr\u00f4nicos de consumo. Reconhecendo o grande potencial dessa \n\n\u00e1rea, em 1991 a Sun Microsystems financiou uma pesquisa corporativa interna com o \n\ncodinome Green [DEITEL 01]. Inicialmente, a empresa considerou o uso de linguagens \n\nj\u00e1 tradicionais como C e C++, mas nenhuma delas mostrou-se inteiramente satisfat\u00f3ria \n\npara a implementa\u00e7\u00e3o dos softwares de dispositivos eletr\u00f4nicos: C era pequena, por\u00e9m \n\nsem suporte a orienta\u00e7\u00e3o a objetos e C++ era orientada a objetos, por\u00e9m excessivamente \n\ngrande e complexa [SEBESTA 00]. \n\nNorteando-se nos princ\u00edpios de confiabilidade, simplicidade e suporte a OO \n\n[SEBESTA 00], o projeto Green propiciou o desenvolvimento de uma linguagem \n\n\n\n 47\n\nbatizada pelo projetista-chefe James Gosling26, em homenagem ao carvalho que podia \n\nser visto da janela de seu escrit\u00f3rio na Sun, como Oak [GOSLING 96]. Mais tarde \n\ndescobriu-se a exist\u00eancia de uma outra linguagem tamb\u00e9m chamada Oak. Ent\u00e3o, uma \n\nequipe da Sun que visitava  um caf\u00e9 local sugeriu o nome Java27 referenciando a cidade \n\nde origem de um caf\u00e9 importado [DEITEL 01]. \n\nAp\u00f3s atravessar um per\u00edodo de dificuldades [DEITEL 01], o projeto Green \n\nencontrou na World Wide Web um vasto campo para aplica\u00e7\u00e3o da novata linguagem \n\nJava : o desenvolvimento de p\u00e1ginas Web com conte\u00fado din\u00e2mico. A Sun apresentou \n\nformalmente a vers\u00e3o alfa da linguagem em maio de 1995 em uma renomada \n\nconfer\u00eancia. \n\nMais tarde, em janeiro de 1996, a vers\u00e3o 1.0 de Java foi liberada. Quase um ano \n\ndepois, em dezembro de 1996, uma nova vers\u00e3o, denominada 1.1, foi disponibilizada e \n\nenglobava v\u00e1rios recursos como acesso a bancos de dados (JDBC), chamadas remotas \n\n(RMI), serializa\u00e7\u00e3o e uma arquitetura de componentes (Java Beans). \n\n3.2 Caracter\u00edsticas \n\nSegundo a Sun Microsystems [FLANAGAN 97], Java pode ser definida como \n\numa \u201clinguagem simples, orientada a objetos, com tipagem forte, interpretada, \n\nindependente de plataforma, multithreaded, com coleta de lixo, robusta, segura, \n\nextens\u00edvel e estruturada\u201d. \n\n 3.2.1 Simples \n\nJava apresenta grande similaridade com outras linguagens bastante difundidas. A \n\nsemelhan\u00e7a sint\u00e1tica com C/C++ \u00e9 evidente, enquanto o modelo de objetos e de \n                                                                  \n\n \n26 James Gosling, projetista-chefe da linguagem Java, era ent\u00e3o conhecido por ter projetado o editor UNIX emacs e a \ninterface de janelas NeWs \n \n27 Java \u00e9 uma meton\u00edmia usada para referenciar o caf\u00e9 nos EUA, tendo nascido quando a importa\u00e7\u00e3o de caf\u00e9 para o \npa\u00eds provinha principalmente da Indon\u00e9sia e uma c\u00e9lebre ilha vulc\u00e2nica da Indon\u00e9sia chama-se Java. \n\n\n\n 48\n\nexecu\u00e7\u00e3o foi baseado em Smalltalk e Simula 67 [SEBESTA 00]. Tais aspectos fazem \n\ncom que um programador j\u00e1 familiarizado com qualquer uma dessas linguagens tenha \n\nmaior facilidade e rapidez para aprender Java. \n\nV\u00e1rias outras linguagens mais poderosas que C++ foram projetadas nos \u00faltimos \n\nanos, mas n\u00e3o atra\u00edram a mesma aten\u00e7\u00e3o. Um grande n\u00famero de empresas e \n\ndesenvolvedores utilizou e ainda utiliza C/C++, existindo uma grande comunidade em \n\ntorno da linguagem. Tal fato levou a Sun a selecionar a linguagem como modelo \n\nsint\u00e1tico/sem\u00e2ntico para Java, de modo que um programador C/C++ pudesse dominar \n\nJava em um espa\u00e7o de tempo mais reduzido. Esta caracter\u00edstica \u00e9 provavelmente uma \n\ndas principais raz\u00f5es que ensejaram a popularidade da linguagem.   \n\nApesar das semelhan\u00e7as, Java n\u00e3o herdou a maioria das complexidades de C++. \n\nTodos os recursos de C++ considerados desnecess\u00e1rios pela Sun (como structs, unions e \n\ntypedef) foram deixados de lado. Assim, Java n\u00e3o possui ponteiros expl\u00edcitos, arquivos \n\nde cabe\u00e7alho, pr\u00e9-processadores, estruturas, uni\u00f5es, matrizes multidimensionais, \n\ngabaritos nem sobrecarga de operadores.  \n\n3.2.2 Orientada a Objetos \n\nJava \u00e9 uma verdadeira linguagem de programa\u00e7\u00e3o orientada a objetos. Tudo \u00e9 \n\nmanipulado como objeto em Java. A \u00fanica exce\u00e7\u00e3o \u00e9 os tipos simples e primitivos como \n\nn\u00fameros e vari\u00e1veis booleanas, que n\u00e3o s\u00e3o objetos por quest\u00f5es de desempenho. \n\nMesmo assim, podem ser encapsulados em objetos quando desej\u00e1vel.   \n\nUma diferen\u00e7a fundamental entre outras linguagens atuais com suporte a \n\norienta\u00e7\u00e3o a objetos, como Ada 95 e C++, e Java \u00e9 que esta \u00faltima n\u00e3o  possibilita a \n\nimplementa\u00e7\u00e3o de subprogramas independentes [SEBESTA 00]. Todos os \n\nsubprogramas s\u00e3o m\u00e9todos e devem necessariamente estar definidos em classes. Toda \n\nvari\u00e1vel ou m\u00e9todo pertence a uma classe ou objeto e s\u00f3 pode ser invocada atrav\u00e9s \n\ndessa classe ou objeto. \n\n\n\n 49\n\nComo dito acima, os programas escritos em Java s\u00e3o organizados em classes, que \n\npodem ser instanciadas para produzir objetos. As classes tamb\u00e9m podem herdar \n\ncaracter\u00edsticas (m\u00e9todos e vari\u00e1veis) de outras classes. Contudo, diferentemente de C++ \n\nJava n\u00e3o prov\u00ea suporte a heran\u00e7a de m\u00faltipla de classes, mas permite que uma classe \n\nimplemente mais de uma interface (ou classe abstrata). A interface pode ser \n\ngrosseiramente conceituada como sendo um tipo especial de classe que n\u00e3o cont\u00e9m \n\ndetalhes de implementa\u00e7\u00e3o. Essa abordagem evita o problema de uma classe herdar \n\ncomportamentos de classes-base que s\u00e3o redundantes, contradit\u00f3rios ou mutuamente \n\nexcludentes. \n\n3.2.3 Interpretada e Independente de Plataforma \n\nUm programa escrito em Java precisa ser compilado antes de ser executado. O \n\ncompilador traduz o c\u00f3digo-fonte e gera arquivos objeto chamados arquivos de classe. \n\nCada programa Java consiste da implementa\u00e7\u00e3o de uma \u00fanica classe. Depois de \n\ncompilado, pode ser executado em qualquer plataforma onde exista um sistema de \n\ntempo de execu\u00e7\u00e3o Java (runtime).  \n\nA compila\u00e7\u00e3o de um programa em C++ realiza a tradu\u00e7\u00e3o do c\u00f3digo-fonte da \n\nlinguagem em instru\u00e7\u00f5es que s\u00e3o interpretadas pelo microprocessador da m\u00e1quina onde \n\nfoi compilado. O programa ent\u00e3o s\u00f3 roda em outra m\u00e1quina que tenha o mesmo tipo de \n\nprocessador. J\u00e1 um programa em Java, quando compilado, gera instru\u00e7\u00f5es (byte-codes) \n\npara um microprocessador virtual. Existem implementa\u00e7\u00f5es desse microprocessador \n\nvirtual para v\u00e1rias plataformas e o programa ent\u00e3o rodar\u00e1 em qualquer uma delas. A fig. \n\n3.1 exibe de maneira esquem\u00e1tica o processo de compila\u00e7\u00e3o de um programa Java. \n\n\n\n 50\n\nInterpretador \nJava(Pentium)\n\nInterpretador \nJava(PowerPC)\n\nInterpretador \nJava(SPARC)\n\ntst\nsts\ntst\nsts\nisi\n\naaaa\n\nbbbb\n\ncccc\n\nCompilador Java(Pentium)\n\nCompilador Java(PowerPC)\n\nCompilador Java(SPARC)\n\nC\u00f3digo da \nM\u00e1quina Java\n\nByteCode\n\nC\u00f3digo-Fonte Java\n\nFIGURA 3.1 \u2013 ESQUEMA DE COMPILA\u00c7\u00c3O JAVA \n\nPor ter suas instru\u00e7\u00f5es interpretadas por um software (processador virtual), os \n\nprogramas em Java s\u00e3o mais lentos que os escritos em C ou C++. A igualdade \u00e9 atingida \n\nusando microprocessadores virtuais com compiladores JIT (Just-In-Time), que j\u00e1 s\u00e3o \n\nbastante comuns. Esse tipo de sistema, converte as instru\u00e7\u00f5es em byte-codes para \n\ninstru\u00e7\u00f5es do microprocessador na hora da execu\u00e7\u00e3o, fazendo com que programas \n\nescritos em Java n\u00e3o tenham grandes perdas de desempenho em rela\u00e7\u00e3o a programas \n\nescritos em C ou C++.  \n\n3.2.4 Robusta \n\nJava \u00e9 uma linguagem com tipagem de dados forte, isto \u00e9, ela exige que os tipos \n\ndos objetos e vari\u00e1veis sejam explicitamente definidos durante a compila\u00e7\u00e3o. O \n\ncompilador n\u00e3o aceita qualquer indefini\u00e7\u00e3o em rela\u00e7\u00e3o ao tipo de dados. Esta \n\ncaracter\u00edstica garante uma maior seguran\u00e7a do c\u00f3digo e o torna menos propenso a erros.  \n\nProgramas em Java n\u00e3o provocam core-dumps ou GPFs (General Protection \n\nFault). Enquanto programas escritos em C ou C++ podem alterar qualquer posi\u00e7\u00e3o da \n\nmem\u00f3ria do computador, os programas escritos na linguagem Java n\u00e3o t\u00eam acesso \n\ndireto \u00e0 mem\u00f3ria e deixam o controle a cargo do sistema operacional.  \n\n\n\n 51\n\nO sistema de gerenciamento de mem\u00f3ria de Java dispensa os programadores da \n\ntarefa de libera\u00e7\u00e3o da mem\u00f3ria usada. Um processo chamado de coletor de lixo \n\n(garbage collector) opera sempre em uma thread de baixa prioridade em background, \n\nliberando automaticamente recursos do ambiente que n\u00e3o s\u00e3o mais utilizados.  \n\nCaso ocorram erros ou situa\u00e7\u00f5es inesperadas, Java possui um meio de lidar com \n\nelas, recuperando-se do erro se poss\u00edvel. O controle de exce\u00e7\u00f5es (condi\u00e7\u00f5es \n\nexcepcionais) \u00e9 uma parte b\u00e1sica da linguagem e, em muitos casos, seu uso \u00e9 \n\nobrigat\u00f3rio.  \n\nEssa gama de recursos confere maior robustez aos programas codificados em \n\nJava, tornando os erros menos freq\u00fcentes e permitindo a detec\u00e7\u00e3o deles nos primeiros \n\nest\u00e1gios do desenvolvimento. Isto resulta em um custo menor de desenvolvimento, \n\nredu\u00e7\u00e3o do n\u00famero de bugs e aplica\u00e7\u00f5es mais confi\u00e1veis.  \n\n3.2.5 Din\u00e2mica \n\nA linguagem Java foi projetada para se adaptar a um ambiente din\u00e2mico, em \n\nconstante evolu\u00e7\u00e3o. Possui uma representa\u00e7\u00e3o de tempo de execu\u00e7\u00e3o que permite ao \n\nprograma saber a classe a que pertence um objeto, no momento em que o recebe, \n\ndurante a execu\u00e7\u00e3o. Isso permite a inclus\u00e3o din\u00e2mica de classes que podem estar \n\narmazenadas em qualquer m\u00e1quina remota.  \n\nJava tamb\u00e9m suporta a integra\u00e7\u00e3o com m\u00e9todos nativos de outras linguagens. \n\nDesta forma, podem ser implementados aplicativos h\u00edbridos em Java e C++, \n\naproveitando o grande volume de c\u00f3digo existente atualmente em C++.  \n\n3.2.6 Segura \n\nPor ter uma tipagem de dados forte, somente permitir acesso aos campos membro \n\npelo nome (e n\u00e3o por endere\u00e7o), n\u00e3o ter aritm\u00e9tica de ponteiros e nem qualquer tipo de \n\nacesso direto \u00e0s posi\u00e7\u00f5es de mem\u00f3ria, um programa compilado em Java pode ser \n\n\n\n 52\n\ntotalmente verificado antes de ser executado. A verifica\u00e7\u00e3o dos byte-codes \u00e9 realizada \n\nnos browsers Web que suportam Java para garantir que as applets n\u00e3o estejam violando \n\nas restri\u00e7\u00f5es da linguagem e n\u00e3o possam provocar danos no computador do usu\u00e1rio.  \n\nDepois da verifica\u00e7\u00e3o, as applets podem ser otimizadas pelo sistema de execu\u00e7\u00e3o, \n\npara garantir um melhor desempenho. A execu\u00e7\u00e3o na m\u00e1quina do cliente tamb\u00e9m \u00e9 \n\nrestrita, n\u00e3o permitindo a escrita no disco nem o acesso a outra localidade na rede, \n\nexcluindo-se aquela que enviou a applet. Como Java n\u00e3o fornece acesso direto \u00e0 \n\nmem\u00f3ria, torna-se muito dif\u00edcil o desenvolvimento de v\u00edrus e outros programas \n\nmaliciosos, da forma como s\u00e3o feitos hoje, usando somente a linguagem Java.  \n\n3.2.7 Multi-linha (multithreaded) \n\nProgramas em Java podem ter mais de uma linha de execu\u00e7\u00e3o (thread) ocorrendo \n\nao mesmo tempo. Os programadores podem definir quando e com que prioridade certas \n\nlinhas de execu\u00e7\u00e3o ser\u00e3o executadas. A maior vantagem dessa caracter\u00edstica \u00e9 a \n\npossibilidade das aplica\u00e7\u00f5es realizarem processamento em background enquanto os  \n\nusu\u00e1rios interagem a interface das mesmas.  \n\nJava ainda fornece meios de sincronizar as linhas de execu\u00e7\u00e3o. Quando um \n\nprograma referencia v\u00e1rias delas e h\u00e1 o risco de utilizarem o mesmo conjunto de dados, \n\n\u00e9 necess\u00e1rio sincronizar as a\u00e7\u00f5es para que n\u00e3o ocorram conflitos. Em Java, um m\u00e9todo \n\npode ser declarado sincronizado para garantir que o objeto no qual atua n\u00e3o possa ser \n\nalterado por outros m\u00e9todos enquanto estiver operando sobre ele. \n\n3.3 Considera\u00e7\u00f5es Finais do Cap\u00edtulo \n\nNesse cap\u00edtulo foram abordadas, de maneira n\u00e3o exaustiva, as caracter\u00edsticas \n\ngerais da linguagem de programa\u00e7\u00e3o Java. Visto que o foco da linguagem Java est\u00e1 na \n\ncomputa\u00e7\u00e3o distribu\u00edda [ECKEL 01], redes e Web [DEITEL 01], [SEBESTA 00], \n\njustifica-se sua escolha para aplica\u00e7\u00e3o no presente trabalho.  \n\n\n\n 53\n\n4. Objetos Distribu\u00eddos e a Arquitetura CORBA \n\n4.1 Objetos  Distribu\u00eddos  \n\nUm objeto distribu\u00eddo \u00e9 essencialmente um componente, uma pe\u00e7a de software \n\nprovida de \u201cintelig\u00eancia auto-contida\u201d, que pode interoperar com outros objetos \n\ndistribu\u00eddos atrav\u00e9s de sistemas operacionais, redes, linguagens de programa\u00e7\u00e3o, \n\naplica\u00e7\u00f5es, ferramentas e dispositivos diversos. Existe recentemente uma tend\u00eancia de \n\nse construir sistemas computacionais abertos utilizando objetos distribu\u00eddos como \n\ninfraestrutura. Tais sistemas possuem diversas vantagens sobre os sistemas tradicionais \n\nsob diversos pontos de vistas, conforme ressaltado em [ORFALI 99]. Os usu\u00e1rios \n\nrecebem suas aplica\u00e7\u00f5es personalizadas, somente com os recursos necess\u00e1rios, evitando, \n\nassim, o denominado fatware; projetistas podem montar sistemas rapidamente \n\nutilizando \"objetos de prateleira\" existentes; e distribuidores podem vender aplica\u00e7\u00f5es \n\ncom recursos espec\u00edficos para determinado tipo de mercado, por exemplo, editores de \n\ntexto para advogados [ORFALI 99].  \n\nAl\u00e9m disso, esses objetos distribu\u00eddos possuem as mesmas caracter\u00edsticas \n\nrepresentativas dos objetos das linguagens de programa\u00e7\u00e3o: encapsulamento, \n\npolimorfismo e heran\u00e7a, tendo, dessa forma, as mesmas vantagens principais: f\u00e1cil \n\nreusabilidade, manuten\u00e7\u00e3o e depura\u00e7\u00e3o.  \n\nEm [HARKEY 98] enfatiza-se os benef\u00edcios da utiliza\u00e7\u00e3o de objetos em sistemas \n\ndistribu\u00eddos. Por exemplo, sua utiliza\u00e7\u00e3o ajuda a tratar a heterogeneidade de alguns \n\nsistemas, pois os servi\u00e7os fornecidos s\u00e3o separados de suas implementa\u00e7\u00f5es. Observa-se \n\ntamb\u00e9m que o encapsulamento \u00e9 adequado para implementar unidades de distribui\u00e7\u00e3o \n\n(que migram de forma independente), unidades de falha e unidades de seguran\u00e7a.  \n\nEntretanto, no mesmo texto s\u00e3o discutidas algumas dificuldades para implementar \n\nheran\u00e7a em sistemas distribu\u00eddos. A heran\u00e7a permite diferentes objetos compartilharem \n\nc\u00f3digo (implementa\u00e7\u00e3o de outro objeto), capacidade que oferece benef\u00edcios \u00f3bvios de \n\n\n\n 54\n\nredu\u00e7\u00e3o de duplicidade de c\u00f3digo. Por\u00e9m, em sistemas distribu\u00eddos, n\u00e3o \u00e9 poss\u00edvel o \n\ncompartilhamento de c\u00f3digo de objetos em n\u00f3s separados.  \n\nUm outro benef\u00edcio da utiliza\u00e7\u00e3o de objetos distribu\u00eddos que se aplica \n\nespecificamente em sistemas de tempo real \u00e9 o polimorfismo de performance (ou \n\npolimorfismo temporal). Esse mecanismo permite que uma interface possua v\u00e1rias \n\nimplementa\u00e7\u00f5es diferentes do mesmo m\u00e9todo, cada uma com um tempo de execu\u00e7\u00e3o \n\ndiferente. Dependendo de determinados aspectos temporais, o m\u00e9todo que puder atender \n\naos requisitos temporais especificados pelo cliente naquele momento, ser\u00e1 executado.  \n\nCada objeto distribu\u00eddo n\u00e3o opera sozinho. A princ\u00edpio ele \u00e9 constru\u00eddo para \n\ntrabalhar com outros objetos e, para isso, precisa de uma esp\u00e9cie de \"barramento\". Tais \n\n\"barramentos\" fornecem infra-estrutura para os objetos, adicionando novos servi\u00e7os que \n\npodem ser herdados durante a constru\u00e7\u00e3o do objeto, ou mesmo em tempo de execu\u00e7\u00e3o \n\npara alcan\u00e7ar altos n\u00edveis de colabora\u00e7\u00e3o com outros objetos independentes. CORBA \n\n(Commom Object Request Broker Architecture) pode ser caracterizada como um \n\nexemplo de \"barramento\" que ser\u00e1 visto a seguir.  \n\n4.2 A Arquitetura CORBA  \n\nA arquitetura CORBA come\u00e7ou a ser definida pela OMG (Object Management \n\nGroup) em 1989 [OMG 01].  \n\nA OMG \u00e9 uma organiza\u00e7\u00e3o internacional suportada por centenas de membros, \n\nabrangendo um grande espectro de interesses, desde usu\u00e1rios at\u00e9 projetistas de sistemas. \n\nTal organiza\u00e7\u00e3o promove estudos sobre a tecnologia orientada a objetos no processo de \n\ndesenvolvimento de software e sua carta de princ\u00edpios inclui o estabelecimento de \n\ndiretrizes na ind\u00fastria e especifica\u00e7\u00f5es de gerenciamento de objetos para fornecer uma \n\nestrutura comum para desenvolvimento de aplica\u00e7\u00f5es. O objetivo prim\u00e1rio \u00e9 se alcan\u00e7ar \n\nsistemas baseados em objetos em ambientes distribu\u00eddos heterog\u00eaneos com \n\ncaracter\u00edsticas de reusabilidade, portabilidade e interoperabilidade. \n\n\n\n 55\n\nEm 1990, a OMG criou o OMA (Object Management Architecture), objetivando \n\nfomentar o crescimento de tecnologias baseadas em objetos e fornecer uma infra-\n\nestrutura conceitual para todas especifica\u00e7\u00f5es OMG. O OMA \u00e9 composto por quatro \n\nelementos principais:  \n\n1. ORB (Object Request Broker), habilita os objetos enviarem e receberem \n\nrequisi\u00e7\u00f5es e, da mesma maneira, receberem respostas a suas requisi\u00e7\u00f5es, \n\nde forma transparente em um sistema distribu\u00eddo. O ORB \u00e9 a funda\u00e7\u00e3o \n\npara se construir aplica\u00e7\u00f5es, utilizando objetos distribu\u00eddos, com \n\ncaracter\u00edsticas de interoperabilidade entre aplica\u00e7\u00f5es em ambientes  \n\nheterog\u00eaneos ou homog\u00eaneos.  \n\n2. Servi\u00e7os de Objetos, \u00e9 uma cole\u00e7\u00e3o de servi\u00e7os (interfaces e objetos) que \n\nsuportam fun\u00e7\u00f5es b\u00e1sicas para usar e implementar objetos.  \n\n3. Facilidades Comuns, \u00e9 uma cole\u00e7\u00e3o de servi\u00e7os que muitas aplica\u00e7\u00f5es \n\npodem compartilhar, mas que n\u00e3o s\u00e3o t\u00e3o fundamentais como os servi\u00e7os \n\nde objetos.  \n\n4. Objetos de Aplica\u00e7\u00e3o, correspondem \u00e0 no\u00e7\u00e3o tradicional de aplica\u00e7\u00f5es de \n\nusu\u00e1rios que, por esse motivo, n\u00e3o s\u00e3o padronizados pelo OMG.  \n\nA fig. 4.1 apresenta uma id\u00e9ia geral da estrutura e dos elementos que comp\u00f5e o \n\nOMA.  \n\n \n\nObjetos de Aplica\u00e7\u00e3o Facilidades Comuns\n\nSERVI\u00c7OS DE OBJETOS\n\nORB\n\n \n \n\nFIGURA 4.1 \u2013 ARQUITETURA DE GERENCIAMENTO DE OBJETOS (OMA). \n\n\n\n 56\n\n \n\n O ORB \u00e9 o elemento principal desse modelo de refer\u00eancia, pois fornece os \n\nmecanismos b\u00e1sicos de envio e de recebimento de chamadas entre objetos e, dessa \n\nforma, ser\u00e1 descrito com mais detalhes adiante.  \n\n4.3 Modelo de objetos CORBA  \n\nPara compreender melhor a arquitetura CORBA \u00e9 necess\u00e1rio conhecer a descri\u00e7\u00e3o \n\ndo modelo de objetos [OMG 01] que fornece conceitos e terminologias de objetos \n\nusados pela arquitetura CORBA.  \n\nUm conceito b\u00e1sico \u00e9 o de sistema de objetos que \u00e9 composto por entidades \n\ndenominadas objetos. Um objeto \u00e9 uma entidade que fornece servi\u00e7os aos clientes. Um \n\ncliente de um servi\u00e7o \u00e9 qualquer entidade capaz de requisitar servi\u00e7os atrav\u00e9s de \n\neventos denominados requisi\u00e7\u00f5es (requests). Uma requisi\u00e7\u00e3o possui informa\u00e7\u00e3o \n\nassociada que consiste basicamente da opera\u00e7\u00e3o, do objeto destino, dos par\u00e2metros e do \n\ncontexto da requisi\u00e7\u00e3o.  \n\nUm valor \u00e9 uma inst\u00e2ncia de um tipo de dados definido no OMG IDL (abordado \n\nmais adiante) que pode ser usado como par\u00e2metro em uma requisi\u00e7\u00e3o. Um valor que \n\nidentifica um objeto \u00e9 denominado nome de objeto, e uma refer\u00eancia de objeto \u00e9 um \n\nnome de objeto que denota um objeto em particular.  \n\nUma requisi\u00e7\u00e3o pode ter par\u00e2metros que podem ser de entrada, sa\u00edda, ou de \n\nentrada e sa\u00edda, e que s\u00e3o identificados pelas suas posi\u00e7\u00f5es na requisi\u00e7\u00e3o. Ela pode ter \n\ntamb\u00e9m um contexto (context) que fornece informa\u00e7\u00e3o adicional sobre a pr\u00f3pria \n\nrequisi\u00e7\u00e3o. Uma requisi\u00e7\u00e3o pode retornar um valor de resultado para os clientes, al\u00e9m \n\nde retornar os par\u00e2metros de sa\u00edda. Entretanto, se uma condi\u00e7\u00e3o anormal ocorrer, uma \n\nexce\u00e7\u00e3o \u00e9 gerada. Objetos CORBA podem ser criados e destru\u00eddos atrav\u00e9s de \n\ndeterminadas requisi\u00e7\u00f5es. O resultado da cria\u00e7\u00e3o do objeto \u00e9 disponibilizado ao cliente \n\nsob a forma de uma refer\u00eancia de objeto, denotando o novo objeto.  \n\n\n\n 57\n\nUma interface \u00e9 uma descri\u00e7\u00e3o de um poss\u00edvel conjunto de opera\u00e7\u00f5es que um \n\ncliente pode requisitar de um objeto. Diz-se que um objeto satisfaz uma interface se ele \n\npode ser especificado como objeto destino em cada opera\u00e7\u00e3o descrita pela interface. \n\nUma heran\u00e7a de interface fornece o mecanismo de composi\u00e7\u00e3o para permitir um objeto \n\nsuportar interfaces m\u00faltiplas.  \n\nUma opera\u00e7\u00e3o \u00e9 uma entidade que denota um servi\u00e7o que pode ser requisitado. \n\nUma opera\u00e7\u00e3o possui uma assinatura que, de um modo geral, descreve os valores \n\nv\u00e1lidos dos par\u00e2metros, dos resultados retornados da requisi\u00e7\u00e3o, a exce\u00e7\u00e3o definida pelo \n\nusu\u00e1rio que pode ser sinalizada para terminar uma requisi\u00e7\u00e3o de opera\u00e7\u00e3o, e a \n\ninforma\u00e7\u00e3o de contexto que ser\u00e1 fornecida \u00e0 implementa\u00e7\u00e3o do objeto. A assinatura \n\ndescreve tamb\u00e9m, a sem\u00e2ntica de execu\u00e7\u00e3o da opera\u00e7\u00e3o no caso de falhas, que pode ser \n\n\"melhor esfor\u00e7o\" ou \"no m\u00e1ximo uma vez\".  \n\nNa implementa\u00e7\u00e3o de objeto, um m\u00e9todo \u00e9 o c\u00f3digo que \u00e9 executado para \n\nfornecer o servi\u00e7o e a execu\u00e7\u00e3o de um m\u00e9todo \u00e9 denominada ativa\u00e7\u00e3o do m\u00e9todo.  \n\nO modelo de objetos do CORBA \u00e9 um modelo de objetos cl\u00e1ssico, onde um \n\ncliente envia uma mensagem a um objeto, o objeto interpreta a mensagem e decide que \n\nservi\u00e7o deve realizar. Como em um modelo cl\u00e1ssico, uma mensagem identifica um \n\nobjeto e zero ou mais par\u00e2metros reais. O primeiro par\u00e2metro \u00e9 requerido e identifica a \n\nopera\u00e7\u00e3o que deve ser realizada, e serve de base para que, durante a interpreta\u00e7\u00e3o da \n\nmensagem, o objeto receptor (ou o ORB) possa selecionar o m\u00e9todo adequado. \n\n4.1.1 Sem\u00e2ntica dos Objetos do CORBA \n\n4.1.1.1 Objeto \n\nEntidade identific\u00e1vel e encapsulada que prov\u00ea servi\u00e7os que podem ser \n\nrequisitados por clientes. \n\n4.1.1.2 Requisi\u00e7\u00e3o \n\n\n\n 58\n\nRequisi\u00e7\u00e3o pode ser conceituada como algo que acontece em um tempo definido \n\n(evento). As informa\u00e7\u00f5es associadas a uma requisi\u00e7\u00e3o s\u00e3o opera\u00e7\u00e3o, objeto alvo, \n\npar\u00e2metros reais (que podem ser de entrada, de sa\u00edda ou de entrada e sa\u00edda) e um \n\ncontexto de requisi\u00e7\u00e3o opcional. Uma requisi\u00e7\u00e3o causa a execu\u00e7\u00e3o de um determinado \n\nservi\u00e7o, e retorna uma exce\u00e7\u00e3o se acontecer uma condi\u00e7\u00e3o anormal durante a sua \n\nexecu\u00e7\u00e3o. \n\n4.1.1.3 Refer\u00eancia a objeto \n\nValor que identifica um objeto e que seguramente denota um (e somente um) \n\nobjeto particular. Em contrapartida, um objeto pode ser denotado por diversas \n\nrefer\u00eancias. \n\n4.1.1.4 Cria\u00e7\u00e3o e destrui\u00e7\u00e3o de objetos  \n\nAcontecem como resultados de requisi\u00e7\u00f5es. Do ponto de vista do cliente, n\u00e3o \n\nexiste nenhum mecanismo especial para cria\u00e7\u00e3o e destrui\u00e7\u00e3o de objetos. \n\n4.1.1.5 Tipos \n\nConceito tradicional de tipos. Formalmente, tipo \u00e9 entidade identific\u00e1vel associada \n\na um predicado definido sobre os valores membros deste tipo. Em particular, um tipo \n\nobjeto \u00e9 um tipo cujos membros s\u00e3o objetos.  \n\nOs tipos existentes no modelo de objetos do CORBA s\u00e3o apresentados na fig. 4.2. \n\nTipos B\u00e1sicos : \n\n inteiros com e sem sinal, 16 e 32 bits;  \n\n n\u00fameros em ponto flutuante de 32 e 64 bits;  \n\n\n\n 59\n\n caracteres (seguindo defini\u00e7\u00e3o ISO Latin-I);  \n\n booleano, assumindo os valores TRUE e FALSE; \n\n tipo opaco de 8 bits que seguramente n\u00e3o sofre nenhuma convers\u00e3o durante \n\ntransfer\u00eancia entre sistemas; \n\n tipos enumerados, consistindo de seq\u00fc\u00eancia enumerada de identificadores;  \n\n tipo string (array de caracteres de tamanho vari\u00e1vel). O tamanho da string est\u00e1 \n\ndispon\u00edvel em tempo de execu\u00e7\u00e3o um tipo \"any\" que pode representar \n\nqualquer tipo b\u00e1sico ou constru\u00eddo.  \n\nTipos Constru\u00eddos: \n\n registro (struct);  \n\n uni\u00e3o, consistindo de um discriminador seguido por uma inst\u00e2ncia cujo tipo \u00e9 \n\napropriado ao valor do discriminador;  \n\n seq\u00fc\u00eancia (array de tipo simples de tamanho vari\u00e1vel). O tamanho do array \n\nest\u00e1 dispon\u00edvel em tempo de execu\u00e7\u00e3o;  \n\n array de tipos simples com tamanho fixo ; \n\n tipo interface, que especifica o conjunto de opera\u00e7\u00f5es que uma inst\u00e2ncia deste \n\ntipo deve suportar.  \n\n \n \n\nFIGURA 4.2 \u2013 TIPOS DO MODELO DE OBJETOS CORBA  \n\n\n\n 60\n\n4.1.1.6 Interface \n\nDescri\u00e7\u00e3o do conjunto de opera\u00e7\u00f5es poss\u00edveis de um objeto que podem ser \n\nrequisitadas por um cliente. Um objeto pode suportar m\u00faltiplas interfaces atrav\u00e9s de \n\nmecanismos como heran\u00e7a. As interfaces s\u00e3o especificadas em uma linguagem \n\ndenominada IDL. \n\n4.1.1.7 Opera\u00e7\u00e3o \n\nEntidade identific\u00e1vel que denota um servi\u00e7o que pode ser requisitado. \u00c9 \n\nextremamente gen\u00e9rica, na medida em que \u00e9 independente da implementa\u00e7\u00e3o dos \n\nobjetos e utiliza-se de mecanismos de heran\u00e7a de interfaces da IDL. Uma opera\u00e7\u00e3o \n\npossui uma assinatura, a qual descreve todos os valores de par\u00e2metros e resultados \n\nposs\u00edveis, atrav\u00e9s de:  \n\n especifica\u00e7\u00e3o de par\u00e2metros necess\u00e1rios em chamadas a esta opera\u00e7\u00e3o;  \n\n especifica\u00e7\u00e3o de resultados da opera\u00e7\u00e3o;  \n\n especifica\u00e7\u00e3o das exce\u00e7\u00f5es que podem ocorrer durante a execu\u00e7\u00e3o do servi\u00e7o;  \n\n especifica\u00e7\u00e3o de informa\u00e7\u00e3o adicional de contexto;  \n\n indica\u00e7\u00e3o da sem\u00e2ntica de execu\u00e7\u00e3o que o cliente espera encontrar na ocasi\u00e3o \n\nde uma requisi\u00e7\u00e3o a esta opera\u00e7\u00e3o.  \n\nA forma geral da assinatura de uma opera\u00e7\u00e3o \u00e9:  \n\n[oneway]&lt;op_type_spec>&lt;identifier> (param1,...,paramL) [raises \n\n(except1,...,exceptN)] \n\n[context(name1,...,nameM)]  \n\nonde:  \n\n oneway indica a sem\u00e2ntica \"best-effort\" de execu\u00e7\u00e3o, na qual a opera\u00e7\u00e3o n\u00e3o \n\nretorna nenhum resultado, e n\u00e3o h\u00e1 sincroniza\u00e7\u00e3o entre o requisitante e o \n\n\n\n 61\n\nt\u00e9rmino da opera\u00e7\u00e3o. O default \u00e9 a sem\u00e2ntica \"at-most-once\", na qual garante-\n\nse que se uma opera\u00e7\u00e3o retorna com sucesso, esta foi executada exatamente \n\numa vez. No caso de exce\u00e7\u00e3o, foi executada uma vez no m\u00e1ximo. A sem\u00e2ntica \n\nde execu\u00e7\u00e3o \u00e9 associada a cada opera\u00e7\u00e3o, o que garante que tanto o cliente \n\nquanto a implementa\u00e7\u00e3o do objeto sempre assumir\u00e3o a mesma sem\u00e2ntica;  \n\n op_type_spec \u00e9 o tipo do retorno da opera\u00e7\u00e3o, que \u00e9 um par\u00e2metro de sa\u00edda \n\ndistinto;  \n\n identifier \u00e9 o nome da opera\u00e7\u00e3o ; \n\n par\u00e2metros s\u00e3o modificados para indicar a dire\u00e7\u00e3o da informa\u00e7\u00e3o: in indica \n\nque a informa\u00e7\u00e3o passa do cliente para o servidor, out do servidor para o \n\ncliente e inout em ambas as dire\u00e7\u00f5es ; \n\n a express\u00e3o raises \u00e9 seguida pela lista de exce\u00e7\u00f5es definidas pelo usu\u00e1rio (as \n\nexce\u00e7\u00f5es padr\u00e3o s\u00e3o inclu\u00eddas implicitamente) que podem ser sinalizadas para \n\nterminar a requisi\u00e7\u00e3o, indicando que a opera\u00e7\u00e3o n\u00e3o foi executada com \n\nsucesso. Tais exce\u00e7\u00f5es podem ser descritas por um registro, no qual s\u00e3o \n\nacompanhadas por informa\u00e7\u00e3o adicional espec\u00edfica da exce\u00e7\u00e3o; \n\n context \u00e9 uma express\u00e3o opcional que indica o contexto de requisi\u00e7\u00e3o \n\ndispon\u00edvel na implementa\u00e7\u00e3o do objeto, e pode afetar a performance da \n\nrequisi\u00e7\u00e3o . \n\n4.1.1.8 Atributos \n\nAnalogamente aos conceitos de orienta\u00e7\u00e3o a objetos pura, os atributos de uma \n\ninterface s\u00e3o logicamente equivalentes a declara\u00e7\u00e3o de um par de fun\u00e7\u00f5es de acesso: \n\numa para recupera\u00e7\u00e3o do valor do atributo e outra para altera\u00e7\u00e3o do valor (caso o \n\natributo n\u00e3o seja apenas para leitura).  \n\n4.1.2 Implementa\u00e7\u00e3o de Objetos no CORBA \n\n\n\n 62\n\nA implementa\u00e7\u00e3o de um sistema de objetos inclui atividades que podem requisitar \n\nservi\u00e7os adicionais, como por exemplo, c\u00e1lculo de resultados das requisi\u00e7\u00f5es e \n\natualiza\u00e7\u00e3o do estado do sistema. O modelo de implementa\u00e7\u00e3o divide-se em 2 partes: o \n\nModelo de Execu\u00e7\u00e3o que descreve como os servi\u00e7os s\u00e3o executados, e o Modelo de \n\nConstru\u00e7\u00e3o que descreve como os servi\u00e7os s\u00e3o definidos. \n\n4.1.2.1 Modelo de execu\u00e7\u00e3o \n\nUm servi\u00e7o requisitado \u00e9 realizado pela execu\u00e7\u00e3o de um c\u00f3digo que manipula \n\ndeterminados dados e pode alterar o estado do sistema. Tal c\u00f3digo \u00e9 denominado um \n\nm\u00e9todo. A execu\u00e7\u00e3o de um m\u00e9todo por uma m\u00e1quina abstrata \u00e9 chamada de ativa\u00e7\u00e3o do \n\nm\u00e9todo. \n\n4.1.2.2 Modelo de Constru\u00e7\u00e3o \n\nDefinem-se os mecanismos para obten\u00e7\u00e3o do comportamento dos pedidos, como \n\ndefini\u00e7\u00f5es do estado do objeto, defini\u00e7\u00e3o dos m\u00e9todos, defini\u00e7\u00e3o de como \u00e9 a \n\ninfraestrutura do objeto para que ele selecione apropriadamente os m\u00e9todos a serem \n\nexecutados e defini\u00e7\u00e3o das a\u00e7\u00f5es concretas que devem ser tomadas quando da cria\u00e7\u00e3o \n\nde um objeto, como por exemplo associa\u00e7\u00e3o do novo objeto aos seus m\u00e9todos.  \n\n4.2 ORB  \n\nObjetos clientes requisitam servi\u00e7os \u00e0s implementa\u00e7\u00f5es de objetos atrav\u00e9s de um \n\nORB (fig. 4.3). O ORB \u00e9 a unidade que gerencia a transfer\u00eancia de controle e de dados \n\nentre os clientes e as implementa\u00e7\u00f5es, sendo respons\u00e1vel por todos os mecanismos \n\nrequeridos para encontrar o objeto, preparar a implementa\u00e7\u00e3o de objeto para receber a \n\nrequisi\u00e7\u00e3o, e executar a requisi\u00e7\u00e3o. O cliente v\u00ea a requisi\u00e7\u00e3o de forma independente de \n\nonde o objeto est\u00e1 localizado, qual linguagem de programa\u00e7\u00e3o ele foi implementado, ou \n\nqualquer outro aspecto que n\u00e3o est\u00e1 refletido na interface do objeto. No caso de uma \n\n\n\n 63\n\nopera\u00e7\u00e3o n\u00e3o ser executada com sucesso, gera-se uma exce\u00e7\u00e3o que deve ser tratada pelo \n\ncliente. \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n\nFIGURA 4.3 \u2013 CLIENTE ENVIANDO REQUISI\u00c7\u00c3O ATRAV\u00c9S DO ORB. \n\n4.2.1 IDL (Interface Definition Language) \n\nCORBA utiliza a OMG IDL (Interface Definition Language) como uma forma de \n\ndescrever interfaces, isto \u00e9, de especificar um contrato entre os objetos. OMG IDL \u00e9 \n\numa linguagem puramente declarativa28 baseada em C++. Isso garante que os \n\ncomponentes em CORBA sejam auto-document\u00e1veis, permitindo que diferentes \n\nobjetos, escritos em diferentes linguagens, possam interagir atrav\u00e9s das redes e de \n\nsistemas operacionais (fig. 4.4) [HARKEY 98]. \n\n                                                                  \n28 Uma linguagem declarativa especifica apenas os resultados desejados em vez dos procedimentos \ndetalhados para produzi-los [SEBESTA 00] \n\nORB \n\nCliente \nImplementa\u00e7\u00e3o \n\ndo Objeto \n\nrequest \n\n\n\n 64\n\nORB\n\nCliente\n\nIDL IDL IDLIDL\n\nJava C++ SmallTalk Outra\n\nImplementa\u00e7\u00e3o do Objeto\n\nIDL IDL IDLIDL\n\nJava C++ SmallTalk Outra\n\nORB\n\nCliente\n\nIDL IDL IDLIDL\n\nJava C++ SmallTalk Outra\n\nImplementa\u00e7\u00e3o do Objeto\n\nIDL IDL IDLIDL\n\nJava C++ SmallTalk Outra\n\nFIGURA 4.4 \u2013 IDL PROV\u00ca INDEPEND\u00caNCIA DE LINGUAGEM DE PROGRAMA\u00c7\u00c3O ENTRE OS \nOBJETOS. \n\nUma defini\u00e7\u00e3o de interface escrita em OMG IDL define completamente a \n\ninterface e especifica cada par\u00e2metro da opera\u00e7\u00e3o. \u00c9 importante ressaltar que os objetos \n\nn\u00e3o s\u00e3o escritos em OMG IDL, que \u00e9 uma linguagem puramente descritiva. Eles s\u00e3o \n\nescritos em linguagens que possuem mapeamentos definidos dos conceitos existentes \n\nem OMG IDL. Na especifica\u00e7\u00e3o CORBA s\u00e3o descritos mapeamentos para C, C++ e \n\nSmalltalk, e existem estudos para se adicionar outras linguagens nas futuras vers\u00f5es de \n\nCORBA.  \n\nDe forma geral a IDL obedece as mesmas regras l\u00e9xicas que a linguagem C++, \n\ncom apenas algumas palavras reservadas a mais. A gram\u00e1tica IDL \u00e9 um subconjunto da \n\nANSI C++, com constru\u00e7\u00f5es adicionais para suportar mecanismos de chamadas a \n\nopera\u00e7\u00f5es. Sendo uma linguagem declarativa, a IDL n\u00e3o possui nenhuma estrutura \n\nalgor\u00edtmica ou vari\u00e1veis. Para que se evitasse conflito de nomes da especifica\u00e7\u00e3o \n\nCORBA com os da linguagem de programa\u00e7\u00e3o, convencionou-se que os primeiros \n\ndevem ser tratados como se tivessem definidos em um m\u00f3dulo denominado CORBA. \n\nOs nomes usados na interface devem ser referenciados, portanto, por seu nome \n\ncompleto (CORBA::<nome>) . \n\nAs diferen\u00e7as b\u00e1sicas para a sintaxe C++ s\u00e3o restri\u00e7\u00f5es  como:  \n\n\n\n 65\n\n retorno de uma fun\u00e7\u00e3o \u00e9 obrigat\u00f3rio;  \n\n devem ser fornecidos nomes para cada um dos par\u00e2metros formais na \n\ndeclara\u00e7\u00e3o de uma opera\u00e7\u00e3o; \n\n uma lista de par\u00e2metros vazia n\u00e3o pode ser substitu\u00edda pela palavra void;  \n\n a declara\u00e7\u00e3o dos tipos inteiros quanto a seu tamanho deve ser expl\u00edcita (short \n\nou long) ; \n\n os modificadores signed e unsigned n\u00e3o s\u00e3o aplic\u00e1veis ao tipo char . \n\nExistem exce\u00e7\u00f5es padr\u00e3o que s\u00e3o definidas pelo ORB, as quais podem acontecer \n\nem qualquer opera\u00e7\u00e3o e n\u00e3o precisam ser listadas na express\u00e3o raises. Alguns exemplos \n\nde exce\u00e7\u00f5es padr\u00e3o s\u00e3o UNKNOWN, NO_MEMORY, INITIALIZE, \n\nDATA_CONVERSION,...  \n\nUm pequeno exemplo de uma defini\u00e7\u00e3o IDL:  \n\nmodule TProduto { \n\n typedef string entrada; \n\n typedef string saida; \n\n interface Produto { \n\n  void Cadastrar (in entrada dados, in string desc, \n\n    in string quant, in string vlr); \n\n  void Consultar (in string desc, out saida dados, \n\n    out string quant, out string vlr); \n\n  void Excluir (in string desc); \n\n }; \n\n4.2.2 Servi\u00e7os \n\nPodemos fazer uma analogia do ORB com uma linha telef\u00f4nica, que permite \n\nenviar e receber mensagens. Entretanto n\u00e3o prov\u00ea outros servi\u00e7os que tem que ser \n\ndefinidos a parte e funciona como uma camada externa que utiliza o ORB como \"meio\". \n\nEsses servi\u00e7os s\u00e3o conhecidos com Object Services.  \n\n\n\n 66\n\nAl\u00e9m desses podemos destacar tamb\u00e9m Common Facilities que tamb\u00e9m constitu\u00ed \n\num grupo de servi\u00e7os de prop\u00f3sito mais geral, enquanto o primeiro \u00e9 um conjunto de \n\nfun\u00e7\u00f5es b\u00e1sicas.  \n\nEsses servi\u00e7os s\u00e3o definidos em IDL e podem ou n\u00e3o ser implementados em uma \n\nlinguagem orientada \u00e0 objetos.   \n\nUm servi\u00e7o \u00e9 caracterizado pela interface que ele prov\u00ea, pelos objetos que \n\nprov\u00eaem essas interfaces e por aspectos de qualidade na implementa\u00e7\u00e3o do servi\u00e7o que \n\nir\u00e3o influenciar na sua utiliza\u00e7\u00e3o. As interfaces de um servi\u00e7o s\u00e3o classificadas de \n\nacordo com :  \n\n1. o tipo de consumidor da interface. Uma interface pode ser utilizada por um \n\nusu\u00e1rio final ou por sistema de gerenciamento de fun\u00e7\u00f5es.  \n\n2. o mensageiro da mensagem. O tipo de objeto que apresenta a mensagem. \n\nPodem ser objetos espec\u00edficos, cujo prop\u00f3sito de exist\u00eancia \u00e9 prover parte do servi\u00e7o de \n\num Object Service, ou objetos gen\u00e9ricos cujo prop\u00f3sito de exist\u00eancia n\u00e3o \u00e9 prover o \n\nservi\u00e7o correspondente a interface que \"carrega\", provavelmente herdou esta interface.  \n\nDentre os servi\u00e7os j\u00e1 identificados e revisados pelo Grupo respons\u00e1vel da OMG, \n\n(Object Service Task Force) podemos destacar os apresentados na Tabela 4.1. \n\nTABELA 4.1 \u2013 SERVI\u00c7OS CORBA \n\nServi\u00e7o Fun\u00e7\u00e3o \n\n Archive Suportar o mapeamento entre objetos ativos e backup. \n\n Backup/Restore Suporta o backup e recupera\u00e7\u00e3o de objetos. \n\n Concurrency Control  Suporta o acesso concorrente a objetos. \n\n Event Notification Suporta a notifica\u00e7\u00e3o de eventos a objetos interessados. \n\n Naming Suporta o mapeamento entre nome e objetos. \n\n\n\n 67\n\n Persistence Suporta a persist\u00eancia de objetos independente do tempo \n\nde vida da aplica\u00e7\u00e3o cliente e da implementa\u00e7\u00e3o que \n\nexecuta os m\u00e9todos. \n\n Query Suporta opera\u00e7\u00f5es sobre conjuntos e cole\u00e7\u00f5es retornando \n\nconjuntos e cole\u00e7\u00f5es. \n\n Relationships Suporta associa\u00e7\u00e3o entre dois ou mais objetos. \n\n Replication Suporta replica\u00e7\u00e3o expl\u00edcita de objetos em um ambiente \n\ndistribu\u00eddo e gerencia a consist\u00eancia das c\u00f3pias. \n\n Security Suporta controle de acesso aos objetos. \n\n Time Suporta a sincroniza\u00e7\u00e3o de rel\u00f3gios em sistemas \n\ndistribu\u00eddos. \n\n Transactions Suporta transa\u00e7\u00f5es na execu\u00e7\u00e3o de opera\u00e7\u00f5es. \n\n4.2.2 Estrutura do ORB  \n\nA fig. 4.5 mostra a estrutura de um ORB, com as setas indicando o fluxo de \n\nchamadas que podem ocorrer de clientes para o ORB, e do ORB para as \n\nimplementa\u00e7\u00f5es de objetos. \n\nPara fazer uma requisi\u00e7\u00e3o, um cliente pode usar a Interface de Invoca\u00e7\u00e3o \n\nDin\u00e2mica (DII - Dynamic Invocation Interface) ou um Stub de IDL. Para algumas \n\npoucas e determinadas fun\u00e7\u00f5es, um cliente pode interagir diretamente com a interface \n\ndo ORB. A interface do ORB oferece fun\u00e7\u00f5es que s\u00e3o independentes do adaptador de \n\nobjetos utilizado, como, por exemplo, fun\u00e7\u00f5es que executam algumas opera\u00e7\u00f5es sobre \n\nrefer\u00eancias de objetos.  \n\nO fato de permitir tanto a invoca\u00e7\u00e3o din\u00e2mica quanto a est\u00e1tica, torna CORBA \n\nbastante flex\u00edvel. A invoca\u00e7\u00e3o est\u00e1tica, que utiliza Stubs de IDL que podem ser gerados \n\n\n\n 68\n\nautomaticamente atrav\u00e9s de pr\u00e9-compiladores, possui uma s\u00e9rie de vantagens sobre a \n\ninvoca\u00e7\u00e3o din\u00e2mica [HARKEY 98]: \u00e9 mais f\u00e1cil de programar, faz verifica\u00e7\u00e3o de tipos \n\nmais robusta, executa mais r\u00e1pido e \u00e9 auto-document\u00e1vel. J\u00e1 a invoca\u00e7\u00e3o din\u00e2mica \n\npermite a adi\u00e7\u00e3o de novos servi\u00e7os \u00e0s implementa\u00e7\u00f5es de objetos sem altera\u00e7\u00f5es nos \n\nclientes. Dessa forma, os clientes podem descobrir em tempo de execu\u00e7\u00e3o quais s\u00e3o os \n\nservi\u00e7os oferecidos. \n\n \n\nObject Implementation\n\nORB\nInterface\n\nORB\nInterface\n\nDynamic\nInvocation\n\nORB\nInterface\n\nIDL\nStubs\n\nORB\n\nInterface id\u00eantica para todas as implementa\u00e7\u00f5es de ORB\n\nPode haver diversos adaptadores de objetos\n\nExistem \"stubs\"e um esqueleto para cada tipo de objeto\n\nInterface Independente do ORB\n\nClient\n\n \n\nFIGURA 4.5 \u2013 ESTRUTURA B\u00c1SICA DE UM ORB. \n\nA invoca\u00e7\u00e3o din\u00e2mica \u00e9 poss\u00edvel atrav\u00e9s dos servi\u00e7os do Reposit\u00f3rio de \n\nInterfaces. Um Reposit\u00f3rio de Interfaces \u00e9 uma base de dados que cont\u00e9m interfaces \n\nOMG IDL, e seus servi\u00e7os basicamente permitem o acesso, armazenagem e atualiza\u00e7\u00e3o \n\ndessas interfaces.  \n\n\u00c9 importante ressaltar que do ponto de vista da implementa\u00e7\u00e3o de objetos (ou um \n\nservant), uma requisi\u00e7\u00e3o feita estaticamente \u00e9 indistingu\u00edvel da feita de forma din\u00e2mica, \n\nj\u00e1 que ambas respeitam a mesma sem\u00e2ntica da requisi\u00e7\u00e3o. Uma requisi\u00e7\u00e3o consiste de \n\numa refer\u00eancia de objeto, uma opera\u00e7\u00e3o e uma lista de par\u00e2metros. \n\n\n\n 69\n\nAo receber uma requisi\u00e7\u00e3o, o ORB localiza o c\u00f3digo da implementa\u00e7\u00e3o transmite \n\npar\u00e2metros e transfere o controle para a implementa\u00e7\u00e3o do objeto (servant). Quando a \n\nrequisi\u00e7\u00e3o \u00e9 completada, o controle e os valores de sa\u00edda s\u00e3o retornados ao cliente.  \n\nDe forma parecida ao que ocorre na requisi\u00e7\u00e3o de um cliente, o ORB pode invocar \n\na implementa\u00e7\u00e3o de objeto atrav\u00e9s de um Esqueleto de IDL Est\u00e1tico ou Din\u00e2mico. A \n\nInterface de Esqueleto de IDL Din\u00e2mica (DSI - Dynamic Skeleton Interface) \u00e9 uma \n\nforma de se enviar requisi\u00e7\u00f5es de um ORB para uma implementa\u00e7\u00e3o de objetos que n\u00e3o \n\npossui informa\u00e7\u00f5es sobre a implementa\u00e7\u00e3o do objeto em tempo de compila\u00e7\u00e3o. O \n\ncliente que invoca um objeto, n\u00e3o pode determinar se a implementa\u00e7\u00e3o est\u00e1 usando um \n\nesqueleto de um tipo espec\u00edfico ou DSI para conectar a implementa\u00e7\u00e3o ao ORB. DSI \u00e9 \n\n\u00fatil em solu\u00e7\u00f5es de interoperabilidade implementando pontes entre diferentes ORBs, e \n\npara suportar linguagens de tipos din\u00e2micos, como LISP29 e PROLOG30.  \n\nPara executar a requisi\u00e7\u00e3o, a implementa\u00e7\u00e3o de objeto pode obter alguns servi\u00e7os \n\ndo ORB atrav\u00e9s do Adaptador de Objetos. O Adaptador de Objetos se situa no topo dos \n\nservi\u00e7os de comunica\u00e7\u00e3o do N\u00facleo de ORB. Ele fornece o ambiente para instanciar \n\nobjetos, atribui-los refer\u00eancias de objetos, e passar requisi\u00e7\u00f5es a eles. Com um \n\nadaptador de objetos, \u00e9 poss\u00edvel a uma implementa\u00e7\u00e3o de objeto ter acesso a um servi\u00e7o \n\nindependentemente se ele est\u00e1 implementado no N\u00facleo de ORB \u2014 se o N\u00facleo de \n\nORB oferecer o servi\u00e7o, o adaptador simplesmente fornece uma interface para ele; caso \n\ncontr\u00e1rio, o adaptador deve implement\u00e1-lo no topo do N\u00facleo de ORB.  \n\nO conceito de adaptador de objetos \u00e9 necess\u00e1rio para permitir que CORBA \n\nsuporte uma grande diversidade de aplica\u00e7\u00f5es, com variados tipos e estilos de \n\nimplementa\u00e7\u00f5es de objeto. Se os servi\u00e7os do adaptador de objetos fossem oferecidos \n\ndiretamente pelo n\u00facleo do ORB, seria necess\u00e1ria a exist\u00eancia de uma gama muito \n\ngrande de m\u00e9todos na interface do ORB para atender todas as demandas dos variados \n\ntipos de servants existentes.  \n\n                                                                  \n29 List Processor. Primeira linguagem de programa\u00e7\u00e3o funcional de uso generalizado projetada por John \nMcCarthy, no MIT, entre 1958 e 1959 [SEBESTA 00] \n30 Programming Logic. Uma linguagem que prov\u00ea um m\u00e9todo para especificar proposi\u00e7\u00f5es de c\u00e1lculo de \npredicado e uma implementa\u00e7\u00e3o de uma forma restrita de resolu\u00e7\u00e3o, sendo o primeiro interpretador \nimplementado em Marseille, Fran\u00e7a, em 1972 [SEBESTA 00] \n\n\n\n 70\n\nN\u00e3o \u00e9 necess\u00e1rio que todos adaptadores de objetos ofere\u00e7am a mesma interface ou \n\nfuncionalidade. Algumas implementa\u00e7\u00f5es de objeto podem ter requisitos especiais, \n\nexigindo adaptadores de objetos espec\u00edficos. Dessa forma, a implementa\u00e7\u00e3o do objeto \n\npode escolher qual adaptador de objetos utilizar dependendo de quais tipos de servi\u00e7os \n\nele requer. Entretanto, com o objetivo de tentar conter uma prolifera\u00e7\u00e3o intermin\u00e1vel de \n\ntipos de adaptadores de objetos, [OMG 01] recentemente definiu o Adaptador de \n\nObjetos Port\u00e1vel (POA - Portable Object Adapter). A especifica\u00e7\u00e3o do POA define um \n\nadaptador de objetos que pode ser usado pela maioria dos objetos que possuem \n\nimplementa\u00e7\u00f5es convencionais.  \n\nPara localizar e ativar implementa\u00e7\u00f5es de objetos, um ORB utiliza-se de \n\nReposit\u00f3rios de Implementa\u00e7\u00f5es. Esses reposit\u00f3rios servem adicionalmente para \n\narmazenar informa\u00e7\u00f5es adicionais associadas com implementa\u00e7\u00f5es de ORBs, tais como, \n\ninforma\u00e7\u00f5es de depura\u00e7\u00e3o, controles administrativos, seguran\u00e7a, dentre outras. \n\n 4.2.3 Interoperabilidade entre ORBs  \n\nA especifica\u00e7\u00e3o de interfaces de objetos obrigatoriamente em OMG IDL, garante \n\na portabilidade dos objetos atrav\u00e9s de diferentes linguagens, ferramentas, sistemas \n\noperacionais e redes. Entretanto, a caracter\u00edstica de interoperabilidade entre objetos s\u00f3 \n\nfoi coberta na vers\u00e3o 2.0 do CORBA, introduzida em dezembro de 1994. Isso se deu \n\natrav\u00e9s da especifica\u00e7\u00e3o de uma arquitetura de interoperabilidade, um suporte para \n\npontes entre ORBs, um protocolo para comunica\u00e7\u00e3o entre ORBs gen\u00e9rico e um \n\nprotocolo para comunica\u00e7\u00e3o entre ORBs para Internet.  \n\nA arquitetura de interoperabilidade do CORBA identifica claramente a regra de \n\ndiferentes tipos de dom\u00ednios para informa\u00e7\u00e3o espec\u00edfica de ORBs. Tais dom\u00ednios podem \n\nincluir dom\u00ednios de refer\u00eancias de objeto, dom\u00ednios de tipos, dom\u00ednios de seguran\u00e7a, \n\ndentre outros. Quando dois ORBs est\u00e3o no mesmo dom\u00ednio, eles podem se comunicar \n\ndiretamente. Entretanto, quando a informa\u00e7\u00e3o em uma invoca\u00e7\u00e3o deve deixar seu \n\ndom\u00ednio, a invoca\u00e7\u00e3o deve atravessar uma ponte.  \n\n\n\n 71\n\nA regra de uma ponte deve assegurar que o conte\u00fado e a sem\u00e2ntica s\u00e3o mapeados \n\nadequadamente de um ORB para outro. O suporte para ponte entre ORBs pode tamb\u00e9m \n\nser usado para prover interoperabilidade com outros sistemas n\u00e3o CORBA.  \n\nO protocolo entre ORBs gen\u00e9rico (GIOP - Generic Inter-ORB Protocol) \n\nespecifica uma sintaxe de transfer\u00eancia padr\u00e3o e um conjunto de formatos de mensagens \n\npara comunica\u00e7\u00e3o entre ORBs. O protocolo entre ORBs para Internet (IIOP - Internet \n\nInter-ORB Protocol) especifica como mensagens GIOP s\u00e3o trocadas usando conex\u00f5es \n\nTCP/IP. Ele especifica um protocolo de interoperabilidade padr\u00e3o para Internet.  \n\nO relacionamento entre GIOP e IIOP \u00e9 similar ao mapeamento existente entre o \n\nOMG IDL e uma linguagem espec\u00edfica: o GIOP pode ser mapeado em diferentes \n\nprotocolos de transportes, e especifica os elementos de protocolo que s\u00e3o comuns a \n\ntodos os mapeamentos. Entretanto, o GIOP n\u00e3o fornece uma completa \n\ninteroperabilidade, da mesma forma que IDL n\u00e3o pode ser usado para se construir \n\nprogramas completos. O IIOP, e outros mapeamentos similares para diferentes \n\nprotocolos de transportes, s\u00e3o realiza\u00e7\u00f5es concretas das defini\u00e7\u00f5es abstratas de GIOP \n\n(fig. 4.6).  \n\nOs protocolos entre ORBs para ambientes espec\u00edficos (ESIOP - Environment-\n\nSpecific Inter-ORB Protocol) devem ser usados para interoperar em locais onde uma \n\nrede ou infra-estrutura de computa\u00e7\u00e3o distribu\u00edda j\u00e1 esteja em uso. Apesar de cada \n\nESIOP poder ser otimizado para um ambiente em particular, toda especifica\u00e7\u00e3o ESIOP \n\ndeve estar conforme as conven\u00e7\u00f5es da arquitetura de interoperabilidade para facilitar o \n\nuso de pontes, se necess\u00e1rio. O suporte de pontes entre ORBs habilita \u00e0s pontes serem \n\nconstru\u00eddas entre dom\u00ednios de ORBs que usam IIOP e dom\u00ednios que usam um ESIOP \n\nparticular.  \n\n \n\n\n\n 72\n\nESIOP\n\nESIOP\n\nESIOP\nGIOP\n\nIIOP\nOutros\n\nMapeamentos\nde GIOP\n\nCORBA/IDLMandat\u00f3rioCORBA 2.0\n\n \n \n\nFIGURA 4.6 \u2013 RELACIONAMENTOS DE PROTOCOLOS ENTRE ORBS. \n\n4.3 Servi\u00e7os CORBA  \n\nO ORB, por si s\u00f3, n\u00e3o executa todas as tarefas necess\u00e1rias para os objetos \n\ninteroperarem. Ele s\u00f3 fornece os mecanismos b\u00e1sicos. Outros servi\u00e7os necess\u00e1rios s\u00e3o \n\noferecidos por objetos com interface IDL, que a OMG vem padronizando para os \n\nobjetos de aplica\u00e7\u00e3o poderem utilizar. \n\n servi\u00e7o de nomes, por exemplo, \u00e9 basicamente um servi\u00e7o de localiza\u00e7\u00e3o de \n\nobjetos, que permite um objeto descobrir outros objetos atrav\u00e9s de \n\nidentificadores, ou nomes.  \n\n servi\u00e7o de controle de concorr\u00eancia fornece um gerente de \"locks\" que \n\ncoordena m\u00faltiplos acessos a recursos compartilhados, permitindo resolu\u00e7\u00e3o \n\nde conflitos de acesso.  \n\n servi\u00e7o de eventos permite que objetos registrem dinamicamente seus \n\ninteresses em determinados eventos, possibilitando uma forma de \n\ncomunica\u00e7\u00e3o pouco acoplada e ass\u00edncrona entre objetos. Eventos s\u00e3o enviados \n\ne recebidos atrav\u00e9s de um canal de eventos.  \n\n servi\u00e7o de tempo especifica uma interface de servi\u00e7o de tempo que permite, \n\nbasicamente, os objetos das aplica\u00e7\u00f5es obterem o tempo atual e executarem \n\ncompara\u00e7\u00f5es com o tempo.  \n\n\n\n 73\n\n servi\u00e7o de tempo tamb\u00e9m estende o servi\u00e7o de eventos, especificando uma \n\ninterface de servi\u00e7os de eventos   temporizados. Esse novo servi\u00e7o gerencia \n\nobjetos manipuladores de eventos temporizados. Um cen\u00e1rio t\u00edpico de \n\nutiliza\u00e7\u00e3o desses servi\u00e7os \u00e9 um usu\u00e1rio criar um canal de eventos e registr\u00e1-lo \n\ncomo destino dos eventos gerados por um manipulador de eventos \n\ntemporizados. Dessa forma, o usu\u00e1rio pode usar o objeto manipulador de \n\neventos temporizados para criar eventos temporizados quando desejar. \n\nBasicamente, o servi\u00e7o de eventos temporizados permite que um objeto possa \n\n\"ligar\" o tempo para disparo do evento (indicando inclusive que esse disparo \n\npode ser peri\u00f3dico). Permite tamb\u00e9m que um objeto que recebeu a notifica\u00e7\u00e3o \n\nde um evento,  possa determinar o tempo em que o evento ocorreu.  \n\n\n\n 74\n\n5 A API AdventSNMP e o Protocolo SNMP \n\nA API AdventNet SNMP \u00e9 um ambiente que prov\u00ea acesso multiplataforma . \u00c9 \n\nempregada na implementa\u00e7\u00e3o de aplica\u00e7\u00f5es (ou applets) de gerenciamento de redes. \n\nSuporta os padr\u00f5es SNMPv1, SNMPv2c e SNMPv3. O Simple Network Management \n\nProtocol (SNMP) \u00e9 um dentre v\u00e1rios tipos de protocolos que definem mensagens \n\nrelacionadas ao gerenciamento de redes [ADVENTNET 01].  \n\nO SNMP \u00e9 um protocolo prim\u00e1rio, utilizado para transferir dados entre duas ou \n\nmais entidades de rede ou nodos. Conforme j\u00e1 comentado no primeiro cap\u00edtulo deste \n\ntrabalho, o gerenciamento de redes deve garantir a disponibilidade dos servi\u00e7os \n\noferecidos pela infraestrutura de rede e para tanto os dispositivos que comp\u00f5em tal \n\ninfraestrutura devem ser monitorados e controlados. Gerenciamento local e \n\ngerenciamento remoto s\u00e3o dois modos de gerenciamento de um dispositivo conectado \u00e0 \n\nrede. O gerenciamento local requer um gerente humano no local onde o objeto \n\ngerenciado est\u00e1 situado. Claramente, redes grandes inviabilizam a aplica\u00e7\u00e3o do \n\ngerenciamento local. E remotamente, o gerenciamento \u00e9 facilitado com o SNMP.  \n\nAtrav\u00e9s do SNMP, uma esta\u00e7\u00e3o rodando uma ou mais aplica\u00e7\u00f5es de ger\u00eancia \n\npodem monitorar dados de gerenciamento coletados por v\u00e1rios dispositivos de rede. \n\nTais dados podem ser usados para restabelecer o funcionamento da rede e prever o \n\nsurgimento de problemas.  \n\n5.1 Diferentes Vers\u00f5es do SNMP \n\nA Internet Engineering Task Force (IETF) publica documentos denominados \n\nRequests For Comments (RFCs)31. Tais documentos s\u00e3o vers\u00f5es finais especifica\u00e7\u00f5es \n\nde  padr\u00f5es, pr\u00e1ticas operacionais, opini\u00f5es e outros sobre os protocolos Internet. \n\nAtualmente existem tr\u00eas vers\u00f5es do SNMP: \n\n                                                                  \n31 http://www.rfc-editor.org/rfcfaq \n\n\n\n 75\n\n SNMPv1, sendo a primeira vers\u00e3o do protocolo, o qual \u00e9 definido nas RFCs \n\n1155 e 1157; \n\n SNMPv2c, \u00e9 a vers\u00e3o revisada do protocolo, adicionando melhoramentos ao \n\nSNMPv1 nas \u00e1reas de tipo de pacote, mapeamento de transporte, elementos da \n\nestrutura da MIB. Est\u00e1 definido nas RFCs 1901, 1905 e 1906; \n\n SNMPv3, \u00e9 a vers\u00e3o segura do SNMP. SNMPv3 tamb\u00e9m facilita configura\u00e7\u00e3o \n\nremota de entidades SNMP. Est\u00e1 definido nas RFCs 1905, 1906, 2261, 2262, \n\n2263, 2264 e 2265. \n\nSNMPv1 foi o padr\u00e3o e primeira vers\u00e3o SNMP. O SNMPv2 foi disponibilizado \n\ncomo uma atualiza\u00e7\u00e3o do SNMPv1 atrav\u00e9s da adi\u00e7\u00e3o de novas caracter\u00edsticas. Os \n\nmelhoramentos chave do SNMPv2 est\u00e3o concentrados no SMI (discutida nas se\u00e7\u00f5es \n\nposteriores desse texto), capacidade gerente-para-gerente e opera\u00e7\u00f5es de protocolo. O \n\nSNMPv2c combina a abordagem baseada em comunidade do SNMPv1 com a opera\u00e7\u00e3o \n\nde protocolo do SNMPv2, omitindo todas as caracter\u00edsticas de seguran\u00e7a do SNMPv2. \n\nUma not\u00e1vel defici\u00eancia do SNMP era a dificuldade de monitoramento de redes, em \n\noposi\u00e7\u00e3o de nodos de uma rede. Assim, uma melhora substancial de funcionalidade no \n\nSNMP foi a defini\u00e7\u00e3o de um conjunto de objetos gerenciados padronizados a MIB de \n\nmonitoramento remoto de rede (Remote Network Monitoring (RMON) MIB). Outra \n\ngrande defici\u00eancia era a lucuna de facilidade de seguran\u00e7a. O desenvolvimento do \n\nSNMPv3 foi embasado em servi\u00e7os de seguran\u00e7a como autentica\u00e7\u00e3o, privacidade, \n\nautoriza\u00e7\u00e3o e controle de acesso. O SNMPv3 define duas capacidades relacionadas com \n\nseguran\u00e7a: User-Based Security Model (USM) e o View-Based Security Model \n\n(VACM). \n\nA distribui\u00e7\u00e3o AdventNet SNMPv3 suporta as vers\u00f5es v1, v2c e v3 do SNMP \n\n[ADVENTNET 01]. \n\n5.2 Panorama Hist\u00f3rico \n\n\n\n 76\n\nA ARPANET foi a primeira rede de pesquisa financiada pelo DoD (Departamento \n\nde Defesa dos EUA), que conectava v\u00e1rias universidades e \u00f3rg\u00e3os governamentais \n\natrav\u00e9s de linhas telef\u00f4nicas. Quando redes de r\u00e1dio e sat\u00e9lite foram introduzidas, os \n\nproblemas de intercomunica\u00e7\u00e3o cresceram e o TCP/IP foi desenvolvido para facilitar a \n\nconex\u00e3o entre essas m\u00faltiplas redes. Em primeiro de janeiro de 1983, o TCP/IP tornou-\n\nse o \u00fanico protocolo oficial usado pelo DoD, marcando o decl\u00ednio da ARPANET. \n\nNascia o embri\u00e3o da rede hoje denominada Internet.  \n\nApesar do r\u00e1pido crescimento da Internet na d\u00e9cada de 80, n\u00e3o haviam modelos \n\npadronizados para gerenciamento. Para preencher a lacuna, tr\u00eas modelos foram \n\ndesenvolvidos: o High-Level Entity Management System (HEMS), o Common \n\nManagement Information Protocol (CMIP) proposto pelo Open Systems \n\nInterconnection (OSI), um grupo da International Standards Organization (ISO) e o \n\nSimple Gateway Monitoring Protocol (SGMP). O CMIP operando sobre o protocolo \n\nTCP foi indicado pela ISO como protocolo de gerenciamento efetivamente utilizado na \n\nInternet. Em fevereiro de 1988, o ent\u00e3o IAB reuniu um comit\u00ea ad hoc para determinar \n\nqual modelo seria adotado. Optou-se pelo CMOT como uma escolha natural. O SGMP \n\nera a solu\u00e7\u00e3o de curto prazo, utilizada antes do CMOT ser distribu\u00eddo. \n\n Para uma transi\u00e7\u00e3o efetiva dos sistemas do SGMP para o CMOT, um framework \n\ncomum para gerenciamento de redes foi desenvolvido para que pudesse ser usado em \n\nambos os modelos. Tal framework foi denominado Simple Network Management \n\nProtocol (SNMP). Em abril de 1989, SNMP recebeu o status de recomenda\u00e7\u00e3o pelo \n\nIAB, como sendo o framework de fato em utiliza\u00e7\u00e3o para o gerenciamento de redes. \n\nCMOT e SNMP passaram a desenvolver-se de maneira independente. Como tentativa \n\nde consenso, em maio de 1990 o IAB tornou o SNMP o protocolo padr\u00e3o para \n\ngerenciamento de redes e um framework recomendado para uso na Internet e em todas \n\nas redes TCP/IP. \n\n5.3 Vantagens Propiciadas pelo SNMP \n\n\n\n 77\n\nComo o nome sugere, o protocolo SNMP \u00e9 simples de ser entendido e o agente \n\nrequer apenas software m\u00ednimo. Essa simplicidade serve como raz\u00e3o primordial para \n\nsua aceita\u00e7\u00e3o como padr\u00e3o de gerenciamento na Internet.  \n\nAlguns dos  benef\u00edcios advindos do emprego do SNMP s\u00e3o:   \n\n padroniza\u00e7\u00e3o. Uma vez que o SNMP \u00e9 um protocolo de gerenciamento de \n\nrede padr\u00e3o para redes TCP/IP. Protocolos Internet s\u00e3o padr\u00f5es abertos e n\u00e3o-\n\npropriet\u00e1rios, desenvolvidos atrav\u00e9s dos esfor\u00e7os da comunidade Internet,  \n\nsofrendo uma ativa manuten\u00e7\u00e3o e atualiza\u00e7\u00e3o; \n\n aceita\u00e7\u00e3o abrangente. Todos os maiores fabricantes suportam SNMP.  Todos \n\nos dispositivos gerenciados pelo SNMP utilizam a mesma interface e suportam \n\num conjunto comum de informa\u00e7\u00f5es de gerenciamento de rede;  \n\n portabilidade. O SNMP \u00e9 implementado inteiramente em n\u00edvel de software e \u00e9 \n\nindependente de sistemas operacionais e linguagens de programa\u00e7\u00e3o. O \n\nprojeto funcional do SNMP tamb\u00e9m \u00e9 port\u00e1vel e define um conjunto b\u00e1sico de \n\nopera\u00e7\u00f5es que devem funcionar de maneira id\u00eantica em todos os dispositivos \n\nque suportam SNMP; \n\n leveza. SNMP facilita a adi\u00e7\u00e3o de capacidade de gerenciamento para um \n\ndispositivo sem um impacto significativo na opera\u00e7\u00e3o ou desempenho do \n\ndispositivo; \n\n estensibilidade. SNMP \u00e9 um conjunto b\u00e1sico de opera\u00e7\u00f5es que se mant\u00e9m em \n\ntodos os dispositivos gerenciados. Suporta qualquer tipo de informa\u00e7\u00e3o em \n\nqualquer tipo de dispositivo que seja parte de uma rede de computadores; \n\n5.4 Componentes b\u00e1sicos do SNMP \n\nOs tr\u00eas maiores componentes do SNMP s\u00e3o o dispositivo de rede, o agente e o \n\ngerente. Na fig. 5.1 \u00e9 apresentado o modelo de gerenciamento de redes SNMP. \n\n\n\n 78\n\nEsta\u00e7\u00e3o de Gerenciamento\n\nREDE\n\nMIB\n\nAgente SNMP\n\nMIB\n\nAgente SNMPRoteador\n\nMIB\n\nAgente SNMPRoteador\n\nMIB\n\nAgente SNMP\n\n \n\nFIGURA 5.1 \u2013 COMPONENTES B\u00c1SICOS DO MODELO SNMP \n\n5.4.1 Dispositivo de Rede \n\nO dispositivo de rede ou objeto gerenciado \u00e9 parte de uma rede que requer algum \n\ntipo de monitoramento ou ger\u00eancia. O agente reside no objeto gerenciado para coletar \n\ninforma\u00e7\u00e3o e disponibiliz\u00e1-la para o gerente. \n\n5.4.2 Agente \n\nUm agente \u00e9 um mediador entre o gerente e o dispositivo. O agente reside no \n\ndispositivo e torna a informa\u00e7\u00e3o de gerenciamento dispon\u00edvel para o gerente. Entende-\n\nse que o agente \u00e9 um programa que reside no dispositivo ou aplica\u00e7\u00e3o e n\u00e3o constitui \n\numa entidade f\u00edsica distinta. Um agente t\u00edpico deve: \n\n implementar o protocolo SNMP; \n\n armazenar e recuperar informa\u00e7\u00f5es de gerenciamento conforme definido na \n\nMIB;  \n\n\n\n 79\n\n coletar e manter informa\u00e7\u00e3o sobre o ambiente local; \n\n poder enviar de maneira ass\u00edncrona um evento para o gerente e  \n\n funcionar como um proxy para nodos de rede gerenciados n\u00e3o-SNMP. \n\n5.4.3 Gerente \n\nUm gerente \u00e9 uma entidade distinta que gerencia os agentes de pontos remotos da \n\nrede. Tipicamente \u00e9 um computador que \u00e9 utilizado para executar um ou mais sistemas \n\nde gerenciamento de rede. Considere, por exemplo, uma organiza\u00e7\u00e3o que possua \n\nescrit\u00f3rios em diferentes localiza\u00e7\u00f5es geogr\u00e1ficas. A administra\u00e7\u00e3o de todos os \n\ncomputadores presentes nas diferentes localidades pode tornar-se dif\u00edcil. Mas, quando o \n\nSistema Administrador possui um gerente e todos os outros dispositivos e sistemas \n\npossuem agentes, a tarefa de gerenciamento \u00e9 facilitada. O administrador deve apenas \n\nconsultar o agente atrav\u00e9s do gerente para estabelecer o estado de funcionamento de um \n\ndispositivo. Um gerente t\u00edpico: \n\n \u00e9 implementado como um Sistema de Gerenciamento de Rede; \n\n deve implementar o protocolo SNMP  e \n\n estar apto para consultar agentes, obter respostas, modificar vari\u00e1veis nos \n\nagentes al\u00e9m de reconhecer  e tratar eventos ass\u00edncronos gerados pelos \n\nagentes.  \n\n5.4.4 Comunica\u00e7\u00e3o entre o Gerente e o Agente   \n\nA comunica\u00e7\u00e3o entre o gerente e o agente na rede \u00e9 implementada atrav\u00e9s de troca \n\nde Protocol Data Units (PDU). Essas PDUs permitem o gerente SNMP interagir com o \n\nagente SNMP residente no dispositivo e estender as possibilidades de gerenciamento \n\ndependendo daquilo que o agente torna dispon\u00edvel. O protocolo SNMP funciona \n\nbasicamente em um processo de \u201cpolling\u201d, onde o gerente consulta periodicamente os \n\n\n\n 80\n\nagentes para determinar o estado dos objetos gerenciados. S\u00e3o exce\u00e7\u00f5es a esta regra as \n\nmensagens de trap que s\u00e3o geradas pelo agente. Considerando traps, quando uma \n\ninterface de um roteador falha, por exemplo, um trap \u00e9 enviado ao sistema de \n\ngerenciamento notificando o problema. Este poder\u00e1 ent\u00e3o pesquisar o dispositivo em \n\nquest\u00e3o para determinar a extens\u00e3o do problema. \n\nAntes que os dados possam ser transportados atrav\u00e9s da rede, eles devem ser \n\nencapsulados. As PDUs s\u00e3o encapsuladas em User Datagram Protocol (UDP). O UDP \n\n\u00e9 um protocolo de transporte n\u00e3o orientado a conex\u00e3o, inclu\u00eddo no conjunto de procolos \n\nTCP/IP e descrito na RFC 768. \n\nAl\u00e9m de operar sob o protocolo de transporte UDP, que \u00e9 n\u00e3o orientado a \n\nconex\u00e3o, o pr\u00f3prio SNMP \u00e9 um protocolo n\u00e3o orientado a conex\u00e3o, sendo cada troca de \n\nmensagens entre o gerente e o agente uma transa\u00e7\u00e3o distinta.  \n\nO SNMP \u00e9 implementado usando abordagem cliente/servidor ass\u00edncrona. Assim \n\numa entidade SNMP (esta\u00e7\u00e3o de gerenciamento ou dispositivo gerenciado) n\u00e3o \n\nnecessita aguardar por uma resposta depois de enviar uma mensagem. Ele pode enviar \n\noutra mensagem se necess\u00e1rio, ou continuar com suas fun\u00e7\u00f5es predefinidas. Em vez de \n\nusar um protocolo baseado no reconhecimento, que consome largura de banda, o SNMP \n\nusa a pr\u00f3pria resposta como parte de reconhecimento da solicita\u00e7\u00e3o. \n\n Cada esta\u00e7\u00e3o de gerenciamento, bem como os agentes, devem implementar os \n\nprotocolos SNMP e em raz\u00e3o disso, o UDP e IP, para estabelecer a comunica\u00e7\u00e3o. Essa \n\nexig\u00eancia limita o uso do SNMP a dispositivos que implementam totalmente o TCP/IP. \n\nPara permitir que dispositivos que n\u00e3o suportam o TCP/IP possam ser gerenciados \n\ncriou-se o conceito de agente proxy. Tal agente \u00e9 capaz de comunicar-se usando SNMP, \n\nem nome de outro dispositivo, retornando o resultado da comunica\u00e7\u00e3o ao dispositivo \n\nrepresentado de acordo com o protocolo que ele entende. Assim o agente proxy \n\nestabelece uma fun\u00e7\u00e3o de mapeamento, recebendo as informa\u00e7\u00f5es do dispositivo \n\nrepresentado e convertendo-as em mensagens SNMP e vice-versa. \n\n Na fig. 5.2 pode-se ver a comunica\u00e7\u00e3o, atrav\u00e9s de um agente proxy, entre uma \n\nesta\u00e7\u00e3o de gerenciamento e um dispositivo que n\u00e3o suporta SNMP.  \n\n\n\n 81\n\nArquitetura\ndo protocolo usado\n\npelo dispositivo\nrepresentado\n\nProcesso Agente\n\nSNMP\n\nProtocolos\ndependentes de rede\n\nUDP\n\nIP\n\nRede\n\nProcesso Gerente\n\nArquitetura do protocolo\nusado pelo dispositivo\n\nrepresentado\n\nProtocolos\n dependentes de rede\n\nEsta\u00e7\u00e3o de Gerenciamento DispositivoRepresentado\n\nAgente Gerente\n\nSNMP\n\nProtocolos\ndependentes de rede\n\nUDP\n\nIP\n\nFun\u00e7\u00e3o de Mapeamento\n\nProtocolos\ndependentes de rede\n\nAgente Proxy\n\nRede\n\nFIGURA 5.2 \u2013 CONFIGURA\u00c7\u00c3O DE UM AGENTE PROXY \n\n5.4.5 Estrutura \n\nO gerenciamento de rede SNMP \u00e9 composto por tr\u00eas partes, as quais tanto o \n\ngerente quanto os agentes devem estar em conformidade. Tais partes s\u00e3o: \n\n Protocolo SNMP, que define o funcionamento das opera\u00e7\u00f5es b\u00e1sicas do \n\nSNMP e o formato das mensagens trocadas entre o gerente e os agentes.  \n\n Structure of Management Information (SMI), um conjunto de regras usadas \n\npara especificar o formato usado para definir objetos gerenciados ou \n\ndispositivos que s\u00e3o acessados atrav\u00e9s do protocolo SNMP. A SMI est\u00e1 \n\ndefinida na RFC 1155 [ROSE 90].  \n\n Management Information Base (MIB) \u00e9 uma cole\u00e7\u00e3o de defini\u00e7\u00f5es, as quais \n\nespecificam as propriedades do objeto gerenciado.  \n\n5.4.5.1 Management Information Base (MIB) \n\n\n\n 82\n\nManagement Information Bases (MIBs) s\u00e3o cole\u00e7\u00f5es de objetos ou defini\u00e7\u00f5es que  \n\nespecificam as propriedades dos objetos gerenciados. \u00c9 um banco de dados ativo, \n\npossibilitando que suas vari\u00e1veis sejam recuperadas e atualizadas. \n\nPara permitir o gerente SNMP ou a aplica\u00e7\u00e3o de ger\u00eancia operar inteligentemente \n\nos dados dispon\u00edveis no dispositivo, o gerente precisa conhecer o nome e os tipos dos \n\nobjetos no dispositivo gerenciado. Isto se torna poss\u00edvel atrav\u00e9s dos m\u00f3dulos MIB, que \n\ns\u00e3o especificados nos arquivos MIB geralmente fornecidos com os dispositivos \n\ngerenciados. A MIB  em si \u00e9 somente uma abstra\u00e7\u00e3o dos dados.Os padr\u00f5es de \n\ngerenciamento OSI e Internet definiram MIBs que representam os objetos necess\u00e1rios \n\npara a ger\u00eancia de seus recursos. \n\n5.4.5.1.1 MIB OSI \n\nO padr\u00e3o OSI define tr\u00eas modelos distintos para ger\u00eancia de redes: o modelo \n\norganizacional, o modelo informacional e o modelo funcional. O modelo organizacional \n\ndescreve a forma pela qual a ger\u00eancia pode ser distribu\u00edda entre dom\u00ednios e sistemas \n\ndentro de um mesmo dom\u00ednio. O modelo funcional descreve as \u00e1reas funcionais e seus \n\nrespectivos relacionamentos.J\u00e1 o modelo informacional prov\u00ea a base para a defini\u00e7\u00e3o de \n\nobjetos gerenciados e suas rela\u00e7\u00f5es, classes atributos, a\u00e7\u00f5es e nomes.  \n\nNa defini\u00e7\u00e3o de objetos gerenciados \u00e9 utilizada a orienta\u00e7\u00e3o a objetos (OO). \n\nSegundo o paradigma OO, objetos com caracter\u00edsticas semelhantes agrupam-se em \n\nclasses de objetos. Uma classe, dita derivada ou filha, pode ser uma subclasse de outra \n\nchamada classe base ou superclasse. A classe filha herda todas as propriedades da classe \n\nbase. Uma classe \u00e9 definida pelos atributos da classe, pelas a\u00e7\u00f5es que podem ser \n\ninvocadas, pelos eventos que podem ser relatados, pela subclasse a qual ela deriva e \n\npela superclasse na qual ela est\u00e1 contida. \n\nPara a defini\u00e7\u00e3o dos objetos gerenciados deve-se considerar tr\u00eas hierarquias:  \n\n\u2022 Hierarquia de Heran\u00e7a \u2013 Tamb\u00e9m denominada hierarquia de classe, tem \n\ncomo objetivo facilitar a modelagem dos objetos, atrav\u00e9s da utiliza\u00e7\u00e3o do \n\n\n\n 83\n\nparadigma da orienta\u00e7\u00e3o a objetos. Assim podem ser definidas classes, \n\nsuperclasses, subclasses. Trata-se de uma ferramenta para uma melhor \n\ndefini\u00e7\u00e3o de classes. \n\n\u2022 Hierarquia de Nomea\u00e7\u00e3o \u2013 A hierarquia de nomea\u00e7\u00e3o, tamb\u00e9m chamada \n\nhierarquia de containment, descreve a rela\u00e7\u00e3o de \u201cestar contido em\u201d \n\naplicado aos objetos. Um objeto gerenciado est\u00e1 contido dentro de um e \n\nsomente um objeto gerenciado. Um objeto gerenciado existe somente se o \n\nobjeto que o cont\u00e9m existir, e dependendo da defini\u00e7\u00e3o, um objeto s\u00f3 pode \n\nser removido se aqueles que lhe pertencerem forem removidos primeiro. \n\n\u2022 Hierarquia de Registro \u2013 A hierarquia de registro \u00e9 usada para identificar \n\nde maneira universal os objetos, independentemente das hierarquias de \n\nheran\u00e7as e nomea\u00e7\u00e3o. Esta hierarquia \u00e9 expressa segundo regras \n\nestabelecidas pela nota\u00e7\u00e3o de dados baseada em texto denominada \n\nAbstract Syntax Notation One (ASN.1), uma descri\u00e7\u00e3o de dados n\u00e3o \n\namb\u00edgua no formato de texto ASCII. Assim, cada objeto \u00e9 identificado por \n\numa seq\u00fc\u00eancia de n\u00fameros, correspondente aos n\u00f3s percorridos desde a \n\nraiz, at\u00e9 o objeto em quest\u00e3o. Esta hierarquia \u00e9 tamb\u00e9m usada pelo padr\u00e3o \n\nInternet. \n\n5.4.5.1.2 MIB Internet \n\nA primeira vers\u00e3o da MIB destinada ao protocolo TCP/IP foi definida na RFC \n\n1066 e ficou conhecida como MIB-I. A RFC 1066 definiu a base de informa\u00e7\u00e3o \n\nnecess\u00e1ria para monitorar e controlar redes baseadas no protocolo TCP/IP. O RFC 1066 \n\nfoi aceito pelo IAB (Internet Activities Board) como padr\u00e3o na RFC 1156. \n\nA MIB-II \u00e9 um superconjunto da MIB-I com alguns objetos e grupos adicionais, \n\nestando definida na RFC 1213. \n\n\n\n 84\n\nAs MIBs padr\u00e3o s\u00e3o todas aquelas aprovadas pelo IAB. Fabricantes de software e \n\nequipamentos definem MIBs privadas de maneira unilateral. A distin\u00e7\u00e3o entre MIBs \n\npadr\u00e3o e privada est\u00e1 baseada em como as vari\u00e1veis est\u00e3o definidas.  \n\nO melhor exemplo de uma MIB padr\u00e3o \u00e9 a rfc1213-MIB (tamb\u00e9m conhecida \n\ncomo MIB-II). \u00c9 um modulo MIB tipicamente suportado por todos os agentes SNMP \n\nem dispositivos TCP/IP dispon\u00edveis.  \n\nNo padr\u00e3o Internet os objetos gerenciados s\u00e3o definidos em uma \u00e1rvore de \n\nregistro, equivalente a hierarquia de registro do padr\u00e3o OSI. O m\u00f3dulo MIB cont\u00e9m a \n\ndescri\u00e7\u00e3o de uma hierarquia de objetos nos dispositivos gerenciados, bem como o nome \n\n(Object ID), sintaxe e privil\u00e9gios de acesso para cada vari\u00e1vel na MIB. \n\nPor exemplo: \n\ndirectory(1) \n\nidentificador de objetos: 1.3.6.1.1 \n\ndescri\u00e7\u00e3o textual: {internet 1} \n\nUm n\u00f3 rotulado pode possuir sub\u00e1rvores, que por sua vez podem conter outros \n\nn\u00f3s rotulados. Caso n\u00e3o tenha sub\u00e1rvores, ou n\u00f3s folhas, o n\u00f3 rotulado conter\u00e1 um valor \n\ne ser\u00e1 um objeto. \n\nO n\u00f3 raiz da \u00e1rvore MIB n\u00e3o possui nome ou n\u00famero, mas tem tr\u00eas sub-\u00e1rvores: \n\n\u2022 ccitt(0), administrada pelo CCITT; \n\n\u2022 iso(1), administrada pela ISO; \n\n\u2022 joint-iso-ccitt(2), administrada pela Isso juntamente com o CCITT. \n\nSob o n\u00f3 iso(1), est\u00e3o outras sub-\u00e1rvores, como \u00e9 o caso da sub-\u00e1rvore org(3), \n\ndefinida pela ISO para conter outras organiza\u00e7\u00f5es. Uma das organiza\u00e7\u00f5es que est\u00e1 sob a \n\nsub-\u00e1rvore org(3) \u00e9 o DoD (Departamento de Defesa dos EUA), no n\u00f3 dod(6). A \n\nInternet(1) est\u00e1 sob o dod(6), possuindo quatro sub\u00e1rvores: \n\n\u2022 directory(1): cont\u00e9m informa\u00e7\u00f5es sobre o servi\u00e7o de diret\u00f3rios OSI \n\n(X.500); \n\n\n\n 85\n\n\u2022 mgmt(2): cont\u00e9m informa\u00e7\u00f5es de gerenciamento, \u00e9 sob esta sub\u00e1rvore que \n\nest\u00e1 o n\u00f3 da mibII, com o identificador de objeto 1.3.6.1.2.1 ou { mgmt 1 \n\n}; \n\n\u2022 experimental(3): cont\u00e9m os objetos que ainda est\u00e3o sendo pesquisados \n\npelo IAB; \n\n\u2022 private(4): cont\u00e9m objetos definidos por outras organiza\u00e7\u00f5es. \n\nA fig. 5.3 apresenta parte da estrutura em \u00e1rvore de uma MIB. \n\niso (1)\n\norg (3)\n\ndod (6)\n\nenterprises (1)\n\ninternet (1)\n\nprivate (4)\n\ntransmission (10)\n\nexperimental (3)\n\negp (8)\n\nsnmp (11)\n\nudp (7)\n\ntcp (6)\n\nicmp (5)\n\nip (4)\n\nat (3)\n\ninterface (2)\n\nsystem (1)\n\nmib-2 (1)\n\nmgmt (2)\n\ndirectory (1)\n\n \n\nFIGURA 5.3 \u2013 FRAGMENTO DA ESTRUTURA DE UMA MIB \n\n\n\n 86\n\nAbaixo da sub\u00e1rvore mibII est\u00e3o os objetos usados para obter informa\u00e7\u00f5es \n\nespec\u00edficas dos dispositivos da rede. Esses objetos s\u00e3o categorizados em 11 grupos, que \n\ns\u00e3o apresentados na tabela 5.1. \n\nTABELA 5.1 \u2013  GRUPOS DA MIB-II \n\nGrupos Informa\u00e7\u00f5es \n\nSystem(1)  Sistema de opera\u00e7\u00e3o dos dispositivos da rede  \n\nInterfaces(2) Interface da rede com o meio f\u00edsico \n\nAddress translation(3)  Mapeamento de endere\u00e7os IP em endere\u00e7os f\u00edsicos  \n\nIp(4)  Protocolo IP \n\nIcmp(5 )  Protocolo ICMP  \n\nTcp(6) Protocolo TCP \n\nUdp(7)  Protocolo UDP  \n\nEgp(8) Protocolo EGP \n\nCmot(9)  Protocolo CMOT  \n\nTransmission(10) Meios de transmiss\u00e3o \n\nSnmp(11) Protocolo SNMP \n\nCada objeto contido nos grupos apresentados na tabela 1 \u00e9 descrito no RFC1213. \n\nA descri\u00e7\u00e3o dos objetos \u00e9 dividida em cinco partes: o nome do objeto, a sintaxe abstrata \n\ndo objeto, a descri\u00e7\u00e3o textual do significado do objeto, o tipo de acesso permitido ao \n\nobjeto (read-only, read-write, write-only ou n\u00e3o acess\u00edvel), e o estado do objeto \n\n(obrigat\u00f3rio, opcional, obsoleto).  \n\nUm aspecto chave das MIBs \u00e9 que somente o tipo dos objetos no dispositivo \n\ngerenciado est\u00e1 definido na MIB e n\u00e3o inst\u00e2ncias espec\u00edficas. Por exemplo, ifInOctets \n\nna rfc1213-MIB especifica um tipo de objeto, para n\u00famero de octetos de entrada em \n\numa interface, mas as inst\u00e2ncias espec\u00edficas desse tipo s\u00e3o especificadas como \n\nifInOctets.1, ifInOctets.2, etc., dependendo do n\u00famero de interfaces. Quando especificar \n\num objeto para o agente SNMP, um Object ID apropriado, que inclui a inst\u00e2ncia, \n\n\n\n 87\n\nprecisa ser informado pelo gerente. Quando n\u00e3o especificado corretamente, o agente \n\nresponde com um erro \"No such variable\". \n\n5.4.5.2 OID \n\nO gerente SNMP ou aplica\u00e7\u00f5es de gerenciamento, utilizam nomes com sintaxe \n\nbem definida para especificar as vari\u00e1veis de interesse para o agente SNMP. Nomes de \n\nobjeto nessa sintaxe s\u00e3o denominados Object Identifiers (object Ids ou OIDs), e s\u00e3o uma \n\ns\u00e9rie de n\u00fameros que univocamente identificam um objeto para o agente SNMP.   \n\nOIDs s\u00e3o arranjados em uma estrutura hier\u00e1quica, de \u00e1rvore invertida. A \u00e1rvore \n\nOID inicia com a raiz e expande-se abaixo para  os ramos. Cada ponto na \u00e1rvore OID \u00e9  \n\nchamado de nodo e  cada nodo pode possuir um ou mais ramos, ou pode terminar com \n\num nodo folha. O formato do OID \u00e9 uma seq\u00fc\u00eancia  de n\u00fameros separados por pontos. \n\nExistem duas ra\u00edzes para identificadores de objetos: iso ( .1) e ccit (iniciando com .0) . \n\nMuitos idenficadores iniciam com .1.3.6.1 (onde  1=iso, 3=org, 6= dod, 1 = internet). \n\n Os ramos internet dividem-se em mgmt e private. Todas as MIB padr\u00e3o est\u00e3o sob \n\nmgmt, enquanto que as MIBs privadas est\u00e3o abaixo de private.enterprises.  \n\nPara esclarecer o conceito de identificadores de objeto Relativo e Absoluto, \n\nconsideremos o identificador de objeto AdventNet .1.3.6.1.4.1.2162. Ele especifica um \n\ncaminho a partir da raiz da \u00e1rvore. A raiz n\u00e3o tem um nome ou um n\u00famero, mas o 1 \n\ninicial neste OID est\u00e1 diretamente abaixo da raiz. Esse \u00e9 chamado de OID absoluto. Por \n\noutro lado, caminhos para vari\u00e1vel podem ser especificados relativamente a algum nodo \n\nna \u00e1rvore OID. Por exemplo,  2.1.1.7 especifica o objeto sysContact no grupo system, \n\nrelativo ao nodo internet (.1.3.6.1) na \u00e1rvore OID. Este \u00e9 um OID relativo. \n\nPara obter valores de objetos do agente, \u00e9 necess\u00e1rio especificar a inst\u00e2ncia do \n\nobjeto. Adicionando o \u00edndice de inst\u00e2ncia ao OID especifica-se a inst\u00e2ncia do mesmo. \n\nPor exemplo, o \u00faltimo 0 em .iso.3.dod.1.mgmt.mib.1.sysUpTime.0, \u00e9 o \u00edndice de \n\ninst\u00e2ncia. Um \u00edndice de int\u00e2ncia \u201c0\u201d indica a primeira int\u00e2ncia, \u201c1\u201d a segunda, e assim \n\nsucessivamente. Sendo sysUpTime um objeto escalar, ele possui apenas uma \u00fanica \n\ninst\u00e2ncia. Ent\u00e3o, um \u00edndice de inst\u00e2ncia de 0 \u00e9 sempre especificado quando recupera-se \n\n\n\n 88\n\no valor de um objeto escalar. Um \u00edndice de inst\u00e2ncia maior do que 0 pode somente ser \n\nutilizado no caso de objetos colunares (em tabela), que podem possuir m\u00faltiplas \n\ninst\u00e2ncias.  \n\n5.4.5.3 SMI e vers\u00f5es SMI \n\nStructure of Management Information \u00e9 um conjunto de regras usadas para \n\nespecificar o formato usado na defini\u00e7\u00e3o de objetos gerenciados ou dispositivos \n\nacessados atrav\u00e9s do SNMP.  \n\nA SMI descreve a \u00e1rvore de nomes MIB, que \u00e9 usada para identificar objetos \n\ngerenciados e definir os ramos da \u00e1rvore MIB onde residem os objetos SNMP \n\ngerenciados.  \n\nAs duas vers\u00f5es do SMI s\u00e3o SMIv1 e SMIv2. SMIv1 \u00e9 definido na RFC 1155, \n\nRFC 1212 e RFC 1215 e o SMIv2 \u00e9 definido nas RFCs 1902, 103 e 1904. \n\nSMIv2 \u00e9 retroativamente compat\u00edvel com o SMIv1. Isso significa que \u00e9 poss\u00edvel \n\nconverter uma MIB SMIv2 para SMIv1, com exce\u00e7\u00e3o daqueles objetos do tipo de dados \n\nCounter64. Por\u00e9m, a convers\u00e3o de SMIv1 para SMIv2, n\u00e3o \u00e9 autom\u00e1tica. Isso se deve \n\nao fato do SMIv2 englobar o  SMIv1. Tamb\u00e9m, o formato SMIv2 cont\u00e9m constru\u00e7\u00f5es \n\npara definir requisi\u00e7\u00e3o de especifica\u00e7\u00f5es e implementa\u00e7\u00e3o de requisi\u00e7\u00f5es, que n\u00e3o \n\nintegram o formato SNMPv1. \n\n5.4.5.4 SMI Data Types  \n\nTipos de dado podem ser inteiro, ponto flutuante, string octeto e identificador \n\n\u00fanico. Os m\u00f3dulos MIB e SMI s\u00e3o expressos em ASN.1. Os dados da MIB s\u00e3o \n\ntransportados pela rede usando mensagens SNMP, as quais s\u00e3o codificadas em Basic \n\nEncoding Rules (BER). S\u00e3o similares ao SMI, mas as mensagens s\u00e3o codificadas no \n\nformato bin\u00e1rio. Tanto o ASN.1 e BER s\u00e3o essenciais para a implementa\u00e7\u00e3o do SNMP. \n\n\n\n 89\n\nOs tipos disponibilizados pelo ASN.1 s\u00e3o categorizado em tipos simples e tipos \n\nestruturados. Os desenvolvedores do SNMP escolheram os tipos simples, os quais \n\nincluem os tipos INTEGER, OCTET STRING e OBJECT IDENTIFIER. Os outros \n\ntipos escolhidos foram Gauge, Counter, TimeTicks, IPAddress, NetworkAddress e \n\nOpaque. \n\nA API SNMP suporta os padr\u00f5es SMIv1 e SMIv2. Os v\u00e1rios tipos de dados para \n\ninforma\u00e7\u00e3o de gerenciamento s\u00e3o apresentados na Tabela 5.1.  \n\nTABELA 5.2 \u2013 TIPOS DE DADOS SMI \n\nTipos de Dados SMIv1 Tipos de Dados SMIv2 \n\nINTEGER Integer32 \n\nINTEGER(enumerated integer) INTEGER(enumerated integer) \n\nUnsigned32 \n\nGauge Gauge32 \n\nCounter  Counter32 \n\nCounter64 \n\nTimeTicks TimeTicks \n\nOCTET STRING OCTET STRING \n\nOBJECT IDENTIFIER OBJECT IDENTIFIER \n\nIpAddress IpAddress \n\nNetworkAddress  \n\nOpaque Opaque \n\n BITS \n\n5.4.5.5 Tipos de Dados MIB SMIv1 \n\nO SMIv1 define os seguintes tipos de dados: \n\n\n\n 90\n\n\u2022 INTEGER. Usado para especificar valores nas quais a faixa inclui \n\nn\u00fameros positivos e negativos. O SNMIv1 n\u00e3o especifica valores m\u00ednimos \n\nou m\u00e1ximos para a faixa; \n\n\u2022 ENUMERATED INTEGER. Usado para especificar uma lista de valores \n\ninteiros nomeados. No SNMIv1 os valores devem ser maiores que zero, \n\nenquanto que no SNMIv2 permite qualquer valor na faixa 231 a 231-1; \n\n\u2022 GAUGE. Representa um inteiro n\u00e3o-negativo que pode ser incrementado \n\nou decrementado, mas at\u00e9 um certo valor m\u00e1ximo ou m\u00ednimo, \n\nrespectivamente; \n\n\u2022 COUNTER. Usado para especificar um valor que representa um \n\ncontagem. A faixa \u00e9 0 at\u00e9 4294967295; \n\n\u2022 TIMETICKS. Usado para especificar o tempo decorrido entre dois \n\neventos, em unidades de mil\u00e9simos de segundo. A faixa \u00e9 0 at\u00e9 232-1; \n\n\u2022 OCTET STRING. Usado para especificar octetos bin\u00e1rios ou informa\u00e7\u00e3o \n\ntextual. Enquanto o SMIv1 n\u00e3o limita o n\u00famero de octetos, o SMIv2 \n\ndetermina um limite de 65535 octetos. Um tamanho pode ser especificado \n\ncomo sendo fixo, variante ou de m\u00faltiplas faixas; \n\n\u2022 OBJECT IDENTIFIER. Usado para identificar um tipo que tenha um \n\natribu\u00eddo um valor de identificador de objeto; \n\n\u2022 IPADDRESS. Usado para especificar um endere\u00e7o Ipv4 como uma string \n\nde 4 octetos; \n\n\u2022 NETWORKADDRESS. Obsoleto. O SMIv2 suporta esse tipo atrav\u00e9s do \n\ntipo IPADDRESS; \n\n\u2022 OPAQUE. Usado para especificar octetos e informa\u00e7\u00e3o bin\u00e1ria. O SMIv2 \n\ndetermina um limite de 65535 octetos, enquanto o SMIv1 n\u00e3o imp\u00f5e \n\nlimita\u00e7\u00e3o. Um valor desse tipo deve um encapsulamento de um valor \n\nASN.1 BER codificado. \n\n\n\n 91\n\n5.4.5.6 Tipos de Dados MIB SMIv2 \n\nO SMIv2 define os seguintes tipos de dados: \n\n\u2022 INTEGER32. Usado para especificar valores nas quais a faixa inclui \n\nn\u00fameros positivos e negativos. O SNMIv2 n\u00e3o especifica valores m\u00ednimos \n\nou m\u00e1ximos para a faixa; \n\n\u2022 ENUMERATED INTEGER. Usado para especificar uma lista de valores \n\ninteiros nomeados. No SNMIv2 s\u00e3o permitidos quaisquer valores \n\npertencentes a faixa 231 a 231-1, enquanto que no SNMIv1 os valores \n\ndevem ser maiores que zero; \n\n\u2022 UNSIGNED32. Usado para especificar valores n\u00e3o negativos na faixa 0 \n\nat\u00e9 a 231-1; \n\n\u2022 GAUGE32. Representa um inteiro n\u00e3o-negativo que pode ser \n\nincrementado ou decrementado, mas at\u00e9 um certo valor m\u00e1ximo ou \n\nm\u00ednimo, respectivamente; \n\n\u2022 COUNTER32. Usado para especificar um valor que representa um \n\ncontagem. A faixa \u00e9 0 at\u00e9 4294967295; \n\n\u2022 COUNTER64. Similar ao COUNTER32, com exce\u00e7\u00e3o da faixa que vai de \n\n0 a 264-1. Como esse tipo n\u00e3o existe no SMIv1, deve ser empregado \n\napenas quando compatibilidade retroativa n\u00e3o \u00e9 requerida; \n\n\u2022 TIMETICKS. Usado para especificar o tempo decorrido entre dois \n\neventos, em unidades de mil\u00e9simos de segundo. A faixa \u00e9 0 at\u00e9 232-1; \n\n\u2022 OCTET STRING. Usado para especificar octetos bin\u00e1rios ou informa\u00e7\u00e3o \n\ntextual. O SMIv2 determina um limite de 65535 octetos, ao contr\u00e1rio do \n\nSMIv1 que n\u00e3o limita o n\u00famero de octetos. Um tamanho pode ser \n\nespecificado como sendo fixo, variante ou de m\u00faltiplas faixas; \n\n\n\n 92\n\n\u2022 OBJECT IDENTIFIER. Usado para identificar um tipo que tenha um \n\natribu\u00eddo um valor de identificador de objeto; \n\n\u2022 IPADDRESS. Usado para especificar um endere\u00e7o Ipv4 como uma string \n\nde 4 octetos; \n\n\u2022 NETWORKADDRESS. Obsoleto. O SMIv2 suporta esse tipo atrav\u00e9s do \n\ntipo IPADDRESS. \n\n\u2022 OPAQUE. Usado para especificar octetos e informa\u00e7\u00e3o bin\u00e1ria. O SMIv2 \n\ndetermina um limite de 65535 octetos, enquanto o SMIv1 n\u00e3o imp\u00f5e \n\nlimita\u00e7\u00e3o. Um valor desse tipo deve um encapsulamento de um valor \n\nASN.1 BER codificado; \n\n\u2022 BITS. Usado para especificar uma cole\u00e7\u00e3o nomeada de bits. Prov\u00ea um \n\nmodo de identificar os bits individuais em um octeto (uma extens\u00e3o do \n\ntipo OCTET STRING). \n\n5.4.6 Opera\u00e7\u00f5es SNMP B\u00e1sicas \n\nConforme j\u00e1 comentado, o SNMP \u00e9 um protocolo solicita\u00e7\u00e3o-resposta. As \n\nopera\u00e7\u00f5es realizadas s\u00e3o categorizadas como :  \n\n Recupera\u00e7\u00e3o de dados - GET, GET NEXT e GET BULK; \n\n Altera\u00e7\u00e3o de vari\u00e1veis \u2013 SET e  \n\n Recebimento de mensagens n\u00e3o solicitadas \u2013 TRAPS. \n\n5.4.6.1 Recupera\u00e7\u00e3o de Dados \n\nUma requisi\u00e7\u00e3o \u00e9 enviada pelo gerente para um agente a fim de retornar dados \n\natrav\u00e9s da execu\u00e7\u00e3o de uma opera\u00e7\u00e3o GET, GETNEXT  ou GETBULK.  \n\n\n\n 93\n\nA opera\u00e7\u00e3o GET \u00e9 uma requisi\u00e7\u00e3o enviada do gerente para o objeto gerenciado \n\natrav\u00e9s do agente. Quando executada retorna um ou mais valores do objeto gerenciado. \n\nJ\u00e1 a opera\u00e7\u00e3o GETNEXT \u00e9 similar a opera\u00e7\u00e3o GET. A diferen\u00e7a significante \u00e9 que o \n\nGETNEXT retorna o valor do pr\u00f3ximo OID na \u00e1rvore. Finalmente, GETBULK retorna \n\ngrandes volumes de dados. \n\n5.4.6.2 Altera\u00e7\u00e3o de Vari\u00e1veis \n\nO gerente pode em dado momento alterar vari\u00e1veis. Essa funcionalidade \u00e9 provida \n\npela opera\u00e7\u00e3o SET. \n\n5.4.6.3 Recebimento de Mensagens N\u00e3o Solicitadas \n\nQuando o agente identifica um erro na transmiss\u00e3o da mensagem, responde ao \n\ngerente enviando uma mensagem n\u00e3o solicitada atrav\u00e9s da opera\u00e7\u00e3o TRAP. \n\n5.4.7 Formato das Mensagens SNMP \n\nNo protocolo SNMP a informa\u00e7\u00e3o \u00e9 trocada entre o gerente e um agente na forma \n\nde mensagem. Cada mensagem inclui um numero de vers\u00e3o, indicando a vers\u00e3o do \n\nSNMP, um nome de comunidade e um dos cinco tipos de PDU: GetRequest, \n\nGetNextRequest, GetResponse, SetRequest e Trap. O formado de cada PDU \u00e9 mostrado \n\nna fig. 5.4 e a descri\u00e7\u00e3o dos campos que a constituem s\u00e3o apresentados na Tabela 5.2 \n\n[STALLINGS 00]. \n\n\n\n 94\n\nVersion Community SNMP PDU\n\nPDU\ntype\n\nrequest-\nid\n\n0 0 variablebindings\n\nPDU\ntype\n\nrequest-\nid\n\nerror-\nstatus\n\nerror-\nindex variablebindings\n\nPDU\ntype\n\nenterpri\nse\n\nagent-\naddr\n\ngeneric-\ntrap\n\nvariablebindings\nspecific-\n\ntrap\ntime-\nstamp\n\nname1 value1 name2 value2 ... valuennamen\n\n(a) Mensagem SNMP\n\n(b) GetRequest, GetNextRequest, SetRequest PDU\n\n(d) Trap PDU\n\n(c) GetResponse PDU\n\n(e) variablebindings\n \n\nFIGURA 5.4 \u2013 FORMATO DAS PDUS SNMP \n\nAs PDU GetRequest, GetNextRequest e SetRequest t\u00eam o mesmo formato da PDU \n\nGetResponse com os campos error-status e error-index sempre tendo o valor zero. Esta \n\nconven\u00e7\u00e3o reduz para um o n\u00famero de diferentes formatos de PDU com que a entidade \n\nSNMP deve lidar [STALLINGS 98]. \n\nTABELA 5.3 \u2013 DESCRI\u00c7\u00c3O DOS CAMPOS DA PDU SNMP \n\nCampo Descri\u00e7\u00e3o \n\nversion Vers\u00e3o do SNMP. \n\ncommunity Nome da comunidade, agindo como uma forma de autentica\u00e7\u00e3o. \n\nrequest-id Usado para distinguir as mensagens enviadas provendo para cada requisi\u00e7\u00e3o um \u00fanico ID. \n\nerror-status Indica que uma exce\u00e7\u00e3o ocorreu durante o processamento de uma requisi\u00e7\u00e3o \n\nerror-index No caso de ocorrer um error-status, este campo cont\u00e9m uma informa\u00e7\u00e3o adicional indicando qual vari\u00e1vel causou a exce\u00e7\u00e3o. \n\nvariablebindings Uma lista de nomes de vari\u00e1veis e seus respectivos valores. \n\nenterprise O tipo de objeto gerador da trap. \n\nagent-addr Endere\u00e7o do objeto gerador da trap. \n\n\n\n 95\n\ngeneric-trap Especifica os tipos gen\u00e9ricos de trap. \n\nspecific-trap C\u00f3digo para uma trap espec\u00edfica. \n\ntime-stamp Tempo decorrido entre a \u00faltima inicializa\u00e7\u00e3o da entidade de rede e a gera\u00e7\u00e3o da trap. \n\nAs mensagens entre o agente e o gerente, com diferentes identificadores de \n\nvers\u00e3o, s\u00e3o simplesmente descartadas sem sofrer qualquer forma de processamento. O \n\nnome da comunidade age como um mecanismo simplificado de senha entre os gerentes \n\ne agentes, ou seja, quando o agente recebe uma solicita\u00e7\u00e3o do gerente, ele confere se os \n\nnomes das comunidades s\u00e3o iguais, caso n\u00e3o sejam, retorna um trap indicando uma \n\nfalha de autentica\u00e7\u00e3o [BAROTTO 98]. \n\nAs PDUs GetRequest e GetNextRequest s\u00e3o comandos do gerente para receber \n\ndados de um agente. A diferen\u00e7a \u00e9 que a opera\u00e7\u00e3o GetRequest lista um valor especifico \n\nde uma ou mais vari\u00e1veis, enquanto que a opera\u00e7\u00e3o GetNextRequest \u00e9 usada para \n\npercorrer a \u00e1rvore MIB. Em ambos os casos, os valores, se dispon\u00edveis, s\u00e3o retornados \n\nao gerente atrav\u00e9s da PDU GetResponse. A opera\u00e7\u00e3o SetRequest \u00e9 um comando do \n\ngerente para o agente, utilizado para atualizar vari\u00e1veis no agente, sendo que neste caso \n\na PDU GetResponse prov\u00ea uma mensagem de confirma\u00e7\u00e3o. Finalmente, a PDU Trap \u00e9 \n\numa notifica\u00e7\u00e3o do agente para o gerente [STALLINGS 98]. \n\n\n\n 96\n\n6. Dom\u00ednio da Aplica\u00e7\u00e3o \n\nConforme exposto no Cap\u00edtulo 1 (Introdu\u00e7\u00e3o), um dos objetivos principais desse \n\ntrabalho \u00e9 demonstrar uma aplica\u00e7\u00e3o de XML na Ger\u00eancia de Redes.  \n\nPara atingir tal objetivo foi implementado um aplicativo de gerenciamento que \n\nextrai informa\u00e7\u00f5es gerenciais de dispositivos de rede dotados de agentes SNMP. O \n\naplicativo comunica-se com o agente SNMP do dispositivo atrav\u00e9s de consultas SNMP \n\ne gerar documentos XML a partir das respostas recebidas. Essa aplica\u00e7\u00e3o foi \n\ndesenvolvida em Java 2. Tais documentos poder\u00e3o ser processados por ferramentas \n\nXML para serem exportados/apresentados em diferentes formatos. \n\nO ambiente de rede que serviu de teste pertence a UNIOESTE (Universidade \n\nEstadual do Oeste do Paran\u00e1), campus de Cascavel, Paran\u00e1. A UNIOESTE \u00e9 uma das \n\ninstitui\u00e7\u00f5es que comp\u00f5em a Intranet Paran\u00e1. Intranet Paran\u00e1 \u00e9 a primeira rede de alta \n\nvelocidade que integra todas as regi\u00f5es paranaenses. Base para o sistema estadual de \n\nCi\u00eancia e Tecnologia, objetiva criar as condi\u00e7\u00f5es ideais para a conex\u00e3o de um canal \n\ninternacional de dados com acesso direto \u00e0 Internet e viabilizar a interoperabilidade \n\nentre as redes de informa\u00e7\u00f5es das institui\u00e7\u00f5es de ensino superior e pesquisa. Constitui \n\num backbone servindo a 45.000 usu\u00e1rios entre pesquisadores, professores e alunos. Tem \n\ncomo ponto central da rede o Centro de Opera\u00e7\u00f5es da Intranet Paran\u00e1 em Curitiba, \n\npodendo ser estendida a pontos remotos, dentro e fora do Paran\u00e1 com links exclusivos \n\nde sat\u00e9lite [INTRANET 02]. A fig. 6.1 apresenta os pontos de presen\u00e7a da Intranet \n\nParan\u00e1. \n\nUm dos fatos que merece aten\u00e7\u00e3o especial dos gerentes de rede \u00e9 o \n\ncongestionamento. Um acr\u00e9scimo gradativo da situa\u00e7\u00e3o de congestionamento, n\u00e3o \n\ntratada pelo gerente, pode ocasionar uma paralisa\u00e7\u00e3o completa da rede. Erros ou mesmo \n\nsobrecargas de certos segmentos da rede podem gerar \u201cgargalos\u201d. \n\nTendo em vista a situa\u00e7\u00e3o de poss\u00edveis gargalos, a aplica\u00e7\u00e3o desenvolvida prop\u00f5e-\n\nse a apresentar a situa\u00e7\u00e3o do tr\u00e1fego dos links TCP/IP que a UNIOESTE mant\u00eam, \n\nprincipalmente com seus outros campi, situados nos munic\u00edpios de Foz do Igua\u00e7u, \n\nFrancisco Beltr\u00e3o, Marechal C\u00e2ndido Rondon e Toledo). Avalia\u00e7\u00f5es sobre o tr\u00e1fego s\u00e3o \n\n\n\n 97\n\nde grande valia particularmente em um momento que a institui\u00e7\u00e3o passa por um \n\nprocesso de reestrutura\u00e7\u00e3o de seus sistemas de informa\u00e7\u00e3o, antes baseados em sistemas \n\nisolados em cada campus para sistemas integrados e distribu\u00eddos, tendo browsers Web \n\ncomo uma ferramenta t\u00edpica para interface com os usu\u00e1rios. \n\nFIGURA 6.1 \u2013 PONTOS DE PRESEN\u00c7A DA INTRANET PARAN\u00c1 \n\nPara a obten\u00e7\u00e3o das informa\u00e7\u00f5es referentes ao tr\u00e1fego, foi considerado um \n\nroteador, equipamento do fabricante Cisco, da s\u00e9rie Cisco 7000 e fisicamente instalado \n\nna Diretoria de Inform\u00e1tica, na Reitoria da UNIOESTE, no munic\u00edpio de Cascavel, \n\n\n\n 98\n\nParan\u00e1. Tal roteador, como mostrado esquematicamente na fig. 6.2, possui uma MIB e \n\num agente SNMP, que dessa forma permite a consulta \u00e0s vari\u00e1veis SNMP atrav\u00e9s de \n\nprimitivas SNMP. \n\nMIB\nAgente\nSNMP\n\nAplica\u00e7\u00e3o\nColetora\n\nSNMP\n\nroteador\n\n200.201.8.1\n\n \n\nFIGURA 6.2 \u2013 ROTEADOR MONITORADO \n\n6.1 Ferramentas Utilizadas \n\nPara a implementa\u00e7\u00e3o dessa aplica\u00e7\u00e3o foram utilizadas as seguintes ferramentas \n\nde software: \n\n\u2022 pacote Java 2 SDK vers\u00e3o 1.4.0, da Sun Microsystems, que inclui o \n\ncompilador Java, a m\u00e1quina virtual Java e a biblioteca de classes padr\u00e3o da \n\nlinguagem; \n\n\u2022 IDE (Integrated Development Environment) destinado a tecnologias Java \n\nJCreator 2.00 PRO, da empresa Xinox Software. O software possui \n\ninterface enxuta e leve, diferente de outras solu\u00e7\u00f5es dispon\u00edveis no \n\nmercado que se caracterizam como exigindo consider\u00e1veis recursos da \n\nm\u00e1quina para executar a pr\u00f3pria interface. O JCreator possui um \n\ngerenciador de projetos, templates de c\u00f3digo, browsers de classes, \n\ncomplementa\u00e7\u00e3o de c\u00f3digo na digita\u00e7\u00e3o (code completion), depurador \n\nintegrado a interface, destacamento de sintaxe (syntax highlighting), \n\nassistentes (wizards) para algumas tarefas e uma interface de usu\u00e1rio \n\ncustomiz\u00e1vel; \n\n\n\n 99\n\n\u2022 API AdventNet SNMP, um conjunto de classes implementadas em Java \n\nque permitem o envio e recebimento de primitivas SNMP [ADVENTNET \n\n01]; \n\n6.2 Vari\u00e1veis Monitoradas \n\nAs vari\u00e1veis monitoradas pertencem ao grupo interfaces da MIB2 \u2013 Internet \n\nespecificada na RFC 1213. O Grupo Interfaces oferece dados sobre cada interface de \n\num dispositivo gerenci\u00e1vel da rede. Essas informa\u00e7\u00f5es s\u00e3o \u00fateis para o gerenciamento \n\nde falhas, de configura\u00e7\u00e3o, de desempenho, e de contabiliza\u00e7\u00e3o. As vari\u00e1veis \n\nmonitoradas s\u00e3o: \n\n\u2022 ifOutOctets \u2013 o n\u00famero total de bytes transmitidos por uma interface, \n\nincluindo caracteres de cabe\u00e7alho. Nome: IF-MIB!ifOutOctets; \n\nIdentificador: 1.3.6.1.2.1.2.2.1.16; \n\n\u2022 ifOutDiscards \u2013 o n\u00famero de pacotes a serem transmitidos por uma \n\ninterface acima do limite. Estes pacotes s\u00e3o escolhidos para serem \n\ndescartados mesmo que n\u00e3o tenham sido detectados erros. Nome: IF-\n\nMIB!ifOutDiscards; Identificador: 1.3.6.1.2.1.2.2.1.19; \n\n\u2022 ifOutErrors \u2013 o n\u00famero de unidades de transmiss\u00e3o que contiveram \n\nerros. Estes pacotes ou unidades de transmiss\u00e3o s\u00e3o descartados, \n\nimpedindo que os mesmos se propaguem pela rede. Nome: IF-\n\nMIB!ifOutErrors; Identificador: 1.3.6.1.2.1.2.2.1.20; \n\n\u2022 ifInOctets \u2013 o n\u00famero total de bytes recebidos em uma interface, \n\nincluindo caracteres de cabe\u00e7alho. Nome: IF-MIB!ifInOctets; \n\nIdentificador: 1.3.6.1.2.1.2.2.1.10; \n\n\u2022 ifInDiscards \u2013 o n\u00famero de pacotes recebidos em uma interface acima do \n\nlimite. Estes pacotes s\u00e3o escolhidos para serem descartados mesmo que \n\nn\u00e3o tenham sido detectados erros. Uma raz\u00e3o para descartar pacotes \u00e9 que \n\n\n\n 100\n\nele pode ser maior do que o espa\u00e7o livre no buffer do roteador. Nome: IF-\n\nMIB!ifInDiscards; Identificador: 1.3.6.1.2.1.2.2.1.13;  \n\n\u2022 ifInErrors \u2013 o n\u00famero de unidades de transmiss\u00e3o recebidos com erros. \n\nEstes pacotes ou unidades de transmiss\u00e3o s\u00e3o descartados, impedindo que \n\nos erros se propaguem para o protocolo de n\u00edvel mais alto. Nome: IF-\n\nMIB!ifInErrors; Identificador: 1.3.6.1.2.1.2.2.1.14; \n\nNa aplica\u00e7\u00e3o, al\u00e9m de utilizar o identificador da vari\u00e1vel monitorada \u00e9 necess\u00e1rio \n\nadicionar, no final do identificador, o n\u00famero da porta monitorada. Por exemplo: a \n\nconstante ifOutOctets tem como identificador o n\u00famero 1.3.6.1.2.1.2.2.1.16 por\u00e9m para \n\na coleta de dados, deve-se acrescentar o \u201c.4\u201d para indicar que a porta monitorada \u00e9 a \n\nporta 4 [VERONEZ 99]. \n\n \n\n6.3 Arquitetura da Aplica\u00e7\u00e3o de Coleta de Dados Gerenciais \n\nA arquitetura da aplica\u00e7\u00e3o implementada \u00e9 mostrada na fig. 6.2. \n\n\n\n 101\n\nrede\nTCP/IP\n\nRoteador\n\nAgente\nSNMP\n\nRequisi\u00e7\u00e3o/Resposta\nSNMP\n\nMIB\n\nAplica\u00e7\u00e3o\n\nGerente\n\n<xml>\n<xml>\n\n<xml>\n\nDocumentos XML\n\nPARSER\nXML\n\n...<xml>&lt;html>\n\nRequisi\u00e7\u00e3o\nSNMP\n\nResposta\nSNMP\n\n \n\nFIGURA 6.3 \u2013 ARQUITETURA DA APLICA\u00c7\u00c3O DE COLETA DE DADOS GERENCIAIS \n\nBasicamente, a aplica\u00e7\u00e3o utiliza o protocolo SNMP para consultar o roteador \n\n(endere\u00e7o IP 200.201.8.1) onde est\u00e3o fisicamente conectados os links e retornar \n\ninforma\u00e7\u00f5es de tr\u00e1fego mantidos na MIB desse equipamento. A partir das informa\u00e7\u00f5es \n\nrecebidas \u00e9 gerado um documento XML. \n\nNos testes, as consultas foram realizadas em intervalos regulares de 5 minutos. \n\nComo as vari\u00e1veis monitoradas retornam octetos, \u00e9 feita uma convers\u00e3o para uma \n\nunidade mais usual, de bits por segundo (bits/s). O principal objetivo \u00e9 prover \n\nestat\u00edsticas de tr\u00e1fego ao administrador da rede. \n\nNa fig. 6.4 \u00e9 apresentada a interface principal da aplica\u00e7\u00e3o de coleta. \n\n\n\n 102\n\n \n\nFIGURA 6.4 \u2013 INTERFACE PRINCIPAL DA APLICA\u00c7\u00c3O DE COLETA DE DADOS \n\nBasicamente, a aplica\u00e7\u00e3o utiliza o protocolo SNMP para consultar o roteador \n\n(endere\u00e7o IP 200.201.8.1) onde est\u00e3o fisicamente conectados os links e retornar \n\ninforma\u00e7\u00f5es de tr\u00e1fego mantidos na MIB desse equipamento. A partir das informa\u00e7\u00f5es \n\nrecebidas \u00e9 gerado um documento XML. Tal documento pode ser reprocessado por \n\naplica\u00e7\u00f5es XML e renderizado para produzir novos formatos de sa\u00edda. Na fig. 6.4 \u00e9 \n\napresentada a sa\u00edda XML renderizada para XHTML e o respectivo documento aberto no \n\nbrowser. \n\n \n\n\n\n 103\n\n \n\nFIGURA 6.5 \u2013 SA\u00cdDA XML RENDERIZADA PARA XHTML \n\n6.4 Arquitetura do ambiente hipot\u00e9tico utilizando CORBA \n\nCOBA IIOP\n\nAplica\u00e7\u00e3o\nGerente\n\nAGENTE\nSNMP\n\nDispositivo\nGerenciado\n\nColetor\n2\n\nMIB\n\nS\nN\n\nM\nP\n\nAGENTE\nSNMP\n\nDispositivo\nGerenciado\n\nColetor\n1\n\nMIB\n\nS\nN\n\nM\nP\n\nAGENTE\nSNMP\n\nDispositivo\nGerenciado\n\nColetor\n3\n\nMIB\n\nS\nN\n\nM\nP\n\nAGENTE\nSNMP\n\nDispositivo\nGerenciado\n\nColetor\nn\n\nMIB\n\nS\nN\n\nM\nP\n\n \n\nFIGURA 6.6 \u2013 MODELO L\u00d3GICO DO AMBIENTE APLICANDO CORBA \n\n\n\n 104\n\n7. Conclus\u00f5es \n\n7.1 Conclus\u00e3o \n\nAtualmente, as redes de computadores baseadas na arquitetura TCP/IP, \n\nnotadamente a Internet, crescem assustadoramente. Tal expans\u00e3o vigorosa concentra-se \n\nna relativa facilidade de implementa\u00e7\u00e3o e manuten\u00e7\u00e3o do conjunto de protocolos \n\nTCP/IP, al\u00e9m da possibilidade de interliga\u00e7\u00e3o de LAN\u2019s atrav\u00e9s de outras WAN\u2019s, com \n\num desempenho bastante razo\u00e1vel. \u00c9 poss\u00edvel, inclusive, ter-se uma implementa\u00e7\u00e3o de \n\nrede local utilizando a arquitetura TCP/IP, sem contudo conect\u00e1-la a outras redes, \n\ncaracterizando uma rede intranet, bastante empregada na implementa\u00e7\u00e3o de LANs em \n\nempresas [STALLINGS 00]. \n\nPor\u00e9m, torna-se imprescind\u00edvel o monitoramento e controle do funcionamento e \n\ncrescimento dessas redes, assegurando um desempenho aceit\u00e1vel.  A necessidade de \n\ngerenciamento de redes \u00e9 evidente e tende a crescer \u00e0 medida que as redes se tornam \n\nmaiores e mais complexas. Como essas redes apresentam-se cada vez mais \n\nheterog\u00eaneas, uma padroniza\u00e7\u00e3o do protocolo de ger\u00eancia garante que estas sejam \n\ngerenciadas de maneira uniforme. \n\nDentre as atividades b\u00e1sicas do gerenciamento de redes est\u00e3o a detec\u00e7\u00e3o e \n\ncorre\u00e7\u00e3o de falhas e o estabelecimento de procedimentos para a previs\u00e3o de problemas \n\nfuturos. Por exemplo, monitorando linhas cujo tr\u00e1fego esteja aumentando ou roteadores \n\nque estejam se sobrecarregando, \u00e9 poss\u00edvel tomar medidas que evitem o colapso da \n\nrede, como a reconfigura\u00e7\u00e3o das rotas ou a troca do roteador por um modelo mais \n\nadequado. \n\nO protocolo de ger\u00eancia SNMP constitui, atualmente, um padr\u00e3o operacional, e \n\ngrande parte do seu sucesso se deve a sua simplicidade. Outro aspecto importante \u00e9 a \n\nsua capacidade de gerenciar redes heterog\u00eaneas constitu\u00eddas de diferentes tecnologias, \n\nprotocolos e sistemas operacionais. Dessa forma, o SNMP \u00e9 capaz de gerenciar redes \n\nEthernet, Token Ring que conectem PC's, Apple Machintosh, esta\u00e7\u00f5es SUN e outros \n\n\n\n 105\n\ntipos de computadores [STALLINGS 00]. Jeffrey Case, presidente do SNMP Research \n\nInternational Inc., certa vez afirmou que \"em um mundo ideal, eu usaria SNMP para \n\ncoleta de dados, browsers para apresenta\u00e7\u00e3o dos dados, Java para a intelig\u00eancia e um \n\nesquema padronizado para a portabilidade dos dados\" [JANDER 96]. \n\nO emprego de padr\u00f5es como o SNMP veio tratar a necessidade de gerenciamento \n\nda infra-estrutura de rede de computadores das institui\u00e7\u00f5es, atrav\u00e9s de um modelo \n\naberto, n\u00e3o propriet\u00e1rio, baseado no princ\u00edpio gerente-agente. \n\nTecnologias como CORBA come\u00e7am a ser utilizadas no desenvolvimento dos \n\nchamados frameworks de forma a tornar dispon\u00edvel um mecanismo transparente para \n\ncomunica\u00e7\u00e3o entre os agentes e gerentes distribu\u00eddos na rede al\u00e9m de oferecer uma API \n\nnormatizada para o desenvolvimento de aplica\u00e7\u00f5es distribu\u00eddas. V\u00e1rias empresas t\u00eam \n\nquestionado os altos custos relacionados \u00e0s plataformas de gerenciamento. Os \n\nfabricantes de equipamentos questionam tamb\u00e9m o esfor\u00e7o de desenvolvimento para \n\nportar suas aplica\u00e7\u00f5es de ger\u00eancia para uma miscel\u00e2nea de plataformas dispon\u00edveis no \n\nmercado. \n\nGra\u00e7as \u00e0 massifica\u00e7\u00e3o das redes TCP/IP, a Internet constitui uma infraestrutura \n\nideal para prover interc\u00e2mbio de informa\u00e7\u00f5es. Uma das possibilidades proporcionadas \n\npela Web \u00e9 o acesso e tratamento de informa\u00e7\u00f5es de gerenciamento de redes. Nessa \n\nconjuntura, CORBA j\u00e1 vem sendo utilizada sobre a infraestrutura Web [BARILLAUD \n\n97] como uma ferramenta para permitir a implementa\u00e7\u00e3o de um sistema de \n\ngerenciamento de rede distribu\u00eddo [BAROTTO 98] entre as m\u00e1quinas que comp\u00f5em a \n\nrede, independente de plataforma e com mecanismo de instala\u00e7\u00e3o autom\u00e1tica, visto que \n\nestar\u00e1 dispon\u00edvel atrav\u00e9s de browsers Web. \n\nApesar da linguagem de marca\u00e7\u00e3o HTML ser predominante nos documentos Web, \n\nsuas conhecidas limita\u00e7\u00f5es v\u00eam se evidenciando, levando alguns a considerar um \n\nmomento de colapso para a HTML [HOLZNER 01]. Tal problem\u00e1tica, somada a grande \n\ninser\u00e7\u00e3o e aceita\u00e7\u00e3o da linguagem HTML como meio de publica\u00e7\u00e3o de documentos na \n\nWeb, motivou o W3C a desenvolver a metalinguagem XML [HOLZNER 01] \n\n[GRAHAM 00].   \n\n\n\n 106\n\nO \u201cesquema padronizado para a portabilidade dos dados\u201d, sugerido por Case, \n\npode ser efetivado com a tecnologia XML, que distingue entre interface, processos e \n\ndados. Al\u00e9m dessa distin\u00e7\u00e3o, XML oferece uma flexibiliza\u00e7\u00e3o no interc\u00e2mbio de dados; \n\na possibilidade de personalizar linguagens de marca\u00e7\u00e3o, a estrutura\u00e7\u00e3o, integra\u00e7\u00e3o e \n\nautodescri\u00e7\u00e3o de dados. A caracter\u00edstica fundamental de XML de dissocia\u00e7\u00e3o entre \n\nestrutura de apresenta\u00e7\u00e3o e conte\u00fado do documento, abre espa\u00e7o para uma revolu\u00e7\u00e3o na \n\nforma como as informa\u00e7\u00f5es s\u00e3o manipuladas. Um mesmo documento base pode ser \n\nautomaticamente convertido para diferentes formatos, podendo ser apresentado em um \n\nmonitor de um computador pessoal, em uma pequena tela de um telefone celular ou at\u00e9 \n\nmesmo ser transformado em voz para utiliza\u00e7\u00e3o de deficientes visuais. \n\nSistemas de gerenciamento de redes que utilizam a Web como infra-estrutura de \n\ndistribui\u00e7\u00e3o podem explorar as caracter\u00edsticas de estrutura\u00e7\u00e3o e flexibiliza\u00e7\u00e3o \n\npropiciadas por XML, produzindo documentos de informa\u00e7\u00e3o de gerenciamento de \n\nredes consistentes e formalmente validados. Tais documentos constituem mat\u00e9ria-prima \n\npara as mais diferentes aplica\u00e7\u00f5es, podendo ser apresentados em in\u00fameros formatos nos \n\nbrowsers Web ou importados por outros sistemas de informa\u00e7\u00e3o. \n\n7.2 Trabalhos Futuros \n\nVislumbra-se como foco de estudo futuro a implementa\u00e7\u00e3o e teste do modelo que \n\nemprega CORBA, a fim de avaliar suas vantagens potenciais, advindas da distribui\u00e7\u00e3o. \n\n \n\n\n\n 107\n\nRefer\u00eancias Bibliogr\u00e1ficas \n\n1. [ADVENTNET 01] ADVENTNET. AdventNet SNMP API Release 3.3: Product \n\nDocumentation. set. 2001. \n\n2. [AHMED 98] AHMED, Suhail. Corba Programming Unleashed. Indianapolis: \n\nSAMS, 1998. \n\n3. [BAROTTO 98] BAROTTO, Andr\u00e9 Mello. Realiza\u00e7\u00e3o da Ger\u00eancia Distribu\u00edda \n\nde Redes Utilizando SNMP, Java, WWW e CORBA. Florian\u00f3polis, abr. 1998. \n\nDisserta\u00e7\u00e3o (Mestrado em Ci\u00eancia da Computa\u00e7\u00e3o) \u2013 Departamento de Inform\u00e1tica \n\ne Estat\u00edstica \u2013 Universidade Federal de Santa Catarina. \n\n4. [BAROTTO 00] BAROTTO, Andr\u00e9 Mello; SOUZA, Adriano de; WESTPHALL, \n\nCarlos Becker. Distributed Network Management Using SNMP, Java, WWW \n\nand CORBA. Journal of Network and Systems Management, v. 8, n.4, set., p. 251-\n\n265, 2000. \n\n5. [BARILLAUD 97] BARILLAUD, Frank; DERI, Luca; FERIDUN, Metin. Network \n\nManagement Using Internet Technologies. Fifth IFIP/IEEE Internet Symposium \n\non Integrated Network Management, San Diego, CA, USA, p. 61-70, 1997.  \n\n6. [BERG 99] BERG, Clifford. Advanced Java 2 Development for Enterprise \n\nApplications. New Jersey: Prentice Hall, 1999. \n\n7. [BOSAK 99] BOSAK, Jon; BRAY, Tim. XML and the Second-Generation Web.  \n\nScientific American, New York, mai.,1999. Acessado em 11 jul. 2001. Online. \n\nDispon\u00edvel na Internet em http://www.sciam.com/1999/0599issue/0599bosak.html . \n\n8. [CASTRO 01] CASTRO, Elizabeth. XML para a World Wide Web. Rio de \n\nJaneiro: Campus, 2001. \n\n9. [COMER 92] COMER, Douglas E.; STEVENS, David L. Internetworking with \n\nTCP/IP. Vol. I. ,New Jersey: Prentice Hall, 1992. \n\n\n\n 108\n\n10. [COMER 99] COMER, Douglas E.; STEVENS, David L. Interliga\u00e7\u00e3o em Rede \n\ncom TCP/IP. Vol. II. Rio de Janeiro: Campus, 1999. \n\n11. [DEROSE 99] DEROSE, Steven. The SGML FAQ Book: Understanding the \n\nFoundation of HTML and XML, Kluwer Academic Publishers, 1999. \n\n12. [DEITEL 01] DEITEL, H. M.; DEITEL, P. J. Java Como Programar. Porto \n\nAlegre: Bookman, 2001. 3a edi\u00e7\u00e3o. \n\n13. [DERI 99] DERI, Luca Haj. Web-Acessible Network Managements Tools. \n\nInternational Journal of Network Management, v. 9, 371\u2013378, nov., 1999. \n\n14. [ECKEL 01] ECKEL, Bruce. Thinking in Java. New Jersey: Prentice Hall, 2001. \n\n2a edi\u00e7\u00e3o. \n\n15. [FLANAGAN 97] FLANAGAN, David. Java in a Nutshell. New Jersey: O\u2019Reilly, \n\n1997. 2a edi\u00e7\u00e3o. \n\n16. [FURGERI 01] FURGERI, S\u00e9rgio. Ensino Did\u00e1tico da Linguagem XML. S\u00e3o \n\nPaulo: \u00c9rica, 2001. \n\n17. [GOSLING 96] GOSLING, James; JOY, Bill; STEELE, Guy. The Java Language \n\nSpecification. Berkeley : Addison-Wesley, 1996. \n\n18. [GRAHAM 00] GRAHAM, Ian S. XHTML 1.0: Web Development Sourcebook. \n\nNew York : John Wiley &amp; Sons, 2000. \n\n19. [HAROLD 01] HAROLD, Elliotte Rusty; MEANS, W. Scott. XML in a Nutshell: \n\nA Desktop Quick Reference. New Jersew: O\u2019Reilly, 2001. \n\n20. [HARKEY 98] HARKEY, Dan; ORFALI, Robert. Client/Server Programming \n\nwith Java and CORBA, 2nd Edition. New York : John Wiley &amp; Sons, 1998. \n\n21. [HAGGERTY 98] HAGGERTY, Paul; SEETHARAMAN, Krishnan. The Benefits \n\nof CORBA-Based Network Management. Communications of the ACM, v. 41, \n\n10, 73\u201379, out., 1998. \n\n\n\n 109\n\n22. [HOLZNER 01] HOLZNER, Steven. Desvendando XML. Rio de Janeiro: Campus, \n\n2001. \n\n23. [IBM 01] IBM.XML:Education. Acessado em 11 jul. 2001. Online. Dispon\u00edvel na \n\nInternet em http://www-\n\n106.ibm.com/developerworks/education/xmlintro/xmlintro.html . \n\n24. [INTRANET 02] INTRANET PARAN\u00c1. Intranet Paran\u00e1. Acessado em 06 mar. \n\n2002. Online. Dispon\u00edvel em http://www.intranetparana.br/. \n\n25. [ISO 86] ISO. ISO 8879:1986 Information processing -- Text and office systems -\n\n- Standard Generalized Markup Language (SGML). 1986 \n\n26. [ISO 95] ISO. ISO 10746-1:1995 Reference Model of Open Distributed \n\nProcessing \u2013 Part 1. 1995. \n\n27. [JANDER 96] JANDER, M. Welcome to the Revolution. Data Communications \n\nInternational, nov., 1996. \n\n28. [JU 02] JU, Hong-Taek; et al. An Embedded Web Server Architecture for XML-\n\nBased Network Management. Proceedings of IEEE/IFIP Network Operations And \n\nManagement Symposium (NOMS). Floren\u00e7a, Italia. Maio, 2002. \n\n29. [JU 01] JU, Hong-Taek; CHOI, Mi-Jung; HONG, James W. EWS-Based \n\nManagement Application Interface and Integration Mechanisms for Web-\n\nBased Element Management. Journal of Network and Systems Management, v. 9, \n\nn. 1, 31-50, 2001. \n\n30. [KOPKA 99] KOPKA, Helmut; DALY, Patrick. A Guide to Latex : Document \n\nPreparation for Beginners and Advanced Users. Berkeley : Addison-Wesley, 1999. \n\n3a edi\u00e7\u00e3o. \n\n31. [LEWIS 01] LEWIS, David; MOURITZSEN, Jens D. The Role of XML in TMN \n\nEvolution. Proceedings of IEEE/IFIP International Symposium on Integrated \n\nNetwork, 689-702, 2001. \n\n\n\n 110\n\n32. [MARCHAL 00] MARCHAL, Beno\u00eet. XML By Example. Indian\u00e1polis: QUE, \n\n2000. \n\n33. [MARTIN-FLATIN 00] MARTIN-FLATIN, J. P. Web-Based Management of IP \n\nNetworks and Systems. Out. 2000. Ph.D. Thesis, EPFL, Lausanne, Switzerland. \n\n34. [MCGRATH 98] MCGRATH, Sean. Rendering XML Documents Using XSL. Dr. \n\nDobb\u2019s Journal, n. 287, 82-85, jul., 1998. \n\n35. [MCGRATH 99] MCGRATH, Sean. XML: Aplica\u00e7\u00f5es Pr\u00e1ticas. Rio de Janeiro: \n\nCampus, 1999. \n\n36. [McLAUGHLIN 01] McLAUGHLIN, Brett. Java and XML. New Jersew: \n\nO\u2019Reilly, 2001. 1a edi\u00e7\u00e3o. \n\n37. [MULLER 97] MULLER, Nathan J. Web-Acessible Network Managements \n\nTools. International Journal of Network Management, v. 7, 288\u2013297, set., 1997. \n\n38. [NAKHIMOVSKY 00] NAKHIMOVSKY, Alexander; MYERS, Tom. \n\nProfessional Java XML Programming with Servlets and JSP. Birmingham: \n\nWrox Press, 2000. 1a edi\u00e7\u00e3o. \n\n39. [NMS 02] NMS. Network Management Server (NMS). Acessado em 13 jul. 2002. \n\nOnline. Dispon\u00edvel na Internet em http://netman.cit.buffalo.edu/index.html. \n\n40. [OMG 01] OMG. Object Management Group. Acessado em 08 jul. 2001. Online. \n\nDispon\u00edvel na Internet em http://www.omg.org . \n\n41. [ORFALI 99] ORFALI, Robert; HARKEY, Dan; EDWARDS, Jeri. Client/Server \n\nSurvival Guide, 3rd Edition. New York : John Wiley &amp; Sons, 1999. \n\n42. [RAY 01] RAY, Erik T. Learning XML : (Guide to) Creating Self-Describing \n\nData. New Jersew: O\u2019Reilly, 2001.  \n\n43. [ROSE 90] ROSE, M.; MCCLOGHRIE, K. Structure and Identification of \n\nManagement Information for TCP/IP based internets. RFC 1155. Network \n\nWorking Group. 1990. \n\n\n\n 111\n\n44. [SEBESTA 00] SEBESTA, Robert W. Conceitos de Linguagens de Programa\u00e7\u00e3o. \n\nPorto Alegre: Bookman, 2000. 4a edi\u00e7\u00e3o. \n\n45. [STALLINGS 98] STALLINGS, Willian; 1998. SNMP and SNMPv2: The \n\nInfrastructure for Network Management. IEEE Communications Magazine. n. 168, \n\n37-43, mar., 1998. \n\n46. [STALLINGS 00] STALLINGS, William. SNMP, SNMPv2, SNMPv3, and RMON \n\n1 and 2. 3 Ed. Reading, MA: Addison Wesley, 2000. \n\n47. [THOMPSON 98] THOMPSON, P. Web-Based Enterprise Management \n\nArchitecture. IEEE Communications Magazine, v. 36, n. 3, mar., 1998. \n\n48. [UC 01] UNICODE CONSORTIUM (UC). What Is Unicode?. Acessado em 15 \n\njul. 2001. Online. Dispon\u00edvel na Internet em   \n\nhttp://www.unicode.org/unicode/standard/WhatIsUnicode.html. \n\n49. [VERONEZ 99] VERONEZ, C. A.; EFRAIN, C.; BAROTTO, A. M.; NASSAR, S. \n\nM.; WESTPHALL, C. B. Ger\u00eancia de Redes Utilizando M\u00e9todos Estat\u00edsticos \n\nBayesianos. Anais do Simp\u00f3sio Brasileiro de Redes de Computadores. Salvador \n\n(BA), Brasil. Maio 1999. \n\n50. [VLIST 01] VLIST, Eric Vander. XML Schema. New Jersew: O\u2019Reilly, 2001. \n\n51. [XMLINFO 01] XMLINFO: The XML Information Site. Acessado em 11 jul. \n\n2001. Online. Dispon\u00edvel na Internet em http://xmlinfo.com . \n\n52. [XML.ORG 01] XML.ORG: The XML Industry Portal. Acessado em 23 mai. \n\n2001. Online. Dispon\u00edvel na Internet em \n\nhttp://www.xml.org/xmlorg_resources/index.shtml . \n\n53. [W3C 01a] WORLD WIDE WEB CONSORTIUM (W3C). Extensible Markup \n\nLanguage (XML). Acessado em 5 mar. 2001. Online. Dispon\u00edvel na Internet em  \n\nhttp://www.w3.org/XML/ . \n\n\n\n 112\n\n54. [W3C 01b] WORLD WIDE WEB CONSORTIUM (W3C). Extensible Markup \n\nLanguage (XML) 1.0 (Second Edition). Acessado em 2 abr. 2001. Online. \n\nDispon\u00edvel na Internet em  http://www.w3.org/TR/REC-xml. \n\n \n\n\n\n 113\n\nAnexo A \u2013 C\u00f3digo-Fonte Java \n/** \n * Title:        SNMPMan \n * Description: \n * Copyright:    Copyright (c) 2002 \n * Company:      Unioeste \n * @author Fabio Alexandre Spanhol \n * @version 1.0 \n */ \n// pacotes Java \nimport javax.swing.*; \nimport org.netbeans.lib.awtextra.*; \nimport java.awt.*; \nimport java.awt.event.*; \nimport java.lang.*; \nimport java.net.*; \nimport java.io.*; \nimport java.util.*; \n// pacotes da API SNMPAdventNet  \nimport com.adventnet.snmp.snmp2.*; \nimport com.adventnet.snmp.snmp2.usm.*; \nimport com.adventnet.snmp.beans.*; \n \nclass GetData  { \n  \n    \n   final String Host; \n   final String OID; \n           \n           \n   javax.swing.JTextArea JTA_Status;        \n            \n   private int ONE_SECOND = 1000; /* valor de um segundo, expresso em mil\u00e9simos de \nsegundo  apenas para melhorar a legibilidade do c\u00f3digo-fonte */ \n   private javax.swing.Timer timerPooling; \n    \n   private boolean firstCatch = true; \n   private boolean errorFound = false;  \n    \n   long previousTime; \n    \n   Double  previousValue; \n    \n      \n    \n   SnmpTarget target = new SnmpTarget(); /* instancia o bean SnmpTarget \n        permite uma sess\u00e3o SNMP leve para   \n    comunica\u00e7\u00e3o SNMP s\u00edncrona */    \n   GetData ( String Host, String OID) {   \n      this.Host = Host; \n      this.OID  = OID;       \n      /* Intervalos regulares de 5 minutos */   \n      timerPooling = new javax.swing.Timer(ONE_SECOND * 300, new ActionListener() { \n            public void actionPerformed(ActionEvent evt) { \n              \n             String response = \"\";              \n              \n             Date now = new Date();             \n              \n             long actualTime  = 0, \n                  bytes       = 0, \n                  elapsedTime = 0; \n              \n                           \n             response = snmpGet (); \n              \n             if (!errorFound) { \n              \n              if (firstCatch) { \n                \n                   previousTime  = now.getTime (); \n                    previousValue = new Double (response); \n\n\n\n 114\n\n                    firstCatch    = false; \n                  \n                 } else { \n               \n                   actualTime = now.getTime(); \n                   Double actualValue = new Double (response); \n                 \n                   elapsedTime = (actualTime - previousTime)/(1000);//em segundos \n                 \n                                    \n                   bytes       = actualValue.longValue() - \npreviousValue.longValue();               \n                 \n                   System.out.println (\"Bytes:\" + bytes); \n                  \n              \n                    long rateBits = (bytes ) * 8 / elapsedTime; \n              \n              \n                    JTA_Status.append (\"\\n->OID [\" + getOID() + \"]\" + rateBits + \" \nbps\"); \n                     \n                    } \n                 } else { \n                  JTA_Status.append(\"\\n\" + response); \n                 }  \n            } \n        }); \n   }      \n     \n   String getOID () { \n     \n     return (this.OID);     \n   } \n    \n   String getHost () { \n     \n      return (this.Host); \n     \n   }   \n      \n      \n       \n void start () { \n  Date date = new Date(); \n   \n   if (timerPooling.isRunning())  \n      timerPooling.restart(); \n   else \n      timerPooling.start(); \n       \n   JTA_Status.append(\"\\n->Pooling de coleta iniciado ...OID [\" + getOID() + \"] \" + \ndate.toLocaleString() + \"\\n\");    \n          \n } \n  \n   \n void stop  () { \n   Date  date = new Date();   \n     \n     \n   timerPooling.stop(); \n   JTA_Status.append(\"\\n->Pooling de coleta interrompido...\" + \ndate.toLocaleString() + \"\\n\"); \n   \n }  \n  \n  \n String snmpGet  () { \n  target.setTargetHost(this.Host);         //seta o host no qual o agente \nSNMP est\u00e1 rodando  \n  target.setObjectID (this.OID);           // seta o OID \n  String result = target.snmpGet(); // executa uma requisi\u00e7\u00e3o SNMP GET NEXT \n  //Verifica se houve erro \n\n\n\n 115\n\n     if (result == null) { \n         //Requisi\u00e7\u00e3o falhou ou houve time out \n         errorFound =  true; \n         return ( target.getErrorString()); \n          \n                           \n     } else { \n          errorFound = false; \n      return (result);  \n     } \n  } \n} \npublic class SNMPMan extends javax.swing.JFrame  { \n \n   GetData in,   //objeto para consultar informa\u00e7\u00f5es do tr\u00e1fego de entrada \n           out;  //objeto para consultar informa\u00e7\u00f5es do tr\u00e1fego de saida \n    \n   //declara\u00e7\u00e3o de vari\u00e1veis para tornar o c\u00f3digo-fonte mais leg\u00edvel \n   public final String Default_Router = \"200.201.8.1\", \n          ifOutOctets    = \".1.3.6.1.2.1.2.2.1.16.4\",  \n      ifOutDiscards  = \".1.3.6.1.2.1.2.2.1.19.4\", \n      ifOutErrors    = \".1.3.6.1.2.1.2.2.1.20.4\", \n      ifInOctets     = \".1.3.6.1.2.1.2.2.1.10.4\", \n      ifInDiscards   = \".1.3.6.1.2.1.2.2.1.13.4\", \n      ifInErrors     = \".1.3.6.1.2.1.2.2.1.14.4\";  \n       \n   /* determina como ser\u00e1 a apar\u00eancia da interface da aplica\u00e7\u00e3o  \n      para o padr\u00e3o MS-Windows a String deve ser \n\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\" */ \n   public static String windowsClassName = \n\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\";  \n   /* Objetos da interface gr\u00e1fica com o usu\u00e1rio*/   \n   private javax.swing.JMenuBar menuBar; \n   private javax.swing.JMenu fileMenu; \n   private javax.swing.JMenu helpMenu; \n   private javax.swing.JMenuItem getMenuItem; \n   private javax.swing.JMenuItem stopMenuItem;       \n   private javax.swing.JMenuItem exitMenuItem; \n   private javax.swing.JMenuItem aboutMenuItem; \n   private javax.swing.JTextArea JTA_Status; \n   private static javax.swing.JTextField JTF_Host; \n   private javax.swing.JLabel JL_Host; \n   private javax.swing.JLabel JL_Status; \n   private javax.swing.JDesktopPane JDP_Panel;  \n   public SNMPMan () { \n     initComponents(); \n     initMyComponents(); \n   }   \n   private void initComponents() {       \n       \n      JDP_Panel = new javax.swing.JDesktopPane(); \n      JTA_Status= new javax.swing.JTextArea(); \n       \n      JTF_Host  = new javax.swing.JTextField(); \n      JL_Host   = new javax.swing.JLabel(); \n      JL_Status = new javax.swing.JLabel(); \n       \n      menuBar = new javax.swing.JMenuBar(); \n       \n      fileMenu = new javax.swing.JMenu(); \n      helpMenu = new javax.swing.JMenu();           \n       \n      getMenuItem   = new javax.swing.JMenuItem(); \n      stopMenuItem  = new javax.swing.JMenuItem();  \n      exitMenuItem  = new javax.swing.JMenuItem(); \n      aboutMenuItem = new javax.swing.JMenuItem(); \n      //------- menu Arquivo   ---------- \n      fileMenu.setText(\"Arquivo\"); \n      fileMenu.setMnemonic('A');         \n       \n      getMenuItem.setText (\"Iniciar Coleta\"); \n      getMenuItem.setMnemonic ('I'); \n      getMenuItem.addActionListener(new java.awt.event.ActionListener() { \n      public void actionPerformed(java.awt.event.ActionEvent evt) { \n\n\n\n 116\n\n             getMenuItemActionPerformed(evt); \n         } \n      }); \n      stopMenuItem.setText (\"Finalizar Coleta\"); \n      stopMenuItem.setMnemonic ('F'); \n      stopMenuItem.addActionListener(new java.awt.event.ActionListener() { \n      public void actionPerformed(java.awt.event.ActionEvent evt) { \n             stopMenuItemActionPerformed(evt); \n         } \n      }); \n       \n      fileMenu.addSeparator(); \n       \n      exitMenuItem.setText(\"Sair\"); \n      exitMenuItem.setMnemonic('S'); \n      exitMenuItem.addActionListener(new java.awt.event.ActionListener() { \n         public void actionPerformed(java.awt.event.ActionEvent evt) { \n             exitMenuItemActionPerformed(evt); \n         } \n      }); \n      //-------- menu Ajuda ------------ \n      helpMenu.setText(\"Ajuda\"); \n      helpMenu.setMnemonic('u'); \n       \n      aboutMenuItem.setText(\"Sobre\"); \n      aboutMenuItem.setMnemonic('o'); \n      aboutMenuItem.addActionListener(new java.awt.event.ActionListener() { \n         public void actionPerformed(java.awt.event.ActionEvent evt) { \n             aboutMenuItemActionPerformed(evt); \n         } \n      }); \n      fileMenu.add (getMenuItem); \n      fileMenu.add (stopMenuItem); \n      fileMenu.add(exitMenuItem); \n       \n      helpMenu.add(aboutMenuItem); \n       \n      menuBar.add(fileMenu); \n      menuBar.add (helpMenu); \n      getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout()); \n      setTitle(\"SNMPManager vers\\u00e3o 1.0\"); \n      addWindowListener(new java.awt.event.WindowAdapter() { \n         public void windowClosing(java.awt.event.WindowEvent evt) { \n             exitForm(evt); \n         } \n      }); \n     //--------------------------------------- \n      JL_Host.setText(\"Roteador Monitorado:\"); \n      JL_Host.setForeground(new java.awt.Color(30, 19, 143)); \n      JL_Host.setFont(new java.awt.Font(\"Verdana\", 3, 12)); \n      getContentPane().add(JL_Host, new rg.netbeans.lib.awtextra.AbsoluteConstraints(10, \n5, -1, -1)); \n      JTF_Host.setForeground(new java.awt.Color(255, 51, 51)); \n      JTF_Host.setFont(new java.awt.Font(\"Dialog\", 1, 12)); \n       \n      JTF_Host.setText(Default_Router); \n      JTF_Host.setEditable(false); \n       \n      getContentPane().add(JTF_Host, new \norg.netbeans.lib.awtextra.AbsoluteConstraints(10, 25, 175, -1)); \n      \n      \n      JDP_Panel.setBorder(new javax.swing.border.EtchedBorder()); \n       \n       \n     /* JDP_Panel.setBackground(new java.awt.Color(174, 178, 195)); \n      JDP_Panel.setAutoscrolls(true); \n      getContentPane().add(JDP_Panel, new \norg.netbeans.lib.awtextra.AbsoluteConstraints(190, 30, 640, 450)); */ \n       \n       \n      JL_Status.setText(\"Situa\\u00e7\\u00e3o\"); \n      JL_Status.setFont(new java.awt.Font(\"Verdana\", 2, 12)); \n        \n\n\n\n 117\n\n      getContentPane().add(JL_Status, new \norg.netbeans.lib.awtextra.AbsoluteConstraints(190, 5, 150, -1)); \n      JTA_Status.setEditable(false); \n      JTA_Status.setForeground(new java.awt.Color(255, 51, 51)); \n      JTA_Status.setBackground(new java.awt.Color(255, 255, 255)); \n       \n      JTA_Status.setFont(new java.awt.Font(\"Dialog\", 3, 12)); \n      JTA_Status.setBorder(new javax.swing.border.EtchedBorder()); \n      JTA_Status.setAutoscrolls(true); \n      getContentPane().add(JTA_Status, new \norg.netbeans.lib.awtextra.AbsoluteConstraints(192, 25, 430, 380));                 \n      JScrollPane JSP_Scroll5 = new JScrollPane(JTA_Status); \n      JSP_Scroll5.setAutoscrolls(true); \n      this.getContentPane().add(JSP_Scroll5, new \norg.netbeans.lib.awtextra.AbsoluteConstraints(192, 25, 430, 380)); \n      JTA_Status.setText(\"->Coleta em Estado Ocioso...\"); \n     //---------------------------------------  \n      setJMenuBar(menuBar); \n      pack(); \n      java.awt.Dimension screenSize = \njava.awt.Toolkit.getDefaultToolkit().getScreenSize(); \n      //setSize(new java.awt.Dimension(1024, 768)); \n      setSize(new java.awt.Dimension(640, 480)); \n      setLocation((screenSize.width-640)/2,(screenSize.height-480)/2); \n      try { \n         UIManager.setLookAndFeel(windowsClassName); \n         SwingUtilities.updateComponentTreeUI(this); \n      } \n      catch (Exception exc) { \n         System.err.println(\"Error loading Look and Feel: \" + exc); \n      }       \n       \n  }    \n  void initMyComponents () { \n        \n       out = new GetData (Default_Router, ifOutOctets); \n        \n       in = new GetData (Default_Router, ifInOctets); \n        \n       in.JTA_Status = this.JTA_Status;  \n       out.JTA_Status = this.JTA_Status;  \n        \n    \n  } \n  \n  \n  private void getMenuItemActionPerformed(java.awt.event.ActionEvent evt) { \n   in.start(); \n   out.start();   \n   \n  }  \n  private void stopMenuItemActionPerformed(java.awt.event.ActionEvent evt) { \n  in.stop(); \n  out.stop(); \n  }  \n  private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) { \n      System.exit(0); \n  } \n  private void exitForm(java.awt.event.WindowEvent evt) { \n      System.exit(0); \n  } \n  private void aboutMenuItemActionPerformed(java.awt.event.ActionEvent evt) { \n  }     \n  public static void main (String args[]) { \n   new SNMPMan().show(); \n  } \n} \n \n\n\n\n 118\n\nAnexo B \u2013 Documento XML Gerado pela Aplica\u00e7\u00e3o \n \n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<LOG xmlns:xsi=\"http://www.w3.org/2000/10/XMLSchema-instance\"  \nxsi:noNamespaceSchemaLocation=\"D:\\Usr\\Fabio\\Mestrado CPGCC\\SNMPManager\\vld_doc.xsd\"> \n<MNG> \n&lt;HOST ip=\"200.201.8.1\">Roteador</HOST> \n&lt;OID>.1.3.6.1.2.1.2.2.1.10.4</OID>  \n&lt;SNMPVERSION>3</SNMPVERSION> \n&lt;DATE>2002-08-27</DATE> \n&lt;TIME>15:18</TIME> \n&lt;RESPONSE unit=\"bps\">881654</RESPONSE> \n</MNG> \n<MNG> \n&lt;HOST ip=\"200.201.8.1\">Roteador</HOST> \n&lt;OID>.1.3.6.1.2.1.2.2.1.10.4</OID>  \n&lt;SNMPVERSION>3</SNMPVERSION> \n&lt;DATE>2002-08-27</DATE> \n&lt;TIME>15:23</TIME> \n&lt;RESPONSE unit=\"bps\">905536</RESPONSE> \n</MNG> \n<MNG> \n&lt;HOST ip=\"200.201.8.1\">Roteador</HOST> \n&lt;OID>.1.3.6.1.2.1.2.2.1.10.4</OID> \n&lt;SNMPVERSION>3</SNMPVERSION> \n&lt;DATE>2002-08-27</DATE> \n&lt;TIME>15:28</TIME> \n&lt;RESPONSE unit=\"bps\">883968</RESPONSE> \n</MNG> \n</LOG> \n \n\n\n\n 119\n\nAnexo C \u2013 XMLSchema com a estrutura do documento XML Coletado \n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<xsd:schema xmlns:xsd=\"http://www.w3.org/2000/10/XMLSchema\" \nelementFormDefault=\"qualified\"> \n \n&lt;!-- Define o tipo utilizado no atributo ip  --> \n&lt;xsd:simpleType name=\"ipaddressType\"> \n &lt;xsd:restriction base=\"xsd:string\"> \n  &lt;xsd:pattern value=\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"/> \n &lt;/xsd:restriction> \n&lt;/xsd:simpleType> \n  \n&lt;!-- Define o tipo complexo utilizado no elemento HOST --> \n&lt;xsd:complexType name= \"hostType\" mixed=\"true\"> \n         &lt;xsd:attribute name=\"ip\" type=\"ipaddressType\" use=\"required\" \nvalue=\"200.201.8.1\" />                         \n&lt;/xsd:complexType> \n \n&lt;!-- Define o tipo  utilizado no elemento SNMPVERSION --> \n&lt;xsd:simpleType name=\"snmpversionType\"> \n &lt;xsd:restriction base=\"xsd:positiveInteger\"> \n  &lt;xsd:minInclusive value=\"1\"/> \n  &lt;xsd:maxInclusive value=\"3\"/> \n &lt;/xsd:restriction> \n&lt;/xsd:simpleType> \n  \n&lt;!-- Define o tipo complexo utilizado no elemento RESPONSE --> \n&lt;xsd:complexType name= \"responseType\" mixed=\"true\"> \n         &lt;xsd:attribute name=\"unit\" type=\"xsd:string\" use=\"required\" value=\"bps\" />                 \n        \n&lt;/xsd:complexType> \n    \n&lt;!-- Define o tipo complexo utilizado no elemento MNG --> \n&lt;xsd:complexType name=\"MngType\"> \n &lt;xsd:sequence> \n  &lt;xsd:element name=\"HOST\" type=\"hostType\" /> \n  &lt;xsd:element name=\"OID\" type=\"xsd:string\"/>  \n  &lt;xsd:element name=\"SNMPVERSION\" type=\"snmpversionType\"/> \n  &lt;xsd:element name=\"DATE\" type=\"xsd:date\"/> \n  &lt;xsd:element name=\"TIME\" type=\"xsd:time\"/> \n  &lt;xsd:element name=\"RESPONSE\" type=\"responseType\"/> \n &lt;/xsd:sequence> \n&lt;/xsd:complexType> \n  \n     &lt;!-- Define o tipo complexo utilizado no elemento raiz LOG --> \n     &lt;xsd:complexType name=\"logType\"> \n    &lt;xsd:sequence> \n                &lt;xsd:element name=\"MNG\" type=\"MngType\" minOccurs=\"1\" \nmaxOccurs=\"unbounded\"/> \n    &lt;/xsd:sequence> \n     &lt;/xsd:complexType> \n \n&lt;!-- Elemento raiz do documento --> \n&lt;xsd:element name=\"LOG\" type=\"logType\" /> \n</xsd:schema>"}]}}}