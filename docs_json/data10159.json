{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.14247"}, {"@name": "filename", "#text": "20531_Measuring%20Difficulty%20in%20Platform%20Videogames.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Measuring Difficulty in Platform Videogames \n\nFausto Jos\u00e9 Mourato \nDepartamento de Sistemas e Inform\u00e1tica \n\nEscola Superior de Tecnologia \nInstituto Polit\u00e9cnico de Set\u00fabal \n\n2910-761 Set\u00fabal \nfausto.mourato@estsetubal.ips.pt \n\nManuel Pr\u00f3spero dos Santos \nCITI, Departamento de Inform\u00e1tica \n\nFaculdade de Ci\u00eancias e Tecnologia \nUniversidade Nova de Lisboa \n\n2829-516 Caparica \nps@di.fct.unl.pt \n\n \n\nAbstract \nAutomatic generation of game levels improves replayability and also allows content adaptation. One important \n\naspect to take into account in the creation of any videogame is difficulty, in particular when it is possible to \n\nadapt content. However, defining difficulty is not a straight subject. In this paper we propose a metric for game \n\ndifficulty in platform levels, mostly based on users\u2019 losing probability for each obstacle. This metric can be fur-\n\nther used in automated processes that generate levels for this type of games, helping the process to recognize \n\nwhether a level is suitable or not for a certain player. We also present some examples of the usage of this metric \n\nin commercial games.   \n\nKeywords \nHuman Factors, Platform videogames, difficulty measurement. \n\n \n\n1. INTRODUCTION \nProcedural generation of content is one active area in \n\nComputer Graphics with some common associations to \n\nother areas such as Artificial Intelligence and Human-\n\nComputer Interaction. In this paper we direct our main \n\nfocus to the automated procedural generation of levels for \n\nplatform games, aiming the contributions to understand-\n\ning the related concept of difficulty. Considering a sys-\n\ntem that automatically generates platform levels, estimat-\n\ning and quantifying difficulty is useful because it im-\n\nproves the knowledge about the output. \n\nThe designation of platform games is used to describe a \n\nparticular type of videogames where the user controls an \n\navatar that has to accomplish a set of challenges. These \n\ntypically consist of jumps between elements which are \n\nreferred as platforms. Some popular examples of this \n\ntype of games are: Super Mario Bros, Sonic \u2013 The \n\nHedgehog and Little Big Planet. Screenshots of these \n\nthree games are provided in Figure 1. \n\nThe main difference in generating automatically platform \n\nlevels in comparison with other automated graphical gen-\n\nerations, such as buildings, trees or even terrain, is that  \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nthe final result represents a challenge with a certain diffi-\n\nculty, and a minor change can affect it with indefinite \n\nproportions. For instance, one platform moved slightly \n\nfrom its original place in a well balanced level can make \n\nit impossible to finish. Therefore, the main question that \n\narises is: How do we measure difficulty in a platform \n\nlevel? \n\nIn order to answer the previous question, we propose a \n\nmethod to measure difficulty in a platform level, which \n\nwe stated that can be considered as a relation to the prob-\n\nability of failure. Inside this topic our main contributions \n\nare: \n\n? A study on the main questions related to difficulty in \nplatform games. \n\n? A proposal for a method to measure difficulty in \nplatform game levels, relying on success probability. \n\n? A practical usage of the difficulty proposed principle \non some levels of existing commercial applications. \n\nIn the next section we will explain some of the major \n\nmotivations behind difficulty measurements in the topic \n\nof automated generation of videogame content.  \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n    \n\nFigure 1 \u2013 Screenshots of the games Super Mario Bros. (A), Little Big Planet (B) and Sonic \u2013 The hedgehog (C) \n\nA B C \n\n\n\n \n\n \n\n2. WHY MEASURE DIFFICULTY? \nAs stated in the previous section, this study consists in \n\nimproving the knowledge about difficulty in platform \n\ngames, which can represent a step forward in processes \n\nthat automatically generate this kind of levels. There are \n\nseveral possible approaches for platform level generation, \n\nbut only a few have been made effective, as we will see \n\nin a later stage of this document, in section 5, where the \n\nrelated work is presented with more detail.   \n\nTo better understand the problem, we can consider a sys-\n\ntem that generates levels on-the-fly where the user can \n\nplay. For the sake of ease we can also consider by now \n\nthat the system validates physical restrictions and thus \n\nproduces always valid levels. This means that the user \n\nwill always have a chance to succeed, depending only on \n\nhis/her skills. However, even in these conditions, there is \n\nno way to ensure that the challenge is appropriate for the \n\nuser because all levels are treated equally. This leads us \n\nto the need of matching users\u2019 skills to provided chal-\n\nlenges, which should have an appropriate dimension of \n\ndifficulty. As a result, it is required that generated levels \n\nhave a certain difficulty value. In the next section we will \n\nlook at the most common situations that are present in \n\nmost platform games in order to understand where the \n\ndifficulty lies and hence measuring it. In section 4 we \n\nwill also present some examples to show that several \n\ncommon game situations can be fitted in our reference \n\nsituations. \n\n3. DIFFICULTY IN PLATFORM GAMES \n\n3.1 Understanding difficulty in a whole level \nWe presented the problem of measuring difficulty on \n\nplatform game levels and its importance for automated \n\nprocedural generation, in particular for content adapta-\n\ntion. In this section we will try to answer the following \n\nquestion: What makes a level difficult? \n\nIn order to understand where difficulty lies, our main \n\nexamples will consider the more trivial cases for platform \n\nlevels and their possible adaptations, covering the com-\n\nmon structures that this type of games have, as proposed \n\nby Compton and Mateas [Compton06]. Levels are de-\n\nfined with one start point and one end point in a bi-\n\ndimensional geometry. Some levels may have certain \n\nobjects that harm the player\u2019s avatar causing him to lose. \n\nThese will be represented as spikes, which are common \n\nobjects in this type of games. In addition, there are two \n\nmain considerations to take into account regarding to the \n\nuser experience, which are the following: \n\n? The users are aware of the task they are doing, which \nmeans that every challenge is directly identifiable, as \n\nproposed by typical usability heuristics such as those \n\npresented by Desurvire et al. [Desurvire04]. \n\n? Trivial tasks, such as moving from one place to an-\nother in a single platform or climbing up a ladder, \n\nare not relevant in difficulty measurements.  \n\nWith those principles we will consider the five different \n\ncases represented in Figure 2, which can be briefly de-\n\nscribed as follows:  \n\nA. A straight way where it is impossible to fail. Since \nthe user knows what to do he/she will not run blindly \n\nagainst the left wall. \n\nB. An impossible level because the end point is physi-\ncally unreachable. \n\nC. An almost impossible level with the end point being \nalmost physically inaccessible. \n\nD. One level with a single jump that the user must ac-\ncomplish to reach the end point. Failure attempting \n\nthe jump will cause the player to lose. \n\nE. A level where the user needs to jump from one block \nto another but if he/she fails he/she will be able to try \n\nagain after passing through another obstacle that may \n\ncause him to lose. The stairs represented in this case \n\nsimply mean that climbing to the first platform is a \n\ntrivial action that every user can do without difficul-\n\nties. \n\n \n\nFigure 2 \u2013 Five examples of common  \n\nsituations in platform games \n\nThe first case is a generalization to represent the easiest \n\nlevel that can exist. Due to the subjective nature of the \n\ntopic this cannot be proven but common sense seems to \n\nbe enough for this situation. The question here can be \n\nreversed and be thought with the following question: Can \n\nwe design an easier level than this? In fact, the task re-\n\nquired to complete the referred challenge can be de-\n\nscribed as a single action, where there is no possible way \n\nof losing. Simplifying the problem, it is plausible to say \n\nthat this first example is easy because the probability of \n\nlosing is zero. Completing this level consists on doing \n\none simple task with a probability value that can be con-\n\nsidered one. A simple graphical representation is avail-\n\nable in Figure 3. \n\n \n\nFigure 3 \u2013 State chart for example level 1 \n\nThe second example tries to create a contradiction with \n\nthe conclusion that we can retrieve from the first exam-\n\nple. In this case, the probability of losing is again zero, \n\nbecause there are no elements to harm the player\u2019s avatar. \n\nHowever, winning probability is also zero because the \n\nuser needs to jump to an unreachable place. The same \n\nproblem will occur if we think of an adaptation of the \n\nfirst example in which the start and end positions are too \n\n\n\n \n\n \n\nfar apart that there is no user with enough patience to \n\ncomplete the challenge. This leads us to another aspect to \n\ntake into account that is the probability of renouncing. \n\nConsidering the psychological approaches to this subject, \n\nthe user will resign playing if he/she is bored or frus-\n\ntrated. Boredom will occur in a situation as the adaptation \n\nof the first example, with an almost infinite distance be-\n\ntween start and end points. Frustration will occur in situa-\n\ntions as the second example, where the user in presented \n\nwith an impossible task. The idea of a good game is to \n\nkeep the user in-between those two states, in a state that \n\nis designated as flow [Csikszentmihaly91]. The state \n\nchart in Figure 4 is a possible representation of the de-\n\nscribed situation.  \n\n \n\nFigure 4 \u2013 State chart for example level 2 \n\nIn the third example we keep the user again in a harmless \n\nlevel with one single jump that has to be accomplished. \n\nThe main difference is that in this case the full probabil-\n\nity is divided in success and giving up. A state chart is \n\nprovided in Figure 5 to represent this situation, consider-\n\ning P(j?) the probability of success in the first obstacle, \nin this case a jump, and P(r) a general resign probability \nfor the user after failing one challenge. If we consider an \n\nimpossible jump, it is possible to state that this case and \n\nthe correspondent diagram will result in the previous \n\nsituation. In the next subsection we will explore the asso-\n\nciated calculations that can be extracted. \n\nPlayer \n\nrenounced\n\nLevel\n\nStarted\n\nLevel\n\nCompleted\nP(j1)\n\nRetry?1-P(j1)\n\n1-P(r)\n\nP(r)\n\n \n\nFigure 5 \u2013 State chart for example level 3 \n\nThe fourth example adds the existence of harm, which \n\ncause the player to fail immediately. Considering that the \n\ndistances between the start and the end point are small, \n\nwe can consider that the user will not forfeit because the \n\nlevel consists in one single task. So, the probabilities will \n\nbe divided directly in winning and losing, as represented \n\nin Figure 6. Those probabilities are only linked with the \n\ndifficulty of the jump, which will have a probability of \n\nsuccess defined by P(j?) as in the previous example. We \nwill also approach this problem with some more detail in \n\nthe next subsection. \n\n \n\nFigure 6 - State chart for example level 4 \n\nFinally, the fifth example gives us a single jump with no \n\ndirect harm that causes failure but that requires succeed-\n\ning in another jump in order to retry. The result is a loop \n\nas in the previous case. The main difference is that, in \n\nthis last example, the retrying loop can be broken either \n\nby renounce or by failing in the process. This is repre-\n\nsented with the state chart in  Figure 7. \n\n Figure 7 \u2013 State chart for example level 5 \n\nAfter the previous examples we can identify two main \n\nvariables that contribute to difficulty in one level: \n\n? P(r): The probability of renouncing after failing one \nattempt, which we will consider constant in one \n\nlevel. This value is directly related to the player\u2019s re-\n\nsilience. \n\n? P(j?): The probability of achieving success in the \njump or similar challenge with the index i. \n\nAlso, we could identify that there are two main elements \n\nto consider for the difficulty calculations over one level, \n\nwhich are the obstacles where the avatar may directly \n\nlose and the obstacles that will make the avatar repeat \n\nother obstacles that may eventually cause renounce or \n\nfailure. \n\nWith these concepts in mind, we will proceed to the next \n\nsubsection to understand how to extract final probability \n\nvalues and thus difficulty. \n\n3.2 Measuring difficulty in a level \nIn the previous subsection we represented the most com-\n\nmon situations in platform games and identified that dif-\n\nficulty is related to the probability of being unsuccess-\n\nfully, which might be caused by failure or resignation. \n\nThe studied situations were represented as state charts in \n\nwhich every transition is associated with a probability \n\nvalue. Our proposal is to calculate the probability of suc-\n\n\n\n \n\n \n\ncess and failure that is recursively represented in those \n\ncharts, and thus extract difficulty.  \n\nCalculating probabilities in cases like one, two and four \n\nare simply a sequence of independent cases of probabili-\n\nties, thus measuring difficulty can be calculated by mul-\n\ntiplying all the values from the start to the end point. \n\nCases like the examples three and five have loops in the \n\nrepresentation, which makes the calculation less simple. \n\nFor instance, probability of success in example four is the \n\nprobability of making the jump on the first attempt plus \n\nthe probability of making it at the second attempt, if there \n\nis a second attempt, and so on. This can be expressed \n\nmathematically with an infinite equation to represent the \n\nprobability of success P(s) as follows: \nP(s) = P(j1) + P(j1?). P(r?). P(j1) + ?  +?P(j?). P(r?)??. P(j1) + ...   \n\nThis equation can be compressed, resulting in the follow-\n\ning: \n\nP(s) = P(j1) ??P(j1?). P(r?)??\n?\n\n \n\nIf we think of a whole level, measuring these probabili-\n\nties with a formal model will require a long set of equa-\n\ntions and the calculation of these series. However, the \n\ninformation is more likely to be represented as a state-\n\nchart or a graph rather than in mathematical notation, so \n\nthese calculations might be done with a recursive and \n\niterative algorithm that spreads probabilities over the \n\nnodes until a certain precision is reached. \n\nConsidering the previous representations for the whole \n\nproblem and that we can recursively spread probability \n\nvalues through a graph in order to understand what are \n\nthe final probabilities to achieve success and failure in \n\none level, it is important to extract the probability values \n\nfor the connections in the graphs, which represent the \n\ndifficulty for isolated jumps or, more generically, isolated \n\nobstacles. This topic is about to be approached in the next \n\nsubsection.  \n\n3.3 Difficulty for independent obstacles  \nIn this subsection we propose a method for measuring the \n\ndifficulty for each isolated jump or challenge, which can \n\nbe used to feed the probability graphs presented in the \n\nlast subsection. \n\nOne simple assumption is that a single jump is more dif-\n\nficult to accomplish if the gap to jump is bigger. This is \n\nvalid for platforms at the same height, but for different \n\nheights the problem is not that direct. With a physics \n\nsimulator it is possible to identify the multiple alterna-\n\ntives to make a successful jump between two platforms. \n\nCompton and Mateas [Compton06] already proposed this \n\napproach but only as a theoretical possibility without \n\nconcretization. In addition, looking at all existing combi-\n\nnations of jumps also gives just a notion on the difficulty \n\nof a jump by counting the successful and failure cases. \n\nSome of those cases will be more likely to happen than \n\nothers, because the user keeps correcting the movement \n\nin the jump. Since transposing physical constraints to a \n\ndifficulty measurer may be a difficult task, especially if \n\nwe are estimating difficulty in an existing game with \n\nclosed source, we propose a faster alternative based on \n\nthe jump characteristics. So, in a jump, at a higher level \n\nof abstraction, the player is trying to jump from one point \n\nto another. These points represent the edges of the origin \n\nand destiny platform. With this in mind, our approach \n\nconsists in launching a projectile from the first point P? \nand measuring a possible margin of error for its trajectory \n\nrelatively to the second point P?. \nRecalling some basic physics, a projectile trajectory can \n\nbe defined by the following set of equations in order of \n\ntime: x(t) = x? + v??. t     and      y(t) = y? + v??. t ? ?? a. t? \nOnce every jump is relative to the platform from which \n\nthe user is jumping, we can consider the origin point (P?) \nas the reference to simplify the equations. Also, we will \n\nnot consider a throwing angle, so the initial speed can be \n\ndefined as a constant (K?), configurable for different \ngames. Finally, these calculations are space oriented and \n\nthe jump duration is not used, so the calculation can be \n\nresumed as one expression, which is basically a quadratic \n\nequation intersecting the origin, simply defined by: \n\nf(x) = K?. x ?\n1\n2 a. x\n\n? \n\nThis trajectory can be seen as the biggest possible jump \n\nthe avatar can perform. By intersecting the projectile with \n\ntwo lines that are parallel to the Cartesian axis and that \n\nalso intersect the destiny point, we can estimate the pos-\n\nsible deviation to the trajectory that is still a valid jump. \n\nFrom now, this deviation will be referred as the error \n\nmargin. In fact, we are identifying two values: the height \n\nof the player when he/she horizontally reaches the plat-\n\nform (?y) and the horizontal amplitude of the jump (?x). \nSo, our error margin has values in x and y axis (m? and \nm?) defined by ?? ? x? and ?? ? y?, respectively, with \nP? = (x?, y?). This concept is graphically summarized in \nFigure 8.  \n\n \n\nFigure 8 \u2013 Graphical representation of  \n\nthe concept of error margin \n\nObtaining m? requires knowing ?y, which consists on \ncalculating f(x?). A negative value means that the plat-\nform in unreachable with the reference jump. Here, the \n\nsystem has to identify whether the platform is really un-\n\nreachable and thus the error margin is immediately zero \n\nwithout any other calculations, or the jump has to be at-\n\ntempted differently (for instance, moving the origin point \n\n\n\n \n\n \n\nto the left). For positive values we measure the horizontal \n\ntolerance by calculating the value of  for which f(x) \nequals y?, which consists in solving a second degree \nequation and selecting the appropriate root. To normalize \n\nresults we consider the error margins as relative values to \n\nthe full distances measured along the axis. In the end we \n\nmultiply both the normalized error margins to define the \n\nfinal error margin for the obstacle (&amp;), defined between \nzero and one.  \n\nEmpirically, one can perceive that difficulty is related to \n\nthe error margin in a non-linear fashion. As error margin \n\ndecreases it is expectable to have a few failures occasion-\n\nally occurring, but as the error margin gets lower, more \n\nand more failures are willing to occur. To reflect this \n\nprinciple, we represent the final difficulty value for each \n\nobstacle based in an exponential function with the fol-\n\nlowing equation for difficulty in the obstacle of index i:  \n\nD(i) = &amp;)*+  \nThe constant ,- represents the mapping of the linear \nerror margin and the expected exponential distribution \n\nthat can be configured to a certain player profile. In the \n\nresults presented in section 4 we will present some com-\n\nparisons.  \n\n3.4 Dynamic entities \nOur main principles consider a static scenario, which is \n\nsomehow a limitation. Some alternatives and proposals \n\nfor the dynamic question will be addressed in future \n\nwork. However, in this subsection we will present how \n\nwe deal with this problem in our current studies.  \n\nTypically, in a platform game, dynamic objects are mov-\n\ning platforms and enemy creatures. For the first ones, we \n\ncan consider a gap that separates two platforms and that \n\nis impossible to jump across the gap. One moveable plat-\n\nform slides from one side of the gap to the other, so the \n\nuser needs to use it as a transport. Considering that the \n\nuser is focused in the task and it is not exploring the sce-\n\nnario in a way that is not intended, this process consists \n\nin jumping two gaps. The main issue is that the move-\n\nment of the dynamic platform produces an extra error \n\nprobability. Also, the faster the platform moves, the big-\n\nger the error might be. So, for situations like this, we ap-\n\nply the calculations previously presented for normal \n\njumps. However, to represent the increase of difficulty \n\ncaused by dynamics, the gap distance to consider is a \n\nnormal jump to the platform at the nearest place plus an \n\nextra term that is proportional to platform speed and a \n\nconstant. Representing enemies can also be considered as \n\njumping implicit gaps. Depending on the enemy\u2019s char-\n\nacteristics (mainly speed and size), we manually define a \n\nvalue for P?.  \n3.5 Final remarks \nIn this section we have presented an approach to measure \n\ndifficulty in platform game levels. For each obstacle we \n\ndefined an error margin to extract an estimated probabil-\n\nity of succeeding. The whole level can be considered as a \n\ngraph with multiple transitions where the referred prob-\n\nabilities can be applied to obtain a global value. The next \n\nsection presents some results about applying this concept. \n\n4. CASE STUDY \nIn this section we will briefly explain our experiences on \n\nmeasuring difficulty in levels of existing commercial \n\napplications. Our experiments consisted on the following: \n\n? Mapping existing game levels in a representation \nwith only the situations previously presented and \n\nmeasuring difficulty in the mapped levels with the \n\nprinciples previously presented. \n\n? Testing levels with real players on the referred lev-\n\nels, measuring their probability of success and com-\n\nparing to the estimated results. \n\n4.1 Mapping and measuring existing levels \nAs we previously referred, we applied our proposed met-\n\nrics to some existing games. The classics are useful be-\n\ncause normally it is possible to find online bitmaps with \n\nwhole level representations. The results of this subsection \n\npresent difficulty measurement in some levels of the \n\ngame Super Mario Bros. \n\nFirst, in Table 1 we present the success probability for a \n\nregular user in some levels of this game measured as we \n\nproposed in this document. We selected a set of levels \n\nthat share similar objects and obstacles to avoid having \n\nparticular aspects biasing the conclusions, such as the \n\nexistence of bosses, portals or different physical condi-\n\ntions (for instance, some levels are played under water). \n\nThe value T in the table represents the number of times \n\nthe user will retry an unsuccessful jump. \n\nLevel T=1 T=2 T=3 T=? \n\nW1L1 10.8% 32.4% 40.8% 44.6% \n\nW1L2 3.5% 10.7% 13.7% 15.0 % \n\nW1L3 .5% .8% .9% 1% \n\nW2 L1 .22% 3.15% 5.8% 7.4% \n\nW3 L1 2.4% 15.9% 21.6% 24.0% \n\nW3 L2 3.6% 13.2% 15.3% 15.7% \n\nW3 L3 .40% .51% .52% .52% \n\nTable 1: Measured values in Super Mario Bros. \n\nOne interesting aspect to notice in these results is that, in \n\nfact, levels tend to have higher difficulty values as the \n\ngame evolves (less probability of success). It is also pos-\n\nsible to notice that different resilience values for the user \n\n(T) influences the final probability of success. In particu-\n\nlar, a value of 1 represents the less resilient player that \n\ncan exist, which is one that resigns automatically after \n\nfailing one simple jump.  \n\nThis particular game, as some others of the genre, organ-\n\nises the levels in groups named as worlds (in table 1, W \n\nstands for world and L for level). One can also notice that \n\nwhen a new world starts difficulty tends to have a small \n\ndecrease before rising again. This might represent an \n\nintention of having a resting level after completing a dif-\n\nficult task, in this case, the last level of the previous \n\nworld. \n\nMoreover, tuning the exponential coefficient allows ad-\n\njusting the values in proportions to have them to be more \n\n\n\n \n\n \n\nreliable for usage as real success probabilities. Lower \n\nvalues are more suitable to represent the more skilled \n\nplayers, which are very unlikely to lose in small chal-\n\nlenges.  Contrary to this, higher values represent less \n\nskilled players that have higher failure rates immediately \n\nas challenges appear. \n\nIn Table 2 we fixed the value of T to 3 and vary the ex-\n\nponential coefficient. So, each column represents the \n\nprobabilities for players with different skills in the levels \n\npresented in each row. \n\nLevel Kd=.25 Kd=.33 Kd=.50 \n\nW1L1 40.8% 28.9% 12.6% \n\nW1L2 13.7% 6.8% 1.4% \n\nW1L3 .9% .2% .01% \n\nW2 L1 5.8% 2.0% .2% \n\nW3 L1 21.6% 13.3% 3.3% \n\nW3 L2 15.3% 8.2% 2.1% \n\nW3 L3 .52% .10% .003% \n\nTable 2: Measured values for difficulty in  \n\nSuper Mario Bros. with different Kd Values \n\n We proceed now to some tests we ran with a set of play-\n\ners in the game Little Big Planet. This game was particu-\n\nlarly useful because it allows users to create their own \n\nlevels. With this, it was possible to create our own test \n\nset. We created a small template level with a few jumps \n\nand adapted it to have different versions with distinct gap \n\nsizes in order to influence the difficulty. In table 2 we \n\npresent the predicted and the effective probability of suc-\n\ncess for each obstacle. \n\nReal P(s) \nPred. P(s) \n\nKd=.3 \n\nPred. P(s) \n\nKd=.2 \n\nPred. P(s) \n\nKd=.1 \n\n40,4% 40% 54% 74% \n\n89,3% 48% 62% 78% \n\n91,7% 65% 75% 87% \n\n96,2% 57% 69% 83% \n\n96,2% 57% 69% 83% \n\n96,2% 94% 96% 98% \n\n97,1% 78% 84% 92% \n\n98,0% 74% 82% 90% \n\n98,0% 94% 96% 98% \n\n98,0% 87% 91% 95% \n\n98,0% 89% 92% 96% \n\n98,0% 81% 87% 93% \n\n100,0% 95% 96% 98% \n\nTable 3: Examples of measured difficulty in the levels \n\ncreated for the game Little Big Planet \n\nEven though we have not yet extracted correlations to the \n\nobtained values, some relations are detectable. In further \n\nexperiments we intend to apply some categorizations to \n\nour users, mapped to different values for ,-, in order to \nachieve for accurate values. \n\n5. RELATED WORK \n\n5.1 Platform videogames \nPlatform games have been studied before by a few au-\n\nthors. There are three main relevant works to refer in the \n\ncontext of this article. In fact, those three articles are the \n\nresult of continuous work inside the same research group.  \n\nIn the first work, Compton and Mateas [Compton06] \n\nstudied the structure of platform levels, identifying some \n\nconstruction parameters to configure platforms. Also, \n\nthey identified that platforms are associated together by \n\npatterns that represent the actions that the avatar has to do \n\nin order to pass through a certain section in one level, \n\ndesignated as cell. They also identified the main struc-\n\ntures of organising cells in one level, which was particu-\n\nlarly helpful in the definition of the examples presented \n\nin the previous sections of this document. Finally, they \n\nstated that a system that automatically generates levels \n\ncould be improved by measuring difficulty. As a theo-\n\nretical approach, the authors pointed this analysis as one \n\nstep of the process. In their proposal, one possible ap-\n\nproach for this was to calculate all possible trajectories \n\nfor each jump from one platform to another. With this, \n\nthey wanted to be able to calculate the spatial window to \n\na possible successful jump. In some aspects, the concept \n\nof error margin previously presented in this article repre-\n\nsents a window like this. Also, they wanted to use the \n\nreferred physical calculation to extract the time window \n\nthe player has to make corrections to the movement.  \n\nLater, Smith et al. [Smith08] defined a framework to ana-\n\nlyse platform levels in which concerns to its structure. \n\nSome important concepts were formalised, resulting in a \n\nconceptual model to define a generic level. The need of \n\nclassifying difficulty was identified once again but only \n\nproposed as a future work. Recalling the simplifications \n\nor abstractions previously considered to deal with dy-\n\nnamic objects and enemies, the same approach was con-\n\nsidered by these authors. For instance, they defined a \n\nplatform level as a hierarchy where everything that may \n\ncause damage to the player is a generic obstacle. This \n\nmeans that one gap between two platforms is an obstacle. \n\nSince in our work we directed our measurements to dis-\n\ntance, our abstraction was built in the other way around, \n\nby mapping objects into gaps. \n\nThe previously presented concepts lead to an effective \n\nimplementation of a level generator [Smith09]. This im-\n\nplementation starts with a rhythm generator that creates a \n\nset of actions to be done by the avatar. Those actions are \n\nthen used with a physics system in order to generate a \n\nvalid geometry, which is one that allows the user to repli-\n\ncate the generated actions. A system based on critics \n\nanalyses the generated levels to avoid over generation \n\nand also to establish a quality threshold. However, the \n\ngeometry that is created is still not analysed with a diffi-\n\nculty perspective. Once again, it was identified the need \n\nof measuring difficulty for further implementations. Also, \n\nthe authors stated that measuring difficulty can be used \n\n\n\n \n\n \n\ninside the critics system. The approach we have pre-\n\nsented allows analysing a level with the condition of hav-\n\ning the set of actions well identified. Once their proposal \n\nis rhythm-based, which means that all the level is gener-\n\nated based on a set of actions, difficulty could be meas-\n\nured as we proposed. \n\nBesides the three previous works, there is one particular \n\nstudy for platform games that is important to refer, de-\n\nveloped by Pederson et al. [Pedersen09]. Their focus was \n\ndirected to more abstract concepts about user experience. \n\nIn particular, the authors studied the users\u2019 perceptions in \n\nan adapted version of the game Super Mario Bros. Sev-\n\neral users played the game with different features to es-\n\ntablish correlations between those features and reported \n\nemotions. A model was built with the obtained results in \n\norder to predict fun, challenge and frustration. \n\n5.2 Difficulty measurements in other genres \nIn other genres, difficulty has been used in some more \n\nconcretized manners. Just to give a brief overview of \n\nthat, we will point a few examples.  \n\nTogelius et al. [Togelius07] presented a system to auto-\n\nmatically generate racing tracks for a driving simulator. \n\nTo evaluate each track quality for usage as fitness func-\n\ntion in a genetic algorithm, they used artificial drivers, \n\nmapped to a certain profile, to extract some attributes \n\nsuch as timings and speeds.  \n\nA similar approach was used for Pac-Man-like games by \n\nTogelius and Schmidhuber [Togelius08]. The interesting \n\naspect of this work is that the generation process pro-\n\nduces game variants instead of game levels. Again, the \n\nmain principle used was evolutionary computation and \n\nthe measurements of difficulty were accomplished by \n\nmaking intelligent agents play the game.  \n\nFinally, another interesting work to refer was developed \n\nby Pereira et al. [Pereira09]. In this case the objectives \n\nand approaches are considerably different from the last \n\nones. The considered genre was Strategic Multiplayer \n\nBrowser Game, which consists on a slow paced evolution \n\nsystem, accessed by players a few times on one day to \n\nestablish some strategies about virtual resource manage-\n\nment. The system tries to involve the player in an ambi-\n\nent that fits the user preferences, with a balanced distribu-\n\ntion of resources to avoid repetition. Also, the authors \n\nrefer the importance in handling efficiently the constant \n\nappearance of new players in the earlier stages of the \n\ngame. \n\nNaturally, there are several other examples of dynamic \n\nadjustment of difficulty, in particular on commercial \n\ngames. Nevertheless, the presented cases are particularly \n\ninteresting because they have emphasis on automated \n\ngeneration of content. \n\n5.3 Practical usage of difficulty measures \nAs presented in this document, the main importance of \n\nquantifying difficulty is that it also allows adapting it. \n\nAdapting difficulty in videogames has the main objective \n\nof levelling a challenge among intervenients. However, it \n\nis important to make those adaptations without compro-\n\nmising the core player experience [Hunicke05]. For a \n\nsingle player game, adapting difficulty normally consists \n\non tuning artificial intelligence behind virtual agents. In \n\nmultiplayer games the key idea is to make the challenge \n\nhigher to expert players and lower to casual player. The \n\nfinal goal is that every player has a similar chance of \n\nwinning. Basically, it is the same intent as in some sports \n\nthat use handicap, such as golf. However, that system is \n\nnot always applicable, and in some videogames we can \n\nmake performance analysis in real-time and with that \n\nadjust difficulty in a more transparent way. One example \n\nof implementation of this concept is the work proposed \n\nby Mart\u00ednez and Mata [Mart\u00ednez09] in which a Pong \n\nversion is adapted according to players\u2019 skills. The au-\n\nthors considered that, in this game, difficulty is due to the \n\npaddle size and ball speed. This two attributes are \n\nadapted during game play to balance the result and level \n\nthe odds of each player. In addition, these values are also \n\nadapted to make the game challenging enough for both \n\nplayers, and not too easy or hard for both. \n\n6. CONCLUSIONS AND FUTURE WORK \n\n6.1 Conclusions \nWe have proposed a way to measure difficulty in plat-\n\nform games and presented its possible application in real \n\ngames. With basic probability principles, we define the \n\nflow of action in a level in association with failing prob-\n\nabilities to obtain a final probability of completing a level \n\nwith success. Resilience parameters were also considered \n\nto reflect the possibility of a user to resign on harder \n\nchallenges. In addition, basic projectile principles al-\n\nlowed a simple estimation of difficulty for each individ-\n\nual obstacle, which is mapped in a probability value to be \n\nused in the calculations of the full success probability. \n\nOur primal experiences show that estimating difficulty \n\nbased on probability gives an effective notion about its \n\ngrowth. We have tested our measurement in some exist-\n\ning games, in particular a few classics in the gaming in-\n\ndustry. As presented previously in section 4, with the \n\nresults obtained in Super Mario Bros., we could verify \n\nthat our approach generally identifies the earlier levels as \n\nbeing easier than the later ones. This goes in line with the \n\nempirical notion of common users and basic design rules. \n\nOne important aspect is that the obtained results don\u2019t \n\nconsider the existence of lives (attempts) and check-\n\npoints. So, the probability values presented estimate the \n\nchance that the user has to complete the whole levels in \n\none single try. \n\nFinally, our tests with users also allowed identifying a \n\nrelationship between the proposed difficulty estimator \n\nand the real probability of success. Once again, it is no-\n\nticeable that the difficulty measured can estimate if a \n\nlevel is easier or harder, but it does not represent an ef-\n\nfective probability of success in one level. \n\n6.2 Future Work \nEven though we have identified some of the principles \n\nwhere difficulty in platform games is based on, some of \n\nthose need to be analysed with more depth. \n\nFirstly, we believe that it is important to expand the con-\n\ncept of obstacle. The simplifications used for enemies \n\n\n\n \n\n \n\nand dynamics were a sufficient solution for this first ap-\n\nproach, but this is a question that requires other calcula-\n\ntions to be defined with more detail.  \n\nAs stated before, the measurements didn\u2019t consider the \n\nexistence of checkpoints and lives that allow the user to \n\nretry the level. It would be interesting to expand the study \n\ntaking this aspect in account and identifying possible \n\ndifferences.  \n\nAlso, it would be interesting to consider the existence in \n\nsome levels of the so called bosses, which are particularly \n\nskilled enemies. For that reason, some levels were not \n\nanalysed.  \n\nMoreover, it is important to make parameter adjustment \n\nbased in real measurements rather than the ad-hoc tuning \n\nthat was used. In particular, the coefficient used can rep-\n\nresent the user skills, hence predicting more accurately \n\nthe user\u2019s probability of success.  \n\nFinally, an interesting way to improve data gathering and \n\nanalysis, in particular on what concerns to difficulty, \n\nmight consist in the creation of a community where play-\n\ners could freely play automatically generated levels. This \n\ncould improve the results obtained in-game.  \n\n7. REFERENCES \n[Compton06] Compton, K. and Mateas, M.  2006. Proce-\n\ndural Level Design for Platform Games.  Proceed-\n\nings of the 2nd Artificial Intelligence and Interactive \n\nDigital Entertainment Conference (Stanford, CA, \n\n2006). \n\n[Csikszentmihaly91] Csikszentmihaly, M.  Flow: The \n\nPsychology of Optimal Experience.  Harper Collins, \n\nNY, 1991. \n\n[Desurvire04] Desurvire, H., Caplan, M., and Toth, J. A. \n\n2004. Using heuristics to evaluate the playability of \n\ngames. CHI '04 Extended Abstracts on Human Fac-\n\ntors in Computing Systems (Vienna, Austria, April \n\n24 - 29, 2004). CHI '04. ACM, New York, NY, \n\n1509-1512.  \n<http://doi.acm.org/10.1145/985921.986102> \n\n[Hunicke05] Hunicke, R. 2005. The case for dynamic \n\ndifficulty adjustment in games. Proceedings of the \n\n2005 ACM SIGCHI international Conference on Ad-\n\nvances in Computer Entertainment Technology (Va-\n\nlencia, Spain, June 15 - 17, 2005). ACE '05, vol. 265. \n\nACM, New York, NY, 429-433. \n<http://doi.acm.org/10.1145/1178477.1178573> \n\n \n\n  \n\n[Mart\u00ednez09] Ib\u00e1\u00f1ez-Mart\u00ednez, J. and Delgado-Mata, C. \n\nFrom competitive to social two-player videogames. \n\nProceedings of the 2nd Workshop on Child, Com-\n\nputer and interaction (Cambridge, Massachusetts, \n\nNovember 05 - 05, 2009). WOCCI '09. ACM, New \n\nYork, NY, 1-5. \n<http://doi.acm.org/10.1145/1640377.1640395> \n\n [Pedersen09] Pedersen, C., Togelius, J., and Yannakakis, \n\nG. N. 2009. Modeling player experience in super \n\nmario bros. In Proceedings of the 5th international \n\nConference on Computational intelligence and \n\nGames (Milano, Italy, September 07 - 10, 2009). \n\nIEEE Press, Piscataway, NJ, 132-139. \n\n[Pereira09] Pereira, G., Santos, P. A., and Prada, R. 2009. \n\nSelf-adapting dynamically generated maps for turn-\n\nbased strategic multiplayer browser games. Proceed-\n\nings of the international Conference on Advances in \n\nComputer Enterntainment Technology (Athens, \n\nGreece, October 29 - 31, 2009). ACE '09, vol. 422. \n\nACM, New York, NY, 353-356.  \n<http://doi.acm.org/10.1145/1690388.1690457> \n\n[Smith08] Smith, G., Cha, M., and Whitehead, J. 2008. A \n\nframework for analysis of 2D platformer levels. Pro-\n\nceedings of the 2008 ACM SIGGRAPH Symposium \n\non Video Games (Los Angeles, California, August \n\n09 - 10, 2008). Sandbox '08. ACM, New York, NY, \n\n75-80. \n<http://doi.acm.org/10.1145/1401843.1401858> \n\n[Smith09] Smith, G., Treanor, M., Whitehead, J., and \n\nMateas, M. 2009. Rhythm-based level generation for \n\n2D platformers. Proceedings of the 4th international \n\nConference on Foundations of Digital Games (Or-\n\nlando, Florida, April 26 - 30, 2009). FDG '09. ACM, \n\nNew York, NY, 175-182. \n<http://doi.acm.org/10.1145/1536513.1536548> \n\n[Togelius07] Togelius, J. Nardi, R and Lucas, S. Towards \n\nautomatic personalised content creation for racing \n\ngames, Proceedings of the IEEE Symposium on \n\nComputational Intelligence and Games, 2007. \n<http://cogprints.org/5573/> \n\n[Togelius08] Togelius, J. and Schmidhuber, J. An expe-\n\nriment in automatic game design. Proceedings of the \n\nIEEE Symposium on Computational Intelligence and \n\nGames, 2008. \n<http://citeseerx.ist.psu.edu/viewdoc/summar\n\ny?doi=10.1.1.141.4110>"}]}}}