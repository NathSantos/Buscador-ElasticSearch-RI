{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.13267"}, {"@name": "filename", "#text": "19169_92156_Jefferson.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "LUCIANE PIRES WERLANG \nJEFFERSON AMORIM DE OLIVEIRA \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nAPLICA\u00c7\u00c3O DA MODULARIZA\u00c7\u00c3O NA ARQUITETURA E \nDESENVOLVIMENTO DE UM COMPONENTE DE PESQUISA BASEADO EM \n\nJAVA \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nPalho\u00e7a, 2006 \n\n\n\n \n\n  \n\nLUCIANE PIRES WERLANG \nJEFFERSON AMORIM DE OLIVEIRA \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nAPLICA\u00c7\u00c3O DA MODULARIZA\u00c7\u00c3O NA ARQUITETURA  E \nDESENVOLVIMENTO DE UM COMPONENTE DE PESQUISA BASEADO EM \n\nJAVA \n \n \n \n \n\nTrabalho de Conclus\u00e3o apresentado ao Curso de \nCi\u00eancia da Computa\u00e7\u00e3o, como requisito \u00e0 \nobten\u00e7\u00e3o do t\u00edtulo de Bacharel em Ci\u00eancia da \nComputa\u00e7\u00e3o. \n\n \n \n\nUniversidade do Sul de Santa Catarina \n \n \n \n \n\nOrientador Prof. M. Eng. Osmar de Oliveira Braz Junior \n \n \n \n \n \n \n \n \n \n \n \n\nPalho\u00e7a, 2006 \n\n\n\n \n\n  \n\nLUCIANE PIRES WERLANG \nJEFFERSON AMORIM DE OLIVEIRA \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nAPLICA\u00c7\u00c3O DA MODULARIZA\u00c7\u00c3O NA ARQUITETURA E \nDESENVOLVIMENTO DE UM COMPONENTE DE PESQUISA BASEADO EM \n\nJAVA \n \n \n\nTrabalho de Conclus\u00e3o apresentado ao Curso de \nCi\u00eancia da Computa\u00e7\u00e3o, como requisito \u00e0 \nobten\u00e7\u00e3o do t\u00edtulo de Bacharel em Ci\u00eancia da \nComputa\u00e7\u00e3o. \n\n \n \n\nUniversidade do Sul de Santa Catarina \n \n \n\nPalho\u00e7a, 05 de Dezembro de 2006. \n \n \n\n____________________________________ \nProf. M. Eng. Osmar de Oliveira Braz Junior \n\nUniversidade do Sul de Santa Catarina \n \n \n\n____________________________________ \nProf\u00aa. Msc. Vera Rejane N. Schuhmacher \n\nUniversidade do Sul de Santa Catarina \n \n \n\n____________________________________ \nMsc. Cristina Foga\u00e7a Soares Teixeira \n\nConvidado  \n \n\n\n\n \n\n  \n\nDEDICAT\u00d3RIA \n\nA meu querido esposo Rodrigo, pelo apoio e ajuda em \ntodos os momentos da minha vida. \n\n  \nLuciane Pires Werlang \n \n \nAos meus pais, Laurete e Nilton, pelo seu amor, carinho \ne confian\u00e7a, fontes de sabedoria, exemplos de vida e \nintegridade, sempre me apoiaram em todos os momentos \nda minha vida. \n \nJefferson Amorim de Oliveira \n\n\n\n \n\n  \n\nAGRADECIMENTOS \n\nAgradecemos, primeiramente, a Deus, pela vida e por \niluminar nosso caminho. \nAos nossos pais, pelo exemplo de vida. Aos nossos \nirm\u00e3os, pelo apoio e carinho. Ao professor Osmar de \nOliveira Braz Junior, nosso orientador, pelas \ncontribui\u00e7\u00f5es, est\u00edmulo, aten\u00e7\u00e3o e orienta\u00e7\u00e3o que nunca \nfaltaram. \nA todos os professores da UNISUL, que contribu\u00edram \npara o nosso crescimento pessoal. \nAos amigos, pelos momentos de distra\u00e7\u00e3o, alegria e \najuda.  \n\n \nVoc\u00eas foram essenciais! \n \n\n\n\n \n\n  \n\nRESUMO \n\nEste trabalho visa a aplica\u00e7\u00e3o da Ci\u00eancia da Computa\u00e7\u00e3o para an\u00e1lise, projeto e \nimplementa\u00e7\u00e3o de um sistema computacional. A necessidade de compreender as t\u00e9cnicas de \nmodulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o, assim como aplicar os conceitos da engenharia de \nsoftware para elaborar uma arquitetura de sistema foram fundamentais para obter reuso e \nredu\u00e7\u00e3o nos custos de manuten\u00e7\u00e3o e desenvolvimento de software. Al\u00e9m disso, utilizar uma \nmetodologia de desenvolvimento que de suporte ao reuso, ao desenvolvimento de \ncomponentes e que permita que a mesma seja customizada. No trabalho foi utilizado o IBM \nRational Unified Process (RUP).  Essa metodologia foi customizada e serviu para gerenciar \ntodo o processo de desenvolvimento do software e do componente e dessa forma permitir o \nacompanhamento de cada momento do desenvolvimento para evitar pular fases que poderiam \np\u00f4r em risco o restante do projeto. A aplica\u00e7\u00e3o dessas t\u00e9cnicas, em conjunto com o processo \nde desenvolvimento, resultou em um componente de pesquisa totalmente reutiliz\u00e1vel e \ntamb\u00e9m em um sistema de manuten\u00e7\u00e3o com pouca redund\u00e2ncia e com manuten\u00e7\u00e3o facilitada. \nNo entanto, para validar a aplica\u00e7\u00e3o dessas t\u00e9cnicas foram feitas compara\u00e7\u00f5es entre o sistema \ncom a funcionalidade de pesquisa implementadas internamente e o mesmo sistema utilizando \no componente para realizar as pesquisas. Os crit\u00e9rios utilizados foram c\u00f3digo-fonte, tamanho \nda aplica\u00e7\u00e3o, tempo de desenvolvimento, coes\u00e3o, acoplamento e reutiliza\u00e7\u00e3o. Dessa forma, \ncom os resultados obtidos foram sugeridas algumas recomenda\u00e7\u00f5es de uso. \n \n\nPalavras-chave: Modulariza\u00e7\u00e3o, Componentiza\u00e7\u00e3o, Desenvolvimento de Software, Reuso, \nEngenharia de Software, Arquitetura de Software, IBM Rational Unified Process. \n\n\n\n \n\n  \n\nABSTRACT \n\nThis work aims at the application of the Computer Science for analysis, project and \nimplementation of a computational system. The necessity to understand the techniques of  \ncreation of modules and development of components, as well as applying the concepts of the \nsoftware engineering to elaborate a system architecture had been basic to get reuses and \nreduction in the maintenance costs and development of software. Moreover, to use a \ndevelopment methodology that of support to reuse, to the development of components and \nthat it allows that the same one is adaptable. In the work IBM Rational Unified Process was \nused (RUP). This methodology was adaptable and served to manage all the process of \ndevelopment of software and the component and of this form to allow the accompaniment of \neach moment of the development to prevent to jump phases that could at risk put the remain \nof the project. The application of these techniques, in set with the development process, also \nresulted in a component of totality reusable research and in a system of maintenance with \nlittle redundancy and facilitated maintenance. However, to validate the application of these \ntechniques had been made comparisons between the system with the research functionality \nimplemented internally and the same system using the component to carry through the \nresearch. The used criteria had been code-source, size of the application, time of development, \ncohesion, coupling and reuse. Of this form, with the gotten results some recommendations of \nuse had been suggested.  \n\nKey words: Creation of Modules, Development of Components, Development of Software, \nReuse, Engineering of Software, Architecture of Software, IBM Rational Unified Process. \n\n \n\n\n\n \n\n  \n\nLISTA DE FIGURAS \n\nFigura 1. Proposta de Solu\u00e7\u00e3o .................................................................................................. 20 \n\nFigura 2. Elicita\u00e7\u00e3o de Requisitos Arquiteturais ...................................................................... 33 \n\nFigura 3. Princ\u00edpios da Orienta\u00e7\u00e3o a Objetos ........................................................................... 39 \n\nFigura 4. Exemplo de Heran\u00e7a ................................................................................................. 41 \n\nFigura 5. Fases da Metodologia RUP ....................................................................................... 44 \n\nFigura 6. Representa\u00e7\u00e3o de Componente em UML ................................................................. 46 \n\nFigura 7. Componentes e Interfaces ......................................................................................... 48 \n\nFigura 8. Estere\u00f3tipos e Valores atribu\u00eddos.............................................................................. 50 \n\nFigura 9. Intera\u00e7\u00e3o entre um Framework e a Aplica\u00e7\u00e3o .......................................................... 52 \n\nFigura 10. Workflow Fase de Concep\u00e7\u00e3o ................................................................................ 56 \n\nFigura 11. Workflow Fase de Elabora\u00e7\u00e3o ................................................................................ 61 \n\nFigura 12. Workflow da Tarefa Projetar Componentes ........................................................... 66 \n\nFigura 13. Workflow Fase de Constru\u00e7\u00e3o ................................................................................ 70 \n\nFigura 14. Workflow da Tarefa Implementar Componentes.................................................... 72 \n\nFigura 15. Workflow Fase de Transi\u00e7\u00e3o .................................................................................. 77 \n\nFigura 16. Cen\u00e1rio Tecnol\u00f3gico ............................................................................................... 82 \n\nFigura 17. Tela de Consulta...................................................................................................... 86 \n\n\n\n \n\n  \n\nFigura 18. Tela de Cadastro...................................................................................................... 86 \n\nFigura 19. Tela de Edi\u00e7\u00e3o......................................................................................................... 87 \n\nFigura 20. Tela de Consulta Cidade para o Cliente .................................................................. 88 \n\nFigura 21. Documento XML para Constru\u00e7\u00e3o da Pesquisa ..................................................... 91 \n\nFigura 22. DTD de Valida\u00e7\u00e3o para as Pesquisas...................................................................... 92 \n\nFigura 23. Dados da Conex\u00e3o ao Banco de Dados no XML.................................................... 92 \n\nFigura 24. Diagrama  de Classes do Componente.................................................................... 94 \n\nFigura 25. Pacotes do Componente .......................................................................................... 95 \n\nFigura 26. TLD com os Par\u00e2metros da Taglib ......................................................................... 96 \n\nFigura 27. C\u00f3digo JSP utilizando a Taglib sem o Par\u00e2metro \u201cimg\u201d ........................................ 97 \n\nFigura 28. P\u00e1gina demonstrando a Taglib sem o Par\u00e2metro \u201cimg\u201d ......................................... 97 \n\nFigura 29. C\u00f3digo JSP utilizando a Taglib com o Par\u00e2metro \u201cimg\u201d........................................ 98 \n\nFigura 30. P\u00e1gina demonstrando a Taglib com o Par\u00e2metro \u201cimg\u201d ......................................... 98 \n\nFigura 31. Trecho gerado pela Taglib ...................................................................................... 99 \n\nFigura 32. P\u00e1gina de Consulta ................................................................................................ 100 \n\nFigura 33. Localiza\u00e7\u00e3o do JAR e respectivos Arquivos de Configura\u00e7\u00e3o ............................. 101 \n\nFigura 34. Demonstra\u00e7\u00e3o do Diagrama Entidade e Relacionamento ..................................... 103 \n\nFigura 35. Diagrama de Interfaces do Sistema Manuten\u00e7\u00e3o com as Consultas Internas ....... 104 \n\nFigura 36. Diagrama de Interfaces Utilizando o Componente para fazer as Consultas ......... 105 \n\n \n\n\n\n \n\n  \n\nLISTA DE QUADROS \n\nQuadro 1. Descri\u00e7\u00e3o dos Elementos da Proposta de Solu\u00e7\u00e3o .................................................. 21 \n\nQuadro 2. Diferen\u00e7as entre Classe e Componente ................................................................... 47 \n\nQuadro 3. M\u00e9trica de Linha de C\u00f3digo .................................................................................. 106 \n\nQuadro 4. M\u00e9trica de Tamanho do Vocabul\u00e1rio .................................................................... 107 \n\n  \n\n \n\n\n\n \n\n  \n\nLISTA DE SIGLAS \n\nDLL \u2013 Dynamic-link library \n\nDTD \u2013 Document Type Definition \n\nEXE \u2013 Extens\u00e3o de arquivos que podem ser executados por computadores \n\nFerramentas CASE \u2013 Ferramentas Computer Aided Software Engineering \n\nJSP \u2013 Java Server Pages \n\nRUP \u2013 IBM Rational Unified Process \n\nUML \u2013 Unified Model Language \n\nXML \u2013 Extensible Markup Language \n\n \n\n\n\n \n\n  \n\nSUM\u00c1RIO \n\n1 INTRODU\u00c7\u00c3O ................................................................................................................... 14 \n\n1.1 Descri\u00e7\u00e3o do Problema ....................................................................................................... 16 \n\n1.2 Objetivos............................................................................................................................. 16 \n\n1.2.1 Objetivo Geral ................................................................................................................. 17 \n\n1.2.2 Objetivos Espec\u00edficos ...................................................................................................... 17 \n\n1.3 Justificativa para o desenvolvimento do projeto ................................................................ 18 \n\n1.4 Proposta de Solu\u00e7\u00e3o ........................................................................................................... 19 \n\n1.5 Delimita\u00e7\u00e3o......................................................................................................................... 21 \n\n1.6 Metodologia Cient\u00edfica Aplicada ao Trabalho ................................................................... 22 \n\n1.7 Estrutura do Trabalho ......................................................................................................... 23 \n\n \n \n2 REVIS\u00c3O BIBLIOGR\u00c1FICA ........................................................................................... 24 \n\n2.1 Engenharia de Software ...................................................................................................... 24 \n\n2.1.1 Engenharia de Requisitos ................................................................................................ 27 \n\n2.1.2 Requisitos de Software .................................................................................................... 29 \n\n2.2 Arquitetura de Software...................................................................................................... 31 \n\n2.2.1 Modulariza\u00e7\u00e3o ................................................................................................................. 34 \n\n2.2.2 Componentiza\u00e7\u00e3o ............................................................................................................ 37 \n\n2.2.3 Orienta\u00e7\u00e3o a Objetos ....................................................................................................... 38 \n\n2.3 An\u00e1lise e Projeto................................................................................................................. 42 \n\n2.4 Unified Modeling Language ............................................................................................... 45 \n\n2.5 Frameworks ........................................................................................................................ 51 \n\n\n\n \n\n  \n\n2.6 Considera\u00e7\u00f5es Finais .......................................................................................................... 53 \n\n \n \n3 MODELAGEM.................................................................................................................... 54 \n\n3.1 Concep\u00e7\u00e3o .......................................................................................................................... 55 \n\n3.2 Elabora\u00e7\u00e3o .......................................................................................................................... 60 \n\n3.3 Constru\u00e7\u00e3o .......................................................................................................................... 69 \n\n3.4 Transi\u00e7\u00e3o ............................................................................................................................ 76 \n\n \n \n4 DESENVOLVIMENTO...................................................................................................... 81 \n\n4.1 Ambiente de Desenvolvimento .......................................................................................... 81 \n\n4.2 Implementa\u00e7\u00e3o do Sistema Manuten\u00e7\u00e3o ............................................................................ 85 \n\n4.3 Implementa\u00e7\u00e3o do Componente LJ .................................................................................... 88 \n\n4.3.1 Cria\u00e7\u00e3o do XML e DTD .................................................................................................. 89 \n\n4.3.2 Cria\u00e7\u00e3o das Classes do Componente ............................................................................... 93 \n\n4.3.3 Cria\u00e7\u00e3o da P\u00e1gina para Consulta ..................................................................................... 95 \n\n \n \n5 VALIDA\u00c7\u00c3O .................................................................................................................... 102 \n\n \n \n6 CONCLUS\u00c3O.................................................................................................................... 109 \n\n \n \nREFER\u00caNCIAS ................................................................................................................... 112 \n\n \n \nAP\u00caNDICES ......................................................................................................................... 115 \n\nAP\u00caNDICE A \u2013 Artefato do RUP de Plano de Desenvolvimento de Software..................... 116 \n\nAP\u00caNDICE B \u2013 Artefato do RUP de Especifica\u00e7\u00e3o Complementar ..................................... 123 \n\nAP\u00caNDICE C \u2013 Artefato do RUP de Especifica\u00e7\u00e3o de Requisitos de Software ................... 129 \n\nAP\u00caNDICE D \u2013 Artefato do RUP de Especifica\u00e7\u00e3o de Caso de Uso ................................... 137 \n\nAP\u00caNDICE E \u2013 Artefato do RUP de Documento de Arquitetura de Software ..................... 152 \n\nAP\u00caNDICE F \u2013 Artefato do RUP de Plano de Itera\u00e7\u00e3o......................................................... 162 \n\nAP\u00caNDICE G \u2013 Artefato do RUP de Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso ............ 187 \n\nAP\u00caNDICE H \u2013 Artefato do RUP de Plano de Implementa\u00e7\u00e3o ............................................ 224 \n\nAP\u00caNDICE I \u2013 Artefato do RUP de Plano de Teste.............................................................. 230 \n\n\n\n \n\n  \n\nAP\u00caNDICE J \u2013 Artefato do RUP de Gloss\u00e1rio...................................................................... 237 \n\n\n\n \n\n  \n\n14 \n\n1 INTRODU\u00c7\u00c3O \n\nO princ\u00edpio de \u201cDividir para Conquistar\u201d era pouco utilizado quando o software \n\nconstitu\u00eda uma pequena por\u00e7\u00e3o dos sistemas computacionais. Entretanto, esse princ\u00edpio \n\ncome\u00e7ou a ser considerado quando o software dominou os sistemas computacionais tornando-\n\nse complexo e com custos de desenvolvimento e manuten\u00e7\u00e3o elevados. Tais fatos levaram \n\nespecialistas a buscar m\u00e9todos para melhorar o processo de desenvolvimento, assim como \n\ndefinir uma arquitetura de software que suportasse a reutiliza\u00e7\u00e3o de c\u00f3digo e complexidade \n\ndos sistemas (MENDES, 2002; PRESSMAN, 1995). \n\nA arquitetura de software descreve o sistema de uma forma global, bem como o \n\nrelacionamento entre subsistemas e componentes. Segundo Pressman (1995, p. 429), \u201ca \n\narquitetura de software deriva de um processo de divis\u00e3o em parti\u00e7\u00f5es que relaciona \n\nelementos de uma solu\u00e7\u00e3o de software a partes de um problema do mundo real\u201d. Nesse \n\nsentido, a arquitetura \u00e9 um guia no processo de desenvolvimento, no qual m\u00faltiplos sistemas \n\ncom funcionalidades distintas podem ser concebidos.  \n\nPara Mendes (2002, p. 6), \u201co processo de desenvolvimento de um sistema de \n\nsoftware vai desde a concep\u00e7\u00e3o do sistema, quando os requisitos s\u00e3o elicitados e analisados, \n\nat\u00e9 a sua concreta implementa\u00e7\u00e3o\u201d. Assim, na fase inicial do processo, h\u00e1 o interesse de \n\ncompreender a funcionalidade do sistema e na fase de implementa\u00e7\u00e3o, onde decis\u00f5es j\u00e1 foram \n\n\n\n \n\n  \n\n15 \n\ntomadas, uma \u00fanica arquitetura \u00e9 implementada. Entretanto, antes da implementa\u00e7\u00e3o de uma \n\narquitetura, a funcionalidade do sistema \u00e9 particionada, isto \u00e9, o sistema passa pelo processo \n\nde modulariza\u00e7\u00e3o.  \n\nA modulariza\u00e7\u00e3o como parte da arquitetura de software parte do princ\u00edpio de \n\ndividir um problema em pequenas partes, sendo que cada uma dessas partes ser\u00e1 independente \n\ne respons\u00e1vel pela realiza\u00e7\u00e3o de uma etapa do problema. Segundo Sanches (2006, p.10), \u201cpara \n\nque haja uma boa modulariza\u00e7\u00e3o \u00e9 necess\u00e1rio principalmente baixo acoplamento e alta \n\ncoes\u00e3o\u201d. O baixo acoplamento \u00e9 definido por uma independ\u00eancia l\u00f3gica dos m\u00f3dulos e a \n\ncomunica\u00e7\u00e3o controlada entre eles. A alta coes\u00e3o caracteriza-se por cada m\u00f3dulo exercer uma \n\natividade espec\u00edfica do sistema.  \n\nOs m\u00f3dulos encontrados no processo de modulariza\u00e7\u00e3o, podem se tornar \n\ncomponentes. Esta componentiza\u00e7\u00e3o, por sua vez,  ocorre  quando um ou mais  m\u00f3dulos se \n\ntornam uma parte f\u00edsica e substitu\u00edvel de um sistema e com o qual o respectivo componente \n\nest\u00e1 em conformidade e disponibilizado atrav\u00e9s de um conjunto de interfaces. Isso resulta em \n\nreutiliza\u00e7\u00e3o de c\u00f3digo, sistemas otimizados e pouca redund\u00e2ncia (BOOCH, 2000; BEZERRA, \n\n2002). \n\nDa mesma forma, quando encontramos m\u00f3dulos que pertencem a um mesmo \n\ndom\u00ednio de problema e com funcionalidades comuns a v\u00e1rias aplica\u00e7\u00f5es temos o que \n\nchamamos de framework. Tipicamente, um framework pode incluir programas de apoio, \n\nbibliotecas, linguagens de script e outros softwares para ajudar a desenvolver e reunir \n\ndiferentes componentes em um projeto de software (STAA, 2000; HUSTED, 2004). \n\n\n\n \n\n  \n\n16 \n\n1.1 Descri\u00e7\u00e3o do Problema \n\nNos \u00faltimos anos percebeu-se um grande avan\u00e7o nos neg\u00f3cios relacionados com a \n\ntecnologia da informa\u00e7\u00e3o. Com essa evolu\u00e7\u00e3o, o software tem ocupado cada vez mais espa\u00e7o \n\ne se tornado um componente vital para quase todos os segmentos de neg\u00f3cio.  \n\nCom essa crescente expans\u00e3o, os softwares tornaram-se cada vez maiores e mais \n\ncomplexos, aumentando seus custos de produ\u00e7\u00e3o e manuten\u00e7\u00e3o. Aliado a isto, as excessivas \n\nmudan\u00e7as pol\u00edticas e econ\u00f4micas exigem que os sistemas tenham a manuten\u00e7\u00e3o facilitada, a \n\nfim de reduzir o tempo de adapta\u00e7\u00e3o a estas mudan\u00e7as. \n\nPercebeu-se ent\u00e3o que para o desenvolvimento dos sistemas, a rela\u00e7\u00e3o custo-\n\nbenef\u00edcio n\u00e3o estava boa. A partir disso, foram buscados meios para reduzir os custos no \n\ndesenvolvimento e manuten\u00e7\u00e3o de softwares e assim obter mais lucro que \u00e9 essencial para o \n\nfuncionamento das economias nacionais e internacionais (SOMMERVILLE, 2003). \n\n1.2 Objetivos \n\nOs objetivos s\u00e3o divididos em: \n\n\u2022 Objetivo Geral \n\n\u2022 Objetivos Espec\u00edficos \n\n\n\n \n\n  \n\n17 \n\n1.2.1 Objetivo Geral \n\nMostrar atrav\u00e9s da modulariza\u00e7\u00e3o e da componentiza\u00e7\u00e3o, uma maneira de \n\ndesenvolver sistemas reutiliz\u00e1veis e otimiz\u00e1veis que permitam a redu\u00e7\u00e3o de custos de \n\nprodu\u00e7\u00e3o e manuten\u00e7\u00e3o. \n\n1.2.2 Objetivos Espec\u00edficos \n\n Os objetivos espec\u00edficos englobam:   \n\n\u2022 Aprofundar os conhecimentos de Engenharia de Software, \n\nprincipalmente na \u00e1rea de arquitetura de software. \n\n\u2022 Conhecer as t\u00e9cnicas de Modulariza\u00e7\u00e3o, Componentiza\u00e7\u00e3o e \n\nFramework como parte da arquitetura de software.   \n\n\u2022 Compreender as t\u00e9cnicas de arquitetura, an\u00e1lise e projeto de software \n\nno processo de desenvolvimento de sistemas que venham a trazer uma \n\nmaior reusabilidade e manutenibilidade de c\u00f3digo. \n\n\u2022 Construir um sistema que demonstre a Modulariza\u00e7\u00e3o como parte do \n\nprocesso de desenvolvimento. \n\n\u2022 Desenvolver um componente que se aproxime de um framework para \n\nser utilizado pelo sistema.  \n\n\u2022 Analisar as vantagens e desvantagens de utilizar a Modulariza\u00e7\u00e3o no \n\ndesenvolvimento de software. \n\n\n\n \n\n  \n\n18 \n\n\u2022 Analisar as vantagens e desvantagens de utilizar um componente dentro \n\nde sistemas de software.  \n\n\u2022 Aplicar as t\u00e9cnicas da computa\u00e7\u00e3o para definir a modelagem e \n\ndesenvolvimento do sistema e do componente. \n\n1.3 Justificativa para o desenvolvimento do projeto \n\nCom o crescimento gradativo da complexidade dos sistemas de software, houve a \n\nnecessidade de utilizar meios que viessem a reduzir os custos e facilitar o desenvolvimento e a \n\nmanuten\u00e7\u00e3o dos sistemas. Al\u00e9m disso, buscou-se tamb\u00e9m melhorar a qualidade do produto, \n\nassim como redu\u00e7\u00e3o de defeitos dos softwares oferecidos. \n\n Segundo Sommerville (2003), com a modulariza\u00e7\u00e3o fica mais f\u00e1cil lidar com a \n\ncomplexidade, remover as redund\u00e2ncias, otimizar as intera\u00e7\u00f5es e simplificar as interfaces. A \n\norganiza\u00e7\u00e3o do ambiente de trabalho \u00e9 outro fator importante para que o desenvolvimento de \n\nsoftware ocorra com o m\u00ednimo de perdas, o que significa que n\u00e3o poder\u00e3o ocorrer falhas \n\ndurante o particionamento do programa. \n\n Al\u00e9m disso, a modulariza\u00e7\u00e3o abre espa\u00e7o para que v\u00e1rias pessoas possam \n\ntrabalhar, ao mesmo tempo, em diferentes partes do sistema, visando sempre resolver o \n\nproblema como um todo. Isso possibilita que a implanta\u00e7\u00e3o e entrega do produto tenham os \n\nprazos reduzidos.  \n\n\n\n \n\n  \n\n19 \n\n1.4 Proposta de Solu\u00e7\u00e3o \n\nA proposta de solu\u00e7\u00e3o abrange uma pesquisa bibliogr\u00e1fica que \u00e9 utilizada para \n\ncoletar crit\u00e9rios. Esses crit\u00e9rios s\u00e3o usados como base para a adapta\u00e7\u00e3o de um processo de \n\ndesenvolvimento que tem seu foco na reutiliza\u00e7\u00e3o de c\u00f3digo. \n\nDurante o processo de desenvolvimento trabalhar-se-\u00e1 uma arquitetura que d\u00ea \n\nsuporte a modulariza\u00e7\u00e3o, assim como a componentiza\u00e7\u00e3o. Com isso, as atividades de an\u00e1lise, \n\nprojeto e implementa\u00e7\u00e3o ir\u00e3o objetivar a organiza\u00e7\u00e3o para o futuro.  \n\nNo sistema desenvolvido nesse processo existe uma funcionalidade espec\u00edfica de \n\npesquisa. Essa funcionalidade \u00e9 transformada em componente e o mesmo usado pelo sistema \n\npara realizar as pesquisas.  \n\nPara demonstrar as vantagens e desvantagens de utilizar componentes em um \n\nsistema de software \u00e9 realizada a compara\u00e7\u00e3o entre o sistema com pesquisas implementadas \n\ninternamente e o sistema utilizando o componente para executar essa funcionalidade. A partir \n\ndisso \u00e9 proposto uma recomenda\u00e7\u00e3o de uso. A Figura 1 demonstra a proposta de solu\u00e7\u00e3o: \n\n\n\n \n\n  \n\n20 \n\n \nFigura 1. Proposta de Solu\u00e7\u00e3o \nFonte: Adaptado de Bezerra (2002).  \n\nA proposta de solu\u00e7\u00e3o possui um conjunto de elementos que s\u00e3o fundamentais \n\npara o desenvolvimento de um produto que visa a reutiliza\u00e7\u00e3o e os mesmos s\u00e3o descritos no \n\nQuadro 1: \n\n  \n\n\n\n \n\n  \n\n21 \n\n   Quadro 1. Descri\u00e7\u00e3o dos Elementos da Proposta de Solu\u00e7\u00e3o \nRevis\u00e3o \nbibliogr\u00e1fica \n\nConjunto de informa\u00e7\u00f5es pesquisadas para desenvolver a monografia \ne atingir os objetivos propostos.  \n\nAnalista Especialista que trabalha no processo de desenvolvimento de \nsoftware, definindo a arquitetura e desenvolvendo o sistema.   \n\nProcesso de \ndesenvolvimento de \nsoftware \n\nProcesso de desenvolvimento que ser\u00e1 adaptado para projetar um \nsistema que permita a reutiliza\u00e7\u00e3o de c\u00f3digo. \n\nAn\u00e1lise  Parte do desenvolvimento de software que busca analisar os \nrequisitos do sistema. \n\nProjeto Parte do desenvolvimento de software que busca projetar, definindo \nos diagramas e a arquitetura do sistema.  \n\nImplementa\u00e7\u00e3o  Parte do desenvolvimento de software que realiza a codifica\u00e7\u00e3o do \nsistema, levando em considera\u00e7\u00e3o a an\u00e1lise dos requisitos e o projeto. \n\nReposit\u00f3rio Base de dados, no qual ser\u00e1 armazenado todo o c\u00f3digo considerado \nreutiliz\u00e1vel, isto \u00e9, componentes, m\u00f3dulos, bibliotecas, frameworks, \netc. \n\n1.5 Delimita\u00e7\u00e3o \n\n\u2022 Ser\u00e3o utilizados padr\u00f5es de arquiteturas de software que possibilitam a reutiliza\u00e7\u00e3o \n\nde c\u00f3digo e o uso da modulariza\u00e7\u00e3o. \n\n\u2022 Os exemplos utilizados ser\u00e3o somente exibidos na linguagem de programa\u00e7\u00e3o \n\nJava. \n\n\u2022 N\u00e3o \u00e9 definida uma metodologia para o desenvolvimento do componente. \n\n\u2022 Utilizar\u00e1 a metodologia de desenvolvimento IBM Rational Unified Process (RUP) \n\ncustomizado ao problema em quest\u00e3o. \n\n\u2022 As instala\u00e7\u00f5es ou configura\u00e7\u00f5es do software utilizadas para a constru\u00e7\u00e3o do \n\nsistema n\u00e3o ser\u00e3o discutidas. \n\n\u2022 O sistema n\u00e3o ir\u00e1 se preocupar com a seguran\u00e7a de acesso, portanto, n\u00e3o ser\u00e1 \n\nimplementado cadastro de usu\u00e1rio e senha.  \n\n\n\n \n\n  \n\n22 \n\n1.6 Metodologia Cient\u00edfica Aplicada ao Trabalho \n\nA metodologia utilizada consiste em tra\u00e7ar um caminho que conduza \u00e0 pesquisa e \n\n\u00e0 investiga\u00e7\u00e3o. Para Silva (2005), as classifica\u00e7\u00f5es de pesquisa do ponto de vista de sua \n\nnatureza, da forma de abordagem do problema, dos seus objetivos e dos procedimentos \n\nt\u00e9cnicos conceituam a metodologia cient\u00edfica utilizada em trabalhos. \n\nPara o desenvolvimento deste trabalho foi adotado, considerando o ponto de vista \n\nde sua natureza, uma metodologia de pesquisa que segundo Silva (2005, p.20) \u201cobjetiva gerar \n\nconhecimentos para aplica\u00e7\u00e3o pr\u00e1tica e dirigidos \u00e0 solu\u00e7\u00e3o de problemas espec\u00edficos\u201d. \n\nNa abordagem do problema a pesquisa \u00e9 qualitativa, isto \u00e9, o n\u00edvel de informa\u00e7\u00e3o \n\ncoletada \u00e9 fundamental e n\u00e3o sua estat\u00edstica. Como ressalta Silva (2005, p.20) \u201c[...]a \n\ninterpreta\u00e7\u00e3o dos fen\u00f4menos e a atribui\u00e7\u00e3o de seus significados s\u00e3o b\u00e1sicos no processo de \n\npesquisa qualitativa. N\u00e3o requer o uso de m\u00e9todos e t\u00e9cnicas estat\u00edsticas[...].\u201d  \n\nEm rela\u00e7\u00e3o aos objetivos a pesquisa \u00e9 explorat\u00f3ria, pois busca tornar o problema \n\nmais expl\u00edcito. Para isso, segundo Gil (apud SILVA, 2005, p.21) \u00e9 necess\u00e1rio ter \n\n\u201c[...]levantamento bibliogr\u00e1fico; entrevistas com pessoas que tiveram experi\u00eancias pr\u00e1ticas \n\ncom o problema pesquisado; an\u00e1lise de exemplos que estimulam a compreens\u00e3o\u201d. \n\nPor fim, quanto aos procedimentos t\u00e9cnicos a pesquisa \u00e9 bibliogr\u00e1fica, isto \u00e9, \n\nsegundo Gil (apud SILVA, 2005, p.21) \u201cquando elaborada a partir de material j\u00e1 publicado, \n\nconstitu\u00eddo principalmente de livros, artigos de peri\u00f3dicos e atualmente com material \n\ndisponibilizado na Internet\u201d. \n\n\n\n \n\n  \n\n23 \n\n1.7 Estrutura do Trabalho \n\nEsta monografia est\u00e1 organizada em seis cap\u00edtulos. O presente cap\u00edtulo apresentou \n\no tema descrevendo o prop\u00f3sito da monografia e o problema de pesquisa, assim como os \n\nobjetivos, a justificativa, a proposta de solu\u00e7\u00e3o juntamente com suas delimita\u00e7\u00f5es e a \n\nmetodologia utilizada.  \n\nNo segundo cap\u00edtulo encontra-se a revis\u00e3o bibliogr\u00e1fica, que fundamenta as \u00e1reas \n\nde conhecimento envolvidas no trabalho: engenharia de software, arquitetura de software e o \n\ndesenvolvimento de sistemas. \n\nNo terceiro cap\u00edtulo \u00e9 especificada a modelagem do sistema desenvolvido, que \n\nutiliza a metodologia RUP. Essa metodologia permite organizar o processo de \n\ndesenvolvimento de software e separar por fases distintas a evolu\u00e7\u00e3o do sistema objeto deste \n\ntrabalho. Al\u00e9m disso, \u00e9 descrito o ambiente tecnol\u00f3gico utilizado no trabalho.  \n\nNo quarto cap\u00edtulo, \u00e9 descrito todo o processo de an\u00e1lise e desenvolvimento do \n\ncomponente com base na modelagem realizada anteriormente, assim como a demonstra\u00e7\u00e3o de \n\numa outra arquitetura para o sistema, com a utiliza\u00e7\u00e3o de um componente.  \n\nNo quinto cap\u00edtulo, \u00e9 feita a valida\u00e7\u00e3o do componente e sua arquitetura, \n\napontando as vantagens e desvantagens de utiliz\u00e1-lo em um sistema, al\u00e9m de uma \n\nrecomenda\u00e7\u00e3o de uso. \n\nFinalmente, o sexto cap\u00edtulo descreve a conclus\u00e3o desta monografia, no qual est\u00e3o \n\ndescritos os resultados e as considera\u00e7\u00f5es finais.            \n\n\n\n \n\n  \n\n24 \n\n2 REVIS\u00c3O BIBLIOGR\u00c1FICA \n\nA revis\u00e3o bibliogr\u00e1fica aborda assuntos que s\u00e3o fundamentais para o \n\ndesenvolvimento da monografia. Inicialmente \u00e9 feito um estudo de como a engenharia de \n\nsoftware lida com a modulariza\u00e7\u00e3o e reutiliza\u00e7\u00e3o de c\u00f3digo, al\u00e9m de demonstrar a \n\nimport\u00e2ncia da engenharia de requisitos no desenvolvimento de sistemas modulares. Na \n\nseq\u00fc\u00eancia s\u00e3o descritas a arquitetura de software e as suas t\u00e9cnicas, assim como conceitos de \n\norienta\u00e7\u00e3o a objeto e a import\u00e2ncia da an\u00e1lise e projeto.  \n\nAs \u00e1reas estudadas nessa revis\u00e3o s\u00e3o todas direcionadas para a produ\u00e7\u00e3o de \n\nsoftware que proporcione redu\u00e7\u00e3o nos custos de desenvolvimento, manuten\u00e7\u00e3o e tamb\u00e9m nos \n\nprazos de entrega do produto. \n\n2.1 Engenharia de Software \n\nCaracterizada por propor uma metodologia no desenvolvimento de software, a \n\nengenharia de software foi criada com base em conceitos de engenharia. O objetivo era \n\n\n\n \n\n  \n\n25 \n\nmelhorar as t\u00e9cnicas que se utilizava para desenvolver sistemas computacionais \n\n(PRESSMAN, 1995).  \n\nPara Peters (2001), a grande vantagem de se iniciar projetos utilizando conceitos \n\nde engenharia de software s\u00e3o a simplifica\u00e7\u00e3o e agilidade, devido a enorme disponibilidade de \n\nferramentas e bibliotecas \u00fateis para a cria\u00e7\u00e3o de software. No lugar de construir novos \n\nsistemas de software, agora \u00e9 poss\u00edvel comprar partes deles, ou adquirir pacotes completos, \n\nmas \u00e9 importante saber qual software j\u00e1 est\u00e1 dispon\u00edvel e ao mesmo tempo criar e integrar o \n\nnovo sistema. O reuso de software \u00e9 atraente por causa da possibilidade de economizar tempo \n\nna resolu\u00e7\u00e3o de um problema. A capacidade de reutiliza\u00e7\u00e3o de software \u00e9 medida pela \n\nfacilidade com que conceitos e objetos anteriormente adquiridos podem ser utilizados em \n\nnovos contextos. Basicamente, a reutiliza\u00e7\u00e3o \u00e9 uma combina\u00e7\u00e3o entre os componentes novos \n\ne os antigos. Assim, sempre que essa combina\u00e7\u00e3o for parcial ou bem-sucedida, o reuso \u00e9 \n\nposs\u00edvel. Al\u00e9m disso, existe a vantagem de reduzir os custos do desenvolvimento.  \n\nA engenharia de software \u00e9 uma disciplina que se ocupa dos aspectos para a \n\nprodu\u00e7\u00e3o do software. Esses aspectos incluem os processos t\u00e9cnicos de desenvolvimento de \n\nsoftware, o gerenciamento de projetos de software e o desenvolvimento de ferramentas, \n\nm\u00e9todos e procedimentos que d\u00e3o apoio \u00e0 produ\u00e7\u00e3o de software. As ferramentas, m\u00e9todos e \n\nprocedimentos s\u00e3o considerados, por alguns autores, fundamentais para a constru\u00e7\u00e3o de \n\nsoftware com alta qualidade. Nesse sentido, as pessoas que trabalham nessa \u00e1rea sempre \n\nprocuram encontrar solu\u00e7\u00f5es para os problemas, no entanto reconhecem que precisam \n\ntrabalhar de acordo com as restri\u00e7\u00f5es organizacionais e financeiras, e assim estabelecem \n\nsolu\u00e7\u00f5es que estejam dentro dessas restri\u00e7\u00f5es (SOMMERVILLE, 2003; PRESSMAN, 1995). \n\nUm m\u00e9todo de engenharia de software, segundo Sommerville (2003), \u00e9 uma \n\nabordagem estruturada para o desenvolvimento de sistemas, com o objetivo de facilitar a \n\nprodu\u00e7\u00e3o de software de alta qualidade, apresentando uma boa rela\u00e7\u00e3o custo-benef\u00edcio. \n\n\n\n \n\n  \n\n26 \n\nSeguindo a mesma id\u00e9ia, Pressman (1995) afirma que os m\u00e9todos de engenharia de software \n\nproporcionam os detalhes de \u201ccomo fazer\u201d para construir o software.  \n\nOs m\u00e9todos buscam identificar componentes funcionais b\u00e1sicos de um sistema, \n\nal\u00e9m de envolver um amplo conjunto de tarefas que incluem o planejamento e estimativa do \n\nprojeto, an\u00e1lise de requisitos, projeto de estrutura de dados, arquitetura do sistema, \n\ncodifica\u00e7\u00e3o e teste. Esses m\u00e9todos geralmente introduzem uma nota\u00e7\u00e3o gr\u00e1fica para \n\ndemonstrar modelos que ser\u00e3o utilizados na especifica\u00e7\u00e3o do sistema (SOMMERVILLE, \n\n2003; PRESSMAN, 1995).  \n\nNesse contexto, percebe-se que \u00e0 medida que a capacidade de produzir software \n\naumenta, cresce tamb\u00e9m sua complexidade. A complexidade dos sistemas \u00e9 um desafio para \n\nos projetistas, al\u00e9m disso, o sistema tem de atender todos os requisitos, para que funcione \n\nconforme o desejo do cliente e a rela\u00e7\u00e3o custo-benef\u00edcio seja satisfat\u00f3ria. Sendo assim, a \n\nengenharia de software utiliza a modulariza\u00e7\u00e3o, que \u00e9 uma t\u00e9cnica da arquitetura de software, \n\ncomo um m\u00e9todo de aux\u00edlio para lidar com os sistemas complexos, tornando-os \n\nintelectualmente administr\u00e1veis (PRESSMAN, 1995).  \n\nAl\u00e9m da complexidade, outro problema bastante comum nos dias de hoje \u00e9 o \n\ntamanho dos sistemas. Para Sommerville (2003), quando nos deparamos com sistemas muito \n\ngrandes a primeira atitude \u00e9 identificar partes distintas do sistema e decomp\u00f4-las em \n\nsubsistemas e/ou m\u00f3dulos. No entanto, a flexibilidade, a complexidade e o reuso em um \n\nsistema ainda s\u00e3o as principais raz\u00f5es para subdividir os sistemas. Com t\u00e9cnicas de \n\ndecomposi\u00e7\u00e3o de software os sistemas se tornam confi\u00e1veis, f\u00e1ceis de manter, permitindo a \n\nreusabilidade e a qualidade do software. Dentro desse contexto, Pressman (1995) destaca que \n\nos seres humanos desenvolvem uma abordagem natural para resolver seus problemas: se o \n\nproblema \u00e9 muito complicado, tendemos a subdividi-lo. Resolvemos cada um deles \n\nindividualmente e esperamos que suas solu\u00e7\u00f5es possam ser combinadas para formar um todo.  \n\n\n\n \n\n  \n\n27 \n\n2.1.1 Engenharia de Requisitos \n\nEngenharia de Requisitos \u00e9 a disciplina que procura sistematizar o processo de \n\ndefini\u00e7\u00e3o de requisitos para que o problema seja entendido de forma correta antes do \n\ncomprometimento de uma solu\u00e7\u00e3o. O grau de compreensibilidade, precis\u00e3o e rigor da \n\ndescri\u00e7\u00e3o do documento de requisitos de software tende a ser diretamente proporcional ao \n\ngrau de qualidade do produto. Al\u00e9m disso, para que a defini\u00e7\u00e3o de requisitos seja a mais \n\neficaz poss\u00edvel, cabe aos engenheiros de software entender o ambiente no qual o software ir\u00e1 \n\nfuncionar e escolher os modelos que melhor se encaixem no ambiente. (SOMMERVILLE, \n\n2003; LEITE, 1994; PETERS, 2001).  \n\nPara o processo de engenharia de requisitos, Sommerville (2003) aponta as \n\nseguintes atividades: o estudo da viabilidade; a obten\u00e7\u00e3o e an\u00e1lise de requisitos; a \n\nespecifica\u00e7\u00e3o de requisitos e sua documenta\u00e7\u00e3o. \n\nO estudo da viabilidade \u00e9 o est\u00e1gio inicial do processo de engenharia de requisitos \n\nque envolve uma descri\u00e7\u00e3o geral do sistema e de como ser\u00e1 utilizado. Esse estudo resultar\u00e1 \n\nem um relat\u00f3rio que recomenda se vale ou n\u00e3o a pena realizar o processo de engenharia de \n\nrequisitos. Al\u00e9m disso, poder\u00e1 propor mudan\u00e7as no enfoque, no or\u00e7amento e no cronograma, \n\ne tamb\u00e9m sugerir a inclus\u00e3o de outros requisitos. \u00c9 preciso dar um foco no objetivo do \n\nsistema, avaliando as informa\u00e7\u00f5es coletadas e verificando se ser\u00e1 poss\u00edvel chegar \u00e0 esse \n\nobjetivo (SOMMERVILLE, 2003; PRESSMAN, 1995; DENNIS, 2005). \n\nNa seq\u00fc\u00eancia \u00e9 realizado o levantamento e a an\u00e1lise de requisitos. Esse est\u00e1gio \n\npode envolver muitas pessoas em uma organiza\u00e7\u00e3o como: desenvolvedores, analistas, clientes \n\ne usu\u00e1rios finais, os quais ter\u00e3o alguma influ\u00eancia direta ou indireta sobre os requisitos do \n\nsistema. Com o levantamento e an\u00e1lise dos requisitos \u00e9 poss\u00edvel obter mais informa\u00e7\u00f5es sobre \n\n\n\n \n\n  \n\n28 \n\no dom\u00ednio da aplica\u00e7\u00e3o, que servi\u00e7os o sistema deve oferecer, desempenho exigido e se existe \n\nrestri\u00e7\u00f5es (PRESSMAN, 1995). \n\nO documento de requisitos, gerado do levantamento e an\u00e1lise, serve como meio \n\nde comunica\u00e7\u00e3o entre os diversos membros do desenvolvimento. Com o aumento cada vez \n\nmaior na complexidade de sistemas e o desejo de aumentar a reusabilidade, tornam essa \n\ndocumenta\u00e7\u00e3o muito importante. Quanto mais precisos, corretos, completos e consistentes os \n\ndados desses documentos maiores as chances de qualidade e reuso em futuras evolu\u00e7\u00f5es ou \n\npr\u00f3ximos desenvolvimentos (STAA, 2000; PRESSMAN, 1995). \n\nParalelamente \u00e0 essas atividades, \u00e9 necess\u00e1rio desenvolver o gerenciamento de \n\nrequisitos. Essa atividade consiste em administrar as inevit\u00e1veis mudan\u00e7as dos requisitos \n\npropostos que surgem, principalmente, quando s\u00e3o alteradas as prioridades do neg\u00f3cio, \n\nquando se identificam erros ou omiss\u00f5es nos requisitos ou quando novos requisitos s\u00e3o \n\ndefinidos. Gerenciamento de requisitos \u00e9 executado por meio da implementa\u00e7\u00e3o de \n\nrastreabilidade. Gerenciamento e rastreamento de requisitos s\u00e3o reconhecidos como \n\nimportantes pr\u00e9-requisitos para desenvolver software de alta qualidade. \n\nQuando s\u00e3o propostas modifica\u00e7\u00f5es, \u00e9 preciso analisar e verificar o impacto \n\ndessas mudan\u00e7as sobre outros requisitos. O gerenciamento de requisitos pode ter o apoio de \n\nferramentas CASE, ou ainda recursos dispon\u00edveis em processadores de texto, planilhas de \n\nc\u00e1lculo, etc. \u00c9 preciso gerenciar tamb\u00e9m as mudan\u00e7as de requisitos, pois assim todas as \n\npropostas ser\u00e3o tratadas de maneira consistente e as mudan\u00e7as no documento de requisitos \n\nser\u00e3o controladas (SOMMERVILLE, 2003). \n\n\n\n \n\n  \n\n29 \n\n2.1.2 Requisitos de Software \n\nOs requisitos s\u00e3o as descri\u00e7\u00f5es de fun\u00e7\u00f5es e de restri\u00e7\u00f5es de um software. O \n\ntermo \u201crequisito\u201d, como argumenta Sommerville (2003), n\u00e3o \u00e9 utilizado sempre com a mesma \n\nvis\u00e3o pela ind\u00fastria de software. Em alguns casos \u00e9 visto como declara\u00e7\u00f5es abstratas de alto \n\nn\u00edvel, com linguagem natural, para uma fun\u00e7\u00e3o que o sistema ir\u00e1 oferecer ou uma restri\u00e7\u00e3o \n\nque ir\u00e1 ocorrer. Por outro ponto de vista, \u00e9 uma defini\u00e7\u00e3o detalhada de uma fun\u00e7\u00e3o \u2013 suas \n\nentradas, sa\u00eddas e o pr\u00f3prio c\u00f3digo - que o sistema dever\u00e1 executar ou do servi\u00e7o a ser \n\nprestado (SOMMERVILLE, 2003; STAA, 2000). \n\n\u00c9 importante fazer a separa\u00e7\u00e3o entre esses dois n\u00edveis de descri\u00e7\u00e3o, pois alguns \n\ndos problemas que ocorrem durante o processo de engenharia de requisitos, surgem da falta \n\nn\u00edtida da separa\u00e7\u00e3o desses n\u00edveis. \n\nRoss et al. (apud STAA, 2000, p. 338) apresenta essa separa\u00e7\u00e3o \n\n\u201cRequisitos n\u00e3o se referem apenas \u00e0 funcionalidade desejada para um software \n(requisitos funcionais), mas tamb\u00e9m referem-se \u00e0s quest\u00f5es n\u00e3o funcionais (por \nexemplo, desempenho, facilidade de uso), requisitos inversos (por exemplo, o \nm\u00f3dulo jamais suspender\u00e1 execu\u00e7\u00e3o) e restri\u00e7\u00f5es (por exemplo, o m\u00f3dulo ser\u00e1 \nredigido em Java)\u201d. \n\nSommerville (2003, p.83, grifo nosso) define os requisitos funcionais e n\u00e3o \n\nfuncionais da seguinte maneira: \n\n\u201c 1. Requisitos Funcionais: S\u00e3o declara\u00e7\u00f5es de fun\u00e7\u00f5es que o sistema deve \nfornecer, como o sistema deve reagir a entradas espec\u00edficas e como deve se \ncomportar em determinadas situa\u00e7\u00f5es. Em alguns casos, os requisitos funcionais \npodem tamb\u00e9m explicitamente declarar o que o sistema n\u00e3o deve fazer. \n     2. Requisitos N\u00e3o Funcionais: S\u00e3o restri\u00e7\u00f5es sobre os servi\u00e7os ou as fun\u00e7\u00f5es \noferecidos pelo sistema. Entre eles destacam-se restri\u00e7\u00f5es de tempo, restri\u00e7\u00f5es sobre \no processo de desenvolvimento, padr\u00f5es, entre outros \u201d. \n\nOs requisitos funcionais podem ser definidos como as fun\u00e7\u00f5es ou atividades que o \n\nsistema realiza. Devem ser definidos claramente e relatados explicitamente. Podem ser \n\nelaborados a partir do relato das necessidades do cliente e/ou usu\u00e1rio, onde uma equipe de \n\n\n\n \n\n  \n\n30 \n\nprojeto pode especificar efetivamente um sistema de informa\u00e7\u00e3o, suas fun\u00e7\u00f5es, desempenho, \n\ninterfaces, restri\u00e7\u00f5es, etc., conforme as fases e subfases de uma metodologia de \n\ndesenvolvimento de software. Eles s\u00e3o fundamentais para elaborar um sistema que atenda e \n\nsatisfa\u00e7a plenamente os anseios do cliente e da a equipe desenvolvedora do projeto.  \n\nQuando os requisitos s\u00e3o bem definidos e formalmente relatados evitam a alta \n\nmanuten\u00e7\u00e3o de sistemas. Eles devem ser elencados por todos os envolvidos e principalmente \n\ncom a concord\u00e2ncia do cliente e/ou usu\u00e1rio. \n\nDurante as fases de desenvolvimento, se ocorrerem problemas em fun\u00e7\u00e3o de uma \n\nm\u00e1 defini\u00e7\u00e3o dos requisitos, esses devem ser corrigidos no respectivo documento, para uma \n\nadequada verifica\u00e7\u00e3o futura. \n\nOs requisitos n\u00e3o funcionais n\u00e3o s\u00e3o relacionados diretamente as fun\u00e7\u00f5es \n\nespec\u00edficas do sistema, mas relacionadas as propriedades que o sistema deve possuir, como \n\nconfiabilidade, precis\u00e3o, desempenho, seguran\u00e7a, exatid\u00e3o, etc. (SOMMERVILLE, 2003; \n\nSTAA, 2000). Muitos desses requisitos se referem ao sistema como um todo e n\u00e3o a partes \n\nindividuais. \n\nPor serem t\u00e3o abrangentes, muitas vezes, os requisitos n\u00e3o funcionais s\u00e3o mais \n\nimportantes que os requisitos funcionais individuais, pois se deixar de atender um requisito \n\nn\u00e3o funcional o sistema pode tornar-se in\u00fatil. \n\n\u201cOs requisitos n\u00e3o funcionais surgem conforme a necessidade dos usu\u00e1rios, em \nraz\u00e3o de restri\u00e7\u00f5es de or\u00e7amento, de pol\u00edticas organizacionais, pela necessidade de \ninteroperabilidade com outros sistemas de software ou hardware ou devido a fatores \nexternos, como por exemplo regulamento de seguran\u00e7a e legisla\u00e7\u00e3o sobre \nprivacidade\u201d (SOMMERVILLE, 2003, p.85). \n\nPelo fato de serem escritos refletindo os objetivos gerais do cliente, os requisitos \n\ns\u00e3o dif\u00edceis de ser verificados, gerando um problema comum para os desenvolvedores \u00e0 \n\nmedida que deixam o enfoque muito aberto \u00e0 interpreta\u00e7\u00e3o. \n\nPara que esses problemas n\u00e3o ocorram, \u00e9 preciso que os requisitos n\u00e3o funcionais \n\nfiquem expressos quantitativamente utilizando m\u00e9tricas, para serem mais verific\u00e1veis e, \n\n\n\n \n\n  \n\n31 \n\nassim, ser poss\u00edvel checar se o sistema atende ao objetivo exigido. No entanto, nem sempre \n\nessa especifica\u00e7\u00e3o quantitativa \u00e9 poss\u00edvel e f\u00e1cil de ser definida. \n\nOs requisitos funcionais e n\u00e3o funcionais devem ser diferenciados no documento \n\nque os descreve, para que n\u00e3o ocorram interpreta\u00e7\u00f5es erradas entre os interessados no \n\nprocesso de desenvolvimento. Por outro lado, se forem definidos separadamente ser\u00e1 dif\u00edcil \n\nrelacion\u00e1-los. Assim, o importante \u00e9 encontrar um equil\u00edbrio claro na defini\u00e7\u00e3o e \n\ndiferencia\u00e7\u00e3o dos requisitos.  \n\n2.2 Arquitetura de Software \n\nA arquitetura de software surgiu para auxiliar o processo de desenvolvimento e \n\ndemonstrar a estrutura global do sistema de software.  O crescimento em termos de tamanho e \n\ncomplexidade dos sistemas levou pesquisadores e profissionais de engenharia de software a \n\nintensificar os estudos a respeito do assunto. Uma evid\u00eancia \u00e9 a grande quantidade de \n\ntrabalhos, tais como linguagem de interface de m\u00f3dulos, arquiteturas espec\u00edficas de dom\u00ednio, \n\nlinguagens para a descri\u00e7\u00e3o de arquiteturas e padr\u00f5es de projeto. Considerada uma \u00e1rea \n\nrelativamente nova dentro da engenharia de software, a arquitetura de software n\u00e3o havia \n\nprovocado interesse dos pesquisadores at\u00e9 o final da d\u00e9cada de 1980, quando Mary Shaw \n\napontou a import\u00e2ncia e a necessidade de considerar o n\u00edvel organizacional ou arquitetural \n\ndos sistemas (MENDES, 2002). \n\nSegundo Shaw et al. (apud VAROTO, 2002, p. 16) \u201carquitetura de software \n\ndefine o que \u00e9 o sistema em termos de componentes computacionais e os relacionamentos \n\nentre estes componentes\u201d, por sua vez, Bass et al. (apud VAROTO, 2002, p. 16) afirma \n\n\n\n \n\n  \n\n32 \n\n \u201cArquitetura de software s\u00e3o as estruturas que incluem componentes, suas \npropriedades externas e os relacionamentos entre eles, constituindo uma abstra\u00e7\u00e3o \ndo sistema. Esta abstra\u00e7\u00e3o suprime detalhes de componentes que n\u00e3o afetam a forma \ncomo eles s\u00e3o usados ou como eles usam outros componentes, auxiliando o \ngerenciamento da complexidade\u201d, \n\n ou, ainda, para Jazayeri et al. (apud VAROTO, 2002, p. 16) \n\n \u201cA arquitetura de software \u00e9 colocada como uma ferramenta para lidar com a \ncomplexidade do software e enfatizam que arquitetura deve satisfazer os requisitos \nfuncionais e n\u00e3o funcionais do sistema, incrementando a defini\u00e7\u00e3o de que \narquitetura de software \u00e9 o conjunto de componentes e seus relacionamentos. \nPortanto, \u00e9 poss\u00edvel notar que a arquitetura de software \u00e9 mais do que a descri\u00e7\u00e3o \ndos componentes que a comp\u00f5em e do relacionamento entre eles. A arquitetura \u00e9 a \ninterface entre duas partes distintas: o problema de neg\u00f3cio e a solu\u00e7\u00e3o t\u00e9cnica\u201d. \n\nA partir das defini\u00e7\u00f5es acima citadas, percebe-se o qu\u00e3o importante e fundamental \n\n\u00e9 a arquitetura de software e o qu\u00e3o essencial \u00e9 o projeto arquitetural de um sistema dentro do \n\nprocesso de desenvolvimento. Al\u00e9m disso, Allen (2003, p. 62) menciona que \u201ca arquitetura de \n\nsoftware \u00e9 importante, mas precisa ser reconfigur\u00e1vel para responder aos ambientes e as \n\ndemandas em muta\u00e7\u00e3o\u201d. \n\nA arquitetura, considerada a estrutura geral de um sistema, pode conter \n\nsubsistemas que interfaceiam com outros subsistemas e deve estar em um alto n\u00edvel de \n\nabstra\u00e7\u00e3o para que o sistema possa ser visto como um todo.  A principal preocupa\u00e7\u00e3o durante \n\no processo de projeto de arquitetura, segundo Sommerville (2003, p.182) \u00e9 \u201c[...]estabelecer \n\num framework estrutural b\u00e1sico[...]\u201d que identifique os principais componentes do sistema e \n\nsuas comunica\u00e7\u00f5es (ALLEN, 2003). \n\nO processo de projeto de arquitetura \u00e9 visto de diversos modos por diferentes \n\nprojetistas e stakeholders (conhecedores e influenciadores do neg\u00f3cio). No entanto, o \n\nprocesso que ser\u00e1 aproveitado depender\u00e1 da aplica\u00e7\u00e3o do conhecimento, da ast\u00facia e da \n\npercep\u00e7\u00e3o clara e direta do arquiteto do sistema. Entretanto, existem atividades comuns a \n\ntodos os processos de projeto de arquitetura de software, como a estrutura\u00e7\u00e3o do sistema, a \n\nmodelagem de controle e a decomposi\u00e7\u00e3o modular. Assim, antes de termos um projeto de \n\narquitetura formalizado, \u00e9 necess\u00e1rio elicitar os requisitos arquiteturais (MENDES, 2002).  \n\n\n\n \n\n  \n\n33 \n\nDurante o est\u00e1gio de elicita\u00e7\u00e3o de requisitos, o arquiteto ou projetista faz uso de \n\nsua experi\u00eancia para buscar identificar as peculiaridades do sistema a ser desenvolvido, al\u00e9m \n\nde utilizar as informa\u00e7\u00f5es de dom\u00ednio e estilos de arquiteturas diferentes. Contudo,  temos a  \n\npossibilidade de criar novos cen\u00e1rios, visando tanto a elicita\u00e7\u00e3o quanto a an\u00e1lise de requisitos, \n\npara ent\u00e3o iniciar o projeto de arquitetura de software como mostrado na Figura 2 \n\n(SOMMERVILLE, 2003; MENDES, 2002). \n\n \nFigura 2. Elicita\u00e7\u00e3o de Requisitos Arquiteturais \n\n          Fonte: Mendes, 2002, p. 37. \n\nProjetar e documentar uma arquitetura de software para Bass et al (apud \n\nSOMMERVILLE, 2003, p. 182, grifo nosso) tem suas vantagens: \n\n\u201c 1. Comunica\u00e7\u00e3o com os stakeholders: a arquitetura \u00e9 uma apresenta\u00e7\u00e3o de alto \nn\u00edvel do sistema, que pode ser utilizada como um ponto de discuss\u00e3o para uma gama \nde diferentes stakeholders. \n   2. An\u00e1lise de sistemas: Tornar expl\u00edcita a arquitetura de sistemas em um est\u00e1gio \ninicial do desenvolvimento do sistema significa que alguma an\u00e1lise pode ser \nrealizada. As decis\u00f5es de projeto de arquitetura t\u00eam um profundo efeito sobre se o \nsistema pode ou n\u00e3o cumprir requisitos importantes, como desempenho, \nconfiabilidade e facilidade de manuten\u00e7\u00e3o. \n   3. Reutiliza\u00e7\u00e3o em larga escala: a arquitetura de sistemas \u00e9 uma descri\u00e7\u00e3o \ncompacta e administr\u00e1vel de como um sistema \u00e9 organizado e de como os \ncomponentes operam entre si. A arquitetura pode ser transferida por meio de \nsistemas com requisitos similares e, dessa maneira, pode fornecer apoio ao reuso de \nsoftware em grande escala\u201d. \n\nAl\u00e9m disso, \u00e9 importante salientar que para obter a arquitetura adequada julga-se \n\nnecess\u00e1rio compreender os requisitos arquiteturais, que incluem os atributos do projeto e os \n\nrequisitos n\u00e3o-funcionais. Os atributos do projeto podem ser vistos como princ\u00edpios que \n\n\n\n \n\n  \n\n34 \n\nnorteiam o processo de desenvolvimento de um software. Esses atributos s\u00e3o respons\u00e1veis por \n\nseparar o sistema em v\u00e1rias partes, al\u00e9m de permitir que o projetista identifique diferentes \n\naspectos do problema sem levar em considera\u00e7\u00e3o seus detalhes. Os requisitos n\u00e3o-funcionais \n\ndescrevem o que o software n\u00e3o far\u00e1, mas como o far\u00e1. Isso significa que os requisitos n\u00e3o-\n\nfuncionais abordam aspectos de qualidade importantes em um sistema de software que, se n\u00e3o \n\nlevados em considera\u00e7\u00e3o, podem tornar o sistema inconsistente e de baixa qualidade. \n\nExemplos desses requisitos s\u00e3o: o desempenho, a portabilidade, a manutenibilidade e a \n\nescalabilidade (MENDES, 2002). \n\n2.2.1 Modulariza\u00e7\u00e3o \n\nA modulariza\u00e7\u00e3o \u00e9 considerada um atributo de projeto no processo de \n\ndesenvolvimento de software. Caracterizada por decompor um sistema em partes, a \n\nmodulariza\u00e7\u00e3o \u00e9 indispens\u00e1vel quando o assunto \u00e9 sistema complexo e/ou grande. A \n\ncapacidade de decompor um sistema baseia-se na id\u00e9ia de dividir o problema inicial em um \n\nconjunto de subproblemas e reaplicar tal procedimento em cada subproblema recursivamente. \n\nAs partes resultantes da decomposi\u00e7\u00e3o s\u00e3o chamados de m\u00f3dulos (MENDES, 2002). \n\nUm m\u00f3dulo normalmente n\u00e3o \u00e9 considerado um sistema independente. Segundo \n\nPeters (2001), o m\u00f3dulo \u00e9 uma parte de programa logicamente separada. Cada m\u00f3dulo oculta \n\ndecis\u00f5es de projeto a respeito das caracter\u00edsticas e conte\u00fados das estruturas de dados e exporta \n\nas opera\u00e7\u00f5es de que o usu\u00e1rio necessita para utilizar o programa corretamente. Tudo isso leva \n\na simplifica\u00e7\u00e3o do projeto de software. \n\n\n\n \n\n  \n\n35 \n\nA modulariza\u00e7\u00e3o \u00e9 o processo de reorganizar, de modo que as partes relacionadas \n\nsejam coletadas e consideradas um \u00fanico m\u00f3dulo. \u00c9 realizada manualmente, com a inspe\u00e7\u00e3o e \n\na edi\u00e7\u00e3o do c\u00f3digo. Para modularizar \u00e9 preciso identificar as rela\u00e7\u00f5es entre componentes e \n\nexaminar o que eles fazem. Feito isso, fica mais f\u00e1cil remover as redund\u00e2ncias, otimizar suas \n\nintera\u00e7\u00f5es e simplificar suas interfaces. \n\nSegundo Pressman (1995), um software monol\u00edtico ou um grande programa \n\ncomposto de um \u00fanico m\u00f3dulo, \u00e9 dif\u00edcil de ser entendido pelo leitor. Assim, \u00e9 mais f\u00e1cil de \n\nresolver um problema complexo quando ele \u00e9 divido em partes administr\u00e1veis, mas \u00e9 \n\nnecess\u00e1rio saber medir as conseq\u00fc\u00eancias, e ponderar as divis\u00f5es. \u00c0 medida que o n\u00famero de \n\nm\u00f3dulos cresce, o esfor\u00e7o (custo) associado \u00e0 cria\u00e7\u00e3o de interfaces tamb\u00e9m cresce. Devemos \n\nmodularizar, mas com aten\u00e7\u00e3o. \n\nOs m\u00f3dulos devem ser especificados e projetados de tal forma que suas \n\ninforma\u00e7\u00f5es sejam inacess\u00edveis a outros m\u00f3dulos que n\u00e3o necessitem dela. Essa oculta\u00e7\u00e3o \n\ndefine e refor\u00e7a as restri\u00e7\u00f5es de acesso, trazendo benef\u00edcios quando modifica\u00e7\u00f5es s\u00e3o \n\nexigidas. Isso evita que essas modifica\u00e7\u00f5es se propaguem a outros locais do sistema \n\n(PRESSMAN, 1995; DENNIS, 2005; STAA, 2000). \n\nA modularidade, tanto de programas quanto de dados, possibilita que o projetista \n\nsimplifique e reutilize os componentes de software. A oculta\u00e7\u00e3o de informa\u00e7\u00f5es e a \n\nindepend\u00eancia funcional oferecem os caminhos para conseguir efetiva modularidade. O \n\nagrupamento, que \u00e9 facilitado pela modulariza\u00e7\u00e3o, produz exibi\u00e7\u00f5es esquem\u00e1ticas do software \n\ne permite uma maior compreens\u00e3o do sistema, pois faz a separa\u00e7\u00e3o da vis\u00e3o de alto n\u00edvel e \n\ndos detalhes ocultos dos m\u00f3dulos. \n\nUm projeto modular reduz a complexidade, facilita a mudan\u00e7a e resulta em uma \n\nimplementa\u00e7\u00e3o mais f\u00e1cil ao estimular o desenvolvimento paralelo de partes do sistema. \n\n\n\n \n\n  \n\n36 \n\nM\u00f3dulos independentes s\u00e3o mais f\u00e1ceis de desenvolver, manter e testar. Desta forma, os \n\nefeitos secund\u00e1rios provocados por modifica\u00e7\u00f5es s\u00e3o limitados.  \n\nA independ\u00eancia dos m\u00f3dulos \u00e9 medida usando-se dois crit\u00e9rios: coes\u00e3o e \n\nacoplamento. A coes\u00e3o \u00e9 uma medida da for\u00e7a funcional e depende do inter-relacionamento \n\nentre os elementos que constituem um m\u00f3dulo. Quanto mais forte for este inter-\n\nrelacionamento, melhor ser\u00e1 a coes\u00e3o. O acoplamento \u00e9 uma medida da interdepend\u00eancia e \n\ndepende do volume de elementos que constituem a interface e da forma com que \u00e9 \n\nestabelecida a interface. O acoplamento surge em fun\u00e7\u00e3o do relacionamento existente entre os \n\nm\u00f3dulos e \u00e9 caracterizado pela passagem de controle entre eles (STAA, 2000). \n\nPor sua vez, Pressman (1995, p. 441) estabelece que um \u201cm\u00f3dulo coesivo executa \n\numa \u00fanica tarefa dentro do procedimento de software, exigindo pouca intera\u00e7\u00e3o com \n\nprocedimentos que s\u00e3o executados em outras partes de um sistema\u201d. Dessa forma, um m\u00f3dulo \n\ncoesivo deve fazer apenas uma coisa. Em rela\u00e7\u00e3o ao acoplamento, o n\u00edvel em um projeto de \n\nsoftware deve ser o mais baixo poss\u00edvel.  \n\nNa modulariza\u00e7\u00e3o um m\u00f3dulo deve possuir uma elevada coes\u00e3o para permitir a \n\nexecu\u00e7\u00e3o de uma tarefa procedimental distinta. Por outro lado, \u00e9 necess\u00e1rio o baixo \n\nacoplamento, que para Pressman (1995) \u00e9 poss\u00edvel utilizando um n\u00famero m\u00ednimo de \n\ninterfaces e  informa\u00e7\u00f5es que s\u00e3o trocadas por elas. \n\nNo entanto, deve-se considerar a baixa coes\u00e3o de forma que o projeto possa ser \n\nmodificado para conseguir maior independ\u00eancia funcional, j\u00e1 que o acoplamento depende da \n\ncomplexidade de interfaces entre os m\u00f3dulos. A simples conectividade entre os m\u00f3dulos \n\nresulta em um software que \u00e9 mais f\u00e1cil de entender e menos propenso a propaga\u00e7\u00e3o de erros \n\npelo sistema (PRESSMAN, 1995). \n\n\n\n \n\n  \n\n37 \n\n2.2.2 Componentiza\u00e7\u00e3o \n\nUm componente \u00e9 um conjunto de um ou mais m\u00f3dulos, formando um todo \n\ncoerente e implementando uma funcionalidade bem definida. Componentes s\u00e3o incorporados \n\nao programa sem sofrer altera\u00e7\u00f5es, al\u00e9m de serem mais abstratos do que classes e poder ser \n\nconsiderados provedores de servi\u00e7os. Quando o sistema precisar desse servi\u00e7o basta chamar o \n\ncomponente, sem se preocupar onde tal componente est\u00e1 sendo executado (STAA, 2000; \n\nBEZERRA, 2002; SOMMERVILLE, 2003; BOOCH, 2000).  \n\nPor sua vez, Peters (2001) caracteriza um componente como uma unidade de \n\nsoftware testada para fins especiais. Por exemplo, uma classe Java, extensivamente testada, \n\nconsiderada confi\u00e1vel que seja \u00fatil, adapt\u00e1vel e reutiliz\u00e1vel. \n\nAssim, para visualizar um componente reutiliz\u00e1vel como provedor de servi\u00e7os \u00e9 \n\npreciso enfatizar, segundo Sommerville (2003), duas importantes caracter\u00edsticas: \n\n\u2022 \u00c9 uma entidade execut\u00e1vel independente. O c\u00f3digo-fonte n\u00e3o est\u00e1 \n\ndispon\u00edvel e n\u00e3o \u00e9 compilado com outros componentes do sistema. \n\n\u2022 Publicam suas interfaces e todas as intera\u00e7\u00f5es s\u00e3o feitas por meio dessa \n\ninterface. Sua interface \u00e9 expressa e seu estado interno nunca \u00e9 exposto. \n\nA reusabilidade \u00e9 uma caracter\u00edstica importante de um componente. Ela permite \n\nque o componente, depois de ser projetado e implementado, possa ser reusado em muitos \n\nprogramas ou sistemas diferentes. Os componentes reutiliz\u00e1veis s\u00e3o mais confi\u00e1veis do que \n\nnovos componentes, j\u00e1 que foram experimentados e testados, reduzindo o n\u00famero de falhas.  \n\nO processo ideal de desenvolvimento de componentes, segundo Sommerville \n\n(2003), deve ter como base a experi\u00eancia, em que os componentes reutiliz\u00e1veis s\u00e3o \n\nconstru\u00eddos a partir de componentes existentes e j\u00e1 utilizados. Utilizando o conhecimento \n\n\n\n \n\n  \n\n38 \n\nsobre problemas de reuso e as adapta\u00e7\u00f5es necess\u00e1rias dos componentes, pode ser criada uma \n\nvers\u00e3o de componente mais gen\u00e9rica, portanto, mais reutiliz\u00e1vel. Tornar um componente \n\nreutiliz\u00e1vel consiste em fornecer uma interface gen\u00e9rica, com opera\u00e7\u00f5es que apresentam as \n\ndiferentes maneiras pelas quais o componente pode ser utilizado.  \n\nO principal objetivo do desenvolvimento baseado em componentes \u00e9 permitir que \n\nos desenvolvedores usem mais de uma vez o c\u00f3digo escrito em qualquer linguagem. Seu \n\nprincipal propulsor \u00e9 a proje\u00e7\u00e3o de unidades de software individuais \u201cconect\u00e1veis\u201d \u2013 unidades \n\nque possam ser facilmente conectadas a uma aplica\u00e7\u00e3o para estender seu funcionamento. \n\n2.2.3 Orienta\u00e7\u00e3o a Objetos \n\nO termo orienta\u00e7\u00e3o a objetos pressup\u00f5e uma organiza\u00e7\u00e3o de software em termos \n\nde cole\u00e7\u00e3o de objetos discretos incorporando estrutura e comportamento pr\u00f3prios. Esta \n\nabordagem de organiza\u00e7\u00e3o \u00e9 essencialmente diferente do desenvolvimento tradicional de \n\nsoftware, onde estruturas de dados e rotinas s\u00e3o desenvolvidas de forma apenas fracamente \n\nacopladas. Al\u00e9m disso, a orienta\u00e7\u00e3o a objetos \u00e9 edificada em cima dos conceitos de \n\nmodularidade, abstra\u00e7\u00e3o e oculta\u00e7\u00e3o de informa\u00e7\u00f5es (PRESSMAN, 1995). \n\nA abstra\u00e7\u00e3o, segundo Mendes (2002), \u00e9 a maneira mais apropriada para lidar com \n\na complexidade. Atrav\u00e9s da abstra\u00e7\u00e3o podemos identificar os aspectos importantes de um \n\nfen\u00f4meno e ignorar os detalhes. Pressman (1995) comenta que a abstra\u00e7\u00e3o pode ser \n\napresentada em v\u00e1rios n\u00edveis. Em um n\u00edvel mais elevado a solu\u00e7\u00e3o \u00e9 declarada em termos \n\namplos, usando a linguagem do ambiente do problema. J\u00e1 em um n\u00edvel inferior, a solu\u00e7\u00e3o \u00e9 \n\ndefinida de uma forma que possa ser diretamente implementada.   \n\n\n\n \n\n  \n\n39 \n\nNa orienta\u00e7\u00e3o a objetos, a abstra\u00e7\u00e3o funciona como uma ferramenta, que \n\npossibilita compreender o sistema. Dessa forma, o sistema \u00e9 dividido em componentes e os \n\nmesmos s\u00e3o visualizados em diferentes n\u00edveis de complexidade e detalhe.  \n\nBezerra (2002) coloca que o paradigma da orienta\u00e7\u00e3o a objetos \u00e9 uma forma de \n\nabordar um problema. Alguns conceitos importantes como abstra\u00e7\u00e3o, objeto, classes, \n\nencapsulamento, heran\u00e7a e polimorfismo devem ser considerados quando utilizamos esse \n\nparadigma no desenvolvimento de software, como mostra a Figura 3: \n\n \nFigura 3. Princ\u00edpios da Orienta\u00e7\u00e3o a Objetos \n\n   Fonte: Bezerra, 2002, p. 09. \n\nUm objeto \u00e9 a abstra\u00e7\u00e3o de uma entidade do mundo real que \u00e9 mapeado para o \n\ndom\u00ednio de software. Um objeto define os fatos. Na linguagem de um programador, um \n\nobjeto \u00e9 a inst\u00e2ncia de uma classe. Uma classe corresponde a descri\u00e7\u00e3o dos atributos e \n\nservi\u00e7os comuns a um grupo de objetos, isto \u00e9, um molde a partir do qual os objetos s\u00e3o \n\nconstru\u00eddos. Uma classe define as regras. Al\u00e9m disso, as classes s\u00e3o utilizadas para agregar \n\na\u00e7\u00f5es fortemente interdependentes e que encapsulam a informa\u00e7\u00e3o de estado manipulada por \n\nestas a\u00e7\u00f5es.  \n\nDentro deste contexto, o encapsulamento \u00e9 a forma pela qual podemos restringir o \n\nacesso a opera\u00e7\u00f5es que pertencem \u00e0 classe, a fim de evitar que as mesmas sejam modificadas. \n\nAssim, a comunica\u00e7\u00e3o entre objetos ser\u00e1 feita atrav\u00e9s de fun\u00e7\u00f5es de acesso. O \n\n\n\n \n\n  \n\n40 \n\nencapsulamento descreve uma maneira de organizar as informa\u00e7\u00f5es em uma abstra\u00e7\u00e3o de \n\nmodo que possam ser usadas eficientemente em uma aplica\u00e7\u00e3o de software. O \n\nencapsulamento separa os fatores necess\u00e1rios a fim de usar o objeto dos fatos necess\u00e1rios para \n\nfaz\u00ea-lo funcionar corretamente. Para usar um objeto, ele precisa expor sua finalidade e suas \n\ninterfaces. Para fazer o objeto funcionar corretamente, ele precisa conter os dados e o \n\ncomportamento que satisfa\u00e7am os servi\u00e7os oferecidos pelas interfaces (PRESSMAN, 1995; \n\nSTAA, 2000; PAGE-JONES, 2001; BEZERRA, 2002).  \n\nComo o encapsulamento restringe o acesso interno dos objetos, a oculta\u00e7\u00e3o de \n\ninforma\u00e7\u00f5es utiliza o encapsulamento para restringir a visibilidade externa de certos detalhes \n\nde informa\u00e7\u00e3o, isto \u00e9, o observador externo tem pleno conhecimento do que o objeto pode \n\nfazer, mas n\u00e3o sabe como ele pode fazer ou como ele \u00e9 constitu\u00eddo (PAGE-JONES, 2001). \n\nUm objeto consegue restringir o acesso a suas informa\u00e7\u00f5es atrav\u00e9s do \n\nencapsulamento e oculta\u00e7\u00e3o de informa\u00e7\u00f5es. No entanto, um objeto tamb\u00e9m tem a capacidade \n\nde reter informa\u00e7\u00f5es indefinidamente, inclusive durante os intervalos de ativa\u00e7\u00e3o de suas \n\nopera\u00e7\u00f5es.  \n\nA heran\u00e7a \u00e9 outro conceito da orienta\u00e7\u00e3o a objetos que define a rela\u00e7\u00e3o atrav\u00e9s da \n\nqual uma classe especializa, refina ou particulariza propriedades de outra classe. Na heran\u00e7a, \n\nclasses semelhantes s\u00e3o agrupadas em hierarquias. Cada n\u00edvel de uma hierarquia pode ser \n\nvisto como um n\u00edvel de abstra\u00e7\u00e3o. Assim, cada classe herda as caracter\u00edsticas das classes dos \n\nn\u00edveis acima, o que facilita o compartilhamento de comportamento comum a essas classes e \n\npermite organizar, de forma clara, as diferen\u00e7as e varia\u00e7\u00f5es de uma determinada classe em \n\nparticular. Na Figura 4, \u00e9 ilustrado um exemplo de heran\u00e7a, onde as propriedades da \n\nsuperclasse Pessoa s\u00e3o herdadas pelas classes herdeiras Empregado, Consultor e Dependente \n\n(STAA, 2000). \n\n\n\n \n\n  \n\n41 \n\n \nFigura 4. Exemplo de Heran\u00e7a \n\n    Fonte: Adaptado de Staa (2000).   \n\nUma caracter\u00edstica associada \u00e0 heran\u00e7a \u00e9 o polimorfismo. O polimorfismo indica a \n\ncapacidade de abstrair v\u00e1rias implementa\u00e7\u00f5es diferentes em uma \u00fanica interface, isto \u00e9, um \n\nobjeto pode enviar a mesma mensagem para objetos semelhantes, mas que implementam a \n\nsua interface de formas diferentes.  \n\nConforme Pressman (1995), para conseguir modularidade em um projeto de \n\nsoftware \u00e9 necess\u00e1rio: capacidade de decompor o problema em subproblemas; capacidade de \n\ncomposi\u00e7\u00e3o, no qual os componentes (m\u00f3dulos), uma vez projetados e constru\u00eddos, possam \n\nser reutilizados em outros sistemas; compreensibilidade; continuidade e prote\u00e7\u00e3o. Os tr\u00eas \n\n\u00faltimos referem-se: a facilidade com que um componente pode ser entendido, sem refer\u00eancia \n\na outras informa\u00e7\u00f5es ou m\u00f3dulos; capacidade de fazer pequenas mudan\u00e7as sem grandes \n\nconseq\u00fc\u00eancias e a redu\u00e7\u00e3o da propaga\u00e7\u00e3o de efeitos colaterais se um erro ocorrer em um \n\ndeterminado m\u00f3dulo. Assim sendo, percebeu-se que a orienta\u00e7\u00e3o a objetos realiza cada \n\ncrit\u00e9rio, acima relacionado, de forma eficaz se comparado a outras abordagens e resulta em \n\narquiteturas que buscam a modularidade mais eficientemente.  \n\n\n\n \n\n  \n\n42 \n\n2.3 An\u00e1lise e Projeto \n\nA an\u00e1lise e projeto de sistemas \u00e9 um campo ativo e empolgante, no qual os \n\nanalistas aprendem continuamente novas t\u00e9cnicas e abordagens para desenvolver sistemas de \n\nforma mais efetiva e eficiente. Os projetos exigem que os analistas re\u00fanam os requisitos, \n\nmodelem as necessidades da empresa e criem planos de como o sistema deve ser \n\ndesenvolvido. Isto requer tamb\u00e9m um conhecimento de conceitos de comportamento \n\norganizacional, como o gerenciamento de mudan\u00e7as e o desenvolvimento de equipes, \n\naplicado nos projetos dos mais diversos segmentos e durante as fases pelas quais os projetos \n\nde software geralmente passam: planejamento, an\u00e1lise, projeto, implementa\u00e7\u00e3o, testes e \n\nimplanta\u00e7\u00e3o. Essas fases comp\u00f5em o ciclo de vida b\u00e1sico de desenvolvimento de sistemas, \n\nindependente da abordagem ou metodologia utilizada (DENNIS, 2005; BEZERRA, 2002). \n\nO ciclo b\u00e1sico de desenvolvimento \u00e9 um processo gradual, no qual os resultados \n\nobtidos na fase de an\u00e1lise servem como entrada na fase de projeto. Por sua vez, a fase de \n\nimplementa\u00e7\u00e3o utiliza os resultados obtidos no projeto para produzir o sistema real. Esse ciclo \n\nde vida b\u00e1sico de desenvolvimento de sistemas \u00e9 implementado nas v\u00e1rias metodologias de \n\ndesenvolvimento de sistemas (DENNIS, 2005; BEZERRA, 2002).  \n\nO processo de desenvolvimento IBM Rational Unified Process (RUP) \u00e9 um \n\nprocesso que est\u00e1 fortemente centrado na arquitetura, funcionalidade e desenvolvimento \n\niterativo e incremental. O RUP se preocupa em retratar a arquitetura do sistema, ressaltando \n\nas caracter\u00edsticas mais importantes do projeto. No entanto, o RUP \u00e9 um processo \n\nconfigur\u00e1vel, o que permite que a organiza\u00e7\u00e3o que empregar o RUP poder\u00e1 adequ\u00e1-lo as suas \n\nnecessidades.   \n\n\n\n \n\n  \n\n43 \n\nO RUP, segundo Tonsig (2003), est\u00e1 baseado em um conjunto de princ\u00edpios que \n\ns\u00e3o considerados fundamentais para o desenvolvimento de um software, onde, ainda \n\nconforme Tonsig (2003), as funcionalidades s\u00e3o demonstradas atrav\u00e9s de casos de uso, que \n\ns\u00e3o a representa\u00e7\u00e3o dos requisitos funcionais. \n\nO primeiro princ\u00edpio diz respeito ao desenvolvimento iterativo do software, o qual \n\nfacilita os ajustes t\u00e1ticos dos requisitos e de novas caracter\u00edsticas. Al\u00e9m disso, \u00e9 poss\u00edvel \n\nidentificar antecipadamente os riscos do projeto, assim como algumas inconsist\u00eancias no \n\nprojeto, entre os requisitos e tamb\u00e9m na implementa\u00e7\u00e3o. Com os riscos identificados, algumas \n\naltera\u00e7\u00f5es podem ser realizadas sem provocar maiores danos, o que facilita tamb\u00e9m a \n\nadministra\u00e7\u00e3o dos requisitos, que ainda assim podem sofrer modifica\u00e7\u00f5es durante a \n\nelabora\u00e7\u00e3o do projeto de sistema. \n\nA utiliza\u00e7\u00e3o de uma arquitetura baseada em componentes busca a reutiliza\u00e7\u00e3o e \n\nadapta\u00e7\u00e3o de componentes existentes em v\u00e1rias fontes. Esses componentes s\u00e3o m\u00f3dulos \n\ndefinidos na arquitetura e que possuem uma funcionalidade claramente delimitada. \n\nA modelagem visual do software consiste em criar modelos para auxiliar a equipe \n\nde desenvolvimento a visualizar, construir e documentar a estrutura e comportamento da \n\narquitetura de um sistema. Utilizar uma linguagem de modelagem padr\u00e3o permite que \n\nmembros da equipe se comuniquem de forma clara e sem ambig\u00fcidades. \n\nA qualidade de software \u00e9 fundamental na constru\u00e7\u00e3o e manuten\u00e7\u00e3o do software \n\ne, portanto, deve ser cont\u00ednua em rela\u00e7\u00e3o \u00e0 funcionalidade, confiabilidade e valida\u00e7\u00e3o. \n\nPor \u00faltimo, temos a gest\u00e3o das altera\u00e7\u00f5es no software, na qual \u00e9 realizada a \n\ncoordena\u00e7\u00e3o das atividades que originam os m\u00f3dulos e suas respectivas vers\u00f5es. \n\nAssim, a metodologia RUP contempla as atividades que v\u00e3o desde o planejamento \n\ndo projeto at\u00e9 os processos de teste. Essa contempla\u00e7\u00e3o determina o quanto o m\u00e9todo \u00e9 \n\nadequado \u00e0 constru\u00e7\u00e3o de sistemas de maneira a atender os par\u00e2metros de qualidade e \n\n\n\n \n\n  \n\n44 \n\nprodutividade. Al\u00e9m disso, o processo de desenvolvimento que utiliza o RUP se d\u00e1 mediante \n\numa s\u00e9rie de ciclos que constituem uma vers\u00e3o do produto de software, onde cada ciclo \u00e9 \n\ncomposto de quatro fases: concep\u00e7\u00e3o, elabora\u00e7\u00e3o, constru\u00e7\u00e3o e transi\u00e7\u00e3o. Em cada uma \n\ndessas fases \u00e9 que se realizam as itera\u00e7\u00f5es, que abrangem um s\u00e9rie de atividades, como \n\nmostra a Figura 5 (TONSIG, 2003): \n\n \nFigura 5. Fases da Metodologia RUP \nFonte: Adaptado da Rational (2006). \n\nAs fases que contemplam a estrutura geral do processo de desenvolvimento s\u00e3o \n\ndescritas a seguir: \n\n\u2022 Concep\u00e7\u00e3o: inicialmente, \u00e9 preciso estabelecer o escopo do projeto e sua \n\nviabilidade econ\u00f4mica. \n\n\u2022 Elabora\u00e7\u00e3o: o objetivo da fase de elabora\u00e7\u00e3o \u00e9 buscar identificar e eliminar \n\nos riscos, estabelecer uma arquitetura de funda\u00e7\u00e3o s\u00f3lida a partir da qual o \n\nsistema a ser projetado poder\u00e1 evoluir. \n\n\u2022 Constru\u00e7\u00e3o: durante a fase de constru\u00e7\u00e3o, conforme o pr\u00f3prio nome indica, \n\nocorre o desenvolvimento do produto, que \u00e9 feito de forma iterativa e \n\nincremental at\u00e9 sua conclus\u00e3o. \n\n\n\n \n\n  \n\n45 \n\n\u2022 Transi\u00e7\u00e3o: depois da constru\u00e7\u00e3o, o produto \u00e9 colocado em uso, o que \n\nnaturalmente leva a surgir novas considera\u00e7\u00f5es que ir\u00e3o demandar a \n\nconstru\u00e7\u00e3o de novas vers\u00f5es. Essas vers\u00f5es, por sua vez, podem acontecer \n\npor ajustes do sistema, corre\u00e7\u00e3o de problemas ou conclus\u00e3o de algumas \n\ncaracter\u00edsticas que foram postergadas. \n\n\u00c9 importante lembrar que dentro de cada fase um conjunto de itera\u00e7\u00f5es \n\n(planejamento, levantamento de requisitos, an\u00e1lise e projeto, implementa\u00e7\u00e3o e testes) \u00e9 \n\nrealizado. Portanto, na fase de concep\u00e7\u00e3o o foco est\u00e1 no planejamento e levantamento dos \n\nrequisitos, ou seja, no entendimento dos requisitos e na determina\u00e7\u00e3o de um escopo para o \n\nprojeto. Na fase de elabora\u00e7\u00e3o \u00e9 realizada a modelagem dos requisitos, isto \u00e9, o levantamento \n\ne an\u00e1lise, bem como iniciam-se tamb\u00e9m alguns trabalhos nas atividades de an\u00e1lise do projeto \n\ne tamb\u00e9m na implementa\u00e7\u00e3o, como a prototipa\u00e7\u00e3o da arquitetura. Na fase de constru\u00e7\u00e3o o \n\nenfoque ficar\u00e1 concentrado na an\u00e1lise e na implementa\u00e7\u00e3o, visando evoluir o prot\u00f3tipo inicial \n\nde arquitetura at\u00e9 obter o primeiro produto operacional. Por fim, na fase de transi\u00e7\u00e3o, os testes \n\ns\u00e3o o destaque, pois \u00e9 preciso garantir que o sistema possua o n\u00edvel adequado de qualidade. \n\nNesta fase tamb\u00e9m acontece o treinamento dos usu\u00e1rios, durante o qual eles podem auxiliar \n\ncom argumentos em pontos de melhoria do sistema ou ainda ajustar caracter\u00edsticas do \n\nsoftware (TONSIG, 2003). \n\n2.4 Unified Modeling Language \n\nA Unified Modeling Language (UML) \u00e9 uma linguagem-padr\u00e3o para a elabora\u00e7\u00e3o \n\nda estrutura de projetos de software. Pode ser utilizada para visualiza\u00e7\u00e3o, especifica\u00e7\u00e3o, \n\n\n\n \n\n  \n\n46 \n\nconstru\u00e7\u00e3o e documenta\u00e7\u00e3o de elementos pertencentes a sistemas complexos de software. \u00c9 \n\numa linguagem muito expressiva, pois abrange todas as vis\u00f5es necess\u00e1rias para o \n\ndesenvolvimento e implanta\u00e7\u00e3o de sistemas (BOOCH, 2000). \n\nA linguagem de modelagem UML \u00e9 somente uma parte do m\u00e9todo para o \n\ndesenvolvimento de software, sendo independente do processo de desenvolvimento utilizado, \n\napesar de se comportar muito bem com processos orientados a casos de uso centrado na \n\narquitetura, iterativo e comportamental. Al\u00e9m disso, a UML \u00e9 uma linguagem para \n\nvisualiza\u00e7\u00e3o, especifica\u00e7\u00e3o, constru\u00e7\u00e3o e documenta\u00e7\u00e3o de todo tipo de sistemas (BOOCH, \n\n2000). \n\nOs diagramas e nota\u00e7\u00f5es apresentados pela UML descrevem todos os elementos \n\nde um sistema. Para o desenvolvimento da monografia ser\u00e3o utilizados muitos desses \n\ndigramas e nota\u00e7\u00f5es, mas principalmente aqueles que representam componentes na UML. \n\n Para Booch (2000, p.20) \u201cos componentes s\u00e3o partes f\u00edsicas e substitu\u00edveis de um \n\nsistema, que proporcionam a realiza\u00e7\u00e3o de um conjunto de interfaces\u201d. Tipicamente os \n\ncomponentes representam o pacote f\u00edsico de elementos l\u00f3gicos diferentes, como classes, \n\ninterfaces e colabora\u00e7\u00f5es. Graficamente, os componentes s\u00e3o representados como ret\u00e2ngulos \n\ncom abas, incluindo apenas seus nomes, como mostra a Figura 6: \n\n \n\n \nFigura 6. Representa\u00e7\u00e3o de Componente em UML \nFonte: Adaptado de BOOCH, 2000. \n \n\nAl\u00e9m disso, essas  caracter\u00edsticas s\u00e3o enfatizadas por Booch (2000, p. 347): \n\n\n\n \n\n  \n\n47 \n\n\u201cPrimeiro, um componente \u00e9 f\u00edsico. Ele vive no mundo dos bits e n\u00e3o dos conceitos. \nSegundo, um componente \u00e9 substitu\u00edvel. Um componente \u00e9 substitu\u00edvel \u2013 \u00e9 poss\u00edvel \nsubstituir um componente por outro que esteja em conformidade com as interfaces. \nTerceiro, um componente \u00e9 parte de um sistema. Um componente raramente existe \nsozinho. Em vez disso, um determinado componente colabora com outros \ncomponentes e, ao fazer isso, existe no contexto de arquitetura ou da tecnologia em \nque se pretende utiliz\u00e1-lo. Um componente \u00e9 l\u00f3gica e fisicamente coeso e, portanto, \ndenota uma parte estrutural e/ou comportamental significativa de um sistema maior. \nUm componente poder\u00e1 ser reutilizado em muitos sistemas\u201d. \n\nUm componente se adapta ao sistema e exp\u00f5em um conjunto de interfaces. As \n\ninterfaces, portanto, constituem a ponte entre os modelos l\u00f3gico e f\u00edsico. Os componentes s\u00e3o \n\nsemelhantes \u00e0s classes, ambos tem nomes, ambos podem expor um conjunto de interfaces, \n\nambos podem participar de um relacionamento de depend\u00eancia, generaliza\u00e7\u00e3o e associa\u00e7\u00e3o. \n\nMas existem diferen\u00e7as significativas, conforme Booch (2000): \n\nQuadro 2. Diferen\u00e7as entre Classe e Componente \nClasses Componentes \n\nRepresentam abstra\u00e7\u00f5es \nl\u00f3gicas; \n\nRepresentam coisas f\u00edsicas que vivem no mundo dos bits; \n\nPodem ter atributos e \nopera\u00e7\u00f5es diretamente; \n\nGeralmente componentes somente t\u00eam opera\u00e7\u00f5es que s\u00e3o \nalcan\u00e7ados por meio das suas interfaces; \n\n Representam o pacote f\u00edsico de componentes e se apresentam em \num n\u00edvel diferente de abstra\u00e7\u00e3o; \n\n \n\nPara especificar um servi\u00e7o de um componente ou de uma classe, utilizamos a \n\ninterface. Uma interface \u00e9 uma cole\u00e7\u00e3o de opera\u00e7\u00f5es utilizadas por uma classe ou um \n\ncomponente realizar os acessos a outros componentes e/ou classes (BOOCH, 2000). \n\nO relacionamento de um componente com suas interfaces \u00e9 feito pela \n\nrepresenta\u00e7\u00e3o da interface em sua forma ic\u00f4nica, oculta e da interface em sua forma \n\nexpandida, em alguns casos revelando suas opera\u00e7\u00f5es. Nos dois casos, o componente tem \n\nacesso aos servi\u00e7os do outro componente por meio da interface. A conex\u00e3o entre o \n\ncomponente e sua interface \u00e9 realizada usando um relacionamento de depend\u00eancia (BOOCH, \n\n2000, p. 346). A Figura 7 mostra essa conex\u00e3o. \n\nBooch (2000, p. 346) explica tamb\u00e9m como s\u00e3o chamadas as interfaces segundo o \n\nservi\u00e7o que realizam: \n\n\n\n \n\n  \n\n48 \n\n\u201cUma interface realizada por um componente \u00e9 chamada interface de exporta\u00e7\u00e3o, \nsignificando uma interface em que o componente fornece um servi\u00e7o para outros \ncomponentes. Um componente poder\u00e1 fornecer muitas interfaces de exporta\u00e7\u00e3o. A \ninterface utilizada pelo componente \u00e9 chamada de interface de importa\u00e7\u00e3o, \nsignificando uma interface \u00e0 qual o componente se adapta e a partir da qual \u00e9 \nconstru\u00eddo. Um componente poder\u00e1 estar em conformidade a muitas interfaces de \nimporta\u00e7\u00e3o. Al\u00e9m disso, um componente pode tanto importar, como exportar \ninterfaces. \nUma determinada interface poder\u00e1 ser exportada por um componente e importada \npor um outro. O fato dessa interface se encontrar entre dois componentes quebra a \ndepend\u00eancia direta entre os componentes. Um componente que utiliza uma \ndeterminada interface funcionar\u00e1 adequadamente, qualquer que seja o componente \nque a realiza. \u00c9 claro que um componente pode ser utilizado em um contexto, se e \nsomente se todas as interfaces de importa\u00e7\u00e3o forem fornecidas pelas interfaces de \nexporta\u00e7\u00e3o de outros componentes\u201d. \n\n \n\n \nFigura 7. Componentes e Interfaces \nFonte: Adaptado de BOOCH (2000). \n\nA import\u00e2ncia e facilidade do uso de componentes \u00e9 confirmada por Booch (2000, \n\np. 346-347): \n\n\u201cO prop\u00f3sito b\u00e1sico de qualquer facilidade de um sistema operacional baseado em \ncomponentes consiste em permitir a montagem de sistemas a partir de partes \nbin\u00e1rias substitu\u00edveis. Isso significa que \u00e9 poss\u00edvel criar um sistema a partir de \ncomponentes e depois evoluir esse sistema pela adi\u00e7\u00e3o de novos componentes e pela \nsubstitui\u00e7\u00e3o dos anteriores, sem reconstruir o sistema. As interfaces s\u00e3o recurso-\nchave para que isso possa acontecer. Ao especificar uma interface, voc\u00ea pode incluir \nno sistema execut\u00e1vel qualquer componente que esteja com conformidade ou que \nforne\u00e7a essa interface. Voc\u00ea pode estender o sistema, fazendo com que os \ncomponentes ofere\u00e7am novos servi\u00e7os por meio de outras interfaces, as quais, por \nsua vez, podem ser descobertas e utilizadas por outros componentes\u201d. \n\n\n\n \n\n  \n\n49 \n\nExistem tr\u00eas tipos de componentes, segundo Booch (2000): \n\n\u2022 Componentes de Implanta\u00e7\u00e3o: Necess\u00e1rios para formar sistemas \n\nexecut\u00e1veis, como bibliotecas din\u00e2micas (DLLs) e os execut\u00e1veis \n\n(EXEs). \n\n\u2022 Componentes do Produto do Trabalho: S\u00e3o essencialmente o res\u00edduo do \n\nprocesso de desenvolvimento, formado por arquivos de c\u00f3digo-fonte e \n\narquivos de dados. Utilizados para a cria\u00e7\u00e3o dos componentes de \n\nimplanta\u00e7\u00e3o, e por sua vez, do sistema execut\u00e1vel. \n\n\u2022 Componentes de Execu\u00e7\u00e3o: S\u00e3o objetos instanciados a partir de DLLs, \n\nou seja, criados por conseq\u00fc\u00eancia de um sistema em execu\u00e7\u00e3o. \n\nTodos os mecanismos de extensibilidade da UML se aplicam aos componentes. \n\nEntretanto, para isso, \u00e9 necess\u00e1rio o uso de valores atribu\u00eddos para estender as propriedades \n\ndos componentes e estere\u00f3tipos para especificar novos tipos de componentes (BOOCH, \n\n2000). \n\nUm estere\u00f3tipo \u00e9 representado como um nome entre \u00e2ngulos (<<nome>>), \n\ncolocado acima do nome de outro elemento. Como uma indica\u00e7\u00e3o visual, voc\u00ea pode definir \n\num \u00edcone para estere\u00f3tipo e apresent\u00e1-lo \u00e0 direita do nome. \n\nJ\u00e1 o valor atribu\u00eddo \u00e9 representado como uma seq\u00fc\u00eancia de caracteres entre \n\nchaves. Essa seq\u00fc\u00eancia inclui um nome (a etiqueta), um separador (o s\u00edmbolo =) e um valor \n\natribu\u00eddo. A Figura 8 demonstra como o estere\u00f3tipo e o valor atribu\u00eddo \u00e9 representado: \n\n\n\n \n\n  \n\n50 \n\n \nFigura 8. Estere\u00f3tipos e Valores atribu\u00eddos \nFonte: Adaptado de BOOCH (2000). \n\nAl\u00e9m disso, a UML define cinco estere\u00f3tipos-padr\u00e3o que se aplicam aos \n\ncomponentes: \n\n\u2022 Execut\u00e1vel: especifica um componente que pode ser executado em um n\u00f3. \n\n\u2022 Biblioteca: especifica uma biblioteca de objetos est\u00e1tica ou din\u00e2mica. \n\n\u2022 Tabela: especifica um componente que representa uma tabela de banco de \n\ndados. \n\n\u2022 Arquivo: especifica um componente que representa um documento \n\ncontendo c\u00f3digo-fonte ou dados. \n\n\u2022 Documento: especifica um componente que representa um documento. \n\nContudo, al\u00e9m do diagrama de componentes, os diagramas de classes, os \n\ndiagramas de casos de uso, os diagramas de seq\u00fc\u00eancia e os diagramas de atividade tamb\u00e9m \n\ns\u00e3o usados para o desenvolvimento da modelagem do sistema e do componente. \n\n\n\n \n\n  \n\n51 \n\n2.5 Frameworks \n\nUm framework, para Peters (2001), \u00e9 um sistema modific\u00e1vel para prop\u00f3sitos \n\ngerais, que ajuda a estreitar a dist\u00e2ncia entre uma resolu\u00e7\u00e3o de alto n\u00edvel de um problema e a \n\nsua implementa\u00e7\u00e3o em software. Fornece ainda uma forma conveniente para a estrutura\u00e7\u00e3o, \n\ncombina\u00e7\u00e3o de dados e estruturas de controle.  \n\nSegundo Sommerville (2003), o framework \u00e9 um projeto constitu\u00eddo de um \n\nconjunto de classes e da interface entre elas. Detalhes espec\u00edficos do projeto s\u00e3o \n\nimplementados com o acr\u00e9scimo de componentes e o fornecimento da implementa\u00e7\u00e3o \n\nconcreta das classes abstratas nos frameworks. Os frameworks raramente s\u00e3o aplica\u00e7\u00f5es \n\npropriamente ditas. As aplica\u00e7\u00f5es normalmente s\u00e3o constru\u00eddas pela integra\u00e7\u00e3o de diversos \n\nframeworks. \n\nPara Sommerville (2003), os frameworks dividem-se em tr\u00eas classes: \n\n\u2022 Frameworks de infra-estrutura de sistema: S\u00e3o compat\u00edveis com o \n\ndesenvolvimento das infra-estruturas de sistemas, como comunica\u00e7\u00f5es, \n\ninterfaces com o usu\u00e1rio e compiladores. \n\n\u2022 Frameworks de integra\u00e7\u00e3o com middleware: Consiste em um conjunto de \n\nclasses de objetos-padr\u00e3o e associadas, que aceitam a comunica\u00e7\u00e3o de \n\ncomponentes e a troca de informa\u00e7\u00f5es. \n\n\u2022 Frameworks de aplica\u00e7\u00f5es corporativos: Ocupam-se de dom\u00ednios \n\nespec\u00edficos de aplica\u00e7\u00f5es, como telecomunica\u00e7\u00f5es ou sistemas financeiros. \n\nIncluem o conhecimento de dom\u00ednio e s\u00e3o compat\u00edveis com o \n\ndesenvolvimento de aplica\u00e7\u00f5es para o usu\u00e1rio final. Normalmente mais \n\nabstratos, possibilitando a cria\u00e7\u00e3o de uma gama mais ampla de aplica\u00e7\u00f5es. \n\n\n\n \n\n  \n\n52 \n\n\u201cUm framework \u00e9 formado por uma estrutura de classes contendo pontos de \nextens\u00e3o. Estes pontos podem ser estendidos pela aplica\u00e7\u00e3o, conforme pode ser visto \nna figura a seguir. Desta forma um determinado programa pode ser visto como \nsendo formado por um framework provendo servi\u00e7os gen\u00e9ricos e que s\u00e3o \ndevidamente especializados por elementos da aplica\u00e7\u00e3o. Contr\u00e1rio ao caso de \ncomponentes em que a aplica\u00e7\u00e3o comanda e coordena o funcionamento dos \ncomponentes, um framework comanda e coordena o comportamento da aplica\u00e7\u00e3o\u201d \n(STAA, 2000, p. 330). \n\n \n\n \nFigura 9. Intera\u00e7\u00e3o entre um Framework e a Aplica\u00e7\u00e3o \nFonte: STAA, 2000, p. 331. \n\nPara Booch (2000), um framework \u00e9 um padr\u00e3o de arquitetura que fornece um \n\ntemplate extens\u00edvel para aplica\u00e7\u00f5es dentro de um dom\u00ednio. Ao especificar um framework, \n\nvoc\u00ea especifica o esqueleto de uma arquitetura, juntamente com os conectores, guias, bot\u00f5es e \n\nindicadores que s\u00e3o expostos aos usu\u00e1rios que desejam adaptar esse framework ao seu pr\u00f3prio \n\ncontexto. \n\nNa mesma id\u00e9ia, Larman (2000) define framework como um conjunto coeso de \n\nclasses que colaboram para o n\u00facleo invariante de um subsistema l\u00f3gico. Essas classes s\u00e3o \n\nconcretas e abstratas, sendo que as \u00faltimas definem interfaces a serem seguidas, intera\u00e7\u00f5es \n\nentre objetos e outros invariantes. Al\u00e9m disso, frameworks fornecem um grau muito elevado \n\nde reutiliza\u00e7\u00e3o, muito mais do que classes individuais. \n\n\n\n \n\n  \n\n53 \n\nDessa forma, usar frameworks prontos ou criar os pr\u00f3prios s\u00e3o caminhos que as \n\norganiza\u00e7\u00f5es podem seguir para reutilizar c\u00f3digo e reduzir o tempo de implementa\u00e7\u00e3o e \n\nentrega de sistemas. No entanto, existem outros caminhos, como mencionado anteriormente, \n\nque utilizam conceitos de modulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o nos processos de \n\ndesenvolvimento de sistemas.  \n\n2.6 Considera\u00e7\u00f5es Finais \n\nA revis\u00e3o bibliogr\u00e1fica permitiu entender conceitos que s\u00e3o fundamentais para o \n\ndesenvolvimento da modelagem, an\u00e1lise e implementa\u00e7\u00e3o do sistema e do componente.  \n\nOs autores citados durante toda a revis\u00e3o foram fundamentais para comprovar a \n\nimport\u00e2ncia da modulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o no desenvolvimento de sistemas que \n\npermitem o reuso e a redu\u00e7\u00e3o de custos no desenvolvimento e manuten\u00e7\u00e3o do sistema.  \n\nA metodologia de desenvolvimento estudada foi adotada pela abordagem que o \n\nRUP tem em rela\u00e7\u00e3o a componentes e tamb\u00e9m pelas caracter\u00edsticas de customiza\u00e7\u00e3o, sendo \n\nadapt\u00e1vel a cada projeto.  \n\nEnfim, todos os crit\u00e9rios abordados nesse estudo s\u00e3o colocados em pr\u00e1tica a partir \n\ndo pr\u00f3ximo cap\u00edtulo, onde \u00e9 descrito o desenvolvimento da modelagem e etapas posteriores, \n\npara ent\u00e3o, chegar ao produto final.  \n\n\n\n \n\n  \n\n54 \n\n3 MODELAGEM \n\nA modelagem de um sistema de software, assim como a modelagem de \n\ncomponentes possui uma caracter\u00edstica intr\u00ednseca: a complexidade de seu desenvolvimento. \n\nPara isso faz-se uso de alguns recursos que auxiliam no planejamento, constru\u00e7\u00e3o e \n\nimplanta\u00e7\u00e3o desses sistemas (BEZERRA, 2002).  \n\nA proposta de solu\u00e7\u00e3o utiliza uma customiza\u00e7\u00e3o do processo de desenvolvimento \n\nde software IBM Rational Unified Process (RUP) e \u00e9 representada atrav\u00e9s da Linguagem de \n\nModelagem Unificada (UML). \n\nPara o processo de an\u00e1lise e projeto do sistema foi feito uso da ferramenta de \n\nmodelagem Enterprise Architect (EA). Segundo a Rational (2006), nesta fase o foco est\u00e1 em \n\ncompreender os elementos-chave do processo, com o objetivo de capturar todas as \n\ninforma\u00e7\u00f5es necess\u00e1rias para um desenvolvimento coerente com a realidade do problema. \n\nNeste cap\u00edtulo ser\u00e3o descritas as fases da metodologia RUP, assim como suas \n\natividade e artefatos. Estes \u00faltimos, ser\u00e3o detalhados nos ap\u00eandices deste trabalho. Por fim, o \n\ndesenvolvimento se dar\u00e1 em uma vis\u00e3o mais abstrata, chegando a n\u00edveis de detalhamento bem \n\nespec\u00edfico e singular. \n\n\n\n \n\n  \n\n55 \n\n3.1 Concep\u00e7\u00e3o \n\nA fase de concep\u00e7\u00e3o aborda uma vis\u00e3o do sistema e estabelece um projeto formal \n\npara constru\u00ed-lo.  Al\u00e9m disso, ser\u00e3o definidos os principais casos de uso, que devem ser \n\nelaborados com precis\u00e3o, para ent\u00e3o proceder com as estimativas de prazo e custo. Assim, a \n\n\u00eanfase nessa etapa recai sobre o planejamento e por conseguinte,  \u00e9 necess\u00e1rio levantar os \n\nrequisitos do sistema e analis\u00e1-los. \n\n\n\n \n\n  \n\n56 \n\n \nFigura 10. Workflow Fase de Concep\u00e7\u00e3o \nFonte: Adaptado da Rational (2006). \n\n \n \n\n\n\n \n\n  \n\n57 \n\nAs tarefas executadas na fase de Concep\u00e7\u00e3o foram: \n\nConceber Novo Projeto \n\n\u2022 Iniciar Projeto \n\nA equipe planeja o projeto e define os crit\u00e9rios para o sucesso de medi\u00e7\u00e3o do \n\nprojeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\nPreparar o Ambiente para a Itera\u00e7\u00e3o \n\n\u2022 Verificar Configura\u00e7\u00e3o e Instala\u00e7\u00e3o de Ferramentas \n\nSelecionar e adquirir as ferramentas necess\u00e1rias para a realiza\u00e7\u00e3o do projeto \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Especialista em Ferramentas. \n\nDesenvolver o Plano de Desenvolvimento do Projeto \n\n\u2022 Definir Organiza\u00e7\u00e3o do Projeto e a Equipe \n\nDefinir uma estrutura organizacional para o projeto, a equipe e suas exig\u00eancias \n\nconforme as estimativas do esfor\u00e7o - em termos de n\u00fameros, tipos e n\u00edveis da \n\nexperi\u00eancia - para a pr\u00f3xima itera\u00e7\u00e3o e para as itera\u00e7\u00f5es subseq\u00fcentes \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\n\u2022 Planejar Fases e Itera\u00e7\u00f5es \n\nEstimar o espa\u00e7o, o esfor\u00e7o e o custo totais para o projeto. Definir um conjunto \n\nde itera\u00e7\u00f5es dentro das fases do projeto, e identificar os objetivos para cada \n\numa destas itera\u00e7\u00f5es. Desenvolver o cronograma e o or\u00e7amento para o projeto, \n\nverificando as atividades iniciais para a conclus\u00e3o do projeto (RATIONAL, \n\n2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\n\n\n \n\n  \n\n58 \n\n\u2022 Revisar Planejamento de Projeto \n\nAprovar o Plano inicial de Desenvolvimento do Software. Se houver mudan\u00e7as \n\n\u00e9 necess\u00e1rio realizar uma nova revis\u00e3o no Plano e em seguida aprov\u00e1-las \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\nAnalisar o Problema \n\n\u2022 Encontrar Atores e Casos de Uso \n\nDefinir o escopo e a funcionalidade do sistema - o que ser\u00e1 feito pelo sistema e \n\no que n\u00e3o ser\u00e1 feito pelo sistema, definindo quem e o que interagir\u00e1 com o \n\nsistema. Criar diagramas de casos de uso (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\n\u2022 Capturar um Vocabul\u00e1rio Comum \n\nDefinir um vocabul\u00e1rio comum que possa ser usado em todas as descri\u00e7\u00f5es \n\ntextuais do sistema, especialmente em descri\u00e7\u00f5es dos casos de uso \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\nGerenciar o Escopo do Sistema \n\n\u2022 Priorizar Casos de Uso \n\nDefinir a entrada para sele\u00e7\u00e3o dos cen\u00e1rios e casos de uso que devem ser \n\nanalisadas na itera\u00e7\u00e3o atual. Definir os cen\u00e1rios e casos de uso que representam \n\nalguma funcionalidade significativa. Definir os cen\u00e1rios e casos de uso que t\u00eam \n\numa cobertura arquitetural substancial ou que for\u00e7am ou ilustram um ponto \n\nespec\u00edfico delicado da arquitetura (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Gerenciar Depend\u00eancias \n\n\n\n \n\n  \n\n59 \n\nUsar atributos e habilidades de exig\u00eancias do projeto, para ajudar no \n\ngerenciamento do escopo e de mudan\u00e7as no projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\nDefinir o Sistema \n\n\u2022 Encontrar Atores e Casos de Uso \n\nDefinir o escopo e a funcionalidade do sistema - o que ser\u00e1 feito pelo sistema e \n\no que n\u00e3o ser\u00e1 feito pelo sistema, definindo quem e o que interagir\u00e1 com o \n\nsistema. Criar diagramas de casos de uso (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\n\u2022 Capturar Vocabul\u00e1rio Comum \n\nDescri\u00e7\u00e3o da atividade: Definir um vocabul\u00e1rio comum que possa ser usado \n\nem todas as descri\u00e7\u00f5es textuais do sistema, especialmente em descri\u00e7\u00f5es dos \n\ncasos de uso (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\n\u2022 Gerenciar Depend\u00eancias \n\nUsar atributos e habilidades de exig\u00eancias do projeto, para ajudar no \n\ngerenciamento do escopo e de mudan\u00e7as no projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\nPreparar S\u00edntese da Arquitetura \n\n\u2022 Analisar a Arquitetura \n\nDefinir uma arquitetura candidata para o sistema baseado na experi\u00eancia \n\nadquirida dos sistemas similares ou em dom\u00ednios similares do problema. \n\nDefinir testes padr\u00f5es da arquitetura, os mecanismos chaves, e modelar \n\nconven\u00e7\u00f5es para o sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\n\n \n\n  \n\n60 \n\n\u2022 Analisar os Casos de Uso \n\nIdentificar as classes que executam o fluxo dos eventos dos casos de uso. \n\nDistribuir o comportamento dos casos de uso para as classes, usando \n\nrealiza\u00e7\u00f5es de casos de uso. Identificar as responsabilidades, os atributos e as \n\nassocia\u00e7\u00f5es das classes. Anotar o uso de mecanismos arquiteturais \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\nPlano para a Pr\u00f3xima Itera\u00e7\u00e3o \n\n\u2022 Desenvolver Plano de Itera\u00e7\u00e3o \n\nCriar e aprovar as metas propostas para a itera\u00e7\u00e3o da pr\u00f3xima fase \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Revis\u00e3o. \n\nOs artefatos gerados durante a fase de Concep\u00e7\u00e3o foram: Plano de \n\nDesenvolvimento de Software (AP\u00caNDICE A), Plano de Itera\u00e7\u00e3o da Concep\u00e7\u00e3o (AP\u00caNDICE \n\nF), Plano de Itera\u00e7\u00e3o Elabora\u00e7\u00e3o (AP\u00caNDICE F), Gloss\u00e1rio (AP\u00caNDICE J), Especifica\u00e7\u00e3o \n\nComplementar (AP\u00caNDICE B), Documento de Arquitetura do Software (AP\u00caNDICE E), \n\nEspecifica\u00e7\u00e3o dos Casos de Uso (AP\u00caNDICE D), Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o dos Casos de \n\nUso (AP\u00caNDICE G). \n\n3.2 Elabora\u00e7\u00e3o \n\nO objetivo da fase de Elabora\u00e7\u00e3o \u00e9 definir a arquitetura candidata de um sistema \n\npara prover uma base est\u00e1vel para a carga de projeto e esfor\u00e7o de implementa\u00e7\u00e3o que ser\u00e1 \n\n\n\n \n\n  \n\n61 \n\nrealizado na fase de Constru\u00e7\u00e3o. A arquitetura evolui a partir da considera\u00e7\u00e3o dos requisitos \n\nmais significativos (dos que possuem um grande impacto na arquitetura de um sistema) e um \n\nc\u00e1lculo do risco. A estabilidade da arquitetura ser\u00e1 avaliada atrav\u00e9s de um ou mais prot\u00f3tipos \n\narquiteturais (RATIONAL, 2006). \n\n \nFigura 11. Workflow Fase de Elabora\u00e7\u00e3o \nFonte: Adaptado da Rational (2006).  \n\nAs tarefas executas na fase de Elabora\u00e7\u00e3o foram: \n\nPreparar o Ambiente para a Itera\u00e7\u00e3o \n\n\n\n \n\n  \n\n62 \n\n\u2022 Verificar Configura\u00e7\u00e3o e Instala\u00e7\u00e3o de Ferramentas \n\nSelecionar e adquirir as ferramentas necess\u00e1rias para a realiza\u00e7\u00e3o do projeto \n\n(RATIONAL, 2006). \n\n Respons\u00e1vel: Especialista em Ferramentas. \n\nGerenciar Mudan\u00e7as de Requisitos \n\n\u2022 Estruturar os modelos de caso de uso \n\nExtrair os comportamentos atrav\u00e9s de casos de uso abstratos, caso isso seja \n\nnecess\u00e1rio e encontrar novos atores abstratos que definem os pap\u00e9is que s\u00e3o \n\ncompartilhados por diversos atores (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistemas. \n\n\u2022 Gerenciar as depend\u00eancias \n\nUsar atributos e caracter\u00edsticas dos requisitos do projeto para auxiliar no \n\ngerenciamento do escopo e nas mudan\u00e7as de requisitos que envolvem o projeto \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistemas. \n\n\u2022 Revisar os requisitos \n\nVerificar formalmente se os requisitos est\u00e3o de acordo com as id\u00e9ias do cliente \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Revisor T\u00e9cnico. \n\nMonitorar e Controlar o Projeto \n\n\u2022 Monitorar a situa\u00e7\u00e3o do projeto \n\nCaptura o status atual do projeto e avalia a situa\u00e7\u00e3o atual do cronograma \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\n\u2022 Planejar e designar o trabalho \n\n\n\n \n\n  \n\n63 \n\nAprovar as mudan\u00e7as (defeitos) que s\u00e3o levantadas durante a itera\u00e7\u00e3o e adapt\u00e1-\n\nlas ao produto e/ou processo (RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\n\u2022 Tratar os problemas e exce\u00e7\u00f5es \n\nPropor a\u00e7\u00f5es corretivas apropriadas para resolver os problemas e as exce\u00e7\u00f5es \n\nque s\u00e3o levantados no projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\nRefinar o Sistema \n\n\u2022 Detalhar o Caso de Uso \n\nDescrever um ou mais casos de uso, detalhando o suficiente para o \n\ndesenvolvimento do software (RATIONAL, 2006). \n\nRespons\u00e1vel: Especificador de Requisitos. \n\n\u2022 Detalhar os Requisitos do Sistema \n\nColetar, detalhar e organizar o pacote dos artefatos que descrevem \n\ncompletamente as exig\u00eancias do sistema ou do subsistema (RATIONAL, \n\n2006). \n\nRespons\u00e1vel: Especificador de Requisitos. \n\nDefinir a Arquitetura candidata \n\n\u2022 Analisar a Arquitetura \n\nDescri\u00e7\u00e3o da atividade: Definir uma arquitetura para o sistema baseado na \n\nexperi\u00eancia ganha com sistemas similares ou em dom\u00ednios similares do \n\nproblema. Definir testes, o padr\u00e3o de arquitetura, os mecanismos chaves, e \n\nmodelar conven\u00e7\u00f5es para o sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Analisar os Casos de Uso \n\n\n\n \n\n  \n\n64 \n\nIdentificar as classes que encadeiam os eventos do fluxo de casos de uso. \n\nDistribuir o comportamento dos casos de uso para aquelas classes, usando as \n\nrealiza\u00e7\u00f5es dos casos de uso. Identificar as responsabilidades, os atributos e as \n\nassocia\u00e7\u00f5es das classes. Anotar o uso de mecanismos arquiteturais \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\nRefinar a Arquitetura \n\n\u2022 Identificar os Mecanismos do Projeto \n\nRefinar os mecanismos da an\u00e1lise do projeto baseado nas restri\u00e7\u00f5es impostas \n\npelo ambiente da execu\u00e7\u00e3o (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Identificar os Elementos do Projeto \n\nAnalisar as intera\u00e7\u00f5es classes de an\u00e1lise para identificar os elementos do \n\nprojeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Incorporar Elementos existentes no Projeto \n\nAnalisar as intera\u00e7\u00f5es das classes de an\u00e1lise para encontrar interfaces, classes \n\ndo projeto e subsistemas do projeto. Refinar a arquitetura, incorporando o \n\nreuso quando poss\u00edvel. Identificar solu\u00e7\u00f5es comuns aos problemas do projeto \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Estruturar o Modelo de Implementa\u00e7\u00e3o \n\nEstabelecer uma estrutura na qual a implementa\u00e7\u00e3o residir\u00e1. Atribuir \n\nresponsabilidades para implementa\u00e7\u00e3o de subsistemas e seus conte\u00fados \n\n(RATIONAL, 2006). \n\n\n\n \n\n  \n\n65 \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Descrever a Arquitetura em Tempo de Funcionamento \n\nAnalisar requisitos concorrentes, identificar processos, identificar mecanismos \n\nde comunica\u00e7\u00e3o inter-process, alocar recursos de coordena\u00e7\u00e3o inter-process, \n\nidentificar ciclo de vida dos processos e distribuir elementos modelo entre os \n\nprocessos (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\nProjetar a Base de Dados \n\n\u2022 Projetar Base de Dados \n\nAssegurar que os dados persistentes sejam armazenados consistentemente e \n\neficientemente. Definir o comportamento que deve ser implementado na base \n\nde dados (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista de Base de Dados. \n\n\u2022 Projetar Classes \n\nAssegurar de que as classes forne\u00e7am o comportamento das realiza\u00e7\u00f5es dos \n\ncasos de uso. Assegurar que as informa\u00e7\u00f5es fornecidas n\u00e3o exer\u00e7am \n\nambig\u00fcidade \u00e0 classe. Capturar os requisitos n\u00e3o-funcionais relacionados \u00e0s \n\nclasses. Incorporar os mecanismos do projeto usados pelas classes \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\nProjetar os Componentes \n\nA tarefa projetar componentes envolve uma s\u00e9rie de outras tarefas que \n\ns\u00e3o necess\u00e1rias para realizar o projeto de componentes de um sistema. Como a \n\nproposta de solu\u00e7\u00e3o envolve o uso de um componente, este item \u00e9 descrito na \n\nfigura a seguir.  \n\n\n\n \n\n  \n\n66 \n\n \n\n \nFigura 12. Workflow da Tarefa Projetar Componentes \nFonte: Adaptado da Rational (2006). \n\nAs atividades que envolvem o projeto de componentes s\u00e3o descritas a \n\nseguir conforme cada tarefa.  \n\nAnalisar o Comportamento \n\n\u2022 Analisar os Casos de Uso \n\nIdentificar as classes que executar\u00e3o os fluxos de eventos dos casos \n\nde uso, distribuir o comportamento dos casos de uso para essas \n\nclasses, usando a realiza\u00e7\u00e3o dos casos de uso. Identificar as \n\nresponsabilidades, atributos e associa\u00e7\u00f5es das classes (RATIONAL, \n\n2006). \n\nRespons\u00e1vel: Projetista. \n\n\n\n \n\n  \n\n67 \n\n\u2022 Identificar os Elementos do Projeto \n\nAnalisar as intera\u00e7\u00f5es da classe de an\u00e1lise para identificar o \n\nelemento modelo do projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Projetar as Interfaces com o Usu\u00e1rio \n\nProduzir um projeto de interface com o usu\u00e1rio que apresente uma \n\nexplica\u00e7\u00e3o sobre o funcionamento do sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista.  \n\n      Projetar os Componentes \n\n\u2022 Projetar Casos de Uso \n\nRefinar a realiza\u00e7\u00e3o dos casos de uso de acordo com as intera\u00e7\u00f5es; \n\nrefinar os requisitos nas opera\u00e7\u00f5es do projeto das classes; refinar os \n\nrequisitos nas opera\u00e7\u00f5es do projeto de subsistemas e/ou suas \n\ninterfaces; refinar os requisitos nas opera\u00e7\u00f5es do projeto de m\u00f3dulos \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\n\u2022 Projetar Classes \n\nAssegurar de que as classes forne\u00e7am o comportamento das \n\nrealiza\u00e7\u00f5es dos casos de uso. Assegurar que as informa\u00e7\u00f5es \n\nfornecidas n\u00e3o exer\u00e7am ambig\u00fcidade a classe. Capturar os requisitos \n\nn\u00e3o-funcionais relacionados \u00e0s classes. Incorporar os mecanismos do \n\nprojeto usados pelas classes (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\n\u2022 Projetar Subsistemas \n\n\n\n \n\n  \n\n68 \n\nDefinir os comportamentos especificados nas interfaces do \n\nsubsistema de acordo com os elementos contidos no projeto e de \n\nsubsistemas/interfaces externos; documentar a estrutura interna do \n\nsubsistema; definir realiza\u00e7\u00f5es entre as interfaces do subsistema e as \n\nclasses contidas; determinar as depend\u00eancias com outros subsistemas \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\n\u2022 Projetar M\u00f3dulos \n\nDefinir e elaborar os tipos de m\u00f3dulos (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\nIntegrar os Componentes \n\n\u2022 Integrar os Subsistemas \n\nIntegrar os elementos em um subsistema, a seguir realizar a \n\nintegra\u00e7\u00e3o do subsistema ao sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\nTestes e Avalia\u00e7\u00f5es \n\n\u2022 Executar os Testes \n\nCriar e executar um ou mais artefatos de teste, que permitam a valida\u00e7\u00e3o do \n\nproduto de software com a execu\u00e7\u00e3o f\u00edsica. Desenvolver os testes que podem \n\nser executados conjuntamente com outros testes como parte de uma infra-\n\nestrutura maior de teste (RATIONAL, 2006). \n\nRespons\u00e1vel: Verificador. \n\nPr\u00f3ximo Plano de Itera\u00e7\u00e3o \n\n\u2022 Desenvolver o Plano de Itera\u00e7\u00e3o \n\n\n\n \n\n  \n\n69 \n\nDesenvolver um refinado plano que busca detalhar os pacotes de trabalho e \n\nseus respectivos respons\u00e1veis, as datas previstas para a entrega e os crit\u00e9rios \n\nque dever\u00e3o ser considerados (RATIONAL, 2006).  \n\nRespons\u00e1vel: Gerente de Projeto. \n\nOs artefatos gerados durante a fase de elabora\u00e7\u00e3o foram Plano de \n\nDesenvolvimento de Software (AP\u00caNDICE A), Plano de Itera\u00e7\u00e3o da Constru\u00e7\u00e3o \n\n(AP\u00caNDICE F), Especifica\u00e7\u00e3o Complementar (AP\u00caNDICE B), Documento de Arquitetura \n\ndo Software (AP\u00caNDICE E), Especifica\u00e7\u00e3o dos Casos de Uso (AP\u00caNDICE D), \n\nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o dos Casos de Uso (AP\u00caNDICE G), Especifica\u00e7\u00e3o dos Requisitos \n\nde Software (AP\u00caNDICE C), Plano de Teste (AP\u00caNDICE I).  \n\n3.3 Constru\u00e7\u00e3o \n\nO objetivo da fase de Constru\u00e7\u00e3o \u00e9 minimizar os custos de desenvolvimento, \n\nevitando o retrabalho, conseguir um produto de boa qualidade e eficiente. Al\u00e9m disso, todo o \n\nsistema deve ser implementado e integrado a um produto de software, a fim de produzir \n\nvers\u00f5es o mais r\u00e1pido poss\u00edvel. Enquanto as fases de Concep\u00e7\u00e3o e Elabora\u00e7\u00e3o t\u00eam um perfil \n\nde pesquisa, esta fase \u00e9 focada na produ\u00e7\u00e3o de software em escala (RATIONAL, 2006).   \n\n\n\n \n\n  \n\n70 \n\n \nFigura 13. Workflow Fase de Constru\u00e7\u00e3o \nFonte: Adaptado da Rational (2006). \n\nAs tarefas executadas na fase de Constru\u00e7\u00e3o foram: \n\nPreparar o Ambiente para a Itera\u00e7\u00e3o \n\n\u2022 Verificar Configura\u00e7\u00e3o e Instala\u00e7\u00e3o de Ferramentas \n\nSelecionar e adquirir as ferramentas necess\u00e1rias para a realiza\u00e7\u00e3o do projeto \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Especialista em Ferramentas. \n\nMonitorar e Controlar o Projeto \n\n\u2022 Monitorar a Situa\u00e7\u00e3o do Projeto \n\n\n\n \n\n  \n\n71 \n\nVerificar a situa\u00e7\u00e3o atual do projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\n\u2022 Planejamento e Designa\u00e7\u00e3o do Trabalho \n\nAcomodar mudan\u00e7as aprovadas (defeitos, realces), ao produto e aos processos, \n\nque se levantam durante uma itera\u00e7\u00e3o (RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\n\u2022 Lidar com Exce\u00e7\u00f5es e Problemas \n\nIniciar a\u00e7\u00f5es corretivas apropriadas aos problemas e exce\u00e7\u00f5es, que s\u00e3o \n\nlevantadas no projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\nGerenciar Mudan\u00e7as de Requisitos \n\n\u2022 Revisar os Requisitos \n\nVerificar formalmente o resultado dos requisitos conforme a customiza\u00e7\u00e3o do \n\nsistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Revisor T\u00e9cnico. \n\n\u2022 Estruturar os Modelos de Casos de Uso \n\nExtrair o comportamento dos casos de uso que necessitam ser considerados \n\ncomo casos de uso abstratos, que devem ser tratados em itera\u00e7\u00f5es anteriores. \n\nEncontrar os novos atores abstratos que definem os pap\u00e9is que s\u00e3o \n\ncompartilhados por diversos atores (RATIONAL, 2006). \n\nRespons\u00e1vel: Analista de Sistema. \n\n\u2022 Gerenciar as Depend\u00eancias \n\nUsar atributos e caracter\u00edsticas dos requisitos do projeto para auxiliar no \n\ngerenciamento do escopo e nas mudan\u00e7as de requisitos que envolvem o projeto \n\n(RATIONAL, 2006). \n\n\n\n \n\n  \n\n72 \n\nRespons\u00e1vel: Analista de Sistema. \n\nImplementar Componentes \n\nA tarefa implementar componentes envolve uma s\u00e9rie de outras tarefas \n\nque s\u00e3o necess\u00e1rias para realizar o projeto de componentes de um sistema. \n\nComo a proposta de solu\u00e7\u00e3o envolve o uso de um componente, este item \u00e9 \n\ndescrito na figura a seguir.  \n\n     \nFigura 14. Workflow da Tarefa Implementar Componentes \nFonte: Adaptado da Rational (2006). \n\nAs atividades que envolvem o projeto de componentes s\u00e3o descritas a \n\nseguir conforme cada tarefa.  \n\n    Analisar o Comportamento \n\n\u2022 Analisar os Casos de Uso \n\n\n\n \n\n  \n\n73 \n\nIdentificar as classes que executar\u00e3o os fluxos de eventos dos casos \n\nde uso, distribuir o comportamento dos casos de uso para essas \n\nclasses, usando a realiza\u00e7\u00e3o dos casos de uso. Identificar as \n\nresponsabilidades, atributos e associa\u00e7\u00f5es das classes (RATIONAL, \n\n2006). \n\nRespons\u00e1vel: Projetista. \n\n\u2022 Identificar os Elementos do Projeto \n\nAnalisar as intera\u00e7\u00f5es da classe de an\u00e1lise para identificar o \n\nelemento modelo do projeto (RATIONAL, 2006). \n\nRespons\u00e1vel: Arquiteto de Software. \n\n\u2022 Projetar as Interfaces com o Usu\u00e1rio \n\nProduzir um projeto de interface com o usu\u00e1rio que apresente uma \n\nexplica\u00e7\u00e3o sobre o funcionamento do sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista.  \n\n               Implementar os Componentes \n\n\u2022 Implementar o Projeto dos Elementos \n\nProduzir uma implementa\u00e7\u00e3o para a parte do projeto (tal como uma \n\nclasse do projeto, subsistema do projeto, ou as realiza\u00e7\u00f5es de caso \n\nde uso), ou para reparar um ou mais defeitos. O resultado \u00e9 o \n\nc\u00f3digo-fonte, ou atualiza\u00e7\u00f5es do mesmo (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Analisar o comportamento da aplica\u00e7\u00e3o em execu\u00e7\u00e3o \n\nEntender o comportamento de um componente durante sua \n\nexecu\u00e7\u00e3o.   Identificar o comportamento anormal e algumas das \n\na\u00e7\u00f5es corretivas que foram solicitadas (RATIONAL, 2006). \n\n\n\n \n\n  \n\n74 \n\nRespons\u00e1vel: Programador. \n\n\u2022 Executar os Elementos de Testabilidade \n\nExecutar funcionalidades especializadas para suportar os requisitos \n\nde teste espec\u00edficos (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Implementar Testes \n\nImplementar um ou mais testes que permitem a valida\u00e7\u00e3o dos \n\ncomponentes de software de forma individual com a execu\u00e7\u00e3o \n\nf\u00edsica.  Desenvolver os testes que podem ser executados \n\nconjuntamente com outros testes como parte de uma infra-estrutura \n\nmaior de teste (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Executar Testes \n\nExecutar a especifica\u00e7\u00e3o de uma unidade.  Verificar a estrutura \n\ninterna de uma unidade (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Rever C\u00f3digo \n\nVerificar a Implementa\u00e7\u00e3o (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022  Planejar a Integra\u00e7\u00e3o do Subsistema \n\nPlanejar a ordem em que os elementos contidos no subsistema \n\ndevem ser integrados (RATIONAL, 2006). \n\n Respons\u00e1vel: Programador.  \n\n              Testes e Avalia\u00e7\u00f5es dos Componentes \n\n\u2022 Implementar o Conjunto de Testes \n\n\n\n \n\n  \n\n75 \n\nMontar um conjunto de testes a serem executados, para capturar a \n\nsitua\u00e7\u00e3o do sistema. Facilitar a largura e a profundidade apropriadas \n\nda cobertura dos testes, exercitando combina\u00e7\u00f5es interessantes \n\ndestes (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Executar o Conjunto de Testes \n\nExecutar o conjunto apropriado de testes requeridos, avaliando a \n\nqualidade do sistema. Capturar os resultados destes testes para \n\nfacilitar avalia\u00e7\u00f5es (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n               Integrar os Componentes \n\n\u2022 Integrar os Subsistemas \n\nIntegrar os elementos em um subsistema. Realizar a integra\u00e7\u00e3o do \n\nsubsistema ao sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Projetista. \n\nTestes e avalia\u00e7\u00f5es \n\n\u2022 Executar os Testes \n\nCriar e executar um ou mais artefatos de teste, que permitam a valida\u00e7\u00e3o do \n\nproduto de software com a execu\u00e7\u00e3o f\u00edsica. Desenvolver os testes que podem \n\nser executados conjuntamente com outros testes como parte de uma infra-\n\nestrutura maior de teste (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\nPr\u00f3ximo Plano de Itera\u00e7\u00e3o \n\n\u2022 Desenvolver Plano de Itera\u00e7\u00e3o \n\n\n\n \n\n  \n\n76 \n\nCriar e aprovar as metas propostas para a itera\u00e7\u00e3o da pr\u00f3xima fase \n\n(RATIONAL, 2006). \n\nRespons\u00e1vel: Gerente de Revis\u00e3o. \n\nOs artefatos gerados durante a fase de constru\u00e7\u00e3o foram Plano de Itera\u00e7\u00e3o \n\nTransi\u00e7\u00e3o (AP\u00caNDICE F), Plano de Desenvolvimento de Software (AP\u00caNDICE A), \n\nEspecifica\u00e7\u00e3o dos Casos de Uso (AP\u00caNDICE D), Plano de Implementa\u00e7\u00e3o(AP\u00caNDICE H), \n\nPlano de Teste (AP\u00caNDICE I). \n\n3.4 Transi\u00e7\u00e3o \n\nO objetivo da fase de Transi\u00e7\u00e3o \u00e9 instalar o software no ambiente do usu\u00e1rio, \n\nexecutar beta testes para validar o sistema em rela\u00e7\u00e3o \u00e0s suas expectativas e treinar os \n\nusu\u00e1rios. Neste momento do ciclo de vida, o usu\u00e1rio deve observar principalmente os ajustes \n\ndo produto configurado, instalado e tamb\u00e9m a quest\u00e3o de usabilidade. Todas as quest\u00f5es \n\nestruturais j\u00e1 foram tratadas nos ciclos de vida anteriores (RATIONAL, 2006).  \n\n\n\n \n\n  \n\n77 \n\n \nFigura 15. Workflow Fase de Transi\u00e7\u00e3o \nFonte: Adaptado da Rational (2006). \n\nAs tarefas executadas na fase de Transi\u00e7\u00e3o foram: \n\nPreparar o Ambiente para a Itera\u00e7\u00e3o \n\n\u2022 Verificar Configura\u00e7\u00e3o e Instala\u00e7\u00e3o de Ferramentas \n\nSelecionar e adquirir as ferramentas necess\u00e1rias para a realiza\u00e7\u00e3o do projeto \n\n(RATIONAL, 2006). \n\n\n\n \n\n  \n\n78 \n\nRespons\u00e1vel: Especialista em Ferramentas. \n\nImplementar Componentes (Defeitos) \n\n\u2022 Rever C\u00f3digo \n\nVerificar a implementa\u00e7\u00e3o e execu\u00e7\u00e3o do sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Analisar o comportamento da aplica\u00e7\u00e3o em execu\u00e7\u00e3o \n\nEntender o comportamento de um componente durante sua execu\u00e7\u00e3o.   \n\nIdentificar o comportamento anormal e algumas das a\u00e7\u00f5es corretivas que foram \n\nsolicitadas (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Executar os Elementos de Testabilidade \n\nExecutar funcionalidades especializadas para suportar os requisitos de testes \n\nespec\u00edficos (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Implementar Testes \n\nImplementar um ou mais testes que permitem a valida\u00e7\u00e3o dos componentes de \n\nsoftware de forma individual com a execu\u00e7\u00e3o f\u00edsica.  Desenvolver os testes que \n\npodem ser executados conjuntamente com outros testes como parte de uma \n\ninfra-estrutura maior de teste (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Executar Testes \n\nExecutar a especifica\u00e7\u00e3o de uma unidade.  Verificar a estrutura interna de uma \n\nunidade (RATIONAL, 2006). \n\nRespons\u00e1vel: Programador. \n\n\u2022 Planejar a Integra\u00e7\u00e3o do Subsistema \n\n\n\n \n\n  \n\n79 \n\nPlanejar a ordem em que os elementos contidos no subsistema devem ser \n\nintegrados (RATIONAL, 2006). \n\n Respons\u00e1vel: Programador.  \n\nTeste e Avalia\u00e7\u00f5es dos Componentes \n\n\u2022 Executar os Testes \n\nExecutar um ou mais artefatos de teste, que permitam a valida\u00e7\u00e3o dos \n\ncomponentes no software. Desenvolver os testes que podem ser executados \n\ncom um ou mais componentes, auxiliando no teste de uma infra-estrutura \n\nmaior do sistema (RATIONAL, 2006). \n\nRespons\u00e1vel: Verificador. \n\nIntegrar ao Sistema \n\n\u2022 Integrar Sistema \n\nIntegrar a implementa\u00e7\u00e3o das partes dos subsistemas no projeto (RATIONAL, \n\n2006). \n\nRespons\u00e1vel: Projetista. \n\nTestes e Avalia\u00e7\u00f5es Finais \n\n\u2022 Executar os Testes \n\nCriar e executar um ou mais artefatos de teste, que permitam a valida\u00e7\u00e3o final \n\ndo produto de software com a execu\u00e7\u00e3o f\u00edsica. Desenvolver os testes que \n\npodem ser executados conjuntamente com outros testes como parte de uma \n\ninfra-estrutura maior de teste (RATIONAL, 2006). \n\nRespons\u00e1vel: Verificador. \n\nDesenvolver Material de Suporte \n\n\u2022 Desenvolver Materiais de Suporte \n\nDesenvolver o material de sustenta\u00e7\u00e3o do usu\u00e1rio final (RATIONAL, 2006).  \n\n\n\n \n\n  \n\n80 \n\nRespons\u00e1vel: Escritor T\u00e9cnico. \n\nFinalizar Projeto \n\n\u2022 Preparar para Finalizar Projeto \n\nTerminar os formul\u00e1rios de aceita\u00e7\u00e3o do projeto, atribuir novas equipes de \n\nfuncion\u00e1rios do projeto e transferir outros recursos do projeto (RATIONAL, \n\n2006). \n\nRespons\u00e1vel: Gerente de Projeto. \n\nOs artefatos gerados durante a fase de transi\u00e7\u00e3o foram Plano de Desenvolvimento \n\nde Software (AP\u00caNDICE A), Plano de Implementa\u00e7\u00e3o (AP\u00caNDICE H), Plano de Teste \n\n(AP\u00caNDICE I). \n\n\n\n \n\n  \n\n81 \n\n4 DESENVOLVIMENTO \n\nO cap\u00edtulo descreve o ambiente tecnol\u00f3gico de desenvolvimento e os \n\nprocedimentos utilizados para a codifica\u00e7\u00e3o do sistema e do componente.  \n\n4.1 Ambiente de Desenvolvimento \n\nO ambiente de desenvolvimento envolve as tecnologias que foram instaladas e \n\nconfiguradas para o desenvolvimento do trabalho. A Figura 16 ilustra o cen\u00e1rio dessas \n\ntecnologias e como elas interagem entre si. \n\n\n\n \n\n  \n\n82 \n\n \nFigura 16. Cen\u00e1rio Tecnol\u00f3gico \n\nA tecnologia IBM RUP foi considerada a linha-mestra do desenvolvimento do \n\nprojeto de software. \u00c9 um processo propriet\u00e1rio de engenharia de software criado pela \n\nRational Software Corporation, adquirida pela IBM tornando-se uma brand na \u00e1rea de \n\nsoftware, fornecendo t\u00e9cnicas a serem seguidas pelos membros da equipe de desenvolvimento \n\nde software com o objetivo de aumentar a sua produtividade. Os artefatos para documenta\u00e7\u00e3o, \n\ndisponibilizados pelo IBM RUP foram capturados e editados no editor de texto Microsoft \n\nWord.  \n\nO Enterprise Architect foi a ferramenta de modelagem que permitiu o \n\ndesenvolvimento da modelagem do sistema e do componente, comprovando a coer\u00eancia \n\nexistente entre a modelagem e o desenvolvimento. \n\nEm rela\u00e7\u00e3o \u00e0s outras tecnologias, \u00e9 feita uma breve descri\u00e7\u00e3o: \n\n\u2022 Apache Tomcat: \u00e9 um servidor de aplica\u00e7\u00f5es Java para web. \u00c9 distribu\u00eddo \n\ncomo software livre e desenvolvido como c\u00f3digo aberto dentro do conceituado \n\nprojeto Apache Jakarta e oficialmente endossado pela Sun como a \n\n\n\n \n\n  \n\n83 \n\nImplementa\u00e7\u00e3o de Refer\u00eancia (RI) para as tecnologias Java Servlet e \n\nJavaServer Pages (JSP). O Tomcat \u00e9 robusto e eficiente o suficiente para ser \n\nutilizado em um ambiente de produ\u00e7\u00e3o (TOMCAT, 2006). \n\n\u2022 Oracle: Banco de dados relacional compat\u00edvel com o padr\u00e3o SQL-ANSI-92. O \n\nacesso \u00e9 feito via JDBC, independente de plataforma. Para poder utiliz\u00e1-lo \u00e9 \n\nnecess\u00e1rio comprar licen\u00e7a. \n\n\u2022 Eclipse: \u00e9 uma IDE open Source distribu\u00edda como um componente principal (o \n\nEclipse SDK) com o ambiente b\u00e1sico, com os recursos fundamentais para \n\ndesenvolvimento Java padr\u00e3o, mais diversos componentes adicionais \n\ndistribu\u00eddos na forma de plug-ins. Estes plug-ins estendem a funcionalidade do \n\nambiente e acrescentam suporte a recursos e tecnologias espec\u00edficos \n\n(ECLIPSE, 2006). \n\n\u2022 Hibernate: \u00e9 um framework de acesso a banco de dados escrito em Java. Ele \u00e9 \n\num software livre de c\u00f3digo aberto distribu\u00eddo. O objetivo do Hibernate \u00e9 \n\nfacilitar a constru\u00e7\u00e3o de aplica\u00e7\u00f5es Java dependentes de bases de dados \n\nrelacionais, particularmente, facilitar o desenvolvimento das consultas e \n\natualiza\u00e7\u00f5es dos dados. O uso de ferramentas de mapeamento objeto \n\nrelacional, como o Hibernate, diminuem a complexidade resultante da \n\nconviv\u00eancia de modelos diferentes; o modelo orientado a objetos (da \n\nlinguagem Java) e o relacional (da maioria dos SGBDs) (HIBERNATE, 2006). \n\n\u2022 Apache Ant: \u00e9 uma ferramenta utilizada para automatizar a constru\u00e7\u00e3o de \n\nsoftware. Ela \u00e9 escrita na linguagem Java e foi desenvolvida inicialmente para \n\nser utilizada em projetos desta linguagem. O Ant utiliza um arquivo no formato \n\nXML para descrever o processo de constru\u00e7\u00e3o (build) e suas depend\u00eancias. Por \n\npadr\u00e3o este arquivo XML tem o nome \u201cbuild.xml\u201d. A ferramenta Ant \u00e9 um \n\n\n\n \n\n  \n\n84 \n\nprojeto da Apache Software Foundation. \u00c9 um software livre, licenciado sob a \n\nlicen\u00e7a Apache (ANT, 2006). \n\n\u2022 Java Server Pages (JSP):  \u00e9 uma tecnologia utilizada no desenvolvimento de \n\naplica\u00e7\u00f5es para web. Por ser baseada na linguagem de programa\u00e7\u00e3o Java ela \n\ntem a vantagem da portabilidade de plataforma, que permite a sua execu\u00e7\u00e3o em \n\noutros sistemas operacionais. Esta tecnologia permite ao desenvolvedor de \n\np\u00e1ginas para Internet produzir aplica\u00e7\u00f5es que, acessam o banco de dados, \n\nmanipulam arquivos no formato texto, captam de informa\u00e7\u00f5es a partir de \n\nformul\u00e1rios e captam informa\u00e7\u00f5es sobre o visitante e sobre o servidor (JAVA, \n\n2006). \n\n\u2022 XML: \u00e9 um subtipo de SGML (Standard Generalized Markup Language - \n\nLinguagem Padronizada de Marca\u00e7\u00e3o Gen\u00e9rica) capaz de descrever diversos \n\ntipos de dados. Seu prop\u00f3sito principal \u00e9 a facilidade de compartilhamento de \n\ninforma\u00e7\u00f5es atrav\u00e9s da Internet(XML, 2006). \n\n\u2022 Servlet: \u00e9 um componente que disponibiliza ao programador da linguagem Java \n\numa interface para o servidor web (ou servidor de aplica\u00e7\u00e3o), atrav\u00e9s de uma \n\nAPI. As aplica\u00e7\u00f5es baseadas no Servlet geram conte\u00fado din\u00e2mico \n\n(normalmente HTML) e interagem com os clientes, utilizando o modelo \n\nrequest/response. Os servlets normalmente utilizam o protocolo HTTP, apesar \n\nde n\u00e3o serem restritos a ele. Um Servlet necessita de um container web para ser \n\nexecutado (JAVA, 2006). \n\n\u2022 Struts: \u00e9 um framework de desenvolvimento da camada controladora, em uma \n\nestrutura seguindo o padr\u00e3o Model 2 (uma variante do MVC oficializada pela \n\nSun), de aplica\u00e7\u00f5es web (principalmente) constru\u00eddo em Java para ser utilizado \n\nem um container web em um servidor J2EE. Este framework foi originalmente \n\n\n\n \n\n  \n\n85 \n\ndesenvolvido por Ted Husted e doado para a Apache Software Foundation, \n\nonde continua sendo desenvolvido segundo o padr\u00e3o desta funda\u00e7\u00e3o \n\n(STRUTS, 2006). \n\n\u2022 JavaScript: \u00e9 uma linguagem de programa\u00e7\u00e3o criada pela Netscape em 1995, \n\nque a princ\u00edpio se chamava LiveScript, para atender, principalmente as \n\nvalida\u00e7\u00e3o de formul\u00e1rios no lado cliente (programa navegador), itera\u00e7\u00e3o com a \n\np\u00e1gina. Assim, foi feita como uma linguagem de script. Javascript tem sintaxe \n\nsemelhante a do Java, mas \u00e9 totalmente diferente no conceito e no uso.  \n\n\u2022 Java: \u00e9 uma linguagem de programa\u00e7\u00e3o orientada a objeto desenvolvida na \n\nd\u00e9cada de 90 pelo programador James Gosling, na empresa Sun Microsystems. \n\nDiferentemente das linguagens convencionais, que s\u00e3o compiladas para c\u00f3digo \n\nnativo, a linguagem Java \u00e9 compilada para um bytecode que \u00e9 executado por \n\numa m\u00e1quina virtual (JAVA, 2006). \n\n\u2022 Microsoft\n\u00ae\n\nInternet Explorer (IExplorer): \u00e9 um navegador de licen\u00e7a \n\npropriet\u00e1ria produzido inicialmente pela Microsoft em 23 de agosto de 1995. \u00c9 \n\nde longe o navegador mais usado atualmente uma vez que \u00e9 distribu\u00eddo em \n\ncada vers\u00e3o do sistema operacional Windows (MICROSOFT, 2006). \n\n4.2 Implementa\u00e7\u00e3o do Sistema Manuten\u00e7\u00e3o \n\nA implementa\u00e7\u00e3o do sistema foi realizada seguindo o processo de \n\ndesenvolvimento do RUP e utilizando os conceitos de modulariza\u00e7\u00e3o. A seq\u00fc\u00eancia de \n\nopera\u00e7\u00f5es t\u00eam como fluxo b\u00e1sico a consulta e a partir desta a realiza\u00e7\u00e3o de cadastro, altera\u00e7\u00e3o  \n\n\n\n \n\n  \n\n86 \n\ne exclus\u00e3o. Os fluxos de eventos de cada transa\u00e7\u00e3o est\u00e3o descritos no ap\u00eandice D. A Figura \n\n17 a seguir demonstra a tela de consulta: \n\n \nFigura 17. Tela de Consulta \n\nPara realizar o cadastro de uma nova informa\u00e7\u00e3o, \u00e9 necess\u00e1rio clicar no bot\u00e3o \n\n\u201cNovo\u201d visualizado na Figura 17, para ent\u00e3o ser aberta a tela demonstrada na figura a seguir: \n\n \nFigura 18. Tela de Cadastro \n\nJ\u00e1 para a altera\u00e7\u00e3o e/ou exclus\u00e3o das informa\u00e7\u00f5es cadastradas no sistema \u00e9 \n\nnecess\u00e1rio selecionar um item, resultado da consulta, atrav\u00e9s de um clique na imagem  para \n\nque esta redirecione para a p\u00e1gina de cadastro preenchida. Assim, a altera\u00e7\u00e3o das informa\u00e7\u00f5es \n\n\u00e9 feita quando o usu\u00e1rio clica no bot\u00e3o \u201cSalvar\u201d e a exclus\u00e3o quando ele clica no bot\u00e3o \n\n\u201cExcluir\u201d. A Figura 19 ilustra essa opera\u00e7\u00e3o:  \n\n \n\n\n\n \n\n  \n\n87 \n\n \nFigura 19. Tela de Edi\u00e7\u00e3o \n\nPara implementa\u00e7\u00e3o fez-se uso das ferramentas Eclipse, Internet Explorer e SQL-\n\nPlus. O Eclipse foi utilizado para escrever o c\u00f3digo-fonte do sistema. Como o sistema \u00e9 web \n\nutilizou-se o Internet Explorer como navegador para fazer as transa\u00e7\u00f5es de consulta, cadastro, \n\naltera\u00e7\u00e3o e exclus\u00e3o. O SQL-Plus foi utilizado para executar os scripts do banco de dados \n\npara a cria\u00e7\u00e3o das tabelas e scripts de consulta \u00e0s tabelas criadas. \n\nAs tecnologias utilizadas no desenvolvimento do sistema foram Tomcat como \n\nservidor da aplica\u00e7\u00e3o, Java como linguagem de programa\u00e7\u00e3o, o Framework Struts para \n\nauxiliar na gera\u00e7\u00e3o das interfaces e a\u00e7\u00f5es da aplica\u00e7\u00e3o web, o JavaScript para fazer algumas \n\nvalida\u00e7\u00f5es, JSP para criar as p\u00e1ginas web, o hibernate para fazer a persist\u00eancia dos dados com \n\no banco de dados e os CSS para criar o estilo das p\u00e1ginas do sistema.   \n\nO sistema possui uma tela de consulta para dados que tem um relacionamento \n\ncom outra tabela. Por exemplo, temos o cadastro de cliente que mora em uma cidade. Essa \n\ncidade \u00e9 cadastrada no banco de dados em uma tabela independente de cliente. O objetivo da \n\ntela \u00e9 buscar atrav\u00e9s de uma consulta as cidades cadastradas para que seja selecionada aquela \n\nque \u00e9 necess\u00e1rio para o cadastro. A Figura 20 demonstra o fluxo: \n\n\n\n \n\n  \n\n88 \n\n \nFigura 20. Tela de Consulta Cidade para o Cliente \n\n \nNa an\u00e1lise realizada na arquitetura descrita no AP\u00caNDICE E, verificou-se que a \n\nfuncionalidade de consulta est\u00e1 bem definida a esse m\u00f3dulo pode ser separado do sistema \n\ntornando-se um componente. Foi ent\u00e3o desenvolvido um componente de consulta e o mesmo \n\n\u00e9 descrito a seguir. \n\n4.3 Implementa\u00e7\u00e3o do Componente LJ \n\nCom o intuito de demonstrar a reutiliza\u00e7\u00e3o criou-se um componente de consulta \n\ngen\u00e9rico. Sabendo que a funcionalidade de consulta \u00e9 realizada em diversas partes do sistema, \n\na redund\u00e2ncia e o tempo de programa\u00e7\u00e3o aumentam significativamente dependendo do \n\ntamanho do sistema, pois quanto mais tabelas, mais consultas ir\u00e3o existir. Dessa forma, com o \n\n\n\n \n\n  \n\n89 \n\naux\u00edlio de um componente que execute essa funcionalidade, a redund\u00e2ncia \u00e9 descartada e o \n\ntempo de implementa\u00e7\u00e3o e entrega do produto s\u00e3o reduzidos. \n\nNa implementa\u00e7\u00e3o do componente fez-se uso das ferramentas: Eclipse, Apache \n\nAnt, Internet Explorer e SQL-Plus. O Eclipse foi utilizado para escrever o c\u00f3digo-fonte. J\u00e1 o \n\nApache Ant para toda a distribui\u00e7\u00e3o do desenvolvimento, tendo em vista que o componente \n\nser\u00e1 utilizado na web. A visualiza\u00e7\u00e3o foi feita no Internet Explorer. Toda a parte de \n\nconectividade e verifica\u00e7\u00e3o do banco de dados foi feita com o aux\u00edlio do SQL-Plus. \n\nAs tecnologias utilizadas foram Tomcat como servidor da aplica\u00e7\u00e3o, Java como \n\nlinguagem de programa\u00e7\u00e3o, Servlets para criar as p\u00e1ginas din\u00e2micas para web, XML para \n\ncria\u00e7\u00e3o do arquivo de defini\u00e7\u00e3o das consultas. \n\nO desenvolvimento foi constitu\u00eddo por quatro etapas principais: \n\n- Cria\u00e7\u00e3o do XML e DTD; \n\n- Cria\u00e7\u00e3o das Classes do Componente; \n\n- Cria\u00e7\u00e3o da P\u00e1gina para Consulta. \n\nA seguir descreve-se com mais detalhes cada uma dessas etapas. \n\n4.3.1 Cria\u00e7\u00e3o do XML e DTD \n\nCom o aux\u00edlio de um documento XML e suas tags de marca\u00e7\u00e3o iniciou-se a \n\ndelimita\u00e7\u00e3o das pesquisas&lt;PESQUISAS>, procurando demarcar o esquema de cada pesquisa \n\n<PESQUISA>. Cada pesquisa cont\u00e9m o nome de sua tabela no banco de dados&lt;NOME>, um \n\nou mais filtros a serem exibidos na tela de consulta&lt;FILTRO>, sendo que cada filtro tem \n\n<TIPO>,&lt;CAMPO_PESQUISA> e&lt;ROTULO_PESQUISA>. A tag&lt;TIPO> serve para \n\n\n\n \n\n  \n\n90 \n\nindicar qual tipo de campo ser\u00e1 consultado (\u201cString\u201d ou \u201cint\u201d). Por sua vez, a tag \n\n<CAMPO_PESQUISA> indica o atributo da tabela do banco de dados que se deseja \n\npesquisar e a tag&lt;ROTULO_PESQUISA> indica o r\u00f3tulo de filtro que o usu\u00e1rio deseja \n\nexibir na tela no momento da consulta. \n\nOs campos a serem exibidos na tela no momento da listagem em cada consulta \n\nser\u00e3o indicados pela tag&lt;EXIBIR> que \u00e9 delimitada para cada coluna de listagem \n\n<COLUNAS>, na qual foi especificado seu&lt;CAMPO> atributo da tabela no banco de dados \n\npara exibir os valores retornados. A tag&lt;ROTULO> indica a descri\u00e7\u00e3o da coluna no \n\nmomento da listagem.  \n\nContudo, antes de fechar a tag&lt;PESQUISA> com&lt;/PESQUISA> no documento \n\nXML, \u00e9 utilizada a tag&lt;CHAVE> para passar o atributo chave da tabela contida na tag \n\n<NOME> e a tag&lt;DESCRICAO_CHAVE> para passar o campo descri\u00e7\u00e3o da mesma tabela. \n\nA seguir uma ilustra\u00e7\u00e3o do XML, mostrando a formata\u00e7\u00e3o para consulta de um \n\nCliente: \n\n\n\n \n\n  \n\n91 \n\n \nFigura 21. Documento XML para Constru\u00e7\u00e3o da Pesquisa \n\nEspecificou-se a Defini\u00e7\u00e3o de Tipo de Documento (DTD), que serve para \n\nespecificar quais elementos ou atributos s\u00e3o permitidos no documento XML e em que local \n\ndo documento eles podem aparecer. Podemos definir, ent\u00e3o, que o DTD \u00e9 uma forma de \n\nvalidar o documento XML. A Figura 22 demonstra o DTD criado para validar as pesquisas. \n\n\n\n \n\n  \n\n92 \n\n \nFigura 22. DTD de Valida\u00e7\u00e3o para as Pesquisas \n\nPara facilitar a configura\u00e7\u00e3o da conex\u00e3o ao banco de dados criou-se ainda, no \n\ndocumento XML a tag&lt;CONEXAO> que cont\u00e9m o usu\u00e1rio&lt;USUARIO>, a senha \n\n<SENHA>, o driver&lt;DRIVER> e o host de conex\u00e3o&lt;CONN>. \n\n \nFigura 23. Dados da Conex\u00e3o ao Banco de Dados no XML  \n\nAp\u00f3s a cria\u00e7\u00e3o e valida\u00e7\u00e3o do XML, \u00e9 necess\u00e1rio realizar a leitura e manipula\u00e7\u00e3o \n\ndos dados nele contidos. Para isso, foram criadas classes que realizam essas fun\u00e7\u00f5es e outras \n\nque s\u00e3o necess\u00e1rias para o funcionamento correto do componente. \n\n\n\n \n\n  \n\n93 \n\n4.3.2 Cria\u00e7\u00e3o das Classes do Componente \n\nUtilizou-se o pacote org.w3c.dom que prov\u00ea uma interface de programa\u00e7\u00e3o \n\npadr\u00e3o para aplica\u00e7\u00f5es que manipulam XML. O pacote transforma um documento XML em \n\numa estrutura de \u00e1rvore na mem\u00f3ria.  \n\nAs classes que utilizam esse pacote s\u00e3o: \u201cLeitorXML.java\u201d e \n\n\u201cLeitorConexao.java\u201d. Assim, logo ap\u00f3s ler o documento XML, a classe \u201cLeitorXML.java\u201d \n\nretorna um objeto Consulta com o aux\u00edlio da classe \u201cConsulta.java\u201d, que cont\u00e9m todos os \n\ndados da pesquisa a ser realizada no banco de dados. J\u00e1 a classe \u201cLeitorConexao.java\u201d retorna \n\num objeto Conexao com o aux\u00edlio da classe \u201cConexao.java\u201d, que possui todos os dados da \n\nconex\u00e3o ao banco de dados.  \n\nAs classes \u201cMontaConsulta.java\u201d, \u201cFrames.java\u201d, \u201cBranco.java\u201d e \n\n\u201cConsultar.java\u201d estendem HttpServlet e s\u00e3o utilizadas para criar a p\u00e1gina de consulta.  \n\nO diagrama de classes utilizado para desenvolver o componente est\u00e1 representado \n\nna Figura 24. \n\n\n\n \n\n  \n\n94 \n\n \nFigura 24. Diagrama  de Classes do Componente \n\n \n \n\nPara realizar a implementa\u00e7\u00e3o das classes, criou-se uma estrutura de pacotes. Isso \n\nfoi feito para separar as classes que possuem funcionalidades semelhantes. Essa estrutura est\u00e1 \n\nrepresentada na Figura 25:  \n\n\n\n \n\n  \n\n95 \n\n \nFigura 25. Pacotes do Componente \n\n4.3.3 Cria\u00e7\u00e3o da P\u00e1gina para Consulta \n\nO componente de consulta \u00e9 invocado com a utiliza\u00e7\u00e3o de uma taglib. A classe \n\n\u201cTagLibLJ.java\u201d gera um campo para descri\u00e7\u00e3o do valor que \u00e9 retornado e um bot\u00e3o para \n\n\u201cchamar\u201d a devida consulta, fazendo a interface entre p\u00e1gina requisitante e o componente de \n\nconsulta. Foi implementada uma TLD para a classe \u201cTagLib.java\u201d, no qual foram criados os \n\npar\u00e2metros que s\u00e3o necess\u00e1rios para a execu\u00e7\u00e3o do componente. A Figura 26 mostra a TLD \n\ngerada para o componente. \n\n\n\n \n\n  \n\n96 \n\n \nFigura 26. TLD com os Par\u00e2metros da Taglib \n\nOs par\u00e2metros da TLD s\u00e3o: o nome da tabela a ser pesquisada, o formul\u00e1rio de \n\nretorno, o campo deste formul\u00e1rio para retornar o elemento, nome do bot\u00e3o e se optar por \n\nmostrar uma imagem \u00e9 poss\u00edvel colocar o caminho da mesma para ser localizada dentro do \n\nprojeto.  \n\nNa p\u00e1gina a taglib \u00e9 chamada atrav\u00e9s de uma diretiva, localizada no topo. A partir \n\ndessa diretiva \u00e9 poss\u00edvel utilizar a tag&lt;componente: ljpesquisa> para fazer a interface entre o \n\ncomponente e a p\u00e1gina requisitante. Dessa forma, com todos os par\u00e2metros preenchidos, a \n\nfuncionalidade pode ser executada, como mostra a Figura 27. \n\n\n\n \n\n  \n\n97 \n\n \nFigura 27. C\u00f3digo JSP utilizando a Taglib sem o Par\u00e2metro \u201cimg\u201d \n\nA p\u00e1gina web gerada com o JSP mostrado acima ficaria dessa forma, destacando o \n\ncampo criado pela taglib: \n\n \nFigura 28. P\u00e1gina demonstrando a Taglib sem o Par\u00e2metro \u201cimg\u201d \n\nA taglib permite que o usu\u00e1rio tenha a op\u00e7\u00e3o de colocar uma imagem de sua \n\nprefer\u00eancia no lugar do bot\u00e3o que \u201cchama\u201d a p\u00e1gina de pesquisa. Para que isso ocorra \u00e9 \n\n\n\n \n\n  \n\n98 \n\nnecess\u00e1rio acrescentar o par\u00e2metro \u201cimg\u201d na tag&lt;componente:ljpesquisa> como mostra a \n\nFigura 29.  \n\n \n\n \nFigura 29. C\u00f3digo JSP utilizando a Taglib com o Par\u00e2metro \u201cimg\u201d \n\nDessa forma a visualiza\u00e7\u00e3o da p\u00e1gina \u00e9 alterada, aparecendo uma imagem para \n\nfazer a interface. A Figura 30 ilustra essa diferen\u00e7a.  \n\n \nFigura 30. P\u00e1gina demonstrando a Taglib com o Par\u00e2metro \u201cimg\u201d \n\n\n\n \n\n  \n\n99 \n\nInternamente, a classe \u201cTaglibLJ.java\u201d gera c\u00f3digo javascript que realiza a \n\nopera\u00e7\u00e3o de abrir uma nova janela popup. Este c\u00f3digo possui um m\u00e9todo chamado \u201cabrir\u201d \n\nque realiza a abertura da janela, al\u00e9m disso, cria um campo para o retorno da descri\u00e7\u00e3o da \n\ninforma\u00e7\u00e3o selecionada na pesquisa e um bot\u00e3o. Esse trecho gerado \u00e9 demonstrado na  Figura \n\n31. \n\n \nFigura 31. Trecho gerado pela Taglib \n\nAp\u00f3s clicar no bot\u00e3o ou imagem abre-se uma p\u00e1gina que \u00e9 montada conforme a \n\ntabela passada como par\u00e2metro, a qual possui os campos para filtrar e os bot\u00f5es de \n\n\u201cPesquisar\u201d e \u201cLimpar\u201d. Depois de preencher um filtro e clicar no bot\u00e3o \u201cPesquisar\u201d a mesma \n\np\u00e1gina retornar\u00e1 uma lista de dados relacionados \u00e0 tabela que est\u00e1 sendo pesquisada. Ao \n\nselecionar uma op\u00e7\u00e3o e clicar no bot\u00e3o \u201cEnviar\u201d as informa\u00e7\u00f5es s\u00e3o enviadas \u00e0 p\u00e1gina \n\nrequisitante e a janela \u00e9 fechada. A seguir \u00e9 ilustrada a p\u00e1gina de pesquisa gerada pelo \n\ncomponente: \n\n\n\n \n\n  \n\n100 \n\n \nFigura 32. P\u00e1gina de Consulta \n\nDurante a execu\u00e7\u00e3o dos procedimentos descritos anteriormente \u00e9 feito a leitura no \n\nXML que resulta no preenchimento do objeto Consulta.  Esse objeto cont\u00e9m os itens da \n\npesquisa que s\u00e3o necess\u00e1rios para montar a p\u00e1gina com o aux\u00edlio do Servlet. Os filtros da \n\np\u00e1gina, montados a partir da configura\u00e7\u00e3o no XML, s\u00e3o utilizados para montar o SQL \n\nautomaticamente e fazer a consulta ao banco de dados. Da mesma forma, os campos que s\u00e3o \n\nretornados da execu\u00e7\u00e3o do SQL tamb\u00e9m s\u00e3o configurados, assim como a descri\u00e7\u00e3o dos \n\nr\u00f3tulos. \n\nContudo, o Componente LJ no formato Java Archive (JAR) permite que o mesmo \n\nseja utilizado em qualquer parte da aplica\u00e7\u00e3o. Assim, o componente deve estar localizado \n\ndentro do diret\u00f3rio \u201clib\u201d e seus arquivos de configura\u00e7\u00e3o (XML, TLD e DTD) devem estar \n\npresentes no diret\u00f3rio \u201cWEB-INF\u201d do projeto que faz uso do componente.  A Figura 33 \n\ndemonstra o local onde devem ser colocados esses arquivos. \n\n\n\n \n\n  \n\n101 \n\n \nFigura 33. Localiza\u00e7\u00e3o do JAR e respectivos Arquivos de Configura\u00e7\u00e3o \n\nA partir desse momento, com a implementa\u00e7\u00e3o pronta, testada e documentada, o \n\npr\u00f3ximo passo \u00e9 validar para demonstrar os resultados obtidos. \n\n \n \n\n\n\n \n\n  \n\n102 \n\n5 VALIDA\u00c7\u00c3O \n\nEste cap\u00edtulo busca descrever o procedimento utilizado para validar os objetivos \n\ndo trabalho. Al\u00e9m disso, s\u00e3o descritos os resultados obtidos e uma an\u00e1lise t\u00e9cnica dos \n\nobjetivos que possuem uma abordagem pr\u00e1tica, finalizando com uma recomenda\u00e7\u00e3o de uso. \n\nOs objetivos mais gerais referentes ao estudo para aprofundar os conhecimentos \n\nn\u00e3o foram abordados na valida\u00e7\u00e3o, pois esses s\u00e3o utilizados durante todo o desenvolvimento \n\nprojeto.  \n\nEm rela\u00e7\u00e3o aos objetivos que dizem respeito \u00e0 an\u00e1lise, projeto e implementa\u00e7\u00e3o \n\ndo sistema e do componente, estes s\u00e3o validados a partir dos seguintes crit\u00e9rios: quanto ao \n\nc\u00f3digo-fonte, coes\u00e3o, acoplamento, tempo de desenvolvimento, tamanho da aplica\u00e7\u00e3o e \n\nreutiliza\u00e7\u00e3o.  \n\nA grande maioria dos sistemas de software faz uso de consultas. Esta \n\nfuncionalidade \u00e9 bastante comum e foi utilizada como ponto de refer\u00eancia em toda a \n\nvalida\u00e7\u00e3o. \n\nDurante a an\u00e1lise do sistema Manuten\u00e7\u00e3o verificou-se a exist\u00eancia de uma s\u00e9rie \n\nde consultas que se prop\u00f5e a fazer determinadas regras de neg\u00f3cio com funcionalidades \n\nsemelhantes. Estas regras de neg\u00f3cio resumem-se em realizar consultas em determinadas \n\ntabelas em um banco de dados para preencher um campo que est\u00e1 relacionado com outras \n\n\n\n \n\n  \n\n103 \n\ntabelas. A Figura 34 demonstra os dados a serem consultados e seus relacionamentos atrav\u00e9s \n\nde um modelo de entidade-relacionamento. \n\n \nFigura 34. Demonstra\u00e7\u00e3o do Diagrama Entidade e Relacionamento \n\nComo mostra o diagrama ER, a implementa\u00e7\u00e3o da funcionalidade de consulta \n\ngera redund\u00e2ncia no c\u00f3digo-fonte devido a sua repeti\u00e7\u00e3o, mesmo que os dados sejam de \n\norigens diferentes. Como foi estudado, os conceitos de modulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o \n\ndemonstram e/ou sugerem a possibilidade de desenvolver um componente que realize essa \n\nfuncionalidade e diminua a redund\u00e2ncia. Segundo Bezerra (2002, p. 243) \u201cum componente \u00e9 \n\numa unidade de software que pode ser utilizada na constru\u00e7\u00e3o de v\u00e1rios sistemas e que pode \n\nser substitu\u00edda por uma unidade que tenha a mesma funcionalidade\u201d. \n\nSegue abaixo a descri\u00e7\u00e3o de cada crit\u00e9rio utilizado: \n\n1. Quanto ao c\u00f3digo-fonte \n\nForam realizadas compara\u00e7\u00f5es quanto \u00e0 quantidade de linhas do c\u00f3digo-fonte na \n\ncodifica\u00e7\u00e3o das consultas utilizando o componente e nas consultas implementadas dentro do \n\nsistema Manuten\u00e7\u00e3o. Essa compara\u00e7\u00e3o permitiu perceber que n\u00e3o houve uma redu\u00e7\u00e3o \n\n\n\n \n\n  \n\n104 \n\nsignificativa de linhas e isso aconteceu porque o sistema foi desenvolvido com poucas \n\nconsultas como mostra a Figura 35.  \n\nsd Diagrama de Interface\n\nIndex\n\nljConCidade ljConCliente ljConEstado\nljConPais\n\njlCadCidade ljCadEstado ljCadPaisljCadCliente\n\njlEstadoSearch\n\nljPaisSearch\nljCidadeSearch\n\n \nFigura 35. Diagrama de Interfaces do Sistema Manuten\u00e7\u00e3o com as Consultas Internas \n\nNo entanto, se simularmos o uso do componente em um sistema maior e mais \n\ncomplexo, a redu\u00e7\u00e3o de linhas de c\u00f3digo \u00e9 significativa, pois todas as funcionalidades da \n\nconsulta s\u00e3o implementadas somente uma vez e n\u00e3o de forma repetitiva como acontece \n\nquando a implementa\u00e7\u00e3o ocorre dentro do sistema. O diagrama de interface abaixo demonstra \n\na utiliza\u00e7\u00e3o do componente no sistema. \n\n\n\n \n\n  \n\n105 \n\ncd Diagrama de Interface - Componente\n\nIndex\n\njlCadCidade\n\nljCadCliente ljCadEstado\n\nljCadPais\n\nljConCidade\n\nljConCliente\n\nljConEstado\n\nljConPais\n\nComponente LJ\n\n \nFigura 36. Diagrama de Interfaces Utilizando o Componente para fazer as Consultas \n\nPara dar uma abordagem cient\u00edfica \u00e0 esse crit\u00e9rio utilizou-se a m\u00e9trica Lines of \n\nCode (LOC). Segundo Peters (2001, p. 433) \u201cLOC \u00e9 a forma mais dominante na classe de \n\nmedidas de software orientadas ao tamanho\u201d. Com o aux\u00edlio dessa m\u00e9trica analisou-se as \n\nlinhas de c\u00f3digo do sistema, o que resultou no quadro abaixo: \n\n\n\n \n\n  \n\n106 \n\nQuadro 3. M\u00e9trica de Linha de C\u00f3digo \n \n\nSISTEMA \n \n\nM\u00c9TRICAS \nSEM \n\nCOMPONENTE \nCOM \n\nCOMPONENTE \n\nLOC \nN\u00famero de Linhas de C\u00f3digo \n\n3.517 2.986 \n\n  \n\n2. Quanto a Coes\u00e3o \n\nO sistema Manuten\u00e7\u00e3o foi desenvolvido utilizando os conceitos da orienta\u00e7\u00e3o a \n\nobjeto que pregam naturalmente a modulariza\u00e7\u00e3o. No sistema, cada m\u00e9todo implementado \n\nrealiza somente uma fun\u00e7\u00e3o, assim como no componente.  \n\nAo utilizar o componente no sistema nenhuma regra de neg\u00f3cio necessita ser \n\nalterada, pois \u00e9 o componente que se adapta para atender estas regras. Com isto esta parte do \n\nsistema se torna independente do restante executando uma atividade espec\u00edfica, resultando em \n\num alto n\u00edvel de coes\u00e3o. \n\n3. Quanto ao acoplamento \n\nO acoplamento do sistema Manuten\u00e7\u00e3o ao Componente LJ \u00e9 de n\u00edvel baixo. Isso \n\npode ser comprovado pela quantidade m\u00ednima de par\u00e2metros para sua utiliza\u00e7\u00e3o. A \n\nquantidade de par\u00e2metros foi reduzida ao m\u00e1ximo para que se por ventura ocorrer alguma \n\naltera\u00e7\u00e3o, a mesma afete o m\u00ednimo poss\u00edvel o sistema.  \n\n4. Quanto ao tempo de desenvolvimento \n\nDurante a implementa\u00e7\u00e3o do sistema e do componente foi medido, para ambos, o \n\ntempo de seu desenvolvimento. A codifica\u00e7\u00e3o do sistema com as consultas internas ocorreram \n\nem um curto espa\u00e7o de tempo se comparado ao componente que levou tr\u00eas vezes mais. Essa \n\ndiferen\u00e7a se justifica pelo fato de que para implementar o componente foi necess\u00e1rio \n\nprimeiramente estudar as tecnologias envolvidas, para s\u00f3 ent\u00e3o iniciar seu desenvolvimento.  \n\n\n\n \n\n  \n\n107 \n\nA partir disso, sugere-se a necessidade de realizar uma an\u00e1lise aprofundada - \n\ntempo, pessoas capacitadas e tecnologias dispon\u00edveis - antes de desenvolver componentes. \u00c9 \n\nimportante tamb\u00e9m considerar se o componente ser\u00e1 reutilizado em outras partes do sistema \n\ne/ou em outros projetos para n\u00e3o desperdi\u00e7ar os recursos que seriam empregados no seu \n\ndesenvolvimento. \n\n5. Quanto ao tamanho da aplica\u00e7\u00e3o \n\nChegou-se a conclus\u00e3o que os ganhos ao utilizar um componente com uma \n\nfuncionalidade espec\u00edfica ser\u00e1 sempre de 1: n. Onde teremos 1 (um) componente para n partes \n\nde um sistema e/ou projetos, independente do seu tamanho.  \n\nNo caso do sistema e do componente desenvolvidos fez-se uso da m\u00e9trica \n\nVocabulary Size (VS), que segundo Figueiredo (2005) \u00e9 para avaliar o tamanho do sistema em \n\ntermos de n\u00famero de classes ou interfaces. Os resultados obtidos s\u00e3o demonstrados no \n\nQuadro 4. \n\nQuadro 4. M\u00e9trica de Tamanho do Vocabul\u00e1rio \n \n\nSISTEMA \n \n\nM\u00c9TRICAS \nSEM \n\nCOMPONENTE \nCOM \n\nCOMPONENTE \n\nVS \nTamanho do Vocabul\u00e1rio \n\n \n38 classes \n\nou \n12 interfaces \n\n \n\n34 classes \nou \n\n9 interfaces \n\n \n\n6. Quanto a reutiliza\u00e7\u00e3o \n\nA reutiliza\u00e7\u00e3o \u00e9 muito grande se o sistema utilizar o componente para realizar as \n\nconsultas. No entanto, se essa funcionalidade for implementada dentro da aplica\u00e7\u00e3o, a mesma \n\nir\u00e1 se repetir infinitas vezes interferindo no reuso de c\u00f3digo, j\u00e1 que copiar e colar n\u00e3o \u00e9 \n\nreutilizar.   \n\n\n\n \n\n  \n\n108 \n\nAssim, como recomenda\u00e7\u00e3o de uso, prop\u00f5e-se utilizar as t\u00e9cnicas abordadas neste \n\ntrabalho, pois como foi mostrado em toda a valida\u00e7\u00e3o h\u00e1 um ganho consider\u00e1vel. No entanto, \n\n\u00e9 importante lembrar as pessoas, que v\u00e3o iniciar seus projetos utilizando essas pr\u00e1ticas, que o \n\ntempo de desenvolvimento aumenta e que \u00e9 necess\u00e1rio investimentos em m\u00e3o-de-obra, \n\ntreinamento e tecnologias. Com certeza os resultados v\u00e3o compensar esse esfor\u00e7o inicial e o \n\nproduto final ser\u00e1 de qualidade. O tempo de desenvolvimento ser\u00e1 reduzido com os m\u00f3dulos, \n\ncomponentes e at\u00e9 frameworks reutiliz\u00e1veis que estar\u00e3o dispon\u00edveis para serem usados a \n\nqualquer momento. \n\n\n\n \n\n  \n\n109 \n\n6 CONCLUS\u00c3O \n\nA aplica\u00e7\u00e3o da ci\u00eancia da computa\u00e7\u00e3o foi fundamental para o desenvolvimento do \n\ntrabalho. Os objetivos tra\u00e7ados foram alcan\u00e7ados e os resultados est\u00e3o descritos no cap\u00edtulo \n\nde valida\u00e7\u00e3o. No entanto, alguns itens referentes \u00e0 arquitetura de software tiveram o seu \n\ndesenvolvimento prejudicado, pois durante a realiza\u00e7\u00e3o do curso n\u00e3o houve disciplinas que \n\nabordassem o assunto com maior profundidade.  Al\u00e9m disso, os livros abordam esse assunto \n\nde forma totalmente te\u00f3rica, sem exemplos pr\u00e1ticos de como \u00e9 modelada e implementada. \n\nIsso dificultou a visualiza\u00e7\u00e3o atrav\u00e9s de modelos, de uma arquitetura que aplica as t\u00e9cnicas de \n\nmodulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o. O resultado foi um modelo de arquitetura de software sem \n\num modelo de referencia, mas que demonstrou o objetivo do trabalho. \n\nJ\u00e1 o processo de desenvolvimento RUP utilizado em todo o desenvolvimento do \n\nsistema e do componente foi muito importante, pois permitiu o acompanhamento de todas as \n\nfases do desenvolvimento e facilitou o entendimento de algumas atividades que n\u00e3o s\u00e3o \n\ncomuns no dia-a-dia. Aliado a isso, a utiliza\u00e7\u00e3o das t\u00e9cnicas de modulariza\u00e7\u00e3o e \n\ncomponentiza\u00e7\u00e3o mostraram novas maneiras de analisar e desenvolver sistemas com o \n\nobjetivo de reutilizar a maior quantidade de c\u00f3digo poss\u00edvel. Al\u00e9m disso, observou-se a \n\nimport\u00e2ncia de manter alto grau de coes\u00e3o e baixo acoplamento em rela\u00e7\u00e3o a componentes, \n\n\n\n \n\n  \n\n110 \n\nm\u00f3dulos e frameworks reutiliz\u00e1veis para que os sistemas, que venham a utiliz\u00e1-los, tenham o \n\nm\u00ednimo de altera\u00e7\u00f5es.   \n\nEm rela\u00e7\u00e3o aos outros assuntos abordados, a bibliografia comp\u00f5e-se de autores \n\nque demonstram claramente como a modulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o s\u00e3o importantes, \n\ndescrevendo como e onde essas pr\u00e1ticas devem ser utilizadas para que se consiga bons \n\nresultados. \n\nDurante o desenvolvimento do sistema e do componente tivemos dificuldades por \n\nn\u00e3o dominarmos algumas tecnologias que foram utilizadas. No entanto, com o decorrer da \n\nimplementa\u00e7\u00e3o essas d\u00favidas foram sanadas, principalmente em rela\u00e7\u00e3o \u00e0 codifica\u00e7\u00e3o do \n\ncomponente, pois t\u00ednhamos um conhecimento b\u00e1sico de XML. \n\nFazer este trabalho foi muito importante para nosso crescimento pessoal e \n\nprofissional, pois permitiu conhecer e empregar conceitos e t\u00e9cnicas pouco utilizadas no \n\ndesenvolvimento de sistema de software. A aplica\u00e7\u00e3o de uma metodologia de \n\ndesenvolvimento mostrou o qu\u00e3o fundamental s\u00e3o as atividades que antecedem a \n\nimplementa\u00e7\u00e3o do produto de software, j\u00e1 que no dia-a-dia essa pr\u00e1tica \u00e9 pouco utilizada. \n\nPara n\u00f3s foi um grande desafio, mas com muito trabalho e esfor\u00e7o chegamos ao nosso \n\nobjetivo. Vemos isso como uma vit\u00f3ria pessoal e principalmente profissional, pois \u00e9 no \n\nmercado de trabalho que isso realmente vai fazer diferen\u00e7a. \n\nDessa forma, para as pessoas que tiverem o interesse de conhecer mais sobre as \n\nt\u00e9cnicas de modulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o dentro da arquitetura de software, sugerimos \n\nque estudem autores como STAA (2000), PRESSMAN (1995), MENDES (2002), al\u00e9m de \n\noutros que abordam conte\u00fados a respeito de engenharia de software e arquitetura de software.  \n\nEm rela\u00e7\u00e3o \u00e0 arquitetura de software, \u00e9 dif\u00edcil de encontrar livros que abordam esse assunto \n\ncom profundidade, mas os livros que existem d\u00e3o suporte para iniciar nessa pr\u00e1tica.  \n\n\n\n \n\n  \n\n111 \n\nPretendemos para trabalhos futuros, primeiramente utilizar a monografia para \n\npublicar um artigo sobre a utiliza\u00e7\u00e3o da modulariza\u00e7\u00e3o e componentiza\u00e7\u00e3o num projeto de \n\nsoftware. Al\u00e9m disso, fazer uma p\u00f3s-gradua\u00e7\u00e3o em uma das \u00e1reas abordadas neste projeto, \n\npara aprofundar os conhecimentos adquiridos. \n\nContudo, a monografia permitiu, para n\u00f3s orientandos, ter uma nova vis\u00e3o sobre \n\ncomo desenvolver sistemas, valorizar a reutiliza\u00e7\u00e3o durante os processo de desenvolvimento \n\npara reduzir os custos e evitar que a manuten\u00e7\u00e3o se torne um problema por causa da \n\nredund\u00e2ncia de c\u00f3digo-fonte.  \n\n\n\n \n\n  \n\n112 \n\nREFER\u00caNCIAS \n\nALLEN, Paul; BAMBARA, Joseph. Sun Certified Enterprise Architect for J2EE: guia \noficial de certifica\u00e7\u00e3o. Rio de Janeiro: Campus, 2003. 613 p.  \n \n \nANT. Apache Ant. The Apache Ant Project. Dispon\u00edvel em:&lt;http://www.ant.apache.org>. \nAcesso em: 20 ago. 2006  \n \n \nBEZERRA, Eduardo. Princ\u00edpios de An\u00e1lise e Projeto de Sistemas com UML. Rio de \nJaneiro: Campus, 2002. 286 p. \n \n \nBOOCH, Grady; RUMBAUGH, James; JACOBSON, Ivar. UML: Guia do Usu\u00e1rio. Rio de \nJaneiro: Campus, 2000. 472 p. \n \n \nDENNIS, Alan; WIXON, Barbara Haley. An\u00e1lise e Projeto de Sistemas. 2 ed. Rio de \nJaneiro: LTC, 2005. 484 p. \n \n\nECLIPSE. Eclipse IDE. Eclipse Foundation Inc. Dispon\u00edvel em:&lt;http://www.eclipse.org>. \nAcesso em: 20 ago. 2006  \n \n \nFIGUEIREDO, Eduardo Magno Lages; STAA, Arndt von. Avalia\u00e7\u00e3o de um Modelo de \nQualidade para Implementa\u00e7\u00f5es Orientadas a Objetos e Orientadas a Aspectos. Pont\u00edficia \nUniversidade Cat\u00f3lica do Rio de Janeiro. Rio de Janeiro, 2005. n.14/05. 29 p.  \n \n \nHIBERNATE. Relacional Persistence for Java and .NET. Dispon\u00edvel em: \n<http://www.hibernate.org>. Acesso em: 20 ago. 2006. \n \n \nHUSTED, Ted et al. Struts em A\u00e7\u00e3o. Rio de Janeiro: Editora Ci\u00eancia Moderna Ltda, 2004. \n604 p. \n\n\n\n \n\n  \n\n113 \n\n \n \nJAVA. Sun Developer Network. Dispon\u00edvel em:&lt;http://www.java.sun.com>. Acesso em: 20 \nago. 2006. \n \n \nLARMAN, Craig. Utilizando UML e padr\u00f5es: Uma introdu\u00e7\u00e3o \u00e0 an\u00e1lise e ao projeto \norientado a objetos. Porto Alegre: Bookman, 2000. 491 p.  \n \n \nLEITE, J. C. Engenharia de Requisitos: Notas de Aula. Rio de Janeiro: PUC-RJ, 1994. \n \n \nMENDES, Antonio. Arquitetura de Software: desenvolvimento orientado para arquitetura. \nRio de Janeiro: Campus, 2002. 212 p. \n \n \nMICROSOFT. Microsoft Internet Explorer. Dispon\u00edvel em: \n<http://www.microsoft.com/brasil/windows/ie/default.mspx>. Acesso em: 20 ago. 2006. \n \n \nPAGE-JONES, Meilir. Fundamentos do Desenho Orientado a Objeto com UML. S\u00e3o \nPaulo: Makron Books, 2001. 462 p. \n \n  \nPETERS, James F.; PEDRYCZ, Witold. Engenharia de Software: teoria e pr\u00e1tica. Rio de \nJaneiro: Campus, 2001. 602 p. \n \n \nPRESSMAN, Roger S. Engenharia de Software. 1 ed. S\u00e3o Paulo: Makron Books, 1995. \n1056 p. \n \n \nRATIONAL. IBM Rational Unified Process \u2013 RUP. Sistema de Metodologia de \nDesenvolvimento. Estados Unidos da Am\u00e9rica: Rational, 2006. Dispon\u00edvel em: \nhttp://www.ibm.com/br/products/software/rational/rup.phtml. \n \n \nSANCHES, Rosely. Subprogramas, fun\u00e7\u00f5es e procedimentos. Desenvolvido pela \nUniversidade Federal da Bahia. Dispon\u00edvel em: \n<http://twiki.im.ufba.br/pub/MAT146/TodoMaterial/slides-aula-funcoes.pdf>. Acesso em: 09 \nmar. 2006.  \n \n \nSILVA, Edna L\u00facia da; MENEZES, Estera Muszkat. Metodologia da pesquisa e elabora\u00e7\u00e3o \nde disserta\u00e7\u00e3o. 4 ed. Florian\u00f3polis: UFSC, 2005. \n \n \nSOMMERVILLE, Ian. Engenharia de Software. 6 ed. S\u00e3o Paulo: Addison Wesley, 2003. \n592 p. \n\n\n\n \n\n  \n\n114 \n\n \n \nSTAA, Arndt von. Programa\u00e7\u00e3o Modular: desenvolvendo programas complexos de forma \norganizada e segura. Rio de Janeiro: Campus, 2000. 690 p.    \n \n \nSTRUTS. Struts Framework. The Apache Software Foundation. Dispon\u00edvel em: \n<http://struts.apache.org/>. Acesso em: 20 ago. 2006. \n \n \nTOMCAT. Apache Tomcat. Container Web. The Apache Software Foundation. Dispon\u00edvel \nem:&lt;http://www.tomcat.apache.org>. Acesso em: 20 ago. 2006  \n \n \nTONSIG, S\u00e9rgio Luiz. Engenharia de Software: An\u00e1lise e Projeto de Sistemas. S\u00e3o Paulo: \nFutura, 2003. 351 p. \n \n \nVAROTO. Ane Cristina. Vis\u00f5es em Arquitetura de Software. 2002. 108 f. Disserta\u00e7\u00e3o \n(Mestrado em Ci\u00eancia da Computa\u00e7\u00e3o) \u2013 Universidade de S\u00e3o Paulo, S\u00e3o Paulo. Dispon\u00edvel \nem:&lt;www.ime.usp.br/dcc/posgrad/teses/ane.pdf >. Acesso em: 10 abr. 2006. \n \n \nXML. Extensible Markup Language. Dispon\u00edvel em:&lt;http://www.w3.org/XML>. Acesso \nem: 20 ago. 2006.  \n \n\n\n\n \n\n  \n\n115 \n\nAP\u00caNDICES \n\n\n\n \n\n  \n\n116 \n\n \n\n \n\n \n\n \n\nAP\u00caNDICE A \u2013 Artefato do RUP de Plano de Desenvolvimento de Software \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Project Management - Ger\u00eancia do Projeto \n\nPapel: Project Manager - Gerente do Projeto \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nSoftware Developent Plan (Small Project) \n\nPlano de Desenvolvimento de Software (Pequenos Projetos) \n \n\nVers\u00e3o 1.2 \n \n\n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:   1.2 \nSoftware Developent Plan (Small Project) Data de Cria\u00e7\u00e3o: 30-mai-2006 \nArquivo: A \u2013 Plano de Desenvolvimento de Software (Pequenos Projetos).doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 6 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n30/05/2006 1.0 Processo inicial do projeto  Luciane e Jefferson \n\n20/08/2006 1.1 Revis\u00e3o da fase de Elabora\u00e7\u00e3o  Luciane Pires Werlang \n\n05/11/2006 1.2 Revis\u00e3o final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:   1.2 \nSoftware Developent Plan (Small Project) Data de Cria\u00e7\u00e3o: 30-mai-2006 \nArquivo: A \u2013 Plano de Desenvolvimento de Software (Pequenos Projetos).doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 6 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Escopo 4 \n1.3 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es 4 \n1.4 Vis\u00e3o Geral 4 \n\n2. Vis\u00e3o Geral do Projeto 4 \n2.1 Prop\u00f3sito do Projeto, Escopo e Objetivos 4 \n2.2 Suposi\u00e7\u00f5es e Restri\u00e7\u00f5es 5 \n2.3 Objetos De Entrega do Projeto 5 \n2.4 Evolu\u00e7\u00e3o do Software Development Plan (Plano de Desenvolvimento de Software) 5 \n\n3. Organiza\u00e7\u00e3o do Projeto 5 \n3.1 Estrutura Organizacional 5 \n3.2 Roles (Pap\u00e9is) e Responsabilidades 5 \n\n4. Processo de Gerenciamento 5 \n4.1 Estimativas do Projeto 5 \n4.2 Plano de Projeto 5 \n\n4.2.1 Planejamento da Fase 5 \n4.2.2 Objetivos das Itera\u00e7\u00f5es 6 \n4.2.3 Libera\u00e7\u00f5es 6 \n4.2.4 Cronograma do Projeto 6 \n4.2.5 Recursos do Projeto 6 \n\n4.3 Monitoramento de Projeto e Controle 6 \n\n5. Anexos 6 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:   1.2 \nSoftware Developent Plan (Small Project) Data de Cria\u00e7\u00e3o: 30-mai-2006 \nArquivo: A \u2013 Plano de Desenvolvimento de Software (Pequenos Projetos).doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 6 \n\n \n\nSoftware Development Plan (Small Project) \nPlano de Desenvolvimento de Software (Pequenos Projetos) \n\n1. Introdu\u00e7\u00e3o \n\nO Plano de Desenvolvimento de Software \u00e9 um documento completo, composto de artefatos que \nre\u00fanem as informa\u00e7\u00f5es necess\u00e1rias para gerenciar um projeto.  \n\n1.1 Objetivo \n\nO objetivo do Software Development Plan (Plano de Desenvolvimento de Software) \u00e9 reunir as \ninforma\u00e7\u00f5es necess\u00e1rias para controlar o projeto. Al\u00e9m disso, \u00e9 um plano de alto n\u00edvel que descreve a \nabordagem utilizada para o desenvolvimento do software. \n\nAs pessoas descritas a seguir usam o Software Development Plan (Plano de Desenvolvimento de \nSoftware): \n\n\u2022 O project manager (gerente de projeto) usa este documento para construir o planejamento do \nprojeto e os recursos necess\u00e1rios, e para seguir o planejamento sem atraso.  \n\n\u2022 Project team members (Membros da equipe de Projeto) usam o mesmo para entender o que \neles precisam fazer, quando eles precisam fazer isso, e outras atividades que est\u00e3o sob sua \nresponsabilidade. \n\n1.2 Escopo \n\nEste Software Development Plan (Plano de Desenvolvimento de Software) descreve todo o plano a ser \nusado pelo Projeto Component Search. Os detalhes das itera\u00e7\u00f5es individuais ser\u00e3o descritos nos \nIteration Plans (Planos de Itera\u00e7\u00e3o).  \n\nOs requisitos do sistema ser\u00e3o descritos no Software Requirements Specification (Especifica\u00e7\u00e3o de \nRequisitos de Software). Por outro lado, os detalhes de Arquitetura ser\u00e3o descritos no Software \nArchitecture Document (Documento de Arquitetura de Software). \n\nComo o projeto \u00e9 focado nos componentes, existir\u00e3o documentos espec\u00edficos para descrev\u00ea-los.    \n\n1.3 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n1.4 Vis\u00e3o Geral \n\nEste Software Development Plan (Plano de Desenvolvimento de Software) cont\u00e9m as seguintes \ninforma\u00e7\u00f5es: \n\nVis\u00e3o Geral do Projeto \u2014 fornece uma descri\u00e7\u00e3o do prop\u00f3sito do projeto, escopo, e objetivos.  Este \ntamb\u00e9m define quando as entregas do projeto s\u00e3o esperadas para ocorrer. \n\nOrganiza\u00e7\u00e3o de Projeto \u2014 descreve a estrutura organizacional da equipe do projeto. \n\nProcesso de Gerenciamento \u2014 explica o custo estimado e o planejamento, define as principais fases e \nos milestones (marcos) para o projeto, e descreve como o projeto ser\u00e1 monitorado. \n\n2. Vis\u00e3o Geral do Projeto \n\n2.1 Prop\u00f3sito do Projeto, Escopo e Objetivos \n\nDesenvolver um sistema de controle de clientes por estado e cidade, sendo que as consultas ser\u00e3o \nrealizadas da maneira tradicional e tamb\u00e9m atrav\u00e9s de um componente. Esse componente ser\u00e1 \nimplemetado em linguagem de desenvolvimento JAVA e XML para uso gen\u00e9rico, tendo como \nprincipal caracter\u00edstica o reuso de software.   \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:   1.2 \nSoftware Developent Plan (Small Project) Data de Cria\u00e7\u00e3o: 30-mai-2006 \nArquivo: A \u2013 Plano de Desenvolvimento de Software (Pequenos Projetos).doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 6 \n\n \n\n2.2 Suposi\u00e7\u00f5es e Restri\u00e7\u00f5es \n\nO desenvolvimento do sistema tem como linguagem de desenvolvimento JAVA, baseado na \narquitetura MVC e Struts. \nO componente \u00e9 desenvolvido em JAVA e XML, sua liga\u00e7\u00e3o com o prot\u00f3tipo \u00e9 feito atrav\u00e9s do uso de \nTagLib. \nA equipe de desenvolvimento \u00e9 composta somente por dois integrantes. \nN\u00e3o teremos or\u00e7amento externo para desenvolver o sistema, pois o or\u00e7amento para o seu \ndesenvolvimento \u00e9 pequeno. \n\n2.3 Objetos De Entrega do Projeto \n\nOs itens entregues ser\u00e3o CD contendo o c\u00f3digo fonte, o arquivo execut\u00e1vel e a documenta\u00e7\u00e3o do \nsistema e do componente. \n\n2.4 Evolu\u00e7\u00e3o do Software Development Plan (Plano de Desenvolvimento de Software) \n\nO Software Development Plan (Plano de Desenvolvimento de Software) \u00e9 revisado antes do in\u00edcio de \ncada Iteration Phase (Fase de Itera\u00e7\u00e3o). \n\n3. Organiza\u00e7\u00e3o do Projeto \n\nNeste item s\u00e3o descritas a estrutura organizacional do projeto com os seus pap\u00e9is e responsabilidades.  \n\n3.1 Estrutura Organizacional \n\nAnalista e Desenvolvedor: fazem toda a parte de an\u00e1lise de sistema, bem como o levantamento dos \nrequisitos e o desenvolvimento do sistema. \n\n3.2 Roles (Pap\u00e9is) e Responsabilidades \n\nPessoa Rational Unified Process Role (Papel) \n\nLuciane Pires Werlang \n\nGerente de Projeto \nAnalista de Sistemas \nArquiteto de Software \nEspecificador de Requisitos \nProjetista \nProgramador \n\nJefferson Amorim de Oliveira \n\nGerente de Projeto \nAnalista de Sistemas \nArquiteto de Software \nEspecificador de Requisitos \nProjetista \nProgramador  \n\n \n\n4. Processo de Gerenciamento \n\nA seguir ser\u00e3o listados alguns itens do Processo de Gerenciamento. \n\n4.1 Estimativas do Projeto \n\nEste projeto n\u00e3o tem custo de desenvolvimento, nem receber\u00e1 aux\u00edlio financeiro. \n\n4.2 Plano de Projeto \n\nEsta se\u00e7\u00e3o cont\u00e9m os planejamentos e os recursos para o projeto. \n\n4.2.1 Planejamento da Fase \n\nAbaixo est\u00e1 descrito as principais metas para cada fase. \n\u2022 Concep\u00e7\u00e3o: Analisar o problema, definir o sistema, definir o escopo do sistema, levantar os \n\nrequisitos para iniciar a modelagem do software para que este permita o reuso. \n\u2022 Elabora\u00e7\u00e3o: Definir a arquitetura que atenda os requisitos do sistema, que sirva de base para a \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:   1.2 \nSoftware Developent Plan (Small Project) Data de Cria\u00e7\u00e3o: 30-mai-2006 \nArquivo: A \u2013 Plano de Desenvolvimento de Software (Pequenos Projetos).doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 6 \n\n \n\nan\u00e1lise de consist\u00eancia e depend\u00eancia, al\u00e9m de prover suporte ao reuso. Dar continuidade a \nan\u00e1lise dos requisitos e a finaliza\u00e7\u00e3o da modelagem. \n\n\u2022 Constru\u00e7\u00e3o: Realizar a codifica\u00e7\u00e3o de software e os testes. \n\u2022 Transi\u00e7\u00e3o: Realizar a finaliza\u00e7\u00e3o do software, para que seja feita a distribui\u00e7\u00e3o.    \n\n4.2.2 Objetivos das Itera\u00e7\u00f5es \n\nConcretizar cada itera\u00e7\u00e3o, fazendo as devidas corre\u00e7\u00f5es e integrando-as de forma eficiente com as \npr\u00f3ximas, para a finaliza\u00e7\u00e3o do projeto. \n\n4.2.3 Libera\u00e7\u00f5es \n\nO sistema ser\u00e1 distribuido no final do projeto, por\u00e9m antes n\u00e3o haver\u00e1 uma vers\u00e3o beta para que seja \ndisponibilizado para a realiza\u00e7\u00e3o de testes e satisfa\u00e7\u00e3o de clientes. \n\n4.2.4 Cronograma do Projeto \n\nOs cronogramas est\u00e3o todos demonstrados nos Planos de Itera\u00e7\u00e3o de cada fase, ou seja, Plano de \nItera\u00e7\u00e3o Concep\u00e7\u00e3o (AP\u00caNDICE F), Plano de Itera\u00e7\u00e3o Elabora\u00e7\u00e3o (AP\u00caNDICE F), Plano de Itera\u00e7\u00e3o \nConstru\u00e7\u00e3o (AP\u00caNDICE F) e Plano de Itera\u00e7\u00e3o Transi\u00e7\u00e3o (AP\u00caNDICE F). \n\n4.2.5 Recursos do Projeto \n\nAs pessoas envolvidas no projeto dever\u00e3o ter conhecimento em Banco de Dados, dom\u00ednio em \nprograma\u00e7\u00e3o JAVA, conhecimentos em linguagem XML.     \n\n4.3 Monitoramento de Projeto e Controle \n\n Segue uma lista de itens a considerar: \n\n\u2022 Requirements Management (Gerenciamento de Requisitos) \n\nOs requisitos para este sistema s\u00e3o capturados no documento Software Requirements \nSpecification (Especifica\u00e7\u00e3o de Requisitos de Software). \n\n\u2022 Software Architecture Document (Documento de Arquitetura de Software) \n\nNeste documento est\u00e1 descrita a arquitetura do sistema. \n\n5. Anexos \n\nO projeto seguir\u00e1 o processo do RUP for Small Projects (RUP para Projetos Pequenos), customizado \npara que seja adapt\u00e1vel a este projeto. \n\n \n\n\n\n \n\n  \n\n123 \n\n \n\n \n\n \n\nAP\u00caNDICE B \u2013 Artefato do RUP de Especifica\u00e7\u00e3o Complementar \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Requirements - Requisitos \n\nPapel: System Analyst - Analista de Sistema \n\nIndiv\u00edduo: Luciane Werlang &amp; Jefferson Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nSupplementary Specification \n\nEspecifica\u00e7\u00e3o Complementar \n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nSupplementary Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: B \u2013 Especifica\u00e7\u00e3o Complementar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 5 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n30/05/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n20/08/2006 1.1 Revis\u00e3o e atualiza\u00e7\u00e3o Luciane Pires Werlang \n\n    \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nSupplementary Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: B \u2013 Especifica\u00e7\u00e3o Complementar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 5 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Funcionalidade 4 \n\n3. Usabilidade 4 \n3.1 Interfaces 4 \n\n4. Confiabilidade 4 \n4.1 Disponibilidade 4 \n\n5. Suportabilidade 4 \n5.1 Manutenibilidade 4 \n5.2 Portabilidade 4 \n\n6. Restri\u00e7\u00e3o de Design 4 \n6.1 Tecnologia 4 \n6.2 Ferramentas 5 \n6.3 Banco de Dados 5 \n6.4 Arquitetura 5 \n\n7. Componentes Adquiridos 5 \n\n8. Interfaces 5 \n8.1 Interfaces de Usu\u00e1rio 5 \n8.2 Interfaces de Hardware 5 \n8.3 Interfaces de Software 5 \n8.4 Interfaces de Comunica\u00e7\u00e3o 5 \n\n9. Solicita\u00e7\u00e3o de Licen\u00e7a 5 \n\n10. Padr\u00f5es Aplic\u00e1veis 5 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nSupplementary Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: B \u2013 Especifica\u00e7\u00e3o Complementar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 5 \n\n \n\nSupplementary Specification \nEspecifica\u00e7\u00e3o Complementar \n\n1. Introdu\u00e7\u00e3o \n\nA Supplementary Specification (Especifica\u00e7\u00e3o Complementar) descreve os requisitos do sistema \nque n\u00e3o s\u00e3o capturados de imediato nos modelos de caso de uso. Tais requisitos incluem: \n\n\u2022 Requisitos legais e reguladores, incluindo padr\u00f5es de aplica\u00e7\u00f5es.  \n\n\u2022 Atributos de qualidade do sistema para serem constru\u00eddos, incluindo: usabilidade, \nconfiabilidade, performance e requisitos suport\u00e1veis. \n\n\u2022 Outros requisitos assim como sistemas operacionais e ambientes, requisitos de \ncompatibilidade e restri\u00e7\u00f5es de projeto. \n\n1.1 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n2. Funcionalidade \n\nOs requisitos funcionais ser\u00e3o capturados via especifica\u00e7\u00e3o de casos de uso.  \n\n3. Usabilidade \n\nEsta se\u00e7\u00e3o descreve os requisitos que afetam a usabilidade do sistema. \n\n3.1 Interfaces \n\nAs Interfaces ser\u00e3o amig\u00e1veis e suportadas pelos browsers mais conhecidos (Internet Explorer, \nFirefox). \n\n4. Confiabilidade \n\nEsta se\u00e7\u00e3o descreve os requisitos que afetam a confiabilidade do sistema. \n\n4.1 Disponibilidade \n\nO sistema est\u00e1 dispon\u00edvel em uma plataforma WEB, podendo ser acessado a qualquer momento, desde \nque o usu\u00e1rio esteja previamente cadastrado. \n\n5. Suportabilidade \n\nEsta se\u00e7\u00e3o descreve os requisitos que afetam a suportabilidade do sistema. \n\n5.1 Manutenibilidade \n\nO sistema \u00e9 projetado e implementado utilizando os conceitos de modulariza\u00e7\u00e3o. Isso facilitar\u00e1 e \ntornar\u00e1 a repara\u00e7\u00e3o de erros ou defeitos mais r\u00e1pida, assim como a adi\u00e7\u00e3o de novas funcionalidades ou \nmodifica\u00e7\u00f5es. A arquitetura utilizada para construir o sistema visa a independ\u00eancia das camadas de \nimplementa\u00e7\u00e3o em Modelo, Vis\u00e3o e Controle al\u00e9m de oferecer a vantagem da modularidade. Permite \ntamb\u00e9m que partes j\u00e1 desenvolvidas em um sistema possam ser reutilizados em novos sistemas. \n\n5.2 Portabilidade \n\nComo o sistema \u00e9 desenvolvido em Java, ele poder\u00e1 ser executado em diferentes plataformas, desde \nque estas possuem a respectiva JVM (Java Virtual Machine). \n \n\n6. Restri\u00e7\u00e3o de Design \n\nEsta se\u00e7\u00e3o descreve as retri\u00e7\u00f5es de design que afetam o sistema. \n\n6.1 Tecnologia \n\nA linguagem de modelagem que \u00e9 adotada para projetar o sistema \u00e9 a UML (Unified Modeling \nLanguage), para codifica\u00e7\u00e3o do sistema \u00e9 utilizada a linguagem de programa\u00e7\u00e3o Java e XML com o \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nSupplementary Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: B \u2013 Especifica\u00e7\u00e3o Complementar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 5 \n\n \n\naux\u00edlio do Web Container Apache Tomcat. Para cria\u00e7\u00e3o das interfaces \u00e9 utilizada as tecnologias \nHTML, JSP, XLS, DTD, JavaScript e Servlets.  \n\n6.2 Ferramentas \n\nO desenho da modelagem ser\u00e1 realizada na ferramenta Enterprise Architect (EA). A descri\u00e7\u00e3o dos \nartefatos ser\u00e3o feitos no Microsoft Word. A codifica\u00e7\u00e3o do sistema ser\u00e1 realizada no Eclipse. \n\n6.3 Banco de Dados \n\nO Banco de Dados que dar\u00e1 suporte a aplica\u00e7\u00e3o ser\u00e1 o Oracle.  \n\n6.4 Arquitetura \n\nA arquitetura utilizada ser\u00e1 a arquitetura MVC, pelo suporte que ela d\u00e1 a modularidade e reuso de \nc\u00f3digo. \n\n7. Componentes Adquiridos \n\nOs componentes adquiridos para auxiliar na implementa\u00e7\u00e3o do sistema ser\u00e3o os Frameworks Jakarta \nStruts e Hibernate. \n\n8. Interfaces \n\nEsta se\u00e7\u00e3o descreve os requisitos que afetam as interfaces do sistema. \n\n8.1 Interfaces de Usu\u00e1rio \n\nAs interfaces do sistema ser\u00e3o de f\u00e1cil utiliza\u00e7\u00e3o buscando utilizar recursos amig\u00e1veis e de r\u00e1pido \ncarregamento pelo browser.  \n\n8.2 Interfaces de Hardware \n\nN\u00e3o haver\u00e1 necessidade de nenhuma interface de hardware.  \n\n8.3 Interfaces de Software \n\nN\u00e3o haver\u00e1 necessidade de nenhuma interface de software.  \n\n8.4 Interfaces de Comunica\u00e7\u00e3o \n\nO sistema ir\u00e1 rodar em cima dos protocolos de comunica\u00e7\u00e3o HTTP e TCP/IP, tanto em redes locais \ncomo fora da organiza\u00e7\u00e3o.  \n \n\n9. Solicita\u00e7\u00e3o de Licen\u00e7a \n\nSer\u00e1 necess\u00e1rio adquirir licen\u00e7a para o Banco de Dados Oracle, assim como para o sistema operacional \nWindows, caso utilize-o. \n\n10. Padr\u00f5es Aplic\u00e1veis \n\nN\u00e3o se aplica. \n\n\n\n \n\n  \n\n129 \n\n \n\n \n\n \n\nAP\u00caNDICE C \u2013 Artefato do RUP de Especifica\u00e7\u00e3o de Requisitos de Software \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Requirements - Requisitos \n\nPapel: Requirements Specifier - Especificador de Requisitos \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nSoftware Requirements Specification (with Use-\n\nCase) \nEspecifica\u00e7\u00e3o de Requisitos de Software \n\n \n\nVers\u00e3o 1.2 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Requirements Specification (with Use-Case) Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: C \u2013 Especifica\u00e7\u00e3o de Requisitos de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 7 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n30/05/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n20/08/2006 1.1 Revis\u00e3o  Luciane Pires Werlang \n\n05/11/2006 1.2 Revis\u00e3o Final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Requirements Specification (with Use-Case) Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: C \u2013 Especifica\u00e7\u00e3o de Requisitos de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 7 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Descri\u00e7\u00e3o Completa 4 \n2.1 An\u00e1lise do Modelo de Caso de Uso 4 \n\n2.1.1 Atores 4 \n2.1.2 Casos de Uso 4 \n\n3. Requisitos Espec\u00edficos 7 \n3.1 Requisitos Funcionais 7 \n3.2 Requisitos N\u00e3o-Funcionais 7 \n3.3 Requisitos Complementares 7 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Requirements Specification (with Use-Case) Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: C \u2013 Especifica\u00e7\u00e3o de Requisitos de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 7 \n\n \n\nSoftware Requirements Specification (with Use-\nCase) \n\nEspecifica\u00e7\u00e3o de Requisitos de Software \n\n1. Introdu\u00e7\u00e3o \n\nO Software Requirements Specification \u2013 SRS (Especifica\u00e7\u00e3o dos Requisitos do Software) captura os \nrequisitos de software por completo para o sistema, ou para uma parte do sistema. Seguindo um t\u00edpico \nesbo\u00e7o do SRS para um projeto que usa modelagem de caso de uso. Este artefato consiste em um \npacote contendo casos de uso do modelo de casos de uso, especifica\u00e7\u00e3o suplementar adequada e outras \ninforma\u00e7\u00f5es de apoio. Para um modelo de um SRS que n\u00e3o use modelagem de casos de uso, o qual \ncaptura todos os requisitos em um simples documento, com as se\u00e7\u00f5es adequadas inseridas da \nEspecifica\u00e7\u00e3o Complementar. \n\n1.1 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n2. Descri\u00e7\u00e3o Completa \n\nEsta se\u00e7\u00e3o do Software Requirements Specification - SRS (Especifica\u00e7\u00e3o de Requisitos de Software) \ndescreve as causas gerais que afetam o produto e seus requisitos. Esta se\u00e7\u00e3o n\u00e3o determina requisitos \nespec\u00edficos. No lugar disto ele fornece um fundo para aqueles requisitos, os quais s\u00e3o definidos em \ndetalhes na Se\u00e7\u00e3o 3, e torna-os f\u00e1cil de compreender.  \n\n2.1 An\u00e1lise do Modelo de Caso de Uso \n\nCont\u00e9m uma vis\u00e3o geral do modelo de caso de uso e atores, junto com os diagramas adequados e \nrelacionamentos.  \n\n2.1.1 Atores \n\nListagem de todos os Atores que ir\u00e3o utilizar o sistema. \n\n \n\nFigura 1. Atores \n\n\u2022 Usu\u00e1rio: Representa todos os usu\u00e1rios do sistema. \n\n2.1.2 Casos de Uso \n\n \nListagem de todos os Casos de Uso do sistema. \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Requirements Specification (with Use-Case) Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: C \u2013 Especifica\u00e7\u00e3o de Requisitos de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 7 \n\n \n\n \nFigura 2. Casos de Uso \n\nO diagrama de atividade a seguir demostra uma vis\u00e3o geral do funcionamento do sistema proposto.  \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Requirements Specification (with Use-Case) Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: C \u2013 Especifica\u00e7\u00e3o de Requisitos de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 7 \n\n \n\n \n\nFigura 3. Diagrama de atividade dos casos de uso  \n\n \n\nPara entender melhor os casos de uso,  eles foram divididos em pacotes. \n\n \n\n \n\nFigura 4. Pacotes que comp\u00f5em o sistema \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Requirements Specification (with Use-Case) Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: C \u2013 Especifica\u00e7\u00e3o de Requisitos de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 7 \n\n \n\n \n\n3. Requisitos Espec\u00edficos \n\n Esta se\u00e7\u00e3o do Software Requirements Specification (Especifica\u00e7\u00e3o dos Requisitos de Software) \ncont\u00e9m todos os requisitos de software para um n\u00edvel de detalhes suficiente para habilitar os designers \na fazer o design do sistema. Eles est\u00e3o divididos em requisitos funcionais e requisitos n\u00e3o-funcionais. \n\n3.1 Requisitos Funcionais \n\n \nEm todos os requisitos funcionais citados a seguir o usu\u00e1rio realizar\u00e1 as opera\u00e7\u00f5es de cadastro, \natualiza\u00e7\u00e3o, exclus\u00e3o e consulta. Para o usu\u00e1rio ter acesso \u00e0s opera\u00e7\u00f5es de atualiza\u00e7\u00e3o e exclus\u00e3o, ele \ndever\u00e1 primeiramente executar a opera\u00e7\u00e3o de consulta para ent\u00e3o entrar na edi\u00e7\u00e3o do item selecionado.  \nPara os requisitos de manuten\u00e7\u00e3o de Estado, manuten\u00e7\u00e3o de Cidade e manuten\u00e7\u00e3o de Cliente o usu\u00e1rio \nutilizar\u00e1 um componente que executar\u00e1 consultas gen\u00e9ricas que ir\u00e3o preencher campos que pertencem a \noutro cadastro. \n \n\n\u2022 Manuten\u00e7\u00e3o de Pa\u00eds \n\u2022 Manuten\u00e7\u00e3o de Estado \n\u2022 Manuten\u00e7\u00e3o de Cidade \n\u2022 Manuten\u00e7\u00e3o de Cliente \n\n \n \n\n3.2 Requisitos N\u00e3o-Funcionais  \n\nPara acessar o sistema o usu\u00e1rio dever\u00e1 estar cadastrado na Base de Dados com login e senha. Essa \nrestri\u00e7\u00e3o se d\u00e1 pelo uso de um sistema de seguran\u00e7a, que evita que pessoas n\u00e3o autorizadas possam \nacessar o sistema e corromper seus dados. \n\n3.3 Requisitos Complementares \n\nEst\u00e3o descritos no Artefato Especifica\u00e7\u00e3o Complementar (AP\u00caNDICE B)  \n\n\n\n \n\n  \n\n137 \n\n \n\n \n\n \n\nAP\u00caNDICE D \u2013 Artefato do RUP de Especifica\u00e7\u00e3o de Caso de Uso \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Requirements - Requisitos \n\nPapel: Requirements Specifier - Especificador de Requisitos \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nUse-Case Specifications  \n\nEspecifica\u00e7\u00e3o dos Casos de Uso \n \n\nVers\u00e3o 1.2 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 9 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n31/05/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n20/08/2006 1.1 Revis\u00e3o  Luciane e Jefferson \n\n05/11/2006 1.2 Revis\u00e3o Final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 9 \n\n \n\nSum\u00e1rio \n\n1.0 Manuten\u00e7\u00e3o de Cidade 4 \n1.1 Descri\u00e7\u00e3o Resumida 4 \n1.2 Fluxo de Eventos 4 \n1.3 Fluxo B\u00e1sico 4 \n1.4 Fluxo Alternativo 4 \n\n1.4.1 Incluir 4 \n1.4.2 Excluir 5 \n1.4.3 Consultar 5 \n1.4.4 Atualizar 5 \n\n2.0 Manuten\u00e7\u00e3o de Cliente 5 \n2.1 Descri\u00e7\u00e3o Resumida 6 \n2.2 Fluxo de Eventos 6 \n2.3 Fluxo B\u00e1sico 6 \n2.4 Fluxo Alternativo 6 \n\n2.4.1 Incluir 6 \n2.4.2 Excluir 6 \n2.4.3 Consultar 6 \n2.4.4 Atualizar 6 \n\n3.0 Manuten\u00e7\u00e3o de Pa\u00eds 6 \n3.1 Descri\u00e7\u00e3o Resumida 7 \n3.2 Fluxo de Eventos 7 \n3.3 Fluxo B\u00e1sico 7 \n3.4 Fluxo Alternativo 7 \n\n3.4.1 Incluir 7 \n3.4.2 Excluir 7 \n3.4.3 Consultar 8 \n3.4.4 Atualizar 8 \n\n4.0 Manuten\u00e7\u00e3o de Estado 8 \n4.1 Descri\u00e7\u00e3o Resumida 8 \n4.2 Fluxo de Eventos 9 \n4.3 Fluxo B\u00e1sico 9 \n4.4 Fluxo Alternativo 9 \n\n4.4.1 Incluir 9 \n4.4.2 Excluir 9 \n4.4.3 Consultar 9 \n4.4.4 Atualizar 9 \n\n5.0 Pr\u00e9-Condi\u00e7\u00f5es 9 \n5.1 Conex\u00e3o com o Banco de Dados 9 \n5.2 Usu\u00e1rio cadastrado 9 \n\n6.0 P\u00f3s-Condi\u00e7\u00f5es 9 \n6.1 Executar a a\u00e7\u00e3o 9 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 9 \n\n \n\nUse-Case Specifications  \nEspecifica\u00e7\u00e3o dos Casos de Uso \n\n \n\n1.-1 Manuten\u00e7\u00e3o de Cidade \n\nO diagrama de atividade descreve de um modo geral como ser\u00e1 o funcionamento da manuten\u00e7\u00e3o de \ncidade. \n \n\n \nFigura 1. Diagrama de atividade do pacote Cidade \n\n1.1 Descri\u00e7\u00e3o Resumida \n\nO usu\u00e1rio realizar\u00e1 a manuten\u00e7\u00e3o de Cidade no sistema. As opera\u00e7\u00f5es que ser\u00e3o realizadas \ns\u00e3o: Incluir, Excluir, Atualizar e Consultar. \n\n \n\n1.2 Fluxo de Eventos \n\n1.3 Fluxo B\u00e1sico \n\n1- O usu\u00e1rio clica na op\u00e7\u00e3o Cidade. \n2- O usu\u00e1rio visualizar\u00e1 uma tela onde ele poder\u00e1 consultar ou fazer a inclus\u00e3o de uma nova \n\ncidade. \n3- Escolhendo a op\u00e7\u00e3o de consultar, o usu\u00e1rio poder\u00e1 exluir ou alterar a cidade selecionada. \n4- Caso seja nova inclus\u00e3o, abrir\u00e1 para o usu\u00e1rio uma nova tela, onde ele far\u00e1 o cadastro.     \n\n1.4 Fluxo Alternativo \n\n1.4.1 Incluir \n\n1- O sistema mostrar\u00e1 um formul\u00e1rio com os campos dispon\u00edveis para preenchimento. \n2- O usu\u00e1rio preenche os campos. \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 9 \n\n \n\n3- O usu\u00e1rio invoca o Caso de Uso Consultar. \n4- Usu\u00e1rio finaliza sua inclus\u00e3o. \n\n1.4.2 Excluir \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a(s) linha(s) referente(s) a(s) cidade(s) a ser(em) apagada(s). \n3- Usu\u00e1rio confirma a op\u00e7\u00e3o de apagar a(s) cidade(s). \n4- Caso ocorra algum erro ser\u00e1 emitida uma mensagem.  \n\n1.4.3 Consultar \n\n1- O usu\u00e1rio poder\u00e1 utilizar filtro para realizar a consulta.  \n2- O usu\u00e1rio realiza a consulta. \n3- Sistema mostrar\u00e1 uma listagem. \n\n1.4.4 Atualizar \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a linha referente a cidade a ser atualizada. \n3- Sistema mostrar\u00e1 o formul\u00e1rio com os campos preenchidos e habilitados para serem alterados. \n4- Usu\u00e1rio altera o(s) campo(s) e salva as informa\u00e7\u00f5es. \n\n \n\n2.-1 Manuten\u00e7\u00e3o de Cliente \n\nO diagrama de atividade descreve de um modo geral como ser\u00e1 o funcionamento da manuten\u00e7\u00e3o de \ncliente. \n \n\n \nFigura 2. Diagrama de atividade do pacote Cliente \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 9 \n\n \n\n \n\n2.1 Descri\u00e7\u00e3o Resumida \n\nO usu\u00e1rio realizar\u00e1 a manuten\u00e7\u00e3o de Cliente no sistema. As opera\u00e7\u00f5es que ser\u00e3o realizadas \ns\u00e3o: Incluir, Excluir, Atualizar e Consultar. \n\n2.2 Fluxo de Eventos \n\n2.3 Fluxo B\u00e1sico \n\n1- O usu\u00e1rio clica na op\u00e7\u00e3o Cliente. \n2- O usu\u00e1rio visualizar\u00e1 uma tela onde ele poder\u00e1 consultar ou fazer a inclus\u00e3o de um novo \n\ncliente. \n3- Escolhendo a op\u00e7\u00e3o de consultar, o usu\u00e1rio poder\u00e1 exluir ou alterar o cliente selecionado. \n4- Caso seja nova inclus\u00e3o, abrir\u00e1 para o usu\u00e1rio uma nova tela, onde ele far\u00e1 o cadastro.     \n\n2.4 Fluxo Alternativo \n\n2.4.1 Incluir \n\n1- O sistema mostrar\u00e1 um formul\u00e1rio com os campos dispon\u00edveis para preenchimento. \n2- O usu\u00e1rio preenche os campos. \n3- O usu\u00e1rio invoca o Caso de Uso Consultar. \n4- Usu\u00e1rio finaliza sua inclus\u00e3o. \n\n2.4.2 Excluir \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a(s) linha(s) referente(s) ao(s) cliente(s) a ser(em) apagado(s). \n3- Usu\u00e1rio confirma a op\u00e7\u00e3o de apagar o(s) cliente(s). \n4- Caso ocorra algum erro ser\u00e1 emitida uma mensagem.  \n\n2.4.3 Consultar \n\n 1-    Usu\u00e1rio poder\u00e1 utilizar filtro para realizar a consulta.  \n2- O usu\u00e1rio realiza a consulta. \n3- Sistema mostrar\u00e1 uma listagem. \n\n2.4.4 Atualizar \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a linha referente ao cliente a ser atualizado. \n3- Sistema mostrar\u00e1 o formul\u00e1rio com os campos preenchidos e habilitados para serem alterados. \n4- Usu\u00e1rio altera o(s) campo(s) e salva as informa\u00e7\u00f5es. \n\n \n\n3.-1 Manuten\u00e7\u00e3o de Pa\u00eds \n\nO diagrama de atividade descreve de um modo geral como ser\u00e1 o funcionamento da manuten\u00e7\u00e3o de \npa\u00eds. \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 9 \n\n \n\n \nFigura 3. Diagrama de atividade do pacote Pa\u00eds \n\n \n\n3.1 Descri\u00e7\u00e3o Resumida \n\nO usu\u00e1rio realizar\u00e1 a manuten\u00e7\u00e3o de Pa\u00eds no sistema. As opera\u00e7\u00f5es que ser\u00e3o realizadas s\u00e3o: Incluir, \nExcluir, Atualizar e Consultar. \n\n3.2 Fluxo de Eventos \n\n3.3 Fluxo B\u00e1sico \n\n1- O usu\u00e1rio clica na op\u00e7\u00e3o Pa\u00eds. \n2- O usu\u00e1rio visualizar\u00e1 uma tela onde ele poder\u00e1 consultar ou fazer a inclus\u00e3o de um novo pa\u00eds. \n3- Escolhendo a op\u00e7\u00e3o de consultar, o usu\u00e1rio poder\u00e1 exluir ou alterar o pa\u00eds selecionado. \n4- Caso seja nova inclus\u00e3o, abrir\u00e1 para o usu\u00e1rio uma nova tela, onde ele far\u00e1 o cadastro.     \n\n3.4 Fluxo Alternativo \n\n3.4.1 Incluir \n\n1- O sistema mostrar\u00e1 um formul\u00e1rio com os campos dispon\u00edveis para preenchimento. \n2- O usu\u00e1rio preenche os campos. \n3- Usu\u00e1rio finaliza sua inclus\u00e3o. \n\n3.4.2 Excluir \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a(s) linha(s) referente(s) ao(s) pa\u00eds(es) a ser(em) apagado(s). \n3- Usu\u00e1rio confirma a op\u00e7\u00e3o de apagar o(s) pa\u00eds(es). \n4- Caso ocorra algum erro ser\u00e1 emitida uma mensagem.  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 8 de 9 \n\n \n\n3.4.3 Consultar \n\n1- O usu\u00e1rio poder\u00e1 utilizar filtro para realizar a consulta.  \n2- O usu\u00e1rio realiza a consulta. \n3- Sistema mostrar\u00e1 uma listagem. \n\n3.4.4 Atualizar \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a linha referente ao pa\u00eds a ser atualizado. \n3- Sistema mostrar\u00e1 o formul\u00e1rio com os campos preenchidos e habilitados para serem alterados. \n4- Usu\u00e1rio altera o(s) campo(s) e salva as informa\u00e7\u00f5es. \n\n \n\n4.0 Manuten\u00e7\u00e3o de Estado \n\nO diagrama de atividade descreve de um modo geral como ser\u00e1 o funcionamento da manuten\u00e7\u00e3o de \nestado. \n \n\n \nFigura 4. Diagrama de atividade do pacote Estado \n\n \n\n4.1 Descri\u00e7\u00e3o Resumida \n\nO usu\u00e1rio realizar\u00e1 a manuten\u00e7\u00e3o de Estado no sistema. As opera\u00e7\u00f5es que ser\u00e3o realizadas s\u00e3o: Incluir, \nExcluir, Atualizar e Consultar. \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 7-jun-2006 \nArquivo: D - Especifica\u00e7\u00e3o dos Casos de Uso .doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 9 de 9 \n\n \n\n4.2 Fluxo de Eventos \n\n4.3 Fluxo B\u00e1sico \n\n1- O usu\u00e1rio clica na op\u00e7\u00e3o Estado. \n2- O usu\u00e1rio visualizar\u00e1 uma tela onde ele poder\u00e1 consultar ou fazer a inclus\u00e3o de um novo \n\nestado. \n3- Escolhendo a op\u00e7\u00e3o de consultar, o usu\u00e1rio poder\u00e1 exluir ou alterar o estado selecionado. \n4- Caso seja nova inclus\u00e3o, abrir\u00e1 para o usu\u00e1rio uma nova tela, onde ele far\u00e1 o cadastro.     \n\n4.4 Fluxo Alternativo \n\n4.4.1 Incluir \n\n1- O sistema mostrar\u00e1 um formul\u00e1rio com os campos dispon\u00edveis para preenchimento. \n2- O usu\u00e1rio preenche os campos. \n3- O usu\u00e1rio invoca o Caso de Uso Consultar. \n4- Usu\u00e1rio finaliza sua inclus\u00e3o. \n\n4.4.2 Excluir \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a(s) linha(s) referente(s) ao(s) estado(s) a ser(em) apagado(s). \n3- Usu\u00e1rio confirma a op\u00e7\u00e3o de apagar o(s) estado(s). \n4- Caso ocorra algum erro ser\u00e1 emitida uma mensagem.  \n\n4.4.3 Consultar \n\n1- O usu\u00e1rio poder\u00e1 utilizar filtro para realizar a consulta.  \n2- O usu\u00e1rio realiza a consulta. \n3- Sistema mostrar\u00e1 uma listagem. \n\n4.4.4 Atualizar \n\n1- O usu\u00e1rio executa o Consultar. \n2- O usu\u00e1rio seleciona a linha referente ao estado a ser atualizado. \n3- Sistema mostrar\u00e1 o formul\u00e1rio com os campos preenchidos e habilitados para serem alterados. \n4- Usu\u00e1rio altera o(s) campo(s) e salva as informa\u00e7\u00f5es. \n\n \n \n\n5.-1 Pr\u00e9-Condi\u00e7\u00f5es \n\nUma pr\u00e9-condi\u00e7\u00e3o de um caso de uso \u00e9 o estado que o sistema deve apresentar antes do caso de uso ser \nexecutado. \n\n5.1 Conex\u00e3o com o Banco de Dados \n\nA conex\u00e3o com o banco deve estar ativa. \n \n\n5.2 Usu\u00e1rio cadastrado \n\nO usu\u00e1rio deve estar devidamente cadastrado para utilizar o sistema. \n \n\n6.-1 P\u00f3s-Condi\u00e7\u00f5es \n\nUma p\u00f3s-condi\u00e7\u00e3o de um caso de uso \u00e9 uma lista dos poss\u00edveis estados que o sistema pode estar \nimediatamente ap\u00f3s a finaliza\u00e7\u00e3o de um caso de uso. \n\n6.1 Executar a a\u00e7\u00e3o \n\nMostrar o resultado da a\u00e7\u00e3o. \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Requirements - Requisitos \n\nPapel: Requirements Specifier - Especificador de Requisitos \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nUse-Case Specification \n\nEspecifica\u00e7\u00e3o do Caso de Uso Pesquisar \n \n\nVers\u00e3o 1.2 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: D - Especifica\u00e7\u00e3o do Caso de Uso Pesquisar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 5 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n31/05/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n   20/08/2006 1.1 Revis\u00e3o Luciane e Jefferson \n\n05/11/2006 1.2 Revis\u00e3o final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: D - Especifica\u00e7\u00e3o do Caso de Uso Pesquisar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 5 \n\n \n\nSum\u00e1rio \n\n1. Pesquisar 4 \n1.1 Descri\u00e7\u00e3o Resumida 5 \n\n2. Fluxo de Eventos 5 \n2.1 Fluxo B\u00e1sico 5 \n\n3. Pr\u00e9-Condi\u00e7\u00f5es 5 \n3.1 Conex\u00e3o com o Banco de Dados 5 \n3.2 Usu\u00e1rio cadastrado 5 \n3.3 Dados cadastrados 5 \n\n4. P\u00f3s-Condi\u00e7\u00f5es 5 \n4.1 Executar a a\u00e7\u00e3o 5 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: D - Especifica\u00e7\u00e3o do Caso de Uso Pesquisar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 5 \n\n \n\nUse-Case Specification \nEspecifica\u00e7\u00e3o do Caso de Uso Pesquisar \n\n \n\n1. Pesquisar \n\nO Diagrama de Atividade representa o funciomento do caso de uso. \nad Diagrama de ativ idade Pesquisar \n\nIni cio\n\nClicar na imagem para\nrealizar a pesquisa\n\nDigitar filtro para\npesquisar\n\npesquisar\n\nExistem dados Cadastrados?\n\nretorna lista de dados retorna lista v azia\n\nfim\n\nseleciona o dado\n\nAchou o dado?\n\n[si m]\n\n[n\u00e3o]\n[sim]\n\n[n\u00e3o]\n\n[n\u00e3o]\n\n \n Figura 1. Diagrama de Atividade do Caso de Uso Pesquisar \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nUse-Case Specification Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: D - Especifica\u00e7\u00e3o do Caso de Uso Pesquisar.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 5 \n\n \n\n1.1 Descri\u00e7\u00e3o Resumida \n\nO usu\u00e1rio realiza a pesquisa para preencher um campo que necessita desse dado. \n\n2. Fluxo de Eventos \n\n2.1 Fluxo B\u00e1sico \n\n1- O usu\u00e1rio clica numa imagem de procura que abrir\u00e1 uma tela. \n2- A tela ter\u00e1 filtros chaves para realizar a consulta do dado a ser inserido no cadastro. \n3- A consulta retornar\u00e1 uma lista. \n4- O usu\u00e1rio poder\u00e1 selecionar somente um item da lista para ser inserido no cadastro. \n5- Ap\u00f3s a sele\u00e7\u00e3o, ele dever\u00e1 clicar em selecionar para que o item seja enviado para o cadastro e a \n\ntela se fechar\u00e1. \n \n\n3. Pr\u00e9-Condi\u00e7\u00f5es \n\nUma pr\u00e9-condi\u00e7\u00e3o de um caso de uso \u00e9 o estado que o sistema deve apresentar antes do caso de uso ser \nexecutado. \n\n3.1 Conex\u00e3o com o Banco de Dados \n\nA conex\u00e3o com o banco deve estar ativa. \n \n\n3.2 Usu\u00e1rio cadastrado \n\nO usu\u00e1rio deve estar devidamente cadastrado para utilizar o sistema. \n\n3.3 Dados cadastrados \n\nOs dados devem ser cadastrados para que tenha algum retorno. \n \n\n4. P\u00f3s-Condi\u00e7\u00f5es \n\nO dado selecionado deve estar retornado nos campos para o qual foi requisitado \n\n4.1 Executar a a\u00e7\u00e3o \n\nMostrar o resultado da a\u00e7\u00e3o. \n\n \n\n\n\n \n\n  \n\n152 \n\n \n\n \n\n \n\nAP\u00caNDICE E \u2013 Artefato do RUP de Documento de Arquitetura de Software \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Analysis &amp; Design - An\u00e1lise e Design \n\nPapel: Software Architect - Arquiteto de Software \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nSoftware Architecture Document \n\nDocumento de Arquitetura de Software \n \n\nVers\u00e3o 1.2 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 9 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n30/05/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n08/10/2006 1.1 Revis\u00e3o  Luciane Werlang \n\n05/11/2006 1.2 Revis\u00e3o final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 9 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Representa\u00e7\u00e3o Arquitetural 4 \n\n3. Metas Arquiteturais e Restri\u00e7\u00f5es 4 \n\n4. Realiza\u00e7\u00e3o do Caso de Uso 5 \n\n5. Vis\u00e3o L\u00f3gica 5 \n5.1 Diagrama Geral de Vis\u00e3o 6 \n5.2 Diagrama Geral de Controle 7 \n5.3 Diagrama Geral de Modelo 7 \n\n6. Vis\u00e3o de Implementa\u00e7\u00e3o 8 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 9 \n\n \n\nSoftware Architecture Document \nDocumento de Arquitetura de Software \n\n1. Introdu\u00e7\u00e3o \n\nA introdu\u00e7\u00e3o do Software Architecture Document (Documento de Arquitetura de Software) fornece \numa vis\u00e3o geral do conte\u00fado do documento. Ele inclui o objetivo, escopo, defini\u00e7\u00f5es, acr\u00f4nimos, \nabrevia\u00e7\u00f5es, refer\u00eancias e a vis\u00e3o geral deste documento. \n\n1.1 Objetivo \n\nEste documento fornece uma compreensiva vis\u00e3o geral da arquitetura do sistema, usando um n\u00famero \nde vis\u00f5es arquiteturais diferentes para descrever diferentes aspectos do sistema. Pretende-se capturar e \nconduzir as decis\u00f5es da arquitetura significativas que foram feitas no sistema. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J) \n\n2. Representa\u00e7\u00e3o Arquitetural \n\nConforme previsto no artefato Especifica\u00e7\u00e3o Complementar (AP\u00caNDICE B) o sistema ser\u00e1 \ndesenvolvido e implementado segundo uma arquitetura em tr\u00eas camadas, visando interdepend\u00eancia das \ncamadas para facilitar a manuten\u00e7\u00e3o e sua constru\u00e7\u00e3o. Durante o design do sistema, o mapeamento das \ncamadas respeitou a divis\u00e3o dos pacotes detectados. \n\n3. Metas Arquiteturais e Restri\u00e7\u00f5es \n\nO sistema em desenvolvimento possui as seguintes caracter\u00edsticas: \n\u2022 Multiplataforma: o sistema baseado em tecnologia Java, que \u00e9 independente de plataforma \n\npara implementa\u00e7\u00e3o. \n\u2022 Banco de Dados: Como o sistema possui interdepend\u00eancia entre as camadas, o banco de \n\ndados se comunica junto \u00e0 camada de persist\u00eancia sem comprometer o restante do sistema. Ou \nseja, o sistema ser\u00e1 port\u00e1vel para qualquer banco padr\u00e3o SQL-92 acessado via JDBC. \n\n\u2022 Camadas L\u00f3gicas: o sistema \u00e9 projetado na arquitetura MVC: \n? Vis\u00e3o (View): Arquivos JSP e Java (do tipo Form \u2013 Bean) que s\u00e3o \n\ncarregados pelo cliente via browser, fazendo a liga\u00e7\u00e3o entre o usu\u00e1rio e a \naplica\u00e7\u00e3o. \n\n? Controle (Controller): determina o fluxo da apresenta\u00e7\u00e3o servindo como \numa camada intermedi\u00e1ria entre a camada de apresenta\u00e7\u00e3o e a l\u00f3gica. \n\n? Modelo (Model): \u00c9 o cora\u00e7\u00e3o da aplica\u00e7\u00e3o. Respons\u00e1vel por tudo que a \naplica\u00e7\u00e3o vai fazer. Modela os dados e o comportamento por tr\u00e1s do \nprocessos de neg\u00f3cio, preocupa-se apenas com o armazenamento , \nmanipula\u00e7\u00e3o e gera\u00e7\u00e3o de dados, al\u00e9m de ser um encapsulamento de dados e \nde comportamento independente da Vis\u00e3o.  \n\n \n \n\nO sistema no contexto f\u00edsico \u00e9 compat\u00edvel com as seguintes arquiteturas: \n \n\n\u2022 1 M\u00e1quina: sistema acessado via browser do pr\u00f3prio servidor onde esta hospedado contendo \ntoda a aplica\u00e7\u00e3o (vis\u00e3o, controle e modelo) juntamente com o banco de dados. \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 9 \n\n \n\n \n \n\u2022 2 M\u00e1quinas: sistema acessado via browser do pr\u00f3prio servidor onde esta hospedado contendo \n\na aplica\u00e7\u00e3o e um servidor para os dados. \n\n \n \n\n\u2022 3 M\u00e1quinas: interface via browser na m\u00e1quina dos clientes, um servidor de aplica\u00e7\u00e3o para a \napresenta\u00e7\u00e3o e controle e um servidor para os dados. \n\n \n\n \n\n4. Realiza\u00e7\u00e3o do Caso de Uso \n\nTodas as realiza\u00e7\u00f5es dos casos de uso foram feitas com base na arquitetura MVC: Modelo, Vis\u00e3o e \nControle. \n\n5. Vis\u00e3o L\u00f3gica \n\nEsta se\u00e7\u00e3o descreve as partes significativas da arquitetura do modelo de design, tais como sua \ncomposi\u00e7\u00e3o em subsistemas e em pacotes.  \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 9 \n\n \n\n \n\n5.1 Diagrama Geral de Vis\u00e3o \n\n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 9 \n\n \n\n5.2 Diagrama Geral de Controle \n\n \n\n5.3 Diagrama Geral de Modelo \n\n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 8 de 9 \n\n \n\n \n \n\n6. Vis\u00e3o de Implementa\u00e7\u00e3o \n\n? Camada de Modelo \n \n\n \n \n \n\n? Camada de Controle \n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.2 \nSoftware Architecture Document Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: E - Documento de Arquitetura de Software.doc \n \n\nArtefato de Projeto ?Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 9 de 9 \n\n \n\n? Camada de Vis\u00e3o \n \n\n \n \n\n \n\n\n\n \n\n  \n\n162 \n\n \n\n \n\n \n\nAP\u00caNDICE F \u2013 Artefato do RUP de Plano de Itera\u00e7\u00e3o  \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Project Management - Ger\u00eancia de Projeto \n\nPapel: Project Manager - Gerente de Projeto \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nIteration Plan \n\nPlano de Itera\u00e7\u00e3o (Concep\u00e7\u00e3o) \n \n\nVers\u00e3o 1.1 \n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Concep\u00e7\u00e3o).doc  \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 2 de 4 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n13/06/2006 1.0 Edi\u00e7\u00e3o Inicial Luciane e Jefferson \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n    \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Concep\u00e7\u00e3o).doc  \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 3 de 4 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n1.3 Vis\u00e3o Geral 4 \n\n2. Cronograma 4 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Concep\u00e7\u00e3o).doc  \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 4 de 4 \n\n \n\nIteration Plan \nPlano de Itera\u00e7\u00e3o (Concep\u00e7\u00e3o) \n\n1. Introdu\u00e7\u00e3o \n\nO documento prop\u00f5e demostrar um plano para a fase de concep\u00e7\u00e3o do projeto.  \n\n1.1 Objetivo \n\nO objetivo \u00e9 mostrar um cronograma contendo todas as atividades associadas a essa fase, juntamente \ncom a datas e seus respectivos respons\u00e1veis. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n1.3 Vis\u00e3o Geral \n\nEste documento descreve o plano inicial do projeto atrav\u00e9s de um cronograma feito com o aux\u00edlio do \nMicrosoft Project. No cronograma est\u00e3o descritas as datas de in\u00edcio e fim das atividades inerentes a \nessa fase do projeto.  \n\nOutro ponto descrito no cronograma quando inicia-se a pr\u00f3xima fase que abrange a Elabora\u00e7\u00e3o do que \nfoi analisado nessa primeira parte. \n\n2. Cronograma \n\n \n\n\n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Project Management - Ger\u00eancia de Projeto \n\nPapel: Project Manager - Gerente de Projeto \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nIteration Plan \n\nPlano de Itera\u00e7\u00e3o (Elabora\u00e7\u00e3o) \n \n\nVers\u00e3o 1.1 \n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan  Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Elabora\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 2 de 4 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n13/06/2006 1.0 Edi\u00e7\u00e3o inicial Luciane e Jefferson \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n    \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan  Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Elabora\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 3 de 4 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n1.3 Vis\u00e3o Geral 4 \n\n2. Cronograma 4 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan  Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Elabora\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 4 de 4 \n\n \n\nIteration Plan \nPlano de Itera\u00e7\u00e3o (Elabora\u00e7\u00e3o) \n\n1. Introdu\u00e7\u00e3o \n\nO documento prop\u00f5e demostrar um plano para a fase de elabora\u00e7\u00e3o do projeto.  \n\n1.1 Objetivo \n\nO objetivo \u00e9 mostrar um cronograma contendo todas as atividades associadas a essa fase, juntamente \ncom a datas e seus respectivos respons\u00e1veis. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n1.3 Vis\u00e3o Geral \n\nEste documento descreve o plano inicial do projeto atrav\u00e9s de um cronograma feito com o aux\u00edlio do \nMicrosoft Project. No cronograma est\u00e3o descritas as datas de in\u00edcio e fim das atividades inerentes a \nessa fase do projeto.  Al\u00e9m disso, est\u00e1 descrito as atividades referentes ao componente que \u00e9 \ndesenvolvido para ser utilizado pelo sistema. \n\nOutro ponto descrito no cronograma quando inicia-se a pr\u00f3xima fase que abrange a Constru\u00e7\u00e3o do que \nfoi analisado nas fases anteriores. \n\n2. Cronograma \n\n \n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Project Management - Ger\u00eancia de Projeto \n\nPapel: Project Manager - Gerente de Projeto \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nIteration Plan \n\nPlano de Itera\u00e7\u00e3o (Constru\u00e7\u00e3o) \n \n\nVers\u00e3o 1.1 \n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Constru\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 2 de 4 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n13/06/2006 1.0 Edi\u00e7\u00e3o inicial Luciane e Jefferson \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n    \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Constru\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 3 de 4 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n1.3 Vis\u00e3o Geral 4 \n\n2. Cronograma 4 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Constru\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 4 de 4 \n\n \n\nIteration Plan \nPlano de Itera\u00e7\u00e3o (Constru\u00e7\u00e3o) \n\n1. Introdu\u00e7\u00e3o \n\nO documento prop\u00f5e demostrar um plano para a fase de constru\u00e7\u00e3o do projeto.  \n\n1.1 Objetivo \n\nO objetivo \u00e9 mostrar um cronograma contendo todas as atividades associadas a essa fase, juntamente \ncom a datas e seus respectivos respons\u00e1veis. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n1.3 Vis\u00e3o Geral \n\nEste documento descreve o plano inicial do projeto atrav\u00e9s de um cronograma feito com o aux\u00edlio do \nMicrosoft Project. No cronograma est\u00e3o descritas as datas de in\u00edcio e fim das atividades inerentes a \nessa fase do projeto. Sendo uma fase que envolve o desenvolvimento do sistema e do componente, a \nparte de testes \u00e9 bastante utilizada. \n\nOutro ponto descrito no cronograma envolve o inicio da pr\u00f3xima fase que abrange a Transi\u00e7\u00e3o, no qual \n\u00e9 feita a implanta\u00e7\u00e3o do sistema e resolvido alguns pontos que foram deixados de ser implementados \ne/ou n\u00e3o atenderam o que realmente tinha sido requisitado. \n\n2. Cronograma \n\n\n\n \n\n\n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Project Management - Ger\u00eancia de Projeto \n\nPapel: Project Manager - Gerente de Projeto \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nIteration Plan \n\nPlano de Itera\u00e7\u00e3o (Transi\u00e7\u00e3o) \n \n\nVers\u00e3o 1.1 \n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Transi\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 2 de 4 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n13/06/2006 1.0 Edi\u00e7\u00e3o inicial Luciane e Jefferson \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n    \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Transi\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 3 de 4 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n1.3 Vis\u00e3o Geral 4 \n\n2. Cronograma 4 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIteration Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: F - Plano de Itera\u00e7\u00e3o (Transi\u00e7\u00e3o).doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 4 de 4 \n\n \n\nIteration Plan \nPlano de Itera\u00e7\u00e3o (Transi\u00e7\u00e3o) \n\n1. Introdu\u00e7\u00e3o \n\nO documento prop\u00f5e demostrar um plano para a fase de transi\u00e7\u00e3o do projeto.  \n\n1.1 Objetivo \n\nO objetivo \u00e9 mostrar um cronograma contendo todas as atividades associadas a essa fase, juntamente \ncom a datas e seus respectivos respons\u00e1veis. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n1.3 Vis\u00e3o Geral \n\nEste documento descreve o plano inicial do projeto atrav\u00e9s de um cronograma feito com o aux\u00edlio do \nMicrosoft Project. No cronograma est\u00e3o descritas as datas de in\u00edcio e fim das atividades inerentes a \nessa fase do projeto. \n\n2. Cronograma \n\n \n\n\n\n \n\n\n\n \n\n  \n\n187 \n\n \n\n \n\n \n\nAP\u00caNDICE G \u2013 Artefato do RUP de Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Analysis &amp; Design - An\u00e1lise e Design \n\nPapel: Designer - Designer \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \n\nPa\u00eds \nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 9 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n03/06/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 9 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Fluxo de Eventos \u2013 Design 4 \n\n3. Realiza\u00e7\u00e3o do Caso de Uso 4 \n\n4. Diagrama de Classes para An\u00e1lise 5 \n\n5. Diagramas de Seq\u00fc\u00eancia 6 \n5.1 Atualizar 6 \n5.2 Consultar 7 \n5.3 Excluir 8 \n5.4 Incluir 9 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 9 \n\n \n\nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \nPa\u00eds \n\nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n1. Introdu\u00e7\u00e3o \n\nEste caso de uso tem por finalidade realizar a manuten\u00e7\u00e3o de dados do pa\u00eds. \n\n1.1 Objetivo \n\nRealizar e manter o cadastro de Pa\u00eds. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n2. Fluxo de Eventos \u2013 Design \n\n \nIniciado por: Ator Usu\u00e1rio \n\nO usu\u00e1rio poder\u00e1 cadastrar novos Pa\u00edses quando clicar no bot\u00e3o novo da tela de consulta. Para realizar \na altera\u00e7\u00e3o ou exclus\u00e3o o usu\u00e1rio dever\u00e1 realizar primeiramente a consulta de pa\u00edses e ent\u00e3o selecionar \num para que o mesmo seja editado. Nesse momento o usu\u00e1rio poder\u00e1 escolher se quer excluir ou \nalterar.  \n\n \n\n3. Realiza\u00e7\u00e3o do Caso de Uso \n\nRepresenta a rela\u00e7\u00e3o entre o modelo conceitual e o modelo de implementa\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 9 \n\n \n\n \n\n4. Diagrama de Classes para An\u00e1lise \n\n \n\n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 9 \n\n \n\n5. Diagramas de Seq\u00fc\u00eancia \n\n \n \n\n5.1 Atualizar \n\n \n\n \n \n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 9 \n\n \n\n5.2 Consultar \n\n \n\n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 8 de 9 \n\n \n\n5.3 Excluir \n\n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Pa\u00eds Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Pa\u00eds).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 9 de 9 \n\n \n\n5.4 Incluir \n\n \n\n \n \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Analysis &amp; Design - An\u00e1lise e Design \n\nPapel: Designer - Designer \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \n\nEstado \nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 9 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n03/06/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 9 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Fluxo de Eventos \u2013 Design 4 \n\n3. Realiza\u00e7\u00e3o do Caso de Uso 4 \n\n4. Diagrama de Classes para An\u00e1lise 5 \n\n5. Diagramas de Seq\u00fc\u00eancia 6 \n5.1 Atualizar 6 \n5.2 Consultar 7 \n5.3 Excluir 8 \n5.4 Incluir 9 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 9 \n\n \n\nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \nEstado \n\nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n1. Introdu\u00e7\u00e3o \n\nEste caso de uso tem por finalidade realizar a manuten\u00e7\u00e3o de dados do estado. \n\n1.1 Objetivo \n\nRealizar e manter o cadastro de Estado. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n2. Fluxo de Eventos \u2013 Design \n\n \nIniciado por: Ator Usu\u00e1rio \n\n \n\nO usu\u00e1rio poder\u00e1 cadastrar novos Estados quando clicar no bot\u00e3o novo da tela de consulta. Para \nrealizar a altera\u00e7\u00e3o ou exclus\u00e3o o usu\u00e1rio dever\u00e1 realizar primeiramente a consulta de estados e ent\u00e3o \nselecionar um para que o mesmo seja editado. Nesse momento o usu\u00e1rio poder\u00e1 escolher se quer \nexcluir ou alterar.  \n\n \n\n3. Realiza\u00e7\u00e3o do Caso de Uso \n\nRepresenta a rela\u00e7\u00e3o entre o modelo conceitual e o modelo de implementa\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 9 \n\n \n\n \n\n \n\n4. Diagrama de Classes para An\u00e1lise \n\n \n\n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 9 \n\n \n\n5. Diagramas de Seq\u00fc\u00eancia \n\n \n \n\n5.1 Atualizar \n\n \n\n \n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 9 \n\n \n\n5.2 Consultar \n\n \n\n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 8 de 9 \n\n \n\n5.3 Excluir \n\n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Estado Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Estado).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 9 de 9 \n\n \n\n5.4 Incluir \n\n \n\n \n \n\n \n\n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Analysis &amp; Design - An\u00e1lise e Design \n\nPapel: Designer - Designer \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \n\nCidade \nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 9 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n03/06/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 9 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Fluxo de Eventos \u2013 Design 4 \n\n3. Realiza\u00e7\u00e3o do Caso de Uso 4 \n\n4. Diagrama de Classes para An\u00e1lise 5 \n\n5. Diagramas de Seq\u00fc\u00eancia 6 \n5.1 Atualizar 6 \n5.2 Consultar 7 \n5.3 Excluir 8 \n5.4 Incluir 9 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 9 \n\n \n\nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \nCidade \n\nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n1. Introdu\u00e7\u00e3o \n\nEste caso de uso tem por finalidade realizar a manuten\u00e7\u00e3o de dados da cidade. \n\n1.1 Objetivo \n\nRealizar e manter o cadastro de Cidades. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n2. Fluxo de Eventos \u2013 Design \n\n \nIniciado por: Ator Usu\u00e1rio \n\n \n\nO usu\u00e1rio poder\u00e1 cadastrar novas Cidades quando clicar no bot\u00e3o novo da tela de consulta. Para \nrealizar a altera\u00e7\u00e3o ou exclus\u00e3o o usu\u00e1rio dever\u00e1 realizar primeiramente a consulta de cidades e ent\u00e3o \nselecionar um para que o mesmo seja editado. Nesse momento o usu\u00e1rio poder\u00e1 escolher se quer \nexcluir ou alterar.  \n\n \n\n3. Realiza\u00e7\u00e3o do Caso de Uso \n\nRepresenta a rela\u00e7\u00e3o entre o modelo conceitual e o modelo de implementa\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 9 \n\n \n\n \n\n \n\n \n\n \n\n4. Diagrama de Classes para An\u00e1lise \n\n \n\n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 9 \n\n \n\n5. Diagramas de Seq\u00fc\u00eancia \n\n5.1 Atualizar \n\n \n\n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 9 \n\n \n\n5.2 Consultar \n\n \n\n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 8 de 9 \n\n \n\n5.3 Excluir \n\n \n\n \n \n \n\n \n \n \n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cidade Data de Cria\u00e7\u00e3o: 19-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cidade).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 9 de 9 \n\n \n\n5.4 Incluir \n\n \n \n\n \n \n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Analysis &amp; Design - An\u00e1lise e Design \n\nPapel: Designer - Designer \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira  \n \n\nSistema Manuten\u00e7\u00e3o \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \n\nCliente \nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 2 de 9 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n03/06/2006 1.0 Edi\u00e7\u00e3o Inicial Jefferson Oliveira \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane Werlang \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 3 de 9 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. 4 \n\n2. Fluxo de Eventos \u2013 Design 4 \n\n3. Realiza\u00e7\u00e3o do Caso de Uso 4 \n\n4. Diagrama de Classes para An\u00e1lise 5 \n\n5. Diagramas de Seq\u00fc\u00eancia 6 \n5.1 Atualizar 6 \n5.2 Consultar 7 \n5.3 Excluir 8 \n5.4 Incluir 9 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 4 de 9 \n\n \n\nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de \nCliente \n\nEspecifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso \n\n1. Introdu\u00e7\u00e3o \n\nEste caso de uso tem por finalidade realizar a manuten\u00e7\u00e3o de dados do Cliente. \n\n1.1 Objetivo \n\nRealizar e manter o cadastro de Clientes. \n\n1.2 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es. \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n2. Fluxo de Eventos \u2013 Design \n\nIniciado por: Ator Usu\u00e1rio \n\nO usu\u00e1rio poder\u00e1 cadastrar novos Clientes quando clicar no bot\u00e3o novo da tela de consulta. Para \nrealizar a altera\u00e7\u00e3o ou exclus\u00e3o o usu\u00e1rio dever\u00e1 realizar primeiramente a consulta de clientes e ent\u00e3o \nselecionar um para que o mesmo seja editado. Nesse momento o usu\u00e1rio poder\u00e1 escolher se quer \nexcluir ou alterar.  \n\n3. Realiza\u00e7\u00e3o do Caso de Uso \n\nRepresenta a rela\u00e7\u00e3o entre o modelo conceitual e o modelo de implementa\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 5 de 9 \n\n \n\n4. Diagrama de Classes para An\u00e1lise \n\n \n \n\n \n \n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 6 de 9 \n\n \n\n5. Diagramas de Seq\u00fc\u00eancia \n\n \n\n5.1 Atualizar \n\n \n\n \n \n \n \n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 7 de 9 \n\n \n\n5.2 Consultar \n\n \n\n \n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 8 de 9 \n\n \n\n5.3 Excluir \n\n \n\n \n \n\n \n\n \n\n \n\n \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nUse-Case-Realization Specification: Manuten\u00e7\u00e3o de Cliente Data de Cria\u00e7\u00e3o: 25-jun-2006 \nArquivo: G - Especifica\u00e7\u00e3o da Realiza\u00e7\u00e3o do Caso de Uso (Manuten\u00e7\u00e3o de Cliente).doc \n \n\nArtefato de Projeto ? Luciane Pires Werlang &amp; \nJefferson Amorim de Oliveira, \n\n2006 \n\nP\u00e1gina 9 de 9 \n\n \n\n5.4 Incluir \n\n \n\n \n\n \n\n\n\n \n\n  \n\n224 \n\n \n\n \n\n \n\nAP\u00caNDICE H \u2013 Artefato do RUP de Plano de Implementa\u00e7\u00e3o \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Implementation - Implementa\u00e7\u00e3o \n\nPapel: Integrator - Integrador \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nIntegration Build Plan \n\nPlano de Constru\u00e7\u00e3o de Integra\u00e7\u00e3o \n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIntegration Build Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: H - Plano de Implementa\u00e7\u00e3o.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 2 de 5 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n10/09/2006 1.0 Edi\u00e7\u00e3o Inicial Luciane e Jefferson \n\n05/11/2006 1.1 Revis\u00e3o Final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIntegration Build Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: H - Plano de Implementa\u00e7\u00e3o.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 3 de 5 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es 4 \n1.2 Vis\u00e3o Geral 4 \n\n2. Sub-Sitemas 4 \n\n3. Constru\u00e7\u00f5es 4 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIntegration Build Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: H - Plano de Implementa\u00e7\u00e3o.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 4 de 5 \n\n \n\nIntegration Build Plan \nPlano de Constru\u00e7\u00e3o de Integra\u00e7\u00e3o \n\n1. Introdu\u00e7\u00e3o \n\nEste documento inclui as defini\u00e7\u00f5es, acr\u00f4nimos, abrevia\u00e7\u00f5es, a vis\u00e3o geral do Build Plan (Plano de \nConstru\u00e7\u00e3o de Integra\u00e7\u00e3o). \n\n1.1 Defini\u00e7\u00f5es, Acr\u00f4nimos e Abrevia\u00e7\u00f5es \n\nEst\u00e3o descritas no Gloss\u00e1rio (AP\u00caNDICE J). \n\n1.2 Vis\u00e3o Geral \n\nEste Plano de Constru\u00e7\u00e3o descreve os procedimentos adotados para iniciar a implementa\u00e7\u00e3o do \nsistema.  \n\n2. Sub-Sitemas \n\nO sistema que ser\u00e1 implementado \u00e9 composto por pacotes distintos. Esses pacotes s\u00e3o implementados \nna seguinte ordem: Pacote Pa\u00eds, Pacote Estado, Pacote Cidade, Pacote Cliente.  \n\n   \n\n3. Constru\u00e7\u00f5es \n\nEsta se\u00e7\u00e3o especifica quais constru\u00e7\u00f5es criar e quais sub-sistemas far\u00e3o parte de cada constru\u00e7\u00e3o. Para \ncada constru\u00e7\u00e3o \u00e9 necess\u00e1rio especificar como a constru\u00e7\u00e3o \u00e9 feita, o crit\u00e9rio para sua avalia\u00e7\u00e3o e como \nele ser\u00e1 testado, em particular: \n\n\u2022 Manuten\u00e7\u00e3o de Pa\u00eds \n\nConstru\u00e7\u00e3o \n\n Foram gerados os scripts necess\u00e1rios para criar no banco de dados a tabela para desenvolver as \nopera\u00e7\u00f5es de inclus\u00e3o, altera\u00e7\u00e3o, exclus\u00e3o e consulta. \n\n \n\nAvalia\u00e7\u00e3o e Teste \n\n A cada parte implementada foram feitos testes para ver se as opera\u00e7\u00f5es estavam sendo \natendidas. \n\n \n\n\u2022 Manuten\u00e7\u00e3o do Estado \n\nConstru\u00e7\u00e3o \n\n Foram gerados os scripts necess\u00e1rios para criar no banco de dados as tabelas para desenvolver as \nopera\u00e7\u00f5es de inclus\u00e3o, altera\u00e7\u00e3o, exclus\u00e3o e consulta. Neste caso, o cadastro de estado necessitava de \num Pa\u00eds. \n\n \n\nAvalia\u00e7\u00e3o e Teste \n\n A cada parte implementada foram feitos testes para ver se as opera\u00e7\u00f5es estavam sendo \natendidas. \n\n \n\n\u2022 Manuten\u00e7\u00e3o do Cidade \n\nConstru\u00e7\u00e3o \n\n Foram gerados os scripts necess\u00e1rios para criar no banco de dados as tabelas para desenvolver as \nopera\u00e7\u00f5es de inclus\u00e3o, altera\u00e7\u00e3o, exclus\u00e3o e consulta. Neste caso, o cadastro de estado necessitava de \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nIntegration Build Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: H - Plano de Implementa\u00e7\u00e3o.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 5 de 5 \n\n \n\num Estado e um Pa\u00eds. \n\n \n\nAvalia\u00e7\u00e3o e Teste \n\n A cada parte implementada foram feitos testes para ver se as opera\u00e7\u00f5es estavam sendo \natendidas. \n\n \n\n\u2022 Manuten\u00e7\u00e3o do Cliente \n\nConstru\u00e7\u00e3o \n\n Foram gerados os scripts necess\u00e1rios para criar no banco de dados as tabelas para desenvolver as \nopera\u00e7\u00f5es de inclus\u00e3o, altera\u00e7\u00e3o, exclus\u00e3o e consulta. Neste caso, o cadastro de estado necessitava de \num Estado e um Pa\u00eds e uma Cidade. \n\n \n\nAvalia\u00e7\u00e3o e Teste \n\n A cada parte implementada foram feitos testes para ver se as opera\u00e7\u00f5es estavam sendo \natendidas. \n\n \n\n\u2022 Pesquisar \n\nConstru\u00e7\u00e3o \n\n Foram gerados os scripts necess\u00e1rios para criar no banco de dados as tabelas que ser\u00e3o utilizadas \npara realizar essa funcionalidade. \n\n \n\nAvalia\u00e7\u00e3o e Teste \n\n A cada parte implementada foram feitos testes para ver se as opera\u00e7\u00f5es estavam sendo \natendidas. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n  \n\n230 \n\n \n\n \n\n \n\nAP\u00caNDICE I \u2013 Artefato do RUP de Plano de Teste \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson Oliveira \n \n\n \n\nDisciplina: Test - Teste \n\nPapel: Teste Manager - Gerente de Teste \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nTest Plan \n\nPlano de Teste \n \n\nVers\u00e3o 1.1 \n \n\n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nTest Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: I - Plano de Teste.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 2 de 6 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n15/10/2006 1.0 Edi\u00e7\u00e3o Inicial Luciane e Jefferson \n\n02/11/2006 1.1 Revis\u00e3o Final Luciane e Jefferson \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nTest Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: I - Plano de Teste.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 3 de 6 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n1.1 Objetivo 4 \n1.2 Identifica\u00e7\u00e3o do Projeto 4 \n\n2. Requisitos para Teste 4 \n\n3. Estrat\u00e9gia de Teste 4 \n3.1 Tipos de Teste 4 \n\n3.1.1 Teste da Integridade de Dados e Banco de Dados 4 \n3.1.2 Teste de Fun\u00e7\u00e3o 5 \n3.1.3 Teste da Interface de Usu\u00e1rio 5 \n\n4. Recursos 6 \n4.1 Cargos 6 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nTest Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: I - Plano de Teste.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 4 de 6 \n\n \n\nTest Plan \nPlano de Teste \n\n1. Introdu\u00e7\u00e3o \n\nO Test Plan (Plano de Teste) fornece uma vis\u00e3o geral sobre os testes realizados no sistema \n\n1.1 Objetivo \n\nDescrever os testes realizados no sistema. \n\n1.2 Identifica\u00e7\u00e3o do Projeto \n\nA tabela a seguir identifica a documenta\u00e7\u00e3o e disponibilidade usada para o desenvolvimento do test \nplan (plano de teste): \n\nDocumento  \n(e vers\u00e3o / data) \n\nCriado ou \nDispon\u00edvel \n\nFoi Aceito ou \nAnalisado \n\nEspecifica\u00e7\u00e3o de Requisitos ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nEspecifica\u00e7\u00e3o Funcional ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nRelat\u00f3rios de Caso de Uso ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nPlano de Projeto ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nEspecifica\u00e7\u00e3o de Design ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nProt\u00f3tipo ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nManuais do Usu\u00e1rio ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nModelo ou Fluxo de Dados ? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\nFun\u00e7\u00f5es e Regras de \nNeg\u00f3cios \n\n? Sim  ? N\u00e3o ? Sim  ? N\u00e3o \n\n2. Requisitos para Teste \n\nA lista abaixo identifica aqueles itens \u2013 casos de uso, requisitos funcionais, e n\u00e3o-funcionais \u2013 que tem \nsido identificados como objetivo do teste. Esta lista representa o que ser\u00e1 testado.  \n\nManuten\u00e7\u00e3o de Pa\u00eds; \n\nManuten\u00e7\u00e3o de Estado; \n\nManuten\u00e7\u00e3o de Cidade; \n\nManuten\u00e7\u00e3o de Cliente; \n\nPesquisar; \n\n3. Estrat\u00e9gia de Teste \n\nA Estrat\u00e9gia de Teste apresenta uma aproxima\u00e7\u00e3o recomendada para o teste do alvo de teste. A se\u00e7\u00e3o \nanterior, Requisitos para Teste, descreveu o que ser\u00e1 testado \u2013 isto descreve como o alvo de teste ser\u00e1 \ntestado. \n\n3.1 Tipos de Teste \n\n3.1.1 Teste da Integridade de Dados e Banco de Dados \n\nOs bancos de dados e os processos de banco de dados deveriam ser testados como um subsistema \ndentro do Sistema Manuten\u00e7\u00e3o. Estes subsistemas deveriam ser testados sem a Interface de Usu\u00e1rio do \nAlvo de Teste como interface dos dados. Pesquisas adicionais dentro do Sistema de Gerenciamento de \nBanco de Dados (DBMS - Database Management System) precisam ser executadas para identificar as \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nTest Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: I - Plano de Teste.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 5 de 6 \n\n \n\nferramentas e t\u00e9cnicas que devem existir para apoiar o teste identificado abaixo. \n\n \n\nObjetivo de Teste: Assegure que os m\u00e9todos e processos de acesso ao banco de dados \nfuncionem corretamente e sem corrup\u00e7\u00e3o (perda) de dados. \n\nT\u00e9cnica: A cada fun\u00e7\u00e3o implementada ser\u00e1 testada sua funcionalidade perante o \nbanco de dados.   \n\nCrit\u00e9rio de Finaliza\u00e7\u00e3o: Todos os m\u00e9todos e processos de acesso ao banco de dados funcionam \ncomo descritos e sem qualquer corrup\u00e7\u00e3o de dados. \n\nConsidera\u00e7\u00f5es \nEspeciais: \n\nA conex\u00e3o com o banco de dados \u00e9 feita via JDBC, sendo que a \nbiblioteca \u00e9 adquirida por meio de seus desenvolvedores. \n\n \n\n3.1.2 Teste de Fun\u00e7\u00e3o \n\nTeste de fun\u00e7\u00e3o pode ser tra\u00e7ado diretamente para os casos de uso ou fun\u00e7\u00f5es de neg\u00f3cios e regras de \nneg\u00f3cios. As metas destes testes s\u00e3o verificar aceita\u00e7\u00e3o de dados adequados, processamento, retorno e \na implementa\u00e7\u00e3o apropriada das regras de neg\u00f3cio. Este tipo de teste \u00e9 baseado na t\u00e9cnica de caixa \npreta; que \u00e9 verificar a aplica\u00e7\u00e3o e seus processos internos interagindo com as aplica\u00e7\u00f5es via Gr\u00e1ficos \nda Interface do Usu\u00e1rio (GUI) e analisando as sa\u00eddas ou resultados. A tabela a seguir identifica a \ndescri\u00e7\u00e3o do teste recomendado para cada aplica\u00e7\u00e3o: \n\n \n\nObjetivos de Teste: Assegure uma correta funcionalidade do alvo de teste, incluindo \nnavega\u00e7\u00e3o, entrada de dados, processamento, e retorno. \n\nT\u00e9cnica: Para cada fun\u00e7\u00e3o implementada  \u00e9 realizado testes com diversos tipos \nde inser\u00e7\u00f5es e observar se o comportamento da aplica\u00e7\u00e3o \u00e9 o esperado. \n\nTamb\u00e9m ser\u00e3o realizados os mesmos testes para as exclus\u00f5es, \naltera\u00e7\u00f5es e consultas. \n\nCrit\u00e9rio de Finaliza\u00e7\u00e3o: \u2022    Todos os testes planejados tem sido executados. \n\n\u2022   Todos os defeitos identificados tem sido enfocados. \n\nConsidera\u00e7\u00f5es \nEspeciais: \n\nOs testes ser\u00e3o baseados em cima da aplica\u00e7\u00e3o. \n\n \n\n3.1.3 Teste da Interface de Usu\u00e1rio \n\n Teste da Interface de Usu\u00e1rio (UI) verifica uma intera\u00e7\u00e3o do usu\u00e1rio com o software. O objetivo do \nteste de UI \u00e9 ter certeza que a UI fornece ao usu\u00e1rio acesso e navega\u00e7\u00e3o apropriados atrav\u00e9s de fun\u00e7\u00f5es \ndo objetivo de teste. Al\u00e9m disso, teste de UI traz a certeza que os objetos dentro das fun\u00e7\u00f5es de UI \ncomo esperado e conforme aos padr\u00f5es da corpora\u00e7\u00e3o ou ind\u00fastria. \n\nObjetivos de Teste: \u2022    A Navega\u00e7\u00e3o atrav\u00e9s do alvo de teste refletindo as fun\u00e7\u00f5es de neg\u00f3cio e \nrequisitos, incluindo janela para janela, campo para campo e o uso de m\u00e9todos \nde acesso (tecla tab, movimentos do mouse) \n\n\u2022   Objetos de janela e caracter\u00edsticas,  podem ser exercitados \u2013 assim como \nmenus, tamanhos, posi\u00e7\u00f5es, estados e foco conforme padr\u00e3o. \n\nT\u00e9cnica: Verificar a ordem l\u00f3gica dos bot\u00f5es nas telas; \n\nA ordem da tecla tab na navega\u00e7\u00e3o das telas; \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nTest Plan Data de Cria\u00e7\u00e3o: 28-mai-2006 \nArquivo: I - Plano de Teste.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nOliveira, 2006 \n\nP\u00e1gina 6 de 6 \n\n \n\nCrit\u00e9rio de Finaliza\u00e7\u00e3o: Cada janela \u00e9 verificada com sucesso para ficar consistente com vers\u00e3o de \navalia\u00e7\u00e3o de execu\u00e7\u00e3o ou dentro de padr\u00e3o aceit\u00e1vel. \n\nConsidera\u00e7\u00f5es \nEspeciais: \n\n \n\n \n\n4. Recursos \n\nEsta se\u00e7\u00e3o apresenta os recursos recomendados para o projeto Sistema Manuten\u00e7\u00e3o, suas principais \nresponsabilidades, e seus conhecimentos ou grupo de conhecimento profissional. \n\n4.1 Cargos \n\nEsta tabela mostra a concep\u00e7\u00e3o de grupo de trabalho para o projeto. \n\nTrabalhador Responsabilidades Espec\u00edficas ou Coment\u00e1rios \n\nTester (Validador) Executa os testes. \n\nResponsabilidades: \n\n\u2022 Executa testes \n\n\u2022 Arquiva resultados \n\n\u2022 Recupera erros \n\n\u2022 Documenta requisitos de mudan\u00e7a \n\n\u2022 Administrar os dados de teste (banco de \ndados) \n\n \n\n\n\n \n\n  \n\n237 \n\n \n\n \n\n \n\nAP\u00caNDICE J \u2013 Artefato do RUP de Gloss\u00e1rio \n\n \n \n \n \n \n \n \n \n \n \n\n\n\n \n \n\nLuciane Werlang &amp; Jefferson de Oliveira \n \n\n \n\nDisciplina: Requirements - Requisitos \n\nPapel: System Analyst - Analista de Sistema \n\nIndiv\u00edduo: Luciane Pires Werlang &amp; Jefferson Amorim de Oliveira \n \n\nSistema Manuten\u00e7\u00e3o \nGlossary \n\nGloss\u00e1rio \n \n\nVers\u00e3o 1.1 \n \n\n \n  \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nGlossary Data de Cria\u00e7\u00e3o: 28-May-2006 \nArquivo: J - Gloss\u00e1rio.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 2 de 5 \n\n \n\nHist\u00f3rico de Revis\u00f5es \n \n\nData Vers\u00e3o Descri\u00e7\u00e3o Autor \n\n13/06/2006 1.0 Edi\u00e7\u00e3o inicial Luciane &amp; Jefferson \n\n04/11/2006 1.1 Revis\u00e3o Final Jefferson Oliveira \n\n \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nGlossary Data de Cria\u00e7\u00e3o: 28-May-2006 \nArquivo: J - Gloss\u00e1rio.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 3 de 5 \n\n \n\nSum\u00e1rio \n\n1. Introdu\u00e7\u00e3o 4 \n\n2. Defini\u00e7\u00f5es 4 \n2.1 Apache Tomcat 4 \n2.2 Browser 4 \n2.3 Caso de Uso 4 \n2.4 Deploy 4 \n2.5 EJBs 4 \n2.6 GUI 4 \n2.7 HTML 4 \n2.8 Internet 4 \n2.9 Java 4 \n2.10 JavaScript 4 \n2.11 JSP 5 \n2.12 XML 5 \n2.13 DTD 5 \n2.14 Login 5 \n2.15 Protocolo HTTP 5 \n2.16 Protoloco TCP/IP 5 \n2.17 Servlet 5 \n2.18 Templates 5 \n2.19 UML 5 \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nGlossary Data de Cria\u00e7\u00e3o: 28-May-2006 \nArquivo: J - Gloss\u00e1rio.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 4 de 5 \n\n \n\nGlossary \nGloss\u00e1rio \n\n1. Introdu\u00e7\u00e3o \n\nEste documento \u00e9 usado para definir nomenclaturas espec\u00edficas ao dom\u00ednio do problema, explicando os \ntermos que podem n\u00e3o ser familiar ao leitor nas descri\u00e7\u00f5es dos Casos de Uso ou em outros documentos \ndo projeto. \n\n2. Defini\u00e7\u00f5es \n\nOs termos definidos aqui formam \u00e0 subst\u00e2ncia essencial do documento.  \n\n2.1 Apache Tomcat \n\nTomcat \u00e9 um Container Web, parte da plataforma J2EE que abrange as tecnologias Servlet e JSP. \n\n2.2 Browser \n\nUm navegador (tamb\u00e9m conhecido como web browser ou simplesmente browser) \u00e9 um programa que \nhabilita seus usu\u00e1rios a interagirem com documentos HTML hospedados em um servidor Web. \n\n2.3 Caso de Uso \n\n\u00c9 uma t\u00e9cnica para capturar os requisitos potenciais de um novo sistema ou mudan\u00e7a do sistema. Cada \ncaso de uso fornece um ou mais cen\u00e1rios, que mostram como o sistema deve interagir com o usu\u00e1rio \nfinal ou um outro sistema, para conseguir um objetivo de neg\u00f3cio espec\u00edfico. Os casos de uso evitam \ntipicamente a linguagem t\u00e9cnica, preferindo a l\u00edngua natural do usu\u00e1rio final.  \n\n2.4 Deploy \n\nA distribui\u00e7\u00e3o (deploy) do projeto. \n\n2.5 EJBs \n\nUtilizados no desenvolvimento de componentes de software. Eles permitem que o programador se \nconcentre nas necessidades do neg\u00f3cio do cliente, enquanto quest\u00f5es de infra-estrutura, seguran\u00e7a, \ndisponibilidade e escalabilidade s\u00e3o responsabilidade do servidor de aplica\u00e7\u00f5es. \n\n2.6 GUI \n\nInterface gr\u00e1fica (GUI, do ingl\u00eas Graphical User Interface) \u00e9 um mecanismo de intera\u00e7\u00e3o entre usu\u00e1rio \ne sistema de computador baseado em s\u00edmbolos visuais, como \u00edcones, menus e janelas. \n\n2.7 HTML \n\nHyperText Markup Language (HTML) \u00e9 uma linguagem de marca\u00e7\u00e3o utilizada para produzir p\u00e1ginas \nna Internet. Esses c\u00f3digos podem ser interpretados pelos browsers para exibir as p\u00e1ginas da World \nWide Web. \n\n2.8 Internet \n\nA Internet \u00e9 uma rede em escala mundial de milh\u00f5es de computadores que permite o acesso a \ninforma\u00e7\u00f5es e todo tipo de transfer\u00eancia de dados. \n\n2.9 Java \n\n\u00c9 uma linguagem de programa\u00e7\u00e3o orientada a objeto desenvolvida na d\u00e9cada de 90 pelo programador \nJames Gosling, na empresa Sun Microsystems. Diferentemente das linguagens convencionais, que s\u00e3o \ncompiladas para c\u00f3digo nativo, a linguagem Java \u00e9 compilada para um bytecode que \u00e9 executado por \numa m\u00e1quina virtual. \n\n \n\n2.10 JavaScript \n\nJavaScript \u00e9 uma linguagem de programa\u00e7\u00e3o criada pela Netscape, para valida\u00e7\u00e3o de formul\u00e1rios e \nintera\u00e7\u00e3o com p\u00e1ginas da web. \n\n\n\nSistema Manuten\u00e7\u00e3o Vers\u00e3o:  1.1 \nGlossary Data de Cria\u00e7\u00e3o: 28-May-2006 \nArquivo: J - Gloss\u00e1rio.doc \n \n\nArtefato de Projeto ?Luciane Werlang &amp; Jefferson \nde Oliveira, 2006 \n\nP\u00e1gina 5 de 5 \n\n \n\n2.11 JSP \n\nJava Server Pages (JSP) \u00e9 uma tecnologia para desenvolvimento de aplica\u00e7\u00f5es WEB. Permite que \nconte\u00fado din\u00e2mico seja facilmente desenvolvido. \n\n2.12 XML \n\nExtensible Markup Language (XML) \u00e9 um subtipo de Standard Generalized Markup Language - \nLinguagem Padronizada de Marca\u00e7\u00e3o Generica (SGML) capaz de descrever diversos tipos de dados. \nSeu prop\u00f3sito principal \u00e9 a facilidade de compartilhamento de informa\u00e7\u00f5es atrav\u00e9s da Internet. \n\n2.13 DTD \n\nDefini\u00e7\u00e3o de Tipo de Documento (DTD), que serve para especificar quais elementos ou atributos s\u00e3o \npermitidos no documento XML e em que local do documento eles podem aparecer. Podemos definir, \nent\u00e3o, que o DTD \u00e9 uma forma de validar o documento XML. \n\n2.14 Login \n\nIn\u00edcio de uma sess\u00e3o, ou seja, a entrada do usu\u00e1rio no sistema. \n\n2.15 Protocolo HTTP \n\nHyper Text Transfer Protocol - Protocolo de Transfer\u00eancia de Hipertexto (HTTP)  \u00e9 um protocolo da \ncamada de \"Aplica\u00e7\u00e3o\" do modelo OSI, utilizado para transfer\u00eancia de dados na World Wide Web. \n\n2.16 Protoloco TCP/IP \n\nS\u00e3o protocolos de comunica\u00e7\u00e3o, o protocolo  Transmission Control Protocol  - Protocolo de Controle \nde Transmiss\u00e3o (TCP) e o Internet Protocol  - Protocolo Internet (IP).  \n\n2.17 Servlet \n\nServlet \u00e9 um programa que estende a funcionalidade de um web server, gerando conte\u00fado din\u00e2mico e \ninteragindo com os clientes, utilizando o modelo request/response. \n\n2.18 Templates \n\nS\u00e3o moldes, foram usados para gerar os artefatos (AP\u00caNDICES). \n\n2.19 UML \n\nA Unified Modeling Language (UML) \u00e9 uma linguagem de modelagem. Permite que desenvolvedores \nvisualizem os produtos de seu trabalho em diagramas padronizados. Junto com uma nota\u00e7\u00e3o gr\u00e1fica, a \nUML tamb\u00e9m especifica significados, isto \u00e9, a sem\u00e2ntica."}]}}}