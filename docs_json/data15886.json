{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.19337"}, {"@name": "filename", "#text": "2660_PFC_2016-1%20Rodrigo_da_Silva_Gesser.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Simulador de Processos e Controle\nPreditivo para a Ind\u00fastria de Petr\u00f3leo\n\ne G\u00e1s\n\nRelat\u00f3rio submetido \u00e0 Universidade Federal de Santa Catarina\n\ncomo requisito para a aprova\u00e7\u00e3o da disciplina:\n\nDAS 5511: Projeto de Fim de Curso\n\nRodrigo da Silva Gesser\n\nFlorian\u00f3polis, Agosto de 2016\n\n\n\n\n\nSimulador de Processos e Controle Preditivo para a\nInd\u00fastria de Petr\u00f3leo e G\u00e1s\n\nRodrigo da Silva Gesser\n\nEsta monografia foi julgada no contexto da disciplina\n\nDAS 5511: Projeto de Fim de Curso\n\ne aprovada na sua forma final pelo\n\nCurso de Engenharia de Controle e Automa\u00e7\u00e3o\n\nProf. Daniel Martins Lima\n\n\n\nBanca Examinadora:\n\nProf. Julio Elias Normey Rico\nOrientador na Empresa\n\nProf. Daniel Martins Lima\nOrientador no Curso\n\nProf. Hector Bessa Silveira\nRespons\u00e1vel pela disciplina\n\nProf. Jos\u00e9 Dolores Vergara Dietrich, Avaliador\n\nAmadeu Pl\u00e1cido Neto, Debatedor\n\nPedro Augusto Ceriotti, Debatedor\n\n\n\nAgradecimentos\n\nAo Professor Julio Elias Normey-Rico pela orienta\u00e7\u00e3o e confian\u00e7a no meu\ntrabalho, dando a aten\u00e7\u00e3o e o conhecimento necess\u00e1rio.\n\nAo Professor Daniel Martins Lima que trabalhou continuamente comigo e teve\npapel fundamental no decorrer do projeto e seu desenvolvimento.\n\n\u00c0 ANP e ao PRH-34 pela oportunidade oferecida e o apoio ao longo do projeto.\n\n\u00c0 minha fam\u00edlia, amigos e namorada pelo carinho incondicional.\n\n\n\n\n\nResumo\n\nA an\u00e1lise e identifica\u00e7\u00e3o de processos industriais melhora a percep\u00e7\u00e3o do engenheiro\nacerca das a\u00e7\u00f5es que devem ser tomadas em diversos cen\u00e1rios na ind\u00fastria. Na \u00e1rea\nda engenharia de controle, o entendimento do processo \u00e9 essencial para que a sintonia\ne configura\u00e7\u00e3o de controladores tenham resultados satisfat\u00f3rios, por\u00e9m a an\u00e1lise pode\nser dificultada caso o processo seja muito complexo e tamb\u00e9m caso controladores\navan\u00e7ados sejam utilizados, tornando essa sintonia dispendiosa e lenta. Dessa forma,\nsimuladores podem ser empregados para auxiliar na sintonia do controlador, na an\u00e1lise\ndo processo e na tomada de decis\u00e3o em diferentes cen\u00e1rios, reduzindo o tempo gasto\nrealizando essas tarefas. Por\u00e9m, o maior problema de se utilizar um simulador est\u00e1 no\ncusto elevado para a obten\u00e7\u00e3o de licen\u00e7as, principalmente nos que simulam processos\ne controladores avan\u00e7ados. Uma solu\u00e7\u00e3o para esse problema seria o desenvolvimento\nde uma ferramenta de alta qualidade com baixo custo e que tornasse poss\u00edvel a\nsimula\u00e7\u00e3o de diferentes cen\u00e1rios industriais, a sintonia de controladores avan\u00e7ados\n(especificamente controladores preditivos baseados em modelo) e a an\u00e1lise e estudo\ndo processo. Portanto, neste trabalho \u00e9 apresentado um projeto desenvolvido junto ao\nPRH-34 que implementa uma interface gr\u00e1fica capaz de simular processos industriais,\nal\u00e9m de controladores preditivos, na linguagem de programa\u00e7\u00e3o Python para contornar\no problema da aquisi\u00e7\u00e3o de licen\u00e7as, visto que o Python \u00e9 uma linguagem aberta\n(open source) e sem custos. O software criado \u00e9 apto a simular matematicamente\nsistemas industriais a partir de modelos matem\u00e1ticos, gerando gr\u00e1ficos com a resposta\nda simula\u00e7\u00e3o de forma intuitiva e de f\u00e1cil leitura para o usu\u00e1rio. Para auxiliar o uso da\ninterface tamb\u00e9m foi implementada uma biblioteca que cont\u00e9m modelos de processos\nmuito comuns na ind\u00fastria e amplamente estudados na literatura.\n\nPalavras-chave: Controle de Processos. Controle Preditivo. Desenvolvimento de Soft-\nware. Python.\n\n\n\n\n\nAbstract\n\nThe analysis and identification of industrial processes improve the engineer\u2019s percep-\ntion about the actions that must be taken in several scenarios in industry. In Control\nEngineering, the process understanding is essential for design and configuration of\ncontrollers in order to obtain satisfactory results, however the analysis might be difficult\nif the process is more complex and also if advanced controllers are used, turning the\ndesign of the controller slow and costly. Therefore, simulators might be used so that it\ncould help the configuration of the controller, analysis of the process and the decision-\nmaking in different scenarios, reducing the time spent accomplishing this task. The\ngreatest problem in using simulators is the high cost to obtain the software\u2019s license,\nmainly when using advanced controllers and complex processes. A solution for this\nproblem is to develop a high quality software with a lower cost which implemented the\nsimulation of different industrial scenarios, design of advanced controllers (focusing\non model predictive controllers) and the analysis and study of the process. Thus, this\npaper presents a project developed with the collaboration of PRH-34 that implements\na graphic interface capable of simulating industrial processes, aside from predictive\ncontrollers, using the Python as the programming language to solve the license acqui-\nsition problem, since Python is an Open Source language. The software is capable\nof simulating industrial systems using mathematical models, and to plot the results.\nFurthermore, a tool was developed to facilitate using the interface by implementing a\nlibrary that contains different process models commonly found in industry and largely\nstudied in literature.\n\nKeywords: Process Control. Predictive Control. Software Development. Pyhon.\n\n\n\n\n\nLista de ilustra\u00e7\u00f5es\n\nFigura 1 \u2013 Estrutura b\u00e1sica do MPC. . . . . . . . . . . . . . . . . . . . . . . . . 21\nFigura 2 \u2013 No\u00e7\u00e3o b\u00e1sica do MPC. . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nFigura 3 \u2013 Etapas do Processo Unificado. . . . . . . . . . . . . . . . . . . . . . 46\nFigura 4 \u2013 Diagrama de casos de uso. . . . . . . . . . . . . . . . . . . . . . . . 49\nFigura 5 \u2013 Passos obrigat\u00f3rios durante a expans\u00e3o dos casos de uso. . . . . . 51\nFigura 6 \u2013 Modelo conceitual representado por diagrama de classes. . . . . . . 52\nFigura 7 \u2013 Diagrama de sequ\u00eancia. . . . . . . . . . . . . . . . . . . . . . . . . . 54\nFigura 8 \u2013 Diagrama de colabora\u00e7\u00e3o. . . . . . . . . . . . . . . . . . . . . . . . . 56\nFigura 9 \u2013 Diagrama de classes. . . . . . . . . . . . . . . . . . . . . . . . . . . 57\nFigura 10 \u2013 Diagrama de estados. . . . . . . . . . . . . . . . . . . . . . . . . . . 58\nFigura 11 \u2013 Esquema b\u00e1sico do XML. . . . . . . . . . . . . . . . . . . . . . . . . 60\nFigura 12 \u2013 Exemplo de um documento schema. . . . . . . . . . . . . . . . . . . 61\nFigura 13 \u2013 Software Doxygen. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nFigura 14 \u2013 Diagrama de caso de uso gerado para o sistema. . . . . . . . . . . . 68\nFigura 15 \u2013 Modelo conceitual do projeto. . . . . . . . . . . . . . . . . . . . . . . 70\nFigura 16 \u2013 Diagrama de sequ\u00eancia representando a simula\u00e7\u00e3o de um cen\u00e1rio. 72\nFigura 17 \u2013 Diagrama de colabora\u00e7\u00e3o para a fun\u00e7\u00e3o AlterarFT. . . . . . . . . . . 73\nFigura 18 \u2013 Diagrama de classes do sistema. . . . . . . . . . . . . . . . . . . . . 74\nFigura 19 \u2013 Diagrama de estados da classe Projeto. . . . . . . . . . . . . . . . . 76\nFigura 20 \u2013 Qt Designer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\nFigura 21 \u2013 Fragmento do schema criado para o projeto. . . . . . . . . . . . . . 78\nFigura 22 \u2013 Documento XML gerado para o projeto de um tanque c\u00f4nico. . . . . 79\nFigura 23 \u2013 Janela principal da interface com as seis abas definidas. . . . . . . . 82\nFigura 24 \u2013 Arquivo na barra de ferramentas. . . . . . . . . . . . . . . . . . . . . 83\nFigura 25 \u2013 Op\u00e7\u00f5es na barra de ferramentas. . . . . . . . . . . . . . . . . . . . . 83\nFigura 26 \u2013 Vari\u00e1veis do projeto. . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\nFigura 27 \u2013 Aviso gerado quando o n\u00famero de entradas escolhidas for inv\u00e1lido. 85\nFigura 28 \u2013 Dados do projeto e nome das vari\u00e1veis. . . . . . . . . . . . . . . . . 86\nFigura 29 \u2013 Demonstra\u00e7\u00e3o de como modificar nome da vari\u00e1vel. . . . . . . . . . 86\nFigura 30 \u2013 Aba dos modelos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\nFigura 31 \u2013 Lista de modelos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88\nFigura 32 \u2013 Exemplo de modelo tipo fun\u00e7\u00e3o transfer\u00eancia selecionado. . . . . . 89\nFigura 33 \u2013 Janelas para alterar a satura\u00e7\u00e3o e os pontos de opera\u00e7\u00e3o. . . . . . 90\nFigura 34 \u2013 Se\u00e7\u00e3o da interface do modelo resposta ao degrau. . . . . . . . . . . 92\nFigura 35 \u2013 Se\u00e7\u00e3o da interface do modelo de equa\u00e7\u00e3o de diferen\u00e7as. . . . . . . 93\nFigura 36 \u2013 Janela para defini\u00e7\u00e3o de constantes. . . . . . . . . . . . . . . . . . . 94\n\n\n\nFigura 37 \u2013 Aba dos controladores. . . . . . . . . . . . . . . . . . . . . . . . . . 95\nFigura 38 \u2013 Defini\u00e7\u00e3o dos controladores. . . . . . . . . . . . . . . . . . . . . . . 96\nFigura 39 \u2013 Configura\u00e7\u00e3o dos controladores. . . . . . . . . . . . . . . . . . . . . 97\nFigura 40 \u2013 Janela para altera\u00e7\u00e3o dos par\u00e2metros de entrada do controlador. . . 98\nFigura 41 \u2013 Aba dos cen\u00e1rios. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\nFigura 42 \u2013 Janela para configura\u00e7\u00e3o dos cen\u00e1rios de simula\u00e7\u00e3o. . . . . . . . . 101\nFigura 43 \u2013 Demonstra\u00e7\u00e3o de como modificar a refer\u00eancia. . . . . . . . . . . . . 102\nFigura 44 \u2013 Aba de simula\u00e7\u00e3o. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\nFigura 45 \u2013 Exemplo de gr\u00e1fico gerado. . . . . . . . . . . . . . . . . . . . . . . . 104\nFigura 46 \u2013 Outro exemplo de gr\u00e1fico gerado. . . . . . . . . . . . . . . . . . . . . 105\nFigura 47 \u2013 Aba de \u00edndices de desempenho. . . . . . . . . . . . . . . . . . . . . 107\nFigura 48 \u2013 Exemplo de arquivo importado para a interface. . . . . . . . . . . . . 108\nFigura 49 \u2013 Interface da biblioteca de modelos. . . . . . . . . . . . . . . . . . . . 109\n\n\n\nLista de tabelas\n\nTabela 1 \u2013 Sum\u00e1rio executivo gerado na fase de concep\u00e7\u00e3o da UP . . . . . . . 65\nTabela 2 \u2013 Descri\u00e7\u00e3o do requisito Armazenar Modelas da Biblioteca . . . . . . 66\nTabela 3 \u2013 Expans\u00e3o do caso de uso Configurar Controle . . . . . . . . . . . . 69\nTabela 4 \u2013 Contrato de uma das fun\u00e7\u00f5es da Interface Gr\u00e1fica . . . . . . . . . . 71\nTabela 5 \u2013 Descri\u00e7\u00e3o do requisito Defini\u00e7\u00e3o dos Par\u00e2metros do Projeto . . . . 119\nTabela 6 \u2013 Descri\u00e7\u00e3o do requisito Defini\u00e7\u00e3o dos Modelos . . . . . . . . . . . . 119\nTabela 7 \u2013 Descri\u00e7\u00e3o do requisito Defini\u00e7\u00e3o dos Controladores . . . . . . . . . 120\nTabela 8 \u2013 Descri\u00e7\u00e3o do requisito Configura\u00e7\u00e3o do Cen\u00e1rio de Simula\u00e7\u00e3o . . . 120\nTabela 9 \u2013 Descri\u00e7\u00e3o do requisito Visualiza\u00e7\u00e3o dos Gr\u00e1ficos de Simula\u00e7\u00e3o . . 120\nTabela 10 \u2013 Descri\u00e7\u00e3o do requisito Calcular A\u00e7\u00e3o de Controle . . . . . . . . . . 121\nTabela 11 \u2013 Descri\u00e7\u00e3o do requisito Calcular \u00cdndices de Desempenho . . . . . . 121\nTabela 12 \u2013 Descri\u00e7\u00e3o do requisito Implementa\u00e7\u00e3o da Simula\u00e7\u00e3o . . . . . . . . 121\nTabela 13 \u2013 Descri\u00e7\u00e3o do requisito Gerenciamento do Banco de Dados . . . . . 121\nTabela 14 \u2013 Descri\u00e7\u00e3o do requisito Gerenciar Dados do Processo . . . . . . . . 122\nTabela 15 \u2013 Descri\u00e7\u00e3o do requisito Atualizar Dados do Processo . . . . . . . . . 122\nTabela 16 \u2013 Descri\u00e7\u00e3o do requisito Salvar Dados da Simula\u00e7\u00e3o . . . . . . . . . . 122\nTabela 17 \u2013 Descri\u00e7\u00e3o do requisito Abrir Dados de Simula\u00e7\u00f5es Armazenadas . . 122\n\n\n\n\n\nLista de abreviaturas e siglas\n\nAPI Application Program Interface\n\nCARIMA Controlled Autoregressive Integrated Moving Average\n\nDMC Dynamic Matrix Control\n\nDTD Document Type Definition\n\nEPSAC Extended Prediction Self-Adaptive Control\n\nXML Extensible Markup Language\n\nGPC Generalized Predictive Control\n\nMAC Model Algorithm Control\n\nMIMO Multiple-Input Multiple-Output\n\nMPC Model based Predictive Controller\n\nPNMPC Practical Nonlinear Model Predictive Control\n\nSISO Single-Input Single-Output\n\nUP Unified Process\n\n\n\n\n\nSum\u00e1rio\n\n1 INTRODU\u00c7\u00c3O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n2 CONTROLADOR PREDITIVO BASEADO EM MODELO . . . . . . . 21\n2.1 Vis\u00e3o Geral do MPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n\n2.1.1 Estrat\u00e9gia do MPC . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\n2.1.2 Elementos do MPC . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n2.1.2.1 Modelo de Predi\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . 24\n\n2.1.2.2 Resposta Livre e Resposta For\u00e7ada . . . . . . . . . . 26\n\n2.1.2.3 Fun\u00e7\u00e3o Objetivo . . . . . . . . . . . . . . . . . . . . . 27\n\n2.1.2.4 Obtendo a Lei de Controle . . . . . . . . . . . . . . . 29\n\n2.2 Generalized Predictive Controller . . . . . . . . . . . . . . . . . . . . . 30\n\n2.2.1 Algoritmo GPC . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n\n2.3 Dynamic Matrix Control . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n\n2.3.1 Computando as Predi\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . 36\n\n2.3.2 Obtendo Resposta Livre Recursivamente . . . . . . . . . . . . 37\n\n2.4 Practical Non-Linear Model Predictive Controller . . . . . . . . . . . . . 38\n\n2.4.1 Obtendo a Resposta For\u00e7ada . . . . . . . . . . . . . . . . . . . 39\n\n2.4.2 Obtendo a Resposta Livre . . . . . . . . . . . . . . . . . . . . . 41\n\n2.4.3 Algoritmo PNMPC . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n3 METODOLOGIA DE DESENVOLVIMENTO DE SOFTWARE . . . . 45\n3.1 Etapa de Concep\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\n3.1.1 Requisitos do Projeto . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n3.1.2 Casos de Uso . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n\n3.2 Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . 49\n\n3.2.1 Expans\u00e3o dos Casos de Uso . . . . . . . . . . . . . . . . . . . 50\n\n3.2.2 Modelagem Conceitual . . . . . . . . . . . . . . . . . . . . . . . 51\n\n3.2.3 Contratos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\n\n3.2.4 Diagrama de Sequ\u00eancia . . . . . . . . . . . . . . . . . . . . . . 54\n\n3.2.5 Diagrama de Colabora\u00e7\u00e3o e de Classes . . . . . . . . . . . . . 55\n\n3.2.6 Diagrama de Estados . . . . . . . . . . . . . . . . . . . . . . . 58\n\n3.3 Camada de Persist\u00eancia . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n\n3.3.1 Extensible Markup Language (XML) . . . . . . . . . . . . . . . 59\n\n3.3.2 XML Schema . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\n3.4 Linguagem de Programa\u00e7\u00e3o - Python . . . . . . . . . . . . . . . . . . . 61\n\n\n\n4 REQUISITOS DA INTERFACE E PROJETO DE SOFTWARE . . . . 65\n4.1 Requisitos da Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4.2 Levantamento dos Casos de Uso . . . . . . . . . . . . . . . . . . . . . 67\n4.3 Expans\u00e3o dos Casos de Uso . . . . . . . . . . . . . . . . . . . . . . . . 68\n4.4 Modelo conceitual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n4.5 Contratos e Diagrama de Sequ\u00eancia . . . . . . . . . . . . . . . . . . . 71\n4.6 Diagrama de Colabora\u00e7\u00e3o e de Classes . . . . . . . . . . . . . . . . . 73\n4.7 Implementa\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\n4.7.1 Qt Designer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n4.8 Camada de Persist\u00eancia . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n\n5 INTERFACE DE USU\u00c1RIO . . . . . . . . . . . . . . . . . . . . . . . . 81\n5.1 Caracter\u00edsticas do Projeto . . . . . . . . . . . . . . . . . . . . . . . . . 83\n5.2 Modelo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\n5.3 Controlador . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\n5.4 Cen\u00e1rio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n5.5 Simula\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n5.6 \u00cdndice de Desempenho . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\n5.7 Biblioteca de Modelos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\n\n6 CONCLUS\u00c3O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n6.1 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n\nREFER\u00caNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\n\nAP\u00caNDICES 117\n\nAP\u00caNDICE A \u2013 DOCUMENTOS DO PROJETO DE SOFTWARE . 119\nA.1 Requisitos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\n\n\n\n17\n\n1 Introdu\u00e7\u00e3o\n\nO incentivo \u00e0 pesquisa e desenvolvimento de novas tecnologias a n\u00edvel mundial\nvem contribuindo para um avan\u00e7o em diversas \u00e1reas que crescem exponencialmente\nnos \u00faltimos anos, como a intelig\u00eancia artificial, a rob\u00f3tica e o processamento de si-\nnais. Esses avan\u00e7os estimularam o crescimento de simuladores de alta qualidade [1],\nauxiliando profissionais de diversos segmentos da sociedade a resolver problemas. A si-\nmula\u00e7\u00e3o \u00e9 um mecanismo amplamente difundido cujo objetivo \u00e9 reproduzir situa\u00e7\u00f5es do\nmundo real num ambiente controlado e a ferramenta que implementa esse mecanismo\n\u00e9 chamada de simulador [2]. Desta forma, os simuladores s\u00e3o fundamentais para a\nan\u00e1lise de diferentes cen\u00e1rios do mundo real e nesse trabalho \u00e9 proposto um simulador\ncapaz de recriar situa\u00e7\u00f5es comuns em processos industriais, principalmente da \u00e1rea\nde petr\u00f3leo e g\u00e1s, utilizando modelos matem\u00e1ticos para represent\u00e1-los com atua\u00e7\u00e3o\nde controladores e focando principalmente em controladores preditivos baseado em\nmodelo, ou MPC (Model based Predictive Controller ).\n\nExistem in\u00fameros tipos de algoritmo de controle utilizados na ind\u00fastria, podendo\nse destacar na ind\u00fastria petroqu\u00edmica principalmente os controladores preditivos cuja\n\u00e1rea de atua\u00e7\u00e3o v\u00eam crescendo com a sua pesquisa e desenvolvimento. Os contro-\nladores preditivos s\u00e3o ditos avan\u00e7ados pelo elevado grau de complexidade de sua\nimplementa\u00e7\u00e3o, aplicados em sistemas complexos onde \u00e9 vi\u00e1vel economicamente seu\nuso [3]. Dentre os diferentes algoritmos, o mais comum e utilizado neste projeto \u00e9 o\nMPC, que \u00e9 compreendido como um conjunto de t\u00e9cnicas que levam em considera\u00e7\u00e3o\no conceito de predi\u00e7\u00e3o e calculam a lei de controle adequada para o sistema utilizando\nalgoritmos de otimiza\u00e7\u00e3o que determinam a resposta \u00f3tima atrav\u00e9s da minimiza\u00e7\u00e3o de\numa fun\u00e7\u00e3o custo. Foram implementados tr\u00eas algoritmos MPC diferentes no projeto, o\nGPC (Generalized Predictive Control ), que utiliza modelos do tipo fun\u00e7\u00e3o transfer\u00eancia,\no PNMPC (Practical Nonlinear Model Predictive Control ) com modelos de equa\u00e7\u00f5es de\ndiferen\u00e7a n\u00e3o-lineares e por fim o DMC (Dynamic Matrix Control ) que se baseia nos\nmodelos de resposta ao degrau. \u00c9 importante salientar que tamb\u00e9m foi implementado\no algoritmo de controle PID para fins de compara\u00e7\u00e3o de desempenho com os controla-\ndores preditivos e auxiliar na simula\u00e7\u00e3o e avalia\u00e7\u00e3o do comportamento do sistema em\ndiferentes situa\u00e7\u00f5es.\n\nDesta maneira, um dos objetivos do projeto \u00e9 assessorar o engenheiro de con-\ntrole e automa\u00e7\u00e3o no estudo e an\u00e1lise de processos industriais criando uma ferramenta\nque fornecesse o conhecimento b\u00e1sico do comportamento do processo e como este\nresponde em diversos cen\u00e1rios e com controladores diferentes. A import\u00e2ncia disso\nest\u00e1 em situa\u00e7\u00f5es em que parar a produ\u00e7\u00e3o \u00e9 invi\u00e1vel, como por exemplo numa refi-\n\n\n\n18 Cap\u00edtulo 1. Introdu\u00e7\u00e3o\n\nnaria de petr\u00f3leo cuja produ\u00e7\u00e3o ocorre durante 24h ininterruptas, e o sistema est\u00e1 se\ncomportando diferentemente do planejado, tornando poss\u00edvel a realiza\u00e7\u00e3o de testes\nem paralelo \u00e0 produ\u00e7\u00e3o para sintonizar o controlador e verificar se certas altera\u00e7\u00f5es\nresultariam em melhoras significativas durante a produ\u00e7\u00e3o. Outra situa\u00e7\u00e3o em que a\nferramenta pode ter um papel essencial \u00e9 na sintonia do controlador antes mesmo da\nimplementa\u00e7\u00e3o do projeto final, facilitando o design do controlador e permitindo que o\nengenheiro verifique as melhores possibilidades. Uma ferramenta capaz disso e que\nainda possibilite a an\u00e1lise utilizando controladores preditivos pode ser importante para o\ncrescimento da empresa, melhorando seus processos reduzindo custos e evitando que\na produ\u00e7\u00e3o seja interrompida para modificar par\u00e2metros de controle ou para an\u00e1lise do\nprocesso.\n\nNa simula\u00e7\u00e3o s\u00e3o utilizados os modelos matem\u00e1ticos para reproduzir sistemas\nf\u00edsicos din\u00e2micos. Um modelo matem\u00e1tico pode ser definido como uma representa\u00e7\u00e3o\nabstrata da realidade por via de equa\u00e7\u00f5es matem\u00e1ticas [2], sendo uma aproxima\u00e7\u00e3o do\nsistema real modelado e, desta forma, os modelos n\u00e3o s\u00e3o reprodu\u00e7\u00f5es exatas, bus-\ncando sempre um compromisso entre a perfei\u00e7\u00e3o e o custo para que a melhor solu\u00e7\u00e3o\nseja alcan\u00e7ada durante a simula\u00e7\u00e3o. Portanto, quanto mais fiel for um modelo, maior o\nesfor\u00e7o e tempo computacional necess\u00e1rio para que se tenha um bom desempenho,\ngerando uma dificuldade para sistemas mais complexos que requerem modelos com\nmuitas vari\u00e1veis, encarecendo o produto a ser desenvolvido e podendo at\u00e9 inviabilizar\nsua implementa\u00e7\u00e3o. Sendo assim, o grande empecilho em se adquirir simuladores\nde processos industriais mais complexos se deve ao custo elevado para aquisi\u00e7\u00e3o\nde licen\u00e7as, devido \u00e0 dificuldade no desenvolvimento de ferramentas de simula\u00e7\u00e3o\ncomputacional e at\u00e9 mesmo a aus\u00eancia de interfaces intuitivas e simples para modelos\ncomplexos e com grande n\u00famero de vari\u00e1veis.\n\nPortanto, outro grande objetivo deste projeto \u00e9 o desenvolvimento de um soft-\nware com interface gr\u00e1fica capaz de simular processos industriais com controladores\npreditivos de forma simples e que seja implementado de forma a baratear o produto\npara o usu\u00e1rio final. Partindo dessa premissa, foram analisadas as possibilidades de\nimplementa\u00e7\u00e3o e concluiu-se que a melhor solu\u00e7\u00e3o seria utilizar uma linguagem de\nprograma\u00e7\u00e3o open source que exigisse um esfor\u00e7o de programa\u00e7\u00e3o reduzido e capaz\nde resultar num produto de alta qualidade, sendo escolhida o Python como linguagem\nde programa\u00e7\u00e3o .\n\nO Python \u00e9 uma linguagem de programa\u00e7\u00e3o de alto n\u00edvel, interpretada, orientada\na objetos e que tem como principal filosofia enfatizar a import\u00e2ncia do esfor\u00e7o do progra-\nmador frente ao esfor\u00e7o computacional [4], com \u00eanfase na interatividade e privilegiando\na legibilidade do c\u00f3digo [5]. \u00c9 dispon\u00edvel gratuitamente, possibilitando o design de uma\ninterface sem a necessidade de obten\u00e7\u00e3o de licen\u00e7a. Seu grande diferencial est\u00e1 na\n\n\n\n19\n\ndisponibilidade de in\u00fameras bibliotecas, como de matem\u00e1tica simb\u00f3lica, integra\u00e7\u00e3o com\nsistema e plot interativo, criando um ambiente com infinitas possibilidades e facilitando\no desenvolvimento de softwares capazes de resolver problemas complexos. Foram\nintegrados ao Python outras ferramentas para auxiliar no desenvolvimento da interface,\ncomo por exemplo o Qt Designer, respons\u00e1vel pelo design da interface gr\u00e1fica e o XML\npara armazenamento de dados.\n\nA interface gr\u00e1fica desenvolvida possui seis \u00e1reas principais, cada uma dividida\nnuma aba separada. Cada uma dessas \u00e1reas apresenta caracter\u00edsticas \u00fanicas, e s\u00e3o\ndivididas igualmente dentro da interface, se complementando. Essas \u00e1reas s\u00e3o:\n\n\u2022 Caracter\u00edsticas do Projeto: Nesta aba s\u00e3o definidos os par\u00e2metros b\u00e1sicos do\nprojeto, como n\u00famero de vari\u00e1veis controladas, manipuladas e perturba\u00e7\u00f5es,\nal\u00e9m de definir um nome para o projeto e outros requisitos b\u00e1sicos, como nome\ndo projeto e amostragem;\n\n\u2022 Modelo: O usu\u00e1rio define as fun\u00e7\u00f5es matem\u00e1ticas dos modelos, que podem ser\nlineares ou n\u00e3o lineares. Neste caso, o usu\u00e1rio define fun\u00e7\u00f5es transfer\u00eancias ou\nmodelo de resposta ao degrau para modelos lineares e equa\u00e7\u00f5es de diferen\u00e7a\npara modelos n\u00e3o lineares. Al\u00e9m disso podem ser definidos alguns par\u00e2metros\nde modelos em geral, como ponto de opera\u00e7\u00e3o e satura\u00e7\u00e3o do sinal de controle;\n\n\u2022 Controlador: Os algoritmos utilizados para o controle preditivo s\u00e3o GPC para\nfun\u00e7\u00f5es transfer\u00eancia, o DMC para modelo de resposta ao degrau e PNMPC\npara equa\u00e7\u00f5es de diferen\u00e7a. O usu\u00e1rio define os par\u00e2metros dos controladores,\nincluindo o modelo de predi\u00e7\u00e3o. Tamb\u00e9m foi implementado um algoritmo PID e o\nusu\u00e1rio pode definir os ganhos do controlador;\n\n\u2022 Cen\u00e1rio de Simula\u00e7\u00e3o: O cen\u00e1rio de simula\u00e7\u00e3o define como ser\u00e1 realizada a\nsimula\u00e7\u00e3o, quais as refer\u00eancias para a sa\u00edda, o tempo de simula\u00e7\u00e3o e se ser\u00e1 de\nmalha aberta ou malha fechada;\n\n\u2022 Simula\u00e7\u00e3o: Nesta aba \u00e9 mostrado o resultado final, gerando gr\u00e1ficos com a\nresposta do sistema, das vari\u00e1veis manipuladas e controladas;\n\n\u2022 \u00cdndice de Desempenho: Ap\u00f3s a simula\u00e7\u00e3o foi criada uma aba que mostra \u00edndices\ndo desempenho do controlador para a an\u00e1lise de robustez deste pelo usu\u00e1rio.\n\nAl\u00e9m disso, foi criada uma ferramenta com o intuito de prover ao usu\u00e1rio uma\nbiblioteca com modelos tradicionais encontrados na ind\u00fastria. Dessa forma, o usu\u00e1rio\nter\u00e1 mais facilidade em simular processos comuns, amplamente estudados na literatura,\ntornando a interface mais pr\u00e1tica.\n\n\n\n20 Cap\u00edtulo 1. Introdu\u00e7\u00e3o\n\nEste projeto foi desenvolvido no laborat\u00f3rio do PRH-34 com orienta\u00e7\u00e3o dos\nprofessores Daniel Martins Lima e Julio Elias Normey-Rico.\n\nNos Cap\u00edtulos 2 e 3 ser\u00e1 dada uma defini\u00e7\u00e3o dos algoritmos de controle uti-\nlizados na interface, com uma breve descri\u00e7\u00e3o de controle preditivo e tamb\u00e9m uma\ndescri\u00e7\u00e3o sobre a metodologia de desenvolvimento utilizada. J\u00e1 no Cap\u00edtulo 4 ser\u00e1\ndetalhado passo a passo todo resultado da metodologia, desde a concep\u00e7\u00e3o inicial\ndas ideias at\u00e9 a implementa\u00e7\u00e3o de fato. Por fim, no Cap\u00edtulo 5 \u00e9 dada uma vis\u00e3o geral\nda interface, suas fun\u00e7\u00f5es e organiza\u00e7\u00e3o, al\u00e9m de cada aba presente na interface\ndetalhada profundamente.\n\n\n\n21\n\n2 Controlador Preditivo Baseado em\nModelo\n\nNeste cap\u00edtulo ser\u00e3o introduzidas as defini\u00e7\u00f5es b\u00e1sicas referentes ao Model\nPredictive Control (MPC), em portugu\u00eas Controle Preditivo Baseado em Modelo, com\numa breve explica\u00e7\u00e3o do funcionamento deste algoritmo de controle, dando enf\u00e2se\npara os algoritmos utilizados na implementa\u00e7\u00e3o do projeto, que s\u00e3o: Generalized\nPredictive Controller (GPC), Dynamix Matrix Control (DMC) e Practical Non-Linear\nModel Predictive Control (PNMPC). A refer\u00eancia utilizada para o desenvolvimentos do\nalgoritmos dos controlares preditivos foram retirados da tese de doutorado do orientador\nDaniel Martins Lima [6].\n\nA estrutura b\u00e1sica mostrada na Figura 1 \u00e9 usada para implementar essa estra-\nt\u00e9gia. Resumindo, dado um Processo \u00e9 utilizado um Modelo para predizer o compor-\ntamento futuro desse processo e baseando-se nesse comportamento \u00e9 calculada a\nmelhor a\u00e7\u00e3o de controle a ser aplicada. Essa melhor a\u00e7\u00e3o de controle \u00e9 definida por\numa fun\u00e7\u00e3o custo utilizada para otimizar sua resposta, cujos par\u00e2metros s\u00e3o definidos\npelo usu\u00e1rio (considerando os erros de seguimento de refer\u00eancia futuros), levando\ntamb\u00e9m em conta as restri\u00e7\u00f5es impostas ao modelo.\n\nFigura 1 \u2013 Estrutura b\u00e1sica do MPC.\n\n\n\n22 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\n2.1 Vis\u00e3o Geral do MPC\n\nQuando se utiliza o termo controle baseado em modelo n\u00e3o se refere espe-\ncificamente \u00e0 uma estrat\u00e9gia de controle, mas a um conjunto de m\u00e9todos que tem\ncaracter\u00edsticas semelhantes, caracterizados principalmente pelo uso de modelos do\nprocesso que s\u00e3o utilizados para predizer o comportamento futuro do processo, e\nno uso de uma fun\u00e7\u00e3o custo para se calcular a a\u00e7\u00e3o de controle a ser aplicada no\nmomento atual. As suas principais caracter\u00edsticas s\u00e3o [7]:\n\n\u2022 Uso expl\u00edcito de modelos para predizer sa\u00eddas do processo em instantes de tempo\nfuturos (horizontes);\n\n\u2022 C\u00e1lculo de uma sequ\u00eancia de controles minimizando uma fun\u00e7\u00e3o objetivo;\n\n\u2022 Estrat\u00e9gia de horizonte deslizante, de maneira que em cada instante o horizonte\n\u00e9 deslocado para o futuro, o que envolve a aplica\u00e7\u00e3o do primeiro sinal de controle\nda sequ\u00eancia calculado em cada passo.\n\nAs principais diferen\u00e7as entre as variedades de algoritmos MPC s\u00e3o o tipo do\nmodelo que representar\u00e1 o processo, as perturba\u00e7\u00f5es, o formato da fun\u00e7\u00e3o custo\nque dever\u00e1 ser minimizada. Diversas aplica\u00e7\u00f5es de controle preditivo foram relatadas\nna literatura, n\u00e3o somente na ind\u00fastria de processos, mas tamb\u00e9m em aplica\u00e7\u00f5es\nespec\u00edficas de pesquisas [8\u201312]. Essas aplica\u00e7\u00f5es mostram a capacidade do MPC\nem alcan\u00e7ar sistemas de controle altamente eficientes capazes de operar sob grandes\nper\u00edodos de tempo com pouca interven\u00e7\u00e3o.\n\nPode-se destacar algumas vantagens que o MPC apresenta com rela\u00e7\u00e3o a\noutros m\u00e9todos de controle de processos [13]:\n\n\u2022 \u00c9 atraente para usu\u00e1rios com pouco conhecimento em controle, visto que seus\nconceitos s\u00e3o muito intuitivos;\n\n\u2022 Pode ser usado para controlar uma grande variedade de processos, abrangendo\ndesde processos com din\u00e2mica simples at\u00e9 outros mais complexos, incluindo\nsistemas com longo tempo morto, fase n\u00e3o-m\u00ednima e sistemas inst\u00e1veis;\n\n\u2022 Sistemas multivari\u00e1veis s\u00e3o facilmente tratados;\n\n\u2022 Ele intrinsecamente compensa atrasos por tempo morto;\n\n\u2022 \u00c9 introduzido controle feedforward naturalmente para compensar a medi\u00e7\u00e3o de\nperturba\u00e7\u00f5es;\n\n\n\n2.1. Vis\u00e3o Geral do MPC 23\n\n\u2022 A sua extens\u00e3o para o tratamento de restri\u00e7\u00f5es \u00e9 conceitualmente simples e\npodem ser inclu\u00eddos sistematicamente durante o design do processo;\n\n\u2022 \u00c9 muito \u00fatil quando as refer\u00eancias futuras s\u00e3o conhecidas;\n\n\u2022 \u00c9 uma metodologia aberta baseada em princ\u00edpios que permitem desenvolvimen-\ntos mais profundos no assunto.\n\nPor todas essas vantagens citadas, o controle preditivo baseado em modelo \u00e9\numa das t\u00e9cnicas mais difundidas na ind\u00fastria [14].\n\n2.1.1 Estrat\u00e9gia do MPC\n\nToda a fam\u00edlia de controladores pertencentes ao MPC possuem passos em co-\nmum e, como pode ser observado na Figura 2, existe uma ideia b\u00e1sica que caracteriza\nos controladores dessa fam\u00edlia. As caracter\u00edsticas b\u00e1sicas do MPC s\u00e3o: [6]:\n\n1. As sa\u00eddas futuras para um horizonte definido N, chamado horizonte de predi\u00e7\u00e3o,\ns\u00e3o preditas em cada instante de tempo t usando o modelo do processo. Essas\nsa\u00eddas preditas y?(t + k|t) para k = 1...N dependem dos valores conhecidos at\u00e9\no instante t (entradas e sa\u00eddas passadas) e tamb\u00e9m do sinal de controle futuro\nu(t + k|t), k = 0...N ? 1, que devem ser enviadas para o sistema e calculadas;\n\n2. O conjunto de sinais de controle futuros s\u00e3o calculados otimizando um determi-\nnado crit\u00e9rio de forma a manter o processo mais pr\u00f3ximo poss\u00edvel da trajet\u00f3ria de\nrefer\u00eancia w(t + k) (que pode ser o pr\u00f3prio set-point ou uma aproxima\u00e7\u00e3o dele).\nEsse crit\u00e9rio geralmente assume a forma de uma fun\u00e7\u00e3o quadr\u00e1tica dos erros\nentre o sinal de sa\u00edda predito e a trajet\u00f3ria de refer\u00eancia predita. O esfor\u00e7o de\ncontrole \u00e9 inclu\u00eddo na fun\u00e7\u00e3o objetivo na maioria dos casos. Uma solu\u00e7\u00e3o expl\u00edcita\npode ser obtida se o crit\u00e9rio \u00e9 quadr\u00e1tico, o modelo \u00e9 linear e n\u00e3o existirem\nrestri\u00e7\u00f5es, caso contr\u00e1rio um m\u00e9todo iterativo de otimiza\u00e7\u00e3o deve ser utilizado;\n\n3. O sinal de controle u(t|t) \u00e9 enviado para o processo enquanto os sinais de controle\nseguintes s\u00e3o descartados, porque, no pr\u00f3ximo instante de amostragem, y(t + 1)\nser\u00e1 conhecido, o passo 1 se repetir\u00e1 com esse novo valor e todas as sequ\u00eancias\nser\u00e3o atualizadas. Portanto, o u(t + 1|t + 1) \u00e9 calculado (que em princ\u00edpio ser\u00e1\ndiferente de u(t + 1|t) porque novas informa\u00e7\u00f5es foram apresentas) usando o\nconceito de horizonte deslizante.\n\n\n\n24 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\nFigura 2 \u2013 No\u00e7\u00e3o b\u00e1sica do MPC.\n\n2.1.2 Elementos do MPC\n\nExistem elementos em comum nos algoritmos preditivos baseados em modelo,\npor\u00e9m a diferen\u00e7a \u00e9 a forma como tais elementos s\u00e3o calculados ou at\u00e9 mesmo a sua\nestrutura, que proporciona novas op\u00e7\u00f5es de algoritmos MPC. Os principais elementos\ns\u00e3o [6]:\n\n\u2022 O modelo de predi\u00e7\u00e3o;\n\n\u2022 Resposta livre e resposta for\u00e7ada;\n\n\u2022 A fun\u00e7\u00e3o objetivo;\n\n\u2022 O procedimento para obter a lei de controle.\n\n2.1.2.1 Modelo de Predi\u00e7\u00e3o\n\nUm dos aspectos mais importantes e que diferencia o MPC dos demais algorit-\nmos \u00e9 a sua capacidade de predizer sa\u00eddas em instantes futuros y?(t + k|t) e usar esta\ninforma\u00e7\u00e3o para calcular as a\u00e7\u00f5es de controle. Para que se torne poss\u00edvel calcular a\nsa\u00edda predita \u00e9 introduzido na malha de controle um modelo do processo. Este modelo\npode ser separado em dois, o modelo do processo propriamente dito e o modelo das\nperturba\u00e7\u00f5es. Abaixo ser\u00e3o apresentados diferentes modelos que podem ser utilizados.\n\n\n\n2.1. Vis\u00e3o Geral do MPC 25\n\nModelo do Processo\n\nExistem in\u00fameros modelos que representam o comportamento do processo e\nagora ser\u00e3o detalhados alguns dos modelos discretos mais vistos na ind\u00fastria e que\nforam implementados na interface gr\u00e1fica desenvolvida.\n\n\u2022 Resposta ao degrau. Esse modelo considera o relacionamento entre entradas e\nsa\u00eddas de um sistema est\u00e1vel dado por\n\ny(t) =\n??\ni=1\n\ngi?u(t? i) (2.1)\n\nonde gi s\u00e3o os valores de sa\u00edda amostrados pelo degrau de entrada ?u(t) =\nu(t) ?u(t? 1). Embora esse modelo apresenta um somat\u00f3rio com infinitos ele-\nmentos, posteriormente ser\u00e1 mostrado que esse somat\u00f3rio pode ser truncado.\nEsse m\u00e9todo \u00e9 amplamente aceito na pr\u00e1tica industrial por ser muito simples e\npor claramente refletir a influ\u00eancia de cada vari\u00e1vel manipulada em uma sa\u00edda\ndeterminada. Outra grande vantagem desse m\u00e9todo \u00e9 que caso o modelo precise\nser identificado a partir de dados experimentais, n\u00e3o \u00e9 necess\u00e1rio ter conheci-\nmento a priori da estrutura do modelo, de maneira que o processo de identifica\u00e7\u00e3o\n\u00e9 simplificado e ao mesmo tempo permite que din\u00e2micas complexas, como fase\nn\u00e3o m\u00ednima e tempo morto, sejam descritas com facilidade.\n\n\u2022 Fun\u00e7\u00e3o Transfer\u00eancia. Esse modelo \u00e9 dado pela fun\u00e7\u00e3o transfer\u00eancia G(z) =\nDg(z)/Ng(z) de forma que a sa\u00edda \u00e9\n\nDg(z)y(t) = Ng(z)u(t) (2.2)\n\nonde Ng(z) e Dg(z) s\u00e3o polin\u00f4mios em z, vari\u00e1vel complexa do dom\u00ednio da\nfrequ\u00eancia discreto. \u00c9 considerado, a partir desse momento, que o processo n\u00e3o\npode ter uma resposta instant\u00e2nea, ent\u00e3o o modelo pode ser reescrito como\n\nA(z)y(t) = B(z)u(t? 1) (2.3)\n\nsabendo que,\n\nA(z) = 1 + a1z\n?1 + a2z\n\n?2 + ... + anaz\n?na (2.4)\n\nB(z) = b0 + b1z\n?1 + b2z\n\n?2 + ... + bnbz\n?nb (2.5)\n\n\n\n26 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\nEssa considera\u00e7\u00e3o \u00e9 razo\u00e1vel na pr\u00e1tica porque, em geral, existe um tempo morto\nde uma amostra entre a aplica\u00e7\u00e3o da a\u00e7\u00e3o de controle e a medi\u00e7\u00e3o do seu efeito\nna sa\u00edda da planta. Portanto, a predi\u00e7\u00e3o \u00e9 dada por:\n\ny?(t + k|t) =\nB(z)\n\nA(z)\nu(t + k ? 1|t) (2.6)\n\nA representa\u00e7\u00e3o por fun\u00e7\u00e3o transfer\u00eancia \u00e9 v\u00e1lida para sistemas inst\u00e1veis e\ntem a vantagem de necessitar de apenas alguns par\u00e2metros, embora a priori\n\u00e9 fundamental o conhecimento sobre o processo no caso de identifica\u00e7\u00e3o do\nmodelo, especialmente a ordem dos polin\u00f4mios A e B.\n\n\u2022 Modelos N\u00e3o-Lineares Gen\u00e9ricos. Esse modelo considera uma resposta vari\u00e1vel\n\nyi(k + 1) = f(xi(k),ui(k)) (2.7)\n\nf(.) \u00e9 uma fun\u00e7\u00e3o n\u00e3o linear discreta, com forma conhecida, das vari\u00e1veis x(k) e\nu(k), com sa\u00edda y(k + 1). Essa representa\u00e7\u00e3o apresenta grande vantagem visto\nque sua defini\u00e7\u00e3o segue fun\u00e7\u00f5es matem\u00e1ticas simples e conhecidas.\n\nModelo das Perturba\u00e7\u00f5es\n\nExistem diversos modelos para representar perturba\u00e7\u00f5es, isto \u00e9, a diferen\u00e7a\nentre a sa\u00edda medida e a calculada pelo modelo do processo. Na pr\u00e1tica, modelos\nde degrau ou rampa s\u00e3o normalmente utilizados e s\u00e3o considerados como casos\nparticulares de modelos de perturba\u00e7\u00f5es. Quando perturba\u00e7\u00f5es n\u00e3o-determin\u00edsticas\ns\u00e3o consideradas, como mudan\u00e7as aleat\u00f3rias ocorrendo em instantes de tempo alea-\nt\u00f3rios, o modelo ARMA (do ingl\u00eas auto-regressive and integrated moving average) \u00e9\namplamente utilizado. O ARMA \u00e9 dado por:\n\n?(t) =\nC(z)e(t)\n\nD(z)(1 ?z?1)\n(2.8)\n\nsabendo que e(t) \u00e9 um ru\u00eddo branco com mediana zero e os polin\u00f4mios C(z) e D(z)\ns\u00e3o usados para descrever as caracter\u00edsticas estoc\u00e1sticas de ?(t) [6]. Na interface\nforam implementados apenas perturba\u00e7\u00f5es simples, como do tipo degrau, rampa ou\nru\u00eddo branco.\n\n2.1.2.2 Resposta Livre e Resposta For\u00e7ada\n\nA maior parte dos algoritmos MPC se beneficiam do conceito de resposta\nlivre e resposta for\u00e7ada, uma caracter\u00edstica explorada nos MPCs lineares. A ideia \u00e9\n\n\n\n2.1. Vis\u00e3o Geral do MPC 27\n\nexpressar a sequ\u00eancia de controle como uma soma entre diferentes sinais, como pode\nser observado abaixo:\n\nu(t) = uf (t) + uc(t) (2.9)\n\nuf (t) e uc(t) s\u00e3o relacionados, respectivamente, com a resposta livre e a for\u00e7ada.\nO sinal uf (t) corresponde \u00e0s entradas passadas e nos instantes futuros \u00e9 mantido\nconstante e igual ao \u00faltimo valor da vari\u00e1vel manipulada. Isto \u00e9\n\nuf (t?k) = u(t?k), k = 0, 1, 2, ... (2.10)\n\nuf (t + k) = u(t? 1), k = 0, 1, 2, ... (2.11)\n\nO sinal uc(t) \u00e9 mantido em zero nos instantes passados e igual ao pr\u00f3ximo\nmovimento de controle no futuro. Ou seja:\n\nuc(t?k) = 0, k = 0, 1, 2, ... (2.12)\n\nuc(t + k) = u(t + k) ?u(t? 1), k = 0, 1, 2, ... (2.13)\n\nPortanto, para calcular a predi\u00e7\u00e3o da sequ\u00eancia de sa\u00edda, y?(t + k|t) \u00e9 dividido\nem dois: a resposta livre (yc(t)), que corresponde \u00e0 sa\u00edda predita se for considerada\nque a a\u00e7\u00e3o de controle corresponde apenas a parte da resposta livre ,considerando o\nsinal de controle como uf (t). J\u00e1 a segunda parte de y?(t + k|t) \u00e9 a resposta for\u00e7ada, que\nconsidera a sequ\u00eancia de controle como sendo igual a uc(t). Conceitualmente, pode-se\nentender a resposta livre como a evolu\u00e7\u00e3o do processo resultante do estado atual do\nprocesso e a resposta for\u00e7ada seria a rea\u00e7\u00e3o do sistema quando aplicados os controle\nfuturos nele.\n\n2.1.2.3 Fun\u00e7\u00e3o Objetivo\n\nS\u00e3o propostas muitas fun\u00e7\u00f5es objetivo (tamb\u00e9m conhecido como fun\u00e7\u00e3o custo)\npara alcan\u00e7ar as a\u00e7\u00f5es de controle e os diversos algoritmos MPC apresentam diferentes\nfun\u00e7\u00f5es objetivo. Por\u00e9m, existe uma proposta geral ao se utilizar uma fun\u00e7\u00e3o objetivo,\nque seria o seguimento de um determinado sinal de referencia (w) das sa\u00eddas futuras\n(y?) num horizonte determinado, penalizando o esfor\u00e7o de controle (?u) necess\u00e1rio para\no seguimento desta refer\u00eancia.\n\n\n\n28 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\nNo caso SISO, a fun\u00e7\u00e3o custo mais comum \u00e9 representada por\n\nJ =\n\nN2?\nk=N1\n\n?(k)[y?(t + k|t) ?w(t + k|t)]2 +\nNu?\nk=1\n\n?(k)[?u(t + k ? 1)]2 (2.14)\n\nque \u00e9 tradicionalmente utilizada nos algoritmos GPC e DMC.\n\nExistem diferentes varia\u00e7\u00f5es da fun\u00e7\u00e3o custo proposta, como por exemplo em\nalguns casos n\u00e3o se utiliza no segundo termo o incremento de controle, mas o valor\ndo sinal de controle e, em algumas fun\u00e7\u00f5es, o segundo termo pode ser at\u00e9 mesmo\ninexistente. A fun\u00e7\u00e3o custo apresenta alguns atributos, incluindo:\n\n\u2022 Par\u00e2metros: N1 e N2 s\u00e3o os horizontes de predi\u00e7\u00e3o m\u00ednimo e m\u00e1ximo e Nu \u00e9\no horizonte de controle, que n\u00e3o necessariamente \u00e9 o mesmo que o horizonte\nde predi\u00e7\u00e3o m\u00e1ximo. A interpreta\u00e7\u00e3o de N1 e N2 \u00e9 bem intuitiva: eles delimitam\no limite do qual se deseja que a trajet\u00f3ria predita siga a refer\u00eancia. Portanto,\nquando um N1 \u00e9 escolhido, todos valores nos primeiros instantes at\u00e9 N1 ? 1\nn\u00e3o s\u00e3o importantes. Isso acarretar\u00e1 numa resposta do processo suave. Em\nprocessos com um tempo morto d n\u00e3o \u00e9 necess\u00e1rio que N1 seja menor que\nd + 1 porque u(t) s\u00f3 ser\u00e1 influenciado a partir de t + d. Al\u00e9m disso, em processos\ncom fase n\u00e3o m\u00ednima, esse par\u00e2metro permitir\u00e1 que os primeiros instantes com\nresposta negativa sejam eliminados da fun\u00e7\u00e3o objetivo. Os coeficientes ?(j) e\n?(j) s\u00e3o sequ\u00eancias de pondera\u00e7\u00f5es que consideram o comportamento futuro;\ngeralmente valores constantes s\u00e3o escolhidos. Eles indicam qual vari\u00e1vel dever\u00e1\nser priorizada, ou seja, se ? \u00e9 maior que ?, isso significa que a minimiza\u00e7\u00e3o\nda fun\u00e7\u00e3o custo resultar\u00e1 num erro futuro menor, enquanto, se o contr\u00e1rio for\nverdade, resultar\u00e1 em incrementos de controle menores.\n\n\u2022 Trajet\u00f3ria da Refer\u00eancia: Uma das vantagens do controle preditivo \u00e9 que, se a\nevolu\u00e7\u00e3o futura da refer\u00eancia for conhecida a priori, o sistema pode reagir antes\nque a mudan\u00e7a tenha sido efetivamente realizada, evitando efeitos de atraso\nna resposta do processo. A evolu\u00e7\u00e3o futura da refer\u00eancia r(t + k) \u00e9 conhecida\nanteriormente em muitas aplica\u00e7\u00f5es, como rob\u00f4s, servos ou processos batch; em\noutras aplica\u00e7\u00f5es uma melhoria evidente na performance pode ser observada,\nmesmo que a refer\u00eancia seja constante, simplesmente sabendo o instante em\nque ela altera seu valor e se adiantando nessa circunst\u00e2ncia. Na minimiza\u00e7\u00e3o\nda equa\u00e7\u00e3o 2.14, a maioria dos m\u00e9todos geralmente usa a trajet\u00f3ria refer\u00eancia\nw(t+k), que n\u00e3o necessariamente coincide com a refer\u00eancia verdadeira, podendo\nincluir um filtro de refer\u00eancia.\n\n\n\n2.1. Vis\u00e3o Geral do MPC 29\n\n\u2022 Restri\u00e7\u00f5es: Na pr\u00e1tica, todos os processos est\u00e3o sujeitos a restri\u00e7\u00f5es. Os atua-\ndores tem um campo de a\u00e7\u00e3o limitado assim como slew rate (taxa de varia\u00e7\u00e3o)\ndeterminado, como no caso das v\u00e1lvulas. Por raz\u00f5es construtivas, de seguran\u00e7a\nou ambientais, ou at\u00e9 mesmo por causa do pr\u00f3prio escopo dos sensores, podem\nexistir limita\u00e7\u00f5es nas vari\u00e1veis do processo, como o n\u00edveis de tanques, vaz\u00f5es\nem tubos ou valores m\u00e1ximo de temperatura e press\u00e3o; ademais, as condi\u00e7\u00f5es\nde opera\u00e7\u00e3o s\u00e3o definidas pela intersec\u00e7\u00e3o de certas restri\u00e7\u00f5es por motivos\necon\u00f4micos, de forma que o sistema de controle opere dentro de fronteiras. Tudo\nisso requer a introdu\u00e7\u00e3o de restri\u00e7\u00f5es na fun\u00e7\u00e3o que ser\u00e1 minimizada. Muito\nalgoritmos preditivos intrinsecamente levam em considera\u00e7\u00e3o as restri\u00e7\u00f5es nor-\nmalmente definidas como fronteiras na amplitude e no slew rate do sinal de\ncontrole e limites da sa\u00edda:\n\numin ? u(t) ? umax, ?t > 0 (2.15)\n\n?umin ? u(t) ?u(t? 1) ? ?umax, ?t > 0 (2.16)\n\nymin ? y(t) ? ymax, ?t > 0 (2.17)\n\nSe as restri\u00e7\u00f5es s\u00e3o adicionadas na fun\u00e7\u00e3o objetivo, a minimiza\u00e7\u00e3o se torna mais\ncomplexa e uma solu\u00e7\u00e3o linear n\u00e3o pode ser obtida, j\u00e1 que com restri\u00e7\u00f5es n\u00e3o \u00e9\nposs\u00edvel minimizar a fun\u00e7\u00e3o custo de forma alg\u00e9brica. Assim, a minimiza\u00e7\u00e3o \u00e9\nfeita de forma num\u00e9rica utilizando um dos v\u00e1rios m\u00e9todos existentes, tornando o\nproblema mais dif\u00edcil de resolver computacionalmente.\n\n2.1.2.4 Obtendo a Lei de Controle\n\nPara obter os valores de u(t+k|t), \u00e9 necess\u00e1rio minimizar a fun\u00e7\u00e3o J da Equa\u00e7\u00e3o\n2.14. Para implementar isso, os valores da sa\u00edda predita y?(t + k|t) s\u00e3o calculados como\nfun\u00e7\u00e3o dos valores passados de entrada, e da sa\u00edda e dos sinais de controle futuros,\nutilizando o modelo escolhido e substituindo na fun\u00e7\u00e3o custo, conduzindo a uma\nexpress\u00e3o cuja minimiza\u00e7\u00e3o resulta no valores desejados. Uma solu\u00e7\u00e3o anal\u00edtica pode\nser obtida pelo crit\u00e9rio quadr\u00e1tico se o modelo \u00e9 linear e n\u00e3o possui restri\u00e7\u00f5es, caso\ncontr\u00e1rio um m\u00e9todo iterativo de otimiza\u00e7\u00e3o deve ser utilizado para encontrar a solu\u00e7\u00e3o.\nIndependentemente do m\u00e9todo, obter a solu\u00e7\u00e3o n\u00e3o \u00e9 f\u00e1cil porque pode apresentar\nmuitas vari\u00e1veis independentes, valor que pode chegar na ordem 10 a 30 por vari\u00e1vel\nmanipulada. Para reduzir os graus de liberdade uma certa estrutura pode ser imposta \u00e0\nlei de controle. Isto pode ser obtido, por exemplo, utilizando o conceito de horizonte de\n\n\n\n30 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\ncontrole Nu, que consiste em considerar que ap\u00f3s um intervalo Nu &lt;N2 n\u00e3o existir\u00e1\nnenhuma varia\u00e7\u00e3o no sinal de controle proposto, isto \u00e9:\n\n?u(t + k ? 1) = 0, k > Nu (2.18)\n\nque significa considerar que a pondera\u00e7\u00e3o de controle tem valores infinitos a partir de\nNu [6].\n\nExistem muitos algoritmos que implementam as ideias propostas anteriormente,\nque podem ser divididos em tr\u00eas grupos. O primeiro grupo \u00e9 caracterizado por ter sido\ncriado na pr\u00f3pria ind\u00fastria como uma ideia para resolver os problemas encontrados\nno controle dos processos. Os principais s\u00e3o o DMC (Dynamic Matrix Controller ) [15]\ne o MAC (Model Algorithm Control ) [12] e neles s\u00e3o utilizados modelos baseados\nna resposta ao degrau e ao impulso, respectivamente, da planta para o c\u00e1lculo da\npredi\u00e7\u00e3o, al\u00e9m das perturba\u00e7\u00f5es serem consideradas a diferen\u00e7a entre a sa\u00edda real e\na predita [16]. J\u00e1 o segundo grupo de MPC s\u00e3o derivados dos conceitos de controle\nadaptativo [17], incluindo o GPC (Generalized Predictive Controller ) [18] e o EPSAC\n(Extended Prediction Self-Adaptive Control ) [19], utilizando modelos CARIMA para\nrepresenta\u00e7\u00e3o dos modelos. O terceiro e \u00faltimo grupo \u00e9 utilizado para representar\nsistemas n\u00e3o-lineares, do qual encontramos o PNMPC (Practical Non-Linear Model\nPredictive Controller) [20].\n\nNo projeto foram implementados tr\u00eas tipos de controladores baseados em\nmodelos, um de cada grupo citado anteriormente. Os algoritmos s\u00e3o o GPC, o PNMPC\ne o DMC, que ser\u00e3o aprofundados com mais detalhes nas se\u00e7\u00f5es seguintes.\n\n2.2 Generalized Predictive Controller\n\nO algoritmo GPC ampliado para sistemas multivari\u00e1veis (MIMO) calcula a\nsequ\u00eancia de controle segundo um crit\u00e9rio de otimiza\u00e7\u00e3o dado por uma fun\u00e7\u00e3o custo.\nPara um sistema com m entradas e n sa\u00eddas, a equa\u00e7\u00e3o correspondente para a fun\u00e7\u00e3o\ncusto \u00e9:\n\nJ =\nn?\n\ni=1\n\nN2i?\nk=N1i\n\n?i(k)[y?i(t + k|t)?wi(t + k|t)]2 +\nm?\ni=1\n\nNui?\nk=1\n\n?i(k)[?ui(t + k?1)]2\n\n(2.19)\n\ndos quais y?i(t+k|t) \u00e9 a predi\u00e7\u00e3o \u00f3tima da i-\u00e9sima sa\u00edda do sistema no instante de tempo\nt+k. N1i e N2i s\u00e3o, respectivamente, os horizontes m\u00ednimos e m\u00e1ximos de predi\u00e7\u00e3o para\na sa\u00edda i, Nui \u00e9 o horizonte de controle de entrada i, ?i(k) e ?i(k) s\u00e3o as pondera\u00e7\u00f5es\n\n\n\n2.2. Generalized Predictive Controller 31\n\nda i-\u00e9sima entrada e sa\u00edda, respectivamente, k instantes no futuro e wi(t + k) \u00e9 a\ntrajet\u00f3ria de refer\u00eancia futura para a i-\u00e9sima sa\u00edda no instante t + k. Os horizontes totais\nde cada sa\u00edda podem ser obtidos atrav\u00e9s da equa\u00e7\u00e3o Ni = N2i?N1i + 1. A fun\u00e7\u00e3o custo\ndada \u00e9 uma generaliza\u00e7\u00e3o da fun\u00e7\u00e3o utilizada para sistemas monovari\u00e1veis (SISO).\n\nEm geral, os horizontes de entrada e sa\u00edda s\u00e3o escolhidos de forma indepen-\ndente devido ao fato de que cada vari\u00e1vel controlada apresenta atrasos e din\u00e2micas\ndistintas quando relacionadas a uma vari\u00e1vel manipulada. Tamb\u00e9m \u00e9 importante res-\nsaltar que os modelos devem ser normalizados para que as pondera\u00e7\u00f5es das vari\u00e1veis\nsejam adequadas, pois, caso contr\u00e1rio os erros de predi\u00e7\u00e3o e as sequ\u00eancias de controle\nn\u00e3o ser\u00e3o compat\u00edveis na fun\u00e7\u00e3o custo e por isso a escolha das pondera\u00e7\u00f5es ?i(k) e\n?i(k) ser\u00e1 mais dif\u00edcil [13]. Uma das formas de normalizar seria dividir cada vari\u00e1vel\npelo seu valor m\u00e1ximo desejado [21], fazendo com que todas as vari\u00e1veis tenham valor\nabsoluto menor que um.\n\nS\u00e3o utilizadas nos algoritmos GPC as equa\u00e7\u00f5es diofantinas, que s\u00e3o equa\u00e7\u00f5es\ncujas vari\u00e1veis inc\u00f3gnitas a serem determinadas s\u00e3o na verdade polin\u00f4mios, com o\nformato:\n\nS(z?1)A(z?1) + T(z?1)B(z?1) = C(z?1) (2.20)\n\nParticurlarmente nos algoritmos preditivos, s\u00e3o utilizados polin\u00f4mios em fun\u00e7\u00e3o\ndo operador de atraso discreto z?1, como por exemplo A(z?1) = a0 + a1z?1 + \u00b7 \u00b7 \u00b7 +\nanz\n\n?n. O objetivo das equa\u00e7\u00f5es diofantinas \u00e9 separar o polin\u00f4mio original A(z?1) em\nem dois novos polin\u00f4mios S(z?1) e T(z?1) de forma que o c\u00e1lculo da predi\u00e7\u00e3o seja\nrealizada de forma dependente entre as entradas futuras e as passadas, como ser\u00e1\nvisto posteriormente.\n\nO modelo utilizado para representar o sistema MIMO \u00e9 o CARIMA, que \u00e9 descrito\nde acordo com o formato DMF (Descri\u00e7\u00e3o Matricial Fracion\u00e1ria), dado por\n\nA(z?1)y(t) = L(z?1)B(z?1)u(t? 1) + D(z?1)v(t) + T(z?1)\ne(t)\n\n?\n(2.21)\n\nonde est\u00e3o presentes o vetor de sa\u00eddas y(t) = [y1(t) . . .yn(t)]T , o vetor de entradas\nu(t) = [u1(t) . . .um(t)]\n\nT , o vetor de perturba\u00e7\u00f5es v(t) = [v1(t) . . .v(t)]T , o vetor de ru\u00eddos\nbrancos e(t) = [e1(t) . . .en(t)]T e ? = 1 ?z?1 que representa o operador diferen\u00e7a. A e\nL s\u00e3o matrizes diagonais n\u00d7n sendo que a primeira representa os denominadores das\nfun\u00e7\u00f5es transfer\u00eancia entre entradas e sa\u00eddas, e a segunda representa o atraso m\u00ednimo\ncom rela\u00e7\u00e3o \u00e0s entradas para cada sa\u00edda. B, de ordem n\u00d7m, e D, de ordem n\u00d7p\nrepresentam os numeradores das fun\u00e7\u00f5es de transfer\u00eancia em rela\u00e7\u00e3o \u00e0s entradas e\n\u00e0s perturba\u00e7\u00f5es, respectivamente. \u00c9 importante destacar que os atrasos existentes\n\n\n\n32 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\ncom rela\u00e7\u00e3o \u00e0s perturba\u00e7\u00f5es ficam impl\u00edcitos em D. T \u00e9 uma matriz diagonal n\u00d7n\ne T(z?1) que pode ser utilizada para modelar caracter\u00edsticas do ru\u00eddo e(t), ou como\npar\u00e2metro de ajuste para melhorar a robustez do sistema em malha fechada [3].\n\nComo a matriz A(z?1) \u00e9 diagonal, \u00e9 poss\u00edvel obter as predi\u00e7\u00f5es \u00f3timas de cada\nsa\u00edda utilizando equa\u00e7\u00f5es diofantinas independentes, assim, o seguinte modelo MIMO\n\u00e9 utilizado:\n\nAi(z\n?1)y(t) = z?diBi(z\n\n?1)u(t? 1) + Di(z?1)v(t) + Ti(z?1)\nei(t)\n\n?\n(2.22)\n\nonde Bi = [Bi1, ...,Bim] e Di = [Di1, ...,Dip]\n\nComo descrito por Lima [3], com uma \u00fanica diferen\u00e7a no aumento no n\u00famero\nde equa\u00e7\u00f5es diofantinas necess\u00e1rias devido \u00e0 quantidade superior de entradas e\nperturba\u00e7\u00f5es, obt\u00e9m-se a predi\u00e7\u00e3o \u00f3tima da i-\u00e9sima sa\u00edda:\n\ny?i(t + l|t) = z?diHil(z?1)?u(t? 1 + l) + Iil(z?1)\n?u(t? 1)\nTi(z?1)\n\n+ Hvil(z\n?1)?v(t + l) + Ivil(z\n\n?1)\n?v(t? 1)\nTi(z?1)\n\n+\nHil(z\n\n?1)\n\nTi(z?1)\nyi(t)\n\n(2.23)\n\nonde Hil(z?1), Iil(z?1), Hvil (z\n?1) e Ivil (z\n\n?1) s\u00e3o vetores polinomiais e os referentes \u00e0s\nentradas possuem ordem 1 \u00d7m, e os referentes \u00e0s sa\u00eddas 1 \u00d7p. Estes vetores t\u00eam\ncomo elementos os polin\u00f4mios resultantes das solu\u00e7\u00f5es das equa\u00e7\u00f5es diofantinas para\no i-\u00e9sima sa\u00edda.\n\nRepetindo este procedimento para as outras sa\u00eddas, pode-se obter o vetor de\npredi\u00e7\u00f5es futuras \u00f3timas y?(t) atrav\u00e9s de\n\ny?(t) = H?u(t) + Hv(z\n?1)?v(t + 1) + I(z?1)?uf (t? 1) + Iv(z?1)?vf (t)\n\n+ F(z?1)yf (t)\n\n(2.24)\n\nDa mesma forma que no caso SISO, a Equa\u00e7\u00e3o 2.24 pode ser simplificada\nagrupando as parcelas que n\u00e3o dependem das varia\u00e7\u00f5es futuras da a\u00e7\u00e3o de controle\nna resposta livre f, resultando e,\n\ny?(t) = Hu(t) + f (2.25)\n\n\n\n2.2. Generalized Predictive Controller 33\n\nA fun\u00e7\u00e3o custo da Equa\u00e7\u00e3o 2.19 pode ser reescrita da seguinte forma:\n\nJ = (Hu + f ?w)TQy(Hu + f ?w) + uTQuu (2.26)\n\nonde Qy = diag(?1, . . . ,?n) \u00e9 uma matriz diagonal quadrada de ordem\n?n\n\ni=1 Ni que\nrepresenta os pesos dos erros futuros e os pesos das a\u00e7\u00f5es de controle futuras s\u00e3o\ndadas por Qu = diag(?1, . . . ,?n), que tamb\u00e9m \u00e9 diagonal quadrada, de ordem\n\n?m\ni=1 Nui,\n\nonde diag \u00e9 uma fun\u00e7\u00e3o para representar matrizes diagonais.\n\nRearranjando a Equa\u00e7\u00e3o 2.26, \u00e9 obtido:\n\nJ =\n1\n\n2\nuTPu + qTu + f0 (2.27)\n\nonde:\n\nP = 2(HTQyH + Qu) (2.28)\n\nqT = 2(f ?w)TQyH (2.29)\n\nf0 = (f ?w)TQy(f ?w) (2.30)\n\nO c\u00e1lculo da lei de controle ocorre da seguinte maneira:\n\n?u = K1(w ?f) (2.31)\n\nu(t) = u(t? 1) + ?u(t) (2.32)\n\nonde K1 \u00e9 a primeira linha que faz refer\u00eancia a cada vari\u00e1vel manipulada da matriz\nK = (HTQyH + Qu)\n\n?1HTQy de ordem 1 \u00d7\n?n\n\ni=1 Ni.\n\n2.2.1 Algoritmo GPC\n\nDado um processo MIMO, com m entradas, n sa\u00eddas e p perturba\u00e7\u00f5es, repre-\nsentado por:\n\nY (z?1) = ?u(z\n?1)U(z?1) + ?v(z\n\n?1)V (z?1) (2.33)\n\n?u e ?v s\u00e3o matrizes de transfer\u00eancia discretas, o algoritmo MIMO-GPC \u00e9 executado\nda seguinte forma:\n\n\n\n34 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\n1. Calcular a representa\u00e7\u00e3o em DMF do processo, obtendo as matrizes polinomiais\nA(z?1), B(z?1), D(z?1) e L(z?1);\n\n2. Solucionar o conjunto de equa\u00e7\u00f5es diofantinas e, considerando os horizontes de\npredi\u00e7\u00e3o e de controle, obter as matrizes H, Hv, Iij, Ivik e Fi dado que i = 1, . . . ,n;\nj = 1, . . . ,m e k = 1, . . . ,p;\n\n3. Leitura das sa\u00eddas e perturba\u00e7\u00f5es do processo e, caso Ti(z?1) = 1 para algum\ni, filtrar as vari\u00e1veis de perturba\u00e7\u00e3o, entrada e sa\u00edda pelo respectivo polin\u00f4mio\nTi(z\n\n?1);\n\n4. C\u00e1lculo da resposta livre por partes:\n\n(a) Calcular a resposta livre da i-\u00e9sima sa\u00edda atrav\u00e9s da equa\u00e7\u00e3o;\n\nfi =\nm?\ni=1\n\nIij[?ufj(t? 1), ..., ?ufj(t?dij ?nbij)]T\n\n+\n\np?\ni=1\n\nIvij [?vfj(t? 1), ..., ?vfj(t?dvij ?nbij) + 1]\nT\n\n+ Fi[yfi, ...,yfi(t?nai)]T\n\n(2.34)\n\n(b) Calcular a resposta livre total atrav\u00e9s da abaixo e adicionar o termo Hv?v(t+\n1) caso os valores das perturba\u00e7\u00f5es futuras sejam conhecidos.\n\nf =\n\n?\n???\nf1\n...\n\nfn\n\n?\n??? (2.35)\n\n5. Minimiza\u00e7\u00e3o da fun\u00e7\u00e3o custo:\n\n(a) Obter as matrizes P, qT e f0;\n\n(b) Minimizar a fun\u00e7\u00e3o custo com o uso de um algoritmo de otimiza\u00e7\u00e3o quadr\u00e1-\ntica e, assim, obter o vetor de incrementos das a\u00e7\u00f5es de controle futuras\nu.\n\n6. Calcular a a\u00e7\u00e3o de controle a ser aplicada no instante atual dado que uj(t) =\nuj(t? 1) + ?uj(t);\n\n7. Aplicar a a\u00e7\u00e3o de controle, e esperar um per\u00edodo de amostragem;\n\n8. Voltar ao Passo 3.\n\n\n\n2.3. Dynamic Matrix Control 35\n\nObserve que o algoritmo anterior tamb\u00e9m se aplica a um processo SISO, que \u00e9\num caso MIMO particular onde o n\u00famero de entradas e sa\u00eddas \u00e9 igual a 1.\n\n2.3 Dynamic Matrix Control\n\nA estrat\u00e9gia DMC usa a fun\u00e7\u00e3o custo introduzida anteriormente na Equa\u00e7\u00e3o\n2.14, com passos semelhantes aos das estrat\u00e9gias introduzidas anteriormente. As\ndiferen\u00e7as est\u00e3o nos c\u00e1lculos das respostas for\u00e7ada e livre, al\u00e9m das sa\u00eddas preditas\nda planta, que s\u00e3o computadas utilizando modelos de resposta ao degrau [6]:\n\ny?(t + k|t) =\n??\ni=1\n\ngi?u(t + k ? i) + ?(t + k|t) (2.36)\n\nA predi\u00e7\u00e3o da perturba\u00e7\u00e3o ?(t + k|t) \u00e9 considerada constante durante todo o\nhorizonte e igual a diferen\u00e7a entre as sa\u00eddas do modelo e processo.\n\n?(t + k|t) = ?(t|t) = y(t) ? y?(t|t) (2.37)\n\nUsando estas duas express\u00f5es e separando a a\u00e7\u00e3o de controle futuros resulta\nem:\n\ny?(t + k|t) =\nk?\n\ni=1\n\ngi?u(t + k ? i) +\n??\n\ni=k+1\n\ngi?u(t + k ? i)\n\n+ y(t) ?\n??\ni=1\n\ngi?u(t? i)\n\n=\nk?\n\ni=1\n\ngi?u(t + k ? i) + f(t + k)\n\n(2.38)\n\nonde f(t+k) \u00e9 a resposta livre do sistema, isto \u00e9, a parte da resposta que n\u00e3o depende\ndas a\u00e7\u00f5es de controle futuras, e \u00e9 dada por\n\nf(t + k) = y(t) +\n??\ni=1\n\n(gk+i ?gi)?u(t? i) (2.39)\n\nSe o processo \u00e9 assintoticamente est\u00e1vel, os coeficientes gi da resposta ao\ndegrau tendem a ser constantes ap\u00f3s M per\u00edodos de amostragem, ent\u00e3o gk+i ? gi\n\n\n\n36 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\ntende a zero e pode ser considerado que:\n\ny?(t + k|t) =\nk?\n\ni=1\n\ngi?u(t + k ? i) + y(t) +\nM?\ni=1\n\n(gk+i ?gi)?u(t? i) (2.40)\n\nNote que se o processo n\u00e3o for assintoticamente est\u00e1vel, ent\u00e3o M n\u00e3o existe e\nf(t + k) n\u00e3o pode ser computado. Usando um horizonte de predi\u00e7\u00e3o e um horizonte de\ncontrole, a minimiza\u00e7\u00e3o de J pode ser alcan\u00e7ada utilizando as predi\u00e7\u00f5es.\n\n2.3.1 Computando as Predi\u00e7\u00f5es\n\nPara computar as predi\u00e7\u00f5es basta escrev\u00ea-las na forma matricial:\n\ny? = G?u(t) + H?u(t? 1) + 1y(t) (2.41)\n\nonde:\n\ny? = [y?(t + 1|t), . . . , y?(t + N|t)]T (2.42)\n\n?u(t) = [?u(t), ?u(t + 1|t), . . . , ?u(t + Nu ? 1|t)]T (2.43)\n\n?u(t? 1) = [?u(t? 1), ?u(t? 2|t), . . . , ?u(t?M|t)]T (2.44)\n\nsabendo que 1 \u00e9 uma matriz N \u00d7 1 cujos elementos s\u00e3o todos um. As matrizes G e H\ntem dimens\u00e3o N \u00d7Nu e N \u00d7M, respectivamente e s\u00e3o dadas por:\n\nG =\n\n?\n??????????\n\ng1 0 . . . 0\n\ng2 g1 . . . 0\n... ... . . . ...\n\ngNu gNu?1 . . . g1\n... ... . . . ...\n\ngN gN?1 . . . gN?Nu+1\n\n?\n??????????\n\n(2.45)\n\nH =\n\n?\n?????\n\n(g2 ?g1) (g3 ?g2) . . . (gM+1 ?gM )\n(g3 ?g1) (g4 ?g2) . . . (gM+2 ?gM )\n\n... ... . . . ...\n\n(gN+1 ?g1) (gN+2 ?g2) . . . (gM+N ?gM )\n\n?\n????? (2.46)\n\n\n\n2.3. Dynamic Matrix Control 37\n\nComo pode-se observar na Equa\u00e7\u00e3o 2.41, basta calcular a matriz G para\nencontrar a resposta for\u00e7ada G?u(t). J\u00e1 a resposta livre do sistema \u00e9 dada por\nf = H?u(t? 1) + 1y(t) e pode ser obtida recursivamente.\n\n2.3.2 Obtendo Resposta Livre Recursivamente\n\nPara efeitos de simplifica\u00e7\u00e3o, ser\u00e1 analisado o caso SISO para descrever a\nrecursividade do DMC. As predi\u00e7\u00f5es em malha aberta, yo, num instante t + k, sabendo\ninforma\u00e7\u00f5es dos instantes t e t? 1, s\u00e3o [22]:\n\nyo(t + k|t) =\n??\n\ni=k+1\n\ngi?u(t + k ? i)\n\nyo(t + k|t? 1) =\n??\n\ni=k+2\n\ngi?u(t + k ? i)\n(2.47)\n\nA diferen\u00e7a das predi\u00e7\u00f5es em t + k nos instantes t e t ? 1 \u00e9 somente o novo\nincremento de controle ?u(t? 1), que n\u00e3o era conhecido em t? 1. Subtraindo as duas\nequa\u00e7\u00f5es anteriores, as predi\u00e7\u00f5es podem ser reescritas recursivamente como:\n\nyo(t + k|t) = gk+1?u(t? 1) + yo(t + k|t? 1) (2.48)\n\nDessa forma, para calcular a resposta livre inicialmente deve-se criar um vetor,\ncom M elementos, e armazen\u00e1-lo na mem\u00f3ria Yo = [yo(t|t?1), . . . ,yo(t+M?1|t?1)]T ,\ncujos elementos s\u00e3o as predi\u00e7\u00f5es futuras dadas as a\u00e7\u00f5es de controle passadas conhe-\ncidas at\u00e9 o instante t? 1. Durante a inicializa\u00e7\u00e3o no instante t0, pode ser considerado\nque o sistema est\u00e1 em regime permanente e todas as predi\u00e7\u00f5es futuras s\u00e3o iguais \u00e0\nsa\u00edda atual do sistema y(t0).\n\nDepois da inicializa\u00e7\u00e3o, no instante t, \u00e9 necess\u00e1rio atualizar o vetor j\u00e1 que as\na\u00e7\u00f5es de controle passadas se tornam conhecidas.\n\nY0 = Y0 +\n\n?\n?????\ng1\n\ng2\n...\n\ngM\n\n?\n????? ?u(t? 1) (2.49)\n\nPortanto, o vetor Y0 \u00e9 atualizado. Depois da atualiza\u00e7\u00e3o, \u00e9 necess\u00e1rio mover\nos valores dentro do vetor Y0. Isso \u00e9 importante porque no pr\u00f3ximo instante, t + 1,\nser\u00e3o necess\u00e1rios as predi\u00e7\u00f5es futuras do instante t + 1 at\u00e9 t + M baseados nas a\u00e7\u00f5es\n\n\n\n38 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\nde controle no instante t. Portanto, o primeiro elemento, y0(t|t), \u00e9 removido do vetor\ne usado para calcular o erro de predi\u00e7\u00e3o atual, ?(t|t) = y(t) ? y0(t|t). Por causa do\ndeslocamento, o \u00faltimo valor de Y0, que deveria ser y0(t+M|t) n\u00e3o \u00e9 conhecido. Por\u00e9m,\nno caso de sistemas est\u00e1veis, y0(t + M|t) ?= y0(t + M ? 1|t), e, portanto, o novo vetor\nY0 ser\u00e1:\n\nY0 =\n\n?\n????????\n\nyo(t + 1|t)\nyo(t + 2|t)\n\n...\n\nyo(t + M ? 1|t)\nyo(t + M ? 1|t)\n\n?\n????????\n\n(2.50)\n\nPor fim, para calcular a resposta livre \u00e9 feito, sabendo que 1N \u00e9 uma matriz\ncoluna com elementos igual a 1:\n\nf =\n\n?\n???\nyo(t + 1|t)\n\n...\n\nyo(t + N|t)\n\n?\n??? + 1N (y(t) ?yo(t|t)) (2.51)\n\nOs passos para o c\u00e1lculo do sinal de controle s\u00e3o semelhantes ao do m\u00e9todo\nanterior, considerando que para calcular as respostas for\u00e7ada e livre s\u00e3o utilizados os\nconceitos apresentados especificamente para o algoritmo DMC.\n\n2.4 Practical Non-Linear Model Predictive Controller\n\nNa pr\u00e1tica os algoritmos MPC mais utilizados s\u00e3o os baseados em modelos\nlineares. Mas, na grande maioria dos casos, os processos se comportam segundo\nequa\u00e7\u00f5es n\u00e3o lineares, o que pode causar erros consider\u00e1veis na modelagem do\nprocesso dependendo de como o modelo foi linearizado e quais as faixas de opera\u00e7\u00e3o\ndefinidas para o processo, dificultando a utiliza\u00e7\u00e3o de modelos lineares para represent\u00e1-\nlos.\n\nDesta forma, foi proposto por Plucenio em [20] um algoritmo, chamado de\nPractical Non-Linear Model Predictive Controller (PNMPC), capaz de utilizar modelos\nn\u00e3o-lineares e se beneficiar da estrat\u00e9gia do MPC para o controle de processos. O\nintuito do PNMPC \u00e9, atrav\u00e9s da aplica\u00e7\u00e3o dos conceitos de controle preditivo baseado\nem modelo e modelos de sistemas n\u00e3o-lineares, proporcionar uma forma pr\u00e1tica de evi-\ntar problemas de otimiza\u00e7\u00e3o n\u00e3o-lineares complexas. O desenvolvimento apresentado\na seguir foi baseado na tese de doutorado do professor Daniel Martins Lima [6].\n\n\n\n2.4. Practical Non-Linear Model Predictive Controller 39\n\nComo mencionado anteriormente, existem conceitos b\u00e1sicos que se aplicam\npara os algoritmos MPC. Ent\u00e3o, sabendo que o sistema apresenta uma resposta livre e\numa resposta for\u00e7ada, combinando ambas resulta no seguinte vetor de predi\u00e7\u00e3o:\n\ny? = G?u(t) + f (2.52)\n\nNos sistemas lineares \u00e9 poss\u00edvel se aproveitar do conceito de superposi\u00e7\u00e3o,\nrepresentando o vetor de predi\u00e7\u00e3o como a soma entre a resposta for\u00e7ada e livre\ne permitindo que estes sejam calculados separadamente. Por\u00e9m, em sistemas n\u00e3o\nlineares o princ\u00edpio da superposi\u00e7\u00e3o n\u00e3o pode ser aplicado e desta forma n\u00e3o \u00e9\nposs\u00edvel calcular as respostas livre e for\u00e7ada em partes. Entretanto, para ultrapassar\nessa barreira imposta o PNMPC prop\u00f5e uma solu\u00e7\u00e3o que permite a separa\u00e7\u00e3o das\nrespostas linearizando a equa\u00e7\u00e3o em cada instante de tempo.\n\n2.4.1 Obtendo a Resposta For\u00e7ada\n\nPara facilitar o desenvolvimento, considere um sistema SISO de primeira ordem,\ndiscreto e n\u00e3o-linear:\n\ny(t + 1) = f(y(t),u(t)) (2.53)\n\nonde f : R\u00d7R ? R. Note que o valor da sa\u00edda em t + 1 depende apenas da entrada e\nsa\u00edda em t. Essa suposi\u00e7\u00e3o parece restritiva, mas o resultados que ser\u00e3o demonstrados\npodem ser facilmente estendidos para sistema n\u00e3o-lineares mais gen\u00e9ricos. Portanto,\npara maior simplicidade, esse sistema ser\u00e1 usado.\n\nPara prosseguir, \u00e9 necess\u00e1rio obter o vetor de predi\u00e7\u00e3o, mas, antes disso, \u00e9\nlevado em considera\u00e7\u00e3o que u(t) = u(t?1) + ?u(t), portanto, a predi\u00e7\u00e3o em t + 1 pode\nescrita como:\n\ny(t + 1) = f0(y(t),u(t? 1), ?u(t)) (2.54)\n\nAs predi\u00e7\u00f5es futuras podem ser computadas recursivamente. Por exemplo, a\npredi\u00e7\u00e3o em t + 2:\n\ny(t + 2) = f(y(t + 1),u(t + 1))\n\n= f(f0(y(t),u(t? 1), ?u(t)),u(t + 1))\n(2.55)\n\nconsiderando que u(t + 1) = u(t? 1) + ?u(t) + ?u(t + 1),\n\ny(t + 2) = f1(y(t),u(t? 1), ?u(t), ?u(t)(t + 1)) (2.56)\n\n\n\n40 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\nonde f1(.) \u00e9 o resultado da composi\u00e7\u00e3o das fun\u00e7\u00f5es. Por inspe\u00e7\u00e3o, \u00e9 facilmente\nobservado que o vetor de predi\u00e7\u00f5es \u00e9:\n\n?\n?????\ny(t + 1)\n\ny(t + 2)\n...\n\ny(t + N)\n\n?\n????? =\n\n?\n?????\n\nf0(y(t),u(t? 1), ?u(t))\nf1(y(t),u(t? 1), ?u(t), ?u(t + 1))\n\n...\n\nfN?1(y(t),u(t? 1), ?u(t), . . . , ?u(t + N ? 1))\n\n?\n????? (2.57)\n\nSabendo que N \u00e9 o horizonte de predi\u00e7\u00e3o e, para simplificar, \u00e9 considerado que\no horizonte de controle Nu = N. Essa \u00faltima equa\u00e7\u00e3o pode ser reescrita como\n\ny = F (y(t),u(t? 1), ?u(t)) (2.58)\n\nonde ?u(t) = [?u(t), ?u(t + 1), . . . , ?u(t + N ? 1)]T\n\nUtilizando a s\u00e9rie de Taylor para aproximar a fun\u00e7\u00e3o y por uma fun\u00e7\u00e3o linearizada\nem cada instante de tempo, o algoritmo PNMPC computa a predi\u00e7\u00e3o do processo n\u00e3o-\nlinear da seguinte forma:\n\ny = GP NMP C?u(t) + f (2.59)\n\ncujo GPNMPC \u00e9 uma matriz Jacobiana de F com a seguinte estrutura:\n\nGP NMP C =\n?F\n\n??u(t)\n=\n\n?\n?????????\n\n?y(t + 1)\n\n??u(t)\n0 \u00b7 \u00b7 \u00b7 0\n\n?y(t + 2)\n\n??u(t)\n\n?y(t + 2)\n\n??u(t + 1)\n\u00b7 \u00b7 \u00b7 0\n\n... ... . . . ...\n?y(t + N)\n\n??u(t)\n\n?y(t + N)\n\n??u(t + 1)\n\u00b7 \u00b7 \u00b7\n\n?y(t + N)\n\n??u(t + N ? 1)\n\n?\n?????????\n\n(2.60)\n\nPode ser observado que a matriz GPNMPC apresenta caracter\u00edstica de uma matriz\ntriangular inferior, o que \u00e9 bastante intuitivo. Como o sistema \u00e9 causal, as predi\u00e7\u00f5es em\nt + i dependem apenas dos incrementos de controle at\u00e9 o instante t + i? 1.\n\nPara computar o Jacobiano da matriz F :\n\n1. Compute e resposta livre do sistema y?0 = F (x)\n\n\n\n2.4. Practical Non-Linear Model Predictive Controller 41\n\n2. Compute a primeira coluna de GPNMPC. Fa\u00e7a ?u(t) = [?, 0, . . . , 0]T , onde ? \u00e9 um\nvalor pequeno, como u(t? 1)/1000 e calcule y?1 = F(y(t),u(t? 1), ?u(t)). Ent\u00e3o,\na primeira coluna de GPNMPC \u00e9 dada por:\n\ny?1 ? y?0\n\n?\n(2.61)\n\n3. Compute a segunda coluna de GPNMPC. Fa\u00e7a ?u(t) = [0, ?, 0, . . . , 0]T e calcule\ny?2 = F(y(t),u(t? 1), ?u(t)). Portanto, a segunda coluna de GPNMPC \u00e9 dada por:\n\ny?2 ? y?0\n\n?\n(2.62)\n\n4. Repita o mesmo procedimento para as outras colunas de GPNMPC at\u00e9 completar a\nmatriz.\n\n2.4.2 Obtendo a Resposta Livre\n\nA resposta for\u00e7ada do modelo computado anteriormente \u00e9 somente utilizada\npara encontrar a matriz GPNMPC porque n\u00e3o leva em considera\u00e7\u00e3o a presen\u00e7a de\nperturba\u00e7\u00f5es e, portanto, o controle resultante n\u00e3o ir\u00e3 rejeitar esses sinais. Para\ncomputar a resposta livre corretamente o PNMPC modela as perturba\u00e7\u00f5es como um\nru\u00eddo branco integrado, o que \u00e9 suficiente para descrever perturba\u00e7\u00f5es constantes de\nprocessos.\n\ny(t + 1) = f(y(t),u(t)) +\ne(t)\n\n?\n(2.63)\n\nonde e(t) \u00e9 o ru\u00eddo branco e ? = 1 ? q?1 \u00e9 um polin\u00f4mio no operador atraso q, isto \u00e9,\nq?1f(x(t),u(t)) = f(x(t + 1),u(t + 1)). Multiplicando ambos lados por ?, temos:\n\n?y(t + 1) = ?f(y(t),u(t)) + e(t) (2.64)\n\nComo o valor esperado de e(t) = 0,?t, a predi\u00e7\u00e3o \u00f3tima em t + 1 \u00e9:\n\n?y(t + 1) = ?f(y(t),u(t)) (2.65)\n\ny(t + 1|t) ?y(t|t) = f(y(t),u(t)) ?f(y(t? 1),u(t? 1)) (2.66)\n\ne sabendo que a predi\u00e7\u00e3o y(t|t) = y(t), chega-se \u00e0 conclus\u00e3o que a sa\u00edda medida \u00e9:\n\ny(t + 1|t) = f(y(t),u(t)) + y(t) ?f(y(t? 1),u(t? 1)) (2.67)\n\n\n\n42 Cap\u00edtulo 2. Controlador Preditivo Baseado em Modelo\n\nNote que y(t) ?f(y(t? 1),u(t? 1)) \u00e9 a predi\u00e7\u00e3o do erro, ou seja, a diferen\u00e7a\nentre a sa\u00edda em k menos a predi\u00e7\u00e3o em y(t|t? 1), ou, y(t) ?y(t|t? 1).\n\nO mesmo procedimento pode ser usado para computar a predi\u00e7\u00e3o em t + 2.\n\n?y(t + 2) = ?f(y(t + 1),u(t + 1)) (2.68)\n\ny(t + 2|t) ?y(t + 1|t) = f(y(t + 1),u(t + 1)) ?f(y(t),u(t)) (2.69)\n\nsubstituindo y(t + 1|t) da Equa\u00e7\u00e3o 2.67 na Equa\u00e7\u00e3o 2.69:\n\ny(t + 2|t) = f(y(t + 1|t),u(t + 1)) + y(t) ?f(y(t? 1),u(t? 1)) (2.70)\n\nPor inspe\u00e7\u00e3o, pode ser observado que as predi\u00e7\u00f5es podem ser calculadas\nrecursivamente com a adi\u00e7\u00e3o do erro de predi\u00e7\u00e3o:\n\ny(t+k|t) = f(y(t+k?1|t),u(t+k?1))+y(t)?f(y(t?1),u(t?1)) (2.71)\n\n2.4.3 Algoritmo PNMPC\n\nPortanto, para se aplicar o algoritmo PNMPC, os passos abaixo s\u00e3o necess\u00e1rios:\n\n1. Leia a sa\u00edda atual do sistema y(t);\n\n2. Compute GPNMPC, utilizando o m\u00e9todo descrito na se\u00e7\u00e3o 2.3.1;\n\n3. Calcule a resposta livre corrigida f do sistema, usando a Equa\u00e7\u00e3o 2.71 recursiva-\nmente;\n\n4. Minimize a fun\u00e7\u00e3o custo quadr\u00e1tica, reescrita da forma obtida para o algoritmo\nGPC:\n\nJ = (y? ?w)TQy(y? ?w) + ?uTQu?u (2.72)\n\ne obtenha os incrementos de controle. A equa\u00e7\u00e3o J \u00e9 igual \u00e0 utilizada no algoritmo\nGPC e por isso a solu\u00e7\u00e3o \u00e9 a mesma ;\n\n5. Aplique a a\u00e7\u00e3o de controle calculada no processo n\u00e3o-linear;\n\n6. Espere um tempo de amostra e repita.\n\n\n\n2.4. Practical Non-Linear Model Predictive Controller 43\n\nConsidera\u00e7\u00f5es Finais\n\nFoi abordado nesse cap\u00edtulo detalhes dos algoritmos implementados no software\ndescrevendo a diferen\u00e7a entre cada estrat\u00e9gia MPC presente na interface desenvolvida.\nO DMC foi desenvolvido principalmente devido \u00e0 sua grande presen\u00e7a na ind\u00fastria\npetroqu\u00edmica, sendo amplamente utilizado na Petrobr\u00e1s e sendo alvo de muitas pes-\nquisas e estudos. J\u00e1 o GPC e o PNMPC s\u00e3o algoritmos com grande capacidade e\nque ainda ter\u00e3o participa\u00e7\u00e3o cada vez maior conforme suas t\u00e9cnicas se tornarem mais\nexploradas.\n\n\n\n\n\n45\n\n3 Metodologia de Desenvolvimento de\nSoftware\n\nExistem diversas t\u00e9cnicas que s\u00e3o empregadas para auxiliar no desenvolvimento\nde softwares, conhecidas como Metodologias de Desenvolvimento de Software. Pode-\nse considerar que uma metodologia de desenvolvimento de software \u00e9 [23]:\n\n(...) um conjunto coerente e coordenado de m\u00e9todos para atingir um objetivo,\nde modo que se evite, tanto quanto poss\u00edvel, a subjetividade na execu\u00e7\u00e3o\ndo trabalho. Fornecendo um roteiro, um processo din\u00e2mico e interativo para\ndesenvolvimento estruturado de projetos, sistemas ou software, visando \u00e0\nqualidade e produtividade dos projetos. (LEITE, 2006)\n\nAs metodologias s\u00e3o usadas com objetivos diversos, al\u00e9m de ter fun\u00e7\u00f5es dis-\ntintas dependendo do projeto. Uma das principais fun\u00e7\u00f5es \u00e9 a defini\u00e7\u00e3o do dever e\nresponsabilidade de cada agente, incluindo o usu\u00e1rio, o programador e o administrador.\nO resultado dessa divis\u00e3o de trabalho \u00e9 uma solidez de execu\u00e7\u00e3o do projeto, de forma\na atender as exig\u00eancias b\u00e1sicas de implementa\u00e7\u00e3o do projeto com clareza e permitindo\numa liberdade suficiente para garantir a qualidade do produto final.\n\nPara o desenvolvimento da interface gr\u00e1fica apresentada nesta monografia foi\nutilizada a metodologia baseado no Unified Process, ou Processo Unificado, devido\na sua forte conex\u00e3o com a orienta\u00e7\u00e3o a objeto, um dos paradigmas de programa\u00e7\u00e3o\nda linguagem utilizada para implementa\u00e7\u00e3o da interface. O UP possibilita a divis\u00e3o do\nprojeto em pequenas partes, subdivindo-o para facilitar a sua execu\u00e7\u00e3o, aproveitando-\nse dos conceitos da engenharia do software. Cada etapa do subprojeto \u00e9 executada\nindividualmente e de forma incremental utilizando diagramas ou tabelas para simplificar\na implementa\u00e7\u00e3o.\n\nPara melhorar a compreens\u00e3o de cada etapa desenvolvida antes da implemen-\nta\u00e7\u00e3o durante o UP, \u00e9 comum integr\u00e1-lo com alguma nota\u00e7\u00e3o que permite representar\nos sistemas de forma padronizada. Portanto, o Processo Unificado foi integrado com\no UML (Unified Modelling Language), uma linguagem de estrutura\u00e7\u00e3o e modelagem\nde sistemas, aplica\u00e7\u00f5es e comportamentos do processo, para facilitar a leitura dos\ndiversos artefatos (diagramas e tabelas) desenvolvidos [24]. O UML apresenta uma\nespecifica\u00e7\u00e3o mundialmente conhecida e aceita na comunidade acad\u00eamica, o que o\ntorna interessante para cria\u00e7\u00e3o dos softwares por seu reconhecimento.\n\n\n\n46 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\nFigura 3 \u2013 Etapas do Processo Unificado.\n\nNa Figura 3 \u00e9 mostrado como as etapas s\u00e3o divididas e se comunicam durante\na implementa\u00e7\u00e3o do projeto.\n\n\u2022 Concep\u00e7\u00e3o: Nesta etapa \u00e9 realizada a obten\u00e7\u00e3o dos requisitos de forma a\nverificar a viabilidade e os riscos do projeto [25], obtidos atrav\u00e9s de cen\u00e1rios com\nas intera\u00e7\u00f5es entre clientes e usu\u00e1rios finais, criando a partir dos cen\u00e1rios os\ncasos de uso a serem desenvolvidos.\n\n\u2022 Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o: O projeto come\u00e7a a ser planejado e modelado mais\nprofundamente para come\u00e7ar a ser implementado com mais detalhes e interativa-\nmente, partindo dos requisitos de projeto definidos a priori. A implementa\u00e7\u00e3o dos\nc\u00f3digos \u00e9 interativa de forma que ao final da intera\u00e7\u00e3o o projeto est\u00e1 praticamente\npronto, dependendo apenas da pr\u00f3xima etapa de transi\u00e7\u00e3o.\n\n\u2022 Transi\u00e7\u00e3o: \u00daltima etapa da metodologia, no qual o projeto constru\u00eddo \u00e9 implan-\ntado, sendo este levado at\u00e9 o usu\u00e1rio final para testes. Esta etapa n\u00e3o \u00e9 objeto\nde estudo nesta monografia.\n\n3.1 Etapa de Concep\u00e7\u00e3o\n\nO principal objetivo da etapa de concep\u00e7\u00e3o \u00e9 definir o prop\u00f3sito geral do objeto.\nVale ressaltar que nesta fase n\u00e3o \u00e9 necess\u00e1ria uma especifica\u00e7\u00e3o detalhada dos\nrequisitos do projeto, apenas levantamentos da estrutura b\u00e1sica necess\u00e1ria para cria\u00e7\u00e3o\ne implementa\u00e7\u00e3o, sua viabilidade e tamb\u00e9m uma estimativa do esfor\u00e7o e prazos\nnecess\u00e1rios para realiza\u00e7\u00e3o do projeto. Inicialmente s\u00e3o levantados os requisitos do\nprojeto [26].\n\n\n\n3.1. Etapa de Concep\u00e7\u00e3o 47\n\nO primeiro contato com o cliente ocorre durante a concep\u00e7\u00e3o, onde o analista ir\u00e1\ndescobrir quais as inten\u00e7\u00f5es do cliente para o projeto, produzindo um relat\u00f3rio com os\nobjetivos gerais. Trata-se de uma fase com grande comunica\u00e7\u00e3o entre analista e cliente,\nvisto que o analista apresenta nenhum conhecimento acerca do que ser\u00e1 desenvolvido,\nsendo necess\u00e1ria uma an\u00e1lise para que ele saiba se vale a pena desenvolver o projeto\nrequisitado.\n\nAp\u00f3s comunicar-se com o cliente, um documento deve ser gerado pelo analista\ncom uma vis\u00e3o geral do sistema, chamado de Sum\u00e1rio Executivo. Nele s\u00e3o levantados\nos dados relevantes, exprimindo certo requisitos b\u00e1sicos do projeto, assim como\nrestri\u00e7\u00f5es que ser\u00e3o impostas nele. Como trata-se de uma vis\u00e3o geral, o sum\u00e1rio\nexecutivo pode n\u00e3o contemplar todas as restri\u00e7\u00f5es, que dever\u00e3o ser analisadas e/ou\nimplementadas em fases posteriores.\n\nDessa forma, os resultados da etapa de concep\u00e7\u00e3o geralmente envolvem o\nlevantamento dos requisitos do projeto, assim como os riscos ao realiz\u00e1-lo, para depois\nserem criados os casos de uso gen\u00e9ricos e o cronograma geral a ser seguido durante\no desenvolvimento do projeto [27].\n\n3.1.1 Requisitos do Projeto\n\nOs requisitos s\u00e3o condi\u00e7\u00f5es e capacidades que o sistema, ou projeto, deve\nseguir. O principal desafio em definir os requisitos est\u00e1 em encontrar, comunicar e\nlembrar o que realmente \u00e9 necess\u00e1rio desenvolver de forma que o cliente e os membros\nde desenvolvimento entendam com clareza os objetivos do projeto [28].\n\nAl\u00e9m disso, devem tamb\u00e9m ser definidas todas as atribui\u00e7\u00f5es b\u00e1sicas, descre-\nvendo brevemente o comportamento do sistema para que o seu planejamento tenha\nclareza e facilidade durante a sua execu\u00e7\u00e3o. Portanto, durante a fase de an\u00e1lise dos\nrequisitos \u00e9 necess\u00e1rio agrupar o m\u00e1ximo de informa\u00e7\u00e3o, assim como definir as restri-\n\u00e7\u00f5es do projeto, com o objetivo de representar o sistema o mais fiel poss\u00edvel, evitando\nreprojetos durante a sua realiza\u00e7\u00e3o.\n\nOs requisitos podem ser agrupados em dois grupos, os requisitos funcionais\nque apresentam as funcionalidades do sistema e os requisitos n\u00e3o-funcionais que s\u00e3o\nas restri\u00e7\u00f5es ligadas a cada requisito funcional. Portanto, requisitos n\u00e3o-funcionais\naparecem sempre conectados aos funcionais, constituindo dois tipos b\u00e1sicos:\n\n\u2022 L\u00f3gicos: est\u00e3o relacionados \u00e0s regras de neg\u00f3cio da fun\u00e7\u00e3o associada;\n\n\u2022 Tecnol\u00f3gicos: dizem respeito \u00e0 tecnologia que ser\u00e1 necess\u00e1ria para a efetua\u00e7\u00e3o\nda fun\u00e7\u00e3o.\n\n\n\n48 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\nA documenta\u00e7\u00e3o dos requisitos \u00e9 de extrema import\u00e2ncia para o analista com-\npreender a complexidade do sistema a ser desenvolvido. Dessa forma, \u00e9 necess\u00e1rio um\ndetalhamento de cada requisito que, segundo Larman (2004), sem esse detalhamento\no sistema parecer\u00e1 mais simples do que de fato \u00e9, explicando o porque de muitos\nanalistas desperdi\u00e7arem muito mais tempo desenvolvendo um determinado sistema,\nultrapassando os prazos e or\u00e7amentos previstos [28].\n\n3.1.2 Casos de Uso\n\nUma vez que todos os requisitos tenham sido abordados, s\u00e3o criados grupos\ncorrelacionados, organizando-os em ciclos iterativos, chamados de Casos de Uso. O\nprincipal objetivo dos casos de uso \u00e9 assistir no di\u00e1logo entre analistas e usu\u00e1rios,\ndescrevendo a sequ\u00eancia l\u00f3gica de como o sistema ser\u00e1 utilizado, as intera\u00e7\u00f5es que\nexistem entre cada ator. Com isso, as funcionalidades do sistema come\u00e7am a se\ntornar evidente, de forma que at\u00e9 mesmo pessoas sem nenhum conhecimento sobre o\nsistema s\u00e3o capazes de compreender suas fun\u00e7\u00f5es e comportamentos.\n\nOs casos de uso apresentam uma representa\u00e7\u00e3o espec\u00edfica no UML, em forma\nde diagramas, dos quais as elipses representam casos de uso, os bonecos representam\natores (usu\u00e1rios) e o ret\u00e2ngulo representa a fronteira do sistema ou subsistemas, como\npode-se observar na Figura 4.\n\n\u00c9 importante que nessa fase de desenvolvimento os diagramas ainda tenham\nalto n\u00edvel de representa\u00e7\u00e3o, pois ainda n\u00e3o \u00e9 a inten\u00e7\u00e3o do analista mostrar intera\u00e7\u00f5es\ndetalhadas do sistema, mas sim represent\u00e1-lo de forma simples e clara. Portanto,\ndeve-se evitar um grande n\u00famero de elipses e caracterizar muito bem os casos de uso\npara evitar que eles se tornem demasiadamente aprofundados, ou, tamb\u00e9m, que faltem\nfuncionalidades importantes do sistema.\n\nCom a identifica\u00e7\u00e3o dos casos de uso, \u00e9 necess\u00e1rio apurar se todos os requisitos\nfuncionais do sistema est\u00e3o associados de alguma forma com ao menos um dos casos\nde uso. Quando isso n\u00e3o ocorre, significa que provavelmente ainda esteja faltando\nalgum caso de uso.\n\nO UP \u00e9 governado pelos casos de uso e centrado na arquitetura. Portanto,\nnas fases seguintes do desenvolvimento do sistema ser\u00e1 detalhada progressivamente\numa arquitetura que permita que cada caso de uso identificado seja devidamente\ndesempenhado pelo seu respectivo ator. E, como dito anteriormente, o UP \u00e9 interativo\ne incremental, o que significa que em cada etapa do desenvolvimento um conjunto de\ncasos de uso sejam considerados para estudo e suas funcionalidades incorporadas na\narquitetura [27].\n\n\n\n3.2. Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o 49\n\nFigura 4 \u2013 Diagrama de casos de uso.\n\n3.2 Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o\n\nA fase de constru\u00e7\u00e3o engloba a gera\u00e7\u00e3o do bancos de dados e a gera\u00e7\u00e3o de\nc\u00f3digo e testes. E, durante a fase de elabora\u00e7\u00e3o do UP, o analista come\u00e7a a an\u00e1lise e\nprojeto do sistema a ser desenvolvido. Nela s\u00e3o feitas s\u00e9ries de itera\u00e7\u00f5es onde [28]:\n\n\u2022 A maioria dos requisitos s\u00e3o descobertos e estabilizados;\n\n\u2022 A maioria dos riscos s\u00e3o mitigados ou at\u00e9 mesmo retirados;\n\n\u2022 Os elementos principais da arquitetura s\u00e3o implementados e provados.\n\nA an\u00e1lise realizada na elabora\u00e7\u00e3o do projeto geralmente \u00e9 dividida em tr\u00eas\nsubatividades [27]:\n\na) Expans\u00e3o dos casos de uso;\n\nb) Constru\u00e7\u00e3o ou refinamento do modelo conceitual;\n\nc) Elabora\u00e7\u00e3o dos contratos das opera\u00e7\u00f5es e consultas de sistema;\n\n\u00c9 comum iniciar esta etapa da metodologia com a expans\u00e3o dos casos de uso,\nvisto que \u00e9 uma atividade que necessita apenas dos casos de uso de alto n\u00edvel definidos\nanteriormente e tamb\u00e9m do documento de requisitos para realiz\u00e1-la imediatamente.\n\nJ\u00e1 o modelo conceitual, que ser\u00e1 detalhado posteriormente, depende unica-\nmente da expans\u00e3o dos casos de uso, pois o modelo conceitual utiliza informa\u00e7\u00f5es\n\n\n\n50 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\ntrocadas entre o sistema e o mundo externo que s\u00e3o geradas durante a expans\u00e3o dos\ncasos de uso.\n\nPor fim, a etapa de elabora\u00e7\u00e3o dos contratos \u00e9 realizada por \u00faltimo, j\u00e1 que\ndepende diretamente do modelo conceitual e das opera\u00e7\u00f5es e consultas do sistema\n[27].\n\n3.2.1 Expans\u00e3o dos Casos de Uso\n\nA expans\u00e3o dos casos de uso tem como objetivo a an\u00e1lise direta do documento\nde requisitos e dos casos de uso criados na etapa de concep\u00e7\u00e3o, especificando-os\ndetalhadamente, seus fluxos principais e alternativos, descrevendo o comportamento\nnatural do sistema a ser implementado e compreender todas as a\u00e7\u00f5es que o usu\u00e1rio\npode realizar, os caminhos que o sistema pode seguir. Tamb\u00e9m deve-se apresentar\nas exce\u00e7\u00f5es em conjunto, definindo quais caminhos n\u00e3o convencionais que o usu\u00e1rio\npode tomar no fluxo principal ou alternativo.\n\nDurante a expans\u00e3o, procura-se evitar mencionar interfaces ou tecnologias\nutilizadas, deve-se apenas informar o que o ator est\u00e1 comunicando ao sistema e, da\nmesma forma, o que o sistema est\u00e1 comunicando aos atores. Portanto, o caso de uso\nanalisado deve ser descrito detalhadamente e deve informar as intera\u00e7\u00f5es entre os\ndiversos atores e o sistema.\n\nInicialmente s\u00e3o descritos todas os fluxos principais que o sistema percorre,\nou seja, s\u00e3o esbo\u00e7ados os caminhos mais comuns que ser\u00e3o percorridos quando\no sistema est\u00e1 funcionando da forma desejada, sem a tentativa de prever erros ou\nexce\u00e7\u00f5es. Na expans\u00e3o existem alguns passos obrigat\u00f3rios que devem ser cumpridos,\ncomo mostrado na Figura 5. Em todos os passos da expans\u00e3o deve-se de alguma\nforma ficar expl\u00edcito que houve troca de informa\u00e7\u00f5es entre o sistema e um ou mais\nusu\u00e1rios.\n\nOs passos obrigat\u00f3rios em um caso de uso podem ser de dois tipos:\n\na) Eventos de sistema: quando alguma informa\u00e7\u00e3o \u00e9 transmitida do ator para o\nsistema;\n\nb) Respostas de sistema: quando a informa\u00e7\u00e3o \u00e9 transmitida do sistema para o ator.\n\nDepois, s\u00e3o identificados os fluxos alternativos, tentando observar os poss\u00edveis\nerros ou exce\u00e7\u00f5es que podem acontecer quando o sistema est\u00e1 percorrendo um fluxo\nprincipal, para ent\u00e3o descrever os procedimentos necess\u00e1rios para resolver o problema\nou tratar a exce\u00e7\u00e3o. \u00c9 importante salientar que as exce\u00e7\u00f5es n\u00e3o necessariamente\nocorrem com rara frequ\u00eancia, elas correspondem \u00e0 eventos que, quando n\u00e3o tratados\n\n\n\n3.2. Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o 51\n\nFigura 5 \u2013 Passos obrigat\u00f3rios durante a expans\u00e3o dos casos de uso.\n\ncomo devido, podem impedir o funcionamento adequado do sistema, impedindo a\nconclus\u00e3o do caso de uso e n\u00e3o que ele seja iniciado.\n\nNa pr\u00e1tica, as exce\u00e7\u00f5es apenas acontecem devido \u00e0 eventos de sistema, pois\nquando uma informa\u00e7\u00e3o \u00e9 transmitida ao sistema ele realiza certas valida\u00e7\u00f5es, ge-\nralmente correspondendo a restri\u00e7\u00f5es impostas durante a fase de concep\u00e7\u00e3o nos\nrequisitos do projeto. Para cada exce\u00e7\u00e3o detecta-se quais poss\u00edveis a\u00e7\u00f5es corretivas,\nde forma a tratar cada exce\u00e7\u00e3o evitando o funcionamento incorreto do caso de uso.\n\nComo dito anteriormente, deve-se evitar mencionar a tecnologia que ser\u00e1 utili-\nzada para implementa\u00e7\u00e3o. Dessa forma, independente de como ser\u00e1 implementado o\nsistema, as descri\u00e7\u00f5es geradas durante a expans\u00e3o dos casos de uso devem conter in-\nforma\u00e7\u00f5es que podem ser utilizadas em qualquer interface, contendo quais informa\u00e7\u00f5es\nser\u00e3o trocadas entre o sistema e o ambiente externo.\n\n3.2.2 Modelagem Conceitual\n\nO modelo conceitual \u00e9 uma especifica\u00e7\u00e3o do projeto que est\u00e1 sendo desen-\nvolvido, independente do software de simula\u00e7\u00e3o que se utilizar\u00e1 [29]. Desta forma, o\nmodelo conceitual visa apenas criar uma representa\u00e7\u00e3o l\u00f3gica do sistema, no mais alto\nn\u00edvel de abstra\u00e7\u00e3o, dando suporte para a constru\u00e7\u00e3o de fato do sistema. O diagrama\nconceitual representa diferentes conceitos, cada um com seus atributos e associando\nesses conceitos de forma coerente.\n\nEle tamb\u00e9m deve descrever a informa\u00e7\u00e3o gerenciada pelo sistema. O modelo\nconceitual n\u00e3o apresenta solu\u00e7\u00f5es para implementa\u00e7\u00e3o do sistema, apenas exp\u00f5e\no problema. Portanto, n\u00e3o deve ser interpretado como a arquitetura do software (re-\n\n\n\n52 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\npresentado pelo diagrama de classes), j\u00e1 que esta, apesar de originar-se da modelo\nconceitual, j\u00e1 apresenta uma solu\u00e7\u00e3o para o sistema.\n\nOutro equ\u00edvoco que muitas vezes ocorre \u00e9 confundir o modelo conceitual com o\nmodelo de dados. O modelo de dados interpreta como s\u00e3o representados e organizados\nos dados que ser\u00e3o armazenados no sistema, \u00e0 medida que o modelo conceitual tem\npor objetivo representar a compreens\u00e3o da informa\u00e7\u00e3o e n\u00e3o a sua representa\u00e7\u00e3o\nf\u00edsica [27]. Vendo por outro lado, um modelo de dados pode ser compreendido como\numa poss\u00edvel representa\u00e7\u00e3o f\u00edsica do modelo conceitual mais essencial.\n\nO modelo conceitual reflete apenas o ponto de vista est\u00e1tico da informa\u00e7\u00e3o.\nPortanto, n\u00e3o pode aparecer nele nada com semblante de informa\u00e7\u00e3o din\u00e2mica, embora\nna representa\u00e7\u00e3o UML utiliza-se diagrama de classes para representar o modelo\nconceitual e \u00e9 comum utiliz\u00e1-lo para representar informa\u00e7\u00f5es din\u00e2micas do sistema,\ncomo as classes. Ent\u00e3o, o analista n\u00e3o deve criar modelos conceituais com m\u00e9todos\nde classes.\n\nNa modelagem conceitual utiliza um esquema com tr\u00eas tipos de elementos\npara representar a informa\u00e7\u00e3o contida, utilizando diagramas de classes da UML como\nobservado na Figura 6:\n\na) Atributos: representa\u00e7\u00e3o que cont\u00e9m informa\u00e7\u00f5es simples, como n\u00fameros, textos,\ndatas e etc. Por exemplo, nome do controlador, n\u00famero de entradas e tempo de\namostragem;\n\nb) Conceitos, representa\u00e7\u00e3o que cont\u00e9m informa\u00e7\u00f5es complexas que agregam\natributos e que n\u00e3o podem ser descritas apenas por n\u00famero e letras. Por exemplo,\nControlador, Modelo, Cen\u00e1rio e Projeto;\n\nc) Associa\u00e7\u00f5es, que s\u00e3o liga\u00e7\u00f5es entre diferentes conceitos contendo informa\u00e7\u00f5es\nespec\u00edficas sobre a conex\u00e3o, sendo ela mesma um tipo de informa\u00e7\u00e3o. Por exem-\nplo, no software dever\u00e1 aparecer uma associa\u00e7\u00e3o entre o Projeto e o Controlador,\ncomo o n\u00famero de controladores que o projeto tem armazenado.\n\nFigura 6 \u2013 Modelo conceitual representado por diagrama de classes.\n\nPor\u00e9m, a cria\u00e7\u00e3o dos modelos conceituais apresentam complexidade maior\nque apenas relacionar conceitos com associa\u00e7\u00f5es e atributos. Para que a modelagem\n\n\n\n3.2. Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o 53\n\nconceitual resulte numa representa\u00e7\u00e3o confi\u00e1vel e rigorosa da informa\u00e7\u00e3o gerenciada\npelo sistema, recorre-se \u00e0 diferentes pr\u00e1ticas comuns de modelagem de sistemas.\nEssas pr\u00e1ticas s\u00e3o:\n\na) Estruturais: representando rela\u00e7\u00f5es de generaliza\u00e7\u00e3o estrutural de conceitos, utili-\nzando um importante paradigma da orienta\u00e7\u00e3o de objetos, a heran\u00e7a (definida nas\npr\u00f3ximas se\u00e7\u00f5es). Por exemplo, s\u00e3o implementados tr\u00eas tipos de controladores,\nque apresentam estruturas semelhantes. Assim, considera-se uma superclasse\nControlador, que generaliza tr\u00eas subclasses ControladorPNMPC, ControladorGPC\ne ControladorDMC;\n\nb) Associativas, representando rela\u00e7\u00f5es de pap\u00e9is associativos entre conceitos,\ncomo, por exemplo, Modelo, podendo representar junto no projeto o papel de\nmodelo do processo ou modelo utilizado pelo controlador para predi\u00e7\u00f5es;\n\nc) Temporais, representando rela\u00e7\u00f5es entre estados de um conceito como, por\nexemplo, um Cen\u00e1rio (cen\u00e1rio de simula\u00e7\u00e3o) e os estados simulado, n\u00e3o simulado.\n\nPor fim, \u00e9 muito importante garantir um modelo conceitual que resulte num\nbanco de dados estruturado e normalizado, garantindo que as informa\u00e7\u00f5es sejam\nrepresentadas inconsistentemente e evitando dados irrelevantes. Um bom modelo\nconceitual simplifica a cria\u00e7\u00e3o de c\u00f3digos porque o programador n\u00e3o precisar\u00e1 verificar\ncontinuamente a consist\u00eancia do sistema, que \u00e9 garantida pelo modelo conceitual.\n\n3.2.3 Contratos\n\nAs diversas opera\u00e7\u00f5es e consultas que ser\u00e3o implementadas no projeto podem\nser descritas utilizando contratos definidos ainda durante a etapa de elabora\u00e7\u00e3o do\nprojeto. As opera\u00e7\u00f5es de sistema s\u00e3o m\u00e9todos que s\u00e3o acionados quando ocorre\num evento de sistema, portanto, como uma rea\u00e7\u00e3o a uma a\u00e7\u00e3o do usu\u00e1rio. Podem\ntamb\u00e9m ser interpretadas como fluxos de informa\u00e7\u00e3o que fluem do exterior para o\ninterior do sistema, alterando informa\u00e7\u00f5es gerenciadas pelo sistema. J\u00e1 as consultas\nde sistema apresentam papel inverso, as informa\u00e7\u00f5es j\u00e1 armazenadas s\u00e3o verificadas\ninternamente.\n\nEnt\u00e3o, os contratos descrevem quais as fun\u00e7\u00f5es das opera\u00e7\u00f5es e o que ser\u00e1\ncumprido pelas opera\u00e7\u00f5es. S\u00e3o determinadas pr\u00e9- e p\u00f3s-condi\u00e7\u00f5es que descrevem\nmudan\u00e7as de estados do sistema e tamb\u00e9m exce\u00e7\u00f5es. As pr\u00e9-condi\u00e7\u00f5es definem quais\nas condi\u00e7\u00f5es iniciais que o sistema deve obedecer para que a opera\u00e7\u00e3o ou consulta\nseja executada. As p\u00f3s-condi\u00e7\u00f5es representam as mudan\u00e7as que ocorreram no sistema\nap\u00f3s a execu\u00e7\u00e3o da opera\u00e7\u00e3o ou consulta. Por fim, as exce\u00e7\u00f5es que representam\n\n\n\n54 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\nFigura 7 \u2013 Diagrama de sequ\u00eancia.\n\nestados que devem ser avaliados durante a execu\u00e7\u00e3o que pode acarretar na n\u00e3o\nexecu\u00e7\u00e3o final da opera\u00e7\u00e3o [3].\n\n3.2.4 Diagrama de Sequ\u00eancia\n\nOs diagramas de sequ\u00eancia s\u00e3o comumente utilizados para representar uma\nsequ\u00eancia de processos realizadas pelo usu\u00e1rio, cumprindo com os contratos definidos\npara cada opera\u00e7\u00e3o para execut\u00e1-las. Seu principal objetivo \u00e9 mostrar intera\u00e7\u00f5es entre\ndiferentes objetos a partir de casos de uso, representando uma linha de tempo no qual\neventos podem ocorrer.\n\nOutra forma de interpretar os diagramas de sequ\u00eancia \u00e9 como uma ferramenta\nque sistematiza os casos de uso expandidos desenvolvidos previamente com o intuito\nde refin\u00e1-los, obtendo mais detalhes sobre o funcionamento do sistema.\n\nA UML apresenta um diagrama ben\u00e9fico e espec\u00edfico para representar a sequ\u00ean-\ncia de eventos do sistema numa situa\u00e7\u00e3o de um caso de uso, como pode ser observado\nna Figura 7. O diagrama de sequ\u00eancia apresentado tem como elementos inst\u00e2ncias de\natores, interpretado por figuras humanas, e inst\u00e2ncias que representam elementos do\nsistema (interface).\n\nAl\u00e9m disso, para representar as mensagens trocadas s\u00e3o utilizadas linhas\n\n\n\n3.2. Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o 55\n\nverticais, podendo ser tracejadas ou inteiras dependendo do tipo de mensagem. As\nmensagens tracejadas consistem em retornos de mensagens pelo sistema, represen-\ntando ent\u00e3o a rea\u00e7\u00e3o do sistema aos atores quando estes provocam um est\u00edmulo\nao sistema. No diagrama representado pela Figura 7 existem tr\u00eas tipos de envio de\nmensagens:\n\na) entre atores, correspondendo a passos complementares do caso de uso expan-\ndido;\n\nb) dos atores para o sistema, eventos de sistema do caso de uso expandido;\n\nc) do sistema para os atores, respostas do sistema do caso de uso expandido.\n\nPor\u00e9m, \u00e9 poss\u00edvel interpretar os tipos de envio de mensagens de outra forma,\ndividindo-os em quatro tipos:\n\na) evento de sistema: representa mensagens enviadas pelo ator para o sistema,\nsendo caracterizado por uma seta do ator para a interface;\n\nb) resposta do sistema: acontecem quando o sistema envia alguma informa\u00e7\u00e3o para\nos atores, sendo representado por uma seta tracejada da interface para o ator;\n\nc) opera\u00e7\u00e3o do sistema: quando o sistema precisa alterar alguma informa\u00e7\u00e3o interna,\nele faz uma opera\u00e7\u00e3o de sistema. Portanto, \u00e9 uma chamada de m\u00e9todo executada\ninternamente em resposta a um evento do sistema;\n\nd) consulta do sistema: s\u00e3o semelhantes a opera\u00e7\u00e3o do sistema, por\u00e9m nesse caso\num m\u00e9todo \u00e9 invocado apenas para que o sistema retorne alguma informa\u00e7\u00e3o\npara os atores, sem alterar dados contidos internamente.\n\nTodos os elementos do diagrama de sequ\u00eancia, como atores ou interfaces,\ndisp\u00f5em de uma linha de tempo representado por colunas verticais, onde eventos\npodem ocorrer. Se a linha do tempo permanece tracejada ent\u00e3o o elemento que a\nconstitui est\u00e1 inativo. J\u00e1 quando ela est\u00e1 cheia, o elemento est\u00e1 ativo, o que pode\nsugerir que o elemento est\u00e1 operando ou est\u00e1 esperando o resultado de alguma\nopera\u00e7\u00e3o. Atores humanos est\u00e3o sempre ativos.\n\n3.2.5 Diagrama de Colabora\u00e7\u00e3o e de Classes\n\nAp\u00f3s todas as an\u00e1lises anteriores, pode-se come\u00e7ar a desenvolver solu\u00e7\u00f5es\npara o projeto de software propriamente dito. O problema j\u00e1 est\u00e1 descrito no diagrama\nconceitual, diagramas de sequ\u00eancia dos casos de uso e tamb\u00e9m no contratos e,\n\n\n\n56 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\nFigura 8 \u2013 Diagrama de colabora\u00e7\u00e3o.\n\nportanto, apenas falta o desenvolvimento do projeto de software para finalizar o sistema\n[3]. Pode-se dividir o desenvolvimento do projeto em duas partes:\n\na) o projeto l\u00f3gico, evolu\u00e7\u00e3o do modelo conceitual e diagramas de sequ\u00eancia resul-\ntando nos diagramas de classes e colabora\u00e7\u00e3o, representando a intera\u00e7\u00e3o entre\nos objetos quando opera\u00e7\u00f5es e consultas de sistemas s\u00e3o executadas;\n\nb) o projeto tecnol\u00f3gico, que representa a solu\u00e7\u00e3o inerente a tecnologia, como por\nexemplo: interface a ser desenvolvida, como ser\u00e1 feito o armazenamento dos\ndados internos, a comunica\u00e7\u00e3o entre os diversos atores e etc.\n\nDessa maneira, s\u00e3o definidas duas atividades, o diagrama de colabora\u00e7\u00e3o e o\ndiagrama de classes. O diagrama de colabora\u00e7\u00e3o permite a cria\u00e7\u00e3o de intera\u00e7\u00f5es entre\nclasses de objetos, mostrando como as p\u00f3s condi\u00e7\u00f5es dos contratos ser\u00e3o realizadas,\nexpressando detalhadamente a comunica\u00e7\u00e3o entre os objetos. As mensagens enviadas\ndefinem os m\u00e9todos que ser\u00e3o implementados nas classes do projeto, podendo ser b\u00e1-\nsicas ou delegadas. As b\u00e1sicas acontecem quando o objeto que recebeu a mensagem\nsimplesmente executam a opera\u00e7\u00e3o enviada, j\u00e1 as delegadas s\u00e3o mensagens que s\u00e3o\npassadas adiante para o pr\u00f3ximo objeto, de forma que o acoplamento entre os objetos\nn\u00e3o aumente a complexidade das classes envolvidas. Portanto, com o diagrama de\ncolabora\u00e7\u00e3o pode-se determinar as intera\u00e7\u00f5es entre as inst\u00e2ncias de objetos, que se\ncomunicam via mensagens, como observado na Figura 8.\n\nDepois de criado os diagramas de colabora\u00e7\u00e3o \u00e9 poss\u00edvel criar o diagrama de\nclasses que descreve os objetos do sistema e os relacionamentos que os diferentes\nobjetos apresentam entre si, com seus respectivos m\u00e9todos a serem inseridos entre as\nassocia\u00e7\u00f5es. Primeiramente, o diagrama de classes \u00e9 uma c\u00f3pia do de colabora\u00e7\u00e3o,\npara depois desenvolver mais profundamente os atributos e m\u00e9todos das associa\u00e7\u00f5es,\nal\u00e9m das opera\u00e7\u00f5es atribu\u00eddas a cada classe. Tamb\u00e9m s\u00e3o criados atributos particula-\nres de cada classe, que n\u00e3o s\u00e3o \u201cenxergadas\u201d por classes diferentes, representando a\n\n\n\n3.2. Etapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o 57\n\nFigura 9 \u2013 Diagrama de classes.\n\ndin\u00e2mica interna do objeto. As modifica\u00e7\u00f5es b\u00e1sicas que devem ser feitas no diagrama\nconceitual para a cria\u00e7\u00e3o do diagrama de classes s\u00e3o, basicamente [27]:\n\na) adi\u00e7\u00e3o dos m\u00e9todos;\n\nb) poss\u00edvel detalhamento dos atributos e associa\u00e7\u00f5es.;\n\nc) poss\u00edvel altera\u00e7\u00e3o na estrutura das classes e associa\u00e7\u00f5es.;\n\nd) poss\u00edvel cria\u00e7\u00e3o de atributos privados ou protegidos;\n\ne) adi\u00e7\u00e3o da dire\u00e7\u00e3o das associa\u00e7\u00f5es..\n\nPortanto, o diagrama de classes apresenta mais informa\u00e7\u00f5es com rela\u00e7\u00e3o ao mo-\ndelo conceitual, acrescentando mais m\u00e9todos e associa\u00e7\u00f5es ao diagrama, aumentando\na complexidade utilizando o conceito de heran\u00e7a. A heran\u00e7a consiste numa t\u00e9cnica que\npossibilita que classes com atributos e m\u00e9todos semelhantes possam ser agrupadas\nnuma \u00fanica classe que ter\u00e1 essas caracter\u00edsticas inerentes [30]. Portanto, a heran\u00e7a\npermite que sistemas altamente complexos sejam simplificados com reaproveitamento\nde c\u00f3digo, generalizando associa\u00e7\u00f5es entre classes [3].\n\nComo pode ser observado na Figura 9, o diagrama de classes possui elementos\nb\u00e1sicos para sua representa\u00e7\u00e3o UML:\n\n\u2022 Atributos, que determinam as caracter\u00edsticas b\u00e1sicas do objeto. Essas caracter\u00eds-\nticas podem incluir, por exemplo, nome da classe, tipo de dado do atributo, valores\niniciais;\n\n\u2022 M\u00e9todos, definem as fun\u00e7\u00f5es que os objetos, que podem ter nomes e receber\npar\u00e2metros para execu\u00e7\u00e3o da fun\u00e7\u00e3o;\n\n\u2022 Associa\u00e7\u00f5es, exprimem a rela\u00e7\u00e3o entre cada classe descrita no diagrama, com\nintuito de associar e criar uma rede de comunica\u00e7\u00e3o entre classes.\n\nQuando terminados os detalhamentos do diagrama conceitual que resultam no\ndiagrama de classes do projeto, termina-se o desenvolvimento do projeto l\u00f3gico, o que\n\n\n\n58 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\nFigura 10 \u2013 Diagrama de estados.\n\nsignifica que existem informa\u00e7\u00f5es suficiente para implementar as classes e representar\ntoda a l\u00f3gica de transforma\u00e7\u00e3o e apresenta\u00e7\u00e3o dos dados do sistema. Por\u00e9m, ainda\npode-se utilizar mais um diagrama comum ao UML para facilitar a compreens\u00e3o do ciclo\nde vida do sistema e os caminhos percorridos por ele, chamado de diagrama de estados,\nque permite faz\u00ea-lo em paralelo a cria\u00e7\u00e3o de c\u00f3digos e l\u00f3gicas de programa\u00e7\u00e3o.\n\n3.2.6 Diagrama de Estados\n\nA \u00faltima etapa da metodologia consiste na cria\u00e7\u00e3o do diagrama de estados,\nque modela todos os estados em que o sistema percorre durante seu ciclo de vida,\nsendo uma descri\u00e7\u00e3o abstrata do comportamento do sistema com clareza e de forma\nsimplificada. Nessa etapa o c\u00f3digo propriamente dito \u00e9 implementado, com a cria\u00e7\u00e3o\ndos c\u00f3digos de cada classe correspondentes \u00e0 camada de dom\u00ednio da aplica\u00e7\u00e3o [3],\nou seja, \u00e9 implementada toda a l\u00f3gica interna que foi definida anteriormente para cada\nclasse. Tamb\u00e9m \u00e9 feita a associa\u00e7\u00e3o entre a camada de dom\u00ednio e a de persist\u00eancia,\nde modo que os dados preservados possam ser recuperados pelo usu\u00e1rio.\n\nOs diagramas de estados mostram o ciclo de vida de um dado objeto, os eventos\nque ele experiencia, as suas transi\u00e7\u00f5es e os estados que o objeto se encontra durante\nas transi\u00e7\u00f5es. Se um evento \u00e9 acionado que n\u00e3o est\u00e1 representado no diagrama de\nestado, este evento \u00e9 ignorado completamente ou analisado para tratamento durante o\ndesenvolvimento. Portanto, os elementos b\u00e1sicos do diagrama de estados s\u00e3o:\n\n\u2022 Estados, que representam a situa\u00e7\u00e3o ou condi\u00e7\u00e3o que o objeto se encontra em\ndeterminado instante, dependendo diretamente dos pr\u00f3ximos elementos. Todo\nobjeto possui um estado inicial, que pode ou n\u00e3o ser retornado futuramente;\n\n\u2022 Eventos, que definem situa\u00e7\u00f5es dos quais ocorrem uma transi\u00e7\u00e3o, podendo mudar\nou n\u00e3o o estado do objeto;\n\n\u2022 Transi\u00e7\u00f5es, que s\u00e3o definidos por setas no diagrama UML, demonstrando a\nrela\u00e7\u00e3o entre dois estados diferentes, modificando o estado de um objeto para\noutro quando um evento espec\u00edfico \u00e9 acionado.\n\n\n\n3.3. Camada de Persist\u00eancia 59\n\n3.3 Camada de Persist\u00eancia\n\n\u00c9 muito importante para o usu\u00e1rio a preserva\u00e7\u00e3o dos dados ap\u00f3s uma simula\u00e7\u00e3o\nevitando retrabalho e facilitando o uso da interface gr\u00e1fica. Dessa forma, utiliza-se o\nconceito de persist\u00eancia para o armazenamento eficaz [31] e autom\u00e1tico dos dados em\nm\u00eddias n\u00e3o-vol\u00e1teis, como HD do computador [3], permitindo recupera\u00e7\u00e3o dos dados\nat\u00e9 mesmo quando o sistema est\u00e1 inativo ou quando \u00e9 reiniciado.\n\nOs tipos de vari\u00e1veis armazenadas internamente s\u00e3o todas aquelas que s\u00e3o\nsuficientes para recriar a simula\u00e7\u00e3o exatamente igual \u00e0 realizada inicialmente, ou\nseja, s\u00e3o armazenados apenas os dados necess\u00e1rios para o usu\u00e1rio ter condi\u00e7\u00f5es de\nsimular um projeto novamente, para evitar que sejam armazenadas muitas informa\u00e7\u00f5es\nirrelevantes.\n\nA camada de persist\u00eancia foi implementada utilizando o formato XML (Exten-\nsible Markup Language) para salvar os dados, que \u00e9 uma linguagem de marca\u00e7\u00e3o\nque descreve uma classe de objetos chamada de documentos XML, descrevendo\nparcialmente o comportamento de programas que os processam [32], definindo um\nconjunto de regras das quais esses documentos devem seguir de forma que evidencie\no que est\u00e1 documentado tanto para o humano quanto para a m\u00e1quina. Ela foi criada\npela W3C, uma das principais organiza\u00e7\u00f5es de padroniza\u00e7\u00f5es da World Wide Web,\nque mantem todas suas especifica\u00e7\u00f5es open source, permitindo o car\u00e1ter aberto e a\nfacilidade do desenvolvimento de uma interface sem a necessidade de obten\u00e7\u00e3o de\nlicen\u00e7as.\n\n3.3.1 Extensible Markup Language (XML)\n\nPara interpretar os documentos XML geralmente s\u00e3o utilizados pacotes de\nsoftwares espec\u00edficos, tamb\u00e9m conhecidos como XML parsers ou processador XML.\nOs elementos b\u00e1sicos de um documento XML, mostrados na Figura 11, s\u00e3o [33]:\n\n\u2022 Declara\u00e7\u00e3o: Sempre aparecendo na primeira linha com os caracteres&lt;?, in-\ndica a vers\u00e3o do XML sendo utilizado, al\u00e9m de algumas informa\u00e7\u00f5es acerca da\ndocumenta\u00e7\u00e3o do c\u00f3digo;\n\n\u2022 Elementos: Os elementos representam alguma informa\u00e7\u00e3o, sempre iniciando\ncom&lt;> e finalizando com&lt;/>, possuindo uma tag espec\u00edfica (representada na\nfigura por \u2019Elemento\u2019). Percebe-se que um elemento pode ter no seu corpo outros\nelementos declarados com as suas pr\u00f3prias tags.\n\n\u2022 Atributo: Conferem caracter\u00edsticas aos elementos, assumindo valores ou strings,\npor exemplo. Um elemento pode ter quantos atributos forem necess\u00e1rios.\n\n\n\n60 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\nDessa forma, s\u00e3o utilizadas tags para determinar os tipos de objetos armazena-\ndos, criando elementos de diferentes tipos e combina\u00e7\u00f5es. A estrutura hier\u00e1rquica do\nXML \u00e9 perfeita para a representa\u00e7\u00e3o do conceito de programa\u00e7\u00e3o orientada a objeto,\npermitindo a cria\u00e7\u00e3o de classes complexas, com atributos espec\u00edficos e implementando\numa camada de persist\u00eancia simples e objetiva.\n\nMas tamb\u00e9m existem outras vantagens ao se utilizar o XML como linguagem de\nmarca\u00e7\u00e3o. Devido a sintaxe simples utilizada, o XML \u00e9 uma linguagem de f\u00e1cil leitura\npara humanos e m\u00e1quinas, permitindo uma compreens\u00e3o maior para os desenvolve-\ndores e analistas, facilitando a an\u00e1lise do que est\u00e1 sendo armazenado e permitindo\nque altera\u00e7\u00f5es sejam feitas de forma simplificada. Tamb\u00e9m \u00e9 considerada uma lingua-\ngem multi-plataforma, sendo interpretada em m\u00e1quinas com diferentes plataformas\ninstaladas permitindo a cambiabilidade da informa\u00e7\u00e3o.\n\nOutra caracter\u00edstica importante do XML \u00e9 a valida\u00e7\u00e3o de documentos. Sempre\nque documentos XML s\u00e3o constru\u00eddos e interpretados pelo parser \u00e9 poss\u00edvel especificar\na priori como estes documentos devem ser formatados. Portanto, todo documento XML\ns\u00f3 ser\u00e1 utilizado se ele estiver conforme um formato padr\u00e3o criado anteriormente,\nevitando com isso erros com arquivos corrompidos ou que perderam informa\u00e7\u00f5es. Essa\npadroniza\u00e7\u00e3o \u00e9 realizada num documento onde todos os tipos de elementos, seus\natributos, a ordem de apari\u00e7\u00e3o de cada elemento e outras informa\u00e7\u00f5es relevantes s\u00e3o\ndefinidas, sendo chamadas de XML schema.\n\n3.3.2 XML Schema\n\nQuando se fala em tipagem de documentos pode-se fazer uma analogia com\nos tipos de linguagem de programa\u00e7\u00e3o. Geralmente, linguagens de programa\u00e7\u00e3o s\u00e3o\nutilizadas para descrever estruturas que podem ser compostas de formas particulares\ne tipagem de documentos tamb\u00e9m podem ser vistos dessa forma. Os componentes\nprimitivos e os tipos de composi\u00e7\u00f5es poss\u00edveis de cada caso que s\u00e3o diferentes,\npor\u00e9m conceitualmente s\u00e3o semelhantes. Uma tipagem de documento \u00e9, geralmente,\nconhecida como um schema.\n\nOs schemas s\u00e3o particularmente valioso por diversas raz\u00f5es, mas principal-\n\nFigura 11 \u2013 Esquema b\u00e1sico do XML.\n\n\n\n3.4. Linguagem de Programa\u00e7\u00e3o - Python 61\n\nFigura 12 \u2013 Exemplo de um documento schema.\n\nmente por duas: eles requerem um pensamento cr\u00edtico quanto ao design da aplica\u00e7\u00e3o e\ndos dados descritos e s\u00e3o muito usados para ajudar a especificar como certos documen-\ntos devem ser constru\u00eddos e interpretados. Dessa forma, s\u00e3o muito importantes para a\ndefini\u00e7\u00e3o da estrutura que os documentos XML, por exemplo, ir\u00e3o apresentar [33].\n\nExistem diversas linguagens para a defini\u00e7\u00e3o dos schema, sendo a mais en-\ncontrada a DTD (Document Type Definition), que foi a utilizada no projeto. O DTD foi\nescolhido j\u00e1 que permite uma grande exatid\u00e3o e flexibilidade na defini\u00e7\u00e3o das estruturas\ne dos elementos do documento XML. Na Figura 12 pode ser observado um exemplo\nde um schema criado para representar a estrutura de um documento XML, composto\npor um elemento chamado Processo, que nele s\u00e3o atribu\u00eddos diversos elementos\nnuma sequ\u00eancia. Pode-se observar que existem diferentes tipos de elementos, os\ncomplexos, que s\u00e3o compostos por outros elementos, e os simples, que s\u00e3o definidos\ncomo n\u00fameros, textos e etc. A sintaxe utilizado \u00e9 bastante similar da utilizada para\ndefini\u00e7\u00e3o dos documentos XML, mostrando a facilidade de se estruturar utilizando o\nDTD.\n\n3.4 Linguagem de Programa\u00e7\u00e3o - Python\n\nCriado no fim dos anos 80, o Python surgiu numa \u00e9poca em que o desenvolvi-\nmento tecnol\u00f3gico computacional estava em crescimento exponencial, impulsionados\n\n\n\n62 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\npor empresas que estavam em crescente avan\u00e7o no mundo, como Microsoft e Apple.\nInspirado pela tradi\u00e7\u00e3o de se nomear uma linguagem de programa\u00e7\u00e3o homenageando\numa pessoa famosa, Guido Van Rossum criou o Python inspirado na s\u00e9rie brit\u00e2nica\nMonty Python\u2019s Flying Circus em 1989 [34].\n\nO Python \u00e9 uma linguagem de programa\u00e7\u00e3o de larga escala e evoluiu das ra\u00edzes\ndo mundo dos scripts, desenvolvendo-se de forma org\u00e2nica pela vis\u00e3o e lideran\u00e7a do\nseu criador. Como a maioria das linguagens de script, o Python caracteriza-se pela\nexcelente capacidade de manipula\u00e7\u00e3o de textos e arquivos. Por\u00e9m, diferentemente da\nmaioria das linguagens de script, o Python apresenta um ambiente de orienta\u00e7\u00e3o a ob-\njetos poderoso com uma API (Application Program Interface) robusta para programa\u00e7\u00e3o\nde redes, threads e desenvolvimento de interfaces de usu\u00e1rio gr\u00e1ficas [33].\n\nConsidera-se que o Python trouxe para o \u2019mundo dos scripts\u2019 a robustez e a\nsanidade, da mesma forma que o Java trouxe para o mundo do C++. Mas, assim como\nao utilizar o Java no lugar do C++, houve uma simplifica\u00e7\u00e3o da linguagem com forte\nsuporte em orienta\u00e7\u00e3o a objetos. Mudando para uma linguagem mais simples removeu-\nse os detalhes de baixo n\u00edvel em gest\u00e3o de mem\u00f3ria e hardware em linguagens como\nC++, por\u00e9m ganhou-se em robustez e facilidade em encontrar erros nos c\u00f3digos.\nComo esperado, a flexibilidade teve um custo, j\u00e1 que o Python pode resultar em piores\nperformances que outras linguagens como C e C++.\n\nMas o Python apresenta algumas caracter\u00edsticas que o tornam atraente com\nrela\u00e7\u00e3o a outras linguagem de programa\u00e7\u00e3o [33]:\n\n\u2022 A leitura e manuten\u00e7\u00e3o do c\u00f3digo-fonte do Python \u00e9 simples e f\u00e1cil;\n\n\u2022 O interpretador interativo simplifica o uso de c\u00f3digo fragmentados;\n\n\u2022 O Python possui uma portabilidade excelente, mas tamb\u00e9m n\u00e3o restringe o\nacesso \u00e0s capacidades de outra plataformas espec\u00edficas;\n\n\u2022 As caracter\u00edsticas de orienta\u00e7\u00e3o a objetos s\u00e3o poderosas e acess\u00edveis.\n\nDessa forma, foi escolhido o Python para cria\u00e7\u00e3o da interface desenvolvida no\nprojeto. Para melhorar a legibilidade e documenta\u00e7\u00e3o do c\u00f3digo criado foi utilizado o\nDoxygen, uma ferramenta (Figura 13) para gera\u00e7\u00e3o de documenta\u00e7\u00e3o de c\u00f3digos, que\nsuporta as linguagens de programa\u00e7\u00e3o mais comuns. O Doxygen pode ser \u00fatil de tr\u00eas\nforma distintas [35]:\n\n1. Pode gerar uma documenta\u00e7\u00e3o online, criando um browser via HTML e/ou um\nmanual de refer\u00eancia offline (em Latex ) a partir de um arquivo fonte documentado.\nA documenta\u00e7\u00e3o \u00e9 extra\u00edda diretamente das fontes, o que permite manter mais\nfacilmente uma documenta\u00e7\u00e3o consistente com o c\u00f3digo fonte;\n\n\n\n3.4. Linguagem de Programa\u00e7\u00e3o - Python 63\n\nFigura 13 \u2013 Software Doxygen.\n\n2. \u00c9 poss\u00edvel configurar o Doxygen para extrair a estrutura do c\u00f3digo de arquivos\nfonte n\u00e3o documentados. Essa fun\u00e7\u00e3o \u00e9 muito \u00fatil para se encontrar rapidamente\nquando s\u00e3o utilizados fontes muito grandes;\n\n3. O Doxygen tamb\u00e9m permite visualizar a rela\u00e7\u00e3o entre os v\u00e1rios elementos a partir\nde gr\u00e1ficos de depend\u00eancia, diagramas de heran\u00e7a e diagramas de colabora\u00e7\u00e3o,\ntodos gerados automaticamente, facilitando a leitura da documenta\u00e7\u00e3o do c\u00f3digo\ne o seu entendimento.\n\nConsidera\u00e7\u00f5es Finais\n\nNeste cap\u00edtulo foi apresentada a metodologia utilizada para o desenvolvimento\ndo projeto da interface gr\u00e1fica. Durante sua implementa\u00e7\u00e3o, o projeto foi alterado\ndiversas vezes e sempre que poss\u00edvel tentou-se manter as caracter\u00edsticas descritas\n\n\n\n64 Cap\u00edtulo 3. Metodologia de Desenvolvimento de Software\n\ndurante as etapas da metodologia, procurando manter a coer\u00eancia no design do\nsoftware. Al\u00e9m disso, foi descrito brevemente a linguagem de programa\u00e7\u00e3o utilizada\npara desenvolver a interface, assim como as ferramentas que foram necess\u00e1rias\npara sua elabora\u00e7\u00e3o, tentando destacar o porque da sua escolha mostrando as suas\nqualidades.\n\n\n\n65\n\n4 Requisitos da interface e Projeto de\nsoftware\n\nNo cap\u00edtulo anterior foi detalhado o Processo Unificado, metodologia utilizada\npara desenvolver o projeto. Assim, seguindo os passos descritos pela UP, o projeto \u00e9\niniciado pela fase de concep\u00e7\u00e3o, do qual \u00e9 criado um documento com uma vis\u00e3o geral\ndo que deve ser desenvolvido, procurando definir suas fun\u00e7\u00f5es e comportamentos\nb\u00e1sicos. Esse documento, chamado de Sum\u00e1rio Executivo, originou-se ap\u00f3s a an\u00e1lise\njunto ao orientador da empresa do que deveria ser o projeto, visto que o sum\u00e1rio\nexecutivo visa justamente dar ao analista uma no\u00e7\u00e3o do projeto e as suas restri\u00e7\u00f5es\nmais b\u00e1sicas. O resultado \u00e9 mostrado na Tabela 1:\n\nTabela 1 \u2013 Sum\u00e1rio executivo gerado na fase de concep\u00e7\u00e3o da UP\n\nSum\u00e1rio Executivo\nCriar um software com uma interface gr\u00e1fica que visa simular o controle de processos\nindustriais utilizando modelos matem\u00e1ticos de plantas reais da ind\u00fastria petroqu\u00edmica.\nN\u00e3o ser\u00e1 fun\u00e7\u00e3o do sistema identificar modelos, estes j\u00e1 estar\u00e3o definidos pelo\nusu\u00e1rio e/ou estar\u00e3o armazenados num banco de dados do sistema, gerando uma\nbiblioteca, tamb\u00e9m fornecendo um modelo inicial capaz de realizar as simula\u00e7\u00f5es\nnecess\u00e1rias.\nDever\u00e1 ser capaz de simular modelos lineares e n\u00e3o-lineares assim como simular\ndiversos modelos simultaneamente, al\u00e9m de sistemas monovari\u00e1veis e multivari\u00e1veis.\nOs sistemas ser\u00e3o discretos e portanto um per\u00edodo de amostragem dever\u00e1 ser\ndefinido corretamente pelo usu\u00e1rio.\nA simula\u00e7\u00e3o em si do controle deve prover diversos tipos de controladores, tendo\nfoco em controladores preditivos. O sistema deve ser capaz de avaliar a robustez\ndos controladores para diferentes fatores que gerem erros e avaliar o \u00edndice de\ndesempenho. Al\u00e9m disso os cen\u00e1rios de simula\u00e7\u00e3o ser\u00e3o definidas pelo usu\u00e1rio,\npodendo este definir, por exemplo, diferentes tipos de entrada, como refer\u00eancia ou\nperturba\u00e7\u00f5es e entre outras condi\u00e7\u00f5es. Tamb\u00e9m poder\u00e1 ser feita simula\u00e7\u00e3o em\nmalha aberta para se analisar os modelos.\nO simulador dever\u00e1 ser capaz de prover uma janela de visualiza\u00e7\u00e3o de dados da\nsimula\u00e7\u00e3o para o usu\u00e1rio analisar o resultado obtido de forma objetiva. Al\u00e9m disso,\na interface dever\u00e1 apresentar uma ferramenta com diversos modelos j\u00e1 estudados\nna ind\u00fastria armazenados num banco de dados.\nA interface gr\u00e1fica ser\u00e1 implementada na linguagem de programa\u00e7\u00e3o Python pela\nfacilidade e o alto n\u00edvel de abstra\u00e7\u00e3o em conjunto com um software de desenvol-\nvimento de interfaces do pr\u00f3prio Python, o Qt Designer. Dever\u00e1 prover uma forma\nsimples e clara para o usu\u00e1rio ter facilidade ao utilizar o sistema e um algoritmo de\nsimula\u00e7\u00e3o eficiente.\n\n\n\n66 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\n4.1 Requisitos da Interface\n\nUma vez que o sum\u00e1rio executivo \u00e9 finalizado, \u00e9 criada uma lista completa com\nos requisitos funcionais do projeto, definindo as fun\u00e7\u00f5es b\u00e1sicas do software ou parte\ndele, al\u00e9m dos requisitos n\u00e3o-funcionais, que est\u00e3o relacionados com desempenho,\nusabilidade, disponibilidade e com as tecnologias envolvidas do sistema, agrupando os\ndois tipos de requisitos numa tabela similar \u00e0 Tabela 2. Nela \u00e9 observado a constru\u00e7\u00e3o\ndo requisito Armazenar Modelos da Biblioteca, que foi dada a c\u00f3digo (F12), detalhando\ntamb\u00e9m os requisitos n\u00e3o-funcionais e as restri\u00e7\u00f5es impostas. As funcionalidades do\nsistema foram divididas em tr\u00eas grupos: (i) Interface Gr\u00e1fica (ii) Algoritmo da Simula\u00e7\u00e3o\n(iii) Armazenamento de dados.\n\nTabela 2 \u2013 Descri\u00e7\u00e3o do requisito Armazenar Modelas da Biblioteca\n\nF12 \u2013 Armazenar Modelos da Biblioteca\nDescri\u00e7\u00e3o \u2013 o sistema deve ser capaz de armazenar todos os modelos dos proces-\nsos desejados numa biblioteca, de forma que seja poss\u00edvel que o usu\u00e1rio utilize os\nmodelos na interface posteriormente para simula\u00e7\u00f5es.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 usu\u00e1rio n\u00e3o pode alterar os modelos armazenados dentro da biblioteca.\nNF1.2 \u2013 armazenamento deve ser implementado utilizando XML pela facilidade de\nintera\u00e7\u00e3o com Python.\nNF1.3 \u2013 n\u00e3o armazenar todos par\u00e2metros, apenas os suficientes para que a si-\nmula\u00e7\u00e3o possa ser realizada. Os \u00fanicos par\u00e2metros armazenados s\u00e3o: Nome do\nprojeto, n\u00famero de vari\u00e1veis de processo, per\u00eddo de amostragem, lista dos modelos,\ncontroladores e cen\u00e1rios contendo as informa\u00e7\u00f5es b\u00e1sicas de cada um.\n\nPara cada grupo encontrado foram definidas diferentes funcionalidades, descri-\ntas a seguir, que s\u00e3o mostradas mais detalhadamente no Ap\u00eandice A:\n\n(i) Interface Gr\u00e1fica\n\n(F1) Defini\u00e7\u00e3o dos Par\u00e2metros do Projeto\n\n(F2) Defini\u00e7\u00e3o dos Modelos\n\n(F3) Defini\u00e7\u00e3o dos Controladores\n\n(F4) Configura\u00e7\u00e3o do Cen\u00e1rio de Simula\u00e7\u00e3o\n\n(F5) Visualiza\u00e7\u00e3o dos Gr\u00e1ficos de Simula\u00e7\u00e3o\n\n(ii) Algoritmo da Simula\u00e7\u00e3o\n\n(F6) Calcular A\u00e7\u00e3o de Controle\n\n(F7) Calcular \u00cdndices de Desempenho\n\n\n\n4.2. Levantamento dos Casos de Uso 67\n\n(F8) Implementa\u00e7\u00e3o da Simula\u00e7\u00e3o\n\n(F9) Gerenciamento do Banco de Dados\n\n(F10) Gerenciar Dados do Processo\n\n(F11) Atualizar Dados do Processo\n\n(iii) Armazenamento de dados\n\n(F12) Armazenar Modelos da Biblioteca\n\n(F13) Salvar Dados da Simula\u00e7\u00e3o\n\n(F14) Abrir Dados de Simula\u00e7\u00f5es Armazenadas\n\n4.2 Levantamento dos Casos de Uso\n\nCom os requisitos devidamente coletados, pode-se levantar o diagrama de\ncasos de uso do sistema. Como j\u00e1 citado anteriormente, o diagrama visa auxiliar a\ncomunica\u00e7\u00e3o entre os analistas e o usu\u00e1rio, descrevendo a sequ\u00eancia l\u00f3gica de como o\nsistema deve ser utilizado, de forma que fique evidente as funcionalidades do software\nem quest\u00e3o.\n\nComo observado na Figura 14, foram encontrados os Casos de Uso, que\nrepresentam os principais neg\u00f3cios realizados pelo sistema. Os Casos de Uso s\u00e3o:\nConfigurar Projeto, Configurar Modelo, Configurar Controlador, Configurar Cen\u00e1rios de\nSimula\u00e7\u00e3o, Calcular Lei de Controle e Gerar Gr\u00e1ficos. Pode-se interpretar o diagrama\ncomo:\n\n\u2022 O usu\u00e1rio inicialmente configura o projeto, definindo os par\u00e2metros b\u00e1sicos da\nsimula\u00e7\u00e3o;\n\n\u2022 Posteriormente ele configura os modelos a serem utilizados na interface;\n\n\u2022 Ent\u00e3o o usu\u00e1rio configura os controladores, seus par\u00e2metros e vari\u00e1veis deseja-\ndas.\n\n\u2022 Por fim o usu\u00e1rio define o cen\u00e1rio da simula\u00e7\u00e3o, as refer\u00eancias, tempo de simula-\n\u00e7\u00e3o e outros par\u00e2metros, realizando a simula\u00e7\u00e3o.\n\n\u2022 O processo executa, analisa as configura\u00e7\u00f5es e calcula uma lei de controle\nadequada para o cen\u00e1rio escolhido pelo usu\u00e1rio.\n\n\u2022 Ent\u00e3o o processo gera os gr\u00e1ficos da simula\u00e7\u00e3o realizada conforme solicitado\npelo usu\u00e1rio.\n\n\n\n68 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\nFigura 14 \u2013 Diagrama de caso de uso gerado para o sistema.\n\nObserva-se que de maneira sucinta e simplificada pode-se descrever todo o\nprocesso de simula\u00e7\u00e3o, as funcionalidades do sistema e o seu comportamento perante\nas a\u00e7\u00f5es do usu\u00e1rio e assim, o analista apresenta uma no\u00e7\u00e3o b\u00e1sica de como deve\nser implementado a interface. Com a cria\u00e7\u00e3o dos Casos de Uso, a fase de Concep\u00e7\u00e3o\n\u00e9 finalizada, seguindo para a fase de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o.\n\n4.3 Expans\u00e3o dos Casos de Uso\n\nCom o fim da fase de concep\u00e7\u00e3o do projeto, os requisitos foram levantados\nassim como os casos de uso do sistema definidos. Portanto, pode-se come\u00e7ar a fase\nde elabora\u00e7\u00e3o e constru\u00e7\u00e3o da UP, onde se executa uma investiga\u00e7\u00e3o mais detalhada\nda fase anterior.\n\nEssa etapa \u00e9 iniciado com a Expans\u00e3o dos Casos de Uso, que tem como\nfinalidade o aprofundamento da an\u00e1lise dos requisitos levantando anteriormente, es-\npecificando os casos de uso detalhadamente, seus fluxos principais e alternativos,\ndescrevendo como o sistema se comporta naturalmente e quais caminhos ele pode\ntomar dependendo das a\u00e7\u00f5es do usu\u00e1rio. Por fim, mostra-se as exce\u00e7\u00f5es, que defi-\nnem a\u00e7\u00f5es do usu\u00e1rio que criam caminhos n\u00e3o convencionais no fluxo principal ou\nalternativo.\n\nNa Tabela 3 \u00e9 apresentada a expans\u00e3o do caso de uso Configurar Controle,\n\n\n\n4.4. Modelo conceitual 69\n\nTabela 3 \u2013 Expans\u00e3o do caso de uso Configurar Controle\n\nFluxo Principal\n\n1. O usu\u00e1rio cria um controlador\ndo tipo MPC, escolhendo o tipo\ndo controlador preditivo (GPC,\nPNMPC ou DMC).\n\n2. O usu\u00e1rio define os par\u00e2metros\ndo controlador criado anterior-\nmente.\n\n3. As restri\u00e7\u00f5es do controlador s\u00e3o\ndefinidas pelo usu\u00e1rio, caso ne-\ncess\u00e1rio.\n\n4. O modelo de predi\u00e7\u00e3o que o MPC\nir\u00e1 se basear para os c\u00e1lculos\nda lei de controle \u00e9 definido pelo\nusu\u00e1rio.\n\nFluxos Alternativos\n\n1a. Se o modelo \u00e9 do tipo fun\u00e7\u00e3o\ntransfer\u00eancia, o algoritmo de con-\ntrole \u00e9 o GPC.\n\n1b. Se o modelo \u00e9 do tipo equa\u00e7\u00e3o\nde diferen\u00e7a, ent\u00e3o o algoritmo de\ncontrole \u00e9 o PNMPC.\n\n1c. Se o modelo \u00e9 do tipo resposta\nao degrau, ent\u00e3o o algoritmo de\ncontrole \u00e9 o DMC.\n\n2a. Usu\u00e1rio pode copiar um controla-\ndor existente, criando uma r\u00e9plica\ndo controlador escolhido.\n\nExce\u00e7\u00f5es\n\n1a. Dois controladores n\u00e3o podem ter\no mesmo nome, gerar janela de\nerro se o usu\u00e1rio criar.\n\n1b. O usu\u00e1rio n\u00e3o pode dar nomes\nvazios para os controladores.\n\n2a. Controlador copiado n\u00e3o pode ter\nmesmo nome que outro controla-\ndor j\u00e1 existente.\n\ndescrevendo com mais detalhes o fluxo principal, os alternativos e tamb\u00e9m as exce\u00e7\u00f5es.\nO fluxo principal indica a\u00e7\u00f5es que s\u00e3o tomadas durante o funcionamento padr\u00e3o do\nsistema, modelando o seu comportamento mais comum. O fluxo alternativo indica\nsitua\u00e7\u00f5es menos convencionais, mas que n\u00e3o necessariamente indicam mau funciona-\nmento do sistema. Por fim, as exce\u00e7\u00f5es indicam a\u00e7\u00f5es que resultam no travamento do\nsistema, podendo causar problemas ao funcionamento dele caso n\u00e3o sejam tratadas\ndevidamente.\n\n4.4 Modelo conceitual\n\nNessa etapa \u00e9 criada uma representa\u00e7\u00e3o l\u00f3gica do sistema, de alto n\u00edvel,\nabstendo-se de qualquer an\u00e1lise do software que ser\u00e1 utilizada para implementa\u00e7\u00e3o.\n\n\n\n70 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\nFigura 15 \u2013 Modelo conceitual do projeto.\n\nPortanto, s\u00e3o criados conceitos para refletir os casos de uso expandidos anteriormente\nsem fazer refer\u00eancias \u00e0s opera\u00e7\u00f5es ou outros aspectos din\u00e2micos do sistema projetado\n[27]\n\nO Diagrama Conceitual proposto pode ser observado na Figura 15, definindo os\nconceitos como:\n\n\u2022 Sistema: Representa\u00e7\u00e3o do software na sua totalidade, n\u00e3o um conceito propria-\nmente dito;\n\n\u2022 Projeto: Conceito utilizado que ir\u00e1 armazenar as principais informa\u00e7\u00f5es do projeto,\ncomo por exemplo uma lista contendo todos os modelos do sistema. Seus atri-\nbutos s\u00e3o nome, tipo (Discreto), quantidade de sa\u00eddas, entradas e perturba\u00e7\u00f5es,\nlista dos modelos, controladores e cen\u00e1rios, lista das vari\u00e1veis do processo e p\u00f4r\nfim a amostragem;\n\n\u2022 Modelo: O modelo \u00e9 uma representa\u00e7\u00e3o matem\u00e1tica do processo. Seus atribu-\ntos s\u00e3o nome, tipo (Fun\u00e7\u00e3o Transfer\u00eancia/Equa\u00e7\u00f5es de Diferen\u00e7a/Resposta ao\nDegrau) e os pontos de opera\u00e7\u00f5es;\n\n\u2022 Controlador: Representa o algoritmo que calcula a a\u00e7\u00e3o de controle utilizando\no MPC, de forma a controlar o processo. Seus atributos s\u00e3o os horizontes, as\npondera\u00e7\u00f5es, as restri\u00e7\u00f5es e o tipo do controlador (GPC/PNMPC/DMC);\n\n\u2022 Cen\u00e1rio: Conceito que realiza toda a configura\u00e7\u00e3o do cen\u00e1rio de simula\u00e7\u00e3o,\nutilizando os modelos e controladores para criar uma simula\u00e7\u00e3o, selecionando as\n\n\n\n4.5. Contratos e Diagrama de Sequ\u00eancia 71\n\nrefer\u00eancias e perturba\u00e7\u00f5es. Seus atributos s\u00e3o nome, refer\u00eancias, perturba\u00e7\u00f5es e\no n\u00famero de itera\u00e7\u00f5es, ou seja, o tempo de simula\u00e7\u00e3o;\n\n\u2022 Simula\u00e7\u00e3o: Representa o resultado obtido ao criar e executar o cen\u00e1rio, gerando\ngr\u00e1ficos com as vari\u00e1veis manipuladas e controladas. Seus atributos s\u00e3o as\nresposta das vari\u00e1veis manipuladas e controladas, e o tipo (Malha Aberta/Malha\nFechada).\n\n4.5 Contratos e Diagrama de Sequ\u00eancia\n\nPartindo dos casos de uso encontrados anteriormente, pode-se definir as opera-\n\u00e7\u00f5es e consultas do sistema. Os contratos permitem represent\u00e1-las identificando as\npr\u00e9-condi\u00e7\u00f5es, as p\u00f3s-condi\u00e7\u00f5es e por fim as exce\u00e7\u00f5es para cada opera\u00e7\u00e3o e consulta\nrealizada. A principal import\u00e2ncia dos contratos est\u00e1 na descri\u00e7\u00e3o da responsabilidade\nde cada classe, atentando \u00e0s mudan\u00e7as do estado dos objetos quando alguma opera-\n\u00e7\u00e3o ou consulta do sistema s\u00e3o executadas, descrevendo o qu\u00ea deve ser feito, sem se\npreocupar em como deve ser feito.\n\nTabela 4 \u2013 Contrato de uma das fun\u00e7\u00f5es da Interface Gr\u00e1fica\n\nOpera\u00e7\u00e3o: Escolhe_Cenario(cenario)\nPr\u00e9-Condi\u00e7\u00e3o: Existir um objeto cen\u00e1rio v\u00e1lido com nome n\u00e3o-vazio.\nP\u00f3s-Condi\u00e7\u00e3o: O objeto cen\u00e1rio foi retornado, de forma que a interface poder\u00e1\nrealizar a simula\u00e7\u00e3o usando as informa\u00e7\u00f5es desse cen\u00e1rio, podendo tamb\u00e9m alterar\nas suas informa\u00e7\u00f5es.\n\nNa Tabela 4 aparece a descri\u00e7\u00e3o da opera\u00e7\u00e3o Escolhe_Cenario, que basica-\nmente seleciona um cen\u00e1rio de simula\u00e7\u00e3o, mostrando que para ocorrer essa opera\u00e7\u00e3o\nexiste uma pr\u00e9-condi\u00e7\u00e3o e uma p\u00f3s-condi\u00e7\u00e3o para sua execu\u00e7\u00e3o. Nesse caso, deve\nhaver algum cen\u00e1rio j\u00e1 criado pelo usu\u00e1rio com nome n\u00e3o-vazio para posteriormente\nretornar o objeto que representa o cen\u00e1rio escolhido para que o usu\u00e1rio possa alter\u00e1-lo\ntamb\u00e9m permitindo a sua simula\u00e7\u00e3o.\n\n\u00c9 muito comum utilizar os diagramas de sequ\u00eancia junto aos contratos para\nrepresentar uma sequ\u00eancia de processos realizadas pelo usu\u00e1rio, cumprindo com\nos contratos definidos para cada opera\u00e7\u00e3o para execut\u00e1-las. Seu principal objetivo \u00e9\nmostrar intera\u00e7\u00f5es entre diferentes objetos a partir de casos de uso, representando\numa linha de tempo no qual eventos podem ocorrer.\n\nO diagramas de sequ\u00eancia mostrado na Figura 16 mostra como ocorre a si-\nmula\u00e7\u00e3o de um cen\u00e1rio na interface gr\u00e1fica. O que pode ser observado no diagrama\n\u00e9:\n\n\n\n72 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\nFigura 16 \u2013 Diagrama de sequ\u00eancia representando a simula\u00e7\u00e3o de um cen\u00e1rio.\n\n1. O objeto cen\u00e1rio \u00e9 criado executando a opera\u00e7\u00e3o Criar_Cenario() e o sistema\nretorna um aviso que o cen\u00e1rio foi criado;\n\n2. O usu\u00e1rio seleciona um cen\u00e1rio para ser simulado, chamando a fun\u00e7\u00e3o Esco-\nlhe_Cenario(cenario), descrita no contrato da Tabela 4 e que recebe o cen\u00e1rio\ncriado anteriormente como par\u00e2metro de execu\u00e7\u00e3o;\n\n3. O usu\u00e1rio define o n\u00famero de itera\u00e7\u00f5es necess\u00e1rias durante a simula\u00e7\u00e3o;\n\n4. S\u00e3o escolhidas as refer\u00eancias e perturba\u00e7\u00f5es aplicadas ao processo, sendo\npermitido definir mais de uma para refer\u00eancia ou perturba\u00e7\u00e3o;\n\n5. \u00c9 definido o modelo e o controlador da simula\u00e7\u00e3o;\n\n6. Usu\u00e1rio define o tipo da simula\u00e7\u00e3o, se ser\u00e1 de malha aberta ou malha fechada;\n\n\n\n4.6. Diagrama de Colabora\u00e7\u00e3o e de Classes 73\n\n7. A simula\u00e7\u00e3o de fato \u00e9 realizada, chamando a fun\u00e7\u00e3o Simular(), retornando um\naviso de que a opera\u00e7\u00e3o foi realizada com sucesso.\n\n4.6 Diagrama de Colabora\u00e7\u00e3o e de Classes\n\nNessa etapa do projeto de software, busca-se uma solu\u00e7\u00e3o ao problema identifi-\ncado durante a etapa de elabora\u00e7\u00e3o do projeto. A parte do projeto l\u00f3gico visa ampliar o\nque foi desenvolvido no modelo conceitual, nos contratos e diagramas de sequ\u00eancia de\nforma resultando nos diagramas de colabora\u00e7\u00e3o e de classes, sempre pensando j\u00e1 na\nrealiza\u00e7\u00e3o do software propriamente dito. O projeto l\u00f3gico tenta resolver os problemas\nna camada de dom\u00ednio da aplica\u00e7\u00e3o, independente da tecnologia que desenvolver\u00e1 o\nsistema.\n\nOs diagramas de colabora\u00e7\u00e3o s\u00e3o criados a partir dos diagramas de sequ\u00eancia\ne determinam com detalhes a troca de mensagens entre inst\u00e2ncias de objetos das\ndiversas classes projetadas.\n\nFigura 17 \u2013 Diagrama de colabora\u00e7\u00e3o para a fun\u00e7\u00e3o AlterarFT.\n\nNa Figura 17 \u00e9 observado um diagrama de colabora\u00e7\u00e3o para uma fun\u00e7\u00e3o que\ntem como objetivo alterar uma Fun\u00e7\u00e3o Transfer\u00eancia de uma classe Modelo. Inicial-\nmente s\u00e3o escolhidos os pares entrada/sa\u00edda ou perturba\u00e7\u00e3o/sa\u00edda que ir\u00e3o compor\na fun\u00e7\u00e3o transfer\u00eancia a ser modificada, utilizando a fun\u00e7\u00e3o SelecionarParFT(). De-\npois, a partir da interface, \u00e9 determinada a nova fun\u00e7\u00e3o transfer\u00eancia com a fun\u00e7\u00e3o\nGerarStringFTDiscreto(). Por fim, a interface altera a fun\u00e7\u00e3o e envia uma mensa-\ngem, AlterarModeloFT(), \u00e0 classe Projeto para ela identificar se o par alterado era\nentrada/sa\u00edda ou perturba\u00e7\u00e3o/sa\u00edda, alterar a fun\u00e7\u00e3o transfer\u00eancia para esse par de\nvari\u00e1veis e armazenar a informa\u00e7\u00e3o.\n\nO diagrama de classes do projeto atualmente \u00e9 representado na Figura 18, sem\nos atributos e m\u00e9todos correspondentes para facilitar a visualiza\u00e7\u00e3o do diagrama. Como\ncitado no cap\u00edtulo anterior, o diagrama primeiramente \u00e9 uma c\u00f3pia do modelo conceitual,\npara ent\u00e3o acrescentar mais informa\u00e7\u00f5es ao modelo, adicionando m\u00e9todos, atributos\ne aumentando a complexidade da representa\u00e7\u00e3o usando o conceito de heran\u00e7a. Ela\n\n\n\n74 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\npermite representar o sistema de forma simples, sem uso excessivo de informa\u00e7\u00e3o. Por\nexemplo, a classe Modelo apresenta tr\u00eas subclasses que herdam suas caracter\u00edsticas\npois essas tr\u00eas subclasses (ModeloFT, ModeloNLinear e ModeloRespostaDegrau),\npossuem atributos e m\u00e9todos similares, como nome e tipo do modelo, n\u00famero de\nentradas e sa\u00eddas, e etc. Por\u00e9m, alguns atributos s\u00e3o \u00fanicos \u00e0 classe, como no caso\ndo ModeloFT que utiliza fun\u00e7\u00f5es transfer\u00eancias para represent\u00e1-los, o que exige a\ndiferencia\u00e7\u00e3o entre subclasses para uma implementa\u00e7\u00e3o coerente.\n\nFigura 18 \u2013 Diagrama de classes do sistema.\n\nAs principais classes do projeto s\u00e3o mostradas abaixo com uma breve descri\u00e7\u00e3o\ndos seus atributos e m\u00e9todos mais importantes.\n\nClasse Projeto\n\nA classe Projeto cont\u00e9m atributos e m\u00e9todos necess\u00e1rios para deixar a inter-\nface operacional, armazenando todas as informa\u00e7\u00f5es b\u00e1sicas referentes aos modelos,\n\n\n\n4.6. Diagrama de Colabora\u00e7\u00e3o e de Classes 75\n\ncontroladores, cen\u00e1rios e as vari\u00e1veis do projeto. Al\u00e9m disso, tem um papel de ge-\nrenciamento, permitindo altera\u00e7\u00f5es na simula\u00e7\u00e3o, no cen\u00e1rios, tamb\u00e9m com m\u00e9todos\nimportantes como SimulaCenario(), que realiza toda a simula\u00e7\u00e3o, seja ela de malha\naberta ou fechada.\n\nClasse Modelo\n\nA classe Modelo e suas subclasses tem como principal objetivo criar os modelos\ndo processo a ser simulado, utilizando duas estruturas principais: Fun\u00e7\u00f5es Transfe-\nr\u00eancias e Modelo de Resposta ao Degrau para a simula\u00e7\u00e3o de sistemas lineares e\nEqua\u00e7\u00f5es de Diferen\u00e7as para sistemas n\u00e3o-lineares. Portanto, nela s\u00e3o armazenadas\nas informa\u00e7\u00f5es relacionadas aos modelos.\n\nClasse Controlador\n\nSemelhante \u00e0 ideia utilizada na classe Modelo, a classe Controlador e as sub-\nclasses armazenam dados referentes aos controladores usados durante a simula\u00e7\u00e3o.\nOs tipos de controladores s\u00e3o: Generalized Predictive Controller (GPC) e Dynamic\nMatrix Control (DMC) para controle preditivo linear e Practical Non-Linear Predictive\nController (PNMPC) para controle preditivo n\u00e3o-linear. Ent\u00e3o, os par\u00e2metros dos con-\ntroladores, as restri\u00e7\u00f5es de controle, os modelos de predi\u00e7\u00e3o e outros dados s\u00e3o\nguardados para uso pela interface, al\u00e9m de atributos que calculam a a\u00e7\u00e3o de controle e\nrealizam os algoritmos necess\u00e1rios para o controle, seja linear ou n\u00e3o-linear. A classe\ncontrolador e a classe modelo apresentam uma associa\u00e7\u00e3o, visto que os controlado-\nres preditivos necessitam de modelos para encontrar as predi\u00e7\u00f5es e, posteriormente,\nencontrar as a\u00e7\u00f5es de controle.\n\nClasse Cen\u00e1rio\n\nNa classe Cen\u00e1rio, o sistema guarda informa\u00e7\u00f5es referentes a simula\u00e7\u00e3o, como\nas refer\u00eancias, perturba\u00e7\u00f5es, o tempo de simula\u00e7\u00e3o e tamb\u00e9m o tipo de simula\u00e7\u00e3o, que\npode ser de malha aberta ou fechada. Alguns atributos, como setControlador(), tem\ncomo fun\u00e7\u00e3o definir as caracter\u00edsticas gerais da simula\u00e7\u00e3o, como qual o modelo a ser\nsimulado, qual o controlador, os valores atuais das sa\u00eddas e entradas, etc.\n\nClasse Simulador\n\nPor fim, a classe Simulador tem como fun\u00e7\u00e3o prover os dados de necess\u00e1rios\npara a interface gerar os resultados da simula\u00e7\u00e3o, ou seja, para que os gr\u00e1ficos da\nsimula\u00e7\u00e3o sejam fornecidos ao usu\u00e1rio. Os principais atributos s\u00e3o os cen\u00e1rios, as en-\ntradas, sa\u00eddas calculadas, perturba\u00e7\u00f5es, as refer\u00eancias e os m\u00e9todos mais importantes\n\n\n\n76 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\ns\u00e3o SalvarDados() que armazena os valores de todas as vari\u00e1veis em cada instante de\ntempo e tamb\u00e9m SimulaCenario() que faz os c\u00e1lculos propriamente dito das sa\u00eddas,\ninvocando fun\u00e7\u00f5es da classe Controlador para o c\u00e1lculo das a\u00e7\u00f5es de controle.\n\n4.7 Implementa\u00e7\u00e3o\n\nCom a finaliza\u00e7\u00e3o do desenvolvimento da camada de dom\u00ednio, o projeto l\u00f3gico \u00e9\ncriado e pode-se come\u00e7ar a gera\u00e7\u00e3o de c\u00f3digos. A partir disso, s\u00e3o gerados os c\u00f3digos\ndas classes correspondentes a camada de dom\u00ednio da aplica\u00e7\u00e3o com as respectivas\nopera\u00e7\u00f5es e consultas de cada classe definida anteriormente [3].\n\nPortanto, durante a etapa atual o projeto j\u00e1 est\u00e1 sendo implementado de fato,\na gera\u00e7\u00e3o de c\u00f3digos de programa\u00e7\u00e3o foca principalmente nas classes definidas na\netapa anterior (ver Figura 18). O diagrama de estados visa representar o funcionamento\ndos objetos das classes do sistema desenvolvido no decorrer da execu\u00e7\u00e3o do software.\n\nFigura 19 \u2013 Diagrama de estados da classe Projeto.\n\nUm exemplo est\u00e1 demonstrado na Figura 19, que consiste no diagrama de esta-\ndos referente \u00e0 classe Projeto de forma simplificada, descrevendo os comportamentos\ne as poss\u00edveis situa\u00e7\u00f5es de um objeto da classe.\n\nObserva-se que, inicialmente, o usu\u00e1rio cria um novo projeto iniciando o sistema\ne escolhendo os par\u00e2metros b\u00e1sicos para que os dados sejam armazenados interna-\n\n\n\n4.7. Implementa\u00e7\u00e3o 77\n\nmente, sendo poss\u00edvel alterar o nome default definido para as vari\u00e1veis de entrada e\nsa\u00edda ap\u00f3s a inicializa\u00e7\u00e3o do projeto. O projeto tamb\u00e9m pode ser inicializado abrindo\num arquivo XML armazenado na camada de persist\u00eancia, caso existam dados armaze-\nnados. Al\u00e9m disso, o usu\u00e1rio pode guardar os dados criados, salvando-os na camada\nde persist\u00eancia, de maneira que o usu\u00e1rio consiga recuperar os dados posteriormente.\nAl\u00e9m disso, caso necess\u00e1rio, pode-se recome\u00e7ar um projeto novo que reinicializa todo\no processo descrito, mantendo a mesma l\u00f3gica.\n\n4.7.1 Qt Designer\n\nA interface foi criada utilizando a ferramenta Qt Designer e posteriormente\ntraduzida para a linguagem Python utilizando comandos pr\u00e9-determinados, devido a\ngrande compatibilidade entre o Python e o Qt. A Figura 20 mostra como o Qt Designer\nfoi utilizado para criar a interface, sendo uma ferramenta simples e de f\u00e1cil utiliza\u00e7\u00e3o.\n\nFigura 20 \u2013 Qt Designer.\n\nNa parte esquerda do Qt Designer est\u00e3o as diferentes op\u00e7\u00f5es de estrutura\nque podem ser utilizadas para o desenvolvimento da interface, que s\u00e3o elementos\nb\u00e1sicos mas de grande import\u00e2ncia, como bot\u00f5es, textos, linhas e etc. No canto\ndireito aparecem as defini\u00e7\u00f5es dos nomes dos elementos da interface, al\u00e9m de outros\npar\u00e2metros que contribuem para coer\u00eancia e design do projeto. O Qt Designer utiliza o\nconceito de classes para definir cada estrutura, seja um simples bot\u00e3o at\u00e9 uma aba\n\n\n\n78 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\ncompleta com todos elementos dispostos, onde cada elemento se torna uma inst\u00e2ncia\nde objeto, se valendo do mesmo conceito de heran\u00e7a definido anteriormente.\n\nA extens\u00e3o de arquivo adotada pelo Qt Designer \u00e9 .ui. Desta forma, para que\nseja poss\u00edvel a utiliza\u00e7\u00e3o da interface utilizando o Python \u00e9 necess\u00e1ria a convers\u00e3o do\narquivo .ui para .py, ou seja, a extens\u00e3o utilizada pelo Qt Designer deve ser adaptada\npara que possa ser interpretada na linguagem Python, que apenas lida com arquivos\n.py. Para tal, utiliza-se o comando abaixo para a convers\u00e3o das extens\u00f5es:\n\npyuic4 interface.ui -o ..\\interface.py\n\nCom o arquivo convertido, pode-se come\u00e7ar a criar algoritmos que fa\u00e7am a\nsimula\u00e7\u00e3o de fato na pr\u00f3pria API do Python, facilitando a implementa\u00e7\u00e3o do c\u00f3digo e\ncria\u00e7\u00e3o do software.\n\n4.8 Camada de Persist\u00eancia\n\nA primeira an\u00e1lise que foi feita antes de se iniciar o desenvolvimento da camada\nde persist\u00eancia foi quais seriam os dados que deveriam ser armazenados e de que\ntipo eles seriam. A camada de persist\u00eancia deve ser capaz de guardar todos os dados\nnecess\u00e1rios de forma que eles, ao serem recuperados, permitam que o projeto seja\nrecriado exatamente igual e por isso \u00e9 muito importante decidir quais as informa\u00e7\u00f5es\nmais relevantes do sistema.\n\nFigura 21 \u2013 Fragmento do schema criado para o projeto.\n\nInicialmente foi criado o arquivo schema que continha a estrutura b\u00e1sica do\ndocumento XML que seria gerado na camada de persist\u00eancia, informando detalha-\n\n\n\n4.8. Camada de Persist\u00eancia 79\n\ndamente os tipos e caracter\u00edsticas das informa\u00e7\u00f5es. Na Figura 21 \u00e9 mostrado um\nfragmento do arquivo que define as caracter\u00edsticas do schema, criando um elemento\ncomplexo composto por uma sequ\u00eancia de outros elementos, cada um de um tipo espe-\nc\u00edfico. Esses elementos comp\u00f5em as informa\u00e7\u00f5es que ser\u00e3o armazenadas na camada\nde persist\u00eancia e, portanto, s\u00e3o suficientes para que o projeto possa ser recuperado\nposteriormente.\n\nCom o schema definindo a estrutura dos documentos XML, foi ent\u00e3o imple-\nmentado o c\u00f3digo que permitiria ao usu\u00e1rio na pr\u00f3pria interface gr\u00e1fica salvar dados\nde um projeto criado. Para interpretar os arquivos XML \u00e9 comum utilizar pacotes ou\nbibliotecas integradas \u00e0 linguagem de programa\u00e7\u00e3o, e no caso do Python existem\ndiversas bibliotecas que permitem a leitura e escrita de arquivos XML. Entre as op\u00e7\u00f5es\ndispon\u00edveis foi utilizada a biblioteca PyXB [36] pela simplicidade em integrar c\u00f3digo do\nPython com o arquivo schema. Na Figura 22 \u00e9 observado um exemplo de XML gerado,\nseguindo o padr\u00e3o do schema mostrado, representando o projeto de um tanque c\u00f4nico\nhipot\u00e9tico.\n\nFigura 22 \u2013 Documento XML gerado para o projeto de um tanque c\u00f4nico.\n\nOs arquivos gerados s\u00e3o suficiente para que o usu\u00e1rio consiga Salvar, Salvar\n\n\n\n80 Cap\u00edtulo 4. Requisitos da interface e Projeto de software\n\nComo e Abrir os projetos desenvolvidos, permitindo o desenvolvimento de um banco\nde dados com os diversos projeto criados. Para facilitar a cria\u00e7\u00e3o desse banco de\ndados, foi implementada uma biblioteca que cont\u00e9m projetos com modelos comuns da\nind\u00fastria, com intuito de criar uma base de dados s\u00f3lida para o usu\u00e1rio antes mesmo\ndele iniciar o uso da interface gr\u00e1fica. Por\u00e9m, alguns cuidados foram tomados para\nque as informa\u00e7\u00f5es armazenadas n\u00e3o fossem corrompidas durante alguma simula\u00e7\u00e3o,\nprotegendo todos os dados guardados nessa biblioteca, de forma que ela estivesse\nfora do alcance do usu\u00e1rio. Por isso, os arquivos da biblioteca foram criptografados e\nsalvos em arquivos de texto inacess\u00edveis ao usu\u00e1rio.\n\nConsidera\u00e7\u00f5es Finais\n\nNesse cap\u00edtulo foram apresentadas as etapas da metodologia para desenvolver\no software proposto, detalhando os aspectos mais importantes do desenvolvimento.\nMuitas etapas foram realizadas durante o in\u00edcio do projeto, por\u00e9m algumas foram\natualizadas para se adequar \u00e0 vers\u00e3o final. Por exemplo, quando o projeto come\u00e7ou\nn\u00e3o estava prevista a aplica\u00e7\u00e3o do algoritmo DMC para controle preditivo e modelos do\ntipo resposta ao degrau, tendo que adaptar os diagramas de classe do projeto. Tamb\u00e9m\nn\u00e3o s\u00e3o mencionados com detalhe os controladores PID que n\u00e3o s\u00e3o foco do sistema,\npois foram implementados apenas como uma ferramenta adicional de simula\u00e7\u00e3o.\n\n\n\n81\n\n5 Interface de Usu\u00e1rio\n\nNeste cap\u00edtulo \u00e9 apresentado o resultado final da interface desenvolvida, deta-\nlhando cada caracter\u00edstica e explicando no formato de um pequeno manual demons-\ntrando o funcionamento da interface gr\u00e1fica. Alguns elementos implementados na\ninterface n\u00e3o s\u00e3o explicados aqui pois n\u00e3o foram implementados para esse projeto,\nmas para outros que aconteciam em paralelo.\n\nO software criado, portanto, implementa uma interface gr\u00e1fica, chamada atu-\nalmente de SimPro, com intuito de simular processos industriais e com \u00eanfase em\ncontrole preditivo. Todo o processo de simula\u00e7\u00e3o foi criado de forma que seguisse uma\nsequ\u00eancia l\u00f3gica b\u00e1sica de opera\u00e7\u00f5es, buscando compreender como s\u00e3o feitos testes e\nsimula\u00e7\u00f5es de processos industriais na pr\u00e1tica para aprimorar o uso da interface. Com\nisso foram analisados as classes do sistema para definir qual seria essa sequ\u00eancia\nl\u00f3gica b\u00e1sica, obtendo:\n\n1. Primeiramente o usu\u00e1rio deve iniciar o projeto definindo suas caracter\u00edsticas;\n\n2. Depois, todos os modelos que ser\u00e3o utilizados na simula\u00e7\u00e3o devem ser definidos;\n\n3. Ent\u00e3o, o usu\u00e1rio define a sintonia dos controladores;\n\n4. Na sequ\u00eancia s\u00e3o criados os cen\u00e1rios de simula\u00e7\u00e3o e a simula\u00e7\u00e3o propriamente\ndita \u00e9 realizada;\n\n5. Com a simula\u00e7\u00e3o realizada, o usu\u00e1rio verifica os resultados da simula\u00e7\u00e3o a partir\nde gr\u00e1ficos;\n\n6. Por fim, o usu\u00e1rio pode explorar a robustez dos controladores definidos analisando\nos \u00edndices de desempenho.\n\nConsiderando essa sequ\u00eancia, pode-se observar que existem seis a\u00e7\u00f5es princi-\npais que o usu\u00e1rio pode executar durante a simula\u00e7\u00e3o, que s\u00e3o distintas e apresentam\ncaracter\u00edsticas \u00fanicas. Com o intuito de aproveitar esse fato constatado, a interface\ngr\u00e1fica foi criada com seis abas distintas, cada uma representando um dos elementos\nprincipais destacados na sequ\u00eancia l\u00f3gica exposta: as Caracter\u00edsticas do Projeto, o\nModelo, o Controlador, o Cen\u00e1rio, a Simula\u00e7\u00e3o e os \u00cdndices de Desempenho. Na Figura\n23 est\u00e1 a vers\u00e3o final da interface implementada com as seis abas (mais duas abas que,\ncomo dito anteriormente, n\u00e3o s\u00e3o escopo desse projeto) e uma barra de ferramentas.\n\nA implementa\u00e7\u00e3o da barra de ferramentas teve como objetivo possibilitar ao\nusu\u00e1rio o acesso r\u00e1pido a certas fun\u00e7\u00f5es especiais do sistema, que acrescentam\n\n\n\n82 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nFigura 23 \u2013 Janela principal da interface com as seis abas definidas.\n\ncaracter\u00edsticas a ele que melhoram sua performance e sua usabilidade. Na parte do\nArquivo na barra de ferramenta, essas fun\u00e7\u00f5es s\u00e3o (ver Figura 24):\n\n\u2022 Novo...: Permite ao usu\u00e1rio reiniciar um projeto em andamento, retornando o\nsistema ao seu estado inicial;\n\n\u2022 Abrir...: Essa fun\u00e7\u00e3o possibilita abrir arquivos XML que est\u00e3o armazenados no\ncomputador e que tenham a mesma estrutura definida pelo schema;\n\n\u2022 Salvar : Caso o usu\u00e1rio tenha alterado o arquivo a fun\u00e7\u00e3o Salvar permite que os\ndados alterados sejam armazenados num arquivo XML, de forma que ele possa\nrecuperar o projeto criado;\n\n\u2022 Salvar Como...: Semelhante \u00e0 Salvar, por\u00e9m o usu\u00e1rio tamb\u00e9m define o nome do\narquivo XML gerado:\n\n\n\n5.1. Caracter\u00edsticas do Projeto 83\n\n\u2022 Sair : Finaliza o projeto, perguntando ao usu\u00e1rio se ele deseja salvar caso alguma\naltera\u00e7\u00e3o seja realizada no projeto.\n\nFigura 24 \u2013 Arquivo na barra de ferramentas.\n\nPara facilitar o uso da barra de ferramentas, algumas das fun\u00e7\u00f5es foram imple-\nmentadas com atalhos, diminuindo esfor\u00e7o e o tempo gasto utilizando a interface. O\noutro elemento da barra de ferramentas \u00e9 Op\u00e7\u00f5es, que basicamente implementa a\nbiblioteca de modelos (Figura 25) estudada no final do cap\u00edtulo.\n\nFigura 25 \u2013 Op\u00e7\u00f5es na barra de ferramentas.\n\nNas se\u00e7\u00f5es seguintes ser\u00e3o examinadas cada aba da interface gr\u00e1fica com\ndetalhes, explicando o funcionamento de cada atributo da aba.\n\n5.1 Caracter\u00edsticas do Projeto\n\nCada aba tem uma funcionalidade particular dentro da sequ\u00eancia l\u00f3gica citada\nanteriormente. Essa sequ\u00eancia tamb\u00e9m pode ser considerada cronol\u00f3gica, na maioria\ndas simula\u00e7\u00f5es realizadas, pois algumas a\u00e7\u00f5es tomadas pelo usu\u00e1rio seguem uma\nordem espec\u00edfica. Por exemplo, o usu\u00e1rio s\u00f3 pode criar um modelo do processo se\no projeto for iniciado, definindo o n\u00famero de vari\u00e1veis manipuladas, controladas e\nperturba\u00e7\u00f5es do sistema. Para resolver esse problema, todas as abas se iniciam\ndesabilitadas, exceto a aba Caracter\u00edsticas do Projeto (ver Figura 23) e elas s\u00f3 ser\u00e3o\nhabilitadas quando o usu\u00e1rio iniciar o projeto, determinando as caracter\u00edsticas dele.\n\nNum primeiro instante, portanto, o usu\u00e1rio define os par\u00e2metros do projeto. Na\nFigura 26 est\u00e3o definidas as vari\u00e1veis do projeto:\n\n\u2022 Nome: define o nome dado ao projeto. N\u00e3o existe nenhuma restri\u00e7\u00e3o quanto ao\nnome, \u00e9 sugerido nomes que tenham rela\u00e7\u00e3o com o escopo da simula\u00e7\u00e3o, como\n\n\n\n84 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nFigura 26 \u2013 Vari\u00e1veis do projeto.\n\no processo que ser\u00e1 simulado, ou tamb\u00e9m nomes que identificam especificada-\nmente qual o projeto est\u00e1 sendo feito;\n\n\u2022 Tipo: A princ\u00edpio, a simula\u00e7\u00e3o poderia ser feita em sistemas discretos e cont\u00ednuos,\npor\u00e9m foi decidido que seriam implementados apenas sistemas discretos, visto\nque atualmente a maioria dos processos s\u00e3o controlados digitalmente. Portanto,\no processo \u00e9 sempre representado em sistemas do tipo Discreto;\n\n\u2022 Amostragem: os sistemas discretos s\u00e3o amostrados e, portanto, tamb\u00e9m deve\nser definido um tempo de amostragem do processo, permitindo apenas valores\nracionais positivos.\n\n\u2022 N\u00famero de Vari\u00e1veis Controladas: define o n\u00famero de sa\u00eddas do sistema, permi-\ntindo apenas n\u00famero inteiros positivos.\n\n\n\n5.1. Caracter\u00edsticas do Projeto 85\n\n\u2022 N\u00famero de Vari\u00e1veis Manipuladas: define o n\u00famero de entradas do sistema,\npermitindo apenas n\u00famero inteiros positivos.\n\n\u2022 N\u00famero de Perturba\u00e7\u00f5es: define o n\u00famero de perturba\u00e7\u00f5es do sistema, permi-\ntindo apenas n\u00famero inteiros positivos.\n\nO software permite a implementa\u00e7\u00e3o de sistemas monovari\u00e1veis ou multivari\u00e1-\nveis, definidos de acordo com a necessidade do usu\u00e1rio que escolhe se o sistema ser\u00e1\nSISO ou MIMO. Caso o usu\u00e1rio tente definir algum dos par\u00e2metros de forma inv\u00e1lida,\numa janela de aviso aparecer\u00e1 para inform\u00e1-lo de que a opera\u00e7\u00e3o foi inv\u00e1lida. Por\nexemplo, se for escolhido um n\u00famero de entradas igual a 2.5, um aviso ser\u00e1 gerado\ncomo o da Figura 27, notificando o usu\u00e1rio qual opera\u00e7\u00e3o foi realizada de maneira\nincorreta e impedindo que o projeto seja iniciado at\u00e9 que todos par\u00e2metros sejam\ndefinidos corretamente.\n\nFigura 27 \u2013 Aviso gerado quando o n\u00famero de entradas escolhidas for inv\u00e1lido.\n\nTamb\u00e9m foi aproveitado um elemento dispon\u00edvel no Qt Designer para auxiliar o\nusu\u00e1rio quando ele est\u00e1 usando a interface gr\u00e1fica, chamado de ToolTip. O seu intuito \u00e9\ndar dicas ao usu\u00e1rio sobre como utilizar a interface e os seus atributos, sem atrapalhar\na visualiza\u00e7\u00e3o. Para aparecer o ToolTip basta deixar a seta do mouse est\u00e1tica em cima\nde algum elemento da interface que automaticamente ir\u00e1 aparecer um texto revelando\nalguma informa\u00e7\u00e3o \u00fatil.\n\nAp\u00f3s o usu\u00e1rio definir as vari\u00e1veis do projeto corretamente, o projeto pode ser\niniciado clicando no bot\u00e3o Iniciar. Em seguida, os par\u00e2metros escolhidos s\u00e3o mostrados\nna pr\u00f3pria aba e uma lista \u00e9 criada com o nome das vari\u00e1veis do processo, conforme a\nFigura 28.\n\nO padr\u00e3o do sistema \u00e9 definir as sa\u00eddas como \u2019Y\u2019, as entradas como \u2019U\u2019 e as\nperturba\u00e7\u00f5es como \u2019Q\u2019, por\u00e9m o pr\u00f3prio usu\u00e1rio pode alterar o nome das vari\u00e1veis,\nclicando duas vezes na vari\u00e1vel que deseja alterar da lista, como mostrado na Figura\n29. O nome das vari\u00e1veis sempre depender\u00e1 do processo em quest\u00e3o, por exemplo,\nnum sistema de controle de n\u00edvel que utiliza-se v\u00e1lvulas para manipular a vaz\u00e3o de\nentrada seria l\u00f3gico definir a vari\u00e1vel controlada como \u2019N\u00edvel\u2019 e a manipulada como\n\u2019Vaz\u00e3o de Entrada\u2019. A escolha dos nomes padr\u00f5es surgiu dos nomes mais comuns\n\n\n\n86 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nFigura 28 \u2013 Dados do projeto e nome das vari\u00e1veis.\n\nFigura 29 \u2013 Demonstra\u00e7\u00e3o de como modificar nome da vari\u00e1vel.\n\n\n\n5.2. Modelo 87\n\nencontrados nas literaturas relacionadas a controle de processos para representar\nsistemas gen\u00e9ricos.\n\nCom as caracter\u00edsticas b\u00e1sicas do projeto definidas, \u00e9 permitido ao usu\u00e1rio\nnavegar entre as outras abas da interface. Seguindo a l\u00f3gica criada, o pr\u00f3ximo passo \u00e9\na defini\u00e7\u00e3o dos modelos do processo na aba seguinte.\n\n5.2 Modelo\n\nNa aba Modelo s\u00e3o configurados todos os modelos do processo que o usu\u00e1rio\nir\u00e1 utilizar durante a simula\u00e7\u00e3o, incluindo os modelos utilizados pelos controladores.\nNa Figura 30 pode-se observar as diversas funcionalidades da aba e como est\u00e3o\norganizados os diferentes tipos de modelo. Ela foi criada para se adaptar ao tipo de\nmodelo escolhido, modificando sua apar\u00eancia dependendo do tipo do modelo.\n\nFigura 30 \u2013 Aba dos modelos.\n\n\n\n88 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nForam implementados tr\u00eas tipos de modelos para representar os processos:\nFun\u00e7\u00e3o Transfer\u00eancia Discreta, Resposta ao Degrau e Equa\u00e7\u00f5es de Diferen\u00e7a. Os\ndois primeiros foram definidos para sistemas lineares discretos, enquanto o \u00faltimo\nrepresenta sistemas n\u00e3o-lineares e, dessa forma, foram criadas duas listas para dife-\nrenciar os modelos lineares e n\u00e3o-lineares na interface, como pode ser visto na Figura\n31. Por quest\u00e3o de comodidade ao usu\u00e1rio, quando o projeto foi iniciado o sistema\nautomaticamente j\u00e1 adiciona dois modelos na lista, um modelo linear do tipo fun\u00e7\u00e3o\ntransfer\u00eancia e outro n\u00e3o linear (mostrado na figura com nomes Nominal e Nominal2).\n\nFigura 31 \u2013 Lista de modelos.\n\nPara criar um novo modelo o usu\u00e1rio primeiramente define o seu Nome e define\no tipo do modelo, clicando no bot\u00e3o Adicionar. Existem algumas restri\u00e7\u00f5es quanto ao\n\n\n\n5.2. Modelo 89\n\nnome do novo modelo que se executadas elas geram uma janela semelhante a da\nFigura 27:\n\n\u2022 N\u00e3o podem ser criados modelos com nomes j\u00e1 existentes nas listas;\n\n\u2022 Os nomes devem ser de no m\u00e1ximo 12 caracteres.\n\nFigura 32 \u2013 Exemplo de modelo tipo fun\u00e7\u00e3o transfer\u00eancia selecionado.\n\nA Figura 31 tamb\u00e9m revela alguns bot\u00f5es adicionais logo abaixo das listas:\nSelecionar, Copiar e Remover. O primeiro serve para o usu\u00e1rio definir um modelo para\n\n\n\n90 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nmodificar suas vari\u00e1veis e configurar seus par\u00e2metros, de forma que o usu\u00e1rio sempre\ndeve clicar num dos modelos da lista para selecion\u00e1-los. O mesmo tamb\u00e9m acontece\ncom o bot\u00e3o Copiar que ao ser clicado com um item da lista selecionado abre uma\njanela e pergunta ao usu\u00e1rio se ele deseja copiar o modelo para a lista e qual o nome\ndo novo modelo. Por fim, o bot\u00e3o Remover retira um dos itens selecionados da lista\nquando clicado.\n\nComo citado anteriormente, a pr\u00f3pria interface se adapta ao tipo de modelo\nselecionado, por\u00e9m alguns elementos da interface s\u00e3o comuns a todos os tipos (ver\nFigura 32). Esses elementos s\u00e3o:\n\n\u2022 Satura\u00e7\u00e3o do sinal de controle;\n\n\u2022 Ponto de opera\u00e7\u00e3o das vari\u00e1veis;\n\n\u2022 Lista de vari\u00e1veis controladas, manipuladas e perturba\u00e7\u00f5es.\n\nFigura 33 \u2013 Janelas para alterar a satura\u00e7\u00e3o e os pontos de opera\u00e7\u00e3o.\n\nA satura\u00e7\u00e3o do sinal de controle e os pontos de opera\u00e7\u00f5es foram implementados\ncriando bot\u00f5es na interface, na parte superior direita da aba, de maneira que quando\nclicadas ambas abrem janelas (iguais a Figura 33) semelhantes que permitem a\nconfigura\u00e7\u00e3o desses par\u00e2metros. Os dois s\u00e3o similares no sentido de que apresentam\n\n\n\n5.2. Modelo 91\n\numa tabela com as vari\u00e1veis na primeira coluna e os par\u00e2metros de configura\u00e7\u00e3o nas\ncolunas seguintes. No caso dos pontos de opera\u00e7\u00e3o o usu\u00e1rio pode definir valores do\ntipo float para qualquer vari\u00e1vel do sistema. J\u00e1 para satura\u00e7\u00e3o, apenas as vari\u00e1veis\nmanipuladas apresentam satura\u00e7\u00f5es e o usu\u00e1rio define um valor m\u00ednimo e m\u00e1ximo\n(ou seja, um intervalo de satura\u00e7\u00e3o) e tamb\u00e9m define se a satura\u00e7\u00e3o est\u00e1 \u2019Ativada\u2019 ou\n\u2019Desativada\u2019, que indica se durante a simula\u00e7\u00e3o as entradas realmente ir\u00e3o apresentar\num intervalo de satura\u00e7\u00e3o.\n\nNo exemplo da Figura 32 foi selecionado um modelo do tipo fun\u00e7\u00e3o transfer\u00eancia,\ncujo nome \u00e9 Nominal. Cada tipo de modelo tem suas caracter\u00edsticas pr\u00f3prias que podem\nser ajustadas pelo usu\u00e1rio e para isso ele deve escolher quais as vari\u00e1veis do processo\nque ser\u00e3o modificadas. No exemplo da Figura 32 o usu\u00e1rio escolheu um par entrada\ne sa\u00edda espec\u00edfico da lista de vari\u00e1veis manipuladas e controladas para modificar a\nfun\u00e7\u00e3o transfer\u00eancia do modelo.\n\nModelo Fun\u00e7\u00e3o Transfer\u00eancia\n\nComo j\u00e1 citado, para modelos do tipo fun\u00e7\u00e3o transfer\u00eancia o usu\u00e1rio deve seleci-\nonar um item da lista de vari\u00e1veis controladas e outro da lista de vari\u00e1veis manipuladas\nou perturba\u00e7\u00f5es. \u00c9 necess\u00e1rio escolher um par de vari\u00e1veis pois na representa\u00e7\u00e3o por\nfun\u00e7\u00f5es transfer\u00eancia (ver Equa\u00e7\u00e3o 2.6) cada sa\u00edda \u00e9 relacionada com uma entrada ou\nperturba\u00e7\u00e3o, criando fun\u00e7\u00f5es definidas por numeradores, denominadores e o tempo\nmorto do sistema. Para configurar esses par\u00e2metros \u00e9 utilizado um formato espec\u00edfico\npara represent\u00e1-los:\n\n\u2022 Sempre definidos entre colchetes;\n\n\u2022 Os n\u00fameros s\u00e3o separados por v\u00edrgulas e utiliza-se ponto para separar as casas\ndecimais;\n\n\u2022 Pode-se entender como uma lista L = [k1,k2, . . . ,kn] de tamanho n, onde cada\nelemento da lista representa um fator que multiplica um componente do polin\u00f4mio\nP = [zn?1,zn?2, . . . ,z0] elemento por elemento. Por exemplo, na Figura 32 o\nnumerador \u00e9 uma lista L = [0.0952, 1.0], com n igual a 2, que ent\u00e3o multiplica o\npolin\u00f4mio P = [z1,z0] elemento por elemento, resultando em:\n\nL.?P = [0.0952 ?z1, 1.0 ?z0] (5.1)\n\nonde o s\u00edmbolo .* representa a multiplica\u00e7\u00e3o elemento por elemento;\n\n\u2022 O tempo morto \u00e9 definido apenas por um n\u00famero inteiro.\n\n\n\n92 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nPara alterar o numerador, denominador e tempo morto do par escolhido, o\nusu\u00e1rio s\u00f3 precisa clicar no bot\u00e3o Alterar.\n\nModelo Resposta ao Degrau\n\nAssim como no caso anterior, os modelo do tipo resposta ao degrau exigem\nque o usu\u00e1rio selecione um par entrada/sa\u00edda ou perturba\u00e7\u00e3o/sa\u00edda (ver Equa\u00e7\u00e3o 2.1).\nMas nesse caso, os par\u00e2metros de configura\u00e7\u00e3o s\u00e3o diferentes, j\u00e1 que a estrutura\ndo modelo \u00e9 outra. Na Figura 34 pode-se constatar que o usu\u00e1rio configura dois\npar\u00e2metros distintos, um vetor de coeficientes gi, definido entre colchetes e separando\ncada elemento por v\u00edrgulas, e o n\u00famero de coeficientes do vetor gi. \u00c9 importante que\ndurante a defini\u00e7\u00e3o do vetor gi o tamanho do vetor coincida com o n\u00famero determinado\nna interface, caso contr\u00e1rio um aviso ser\u00e1 gerado informando que a a\u00e7\u00e3o foi inv\u00e1lida.\n\nFigura 34 \u2013 Se\u00e7\u00e3o da interface do modelo resposta ao degrau.\n\nAo clicar no bot\u00e3o Gr\u00e1fico, o sistema gera um gr\u00e1fico que mostra o vetor gi,\nnum intervalo que come\u00e7a em zero e termina no n\u00famero de coeficiente definido pelo\nusu\u00e1rio.\n\nOutra ferramenta implementada diz respeito ao bot\u00e3o Importar, que permite ao\nusu\u00e1rio importar arquivos externos para a interface que cont\u00eam vetores de coeficientes\nj\u00e1 previamente criados num formato espec\u00edfico, cuja a extens\u00e3o \u00e9 o .dmi. O principal\nobjetivo da implementa\u00e7\u00e3o dessa ferramenta foi auxiliar projetos j\u00e1 existentes em\nparceria com o centro de pesquisa da Petrobr\u00e1s, reduzindo o tempo necess\u00e1rio para\nimportar os dados do modelo direto para a interface.\n\n\n\n5.2. Modelo 93\n\nPor fim, semelhante ao modelo fun\u00e7\u00e3o transfer\u00eancia, o usu\u00e1rio altera os par\u00e2-\nmetros clicando no bot\u00e3o Alterar.\n\nModelo Equa\u00e7\u00e3o de Diferen\u00e7as\n\nDiferentemente dos casos apresentados anteriormente, o modelo de equa\u00e7\u00e3o\nde diferen\u00e7as requer apenas a sele\u00e7\u00e3o de uma sa\u00edda, visto que uma mesma vari\u00e1vel\ncontrolada pode apresentar na sua equa\u00e7\u00e3o qualquer vari\u00e1vel do sistema e portanto o\nmodelo n\u00e3o representado por pares (ver Equa\u00e7\u00e3o 2.7).\n\nFigura 35 \u2013 Se\u00e7\u00e3o da interface do modelo de equa\u00e7\u00e3o de diferen\u00e7as.\n\nA equa\u00e7\u00e3o \u00e9 escrita intuitivamente, conforme a Figura 35, com formato conhe-\ncido em diferentes softwares computacionais que apresentam equa\u00e7\u00f5es matem\u00e1ticas,\nfacilitando a utiliza\u00e7\u00e3o para usu\u00e1rios familiarizados com softwares como Matlab ou\nOctave (no caso do modelo linear tamb\u00e9m foi utilizado padr\u00f5es difundidos em softwa-\nres de desenvolvimento de algoritmos matem\u00e1ticos). A equa\u00e7\u00e3o deve ser indicada\nsempre com a vari\u00e1vel k para representar os instantes de tempo, entre colchetes e o\nnome das vari\u00e1veis do processo devem ser exatamente iguais aos definidos na aba\nCaracter\u00edsticas do Projeto.\n\nOs modelos n\u00e3o-lineares apresentam uma caracter\u00edstica \u00fanica que \u00e9 a possi-\nbilidade de definir constantes do processo (Figura 36). Isso permite ao usu\u00e1rio criar\nequa\u00e7\u00f5es que dependem de certas constantes e simular o sistema modificando as\nconstantes em diferentes cen\u00e1rio. Por exemplo, pode-se iniciar um projeto de controle\nde n\u00edvel onde o tanque pode apresentar diferentes volumes. Pode-se ent\u00e3o criar uma\nconstante chamada Volume e atribuir valores distintos, como 100 litros ou 300 litros, e\ndepois criar diferentes cen\u00e1rio que simulam o comportamento do sistema para cada\nvolume.\n\n\n\n94 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nFigura 36 \u2013 Janela para defini\u00e7\u00e3o de constantes.\n\n5.3 Controlador\n\nNo Cap\u00edtulo 2 foram apresentados os algoritmos de controle preditivo MPC im-\nplementados na interface, foco principal do software. Portanto, a aba dos Controladores\nfoi criada para permitir a defini\u00e7\u00e3o de diferentes tipos de controladores utilizando a\nmesma ideia dos aba do modelos que se adaptava para os diferentes tipos escolhidos.\nO resultado \u00e9 apresentado na Figura 37 que mostra alguns dos elementos da aba para\ndefini\u00e7\u00e3o dos controladores, bastante semelhantes \u00e0 aba modelo.\n\nOs controladores podem ser do tipo GPC, PNMPC, DMC e PID. Cada tipo de\ncontrolador tem atributos \u00fanicos, visto que seus algoritmos s\u00e3o diferentes entre si,\npor\u00e9m no caso dos algoritmos preditivos h\u00e1 atributos semelhantes que s\u00e3o explorados.\nOs controladores PID foram implementados principalmente para realiza\u00e7\u00e3o de testes da\nperformance do MPC, pois s\u00e3o controladores amplamente estudados e com resultados\nmais previs\u00edveis, portanto s\u00e3o bons para comparar com simula\u00e7\u00f5es utilizando algoritmos\npreditivos.\n\nA cria\u00e7\u00e3o dos controladores \u00e9 realizada de maneira semelhante \u00e0 aba modelo,\nna Figura 38 pode-se perceber que a pr\u00f3pria estrutura \u00e9 similar. O objetivo \u00e9 manter a\ncoer\u00eancia dos elementos da interface, na tentativa de padronizar esses elementos para\n\n\n\n5.3. Controlador 95\n\nFigura 37 \u2013 Aba dos controladores.\n\nauxiliar na utiliza\u00e7\u00e3o do software. Resumindo a defini\u00e7\u00e3o dos controladores, o usu\u00e1rio\nescolhe um nome para o controlador, com as mesmas restri\u00e7\u00f5es dadas aos modelos\ne tamb\u00e9m n\u00e3o permitindo a cria\u00e7\u00e3o de controladores com nome igual aos modelos\ncriados anteriormente. Em sequ\u00eancia, o usu\u00e1rio escolhe o tipo do controlador e clica\nno bot\u00e3o Adicionar. Na Figura 38 foram adicionados tr\u00eas controladores \u00e0 lista, com\nnomes cont1, cont3 e cont2, como exemplo.\n\nNa aba tamb\u00e9m foram adicionados tr\u00eas bot\u00f5es logo abaixo da lista Selecionar,\nCopiar e Remover, com as mesmas fun\u00e7\u00f5es dos adicionados para os modelos. Todos\nexigem que um item da lista de controladores tenha sido clicado, gerando uma janela\nde aviso caso o usu\u00e1rio clique no bot\u00e3o sem um item selecionado.\n\nAo selecionar um controlador, a interface ir\u00e1 se adaptar ao tipo escolhido pelo\nusu\u00e1rio e, com isso, o usu\u00e1rio pode configurar os par\u00e2metros do controlador que\nser\u00e3o utilizados durante a simula\u00e7\u00e3o para o c\u00e1lculo das a\u00e7\u00f5es de controle. Na Figura\n\n\n\n96 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nFigura 38 \u2013 Defini\u00e7\u00e3o dos controladores.\n\n39 \u00e9 mostrada a se\u00e7\u00e3o da janela respons\u00e1vel pela configura\u00e7\u00e3o dos par\u00e2metros do\ncontrolador, composta por tr\u00eas listas para cada vari\u00e1vel do processo no lado esquerdo\ne as informa\u00e7\u00f5es de cada vari\u00e1vel no lado direito. Essas informa\u00e7\u00f5es s\u00e3o atualizadas\nautomaticamente sempre que o usu\u00e1rio clica numa das vari\u00e1veis (sem pressionar no\nbot\u00e3o Alterar ). Al\u00e9m disso, quando selecionado um controlador preditivo ir\u00e1 aparecer no\ncanto inferior direito uma lista que cont\u00e9m os modelos, permitindo ao usu\u00e1rio selecionar\nqual ser\u00e1 o modelo de predi\u00e7\u00e3o do controlador clicando num dos itens da lista.\n\nA configura\u00e7\u00e3o dos par\u00e2metros se d\u00e1 clicando no bot\u00e3o Alterar posicionado\nabaixo das listas de vari\u00e1veis do processo, ap\u00f3s o usu\u00e1rio escolher um item das listas,\nabrindo um janela para a configura\u00e7\u00e3o. Por exemplo, na Figura 39 foi selecionado o\n\n\n\n5.3. Controlador 97\n\nFigura 39 \u2013 Configura\u00e7\u00e3o dos controladores.\n\ncontrolador cont1 e o usu\u00e1rio deseja alterar um par\u00e2metro da vari\u00e1vel manipulada U1.\nPara isso ele deve selecion\u00e1-la na lista de vari\u00e1veis manipuladas e ent\u00e3o clicar no\nbot\u00e3o Alterar, o que resultando na apari\u00e7\u00e3o da janela mostrada na Figura 40.\n\nPara os algoritmos preditivos, existem par\u00e2metros comuns aos tr\u00eas tipos defini-\ndos, simplificando a implementa\u00e7\u00e3o da l\u00f3gica de programa\u00e7\u00e3o (utilizando o conceito de\nclasses). Esses par\u00e2metros s\u00e3o:\n\n\n\n98 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\n\u2022 Vari\u00e1veis Manipuladas;\n\n\u2013 Pondera\u00e7\u00e3o;\n\n\u2013 Horizonte de entrada;\n\n\u2013 Restri\u00e7\u00e3o de Amplitude;\n\n\u2013 Restri\u00e7\u00e3o de Incremento de controle.\n\n\u2022 Vari\u00e1veis Controladas;\n\n\u2013 Pondera\u00e7\u00e3o;\n\n\u2013 Horizonte de sa\u00edda;\n\n\u2013 Restri\u00e7\u00e3o de Amplitude;\n\n\u2013 Restri\u00e7\u00e3o de Banda.\n\n\u2022 Perturba\u00e7\u00f5es.\n\n\u2013 A\u00e7\u00e3o Feedforward.\n\nAs restri\u00e7\u00f5es para cada par\u00e2metro s\u00e3o:\n\n\u2022 Pondera\u00e7\u00f5es devem sempre ser positivas;\n\n\u2022 Horizontes devem assumir valores inteiros positivos;\n\n\u2022 A amplitude m\u00e1xima das restri\u00e7\u00f5es deve sempre ser maior que a m\u00ednima;\n\n\u2022 O usu\u00e1rio pode desativar as restri\u00e7\u00f5es.\n\nFigura 40 \u2013 Janela para altera\u00e7\u00e3o dos par\u00e2metros de entrada do controlador.\n\n\n\n5.4. Cen\u00e1rio 99\n\nO que diferencia cada algoritmo preditivo \u00e9 como s\u00e3o calculadas as predi\u00e7\u00f5es\ndo processo. Os algoritmos apresentam modelos diferentes para o c\u00e1lculo, como\nexplicado com detalhes no Cap\u00edtulo 2, influenciando nos modelos que s\u00e3o mostrados\nna lista de modelos de predi\u00e7\u00e3o. Portanto, na lista somente ser\u00e3o mostrados ao usu\u00e1rio\nos modelos que s\u00e3o permitidos utilizar para calcular a predi\u00e7\u00e3o dependendo do tipo\ndo controlador. Por exemplo, na Figura 39 apenas o modelo Nominal est\u00e1 listado,\npois o controlador selecionado \u00e9 do tipo GPC e o modelo Nominal \u00e9 do tipo fun\u00e7\u00e3o\ntransfer\u00eancia.\n\n5.4 Cen\u00e1rio\n\nTodos os elementos componentes b\u00e1sicos para que o sistema execute a simula-\n\u00e7\u00e3o do processo j\u00e1 foram criados. Agora, seguindo a sequ\u00eancia descrita anteriormente,\no usu\u00e1rio deve configurar a simula\u00e7\u00e3o antes de execut\u00e1-lo. O principal objetivo dessa\nconfigura\u00e7\u00e3o \u00e9 recriar situa\u00e7\u00f5es reais, buscando representar processos industriais da\nforma mais fiel poss\u00edvel e gerando cen\u00e1rios de simula\u00e7\u00e3o.\n\nPortanto, a aba de Cen\u00e1rios deve ser respons\u00e1vel pela configura\u00e7\u00e3o da simu-\nla\u00e7\u00e3o. Na Figura 41 \u00e9 mostrado o resultado da implementa\u00e7\u00e3o, que assim como nas\nduas abas anteriores, exibe uma lista no lado esquerdo da interface, respons\u00e1vel por\narmazenar todos os cen\u00e1rio criados. Para criar um cen\u00e1rio, o usu\u00e1rio escolhe um nome,\natendendo todas as restri\u00e7\u00f5es e ent\u00e3o clica no bot\u00e3o Adicionar. Tamb\u00e9m foram adici-\nonados os mesmos bot\u00f5es Selecionar, Copiar e Remover que funcionam conforme\ndescrito anteriormente.\n\nCada cen\u00e1rio tem caracter\u00edsticas pr\u00f3prias, que s\u00e3o modificados na se\u00e7\u00e3o da\njanela mostrado na Figura 42. As principais caracter\u00edsticas s\u00e3o:\n\n\u2022 Tempo de simula\u00e7\u00e3o ou n\u00famero de itera\u00e7\u00f5es;\n\n\u2022 Estado inicial;\n\n\u2022 Tipo do cen\u00e1rio (malha aberta ou malha fechada);\n\n\u2022 Sinais de refer\u00eancia (caso malha fechada), entrada (caso malha aberta) e pertur-\nba\u00e7\u00e3o;\n\n\u2022 Modelo de simula\u00e7\u00e3o;\n\n\u2022 Controlador.\n\nCada uma dessas vari\u00e1veis tem papel fundamental na configura\u00e7\u00e3o do cen\u00e1rio.\nO tempo de simula\u00e7\u00e3o determina a dura\u00e7\u00e3o necess\u00e1ria para finalizar toda a simula\u00e7\u00e3o\n\n\n\n100 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nFigura 41 \u2013 Aba dos cen\u00e1rios.\n\nem itera\u00e7\u00f5es. O estado inicial determina quais as condi\u00e7\u00f5es que cada vari\u00e1vel do\nprocesso se encontra no in\u00edcio da simula\u00e7\u00e3o, alterando os valores clicando no botando\nposicionado no canto superior direito da tela. O tipo de cen\u00e1rio interfere na simula\u00e7\u00e3o,\ndefinindo se o sistema ser\u00e1 realimentado ou n\u00e3o. Quando o tipo \u00e9 escolhido, o usu\u00e1rio\npode definir as refer\u00eancias (ou entradas) e perturba\u00e7\u00f5es do sistema, atribuindo valores\nem diferentes instantes de tempo, numa tabela posicionada no centro direito da tela.\nEsses valores atribu\u00eddos podem ser definidos pelo usu\u00e1rio como sinais espec\u00edficos:\n\n\u2022 Para aplicar um sinal do tipo degrau o usu\u00e1rio define apenas um valor para a\nvari\u00e1vel, como 1, 5 ou 10;\n\n\u2022 Para aplicar um sinal do tipo rampa, deve-se na coluna Valor da tabela digitar k,\n2k, 10k, etc. A constante k representa o instante incremental de tempo e o fator\nque o multiplica apenas indica a inclina\u00e7\u00e3o da rampa;\n\n\n\n5.4. Cen\u00e1rio 101\n\nFigura 42 \u2013 Janela para configura\u00e7\u00e3o dos cen\u00e1rios de simula\u00e7\u00e3o.\n\n\u2022 Para aplicar sen\u00f3ides de entrada basta no campo Valor da tabela o usu\u00e1rio\ndigitar sen(k), sen(60k), cos(k), cos(30), etc;\n\n\u2022 Por fim, o usu\u00e1rio pode definir sinais aleat\u00f3rios, digitando random(a,b). As cons-\ntantes \u2019a\u2019 e \u2019b\u2019 podem assumir qualquer valor, desde que a &lt;b. O resultado \u00e9 um\nvalor aleat\u00f3rio entre o intervalo [a,b].\n\nClicando no bot\u00e3o Adicionar Linhas pode-se criar novas refer\u00eancias, sinais de\n\n\n\n102 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nentrada ou perturba\u00e7\u00f5es (ver Figura 43). Portanto, o usu\u00e1rio pode definir a quantidade\nnecess\u00e1ria de sinais para cada vari\u00e1vel, incluindo diferentes sinais de refer\u00eancia para\ncada sa\u00edda por exemplo. Analogamente, pode-se remover um sinal apertando no bot\u00e3o\nRemover Linha.\n\nFigura 43 \u2013 Demonstra\u00e7\u00e3o de como modificar a refer\u00eancia.\n\nPor fim, o usu\u00e1rio pode simular o cen\u00e1rio j\u00e1 configurado, selecionando um mo-\ndelo, um controlador e clicando no bot\u00e3o Simular. Para que a simula\u00e7\u00e3o tenha sucesso,\no usu\u00e1rio tamb\u00e9m deve escolher um modelo de predi\u00e7\u00e3o, na aba do controlador, para\no controlador escolhido. Com todas as pr\u00e9-condi\u00e7\u00f5es da simula\u00e7\u00e3o satisfeitas, todos\nos c\u00e1lculos s\u00e3o realizados, determinando as a\u00e7\u00f5es de controle para que o sistema\nalcance as refer\u00eancias selecionadas. Durante o c\u00e1lculo aparece um aviso ao usu\u00e1rio\npara aguardar at\u00e9 que a simula\u00e7\u00e3o seja finalizada no canto inferior esquerdo, na parte\ncinza da tela e, ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o, uma janela \u00e9 gerada para informar ao\nusu\u00e1rio que a opera\u00e7\u00e3o foi realizada com sucesso.\n\n5.5 Simula\u00e7\u00e3o\n\nNesse momento o sistema j\u00e1 fez todos os c\u00e1lculos necess\u00e1rios para o usu\u00e1rio\nanalisar a simula\u00e7\u00e3o. Portanto, na aba Simula\u00e7\u00e3o (Figura 44), como o pr\u00f3prio nome\nrevela, s\u00e3o recuperados os dados calculados anteriormente e s\u00e3o fornecidos gr\u00e1ficos\npara o usu\u00e1rio interpret\u00e1-los. Uma das suas principais caracter\u00edsticas \u00e9 que pode-se\nproduzir gr\u00e1ficos de diferentes cen\u00e1rios ao mesmo tempo, ou seja, o usu\u00e1rio pode\ncriar diferentes situa\u00e7\u00f5es que envolvam o modelo, como controladores diferentes ou\npar\u00e2metros de entrada/refer\u00eancias diferentes e simular ambos cen\u00e1rios para comparar\nsuas performances, conforme a sua necessidade. Outra informa\u00e7\u00e3o importante \u00e9 que o\nusu\u00e1rio pode escolher as vari\u00e1veis que ele deseja observar nos gr\u00e1ficos.\n\nPortanto, para gerar um gr\u00e1fico da simula\u00e7\u00e3o o usu\u00e1rio deve:\n\n\n\n5.5. Simula\u00e7\u00e3o 103\n\nFigura 44 \u2013 Aba de simula\u00e7\u00e3o.\n\n1. Selecionar os cen\u00e1rios desejados na Lista de Cen\u00e1rios;\n\n2. Selecionar as vari\u00e1veis do processo que deseja-se analisar nas suas respectivas\nlistas;\n\n3. Clicar no bot\u00e3o Gerar Gr\u00e1ficos.\n\nUm exemplo pode ser observado na Figura 45. Nessa simula\u00e7\u00e3o foi definido um\nsistema com duas entradas (U1 e U2), duas sa\u00eddas (Y1 e Y2) e uma perturba\u00e7\u00e3o (Q1) e\ncen\u00e1rio cujo controlador era do tipo GPC, com Nu = 5, Ny = 40, Qu = 2.0, Qy = 1.0 e\nsem restri\u00e7\u00f5es. A fun\u00e7\u00e3o transfer\u00eancia do modelo \u00e9 desacoplada, com:\n\nY\n\nU\n=\n\n0.0952\n\nz ? 0.9048\nY\n\nQ\n=\n\n0.0952\n\nz(z ? 0.9048)\n(5.2)\n\nO cen\u00e1rio foi configurado da seguinte forma:\n\n\n\n104 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\n\u2022 N\u00famero de itera\u00e7\u00f5es igual a 200;\n\n\u2022 Tipo do cen\u00e1rio \u00e9 malha fechada;\n\n\u2022 Refer\u00eancias e perturba\u00e7\u00f5es em:\n\n\u2013 em k = 0 ? refer\u00eancia = 1.0 para as duas sa\u00eddas;\n\n\u2013 em k = 50 ? perturba\u00e7\u00e3o Q1 = 0.5;\n\n\u2013 em k = 100 ? Y1 com refer\u00eancia = 0.5 e Y2 com refer\u00eancia = 1.5.\n\nFigura 45 \u2013 Exemplo de gr\u00e1fico gerado.\n\n\n\n5.5. Simula\u00e7\u00e3o 105\n\nTamb\u00e9m foi criado um exemplo de simula\u00e7\u00e3o para um sistema n\u00e3o-linear, cuja\nequa\u00e7\u00e3o de diferen\u00e7a \u00e9 dada por\n\nYi[k] =\n2.5Yi[k ? 1]Yi[k ? 2]\n\n1 + Yi[k ? 1]2\n+ Yi[k ? 2]2\n\n+ 0.3 cos 0.5(Yi[k ? 1] + Yi[k ? 2])\n\n+ K1U1[k ? 1] + K1U2[k ? 1] + Q1[k ? 1]\n\n(5.3)\n\nsabendo que i = 1, 2, K1 e K2 s\u00e3o duas constantes definidas na aba dos modelos e\nque K1 = K2 = 1.2.\n\nFigura 46 \u2013 Outro exemplo de gr\u00e1fico gerado.\n\n\n\n106 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nO controlador definido \u00e9 do tipo PNMPC, com Nu = 5, Ny = 40, Qu = 2.0,\nQy = 1.0 e sem restri\u00e7\u00f5es. O cen\u00e1rio foi configurado da seguinte forma:\n\n\u2022 N\u00famero de itera\u00e7\u00f5es igual a 50;\n\n\u2022 Tipo do cen\u00e1rio \u00e9 malha fechada;\n\n\u2022 Refer\u00eancias e perturba\u00e7\u00f5es em:\n\n\u2013 em k = 0 ? refer\u00eancia = 1.0 para as duas sa\u00eddas;\n\n\u2013 em k = 0 ? perturba\u00e7\u00e3o Q1 = random(0, 0.01).\n\nO resultado \u00e9 mostrado na Figura 46. Observa-se que foram selecionados\napenas as vari\u00e1veis controladas e as perturba\u00e7\u00f5es nas lista da aba simula\u00e7\u00e3o, de\nforma que apenas dois gr\u00e1ficos foram gerados.\n\n5.6 \u00cdndice de Desempenho\n\nOs \u00edndices de desempenho s\u00e3o necess\u00e1rios para analisar a robustez do contro-\nlador criado no cen\u00e1rio de simula\u00e7\u00e3o definido pelo usu\u00e1rio. Ferramentas de avalia\u00e7\u00e3o\nda performance do MPC d\u00e3o subs\u00eddios ao engenheiro para melhorar a sintonia dos\ncontroladores ou at\u00e9 mesmo para indicar quando um modelo de predi\u00e7\u00e3o \u00e9 insatisfat\u00f3-\nrio [37]. Os algoritmos implementados para calcular os \u00edndices originaram-se durante o\nmestrado de Paulo Cortez na Universidade Federal de Santa Catarina.\n\nForam implementados os seguintes \u00edndices de desempenho:\n\n\u2022 \u00cdndices de Avalia\u00e7\u00e3o\n\n\u2013 Desvios M\u00e9dios Individuais;\n\n\u2013 \u00cdndices de Estabilidade;\n\n\u2013 Desvio M\u00e9dio Total.\n\n\u2022 \u00cdndices de Sintonia\n\n\u2013 \u00cdndices de Seguimento Relativo;\n\n\u2013 \u00cdndices de Erro de Modelagem;\n\n\u2013 \u00cdndices de Controle Relativos;\n\n\u2013 \u00cdndices de Supress\u00e3o de Movimento.\n\n\n\n5.6. \u00cdndice de Desempenho 107\n\nPortanto, o resultado foi a aba dos \u00cdndices de Desempenho proposta na Figura\n47. Tamb\u00e9m foi implementada uma vari\u00e1vel chamada de Fator de Esquecimento,\nque permite uma avalia\u00e7\u00e3o cont\u00ednua do resultado possibilitando a atualiza\u00e7\u00e3o dos\n\u00edndices [37] em sistemas com tempo de simula\u00e7\u00e3o longos.\n\nFigura 47 \u2013 Aba de \u00edndices de desempenho.\n\nExistem duas formas de calcular os \u00edndices de desempenho. A primeira permite\nque uma simula\u00e7\u00e3o interna da interface tenha seus \u00edndices calculados e mostrados\nna interface, enquanto a outra possibilidade \u00e9 importar para a interface um cen\u00e1rio de\nsimula\u00e7\u00e3o externo.\n\nOs \u00edndices calculados por simula\u00e7\u00f5es internas s\u00e3o feitos clicando no bot\u00e3o\nCalcular, o que abre duas janelas em sequ\u00eancia que perguntam ao usu\u00e1rio qual o\ncen\u00e1rio e qual o controlador que ser\u00e3o utilizados para calcular os \u00edndices. Ap\u00f3s escolher\no cen\u00e1rio e o controlador, basta ao usu\u00e1rio selecionar um dos \u00edndices situados na\nlateral esquerda da aba, clicando no bot\u00e3o \"Mostrar\". O \u00edndice de controle relativo n\u00e3o\n\n\n\n108 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\n\u00e9 dispon\u00edvel para simula\u00e7\u00f5es internas porque alguns par\u00e2metros necess\u00e1rios para o\nseu c\u00e1lculo n\u00e3o foram implementados na interface.\n\nOs arquivos importados apresentam um formato espec\u00edfico e t\u00eam uma extens\u00e3o\nespec\u00edfica, chamada .csv. O usu\u00e1rio escolhe uma pasta contendo n arquivos .csv, cada\num representando um instante de tempo da simula\u00e7\u00e3o externa e depois seleciona\ntamb\u00e9m um arquivo que contenha os ganhos de malha aberta do modelo do processo,\ngeralmente na extens\u00e3o .mat. Assim, os \u00edndices s\u00e3o calculados e segue-se o mesmo\nprocedimento anterior para mostrar o resultado na interface. Na Figura 48 \u00e9 mostrado\no \u00edndice de seguimento relativo calculado a partir de uma simula\u00e7\u00e3o externa.\n\nFigura 48 \u2013 Exemplo de arquivo importado para a interface.\n\n5.7 Biblioteca de Modelos\n\nExistem muitos processos plenamente estudados nas universidades. Sabendo\ndisso foi concebida uma ferramenta com o intuito de possibilitar ao usu\u00e1rio simular esses\nprocessos que apresentam comportamento conhecido, oferecendo uma biblioteca com\ndiferentes modelos armazenados, possibilitando a importa\u00e7\u00e3o dos seus dados para a\n\n\n\n5.7. Biblioteca de Modelos 109\n\ninterface. O foco da biblioteca s\u00e3o processos da ind\u00fastria do petr\u00f3leo e g\u00e1s, visando\nespecializar a ferramenta para processos petroqu\u00edmicos comuns.\n\nPara o usu\u00e1rio acessar essa biblioteca de modelos, foi criada na barra de\nferramentas uma se\u00e7\u00e3o Op\u00e7\u00f5es que apertando em Biblioteca (ver Figura 25) uma nova\njanela \u00e9 aberta, como pode ser visto na Figura 49. Nela est\u00e3o presentes informa\u00e7\u00f5es\nb\u00e1sicas sobre o modelo, al\u00e9m de uma breve descri\u00e7\u00e3o do processo, para apresentar\nao usu\u00e1rio brevemente como o sistema se comporta caso este seja desconhecido.\n\nFigura 49 \u2013 Interface da biblioteca de modelos.\n\nDos modelos mostrados na Figura 49 foram implementados apenas o Tanque\nC\u00f4nico, Tanque Cil\u00edndrico e CSTR1, pois os outros modelos requerem uma breve\nmodifica\u00e7\u00e3o na interface para permitir que sejam adicionadas equa\u00e7\u00f5es est\u00e1ticas para\no c\u00e1lculo de par\u00e2metros do processo. Caso o usu\u00e1rio queira importar um modelo, ele\ndeve primeiramente clicar no modelo na lista posicionada na parte esquerda da tela e\nent\u00e3o apertar no bot\u00e3o Selecionar.\n\n\n\n110 Cap\u00edtulo 5. Interface de Usu\u00e1rio\n\nConsidera\u00e7\u00f5es Finais\n\nEsse cap\u00edtulo explicou detalhadamente cada elemento da interface e como eles\nfuncionam. A interface foi criada para seguir uma sequ\u00eancia l\u00f3gica e cronol\u00f3gica, sem-\npre priorizando a usabilidade do usu\u00e1rio. Cada aba foi implementada individualmente,\npor\u00e9m todas se comunicam constantemente, trocando informa\u00e7\u00f5es relevantes para o\nbom funcionamento do sistema.\n\nAlgumas fun\u00e7\u00f5es n\u00e3o foram detalhadas profundamente, como o controlador PID,\npois foram focados os elementos principais da interface e que t\u00eam papel fundamental\nno seu desenvolvimento. As duas \u00faltimas abas foram desenvolvidas para outro projeto\nenvolvendo controle preditivo aplicado a sistemas embarcados e por isso n\u00e3o s\u00e3o\nobjetos de estudo dessa monografia.\n\n\n\n111\n\n6 Conclus\u00e3o\n\nA implementa\u00e7\u00e3o do projeto conseguiu cumprir as expectativas impostas ao seu\nresultado final. Um dos objetivos era o desenvolvimento de uma interface gr\u00e1fica capaz\nde simular processos industriais integrando com a sintonia de controladores preditivos\npara an\u00e1lises de malha fechada do processo, buscando uma ferramenta robusta mas\nque oferecesse ao usu\u00e1rio uma boa usabilidade. Outro objetivo cumprido foi a cria\u00e7\u00e3o\nde um software com baixo custo de aquisi\u00e7\u00e3o, pois a programa\u00e7\u00e3o foi toda feita em\nPython, uma linguagem de programa\u00e7\u00e3o extremamente eficiente, que diminui o esfor\u00e7o\ndo programador e que possibilitou a implementa\u00e7\u00e3o de uma ferramenta open source.\n\nO produto da implementa\u00e7\u00e3o foi uma interface gr\u00e1fica acess\u00edvel, mas conceitu-\nalmente complexa pelos elementos nela presentes, modelada seguindo os princ\u00edpios\nda engenharia de software e com grande potencial. Parte desse potencial est\u00e1 nas\ndiferentes \u00e1reas de atua\u00e7\u00e3o que a interface pode ser utilizada. Por exemplo, ela pode\nser aproveitada na academia como uma ferramenta did\u00e1tica, os professores podem\nutiliz\u00e1-la em disciplinas que estudam modelagem de processos industriais, controle\npreditivo, simula\u00e7\u00e3o em malha aberta e sistemas realimentados. Com isso, os alunos\npodem ter mais facilidade para adquirir conhecimentos nessas disciplinas, tendo uma\nmaior familiaridade com os assuntos de forma mais intuitiva.\n\nA interface tamb\u00e9m tem um potencial na ind\u00fastria de processos, onde pode ser\naproveitada para testes e simula\u00e7\u00f5es de sistemas complexos. Como dito anteriormente,\n\u00e9 comum que a produ\u00e7\u00e3o industrial seja cont\u00ednua, necessitando o funcionamento\nconstante da planta e interromper esse funcionamento pode gerar perdas financeiras\nconsider\u00e1veis. Por isso, ferramentas que permitem a simula\u00e7\u00e3o de processos s\u00e3o muito\nimportantes pois viabilizam que testes sejam realizadas sem a descontinua\u00e7\u00e3o da\nprodu\u00e7\u00e3o, ocorrendo em paralelo a ela. O que diferencia a ferramenta produzida \u00e9\na possibilidade de uma simula\u00e7\u00e3o que envolva controladores avan\u00e7ados e de criar\ndiversos cen\u00e1rios poss\u00edveis de simula\u00e7\u00e3o, analisando-os simultaneamente para verificar,\npor exemplo, a robustez do controlador em diferente situa\u00e7\u00f5es.\n\nFoi mostrado que \u00e9 poss\u00edvel criar projetos diversos, possibilitando ao usu\u00e1-\nrio formar um acervo de simula\u00e7\u00f5es armazenadas num disco r\u00edgido. Dessa forma, o\nengenheiro pode guardar num banco de dados informa\u00e7\u00f5es referentes a momentos\nespec\u00edficos da produ\u00e7\u00e3o, gerando um banco de dados com o comportamento do sis-\ntema ao longo do tempo. Isso \u00e9 \u00fatil para entender como o processo se comportou com\no passar do tempo, permitindo a verifica\u00e7\u00e3o de problemas quando algum processo foi\nalterado e at\u00e9 mesmo como reagir nessas situa\u00e7\u00f5es analisando simula\u00e7\u00f5es passadas.\n\n\n\n112 Cap\u00edtulo 6. Conclus\u00e3o\n\n6.1 Trabalhos Futuros\n\nMesmo com a finaliza\u00e7\u00e3o da interface gr\u00e1fica, algumas funcionalidades ainda po-\nderiam ser adicionadas para melhorar a performance do sistema. Assim, s\u00e3o sugeridos\nalguns temas que poderiam ser objeto de estudo para implementa\u00e7\u00e3o na interface:\n\n\u2022 Referentes ao MPC:\n\na) Permitir a defini\u00e7\u00e3o de diferentes fun\u00e7\u00f5es objetivo para melhorar o ajuste do\nMPC;\n\nb) Adicionar tamb\u00e9m t\u00e9cnicas de controle adaptativos;\n\nc) Adicionar mais algoritmos preditivos, como o DTC-GPC;\n\n\u2022 Interface do usu\u00e1rio:\n\na) Adi\u00e7\u00e3o de t\u00e9cnicas de identifica\u00e7\u00e3o de sistemas para auxiliar o usu\u00e1rio na\nobten\u00e7\u00e3o do modelo do processo;\n\nb) Adi\u00e7\u00e3o de mais modelos na biblioteca;\n\nc) Adi\u00e7\u00e3o de diagramas de bloco para melhorar cria\u00e7\u00e3o de cen\u00e1rios;\n\nd) C\u00e1lculo de equa\u00e7\u00f5es est\u00e1ticas.\n\nOs pontos propostos n\u00e3o alterariam consideravelmente a interface atual, apenas\nadicionaria novas funcionalidades para incrementar ao sistema, sempre pensando na\nusabilidade da interface e mantendo a qualidade do produto.\n\n\n\n113\n\nRefer\u00eancias\n\n1 BEAUBIEN, J. M.; BAKER, D. P. The use of simulation for training teamwork skills in\nhealth care: how low can you go? Qual Saf Health Care, v. 13, p. i51\u2013i56, 2004. Citado\nna p\u00e1gina 17.\n\n2 GARCIA, C. Modelagem e Simula\u00e7\u00e3o de Processos Industriais e de Sistemas\nEletromec\u00e2nicos. 2. ed. [S.l.]: Universidade de S\u00e3o Paulo, 2005. Citado 2 vezes nas\np\u00e1ginas 17 e 18.\n\n3 LIMA, D. M. Sistema Embarcado de Controle Preditivo para Processos Industriais.\n[S.l.], 2013. Citado 8 vezes nas p\u00e1ginas 17, 32, 54, 56, 57, 58, 59 e 76.\n\n4 LABAKI, J.; CORREA, P. Introdu\u00e7\u00e3o ao Python. Dispon\u00edvel em:&lt;http:\n//www.sr.ifes.edu.br/~secchin/Programacao/Python/python.html>. Citado na p\u00e1gina 18.\n\n5 VENNERS, B. The Making of Python: A Conversation with Guido Van Rossum, Part\nI. Dispon\u00edvel em:&lt;http://www.artima.com/intv/pythonP.html>. Citado na p\u00e1gina 18.\n\n6 LIMA, D. M. Predictor Based Robust Control of Dead Time Processes. [S.l.], 2014.\nCitado 7 vezes nas p\u00e1ginas 21, 23, 24, 26, 30, 35 e 38.\n\n7 CAMACHO, E. F.; BORDONS, C. Model Predictive Control. 2. ed. [S.l.]: Springer,\n2004. Citado na p\u00e1gina 22.\n\n8 LELIc?, M. A.; ZARROP, M. B. Generalized pole-placement self-tuning controller part\n1, basic algorithm. International Journal of Control, v. 46, p. 369\u2013374, 1987. Citado na\np\u00e1gina 22.\n\n9 LINKERS, D.; MAHFONF, M. Advances in model-based predictive control. [S.l.]:\nOxford University Press, 1994. Citado na p\u00e1gina 22.\n\n10 CLARKE, D. W. Application of generalized predictive control to industrial processes.\nIEEE Control Systems Magazine, v. 8, p. 49 \u2013 55, 1988. Citado na p\u00e1gina 22.\n\n11 RICHALET, J. Industrial applications of model based predictive control. Automatica,\nv. 29, p. 1251\u20131274, 1993. Citado na p\u00e1gina 22.\n\n12 RICHALET, J.; AL et. Model predictive heuristic control: Applications to industrial\nprocesses. Automatica, v. 14, p. 413\u2013428, 1978. Citado 2 vezes nas p\u00e1ginas 22 e 30.\n\n13 CAMACHO, E. F.; NORMEY-RICO, J. E. Control of Dead-Time Processes. 1. ed.\n[S.l.]: Springer, 2007. Citado 2 vezes nas p\u00e1ginas 22 e 31.\n\n14 TAKATSU, H.; ITOH, T.; ARAKI, M. Future needs for the control theory in industries.\nreport and topics of the control technology survey in japanese industry. Journal of\nProcess Control, v. 8, p. 369\u2013374, 1998. Citado na p\u00e1gina 23.\n\n15 CUTLER, C.; RAMAKER, B. Dynamic matrix control\u2013a computer control algorithm.\nJoint Automatic Control Conference, v. 17, p. 72, 1979. Citado na p\u00e1gina 30.\n\nhttp://www.sr.ifes.edu.br/~secchin/Programacao/Python/python.html\nhttp://www.sr.ifes.edu.br/~secchin/Programacao/Python/python.html\nhttp://www.artima.com/intv/pythonP.html\n\n\n114 Refer\u00eancias\n\n16 LEE, J. H.; MORARI, M. State-space interpretation of model predictive control.\nAutomatica, v. 30, p. 707\u2013717, 1994. Citado na p\u00e1gina 30.\n\n17 DATTA, A.; OCHOA, J. Adaptive internal model control: Design and stability\nanalysis. Automatica, v. 32, p. 261\u2013266, 1996. Citado na p\u00e1gina 30.\n\n18 CLARKE, D.; MOHTADI, C.; TUFFS, P. Generalized predictive control - part i. the\nbasic algorithm. Automatica, p. 167\u2013148, 1987. Citado na p\u00e1gina 30.\n\n19 KAYSER, R. M. C. D.; CUAWENBERGHE, A. van. Extended prediction\nself-adaptive control. IFAC Symposium on Identification and System Parameter\nEstimation, p. 1317\u20131328, 1985. Citado na p\u00e1gina 30.\n\n20 PLUCENIO, A. A practical approach to predictive control for nonlinear processes.\nIFAC Symposium on Identification and System Parameter Estimation, 2007. Citado 2\nvezes nas p\u00e1ginas 30 e 38.\n\n21 SKOGESTAD, S.; POSTLETHWAITE, I. Multivariable Feedback Control: Analysis\nand Design. 2. ed. [S.l.]: John Wiley, 2005. Citado na p\u00e1gina 31.\n\n22 LIMA, D. M. et al. Improving robustness and disturbance rejection performance\nwith industrial mpc. Anais do XX Congresso Brasileiro de Autom\u00e1tica, 2014. Citado na\np\u00e1gina 37.\n\n23 GROUP, O. M. Unified Modelling Language(UML) Resource Page. Dispon\u00edvel em:\n<http://www.uml.org/>. Citado na p\u00e1gina 45.\n\n24 LEITE, A. Metodologia de Desenvolvimento de Software. Dispon\u00edvel em:\n<http://www.devmedia.com.br/metodologia-de-desenvolvimento-de-software/1903>.\nCitado na p\u00e1gina 45.\n\n25 BARBOSA, W. L. de O.; PASCO, C. D. Processo Unificado e Processo\nUnificado Racional. 2011. Dispon\u00edvel em:&lt;http://www.webartigos.com/artigos/\nprocesso-unificado-e-processo-unificado-racional-up-e-rup/65404/>. Citado na p\u00e1gina\n46.\n\n26 PRESSMAN, R. Engenharia de Software - 7.ed.:. [S.l.]: McGraw Hill Brasil, 2009.\nCitado na p\u00e1gina 46.\n\n27 WAZLAWICK, R. S. An\u00e1lise e projeto de sistemas de informa\u00e7\u00e3o orientados a\nobjetos. 2. ed. [S.l.]: Campus, 2011. Citado 7 vezes nas p\u00e1ginas 47, 48, 49, 50, 52, 57\ne 70.\n\n28 LARMAN, C. Applying UML and Patterns. An Introduction to Object-Oriented and\nDesign and The Unified Process. 3. ed. [S.l.]: Prentice Hall, 2004. Citado 3 vezes nas\np\u00e1ginas 47, 48 e 49.\n\n29 LEAL, F.; ALMEIDA, D. A. de; MONTEVECHI, J. A. B. Uma proposta de t\u00c9cnica de\nmodelagem conceitual para a simula\u00c7\u00c3o atrav\u00c9s de elementos do idef. XL SBPO \u2013 A\nPesquisa Operacional e o uso racional de recursos h\u00eddricos, 2008. Citado na p\u00e1gina\n51.\n\n30 RICARTE, I. L. M. Heran\u00e7a. 2000. Dispon\u00edvel em:&lt;http://www.dca.fee.unicamp.br/\ncourses/PooJava/heranca/index.html>. Citado na p\u00e1gina 57.\n\nhttp://www.uml.org/\nhttp://www.devmedia.com.br/metodologia-de-desenvolvimento-de-software/1903\nhttp://www.webartigos.com/artigos/processo-unificado-e-processo-unificado-racional-up-e-rup/65404/\nhttp://www.webartigos.com/artigos/processo-unificado-e-processo-unificado-racional-up-e-rup/65404/\nhttp://www.dca.fee.unicamp.br/courses/PooJava/heranca/index.html\nhttp://www.dca.fee.unicamp.br/courses/PooJava/heranca/index.html\n\n\nRefer\u00eancias 115\n\n31 ROCHA, G.; FILHO, H.; JURITY, R. Camada de persist\u00eancia de dados para\naplica\u00e7\u00f5es java: O hibernate. Instituto de Matem\u00e1tica \u2013 Universidade Federal da Bahia,\n2009. Citado na p\u00e1gina 59.\n\n32 W3C. Extensible Markup Language (XML). 2008. Dispon\u00edvel em:&lt;https:\n//www.w3.org/TR/REC-xml/>. Citado na p\u00e1gina 59.\n\n33 JONES, C. A.; DRAKE, J. F. L. Python and XML. 1. ed. [S.l.]: O\u2019Reilly, 2002.\nCitado 3 vezes nas p\u00e1ginas 59, 61 e 62.\n\n34 MAGNUM. A Hist\u00f3ria do Python. 2014. Dispon\u00edvel em:&lt;http://mindbending.org/pt/\na-historia-do-python>. Citado na p\u00e1gina 62.\n\n35 DOXYGEN. Doxygen. 2015. Dispon\u00edvel em:&lt;http://www.stack.nl/~dimitri/doxygen/\n>. Citado na p\u00e1gina 62.\n\n36 PYXB. PyXB: Python XML Schema Bindings. 2009. Dispon\u00edvel em:\n<http://pyxb.sourceforge.net/>. Citado na p\u00e1gina 79.\n\n37 CORTEZ, P. E. F. et al. Performance indexes for assistance in retuning multivariable\nmodel predictive controllers. Industry Applications (INDUSCON), 2014 11th IEEE/IAS\nInternational Conference, 2014. Citado 2 vezes nas p\u00e1ginas 106 e 107.\n\nhttps://www.w3.org/TR/REC-xml/\nhttps://www.w3.org/TR/REC-xml/\nhttp://mindbending.org/pt/a-historia-do-python\nhttp://mindbending.org/pt/a-historia-do-python\nhttp://www.stack.nl/~dimitri/doxygen/\nhttp://www.stack.nl/~dimitri/doxygen/\nhttp://pyxb.sourceforge.net/\n\n\n\n\nAp\u00eandices\n\n\n\n\n\n119\n\nAP\u00caNDICE A \u2013 Documentos do\nProjeto de Software\n\nA.1 Requisitos\n\nTabela 5 \u2013 Descri\u00e7\u00e3o do requisito Defini\u00e7\u00e3o dos Par\u00e2metros do Projeto\n\nF1 \u2013 Defini\u00e7\u00e3o dos Par\u00e2metros do Projeto\nDescri\u00e7\u00e3o \u2013 a interface gr\u00e1fica deve permitir que o usu\u00e1rio defina os par\u00e2metros\ndo projeto, como n\u00famero de sa\u00eddas, n\u00famero de entradas, n\u00famero de perturba\u00e7\u00f5es,\nnome do projeto, tempo de amostragem.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 usu\u00e1rio s\u00f3 pode definir valores inteiros para o n\u00famero de entradas, sa\u00eddas\ne perturba\u00e7\u00f5es.\nNF1.2 \u2013 usu\u00e1rio s\u00f3 pode definir valores inteiros positivos para o tempo de amostra-\ngem.\nNF1.3 \u2013 o nome do projeto tem um tamanho m\u00e1ximo de 12 caracteres.\nNF1.4 \u2013 s\u00f3 pode ser iniciado um projeto\n\nTabela 6 \u2013 Descri\u00e7\u00e3o do requisito Defini\u00e7\u00e3o dos Modelos\n\nF2 \u2013 Defini\u00e7\u00e3o dos Modelos\nDescri\u00e7\u00e3o \u2013 a interface gr\u00e1fica deve permitir ao usu\u00e1rio criar, remover ou modificar\nmodelos.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 usu\u00e1rio n\u00e3o pode criar modelos com nome j\u00e1 existente na lista de modelos.\nNF1.2 \u2013 defini\u00e7\u00e3o de diferentes tipos de modelos\n\n\n\n120 AP\u00caNDICE A. Documentos do Projeto de Software\n\nTabela 7 \u2013 Descri\u00e7\u00e3o do requisito Defini\u00e7\u00e3o dos Controladores\n\nF3 \u2013 Defini\u00e7\u00e3o dos Controladores\nDescri\u00e7\u00e3o \u2013 a interface gr\u00e1fica deve permitir ao usu\u00e1rio criar, remover ou modificar\ncontroladores.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 usu\u00e1rio n\u00e3o pode criar controladores com nome j\u00e1 existente na lista de\ncontroladores.\nNF1.2 \u2013 defini\u00e7\u00e3o de diferentes tipos de controlador\n\nTabela 8 \u2013 Descri\u00e7\u00e3o do requisito Configura\u00e7\u00e3o do Cen\u00e1rio de Simula\u00e7\u00e3o\n\nF4 \u2013 Configura\u00e7\u00e3o do Cen\u00e1rio de Simula\u00e7\u00e3o\nDescri\u00e7\u00e3o \u2013 a interface gr\u00e1fica deve permitir ao usu\u00e1rio criar cen\u00e1rios de simula\u00e7\u00f5es,\nconfigurando-os conforme sua necessidade. A configura\u00e7\u00e3o engloba defini\u00e7\u00e3o de\nrefer\u00eancias, perturba\u00e7\u00f5es (entradas em malha aberta), n\u00famero de itera\u00e7\u00f5es da\nsimula\u00e7\u00e3o, os modelos e controladores a serem simulados e condi\u00e7\u00f5es iniciais das\nvari\u00e1veis.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 usu\u00e1rio n\u00e3o pode criar cen\u00e1rios com nome j\u00e1 existente na lista de cen\u00e1rios.\nNF1.2 \u2013 n\u00famero de itera\u00e7\u00f5es deve ser um n\u00famero inteiro positivo\nNF1.3 \u2013 condi\u00e7\u00f5es iniciais devem ser n\u00fameros reais\nNF1.4 \u2013 refer\u00eancias e perturba\u00e7\u00f5es podem ser do tipo degrau, rampa, senoidais ou\nru\u00eddos branco\nNF1.4 \u2013 cen\u00e1rio pode ser simulado em malha aberta ou malha fechada\n\nTabela 9 \u2013 Descri\u00e7\u00e3o do requisito Visualiza\u00e7\u00e3o dos Gr\u00e1ficos de Simula\u00e7\u00e3o\n\nF5 \u2013 Visualiza\u00e7\u00e3o dos Gr\u00e1ficos de Simula\u00e7\u00e3o\nDescri\u00e7\u00e3o \u2013 a interface gr\u00e1fica deve permitir ao usu\u00e1rio verificar os resultados da\nsimula\u00e7\u00e3o na forma de gr\u00e1ficos, de maneira clara e simples.\n\n\n\nA.1. Requisitos 121\n\nTabela 10 \u2013 Descri\u00e7\u00e3o do requisito Calcular A\u00e7\u00e3o de Controle\n\nF6 \u2013 Calcular A\u00e7\u00e3o de Controle\nDescri\u00e7\u00e3o \u2013 o algoritmo de simula\u00e7\u00e3o deve, de forma eficiente quando o cen\u00e1rio\nestiver configurado corretamente, calcular as a\u00e7\u00f5es de controle, otimizando uma\nfun\u00e7\u00e3o custo do tipo quadr\u00e1tica para o c\u00e1lculo utilizando o algoritmo MPC.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 caso ocorra de o tempo de c\u00e1lculo ultrapassar o tempo de amostragem\nseguidamente, um alarme deve ser acionado.\nNF1.2 \u2013 caso ocorram problemas de otimiza\u00e7\u00e3o, deve-se tomar provid\u00eancias para\nn\u00e3o causar problemas de estabilidade.\nNF1.3 \u2013 op\u00e7\u00e3o de v\u00e1rios algoritmos MPC.\n\nTabela 11 \u2013 Descri\u00e7\u00e3o do requisito Calcular \u00cdndices de Desempenho\n\nF7 \u2013 Calcular \u00cdndices de Desempenho\nDescri\u00e7\u00e3o \u2013 o algoritmo deve ser capaz de calcular os \u00edndices de desempenho de\numa dada simula\u00e7\u00e3o, analisando a robustez do sistema.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 usu\u00e1rio pode calcular os \u00edndices atrav\u00e9s de uma simula\u00e7\u00e3o realizada na\npr\u00f3pria interface ou pode exportar dados a partir de arquivo .xsd com um formato\nespec\u00edfico que contem dados de uma simula\u00e7\u00e3o externa.\nNF1.2 \u2013 Alguns \u00edndices s\u00e3o exclusivos de simula\u00e7\u00f5es exportadas, pois alguns \u00edndices\napresentam vari\u00e1veis que n\u00e3o ser\u00e3o implementadas na interface.\n\nTabela 12 \u2013 Descri\u00e7\u00e3o do requisito Implementa\u00e7\u00e3o da Simula\u00e7\u00e3o\n\nF8 \u2013 Implementa\u00e7\u00e3o da Simula\u00e7\u00e3o\nDescri\u00e7\u00e3o \u2013 o algoritmo deve fazer os c\u00e1lculos de sa\u00edda a partir de a\u00e7\u00f5es de controle\ncalculadas anteriormente, de forma a mostrar o resultado da simula\u00e7\u00e3o de forma\ncorreta e coerente.\n\nTabela 13 \u2013 Descri\u00e7\u00e3o do requisito Gerenciamento do Banco de Dados\n\nF9 \u2013 Gerenciamento do Banco de Dados\nDescri\u00e7\u00e3o \u2013 o algoritmo deve gerenciar o banco de dados de forma a ser capaz\nde salvar ou abrir documentos XML para o uso, armazenando as informa\u00e7\u00f5es\nnecess\u00e1rias para que o usu\u00e1rio possa reutilizar um projeto criado posteriormente.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 os dados guardados devem seguir o padr\u00e3o definido no schema\nNF1.2 \u2013 caso alguma informa\u00e7\u00e3o esteja incorreta, gerar uma janela de aviso\n\n\n\n122 AP\u00caNDICE A. Documentos do Projeto de Software\n\nTabela 14 \u2013 Descri\u00e7\u00e3o do requisito Gerenciar Dados do Processo\n\nF10 \u2013 Gerar Dados do Processo\nDescri\u00e7\u00e3o \u2013 algoritmo necess\u00e1rio para gerenciar todos os dados internos, como\nlistas das vari\u00e1veis, dos modelos, controladores, cen\u00e1rio, al\u00e9m de dados essenciais\ncomo tempo de amostragem, refer\u00eancias, perturba\u00e7\u00f5es, etc.\n\nTabela 15 \u2013 Descri\u00e7\u00e3o do requisito Atualizar Dados do Processo\n\nF11 \u2013 Atualizar Dados do Processo\nDescri\u00e7\u00e3o \u2013 o sistema deve ser capaz de atualizar os dados do processo sempre que\nalgo for alterado no projeto, de forma a manter os dados armazenados corretamente\ne com coer\u00eancia \u00e0s a\u00e7\u00f5es do usu\u00e1rio.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 dados armazenados de forma inv\u00e1lido n\u00e3o devem ser atualizados.\n\nTabela 16 \u2013 Descri\u00e7\u00e3o do requisito Salvar Dados da Simula\u00e7\u00e3o\n\nF13 \u2013 Salvar Dados da Simula\u00e7\u00e3o\nDescri\u00e7\u00e3o \u2013 o sistema deve ser capaz de armazenar os resultados das simula\u00e7\u00f5es\npara que seja poss\u00edvel a plotagem dos gr\u00e1ficos de simula\u00e7\u00e3o.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 os dados devem ser salvos em listas, com tamanho igual ao n\u00famero de\nsa\u00eddas do processo.\n\nTabela 17 \u2013 Descri\u00e7\u00e3o do requisito Abrir Dados de Simula\u00e7\u00f5es Armazenadas\n\nF14 \u2013 Abrir Dados de Simula\u00e7\u00f5es Armazenadas\nDescri\u00e7\u00e3o \u2013 o sistema deve ser capaz de ler os resultados das simula\u00e7\u00f5es para que\nseja poss\u00edvel a plotagem dos gr\u00e1ficos de simula\u00e7\u00e3o.\nRestri\u00e7\u00f5es N\u00e3o-Funcionais\nNF1.1 \u2013 caso algum cen\u00e1rio n\u00e3o tenha sido simulado, gerar uma janela de aviso\ncaso o sistema tente abrir os dados de simula\u00e7\u00e3o deste cen\u00e1rio.\n\n\n\tFolha de aprova\u00e7\u00e3o\n\tAgradecimentos\n\tResumo\n\tAbstract\n\tLista de ilustra\u00e7\u00f5es\n\tLista de tabelas\n\tLista de abreviaturas e siglas\n\tSum\u00e1rio\n\tIntrodu\u00e7\u00e3o\n\tControlador Preditivo Baseado em Modelo\n\tVis\u00e3o Geral do MPC\n\tEstrat\u00e9gia do MPC\n\tElementos do MPC\n\tModelo de Predi\u00e7\u00e3o\n\tResposta Livre e Resposta For\u00e7ada\n\tFun\u00e7\u00e3o Objetivo\n\tObtendo a Lei de Controle\n\n\n\tGeneralized Predictive Controller\n\tAlgoritmo GPC\n\n\tDynamic Matrix Control\n\tComputando as Predi\u00e7\u00f5es\n\tObtendo Resposta Livre Recursivamente\n\n\tPractical Non-Linear Model Predictive Controller\n\tObtendo a Resposta For\u00e7ada\n\tObtendo a Resposta Livre\n\tAlgoritmo PNMPC\n\n\n\t Metodologia de Desenvolvimento de Software\n\tEtapa de Concep\u00e7\u00e3o\n\tRequisitos do Projeto\n\tCasos de Uso\n\n\tEtapa de Elabora\u00e7\u00e3o e Constru\u00e7\u00e3o\n\tExpans\u00e3o dos Casos de Uso\n\tModelagem Conceitual\n\tContratos\n\tDiagrama de Sequ\u00eancia\n\tDiagrama de Colabora\u00e7\u00e3o e de Classes\n\tDiagrama de Estados\n\n\tCamada de Persist\u00eancia\n\tExtensible Markup Language (XML)\n\tXML Schema\n\n\tLinguagem de Programa\u00e7\u00e3o - Python\n\n\tRequisitos da interface e Projeto de software\n\tRequisitos da Interface\n\tLevantamento dos Casos de Uso\n\tExpans\u00e3o dos Casos de Uso\n\tModelo conceitual\n\tContratos e Diagrama de Sequ\u00eancia\n\tDiagrama de Colabora\u00e7\u00e3o e de Classes\n\tImplementa\u00e7\u00e3o\n\tQt Designer\n\n\tCamada de Persist\u00eancia\n\n\tInterface de Usu\u00e1rio\n\tCaracter\u00edsticas do Projeto\n\tModelo\n\tControlador\n\tCen\u00e1rio\n\tSimula\u00e7\u00e3o\n\t\u00cdndice de Desempenho\n\tBiblioteca de Modelos\n\n\tConclus\u00e3o\n\tTrabalhos Futuros\n\n\tRefer\u00eancias\n\tAp\u00eandices\n\tDocumentos do Projeto de Software\n\tRequisitos"}]}}}