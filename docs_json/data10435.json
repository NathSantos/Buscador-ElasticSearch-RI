{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.14773"}, {"@name": "filename", "#text": "21145_240542.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DE SANTA CATARINA\n\nPROGRAMA DE P\u00d3S-GRADUA\u00c7\u00c3O EM CI\u00caNCIA DA\n\nCOMPUTA\u00c7\u00c3O\n\nArliones Stevert Hoeller Junior\n\nGer\u00eancia do Consumo de Energia Dirigida pela\n\nAplica\u00e7\u00e3o em Sistemas Embarcados\n\nDisserta\u00e7\u00e3o submetida \u00e0 Universidade Federal de Santa Catarina como parte dos\n\nrequisitos para a obten\u00e7\u00e3o do grau de Mestre em Ci\u00eancia da Computa\u00e7\u00e3o.\n\nProf. Dr. Ant\u00f4nio Augusto Medeiros Fr\u00f6hlich\n\nFlorian\u00f3polis, Fevereiro de 2007\n\n\n\nGer\u00eancia do Consumo de Energia Dirigida pela Aplica\u00e7\u00e3o em\n\nSistemas Embarcados\n\nArliones Stevert Hoeller Junior\n\nEsta Disserta\u00e7\u00e3o foi julgada adequada para a obten\u00e7\u00e3o do t\u00edtulo de Mestre em Ci\u00eancia da\n\nComputa\u00e7\u00e3o, \u00e1rea de concentra\u00e7\u00e3o Computa\u00e7\u00e3o Paralela e Distribu\u00edda e aprovada em sua\n\nforma final pelo Programa de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o.\n\nProf. Dr. Rog\u00e9rio Cid Bastos\n\nBanca Examinadora\n\nProf. Dr. Ant\u00f4nio Augusto Medeiros Fr\u00f6hlich\n\nProf. Dr. Fl\u00e1vio Rech Wagner\n\nProf. Dr. R\u00f4mulo Silva de Oliveira\n\nProf. Dr. Mauro Roisenberg\n\n\n\nAgradecimentos\n\nAgrade\u00e7o primeiramente a minha fam\u00edlia pelo apoio incondicional du-\n\nrante meus estudos. Especialmente agrade\u00e7o aos meus pais, Arliones e Elisabete, e meu\n\nirm\u00e3o, Alexandre, pelo amor, carinho, aten\u00e7\u00e3o e compreens\u00e3o, e por aceitar e entender\n\num filho/irm\u00e3o por muitas vezes ausente.\n\nGostaria tamb\u00e9m de agradecer aos meus amigos, muitos dos quais tenho\n\ncomo irm\u00e3os, que sempre estiveram dispostos a ajudar. A eles agrade\u00e7o pelos momentos\n\nde divers\u00e3o e alegria, certamente essenciais para manter-se motivado e centrado em qual-\n\nquer momento da vida. Muito obrigado Beavis, Cabe\u00e7a, Carlucci, Daniel, Gabriela, Ivan,\n\nPelotas, Petr\u00facio, Rafa, Roberta, Pretinho, Zeh, e muitos outros, aos quais pe\u00e7o desculpas\n\npor n\u00e3o ter inclu\u00eddo o nome na lista.\n\nAgrade\u00e7o tamb\u00e9m aos meus colegas de laborat\u00f3rio (LISHA - Laborat\u00f3-\n\nrio de Integra\u00e7\u00e3o Software/Hardware) pelo companheirismo, aux\u00edlio e valorosas discus-\n\ns\u00f5es sobre o meu trabalho. Em especial ao Lucas, Hugo e Fauze, que sempre estiveram\n\npr\u00f3ximos a mim e deveriam, sem d\u00favida alguma, estar citados no par\u00e1grafo anterior.\n\nAgrade\u00e7o ao Guto, meu orientador, pela orienta\u00e7\u00e3o e ensinamentos, sem\n\nos quais a realiza\u00e7\u00e3o deste trabalho n\u00e3o seria poss\u00edvel. Obrigado pelo esfor\u00e7o despendido\n\npara tornar todas as pessoas que passam pelo LISHA \u00f3timos pesquisadores. Gra\u00e7as a\n\neste esfor\u00e7o que foi poss\u00edvel pertencer a um grupo de pesquisa s\u00e9rio, bem sucedido e\n\nconceituado. Obrigado por ter orientado este trabalho e obrigado pela amizade.\n\nFinalmente, agrade\u00e7o n\u00e3o \u00e0 Universidade Federal de Santa Catarina,\n\nmas sim a todos aqueles respons\u00e1veis por tornar esta institui\u00e7\u00e3o uma das mais bem con-\n\nceituadas da Am\u00e9rica Latina. Agrade\u00e7o especialmente \u00e0 Verinha (Vera L\u00facia Sodr\u00e9 Tei-\n\n\n\niv\n\nxeira), secret\u00e1ria do Programa de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o, ao Prof.\n\nDr. Raul Wazlawick, coordenador deste programa durante quase todo o tempo que estive\n\nvinculado a ele e ao Prof. Dr. Rog\u00e9rio Cid Bastos, atual coordenador do programa, pelo\n\nesfor\u00e7o em proporcionar aos seus alunos um curso de mestrado de alta qualidade.\n\n\n\nv\n\n\u00c0 minha fam\u00edlia.\n\n\n\nResumo\n\nBaixo consumo de energia \u00e9 um dos principais requisitos no projeto de\n\nsistemas embarcados, principalmente quando estes s\u00e3o alimentados por baterias. T\u00e9cni-\n\ncas que t\u00eam sido aplicadas com efic\u00e1cia em sistemas de computa\u00e7\u00e3o gen\u00e9rica n\u00e3o t\u00eam\n\natingido o mesmo \u00eaxito em sistemas embarcados, ou devido \u00e0 falta de flexibilidade, ou\n\ndevido aos requisitos para sua implanta\u00e7\u00e3o (volumes de mem\u00f3ria e processamento), que\n\npodem tornar proibitiva sua aplica\u00e7\u00e3o nestes dispositivos.\n\nEste trabalho define uma interface simples e uniforme para ger\u00eancia de\n\nenergia dirigida pela aplica\u00e7\u00e3o em sistemas embarcados. Esta interface disponibiliza ao\n\nprogramador da aplica\u00e7\u00e3o a flexibilidade de configurar os modos de opera\u00e7\u00e3o de baixo\n\nconsumo dos componentes em uso, conforme sua necessidade. A implementa\u00e7\u00e3o buscou\n\ngarantir a portabilidade desta aplica\u00e7\u00e3o a um baixo custo em termos de uso de mem\u00f3ria\n\ne processamento. Este trabalho utiliza Redes de Petri Hier\u00e1rquicas para especificar os\n\nprocedimentos de troca de modos de opera\u00e7\u00e3o dos componentes, utilizando os pontos de\n\nrefinamento destas redes para representar as rela\u00e7\u00f5es entre os diversos componentes do\n\nsistema. O uso das Redes de Petri permitiu analisar o mecanismo de ger\u00eancia de energia\n\npara verificar seu funcionamento e a inexist\u00eancia de impasses.\n\nA extens\u00e3o da interface dos componentes e a inclus\u00e3o dos procedimen-\n\ntos de troca de modo de opera\u00e7\u00e3o foram implementadas como um aspecto. Um prot\u00f3tipo\n\nfoi desenvolvido utilizando o sistema operacional Embedded Parallel Operating System\n\n(EPOS) e estudos de caso foram realizados para demonstrar a usabilidade desta inter-\n\nface.\n\n\n\nAbstract\n\nLow power consumption is among the main requirements of embedded\n\nsystems design, specially when these systems are battery-powered. Power management\n\ntechniques that have been successfully applied on general purpose computing systems\n\nhaven\u2019t achieved the same results on the embedded field. This happens either due to the\n\nlack of flexibility of such techniques or due to the resources (memory and processing)\n\nrequired to use them.\n\nWithin this context, this work defines a simple and uniform interface\n\nfor application-driven power management of embedded system. This interface allows\n\napplication programmers to configure low power operating modes of each component\n\nin order to satisfy their needs. Hierarchical Petri Nets are used to specify the operating\n\nmode transition procedures of components, using the refinement of these Petri nets to\n\nrepresent system components\u2019 interactions. The use of Petri Nets allowed the analysis\n\nof the proposed power management mechanism to verify its behavior and the absence of\n\ndeadlocks.\n\nThe implementation of this mechanism focused on ensuring applicati-\n\nons portability, while not incurring in unnecessary memory or processing overheads. The\n\nextension of the system components to implement the power management mechanism\n\nwas done using aspect-oriented programming, thus not modifying original components.\n\nA prototype of the power manager was developed using the EMBEDDED PARALLEL OPE-\n\nRATING SYSTEM (EPOS) and case studies were performed to show the usability of the\n\nmechanism.\n\n\n\nSum\u00e1rio\n\nResumo vi\n\nAbstract vii\n\nLista de Figuras 3\n\nLista de Tabelas 5\n\nLista de Siglas 6\n\n1 Introdu\u00e7\u00e3o 1\n\n1.1 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n\n1.2 Estrutura do Texto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n\n2 Ger\u00eancia do Consumo de Energia 7\n\n2.1 Consumo de Energia em Sistemas Computacionais . . . . . . . . . . . . 8\n\n2.2 T\u00e9cnicas de Redu\u00e7\u00e3o do Consumo de Energia no Projeto de Hardware . . 10\n\n2.3 Dynamic Voltage Scaling - DVS . . . . . . . . . . . . . . . . . . . . . . 13\n\n2.4 Hiberna\u00e7\u00e3o de Recursos . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n2.5 Estrat\u00e9gias Para Ger\u00eancia de Energia . . . . . . . . . . . . . . . . . . . . 16\n\n2.6 Adapta\u00e7\u00f5es Multi-Camada . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n2.7 Interfaces e Padr\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n2.8 O Papel da Aplica\u00e7\u00e3o na Ger\u00eancia do Consumo de Energia . . . . . . . . 23\n\n2.9 Interfaces de Ger\u00eancia de Energia Dirigida Pela Aplica\u00e7\u00e3o em Sistemas\n\nEmbarcados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\n\n\n2\n\n3 O sistema de Ger\u00eancia de Energia Proposto 28\n\n3.1 Interface de Ger\u00eancia do Consumo de Energia para Componentes de Soft-\n\nware e Hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\n3.2 Redes de Troca de Modos de Opera\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . 35\n\n3.3 Propaga\u00e7\u00e3o de Mensagens . . . . . . . . . . . . . . . . . . . . . . . . . 40\n\n3.3.1 Propaga\u00e7\u00e3o Hier\u00e1rquica de Mensagens . . . . . . . . . . . . . . 42\n\n3.3.2 Compartilhamento de Recursos . . . . . . . . . . . . . . . . . . 45\n\n4 Implementa\u00e7\u00e3o do Gerente de Energia Proposto 47\n\n4.1 Ambiente Experimental . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n4.1.1 Embedded Parallel Operating System - EPOS . . . . . . . . . . . 48\n\n4.1.2 Ambiente de Hardware . . . . . . . . . . . . . . . . . . . . . . . 49\n\n4.2 Extens\u00e3o dos Componentes Para Inclus\u00e3o da API . . . . . . . . . . . . . 52\n\n4.3 Resolu\u00e7\u00e3o Est\u00e1tica das Redes de Troca de Modos de Opera\u00e7\u00e3o . . . . . . 54\n\n4.4 Mecanismo de Propaga\u00e7\u00e3o de Mensagens . . . . . . . . . . . . . . . . . 58\n\n5 Estudos de Caso 62\n\n5.1 Term\u00f4metro . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n\n5.2 M\u00f3dulo de Sensoriamento Mica Mote2 . . . . . . . . . . . . . . . . . . . 66\n\n5.3 Discuss\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n\n6 Conclus\u00e3o 72\n\nRefer\u00eancias Bibliogr\u00e1ficas 76\n\nA Rede de Troca de Modos de Opera\u00e7\u00e3o Gereralizada 82\n\n\n\nLista de Figuras\n\n2.1 Progress\u00e3o da densidade de pot\u00eancia em semicondutores (figura adaptada\n\nde [POL 99]). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n\n2.2 Reestrutura\u00e7\u00e3o de portas l\u00f3gicas. Adaptada de [VEN 05] . . . . . . . . . 12\n\n3.1 Meios de acesso \u00e0 API de ger\u00eancia do consumo de energia. . . . . . . . . 31\n\n3.2 Comportamento da rede generalizada de troca de modos de opera\u00e7\u00e3o. . . 36\n\n3.3 Refinamento com rede de Petri hier\u00e1rquica para o componente CMAC. . . 39\n\n3.4 Aplica\u00e7\u00f5es hipot\u00e9ticas com ger\u00eancia do consumo de energia dirigido pela\n\naplica\u00e7\u00e3o. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n\n3.5 Rede completa de troca para o modo FULL do componente CMAC. . . . . 43\n\n3.6 Procedimentos para troca de modo de opera\u00e7\u00e3o. . . . . . . . . . . . . . . 44\n\n3.7 Dois sensores diferentes compartilham o mesmo ADC. . . . . . . . . . . 45\n\n4.1 Adaptador de cen\u00e1rio no EPOS . . . . . . . . . . . . . . . . . . . . . . . 52\n\n4.2 Adaptador de cen\u00e1rio Power_Manager. . . . . . . . . . . . . . . . . . 53\n\n4.3 Adaptador de cen\u00e1rio Power_Manager. . . . . . . . . . . . . . . . . . 53\n\n4.4 Seq\u00fc\u00eancia para gera\u00e7\u00e3o de c\u00f3digo a partir das redes de modos de opera\u00e7\u00e3o. 56\n\n4.5 Seq\u00fc\u00eancia de simula\u00e7\u00e3o com c\u00f3digo sendo gerado. . . . . . . . . . . . . 57\n\n4.6 Declara\u00e7\u00f5es de componentes utilizados na implementa\u00e7\u00e3o do componente\n\nCMAC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n\n4.7 C\u00f3digo final para a simula\u00e7\u00e3o da figura 4.5. . . . . . . . . . . . . . . . . 58\n\n4.8 Procedimento de troca de modo de opera\u00e7\u00e3o (implementa\u00e7\u00e3o da rede ge-\n\nneralizada). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n\n\n\n4\n\n4.9 Adaptador de cen\u00e1rio Power_Manager. . . . . . . . . . . . . . . . . . 59\n\n5.1 Hardware do prot\u00f3tipo constru\u00eddo. . . . . . . . . . . . . . . . . . . . . . 63\n\n5.2 Amarra\u00e7\u00f5es dos modos de opera\u00e7\u00e3o. . . . . . . . . . . . . . . . . . . . . 64\n\n5.3 A aplica\u00e7\u00e3o Term\u00f4metro. . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n\n5.4 Diagrama de hardware do Mica2 Mote. . . . . . . . . . . . . . . . . . . 66\n\n5.5 Aplica\u00e7\u00e3o para o Mica2 Mote. . . . . . . . . . . . . . . . . . . . . . . . 67\n\n5.6 Amarra\u00e7\u00f5es dos modos de opera\u00e7\u00e3o. . . . . . . . . . . . . . . . . . . . . 68\n\n\n\nLista de Tabelas\n\n3.1 Sem\u00e2ntica dos modos de opera\u00e7\u00e3o universais. . . . . . . . . . . . . . . . 33\n\n4.1 Pot\u00eancia e corrente drenada para alguns dos modos de opera\u00e7\u00e3o do AT-\n\nMEGA128. Adaptada de Kellner [KEL 06]. . . . . . . . . . . . . . . . . 50\n\n4.2 Pot\u00eancia e corrente drenada do CC1000 operando a uma tens\u00e3o de 3.3 V\n\ne frequ\u00eancia de transmiss\u00e3o de 868 MHz. . . . . . . . . . . . . . . . . . 51\n\n5.1 Ger\u00eancia de energia pelo EPOS para o estudo de caso Term\u00f4metro. . . . . 65\n\n5.2 Ger\u00eancia de energia pelo EPOS para o estudo de caso Mica2 Mote. . . . . 69\n\n\n\nLista de Siglas\n\nACPI Advanced Configuration and Power Interface\n\nADC Analog-to-Digital Converter\n\nAML ACPI Machine Language\n\nAOP Aspect Oriented Programming\n\nAOSD Application Oriented System Design\n\nAPI Application Programmer Interface\n\nAPM Advanced Power Management\n\nCMAC Configurable MAC\n\nCoS Class of Service\n\nCPU Central Processing Unit\n\nDPM Dynamic Power Management\n\nDRAM Dynamic Random Access Memory\n\nDVS Dynamic Voltage Scaling\n\neCos embedded Configurable operating system\n\nEPOS Embedded Prallel Operating System\n\nGPRS General Packet Radio Service\n\n\n\n7\n\nHAL Hardware Abstraction Layer\n\nISO International Organization for Standardization\n\nMAC Media Access Control\n\nNIC Network Interface Card\n\nNoC Network-on-Chip\n\nPNML Petri Net Modeling Language\n\nPNTD Petri Net Type Definition\n\nQoS Quality of Service\n\nSPI Serial Peripheral Interface\n\nSRAM Static Random Access Memory\n\nTCP/IP Transmission Control Protocol / Internet Protocol\n\nTLB Translation Lookaside Buffer\n\nUART Universal Asynchronous Receiver/Transmitter\n\nUML Unified Modeling Language\n\n\n\nCap\u00edtulo 1\n\nIntrodu\u00e7\u00e3o\n\nSistemas embarcados s\u00e3o plataformas computacionais utilizadas para\n\nmonitorar e/ou controlar os espa\u00e7os nos quais est\u00e3o inseridos. Estes espa\u00e7os podem ser\n\nm\u00e1quinas, motores, dispositivos eletr\u00f4nicos, ambientes f\u00edsicos (e.g, m\u00f3dulos de sensori-\n\namento em uma rede de sensores sem-fio monitorando um habitat), etc. Como grande\n\nparte deles s\u00e3o alimentados por baterias, \u00e9 muito importante que estes sistemas sejam\n\npower-aware, i.e., capazes de gerenciar sua pot\u00eancia, possibilitando assim a diminui\u00e7\u00e3o\n\ndo consumo de energia e o controle do aquecimento. Contudo, a maioria das metodolo-\n\ngias, t\u00e9cnicas e padr\u00f5es de software para este tipo de ger\u00eancia n\u00e3o se mostram vi\u00e1veis para\n\nsistemas embarcados que sofrem de severas limita\u00e7\u00f5es de recursos. Isto ocorre porque\n\naquelas estrat\u00e9gias foram concebidas focando sistemas de prop\u00f3sito geral, onde custos\n\nadicionais de processamento ou mem\u00f3ria s\u00e3o geralmente insignificantes.\n\nACPI [HP 04] e APM [INT 96] s\u00e3o os padr\u00f5es mais utilizados pela\n\nind\u00fastria hoje para especificar a interface entre software e hardware no que diz respeito\n\na controle do consumo de energia. Embora muito usados em dispositivos para sistemas\n\nde prop\u00f3sito geral, eles imp\u00f5em requisitos de recursos adicionais de hardware ou capa-\n\ncidade de processamento que freq\u00fcentemente inviabilizam seu uso em sistemas embarca-\n\ndos. Componentes de sistemas embarcados apresentam uma grande variedade de carac-\n\nter\u00edsticas que podem ser configuradas para reduzir o consumo de energia. Padr\u00f5es como\n\nestes (ACPI e APM) poderiam restringir esta configurabilidade. Al\u00e9m destes padr\u00f5es,\n\n\n\n2\n\ndiversas outras t\u00e9cnicas foram desenvolvidas para tratar o consumo de energia de siste-\n\nmas eletr\u00f4nicos. A maioria delas s\u00e3o sistemas din\u00e2micos que re\u00fanem informa\u00e7\u00e3o atrav\u00e9s\n\nda an\u00e1lise do comportamento do sistema, e usam esta informa\u00e7\u00e3o para guiar as decis\u00f5es\n\nacerca da ger\u00eancia de energia (Dynamic Power Management - DPM) [BEN 98]. Exem-\n\nplos de tais t\u00e9cnicas s\u00e3o heur\u00edsticas para aplica\u00e7\u00e3o de Dynamic Voltage Scaling (DVS),\n\nque, dinamicamente, ajustam a fonte de tens\u00e3o e freq\u00fc\u00eancia do processador para diminuir\n\no consumo de energia.\n\nEmbora geralmente baseados em microcontroladores relativamente sim-\n\nples, dispositivos embarcados tamb\u00e9m permitem gerenciar energia provendo diferentes\n\nmodos de opera\u00e7\u00e3o e um grande conjunto de caracter\u00edsticas configur\u00e1veis do hardware.\n\nPor exemplo, um microcontrolador ATMEGA [ATM 04a], da Atmel, oferece oito modos\n\nde opera\u00e7\u00e3o diferentes e caracter\u00edsticas configur\u00e1veis para quase todos seus componentes\n\n(e.g., ADC, UART, etc) que t\u00eam efeito direto no consumo de energia. Varia\u00e7\u00f5es na tens\u00e3o\n\n(e.g., opera\u00e7\u00e3o em 3 V e 5 V) e na freq\u00fc\u00eancia do processador tamb\u00e9m s\u00e3o poss\u00edveis com o\n\naux\u00edlio de um circuito externo. Outros processadores como ARM, XSCALE e POWERPC\n\npossuem uma s\u00e9rie muito mais complexa de modos de opera\u00e7\u00e3o e recursos para grada\u00e7\u00e3o\n\nde tens\u00e3o e freq\u00fc\u00eancia. De fato, o hardware tipicamente usado em sistemas embarcados\n\npermite que o consumo de energia seja eficientemente gerenciado, mas os ambientes de\n\nsoftware existentes (sistemas operacionais e bibliotecas para sistemas embarcados) n\u00e3o\n\nprov\u00e9m suporte adequado para este fim.\n\nA maioria dos sistemas operacionais para plataformas embarcadas s\u00e3o\n\ncompostas por simples camadas de abstra\u00e7\u00e3o de hardware (Hardware Abstraction Layers\n\n- HAL) e oferecem pouco (ou nenhum) suporte de alto-n\u00edvel para ger\u00eancia de ener-\n\ngia [POL 04]. Na maioria destes sistemas \u00e9 esperado que as pr\u00f3prias aplica\u00e7\u00f5es im-\n\nplementem opera\u00e7\u00f5es de controle de consumo de energia acessando a HAL. Dentre os\n\nproblemas que surgem com estes mecanismos est\u00e1 o comprometimento da portabilidade\n\ne o aumento da complexidade da aplica\u00e7\u00e3o, j\u00e1 que o programador desta \u00e9 for\u00e7ado a adap-\n\ntar seu c\u00f3digo-fonte \u00e0s peculiaridades do hardware que est\u00e1 utilizando.\n\nNeste contexto surgem os sistemas operacionais baseados em compo-\n\nnentes [SMA 95, FOR 97]. Estes sistemas buscam dividir o sistema operacional em arte-\n\n\n\n3\n\nfatos de software independentes (i.e., componentes) que implementam as funcionalidades\n\ndesejadas (e.g., comunica\u00e7\u00e3o, processamento). Estes componentes podem ser utilizados\n\npara abstrair diferentes camadas do sistema como, por exemplo, utilizando um compo-\n\nnente para implementar cada camada de uma pilha de protocolos de comunica\u00e7\u00e3o. Estas\n\nsepara\u00e7\u00f5es associadas a regras de composi\u00e7\u00e3o de componentes t\u00eam permitido a gera\u00e7\u00e3o\n\nde sistemas operacionais especializados para diferentes contextos, al\u00e9m de facilitar os\n\nprocessos de desenvolvimento e manuten\u00e7\u00e3o destes sistemas. Estes sistemas s\u00e3o atrativos\n\ndo ponto de vista das aplica\u00e7\u00f5es ao passo que disponibilizam interfaces de programa\u00e7\u00e3o\n\n(API) geralmente simplificadas e que abstraem um maior n\u00famero de funcionalidades.\n\nSendo assim, este trabalho define uma interface de alto n\u00edvel para ge-\n\nr\u00eancia do consumo de energia de aplica\u00e7\u00f5es embarcadas, em sistemas baseados em com-\n\nponentes, que n\u00e3o implica em custos adicionais excessivos de processamento e mem\u00f3ria\n\nenquanto mant\u00e9m a portabilidade das aplica\u00e7\u00f5es e a facilidade no seu desenvolvimento. O\n\nfoco principal deste trabalho est\u00e1 nos sistemas ditos profundamente embarcados, ou seja,\n\nsistemas computacionais embarcados, de pequeno porte e com funcionalidade espec\u00edfica,\n\ncujos requisitos de pre\u00e7o, tamanho e desempenho levam ao emprego de dispositivos de\n\nhardware extremamente simples, como microcontroladores que operam a baixas freq\u00fc\u00ean-\n\ncias (muitas vezes na ordem de KHz) e que possuam pouca quantidade de mem\u00f3ria (na\n\nordem de KBytes).\n\nNesta proposta, a portabilidade \u00e9 atingida atrav\u00e9s da defini\u00e7\u00e3o de uma\n\ninterface compacta e uniforme de ger\u00eancia de energia para componentes de software e\n\nhardware. Al\u00e9m de m\u00e9todos para o acesso pela aplica\u00e7\u00e3o, a interface \u00e9 composta de uma\n\nestrutura que permite ao programador configurar os modos de opera\u00e7\u00e3o que pretende uti-\n\nlizar em sua aplica\u00e7\u00e3o. Para facilitar o desenvolvimento das aplica\u00e7\u00f5es foi adotado um\n\nmecanismo para especificar as rela\u00e7\u00f5es entre diferentes componentes do sistema. Este\n\nmecanismo \u00e9 baseado em Redes de Petri Hier\u00e1rquicas [PET 77], utilizando os pontos de\n\nespecializa\u00e7\u00e3o na hierarquia das redes para representar trocas de mensagens entre com-\n\nponentes do sistema. Atrav\u00e9s do mecanismo de trocas de mensagens \u00e9 poss\u00edvel coordenar\n\nos componentes para que as trocas entre modos de opera\u00e7\u00e3o sejam realizadas de forma\n\ncorreta. A facilita\u00e7\u00e3o no desenvolvimento das aplica\u00e7\u00f5es adv\u00e9m do fato de o programa-\n\n\n\n4\n\ndor apenas gerenciar os componentes que utiliza diretamente no sistema. Solicitando a\n\ntroca de modo de opera\u00e7\u00e3o destes componentes, o sistema fica respons\u00e1vel por propagar\n\nmensagens aos demais componentes do sistema.\n\n1.1 Objetivos\n\nO objetivo principal deste trabalho \u00e9 explorar ger\u00eancia de energia di-\n\nrigida pela aplica\u00e7\u00e3o para permitir o controle do consumo de energia em sistemas pro-\n\nfundamente embarcados sem implicar em adi\u00e7\u00e3o excessiva de custos de processamento\n\ne consumo de mem\u00f3ria e mantendo a portabilidade das aplica\u00e7\u00f5es. Para tanto, o sistema\n\nde ger\u00eancia de energia proposto permite que a aplica\u00e7\u00e3o expresse quando certos compo-\n\nnentes de software n\u00e3o est\u00e3o sendo utilizados, fazendo com que o sistema troque estes\n\ncomponentes para estados de mais baixo consumo.\n\nNo desenvolvimento deste sistema foram identificados desafios a serem\n\nvencidos para permitir a transpar\u00eancia de v\u00e1rios aspectos relativos a, principalmente, dife-\n\nren\u00e7as arquiteturais entre dispositivos de hardware e \u00e0 concorr\u00eancia no acesso a recursos\n\ndo sistema. S\u00e3o eles:\n\nDefini\u00e7\u00e3o de uma interface uniforme de ger\u00eancia do consumo de energia: Uma inter-\n\nface foi especificada para permitir que a troca entre modos de opera\u00e7\u00e3o dos diversos\n\ncomponentes do sistema possa ser realizada com a mesma sem\u00e2ntica, contribuindo\n\nassim para a portabilidade. A interface definida \u00e9 simples, i.e., possui um conjunto\n\nm\u00ednimo de m\u00e9todos para ger\u00eancia de energia, e uniforme, i.e., a mesma interface\n\n\u00e9 apresentada por todos os componentes do sistema. Esta interface ainda apresenta\n\num mecanismo de configura\u00e7\u00e3o dos modos de opera\u00e7\u00e3o para cada componente,\n\npermitindo que o programador da aplica\u00e7\u00e3o selecione os modos de opera\u00e7\u00e3o mais\n\nrelevantes para sua aplica\u00e7\u00e3o.\n\nPropaga\u00e7\u00e3o de trocas de modo de opera\u00e7\u00e3o: Em sistemas baseados em componentes\n\n\u00e9 comum que programadores utilizem componentes de alto-n\u00edvel, i.e, componentes\n\nque abstraem implementa\u00e7\u00f5es complexas e que, muito freq\u00fcentemente, agregam\n\n\n\n5\n\ne utilizam outros componentes do sistema. Seria contraproducente exigir que o\n\nprogramador da aplica\u00e7\u00e3o conhe\u00e7a todos os componentes envolvidos na implemen-\n\nta\u00e7\u00e3o destes componentes de alto-n\u00edvel e gerencie o consumo de energia de todos\n\neles individualmente. Para permitir uma ger\u00eancia completa do consumo de energia\n\nfoi necess\u00e1rio estabelecer um mecanismo pelo qual as trocas de modo de opera\u00e7\u00e3o\n\nsejam propagadas atrav\u00e9s da hierarquia de componentes do sistema.\n\nEspecifica\u00e7\u00e3o de um mecanismo de propaga\u00e7\u00e3o das trocas de modos de opera\u00e7\u00e3o:\n\nFoi identificada a necessidade de especificar o procedimento de troca de modos de\n\nopera\u00e7\u00e3o dos componentes a fim de permitir que esta troca n\u00e3o gere inconsist\u00eancias\n\nno sistema. Para tanto, Redes de Petri Hier\u00e1rquicas foram utilizadas para descrever\n\nestes procedimentos. Para n\u00e3o agregar custos de processamento e mem\u00f3ria em\n\ntempo de execu\u00e7\u00e3o, uma an\u00e1lise destas redes \u00e9 realizada em tempo de compila\u00e7\u00e3o,\n\nevitando a necessidade de um interpretador no sistema.\n\n1.2 Estrutura do Texto\n\nO cap\u00edtulo 2 apresenta um levantamento do estudo realizado sobre ge-\n\nr\u00eancia do consumo de energia em sistemas computacionais. Este estudo tenta deixar claro\n\na grande variedade de t\u00e9cnicas desenvolvidas por pesquisadores e pela ind\u00fastria para o\n\ncontrole de consumo de energia. O cap\u00edtulo relata t\u00e9cnicas utilizadas para controlar o\n\nconsumo de energia em diferentes n\u00edveis do projeto de um sistema computadorizado, i.e.,\n\ndo hardware \u00e0 aplica\u00e7\u00e3o, ressaltando a necessidade da integra\u00e7\u00e3o dos mecanismos utili-\n\nzados nas diferentes camadas, atrav\u00e9s das t\u00e9cnicas denominadas cross-layer adaptations.\n\nO cap\u00edtulo 3 apresenta a proposta deste trabalho para ger\u00eancia do con-\n\nsumo de energia em sistemas embarcados. Este cap\u00edtulo descreve o mecanismo de especi-\n\nfica\u00e7\u00e3o das trocas de modo de opera\u00e7\u00e3o, a interface para ger\u00eancia do consumo de energia\n\nem componentes de software e hardware e o mecanismo de propaga\u00e7\u00e3o de mensagens de\n\nger\u00eancia de energia. O cap\u00edtulo 4 descreve a implementa\u00e7\u00e3o dos componentes da proposta\n\ndeste trabalho no sistema operacional EPOS [FR\u00f6 01]. O cap\u00edtulo 5 apresenta a an\u00e1lise\n\n\n\n6\n\ndos resultados obtidos em dois estudos de caso envolvendo implementa\u00e7\u00f5es reais. O ca-\n\np\u00edtulo 6 finaliza o trabalho, sumarizando os resultados alcan\u00e7ados e discutindo futuras\n\naplica\u00e7\u00f5es e extens\u00f5es do sistema desenvolvido.\n\n\n\nCap\u00edtulo 2\n\nGer\u00eancia do Consumo de Energia\n\nO avan\u00e7o das tecnologias aplicadas na produ\u00e7\u00e3o de computadores, em-\n\nbora permitam a produ\u00e7\u00e3o de dispositivos muito mais r\u00e1pidos e vers\u00e1teis, fazem com que\n\nestes equipamentos passem a consumir muita energia. Conforme pode ser observado na\n\nfigura 2.1, a densidade de pot\u00eancia1 em dispositivos semicondutores cresce em escala\n\nexponencial conforme progride seu n\u00edvel de integra\u00e7\u00e3o. O aumento da densidade de po-\n\nt\u00eancia nestes dispositivos traz \u00e0 tona diversos problemas relativos \u00e0 vida-\u00fatil dos chips, a\n\nalternativas de resfriamento e, de maior interesse neste trabalho, ao consumo de energia.\n\n1\n\n1000\n\n100\n\n10\n\n1.5 \u00b5 1 \u00b5 0.7 \u00b5 0.5 \u00b5 0.35 \u00b5 0.25 \u00b5 0.18 \u00b5 0.13 \u00b5 0.1 \u00b5 0.07 \u00b5\n\nw\nat\n\nts\n/c\n\nm\n2\n\nD\nen\n\nsi\nda\n\nde\n d\n\ne \nP\n\not\nen\n\nci\na\n\ni386 i486\n\nPentium\n\nPentium Pro\n\nHot Plate\n\nPentium II\n\nPentium III\n\nTecnologia (tamanho do transistor)\n\nReator Nuclear Propulsor de Foguete\n\nSuperficie Solar\n\nFigura 2.1: Progress\u00e3o da densidade de pot\u00eancia em semicondutores (figura adaptada\n\nde [POL 99]).\n\n1Densidade de pot\u00eancia \u00e9 a quantidade de pot\u00eancia produzida por uma fonte de energia em uma deter-\n\nminada \u00e1rea ou volume.\n\n\n\n8\n\nNeste cap\u00edtulo ser\u00e1, primeiramente, caracterizado o problema de con-\n\nsumo de energia em sistemas computacionais, apresentando como estes dispositivos con-\n\nsomem energia e em que pontos se pode agir para diminuir este consumo. Em seguida \u00e9\n\napresentada uma revis\u00e3o bibliogr\u00e1fica de t\u00e9cnicas de ger\u00eancia de energia, incluindo t\u00e9c-\n\nnicas de redu\u00e7\u00e3o do consumo de energia desde o projeto do hardware at\u00e9 a gera\u00e7\u00e3o de\n\naplica\u00e7\u00f5es, por\u00e9m com maior \u00eanfase em t\u00e9cnicas que envolvam software, i.e., com parti-\n\ncipa\u00e7\u00e3o do sistema operacional, compiladores ou aplica\u00e7\u00f5es.\n\n2.1 Consumo de Energia em Sistemas Computacionais\n\nPot\u00eancia e energia s\u00e3o comumente definidas em termos do trabalho realizado\n\npor um sistema. Energia \u00e9 o total de trabalho que um sistema realiza em um\n\nper\u00edodo de tempo, enquanto pot\u00eancia \u00e9 a taxa em que o sistema realiza este\n\ntrabalho. [VEN 05]\n\nAdaptando a defini\u00e7\u00e3o acima ao contexto de computadores, o trabalho\n\nseria definido pela execu\u00e7\u00e3o de programas, pot\u00eancia representaria a taxa em que este tra-\n\nbalho \u00e9 realizado e energia seria o total de energia el\u00e9trica consumida ou dissipada como\n\ncalor pelo sistema em um per\u00edodo de tempo. Neste contexto \u00e9 importante diferenciar po-\n\nt\u00eancia e energia porque, nem sempre, redu\u00e7\u00e3o de pot\u00eancia implica em redu\u00e7\u00e3o de energia.\n\nEmbora a varia\u00e7\u00e3o de uma afete a outra de forma linear (equa\u00e7\u00e3o 2.1), algumas medidas\n\nque reduzem pot\u00eancia (P ) podem afetar o tempo de execu\u00e7\u00e3o (T ) de um mesmo con-\n\njunto de tarefas em um processador, resultando em quantidades similares de energia total\n\nconsumida (E). Por exemplo, reduzir a freq\u00fc\u00eancia de um processador pela metade pode-\n\nria, grosseiramente, reduzir a pot\u00eancia pela metade. Por\u00e9m o sistema ter\u00e1 consumido a\n\nmesma quantidade de energia se essa redu\u00e7\u00e3o na freq\u00fc\u00eancia de opera\u00e7\u00e3o dobrar o tempo\n\nnecess\u00e1rio para realizar o mesmo conjunto de tarefas.\n\nE =\n\n? t2\nt1\n\nP dt (2.1)\n\nNo contexto de sistemas embarcados, em especial os m\u00f3veis, o impor-\n\n\n\n9\n\ntante \u00e9 reduzir a energia total consumida pelo sistema, permitindo assim o aumento da\n\nvida-\u00fatil de suas baterias. Para permitir o controle deste quantidade de energia, t\u00e9cnicas\n\ntentam reduzir os dois tipos de pot\u00eancia existentes nestes dispositivos: pot\u00eancia din\u00e2mica\n\n(Dynamic Power), que \u00e9 decorrente da atividade do sistema, e pot\u00eancia est\u00e1tica (Leakage\n\nPower), que \u00e9 a energia consumida mesmo quando um dispositivo est\u00e1 inativo.\n\nExistem duas fontes de pot\u00eancia din\u00e2mica: altera\u00e7\u00f5es nas cargas dos ca-\n\npacitores e curto-circuitos. Curto-circuitos, que ocorrem quando transistores adjacentes\n\nde diferentes polaridades trocam de estado simultaneamente, representam apenas 10% a\n\n15% do total de pot\u00eancia din\u00e2mica. J\u00e1 as altera\u00e7\u00f5es nas cargas dos capacitores, que ocorre\n\ndevido \u00e0 atividade do circuito (carregando e descarregando os capacitores), \u00e9 a fonte pri-\n\nm\u00e1ria de pot\u00eancia din\u00e2mica. Como al\u00e9m de n\u00e3o serem muito expressivos no c\u00e1lculo\n\nda pot\u00eancia din\u00e2mica total, os curto-circuitos s\u00e3o provenientes do projeto do hardware e,\n\nem muitos casos, inevit\u00e1veis, o c\u00e1lculo da pot\u00eancia din\u00e2mica \u00e9 normalmente simplificado.\n\nEsta simplifica\u00e7\u00e3o \u00e9 demonstrada na equa\u00e7\u00e3o 2.2 que apresenta a pot\u00eancia din\u00e2mica como\n\no c\u00e1lculo das altera\u00e7\u00f5es nas cargas dos capacitores do circuito (Pdin). Este valor \u00e9 definido\n\ncomo sendo o produto da capacit\u00e2ncia (C), do quadrado da tens\u00e3o (V 2), da freq\u00fc\u00eancia de\n\nopera\u00e7\u00e3o do circuito (f ) e do fator de atividade (a), que representa o n\u00famero de transi\u00e7\u00f5es\n\nl\u00f3gicas entre 0 e 1 ou 1 e 0 que ocorrem em um chip [VEN 05].\n\nPdinamica ? aCV\n2f (2.2)\n\nSucintamente, a pot\u00eancia est\u00e1tica dos circuitos semicondutores adv\u00e9m\n\nda imperfei\u00e7\u00e3o dos transistores. Transistores s\u00e3o dispositivos semicondutores com tr\u00eas\n\nterminais: gatilho (gate), fonte (source) e dreno (drain). O transistor opera controlando\n\no fluxo de corrente entre seus terminais fonte e dreno baseado na tens\u00e3o aplicada em\n\nseu terminal gatilho. Em situa\u00e7\u00e3o ideal, estes transistores deveriam operar liberando o\n\nfluxo de corrente apenas quando a tens\u00e3o aplicada no gatilho atingisse um determinado\n\nlimite. Contudo, os transistores permitem que uma determinada quantidade de corrente\n\nflua entre os terminais fonte e dreno mesmo quando a tens\u00e3o aplicada est\u00e1 abaixo do limite\n\ndesejado. Esta corrente, conhecida como corrente de fuga, \u00e9 respons\u00e1vel pela pot\u00eancia\n\n\n\n10\n\nest\u00e1tica, conforme demonstra a equa\u00e7\u00e3o 2.3. Este tipo de pot\u00eancia est\u00e1 se tornando a\n\nfonte dominante da pot\u00eancia total em circuitos [POL 99].\n\nPestatica = V If uga (2.3)\n\nRetomando o exemplo anterior da diminui\u00e7\u00e3o da freq\u00fc\u00eancia de opera-\n\n\u00e7\u00e3o de um processador, agora fica claro que simplesmente reduzir pela metade a freq\u00fc\u00ean-\n\ncia de opera\u00e7\u00e3o de um circuito, na verdade, pode aumentar o consumo de energia deste.\n\nIsso ocorre porque, al\u00e9m de n\u00e3o alterar o consumo de energia devido \u00e0 pot\u00eancia din\u00e2mica,\n\neste dispositivo ficaria por mais tempo consumindo energia devido \u00e0 pot\u00eancia est\u00e1tica.\n\nSendo assim, tentativas de reduzir a pot\u00eancia destes circuitos t\u00eam que abordar, al\u00e9m da\n\nfreq\u00fc\u00eancia, outras grandezas que influem no consumo de energia, como a tens\u00e3o de ope-\n\nra\u00e7\u00e3o, que implica em diminui\u00e7\u00e3o de ambos os tipos de pot\u00eancia, e a capacit\u00e2ncia dos\n\ncircuitos, que reduz a pot\u00eancia din\u00e2mica.\n\n2.2 T\u00e9cnicas de Redu\u00e7\u00e3o do Consumo de Energia no Pro-\n\njeto de Hardware\n\nH\u00e1 v\u00e1rias medidas que s\u00e3o utilizadas para diminuir pot\u00eancia no projeto\n\nde hardware. Estas medidas v\u00e3o desde a concep\u00e7\u00e3o dos transistores e circuitos at\u00e9 a es-\n\npecifica\u00e7\u00e3o das hierarquias de mem\u00f3ria. Uma t\u00e9cnica bastante utilizada no processo de\n\nconcep\u00e7\u00e3o de transistores \u00e9 a altera\u00e7\u00e3o de tamanho (sizing). Quanto menores os transis-\n\ntores, menos pot\u00eancia din\u00e2mica eles consomem. Esta diminui\u00e7\u00e3o, contudo, aumenta o\n\natraso na propaga\u00e7\u00e3o de sinais. Sendo assim, pesquisadores t\u00eam trabalhado em algorit-\n\nmos para determinar pontos cr\u00edticos em circuitos, definindo atrasos aceit\u00e1veis para cada\n\nponto, permitindo estimar o tamanho ideal dos transistores de modo a n\u00e3o violar estes\n\natrasos [PEN 02, EBE 04]. T\u00e9cnicas de reordena\u00e7\u00e3o procuram identificar transistores que\n\ntrocam de estado muito freq\u00fcentemente e posiciona-los pr\u00f3ximos \u00e0s sa\u00eddas dos circuitos,\n\nevitando que suas trocas de estados afetem outros transistores e, em um efeito domin\u00f3,\n\naumente ainda mais a pot\u00eancia [KUR 04, SUL 04]. Outras t\u00e9cnicas utilizadas para reduzir\n\n\n\n11\n\npot\u00eancia em circuitos s\u00e3o Half Frequency e Half Swing Clocks. Half Frequency ajusta os\n\ncircuitos para que seus eventos ocorram tanto na borda de subida quanto na de descida do\n\nclock, permitindo a redu\u00e7\u00e3o da freq\u00fc\u00eancia de opera\u00e7\u00e3o a metade. T\u00e9cnicas de Half Swing\n\nClocks usam sinais de clock de baixa tens\u00e3o, o que permite uma redu\u00e7\u00e3o quadr\u00e1tica da\n\npot\u00eancia din\u00e2mica (equa\u00e7\u00e3o 2.2).\n\nV\u00e1rios trabalhos exploram t\u00e9cnicas para economizar energia no n\u00edvel de\n\nprojeto de circuitos l\u00f3gicos. Venkatachalam descreve m\u00e9todos de organiza\u00e7\u00e3o de portas\n\nl\u00f3gicas mais eficientes em termos de pot\u00eancia [VEN 05]. Como exemplo, ele cita o caso\n\nda implementa\u00e7\u00e3o de um circuito l\u00f3gico AND com quatro entradas. Ele analisa os efeitos\n\nde implementar este circuito encadeando portas AND de 2 entradas (figura 2.2a) ou organi-\n\nzando estas portas em uma estrutura de \u00e1rvore (figura 2.2b). Neste exemplo, em circuitos\n\nonde todas as entradas (A, B, C, D) possuem as mesmas probabilidades de adquirir valor\n\nl\u00f3gico 1 ou 0, uma estrutura em cadeia (figura 2.2a) seria mais indicada, pois apresentaria\n\nmenos trocas de estados nas sa\u00eddas das portas l\u00f3gicas, diminuindo o fator de atividade e,\n\npor conseq\u00fc\u00eancia, a pot\u00eancia din\u00e2mica (equa\u00e7\u00e3o 2.2). Esta topologia pode, contudo, ge-\n\nrar atrasos na propaga\u00e7\u00e3o dos sinais e, eventualmente, valores incorretos na sa\u00edda, sendo\n\nnecess\u00e1rio a inser\u00e7\u00e3o de flip-flops ou registradores para sincronizar os sinais. Devido\n\nao grande n\u00famero de possibilidades de implementa\u00e7\u00e3o de transistores e organiza\u00e7\u00e3o de\n\ncircuitos l\u00f3gicos, pesquisadores t\u00eam trabalhado para desenvolver algoritmos capazes de\n\nmapear modelos de circuitos definidos no n\u00edvel de portas l\u00f3gicas em diferentes estruturas\n\nde portas ou diferentes tecnologias de implementa\u00e7\u00e3o [CHE 04, LI 04, RUT 01]. Outros\n\npontos pesquisados no \u00e2mbito do projeto de hardware de baixa pot\u00eancia s\u00e3o o desenvol-\n\nvimento de flip-flops e l\u00f3gica de controle de menor pot\u00eancia.\n\nAl\u00e9m dos circuitos, os mecanismos de interconex\u00e3o afetam a pot\u00eancia,\n\nj\u00e1 que \u00e9 atrav\u00e9s dos meios de interconex\u00e3o que se d\u00e1 a maior parte da atividade el\u00e9trica.\n\nT\u00e9cnicas para evitar o aumento do consumo de energia em mecanismos de interconex\u00e3o\n\nenvolvem Bus Encoding, que busca diminuir as trocas de estado nos fios destes barra-\n\nmentos, e inser\u00e7\u00e3o de shield wires para evitar interfer\u00eancias entre fios (Crosstalk). Outras\n\nt\u00e9cnicas tentam eliminar os mecanismos de codifica\u00e7\u00e3o, permitindo maiores trocas de es-\n\ntado nos fios, por\u00e9m operando em baixas tens\u00f5es, diminuindo a pot\u00eancia do barramento.\n\n\n\n12\n\nA\n\nB\nC\n\nD\nF\n\n(a)\n\nF\n\nA\n\nB\n\nC\n\nD\n\n(b)\n\nFigura 2.2: Reestrutura\u00e7\u00e3o de portas l\u00f3gicas. Adaptada de [VEN 05]\n\nTamb\u00e9m s\u00e3o adotadas t\u00e9cnicas de segmenta\u00e7\u00e3o de barramentos que permitem que os si-\n\nnais atinjam somente os setores do barramento onde s\u00e3o necess\u00e1rios. Todas estas t\u00e9cnicas\n\nprev\u00eaem a exist\u00eancia de uma arquitetura em que v\u00e1rias unidades funcionais compartilhem\n\num ou mais barramentos. A fim de tratar problemas como atraso (devido a concorr\u00eancia e\n\nhandshaking) e pot\u00eancia existentes neste modelo, pesquisadores t\u00eam desenvolvido redes\n\nintra-chip (Network-on-Chip - NOC). Estas t\u00e9cnicas permitem aplicar mecanismos de re-\n\ndu\u00e7\u00e3o de atraso e controle de tr\u00e1fego \u00e0 interconex\u00e3o de unidades funcionais dentro de um\n\nchip, impactando em melhoria do desempenho e redu\u00e7\u00e3o do consumo de energia.\n\nAs mem\u00f3rias tamb\u00e9m contribuem para o consumo de energia em sis-\n\ntemas. Algumas t\u00e9cnicas para reduzir este consumo focam na divis\u00e3o das mem\u00f3rias\n\nem subsistemas menores, permitindo que bancos de mem\u00f3ria troquem seus modos de\n\nopera\u00e7\u00e3o para estados de menor consumo de energia separadamente. Divis\u00f5es de baixa\n\ngranularidade associadas a t\u00e9cnicas de software que aumentam a localidade espacial de\n\ndados permitem concentrar o uso da mem\u00f3ria a um pequeno conjunto dos bancos defini-\n\ndos, permitindo que os demais bancos entrem em modos de opera\u00e7\u00e3o de menor pot\u00eancia.\n\nAumentando a granularidade desta divis\u00e3o, cada um dos bancos de mem\u00f3ria poderiam\n\nser divididos em \u201csub-bancos\u201d, permitindo ativar apenas os sub-bancos relevantes em\n\ncada acesso \u00e0 mem\u00f3ria. Outras t\u00e9cnicas exploram diferentes hierarquias de mem\u00f3ria e\n\nestrat\u00e9gias para a ger\u00eancia destas hierarquias. Devido a quest\u00f5es como desempenho e\n\ncusto, diferentes tecnologias s\u00e3o utilizadas em diferentes n\u00edveis da hierarquia de mem\u00f3-\n\nria, incluindo SRAMs (Static Random Access Memories) para caches, DRAM (Dynamic\n\n\n\n13\n\nRandom Access Memories) para mem\u00f3ria principal e, em algumas situa\u00e7\u00f5es, discos r\u00edgi-\n\ndos para swap, entre outras. Basicamente, quanto mais alto o n\u00edvel do acesso \u00e0 mem\u00f3ria,\n\nmaior o atraso e a quantidade de energia consumida. Portanto, t\u00e9cnicas que diminuem a\n\nquantidade de faltas nas caches e nas TLBs (Translation Lookaside Buffers) dos proces-\n\nsadores contribuem para um menor consumo de energia.\n\n2.3 Dynamic Voltage Scaling - DVS\n\nUma das t\u00e9cnicas mais eficientes para reduzir o consumo de energia em\n\nsistemas computacionais \u00e9 a redu\u00e7\u00e3o da tens\u00e3o de opera\u00e7\u00e3o destes circuitos. Por\u00e9m, como\n\na diminui\u00e7\u00e3o do n\u00edvel de tens\u00e3o acarreta atrasos na propaga\u00e7\u00e3o de sinais (gate delays), \u00e9\n\nnecess\u00e1rio reduzir tamb\u00e9m a freq\u00fc\u00eancia de opera\u00e7\u00e3o para manter a sincronia do circuito.\n\nO processo de conciliar varia\u00e7\u00f5es de tens\u00e3o e freq\u00fc\u00eancia \u00e9 chamado de Dynamic Voltage\n\nScaling (DVS) [CHA 92]. A diminui\u00e7\u00e3o da tens\u00e3o de opera\u00e7\u00e3o \u00e9 bastante eficiente, pois\n\nafeta linearmente a pot\u00eancia est\u00e1tica (equa\u00e7\u00e3o 2.3) e quadraticamente a pot\u00eancia din\u00e2-\n\nmica (equa\u00e7\u00e3o 2.2), sendo largamente utilizada, principalmente em processadores. Como\n\nDVS tem um efeito direto sobre o desempenho, trabalhos nesta \u00e1rea t\u00eam desenvolvido\n\nheur\u00edsticas que exploram trocas entre consumo de energia e desempenho com base no\n\ncomportamento do sistema e/ou aplica\u00e7\u00f5es. A aplica\u00e7\u00e3o destas heur\u00edsticas \u00e9, contudo,\n\ncomplexa devido \u00e0 natureza imprevis\u00edvel dos workloads, al\u00e9m do indeterminismo e das\n\nanomalias apresentadas por sistemas reais. Tradicionalmente, as t\u00e9cnicas DVS s\u00e3o clas-\n\nsificadas em baseadas em intervalos, inter-processos ou intra-processos.\n\nT\u00e9cnicas baseadas em intervalos de tempo monitoram o comportamento\n\ndo sistema e, conhecendo a taxa de utiliza\u00e7\u00e3o do dispositivo no \u00faltimo intervalo, estimam\n\na taxa de utiliza\u00e7\u00e3o para o pr\u00f3ximo ajustando a velocidade e a tens\u00e3o. O que diferencia as\n\nt\u00e9cnicas desta categoria \u00e9 o modo de estimar a taxa futura de utiliza\u00e7\u00e3o. Um dos primeiros\n\nalgoritmos baseados em intervalos foi o PAST [WEI 94]. O PAST mede periodicamente o\n\ntempo de ociosidade do processador, diminuindo sua velocidade sempre que este tempo\n\nultrapassa um limite. De modo similar, sempre que o processador permanece ocupado\n\npor um tempo maior que um limite, a velocidade \u00e9 aumentada. Como o PAST baseia suas\n\n\n\n14\n\ndecis\u00f5es apenas na janela de tempo mais recente ele est\u00e1 muito suscept\u00edvel a erros. V\u00e1rias\n\nextens\u00f5es foram feitas a este algoritmo para aumentar sua efici\u00eancia. Grande parte destas\n\nmodifica\u00e7\u00f5es permitiram basear sua decis\u00e3o em uma maior quantidade de informa\u00e7\u00e3o,\n\naumentando a janela de tempo analisada [GOV 95]. Contudo, todos estes algoritmos\n\nassumem que os workloads s\u00e3o regulares, o que raramente \u00e9 verdade.\n\nT\u00e9cnicas inter-tarefa (intertask) definem diferentes modos de opera\u00e7\u00e3o\n\npara cada tarefa. Assim, o escalonador do sistema, ao realizar a troca de contexto, con-\n\nfigura os dispositivos de hardware com base no comportamento passado da aplica\u00e7\u00e3o\n\na ser carregada. Neste contexto, Weissel e Bellosa propuseram o Process Cruise Con-\n\ntrol [WEI 02a]. Esta t\u00e9cnica utiliza contadores de eventos, presentes em processadores\n\nmodernos, para monitorar a ocorr\u00eancia dos eventos que impactam no consumo de ener-\n\ngia (e.g., per\u00edodos de computa\u00e7\u00e3o intensiva, acessos a mem\u00f3ria, uso de barramentos).\n\nA t\u00e9cnica ajusta a configura\u00e7\u00e3o do hardware consultando uma tabela que relaciona dife-\n\nrentes comportamentos (obtidos atrav\u00e9s de simula\u00e7\u00e3o) com a freq\u00fc\u00eancia mais baixa em\n\nque a tarefa possa executar sem comprometer o n\u00edvel de desempenho desejado. Uma das\n\ndesvantagens destas t\u00e9cnicas est\u00e1 relacionada ao fato de que, normalmente, o workload\n\ndas tarefas \u00e9 desconhecido. Isso implica em conhecimento profundo das tarefas (e.g.,\n\nutilizando simula\u00e7\u00f5es para o pior caso) ou a basear as decis\u00f5es utilizando workloads an-\n\nteriores. Se os workloads forem irregulares, estim\u00e1-los com efic\u00e1cia \u00e9 dif\u00edcil. Alguns\n\ntrabalhos tentam minimizar este problema classificando os workloads e utilizando dife-\n\nrentes heur\u00edsticas para cada classe [FLA 01].\n\nT\u00e9cnicas intra-tarefa (intratask) gerenciam o consumo de energia du-\n\nrante a execu\u00e7\u00e3o das tarefas. Uma das t\u00e9cnicas intra-tarefa \u00e9 run-time voltage hop-\n\nping [LEE 00]. Essa t\u00e9cnica divide cada tarefa em fatias de tempo de tamanho fixo e,\n\npara cada fatia de tempo, um algoritmo atribui a velocidade mais baixa que permite \u00e0\n\ntarefa executar dentro do tempo desejado. Esse algoritmo, contudo, \u00e9 pessimista, j\u00e1 que\n\nutiliza simula\u00e7\u00f5es baseadas no pior caso de execu\u00e7\u00e3o para calcular as velocidades em que\n\na tarefa ir\u00e1 executar, fazendo com que o tempo de execu\u00e7\u00e3o seja sempre muito parecido,\n\nsen\u00e3o igual, ao obtido na simula\u00e7\u00e3o para o pior caso. H\u00e1 varia\u00e7\u00f5es desta t\u00e9cnica, entre\n\nelas cabe citar PACE [LOR 01] e Stochastic DVS [GRU 01]. Estas duas t\u00e9cnicas utilizam\n\n\n\n15\n\nmodelos probabil\u00edsticos para estimar o workload do ciclo de execu\u00e7\u00e3o de uma tarefa ba-\n\nseado nos ciclos anteriores. Contudo, elas utilizam modelos simplificados do consumo de\n\nenergia que podem n\u00e3o corresponder ao consumo de energia em sistemas reais.\n\nAs tr\u00eas t\u00e9cnicas intra-tarefa citadas acima s\u00e3o implementadas no n\u00edvel\n\ndo sistema operacional. Contudo, h\u00e1 outras t\u00e9cnicas desta categoria que s\u00e3o implemen-\n\ntadas ao n\u00edvel de compiladores. Uma destas t\u00e9cnicas realiza profiling de aplica\u00e7\u00f5es para\n\nidentificar diferentes fluxos e tempos de execu\u00e7\u00e3o, inserindo instru\u00e7\u00f5es para alterar a ve-\n\nlocidade de opera\u00e7\u00e3o do processador no in\u00edcio de cada fluxo, fazendo com que as tarefas\n\nconsumam menos energia quando n\u00e3o executam segundo o pior caso [SHI 01]. Program\n\ncheckpointing [AZE 02] marca tarefas com pontos de verifica\u00e7\u00e3o e define tempos de exe-\n\ncu\u00e7\u00e3o para os trechos da tarefa entre estes pontos. Atrav\u00e9s de profiling ele determina\n\no n\u00famero m\u00e9dio ciclos entre cada ponto, inserindo c\u00f3digo para ajustar a velocidade do\n\nprocessador em cada ponto de verifica\u00e7\u00e3o. Outra t\u00e9cnica [HSU 03] realiza profiling das\n\naplica\u00e7\u00f5es considerando todas as possibilidades de freq\u00fc\u00eancia de opera\u00e7\u00e3o em diferentes\n\nregi\u00f5es de um programa, construindo uma tabela que relaciona a freq\u00fc\u00eancia com o im-\n\npacto no tempo de execu\u00e7\u00e3o e no consumo de energia para cada regi\u00e3o. A partir desta\n\ntabela, s\u00e3o selecionadas as combina\u00e7\u00f5es de regi\u00f5es e freq\u00fc\u00eancias que economizam mais\n\nenergia sem ultrapassar um limite de tempo para execu\u00e7\u00e3o.\n\n2.4 Hiberna\u00e7\u00e3o de Recursos\n\nComo ressaltado na se\u00e7\u00e3o 2.1, componentes de sistemas computadori-\n\nzados consomem energia mesmo quando est\u00e3o ociosos devido \u00e0 pot\u00eancia est\u00e1tica. Para\n\nreduzir o consumo de energia nestes casos s\u00e3o empregadas t\u00e9cnicas de hiberna\u00e7\u00e3o de\n\nrecursos. Estas t\u00e9cnicas implementam heur\u00edsticas que \u201cdesligam\u201d os dispositivos em pe-\n\nr\u00edodos ociosos. Este \u201cdesligamento\u201d normalmente utiliza modos de opera\u00e7\u00e3o que inibem\n\na passagem de corrente pelo circuito do dispositivo. O impacto da hiberna\u00e7\u00e3o tempor\u00e1ria\n\n\u00e9 normalmente bastante expressivo no consumo de energia, por\u00e9m h\u00e1 alguns cuidados\n\nque devem ser tomados. Al\u00e9m da detec\u00e7\u00e3o dos per\u00edodos de ociosidade, as heur\u00edsticas t\u00eam\n\nque levar em considera\u00e7\u00e3o dois fatores: muitos componentes consomem uma quantidade\n\n\n\n16\n\nmaior de energia para desligar e religar; e o acesso a componentes desligados acarreta\n\natrasos que podem impactar significativamente no desempenho do sistema.\n\nO processo de hiberna\u00e7\u00e3o e reinicializa\u00e7\u00e3o do processador de um sis-\n\ntema normalmente \u00e9 muito custoso em termos de processamento e consumo de energia,\n\nsendo esta t\u00e9cnica utilizada apenas quando existe a certeza de que o sistema permanecer\u00e1\n\nhibernado por um per\u00edodo muito longo. Contudo, a hiberna\u00e7\u00e3o de perif\u00e9ricos \u00e9 um re-\n\ncurso bastante utilizado e eficaz. Sendo assim, t\u00e9cnicas de hiberna\u00e7\u00e3o de recursos t\u00eam\n\nfocado principalmente em dois tipos de dispositivos: discos e placas de rede (com ou sem\n\nfio). T\u00e9cnicas de ger\u00eancia de disco implementadas em sistemas operacionais tradicionais\n\nprocuram reduzir a velocidade ou parar a rota\u00e7\u00e3o quando o tempo de ociosidade do disco\n\natinge um determinado limite. T\u00e9cnicas mais avan\u00e7adas utilizam heur\u00edsticas que permi-\n\ntem ajustar este limite de tempo conforme o comportamento do sistema e das aplica\u00e7\u00f5es.\n\nGer\u00eancia do consumo de energia em placas de rede apresentam um maior desafio para os\n\nmecanismos de hiberna\u00e7\u00e3o. Este desafio \u00e9 o fato de que o simples desligamento de uma\n\nplaca de rede pode desconectar o dispositivo de servidores ou outros hosts aos quais est\u00e1\n\nconectado. Portanto, as t\u00e9cnicas para hibernar estes dispositivos envolvem o desenvol-\n\nvimento de protocolos para sincroniz\u00e1-los com os demais dispositivos conectados a sua\n\nrede.\n\n2.5 Estrat\u00e9gias Para Ger\u00eancia de Energia\n\nGer\u00eancia de energia dirigida pelo sistema operadional (OS-directed power\n\nmanagement) est\u00e1 associada \u00e0s t\u00e9cnicas que utilizam o sistema operacional como entidade\n\ngerenciadora de energia. Os mecanismos de ger\u00eancia de energia que adotam esta meto-\n\ndologia, o que inclui as implementa\u00e7\u00f5es da maioria das t\u00e9cnicas discutidas nas se\u00e7\u00f5es 2.3\n\ne 2.4, o fazem por considerar que o sistema operacional \u00e9 o componente que possui a\n\ninforma\u00e7\u00e3o necess\u00e1ria para realizar essa ger\u00eancia, ou seja, conhecimento relativo ao com-\n\nportamento das aplica\u00e7\u00f5es e acesso para monitorar e configurar o hardware.\n\nGer\u00eancia de energia dirigida pelo sistema operacional \u00e9 utilizada pela\n\ngrande maioria dos sistemas operacionais, tanto para computa\u00e7\u00e3o gen\u00e9rica (e.g., WIN-\n\n\n\n17\n\nDOWS, LINUX), quanto para computa\u00e7\u00e3o dedicada/embarcada (e.g., \u00b5CLINUX, VX-\n\nWORKS, ECOS). Nestes sistemas os gerenciadores de energia s\u00e3o implementados ou\n\ncomo extens\u00f5es dos escalonadores (para ger\u00eancia da CPU) ou dentro dos drivers de dis-\n\npositivos (para ger\u00eancia de perif\u00e9ricos como discos ou placas de rede). A separa\u00e7\u00e3o das\n\npol\u00edticas em diferentes partes do sistema torna complexa a tarefa de manter e integrar a\n\nger\u00eancia de energia, ou seja, implementar uma entidade \u00fanica que seja capaz de gerenciar\n\ntodos os componentes do sistema de modo uniforme.\n\nAl\u00e9m das tecnologias de ger\u00eancia de energia controladas por software,\n\nexistem alguns recursos de ger\u00eancia de energia que s\u00e3o implementados pelo hardware de\n\nforma transparente ao software, principalmente por processadores. A grande maioria dos\n\nprocessadores que suportam DVS configuram sua tens\u00e3o de opera\u00e7\u00e3o com base em uma\n\ntabela que cont\u00e9m n\u00edveis de tens\u00e3o para opera\u00e7\u00e3o em diferentes freq\u00fc\u00eancias. Esta tabela \u00e9\n\nconstru\u00edda atrav\u00e9s de uma an\u00e1lise pr\u00e9via de pior caso, garantindo que os n\u00edveis de tens\u00e3o\n\nutilizados sejam seguros para a opera\u00e7\u00e3o do processador. Processadores IA32 recentes\n\nda INTEL implementam DVS atrav\u00e9s da tecnologia SPEEDSTEP, que permite utilizar\n\nfreq\u00fc\u00eancias de opera\u00e7\u00e3o variando a cada 100 MHz a partir de 40% da freq\u00fc\u00eancia m\u00e1xima\n\ndo processador. Al\u00e9m desta tecnologia, modelos mais recentes como PENTIUM M e\n\nCENTRINO tamb\u00e9m implementam v\u00e1rias t\u00e9cnicas que reduzem a atividade de regi\u00f5es do\n\nprocessador que n\u00e3o est\u00e3o em uso. A AMD possui uma tecnologia semelhante chamada\n\nPOWER NOW!. A tecnologia LONGRUN, empregada nos processadores CRUSOE e\n\nEFFICEON da TRANSMETA, tamb\u00e9m implementa ajustes de tens\u00e3o de opera\u00e7\u00e3o baseados\n\nem tabelas. Por\u00e9m, a vers\u00e3o mais recente do LONGRUN atribui diferentes tens\u00f5es para\n\ndiferentes partes do circuito, economizando mais energia.\n\nEmbora nestes exemplos o ajuste da tens\u00e3o seja feito automaticamente\n\npelos processadores, continua existindo uma participa\u00e7\u00e3o importante do software neste\n\nprocesso, j\u00e1 que a tens\u00e3o s\u00f3 \u00e9 ajustada a partir do momento que o software solicita um\n\najuste da freq\u00fc\u00eancia, ou seja, a tomada de decis\u00e3o continua vindo do software, princi-\n\npalmente do sistema operacional. Outra desvantagem destes sistemas \u00e9 o uso de n\u00edveis\n\nde tens\u00e3o obtidos atrav\u00e9s de an\u00e1lise de pior caso. Para melhorar a efici\u00eancia do DVS\n\nem processadores, a ARM desenvolveu um mecanismo de ajuste autom\u00e1tico de tens\u00e3o,\n\n\n\n18\n\no RAZOR PIPELINE [ERN 03]. Este mecanismo utiliza a detec\u00e7\u00e3o de atrasos no circuito\n\nque ocorrem quando o n\u00edvel de tens\u00e3o est\u00e1 muito baixo para opera\u00e7\u00e3o numa determinada\n\nfreq\u00fc\u00eancia. O RAZOR inclui hardware adicional para monitorar e corrigir estes atrasos.\n\nUma pol\u00edtica monitora a ocorr\u00eancia dos atrasos, aumentando a tens\u00e3o de opera\u00e7\u00e3o quando\n\nmuitos atrasos est\u00e3o ocorrendo, e diminuindo a tens\u00e3o enquanto a quantidade de atrasos\n\nestiver num limite aceit\u00e1vel. Como resultado, os pesquisadores obtiveram apenas 3% de\n\nredu\u00e7\u00e3o no desempenho do sistema (devido aos atrasos corrigidos), enquanto consegui-\n\nram economizar at\u00e9 64,2% da energia consumida.\n\nAlguns sistemas operacionais embarcados, tais como TINYOS e ECOS,\n\nexportam interfaces que permitem \u00e0s aplica\u00e7\u00f5es gerenciar o consumo de energia de com-\n\nponentes do sistema. Estas interfaces, contudo, s\u00e3o muitas vezes incompletas, limitando\n\na configura\u00e7\u00e3o dos dispositivos, ou n\u00e3o padronizadas, comprometendo a facilidade de im-\n\nplementa\u00e7\u00e3o e portabilidade da aplica\u00e7\u00e3o. Por exemplo, o TinyOS, um sistema operaci-\n\nonal desenvolvido na Universidade de Berkley para sistemas de sensoriamento [HIL 00],\n\npossui uma interface de controle de dispositivos chamada StdControl que permite \u00e0s\n\naplica\u00e7\u00f5es lig\u00e1-los (StdControl.start()) ou deslig\u00e1-los (StdControl.stop()).\n\nNeste sistema, para que a aplica\u00e7\u00e3o coloque um dispositivo em algum modo alternativo de\n\nbaixo consumo de energia, precisar\u00e1 utilizar outros m\u00e9todos da interface do componente\n\nou implementar ela mesma os procedimentos de migra\u00e7\u00e3o entre modos de opera\u00e7\u00e3o.\n\n2.6 Adapta\u00e7\u00f5es Multi-Camada\n\nPara desenvolver um sistema que consuma energia de forma eficiente \u00e9\n\nnecess\u00e1rio dar aten\u00e7\u00e3o a aspectos relacionados a todas as camadas que formam este sis-\n\ntema, desde os transistores at\u00e9 as aplica\u00e7\u00f5es. Por isso, uma quest\u00e3o que tem sido cada\n\nvez mais freq\u00fcente em trabalhos cient\u00edficos da \u00e1rea \u00e9 como desenvolver modelos abran-\n\ngentes, que integrem informa\u00e7\u00f5es presentes em v\u00e1rios n\u00edveis (e.g., sistema operacional,\n\ncompilador e aplica\u00e7\u00e3o) nas decis\u00f5es de ger\u00eancia de energia. Para tentar responder a esta\n\npergunta, alguns sistemas t\u00eam sido constru\u00eddos para permitir as chamadas cross-layer\n\nadaptations, com destaque para os sistemas Forge [MOH 05] e Grace [SAC 06].\n\n\n\n19\n\nO Forge \u00e9 um framework de ger\u00eancia de energia para aplica\u00e7\u00f5es mul-\n\ntim\u00eddia. Este sistema foca um cen\u00e1rio t\u00edpico em que usu\u00e1rios com dispositivos port\u00e1teis\n\n(e.g., PDA, celular) requisitam v\u00eddeos pela rede. O sistema Forge filtra estas requisi\u00e7\u00f5es\n\natrav\u00e9s de um proxy, transcodificando e transmitindo os v\u00eddeos para cada cliente conforme\n\no n\u00edvel de qualidade de servi\u00e7o (Quality of Service - QOS) mais eficiente em termos de\n\nenergia. O Forge integra v\u00e1rias camadas em seu framework de ger\u00eancia de energia. No\n\nn\u00edvel do hardware, ele prov\u00ea interfaces para DVS e para a placa de rede, permitindo\n\ndeslig\u00e1-la quando ociosa. Acima do hardware est\u00e3o o sistema operacional e o compila-\n\ndor, que controlam as configura\u00e7\u00f5es do hardware, e acima do sistema operacional, est\u00e1\n\num middleware distribu\u00eddo, que possui uma parte no dispositivo m\u00f3vel e outra parte no\n\nproxy. O middleware em cada dispositivo m\u00f3vel monitora as estat\u00edsticas relevantes ao\n\nconsumo de energia e repassa esta informa\u00e7\u00e3o ao middleware no proxy. De posse desta\n\ninforma\u00e7\u00e3o, o middleware no proxy ajusta o tr\u00e1fego na rede e decide em qual n\u00edvel de\n\nQOS deve transmitir cada v\u00eddeo requisitado.\n\nO Grace \u00e9 outro framework que busca adaptar v\u00e1rias camadas de ger\u00ean-\n\ncia de energia. Ele tenta integrar DVS, escalonamento eficiente em termos de energia e\n\nconfigura\u00e7\u00f5es de QOS. Ele foi concebido para suportar aplica\u00e7\u00f5es multim\u00eddia de tempo\n\nreal com per\u00edodos e prazos fixos. Este sistema inclui dois n\u00edveis de adapta\u00e7\u00e3o: global e\n\nlocal. Adapta\u00e7\u00f5es globais s\u00e3o realizadas por um coordenador central que monitora o n\u00edvel\n\nda bateria e a demanda de processamento do sistema, atuando apenas quando estes sofrem\n\ngrandes varia\u00e7\u00f5es. Adapta\u00e7\u00f5es locais, contudo, respondem a pequenas varia\u00e7\u00f5es dos wor-\n\nkloads em cada tarefa. Estas adapta\u00e7\u00f5es s\u00e3o realizadas por tr\u00eas \u201cadaptadores locais\u201d, um\n\npara configurar a freq\u00fc\u00eancia da CPU (DVS), um para atuar no escalonamento de tarefas e\n\num terceiro para adaptar os par\u00e2metros de QOS. Altera\u00e7\u00f5es importantes no estado do sis-\n\ntema (e.g., diminui\u00e7\u00e3o dr\u00e1stica do n\u00edvel da bateria, aumento muito grande da demanda por\n\nprocessamento) acionam o coordenador central para que este dispare um novo conjunto\n\nde adapta\u00e7\u00f5es globais. Estas adapta\u00e7\u00f5es, que s\u00e3o propagadas para os adaptadores locais,\n\npodem ser, por exemplo, solicita\u00e7\u00f5es para que os servi\u00e7os n\u00e3o cr\u00edticos sejam desativados,\n\nou que tarefas classificadas em uma classe de servi\u00e7o (Class of Service - COS) inferior\n\nsejam suspensas. As a\u00e7\u00f5es que executam as decis\u00f5es tomadas pelo coordenador global\n\n\n\n20\n\ns\u00e3o implementadas pelos adaptadores locais, que s\u00e3o livres para adaptar estas diretrizes\n\nglobais conforme a execu\u00e7\u00e3o de cada tarefa.\n\nOutro trabalho explora como compilador e sistema operacional podem\n\ninteragir para economizar energia [ABO 03]. Esse trabalho realiza uma an\u00e1lise de aplica-\n\n\u00e7\u00f5es tempo real com prazos fixos para obter, atrav\u00e9s de simula\u00e7\u00e3o, os tempos de execu\u00e7\u00e3o\n\nde pior caso para v\u00e1rios fluxos de execu\u00e7\u00e3o diferentes na aplica\u00e7\u00e3o analisada. O compi-\n\nlador utiliza estes tempos de execu\u00e7\u00e3o para manter em um registrador o n\u00famero de ciclos\n\nrestantes para que a tarefa finalize segundo o pior caso. O sistema operacional acessa pe-\n\nriodicamente este registrador, ajustando a velocidade do processador de modo a garantir\n\nque a tarefa sempre finalize dentro do tempo previsto. T\u00e9cnicas semelhantes a estas j\u00e1\n\nforam descritas na se\u00e7\u00e3o 2.3, por\u00e9m neste m\u00e9todo, n\u00e3o s\u00e3o trechos de c\u00f3digo inseridos\n\npelo compilador que alteram a configura\u00e7\u00e3o do processador, quem configura o hardware\n\n\u00e9 o sistema operacional. Isso permite \u00e0 pol\u00edtica de ger\u00eancia de energia implementada pelo\n\nsistema simplesmente atender o prazo da tarefa em quest\u00e3o ou, devido \u00e0 exist\u00eancia de\n\noutros eventos mais priorit\u00e1rios (e.g., bateria em n\u00edvel muito baixo), permitir que a tarefa\n\nperca o prazo.\n\n2.7 Interfaces e Padr\u00f5es\n\nTentativas de padroniza\u00e7\u00e3o de interfaces para ger\u00eancia de energia tive-\n\nram origem em sistemas de prop\u00f3sito geral. Antes do surgimento das primeiras tentativas\n\nde padroniza\u00e7\u00e3o, as funcionalidades de ger\u00eancia de energia estavam limitadas a procedi-\n\nmentos no firmware de computadores que implementavam desligamento dos monitores\n\ne mecanismos de hiberna\u00e7\u00e3o do sistema para a mem\u00f3ria ou disco. Contudo, estes pro-\n\ncedimentos eram realizados pelo firmware sem interven\u00e7\u00e3o ou sequer conhecimento do\n\nsistema operacional. Outro fator complicante das t\u00e9cnicas at\u00e9 ent\u00e3o era o fato de que\n\ncada fabricante implementava as funcionalidades de modo diferente. Neste contexto, o\n\nAPM (Advanced Power Management) [INT 96] surgiu para unificar as funcionalidades\n\nde ger\u00eancia de energia, e permitir ao firmware expor ao sistema operacional uma interface\n\nde ger\u00eancia de energia. Isto permitiu ao sistema operacional ter informa\u00e7\u00f5es importantes\n\n\n\n21\n\nsobre o sistema como o n\u00edvel da bateria, al\u00e9m de controlar alguns aspectos de ger\u00eancia de\n\nenergia, como requisitar a hiberna\u00e7\u00e3o do sistema para disco ou mem\u00f3ria. As a\u00e7\u00f5es efeti-\n\nvas de ger\u00eancia de energia, contudo, continuavam sendo realizadas pelo software contido\n\nno firmware, apresentando uma s\u00e9rie de desvantagens [GRO 03]:\n\n\u2022 falta de controle oferecido ao sistema operacional sobre os aspectos de ger\u00eancia\n\nde energia (por exemplo, o mecanismo de hiberna\u00e7\u00e3o do sistema era executado\n\ntotalmente pelo firmware, n\u00e3o permitindo ao sistema operacional adapt\u00e1-lo ao seu\n\nestado atual);\n\n\u2022 falta de flexibilidade da interface (e.g., o indicador de estado da bateria agrega in-\n\nforma\u00e7\u00e3o, possivelmente de m\u00faltiplas baterias, em um simples valor que indica\n\n\u201cminutos de bateria restantes\u201d);\n\n\u2022 a falta de extens\u00f5es da interface para uma maior variedade de dispositivos (e.g.,\n\nplacas de rede, discos);\n\n\u2022 nos computadores baseados na arquitetura INTEL X86, os procedimentos do APM\n\nprecisam ser executados com o processador operando em Modo Real, o que se tor-\n\nnou um inconveniente ao passo que os sistemas come\u00e7aram a operar em modo pro-\n\ntegido, al\u00e9m do fato de que, a partir do momento que um procedimento no firmware\n\nest\u00e1 sendo executado, o sistema operacional n\u00e3o est\u00e1 mais no controle do sistema.\n\nUma chamada de procedimento do firmware poderia tomar muito tempo para retor-\n\nnar, ou fazer algo inesperado, ou, at\u00e9 mesmo, nunca retornar.\n\nPara substituir o APM foi proposto o ACPI (Advanced Configuration\n\n&amp; Power Interface) [HP 04]: uma interface mais flex\u00edvel, abrangente e com extens\u00f5es\n\nque eliminam a necessidade de executar c\u00f3digo estranho ao sistema operacional, como\n\nocorria com os procedimentos APM contidos no firmware. O ACPI identifica o sistema\n\noperacional como a entidade que tem conhecimento abrangente sobre os componentes\n\nde hardware e seu uso, al\u00e9m de tamb\u00e9m conhecer as caracter\u00edsticas e comportamento das\n\naplica\u00e7\u00f5es que acessam estes componentes. Em contraste ao APM, o sistema operacional\n\n\n\n22\n\ntem total controle sobre os modos de opera\u00e7\u00e3o e peculiaridades da ger\u00eancia de energia do\n\nhardware. ACPI foi projetada para n\u00e3o realizar chamadas diretas ao firmware. Ao inv\u00e9s\n\nde armazenar procedimentos de ger\u00eancia de energia em c\u00f3digo nativo pronto para ser exe-\n\ncutado, o firmware com suporte a ACPI passa a armazenar estes procedimentos em uma\n\nlinguagem chamada AML (ACPI Machine Language). Este c\u00f3digo \u00e9 ent\u00e3o executado\n\npelo sistema operacional atrav\u00e9s de uma m\u00e1quina virtual. A interpreta\u00e7\u00e3o do AML tr\u00e1s\n\nalgumas vantagens importantes:\n\n\u2022 permite ao sistema operacional evitar a execu\u00e7\u00e3o de c\u00f3digo err\u00f4neo ou malicioso;\n\n\u2022 a linguagem de m\u00e1quina do ACPI abstrai tanto o sistema operacional, quanto a ar-\n\nquitetura ou plataforma em que est\u00e1 executando, retirando dos fabricantes da obri-\n\nga\u00e7\u00e3o de fornecer suporte a drivers para v\u00e1rios sistemas ou arquiteturas diferentes.\n\nContudo, ao se considerar a adequa\u00e7\u00e3o desta interface para sistemas\n\nembarcados, s\u00e3o identificados tr\u00eas maiores inconvenientes:\n\n\u2022 o ACPI abstrai os modos de opera\u00e7\u00e3o do hardware de um modo que pode ser muito\n\nrestritivo para sistemas embarcados. Usando como exemplo um m\u00f3dulo de senso-\n\nriamento MICA2 MOTE [HIL 00], \u00e9 observado que pode ser importante suportar\n\ntodos os modos de baixo consumo de energia ou de maior desempenho do dis-\n\npositivo de comunica\u00e7\u00e3o (r\u00e1dio) para minimizar o consumo de energia de forma\n\neficiente. O ACPI permite a defini\u00e7\u00e3o de, no m\u00e1ximo, quatro modos de opera\u00e7\u00e3o\n\npara cada dispositivo (D0 - D3), o que pode ser de granularidade muito grossa para\n\naplica\u00e7\u00f5es embarcadas.\n\n\u2022 o uso de uma linguagem interpretada para acessar os componentes de hardware,\n\nembora apresente vantagens substanciais, imp\u00f5e requisitos ao sistema que podem\n\nexceder, em muito, os recursos limitados da maioria dos dispositivos embarca-\n\ndos. Nestes sistemas, quantidade de mem\u00f3ria dispon\u00edvel ou espa\u00e7o para c\u00f3digo\n\npodem ser da ordem de poucos quilobytes, requerendo a exist\u00eancia de uma interface\n\nque permita uma implementa\u00e7\u00e3o com tamanho de c\u00f3digo minimizado e agregando\n\npouco custo de mem\u00f3ria e processamento.\n\n\n\n23\n\n\u2022 o papel do ACPI (assim como era do APM) \u00e9 abstrair a interface entre sistema\n\noperacional e dispositivos de hardware. Sendo assim, mesmo melhorando consi-\n\nderavelmente o padr\u00e3o anterior, o ACPI ainda mant\u00e9m a padroniza\u00e7\u00e3o num n\u00edvel\n\nbaixo de abstra\u00e7\u00e3o. O modo como o sistema operacional realiza a interface entre\n\nsua camada de abstra\u00e7\u00e3o de hardware e seus componentes de mais alto n\u00edvel, assim\n\ncomo o modo pelo qual funcionalidades de ger\u00eancia de energia s\u00e3o exportadas para\n\naplica\u00e7\u00f5es, n\u00e3o fazem parte deste padr\u00e3o. Isso implica em interfaces diferentes en-\n\ntre sistemas operacionais ou na aus\u00eancia de padr\u00e3o at\u00e9 mesmo entre componentes\n\ndo mesmo sistema. Alguns sistemas sequer implementam algum tipo de interface\n\nde alto n\u00edvel de ger\u00eancia de energia. Esta grande variedade de situa\u00e7\u00f5es impede\n\nque aplica\u00e7\u00f5es sejam desenvolvidas eficientemente levando em conta crit\u00e9rios de\n\nger\u00eancia de energia.\n\n2.8 O Papel da Aplica\u00e7\u00e3o na Ger\u00eancia do Consumo de\n\nEnergia\n\nV\u00e1rios trabalhos t\u00eam sido realizados para dar \u00e0s aplica\u00e7\u00f5es um papel\n\nmais ativo nas decis\u00f5es de ger\u00eancia de energia. Ellis [ELL 99] realizou uma primeira an\u00e1-\n\nlise que constatou os benef\u00edcios do envolvimento das aplica\u00e7\u00f5es na ger\u00eancia de energia,\n\ndefendendo a cria\u00e7\u00e3o de uma API que permita o envolvimento das aplica\u00e7\u00f5es de forma\n\nativa no processo de ger\u00eancia de energia. Seguindo esta mesma vis\u00e3o, outros trabalhos re-\n\nalizados neste sentido focaram em tr\u00eas principais pontos: transforma\u00e7\u00f5es nas aplica\u00e7\u00f5es,\n\naplica\u00e7\u00f5es adaptativas e concep\u00e7\u00e3o de interfaces que permitam \u00e0s aplica\u00e7\u00f5es influenciar\n\no gerenciador de energia ativamente.\n\nTan et al. [TAN 03] prop\u00f5em uma metodologia para projeto de apli-\n\nca\u00e7\u00f5es de baixo consumo de energia. Neste trabalho os autores analisam a estrutura das\n\naplica\u00e7\u00f5es e artefatos do sistema por ela utilizados (processos/threads, tratadores de even-\n\ntos, device drivers), bem como a comunica\u00e7\u00e3o entre estes artefatos (sincroniza\u00e7\u00e3o e me-\n\ncanismos de comunica\u00e7\u00e3o) para montar um grafo que represente o comportamento da\n\n\n\n24\n\naplica\u00e7\u00e3o e a intera\u00e7\u00e3o com os artefatos envolvidos. A partir desta representa\u00e7\u00e3o de alto\n\nn\u00edvel da aplica\u00e7\u00e3o s\u00e3o realizadas simula\u00e7\u00f5es para estimar o consumo de energia da aplica-\n\n\u00e7\u00e3o original. Em seguida, transforma\u00e7\u00f5es s\u00e3o aplicadas ao grafo original a fim de reduzir\n\no consumo de energia. Estas transforma\u00e7\u00f5es envolvem fus\u00e3o de processos para reduzir\n\na comunica\u00e7\u00e3o inter-processos (IPC), escolha de mecanismos de IPC mais eficientes e\n\nmigra\u00e7\u00e3o de trechos de computa\u00e7\u00e3o entre processos.\n\nOutros trabalhos exploram o desenvolvimento de aplica\u00e7\u00f5es adaptati-\n\nvas que permitam trocas entre exatid\u00e3o das tarefas e consumo de energia. Sachs et al.\n\nprop\u00f5e um codificador de v\u00eddeo que permite variar a efici\u00eancia da compress\u00e3o n\u00e3o re-\n\nalizando algumas fases deste processo (Motion Search e DCT - Discrete Cosine Trans-\n\nform) [SAC 03]. No prot\u00f3tipo implementado, o codificador executou sobre um proces-\n\nsador com suporte a DVS e a adapta\u00e7\u00f5es do hardware (e.g., caches configur\u00e1veis). O\n\ngerente de energia consiste de duas tarefas que operavam em conjunto. Uma tarefa confi-\n\ngura os par\u00e2metros do hardware no in\u00edcio da codifica\u00e7\u00e3o de cada frame de v\u00eddeo, enquanto\n\noutra ajusta os par\u00e2metros do codificador enquanto o frame est\u00e1 sendo processado.\n\nTrabalhos explorando trocas entre QOS das aplica\u00e7\u00f5es e consumo de\n\nenergia tamb\u00e9m foram realizados. Um sistema operacional que realiza este tipo de ger\u00ean-\n\ncia de energia \u00e9 o Odyssey [FLI 99]. O Odyssey implementa um framework para aplica-\n\n\u00e7\u00f5es multim\u00eddia e Web. O sistema monitora os recursos utilizados pelas aplica\u00e7\u00f5es e envia\n\num alerta \u00e0s aplica\u00e7\u00f5es cujos recursos est\u00e3o se tornado escassos, exigindo que a aplica\u00e7\u00e3o\n\ndiminua sua qualidade de servi\u00e7o at\u00e9 que os recursos estejam dispon\u00edveis novamente. Por\n\nexemplo, uma aplica\u00e7\u00e3o de visualiza\u00e7\u00e3o de mapas ao receber um alerta de baixo n\u00edvel de\n\nbateria poderia passar a solicitar imagens de menor qualidade pela rede, cujos arquivos\n\nseriam menores, diminuindo o fluxo de dados e, conseq\u00fcentemente, diminuindo o con-\n\nsumo de energia. Outro sistema operacional que suporta a adapta\u00e7\u00e3o das aplica\u00e7\u00f5es \u00e9 o\n\nECOSystem [ZEN 02]. Este sistema atribui pre\u00e7os que as aplica\u00e7\u00f5es precisam pagar para\n\nutilizar cada recurso necess\u00e1rio (e.g., acesso a mem\u00f3ria, rede ou disco). As aplica\u00e7\u00f5es\n\npagam estes acessos atrav\u00e9s de uma \u201cmoeda\u201d, chamada currentcy, que o sistema distribui\n\nperiodicamente. Isto permite o desenvolvimento de aplica\u00e7\u00f5es que adaptam seu fluxo de\n\nexecu\u00e7\u00e3o com base em seu saldo de currentcy.\n\n\n\n25\n\nUma s\u00e9rie de trabalhos tamb\u00e9m foram realizados para estabelecer inter-\n\nfaces de programa\u00e7\u00e3o (API) para ger\u00eancia de energia pelas aplica\u00e7\u00f5es. Estes trabalhos\n\nfocam em interfaces que fornecem \u00e0 aplica\u00e7\u00e3o informa\u00e7\u00f5es acerca do estado de com-\n\nponentes, bem como permitem \u00e0 aplica\u00e7\u00e3o influenciar a ger\u00eancia de energia do sistema\n\noperacional, geralmente atrav\u00e9s de \u201cdicas\u201d passadas ao sistemas operacional (Application\n\nHints). Os projetos PASA [PER 02] e Cooperative IO [WEI 02b] permitem \u00e0 aplica\u00e7\u00e3o\n\npassar ao sistema operacional suas restri\u00e7\u00f5es temporais, informando, por exemplo, prazos\n\npara chamadas de fun\u00e7\u00f5es e expectativas de tempo de execu\u00e7\u00e3o. Esta informa\u00e7\u00e3o \u00e9 ent\u00e3o\n\nutilizada pelo gerente de energia para melhorar suas previs\u00f5es sobre o comportamento\n\nfuturo das aplica\u00e7\u00f5es, permitindo uma ger\u00eancia de energia mais eficiente. Outro trabalho\n\nexplora transforma\u00e7\u00f5es no c\u00f3digo da aplica\u00e7\u00e3o, realizadas atrav\u00e9s do compilador, para\n\nagrupar acessos a disco por uma tarefa, inserindo no c\u00f3digo dicas informando o sistema\n\noperacional sobre quanto tempo estes acessos deveriam levar [HEA 04]. De posse desta\n\ninforma\u00e7\u00e3o, o sistema operacional pode implementar pol\u00edticas que reduzem a velocidade\n\nde rota\u00e7\u00e3o do disco gerando um menor n\u00famero de erros na previs\u00e3o dos per\u00edodos de oci-\n\nosidade.\n\nOutro projeto que permite a passagem de dicas da aplica\u00e7\u00e3o para o sis-\n\ntema operacional \u00e9 o Ghosts in the machine [ANA 04], por\u00e9m a sem\u00e2ntica das dicas\n\npassadas pela aplica\u00e7\u00e3o neste projeto s\u00e3o diferentes. Ao inv\u00e9s de passar informa\u00e7\u00f5es so-\n\nbre sua execu\u00e7\u00e3o, aplica\u00e7\u00f5es adaptativas consultam informa\u00e7\u00f5es sobre modo de opera\u00e7\u00e3o\n\natual e custos para trocas entre modos de opera\u00e7\u00e3o dos dispositivos que utilizam. Base-\n\nada nesta informa\u00e7\u00e3o, a aplica\u00e7\u00e3o decide realizar tarefas de um modo que consuma menos\n\nenergia e informa o sistema operacional que foi necess\u00e1rio degradar o desempenho devido\n\na um erro na previs\u00e3o do comportamento da aplica\u00e7\u00e3o feita pela pol\u00edtica de ger\u00eancia de\n\nenergia (e.g., um navegador Web necessita buscar um arquivo pela rede porque o mesmo\n\narquivo n\u00e3o pode ser obtido de sua cache em disco, o que seria mais r\u00e1pido, j\u00e1 que o disco\n\nhavia sido desligado pela pol\u00edtica de ger\u00eancia de energia).\n\n\n\n26\n\n2.9 Interfaces de Ger\u00eancia de Energia Dirigida Pela Apli-\n\nca\u00e7\u00e3o em Sistemas Embarcados\n\nDois tipos de interfaces para aplica\u00e7\u00f5es foram estudadas neste cap\u00edtulo.\n\nPrimeiramente foram apresentadas interfaces que permitem ao programador da aplica\u00e7\u00e3o\n\nmodificar o estado de opera\u00e7\u00e3o de cada componente individualmente. Estas interfaces,\n\nimplementadas por sistemas como o TINYOS [CUL 01], s\u00e3o simplistas (e.g., permitindo\n\napenas ligar e desligar dispositivos). O segundo tipo de interface foram as desenvolvidas\n\npor trabalhos que exploram o envolvimento das aplica\u00e7\u00f5es na ger\u00eancia de energia. APIs\n\nforam desenvolvidas, basicamente, para permitir \u00e0s aplica\u00e7\u00f5es informar o gerente de ener-\n\ngia sobre algumas de suas caracter\u00edsticas (e.g., prazos, tempos de execu\u00e7\u00e3o) ou para exp\u00f4r\n\n\u00e0 aplica\u00e7\u00e3o o estado atual dos componentes de hardware, permitindo o desenvolvimento\n\nde aplica\u00e7\u00f5es que se adaptem ao ambiente de execu\u00e7\u00e3o.\n\nSistemas embarcados apresentam uma grande variedade de dispositi-\n\nvos que diferem tanto quanto \u00e0s funcionalidades que implementam quanto aos recursos\n\nque oferecem para gerenciar seu consumo de energia. Para uma classe espec\u00edfica des-\n\ntes dispositivos, os chamados sistemas profundamente embarcados 2, estas diferen\u00e7as se\n\nmostram ainda mais importantes, j\u00e1 que limita\u00e7\u00f5es de recursos (e.g., mem\u00f3ria, capacidade\n\nde processamento), assim como restri\u00e7\u00f5es temporais de execu\u00e7\u00e3o, muitas vezes inviabi-\n\nlizam a implementa\u00e7\u00e3o de t\u00e9cnicas complexas para realizar a ger\u00eancia de energia. Neste\n\ncontexto, \u00e9 interessante que sistemas operacionais forne\u00e7am interfaces que permitam \u00e0\n\naplica\u00e7\u00e3o controlar, e n\u00e3o apenas influenciar, a ger\u00eancia de energia.\n\nContudo, um problema encontrado ao entregar a responsabilidade sobre\n\na ger\u00eancia de energia do sistema \u00e0 aplica\u00e7\u00e3o \u00e9 o aumento da complexidade destas apli-\n\nca\u00e7\u00f5es \u00e0 medida que um n\u00famero maior de componentes venham a ser utilizados. Este\n\nproblema tende a piorar quando o sistema operacional aumenta a granularidade em que\n\n2Sistemas Profundamente Embarcados s\u00e3o sistemas computacionais embarcados, de pequeno porte e\n\ncom funcionalidade espec\u00edfica cujos requisitos de pre\u00e7o, tamanho e desempenho levam ao emprego de\n\ndispositivos de hardware extremamente simples, como microcontroladores que operam a baixas freq\u00fc\u00eancias\n\n(muitas vezes na ordem de KHz) e que possuam pouca quantidade de mem\u00f3ria (na ordem de KBytes).\n\n\n\n27\n\nseus componentes s\u00e3o organizados. Sistemas que implementam componentes desta ma-\n\nneira (e.g., EPOS [FR\u00f6 01]) normalmente o fazem de forma hier\u00e1rquica, i.e., utilizam\n\ncomponentes para abstrair camadas de software. Estes sistemas se beneficiariam de um\n\nmecanismo que permita representar as intera\u00e7\u00f5es necess\u00e1rias entre componentes para re-\n\nalizar o processo de troca entre modos de opera\u00e7\u00e3o, permitindo que a aplica\u00e7\u00e3o gerencie\n\napenas os componentes de alto n\u00edvel do sistema.\n\n\n\nCap\u00edtulo 3\n\nO sistema de Ger\u00eancia de Energia\n\nProposto\n\nNeste cap\u00edtulo \u00e9 proposta uma infra-estrutura de software para permitir\n\na ger\u00eancia do consumo de energia dirigido pela aplica\u00e7\u00e3o em sistemas embarcados. A\n\nger\u00eancia de energia \u00e9 realizada atrav\u00e9s de chamadas da aplica\u00e7\u00e3o a uma API (Applica-\n\ntion Programming Interface) uniforme que \u00e9 implementada por todos os componentes do\n\nsistema operacional. Para garantir o correto funcionamento, as rela\u00e7\u00f5es entre componen-\n\ntes do sistema foram especificadas atrav\u00e9s de Redes de Petri. Esta especifica\u00e7\u00e3o permite\n\nn\u00e3o s\u00f3 uma an\u00e1lise em alto-n\u00edvel dos procedimentos de troca de modo de opera\u00e7\u00e3o dos\n\ncomponentes, mas tamb\u00e9m o estabelecimento de um mecanismo de troca de mensagens,\n\nem que os componentes se coordenam para garantir a consist\u00eancia na mudan\u00e7a de estado\n\ndos servi\u00e7os do sistema operacional (e.g., comunica\u00e7\u00e3o, processamento, sensoriamento)\n\nou de todo o sistema.\n\nMecanismos convencionais para ger\u00eancia do consumo de energia, tanto\n\nem sistemas operacionais de prop\u00f3sito geral (e.g, LINUX, WINDOWS) quanto em alguns\n\nsistemas operacionais embarcados (e.g., \u00b5CLINUX, VXWORKS), analisam dinamica-\n\nmente o comportamento do sistema para determinar quando um dispositivo deve mo-\n\ndificar seu modo de opera\u00e7\u00e3o, passando a consumir menos energia. Outros sistemas para\n\ncomputa\u00e7\u00e3o embarcada implementam apenas interfaces simples que muitas vezes n\u00e3o sa-\n\n\n\n29\n\ntisfazem as necessidades do programador da aplica\u00e7\u00e3o, que \u00e9 obrigado a implementar na\n\npr\u00f3pria aplica\u00e7\u00e3o os mecanismos de ger\u00eancia de energia (e.g., TINYOS, ECOS). A im-\n\nplementa\u00e7\u00e3o do software respons\u00e1vel por gerenciar energia normalmente \u00e9 feita atrav\u00e9s\n\nde iniciativas independentes de cada fabricante ou programador do sistema, que exportam\n\nAPIs r\u00edgidas (drivers) e, em alguns casos, incompletas para os usu\u00e1rios.\n\nTentativas de padroniza\u00e7\u00e3o das interfaces de ger\u00eancia de energia n\u00e3o\n\nforam largamente adotadas pela ind\u00fastria de sistemas embarcados e, mesmo se houvesse\n\nsido, muitos problemas continuariam a existir, j\u00e1 que a padroniza\u00e7\u00e3o \u00e9 feita num n\u00edvel\n\nmuito baixo de abstra\u00e7\u00e3o. A maioria das plataformas de computa\u00e7\u00e3o comerciais (com-\n\nputadores pessoais) implementam APM (Advanced Power Management) ou ACPI (Ad-\n\nvanced Configuration Power Interface) para gerenciar a energia consumida pelo sistema.\n\nEstes mecanismos possibilitam colocar dispositivos ociosos em estados de baixa pot\u00eancia\n\npor\u00e9m, como discutido na se\u00e7\u00e3o 2.7, isto \u00e9 feito utilizando mecanismos custosos que tam-\n\nb\u00e9m podem limitar a configura\u00e7\u00e3o dos dispositivos de hardware. Os problemas encontra-\n\ndos no emprego destas interfaces inviabilizam seu uso em sistemas embarcados devido a\n\nv\u00e1rias restri\u00e7\u00f5es, que v\u00e3o desde a falta de recursos para suport\u00e1-las (e.g., processamento,\n\nmem\u00f3ria) at\u00e9 requisitos funcionais, como disponibilidade ou restri\u00e7\u00f5es temporais.\n\nOs estudos apresentados no cap\u00edtulo 2 mostram v\u00e1rias tentativas recen-\n\ntes de dar \u00e0s aplica\u00e7\u00f5es um papel mais ativo na ger\u00eancia de energia. Tendo em vista que\n\na maioria dos sistemas embarcados s\u00e3o dispositivos de finalidade espec\u00edfica que, geral-\n\nmente, executam apenas uma aplica\u00e7\u00e3o, foi considerado que um bom lugar para determi-\n\nnar a estrat\u00e9gia de ger\u00eancia do consumo de energia seria na pr\u00f3pria aplica\u00e7\u00e3o. As se\u00e7\u00f5es\n\na seguir detalham a proposta deste trabalho, apresentando a API definida para que a apli-\n\nca\u00e7\u00e3o gerencie seu consumo de energia, o mecanismo de especifica\u00e7\u00e3o das rela\u00e7\u00f5es entre\n\ncomponentes do sistema e a estrat\u00e9gia de propaga\u00e7\u00e3o das trocas de modos de opera\u00e7\u00e3o.\n\n\n\n30\n\n3.1 Interface de Ger\u00eancia do Consumo de Energia para\n\nComponentes de Software e Hardware\n\nNa estrat\u00e9gia proposta neste trabalho \u00e9 esperado que o programador\n\nda aplica\u00e7\u00e3o especifique, em seu c\u00f3digo-fonte, quando certos componentes n\u00e3o est\u00e3o\n\nsendo utilizados. Para isso, foi definida uma API uniforme de ger\u00eancia do consumo de\n\nenergia. A mesma interface permite intera\u00e7\u00e3o da aplica\u00e7\u00e3o com o sistema (atrav\u00e9s de\n\nseus componentes), de componentes do sistema entre si, de componentes do sistema a\n\ndispositivos de hardware e, inclusive, o acesso direto das aplica\u00e7\u00f5es aos dispositivos de\n\nhardware. Para evitar que o programador tenha que, manualmente, acordar cada um dos\n\ncomponentes que utiliza, o mecanismo de ger\u00eancia abstra\u00eddo pela API garante que estes\n\ncomponentes retomem o seu estado anterior automaticamente quando utilizados.\n\nA figura 3.1 apresenta todos estes modos de intera\u00e7\u00e3o atrav\u00e9s de um di-\n\nagrama de comunica\u00e7\u00e3o UML de uma inst\u00e2ncia hipot\u00e9tica de sistema. A aplica\u00e7\u00e3o pode\n\nacessar um componente global (System), que conhece todos os componentes instancia-\n\ndos no sistema, provocando a altera\u00e7\u00e3o do modo de opera\u00e7\u00e3o de todo o sistema (seq\u00fc\u00eancia\n\nde execu\u00e7\u00e3o 1). A API tamb\u00e9m pode ser acessada para alterar os modos de opera\u00e7\u00e3o de\n\ngrupos de componentes respons\u00e1veis por implementar funcionalidades espec\u00edficas do sis-\n\ntema (no caso, comunica\u00e7\u00e3o atrav\u00e9s da seq\u00fc\u00eancia de execu\u00e7\u00e3o 2). A aplica\u00e7\u00e3o ainda\n\npode acessar diretamente o hardware, utilizando a API dispon\u00edvel nos drivers, como NIC\n\n(Network Interface Card), CPU e ADC (no caso, acesso ao componente CPU pela seq\u00fc\u00ean-\n\ncia 3). Como dito anteriormente, a API tamb\u00e9m \u00e9 utilizada entre os componentes do\n\nsistema, como pode ser observado na figura 3.1 nas trocas de mensagens entre os compo-\n\nnentes representados.\n\nDe modo a aliar portabilidade da aplica\u00e7\u00e3o \u00e0 facilidade de desenvolve-\n\nlas, foi decis\u00e3o deste projeto dotar a interface de um conjunto m\u00ednimo de m\u00e9todos e de\n\numa estrutura que permita a configura\u00e7\u00e3o das caracter\u00edsticas e dos modos de opera\u00e7\u00e3o dos\n\ncomponentes, permitindo ao programador da aplica\u00e7\u00e3o configurar o gerente de energia\n\nconforme as necessidades de sua aplica\u00e7\u00e3o. Neste caso, a portabilidade vem do fato de\n\n\n\n31\n\nSystem\n\n:Sensor\n\n:Scheduler :Thermistor:Network\n\n:NIC :CPU :ADC\n\n:Thread:Communicator\n\n1.1.1. power(mode)\n\n2.1. power(mode)\n1.2.1. power(mode) 1.3.1. power(mode)\n\n1.1.1.1. power(mode)\n\n2.1.1. power(mode)\n\n3. power(mode)\n\n1.1. power(mode) 1.3. power(mode)\n\n1.2. power(mode)\n2. power(mode)\n\n1. power(mode)\n\n1.3.1.1. power(mode)1.2.1.1. power(mode)\n\nApplication\n\nFigura 3.1: Meios de acesso \u00e0 API de ger\u00eancia do consumo de energia.\n\na aplica\u00e7\u00e3o n\u00e3o necessitar implementar procedimentos espec\u00edficos para cada dispositivo\n\nde hardware ao alterar seus modos de opera\u00e7\u00e3o. Estes procedimentos s\u00e3o abstra\u00eddos pela\n\nAPI. J\u00e1 a facilidade de desenvolvimento ocorre porque o programador da aplica\u00e7\u00e3o n\u00e3o\n\nnecessita analisar os manuais do hardware a fim de identificar os modos de opera\u00e7\u00e3o\n\ndispon\u00edveis, os procedimentos para realizar as trocas e as conseq\u00fc\u00eancias de cada uma\n\ndestas mudan\u00e7as.\n\nFocando a simplicidade, apenas dois m\u00e9todos foram definidos para a\n\nAPI: um para alterar o modo de opera\u00e7\u00e3o e outro para consulta-lo. Al\u00e9m dos m\u00e9todos, a\n\nAPI ainda cont\u00e9m uma rela\u00e7\u00e3o dos modos de opera\u00e7\u00e3o dispon\u00edveis em cada componente.\n\nEsta rela\u00e7\u00e3o n\u00e3o possui um tamanho fixo, j\u00e1 que cada componente deve enumerar nela\n\ntodos os modos de opera\u00e7\u00e3o poss\u00edveis. Componentes de hardware de baixa pot\u00eancia que\n\ns\u00e3o utilizados em sistemas embarcados freq\u00fcentemente apresentam um grande conjunto\n\nde modos de opera\u00e7\u00e3o. Aplica\u00e7\u00f5es embarcadas se beneficiam disso para utilizar os mo-\n\ndos de opera\u00e7\u00e3o que melhor se adaptam em determinadas situa\u00e7\u00f5es. A mesma aplica\u00e7\u00e3o,\n\ncontudo, muito dificilmente utilizar\u00e1 todos os modos de opera\u00e7\u00e3o dispon\u00edveis. Para per-\n\n\n\n32\n\nmitir que o programador da aplica\u00e7\u00e3o selecione os modos que sua aplica\u00e7\u00e3o utilizar\u00e1, sem\n\nprecisar conhecer profundamente o hardware sendo utilizado, foram definidos modos de\n\nopera\u00e7\u00e3o universais. Estes modos universais, chamados de FULL, LIGHT, STANDBY e\n\nOFF, est\u00e3o originalmente amarrados a modos de opera\u00e7\u00e3o equivalentes aos modos mais\n\ncomumente utilizados em cada componente. Esta amarra\u00e7\u00e3o tenta seguir a mesma sem\u00e2n-\n\ntica para todos os componentes sempre que poss\u00edvel (i.e., sempre que modo equivalente\n\nexistir para o componente em quest\u00e3o). O programador da aplica\u00e7\u00e3o pode, contudo, con-\n\nfigurar estas amarra\u00e7\u00f5es para utilizar os modos de opera\u00e7\u00e3o que desejar.\n\nA Tabela 3.1 apresenta a sem\u00e2ntica pretendida para os modos de ope-\n\nra\u00e7\u00e3o. Quando o dispositivo est\u00e1 operando com toda sua capacidade, ele est\u00e1 no modo\n\nFULL. Neste modo de opera\u00e7\u00e3o, o sistema configura o dispositivo para operar fornecendo\n\nseus servi\u00e7os da maneira mais completa poss\u00edvel, incluindo todas as suas funcionalidades,\n\npor\u00e9m consumindo mais energia. O modo LIGHT coloca o dispositivo em um modo de\n\nopera\u00e7\u00e3o onde ele continua oferecendo todas as suas funcionalidades, por\u00e9m consumindo\n\nmenos energia e, muito provavelmente, implicando em perda de desempenho. Alguns\n\ndispositivos, contudo, n\u00e3o apresentam tais modos. Nestes casos, o modo LIGHT estar\u00e1\n\nassociado ao modo de opera\u00e7\u00e3o com maior n\u00famero de funcionalidades dispon\u00edvel ou a\n\num modo de menor consumo de energia que seja comumente utilizado pelo componente\n\nem quest\u00e3o. A fim de evitar erros por parte do programador da aplica\u00e7\u00e3o, estas situa\u00e7\u00f5es\n\nestar\u00e3o claramente especificadas na documenta\u00e7\u00e3o do gerente de energia. Exemplos des-\n\ntes modos est\u00e3o presentes em dispositivos que possuem sele\u00e7\u00e3o de diferentes n\u00edveis de\n\ntens\u00e3o e/ou divisores de freq\u00fc\u00eancia de opera\u00e7\u00e3o (DVS - Dynamic Voltage Scaling). O\n\nretorno deste modo de opera\u00e7\u00e3o para o modo FULL \u00e9 r\u00e1pido e, geralmente, n\u00e3o implica\n\nem atrasos consider\u00e1veis para a aplica\u00e7\u00e3o.\n\nPara o caso espec\u00edfico de DVS em processadores, o modo FULL \u00e9 asso-\n\nciado ao modo de opera\u00e7\u00e3o de mais alta freq\u00fc\u00eancia, e o modo LIGHT \u00e9 associado ao modo\n\nde opera\u00e7\u00e3o de mais baixa freq\u00fc\u00eancia. Entre os modos FULL e LIGHT existem modos de\n\nopera\u00e7\u00e3o que realizam saltos de 10% na freq\u00fc\u00eancia de opera\u00e7\u00e3o do dispositivo. Estes mo-\n\ndos s\u00e3o DVS_90, DVS_80, DVS_70, DVS_60, DVS_50, DVS_40, DVS_30, DVS_20.\n\nOs modos DVS_100 e DVS_10 s\u00e3o equivalentes aos modos FULL e LIGHT, respecti-\n\n\n\n33\n\nvamente. Caso o processador em quest\u00e3o n\u00e3o permita a configura\u00e7\u00e3o da freq\u00fc\u00eancia de\n\nopera\u00e7\u00e3o a uma granularidade t\u00e3o fina, ou as freq\u00fc\u00eancias dispon\u00edveis n\u00e3o implementem\n\nsaltos de 10%, os modos DVS devem sempre corresponder \u00e0 freq\u00fcencia dispon\u00edvel que\n\nseja imediatamente maior.\n\nModo FULL LIGHT STANDBY OFF\n\nEnergia Alto Baixo Baix\u00edssimo Nenhum\n\nFuncionalidades Total Limitada Nenhuma Nenhuma\n\nDesempenho M\u00e1ximo Reduzido Parado Parado\n\nTabela 3.1: Sem\u00e2ntica dos modos de opera\u00e7\u00e3o universais.\n\nNos modos STANDBY e OFF o dispositivo para de operar. Entretanto,\n\nquando em STANDBY, o dispositivo est\u00e1 em um modo do qual pode voltar a operar nor-\n\nmalmente quando necess\u00e1rio, podendo continuar sua opera\u00e7\u00e3o do ponto em que parou.\n\nEmbora parado, neste modo o hardware ainda consome uma pequena quantidade de ener-\n\ngia. Esta energia \u00e9 necess\u00e1ria para manter dados em mem\u00f3ria e registradores, permitindo\n\nque o dispositivo volte a operar sem que ocorra uma reinicializa\u00e7\u00e3o. J\u00e1 no modo OFF o\n\ndispositivo \u00e9 desligado. Quando isto \u00e9 feito, o dispositivo perde sua configura\u00e7\u00e3o original,\n\ne seu retorno a um modo operacional implica em uma reinicializa\u00e7\u00e3o. Outra diferen\u00e7a im-\n\nportante entre os dois modos \u00e9 o tempo para que o componente retorne a um modo ativo.\n\nComo o retorno do modo OFF implica em uma reinicializa\u00e7\u00e3o, este processo tende a ser\n\nmuito mais lento que o retorno do modo STANDBY.\n\nAl\u00e9m dos requisitos funcionais, tamb\u00e9m \u00e9 desej\u00e1vel que a API seja de\n\nf\u00e1cil manuten\u00e7\u00e3o e aplic\u00e1vel a sistemas j\u00e1 existentes. Sendo a ger\u00eancia do consumo de\n\nenergia uma propriedade n\u00e3o-funcional no \u00e2mbito de sistemas operacionais [LOH 05],\n\nfoi considerado importante implementar esta API utilizando programa\u00e7\u00e3o orientada a\n\naspectos [KIC 97], permitindo, assim, o isolamento do gerente de energia do restante do\n\nsistema.\n\nA t\u00e9cnica de programa\u00e7\u00e3o orientada a aspectos define estruturas que\n\n\n\n34\n\npermitem aos programadores separar caracter\u00edsticas n\u00e3o funcionais cujas implementa\u00e7\u00f5es\n\nimplicam em replica\u00e7\u00e3o de c\u00f3digo em v\u00e1rias partes do sistema. Linguagens de programa-\n\n\u00e7\u00e3o que suportam aspectos definem estruturas para especifica\u00e7\u00f5es de \"comportamentos\n\nadicionais\"(advice) e \"pontos de execu\u00e7\u00e3o\"(join point), que definem, geralmente atrav\u00e9s\n\nde express\u00f5es regulares, os pontos do c\u00f3digo alvo (i.e., o sistema existente) onde os com-\n\nportamentos adicionais devem ser inseridos.\n\nOs pontos de execu\u00e7\u00e3o de um aspecto devem especificar a posi\u00e7\u00e3o em\n\nque os comportamentos adicionais ser\u00e3o inclu\u00eddos, isto \u00e9, se o comportamento adicional\n\n\u00e9 inserido antes (before), depois (after) ou ao redor (around) do ponto definido. Um\n\nexemplo de utiliza\u00e7\u00e3o de aspecto para implementar uma caracter\u00edstica n\u00e3o-funcional de\n\nsistemas operacionais \u00e9 sincroniza\u00e7\u00e3o. Um aspecto definiria pontos de execu\u00e7\u00e3o que\n\nrepresentam as regi\u00f5es cr\u00edticas do c\u00f3digo, e um comportamento adicional atuaria \"ao\n\nredor\"destes pontos de execu\u00e7\u00e3o realizando opera\u00e7\u00f5es lock num mutex ao entrar nas\n\nregi\u00f5es cr\u00edticas e unlock ao sair.\n\nO problema encontrado ao abstrair a ger\u00eancia de energia como um as-\n\npecto \u00e9 a quest\u00e3o da independ\u00eancia arquitetural que se espera encontrar em um aspecto\n\nde software. Mais especificamente, \u00e9 interessante que um aspecto possa ser aplicado a\n\nqualquer componente do sistema. Num aspecto gerente de energia o controle das trocas\n\nde modo de opera\u00e7\u00e3o poderia ser generalizada para ser aplicada a qualquer componente.\n\nPor\u00e9m, n\u00e3o existe um modo gen\u00e9rico de implementar as a\u00e7\u00f5es que realmente trocam\n\nos modos de opera\u00e7\u00e3o de um componente, tanto de software, quanto de hardware. Isto\n\nocorre porque esta implementa\u00e7\u00e3o tem que levar em conta detalhes arquiteturais e/ou de\n\nimplementa\u00e7\u00e3o espec\u00edficos de cada sistema ou dispositivo. Para permitir que um aspecto\n\nde ger\u00eancia de energia seja aplicado aos componentes de um sistema operacional, \u00e9 es-\n\ntabelecido nesta proposta um mecanismo que representa as a\u00e7\u00f5es necess\u00e1rias para trocar\n\nos modos de opera\u00e7\u00e3o dos componentes. Este mecanismo, descrito na pr\u00f3xima se\u00e7\u00e3o,\n\nutiliza Redes de Petri Hier\u00e1rquicas para especificar as intera\u00e7\u00f5es que o gerente de energia\n\nprecisa realizar com o sistema a fim de realizar as trocas de modo de opera\u00e7\u00e3o de um\n\ndeterminado componente.\n\n\n\n35\n\n3.2 Redes de Troca de Modos de Opera\u00e7\u00e3o\n\nNesta se\u00e7\u00e3o \u00e9 descrita a parte da proposta que introduz o mecanismo\n\nde especifica\u00e7\u00e3o das trocas de modo de opera\u00e7\u00e3o. A ferramenta escolhida para modelar\n\nestas transi\u00e7\u00f5es foi Redes de Petri. Redes de Petri se mostraram uma boa escolha devido \u00e0\n\nclareza de sua representa\u00e7\u00e3o gr\u00e1fica e ao extenso leque de modelos de an\u00e1lise matem\u00e1tica\n\nexistentes. Outra caracter\u00edstica das Redes de Petri explorada nesta proposta \u00e9 a repre-\n\nsenta\u00e7\u00e3o hier\u00e1rquica que esta ferramenta possui, o que permite abstrair intera\u00e7\u00f5es entre\n\ncomponentes [PET 77]. Como ficar\u00e1 claro ao longo desta se\u00e7\u00e3o, as an\u00e1lises matem\u00e1ti-\n\ncas permitiram provar a inexist\u00eancia de deadlocks, al\u00e9m de demonstrar a alcan\u00e7abilidade\n\ndos estados desejados (atrav\u00e9s das marca\u00e7\u00f5es pretendidas) e a impossibilidade de estados\n\nindesejados serem alcan\u00e7ados, e a hierarquia de Redes de Petri facilitou a organiza\u00e7\u00e3o e\n\nrepresenta\u00e7\u00e3o destas redes.\n\nEmbora os procedimentos para realizar as trocas de modo de opera\u00e7\u00e3o\n\ndos componentes sejam diferentes (tanto para software, quanto para hardware), o controle\n\ndestas trocas pode ser expresso de forma generalizada. Para isso, foi especificada uma\n\nrede de troca de modos de opera\u00e7\u00e3o que determina condi\u00e7\u00f5es para que as trocas ocorram.\n\nNeste trabalho, a proposta da rede de troca de modos de opera\u00e7\u00e3o generalizada \u00e9 baseada\n\nnos modos universais definidos na se\u00e7\u00e3o anterior (FULL, LIGHT, STANDBY e OFF).\n\nEsta rede pode, contudo, ser extendida para atender uma quantidade maior de modos de\n\nopera\u00e7\u00e3o quando necess\u00e1rio.\n\nDevido ao tamanho da rede definida, uma vers\u00e3o simplificada foi pro-\n\nduzida para apresentar a seq\u00fc\u00eancia de transi\u00e7\u00f5es realizadas supondo que o componente\n\nsendo manipulado estivesse saindo do modo de opera\u00e7\u00e3o OFF para FULL (figura 3.2).\n\nA rede de Petri completa, ou seja, incluindo todos os modos de opera\u00e7\u00e3o, pode ser vista\n\nno anexo A. Como pode ser observado na figura, h\u00e1 lugares associados aos modos de\n\nopera\u00e7\u00e3o existentes (FULL e OFF). Um recurso nestes lugares marca o modo de opera\u00e7\u00e3o\n\natual do componente.\n\nO lugar Atomic_Execution \u00e9 respons\u00e1vel por garantir que opera-\n\n\u00e7\u00f5es diferentes de troca de modo de opera\u00e7\u00e3o n\u00e3o sejam executadas em paralelo. Para\n\n\n\n36\n\nFigura 3.2: Comportamento da rede generalizada de troca de modos de opera\u00e7\u00e3o.\n\nisto, este lugar \u00e9 sempre inicializado com um recurso. Este recurso \u00e9 necess\u00e1rio para\n\nhabilitar as transi\u00e7\u00f5es que disparam as mudan\u00e7as de modos de opera\u00e7\u00e3o. A partir do mo-\n\nmento que uma chamada \u00e9 realizada \u00e0 API de ger\u00eancia de energia solicitando a troca de\n\nmodo de opera\u00e7\u00e3o, uma das transi\u00e7\u00f5es que representam estas chamadas \u00e0 API \u00e9 dispa-\n\nrada (no exemplo, power(FULL)), consumindo o recurso de Atomic_Execution e\n\nimpedindo que as transi\u00e7\u00f5es que d\u00e3o in\u00edcio \u00e0s demais trocas de modo de opera\u00e7\u00e3o sejam\n\ndisparadas (verificar rede completa no anexo A). Al\u00e9m disso, um novo recurso inserido no\n\nlugar Triggering_FULL permite a habilita\u00e7\u00e3o das transi\u00e7\u00f5es que removem o recurso\n\nque marca o modo de opera\u00e7\u00e3o atual do componente (no lugar OFF). Como o compo-\n\nnente do exemplo est\u00e1 no modo OFF, apenas a transi\u00e7\u00e3o OFF_TO_FULL \u00e9 habilitada. A\n\npartir do seu disparo, o recurso que marcava o lugar OFF \u00e9 consumido, e tr\u00eas recursos s\u00e3o\n\ninseridos no lugar FULL_Enable. Isto \u00e9 feito para habilitar a transi\u00e7\u00e3o Enter_FULL,\n\nque \u00e9 respons\u00e1vel por executar as opera\u00e7\u00f5es necess\u00e1rias para que o componente seja efe-\n\ntivamente colocado no modo de opera\u00e7\u00e3o desejado. Ap\u00f3s o disparo desta transi\u00e7\u00e3o, dois\n\nrecursos s\u00e3o inseridos no lugar FULL, habilitando a transi\u00e7\u00e3o FULL_Entered, que fina-\n\nliza o processo consumindo o recurso restante do lugar FULL_Enable e retornando um\n\nrecurso para o lugar Atomic_Execution. Ao final do procedimento, um recurso foi\n\nretirado do lugar OFF e inserido no lugar FULL. Para evitar a ocorr\u00eancia de deadlocks ao\n\n\n\n37\n\ndisparar transi\u00e7\u00f5es que levem ao modo de opera\u00e7\u00e3o atual do componente, uma outra tran-\n\nsi\u00e7\u00e3o teve que ser inserida (Recurrence). Esta transi\u00e7\u00e3o retorna o recurso tomado do\n\nlugar Atomic_Execution em caso de recorr\u00eancia (e.g., solicitar disparo da transi\u00e7\u00e3o\n\npower(FULL) quando j\u00e1 houver um recurso no lugar FULL).\n\nA rede de troca de modos de opera\u00e7\u00e3o generalizada foi submetida a uma\n\nferramenta de an\u00e1lise [AKH 05], o que permitiu verificar algumas propriedades da rede\n\nimplementada:\n\nVivacidade: A an\u00e1lise da vivacidade desta rede permite determinar a exist\u00eancia ou n\u00e3o\n\nde deadlocks. Para isso, \u00e9 necess\u00e1rio que todas as transi\u00e7\u00f5es da rede em quest\u00e3o\n\nsejam quase-vivas. Uma transi\u00e7\u00e3o \u00e9 dita quase-viva quando existe uma seq\u00fc\u00ean-\n\ncia de disparo de transi\u00e7\u00f5es a partir de uma marca\u00e7\u00e3o inicial que conduzir\u00e1 a seu\n\ndisparo. Neste caso, esta rede de Petri pode ser considerada livre de deadlock\n\na partir da marca\u00e7\u00e3o inicial utilizada, ou seja, um recurso depositado no lugar\n\nAtomic_Execution e outro em um dos lugares referentes aos modos de opera-\n\n\u00e7\u00e3o (FULL, LIGHT, STANDBY ou OFF).\n\nAlcan\u00e7abilidade: A an\u00e1lise de alcan\u00e7abilidade permite identificar as marca\u00e7\u00f5es pos-\n\ns\u00edveis de serem atingidas a partir de uma marca\u00e7\u00e3o inicial. Esta an\u00e1lise \u00e9 feita\n\natrav\u00e9s da montagem de um grafo de alcan\u00e7abilidade, que inclui todos os poss\u00edveis\n\nestados da rede. Para esta rede, a an\u00e1lise de alcan\u00e7abilidade p\u00f4de ser completa, j\u00e1\n\nque seu grafo de alcan\u00e7abilidade resultou em um n\u00famero finito de estados. Assim,\n\nfoi poss\u00edvel concluir que todos os estados desejados foram alcan\u00e7ados, e que esta-\n\ndos indesejados (e.g., recursos presentes em mais de um lugar referente a modo de\n\nopera\u00e7\u00e3o simultaneamente) n\u00e3o s\u00e3o poss\u00edveis de serem alcan\u00e7ados.\n\nA rede generalizada representa a troca de modos de opera\u00e7\u00e3o sob uma\n\nvis\u00e3o de alto n\u00edvel, onde as especificidades envolvidas nestas trocas n\u00e3o est\u00e3o expressas.\n\nLogo, para tornar poss\u00edvel a infer\u00eancia dos procedimentos de troca de modos de opera\u00e7\u00e3o\n\na partir desta rede, um refinamento \u00e9 necess\u00e1rio. Este refinamento \u00e9 feito explorando\n\na caracter\u00edstica hier\u00e1rquica das Redes de Petri. Atrav\u00e9s desta caracter\u00edstica, uma rede\n\n\n\n38\n\ninteira pode ser substitu\u00edda por um lugar ou transi\u00e7\u00e3o para modelar um n\u00edvel mais abstrato\n\n(abstra\u00e7\u00e3o), ou lugares e transi\u00e7\u00f5es podem ser substitu\u00eddos por sub-redes para prover um\n\nmodelo mais detalhado (refinamento).\n\nA figura 3.3 apresenta um exemplo de refinamento para aplica\u00e7\u00e3o da\n\nrede generalizada no controle dos modos de opera\u00e7\u00e3o do componente CMAC. Para refi-\n\nnar os procedimentos de troca de modo de opera\u00e7\u00e3o na rede generalizada, as transi\u00e7\u00f5es\n\n\u201cEnter\u201d s\u00e3o substitu\u00eddas por subredes que implementam os procedimentos de troca de\n\nmodo de opera\u00e7\u00e3o com maior detalhe. No exemplo, \u00e9 apresentada a subrede que imple-\n\nmenta a mudan\u00e7a do componente CMAC para o modo de opera\u00e7\u00e3o FULL. Para formar\n\na rede de troca de modos de opera\u00e7\u00e3o deste componente, esta subrede substitui a tran-\n\nsi\u00e7\u00e3o Enter_FULL na rede generalizada. Esta subrede ainda apresenta transi\u00e7\u00f5es que\n\nabstraem o disparo das trocas de modo de opera\u00e7\u00e3o de outros componentes.\n\nO CMAC \u00e9 uma implementa\u00e7\u00e3o em software de um MAC (Media Ac-\n\ncess Control) configur\u00e1vel para um m\u00f3dulo de rede de sensores sem fio [HIL 00]. Neste\n\ndispositivo, a comunica\u00e7\u00e3o entre o processador e o r\u00e1dio \u00e9 realizada atrav\u00e9s de um bar-\n\nramento serial (SPI). Neste exemplo, \u00e9 esperado que a aplica\u00e7\u00e3o utilize a API do com-\n\nponente CMAC como interface das funcionalidades de comunica\u00e7\u00e3o. Quando a aplica\u00e7\u00e3o\n\nrealiza uma chamada \u00e0 fun\u00e7\u00e3o CMAC::power(FULL), por exemplo, o procedimento\n\npara ligar as funcionalidades de comunica\u00e7\u00e3o deve iniciar ligando o dispositivo de r\u00e1dio\n\n(Radio::power(FULL)), passado ao ligamento do dispositivo respons\u00e1vel pela co-\n\nmunica\u00e7\u00e3o com o tranceptor de r\u00e1dio (SPI::power(FULL)). A partir deste ponto o\n\nmecanismo de envio de dados j\u00e1 est\u00e1 inicializado. J\u00e1 o mecanismo de recep\u00e7\u00e3o necessita\n\nde um temporizador, que \u00e9 utilizado para estabelecer o beacon de verifica\u00e7\u00e3o da exist\u00eancia\n\nde portadoras na freq\u00fc\u00eancia de opera\u00e7\u00e3o do r\u00e1dio. Ap\u00f3s a inicializa\u00e7\u00e3o do temporizador\n\n(Timer::power(FULL)), o CMAC est\u00e1 ativo. A pr\u00f3xima se\u00e7\u00e3o descreve como as re-\n\ndes de troca de modo de opera\u00e7\u00e3o s\u00e3o montadas para permitir a propaga\u00e7\u00e3o destas trocas\n\nentre os componentes do sistema.\n\n\n\n39\n\n2\n\n2\n\nRede Generalizada (Simplificada)\nSubrede para modo de opera\u00e7\u00e3o FULL do componente CMAC\n\nFigura 3.3: Refinamento com rede de Petri hier\u00e1rquica para o componente CMAC.\n\n\n\n40\n\n3.3 Propaga\u00e7\u00e3o de Mensagens\n\nConforme as aplica\u00e7\u00f5es embarcadas crescem em complexidade, elas\n\npassam a usar um maior n\u00famero de componentes de sistema. Com isso, pode se tornar\n\nimpratic\u00e1vel para programadores de aplica\u00e7\u00e3o controlar o consumo de energia de cada\n\ncomponente individualmente. Na maioria das vezes esta complexidade est\u00e1 evidente na\n\naplica\u00e7\u00e3o quando ela faz uso de v\u00e1rios componentes diretamente. Contudo, mesmo apli-\n\nca\u00e7\u00f5es extremamente simples podem utilizar um conjunto complexo de componentes.\n\nComo exemplo, a figura 3.4 apresenta uma aplica\u00e7\u00e3o hipot\u00e9tica em que\n\na ger\u00eancia do consumo de energia \u00e9 feita pela aplica\u00e7\u00e3o. A aplica\u00e7\u00e3o utilizada imple-\n\nmenta um m\u00f3dulo de telemetria que envia a leitura de um sensor de press\u00e3o a cada dois\n\nsegundos atrav\u00e9s de um modem GPRS. Na figura 3.4(a) fica claro a complexidade exis-\n\ntente ao se oferecer somente APIs para componentes isolados do sistema. Neste exemplo,\n\nantes de desligar o modem, a pilha de comunica\u00e7\u00e3o TCP/IP precisa ser \u201cdesligada\u201d, ou\n\nseja, precisa ter todos os dados enviados antes que o modem possa ser desligado. Ap\u00f3s\n\no desligamento do modem, ainda \u00e9 desej\u00e1vel que uma das portas seriais (UART) tam-\n\nb\u00e9m seja desligada, j\u00e1 que \u00e9 atrav\u00e9s desta porta que o processador realiza a comunica\u00e7\u00e3o\n\ncom o modem. Neste caso, como o exemplo \u00e9 hipot\u00e9tico, n\u00e3o foram considerados outros\n\ncomponentes que poderiam estar sendo utilizados (e.g., um temporizador para controlar\n\ntime-outs no protocolo de comunica\u00e7\u00e3o). Complexidades semelhantes a esta est\u00e3o pre-\n\nsentes em quase todos componentes de alto-n\u00edvel de um sistema. Abstrair estes detalhes\n\ndo programador de uma aplica\u00e7\u00e3o embarcada melhora em muito a usabilidade da API,\n\ncomo mostram a s figuras 3.4(b) e 3.4(c).\n\nO restante desta se\u00e7\u00e3o \u00e9 dedicada a apresentar como esta proposta ex-\n\nplora a organiza\u00e7\u00e3o hier\u00e1rquica das redes de troca de modos de opera\u00e7\u00e3o para identificar\n\nas rela\u00e7\u00f5es entre componentes e propagar mensagens para coordenar as trocas de modo\n\nde opera\u00e7\u00e3o.\n\n\n\n41\n\nvoid event() {\nstatic Modem modem;\nstatic Pressure_Sensor sensor;\nint pressure = sensor.sample();\nmodem.send(dest, &amp;pressure, 2);\n//Stoping communication\nNetwork::flush();\nmodem.power(STANDBY);\nUART::power(STANDBY);\n//Stoping sensor\nsensor.power(STANDBY);\nADC::power(STANDBY);\n\n}\n\nint main() {\nAlarm alarm(2000000, &amp;event);\nwhile(1) {\n//Stoping processing\nCPU::power(STANDBY);\n\n}\n}\n\n(a) Controlando todos componentes\n\nvoid event() {\nstatic Modem modem;\nstatic Pressure_Sensor sensor;\nint pressure = sensor.sample();\nmodem.send(dest, &amp;pressure, 2);\n//Stoping communication\n\nmodem.power(STANDBY);\n\n//Stoping sensor\nsensor.power(STANDBY);\n\n}\n\nint main() {\nAlarm alarm(2000000, &amp;event);\nwhile(1) {\n//Stoping processing\nCPU::power(STANDBY);\n\n}\n}\n\n(b) Controlando subsistemas\n\nvoid event() {\nstatic Modem modem;\nstatic Pressure_Sensor sensor;\nint pressure = sensor.sample();\nmodem.send(dest, &amp;pressure, 2);\n\n}\n\nint main() {\nAlarm alarm(2000000, &amp;event);\nwhile(1) {\n//Stoping everything\nSystem::power(STANDBY);\n\n}\n}\n\n(c) Controlando todo o sistema\n\nFigura 3.4: Aplica\u00e7\u00f5es hipot\u00e9ticas com ger\u00eancia do consumo de energia dirigido pela aplica\u00e7\u00e3o.\n\n\n\n42\n\n3.3.1 Propaga\u00e7\u00e3o Hier\u00e1rquica de Mensagens\n\nPara que um conjunto de componentes envolvido na implementa\u00e7\u00e3o de\n\nalguma funcionalidade seja desativado ou colocado em modos de opera\u00e7\u00e3o mais restritos\n\nde forma eficiente \u00e9 necess\u00e1rio garantir que os artefatos de software e hardware primei-\n\nramente finalizem as atividades iniciadas, ou que se adaptem aos novos par\u00e2metros de\n\nopera\u00e7\u00e3o. Da mesma forma, \u00e9 necess\u00e1rio garantir que estes componentes possam operar\n\ncorretamente ao retornar para modos de opera\u00e7\u00e3o funcionais. Para tanto, \u00e9 necess\u00e1rio\n\nestabelecer um mecanismo pelo qual os componentes possam interagir, al\u00e9m de um meio\n\npelo qual estas intera\u00e7\u00f5es possam ser especificadas.\n\nDadas as defini\u00e7\u00f5es j\u00e1 apresentadas (API e redes de troca de modos\n\nde opera\u00e7\u00e3o), \u00e9 poss\u00edvel definir os procedimentos de troca de modo de opera\u00e7\u00e3o para\n\ncada componente. Neste contexto, o mecanismo de intera\u00e7\u00e3o \u00e9 formado por trocas de\n\nmensagens atrav\u00e9s da API. J\u00e1 a seq\u00fc\u00eancia em que a\u00e7\u00f5es devem ser executadas ou men-\n\nsagens devem ser propagadas pode ser derivada das Redes de Petri de cada componente.\n\nAnalisando a rede da figura 3.3, \u00e9 poss\u00edvel notar a exist\u00eancia de transi\u00e7\u00f5es que dispa-\n\nram trocas de modos de opera\u00e7\u00e3o em outros componentes (Radio::power(FULL),\n\nSPI::power(FULL) e Timer::power(FULL)). Estas transi\u00e7\u00f5es constituem os pon-\n\ntos em que h\u00e1 trocas de mensagens entre componentes. Utilizando a propriedade hier\u00e1r-\n\nquica das Redes de Petri para realizar todas as substitui\u00e7\u00f5es existentes, a rede de troca\n\npara o modo FULL do componente CMAC seria a rede apresentada na figura 3.5.\n\nA partir da an\u00e1lise das redes \u00e9 poss\u00edvel montar, em tempo de compila-\n\n\u00e7\u00e3o, os m\u00e9todos que garantir\u00e3o a seq\u00fc\u00eancia correta de execu\u00e7\u00e3o dos procedimentos de\n\ntroca de modos de opera\u00e7\u00e3o. No exemplo do CMAC (figura 3.5) as tr\u00eas conex\u00f5es com\n\noutras redes (Timer, SPI e Radio) indicam o ponto onde h\u00e1 troca de mensagens entre\n\nos componentes, ou seja, onde h\u00e1 a propaga\u00e7\u00e3o das trocas de modo de opera\u00e7\u00e3o. Reali-\n\nzando a an\u00e1lise desta rede \u00e9 poss\u00edvel extrair um procedimento algoritmo como o descrito\n\npelos diagramas de atividades apresentados na figura 3.6. A atividade Power representa\n\no comportamento esperado para controle das trocas de modo de opera\u00e7\u00e3o pela rede de\n\ntroca de modo de opera\u00e7\u00e3o generalizada (anexo A). As outras atividades representam o\n\n\n\n43\n\n2\n\n2\n\n2\n\n2\n\n2\n\n2\n\n2\n\n2\n\nFigura 3.5: Rede completa de troca para o modo FULL do componente CMAC.\n\n\n\n44\n\ncomportamento esperado do c\u00f3digo extra\u00eddo das redes dos componentes envolvidos na\n\ncomunica\u00e7\u00e3o do sistema. Por exemplo, na atividade CMAC Entra FULL h\u00e1 chamadas\n\npara a atividade Power dos componentes que o CMAC utiliza em sua implementa\u00e7\u00e3o,\n\nrepresentando os pontos onde h\u00e1 propaga\u00e7\u00e3o das trocas de modo de opera\u00e7\u00e3o.\n\nEntra OFF\n\nEntra FULL\n\nEntra LIGHT\n\nEntra STANDBY\nstart\n\nseleciona modo\n\n[mode = OFF]\n\n[mode = FULL]\n\n[mode = STANDBY]\n\n[mode = LIGHT]\n\nend\n\nact Power\n\nstart\n\nend\n\nRadio Power FULL\n\nSPI Power FULL\n\nTimer Power FULL\n\nact CMAC Entra FULL\n\nstart\n\nend\n\nConfigura Pot\u00eancia\nM\u00e1xima\n\nLiga Receptor\ne Emissor\n\nact Radio Entra FULL\n\nstart\nLiga SPI\n\nLiga Interrup\u00e7\u00f5es\nend\n\nact SPI Entra FULL\n\nstart\n\nend\n\nInicia Timer\n\nact Timer Entra FULL\n\nFigura 3.6: Procedimentos para troca de modo de opera\u00e7\u00e3o.\n\nPropaga\u00e7\u00e3o para todo o sistema\n\nA\u00e7\u00f5es de ger\u00eancia do consumo de energia do sistema como um todo\n\ns\u00e3o tratadas por um componente global do sistema (System). Este componente cont\u00e9m\n\nrefer\u00eancias para todos os componentes em uso pela aplica\u00e7\u00e3o. Ent\u00e3o, se uma aplica\u00e7\u00e3o\n\ndeseja alterar o modo de opera\u00e7\u00e3o do sistema inteiro, isto pode ser feito acessando a API\n\ndeste componente, que propagar\u00e1 este pedido para os demais componentes. Isto ser\u00e1\n\nfeito atrav\u00e9s de uma lista montada em tempo de execu\u00e7\u00e3o atrav\u00e9s do aspecto de ger\u00eancia\n\nde energia, que utilizar\u00e1 as chamadas de constru\u00e7\u00e3o e destrui\u00e7\u00e3o de componentes para,\n\nrespectivamente, incluir e remover refer\u00eancias a inst\u00e2ncias de componentes desta lista.\n\nQuando a API de ger\u00eancia do consumo de energia do sistema \u00e9 acessada pela aplica\u00e7\u00e3o,\n\n\n\n45\n\no sistema realiza uma varredura pela lista de inst\u00e2ncias que possui, disparando chamadas\n\n\u00e0s APIs dos componentes que registrou.\n\n3.3.2 Compartilhamento de Recursos\n\nO compartilhamento de recursos \u00e9 uma caracter\u00edstica de sistemas com-\n\nputacionais que precisa ser tratada nesta proposta. Problemas podem ocorrer na troca de\n\nmodos de opera\u00e7\u00e3o quando componentes de alto n\u00edvel compartilham o mesmo compo-\n\nnente de hardware. Por exemplo, uma aplica\u00e7\u00e3o que utiliza dois sensores que comparti-\n\nlham o mesmo conversor anal\u00f3gico-digital (ADC) n\u00e3o pode ter o ADC desligado devido\n\n\u00e0 solicita\u00e7\u00e3o de um dos sensores se o outro sensor ainda o est\u00e1 utilizando (figura 3.7).\n\nADC\n\n:Accelerometer :ADX202\n1.1: power(OFF)1: power(OFF)\n\n:Temperature_Sensor\n1: power(FULL)\n\n:ERT?J1VR103J\n1.1: power(FULL)\n\n1.2: power(OFF)\n\n1.2: power(FULL)\n\nThread B\n\nThread A\n\nFigura 3.7: Dois sensores diferentes compartilham o mesmo ADC.\n\nPara resolver este problema, foi adotado um mecanismo de contadores\n\nde uso. Cada componente compartilhado possui um contador de refer\u00eancias para cada\n\nmodo de opera\u00e7\u00e3o. Atrav\u00e9s deste mecanismo \u00e9 poss\u00edvel saber quantos \u201cusu\u00e1rios\u201d (i.e.,\n\noutros componentes do sistema ou aplica\u00e7\u00f5es) utilizam cada componente. Como os mo-\n\ndos de opera\u00e7\u00e3o de cada componente est\u00e3o organizados para representar estados de maior\n\nconsumo/desempenho para menor consumo/desempenho (FULL\u2013OFF), os componentes\n\ndo sistema permanecem no modo de opera\u00e7\u00e3o com maior n\u00famero de funcionalidades que\n\npossuir \u201cusu\u00e1rios\u201d. Para isto, sempre que uma requisi\u00e7\u00e3o de troca de modos de opera\u00e7\u00e3o\n\n\u00e9 feita, os contadores do componente s\u00e3o atualizados (contador do modo atual decremen-\n\ntado e do modo pretendido incrementado) e um teste \u00e9 realizado verificando o somat\u00f3rio\n\ndos contadores para os modos de opera\u00e7\u00e3o \u201cmaiores\u201d que o pretendido, ou seja, mo-\n\n\n\n46\n\ndos de opera\u00e7\u00e3o menos restritos. Se o somat\u00f3rio for zero, o componente entra no modo\n\npretendido. Se houver usu\u00e1rios para modos de opera\u00e7\u00e3o menos restritos, o componente\n\npermanece como est\u00e1 at\u00e9 que novas solicita\u00e7\u00f5es de troca de modo de opera\u00e7\u00e3o sejam\n\nrealizadas.\n\nAs propostas apresentadas neste cap\u00edtulo definem as caracter\u00edsticas de-\n\nsej\u00e1veis de um gerente de energia dirigido pela aplica\u00e7\u00e3o para sistemas embarcados. Uma\n\nAPI configur\u00e1vel de ger\u00eancia de energia foi definida e um mecanismo baseado em Redes\n\nde Petri foi utilizado para especificar os procedimentos para troca de modo de opera\u00e7\u00e3o\n\ndos componentes do sistema. O pr\u00f3ximo cap\u00edtulo apresenta como esta proposta foi im-\n\nplementada no EPOS, um sistema operacional baseado em componentes para plataformas\n\nembarcadas.\n\n\n\nCap\u00edtulo 4\n\nImplementa\u00e7\u00e3o do Gerente de Energia\n\nProposto\n\nEste cap\u00edtulo apresenta e discute a implementa\u00e7\u00e3o de um prot\u00f3tipo do\n\ngerente de energia proposto neste trabalho. Primeiramente \u00e9 apresentado o ambiente ex-\n\nperimental de software e hardware utilizado. A seguir, \u00e9 apresentada a solu\u00e7\u00e3o desen-\n\nvolvida para a implementa\u00e7\u00e3o do gerente de energia como um aspecto e para a gera\u00e7\u00e3o\n\nautom\u00e1tica de c\u00f3digo a partir das redes de modos de opera\u00e7\u00e3o.\n\n4.1 Ambiente Experimental\n\nO gerente de energia foi implementado no sistema operacional EMBED-\n\nDED PARALLEL OPERATING SYSTEM (EPOS) [FR\u00f6 01]. O EPOS \u00e9 um framework ba-\n\nseado em componentes que permite a gera\u00e7\u00e3o de sistemas operacionais adaptados para\n\naplica\u00e7\u00f5es dedicadas. Implementa\u00e7\u00f5es deste sistema para dois microcontroladores foram\n\nutilizados (ATMEGA16 e ATMEGA128). Al\u00e9m disto, suporte para outros componentes\n\npresentes em algumas das plataformas utilizadas foi desenvolvido em conjunto com um\n\ntrabalho paralelo que explorou suporte de sistema operacional para aplica\u00e7\u00f5es de redes de\n\nsensores sem fio [WAN 06]. Esta se\u00e7\u00e3o apresenta este ambiente experimental em maior\n\ndetalhe.\n\n\n\n48\n\n4.1.1 Embedded Parallel Operating System - EPOS\n\nO sistema operacional EPOS foi proposto por Fr\u00f6hlich como prot\u00f3tipo\n\npara provar os conceitos de sua metodologia de projeto de sistemas orientados a aplica-\n\n\u00e7\u00e3o (Application-Oriented System Design - AOSD) [FR\u00f6 01]. Esta metodologia utiliza\n\nv\u00e1rias t\u00e9cnicas avan\u00e7adas de engenharia de software e programa\u00e7\u00e3o que, combinadas,\n\npermitem a gera\u00e7\u00e3o de sistemas especializados para aplica\u00e7\u00f5es dedicadas. Desde sua cri-\n\na\u00e7\u00e3o, o EPOS tem servido como ambiente para valida\u00e7\u00e3o e extens\u00e3o dos conceitos desta\n\nmetodologia.\n\nO EPOS oferece aos programadores de aplica\u00e7\u00e3o um framework ba-\n\nseado em componentes que permite a configura\u00e7\u00e3o e a gera\u00e7\u00e3o de sistemas operacio-\n\nnais adaptados para aplica\u00e7\u00f5es dedicadas, isto \u00e9, sistemas espec\u00edficos contendo apenas\n\nos componentes necess\u00e1rios para suportar a aplica\u00e7\u00e3o em quest\u00e3o. O framework do\n\nEPOS oferece ao programador da aplica\u00e7\u00e3o um conjunto de componentes de alto-n\u00edvel,\n\nchamados de Abstra\u00e7\u00f5es, que implementam funcionalidades abstratas como Thread,\n\nCommunicator e Sensor de forma independente de arquitetura. Estes componentes\n\nutilizam outros componentes deste sistema, chamados de Mediadores, que abstraem os\n\ndispositivos de hardware e exportam as funcionalidades destes dispositivos atrav\u00e9s de uma\n\ninterface uniforme, possibilitando a independ\u00eancia arquitetural das Abstra\u00e7\u00f5es. Al\u00e9m dos\n\ncomponentes do sistema o EPOS tamb\u00e9m utiliza aspectos [KIC 97] e caracter\u00edsticas con-\n\nfigur\u00e1veis [CZA 98]. O primeiro permite a fatora\u00e7\u00e3o de caracter\u00edsticas n\u00e3o-funcionais do\n\nsistema (e.g., compartilhamento, identifica\u00e7\u00e3o) em artefatos de software independentes, o\n\nsegundo permite que os componentes do sistema sejam configurados. O uso de aspectos e\n\nde caracter\u00edsticas configur\u00e1veis aliados a t\u00e9cnicas de programa\u00e7\u00e3o avan\u00e7adas como meta-\n\nprograma\u00e7\u00e3o est\u00e1tica e programa\u00e7\u00e3o orientada a aspectos disponibiliza \u00e0 aplica\u00e7\u00e3o um\n\nsistema altamente configur\u00e1vel e adaptativo.\n\nO sistema EPOS foi utilizado n\u00e3o somente por ter sido desenvolvido\n\ndentro do mesmo grupo de pesquisa deste trabalho, mas tamb\u00e9m por possuir caracter\u00eds-\n\nticas interessantes para a implementa\u00e7\u00e3o da proposta. Dentre estas caracter\u00edsticas cabe\n\ncitar:\n\n\n\n49\n\n\u2022 A organiza\u00e7\u00e3o do sistema em componentes de software, que permite o desenvol-\n\nvimento das redes hier\u00e1rquicas de troca de modos de opera\u00e7\u00e3o de forma modular,\n\ndiminuindo sua complexidade.\n\n\u2022 O uso de interfaces bem definidas para componentes do sistema, que facilitam a\n\nintera\u00e7\u00e3o com os componentes do sistema, tamb\u00e9m facilitando o desenvolvimento\n\ndas redes de troca de modos de opera\u00e7\u00e3o.\n\n\u2022 O fato deste sistema permitir a implementa\u00e7\u00e3o de componentes de software como\n\naspectos. No EPOS aspectos s\u00e3o implementados atrav\u00e9s da t\u00e9cnica chamada Adap-\n\ntadores de Cen\u00e1rio [D\u2019A 05], que implementa os aspectos utilizando t\u00e9cnicas de\n\nmeta-programa\u00e7\u00e3o est\u00e1tica e sem o uso de weavers de c\u00f3digo.\n\n4.1.2 Ambiente de Hardware\n\nDurante o desenvolvimento deste trabalho o sistema EPOS foi portado\n\npara a arquitetura de processadores AVR em conjunto com outro projeto, que explorou\n\nsuporte de sistema operacional para redes de sensores sem fio. Sendo assim, o prot\u00f3tipo\n\nde gerente de energia desenvolvido foi implementado e testado em processadores desta\n\narquitetura e utilizando m\u00f3dulos de sensoriamento. Esta se\u00e7\u00e3o descrever\u00e1 o ambiente de\n\nhardware utilizado.\n\nMicrocontroladores AVR\n\nOs microcontroladores AVR s\u00e3o produzidos pela ATMEL [ATM 04a].\n\nEstes microcontroladores RISC (Reduced Instruction Set Computer) de 8 bits s\u00e3o basea-\n\ndos na arquitetura de Harvard, ou seja, possuem barramentos separados para instru\u00e7\u00f5es e\n\ndados. H\u00e1 v\u00e1rios modelos destes microcontroladores, cada um oferecendo uma combina-\n\n\u00e7\u00e3o diferente de perif\u00e9ricos como temporizador, UART (Universal Asynchronous serial\n\nReceiver and Transmitter), SPI (Serial Peripheral Interface) e ADC (Analog to Digital\n\nConverter).\n\nPara os prot\u00f3tipos deste trabalho foram utilizados microcontroladores\n\n\n\n50\n\nAVR dos modelos ATMEGA128L e ATMEGA16. No que tange o controle do consumo\n\nde energia, estes microcontroladores apresentam seis diferentes modos de opera\u00e7\u00e3o de\n\nbaixo consumo de energia (sleep modes). Como pode ser observado na tabela 4.1.2, a\n\nescolha do modo de opera\u00e7\u00e3o correto para utilizar pode impactar bastante no consumo\n\nde energia, j\u00e1 que a pot\u00eancia nos diferentes modos de opera\u00e7\u00e3o apresenta uma grande\n\nvaria\u00e7\u00e3o.\n\nModo de opera\u00e7\u00e3o Pot\u00eancia Corrente\n\nidle 14.28 mW 4.8 mA\n\npower save 0.79 \u00b5W 266 \u00b5A\n\npower down 0.71 \u00b5W 239 \u00b5A\n\nTabela 4.1: Pot\u00eancia e corrente drenada para alguns dos modos de opera\u00e7\u00e3o do ATMEGA128.\n\nAdaptada de Kellner [KEL 06].\n\nM\u00f3dulos de Sensoriamento: Mica Mote2\n\nA plataforma MICA2 \u00e9 um m\u00f3dulo de sensoriamento para redes de sen-\n\nsores sem fio desenvolvido pela CrossBow [CRO 06]. Basicamente, esta plataforma \u00e9\n\num dispositivo alimentado por baterias composto por um microcontrolador Atmel AT-\n\nMEGA128, um transceiver de r\u00e1dio Chipcon CC1000 [AS 04] e um conjunto de senso-\n\nres (temperatura, luminosidade, acelera\u00e7\u00e3o, etc). Suporte de sistema operacional atrav\u00e9s\n\ndo EPOS para este m\u00f3dulo de sensoriamento foi desenvolvido por Wanner [WAN 06].\n\nO dispositivo de comunica\u00e7\u00e3o deste m\u00f3dulo, o CC1000, \u00e9 um transcei-\n\nver de radio freq\u00fc\u00eancia de baix\u00edssimo consumo de energia. Este dispositivo apresenta uma\n\ngrande variedade de caracter\u00edsticas que podem ser ajustadas para atender necessidades es-\n\npec\u00edficas de cada aplica\u00e7\u00e3o. Estas mesmas caracter\u00edsticas permitem tamb\u00e9m configurar o\n\ndispositivo para consumir ainda menos energia. Dentre o que pode ser configurado neste\n\ntransceiver est\u00e3o a freq\u00fc\u00eancia de opera\u00e7\u00e3o (de 300 a 1000 MHz), pot\u00eancia de envio (de\n\n-20 a 10 dBm) e tens\u00e3o de alimenta\u00e7\u00e3o (de 2.1 a 3.6 V). Al\u00e9m destas caracter\u00edsticas, o\n\n\n\n51\n\nCC1000 ainda apresenta um modo de espera (Power Down Mode) e recursos para ligar e\n\ndesligar os m\u00f3dulos de envio (TX) e recep\u00e7\u00e3o (RX) separadamente. Diferentes modos de\n\nopera\u00e7\u00e3o para este dispositivo apresentam diferen\u00e7as consider\u00e1veis no consumo de ener-\n\ngia, como pode ser observado na tabela 4.1.2, que relaciona pot\u00eancia e corrente drenada\n\npara alguns dos modos de opera\u00e7\u00e3o do transceiver.\n\nModo de opera\u00e7\u00e3o Pot\u00eancia Corrente\n\nPower Down 0.66 \u00b5W 0.2 \u00b5A\n\nReceive 31.7 mW 9.6 mA\n\nReceive with polling 0.32 mW 96 \u00b5A\n\nTransmit (-20 dBm) 28.4 mW 8.6 mA\n\nTransmit (-5 dBm) 45.5 mW 13.8 mA\n\nTransmit (0 dBm) 54.5 mW 16.5 mA\n\nTransmit (5 dBm) 83.8 mW 25.4 mA\n\nTabela 4.2: Pot\u00eancia e corrente drenada do CC1000 operando a uma tens\u00e3o de 3.3 V e frequ\u00eancia\n\nde transmiss\u00e3o de 868 MHz.\n\nO MICA2 tamb\u00e9m possui um grande conjunto de sensores dispon\u00edveis.\n\nEstes sensores apresentam caracter\u00edsticas variadas e, geralmente, consomem uma quan-\n\ntidade razo\u00e1vel de energia. Por exemplo, o sensor de temperatura presente nesta plata-\n\nforma, que \u00e9 um termistor, ou seja, um resistor cuja resist\u00eancia varia conforme a tempera-\n\ntura, pode apresentar uma pot\u00eancia equivalente \u00e0 apresentada pelo r\u00e1dio quando enviando\n\ndados em seu modo de opera\u00e7\u00e3o mais potente. O dispositivo presente na plataforma em\n\nquest\u00e3o \u00e9 um ERT-J1VR103J da Panasonic [PAN 04]. A pot\u00eancia deste dispositivo,\n\ndependendo da temperatura e, conseq\u00fcentemente, da resist\u00eancia assumida, pode atingir\n\nat\u00e9 100 mW, o que \u00e9 preocupantemente alto. Para evitar consumo de energia excessivo, o\n\nMICA2 disponibiliza pinos de controle que permitem inibir a corrente que alimenta estes\n\nsensores, permitindo \u201clig\u00e1-los\u201d apenas quando necess\u00e1rio.\n\n\n\n52\n\n4.2 Extens\u00e3o dos Componentes Para Inclus\u00e3o da API\n\nComo dito anteriormente, no sistema EPOS aspectos s\u00e3o aplicados aos\n\ncomponentes atrav\u00e9s da t\u00e9cnica chamada adaptadores de cen\u00e1rio. A figura 4.1 apresenta\n\na estrutura de um adaptador de cen\u00e1rio no EPOS. O aspecto (cen\u00e1rio) implementa m\u00e9-\n\ntodos que realizam as a\u00e7\u00f5es que devem ser inclu\u00eddas antes ou depois do m\u00e9todo original\n\natrav\u00e9s dos m\u00e9todos enter e leave. Por este mecanismo tamb\u00e9m \u00e9 poss\u00edvel estender a\n\ninterface do componente alvo. Para isto basta apenas incluir um novo m\u00e9todo ao cen\u00e1rio\n\ne este m\u00e9todo \u00e9 adicionado \u00e0 interface do componente atrav\u00e9s da heran\u00e7a existente entre\n\nScenario e Adapter.\n\n+leave()\n+enter()\n\n+new_method() +operation(parms): result\n\nAbs\n\nAbs\n+operation(parms): result\n\nenter();\n\nleave();\nreturn res;\n\nResult res = Abs::operation(args);\n\nClient\n\nAbs\nScenario\n\nAbs\nAdapter\n\nFigura 4.1: Adaptador de cen\u00e1rio no EPOS\n\nSendo assim, um adaptador de cen\u00e1rio para ger\u00eancia de energia foi defi-\n\nnido. A figura 4.2 mostra um diagrama UML deste adaptador de cen\u00e1rio. Este adaptador\n\nfoi modelado para, atrav\u00e9s da extens\u00e3o da interface do componente, incluir os m\u00e9todos\n\ndefinidos pela API de ger\u00eancia de energia desta proposta. Outra caracter\u00edstica definida\n\npela API \u00e9 a abstra\u00e7\u00e3o do retorno dos componentes a um modo operacional. A proposta\n\n\u00e9 que os componentes que estiverem desligados (em um modo de opera\u00e7\u00e3o OFF) sejam\n\ncolocados em seu modo de opera\u00e7\u00e3o anterior quando acessados. Para que isto ocorra o\n\nm\u00e9todo enter do adaptador de cen\u00e1rio seria adaptado para realizar um teste antes da exe-\n\n\n\n53\n\ncu\u00e7\u00e3o do m\u00e9todo chamado. Contudo, foi considerado que a realiza\u00e7\u00e3o constante destes\n\ntestes, que ocorreriam mesmo quando o componente estivesse em um modo operacional,\n\naumentaria a carga de processamento do sistema de forma indesej\u00e1vel.\n\n+power(mode:OP_Mode)\n+power():OP_Mode\n+leave()\n+enter()\n\n  retornar ao modo de opera\u00e7\u00e3o anterior\nSe componente est\u00e1 em OFF\n\nM\u00e9todo vazio\n\nPower_Manager\nAbs\n\nFigura 4.2: Adaptador de cen\u00e1rio Power_Manager.\n\nPara eliminar este teste a chamada direta do m\u00e9todo enter foi elimi-\n\nnada. A figura 4.3 apresenta um diagrama UML para esta nova solu\u00e7\u00e3o. Nesta vers\u00e3o\n\nexistem duas implementa\u00e7\u00f5es para o m\u00e9todo enter: enter_on, para ser executado\n\nquando o componente estiver em um modo funcional, e enter_off, para ser executado\n\nquando o componente estiver desligado. A fun\u00e7\u00e3o a ser chamada \u00e9 definida pela vari\u00e1vel\n\nfunction_pointer_enter. A fun\u00e7\u00e3o apontada por esta vari\u00e1vel \u00e9 definida no m\u00e9-\n\ntodo power, fazendo com que apenas ocorram testes no momento das trocas de modos\n\nde opera\u00e7\u00e3o. Esta solu\u00e7\u00e3o n\u00e3o implica em custo adicional de processamento devido a\n\nnovas chamadas de fun\u00e7\u00f5es, j\u00e1 que o compilador utilizado otimiza o c\u00f3digo, colocando\n\nas fun\u00e7\u00f5es inline.\n\n+leave()\n+enter()\n\n?enter_off()\n?enter_on() sen\u00e3o\n\n    function_pointer_enter = enter_on\n\n    function_pointer_enter = enter_off\nSe mode = OFF\n\nfunction_pointer_enter()\n\nfunction_pointer_enter = enter_on\n\n+power(mode:OP_Mode)\n+power():OP_Mode\n\n?function_pointer_enter:Function\n\n+Power_Manager()\n\nPower_Manager\nAbs\n\nFigura 4.3: Adaptador de cen\u00e1rio Power_Manager.\n\nOutra caracter\u00edstica da proposta que precisa ser tratada \u00e9 a gera\u00e7\u00e3o do\n\nm\u00e9todo power, que deve ser gerado com base nas redes de troca de modo de opera\u00e7\u00e3o.\n\n\n\n54\n\nO mecanismo utilizado para extrair a implementa\u00e7\u00e3o deste m\u00e9todo das Redes de Petri \u00e9\n\ndescrito na pr\u00f3xima se\u00e7\u00e3o.\n\n4.3 Resolu\u00e7\u00e3o Est\u00e1tica das Redes de Troca de Modos de\n\nOpera\u00e7\u00e3o\n\nAs redes de troca de modos de opera\u00e7\u00e3o apresentadas na se\u00e7\u00e3o 3.2 for-\n\nnecem a esta proposta um mecanismo para especificar os procedimentos de mudan\u00e7a de\n\nmodo de opera\u00e7\u00e3o. Embora existam diversos modelos de an\u00e1lise matem\u00e1tica para a inter-\n\npreta\u00e7\u00e3o destas redes em tempo de execu\u00e7\u00e3o, estas an\u00e1lises demandam por capacidades\n\nde processamento e mem\u00f3ria que se encontram al\u00e9m dos apresentados pela maioria dos\n\ndispositivos utilizados em sistemas profundamente embarcados. Por exemplo, uma estru-\n\ntura de dados para representar o grafo de uma Rede de Petri utilizaria, no m\u00ednimo, um\n\ncontador para cada n\u00f3 (1 byte) e refer\u00eancias para as conex\u00f5es de cada n\u00f3 (2 bytes para\n\ncada conex\u00e3o em um processador com endere\u00e7amento de 16 bits), al\u00e9m dos dados adici-\n\nonais da estrutura de controle. Por este ponto de vista simplista, cada rede generalizada\n\n(anexo A) necessitaria de 225 bytes de mem\u00f3ria para ser representada. Neste cen\u00e1rio,\n\numa rede como a gerada pelo exemplo apresentado na figura 3.5 utilizaria, grosseira-\n\nmente, 900 bytes. Este consumo de mem\u00f3ria tornaria a t\u00e9cnica proibitiva em plataformas\n\ncomo as apresentadas na se\u00e7\u00e3o 4.1.2, que possuem apenas alguns poucos quilobytes de\n\nmem\u00f3ria. Al\u00e9m do consumo excessivo de mem\u00f3ria, os algoritmos que manipulariam es-\n\ntas estruturas em tempo de execu\u00e7\u00e3o tamb\u00e9m agregariam ao sistema custos adicionais de\n\nprocessamento indesej\u00e1veis.\n\nComo ressaltado na se\u00e7\u00e3o 3.2, as redes de troca de modos de opera-\n\n\u00e7\u00e3o devem ser desenvolvidas de modo a n\u00e3o gerar situa\u00e7\u00f5es de concorr\u00eancia. Redes de\n\nPetri organizadas desta forma permitem uma execu\u00e7\u00e3o seq\u00fcencial j\u00e1 que, em nenhum mo-\n\nmento, mais de uma transi\u00e7\u00e3o est\u00e1 habilitada. Isso torna poss\u00edvel conhecer a seq\u00fc\u00eancia\n\nde disparos das transi\u00e7\u00f5es em uma Rede de Petri. Deste modo, a interpreta\u00e7\u00e3o em tempo\n\nde execu\u00e7\u00e3o das redes de troca de modos de opera\u00e7\u00e3o \u00e9 desnecess\u00e1ria. Para substituir\n\n\n\n55\n\nesta interpreta\u00e7\u00e3o, o c\u00f3digo-fonte necess\u00e1rio para realizar as trocas de modo de opera\u00e7\u00e3o\n\ndefinidas pelas redes foi extra\u00eddo automaticamente.\n\nAs redes de troca de modos de opera\u00e7\u00e3o propostas neste trabalho foram\n\nmodeladas utilizando o software PIPE2 [AKH 05]. Esta ferramenta, de c\u00f3digo aberto e\n\ndesenvolvida no Col\u00e9gio Imperial de Londres, al\u00e9m de permitir representar e simular as\n\nRedes de Petri tamb\u00e9m fornece um conjunto de ferramentas para an\u00e1lise das proprieda-\n\ndes da rede desenvolvida. Esta ferramenta exporta as redes que modela em um formato\n\nchamado PNML (Petri Net Markup Language) [BIL 03]. Esta linguagem possui estruturas\n\npara a representa\u00e7\u00e3o dos diferentes tipos de Redes de Petri. A PNML utiliza a PNTD (Petri\n\nNet Type Definition) para definir o tipo de rede utilizada, permitindo representar objetos\n\ncomuns a todas as Redes de Petri e as extens\u00f5es espec\u00edficas para cada tipo. A lingua-\n\ngem tem sido largamente adotada para representa\u00e7\u00e3o de v\u00e1rios tipos de Redes de Petri e\n\nest\u00e1 em vias de se tornar um padr\u00e3o da ISO. A representa\u00e7\u00e3o das redes neste formato \u00e9\n\ninteressante nesta proposta pois possibilita que, no futuro, novas ferramentas venham a\n\nutiliza-las para diferentes finalidades.\n\nPara gerar c\u00f3digo automaticamente a partir das redes de troca de modos\n\nde opera\u00e7\u00e3o, foi utilizado o processo apresentado pela figura 4.4. O PIPE2 foi modificado\n\npara permitir exportar o resultado da simula\u00e7\u00e3o da rede. Este resultado da simula\u00e7\u00e3o\n\ncont\u00e9m a seq\u00fc\u00eancia em que as transi\u00e7\u00f5es s\u00e3o disparadas na rede. Esta sa\u00edda alimenta\n\numa nova ferramenta, que foi chamada de Tradutor. O papel do Tradutor \u00e9 bastante\n\nsimples: ele analisa o c\u00f3digo-fonte com a declara\u00e7\u00e3o do componente no sistema alvo\n\nbuscando pelas declara\u00e7\u00f5es de outros componentes, identificando o nome das vari\u00e1veis\n\nque representam estes componentes e adaptando a sa\u00edda da simula\u00e7\u00e3o para c\u00f3digo C++\n\ncompil\u00e1vel.\n\nPara exemplificar, a figura 4.5 mostra o resultado da simula\u00e7\u00e3o da rede\n\nde modos de opera\u00e7\u00e3o que p\u00f5e o componente CMAC no modo de opera\u00e7\u00e3o FULL. De\n\nposse deste resultado, o Tradutor identifica os componentes com os quais a rede interage.\n\nNeste exemplo, os componentes identificados na rede seriam: Radio, SPI e Timer. Ao\n\nanalisar o c\u00f3digo fonte do componente alvo, \u00e9 encontrado o trecho de c\u00f3digo apresentado\n\nna figura 4.6. Identificadas as devidas declara\u00e7\u00f5es, o Tradutor produz o c\u00f3digo-fonte\n\n\n\n56\n\nPNML Pipe2 TXT Tradutor C++\n\nRede de Petri Resultado da Simula\u00e7\u00e3o C\u00f3digo\n\nFigura 4.4: Seq\u00fc\u00eancia para gera\u00e7\u00e3o de c\u00f3digo a partir das redes de modos de opera\u00e7\u00e3o.\n\napresentado na figura 4.7.\n\nSeguindo o modelo hier\u00e1rquico das redes de modos de opera\u00e7\u00e3o, o c\u00f3-\n\ndigo das redes individuais geradas segundo o procedimento descrito anteriormente deve\n\nser integrado \u00e0 rede de modos de opera\u00e7\u00e3o generalizada. Para isso, a rede generalizada\n\nfoi submetida a um processo semelhante ao anterior para extrair c\u00f3digo C++ que repro-\n\nduza o comportamento esperado. O problema encontrado aqui \u00e9 a exist\u00eancia de conflito\n\nna marca\u00e7\u00e3o inicial da rede, isto \u00e9, na rede generalizada as transi\u00e7\u00f5es power(FULL),\n\npower(LIGHT), power(STANDBY) e power(OFF) est\u00e3o habilitadas simultanea-\n\nmente e competindo pelo \u00fanico recurso presente no lugar Atomic_Execution. Ana-\n\nlisando esta rede, \u00e9 observado que este \u00e9 o \u00fanico conflito apresentado. A partir do disparo\n\nde uma das transi\u00e7\u00f5es em conflito, a execu\u00e7\u00e3o se torna seq\u00fcencial at\u00e9 que um recurso seja\n\nnovamente inserido no lugar Atomic_Execution. Assim sendo, as seguintes a\u00e7\u00f5es\n\nforam adotadas para reproduzir o comportamento desejado a partir do disparo de cada\n\numa das transi\u00e7\u00f5es ativadas, que \u00e9 iniciado por uma chamada da aplica\u00e7\u00e3o:\n\n1. Adquirir exclus\u00e3o m\u00fatua;\n\n2. Atualizar vari\u00e1veis de modo de opera\u00e7\u00e3o;\n\n3. Trocar modo de opera\u00e7\u00e3o do componente;\n\n4. Liberar exclus\u00e3o m\u00fatua;\n\nA exclus\u00e3o m\u00fatua foi garantida atrav\u00e9s do uso de um mutex. As vari\u00e1-\n\nveis de modo de opera\u00e7\u00e3o s\u00e3o duas na implementa\u00e7\u00e3o elaborada, uma para armazenar o\n\n\n\n57\n\nFigura 4.5: Seq\u00fc\u00eancia de simula\u00e7\u00e3o com c\u00f3digo sendo gerado.\n\nc l a s s CMAC {\n\n/ / . . .\n\np r i v a t e :\nRadio _ r a d i o ;\nSPI _ s p i ;\nTimer _ t i m e r ;\n\n/ / . . .\n\n} ;\n\nFigura 4.6: Declara\u00e7\u00f5es de componentes utilizados na implementa\u00e7\u00e3o do componente CMAC.\n\n\n\n58\n\nvoid p o w e r _ f u l l ( ) {\n/ / E n t e r FULL Begin\n_ r a d i o . power ( Radio : : FULL ) ;\n_ s p i . power ( SPI : : FULL ) ;\n_ t i m e r . power ( Timer : : FULL ) ;\n/ / E n t e r FULL End\n\n}\n\nFigura 4.7: C\u00f3digo final para a simula\u00e7\u00e3o da figura 4.5.\n\nmodo de opera\u00e7\u00e3o atual, e outra para armazenar o modo de opera\u00e7\u00e3o anterior. Esta \u00faltima\n\nvari\u00e1vel \u00e9 utilizada para implementar o mecanismo que retorna ao modo de opera\u00e7\u00e3o an-\n\nterior quando um componente \u201cdesligado\u201d \u00e9 acessado. A troca de modo de opera\u00e7\u00e3o \u00e9\n\nrealizada executando o c\u00f3digo gerado pelas redes de troca de modo de opera\u00e7\u00e3o de cada\n\ncomponente. Ao final o mutex deve ser liberado. O conflito encontrado na marca\u00e7\u00e3o\n\ninicial da rede foi resolvido disparando a transi\u00e7\u00e3o desejada baseado no par\u00e2metro que \u00e9\n\npassado ao m\u00e9todo power(mode) da API de ger\u00eancia de energia. A figura 4.8 apre-\n\nsenta o procedimento implementado, e a figura 4.9 apresenta a nova vers\u00e3o do cen\u00e1rio\n\nPower_Manager para implementar esta estrutura.\n\n4.4 Mecanismo de Propaga\u00e7\u00e3o de Mensagens\n\nA se\u00e7\u00e3o 3.3 especifica um mecanismo para permitir a intera\u00e7\u00e3o entre\n\nos diversos componentes do sistema nos procedimentos de troca de modo de opera\u00e7\u00e3o.\n\nComo \u00e9 definido naquela se\u00e7\u00e3o, as mensagens s\u00e3o passadas atrav\u00e9s da API e a seq\u00fc\u00ean-\n\ncia em que estas mensagens s\u00e3o passadas est\u00e1 expressa nas redes de troca de modos de\n\nopera\u00e7\u00e3o. Sendo assim, as implementa\u00e7\u00f5es descritas nas se\u00e7\u00f5es 4.2 (API) e 4.3 (redes de\n\ntroca de modo de opera\u00e7\u00e3o) j\u00e1 cobrem a propaga\u00e7\u00e3o de mensagens entre os componentes\n\nque possuem algum tipo de rela\u00e7\u00e3o (e.g., propaga\u00e7\u00e3o da troca de modo de opera\u00e7\u00e3o do\n\ncomponente CMAC para os componentes Radio, SPI e Timer). Estas estruturas, con-\n\ntudo, ainda n\u00e3o s\u00e3o suficientes para implementar o mecanismo de propaga\u00e7\u00e3o para todo\n\no sistema. Esta se\u00e7\u00e3o descreve a implementa\u00e7\u00e3o da lista de inst\u00e2ncias de componentes\n\nque um componente global do sistema (System) utiliza para acessar a API de todos os\n\n\n\n59\n\nvoid Component : : power ( char mode ) {\n\n_ a t o m i c_ e xe cu t i o n _ m u t e x . l o c k ( ) ;\n\n_prev_op_mode = _op_mode ;\n_op_mode = mode ;\n\nswitch ( mode ) {\n\ncase Component : : FULL :\np o w e r _ f u l l ( ) ;\nbreak ;\n\ncase Component : : LIGHT :\np o w e r _ l i g h t ( ) ;\nbreak ;\n\ncase Component : : STANDBY:\npower_standby ( ) ;\nbreak ;\n\ncase Component : : OFF :\np o w e r _ o f f ( ) ;\nbreak ;\n\n}\n\n_ a t o m i c_ e xe cu t i o n _ m u t e x . u n l o c k ( ) ;\n\n}\n\nFigura 4.8: Procedimento de troca de modo de opera\u00e7\u00e3o (implementa\u00e7\u00e3o da rede generalizada).\n\n+leave()\n+enter()\n\n+power(mode:OP_Mode)\n+power():OP_Mode\n\nA implementa\u00e7\u00e3o destes m\u00e9todos\nest\u00e1 em uma unidade de\ncompila\u00e7\u00e3o separada.\n\n?enter_off()\n?enter_on()\n\n?power_off()\n?power_standby()\n?power_light()\n?power_full()\n\n?function_pointer_enter:Function\n\n+Power_Manager()\n\nAbs\nPower_Manager\n\nFigura 4.9: Adaptador de cen\u00e1rio Power_Manager.\n\n\n\n60\n\ncomponentes sendo utilizados.\n\nPropaga\u00e7\u00e3o Generalizada (Para Todo o Sistema)\n\nPara implementar uma lista de inst\u00e2ncias de componentes do sistema \u00e9\n\nnecess\u00e1rio, primeiramente, conhecer os componentes do sistema que est\u00e3o sendo utiliza-\n\ndos. Para isso um componente global do sistema EPOS chamado System foi modificado\n\npara manter uma lista de inst\u00e2ncias dos componentes do sistema. Esta lista utiliza uma\n\ncombina\u00e7\u00e3o de polimorfismo e t\u00e9cnicas de meta-programa\u00e7\u00e3o est\u00e1tica para permitir a\n\ntranspar\u00eancia de tipos dos componentes. Feito isso, os m\u00e9todos da API de ger\u00eancia de\n\nenergia foram adicionados ao componente. O m\u00e9todo power(mode:OP_Mode) neste\n\ncomponente varre esta lista, propagando o modo de opera\u00e7\u00e3o requisitado para os compo-\n\nnentes em uso pela aplica\u00e7\u00e3o.\n\nO sistema EPOS possui uma fam\u00edlia de aspectos chamada Shared, que\n\n\u00e9 respons\u00e1vel por tratar o compartilhamento de recursos do sistema. Um dos membros\n\ndesta fam\u00edlia, o aspecto Referenced, implementa um mecanismo de contadores de\n\nrefer\u00eancias para os recursos do sistema. O comportamento padr\u00e3o deste aspecto \u00e9 o de\n\napenas permitir que um recurso seja destru\u00eddo quando n\u00e3o houverem mais refer\u00eancias\n\na ele no sistema. Algumas abstra\u00e7\u00f5es, contudo, necessitam de tratamento especial para\n\ncompartilhamento. Neste contexto existe, por exemplo, uma especializa\u00e7\u00e3o deste aspecto\n\npara ser aplicada ao componente Segment, que abstrai segmentos de mem\u00f3ria. Esta\n\nespecializa\u00e7\u00e3o prov\u00ea suporte adequado para sistemas onde h\u00e1 mem\u00f3ria compartilhada.\n\nDe modo similar, uma especializa\u00e7\u00e3o do aspecto Referenced foi cri-\n\nada para ger\u00eancia de energia. Esta especializa\u00e7\u00e3o modifica os construtores e destrutor dos\n\ncomponentes para, respectivamente, guardar e descartar refer\u00eancias aos objetos criados\n\nna lista do componente System.\n\nCompartilhamento de Recursos\n\nA \u00faltima modifica\u00e7\u00e3o do sistema foi a inclus\u00e3o de c\u00f3digo para tratar o\n\nproblema de compartilhamento de recursos descrito na se\u00e7\u00e3o 3.3.2. Para isto, foram adi-\n\n\n\n61\n\ncionados ao adaptador de aspecto Referenced especializado para ger\u00eancia de energia\n\nquatro contadores, um para cada modo de opera\u00e7\u00e3o.Nesta vers\u00e3o do aspecto, o construtor\n\ndo componente incrementa o contador do modo de opera\u00e7\u00e3o FULL. Altera\u00e7\u00f5es de modos\n\nde opera\u00e7\u00e3o (chamadas ao m\u00e9todo power) tamb\u00e9m s\u00e3o interceptadas para permitir que\n\no componente seja mantido no modo de opera\u00e7\u00e3o menos restrito que possuir refer\u00eancias.\n\nEsta intercepta\u00e7\u00e3o tamb\u00e9m \u00e9 utilizada para atualizar os contadores de modos de opera\u00e7\u00e3o.\n\nA implementa\u00e7\u00e3o descrita neste cap\u00edtulo focou o desenvolvimento de\n\num conjunto de artefatos de software que, oferecendo as funcionalidades descritas no\n\ncap\u00edtulo 3, n\u00e3o agrega ao sistema custos adicionais de processamento e mem\u00f3ria inde-\n\nsej\u00e1veis. No pr\u00f3ximo cap\u00edtulo s\u00e3o apresentados estudos de caso do uso deste sistema,\n\nonde \u00e9 feita uma an\u00e1lise do impacto deste em termos de custos adicionais de mem\u00f3ria de\n\nc\u00f3digo e dados, bem como na redu\u00e7\u00e3o do consumo de energia.\n\n\n\nCap\u00edtulo 5\n\nEstudos de Caso\n\nDuas aplica\u00e7\u00f5es foram desenvolvidas para testar esta proposta de ge-\n\nrente de energia. A primeira \u00e9 um term\u00f4metro que manda leituras peri\u00f3dicas de tem-\n\nperatura atrav\u00e9s de uma porta serial. Esta aplica\u00e7\u00e3o \u00e9 simples e foi desenvolvida para\n\ndemonstrar a facilidade em tratar o consumo de energia atrav\u00e9s da API proposta. A se-\n\ngunda, mais complexa, utiliza uma plataforma de sensoriamento MICA2 MOTE [HIL 00].\n\nA aplica\u00e7\u00e3o realiza leituras peri\u00f3dicas de dois sensores (temperatura e luminosidade), en-\n\nviando estas leituras atrav\u00e9s do r\u00e1dio.\n\n5.1 Term\u00f4metro\n\nPara demonstrar a usabilidade da interface definida, um term\u00f4metro se-\n\nrial foi implementado utilizando um prot\u00f3tipo com um termistor (resistor sens\u00edvel a tem-\n\nperatura) de 10 K? conectado a um canal do conversor anal\u00f3gico-digital de um micro-\n\ncontrolador ATMEGA16, da Atmel [ATM 04b]. A figura 5.1 apresenta um diagrama do\n\nhardware utilizado. Este dispositivo deve operar enviando uma leitura de temperatura a\n\ncada segundo pela porta serial.\n\nAnalisando a aplica\u00e7\u00e3o foram identificados dois modos de opera\u00e7\u00e3o\n\npara o sistema, aqui chamados de ativo e espera. Quando ativo, o sistema adquire uma\n\nleitura do sensor de temperatura, converte esta leitura para uma unidade real (e.g., graus\n\n\n\n63\n\nB\nA\n\nR\nR\n\nA\nM\n\nE\nN\n\nT\nO\n\nAVR8 CPU\n\nMEM\u00d3RIA\n\nE\nE\n\nP\nR\n\nO\nM\n\nC\no\n\nn\nv\n\n. \nA\n\n/D\n\nR\nS\n\n?\n2\n\n3\n2\n\nAtmel ATMega16\n\nTermistor\n\nFigura 5.1: Hardware do prot\u00f3tipo constru\u00eddo.\n\nCelcius) e envia pela porta serial. Quando o sistema est\u00e1 em espera, este fica aguardando\n\nque o intervalo de tempo entre leituras passe para retornar ao estado ativo. Neste \u00fal-\n\ntimo estado, o \u00fanico dispositivo que precisa estar operando \u00e9 o temporizador do sistema,\n\npara permitir o acionamento do estado ativo. Sendo assim, foi projetada uma aplica\u00e7\u00e3o\n\nque utiliza quatro componentes do EPOS: System, Alarm, Temperature_Sensor\n\n(membro da fam\u00edlia de Sencientes [WAN 05]) e UART. Em modo ativo, todos os com-\n\nponentes devem estar ligados. Em modo de espera, apenas o Alarm deve ser mantido\n\nligado. Assim, foram utilizados dois modos de opera\u00e7\u00e3o: FULL para representar o modo\n\nativo e STANDBY para representar o modo espera. No modo de opera\u00e7\u00e3o FULL todos os\n\ncomponentes devem estar completamente operacionais. J\u00e1 no modo STANDBY, todos os\n\ncomponentes, exceto o Alarm, devem entrar em modos restritos, de baixo consumo de\n\nenergia. O componente Alarm deve ser mantido em um modo funcional para acordar o\n\nsistema periodicamente. A figura 5.2 apresenta o conjunto de amarra\u00e7\u00f5es de modos de\n\nopera\u00e7\u00e3o realizados. Estas amarra\u00e7\u00f5es s\u00e3o as originais do sistema, ou seja, o programa-\n\ndor da aplica\u00e7\u00e3o n\u00e3o necessita alterar as configura\u00e7\u00f5es do gerente de energia para esta\n\naplica\u00e7\u00e3o. Caso haja a necessidade destas amarra\u00e7\u00f5es serem alteradas, isto pode ser feito\n\natrav\u00e9s de uma ferramenta gr\u00e1fica de configura\u00e7\u00e3o do EPOS.\n\nA aplica\u00e7\u00e3o implementada para esta plataforma no EPOS \u00e9 apresentada\n\nna figura 5.3. Quando a aplica\u00e7\u00e3o inicia, todos os componentes sendo utilizados s\u00e3o ini-\n\n\n\n64\n\n/ / Alarm\ns t a t i c const char FULL = Alarm : : ON;\ns t a t i c const char STANDBY = Alarm : : ON;\n\n/ / Temperature_Sensor\ns t a t i c const char FULL = Temperature_Sensor : : ON;\ns t a t i c const char STANDBY = Temperature_Sensor : : STOPED ;\n\n/ / UART\ns t a t i c const char FULL = UART : : ON;\ns t a t i c const char STANDBY = UART : : STOPED;\n\nFigura 5.2: Amarra\u00e7\u00f5es dos modos de opera\u00e7\u00e3o.\n\ncializados atrav\u00e9s de seus construtores e, por defini\u00e7\u00e3o, colocados no modo de opera\u00e7\u00e3o\n\nFULL. Em seguida um evento peri\u00f3dico \u00e9 registrado no componente Alarm. O modo de\n\nopera\u00e7\u00e3o de todo o sistema \u00e9 ent\u00e3o alterado para STANDBY atrav\u00e9s do m\u00e9todo power\n\ndo componente System. Quando isto acontece, o componente System coloca todos os\n\ncomponentes do sistema em seus modos STANDBY, conforme definido pelas amarra\u00e7\u00f5es\n\nde modos de opera\u00e7\u00e3o (ver figura 5.2). O Alarm utiliza um temporizador para gerar in-\n\nterrup\u00e7\u00f5es a uma dada frequ\u00eancia. A cada interrup\u00e7\u00e3o de tempo, a CPU, que encontra-se\n\nno modo de opera\u00e7\u00e3o power_save (ver tabela 4.1.2), acorda e o componente Alarm trata\n\ntodos os eventos registrados, executando os que atingiram seu per\u00edodo. Neste exemplo,\n\na cada segundo os componentes Temperature_Sensor e UART s\u00e3o acordados auto-\n\nmaticamente quando acessados e uma leitura de temperatura \u00e9 enviada atrav\u00e9s da porta\n\nserial. Quando todos os eventos registrados s\u00e3o tratados, a aplica\u00e7\u00e3o continua a execu\u00e7\u00e3o\n\nnormal chegando ao la\u00e7o principal, que p\u00f5e o componente System de volta no modo de\n\nopera\u00e7\u00e3o STANDBY.\n\nForam realizadas medi\u00e7\u00f5es do consumo de energia para este estudo de\n\ncaso. Estas leituras foram realizadas medindo a queda de tens\u00e3o em um resistor de alta\n\nprecis\u00e3o colocado entre a fonte de alimenta\u00e7\u00e3o e o sistema. A medi\u00e7\u00e3o foi feita por um\n\nconversor anal\u00f3gico-digital operando a uma freq\u00fc\u00eancia de 20 KHz e com resolu\u00e7\u00e3o de\n\n8 bits. Foram realizadas dez medi\u00e7\u00f5es, cada uma com uma dura\u00e7\u00e3o de dez segundos.\n\nForam medidos os consumos de energia para a aplica\u00e7\u00e3o com e sem ger\u00eancia de energia\n\n\n\n65\n\n# i n c l u d e&lt;system . h>\n# i n c l u d e &lt;t e m p e r a t u r e _ s e n s o r . h>\n# i n c l u d e &lt;u a r t . h>\n# i n c l u d e &lt;a l a r m . h>\n\nvoid a l a r m _ h a n d l e r ( ) {\ns t a t i c Temperature_Sensor therm ;\ns t a t i c UART u a r t ;\nu a r t . p u t ( therm . sample ( ) ) ;\n\n}\n\ni n t main ( ) {\nH a n d l e r _ F u n c t i o n h a n d l e r (&amp; a l a r m _ h a n d l e r ) ;\nAlarm a l a r m (1000000 , &amp;h a n d l e r ) ;\n\nw h i l e ( 1 ) {\nSystem : : power ( System : : STANDBY ) ;\n\n}\n}\n\nFigura 5.3: A aplica\u00e7\u00e3o Term\u00f4metro.\n\nC\u00f3digo Dados Energia\n\nSem gerenciamento 9.496 Bytes 161 Bytes 513 mJ\n\nCom gerenciamento 10.758 Bytes 200 Bytes 472 mJ\n\nImpacto +11,73% +19,5% -8%\n\nTabela 5.1: Ger\u00eancia de energia pelo EPOS para o estudo de caso Term\u00f4metro.\n\npelo sistema. A tabela 5.1 apresenta os resultados destas medi\u00e7\u00f5es, juntamente com o\n\nimpacto do gerente de energia em termos de consumo de mem\u00f3ria para c\u00f3digo e para\n\ndados. O ganho em consumo de energia neste estudo de caso foi relativamente pequeno\n\n(8%). Isto se deve a dois fatores: (1) o sistema foi prototipado em um prot-o-board, cu-\n\njas conex\u00f5es imperfeitas e contatos realizados por fios contribuem para gerar uma grande\n\nquantidade de ru\u00eddo e (2) o microcontrolador utilizado n\u00e3o foi projetado para aplica\u00e7\u00f5es\n\nonde o consumo de energia \u00e9 cr\u00edtico. O pr\u00f3ximo estudo de caso utiliza um outro mi-\n\ncrocontrolador da mesma fam\u00edlia cujas caracter\u00edsticas permitem um melhor controle do\n\nconsumo de energia.\n\n\n\n66\n\n5.2 M\u00f3dulo de Sensoriamento Mica Mote2\n\nO segundo estudo de caso realizado para testar a proposta foi desen-\n\nvolvido sobre a plataforma de redes de sensores sem fio descrita na se\u00e7\u00e3o 4.1.2. Um\n\ndiagrama do hardware desta plataforma \u00e9 apresentada na figura 5.4. Neste estudo de caso\n\no dispositivo deve operar enviando atrav\u00e9s do r\u00e1dio leituras de temperatura a cada segundo\n\ne de luminosidade a cada cem mil\u00e9ssimos de segundo. Neste exemplo h\u00e1 compartilha-\n\nmento do conversor anal\u00f3gico-digital (ADC) pelas abstra\u00e7\u00f5es dos sensores de temperatura\n\ne luminosidade, o que torna necess\u00e1rio a utiliza\u00e7\u00e3o do mecanismo de controle de compar-\n\ntilhamento de recursos descrito na se\u00e7\u00e3o 4.4.\n\nB\nA\n\nR\nR\n\nA\nM\n\nE\nN\n\nT\nO\n\nAVR8 CPU\n\nMEM\u00d3RIA\n\nE\nE\n\nP\nR\n\nO\nM\n\nC\no\n\nn\nv\n\n. \nA\n\n/D\n\nS\nP\n\nI\nG\n\nP\nIO\n\nG\nP\n\nIO\n\nCC1000\n\nAtmel ATMega128\n\nSensoresAntena\n\nFigura 5.4: Diagrama de hardware do Mica2 Mote.\n\nA aplica\u00e7\u00e3o implementada para esta plataforma no EPOS \u00e9 apresentada\n\nna figura 5.5. Quando a aplica\u00e7\u00e3o inicia, todos os componentes sendo utilizados s\u00e3o ini-\n\ncializados atrav\u00e9s de seus construtores e, por defini\u00e7\u00e3o, colocados no modo de opera\u00e7\u00e3o\n\nFULL. Em seguida dois eventos peri\u00f3dicos s\u00e3o registrados no componente Alarm, um\n\npara enviar leituras de temperatura a cada segundo e outro para enviar leituras de lumi-\n\nnosidade a cada cem milissegundos. O modo de opera\u00e7\u00e3o de todo o sistema \u00e9 ent\u00e3o\n\nalterado para STANDBY atrav\u00e9s do m\u00e9todo power do componente System. Quando\n\nisto acontece, o componente System coloca todos os componentes do sistema no modo\n\nSTANDBY, conforme definido pelas amarra\u00e7\u00f5es de modos de opera\u00e7\u00e3o (ver figura 5.6).\n\n\n\n67\n\n# i n c l u d e&lt;system . h>\n# i n c l u d e &lt;n i c . h>\n# i n c l u d e &lt;se n so r . h>\n# i n c l u d e &lt;a l a r m . h>\n\nNIC r a d i o ;\n\nvoid t e m p e r a t u r e ( ) {\ns t a t i c Temperature_Sensor t e m p e r a t u r e ;\ni n t b u f f e r = t e m p e r a t u r e . sample ( ) ;\nt e m p e r a t u r e . power ( Temperature_Sensor : : OFF ) ;\nr a d i o . send ( address , p r o t o c o l , &amp; b u f f e r , s i z e o f ( i n t ) ) ;\nr a d i o . power ( NIC : : OFF ) ;\n\n}\n\nvoid p h o t o ( ) {\ns t a t i c Photo_Sensor p h o t o ;\ni n t b u f f e r = p h o t o . sample ( ) ;\np h o t o . power ( Photo_Sensor : : OFF ) ;\nr a d i o . send ( address , p r o t o c o l , &amp; b u f f e r , s i z e o f ( i n t ) ) ;\nr a d i o . power ( NIC : : OFF ) ;\n\n}\n\ni n t main ( ) {\nH a n d l e r _ F u n c t i o n t e m p e r a t u r e _ h a n d l e r (&amp; t e m p e r a t u r e ) ;\nAlarm t e m p e r a t u r e _ a l a r m (1000000 , &amp;t e m p e r a t u r e _ h a n d l e r ) ;\n\nH a n d l e r _ F u n c t i o n p h o t o _ h a n d l e r (&amp; p h o t o ) ;\nAlarm p h o t o _ a l a r m ( 1 0 0 0 0 0 , &amp;p h o t o _ h a n d l e r ) ;\n\nw h i l e ( 1 ) {\nSystem : : power ( System : : STANDBY ) ;\n\n}\n}\n\nFigura 5.5: Aplica\u00e7\u00e3o para o Mica2 Mote.\n\n\n\n68\n\nO Alarm utiliza um temporizador para gerar interrup\u00e7\u00f5es a uma dada freq\u00fc\u00eancia. A\n\ncada interrup\u00e7\u00e3o de tempo, a CPU acorda e o componente Alarm trata todos os eventos\n\nregistrados, executando os que atingiram seu per\u00edodo. Neste exemplo, a cada cem milis-\n\nsegundos o componente Photo_Sensor \u00e9 acordado automaticamente quando acessado\n\ne uma leitura de luminosidade \u00e9 realizada. Ap\u00f3s esta leitura, o sensor \u00e9 desligado e o r\u00e1dio\n\n\u00e9 acordado automaticamente quando o envio \u00e9 realizado. A mesma sequ\u00eancia de eventos\n\nocorre para a leitura de temperatura atrav\u00e9s do componente Temperature_Sensor\n\npor\u00e9m, neste caso, com per\u00edodo de um segundo. Quando todos os eventos registrados s\u00e3o\n\ntratados, a aplica\u00e7\u00e3o continua a execu\u00e7\u00e3o normal chegando ao la\u00e7o principal, que p\u00f5e o\n\ncomponente System de volta no modo de opera\u00e7\u00e3o STANDBY.\n\n/ / Alarm\ns t a t i c const char FULL = Alarm : : ON;\ns t a t i c const char STANDBY = Alarm : : ON;\n\n/ / Temperature_Sensor\ns t a t i c const char FULL = Temperature_Sensor : : ON;\ns t a t i c const char STANDBY = Temperature_Sensor : : STOPED ;\n\n/ / L i g h t _ S e n s o r\ns t a t i c const char FULL = L i g h t _ S e n s o r : : ON;\ns t a t i c const char STANDBY = L i g h t _ S e n s o r : : STOPED ;\n\n/ / CMAC\ns t a t i c const char FULL = CMAC : : ON;\ns t a t i c const char STANDBY = CMAC : : STOPED;\n\nFigura 5.6: Amarra\u00e7\u00f5es dos modos de opera\u00e7\u00e3o.\n\nA cada segundo nesta aplica\u00e7\u00e3o o sistema realiza leituras nos dois sen-\n\nsores. Nestes pontos h\u00e1 concorr\u00eancia no acesso ao ADC, conforme apresentado na fi-\n\ngura 3.7, neste caso com sensores de luminosidade e temperatura. Nesta situa\u00e7\u00e3o o meca-\n\nnismo de contadores implementado pelo aspecto Shared faz com que o ADC permane\u00e7a\n\nligado at\u00e9 que ambos os sensores (Photo_Sensor e Temperature_Sensor) soli-\n\ncitem seu desligamento.\n\nForam realizadas medi\u00e7\u00f5es do consumo de energia para este estudo de\n\ncaso. Estas leituras foram realizadas medindo a queda de tens\u00e3o em um resistor de alta\n\n\n\n69\n\nprecis\u00e3o colocado entre a fonte de alimenta\u00e7\u00e3o e o sistema. A medi\u00e7\u00e3o foi feita por um\n\nconversor anal\u00f3gico-digital operando a uma frequ\u00eancia de 20 KHz e com resolu\u00e7\u00e3o de 8\n\nbits. Foram realizadas dez medi\u00e7\u00f5es, cada uma com uma dura\u00e7\u00e3o de dez segundos. Foram\n\nmedidos os consumos de energia para a aplica\u00e7\u00e3o com e sem gerenciamento de energia\n\npelo sistema. A tabela 5.2 apresenta os resultados destas medi\u00e7\u00f5es, juntamente com o\n\nimpacto do gerente de energia em termos de consumo de mem\u00f3ria para c\u00f3digo e para\n\ndados. Neste caso, a economia de energia reflete, principalmente, a redu\u00e7\u00e3o no consumo\n\ndo processador e dos sensores quando estes est\u00e3o em modos de mais baixo consumo.\n\nIsto ocorre porque a implementa\u00e7\u00e3o do CMAC j\u00e1 utiliza o r\u00e1dio de forma a minimizar o\n\nconsumo de energia, desligando partes n\u00e3o utilizadas quando desnecess\u00e1rio (e.g., ligando\n\no circuito de envio apenas quando h\u00e1 dados para serem enviados). Optou-se por utilizar a\n\nmesma implementa\u00e7\u00e3o em ambos os testes por considerar justo, j\u00e1 que seria il\u00f3gico for\u00e7ar\n\no r\u00e1dio a consumir mais energia sem que haja necessidade para isso.\n\nC\u00f3digo Dados Energia\n\nSem gerenciamento 12.900 Bytes 294 Bytes 73,6 mJ\n\nCom gerenciamento 14.294 Bytes 345 Bytes 60,8 mJ\n\nImpacto +9,7% +14,8% -17,5%\n\nTabela 5.2: Ger\u00eancia de energia pelo EPOS para o estudo de caso Mica2 Mote.\n\n5.3 Discuss\u00e3o\n\nOs estudos de caso apresentados neste cap\u00edtulo tinham como objetivo\n\nmostrar como a infra-estrutura para ger\u00eancia de energia definida neste trabalho \u00e9 utili-\n\nzada. Estes estudos de caso, contudo, s\u00e3o relativamente simples. Isto ocorre porque\n\nos prot\u00f3tipos foram desenvolvidos para sistemas de sensoriamento, cujas aplica\u00e7\u00f5es s\u00e3o\n\nfrequentemente simples. Estas aplica\u00e7\u00f5es, por\u00e9m, tamb\u00e9m se beneficiam do uso do me-\n\ncanismo de ger\u00eancia de energia definido neste trabalho. A import\u00e2ncia da minimiza\u00e7\u00e3o\n\n\n\n70\n\ndo consumo de energia nestes sistemas \u00e9 latente, dada a naturaza de sua implanta\u00e7\u00e3o, que\n\npode envolver locais de dif\u00edcil acesso, inviabilizando a troca de baterias. Nestas situa\u00e7\u00f5es\n\na vida \u00fatil das baterias \u00e9 a vida \u00fatil do sistema.\n\nAplica\u00e7\u00f5es mais complexas tamb\u00e9m se beneficiariam desta t\u00e9cnica ao\n\npasso que utilizem mais componentes, aumentando o n\u00famero de rela\u00e7\u00f5es e depend\u00eancias\n\nentre estes componentes; passem a utilizar m\u00faltiplas threads, aumentando o compartilha-\n\nmento de recursos do sistema; e aumentem a carga de trabalho do sistema, passando a\n\nconsumir mais energia. O aumento desta complexidade, contudo, pode tamb\u00e9m trazer\n\nproblemas \u00e0 ger\u00eancia de energia. Dentre estes problemas est\u00e1 o fato de a concorr\u00eancia\n\npelo uso de certos dispositivos vir a gerar altera\u00e7\u00f5es muito frequentes de modos de ope-\n\nra\u00e7\u00e3o, o que pode acabar aumentando o consumo de energia do sistema. Outra poss\u00edvel\n\nfalha do sistema nestas situa\u00e7\u00f5es \u00e9 a confian\u00e7a nas tarefas. Em um ambiente multi-tarefa,\n\nse uma das tarefas do sistema n\u00e3o implementar ger\u00eancia de energia existe o risco de\n\ncomponentes serem mantidos ligados, mesmo quando ociosos, devido ao mecanismo de\n\ncontadores implementado para controle de concorr\u00eancia. Nestas situa\u00e7\u00f5es, um gerente\n\nde energia ativo, que verifique constantemente o estado de cada componente do sistema,\n\nprovavelmente economizaria mais energia.\n\nMesmo sendo simples, as aplica\u00e7\u00f5es utilizadas nos estudos de caso per-\n\nmitiram demonstrar o uso da interface. O objetivo deste trabalho n\u00e3o \u00e9 desenvolver um\n\ngerente de energia mais eficiente que outros j\u00e1 implementados. O objetivo deste trabalho\n\n\u00e9 desenvolver uma infra-estrutura que permita a integra\u00e7\u00e3o de mecanismos de ger\u00eancia de\n\nenergia diversos sob uma \u00fanica interface, que possa ser facilmente utilizada por um pro-\n\ngramador sem que haja necessidade deste conhecer detalhes do hardware que est\u00e1 sendo\n\nutilizado. Por este motivo, n\u00e3o foram realizados testes comparativos com as t\u00e9cnicas apre-\n\nsentadas no cap\u00edtulo 2. Em termos de consumo de energia, aquelas t\u00e9cnicas seriam mais\n\neficientes que as implementadas aqui.\n\nEm termos de desempenho, o impacto da estrutura desenvolvida no\n\ntempo de execu\u00e7\u00e3o das aplica\u00e7\u00f5es \u00e9 bastante reduzido. Isto ocorre devido ao uso in-\n\ntensivo de t\u00e9cnicas de metaprograma\u00e7\u00e3o est\u00e1tica, os templates em C++, cuja resolu\u00e7\u00e3o\n\nem tempo de compila\u00e7\u00e3o permite dilui\u00e7\u00e3o do c\u00f3digo de ger\u00eancia de energia nos compo-\n\n\n\n71\n\nnentes alvo, eliminando, principalmente, chamadas de fun\u00e7\u00e3o, que impactariam de modo\n\nbastante negativo no tempo de execu\u00e7\u00e3o. Atrasos significativos, contudo, podem ocorrer\n\ndevido a caracter\u00edsticas dos dispositivos utilizados. Por exemplo, ao ligar um termistor\n\n(permitindo passagem de corrente atrav\u00e9s dele) \u00e9 necess\u00e1rio aguardar um tempo (e.g., um\n\nmilisegundo no exemplo da se\u00e7\u00e3o 5.2) para que a corrente estabilize e seja poss\u00edvel obter\n\nleituras corretas do dispositivo. Tempos de estabiliza\u00e7\u00e3o ainda maiores s\u00e3o necess\u00e1rios\n\npara alguns outros dispositivos, principalmente aqueles que possuem partes mec\u00e2nicas,\n\ncomo discos para iniciar a rota\u00e7\u00e3o do cilindro. Nestes casos, a perda de prazos na execu-\n\n\u00e7\u00e3o de tarefas pode se tornar um problema cr\u00edtico, o que \u00e9, de fato, foco de muita pesquisa\n\nhoje.\n\nEmbora este trabalho n\u00e3o tenha implementado t\u00e9cnicas complexas como\n\nas muitas apresentadas no cap\u00edtulo 2, ele n\u00e3o impede que estas t\u00e9cnicas sejam integradas\n\na este sistema. Dada a configurabilidade disponibilizada pela API de ger\u00eancia de energia\n\ndesenvolvida aqui, \u00e9 poss\u00edvel integrar qualquer um daqueles trabalhos ao sistema desen-\n\nvolvido. Por exemplo, uma CPU com suporte a DVS cont\u00e9m modos de opera\u00e7\u00e3o dis-\n\ntindos para cada freq\u00fc\u00eancia de opera\u00e7\u00e3o que suporte. Assim, diferentes heur\u00edsticas para\n\naplica\u00e7\u00e3o de DVS poderiam ser implementadas como diferentes modos de opera\u00e7\u00e3o do\n\ncomponente escalonador, que gerenciaria os modos de opera\u00e7\u00e3o da CPU. Outro exemplo\n\nseria a implementa\u00e7\u00e3o de t\u00e9cnicas para gerenciar o consumo de energia de dispositivos\n\nde armazenamento de dados, como discos ou mem\u00f3rias persistentes. Um dos modos de\n\nopera\u00e7\u00e3o de um sistema de arquivos poderia manter os dispositivos desligados, agrupando\n\nrequisi\u00e7\u00f5es de leitura e escrita at\u00e9 que, ou hajam muitas tarefas bloqueadas no sistema, ou\n\no volume de requisi\u00e7\u00f5es seja suficiente para justificar o ligamento do dispositivo.\n\n\n\nCap\u00edtulo 6\n\nConclus\u00e3o\n\nO termo power-aware est\u00e1 cada dia mais presente nas discuss\u00f5es e pro-\n\njetos sobre sistemas computacionais. De fato, este \u00e9 um problema que precisa ser tratado\n\nem sistemas de todos os tipos, desde grandes centros de computa\u00e7\u00e3o (e.g., agregados e\n\ngrades computacionais) at\u00e9 pequenos dispositivos de computa\u00e7\u00e3o embarcada e dedicada\n\nque s\u00e3o, freq\u00fcentemente, alimentados por bateria. Este trabalho concentrou seus estudos\n\nnas t\u00e9cnicas para gerenciar o consumo de energia destes \u00faltimos sistemas. Nestes estudos\n\nfoi poss\u00edvel observar que as melhores t\u00e9cnicas de ger\u00eancia de energia s\u00e3o sempre aquelas\n\nque, de algum modo, consideram caracter\u00edsticas e comportamento das aplica\u00e7\u00f5es como\n\ndiretrizes para a ger\u00eancia de energia. Assim sendo, foi considerada uma boa estrat\u00e9gia\n\nentregar a ger\u00eancia de energia do sistema \u00e0 aplica\u00e7\u00e3o.\n\nAo entregar o controle do consumo de energia para a aplica\u00e7\u00e3o, con-\n\ntudo, surge uma nova s\u00e9rie de problemas que precisam ser resolvidos. Um destes proble-\n\nmas \u00e9 o estabelecimento de um mecanismo pelo qual a aplica\u00e7\u00e3o possa interagir com o\n\nsistema operacional e, assim, agir como gerente de energia deste sistema. Buscando agre-\n\ngar o m\u00ednimo poss\u00edvel de complexidade ao processo de desenvolvimento de aplica\u00e7\u00f5es\n\nembarcadas, foi definida uma API configur\u00e1vel de ger\u00eancia de energia atrav\u00e9s da qual\n\nos modos de opera\u00e7\u00e3o dos componentes do sistema podem ser consultados ou alterados.\n\nNesta proposta \u00e9 esperado que o programador da aplica\u00e7\u00e3o comunique ao sistema quando\n\num determinado componente passar\u00e1 por um per\u00edodo de inatividade, informando que este\n\n\n\n73\n\ncomponente pode ser desligado. A API garante que estes componentes voltem aos seus\n\nmodos de opera\u00e7\u00e3o anteriores automaticamente quando utilizados.\n\nEste mecanismo de ger\u00eancia de energia foi concebido para operar com\n\nsistemas operacionais baseados em componentes. Nestes sistemas componentes s\u00e3o or-\n\nganizados para separar funcionalidades do sistema operacional, facilitando a identifica-\n\n\u00e7\u00e3o dos componentes que podem ser desligados em determinado momento por parte do\n\nprogramador da aplica\u00e7\u00e3o. Em sistemas baseados em componentes, contudo, compo-\n\nnentes costumam interagir para implementar as funcionalidades desejadas. Por exem-\n\nplo, um componente de comunica\u00e7\u00e3o agrega diversos componentes que implementam\n\ndiferentes protocolos (e.g., TCP, IP), os drivers de dispositivo (e.g., Ethernet_NIC,\n\nRadio_NIC), etc. De modo a abstrair as rela\u00e7\u00f5es entre componentes para gerenciar\n\nconsumo de energia, este trabalho prop\u00f4s um mecanismo baseado em redes de Petri que\n\nformaliza estas rela\u00e7\u00f5es durante trocas de modos de opera\u00e7\u00e3o. A an\u00e1lise matem\u00e1tica\n\ndestas redes mostra que o sistema de ger\u00eancia de energia proposto \u00e9 livre de impasse e,\n\natrav\u00e9s de an\u00e1lise do grafo de alcan\u00e7abilidade desta rede, que todos os estados desejados\n\ns\u00e3o alcan\u00e7\u00e1veis, e que estados indesejados n\u00e3o o s\u00e3o.\n\nConsiderando a ger\u00eancia de energia uma caracter\u00edstica n\u00e3o-funcional de\n\nsistemas computacionais e, portanto, fator\u00e1vel como um aspecto [LOH 05], este gerente\n\nfoi modelado como tal. O sistema operacional EPOS, que oferece suporte para utiliza\u00e7\u00e3o\n\nde aspectos, foi utilizado para gerar os prot\u00f3tipos desta proposta. Das redes de troca de\n\nmodos de opera\u00e7\u00e3o foi extra\u00eddo o c\u00f3digo-fonte necess\u00e1rio para que as trocas realmente\n\nocorram. Isto foi feito combinando uma ferramenta de simula\u00e7\u00e3o de redes de Petri e uma\n\nferramenta desenvolvida neste trabalho que, analisando o sistema alvo (EPOS), traduz os\n\nresultados da simula\u00e7\u00e3o para c\u00f3digo C++ compil\u00e1vel naquele sistema. O c\u00f3digo-fonte\n\ngerado \u00e9 agrupado em um m\u00f3dulo de compila\u00e7\u00e3o separado e ligado ao sistema quando\n\neste \u00e9 gerado.\n\nEstudos de caso neste trabalho demonstraram como a API p\u00f4de ser con-\n\nfigurada para satisfazer as necessidades espec\u00edficas de cada aplica\u00e7\u00e3o. Estes estudos de\n\ncaso ainda mostram que o papel do programador da aplica\u00e7\u00e3o como \u201cgerente de energia\u201d\n\ndo sistema n\u00e3o deve tornar a tarefa de desenvolvimento desta aplica\u00e7\u00e3o mais complexa\n\n\n\n74\n\nj\u00e1 que, a partir de uma an\u00e1lise da aplica\u00e7\u00e3o, \u00e9 poss\u00edvel identificar os momentos em que\n\ncada componente deve estar em cada modo de opera\u00e7\u00e3o, n\u00e3o sendo complicado inserir\n\nno c\u00f3digo da aplica\u00e7\u00e3o chamadas \u00e0 API de ger\u00eancia de energia. Mecanismos especi-\n\nficados nesta proposta ainda liberam o programador da aplica\u00e7\u00e3o de se preocupar com\n\nconcorr\u00eancia no acesso a componentes (e.g., duas threads utilizando o mesmo dispositivo\n\nde comunica\u00e7\u00e3o), e a integra\u00e7\u00e3o dos componentes atrav\u00e9s das redes de modo de opera\u00e7\u00e3o\n\npermite ao programador trocar os modos de opera\u00e7\u00e3o de todos os componentes do sistema\n\nem conjunto.\n\n\u00c9 fato, por\u00e9m, que esta proposta possui limita\u00e7\u00f5es. Uma das limita\u00e7\u00f5es\n\nexistentes \u00e9 o emprego das redes de troca de modos de opera\u00e7\u00e3o para gerar c\u00f3digo-fonte\n\nde ger\u00eancia de energia. Como este mecanismo de ger\u00eancia de energia foi implementado\n\ncomo um aspecto e, portanto, n\u00e3o est\u00e1 diretamente integrado ao sistema, mudan\u00e7as no\n\nsistema alvo podem fazer com que o aspecto de ger\u00eancia de energia ou deixe de operar ou\n\npasse a n\u00e3o ser totalmente eficiente. Algumas mudan\u00e7as no sistema alvo podem requerer\n\nmudan\u00e7as nas redes de troca de modos de opera\u00e7\u00e3o e, por consequ\u00eancia, a re-gera\u00e7\u00e3o de\n\nc\u00f3digo para o sistema. Outra limita\u00e7\u00e3o, n\u00e3o t\u00e3o grave, \u00e9 o fato de tornar a ger\u00eancia de\n\nenergia do sistema alvo dependente de uma ferramenta externa ao sistema. Esta limita\u00e7\u00e3o\n\nfica menos importante ao passo que, com o tempo, as redes de troca de modos de opera\u00e7\u00e3o\n\ntomem forma est\u00e1vel. A partir da\u00ed seria poss\u00edvel manter unidades de compila\u00e7\u00e3o prontas,\n\nn\u00e3o sendo necess\u00e1rio o uso das ferramentas de ger\u00eancia de energia a cada compila\u00e7\u00e3o do\n\nsistema.\n\nAinda como limita\u00e7\u00e3o desta proposta cabe citar o fato de que, assim\n\ncomo gerentes de energia convencionais que tomam decis\u00f5es em tempo de execu\u00e7\u00e3o, o\n\nprogramador da aplica\u00e7\u00e3o tamb\u00e9m est\u00e1 propenso a cometer erros no gerenciamento de\n\nenergia. O principal erro que um programador de aplica\u00e7\u00e3o pode gerar \u00e9 o de ligar e\n\ndesligar dispositivos muito freq\u00fcentemente. A maioria dos dispositivos consomem para\n\nligar ou desligar uma quantidade de energia compar\u00e1vel \u00e0 sua opera\u00e7\u00e3o por um determi-\n\nnado per\u00edodo de tempo. Em alguns casos \u00e9 interessante manter os dispositivos ligados\n\ncaso estes devam estar novamente ativos dentro de um curto per\u00edodo de tempo. Identificar\n\nestes casos \u00e9, contudo, uma tarefa dif\u00edcil para o programador, j\u00e1 que atividades do sis-\n\n\n\n75\n\ntema podem estar condicionadas a eventos espor\u00e1dicos, cuja freq\u00fc\u00eancia n\u00e3o se conhece.\n\nUm trabalho em andamento est\u00e1 estudando os custos de ligar e desligar componentes\n\npara estender este mecanismo de ger\u00eancia de energia possibilitando que, atrav\u00e9s de uma\n\nan\u00e1lise do comportamento dos dispositivos individualmente, seja poss\u00edvel impedir que o\n\nprogramador da aplica\u00e7\u00e3o cometa estes erros.\n\nOutro trabalho em andamento est\u00e1 utilizando a infra-estrutura de ger\u00ean-\n\ncia de energia definida nesta proposta para computar o consumo de energia de tarefas\n\nimprecisas para guiar o processo de tomada de decis\u00e3o quanto \u00e0 execu\u00e7\u00e3o ou n\u00e3o dos tre-\n\nchos imprecisos destas tarefas. No futuro este mecanismo deve ser integrado a um sistema\n\nde QOS (Quality of Service) que permitir\u00e1 o uso de consumo de energia como par\u00e2metro\n\nde QOS dos sistemas computacionais.\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas\n\n[ABO 03] ABOUGHAZALEH, N. et al. Energy management for real-time embedded applications with\n\ncompiler support. In: LCTES \u201903: PROCEEDINGS OF THE 2003 ACM SIGPLAN\n\nCONFERENCE ON LANGUAGE, COMPILER, AND TOOL FOR EMBEDDED\n\nSYSTEMS, 2003. Proceedings... New York, NY, USA: ACM Press, 2003. p.284\u2013293.\n\n[AKH 05] AKHARWARE, N. PIPE2: Platform Independent Petri Net Editor. London: Imperial\n\nCollege of Science, Technology and Medicine, 2005. Disserta\u00e7\u00e3o de Mestrado.\n\n[ANA 04] ANAND, M.; NIGHTINGALE, E. B.; FLINN, J. Ghosts in the machine: Interfaces for better\n\npower management. In: PROCEEDINGS OF THE SECOND INTERNATIONAL\n\nCONFERENCE ON MOBILE SYSTEMS, APPLICATIONS, AND SERVICES\n\n(MOBISYS\u201904), 2004. Proceedings... Boston, USA: [s.n.], 2004.\n\n[AS 04] AS, C. SmartRF CC1000 Datasheet. Oslo, Norway, 2.2. ed., Apr, 2004.\n\n[ATM 04a] ATMEL. ATMega128L Datasheet. San Jose, CA, 2467M. ed., Nov, 2004.\n\n[ATM 04b] ATMEL. ATMega16L Datasheet. San Jose, CA, 2466J. ed., Oct, 2004.\n\n[AZE 02] AZEVEDO, A. et al. Profile-based dynamic voltage scheduling using program checkpoints.\n\nIn: DATE \u201902: PROCEEDINGS OF THE CONFERENCE ON DESIGN, AUTOMATION\n\nAND TEST IN EUROPE, 2002. Proceedings... Washington, DC, USA: IEEE Computer\n\nSociety, 2002. p.168.\n\n[BEN 98] BENINI, L.; BOGLIOLO, A.; MICHELI, G. D. Dynamic power management of electronic\n\nsystems. In: ICCAD \u201998: PROCEEDINGS OF THE 1998 IEEE/ACM INTERNATIONAL\n\nCONFERENCE ON COMPUTER-AIDED DESIGN, 1998. Proceedings... New York, NY,\n\nUSA: ACM Press, 1998. p.696\u2013702.\n\n[BIL 03] BILLINGTON, J. et al. The petri net markup language: Concepts, technology, and tools. In:\n\nAPPLICATIONS AND THEORY OF PETRI NETS 2003: 24TH INTERNATIONAL\n\nCONFERENCE, ICATPN 2003, 2003. Proceedings... Eindhoven, The Netherlands:\n\nSpringer, 2003. v.2679/2003 of LNCS, p.483\u2013505.\n\n\n\n77\n\n[CHA 92] CHANDRAKASAN, A. P.; SHENG, S.; BRODERSEN, R. W. Low-power cmos digital\n\ndesign. IEEE Journal of Solid-State Circuits, [S.l.], v.27, n.4, p.473\u2013484, Apr, 1992.\n\n[CHE 04] CHEN, D. et al. Low-power technology mapping for fpga architectures with dual supply\n\nvoltages. In: FPGA \u201904: PROCEEDINGS OF THE 2004 ACM/SIGDA 12TH\n\nINTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS, 2004.\n\nProceedings... New York, NY, USA: ACM Press, 2004. p.109\u2013117.\n\n[CRO 06] CROSSBOW. MPR-MIB Users Manual. San Jose, USA, Rev. B. ed., 2006.\n\n[CUL 01] CULLER, D. E. et al. A network-centric approach to embedded software for tiny devices. In:\n\nEMSOFT, 2001. Proceedings... Tahoe City, CA, USA: Springer, 2001. v.2211 of Lecture\n\nNotes in Computer Science.\n\n[CZA 98] CZARNECKI, K. et al. Generative Programming and Active Libraries. In: REPORT OF\n\nTHE DAGSTUHL SEMINAR ON GENERIC PROGRAMMING, 1998. Proceedings...\n\nSchlo\u00df Dagstuhl, Germany: [s.n.], 1998.\n\n[D\u2019A 05] D\u2019AGOSTINI, T. S.; FR\u00f6HLICH, A. A. Bridging AOP to SMP: turning GCC into a\n\nmetalanguage preprocessor. In: 20TH ANNUAL ACM SYMPOSIUM ON APPLIED\n\nCOMPUTING, 2005. Proceedings... Santa Fe, U.S.A.: [s.n.], 2005. p.1563\u20131564.\n\n[EBE 04] EBERGEN, J.; GAINSLEY, J.; CUNNINGHAM, P. Transistor sizing: how to control the\n\nspeed and energy consumption of a circuit. In: PROCEEDINGS OF THE 10TH\n\nINTERNATIONAL SYMPOSIUM ON ASYNCHRONOUS CIRCUITS AND SYSTEMS,\n\n2004. Proceedings... Crete, Greece: IEEE, 2004. p.51\u201361.\n\n[ELL 99] ELLIS, C. S. The case for higher-level power management. In: HOTOS \u201999:\n\nPROCEEDINGS OF THE THE SEVENTH WORKSHOP ON HOT TOPICS IN\n\nOPERATING SYSTEMS, 1999. Proceedings... Washington, DC, USA: IEEE Computer\n\nSociety, 1999. p.162.\n\n[ERN 03] ERNST, D. et al. Razor: A low-power pipeline based on circuit-level timing speculation. In:\n\nMICRO 36: PROCEEDINGS OF THE 36TH ANNUAL IEEE/ACM INTERNATIONAL\n\nSYMPOSIUM ON MICROARCHITECTURE, 2003. Proceedings... Washington, DC, USA:\n\nIEEE Computer Society, 2003. p.7.\n\n[FLA 01] FLAUTNER, K.; REINHARDT, S.; MUDGE, T. Automatic performance setting for dynamic\n\nvoltage scaling. In: MOBICOM \u201901: PROCEEDINGS OF THE 7TH ANNUAL\n\nINTERNATIONAL CONFERENCE ON MOBILE COMPUTING AND NETWORKING,\n\n2001. Proceedings... New York, NY, USA: ACM Press, 2001. p.260\u2013271.\n\n\n\n78\n\n[FLI 99] FLINN, J.; SATYANARAYANAN, M. Energy-aware adaptation for mobile applications. In:\n\nSOSP \u201999: PROCEEDINGS OF THE SEVENTEENTH ACM SYMPOSIUM ON\n\nOPERATING SYSTEMS PRINCIPLES, 1999. Proceedings... New York, NY, USA: ACM\n\nPress, 1999. p.48\u201363.\n\n[FOR 97] FORD, B. et al. The Flux OS Toolkit: Reusable Components for OS Implementation. In:\n\nPROCEEDINGS OF THE SIXTH WORKSHOP ON HOT TOPICS IN OPERATING\n\nSYSTEMS, 1997. Proceedings... Cape Cod, U.S.A.: [s.n.], 1997. p.14\u201319.\n\n[FR\u00f6 01] FR\u00f6HLICH, A. A. Application-Oriented Operating Systems. Sankt Augustin: GMD -\n\nForschungszentrum Informationstechnik, 2001. 200 p.\n\n[GOV 95] GOVIL, K.; CHAN, E.; WASSERMAN, H. Comparing algorithm for dynamic speed-setting\n\nof a low-power cpu. In: MOBICOM \u201995: PROCEEDINGS OF THE 1ST ANNUAL\n\nINTERNATIONAL CONFERENCE ON MOBILE COMPUTING AND NETWORKING,\n\n1995. Proceedings... New York, NY, USA: ACM Press, 1995. p.13\u201325.\n\n[GRO 03] GROVER, A. Modern system power management. ACM Queue, New York, NY, USA, v.1,\n\nn.7, p.66\u201372, 2003.\n\n[GRU 01] GRUIAN, F. Hard real-time scheduling for low-energy using stochastic data and dvs\n\nprocessors. In: ISLPED \u201901: PROCEEDINGS OF THE 2001 INTERNATIONAL\n\nSYMPOSIUM ON LOW POWER ELECTRONICS AND DESIGN, 2001. Proceedings...\n\nNew York, NY, USA: ACM Press, 2001. p.46\u201351.\n\n[HEA 04] HEATH, T. et al. Code transformations for energy-efficient device management. IEEE\n\nTransactions on Computers, [S.l.], v.53, n.8, August, 2004.\n\n[HIL 00] HILL, J. et al. System architecture directions for networked sensors. In: PROCEEDINGS OF\n\nTHE NINTH INTERNATIONAL CONFERENCE ON ARCHITECTURAL SUPPORT FOR\n\nPROGRAMMING LANGUAGES AND OPERATING SYSTEMS, 2000. Proceedings...\n\nCambridge, Massachusetts, United States: [s.n.], 2000. p.93\u2013104.\n\n[HP 04] HEWLETT-PACKARD, C. et al. Advanced Configuration and Power Interface\n\nSpecification, 3.0. ed., Sep, 2004.\n\n[HSU 03] HSU, C.-H.; KREMER, U. The design, implementation, and evaluation of a compiler\n\nalgorithm for cpu energy reduction. In: PLDI \u201903: PROCEEDINGS OF THE ACM\n\nSIGPLAN 2003 CONFERENCE ON PROGRAMMING LANGUAGE DESIGN AND\n\nIMPLEMENTATION, 2003. Proceedings... New York, NY, USA: ACM Press, 2003.\n\np.38\u201348.\n\n\n\n79\n\n[INT 96] INTEL, C.; MICROSOFT, C. Advanced Power Management (APM) BIOS Interface\n\nSpecification, 1.2. ed., Feb, 1996.\n\n[KEL 06] KELLNER, S. Energy Accounting and Control for Sensor Nodes. Erlangen, Germany:\n\nUniversity of Erlangen-N\u00fcrnberg, jan, 2006. Diplomarbeit.\n\n[KIC 97] KICZALES, G. et al. Aspect-Oriented Programming. In: PROCEEDINGS OF THE\n\nEUROPEAN CONFERENCE ON OBJECT-ORIENTED PROGRAMMING\u201997, 1997.\n\nProceedings... Jyv\u00e4skyl\u00e4, Finland: Springer, 1997. v.1241 of Lecture Notes in Computer\n\nScience, p.220\u2013242.\n\n[KUR 04] KURSUN, E.; GHIASI, S.; SARRAFZADEH, M. Transistor level budgeting for power\n\noptimization. In: ISQED \u201904: PROCEEDINGS OF THE 5TH INTERNATIONAL\n\nSYMPOSIUM ON QUALITY ELECTRONIC DESIGN, 2004. Proceedings... Washington,\n\nDC, USA: IEEE Computer Society, 2004. p.116\u2013121.\n\n[LEE 00] LEE, K. Ieee 1451: A standard in support of smart transducer networking. In:\n\nPROCEEDINGS OF THE IEEE INSTRUMENTATION AND MEASUREMENT\n\nTECHNOLOGY CONFERENCE, 2000. Proceedings... Baltimore, MD: [s.n.], 2000.\n\np.525\u2013528.\n\n[LI 04] LI, H.; KATKOORI, S.; MAK, W.-K. Power minimization algorithms for lut-based fpga\n\ntechnology mapping. ACM Trans. Des. Autom. Electron. Syst., New York, NY, USA, v.9,\n\nn.1, p.33\u201351, 2004.\n\n[LOH 05] LOHMANN, D.; SCHR\u00f6DER-PREIKSCHAT, W.; SPINCZYK, O. Functional and\n\nnon-functional properties in a family of embedded operating systems. In: PROCEEDINGS\n\nOF THE TENTH IEEE INTERNATIONAL WORKSHOP ON OBJECT-ORIENTED\n\nREAL-TIME DEPENDABLE SYSTEMS, 2005. Proceedings... Sedona, USA: IEEEPress,\n\n2005.\n\n[LOR 01] LORCH, J. R.; SMITH, A. J. Improving dynamic voltage scaling algorithms with pace. In:\n\nSIGMETRICS \u201901: PROCEEDINGS OF THE 2001 ACM SIGMETRICS\n\nINTERNATIONAL CONFERENCE ON MEASUREMENT AND MODELING OF\n\nCOMPUTER SYSTEMS, 2001. Proceedings... New York, NY, USA: ACM Press, 2001.\n\np.50\u201361.\n\n[MOH 05] MOHAPATRA, S. et al. A cross-layer approach for power-performance optimization in\n\ndistributed mobile systems. In: IPDPS \u201905: PROCEEDINGS OF THE 19TH IEEE\n\nINTERNATIONAL PARALLEL AND DISTRIBUTED PROCESSING SYMPOSIUM\n\n(IPDPS\u201905) - WORKSHOP 10, 2005. Proceedings... Washington, DC, USA: IEEE\n\nComputer Society, 2005. p.218.1.\n\n\n\n80\n\n[PAN 04] PANASONIC. ERTJ Multilayer Chip NTC Thermistors Datasheet. Panasonic, 2004.\n\n[PEN 02] PENZES, P.; NYSTROEM, M.; MARTIN, A. Transistor sizing of energy-delay\u2013efficient\n\ncircuits. California Institute of Technology, Apr, 2002. Relat\u00f3rio T\u00e9cnico318.\n\n[PER 02] PEREIRA, C.; GUPTA, R.; SRIVASTAVA, M. Pasa: A software architecture for building\n\npower aware embedded systems. In: PROCEEDINGS OF THE 2002 IEEE CAS\n\nWORKSHOP ON WIRELESS COMMUNICATION AND NETWORKING, 2002.\n\nProceedings... Pasadena, USA: [s.n.], 2002.\n\n[PET 77] PETERSON, J. L. Petri nets. ACM Comput. Surv., New York, NY, USA, v.9, n.3,\n\np.223\u2013252, 1977.\n\n[POL 99] POLLACK, F. J. New microarchitecture challenges in the coming generations of cmos\n\nprocess technologies (keynote address)(abstract only). In: MICRO 32: PROCEEDINGS OF\n\nTHE 32ND ANNUAL ACM/IEEE INTERNATIONAL SYMPOSIUM ON\n\nMICROARCHITECTURE, 1999. Proceedings... Washington, DC, USA: IEEE Computer\n\nSociety, 1999. p.2.\n\n[POL 04] POLPETA, F. V.; FR\u00f6HLICH, A. A. Hardware Mediators: a Portability Artifact for\n\nComponent-Based Systems. In: INTERNATIONAL CONFERENCE ON EMBEDDED\n\nAND UBIQUITOUS COMPUTING, 2004. Proceedings... Aizu, Japan: Springer, 2004.\n\nv.3207 of Lecture Notes in Computer Science, p.271\u2013280.\n\n[RUT 01] RUTENBAR, R. A. et al. Low-power technology mapping for mixed-swing logic. In:\n\nISLPED \u201901: PROCEEDINGS OF THE 2001 INTERNATIONAL SYMPOSIUM ON LOW\n\nPOWER ELECTRONICS AND DESIGN, 2001. Proceedings... New York, NY, USA: ACM\n\nPress, 2001. p.291\u2013294.\n\n[SAC 03] SACHS, D. G.; ADVE, S. V.; JONES, D. L. Cross-layer adaptive video coding to reduce\n\nenergy on general-purpose processors. In: PROCEEDINGS OF THE 2003\n\nINTERNATIONAL CONFERENCE ON IMAGE PROCESSING, 2003. Proceedings...\n\nBarcelona, Spain: [s.n.], 2003. v.3, p.109\u2013112.\n\n[SAC 06] SACHS, D. G. A new framework for hierarchical cross-layer adaptation. Urbana, USA:\n\nUniversity of Illinois at Urbana-Champaign, 2006. Tese de Doutorado.\n\n[SHI 01] SHIN, D.; KIM, J.; LEE, S. Low-energy intra-task voltage scheduling using static timing\n\nanalysis. In: DAC \u201901: PROCEEDINGS OF THE 38TH CONFERENCE ON DESIGN\n\nAUTOMATION, 2001. Proceedings... New York, NY, USA: ACM Press, 2001. p.438\u2013443.\n\n[SMA 95] SMALL, C.; SELTZER, M. Structuring the Kernel as a Toolkit of Extensible, Reusable\n\nComponents. In: PROCEEDINGS OF THE 1995 INTERNATIONAL WORKSHOP ON\n\n\n\n81\n\nOBJECT ORIENTATION IN OPERATING SYSTEMS, 1995. Proceedings... Lund,\n\nSweden: [s.n.], 1995. p.134\u2013137.\n\n[SUL 04] SULTANIA, A. K.; SYLVESTER, D.; SAPATNEKAR, S. S. Transistor and pin reordering\n\nfor gate oxide leakage reduction in dual tox circuits. In: ICCD \u201904: PROCEEDINGS OF\n\nTHE IEEE INTERNATIONAL CONFERENCE ON COMPUTER DESIGN (ICCD\u201904),\n\n2004. Proceedings... Washington, DC, USA: IEEE Computer Society, 2004. p.228\u2013233.\n\n[TAN 03] TAN, T. K.; RAGHUNATHAN, A.; JHA, N. K. Software architectural transformations: A\n\nnew approach to low energy embedded software. In: DATE \u201903: PROCEEDINGS OF THE\n\nCONFERENCE ON DESIGN, AUTOMATION AND TEST IN EUROPE, 2003.\n\nProceedings... Washington, DC, USA: IEEE Computer Society, 2003. p.11046.\n\n[VEN 05] VENKATACHALAM, V.; FRANZ, M. Power reduction techniques for microprocessor\n\nsystems. ACM Comput. Surv., New York, NY, USA, v.37, n.3, p.195\u2013237, 2005.\n\n[WAN 05] WANNER, L. F. et al. Operating System Support for Handling Heterogeneity in Wireless\n\nSensor Networks. In: 10TH IEEE INTERNATIONAL CONFERENCE ON EMERGING\n\nTECHNOLOGIES AND FACTORY AUTOMATION, 2005. Proceedings... Catania, Italy:\n\n[s.n.], 2005.\n\n[WAN 06] WANNER, L. F. Suporte de sistema operacional para rede de sensores sem fio.\n\nFlorianpolis: Federal University of Santa Catarina, 2006. Disserta\u00e7\u00e3o de Mestrado.\n\n[WEI 94] WEISER, M. et al. Scheduling for reduced cpu energy. In: PROCEEDINGS OF THE FIRST\n\nSYMPOSIUM ON OPERATING SYSTEMS DESIGN AND IMPLEMENTATION, 1994.\n\nProceedings... Monterey, USA: [s.n.], 1994. p.13\u201323.\n\n[WEI 02a] WEISSEL, A.; BELLOSA, F. Process cruise control: Event-driven clock scaling for dynamic\n\npower management. In: PROCEEDINGS OF THE INTERNATIONAL CONFERENCE ON\n\nCOMPILERS, ARCHITECTURE, AND SYNTHESIS FOR EMBEDDED SYSTEMS\n\nCASES\u201902, 2002. Proceedings... Grenoble, France: [s.n.], 2002.\n\n[WEI 02b] WEISSEL, A.; BEUTEL, B.; BELLOSA, F. Cooperative io - a novel io semantics for\n\nenergy-aware applications. In: PROCEEDINGS OF THE FIFTH SYMPOSIUM ON\n\nOPERATING SYSTEMS DESIGN AND IMPLEMENTATION (OSDI \u201902), 2002.\n\nProceedings... Boston, USA: [s.n.], 2002. p.117\u2013129.\n\n[ZEN 02] ZENG, H. et al. Ecosystem: managing energy as a first class operating system resource. In:\n\nASPLOS-X: PROCEEDINGS OF THE 10TH INTERNATIONAL CONFERENCE ON\n\nARCHITECTURAL SUPPORT FOR PROGRAMMING LANGUAGES AND OPERATING\n\nSYSTEMS, 2002. Proceedings... New York, NY, USA: ACM Press, 2002. p.123\u2013132.\n\n\n\nAp\u00eandice A\n\nRede de Troca de Modos de Opera\u00e7\u00e3o\n\nGereralizada\n\n\n\n83"}]}}}