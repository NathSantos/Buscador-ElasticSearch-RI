{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.09786"}, {"@name": "filename", "#text": "14782_TESE%20Abner%20Correa%20Barros.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "^^Centro\nde Inform\u00e1tica\nU \u2022 F \u25a0 P \u2022 E\nP\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o\nUMA METODOLOGIA PARA A DETERMINA\u00c7\u00c3O DA PRECIS\u00c3O NUM\u00c9RICA NECESS\u00c1RIA \u00c0 IMPLEMENTA\u00c7\u00c3O DO ALGORITMO RTM\nAbner Corr\u00eaa Barros\nTese de Doutorado\nr\n\nUniversidade Federal de Pernambuco posgraduacao@cin.ufpe.br www.cin.ufpe.br/~posgraduacao\nAbner Corr\u00eaa Barros\nUMA METODOLOGIA PARA A DETERMINA\u00c7\u00c3O DA PRECIS\u00c3O NUM\u00c9RICA NECESS\u00c1RIA \u00c0 IMPLEMENTA\u00c7\u00c3O DO ALGORITMO RTM\nTrabalho apresentado ao Programa de P\u00f3s-gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o do Centro de Inform\u00e1tica da Universidade Federal de Pernambuco como requisito parcial para obten\u00e7\u00e3o do grau de Doutor em Ci\u00eancia da Computa\u00e7\u00e3o.\nOrientador: Dr. Manoel Eusebio de Lima Co-Orientador: Dr. Renato Jos\u00e9 de Sobral Cintra\nCataloga\u00e7\u00e3o na fonte\nBibliotec\u00e1ria Jane Souto Maior, CRB4-571\nBarros, Abner Corr\u00eaa\nUma metodologia para a determina\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria \u00e1 implementa\u00e7\u00e3o do algoritmo RTM / Abner Corr\u00eaa Barros. - Recife: O Autor, 2014.\n233 p., fig., tab., gr\u00e1f.\nOrientador: Manoel Eusebio de Lima.\nTese (doutorado) - Universidade Federal de Pernambuco. CIn, Ci\u00eancia da Computa\u00e7\u00e3o, 2014.\nInclui refer\u00eancias e ap\u00eandice.\n1.\tArquitetura de computadores. 2. Computa\u00e7\u00e3o de alto desempenho. 3. Computa\u00e7\u00e3o cient\u00edfica. I. Lima, Manoel Eusebio de (orientador). II. T\u00edtulo.\n004.22\nCDD (23. ed.)\nMEI2014 - 136\nPro\u00eda. Marcilia Andrade Campos\nCentro de Inform\u00e1tica / UFPE\nProf. Abel Guilhermino da Silva Filho Centro de Inform\u00e1tica / UFPE\nProf. Jos\u00e9 Antonio Barbosa\nDepartamento de Geologia / UFPE\nProf. Paulo S\u00e9rgio Brand\u00e3o Nascimento\nInstituto Federal de Pennambuco\nProf. Ismael Humberto Ferreira dos Santos Centro de Pesquisa da Petrobras\nVisto e permitida a impress\u00e3o.\nRecife, 14 de mar\u00e7o de 2014.\nProfa. Edna Natividade da Silva Barros\nCoordenadora da P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o do Centro de Inform\u00e1tica da Universidade Federal de Pernambuco.\nDedico este trabalho aos meus pais, \u00e0 minha querida esposa, Rosangela, aos meus filhos Natalia, Gabriela, Yuri e Laysa, e ao meu netinho Ravi.\nAgradecimentos\nAo meu querido filho Yuri, por sua inestim\u00e1vel ajuda na resolu\u00e7\u00e3o das intermin\u00e1veis s\u00e9ries de c\u00e1lculos e avalia\u00e7\u00f5es dos experimentos e pelas longas e acaloradas discuss\u00f5es sobre os fen\u00f4menos f\u00edsicos envolvidos na propaga\u00e7\u00e3o da onda s\u00edsmica.\nAo meu amigo Ricardo de Bragan\u00e7a, um verdadeiro Doutor em Geof\u00edsica. Algu\u00e9m que eu aprendi a respeitar e admirar por sua compet\u00eancia e esp\u00edrito prestativo. Foram suas as primeiras orienta\u00e7\u00f5es que me mostraram o rumo a seguir.\nAo meu orientador e amigo, Prof. Dr. Manoel Eusebio de Lima, por suas palavras de incentivo e apoio.\nAo meu coorientador, Prof. Dr. Renato Cintra, que tantas vezes conseguiu ver no meu trabalho algo que nem eu mesmo era capaz de ver.\n\u00c0s minhas amigas Aline Tim\u00f3teo e Fl\u00e1via Merlin, companheiras de longas datas. Pelas cr\u00edticas sempre t\u00e3o construtivas e pelas palavras de incentivo ditas sempre em momentos t\u00e3o oportunos.\nAo Centro de Inform\u00e1tica da UFPE, que me concedeu a oportunidade de desenvolver minhas pesquisas e meu potencial em um ambiente t\u00e3o vibrante e, ao mesmo tempo, t\u00e3o acolhedor.\nAo Cenpes, \u00e0 Petrobras e \u00e0 Finep, pelo suporte financeiro atrav\u00e9s da bolsa de pesquisa e pelos recursos necess\u00e1rios \u00e0 conclus\u00e3o deste trabalho. .\nNo princ\u00edpio criou Deus os c\u00e9us e a terra, a terra por\u00e9m era sem forma e vazia.\n\u2014GENESIS 1:1\nResumo\nNestes \u00faltimos anos, com o in\u00edcio da prospec\u00e7\u00e3o de petr\u00f3leo em regio\u00f5es com litolo-gias complexas, tem se observado um crescente interesse no uso do algoritmo Reverse Time Migration(RTM) como solu\u00e7\u00e3o para o imageamento s\u00edsmico.\nDevido ao seu elevado custo computacional, o algoritmo RTM exige o uso de sistemas computacionais de alto desempenho, os quais demandam investimentos elevados em infra-estrutura, o que normalmente representa tamb\u00e9m um aumento substancial no consumo de energia.\nNeste cen\u00e1rio, o desenvolvimento de coprocessadores aritm\u00e9ticos de alto desempenho, implementados por meio dos Field Programmable Gate Arrays(FPGAs), passou a ser considerado uma alternativa vi\u00e1vel no objetivo de aumentar o a capacidade de processamento de sistemas computacionais j\u00e1 existentes, com impactos positivos tanto nos investimentos em infra-estrutura quanto no consumo de energia.\nEntretanto, o desenvolvimento destes coprocessadores normalmente exige um estudo pr\u00e9vio minucioso das caracter\u00edsticas do algoritmo a ser implementado e do conjunto de dados a ser processado, a fim de determinar a precis\u00e3o num\u00e9rica mnima que deve ser empregada em sua implementa\u00e7\u00e3o.\nO objetivo deste trabalho foi desenvolver uma metodologia que permita identificar a precis\u00e3o num\u00e9rica m\u00ednima necess\u00e1ria \u00e0 implementa\u00e7\u00e3o do algoritmo RTM, baseado nos fen\u00f4menos f\u00edsicos envolvidos na propaga\u00e7\u00e3o da onda s\u00edsmica e nas litologias prov\u00e1veis da regi\u00e3o a ser imageada.\nPara chegar a este objetivo foi desenvolvido um m\u00e9todo anal\u00edtico, capaz de predizer a atenua\u00e7\u00e3o esperada para as ondas s\u00edsmicas durante os processos de modelagem e migra\u00e7\u00e3o presentes no algoritmo RTM. Esse m\u00e9todo foi baseado em uma nova abordagem no tratamento da atenua\u00e7\u00e3o por espalhamento geom\u00e9trico para modelos com m\u00faltiplas camadas, denominada de Raio Efetivo.\nComo estudo de caso de valida\u00e7\u00e3o dessa metodologia, foram feitas predi\u00e7\u00f5es e analisados os resultados de imageamento de diversos modelos sint\u00e9ticos propostos por um especialista em geologia, os quais eram formados apenas por camadas horizontais, planas e paralelas. Al\u00e9m desses modelos mais simples, foi tamb\u00e9m utilizado um modelo reconhecidamente complexo, conhecido como modelo de marmousi. Os resultados obtidos em todos os estudos se mostraram dentro de uma margem de seguran\u00e7a de 1 bit de precis\u00e3o.\nAbstract\nIn recent years, with the beginning of oil exploration in regions with complex lithologies, has observed an increasing interest in the use of the Reverse Time Migration (RTM) algorithm as solution for seismic imaging.\nDue to its high computational cost, the algorithm emph RTM requires the use of high performance computing systems, which require high investments in infrastructure, which usually also represents a substantial increase in energy consumption.\nIn this scenario, the development of the high performance arithmetic co-processor, implemented using Field Programmable Gate Arrays (FPGAs), has been considered a viable alternative, in order to increase the the capacity of processing existent computational systems, with positive impacts both in investments in infrastructure and energy consumption.\nHowever, the development of these coprocessors typically requires thorough previous study of the characteristics of the algorithm to be implemented and about of set of data to be processed in order to determine the minimum numerical precision that must be used in its implementation\nThe aim of this study was to develop a methodology that allows identify the minimum numerical precision necessary to implement the RTM algorithm, based on the physical phenomena involved in propagation of the seismic waves and the likely lithologies in the region to be imaged.\nTo reach this goal it was developed a analytical method, able to predict the expected attenuation for seismic waves during the processes of modeling and migration present in the algorithm emph RTM. This method was based on a new approach treatment of attenuation by geometrical spreading for models with multiple layers, called Effective Radius.\nAs a case study validating this methodology, predictions were made and analyzed the results of various synthetic models proposed by an expert in geology. These models are carecterized by having only horizontal layers, flat and parallel, in compatible dimension with the expected in the real physical medium. Besides these simple models we also used a complex known model, known as the Marmousi model. The results obtained in all studies were within a safety margin of 1 bit precision.\nKeywords: High-performance computing. emph Field Programmable Gate Arrays. emph FPGA. Floating-point arithmetic. Fixed-point arithmetic. Reverse-Time Migration algorithm. RTM algorithm. Processing Seismic Data. Seismic imaging. Effective Radius.\nLista de Figuras\n1.1\tIlustra\u00e7\u00e3o das camadas em subsuperf\u00edcie at\u00e9 a camada pr\u00e9-sal................. 20\n1.2\tVibrosis e Airgun - Fontes controladas de energia utilizadas no imageamento\ns\u00edsmico .................................................................... 22\n1.3\tIlustra\u00e7\u00e3o do m\u00e9todo s\u00edsmico de reflex\u00e3o..................................... 22\n1.4\tComparativo entre as arquiteturas GPU e CPU.................................. 24\n1.5\tVis\u00e3o macro da arquitetura interna dos FPGAs................................. 25\n1.6\tResultado do processamento s\u00edsmico utilizando o algoritmo PSTM em diversas\nprecis\u00f5es num\u00e9ricas......................................................... 27\n1.7\tPrimeiros resultados publicados deste trabalho referentes ao efeito da precis\u00e3o\nnum\u00e9rica no processamento\ts\u00edsmico utilizando o algoritmo RTM.............. 29\n1.8\tEtapas de processamento do ponto-flutuante................................... 32\n1.9\tCompara\u00e7\u00e3o entre as representa\u00e7\u00f5es em ponto-fixo e ponto-flutuante........... 34\n2.1\tMedi\u00e7\u00e3o do tempo de tr\u00e2nsito do pulso s\u00edsmico no algoritmo PSTM.............. 37\n2.2\tPropaga\u00e7\u00e3o do pulso s\u00edsmico ................................................. 40\n2.3\tPrinc\u00edpio de funcionamento do algoritmo RTM ................................. 41\n2.4\tComparativo do tempo de execu\u00e7\u00e3o do algoritmo RTM ........................... 42\n2.5\tDistribui\u00e7\u00e3o dos valores utilizados para determinar o intervalo de valores e a\nprecis\u00e3o do padr\u00e3o de representa\u00e7\u00e3o......................................... 44\n2.6\tPlataforma de processamento s\u00edsmico baseada em FPGAs......................... 45\n2.7\tSNR e UQI total medido em diversas precis\u00f5es ................................ 48\n2.8\tSNR e UQI de transporte...................................................... 48\n3.1\tRepresenta\u00e7\u00e3o do pulso s\u00edsmico modelado por meio da segunda derivada da\nfun\u00e7\u00e3o gausiana ............................................................ 51\n3.2\tAmplitude do pulso s\u00edsmico introduzido em rela\u00e7\u00e3o \u00e0 velocidade do meio ...\t52\n3.3\tOndas compressionais (P) e ondas transversais (S)............................ 53\n3.4\tOndas refletidas, compressionais RP e transversais RS, e refratadas, compressio-\nnais TP e transversais TS .................................................. 54\n3.5\tIlustra\u00e7\u00e3o da aplica\u00e7\u00e3o do Princ\u00edpio de Huygens \u00e0 propaga\u00e7\u00e3o da onda em\nespa\u00e7os isotr\u00f3picos......................................................... 56\n3.6\tIlustra\u00e7\u00e3o da forma de propaga\u00e7\u00e3o\tda onda s\u00edsmica em meio isotr\u00f3pico........ 57\n3.7\tExemplo de c\u00e1lculo do raio efetivo\trE........................................ 60\n3.8\tConfigura\u00e7\u00e3o do experimento 1................................................ 62\n3.9\tAtenua\u00e7\u00e3o por diverg\u00eancia cil\u00edndrica no primeiro experimento de valida\u00e7\u00e3o do\nraio efetivo ............................................................... 63\n3.10\tCompensa\u00e7\u00e3o da atenua\u00e7\u00e3o por diverg\u00eancia por meio da aplica\u00e7\u00e3o da Equa\u00e7\u00e3o\n3.28.................................................................... 63\n3.11\tCompensa\u00e7\u00e3o da atenua\u00e7\u00e3o por diverg\u00eancia por meio da aplica\u00e7\u00e3o conjunta das\nEqua\u00e7\u00f5es 3.28 e 3.26.................................................... 64\n3.12\tConfigura\u00e7\u00e3o do experimento 2.......................................... 64\n3.13\tAtenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em meio isotr\u00f3pico com duas\ncamadas com velocidade de propaga\u00e7\u00e3o de 1500 e 2500 m/s................. 65\n3.14\tCompensa\u00e7\u00e3o da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em modelo com\nduas camadas, sem a aplica\u00e7\u00e3o do raio efetivo........................... 65\n3.15\tCompensa\u00e7\u00e3o da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em modelo com\nduas camadas com a aplica\u00e7\u00e3o do raio efetivo............................ 66\n3.16\tConfigura\u00e7\u00e3o do experimento 3.......................................... 67\n3.17\tTentativa de compensa\u00e7\u00e3o da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em\nmeio com tr\u00eas camadas utilizando o raio real............................ 67\n3.18\tCompensa\u00e7\u00e3o efetiva da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em meio\ncom tr\u00eas camadas por meio da utiliza\u00e7\u00e3o do conceito do raio efetivo .... 68\n3.19\tEsquema gr\u00e1fico\tcom o percurso da onda s\u00edsmica......................... 70\n3.20\tEsquema gr\u00e1fico\tpara a demonstra\u00e7\u00e3o do c\u00e1lculo da atenua\u00e7\u00e3o efetiva.... 71\n3.21\tEsquema gr\u00e1fico\tpara a demonstra\u00e7\u00e3o do c\u00e1lculo da atenua\u00e7\u00e3o efetiva ... 71\n3.22\tAlgoritmo utilizado para a predi\u00e7\u00e3o da menor amplitude das ondas s\u00edsmicas\nrefletidas.............................................................. 75\n3.23\tIdentifica\u00e7\u00e3o dos elementos gerados com a execu\u00e7\u00e3o do algoritmo proposto. . .\t76\n4.1\tEstrutura geol\u00f3gica dos modelos 1, 2, 3 e 4............................. 80\n4.2\tEstruturas geol\u00f3gicas do modelo 5 e do modelo de Marmousi............... 81\n4.3\tResultados\tobtidos\tcom o processamento\tcom o Modelo 1 .................. 82\n4.4\tResultados\tobtidos\tcom o processamento\tcom o Modelo 2................... 83\n4.5\tResultados\tobtidos\tcom o processamento\tcom o Modelo 3 .................. 84\n4.6\tResultados\tobtidos\tcom o processamento\tcom o Modelo 4 .................. 85\n4.7\tResultados\tobtidos\tcom o processamento\tcom o Modelo 5 .................. 86\n4.8\tResultados\tobtidos\tcom o processamento\tcom o Modelo de Marmousi ........ 87\n4.9\tValores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o\nmodelo 1 .............................................................. 88\n4.10\tValores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o\nmodelo 3 ............................................................... 88\n4.11\tValores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o\nmodelo 4 ............................................................... 89\n4.12\tValores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o\nmodelo 5 .............................................................. 89\n4.13\tValores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o\nmodelo de Marmousi.................................................... 90\n4.14\tEstruturado PE-Float Altera.......................................... 92\n4.15\tEstrutura interna utilizada na implementa\u00e7\u00e3o do PE-Float............. 94\n4.16\tEstrutura\tinterna\tdo m\u00f3dulo Multiplica_2Bij.......................... 95\n4.17\tEstrutura\tinterna\tdo m\u00f3dulo Absi_Absj................................ 96\n4.18\tEstrutura\tinterna\tdo m\u00f3dulo Menos_Aij................................ 96\n4.19\tEstrutura\tinterna\tdo m\u00f3dulo Vel_Vel_Fat.............................. 97\n4.20\tEstrutura\tinterna\tdo m\u00f3dulo N\u00facleo Soma.............................. 97\n4.21\tEstrutura\tinterna\tdo m\u00f3dulo M16Soma.................................. 98\n4.22\tEstrutura\tinterna\tdo m\u00f3dulo M1Soma................................... 98\n4.23\tEstrutura\tinterna\tdo m\u00f3dulo M60...................................... 99\n4.24\tEstrutura\tinterna\tdo m\u00f3dulo Conversor. .............................. 99\n4.25\tEstrutura\tinterna\tdo m\u00f3dulo Comparador...............................100\n4.26\tEstrutura\tinterna\tdo m\u00f3dulo Multiplica_V2FAT_NS......................100\n4.27\tEstrutura\tinterna\tdo m\u00f3dulo Soma_MAij_V2FAT_NS.......................101\n4.28\tEstrutura interna dos m\u00f3dulos Multiplica_ABS_1 e Multiplica_ABS_2....101\n4.29\tEstrutura\tinterna\tdo m\u00f3dulo Soma_2Bij_NS.............................102\n4.30\tEstrutura\tinterna\tdo m\u00f3dulo que normaliza e\tarredonda os resultados..102\n4.31\tEstrutura interna do n\u00facleo de processamento 2D em ponto-fixo........103\nA.1 Estrutura geol\u00f3gica do modelo 1........................................118\nA.2 Imageamento de refer\u00eancia para o modelo 1 gerado no padr\u00e3o de ponto-flutuante. 119\nA.3\tImageamento do\tmodelo\t1\tobtido\tcom 22 bits\tde precis\u00e3o...............120\nA.4\tImageamento do\tmodelo\t1\tobtido\tcom 20 bits\tde precis\u00e3o...............121\nA.5\tImageamento do\tmodelo\t1\tobtido\tcom 18 bits\tde precis\u00e3o...............122\nA.6\tImageamento do\tmodelo\t1\tobtido\tcom 16 bits\tde precis\u00e3o...............123\nA.7\tImageamento do\tmodelo\t1\tobtido\tcom 14 bits\tde precis\u00e3o...............124\nA.\t8\tImageamento do\tmodelo\t1\tobtido\tcom 13 bits\tde precis\u00e3o...............125\nB.\t1 Estrutura geol\u00f3gica do modelo 2......................................128\nB.2 Imageamento de refer\u00eancia para o modelo 2 gerado no padr\u00e3o de ponto-flutuante. 129\nB.3\tImageamento do\tmodelo\t2\tobtido\tcom 24 bits\tde precis\u00e3o...............130\nB.4\tImageamento do\tmodelo\t2\tobtido\tcom 22 bits\tde precis\u00e3o...............131\nB.5\tImageamento do\tmodelo\t2\tobtido\tcom 20 bits\tde precis\u00e3o...............132\nB.6\tImageamento do\tmodelo\t2\tobtido\tcom 18 bits\tde precis\u00e3o...............133\nB.7\tImageamento do\tmodelo\t2\tobtido\tcom 16 bits\tde precis\u00e3o...............134\nB.8\tImageamento do\tmodelo\t2\tobtido\tcom 15 bits\tde precis\u00e3o...............135\nB.9\tImageamento do\tmodelo\t2\tobtido\tcom 14 bits\tde precis\u00e3o...............136\nC.6 Imageamento do modelo 3 obtido com\t16 bits de precis\u00e3o.............143\nC.7 Imageamento do modelo 3 obtido com\t16 bits de precis\u00e3o.............144\nC.8 Imageamento do modelo 3 obtido com\t14 bits de precis\u00e3o.............145\nC.9 Imageamento do modelo 3 obtido com\t13 bits de precis\u00e3o.............146\nC.10 Imageamento do modelo 3 obtido com\t12 bits de precis\u00e3o.............147\nC.\t11 Imageamento do modelo 3 obtido com\t11 bits de precis\u00e3o.............148\nD.\t1 Estrutura geol\u00f3gica do modelo 4.....................................150\nD.2 Imageamento de refer\u00eancia para o modelo 4 gerado no padr\u00e3o de ponto-flutuante. 151\nD.3 Imageamento do modelo 3 obtido com\t23 bits de precis\u00e3o.............152\nD.4 Imageamento do modelo 4 obtido com\t21 bits de precis\u00e3o.............153\nD.5 Imageamento do modelo 4 obtido com\t19 bits de precis\u00e3o.............154\nD.6 Imageamento do modelo 4 obtido com\t18 bits de precis\u00e3o.............155\nD.7 Imageamento do modelo 4 obtido com\t16 bits de precis\u00e3o.............156\nD.8 Imageamento do modelo 4 obtido com\t14 bits de precis\u00e3o.............157\nD.9 Imageamento do modelo 4 obtido com\t13 bits de precis\u00e3o.............158\nD.\t10 Imageamento do modelo 4 obtido com\t12 bits de precis\u00e3o.............159\nE.\t1 Estrutura geol\u00f3gica do modelo 5.....................................162\nE.2 Imageamento de refer\u00eancia para o modelo 5 gerado no padr\u00e3o de ponto-flutuante. 163\nE.3 Imageamento do modelo 5 obtido com\t23 bits de precis\u00e3o.............164\nE.4 Imageamento do modelo 5 obtido com\t21 bits de precis\u00e3o.............165\nE.5 Imageamento do modelo 5 obtido com\t19 bits de precis\u00e3o.............166\nE.6 Imageamento do modelo 5 obtido com\t18 bits de precis\u00e3o.............167\nE.7 Imageamento do modelo 5 obtido com\t16 bits de precis\u00e3o.............168\nE.8 Imageamento do modelo 5 obtido com\t14 bits de precis\u00e3o.............169\nE.9 Imageamento do modelo 5 obtido com\t13 bits de precis\u00e3o.............170\nE.\t10 Imageamento do modelo 5 obtido com\t12 bits de precis\u00e3o.............171\nF.\t1\tEstrutura geol\u00f3gica do modelo de Marmousi............................174\nF.2 Imageamento de refer\u00eancia para o modelo de Marmousi gerado no padr\u00e3o de\nponto-flutuante......................................................175\nF.3\tImageamento do modelo de Marmousi com 24 bits\tde\tprecis\u00e3o............176\nF.4\tImageamento do modelo de Marmousi com 22 bits\tde\tprecis\u00e3o............177\nF.5\tImageamento do modelo de Marmousi com 20 bits\tde\tprecis\u00e3o............178\n1.1\tOrganiza\u00e7\u00e3o dos campos que formam a representa\u00e7\u00e3o do padr\u00e3o de ponto-flutuante204\n1.2\tDistribui\u00e7\u00e3o dos valores represent\u00e1veis em ponto-flutuante..............209\n1.3\tDiferen\u00e7a na representa\u00e7\u00e3o entre um significando com 3 e um com 5 bits. . .\t.\t210\n1.4\tCompara\u00e7\u00e3o entre valores represent\u00e1veis com significandos com 5 e 3 bits.\t.\t.\t211\n1.5\tArredondamento em dire\u00e7\u00e3o ao Zero.......................................211\n1.6\tDire\u00e7\u00e3o do arredondamento em dire\u00e7\u00e3o ao+<^..............................212\n1.7\tDire\u00e7\u00e3o do arredondamento em dire\u00e7\u00e3o ao-<*>.............................212\n1.8\tDire\u00e7\u00e3o do arredondamento para o mais pr\u00f3ximo ou par....................213\n1.9\tExemplos de Arredondamento em dire\u00e7\u00e3o ao +^: e ao-<*>...................213\n1.10\tExemplo de Arredondamento para o mais pr\u00f3ximo e em dire\u00e7\u00e3o ao zero......213\n1.11\tEsquema para obten\u00e7\u00e3o do LSB bit, do Guard bit e do Sticky bit..........214\n1.12\tNova organiza\u00e7\u00e3o dos bits para simplificar a an\u00e1lise do processo de arredonda-\nmento........................................................................ 214\n1.13\tGera\u00e7\u00e3o do novo significando por meio dos bits extra\u00eddos do significando original\ne do Round bit obtido durante o processo de arredondamento....................215\n1.14\tLocaliza\u00e7\u00e3o do valor relativo do n\u00famero a ser arredondado por meio do Guard\nBit e do Sticky Bit...........................................................217\n1.15\tExemplos de opera\u00e7\u00f5es efetuadas em ponto-flutuante de base bin\u00e1ria com valores\nnormalizados que geram valores\tdesnormalizados...............................219\n1.16\tRealinhamento do significando.................................................223\n1.17\tRepresenta\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op2 para o formato de ponto-\nflutuante proposto. ......................................................... 224\n1.18\tRepresenta\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op3 para o formato de ponto-\nflutuante proposto. ......................................................... 225\n1.19\tRepresenta\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op4 para o formato de ponto-\nflutuante proposto. ......................................................... 225\n1.20\tDiagrama esquem\u00e1tico da opera\u00e7\u00e3o de soma entre Op1 e Op2......................225\n1.21\tRepresenta\u00e7\u00e3o do resultado da opera\u00e7\u00e3o entre Op1 e Op2 no formato de ponto-\nflutuante proposto. ......................................................... 226\n1.22\tRepresenta\u00e7\u00e3o esquem\u00e1tica da opera\u00e7\u00e3o de adi\u00e7\u00e3o entre Op3\te\tOp4...............226\n1.23\tOpera\u00e7\u00e3o de normaliza\u00e7\u00e3o sobre resultado da adi\u00e7\u00e3o de Op3\te\tOp4...............227\n1.24\tDistribui\u00e7\u00e3o dos bits durante o processo de arredondamento....................227\n1.25\tResultado do processo de arredondamento. .................................... 227\n1.26\tFluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o...........................228\n1.27\tDistribui\u00e7\u00e3o dos bits como resultado de uma opera\u00e7\u00e3o de multiplica\u00e7\u00e3o entre\ndois inteiros de tamanho n....................................................229\n1.28\tFluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o.............................\n1.29\tRepresenta\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op1 para o formato de ponto-\nflutuante proposto..........................................................\n1.30\tRepresenta\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op2 para o formato de ponto-\nflutuante proposto..........................................................\n1.31\tRepresenta\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o do resultado para o formato de ponto-\nflutuante proposto..........................................................\n229\n230\n230\n231\nLista de Tabelas\n2.1\tDesempenho da implementa\u00e7\u00e3o do algoritmo RTM............................... 42\n4.1\tMenor amplitude e precis\u00f5es num\u00e9ricas preditas para os modelos geol\u00f3gicos\navaliados ................................................................. 81\n4.2\tCompara\u00e7\u00e3o entre as precis\u00f5es num\u00e9ricas preditas e as encontradas ......... 90\n1.1\tFormatos de ponto-flutuante................................................207\n1.2\tValores especiais e suas representa\u00e7\u00f5es segundo o padr\u00e3o IEEE 754 ........ 209\n1.3\tDefini\u00e7\u00e3o do Round-Bit no arredondamento para mais pr\u00f3ximo ou par..........218\n1.4\tResultados esperados para opera\u00e7\u00f5es de multiplica\u00e7\u00e3o dos elementos da linha\ninicial pelos elementos da coluna inicial. ............................... 221\n1.5\tResultados esperados para opera\u00e7\u00f5es de divis\u00e3o dos elementos da linha inicial\npelos elementos da coluna inicial..........................................222\n1.6\tResultados esperados para opera\u00e7\u00f5es de adi\u00e7\u00e3o dos elementos da linha inicial\npelos elementos da coluna inicial..........................................222\n1.7\tResultados esperados para opera\u00e7\u00f5es de subtra\u00e7\u00e3o dos elementos da linha inicial\npelos elementos da coluna inicial..........................................222\n1.8\tFormato de ponto-flutuante com 9 bits, formulado apenas para fins did\u00e1ticos. . 224\nLista de Acr\u00f4nimos\nASIC\tApplication Specific Integrated Circuit..................................35\nCENPES\tCentro de Pesquisa e Desenvolvimento da Petrobras........................91\nCI\tCircuito Integrado.......................................................35\nCORDIC\tCoordinate Rotation Digital Computer.....................................36\nCPU\tCentral Processing Unit..................................................23\nDSP\tDigital Signal Processing................................................32\nFPGA\tField Programmable Gate Array............................................23\nFPU\tFloating Point Unit......................................................32\nGPGPU\tGeneral-Purpose Graphics Processing Unit.................................23\nHDL\tHardware Description Language............................................26\nMDF\tM\u00e9todo das Diferen\u00e7as Finitas............................................47\nNaN\tNot a Number.............................................................31\nPE\tProcessing Element.......................................................91\nPSPI\tPhase Shift Plus Interpolation...........................................22\nPSTM\tPre-stack Kirchhoff Time Migration.......................................22\nRTM\tReverse Time Migration...................................................22\nSNR\tSignal to Noise Ratio....................................................45\nUQI\tUniversal Quality Indice.................................................45\nULA\tUnidade L\u00f3gica e Aritm\u00e9tica..............................................23\nSum\u00e1rio\n1\tIntrodu\u00e7\u00e3o\t20\n2\tTrabalhos Relacionados\t35\n2.1\tProcessamento de dados s\u00edsmicos utilizando FPGAs........................ 35\n2.2\tEfeitos da precis\u00e3o num\u00e9rica no processamento de dados s\u00edsmicos......... 43\n2.3\tPrecis\u00e3o da modelagem da propaga\u00e7\u00e3o da onda s\u00edsmica por meio dos operadores\nde diferen\u00e7as finitas................................................... 47\n3\tDetermina\u00e7\u00e3o da precis\u00e3o num\u00e9rica m\u00ednima necess\u00e1ria \u00e0 execu\u00e7\u00e3o do algoritmo\nRTM\t49\n3.1\tFatores que influenciam na amplitude da onda s\u00edsmica.................... 50\n3.2\tEfeito da fonte s\u00edsmica utilizada ...................................... 51\n3.3\tEfeito das dimens\u00f5es e das caracter\u00edsticas das camadas em subsuperf\u00edcie ....\t52\n3.3.1\tEfeitos refrativos e reflexivos.................................. 53\n3.3.2\tA diverg\u00eancia da frente de onda.................................. 56\n3.4\tMetodologia para a predi\u00e7\u00e3o da amplitude das ondas s\u00edsmicas refletidas ....\t59\n3.4.1\tC\u00e1lculo do Raio Efetivo para modelagem bidimensional............. 59\n3.4.2\tExperimentos de valida\u00e7\u00e3o do c\u00e1lculo do raio efetivo ............ 61\n3.4.2.1\tPrimeiro Experimento.................................... 62\n3.4.2.2\tSegundo Experimento .................................... 64\n3.4.2.3\tTerceiro Experimento.................................... 66\n3.4.3\tExperimentos de valida\u00e7\u00e3o da predi\u00e7\u00e3o da atenua\u00e7\u00e3o devido \u00e0 configura-\n\u00e7\u00e3o litol\u00f3gica................................................... 68\n3.5\tDesenvolvimento e valida\u00e7\u00e3o\tda metodologia.............................. 69\n4\tEstudo de Caso\t79\n4.1\tExperimentos de valida\u00e7\u00e3o da metodologia ............................... 79\n4.1.1\tM\u00e9trica de avalia\u00e7\u00e3o da qualidade das imagens geradas............ 88\n4.1.2\tDiscuss\u00e3o dos resultados......................................... 90\n4.2\tDesenvolvimento do n\u00facleo de processamento aritm\u00e9tico................... 91\n4.3\tProjeto dos n\u00facleos de processamento baseados em aritm\u00e9tica de ponto-flutuante 92\n4.3.1\tM\u00f3dulo Multiplica 2Bij .......................................... 94\n4.3.2\tM\u00f3dulo Absi Absj ................................................ 95\n4.3.3\tM\u00f3dulo Menos Aij ................................................ 96\n4.3.4\tM\u00f3dulo Vel_Vel_Fat............................................... 96\n4.3.5\tM\u00f3dulo N\u00facleo_Soma............................................... 97\n4.3.6\tM\u00f3dulo Multiplica_V2FAT_NS...................................100\n4.3.7\tM\u00f3dulo Soma_MAij_V2FAT_NS....................................101\n4.3.8\tM\u00f3dulos Multiplica_ABS_1 e Multiplica_ABS_2..................101\n4.3.9\tM\u00f3dulo Soma_2Bij_NS..........................................101\n4.3.10\tM\u00f3dulo Normaliza e Arredonda ............................... 102\n4.4\tProjetos dos n\u00facleos de processamento baseados em aritm\u00e9tica de ponto-fixo . 103\n5\tConclus\u00f5es e trabalhos futuros\t105\n5.1\tTrabalhos futuros...................................................106\nRefer\u00eancias\t109\nAp\u00eandice\t115\nA\tImagens do Modelo 1\t117\nB Imagens do Modelo 2\t127\nC\tImagens do Modelo 3\t137\nD Imagens do Modelo 4\t149\nE Imagens do Modelo 5\t161\nF\tImagens do modelo de Marmousi\t173\nG Implementa\u00e7\u00e3o do PE-ASM\t181\nH\tImplementa\u00e7\u00e3o do algoritmo de predi\u00e7\u00e3o\t189\nI\tRevis\u00e3o sobre padr\u00f5es de representa\u00e7\u00e3o num\u00e9rica\t201\n1.1\tNota\u00e7\u00e3o de inteiros ............................................... 202\n1.2\tNota\u00e7\u00e3o de ponto-fixo ............................................. 202\n1.3\tNota\u00e7\u00e3o de ponto-flutuante..........................................203\n1.4\tO padr\u00e3o IEEE754 .................................................. 203\n1.4.1\tFormato de representa\u00e7\u00e3o dos dados ......................... 205\n1.4.2\tRepresenta\u00e7\u00e3o de valores especiais ......................... 207\n1.4.3\tArredondamento ............................................. 209\n1.4.3.1\tModos de Arredondamento.............................211\n1.4.3.2\tAlgoritmo do modo de arredondamento em dire\u00e7\u00e3o ao zero . 216\n1.4.3.3\tAlgoritmo do modo de arredondamento em dire\u00e7\u00e3o ao + e ao\n- Infinito ......................................... 216\nI.4.3.4\tAlgoritmo do modo de arredondamento em dire\u00e7\u00e3o ao mais pr\u00f3ximo ou par ................................................. 216\n1.4.4\tNormaliza\u00e7\u00e3o ....................................................218\n1.4.4.1\tAlgoritmo de Normaliza\u00e7\u00e3o...............................220\n1.4.5\tOpera\u00e7\u00f5es aritm\u00e9ticas ......................................... 221\n1.4.5.1\tOpera\u00e7\u00f5es de Soma e Subtra\u00e7\u00e3o...........................223\n1.4.5.2\tOpera\u00e7\u00e3o de Multiplica\u00e7\u00e3o ............................. 228\n1\nCom o in\u00edcio da prospec\u00e7\u00e3o de petr\u00f3leo em regi\u00f5es com estruturas geol\u00f3gicas mais complexas, tais como na camada pr\u00e9-sal1, cresceu a import\u00e2ncia de se imagear2 as camadas em subsuperf\u00edcie com a maior precis\u00e3o poss\u00edvel (SANTOS, 2012). A prospec\u00e7\u00e3o de petr\u00f3leo em tais condi\u00e7\u00f5es envolve riscos econ\u00f4micos e ambientais alt\u00edssimos (NIEMEYER, 2011; SOARES, 2012). Uma perfura\u00e7\u00e3o infrut\u00edfera ou um desastre ambiental causado pela prospec\u00e7\u00e3o em local inadequado pode representar preju\u00edzo de milh\u00f5es de d\u00f3lares. A Figura 1.1 ilustra de maneira simplificada as profundidades e a estrutura das camadas em subsuperf\u00edcie at\u00e9 a camada pr\u00e9-sal.\nPtetafoime porf\u00ediia abaixo cn camada de sa! para extrair o \u00f3leo\n5000 m\nEssas reservas\nest\u00e3o localizadas | snlm 5 mil e 7 mil------\nmetros abaixo do n\u00edvel do mar\n\u2014 PROFUNDIDADE\n2000 H!\n7000 m\n\u00d4leo es!\u00e1 sob camada de str! que pode ter a1\u00e9 \u00a3 mil metros de espessura\nFigura 1.1: Ilustra\u00e7\u00e3o das camadas em subsuperf\u00edcie at\u00e9 a camada pr\u00e9-sal(G1, 2009).\nPor esse motivo as empresas t\u00eam investido cada vez mais em novas tecnologias que permitam obter o melhor conhecimento poss\u00edvel das litologias em subsuperf\u00edcie antes de iniciar o processo de explora\u00e7\u00e3o do petr\u00f3leo (PETROBRAS, 2013). Essa medida tanto minimiza os riscos de desastres quanto otimiza o processo de perfura\u00e7\u00e3o dos po\u00e7os (SANTOS, 2012).\n1A camada pr\u00e9-sal s\u00e3o estruturas geol\u00f3gicas localizadas abaixo da camada de sal existente na crosta terrestre, a mais de 5000 metros abaixo do n\u00edvel do mar (G1, 2009).\n2Imagear neste contexto significa gerar imagens atrav\u00e9s do uso de instrumentos.\nGrande parte desse conhecimento \u00e9 adquirido por meio do imageamento s\u00edsmico3. \u00c9 o imageamento s\u00edsmico que se permite identificar a localiza\u00e7\u00e3o e o volume das reservas dos hidrocarbonetos existentes em subsuperf\u00edcie (SANTOS, 2012).\nAtualmente uma das metodologias mais empregadas na gera\u00e7\u00e3o do imageamento s\u00edsmico \u00e9 o m\u00e9todo s\u00edsmico de reflex\u00e3o (SANTOS, 2012).\nO m\u00e9todo s\u00edsmico de reflex\u00e3o utiliza princ\u00edpios de sismologia para identificar e estimar as propriedades das camadas em subsuperf\u00edcie. Todo o processo \u00e9 baseado na an\u00e1lise das reflex\u00f5es geradas pela passagem de ondas s\u00edsmicas artificiais atrav\u00e9s das interfaces das diversas camadas geol\u00f3gicas existentes. As ondas s\u00edsmicas utilizadas s\u00e3o geradas por meio de fontes controladas de energia tais como os explosivos e os Vibrosis4 para o imageamento a partir da superf\u00edcie terra e os Airguns5 para o imageamento a partir da superf\u00edcie da \u00e1gua (ROBERT E. SHERIFF, 1995). O objetivo em ambos os casos \u00e9 a gera\u00e7\u00e3o de uma onda ac\u00fastica de baixa frequ\u00eancia e alta intensidade, capaz de excitar as camadas em subsuperf\u00edcie. A Figura 1.2 traz uma ilustra\u00e7\u00e3o do uso dos Vibrosis e dos Airguns.\nA Figura 1.3 apresenta de maneira simplificada como ocorre a gera\u00e7\u00e3o das ondas s\u00edsmicas artificiais e como as ondas refletidas s\u00e3o capturadas atrav\u00e9s dos hidrofones e geofones6.\nAo chegarem \u00e0 superf\u00edcie, as ondas s\u00edsmicas refletidas nas interfaces das diversas camadas geol\u00f3gicas apresentam amplitudes proporcionais ao contraste das imped\u00e2ncias ac\u00fasticas existentes nessas interfaces (ROBERT E. SHERIFF, 1995).\n3Procedimento utilizado para imagear a subsuperf\u00edcie a partir da an\u00e1lise dos efeitos da inser\u00e7\u00e3o de pulsos s\u00edsmicos artificiais.\n4Vibrosis s\u00e3o caminh\u00f5es especiais equipados com dispositivos capazes de introduzir vibra\u00e7\u00f5es de baixa frequ\u00eancia nas camadas em subsuperf\u00edcie, servindo assim como fonte de energia s\u00edsmica controlada (DURHAM, 2007).\n5Airgun ou canh\u00f5es de ar comprimido para aplica\u00e7\u00e3o em s\u00edsmica s\u00e3o dispositivos rebocados por navios para atirar fortes rajadas de ar comprimido atrav\u00e9s da \u00e1gua a quil\u00f4metros de profundidade no mar. Estas ondas ao se chocarem com o fundo do mar refletem de volta informa\u00e7\u00f5es sobre dep\u00f3sitos de petr\u00f3leo e g\u00e1s existentes na subsuperf\u00edcie marinha (OCEANA, 2012).\n6Hidrofones e geofones s\u00e3o de transdutores eletroac\u00fasticos utilizados para converter a press\u00e3o ac\u00fastica gerada pelas ondas s\u00edsmicas em impulsos el\u00e9tricos. Os geofones s\u00e3o utilizados para o registro das ondas que chegam \u00e0 superf\u00edcie da terra e os hidrofones para o registro das ondas que chegam \u00e0 superf\u00edcie do mar.\nDessa forma, ao estudar as amplitudes e outras caracter\u00edsticas dessas ondas, \u00e9 poss\u00edvel estimar as caracter\u00edsticas litol\u00f3gicas das camadas em subsuperf\u00edcie (SANTOS, 2012).\nFigura 1.2: Na Figura \u00e0 direita um Vibrosis (DURHAM, 2007) e a esquerda um Airgun (GROBE, 2007) - Fontes controladas de energia utilizadas no imageamento s\u00edsmico\nFigura 1.3: Ilustra\u00e7\u00e3o do m\u00e9todo s\u00edsmico de reflex\u00e3o (DOMINGOS, 2003)\nO conjunto de procedimentos utilizados na convers\u00e3o das ondas refletidas em imagens, dando origem ao imageamento s\u00edsmico, \u00e9 conhecido como Migra\u00e7\u00e3o S\u00edsmica (BULC\u00e3O, 2004).\nApesar de existirem diversos algoritmos que podem ser empregados nesse processo, atualmente os mais utilizados s\u00e3o (SANTOS, 2012):\n\u25a0\to algoritmo de Pre-stack Kirchhoff Time Migration (PSTM);\n\u25a0\to algoritmo de Phase Shift Plus Interpolation (PSPI);\n\u25a0\to algoritmo de Reverse Time Migration (RTM).\nDesses tr\u00eas, o que tem apresentando melhores resultados em \u00e1reas com litologias mais complexas, tais como no pr\u00e9-sal, \u00e9 o algoritmo RTM (SANTOS, 2012).\nApesar de ter sido proposto e implementado h\u00e1 mais de tr\u00eas d\u00e9cadas (SANTOS, 2012; BAYSAL; KOSLOFF; SHERWOOD, 1983; MCMECHAN, 1983; WHITMORE, 1983), devido ao seu elevado custo computacional, o algoritmo RTM ficou por anos sem utiliza\u00e7\u00e3o mais intensa por parte da ind\u00fastria de petr\u00f3leo. Nesse per\u00edodo, a ind\u00fastria dispunha de outros m\u00e9todos e algoritmos, tal como o algoritmo PSTM, os quais permitiam o imageamento das camadas em subsuperf\u00edcie com uma qualidade aceit\u00e1vel e a um custo computacional bem mais acess\u00edvel (LIU et al., 2010).\nFoi apenas mais recentemente, em raz\u00e3o do in\u00edcio da prospec\u00e7\u00e3o em \u00e1reas com estruturas geol\u00f3gicas mais complexas, que o algoritmo RTM passou a ser mais amplamente utilizado (LIU et al., 2010).\nDe modo geral, os algoritmos de imageamento s\u00edsmico sempre foram tidos como algoritmos de alto custo computacional. Mesmo o algoritmo PSTM, que tem um custo de execu\u00e7\u00e3o por volta de 15 vezes menor que o algoritmo RTM (SANTOS, 2012), exige o uso de sistemas computacionais de alta performance para que possa ser executado com um desempenho aceit\u00e1vel (PANETTA et al., 2007). Por esse motivo, nestes \u00faltimos anos diversos trabalhos cient\u00edficos t\u00eam proposto a implementa\u00e7\u00e3o desses algoritmos em arquiteturas de processamento n\u00e3o convencionais, tais como nos General-Purpose Graphics Processing Unit (GPGPU) (LIU et al., 2010; GROSSER et al., 2011; KRUEGER et al., 2011; CLAPP; FU; LINDTJORN, 2010; ABREO et al., 2012) e nos Field Programmable Gate Array (FPGA) (NEMETH et al., 2008,?; FLYNN et al., 2008; FU et al., 2008, 2009; CLAPP; FU; LINDTJORN, 2010; PELL; CLAPP, 2007; JAMRO et al., 2008; KRUEGER et al., 2011; GROSSER et al., 2011; DIMOND; RACANI\u00e8RE; PELL, 2011; MEDEIROS et al., 2013; LINDTJORN et al., 2011; HE; LU; SUN, 2004; MENEZES et al., 2012; ABREO et al., 2012; BRAGAN\u00e7A et al., 2013; PELL, 2010).\nEm ambos os casos, o objetivo \u00e9 explorar o paralelismo intr\u00ednseco existente nessa classe de algoritmos, buscando com isso obter ganhos tanto de desempenho quanto de consumo de energia (WU; LIU, 2008) .\nOs GPGPUs s\u00e3o unidades de processamento de prop\u00f3sito geral constru\u00eddas a partir de unidades de processamento gr\u00e1fico conhecidas Graphic Processing Unit (GPU). Um GPU difere de um processador de prop\u00f3sito geral por ter uma estrutura interna especialmente desenvolvida para explorar o paralelismo intr\u00ednseco existente nos algoritmos de processamento gr\u00e1fico.\nPor esse motivo, diferentemente de um processador de prop\u00f3sito geral, mais conhecidos como Central Processing Unit (CPU), o qual tem uma \u00fanica unidade de controle e uma \u00fanica estrutura de mem\u00f3ria cache conectada a um pequeno n\u00famero de unidades l\u00f3gicas e aritm\u00e9ticas Unidade L\u00f3gica e Aritm\u00e9tica (ULA)1, os processadores gr\u00e1ficos t\u00eam dezenas de pequenas\n7A unidade l\u00f3gica e aritm\u00e9tica \u00e9 a estrutura onde s\u00e3o efetuadas todas as opera\u00e7\u00f5es l\u00f3gicas e aritm\u00e9ticas sobre as vari\u00e1veis dos programas em execu\u00e7\u00e3o. Atualmente os processadores de prop\u00f3sito geral disp\u00f5em de duas a quatro dessas unidades.\nunidades de controle, cada uma com a pr\u00f3pria mem\u00f3ria cache, conectadas a dezenas e at\u00e9 centenas de unidades l\u00f3gicas e aritm\u00e9ticas. S\u00e3o esses verdadeiros clusters8 de processamento, projetados especialmente para efetuar as opera\u00e7\u00f5es l\u00f3gicas e aritm\u00e9ticas necess\u00e1rias ao processamento gr\u00e1fico, que est\u00e3o acess\u00edveis atrav\u00e9s dos GPGPUs. A Figura 1.4 ilustra de maneira simplificada essas duas arquiteturas.\nCPU\tGPU\nControle\tULA\tULA\n\tULA\tULA\nMem\u00f3ria Cache\t\t\n] Unidade de Controle |\t| Mem\u00f3ria Cache |\t| Unidade L\u00f3gica e Aritm\u00e9tica\nFigura 1.4: Comparativo entre as arquiteturas GPU e CPU\nOs FPGAs, por sua vez, s\u00e3o circuitos integrados projetados para terem suas funcionalidades definidas em campo, ap\u00f3s o seu processo de fabrica\u00e7\u00e3o, de acordo com a necessidade da sua aplica\u00e7\u00e3o. Por esse motivo os FPGAs s\u00e3o muitas vezes referidos como unidades hardware reconfigur\u00e1vel, uma vez que podem ser configurados para se tornarem virtualmente qualquer tipo de circuito ou sistema digital (FAROOQ; MARRAKCHI; MEHREZ, 2012).\nDiferentemente dos demais circuitos integrados digitais, os quais j\u00e1 saem de f\u00e1brica com uma funcionalidade preestabelecida, a arquitetura interna dos FPGAs foi concebida de forma a permitir que eles possam ser configurados em campo para assumirem as caracter\u00edsticas e as funcionalidades que deles se esperam. A configura\u00e7\u00e3o desses componentes \u00e9 feita de maneira extremamente simples e eficaz, atrav\u00e9s da carga de um arquivo de configura\u00e7\u00e3o em uma \u00e1rea de mem\u00f3ria de programa\u00e7\u00e3o do componente. Dessa forma, um mesmo componente pode ser reconfigurado in\u00fameras vezes, podendo assim exercer mais de uma funcionalidade em um sistema computacional, de acordo com a necessidade da aplica\u00e7\u00e3o. Essa reconfigura\u00e7\u00e3o pode ser feita a qualquer momento, mesmo remotamente, inclusive depois que uma placa eletr\u00f4nica j\u00e1 estiver instalada em campo.\nA Figura 1.5 traz uma vis\u00e3o macro da arquitetura interna de um FPGA, em que se destacam os seguintes elementos:\n\u25a0 Blocos de Entrada e Sa\u00edda - estruturas que permitem configurar as caracter\u00edsticas de cada terminal de entrada e sa\u00edda, determinando deste o sentido de sua opera\u00e7\u00e3o, se ser\u00e1 entrada, sa\u00edda ou ambas, sua funcionalidade e at\u00e9 a sua tens\u00e3o de opera\u00e7\u00e3o.\n8O termo cluster, neste contexto, \u00e9 utilizado no sentido de um agrupamento coordenado de unidades de processamento semelhantes ou equivalentes que podem ser utilizadas para um fim espec\u00edfico.\n\u25a0\tBlocos L\u00f3gicos - estruturas configur\u00e1veis que podem implementar qualquer fun\u00e7\u00e3o l\u00f3gica at\u00f4mica e outras fun\u00e7\u00f5es l\u00f3gicas de menor complexidade, tanto de l\u00f3gica combinacional quanto de l\u00f3gica sequencial.\n\u25a0\tBlocos de Mem\u00f3ria RAM - elementos de mem\u00f3ria est\u00e1tica que podem ser acessados em palavras de qualquer tamanho, podendo, dessa forma, ser utilizados tanto para formar estruturas de armazenamento mais simples, tais como registradores de um \u00fanico bit, quanto estruturas de armazenamento mais complexas, tais como mem\u00f3rias cache associativas.\n\u25a0\tRede de Interconex\u00e3o - estrutura respons\u00e1vel pelo transporte dos sinais el\u00e9tricos que os blocos l\u00f3gicos trocam entre si, assim como os blocos de mem\u00f3ria. Tamb\u00e9m s\u00e3o utilizados para a conex\u00e3o dos blocos l\u00f3gicos e mem\u00f3ria com os blocos de entrada e sa\u00edda.\n\u25a0\tRede de Comuta\u00e7\u00e3o - estruturas que permitem desviar os sinais el\u00e9tricos de uma rede de interconex\u00e3o para outra, interligando assim, virtualmente, todas as estruturas internas do FPGA.\nFigura 1.5: Vis\u00e3o macro da arquitetura interna dos FPGAs\nInterconex\u00e3o \u25a0 Comuta\u00e7\u00e3o\nDesse modo, diferentemente dos demais circuitos integrados existentes no mercado, um FPGA n\u00e3o \u00e9 escolhido para um projeto por uma funcionalidade que possa oferecer, mas sim pelos recursos internos de que disp\u00f5e. Por isso, a fim de melhor destacar as caracter\u00edsticas e os recursos existentes em seus componentes, os fabricantes dos FPGAs oferecem ao mercado diversas fam\u00edlias de FPGAs, dedicadas \u00e0s mais diversas \u00e1reas de aplica\u00e7\u00e3o.\nAs fam\u00edlias dos FPGAs diferem entre si pelo tipo e pela quantidade de recursos de que disp\u00f5em. Por exemplo, algumas fam\u00edlias de FPGAs disp\u00f5em de um n\u00famero maior de elementos l\u00f3gicos; outras de mais elementos de mem\u00f3ria; outras de canais de comunica\u00e7\u00e3o ultrarr\u00e1pidos; outras ainda de maior n\u00famero de m\u00f3dulos aritm\u00e9ticos especializados.\nDiferentemente da metodologia de desenvolvimento normalmente empregada em sistemas baseados em CPUs e GPGPUs, a qual consiste basicamente na implementa\u00e7\u00e3o de algoritmos por meio do uso de linguagens de programa\u00e7\u00e3o, ou seja, desenvolvimento de software, nos sistemas baseados em FPGAs, os algoritmos devem ser descritos e implementados de tal forma que possam ser transformados em um componente de hardware.\nNos projetos para FPGAs, em vez de uma linguagem de programa\u00e7\u00e3o, normalmente se utiliza uma linguagem de descri\u00e7\u00e3o de hardware ou diretamente de um diagrama esquem\u00e1tico baseado em portas l\u00f3gicas. Em seguida, na etapa de compila\u00e7\u00e3o do algoritmo, em vez de o compilador gerar um arquivo execut\u00e1vel, este transforma a descri\u00e7\u00e3o do algoritmo em um arquivo de configura\u00e7\u00e3o para o FPGA adotado.\n\u00c9 importante destacar que a efici\u00eancia dos sistemas assim implementados estar\u00e1 diretamente ligada \u00e0 forma do mapeamento do algoritmo nos recursos dispon\u00edveis no FPGA utilizado. Por exemplo, a implementa\u00e7\u00e3o de m\u00f3dulos aritm\u00e9ticos ser\u00e1 muito mais eficiente em FPGAs que j\u00e1 disp\u00f5em de operadores aritm\u00e9ticos como um recurso interno do que naqueles em que esses operadores tenham de ser implementados mediante o uso de portas l\u00f3gicas.\nPor outro lado, quanto maior a quantidade de recursos dispon\u00edveis em um determinado FPGA, maior ser\u00e1 o seu custo. Ou seja, a escolha do FPGA para um determinado projeto ser\u00e1 fun\u00e7\u00e3o do algoritmo a ser implementado, do desempenho que se espera dele e do montante de recursos financeiros dispon\u00edveis para a implementa\u00e7\u00e3o do projeto.\nMais especificamente com rela\u00e7\u00e3o ao uso dos FPGAs em processamento de dados s\u00edsmicos, diversos trabalhos publicados nestes \u00faltimos anos t\u00eam buscado destacar as vantagens, tanto do ponto de vista de desempenho quanto do consumo de energia, da ado\u00e7\u00e3o de um padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico diferente do padr\u00e3o de ponto-flutuante conforme definido no padr\u00e3o IEEE754 (FU et al., 2008, 2009; GROSSER et al., 2011; GOVINDU et al., 2004; ABREO et al., 2012; BARROS et al., 2011; BRAGAN\u00e7A et al., 2013; MEDEIROS et al., 2013).\nA prefer\u00eancia pela ado\u00e7\u00e3o de um padr\u00e3o num\u00e9rico n\u00e3o convencional em projetos com FPGAs deve-se ao fato de a grande maioria dos FPGAs, atualmente comercializados, n\u00e3o dispor nativamente de unidades aritm\u00e9ticas de ponto-flutuante, o que exige que essas unidades sejam implementadas diretamente em um por meio de uma Hardware Description Language (HDL) ou a partir de bibliotecas fornecidas pelos fabricantes dos FPGA, ou ainda por empresas especializadas. No entanto, pela complexidade das opera\u00e7\u00f5es de ponto-flutuante, a utiliza\u00e7\u00e3o desses m\u00f3dulos pode ter um impacto muito negativo no desempenho do sistema.\nPor outro lado, alguns trabalhos indicam tamb\u00e9m que, tratando-se da modelagem s\u00edsmica, uma mudan\u00e7a no padr\u00e3o de representa\u00e7\u00e3o num\u00e9rica pode ter um impacto na qualidade das imagens geradas (BARROS et al., 2011; FU et al., 2009, 2008). Muitas vezes, uma diferen\u00e7a de\nFigura 1.6: Resultado do processamento s\u00edsmico utilizando o algoritmo PSTM em diversas precis\u00f5es num\u00e9ricas (FU et al., 2009)\nReduced precision seismic image \u201cTrue\u201d image: single-precision floating-point\num ou dois bits na precis\u00e3o num\u00e9rica adotada \u00e9 o suficiente para tornar os resultados obtidos impr\u00f3prios para o uso a que se destinam.\nNa Figura 1.6, temos os resultados de experimentos relatados em (FU et al., 2009) e que demonstram o quanto o n\u00facleo de processamento aritm\u00e9tico do algoritmo PSTM \u00e9 sens\u00edvel \u00e0 precis\u00e3o num\u00e9rica utilizada em sua implementa\u00e7\u00e3o.\nComo pode-se observar pelo gr\u00e1fico apresentado nessa figura, a qualidade das imagens geradas com a aplica\u00e7\u00e3o do algoritmo PSTM est\u00e1 diretamente ligada \u00e0 precis\u00e3o num\u00e9rica utilizada na implementa\u00e7\u00e3o da opera\u00e7\u00e3o de raiz quadrada (SQRT) existente em seu n\u00facleo de processamento aritm\u00e9tico. Verifica-se por esse gr\u00e1fico que a qualidade das imagens decai bruscamente quando esta opera\u00e7\u00e3o \u00e9 implementada com menos que 10 bits de precis\u00e3o. Por outro lado, verifica-se tamb\u00e9m que n\u00e3o ocorrem melhoras significativas quando \u00e9 utilizado mais que 10 bits de precis\u00e3o. Dessa forma, os autores de (FU et al., 2009) concluem que o ideal \u00e9 que esta opera\u00e7\u00e3o seja efetuada com exatos 10 bits de precis\u00e3o.\nEm (BARROS et al., 2011), s\u00e3o apresentados os primeiros resultados obtidos ainda no in\u00edcio do trabalho que resultou nesta tese, no qual foram avaliados os efeitos da precis\u00e3o num\u00e9rica empregada na implementa\u00e7\u00e3o do algoritmo RTM. A Figura 1.7 apresenta os resultados\nali obtidos. Como se pode observar pelo gr\u00e1fico apresentado nessa figura, \u00e0 semelhan\u00e7a do algoritmo PSTM, o algoritmo RTM tamb\u00e9m apresenta uma grande sensibilidade a varia\u00e7\u00f5es do padr\u00e3o de representa\u00e7\u00e3o num\u00e9rica adotado em sua implementa\u00e7\u00e3o.\n\u00c0 semelhan\u00e7a do experimento conduzido em (FU et al., 2009), nesse trabalho tamb\u00e9m foi conduzido um experimento para averiguar a qualidade do imageamento s\u00edsmico gerado pelo algoritmo RTM para um modelo geol\u00f3gico de refer\u00eancia, o modelo de Marmousi9, (MARTIN; WILEY; MARFURT, 2006) em diversas precis\u00f5es num\u00e9ricas. A Figura 1.7 apresenta os resultados obtidos nesse experimento. O gr\u00e1fico apresentado nessa figura registra o grau de semelhan\u00e7a medido entre as imagens geradas pela aplica\u00e7\u00e3o do algoritmo RTM em diversas precis\u00f5es e uma imagem de refer\u00eancia gerada com o processamento sendo efetuado devido \u00e0 n\u00e3o precis\u00e3o num\u00e9rica adotada. O grau de semelhan\u00e7a foi avaliado a partir do Universal Quality Index (UQI) (WANG; BOVIK, 2002). O UQI \u00e9 uma m\u00e9trica que procura avaliar o grau de semelhan\u00e7a entre duas imagens do ponto de vista de um observador humano. Por esse motivo, o grau de semelhan\u00e7a leva em conta n\u00e3o apenas os artefatos presentes nas imagens, mas tamb\u00e9m o seu brilho e contraste. Como pode-se observar pelo gr\u00e1fico apresentado, diferentemente do que ocorreu com os resultados relatados em (FU et al., 2009), no algoritmo RTM, o grau de semelhan\u00e7a entre as imagens varia mais suavemente, de forma quase linearmente proporcional \u00e0 precis\u00e3o num\u00e9rica adotada.\nConforme se pode observar por esses dois exemplos, a mudan\u00e7a do padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico na implementa\u00e7\u00e3o de um algoritmo para o imageamento s\u00edsmico \u00e9 algo que exige muito cuidado e aten\u00e7\u00e3o. Deve ser levado em conta que quest\u00f5es como a estabilidade dos resultados, a converg\u00eancia do algoritmo e o grau de incerteza dos resultados obtidos est\u00e3o diretamente ligados ao padr\u00e3o num\u00e9rico adotado.\nApesar da sua import\u00e2ncia, esse \u00e9 um tema pouco abordado tanto nos cursos de gradua\u00e7\u00e3o quanto nas pesquisas cient\u00edficas em n\u00edvel de p\u00f3s-gradua\u00e7\u00e3o. Isso porque a representa\u00e7\u00e3o dos n\u00fameros reais em praticamente todos os sistemas computacionais est\u00e1 baseada em um mesmo padr\u00e3o num\u00e9rico, o padr\u00e3o IEEE 754 (P754, 1985). Esse padr\u00e3o estabelece como devem ser representados e operados os n\u00fameros reais em sistemas computacionais. Em raz\u00e3o da forma como os n\u00fameros s\u00e3o representados nesse padr\u00e3o, ele ficou conhecido como padr\u00e3o de n\u00fameros em ponto-flutuante.\nA ado\u00e7\u00e3o do padr\u00e3o IEEE 754 representou um grande avan\u00e7o para a computa\u00e7\u00e3o cient\u00edfica em geral (SEVERANCE, 1998). Foi s\u00f3 a partir do seu estabelecimento que os desenvolvedores e cientistas mais ligados \u00e0 computa\u00e7\u00e3o cient\u00edfica puderam deixar de lado as quest\u00f5es mais ligadas \u00e0 representa\u00e7\u00e3o dos dados e passar a concentrar seus esfor\u00e7os apenas no desenvolvimento e na implementa\u00e7\u00e3o dos algoritmos. Atualmente, a sua utiliza\u00e7\u00e3o est\u00e1 de tal forma difundida entre os profissionais da \u00e1rea que a grande maioria desconhece completamente tanto os detalhes de sua implementa\u00e7\u00e3o quanto as suas limita\u00e7\u00f5es. Eles simplesmente o utilizam como\n9O modelo de Marmousi \u00e9 um modelo geol\u00f3gico sint\u00e9tico muito utilizado como modelo de refer\u00eancia para testes de valida\u00e7\u00e3o para o imageamento s\u00edsmico.\nFigura 1.7: Primeiros resultados publicados deste trabalho (BARROS et al., 2011) referentes ao efeito da precis\u00e3o num\u00e9rica no processamento s\u00edsmico utilizando o algoritmo RTM.\na representa\u00e7\u00e3o dos n\u00fameros reais em sistemas computacionais (GOLDBERG, 1991).\nDe fato, pela forma como os dados s\u00e3o representados, esse padr\u00e3o permite trabalhar com a falsa ideia de que \u00e9 poss\u00edvel representar o cont\u00ednuo, o infinito n\u00e3o enumer\u00e1vel, o qual \u00e9 a pr\u00f3pria ess\u00eancia dos n\u00fameros reais, nos sistemas computacionais. O que na verdade \u00e9 imposs\u00edvel (GOLDBERG, 1991).\nNo padr\u00e3o de ponto-flutuante, os valores s\u00e3o representados por conven\u00e7\u00e3o, atrav\u00e9s de uma estrutura muito semelhante \u00e0 adotada na representa\u00e7\u00e3o de n\u00fameros em nota\u00e7\u00e3o cient\u00edfica, a qual \u00e9 formada por tr\u00eas campos distintos, denominados:\n\u25a0\tSinal: representa o sinal alg\u00e9brico do valor representado.\n\u25a0\tExpoente: est\u00e1 associado \u00e0 magnitude do valor representado.\n\u25a0\tSignificando: representa o conjunto de d\u00edgitos significativos do n\u00famero representado.\nEsses tr\u00eas campos s\u00e3o armazenados na forma de uma \u00fanica palavra bin\u00e1ria, a qual \u00e9 reconhecida como um valor num\u00e9rico no padr\u00e3o de ponto-flutuante. O valor num\u00e9rico representado por essa palavra bin\u00e1ria \u00e9 dado pela seguinte equa\u00e7\u00e3o:\nV = (-1)8 * S* 2e\nem que, V \u00e9 o valor num\u00e9rico representado, 8 representa o valor do campo sinal, S o conte\u00fado do campo significando e e o valor representado no campo expoente.\nAinda \u00e0 semelhan\u00e7a da nota\u00e7\u00e3o cient\u00edfica, no padr\u00e3o de ponto-flutuante, o campo significando tamb\u00e9m \u00e9 representado de maneira normalizada, ou seja, com apenas um d\u00edgito na sua parte inteira, sendo este diferente de zero.\nO padr\u00e3o IEEE 754 prev\u00ea ainda que valores muito pequenos, que n\u00e3o possam ser representados de maneira normalizada, sejam representados fora desse padr\u00e3o, o que \u00e9 conhecido como forma desnormalizada ou apenas n\u00fameros denormais. Nesse caso, a fim de indicar essa discrep\u00e2ncia com o padr\u00e3o de representa\u00e7\u00e3o, atribui-se um valor diferenciado para o campo expoente.\nOutro detalhe importante da representa\u00e7\u00e3o no padr\u00e3o de ponto-flutuante \u00e9 o processo de mapeamento de cada um dos infinitos valores reais existentes em um dos valores por ele represent\u00e1veis. Esse processo de mapeamento \u00e9 denominado de arredondamento. \u00c9 o processo de arredondamento que permite que todo e qualquer valor real, mesmo os n\u00fameros irracionais, possam ser representados. Existem quatro modos de arredondamento previstos no padr\u00e3o IEEE 754, denominados de arredondamento para o mais pr\u00f3ximo ou par, o arredondamento para mais infinito, o arredondamento para menos infinito e o arredondamento para zero.\n\u00c9 a intera\u00e7\u00e3o do padr\u00e3o de representa\u00e7\u00e3o normalizado aliado \u00e0 flutua\u00e7\u00e3o do ponto decimal, devido \u00e0 intera\u00e7\u00e3o do campo significando com o expoente e, por fim, o processo de\narredondamento, que permitem criar a falsa ideia de que \u00e9 poss\u00edvel representar todo o conjunto dos n\u00fameros reais atrav\u00e9s dos sistemas computacionais. O Ap\u00eandice I traz um resumo das principais caracter\u00edsticas e do princ\u00edpio de funcionamento do padr\u00e3o de ponto-flutuante conforme estabelecido pela norma IEEE 754.\nToda essa flexibilidade tem, entretanto, um alto custo de implementa\u00e7\u00e3o em hardware.\nUma vez que no padr\u00e3o de ponto-flutuante os dados passam a ser representados por conven\u00e7\u00e3o e n\u00e3o mais por meio da nota\u00e7\u00e3o posicional, \u00e9 necess\u00e1rio que exista um suporte em hardware especialmente desenvolvido para operar nesse padr\u00e3o. Qualquer opera\u00e7\u00e3o, por mais simples que seja, envolvendo dados no padr\u00e3o de ponto-flutuante, exige a execu\u00e7\u00e3o de diversas etapas de pr\u00e9 e p\u00f3s-processamento. A Figura 1.8 traz de maneira simplificada todas essas etapas. O Ap\u00eandice I traz a opera\u00e7\u00e3o dessas etapas de maneira mais detalhada.\nPrimeiramente \u00e9 necess\u00e1rio que se fa\u00e7a o desempacotamento do dado, ou seja, \u00e9 necess\u00e1rio que o valor armazenado seja recuperado.\nEm seguida \u00e9 necess\u00e1rio que se verifique se o valor armazenado \u00e9 de fato um n\u00famero ou se \u00e9 uma codifica\u00e7\u00e3o de exce\u00e7\u00e3o: Infinito, Not a Number (NaN) ou um n\u00famero denormal.\nRecuperado o valor armazenado, pode-se ent\u00e3o efetuar a opera\u00e7\u00e3o propriamente dita. Cada opera\u00e7\u00e3o tem o seu pr\u00f3prio fluxo de execu\u00e7\u00e3o. O Ap\u00eandice I traz alguns detalhes de implementa\u00e7\u00e3o das opera\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o.\nFeita a opera\u00e7\u00e3o, o resultado obtido precisa ser arredondado e normalizado. O processo de arredondamento mapeia o valor obtido no valor represent\u00e1vel mais pr\u00f3ximo no formato de ponto-flutuante adotado. O processo de normaliza\u00e7\u00e3o ajusta o significando para o modo normalizado, compensando essa opera\u00e7\u00e3o pela atribui\u00e7\u00e3o do valor do campo expoente.\nPor fim, o resultado obtido depois do arredondamento e da normaliza\u00e7\u00e3o \u00e9 verificado para identificar a ocorr\u00eancia de exce\u00e7\u00f5es, tais como Infinito ou denormal. Caso tenha ocorrido alguma exce\u00e7\u00e3o, os valores atribu\u00eddo aos campos expoente e fra\u00e7\u00e3o do significando s\u00e3o ajustados para sinalizar a exce\u00e7\u00e3o identificada.\nFigura 1.8: Etapas de processamento do ponto-flutuante.\nPor esse motivo, a fim de permitir a implementa\u00e7\u00e3o do tipo de dado de ponto-flutuante nas diversas linguagens de programa\u00e7\u00e3o existentes, atualmente todos os processadores, incluindo os processadores de uso mais espec\u00edfico como os GPGPUs, os Digital Signal Processing (DSP) - e at\u00e9 mesmo os de menor porte como muitos microcontroladores, t\u00eam internamente uma unidade de processamento aritm\u00e9tico de ponto-flutuante, tamb\u00e9m conhecida como Floating Point Unit (FPU), que \u00e9 respons\u00e1vel pelas opera\u00e7\u00f5es em ponto-flutuante.\nVale salientar que o padr\u00e3o IEEE 754 n\u00e3o \u00e9 a \u00fanica forma de representar os n\u00fameros reais em sistemas computacionais. Existem ainda in\u00fameros outros padr\u00f5es de representa\u00e7\u00e3o num\u00e9ricos, tais como o padr\u00e3o de n\u00fameros residuais, o padr\u00e3o logaritmo e o padr\u00e3o de ponto-fixo. Cada um com vantagens e desvantagens que os tornam especialmente indicados para determinados tipos de aplica\u00e7\u00f5es (FU, 2009).\nMais especificamente, tratando-se do processamento de dados s\u00edsmicos atrav\u00e9s dos FPGAs, depois de uma pesquisa exaustiva nos trabalhos cient\u00edficos publicados nos \u00faltimos dez anos, realizada durante a fase investigativa deste trabalho, p\u00f4de-se constatar uma n\u00edtida prefer\u00eancia por parte dos diversos autores pela ado\u00e7\u00e3o do padr\u00e3o de ponto-fixo em detrimento de todos os demais padr\u00f5es.\nIsso se explica pelo fato de ser esse o padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico com o menor custo de implementa\u00e7\u00e3o em hardware. Todos os FPGAs t\u00eam internamente certo n\u00famero de operadores aritm\u00e9ticos, o que permite o mapeamento dos algoritmos com m\u00f3dulos aritm\u00e9ticos diretamente em hardware.\nTodos os demais padr\u00f5es, incluindo o padr\u00e3o de ponto-flutuante, exigem que m\u00f3dulos de hardware espec\u00edficos sejam implementados, o que tem que ser feito lan\u00e7ando m\u00e3o dos outros\nrecursos de l\u00f3gica dispon\u00edveis nos FPGAs, o que muitas vezes limita o n\u00famero de m\u00f3dulos que podem ser implementados, al\u00e9m de reduzir a sua frequ\u00eancia de opera\u00e7\u00e3o. Com isso, o desempenho do sistema em sua totalidade pode ser comprometido.\nUma vez que o desempenho alcan\u00e7ado pelos sistemas baseados em FPGA est\u00e1 diretamente ligado ao grau de paralelismo e \u00e0 frequ\u00eancia de trabalho dos m\u00f3dulos de hardware implementados, e considerando ainda que esses dois par\u00e2metros dependem diretamente da quantidade de recursos do FPGA que esses m\u00f3dulos consomem para serem implementados, a op\u00e7\u00e3o por um padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico mais simples, como o padr\u00e3o de ponto-fixo, pode significar um ganho de desempenho consider\u00e1vel (GUO et al., 2004).\nEntretanto, se n\u00e3o for feita com muita cautela, a mudan\u00e7a do padr\u00e3o de representa\u00e7\u00e3o de ponto-flutuante para o padr\u00e3o de ponto-fixo pode trazer s\u00e9rias implica\u00e7\u00f5es para a qualidade dos resultados obtidos.\nDiferentemente do padr\u00e3o de ponto-flutuante, no qual o limite do erro de representa\u00e7\u00e3o percentual independe do valor representado 10, no padr\u00e3o de ponto-fixo, esse erro n\u00e3o tem um limite definido, estando, assim, diretamente ligado ao valor a ser representado11. A Figura 1.9 traz uma compara\u00e7\u00e3o entre as representa\u00e7\u00f5es nos padr\u00f5es de ponto-flutuante e de ponto-fixo, destacando o efeito da mudan\u00e7a autom\u00e1tica de escala presente no padr\u00e3o de ponto-flutuante no n\u00edvel de erro de representa\u00e7\u00e3o.\nEm algoritmos de processamento de sinais, tal como ocorre no processamento de dados s\u00edsmicos, essa varia\u00e7\u00e3o no n\u00edvel de erro de representa\u00e7\u00e3o, com r\n10O erro percentual de representa\u00e7\u00e3o no padr\u00e3o de ponto-flutuante \u00e9 sempre menor que 2-n, onde n \u00e9 a quantidade de bits da fra\u00e7\u00e3o do significando.\n11O erro de representa\u00e7\u00e3o percentual para um padr\u00e3o de ponto-fixo com n bits de precis\u00e3o, ou seja, com n bits reservados \u00e0 representa\u00e7\u00e3o da parte fracion\u00e1ria, ser\u00e1 igual a , em que x \u00e9 o valor representado.\nPonto-Fixo\nEscala Constante\nErro de representa\u00e7\u00e3o vari\u00e1vel\nExpoente =-4\nJ Lrepresenta\u00e7\u00e3o constante\nMudan\u00e7a autom\u00e1tica de escala com o intervalo de valores representados\nErro de\nPonto-Flutuante\n1\nExpoente =1\nExpoente =-2\nFigura 1.9: Compara\u00e7\u00e3o entre as representa\u00e7\u00f5es em ponto-flutuante (A) e em ponto-fixo (B). Observa-se em (A) o efeito da mudan\u00e7a autom\u00e1tica do expoente devido ao processo de normaliza\u00e7\u00e3o e \u00e0 consequente mudan\u00e7a autom\u00e1tica de escala. Em (B), verifica-se a perda de precis\u00e3o \u00e0 medida que a magnitude do valor representado diminui.\n2\nTrabalhos Relacionados\nNeste cap\u00edtulo \u00e9 apresentada uma revis\u00e3o dos principais trabalhos cient\u00edficos relacionados com o tema da defini\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria ao processamento de dados s\u00edsmicos em FPGAs.\nEsses trabalhos s\u00e3o agrupados em tr\u00eas \u00e1reas distintas: Processamento de dados s\u00edsmicos utilizando FPGAs, onde s\u00e3o apresentadas implementa\u00e7\u00f5es de plataformas de processamento de dados s\u00edsmicos baseados em FPGA; efeitos da precis\u00e3o num\u00e9rica no processamento de dados s\u00edsmicos, onde s\u00e3o discutidos trabalhos que tratam diretamente desta tem\u00e1tica; e precis\u00e3o da modelagem de propaga\u00e7\u00e3o da onda s\u00edsmica por meio dos operadores de diferen\u00e7as finitas, onde s\u00e3o apresentados trabalhos que avaliam qu\u00e3o fi\u00e9is ao modelo f\u00edsico real s\u00e3o as implementa\u00e7\u00f5es de algoritmos de processamento s\u00edsmico por meio de operadores de diferen\u00e7as finitas.\n2.1\tProcessamento de dados s\u00edsmicos utilizando FPGAs\nO uso de coprocessadores de aplica\u00e7\u00e3o espec\u00edfica baseados nos FPGAs n\u00e3o \u00e9 algo novo em computa\u00e7\u00e3o de alto desempenho. Diversos trabalhos cient\u00edficos destacam a sua utiliza\u00e7\u00e3o em \u00e1reas t\u00e3o distintas na computa\u00e7\u00e3o cient\u00edfica quanto bioinform\u00e1tica (YAMAGUCHI et al., 2013; DANDASS et al., 2008; CHEN et al., 2013), f\u00edsica (FROHLICH et al., 2002; LIU et al., 2008), an\u00e1lise financeira (SCHRYVER et al., 2011), microscopia eletr\u00f4nica (GRULL et al., 2011) e processamento de dados s\u00edsmicos (MENCER; MORF; FLYNN, 1998; GOVINDU et al., 2004; HE; LU; SUN, 2004; HERBORDT et al., 2007; BARROS et al., 2008).\nTendo sido projetados inicialmente com o objetivo de servir como laborat\u00f3rio de proto-tipa\u00e7\u00e3o para circuitos l\u00f3gicos digitais, com o avan\u00e7o da tecnologia, os FPGAs passaram a ser considerados uma alternativa vi\u00e1vel para projetos em \u00e1reas de aplica\u00e7\u00e3o at\u00e9 ent\u00e3o dominadas pelos Circuito Integrado (CI) tipo ASIC1, tais como o desenvolvimento de coprocessadores de aplica\u00e7\u00e3o espec\u00edfica.\n1 Um Application Specific Integrated Circuit (ASIC) \u00e9 um circuito integrado constru\u00eddo para executar uma tarefa espec\u00edfica tal como controlar uma interface de comunica\u00e7\u00e3o ou garantir a seguran\u00e7a de acesso a dados de um sistema.\nEm tais aplica\u00e7\u00f5es, de modo a permitir o uso mais racional dos recursos dispon\u00edveis no FPGA, \u00e9 comum substituir o padr\u00e3o IEEE 754 (P754,1985), na representa\u00e7\u00e3o dos n\u00fameros reais, por outro de menor precis\u00e3o, tal como o padr\u00e3o de ponto-fixo.\nTal estrat\u00e9gia \u00e9 importante porque, para muitas dessas aplica\u00e7\u00f5es, a ado\u00e7\u00e3o de um padr\u00e3o de representa\u00e7\u00e3o de menor precis\u00e3o ter\u00e1 pouco ou nenhum efeito sobre a qualidade dos resultados obtidos e, em contrapartida, permitir\u00e1 que as opera\u00e7\u00f5es aritm\u00e9ticas possam ser implementadas de maneira mais simples e consequentemente com menor custo em hardware (FU, 2009).\nUm ponto a destacar, entretanto, \u00e9 que qualquer mudan\u00e7a no padr\u00e3o de representa\u00e7\u00e3o num\u00e9rica deve passar obrigatoriamente por um estudo minucioso dos efeitos que essa mudan\u00e7a poder\u00e1 ter no algoritmo a ser implementado e no conjunto de dados a ser processado (FU, 2009).\nEm (HE; LU; SUN, 2004) \u00e9 apresentada a primeira plataforma de processamento baseada em FPGAs, dedicada ao processamento de dados s\u00edsmicos. Essa plataforma foi desenvolvida com o objetivo de acelerar a execu\u00e7\u00e3o do algoritmo Pre-Stack KirchhoffTime Migration (PSTM). Os resultados obtidos apontaram um desempenho 15,6 vezes maior que a vers\u00e3o em software, mesmo executado a uma frequ\u00eancia de opera\u00e7\u00e3o 48 vezes menor. A vers\u00e3o implementada em FPGA executou a 50 MHz, enquanto a vers\u00e3o em software foi executada em uma esta\u00e7\u00e3o de trabalho Pentium 4 de 2,4GHz. Vale salientar que na \u00e9poca da implementa\u00e7\u00e3o dessa plataforma o processador Pentium 4 era considerado de primeira linha para aplica\u00e7\u00f5es em computadores de mesa.\nO algoritmo PSTM implementado em (HE; LU; SUN, 2004) baseia-se no c\u00e1lculo do tempo de tr\u00e2nsito2 das ondas refletidas pelas diversas camadas geol\u00f3gicas em subsuperf\u00edcie. Calcula-se esse tempo conforme o exemplo apresentado na Figura 2.1, por meio da aplica\u00e7\u00e3o da seguinte equa\u00e7\u00e3o:\nR\n+ \u2014\nem que TSR representa o tempo de propaga\u00e7\u00e3o do pulso s\u00edsmico desde a sua inser\u00e7\u00e3o at\u00e9 a captura das ondas refletidas, TS representa o tempo de propaga\u00e7\u00e3o entre o ponto de inser\u00e7\u00e3o e o ponto de reflex\u00e3o, TR o tempo de propaga\u00e7\u00e3o entre o ponto de reflex\u00e3o e os receptores s\u00edsmicos, t a profundidade estimada do ponto de reflex\u00e3o e VT a velocidade RMS 3 entre o ponto de inser\u00e7\u00e3o e o ponto de reflex\u00e3o.\nA fim de atingir melhor desempenho em hardware, a plataforma apresentada em (HE; LU; SUN, 2004) contou com uma vers\u00e3o otimizada da Equa\u00e7\u00e3o 2.1, na qual as opera\u00e7\u00f5es de raiz quadrada foram implementadas em ponto-fixo utilizando m\u00f3dulos Coordinate Rotation Digital Computer (CORDIC)4 com pipeline5, segundo o modelo proposto em (ANDRAKA, 1998).\n2O tempo de tr\u00e2nsito corresponde ao intervalo de tempo medido entre o momento da inser\u00e7\u00e3o do pulso s\u00edsmico at\u00e9 a chegada das ondas refletidas \u00e0 superf\u00edcie.\n3 Velocidade RMS \u00e9 a velocidade m\u00e9dia quadr\u00e1tica de propaga\u00e7\u00e3o da onda ac\u00fastica no meio.\n4CORDIC \u00e9 uma classe de algoritmos simples e eficiente para calcular fun\u00e7\u00f5es hiperb\u00f3licas e trigonom\u00e9tricas\n5Nesse contexto pipeline significa uma estrutura de processamento em que o algoritmo \u00e9 dividido em v\u00e1rias partes menores que s\u00e3o executadas em paralelo. Dessa forma \u00e9 poss\u00edvel, ao mesmo tempo, aumentar a frequ\u00eancia\nFigura 2.1: Esquema simplificado do processo de medi\u00e7\u00e3o do tempo de tr\u00e2nsito do pulso s\u00edsmico no algoritmo PSTM (HE; LU; SUN, 2004)\nDiversos autores apresentam implementa\u00e7\u00f5es do algoritmo Reverse Time Migration (RTM) em FPGA(HE; ZHAO; LU, 2005a; NEMETH et al., 2008; GROSSER et al., 2011; CLAPP; FU; LINDTJORN, 2010; LINDTJORN et al., 2011; KRUEGER et al., 2011; BRAGAN\u00e7A et al., 2013; ARAYA-POLO et al., 2011; HE; ZHAO; LU, 2005b).\nO algoritmo RTM difere do algoritmo PSTM por se basear n\u00e3o apenas no c\u00e1lculo dos tempos de tr\u00e2nsito das ondas refletidas, mas sim em uma solu\u00e7\u00e3o completa da equa\u00e7\u00e3o que rege a propaga\u00e7\u00e3o da onda s\u00edsmica.\nA propaga\u00e7\u00e3o da onda s\u00edsmica \u00e9 regida pela seguinte equa\u00e7\u00e3o,\nd 2P d 2P d2P _\t1 d 2P\nd x2 + d y2 + d z2 v2 (x, y, z) d t2\nna qual d2P representa a varia\u00e7\u00e3o de press\u00e3o no meio em raz\u00e3o da passagem da onda, x, y, z representam as coordenadas do espa\u00e7o, v(x,y, z) representa a velocidade de propaga\u00e7\u00e3o da onda no ponto de coordenadas x, y, z e t representa o tempo de propaga\u00e7\u00e3o da onda, medido em rela\u00e7\u00e3o ao momento de sua inser\u00e7\u00e3o no meio.\nPor ser a Equa\u00e7\u00e3o 2.2 uma equa\u00e7\u00e3o diferencial sem resolu\u00e7\u00e3o alg\u00e9brica para sistemas com grandes varia\u00e7\u00f5es de velocidade, o algoritmo RTM baseia-se n\u00e3o em uma aplica\u00e7\u00e3o direta dessa equa\u00e7\u00e3o, mas sim em uma resolu\u00e7\u00e3o constru\u00edda por meio da aplica\u00e7\u00e3o de um operador de diferen\u00e7as finitas, o qual pode ser descrito para problemas de duas dimens\u00f5es na seguinte equa\u00e7\u00e3o:\nde trabalho do hardware e o re\u00faso de partes do hardware que ficariam sem uso enquanto o algoritmo n\u00e3o fosse conclu\u00eddo.\nCi,j =absi x absj x\t2.3\n(2Bj,j + absi x absj x Vel-j x fat x (16 x (Bi,j+i + Bi,j-1 + Bi+1,j + Bi\u20141,j)\n\u2014\t1 x (Bi,j+2 + Bi,j\u20142 + Bi+2,j + Bi\u20142,j)\n-\t60 x B, j\n) - Ai,\u00ed\n)\nem que A,B e C representam respectivamente o estado anterior, o atual e o futuro do meio por onde a onda se propaga, ou seja, modelam a propaga\u00e7\u00e3o da onda ac\u00fastica tanto no espa\u00e7o quanto no tempo, Veli,j representa a velocidade de propaga\u00e7\u00e3o do pulso s\u00edsmico no ponto i, j, o qual \u00e9 uma caracter\u00edstica das camadas geol\u00f3gicas que est\u00e3o sendo modeladas, e fat \u00e9 um fator constante, calculado a fim de garantir a estabilidade e a converg\u00eancia do operador de diferen\u00e7as finitas.\nDessa forma, mais do que identificar a dist\u00e2ncia dos refletores que deram origem \u00e0s ondas refletidas, o algoritmo RTM permite confirmar outras informa\u00e7\u00f5es igualmente valiosas, tais como a amplitude e a fase das ondas durante a sua propaga\u00e7\u00e3o.\nPor esse motivo, o algoritmo RTM permite obter resultados de melhor qualidade do que o algoritmo PSTM. O algoritmo RTM \u00e9 capaz de gerar o imageamento em \u00e1reas com litologias mais complexas, \u00e1reas para as quais o algoritmo PSTM n\u00e3o \u00e9 aplic\u00e1vel (SANTOS, 2012).\nA Figura 2.3 apresenta de forma simplificada o princ\u00edpio de funcionamento do algoritmo RTM, o qual pode ser resumido como executado em tr\u00eas etapas.\nA primeira etapa consiste na gera\u00e7\u00e3o e captura de um sismograma6 gerado em campo por meio do uso de fontes s\u00edsmicas artificiais. Esse sismograma cont\u00e9m uma assinatura descritiva da subsuperf\u00edcie da regi\u00e3o de interesse, registrada pelas ondas refletidas durante a passagem do pulso s\u00edsmico - Figura 2.3(1).\nA segunda etapa realiza-se em laborat\u00f3rio, e tem por objetivo simular o processo realizado em campo na primeira etapa do algoritmo. Essa simula\u00e7\u00e3o, que tem como base o modelo geol\u00f3gico prov\u00e1vel da regi\u00e3o de interesse, busca modelar a propaga\u00e7\u00e3o do pulso s\u00edsmico no tempo e no espa\u00e7o durante toda a sua trajet\u00f3ria, desde o ponto de inser\u00e7\u00e3o at\u00e9 cobrir toda a \u00e1rea a ser imageada.\nO modelo geol\u00f3gico prov\u00e1vel \u00e9 representado por meio de uma matriz num\u00e9rica com as mesmas dimens\u00f5es da regi\u00e3o a ser imageada. Cada elemento dessa matriz representa a velocidade de propaga\u00e7\u00e3o da onda ac\u00fastica em um ponto espec\u00edfico do meio. Neste trabalho esta\n6Um sismograma \u00e9 o registro da atividade s\u00edsmica ocorrida em uma determinada regi\u00e3o. Em nosso contexto, um sismograma \u00e9 um arquivo com o registro dos sinais captados pelos receptores s\u00edsmicos.\nmatriz \u00e9 denominada de Matriz de Velocidades do meio.\nDurante a simula\u00e7\u00e3o, a fonte s\u00edsmica \u00e9 modelada numericamente atrav\u00e9s da curva gerada pela aplica\u00e7\u00e3o da segunda derivada da fun\u00e7\u00e3o Gausiana sobre um valor constante igual a 1. Os valores assim obtidos s\u00e3o aplicados e propagados no meio pela aplica\u00e7\u00e3o da Equa\u00e7\u00e3o 2.3 em um conjunto de matrizes denominadas de Matrizes do Campo de Press\u00e3o.\nUtilizam-se tr\u00eas matrizes: uma para modelar a press\u00e3o ac\u00fastica exercida pelo pulso s\u00edsmico no tempo atual; outra para o tempo anterior e a terceira para o tempo futuro.\nA cada etapa da simula\u00e7\u00e3o, essas matrizes se sobrep\u00f5em umas as outras: a matriz do tempo futuro passa a ser a matriz do tempo presente e a matriz do tempo presente, a matriz do tempo anterior. A Figura 2.2 apresenta a din\u00e2mica do uso dessas tr\u00eas matrizes.\nComo resultado dessa segunda etapa, gera-se um arquivo com os tempos de tr\u00e2nsito anotados das ondas refletidas em cada ponto de reflex\u00e3o at\u00e9 a superf\u00edcie - Figura 2.3(2).\nA terceira etapa do algoritmo tamb\u00e9m se realiza em laborat\u00f3rio e consiste em uma segunda simula\u00e7\u00e3o do processo realizado em campo. Nessa segunda simula\u00e7\u00e3o substitui-se o pulso s\u00edsmico artificial pela depropaga\u00e7\u00e3o7 do sismograma capturado em campo no campo de press\u00e3o.\nDurante o processo de depropaga\u00e7\u00e3o, nos intervalos de tempo registrados no arquivo com os tempos de tr\u00e2nsito, s\u00e3o feitas capturas dos estados da matriz que representa o tempo presente. O objetivo dessas capturas \u00e9 registrar as amplitudes da frente de onda no momento em que as ondas registradas no sismograma alcan\u00e7am as profundidades esperadas para cada uma das camadas que lhes deram origem.\nPor fim, somam-se todas essas capturas em uma nova matriz, a qual ser\u00e1 convertida em uma imagem. Nessa imagem espera-se que sejam destacadas as interfaces das camadas em subsuperf\u00edcie (SANTOS, 2012) - Figura 2.3(3).\nCaso o modelo de velocidades prov\u00e1vel utilizado na execu\u00e7\u00e3o do algoritmo seja compat\u00edvel com o modelo geol\u00f3gico real encontrado em campo, o imageamento se mostrar\u00e1 n\u00edtido e coerente com as demais informa\u00e7\u00f5es que j\u00e1 se possui do meio; caso contr\u00e1rio, o imageamento se mostrar\u00e1 difuso e incoerente.\nEm (ARAYA-POLO et al., 2011) \u00e9 apresentado um estudo comparativo do desempenho do algoritmo RTM em quatro arquiteturas de processamento distintas:\n\u25a0\tum Processador Xeon E5460;\n\u25a0\tum GP-GPU NVIDIA Tesla C1060 (NVIDIA. TESLA C1060 COMPUTING PROCESSOR BOARD: BOARD SPECIFICATION, 2008);\n\u25a0\tum Processador IBM Cell/B.E. (IBM, 2011) e\n\u25a0\tquatro FPGAs Xilix Virtex5-LX330.\n7Depropaga\u00e7\u00e3o, neste contexto, significa propaga\u00e7\u00e3o inversa, em sentido contr\u00e1rio ao que foi gerado.\nFigura 2.2: Din\u00e2mica da simula\u00e7\u00e3o da propaga\u00e7\u00e3o do pulso s\u00edsmico pelo campo de press\u00e3o\nTodos os experimentos foram suportados por meio de placas especiais adicionadas a uma plataforma de processamento h\u00edbrida Convey HC-1 8 (Convey Computer, 2014). O gr\u00e1fico apresentado na Figura 2.4 apresenta os tempos de execu\u00e7\u00e3o do algoritmo em cada uma das tecnologias avaliadas.\nApesar de ter sido executada a uma frequ\u00eancia de trabalho de 150 MHz, aproximadamente 10 vezes menor que a frequ\u00eancia de trabalho da GP-GPU e 21 vezes menor que a frequ\u00eancia de opera\u00e7\u00e3o da CPU, o desempenho da implementa\u00e7\u00e3o do algoritmo em FPGA foi aproximadamente 20 vezes maior que o obtido com o processador, ficando um pouco abaixo do desempenho obtido pela implementa\u00e7\u00e3o na GP-GPU.\nNa an\u00e1lise apresentada na conclus\u00e3o de (ARAYA-POLO et al., 2011), os autores afirmam que, caso houvesse sido adotado outro padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico mais simples, por exemplo, o padr\u00e3o de ponto-fixo em lugar do padr\u00e3o de ponto-flutuante, o desempenho obtido com a implementa\u00e7\u00e3o em FPGA poderia ter sido ainda maior, superior tamb\u00e9m \u00e0quele apresentado pela implementa\u00e7\u00e3o em GP-GPU.\nEm (CLAPP; FU; LINDTJORN, 2010) \u00e9 apresentado um segundo estudo comparativo do desempenho do algoritmo RTM quando implementado em GP-GPU e em FPGA. Nesse trabalho, embora n\u00e3o sejam apresentados resultados concretos em rela\u00e7\u00e3o ao desempenho, destaca-se o fato de que o desempenho da implementa\u00e7\u00e3o em FPGA liga-se diretamente, entre outras coisas, ao custo de implementa\u00e7\u00e3o dos m\u00f3dulos aritm\u00e9ticos utilizados. Em raz\u00e3o de seu alto custo de implementa\u00e7\u00e3o em hardware, esses autores recomendam que se evite adotar, sempre que poss\u00edvel, o padr\u00e3o de ponto-flutuante para aplica\u00e7\u00f5es de alto desempenho que utilizem FPGAs como coprocessadores aritm\u00e9ticos.\nEm (HE; ZHAO; LU, 2005a,b) apresentada a implementa\u00e7\u00e3o do algoritmo RTM em um FPGA Xilinx Virtex4. Nessa implementa\u00e7\u00e3o adota-se o padr\u00e3o de ponto-flutuante na implementa\u00e7\u00e3o do n\u00facleo de processamento. A fim de melhor avaliar a rela\u00e7\u00e3o do desempenho\n8A plataforma Convey HC1 foi posteriormente substituida pela plataforma HC2.\nFigura 2.3: Princ\u00edpio de funcionamento do algoritmo RTM e do processo de depropaga\u00e7\u00e3o do sismograma para a gera\u00e7\u00e3o do imageamento da subsuperf\u00edcie\n60\n50\n20\n250\n300\n350\t400\t450\nProblem dimension [points]\n500\n40\nX---\nNVIDIA Tesla C1060 \u2014 IBM Cell/B.E. \u2014x-FPGA (CONVEY HC-1) \u2014 Intel Xeon E5460 h-\n\u25a0\u25a0 -3K -\u2022 -----h----\nFigura 2.4: Comparativo do tempo de execu\u00e7\u00e3o do algoritmo RTM nas arquiteturas GP-GPU, IBM Cell/B.E., Intel Xeon e atrav\u00e9s de FPGAs Xilix Virtex5-LX330 (ARAYA-POLO et al., 2011)\nda implementa\u00e7\u00e3o em hardware com o padr\u00e3o de acesso \u00e0 mem\u00f3ria, avaliaram-se diversas configura\u00e7\u00f5es de operadores de diferen\u00e7as finitas, variando o grau do operador no tempo e no espa\u00e7o. A Tabela 2.1 apresenta os resultados obtidos.\nTabela 2.1: Desempenho da implementa\u00e7\u00e3o do algoritmo RTM apresentada em (HE;\nZHAO; LU, 2005b). As velocidades de execu\u00e7\u00e3o apresentadas foram medidas em mpp/s (milh\u00f5es de pontos processados por segundo).\nConfigura\u00e7\u00e3o do Operador (tempo, espa\u00e7o)\tVelocidade em sw\tVelocidade em hw\tdesempenho hw/sw\n(2,2)\t15,37 mpp/s\t49,69 mpp/s\t3,23\n(2,4)\t12,38 mpp/s\t49,57 mpp/s\t4,01\n(2,8)\t8,59 mpp/s\t49,43 mpp/s\t5,69\n(4,4)\t7,11 mpp/s\t48,46 mpp/s\t6,84\n(4,8)\t5,71 mpp/s\t48,48 mpp/s\t8,49\nEm (BRAGAN\u00e7A et al., 2013) \u00e9 apresentada a implementa\u00e7\u00e3o em uma FPGA Altera Stratix-III do algoritmo RTM para modelagem em tr\u00eas dimens\u00f5es, desenvolvido dentro de um projeto de conv\u00eanio de coopera\u00e7\u00e3o entre o Centro de Inform\u00e1tica da UFPE e a Petrobras.\nA fim de se obter maior desempenho, o n\u00facleo de processamento aritm\u00e9tico do projeto apresentado em (BRAGAN\u00e7A et al., 2013) foi implementado utilizando o padr\u00e3o de ponto-fixo.\nApesar de esse n\u00facleo estar sendo processado a uma frequ\u00eancia de apenas 50MHz, o seu desempenho ficou entre 17 e 30 vezes mais r\u00e1pido do que o de um processador Intel Xeon E5430 de 2,66GHz. A varia\u00e7\u00e3o no desempenho se deveu a varia\u00e7\u00f5es nas dimens\u00f5es dos modelos geol\u00f3gicos que foram processados.\nEm (PELL et al., 2013) \u00e9 proposto um fluxo de projeto para a implementa\u00e7\u00e3o do algoritmo RTM em FPGA com base no uso de uma plataforma de hardware desenvolvida pela Empresa Maxeler (Maxeler Tecnologies, 2009) e no ambiente de programa\u00e7\u00e3o MaxGenFD, tamb\u00e9m desenvolvido pela mesma empresa.\nNo fluxo de projeto proposto em (PELL et al., 2013), o n\u00facleo aritm\u00e9tico do algoritmo RTM pode ser implementado tanto no padr\u00e3o de ponto-fixo quanto no padr\u00e3o de ponto-flutuante. Quando este for implementado utilizando o padr\u00e3o de ponto-fixo, a fim de garantir sempre a melhor precis\u00e3o dos resultados, utiliza-se um esquema h\u00edbrido de processamento, no qual os dados s\u00e3o processados em ponto-fixo e armazenados na mem\u00f3ria no padr\u00e3o de ponto-flutuante.\n2.2\tEfeitos da precis\u00e3o num\u00e9rica no processamento de dados s\u00edsmicos\nEm (FU et al., 2008, 2009) \u00e9 apresentada uma abordagem que tem como objetivo determinar de forma semiautom\u00e1tica, baseada na qualidade das imagens geradas, as configura\u00e7\u00f5es de um padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico adequado \u00e0 implementa\u00e7\u00e3o do algoritmo PSTM. Essas configura\u00e7\u00f5es dizem respeito \u00e0s caracter\u00edsticas que esse padr\u00e3o num\u00e9rico deve ter, tais como o intervalo de valores represent\u00e1veis e a precis\u00e3o com que os valores neste intervalo devem ser representados.\nO trabalho apresentado em (FU et al., 2009) parte da premissa de que n\u00e3o existe uma defini\u00e7\u00e3o clara do n\u00edvel de precis\u00e3o num\u00e9rica que os algoritmos s\u00edsmicos exigem. Por essa raz\u00e3o, os autores prop\u00f5em que a melhor estrat\u00e9gia seria eleger diversas configura\u00e7\u00f5es candidatas e dentre elas escolher aquela que apresente a melhor qualidade de imageamento quando comparada com um resultado tido como de refer\u00eancia.\nA abordagem apresentada consiste em primeiramente definir um padr\u00e3o candidato, baseado na an\u00e1lise do intervalo de valores gerados durante o processamento s\u00edsmico de um modelo geol\u00f3gico de refer\u00eancia, para, em seguida, avaliar a qualidade do imageamento gerado por meio de varia\u00e7\u00f5es desse padr\u00e3o candidato.\nA an\u00e1lise do intervalo de valores \u00e9 feita por meio de uma vers\u00e3o modificada do programa que implementa o algoritmo PSTM. Modifica-se o c\u00f3digo original do programa de forma a permitir registrar todos os valores atribu\u00eddos \u00e0s vari\u00e1veis utilizadas no n\u00facleo aritm\u00e9tico do programa.\nAo final da execu\u00e7\u00e3o do algoritmo, anotam-se os maiores e menores valores positivos e negativos atribu\u00eddos a cada uma dessas vari\u00e1veis, respectivamente os valores d, c, b e a do\nesquema apresentado na Figura 2.5. Por meio dos valores a e d, determina-se o intervalo de valores a ser representado e, pelos valores b e c, determina-se a precis\u00e3o do padr\u00e3o candidato.\na\tb 0 c\t\u00bf1\n\u2014 CQ\t\t\t\t\t+ oa\n\t\t\t\t\t\nFigura 2.5: Distribui\u00e7\u00e3o dos valores utilizados para determinar o intervalo de valores e a precis\u00e3o do padr\u00e3o de representa\u00e7\u00e3o.\nCaso se deseje adotar o padr\u00e3o de ponto-fixo, o intervalo de valores representados determinar\u00e1 a quantidade de bits a ser utilizada na parte inteira da representa\u00e7\u00e3o, enquanto a precis\u00e3o determinar\u00e1 a quantidade de bits a ser utilizada na sua parte fracion\u00e1ria.\nSeguindo a abordagem proposta em (FU et al., 2009), ap\u00f3s a defini\u00e7\u00e3o de um padr\u00e3o de representa\u00e7\u00e3o candidato, uma nova vers\u00e3o do programa \u00e9 implementada e executada sobre o modelo geol\u00f3gico de refer\u00eancia. Por meio da compara\u00e7\u00e3o das imagens geradas com essa nova vers\u00e3o do programa contra imagens de refer\u00eancia, pode-se ajustar a precis\u00e3o do padr\u00e3o candidato at\u00e9 chegar a um padr\u00e3o de representa\u00e7\u00e3o considerado ideal, que equalize o custo de implementa\u00e7\u00e3o em hardware com a qualidade das imagens geradas.\nEsses autores (FU et al., 2009) ainda prop\u00f5em que, a fim de reduzir o custo de implementa\u00e7\u00e3o e alcan\u00e7ar melhor desempenho em sistemas implementados em FPGAs, seja feita uma an\u00e1lise do impacto que cada uma das opera\u00e7\u00f5es aritm\u00e9ticas existentes no n\u00facleo de processamento tem sobre o sistema em sua totalidade. Apenas as opera\u00e7\u00f5es que apresentarem maior impacto, no uso do hardware ou na qualidade dos resultados, devem ser consideradas no processo de ajuste da precis\u00e3o. No experimento apresentado, ap\u00f3s a verifica\u00e7\u00e3o do custo de implementa\u00e7\u00e3o de cada uma das opera\u00e7\u00f5es existentes, foram identificadas como alvo as opera\u00e7\u00f5es de raiz quadrada e a exponencial complexa. O n\u00facleo aritm\u00e9tico do algoritmo implementado pode ser visto por meio da Equa\u00e7\u00e3o 1 em (FU et al., 2009).\nEm (MEDEIROS et al., 2013; BARROS et al., 2011) s\u00e3o apresentados resultados observados na fase inicial deste trabalho sobre os efeitos da redu\u00e7\u00e3o da precis\u00e3o aritm\u00e9tica na implementa\u00e7\u00e3o do algoritmo Reverse Time Migration (RTM).\nEsses resultados foram obtidos dentro de um projeto de pesquisa mais amplo, firmado entre o Centro de inform\u00e1tica da Universidade Federal de Pernambuco e a Petrobras, com o objetivo de desenvolver uma plataforma de processamento de alto desempenho baseada em FPGAs, dedicada \u00e0 execu\u00e7\u00e3o do algoritmo Reverse Time Migration (RTM) (MEDEIROS et al., 2013; BRAGAN\u00e7A et al., 2013). A Figura 2.6 detalha a estrutura da plataforma implementada.\nUma plataforma de hardware e software foi desenvolvida especialmente para o projeto. O objetivo dessa plataforma foi permitir que o algoritmo RTM pudesse ser executado de forma otimizada, parte em software e parte diretamente em hardware. A parte relativa ao ajuste de dados e a visualiza\u00e7\u00e3o das imagens geradas foi implementada e executada no PC Host, o qual\ndispunha de um processador Intel Core 2 Quad 6600 de 2.4 GHz com 2 GB de mem\u00f3ria RAM. A parte relativa ao processamento aritm\u00e9tico foi implementada para execu\u00e7\u00e3o em um FPGA Stratix III de uma placa de desenvolvimento GIDEL PROCe-III (GIDEL, 2010).\nFigura 2.6: Plataforma de processamento s\u00edsmico implementada em (MEDEIROS et al., 2013; BRAGAN\u00e7A et al., 2013)\n\u00c0 semelhan\u00e7a do que havia sido proposto em (FU et al., 2008, 2009), nesse projeto tamb\u00e9m se efetuaram estudos pr\u00e9vios do intervalo de valores gerados pelo n\u00facleo de processamento aritm\u00e9tico, a partir do qual, definiram-se algumas configura\u00e7\u00f5es candidatas para o padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico a ser adotado (MEDEIROS et al., 2013).\nA fim de atingir alto desempenho, a exemplo dos demais trabalhos citados, nesse optouse tamb\u00e9m pela utiliza\u00e7\u00e3o do padr\u00e3o de ponto-fixo em lugar do padr\u00e3o de ponto-flutuante na implementa\u00e7\u00e3o do n\u00facleo de processamento.\nPara avaliar a qualidade das imagens geradas nas diversas configura\u00e7\u00f5es de ponto-fixo candidatas, foram utilizadas duas m\u00e9tricas: uma mais objetiva, a Signal to Noise Ratio (SNR), e outra mais subjetiva, proposta em (WANG; BOVIK, 2002), denominada de Universal Quality Indice (UQI).\nA m\u00e9trica SNR foi utilizada com o objetivo de relacionar o n\u00edvel de ru\u00eddo introduzido nas imagens com a configura\u00e7\u00e3o de ponto-fixo utilizada. Sua implementa\u00e7\u00e3o se deu por meio da equa\u00e7\u00e3o a seguir:\nSNR = 20 x log\nVrms (x)\nVrms(x y')\nem que\n1\tN /\u2014\t1 N /----------\nVrms(x) = N E x2,\tVrms(x - y) = N E (xi - yi)2\nna qual Vrms representa a intensidade m\u00e9dia quadr\u00e1tica dos pixels da imagem, medidos em regi\u00f5es quadradas com N pixel.\nA m\u00e9trica UQI foi utilizada com o objetivo de mensurar o grau de semelhan\u00e7a entre as imagens geradas nas diversas configura\u00e7\u00f5es de ponto-fixo avaliadas e uma imagem de refer\u00eancia gerada em ponto-flutuante. Conforme descrito em (WANG; BOVIK, 2002), essa m\u00e9trica busca mensurar esse grau de semelhan\u00e7a do ponto de vista da percep\u00e7\u00e3o humana do brilho, contraste e artefatos presentes nas imagens. Sua implementa\u00e7\u00e3o baseou-se na aplica\u00e7\u00e3o da seguinte equa\u00e7\u00e3o:\nUQI =\n4ox,yxy\n(o2+O2) [(x2) + (y2)]\n(25)\nem que\n_\t1 N\nX = N E xi'\n2 _ 1\nO = N\u20141\n1\n\u00b0x\u2019y = N- 1\n1N\ny=uEyi\nN\nE (Xi - X)2,\tO-y2\ni=1\nN\nE (xi- x)(yi- y)\ni=1\n1\nN- 1\nN\nE (yi - y)2 i=1\nTanto na Equa\u00e7\u00e3o 2.5 quanto na Equa\u00e7\u00e3o 2.4, x representa a intensidade do sinal na imagem gerada enquanto y representa a intensidade do sinal na imagem de refer\u00eancia. Em ambos os casos, as medidas foram aplicadas em janelas com 9x9 pixels cada.\nA Figura 2.7 apresenta os resultados obtidos com as m\u00e9tricas na avalia\u00e7\u00e3o do image-amento do modelo de Marmousi (MARTIN; WILEY; MARFURT, 2006) nas diversas configura\u00e7\u00f5es avaliadas. Como se pode observar, as duas m\u00e9tricas apresentam um comportamento semelhante, com um crescimento acelerado na qualidade dos resultados no intervalo entre 10 e 15 bits de precis\u00e3o. A partir desse ponto, verifica-se que o SNR permanece inalterado para todas as demais configura\u00e7\u00f5es, apesar da m\u00e9trica UQI apresentar ainda um pequeno crescimento.\nPara melhor avaliar esse resultado, executou-se ainda um segundo experimento, no qual o processamento dos dados foi efetuado utilizando-se um n\u00facleo aritm\u00e9tico em ponto-flutuante, mantendo-se entretanto o armazenamento dos resultados em ponto-fixo. Os resultados obtidos nesse segundo experimento denominaram-se de SNR e UQI de transporte, uma vez que o ru\u00eddo\nent\u00e3o avaliado era causado apenas pelo transporte dos dados que estava sendo efetuado em menor precis\u00e3o. A Figura 2.8 traz os gr\u00e1ficos que relacionam esses resultados com a precis\u00e3o utilizada no padr\u00e3o de ponto-fixo.\nComo se pode observar, comparando os gr\u00e1ficos apresentados nas Figuras 2.7 e 2.8, os ru\u00eddos causados pelas opera\u00e7\u00f5es aritm\u00e9ticas do n\u00facleo de processamento dominam sobre o ru\u00eddo causado apenas pelo armazenamento dos dados, sendo, dessa forma, um limitante na qualidade dos resultados. Por esse motivo, pode-se considerar como um artif\u00edcio v\u00e1lido no processo de otimiza\u00e7\u00e3o do sistema operar os dados em uma precis\u00e3o e armazen\u00e1-los em outra. Isso permitiria melhorar a qualidade dos resultados sem impactar no custo do transporte dos dados.\nAinda por esse mesmo experimento, verifica-se que uma rela\u00e7\u00e3o sinal-ru\u00eddo (SNR) em torno de 70dB, o que correspondeu a uma configura\u00e7\u00e3o com 16 bits de precis\u00e3o, pode ser considerado como um limite adequado \u00e0 gera\u00e7\u00e3o de sismogramas para o modelo geol\u00f3gico de Marmousi(MARTIN; WILEY; MARFURT, 2006). Uma vez que, a partir dessa configura\u00e7\u00e3o, o grau de semelhan\u00e7a medido atrav\u00e9s do UQI n\u00e3o apresenta ganhos que possam ser considerados significativos.\n2.3\tPrecis\u00e3o da modelagem da propaga\u00e7\u00e3o da onda s\u00edsmica por meio dos operadores de diferen\u00e7as finitas\nO M\u00e9todo das Diferen\u00e7as Finitas (MDF) foi um dos primeiros m\u00e9todos computacionais desenvolvidos para a resolu\u00e7\u00e3o de equa\u00e7\u00f5es diferenciais. Ele consiste na substitui\u00e7\u00e3o das derivadas presentes na equa\u00e7\u00e3o em estudo por express\u00f5es alg\u00e9bricas de diferen\u00e7as, obtidas pelo truncamento de expans\u00f5es da s\u00e9rie de Taylor (SANTOS, 2012).\nUma vez que esse m\u00e9todo representa uma resolu\u00e7\u00e3o discretizada para fun\u00e7\u00f5es cont\u00ednuas, sua aplica\u00e7\u00e3o sofre algumas restri\u00e7\u00f5es; entre elas, a aplica\u00e7\u00e3o do MDF deve ser feita considerando-se o dom\u00ednio de sua ap\nFigura 2.7: SNR e UQI total medido nas diversas configura\u00e7\u00f5es avaliadas (MEDEIROS\nFigura 2.8: SNR e UQI de transporte medido nas diversas configura\u00e7\u00f5es avaliadas (MEDEIROS et al., 2013)\nT-X j\t1\t\u00bb fv\tS \u2022\tS \u2022\nDetermina\u00e7\u00e3o da precis\u00e3o num\u00e9rica m\u00ednima necess\u00e1ria \u00e0 execu\u00e7\u00e3o do algoritmo RTM\nA defini\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria \u00e0 implementa\u00e7\u00e3o de um algoritmo est\u00e1 diretamente ligada \u00e0 magnitude dos valores a serem processados e \u00e0 sensibilidade desse algoritmo ao n\u00edvel de ru\u00eddo introduzido pelo processamento.\nQuanto menor a magnitude dos valores a serem processados, maior a precis\u00e3o num\u00e9rica necess\u00e1ria para represent\u00e1-los.\nDa mesma forma, quanto mais sens\u00edvel for o algoritmo ao ru\u00eddo introduzido pelo processamento, maior ter\u00e1 de ser a precis\u00e3o dos operadores aritm\u00e9ticos utilizados em sua implementa\u00e7\u00e3o.\nEssas duas premissas est\u00e3o diretamente ligadas ao objetivo deste trabalho, ou seja, \u00e0 determina\u00e7\u00e3o da precis\u00e3o num\u00e9rica m\u00ednima necess\u00e1ria \u00e0 implementa\u00e7\u00e3o do algoritmo RTM.\nNesse contexto, este trabalho buscou estabelecer uma metodologia que permita identificar essa precis\u00e3o por meio da an\u00e1lise dos fen\u00f4menos f\u00edsicos envolvidos na propaga\u00e7\u00e3o da onda s\u00edsmica e da determina\u00e7\u00e3o das caracter\u00edsticas litol\u00f3gicas da regi\u00e3o a ser imageada.\nA metodologia aqui proposta foi estabelecida a partir da realiza\u00e7\u00e3o dos seguintes objetivos:\na)\tO desenvolvimento de um m\u00e9todo anal\u00edtico capaz de predizer, a partir da an\u00e1lise das caracter\u00edsticas da regi\u00e3o a ser imageada, a menor amplitude esperada para as ondas s\u00edsmicas durante o seu processamento.\nb)\tO desenvolvimento de um algoritmo computacional, baseado no m\u00e9todo anal\u00edtico proposto, que seja capaz de identificar deforma autom\u00e1tica, com uma margem de seguran\u00e7a de pelo menos 1 bit, a precis\u00e3o num\u00e9rica m\u00ednima necess\u00e1ria \u00e0 execu\u00e7\u00e3o do algoritmo RTM.\n3.1\tFatores que influenciam na amplitude da onda s\u00edsmica\nDo ponto de vista dos fen\u00f4menos f\u00edsicos associados \u00e0 propaga\u00e7\u00e3o da onda s\u00edsmica, pode-se dizer que a amplitude desta ser\u00e1 diretamente afetada pelos seguintes fatores (ROBERT E. SHERIFF, 1995):\n\u25a0\ta fonte s\u00edsmica utilizada;\n\u25a0\tas dimens\u00f5es e as caracter\u00edsticas das camadas em subsuperf\u00edcie;\n\u25a0\tos fen\u00f4menos dissipativos associados \u00e0 transforma\u00e7\u00e3o da energia transportada pela onda s\u00edsmica em outras formas de energia.\nNo entanto, \u00e9 importante ressaltar que, destes, apenas os dois primeiros fatores listados est\u00e3o de fato presentes na modelagem computacional empregada na implementa\u00e7\u00e3o do algoritmo RTM.\nPor ter sido desenvolvido apenas com base na equa\u00e7\u00e3o que rege a propaga\u00e7\u00e3o da onda ac\u00fastica, sem levar em conta fen\u00f4menos f\u00edsicos dissipativos associados a essa propaga\u00e7\u00e3o, tais como o fator de qualidade do meio e poss\u00edveis transforma\u00e7\u00f5es da energia ac\u00fastica em outras formas de energia, o operador de diferen\u00e7as finitas empregado no algoritmo RTM fica restrito apenas \u00e0 modelagem dos fen\u00f4menos f\u00edsicos associados \u00e0 conserva\u00e7\u00e3o de energia capturados por essa equa\u00e7\u00e3o (SANTOS, 2012).\nAl\u00e9m dos fen\u00f4menos f\u00edsicos j\u00e1 descritos, existem outros fatores ligados \u00e0 configura\u00e7\u00e3o do operador de diferen\u00e7as finitas que podem tamb\u00e9m influenciar na amplitude da onda s\u00edsmica durante a execu\u00e7\u00e3o do algoritmo RTM.\nPar\u00e2metros, tais como o intervalamento espacial e temporal das amostras, as velocidades de propaga\u00e7\u00e3o m\u00ednima e m\u00e1xima esperadas para o modelo de velocidades e a frequ\u00eancia do pulso s\u00edsmico utilizado, podem afetar na amplitude das ondas s\u00edsmicas modeladas (BOORE, 1972; VOSSEN; ROBERTSSON; CHAPMAN, 2002) e, dessa forma, interferir na precis\u00e3o num\u00e9rica necess\u00e1ria para process\u00e1-las.\nEntretanto, por se tratar de par\u00e2metros de configura\u00e7\u00e3o, que n\u00e3o est\u00e3o diretamente ligados a nenhum fen\u00f4meno f\u00edsico, esses fatores n\u00e3o ser\u00e3o considerados no m\u00e9todo aqui proposto.\nDessa forma, de todos os fen\u00f4menos f\u00edsicos e fatores de configura\u00e7\u00e3o que podem afetar a amplitude da onda s\u00edsmica, apenas as caracter\u00edsticas da fonte s\u00edsmica utilizada e as dimens\u00f5es e caracter\u00edsticas das camadas em subsuperf\u00edcie ser\u00e3o consideradas. Os efeitos esperados de cada um desses elementos na amplitude das ondas s\u00edsmicas ser\u00e3o descritos a seguir.\n3.2\tEfeito da fonte s\u00edsmica utilizada\nAs caracter\u00edsticas da fonte s\u00edsmica utilizada na S\u00edsmica de Reflex\u00e3o 1 \u00e9 algo de fundamental import\u00e2ncia para a qualidade das imagens geradas. Entre outras coisas, esta deve gerar um pulso que seja limitado no tempo e no espectro (SANTOS, 2012).\nNa modelagem computacional, a fonte s\u00edsmica deve ser representada por uma fun\u00e7\u00e3o matem\u00e1tica que tenha as mesmas caracter\u00edsticas do pulso s\u00edsmico real.\nNo algoritmo RTM, o pulso s\u00edsmico \u00e9 modelado por meio da segunda derivada da fun\u00e7\u00e3o gaussiana. O pulso gerado por essa fun\u00e7\u00e3o em um meio visco-el\u00e1stico \u00e9 conhecido em geof\u00edsica como Pulso de Ricker (ROBERT E. SHERIFF, 1995). Neste trabalho essa fun\u00e7\u00e3o \u00e9 modelada atrav\u00e9s da seguinte equa\u00e7\u00e3o:\nf(t) =\n1 - 2(t x a/075 x n x fc)2\n\nem que t representa o tempo de simula\u00e7\u00e3o e fc representa a frequ\u00eancia central do pulso s\u00edsmico gerado (ROBERT E. SHERIFF, 1995). O formato do pulso gerado pode ser verificado na Figura\n3.1.\tPor suas caracter\u00edsticas temporais e espectrais, essa fun\u00e7\u00e3o \u00e9 a mais largamente utilizada para esse tipo de aplica\u00e7\u00e3o (SANTOS, 2012; ROBERT E. SHERIFF, 1995).\nFigura 3.1: Representa\u00e7\u00e3o do pulso s\u00edsmico modelado por meio da segunda derivada da fun\u00e7\u00e3o gausiana\nNos experimentos conduzidos ao longo deste trabalho, observou-se que, apesar da fun\u00e7\u00e3o geradora do pulso s\u00edsmico n\u00e3o estar relacionada com as caracter\u00edsticas do meio de simula\u00e7\u00e3o, a amplitude do pulso efetivamente inserido no meio varia de acordo com a velocidade de propaga\u00e7\u00e3o da camada na qual se faz a sua inser\u00e7\u00e3o. O gr\u00e1fico apresentado na Figura 3.2\n1 S\u00edsmica de Reflex\u00e3o \u00e9 a designa\u00e7\u00e3o dada aos m\u00e9todos de imageamento s\u00edsmico baseados nas ondas refletidas\npela subsuperf\u00edcie.\napresenta a rela\u00e7\u00e3o encontrada entre essa amplitude e a velocidade do meio, para uma modelagem em duas dimens\u00f5es.\nFigura 3.2: Amplitude do pulso s\u00edsmico introduzido em rela\u00e7\u00e3o \u00e0 velocidade do meio\nVerifica-se pelo gr\u00e1fico da Figura 3.2 que a amplitude do pulso s\u00edsmico efetivamente inserido ser\u00e1 inversamente proporcional ao quadrado da velocidade do meio.\nApesar desse fen\u00f4meno n\u00e3o ter nenhum efeito na qualidade do imageamento quando a modelagem computacional est\u00e1 baseada no padr\u00e3o de ponto flutuante, o mesmo n\u00e3o ocorre quando este utiliza um padr\u00e3o num\u00e9rico de precis\u00e3o fixa, tal como o padr\u00e3o de ponto fixo. Isso porque, diferentemente do padr\u00e3o de ponto flutuante, no qual o n\u00edvel de ru\u00eddo introduzido com o processamento independe da amplitude dos dados, no padr\u00e3o de ponto fixo este ser\u00e1 inversamente proporcional \u00e0 sua amplitude.\n3.3\tEfeito das dimens\u00f5es e das caracter\u00edsticas das camadas\nem subsuperf\u00edcie\nUm grande n\u00famero de fen\u00f4menos f\u00edsicos que afetam a amplitude da onda s\u00edsmica est\u00e1 diretamente associado \u00e0s dimens\u00f5es e \u00e0s caracter\u00edsticas das camadas em subsuperf\u00edcie. Dentre esses fen\u00f4meno,s destacam-se:\n\u25a0\ta diverg\u00eancia da frente de onda, ou espalhamento geom\u00e9trica da onda;\n\u25a0\tos efeitos refrativos e reflexivos em raz\u00e3o do contraste de imped\u00e2ncia nas interfaces das camadas geol\u00f3gicas;\n\u25a0\tas itera\u00e7\u00f5es construtivas e destrutivas devido ao encontro de duas ou mais frentes de ondas refratadas e/ou refletidas;\nos efeitos de multipercursos (multi-path);\n\u25a0\to espalhamento da frente de onda;\n\u25a0\to efeito de dispers\u00e3o.\nDessa forma, o efeito verificado na qualidade do imageamento s\u00edsmico devido \u00e0s dimens\u00f5es e as caracter\u00edsticas das camadas em subsuperf\u00edcie ser\u00e1, na verdade, um somat\u00f3rio dos efeitos introduzidos por esses fen\u00f4menos.\n3.3.1\tEfeitos refrativos e reflexivos\nAo se propagar de uma camada geol\u00f3gica para a outra, a onda s\u00edsmica sofre efeitos refrativos e reflexivos proporcionais ao contraste de imped\u00e2ncias ac\u00fasticas existentes entre essas camadas (ROBERT E. SHERIFF, 1995).\nA imped\u00e2ncia ac\u00fastica \u00e9 a caracter\u00edstica do meio que identifica o grau de resist\u00eancia deste \u00e0 passagem das ondas s\u00edsmicas.\nExistem dois tipos de onda s\u00edsmica, ondas prim\u00e1rias ou compressionais, denotadas como ondas P e ondas secund\u00e1rias ou transversais, denotadas como ondas S. Essas ondas se diferenciam entre si pela forma como se propagam no meio. A Figura 3.3 apresenta esquematicamente como essas ondas se comportam (ROBERT E. SHERIFF, 1995).\nOndas Prim\u00e1rias (P) - Compressionais Ondas Secund\u00e1rias (S) -Transversais\nDire\u00e7\u00e3o de Propaga\u00e7\u00e3o da Onda\nFigura 3.3: Ondas compressionais (P) e ondas transversais (S)\nPor esse motivo, o meio apresentar\u00e1 tamb\u00e9m dois tipos de imped\u00e2ncias ac\u00fasticas, uma relacionada com a onda P e outra relacionada a onda S.\nEm ambos os casos, a imped\u00e2ncia ac\u00fastica \u00e9 definida como o produto da densidade do meio, denotada por p, pela velocidade de propaga\u00e7\u00e3o da onda. Como as ondas P e S se propagam a velocidades distintas, para as ondas P tem-se:\nZp = p x Vp\nem que ZP denota a imped\u00e2ncia ac\u00fastica do meio relativa \u00e0 onda P e VP denota a velocidade de propaga\u00e7\u00e3o da onda P. Para as ondas S, tem-se:\nem que ZS denota a imped\u00e2ncia ac\u00fastica do meio relativa \u00e0 onda S e VS a velocidade de propaga\u00e7\u00e3o da onda S.\nTanto as ondas P quanto as ondas S, podem ser originadas devido \u00e0 passagem de uma onda P pela interface entre duas camadas geol\u00f3gicas.\nO diagrama da Figura 3.4 apresenta de maneira simplificada como uma onda s\u00edsmica compressional, denotada por Onda P, interage com o meio ao passar de uma camada para a outra.\nDependendo do \u00e2ngulo de incid\u00eancia da onda com a interface entre as camadas, angulo 0i, ela pode dar origem a ondas refletidas compressionais, ondas RP, e ondas refletidas transversais, ondas RS, respectivamente com \u00e2ngulos 01 e \u00c21. Da mesma forma, poder\u00e3o ser geradas ondas transmitidas compressionais, ondas TP e ondas transmitidas transversais, ondas TS, respectivamente com \u00e2ngulos 02 e \u00c22.\nFigura 3.4: Ondas refletidas, compressionais RP e transversais RS, e refratadas, compressionais TP e transversais TS\n\u00c9 importante destacar que, quando o \u00e2ngulo de incid\u00eancia da onda com a interface entre as camadas, \u00e2ngulo 01, estiver entre 0 e 20 graus, apenas ondas refletidas e refratadas compressionais ser\u00e3o geradas, ondas RP e TP. Nessa situa\u00e7\u00e3o pode-se determinar as intensidades das ondas geradas por meio do princ\u00edpio da conserva\u00e7\u00e3o da energia. Os percentuais da energia da onda incidente que ser\u00e3o refletidos e refratados, aqui denominados de coeficientes de reflex\u00e3o e de transmiss\u00e3o, denotados por CR e CT, podem ser calculados pelas seguintes equa\u00e7\u00f5es (ROBERT E. SHERIFF, 1995):\nZ2 - Z1\nR\tZ2 + Z1\ne\nr\t2Zi\nT Z2 + Zi \u2019\nna quais Z1 \u00e9 a imped\u00e2ncia da camada onde a onda se encontra e Z2 a imped\u00e2ncia da camada para onde a onda se propaga.\nNeste trabalho, uma vez que n\u00e3o interessa analisar as ondas transversais, apenas as ondas compressionais geradas com incid\u00eancia normal ao meio ser\u00e3o consideradas. Todas as camadas que formam a subsuperf\u00edcie ser\u00e3o tidas como lineares, paralelas, perfeitamente el\u00e1sticas, homog\u00eaneas e isotr\u00f3picas.\nConsiderando que todas as camadas em subsuperf\u00edcie t\u00eam densidade constante igual a 1, as equa\u00e7\u00f5es 3.4 e 3.5 podem ser reescritas de maneira mais simples, apenas em fun\u00e7\u00e3o das velocidades das camadas envolvidas, ou seja,\nV2 - Vi\nT\tV2 + Vi'\nPor terem sido derivados mediante o princ\u00edpio da conserva\u00e7\u00e3o de energia, os coeficientes de transmiss\u00e3o e reflex\u00e3o assim calculados n\u00e3o determinam diretamente as amplitudes das ondas resultantes, e sim as suas intensidades (ROBERT E. SHERIFF, 1995). A fim de calcular essas amplitudes, \u00e9 necess\u00e1rio primeiramente relacionar a intensidade do fluxo da energia da onda, aqui denotado por I, com a sua amplitude e as caracter\u00edsticas do meio, ou seja, sua velocidade e densidade. Essa rela\u00e7\u00e3o pode ser descrita pela equa\u00e7\u00e3o a seguir (ROBERT E. SHERIFF, 1995):\nI\n1\tpA2\n2\t\u2019\nAssim sendo, uma vez que a intensidade da parcela da energia que \u00e9 transmitida da primeira para a segunda camada, aqui denotada por IT12, \u00e9 igual \u00e0 intensidade da energia que \u00e9 recebida na segunda camada, aqui denotada por I2, tem-se:\nIT12 = I2,\nou seja,\n1\tp AT12\n2\tV2\n1\tp a2\n2\tV2 \u2022\nCancelando os termos comuns e rearranjando os termos restantes, t\u00eam-se:\nA2 = At 12 x\nV1\nEntretanto,\nAT 12 = A1 x Cr,\no que nos leva a\nA2 = A1 x\n2V1\tV2\nV1 + V2 x Vi\nO que pode ser ainda simplificado e reescrito da seguinte forma:\nA2 = Ai x\n2V2\nV1 + V 2 \u2019\nEssa equa\u00e7\u00e3o permite, portanto, calcular a amplitude da onda transmitida para a segunda camada, em fun\u00e7\u00e3o da amplitude da onda incidente na primeira camada e das velocidades de cada uma das camadas. Aplicando o mesmo racioc\u00ednio com rela\u00e7\u00e3o \u00e0 amplitude da onda refletida na primeira camada, denotada por Rn, t\u00eam-se:\nV1\nR11 = A1 x Cr x Vi,\no que nos leva a\nR11 = A1 x Cr .\nDo que se pode concluir que as amplitudes das ondas refletidas e transmitidas podem ser preditas pela aplica\u00e7\u00e3o conjunta das Equa\u00e7\u00f5es 3.14, 3.16 e 3.6. A atenua\u00e7\u00e3o que a onda s\u00edsmica sofre nesse processo \u00e9 denominada neste trabalho de atenua\u00e7\u00e3o em raz\u00e3o da configura\u00e7\u00e3o litol\u00f3gica do meio.\n3.3.2\tA diverg\u00eancia da frente de onda\nO termo diverg\u00eancia ou espalhamento geom\u00e9trico da frente de onda est\u00e1 diretamente associado ao processo de propaga\u00e7\u00e3o da onda conforme descrito pelo Princ\u00edpio de Huygens. Segundo esse princ\u00edpio, cada part\u00edcula excitada pela energia de uma frente de onda dar\u00e1 origem a uma nova frente de onda (ROBERT E. SHERIFF, 1995), conforme ilustrado na Figura 3.5.\nFigura 3.5: Ilustra\u00e7\u00e3o da aplica\u00e7\u00e3o do Princ\u00edpio de Huygens \u00e0 propaga\u00e7\u00e3o da onda em espa\u00e7os isotr\u00f3picos.\nCom isso, em espa\u00e7os isotr\u00f3picos, o fluxo de energia gerado por um pulso s\u00edsmico\n57\t3.3. EFEITO DAS DIMENS\u00d5ES E DAS CARACTER\u00cdSTICAS DAS CAMADAS EM\n_______________________________________________________________SUBSUPERF\u00cdCIE se propagar\u00e1 de maneira homog\u00eanea, em todas as dire\u00e7\u00f5es, podendo ser visto como esferas conc\u00eantricas em meio tridimensional ou como c\u00edrculos conc\u00eantricos em um meio bidimensional.\nA intensidade do fluxo de energia produzido pela passagem da frente de onda, aqui denotado por I, pode ser calculada mediante a seguinte equa\u00e7\u00e3o:\nI = 1v p A2m 2\nna qual A \u00e9 a amplitude da frente de onda, V e m s\u00e3o respectivamente as suas velocidades linear e angular e p \u00e9 a densidade do meio na qual a onda se propaga (ROBERT E. SHERIFF, 1995)\nEm uma modelagem s\u00edsmica tridimensional baseada no operador de diferen\u00e7as finitas utilizado no algoritmo RTM, considerando que o raio da frente de onda cres\u00e7a de r1 para r2, conforme ilustrado na Figura 3.6, verifica-se que a intensidade do fluxo de energia que atravessa a superf\u00edcie da esfera de raio r1, superf\u00edcie S1, deve ser igual \u00e0 intensidade do fluxo de energia que atravessa a superf\u00edcie da esfera de raio r2, superf\u00edcie S2, ou seja,\nIS1 = IS2,\nem que IS1 e IS2 representam respectivamente a intensidade do fluxo de energia que atravessa as superf\u00edcies S1 e S2.\nFigura 3.6: Ilustra\u00e7\u00e3o da forma de propaga\u00e7\u00e3o da onda s\u00edsmica em meio isotr\u00f3pico\nAplicando a Equa\u00e7\u00e3o 3.17 na Equa\u00e7\u00e3o 3.18, tem-se:\n1V pAjrn 2S1 = 2v pA2 m 2S2.\nCancelando os termos comuns em ambos os lados dessa equa\u00e7\u00e3o, obt\u00e9m-se:\na2S1 = a2s2\nou, ainda,\nSabendo-se que a \u00e1rea de uma superf\u00edcie esf\u00e9rica \u00e9 igual a\nS\t= nr2.\nAplicando-se esta defini\u00e7\u00e3o \u00e0 equa\u00e7\u00e3o 3.20, obt\u00e9m-se:\nA2 = A1 x\nou, ainda,\nA2 = Ai x \u2014.\nr2\nA Equa\u00e7\u00e3o 3.22 permite portanto calcular a amplitude que a frente de onda ter\u00e1 ao alcan\u00e7ar a superf\u00edcie S2, a partir da amplitude que essa possui na superf\u00edcie S1 e da rela\u00e7\u00e3o entre os raios de propaga\u00e7\u00e3o da frente de onda em cada uma dessas superf\u00edcies.\nDessa forma, para modelagens em tr\u00eas dimens\u00f5es, a amplitude de uma frente de onda produzida por um pulso inicial de amplitude A0 e raio r0 = 1, a uma dist\u00e2ncia r do seu ponto de inser\u00e7\u00e3o, ser\u00e1 igual a:\n./ x Ao A r = \u2014\nEm uma modelagem bidimensional, substituindo as superf\u00edcies esf\u00e9ricas S1 e S2 da Equa\u00e7\u00e3o 3.20 por circunfer\u00eancias conc\u00eantricas de per\u00edmetro\nL1 = 2n r1\ne\nL2 = 2n r2,\ntem-se\nA1\t/2n r1\nA2 =\\ 2\u00f17~2 \u2019\nou, ainda,\nA2 = A1 x\nVr2\nDessa forma, para modelagens em duas dimens\u00f5es, a amplitude de uma frente de onda produzida por um pulso inicial de amplitude A0 e raio r0 = 1, a uma dist\u00e2ncia r do seu ponto de inser\u00e7\u00e3o, ser\u00e1 igual a:\nNos experimentos conduzidos ao longo deste trabalho, verificou-se que, apesar das Equa\u00e7\u00f5es 3.23 e 3.25 serem adequadas para modelar a atenua\u00e7\u00e3o por diverg\u00eancia em modelos com apenas uma camada, elas n\u00e3o s\u00e3o adequadas para se modelar atenua\u00e7\u00f5es por diverg\u00eancia em modelos com mais de uma camada. Esses experimentos ser\u00e3o apresentados na Se\u00e7\u00e3o 3.4.2.\n3.4\tMetodologia para a predi\u00e7\u00e3o da amplitude das ondas s\u00edsmicas refletidas\nUm dos elementos-chave na defini\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria \u00e0 execu\u00e7\u00e3o do algoritmo RTM s\u00e3o as amplitudes com que as ondas s\u00edsmicas refletidas chegam \u00e0 superf\u00edcie.\nPor esse motivo, um dos objetivos deste trabalho foi desenvolver um m\u00e9todo anal\u00edtico que permitisse estimar essas amplitudes com base nas caracter\u00edsticas do pulso s\u00edsmico introduzido e nas camadas em subsuperf\u00edcie.\nO m\u00e9todo aqui proposto baseia-se na an\u00e1lise dos seguintes fatores:\n\u25a0\ta amplitude do pulso s\u00edsmico efetivamente introduzido em subsuperf\u00edcie, Se\u00e7\u00e3o 3.2;\n\u25a0\ta atenua\u00e7\u00e3o causada pelos efeitos refrativos e reflexivos, Se\u00e7\u00e3o 3.3.1;\n\u25a0\ta atenua\u00e7\u00e3o causada pela diverg\u00eancia da frente de onda, Se\u00e7\u00e3o 3.3.2.\nA amplitude do pulso s\u00edsmico introduzido na modelagem computacional pode ser obtida por meio dos valores experimentais registrados na curva da Figura 3.2.\nA atenua\u00e7\u00e3o causada pelos efeitos refrativos e reflexivos pode ser obtida mediante a aplica\u00e7\u00e3o das Equa\u00e7\u00f5es 3.6, 3.14 e 3.16.\nA princ\u00edpio, a atenua\u00e7\u00e3o causada pela diverg\u00eancia da frente de onda deveria ser calculada pela Equa\u00e7\u00e3o 3.25. Entretanto, os experimentos conduzidos ao longo deste trabalho indicaram que ela n\u00e3o \u00e9 adequada \u00e0 determina\u00e7\u00e3o da atenua\u00e7\u00e3o em modelos com mais de uma camada. Por isso, foi necess\u00e1rio desenvolver outra equa\u00e7\u00e3o que permite ajustar os valores obtidos atrav\u00e9s da Equa\u00e7\u00e3o 3.25 para modelos com qualquer n\u00famero de camadas. Esse ajuste ocorre por meio de uma corre\u00e7\u00e3o feita no valor do raio da frente de onda fornecido \u00e0 Equa\u00e7\u00e3o 3.25, resultando em uma nova equa\u00e7\u00e3o aqui denominada de C\u00e1lculo do Raio Efetivo.\n3.4.1\tC\u00e1lculo do Raio Efetivo para modelagem bidimensional\nCom os experimentos conduzidos ao longo deste trabalho, constatou-se que \u00e9 necess\u00e1rio efetuar um ajuste no valor do raio aplicado \u00e0 Equa\u00e7\u00e3o 3.25, para que ela possa calcular corretamente a atenua\u00e7\u00e3o sofrida pela frente de onda em modelos com mais de uma camada. Esse ajuste deve ser aplicado a cada nova camada encontrada em subsuperf\u00edcie. O novo raio assim calculado, aqui denotado como raio efetivo, rE, ser\u00e1 obtido por meio da seguinte equa\u00e7\u00e3o:\n(M = E (i -i=0 Vo\nna qual hz e hi representam respectivamente: a dist\u00e2ncia percorrida pela frente de onda e a dist\u00e2ncia de onde come\u00e7a a camada geol\u00f3gica atual. Ambas as dist\u00e2ncias devem ser tomadas em rela\u00e7\u00e3o ao ponto de inser\u00e7\u00e3o do pulso s\u00edsmico, medidas em fun\u00e7\u00e3o do intervalamento espacial do operador de diferen\u00e7as finitas utilizado. Vo e Vi- representam respectivamente as velocidades de propaga\u00e7\u00e3o do pulso na primeira camada e na posi\u00e7\u00e3o na qual se encontra a frente de onda.\nDessa forma, reescrevendo a Equa\u00e7\u00e3o 3.25, utilizando agora o raio efetivo no lugar do raio real, chegamos \u00e0 equa\u00e7\u00e3o\na qual permite calcular a atenua\u00e7\u00e3o por diverg\u00eancia para modelos com qualquer configura\u00e7\u00e3o de camadas.\nO conceito do raio efetivo \u00e9, at\u00e9 onde foi poss\u00edvel investigar, uma contribui\u00e7\u00e3o original deste trabalho. Todo o seu arcabou\u00e7o te\u00f3rico ainda precisa ser mais bem estudado e estabelecido, uma vez que ele foi elaborado de maneira emp\u00edrica, exclusivamente por meio dos resultados obtidos nos diversos experimentos conduzidos neste trabalho.\nCom a utiliza\u00e7\u00e3o do conceito do raio efetivo, do ponto de vista da atenua\u00e7\u00e3o por diverg\u00eancia, um meio com diversas camadas passa a ser visto como se tivesse uma \u00fanica camada, com velocidade igual \u00e0 velocidade da primeira camada e tamanho igual ao somat\u00f3rio das proje\u00e7\u00f5es de cada uma das outras camadas na primeira camada.\nA Figura 3.7 ilustra a aplica\u00e7\u00e3o da Equa\u00e7\u00e3o 3.26 no c\u00e1lculo do raio efetivo para um modelo geol\u00f3gico com tr\u00eas camadas.\nVerifica-se, por meio do c\u00e1lculo do raio efetivo apresentado nessa figura, que a primeira parcela do somat\u00f3rio da Equa\u00e7\u00e3o 3.26 corresponde \u00e0 dist\u00e2ncia percorrida pela frente de onda\nainda na primeira camada, ou seja,\n1000\n1\u00d4\u00d4\u00d4 ,\n3\na segunda parcela corresponde a dist\u00e2ncia percorrida na segunda camada,\n2\n2000\n1000\ne a terceira parcela corresponde \u00e0 dist\u00e2ncia percorrida na terceira camada,\n.\t3000\n4 x-----.\n1000\nNesse exemplo, o raio efetivo calculado para uma dist\u00e2ncia de 9 pontos no grid original do modelo de velocidades utilizado corresponde a uma dist\u00e2ncia de 19 pontos em um modelo com uma \u00fanica camada, com uma velocidade de propaga\u00e7\u00e3o igual \u00e0 da primeira camada.\n3.4.2\tExperimentos de valida\u00e7\u00e3o do c\u00e1lculo do raio efetivo\nOs experimentos utilizados na valida\u00e7\u00e3o no c\u00e1lculo do raio efetivo se basearam no seguinte princ\u00edpio: sendo a Equa\u00e7\u00e3o 3.25 a fun\u00e7\u00e3o que determina a atenua\u00e7\u00e3o que a frente de onda sofrer\u00e1 em raz\u00e3o da diverg\u00eancia da frente de onda, e que o operador de diferen\u00e7as finitas utilizado no algoritmo RTM n\u00e3o modela fatores dissipativos, a aplica\u00e7\u00e3o da inversa da Equa\u00e7\u00e3o 3.25 sobre uma curva gerada por esta deve resultar em um valor constante, equivalente \u00e0 amplitude do pulso inicialmente inserido no meio, ou seja, se\nent\u00e3o\ng(f (Ao,ri),ri) = Ai x^/r, = Ao.\nPartindo desse princ\u00edpio, foram efetuados tr\u00eas experimentos a fim de validar o conceito do raio efetivo, os quais se basearam n\u00e3o na predi\u00e7\u00e3o da atenua\u00e7\u00e3o introduzida pela diverg\u00eancia da frente de onda, mas sim no seu cancelamento. Esses experimentos tiveram como objetivo verificar a efici\u00eancia do m\u00e9todo nas seguintes situa\u00e7\u00f5es:\n\u25a0 em um modelo com uma \u00fanica camada;\n\u25a0 em um modelo com duas camadas;\n\u25a0 em um modelo com mais de duas camadas.\nCada experimento foi efetuado em tr\u00eas etapas distintas, conforme descrito a seguir:\na)\tPrimeiramente, realizou-se a simula\u00e7\u00e3o computacional da propaga\u00e7\u00e3o da onda s\u00edsmica no modelo geol\u00f3gico. Ao longo dessa simula\u00e7\u00e3o, foram sendo capturadas\nas amplitudes de chegada da frente de onda em cada um dos pontos localizados perpendicularmente abaixo do ponto de inser\u00e7\u00e3o do pulso s\u00edsmico.\nb)\tEm seguida, aplicou-se a Equa\u00e7\u00e3o 3.28 aos valores capturados na primeira etapa, sendo Ai a amplitude da frente de onda no ponto i e ri a dist\u00e2ncia do ponto i ao ponto de inser\u00e7\u00e3o do pulso s\u00edsmico. O novo conjunto de valores assim obtido \u00e9 reservado para fins de compara\u00e7\u00e3o com o m\u00e9todo proposto.\nc)\tPor fim, reaplica-se a Equa\u00e7\u00e3o 3.28 aos valores capturados na primeira etapa, substituindo o valor de cada ri pelo seu raio efetivo, rE, calculado atrav\u00e9s da Equa\u00e7\u00e3o\n3.26.\n3.4.2.1\tPrimeiro Experimento\nO primeiro experimento consistiu em mensurar a atenua\u00e7\u00e3o por diverg\u00eancia em um modelo sint\u00e9tico com velocidade constante igual a 1500 m/s. A Figura 3.8 traz a configura\u00e7\u00e3o desse experimento.\n\tSf\t\t\t\nPulso / S\u00edsmico\t\tPontos > de medi\u00e7\u00e3o\nV=1500 m/s\t\t\nFigura 3.8: Configura\u00e7\u00e3o do experimento 1.\nO gr\u00e1fico da Figura 3.9 apresenta as amplitudes da frente de onda nos pontos de medi\u00e7\u00e3o.\nO decaimento dessa curva deve-se \u00e0 atenua\u00e7\u00e3o por diverg\u00eancia nesse modelo.\nAmplitude da frente de onda\nFigura 3.9: Atenua\u00e7\u00e3o por diverg\u00eancia cil\u00edndrica no primeiro experimento.\nEm seguida, ao aplicar a Equa\u00e7\u00e3o 3.28 ao conjunto de dados obtidos na primeira etapa desse experimento, obteve-se o gr\u00e1fico da Figura 3.10.\nAmplitude da frente de onda com\nFigura 3.10: Compensa\u00e7\u00e3o da atenua\u00e7\u00e3o por diverg\u00eancia por meio da aplica\u00e7\u00e3o da Equa\u00e7\u00e3o 3.28.\nPor fim, na terceira etapa do experimento, ao aplicar a Equa\u00e7\u00e3o 3.28 substituindo-se o raio da frente de onda pelo raio efetivo, com a aplica\u00e7\u00e3o da Equa\u00e7\u00e3o3.26, obteve-se o gr\u00e1fico da Figura 3.11.\nAmplitude da frente de onda com\nFigura 3.11: Compensa\u00e7\u00e3o da atenua\u00e7\u00e3o por diverg\u00eancia por meio da aplica\u00e7\u00e3o conjunta das Equa\u00e7\u00f5es 3.28 e 3.26.\nComo se pode verificar pelos gr\u00e1ficos das Figuras 3.10 e 3.11, em ambos os casos, ocorreu um efetivo cancelamento da atenua\u00e7\u00e3o por diverg\u00eancia nos valores capturados, uma vez que as amplitudes em todos os pontos dos dois gr\u00e1ficos ficaram constantes. Isso permite dizer que tanto a Equa\u00e7\u00e3o 3.25 quanto a Equa\u00e7\u00e3o 3.27,modelam corretamente a atenua\u00e7\u00e3o por diverg\u00eancia em modelos com apenas uma camada geol\u00f3gica.\n3.4.2.2\tSegundo Experimento\nO segundo experimento consistiu em mensurar e verificar o cancelamento da atenua\u00e7\u00e3o por diverg\u00eancia em um modelo com duas camadas. Para tanto, utilizou-se um modelo geol\u00f3gico com uma camada com 1.500 m/s e outra com 2.500 m/s, conforme indicado na Figura 3.12.\nV =1500 m/s\t5\t\nV =2500 m/s 2\t\nFigura 3.12: Configura\u00e7\u00e3o do experimento 2.\nO gr\u00e1fico da Figura 3.13 apresenta os valores capturados na primeira etapa do experimento. Nesse gr\u00e1fico pode-se observar na posi\u00e7\u00e3o 250 do raio o efeito conjunto da atenua\u00e7\u00e3o por diverg\u00eancia e por fen\u00f4menos ligados \u00e0 litologia.\n\nAtenua\u00e7\u00e3o da frende de onda para um modelo com duas\ncamadas paralelas de 1500 e 2500 m/s\nFigura 3.13: Atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em meio isotr\u00f3pico com duas camadas com velocidade de propaga\u00e7\u00e3o de 1500 e 2500 m/s.\nO gr\u00e1fico da Figura 3.14 apresenta o resultado obtido na segunda etapa desse experimento.\nAmplitude da frende de onda com corre\u00e7\u00e3o da atenua\u00e7\u00e3o\nFigura 3.14: Compensa\u00e7\u00e3o da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em modelo com duas camadas, sem a aplica\u00e7\u00e3o do raio efetivo.\nComo se pode observar, por esse gr\u00e1fico, a simples aplica\u00e7\u00e3o da Equa\u00e7\u00e3o 3.25, sem a utiliza\u00e7\u00e3o do raio efetivo, n\u00e3o foi suficiente para cancelar a atenua\u00e7\u00e3o por diverg\u00eancia na segunda camada do modelo. Verifica-se pelo decaimento apresentado nessa parte da curva que ela ainda\ncont\u00e9m res\u00edduos da atenua\u00e7\u00e3o por diverg\u00eancia.\nPor fim, na terceira etapa do experimento, ao se utilizar o raio efetivo, com a aplica\u00e7\u00e3o conjunta das Equa\u00e7\u00f5es 3.25 e 3.26, obteve-se o gr\u00e1fico da Figura 3.15.\nAmplitude da frende de onda com corre\u00e7\u00e3o da atenua\u00e7\u00e3o\nFigura 3.15: Compensa\u00e7\u00e3o da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em modelo com duas camadas com a aplica\u00e7\u00e3o do raio efetivo.\nComo se pode observar, por esse gr\u00e1fico, dessa vez, tanto a atenua\u00e7\u00e3o da primeira camada quanto a atenua\u00e7\u00e3o da segunda camada foram efetivamente compensadas.\nA diferen\u00e7a das amplitudes observadas nesse gr\u00e1fico se deve \u00e0 atua\u00e7\u00e3o dos efeitos refrativos e reflexivos envolvidos na passagem da onda s\u00edsmica da primeira para a segunda camada do modelo e na representa\u00e7\u00e3o da energia da onda s\u00edsmica em cada camada.\n3.4.2.3\tTerceiro Experimento\nO terceiro experimento teve como objetivo verificar a aplicabilidade do m\u00e9todo para modelos com mais de duas camadas. Para tanto, nesse experimento foi utilizado um modelo com tr\u00eas camadas, com velocidades de 1.500, 2.500 e 3.500 m/s. A disposi\u00e7\u00e3o do experimento pode ser vista na Figura 3.16.\nNesse experimento, a exemplo dos experimentos anteriores, primeiramente se verificou o cancelamento da atenua\u00e7\u00e3o utilizando o raio real da frente de onda, obtendo-se como resultado o gr\u00e1fico da Figura3.17.\nFigura 3.16: Configura\u00e7\u00e3o do experimento 3.\nAmplitude da frente de onda com corre\u00e7\u00e3o da atenua\u00e7\u00e3o\nFigura 3.17: Tentativa de compensa\u00e7\u00e3o da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em meio com tr\u00eas camadas utilizando o raio real.\nComo se pode observar, por esse gr\u00e1fico, apenas a atenua\u00e7\u00e3o da primeira camada foi efetivamente cancelada. Mais uma vez pode-se constatar que a simples aplica\u00e7\u00e3o do modelo de atenua\u00e7\u00e3o sem a utiliza\u00e7\u00e3o do raio efetivo n\u00e3o \u00e9 suficiente para cancelar a atenua\u00e7\u00e3o por diverg\u00eancia para modelos com mais de uma camada.\nEm seguida, repetiu-se o processo, dessa vez substituindo as dist\u00e2ncias dos pontos por seus raios efetivos. O resultado pode ser visto no gr\u00e1fico da Figura 3.18.\nAmplitude da frente de onda com corre\u00e7\u00e3o da atenua\u00e7\u00e3o\nFigura 3.18: Compensa\u00e7\u00e3o efetiva da atenua\u00e7\u00e3o causada pela diverg\u00eancia cil\u00edndrica em meio com tr\u00eas camadas por meio da utiliza\u00e7\u00e3o do conceito do raio efetivo.\nNesse gr\u00e1fico, observa-se que, com a utiliza\u00e7\u00e3o do raio efetivo no lugar do raio real, as atenua\u00e7\u00f5es por diverg\u00eancia das tr\u00eas camadas foram efetivamente compensadas.\nCom esses resultados, pode-se concluir por indu\u00e7\u00e3o que o m\u00e9todo proposto \u00e9 efetivo tanto para o cancelamento quanto para a predi\u00e7\u00e3o da atenua\u00e7\u00e3o por diverg\u00eancia para modelos com qualquer n\u00famero de camadas.\n3.4.3\tExperimentos de valida\u00e7\u00e3o da predi\u00e7\u00e3o da atenua\u00e7\u00e3o devido \u00e0 configura\u00e7\u00e3o litol\u00f3gica\nA valida\u00e7\u00e3o das Equa\u00e7\u00f5es 3.16 e 3.14 relativas \u00e0 atenua\u00e7\u00e3o pela configura\u00e7\u00e3o litol\u00f3gica deu-se com base nos resultados j\u00e1 obtidos nos experimentos de valida\u00e7\u00e3o do c\u00e1lculo do raio efetivo.\nAo observar os resultados obtidos naqueles experimentos, verifica-se que, para modelos com duas ou mais camadas, a compensa\u00e7\u00e3o da atenua\u00e7\u00e3o por diverg\u00eancia da frente de onda gera gr\u00e1ficos com amplitudes distintas para cada camada do modelo.\nAplicando-se a Equa\u00e7\u00e3o 3.14 \u00e0 configura\u00e7\u00e3o utilizada no experimento que gerou o gr\u00e1fico da Figura 3.15, obt\u00e9m-se\nA2 = 1,07 x\n2 x 2500\n1500+2500\n= 1, 337,\no qual \u00e9 o valor verificado na amplitude da frente de onda registrada no gr\u00e1fico da Figura 3.15. Da mesma forma, utilizando as configura\u00e7\u00f5es das camadas do modelo utilizado no experimento que gerou o gr\u00e1fico da Figura 3.18 , obt\u00e9m-se\nA2 = 1,07 x\n2 x 2500\n1500+2500\n= 1, 337,\npara o primeiro degrau da curva, e\nA3 = 1,337 x\n2 x 3500\n2500+3500\n= 1 , 56,\npara o segundo degrau.\nAo observar o gr\u00e1fico da Figura 3.18, verifica-se que os valores assim calculados s\u00e3o os mesmos registrados naquela curva.\nDessa forma, conclui-se que a Equa\u00e7\u00e3o 3.14 e, por conseguinte, a Equa\u00e7\u00e3o 3.16 s\u00e3o adequadas \u00e0 predi\u00e7\u00e3o da varia\u00e7\u00e3o de amplitude que a frente de onda sofre em raz\u00e3o da configura\u00e7\u00e3o do modelo geol\u00f3gico utilizado.\n3.5\tDesenvolvimento e valida\u00e7\u00e3o da metodologia\nAp\u00f3s a an\u00e1lise dos fen\u00f4menos f\u00edsicos associados \u00e0 propaga\u00e7\u00e3o da onda s\u00edsmica, verificase que os principais fatores que afetam a sua amplitude e que, portanto, podem ser utilizados na predi\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria ao seu processamento, s\u00e3o:\na)\ta atenua\u00e7\u00e3o que o pulso s\u00edsmico sofre ao ser introduzido no meio, conforme registrado no gr\u00e1fico da Figura 3.2;\nb)\ta atenua\u00e7\u00e3o causada pelo raio efetivo da frente de onda, que est\u00e1 ligado \u00e0 atenua\u00e7\u00e3o por diverg\u00eancia, Equa\u00e7\u00e3o 3.27;\nc)\ta atenua\u00e7\u00e3o devido \u00e0 configura\u00e7\u00e3o litol\u00f3gica do modelo que est\u00e1 sendo processado, Equa\u00e7\u00f5es 3.14 e 3.16.\nNeste trabalho o segundo e o terceiro fatores foram reunidos e representados atrav\u00e9s de um \u00fanico coeficiente, denominado de coeficiente de atenua\u00e7\u00e3o efetiva, denotado por CAE. Numericamente esse coeficiente nada mais \u00e9 do que a a\u00e7\u00e3o conjunta do coeficiente de atenua\u00e7\u00e3o por diverg\u00eancia, denotada por CAD, com o coeficiente de atenua\u00e7\u00e3o por litologia, denotado por CAL, ou seja,\nCae = Cal x Cad\nSendo assim, a predi\u00e7\u00e3o da amplitude que uma onda s\u00edsmica alcan\u00e7ar\u00e1 ao fim do processo de imageamento pode ser determinada pelo conhecimento da sua amplitude inicial e da atenua\u00e7\u00e3o efetiva que ela sofre durante os processos de modelagem e migra\u00e7\u00e3o.\nA Figura 3.19 traz um modelo esquem\u00e1tico que exemplifica de maneira simplificada o percurso de uma onda s\u00edsmica em todas as etapas de execu\u00e7\u00e3o do algoritmo RTM, indo desde o momento da inser\u00e7\u00e3o do pulso s\u00edsmico na etapa de modelagem, passando pela gera\u00e7\u00e3o do sismograma sint\u00e9tico e indo at\u00e9 a gera\u00e7\u00e3o da se\u00e7\u00e3o migrada. O exemplo foi desenvolvido para um modelo geol\u00f3gico sint\u00e9tico com tr\u00eas camadas.\nFigura 3.19: Percurso da onda s\u00edsmica desde a inser\u00e7\u00e3o do pulso s\u00edsmico no processo de modelagem, passando pelo registro das ondas refletidas e chegando at\u00e9 a gera\u00e7\u00e3o da se\u00e7\u00e3o migrada no processo de migra\u00e7\u00e3o.\nAs Figuras 3.20 e 3.21 apresentam o processo de c\u00e1lculo da atenua\u00e7\u00e3o efetiva para o imageamento do modelo geol\u00f3gico da Figura 3.19.\nEm cada uma dessas figuras, est\u00e3o destacados tanto os elementos respons\u00e1veis pela atenua\u00e7\u00e3o por litologia quanto os respons\u00e1veis pela atenua\u00e7\u00e3o pela diverg\u00eancia da frente de onda.\nFigura 3.20: Esquema gr\u00e1fico para a demonstra\u00e7\u00e3o do c\u00e1lculo da atenua\u00e7\u00e3o efetiva da onda refletida na interface entre a primeira e a segunda camada da Figura 3.19.\nFigura 3.21: Esquema gr\u00e1fico para a demonstra\u00e7\u00e3o do c\u00e1lculo da atenua\u00e7\u00e3o efetiva da onda refletida na interface entre a segunda e a terceira camada da Figura 3.19.\nComo se pode observar, fazendo um paralelo do diagrama esquem\u00e1tico da Figura 3.20 com o da Figura 3.19, no in\u00edcio do processo de modelagem, insere-se um pulso s\u00edsmico na primeira camada em subsuperf\u00edcie, a qual tem velocidade V1 e profundidade h1. A inser\u00e7\u00e3o desse pulso d\u00e1 origem \u00e0 frente de onda P1 com amplitude aP. Ao alcan\u00e7ar a interface entre a primeira e a segunda camada, esta d\u00e1 origem \u00e0 onda refletida P2, que tem intensidade determinada pelos coeficientes de reflex\u00e3o e de transmiss\u00e3o entre essas duas camadas, aqui denotado por CR12.\nAo fim do processo de modelagem, a onda refletida P2 \u00e9 gravada no arquivo que armazena o sismograma.\nNo processo de migra\u00e7\u00e3o, a onda P2 \u00e9 lida do arquivo do sismograma e reintroduzida no meio. Essa onda \u00e9 ent\u00e3o propagada at\u00e9 a interface da primeira com a segunda camada, aonde chega com amplitude AMRP1.\nObserva-se por esse diagrama que a frente de onda AP percorreu um raio efetivo igual a 3 x h1 e foi submetida a uma atenua\u00e7\u00e3o por litologia igual ao coeficiente de reflex\u00e3o entre a primeira e a segunda camada, CR12. Baseado nessa an\u00e1lise e na equa\u00e7\u00e3o 3.29, verifica-se que ela sofreu uma atenua\u00e7\u00e3o efetiva igual a\nCR12\nou seja, a amplitude esperada para a onda s\u00edsmica, que ao fim do processo de migra\u00e7\u00e3o imageia a interface entre as camadas 1 e 2, aqui denotada por aMrP1, \u00e9 igual a:\nAMrP1 = AP x\nA designa\u00e7\u00e3o aMrP1 foi utilizada para indicar que essa onda tem origem na reflex\u00e3o da onda P1 na interface entre as camadas 1 e 2.\nDa mesma forma, analisando-se em paralelo os diagramas das Figuras 3.19 e 3.21, verifica-se que a onda inicial P1 d\u00e1 origem \u00e0 onda transmitida P3 ao ser transmitida da primeira para a segunda camada. A intensidade da onda P3 ser\u00e1 determinada pelo coeficiente de transmiss\u00e3o entre a primeira e a segunda camada, denotado por Cr 12.\nA onda P3, por sua vez, d\u00e1 origem \u00e0 onda refletida P4, na interface entre a segunda e a terceira camada. A amplitude da onda P4 \u00e9 determinada pelo coeficiente de reflex\u00e3o entre essas camadas, aqui denotado por CR23.\nEm seu retorno \u00e0 primeira camada, a onda refletida P4 d\u00e1 origem \u00e0 onda transmitida P5, a qual tem a intensidade determinada pelo coeficiente de transmiss\u00e3o entre a segunda e a primeira camada, que \u00e9 denotado por CT21.\nPor fim, a onda P5 \u00e9 gravada no sismograma.\nNo processo de migra\u00e7\u00e3o, a onda P5 ser\u00e1 lida do sismograma e reinserida no meio. Esta ser\u00e1 ent\u00e3o propagada at\u00e9 a interface das camadas 1 e 2, onde d\u00e1 origem \u00e0 nova onda transmitida P6, que tem a intensidade determinada pelo coeficiente de transmiss\u00e3o entre essas camadas. A onda P6 \u00e9 ent\u00e3o propagada at\u00e9 a interface entre as camadas 2 e 3, aonde chega com amplitude\nAMr 23.\nAo fim desse processo, a onda P1 ter\u00e1 sido submetida a uma atenua\u00e7\u00e3o por litologia igual\na:\n2Ct 12 x Ct2i x Cr23,\ne a uma atenua\u00e7\u00e3o por diverg\u00eancia igual a:\n1\n^3hi + 3h2 V1\no que nos leva a uma atenua\u00e7\u00e3o efetiva igual a:\n2CT12 x CT21 x CR23\ny/3hi + 3h2 Vi\nDesse modo, a amplitude esperada para a onda AMrP3 pode ser definida como:\nAMRP3 = AP x\n2CT12 x CT21 x CR23\n^3h1 + 3h2\nPor meio da an\u00e1lise da regularidade dos resultados obtidos nesse exemplo, desenvolveu-se um algoritmo que permite predizer a amplitude que as ondas refletidas pelas camadas da subsuperf\u00edcie ter\u00e3o ao fim do processo de migra\u00e7\u00e3o. Trata-se de um algoritmo recursivo, baseado em tr\u00eas elementos b\u00e1sicos que podem ser calculados pela combina\u00e7\u00e3o das equa\u00e7\u00f5es 3.29, 3.6 e\n3.26.\tS\u00e3o eles:\n\u25a0\tA atenua\u00e7\u00e3o por litologia que a onda s\u00edsmica sofre ao ser transportada de uma camada para a outra, entre as diversas camadas que formam a subsuperf\u00edcie. Esse c\u00e1lculo inclui tanto a atenua\u00e7\u00e3o sofrida no processo de modelagem quanto no processo de migra\u00e7\u00e3o. Para fins de c\u00e1lculo, a atenua\u00e7\u00e3o assim calculada \u00e9 passada implicitamente de uma camada para a outra por meio da amplitude da onda que \u00e9 transmitida, aqui denotada por At.\n\u25a0\tO raio efetivo at\u00e9 a camada atual, o qual \u00e9 passado recursivamente para a camada seguinte para que seja utilizado no c\u00e1lculo do raio efetivo das pr\u00f3ximas camadas.\n\u25a0\tA atenua\u00e7\u00e3o que a onda s\u00edsmica sofre ao ser refletida na interface entre duas camadas.\nA fim de simplificar a implementa\u00e7\u00e3o desse algoritmo, considerou-se que, ao passar por uma camada, a frente da onda j\u00e1 sofre toda a atenua\u00e7\u00e3o por litologia prevista para os processos de modelagem e migra\u00e7\u00e3o que envolvem essa camada. Esse procedimento inclui as duas passagens que a onda s\u00edsmica faz no sentido direto e uma no sentido inverso. Dessa forma verifica-se que a\namplitude da onda a ser transferida \u00e0 pr\u00f3xima camada pode ser definida pela equa\u00e7\u00e3o 3.14 da seguinte forma:\n2Vn+i\t2Vn\t2Vn+i\nAt = -------- x ------- X -------- X Ap,\n1\tVn + Vn+1 Vn + Vn+1 Vn + Vn+1\tP\u2019\nque pode ser expresso de maneira simplificada por:\nAt =\n(Vn + Vn+1)3\nx Ap,\nem que AP denota a amplitude do pulso inserido na camada atual, AT denota a amplitude do pulso propagado para a pr\u00f3xima camada e Vn e Vn+1 denotam respectivamente as velocidades da camada atual e a velocidade da pr\u00f3xima camada.\nEm seguida, pode-se predizer a amplitude que a onda refletida em cada uma das camadas em subsuperf\u00edcie vai ter ao fim do processo de migra\u00e7\u00e3o, denotada por ARM, por meio da combina\u00e7\u00e3o das equa\u00e7\u00f5es 3.26, 3.27 e 3.6 e da amplitude da onda inserida na respectiva camada, resultando em:\n1\narm =\nVn\nV0+ '\nVn+1 - Vn\nVn + Vn+1\nAp,\nem que V0, Vn e Vn+1 representam respectivamente a velocidade da primeira camada, a velocidade da camada atual e a velocidade da pr\u00f3xima camada; hn e rn-1 representam respectivamente a profundidade interna da camada atual e o raio efetivo at\u00e9 chegar \u00e0 camada atual; AP representa a amplitude do pulso inserido na camada atual.\nNo algoritmo proposto, foram utilizadas as equa\u00e7\u00f5es 3.30 e 3.31 em conjunto, a fim de determinar a menor amplitude esperada ao fim do processo de migra\u00e7\u00e3o para as ondas refletidas nas diversas camadas em subsuperf\u00edcie, denotada por Amin. Essa amplitude ser\u00e1 ent\u00e3o utilizada para determinar a precis\u00e3o num\u00e9rica necess\u00e1ria ao processamento desse modelo. O fluxograma desse algoritmo \u00e9 apresentado na Figura 3.22.\nFigura 3.22: Algoritmo utilizado para a predi\u00e7\u00e3o da menor amplitude das ondas s\u00edsmicas refletidas.\nNa primeira chamada do algoritmo, o raio efetivo, r0, \u00e9 carregado com zero, a amplitude m\u00ednima, Amim, \u00e9 carregada com 10000. Isso \u00e9 feito a fim de garantir que essa amplitude seja, j\u00e1 na primeira itera\u00e7\u00e3o do algoritmo, substitu\u00edda pela amplitude da onda refletida entre a primeira e a segunda camada. AP \u00e9 carregado com a amplitude da onda gerada pelo pulso s\u00edsmico para uma camada de velocidade igual \u00e0 velocidade da primeira camada do modelo.\nDurante a sua execu\u00e7\u00e3o, a cada nova itera\u00e7\u00e3o, o algoritmo calcula recursivamente a amplitude que a onda refletida em cada camada ter\u00e1 ao fim do processo de migra\u00e7\u00e3o. Dessa forma, a cada nova camada encontrada no modelo geol\u00f3gico utilizado, verifica-se se a amplitude refletida nessa camada \u00e9 menor que a menor amplitude encontrada at\u00e9 ent\u00e3o. Caso seja, esta \u00e9 tida como a nova amplitude m\u00ednima e Amin \u00e9 atualizado.\nA Figura 3.23 apresenta os elementos gerados ao longo da execu\u00e7\u00e3o do algoritmo proposto, destacando as incid\u00eancias dos coeficientes de transmiss\u00e3o entre as camadas, a evolu\u00e7\u00e3o do raio efetivo e o coeficiente de reflex\u00e3o entre a \u00faltima e a pen\u00faltima camada.\nFigura 3.23: Identifica\u00e7\u00e3o dos elementos gerados com a execu\u00e7\u00e3o do algoritmo proposto.\nAp\u00f3s a execu\u00e7\u00e3o do algoritmo, o n\u00famero de bits de precis\u00e3o necess\u00e1rio ao processamento, aqui denotado por Nb\u00fcs, \u00e9 determinado de forma a garantir um erro de representa\u00e7\u00e3o percentual de Amin menor ou igual a um por cento, ou seja,\nem que NB,ts denota o n\u00famero de bits de precis\u00e3o a ser utilizado, f.^ denota a opera\u00e7\u00e3o teto da representa\u00e7\u00e3o e |. | denota a opera\u00e7\u00e3o valor absoluto da representa\u00e7\u00e3o.\n4\nEstudo de Caso\nSendo este um trabalho multidisciplinar, envolvendo processamento geof\u00edsico e engenharia da computa\u00e7\u00e3o, a sua valida\u00e7\u00e3o foi feita em duas etapas, primeiramente por meio de um conjunto de experimentos nos quais se pode atestar a aplicabilidade da metodologia desenvolvida e, em seguida, por meio da implementa\u00e7\u00e3o de um n\u00facleo de processamento aritm\u00e9tico para uma plataforma de processamento de alto desempenho dedicada \u00e0 execu\u00e7\u00e3o do algoritmo RTM.\n4.1\tExperimentos de valida\u00e7\u00e3o da metodologia\nOs experimentos de valida\u00e7\u00e3o da metodologia foram realizados por meio da predi\u00e7\u00e3o das precis\u00f5es num\u00e9ricas necess\u00e1rias ao imageamento de um conjunto de modelos geol\u00f3gicos sint\u00e9ticos de baixa complexidade, formado por camadas paralelas planas e horizontais, os quais foram elaborados em colabora\u00e7\u00e3o com especialistas da \u00e1rea de Geologia. Estes modelos foram concebidos com o objetivo de representar as configura\u00e7\u00f5es litol\u00f3gicas normalmente encontradas em subsuperf\u00edcie em regi\u00f5es de prospec\u00e7\u00e3o de hidro-carbonetos.\nAl\u00e9m desses modelos mais simples, foi utilizado tamb\u00e9m um modelo mais complexo conhecido como modelo de Marmousi (MARTIN; WILEY; MARFURT, 2006), o qual \u00e9 um modelo de refer\u00eancia largamente empregado na valida\u00e7\u00e3o de novos algoritmos e processos aplicados ao imageamento s\u00edsmico.\nPara cada um desses modelos, o estudo de casos consistiu em aplicar a metodologia apresentada na Se\u00e7\u00e3o 3.5, identificar a precis\u00e3o num\u00e9rica necess\u00e1ria ao seu imageamento e comparar a qualidade do imageamento obtido nessa precis\u00e3o com a qualidade do imageamento obtido em outras precis\u00f5es num\u00e9ricas.\nAs Figuras 4.1 e 4.2 trazem as configura\u00e7\u00f5es litol\u00f3gicas de cada um dos modelos utilizados. As dimens\u00f5es indicadas nas figuras, tanto no sentido horizontal quanto no vertical, s\u00e3o relativas \u00e0 quantidade de pontos na matriz por meio da qual os modelos foram representados, ou seja, ao grid espacial de cada modelo. Todos os modelos foram representados utilizado-se um intervalamento espacial de 4,12 metros.\n11J\t\t50\t100\t150\t200\t250\n\t\t1500 m/s\t\t\th=90\n\t100 -\t\t\t\t\n\t1-4200..^\t2200 m/s\t\t\th=110\n\t\u25a0 3525\t\t\t\t\n\t300-\t1900 m/s\t\t\th=125\n\t- 2175400_\t\t\t\t\n\t\u25a0 1500\t2600 m/s\t\t\th=160\n\t500 _\t\t\t\t\n\t300 -\t3500 m/s\t\t\th=145\n\t700-\t4200 m/s\t\t\th=120\nModelo.l\n\t0\t50\t100 1\t150\t200 1\t250 1\n\t100 -\t3700 m/s\t\t\t\t\n\tr5600._\t2800 m/s\t\t\t\th=93\n\t\t\t\t\t\t\n\t- 4900\t\t\t\t\t\n\t\t4000 m/s\t\t\t\th=93\n\t300-\t\t\t\t\t\n\t-4200\t\t\t\t\t\n\t\t4500 m/s\t\t\t\th=69\n\t-3500 40() _\t\t\t\t\t\n\t- 2800\t5100 m/s\t\t\t\th=114\n\t500 -\t\t\t\t\t\n\t600 -\t\t\t\t\t\n\t700-\t\t\t\t\t\n\t\t5600 m/s\t\t\t\th=279\nModelo_2\n\t\t50\t100\t150\t200\t250\n\t100-\t1400 m/s\t\t\t\th=172\n\t1-5200... 200-\t\t\t\t\t\n\t-4250\t2300 m/s\t\t\t\th=88\n\t300 -\t\t\t\t\t\n\t- 3300\t3200 m/s\t\t\t\th=124\n\t-2350400-\t\t\t\t\t\n\t-1400\t\t\t\t\t\n\t500-\t4100 m/s\t\t\t\th=128\n\t600-\t\t\t\t\t\n\t700 -\t5200 m/s\t\t\t\th=238\nModelo_3\n:j J\t\t50\t100 1\t150\t200 1\t\n\t\t1600 m/s\t\t\t\th=35\n\t100-\t2200 m/s\t\t\t\th=73\n\t4900\t4600 m/s\t\t\t\th=82\n\t200-\t\t\t\t\t\n\t- 4075 300\t2800 m/s\t\t\t\th=no\n\t- 3250\t\t\t\t\t\n\t-2425400-\t\t\t\t\t\n\t-1600 500-\t\t\t\t\t\n\t600-\t3000 m/s\t\t\t\th=340\n\t\t4900 m/s\t\t\t\tlt=45\n\t700-\t4100 m/s\t\t\t\th=65\n\t\t\t\tModelo 4\t\t\n4300 m/s\th=S4\n2200 m/s\th=90\n3000 m/s\th=246\n1900 m/s\th=29\n_3800 m/s\th=150\n5100 m/s\th=24\n1600 m/s\th=114\nFigura 4.2: Estruturas geol\u00f3gicas do modelo 5 e do modelo de Marmousi.\nA Tabela 4.1 apresenta tanto as precis\u00f5es num\u00e9ricas encontradas quanto as menores amplitudes esperadas para as ondas s\u00edsmicas durante a execu\u00e7\u00e3o do algoritmo RTM para cada um desses modelos.\nTabela 4.1: Menor amplitude e precis\u00f5es num\u00e9ricas preditas para os modelos geol\u00f3gicos avaliados\nModelo\tMenor Amplitude\tPrecis\u00e3o Num\u00e9rica (No de bits)\nModelo 1\t8.98 x 10-5\t21\nModelo 2\t1.65 x 10-5\t23\nModelo 3\t1.1 x 10-4\t20\nModelo 4\t3.07 x 10-5\t21\nModelo 5\t5.68 x 10-5\t21\nMarmousi\t3.08 x 10-5\t22\nAs Figuras 4.3,4.4, 4.5, 4.6,4.7 e 4.8 apresentam os resultados do imageamento de cada um dos modelos em precis\u00f5es acima e abaixo dos valores preditos. Essas Figuras tamb\u00e9m podem ser vistas em tamanho grande nos Ap\u00eandices de A a F\nFigura 4.3: Resultados obtidos com o processamento com o Modelo 1.\n18 bits\t20 bits\nFigura 4.4: Resultados obtidos com o processamento com o Modelo 2.\nFigura 4.5: Resultados obtidos com o processamento com o Modelo 3.\nFigura 4.6: Resultados obtidos com o processamento com o Modelo 4.\nFigura 4.7: Resultados obtidos com o processamento com o Modelo 5.\nFigura 4.8: Resultados obtidos com o processamento com o Modelo de Marmousi.\n4.1.1\tM\u00e9trica de avalia\u00e7\u00e3o da qualidade das imagens geradas\nPara a avalia\u00e7\u00e3o da qualidade das imagens geradas com operadores aritm\u00e9ticos de menor precis\u00e3o, foram utilizadas duas m\u00e9tricas distintas: a rela\u00e7\u00e3o sinal-ru\u00eddo, SNR, e o \u00edndice universal de qualidade de imagens (WANG; BOVIK, 2002), UQI, descritas na se\u00e7\u00e3o 2.2.\nO objetivo da ado\u00e7\u00e3o conjunta dessas duas m\u00e9tricas foi avaliar n\u00e3o apenas o grau de semelhan\u00e7a entre as imagens geradas, mas tamb\u00e9m identificar o grau de sensibilidade do imageamento gerado por meio do algoritmo RTM com o n\u00edvel de ru\u00eddo introduzido com a precis\u00e3o num\u00e9rica adotada em sua execu\u00e7\u00e3o.\nAs Figuras 4.9, 4.10, 4.11, 4.12 e 4.13 relacionam os valores encontrados com am\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para cada um dos modelos avaliados.\nFigura 4.9: Valores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o modelo 1\nFigura 4.10: Valores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o modelo 3\nFigura 4.11: Valores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o modelo 4\nFigura 4.12: Valores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o modelo 5\nFigura 4.13: Valores encontrados com a m\u00e9trica UQI em compara\u00e7\u00e3o com o SNR para o modelo de Marmousi\n4.1.2\tDiscuss\u00e3o dos resultados\nCom base na an\u00e1lise da qualidade das imagens geradas, verifica-se que a metodologia desenvolvida neste trabalho foi capaz de predizer, com uma margem de seguran\u00e7a entre 1e 2 bits, a precis\u00e3o num\u00e9rica a partir da qual as imagens podem ser consideradas como aceit\u00e1veis. A Tabela 4.2 permite fazer uma compara\u00e7\u00e3o entre as precis\u00f5es num\u00e9ricas preditas e as precis\u00f5es num\u00e9ricas a partir das quais as imagens geradas passam a permitir a identifica\u00e7\u00e3o de todas as camadas em subsuperf\u00edcie.\nTabela 4.2: Compara\u00e7\u00e3o entre as precis\u00f5es num\u00e9ricas preditas e as precis\u00f5es num\u00e9ricas\nencontradas\nModelo\tPrecis\u00e3o predita (N\u00b0deBits)\tPrecis\u00e3o encontrada (N\u00b0deBits)\nModelo 1\t21\t20\nModelo 3\t20\t19\nModelo 4\t21\t19\nModelo 5\t21\t19\nMarmousi\t22\t20\nOutro ponto a destacar nos resultados obtidos \u00e9 quanto \u00e0 sensibilidade do algoritmo RTM em rela\u00e7\u00e3o ao n\u00edvel de ru\u00eddo gerado com o processamento.\nObserva-se por meio dos gr\u00e1ficos das Figuras 4.9, 4.10, 4.11,4.12e4.13,em compara\u00e7\u00e3o com as precis\u00f5es registradas na Tabela 4.2, que todas as imagens geradas com uma rela\u00e7\u00e3o sinal-ru\u00eddo melhor que 20 dB, al\u00e9m de permitirem uma identifica\u00e7\u00e3o clara e precisa de todas camadas em subsuperf\u00edcie, n\u00e3o apresentam artefatos que posam levar a uma m\u00e1 interpreta\u00e7\u00e3o das estrtuturas ali existentes. Essa informa\u00e7\u00e3o \u00e9 importante porque permite estabelecer um limiar de\nseguran\u00e7a para o n\u00edvel de ru\u00eddo que pode ser introduzido durante a execu\u00e7\u00e3o do algoritmo RTM sem que seja comprometida a qualidade do imagemaneto gerado .\n4.2\tDesenvolvimento do n\u00facleo de processamento aritm\u00e9tico\nO n\u00facleo de processamento aritm\u00e9tico desenvolvido como parte deste estudo de caso, aqui denotado como Processing Element (PE)1, \u00e9 o m\u00f3dulo de hardware que implementa o operador de diferen\u00e7as finitas descrito por meio da equa\u00e7\u00e3o 2.3, que, para facilitar a leitura desta se\u00e7\u00e3o, se encontra transcrita a seguir.\nCi,j =absi x absj x\n(2Bijj + absi x absj x Velfj x fat x\n(16 x (Bi,j+1 + Bi,j\u20141 + Bi+1,j + Bi\u20141,j)\n\u2014\t1 x (Bi,j+2 + Bi,j\u20142 + Bi+2,j + Bi\u20142,j)\n-\t60 x Bij\n) - AiJ\n)\nPara fins de avalia\u00e7\u00e3o do custo de implementa\u00e7\u00e3o em hardware e da qualidade do imageamento gerado, foi necess\u00e1rio implementar tr\u00eas vers\u00f5es do PE.\nA primeira vers\u00e3o, baseada na aritm\u00e9tica de ponto-flutuante, foi constru\u00edda utilizando m\u00f3dulos de hardware gerados automaticamente por meio da ferramenta Quartus II (ALTERA, 2014). Essa vers\u00e3o foi implementada utilizando o tipo de dado shortreal2 da linguagem System Verilog (IEEE, 2013), por esse motivo, denominada PE-Float Altera.\nA segunda vers\u00e3o tamb\u00e9m foi baseada na aritm\u00e9tica de ponto-flutuante. Entretanto, diferentemente da primeira vers\u00e3o, nessa os operadores aritm\u00e9ticos de ponto-flutuante utilizados foram implementados por meio do tipo de dado logic e dos operadores l\u00f3gicos e aritm\u00e9ticos para inteiros dispon\u00edveis na linguagem System Verilog. Essa vers\u00e3o foi denominada PE-Float.\nA terceira vers\u00e3o foi baseada na aritm\u00e9tica de ponto-fixo. Essa vers\u00e3o tamb\u00e9m foi implementada por meio do tipo de dado logic e dos operadores l\u00f3gicos e aritm\u00e9ticos para inteiros dispon\u00edveis na linguagem System Verilog. Essa \u00faltima vers\u00e3o recebeu a denomina\u00e7\u00e3o de PE-Fixo.\nA plataforma para a qual esse n\u00facleo de processamento foi desenvolvido faz parte de um projeto de pesquisa mais amplo, conveniado entre o Centro de Inform\u00e1tica da UFPE e o Centro de Pesquisa e Desenvolvimento da Petrobras (CENPES), e teve como requisito de valida\u00e7\u00e3o o\n1 PE \u00e9 a abrevia\u00e7\u00e3o da express\u00e3o inglesa Process Element, utilizada neste contexto com o significado de elemento ou n\u00facleo de processamento.\n2O tipo de dado shortreal implementa o ponto-flutuante de precis\u00e3o simples na linguagem SystemVerilog. Ele equivale ao tipo de dado float da linguagem C.\nimageamento do modelo geol\u00f3gico de Marmousi (MARTIN; WILEY; MARFURT, 2006).\n4.3\tProjeto dos n\u00facleos de processamento baseados em aritm\u00e9tica de ponto-flutuante\nO fluxo de projeto do PE-Float Altera foi extremamente simples. Por ter sido constru\u00eddo diretamente por meio do tipo de dado shortreal, o seu fluxo de projeto consistiu basicamente em um arquivo na linguagem System Verilog, no qual as v\u00e1rias opera\u00e7\u00f5es aritm\u00e9ticas existentes no n\u00facleo de processamento foram mapeadas e interconectadas conforme apresentado na Figura 4.14 a seguir.\nComo toda a estrutura dos m\u00f3dulos aritm\u00e9ticos foi gerada automaticamente pelo Quartus II, com total garantia de compatibilidade com o que estabelece o padr\u00e3o IEEE-754, a sua\nvalida\u00e7\u00e3o exigiu apenas uma sequ\u00eancia de testes a fim de garantir o mapeamento das conex\u00f5es existentes entre esses m\u00f3dulos.\nO fluxo de projeto do PE-Float, por outro lado, exigiu um grande esfor\u00e7o, tanto para ser implementado, quanto para ser validado. Apesar da linguagem System Verilog dispor de suporte ao tipo de dados de ponto-flutuante, atrav\u00e9s do tipo real, na pr\u00e1tica os m\u00f3dulos de hardware gerados com esta abordagem n\u00e3o s\u00e3o uma boa op\u00e7\u00e3o para o desenvolvimento de m\u00f3dulos de processamento de alto desempenho, isso porque, \u00e0 semelhan\u00e7a dos m\u00f3dulos gerados pelo Quartus II, cada opera\u00e7\u00e3o aritm\u00e9tica utilizada no PE ser\u00e1 instanciada como um m\u00f3dulo aritm\u00e9tico completo, com diversas estruturas redundantes e que acabam tendo um impacto muito negativo no processo de otimiza\u00e7\u00e3o do PE.\nDessa forma, a fim de atingir maior desempenho com menor custo de implementa\u00e7\u00e3o em hardware, o PE-Float foi desenvolvido dentro de uma metodologia denominada Fused Data Path3 (BERKELEY DESIG TECHNOLOGY INC, 2012). Nessa metodologia m\u00faltiplas opera\u00e7\u00f5es de ponto-flutuante s\u00e3o implementadas como se formassem uma \u00fanica opera\u00e7\u00e3o com m\u00faltiplos argumentos, com uma s\u00f3 etapa de desempacotamento dos dados no in\u00edcio da primeira opera\u00e7\u00e3o e uma s\u00f3 etapa de normaliza\u00e7\u00e3o e arredondamento ao t\u00e9rmino da \u00faltima opera\u00e7\u00e3o.\nDesse modo, foi poss\u00edvel obter uma economia de aproximadamente 95% no hardware destinado ao arredondamento e \u00e0 normaliza\u00e7\u00e3o dos resultados.\nPara simplificar esse processo, dividiu-se o projeto em v\u00e1rios m\u00f3dulos de hardware menores, organizados por meio das opera\u00e7\u00f5es aritm\u00e9ticas constantes no operador de diferen\u00e7as finitas em uma estrutura que pode ser vista na Figura 4.15.\n3Fused Data Path foi uma designa\u00e7\u00e3o criada para definir uma metodologia que prop\u00f5e que m\u00faltiplas opera\u00e7\u00f5es aritm\u00e9ticas de ponto-flutuante sejam vistas como uma \u00fanica opera\u00e7\u00e3o, na forma de um \u00fanico caminho de dados.\nFigura 4.15: Estrutura interna utilizada na implementa\u00e7\u00e3o do PE-Float.\n\t\t\n\tMultiplica_Abs_1\t\n\t\t\t\n\u2014\t\t\u2014\n\tSoma_2Bij_NS\t\n\t\t\t\t/\nUma vez que cada um dos m\u00f3dulos presentes nessa estrutura foi inteiramente descrito atrav\u00e9s da linguagem System Verilog, foi necess\u00e1rio test\u00e1-los e valid\u00e1-los individualmente contra um modelo de refer\u00eancia implementado na linguagem C++.\nO uso da metodologia Fused Data Path exigiu um cuidado especial de modo a garantir que n\u00e3o ocorressem perdas de precis\u00e3o nos resultados obtidos com o PE-Float. O projeto de hardware de cada um dos seus m\u00f3dulos internos teve de ser feito de modo a operar e a propagar de maneira exata os resultados provenientes dos m\u00f3dulos anteriores. No padr\u00e3o IEEE 754, esse modo de opera\u00e7\u00e3o \u00e9 denominado opera\u00e7\u00e3o em precis\u00e3o infinita (P754, 1985).\nA seguir, ser\u00e3o descritas as funcionalidades e os detalhes de implementa\u00e7\u00e3o de cada um dos m\u00f3dulos que formam o PE-Float.\n4.3.1\tM\u00f3dulo Multiplica 2Bij\nEsse m\u00f3dulo \u00e9 respons\u00e1vel ao mesmo tempo por converter o valor de Bi,j do padr\u00e3o de ponto-flutuante para ponto-fixo, e por multiplicar o valor convertido por dois. Sua estrutura interna pode ser vista na Figura 4.16 a seguir.\nFigura 4.16: Estrutura interna do m\u00f3dulo Multiplica_2Bij.\nO m\u00f3dulo Desnormalizador \u00e9 respons\u00e1vel por gerar uma vers\u00e3o em ponto-fixo, da magnitude de 2 x B,.j. Primeiramente \u00e9 efetuada a reconstru\u00e7\u00e3o do significando de Bi,j, por meio da recupera\u00e7\u00e3o do bit impl\u00edcito da sua mantissa. Em seguida, efetua-se um ajuste no significando recuperado, de forma que esse passe a representar o dobro da magnitude de B,.j no padr\u00e3o de ponto-fixo. Esse ajuste \u00e9 feito por meio de deslocamentos sucessivos do conte\u00fado do significando. A quantidade e a dire\u00e7\u00e3o desses deslocamentos \u00e9 calculada por meio da express\u00e3o\nnShift = Exp - BIAS - PRECISAO_OPERANDOS + 1,\nem que: nShift representa o n\u00famero de vezes e o sentido dos deslocamentos a serem aplicados no significando de B,.j; BIAS \u00e9 o valor de refer\u00eancia para a representa\u00e7\u00e3o do campo expoente em ponto-flutuante; Exp \u00e9 o valor representado atrav\u00e9s do campo Expoente. PRECISAO_OPERANDOS \u00e9 a constante de configura\u00e7\u00e3o que determina a precis\u00e3o com que a amplitude de press\u00e3o da frente de onda \u00e9 representada e a constante +1 representa a multiplica\u00e7\u00e3o do significando por 2.\nQuando nShift \u00e9 positivo, o significando \u00e9 deslocado nShift vezes para a esquerda e, quando nShift \u00e9 negativo, o significando \u00e9 deslocado nShift vezes para a direita.\nNa segunda etapa do processo de convers\u00e3o, o significando, assim obtido, \u00e9 ent\u00e3o convertido do modo de sinal-magnitude para o modo de complemento a dois.\n4.3.2\tM\u00f3dulo Absi_Absj\nEsse m\u00f3dulo \u00e9 respons\u00e1vel por efetuar a multiplica\u00e7\u00e3o das constantes de absor\u00e7\u00e3o de bordas, utilizadas para modelar o meio semi-infinito. Sua estrutura interna pode ser vista na Figura 4.17.\nNesse m\u00f3dulo, \u00e0 semelhan\u00e7a do m\u00f3dulo anterior, a primeira parte da opera\u00e7\u00e3o consiste na convers\u00e3o dos operandos do formato de ponto-flutuante para o formato de ponto-fixo, o que \u00e9 feito por meio dos m\u00f3dulos desnormalizadores. Em seguida, os significandos obtidos s\u00e3o multiplicados entre si. Por fim, o resultado obtido \u00e9 arredondado para a precis\u00e3o estabelecida\npara a representa\u00e7\u00e3o das constantes de absor\u00e7\u00e3o das bordas.\nFigura 4.17: Estrutura interna do m\u00f3dulo Absi_Absj.\n4.3.3\tM\u00f3dulo Menos_Aij\nEste m\u00f3dulo converte o valor de Ai, j de ponto-flutuante para ponto-fixo, ao mesmo tempo em que o multiplica por -1. Sua estrutura interna est\u00e1 ilustrada na Figura 4.18.\nA primeira parte da opera\u00e7\u00e3o consiste na convers\u00e3o dos operandos do formato de ponto-flutuante para o formato de ponto-fixo. Em seguida, obt\u00e9m-se o negativo do valor de Ai,j pela invers\u00e3o do sinal de Ai,j no momento da convers\u00e3o do significando para o formato de complemento a dois.\nFigura 4.18: Estrutura interna do m\u00f3dulo Menos_Aij.\n4.3.4\tM\u00f3dulo Vel_Vel_Fat\nEste m\u00f3dulo efetua a opera\u00e7\u00e3o Veli, j x Veli, j x FAT. Sua estrutura interna pode ser vista\nna Figura 4.26.\nSeu funcionamento \u00e9 muito parecido com o funcionamento do m\u00f3dulo Absi_Absj. O \u00fanico destaque \u00e9 a opera\u00e7\u00e3o de elevar Vel ao quadrado, que \u00e9 feita simplesmente multiplicando-se seu valor j\u00e1 desnormalizado por ele mesmo.\nFigura 4.19: Estrutura interna do m\u00f3dulo Vel_Vel_Fat.\n4.3.5\tM\u00f3dulo N\u00facleo_Soma\nEste m\u00f3dulo \u00e9 respons\u00e1vel por efetuar a opera\u00e7\u00e3o\n16 X\t+ Bi-1,j + Bi,j+1 +\t\u2014 1 x (Bi+2,j + Bi-2,j + Bi,j+2 + Bi,j\u20142) \u2014 60 X Bi,j.\nPara simplificar sua implementa\u00e7\u00e3o, esse m\u00f3dulo foi dividido em tr\u00eas m\u00f3dulos menores denominados M16Soma, MISoma e M60, conforme indicado na Figura 4.20.\nFigura 4.20: Estrutura interna do m\u00f3dulo N\u00facleo Soma.\nA estrutura interna de cada um desses m\u00f3dulos pode ser vista respectivamente nas Figuras\n4.21, 4.22 e 4.23.\nFigura 4.21: Estrutura interna do m\u00f3dulo M16Soma.\nFigura 4.22: Estrutura interna do m\u00f3dulo MISoma.\n60*5,\nFigura 4.23: Estrutura interna do m\u00f3dulo M60.\nA exemplo dos m\u00f3dulos anteriores, a primeira etapa de funcionamento desses m\u00f3dulos \u00e9 a convers\u00e3o dos operandos do formato de ponto-flutuante para o formato de ponto-fixo, o que \u00e9 feito por interm\u00e9dio dos m\u00f3dulos conversores. A estrutura interna desse m\u00f3dulos pode ser vista na Figura 4.24.\nMantissa\nPonto-Flutuante\nDesnormalizador\nComplemento a Dois\nPonto-Fixo\nPRECISAO_OPERA\u00c7\u00c3d\nI\nFigura 4.24: Estrutura interna do m\u00f3dulo Conversor.\nO funcionamento de cada m\u00f3dulo conversor \u00e9 id\u00eantico ao que j\u00e1 foi apresentado para a primeira etapa de opera\u00e7\u00e3o dos outros m\u00f3dulos. Ou seja, cada m\u00f3dulo conversor recebe, al\u00e9m do operando a ser convertido, uma constante com a precis\u00e3o a ser utilizada na convers\u00e3o do operando do padr\u00e3o de ponto-flutuante para ponto-fixo.\nPara o m\u00f3dulo M60, a precis\u00e3o de opera\u00e7\u00e3o fornecida ao m\u00f3dulo conversor \u00e9 de 23 bits.\nJ\u00e1 para os m\u00f3dulos M16Soma e MISoma, a precis\u00e3o de opera\u00e7\u00e3o \u00e9 definida com base no expoente do operando de maior magnitude dos quatro que s\u00e3o fornecidos a cada um desses m\u00f3dulos. Essa compara\u00e7\u00e3o \u00e9 feita por um m\u00f3dulo que compara simultaneamente os expoentes dos quatro operandos, conforme ilustrado na Figura 4.25, retornando o maior dentre eles.\nExp.1 Exp.2 Exp.3 Exp.4\nJlA\nComparador\nI\nExpoente Opera\u00e7\u00e3o\nFigura 4.25: Estrutura interna do m\u00f3dulo Comparador.\nA fim de permitir ainda maior economia de hardware, as opera\u00e7\u00f5es de multiplica\u00e7\u00e3o por 16, -1 e -60 da equa\u00e7\u00e3o 2.3 foram aqui substitu\u00eddas por opera\u00e7\u00f5es mais simples, que dispensam o uso de blocos multiplicadores em hardware.\nNo M\u00f3dulo M16Soma, conforme se pode observar na \u00faltima parte da Figura 4.21, a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o por 16 foi substitu\u00edda pela inclus\u00e3o de quatro zeros \u00e0 direita do resultado obtido pela soma dos operandos.\nNo M\u00f3dulo M1Soma, a multiplica\u00e7\u00e3o por menos um foi substitu\u00edda pela subtra\u00e7\u00e3o do resultado obtido de zero, conforme indicado na \u00faltima parte da Figura 4.22.\nNo M\u00f3dulo M60, a multiplica\u00e7\u00e3o por 60 foi substitu\u00edda pela multiplica\u00e7\u00e3o do operando Bi, j ao mesmo tempo por 64, pela inclus\u00e3o de 6 zeros \u00e0 direta do valor convertido para ponto-fixo, e por 4, pela inclus\u00e3o de 2 zeros. Os valores assim obtidos s\u00e3o ent\u00e3o subtra\u00eddos um do outro dando como resultado o valor correto de 60 x Bi,j, conforme indicado na Figura 4.23.\n4.3.6\tM\u00f3dulo Multiplica_V2FAT_NS\nEste m\u00f3dulo multiplica o resultado obtido no m\u00f3dulo N\u00facleo_Soma com o resultado obtido no m\u00f3dulo em Vel_Vel_Fat, arredondando o resultado final para a precis\u00e3o definida para essa opera\u00e7\u00e3o.\n4\t\n\t<\tX Conv. Mag. Sinal&lt;\t\tJ\nFigura 4.26: Estrutura interna do m\u00f3dulo Multiplica_V2FAT_NS.\n4.3.7\tM\u00f3dulo Soma_MAij_V2FAT_NS\nEste m\u00f3dulo efetua a adi\u00e7\u00e3o do resultado obtido no m\u00f3dulo Multiplica_V2FAT_NS com o resultado obtido no m\u00f3dulo Menos_Aij, propagando o resultado obtido, com precis\u00e3o infinita, para o m\u00f3dulo seguinte.\nMenos_Aij Multiplica_V2FAT_NS\nV\nMAij_V2FAT_NS\nFigura 4.27: Estrutura interna do m\u00f3dulo Soma_MAij_V2FAT_NS.\n4.3.8\tM\u00f3dulos Multiplica_ABS_1 e Multiplica_ABS_2.\nOs m\u00f3dulos Multiplica_ABS_1 e Multiplica_ABS_2 t\u00eam um mesmo hardware interno, que pode ser visto na Figura 4.28.\nResultado de Maij V2FAT NS\nVel2FAT_NS\nFigura 4.28: Estrutura interna dos m\u00f3dulos Multiplica_ABS_1 e Multiplica_ABS_2.\nO destaque nesses m\u00f3dulos \u00e9 a convers\u00e3o da representa\u00e7\u00e3o de complemento a dois para magnitude e sinal antes da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o, e o retorno para a representa\u00e7\u00e3o em complemento a dois ap\u00f3s a opera\u00e7\u00e3o. Essa convers\u00e3o faz-se necess\u00e1ria a fim de simplificar o hardware que efetua a multiplica\u00e7\u00e3o. Propaga-se o resultado obtido para o m\u00f3dulo seguinte com precis\u00e3o infinita.\n4.3.9\tM\u00f3dulo Soma_2Bij_NS\nEste m\u00f3dulo efetua a adi\u00e7\u00e3o do resultado obtido no m\u00f3dulo Multiplica_2Bij com o resultado obtido no m\u00f3dulo Multiplica_Abs1, propagando o resultado obtido para o m\u00f3dulo seguinte. Sua estrutura interna encontra-se na Figura 4.29.\nMulriplica_2Bij Multiplica_Abs_1\n2Bij_NS\nFigura 4.29: Estrutura interna do m\u00f3dulo Soma_2Bij_NS.\n4.3.10\tM\u00f3dulo Normaliza e Arredonda\nEste m\u00f3dulo \u00e9 respons\u00e1vel por converter o valor final do operador de diferen\u00e7as finitas do padr\u00e3o de ponto-fixo para o padr\u00e3o de ponto-flutuante.\nNormaliza\nNSHIFT\n\u00e7-------------\nAnaliza_Norm\nL_____________\nMultiplica_Abs_2\n, r\n- Conv_Mag_Sig\nl/\n\u2022\t\u25a0\n\t\t1 Arredonda \t\t\n\t\nMantissa\nFigura 4.30: Estrutura interna do m\u00f3dulo que normaliza e arredonda os resultados.\nA primeira etapa do processo de convers\u00e3o consiste em primeiramente converter o valor recebido do modo de complemento a dois para o modo de magnitude e sinal. Em seguida, coloca-se o valor convertido no formato normalizado. Para tanto, analisa-se o seu conte\u00fado para verificar quantas vezes ser\u00e1 necess\u00e1rio desloc\u00e1-lo para a direita ou para a esquerda at\u00e9 que sua parte inteira fique igual a 1. Essa an\u00e1lise \u00e9 feita pelo m\u00f3dulo Analiza_Norm da Figura 4.30. O resultado obtido dessa an\u00e1lise, NSHIFT, assume valores positivos para indicar a necessidade de deslocamentos \u00e0 direita e valores negativos para deslocamentos \u00e0 esquerda. NSHIFT \u00e9 utilizado ao mesmo tempo tanto para efetuar a normaliza\u00e7\u00e3o quanto como base ao c\u00e1lculo do valor do campo expoente.\nO resultado obtido ap\u00f3s a normaliza\u00e7\u00e3o \u00e9 ent\u00e3o arredondado para 23 bits de precis\u00e3o.\nNesse projeto, a fim tornar a implementa\u00e7\u00e3o desse m\u00f3dulo mais simples em hardware, adotou-se o arredondamento para mais pr\u00f3ximo ou mais infinito no lugar do arredondamento para mais pr\u00f3ximo ou par.\nO arredondamento para mais pr\u00f3ximo ou mais infinito arredonda o valor obtido para o n\u00famero represent\u00e1vel mais pr\u00f3ximo ou, em havendo empate, para o primeiro n\u00famero represent\u00e1vel de maior magnitude que o n\u00famero a ser arredondado.\nDessa forma, a implementa\u00e7\u00e3o do m\u00f3dulo arredondador da Figura 4.30 consistiu simplesmente em somar o vig\u00e9simo quarto bit \u00e0 direita do ponto decimal do valor normalizado \u00e0 palavra bin\u00e1ria formada at\u00e9 essa posi\u00e7\u00e3o, desprezando todos os bits que est\u00e3o al\u00e9m desse.\n4.4\tProjetos dos n\u00facleos de processamento baseados em aritm\u00e9tica de ponto-fixo\nA implementa\u00e7\u00e3o do n\u00facleo de processamento baseado no padr\u00e3o de ponto-fixo, denominado PE-Fixo, foi estruturada conforme apresentado na Figura 4.31.\nFigura 4.31: Estrutura interna do m\u00f3dulo de hardware que implementa o n\u00facleo de processamento 2D no padr\u00e3o de ponto-fixo.\nObserva-se que, \u00e0 exce\u00e7\u00e3o da aus\u00eancia do M\u00f3dulo de Normaliza\u00e7\u00e3o e Arre\n5\nConclus\u00f5es e trabalhos futuros\nOs resultados obtidos por meio dos experimentos de valida\u00e7\u00e3o apresentados no Cap\u00edtulo 3, bem como o estudo de caso real apresentado no Cap\u00edtulo 4 permitem concluir que este trabalho atingiu seus objetivos. Sua aplica\u00e7\u00e3o tornou poss\u00edvel verificar a sua hip\u00f3tese inicial e estabelecer que:\nA defini\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria ao processamento de dados s\u00edsmicos por meio do algoritmo RTM est\u00e1 diretamente ligada \u00e0s litologias das camadas em subsuperf\u00edcie.\nOu seja, por meio dos resultados obtidos neste trabalho, pode-se afirmar que a precis\u00e3o num\u00e9rica necess\u00e1ria para a execu\u00e7\u00e3o do algoritmo RTM n\u00e3o pode ser estabelecida unicamente pela an\u00e1lise do imageamento gerado por meio de um modelo geol\u00f3gico de refer\u00eancia, a exemplo do que se verificou em todos os trabalhos pesquisados (HE; LU; SUN, 2004; ARAYA-POLO et al., 2011; CLAPP; FU; LINDTJORN, 2010; FU et al., 2008, 2009; HE; ZHAO; LU, 2005a,b; PELL et al., 2013; BARROS et al., 2011; BRAGAN\u00e7A et al., 2013; MEDEIROS et al., 2013). A n\u00e3o ser que esse modelo seja compat\u00edvel com as litologias que se espera encontrar na regi\u00e3o a ser imageada.\nPara chegar a esses resultados, foi desenvida uma metodologia in\u00e9dita que permite determinar de maneira autom\u00e1tica, por meio de um programa de computador, qual a precis\u00e3o num\u00e9rica necess\u00e1ria \u00e0 execu\u00e7\u00e3o do algoritmo RTM de acordo com as caracter\u00edsticas do meio a ser imageado.\nVale resslatar que essa metodologia foi baseada em um m\u00e9todo anal\u00edtico in\u00e9dito, tamb\u00e9m desenvolvido neste trabalho.\nUma outra contribui\u00e7\u00e3o original deste trabalho, o conceito do raio efetivo, definido pela Equa\u00e7\u00e3o 3.26, transcrita a seguir:\nrE (fiz) = \u00a3 V x (i - hi)\npermite modelar de maneira eficiente a atenua\u00e7\u00e3o por diverg\u00eancia da frente de onda em modelos geol\u00f3gicos com diversas camadas.\nSua utiliza\u00e7\u00e3o tornou-se elemento-chave no processo da predi\u00e7\u00e3o da atenua\u00e7\u00e3o sofrida pelas ondas s\u00edsmicas durante a execu\u00e7\u00e3o do algoritmo RTM, uma vez que permitiu o c\u00e1lculo em separado das atenua\u00e7\u00f5es em raz\u00e3o da diverg\u00eancia da frente de onda e das configura\u00e7\u00f5es litol\u00f3gicas das camadas em subsuperf\u00edcie.\nAt\u00e9 onde foi poss\u00edvel investigar, esta foi tamb\u00e9m uma abordagem original, n\u00e3o tendo sido encontrada em nenhuma das fontes consultadas, sendo, por conseguinte, uma contribui\u00e7\u00e3o importante deste trabalho para esta \u00e1rea de pesquisa.\nOutro ponto a ser destacado foi a abordagem utilizada na predi\u00e7\u00e3o das amplitudes das ondas transmitidas entre as camadas em subsuperf\u00edcie e na predi\u00e7\u00e3o das amplitudes com que essas ondas chegam \u00e0 superf\u00edcie ao t\u00e9rmino do processo de migra\u00e7\u00e3o, Equa\u00e7\u00f5es 3.30 e 3.31,\ntranscritas a seguir:\tA\t8Vn+1Vn \u201e A AT =(Vn -+Vn+ty X A\narm =\n1\nX\nVn+1 - Vn\nVn + Vn+1\nX AP\nVn\nV0+r\"-'\nFoi o estabelecimento dessas equa\u00e7\u00f5es que permitiu o desenvolvimento do algoritmo recursivo apresentado na Figura 3.22, o qual serviu de base \u00e0 implementa\u00e7\u00e3o da metodologia descrita neste trabalho.\nUma \u00faltima contribui\u00e7\u00e3o deste trabalho \u00e0 \u00e1rea do processamento s\u00edsmico diz respeito \u00e0 verifica\u00e7\u00e3o da sensibilidade do algoritmo RTM ao n\u00edvel de ru\u00eddo introduzido com o processamento dos dados. Evidenciou-se por meio dos experimentos realizados que \u00e9 necess\u00e1rio um SNR melhor que 20dB nas imagens geradas para que se obtenha um imageamento no qual todas as camadas em subsuperf\u00edcie sejam evidenciadas, o que corresponde a um UQI maior que 50%. Em todos os experimentos, esse limiar foi alcan\u00e7ado ao ser estabelecido um erro de representa\u00e7\u00e3o percentual menor ou igual a 1% para as amplitudes das ondas s\u00edsmicas ao fim do processo de migra\u00e7\u00e3o.\n5.1\tTrabalhos futuros\nA fim de dar continuidade a este trabalho, verifica-se a necessidade de que tanto o m\u00e9todo anal\u00edtico quanto a metodologia aqui desenvolvidos sejam estendidos de modo a incluir fen\u00f4menos f\u00edsicos dissipativos e de multipercurso.\n\u00c9 necess\u00e1rio tamb\u00e9m, que seja inclu\u00eddo no m\u00e9todo o c\u00e1lculo da rela\u00e7\u00e3o entre a amplitude da onda gerada pela inser\u00e7\u00e3o do pulso s\u00edsmico e a velocidade da camada em que esse se insere.\nOutro ponto importante ainda a ser trabalhado \u00e9 o desenvolvimento de uma segunda vers\u00e3o dessa metodologia, que permita trabalhar com modelos de tr\u00eas dimens\u00f5es, o que envolver\u00e1 a adapta\u00e7\u00e3o das Equa\u00e7\u00f5es 3.30 e 3.31 para trabalhar em duas e tr\u00eas dimens\u00f5es.\nDeve-se verificar tamb\u00e9m a aplicabilidade dessa metodologia para a predi\u00e7\u00e3o da precis\u00e3o num\u00e9rica necess\u00e1ria \u00e0 execu\u00e7\u00e3o de outros algoritmos de imageamento s\u00edsmico.\nPode ser investigado ainda a aplicabilidade do conceito do raio efetivo como instrumento na gera\u00e7\u00e3o ou valida\u00e7\u00e3o de modelo de velocidades do meio criados a partir de sismogramas reais capturados em campo. Em uma an\u00e1lise preliminar, baseada nos resultados obtidos nos experimentos de valida\u00e7\u00e3o da metodologia, verificou-se que o conceito do raio efetivo pode vir a se constituir um bom indicador da rela\u00e7\u00e3o entre as velocidades de propaga\u00e7\u00e3o da primeira camada e das demais camadas do meio, uma vez que apenas quando esta rela\u00e7\u00e3o est\u00e1 correta \u00e9 poss\u00edvel alcan\u00e7ar o cancelamento total da atenua\u00e7\u00e3o por diverg\u00eancia, o que pode ser facilmente verificado por meio dos gr\u00e1ficos gerados.\nPor fim, \u00e9 necess\u00e1rio que o algoritmo recursivo seja estendido a fim de poder receber como entrada arquivos com modelos de velocidade nos formatos su (CWP-SU, 2012) e segy (BARRY; CAVERS; KNEALE, 1975). Atualmente esse algoritmo trabalha apenas com modelos de velocidade representado por meio de arquivos bin\u00e1rios planos, sem formata\u00e7\u00e3o, ou ainda atrav\u00e9s de modelos de velocidade descritos manualmente pelo usu\u00e1rio.\nRefer\u00eancias\nABREO, S. et al. Alternative computing platforms to implement the seismic migration. In: GOMES, J. S. (Ed.). New technologies in the oil and gas industry. New York: Intech, 2012. p. 83-102.\nALTERA. QuartusII. Acessado em 1 fev. 2014, Dispon\u00edvel em:&lt;http://dl.altera.com/?edition=subscription>.\nANDRAKA, R. A survey of CORDIC algorithms for FPGA based computers. In: ACM/SIGDA SIXTH INTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS,\n1998.,\tMonterey. Proceedings... ACM, 1998. p. 191-200.\nARAYA-POLO, M. et al. Assessing accelerator-based HPC reverse time migration. IEEE Transactions on Parallel and Distributed Systems, [S.l.], v. 22, n. 1, p. 147-162, Jan 2011.\nBARROS, A. C. Implementa\u00e7\u00e3o em FPGA de um m\u00f3dulo multiplicador e acumulador aritm\u00e9tico de alto desempenho para n\u00famero em ponto flutuante de precis\u00e3o dupla, padr\u00e3o IEEE 754. 2008. Disserta\u00e7\u00e3o de Mestrado \u2014 Maste\u2019s thesis, CIn-UFPE. Universidade Federal De Pernambuco, Recife, Pernambuco.\nBARROS, A. C. et al. Implementation of a double-precision multiplier accumulator with exception treatment to a dense matrix multiplier module in FPGA. In: ANNUAL SYMPOSIUM ON INTEGRATED CIRCUITS AND SYSTEM DESIGN - SBCCI \u201908, 21., New York, New York, USA. Proceedings... ACM Press, 2008. p. 40-45.\nBARROS, A. C. et al. Performance evaluation model based on precision reduction and FPGAs applied to seismic modeling. In: SIMP\u00d3SIO EM SISTEMAS COMPUTACIONAIS (WSCAD-SSC),, Petr\u00f3polis, RJ. New York. Proceedings... IEEE, 2011. p. 2-2.\nBARRY, R. M.; CAVERS, D. A.; KNEALE, C. W. Recommended standards for digital tape formats: geophysics. Geophysics, [S.l.], v. 40, n. 2, p. 344-352, Apr. 1975.\nBAYSAL, E.; KOSLOFF, D. D.; SHERWOOD, J. W. Reverse time migration. Rev Geophysics, [S.l.], v. 48, n. 11, p. 1514-1524, 1983.\nBERKELEY DESIG TECHNOLOGY INC, S. of. An Independent Analysis of Altera's FPGA Floating-Point DSP Design Flow. [S.l.]: Berkeley Design Technology, 2012.\nBOORE, D. M. Finite difference methods for seismic wave propagation in heterogeneous materials. In: BOLT, B. A.; ALDER, B. J.; FERNBACH, S. (Ed.). Methods in computational physics: advances in research and applications. New York: Academic Press, 1972. v. 11, p.\n1-37.\nBRAGAN\u00e7A, R. et al. Seismic Modeling and RTM Migration on unconventional Hardware. In: INTERNATIONAL CONGRESS OF BRAZILIAN GEOPHYSICAL SOCIETY &amp; EXPOGEF,\n13.,\tRio de Janeiro. Proceedings... [S.l.: s.n.], 2013.\nBULC\u00e3O, A. Modelagem e migra\u00e7\u00e3o reversa no tempo empregando operadores el\u00e1sticos e ac\u00fasticos. 2004. Tese de Doutorado \u2014 Instituto Alberto Luiz Coimbra de P\u00f3s-Gradua\u00e7\u00e3o e Pesquisa de Engenharia, Coppe UFRJ. Rio de Janeiro.\nCHEN, P et al. Acceleration of the long read mapping on a PC-FPGA architecture (abstract only). In: ACM/SIGDA INTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS, New York, NY, USA. Proceedings... ACM, 2013. p. 271-271. (FPGA \u201913).\nCLAPP, R. G.; FU, H.; LINDTJORN, O. Selecting the right hardware for reverse time migration. The Leading Edge, [S.l.], v. 29, n. 1, p. 48-58, 2010.\nConvey Computer. The HC Series. Acessado em 20 nov. 2013, Dispon\u00edvel em:&lt;http://www.conveycomputer.com/products/hcseries/>.\nCWP-SU. Programs. Acessado em 14 fev. 2014, Dispon\u00edvel em:&lt;http://www.seismicunix.com/wZPrograms>.\nDANDASS, Y. et al. Accelerating string set matching in FPGA hardware for bioinformatics research. BMC bioinformatics, [S.l.], v. 9, n. 197, p. 1-11, Apr 2008.\nDIMOND, R.; RACANI\u00e8RE, S.; PELL, O. Accelerating Large-Scale HPC Applications Using FPGAs. T\u00fcbingen, Germany: IEEE, 2011. 191-192p. .\nDOMINGOS, L. C. G. Breve Hist\u00f3ria do Petr\u00f3leo. Acessado em 31 out. 2013, Dispon\u00edvel em:&lt;http://histpetroleo.no.sapo.pt/index.htm>.\nDURHAM, L. S. Industry Always Enjoys Good Vibes. Acessado em 14 abr. 2013, Dispon\u00edvel em:&lt;http://www.aapg.org/explorer/2007/02feb/vibroseis.cfm>.\nEVEN, G.; PAUL, W. On the design of IEEE compliant floating point units. IEEE Transactions on Computers, [S.l.], v. 49, n. 7, p. 398-413, maio 2000.\nFAROOQ, U.; MARRAKCHI, Z.; MEHREZ, H. FPGA Architectures: an overview. In: Tree-based Heterogeneous FPGA Architectures: application specific exploration and optimization. New York, NY: Springer, 2012. p. 7-48.\nFLYNN, M. et al. Finding Speedup in Parallel Processors. In: INTERNATIONAL SYMPOSIUM ON PARALLEL AND DISTRIBUTED COMPUTING (ISPDC), 7., Krakow, Poland. Proceedings... [S.l.: s.n.], 2008. p. 3-7.\nFROHLICH, I. et al. Pattern recognition in the hades spectrometer: an application of fpga technology in nuclear and particle physics. In: IEEE INTERNATIONAL CONFERENCE ON FIELD-PROGRAMMABLE TECHNOLOGY, 2002., Hong Kong, China. New York. Proceedings... [S.l.: s.n.], 2002. p. 443-444.\nFU, H. Application-Specific Number Representation. 2009. Tese de Doutorado \u2014 Imperial College London Department of Computing Application-Specific.\nFU, H. et al. Accelerating seismic computations on FPGAs: from the perspective of number representations. In: EAGE CONFERENCE &amp; EXHIBITION, 70., Roma, Italia. Proceedings... [S.l.: s.n.], 2008.\nFU, H. et al. Accelerating seismic computations using customized number representations on FPGAs. EURASIP Journal on Embedded Systems, [S.l.], v. 2009, n. 3, p. 382983, Jan. 2009.\nG1. Entenda o que \u00e9 a camada de pr\u00e9-sal. Acessado em: 17 out. 2013, Dispon\u00edvel em:&lt;http://www.passeiweb.com/estudos/sala_de_aula/atualidades/ entenda_o_que_e_a_camada_de_pre-sal>.\nGIDEL. PROCe III: overview. Acessado em: 20 mar. 2014, Dispon\u00edvel em:&lt;http://www.gidel.com/PROCe%20III.htm>.\nGOLDBERG, D. What every computer scientist should know about floating-point arithmetic. ACM Computing Surveys (CSUR), [S.l.], v. 23, n. 1, p. 5-48, 1991.\nGOVINDU, G. et al. Analysis of high-performance floating-point arithmetic on FPGAs. In: INTERNATIONAL PARALLEL AND DISTRIBUTED PROCESSING SYMPOSIUM, 18., Santa Fe, New Mexico. Proceedings... IEEE, 2004. p. 149-157.\nGROBE, H. Airgun-array hg.png. Acessado em: 31 out. 2013, Dispon\u00edvel em:&lt;http://commons.wikimedia.org/wiki/File:\nAirgun-array_hg.png?uselang=pt-br>.\nGROSSER, T. et al. Exploiting Heterogeneous Computing Platforms By Cataloging Best Solutions For Resource Intensive Seismic Applications. In: INTENSIVE 2011. THE THIRD INTERNATIONAL CONFERENCE ON RESOURCE INTENSIVE APPLICATIONS AND SERVICES, Venice, Italia. Proceedings... [S.l.: s.n.], 2011. p. 30-6.\nGRULL, F. et al. Accelerating image analysis for localization microscopy with FPGAs. In: INTERNATIONAL CONFERENCE ON FIELD PROGRAMMABLE LOGIC AND APPLICATIONS (FPL), Chania, Crete, Greece. New York:. Proceedings... IEEE, 2011. p. 1-5.\nGUO, Z. et al. A Quantitative Analysis of the Speedup Factors of FPGAs over Processors. In: ACM/SIGDA 12TH INTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS, 2004., New York, NY, USA. Proceedings... ACM, 2004. p. 162-70. (FPGA \u201904).\nHE, C.; LU, M.; SUN, C. Accelerating seismic migration using FPGA-based coprocessor platform. In: ANNUAL IEEE SYMPOSIUM ON FIELD-PROGRAMMABLE CUSTOM COMPUTING MACHINES, FCCM 2004., 12., Napa, CA. New York. Proceedings... [S.l.: s.n.], 2004. p. 207-16.\nHE, C.; ZHAO, W.; LU, M. Time domain numerical simulation for transient waves on reconfigurable coprocessor platform. In: ANNUAL IEEE SYMPOSIUM ON FIELD-PROGRAMMABLE CUSTOM COMPUTING MACHINES, FCCM 2005., 13., Napa, CA. New York. Anais... IEEE, 2005. p. 127-36.\nHE, C.; ZHAO, W.; LU, M. FPGA-Based High-Order Finite Difference Algorithm for 2D Acoustic Wave Propagation Problems. In: ERSA 2005, Las Vegas, Nevada. Proceedings... CSREA Press, 2005. p. 267-73.\nHERBORDT, M. et al. Achieving High Performance with FPGA-Based Computing. Computer, [S.l.], v. 40, n. 3, p. 50-7, 2007.\nHUCKLE, T. Collection of Software Bugs. Acessado em: 19 maio 2014.\nIBM. Cell Broadband Engine. Acessado em 11 nov. 2013, Dispon\u00edvel em:&lt;https://www-01.ibm.com/chips/techlib/techlib.nsf/products/ Cell_Broadband_Engine>.\nIEEE. IEEE Standard for SystemVerilog-Unified Hardware Design, Specification, and\nVerification Language. IEEE Std 1800-2012 (Revision of IEEE Std 1800-2009), New York, v. .,p. 1-1315, Feb. 2013.\nJAMRO, E. et al. Computation acceleration on SGI RASC: fpga based reconfigurable computing hardware. Computer Science, [S.l.], v. 9, p. 21-34, 2008.\nKRUEGER, J. et al. Hardware/software co-design for energy-efficient seismic modeling. In: INTERNATIONAL CONFERENCE FOR HIGH PERFORMANCE COMPUTING, NETWORKING, STORAGE AND ANALYSIS, 2011., Seattle, WA. New York, NY.\nProceedings... ACM, 2011. p. 1-73.\nKULISCH, U. W.; MIRANKER, W. L. Computer Arithmetic in theory and pratice. [S.l.]: Academic Press, 1981. 1-249p..\nLINDTJORN, O. et al. Beyond traditional microprocessors for geoscience high-performance computing applications. Micro, IEEE, [S.l.], v. 31, n. 2, p. 41-9, Mar-Apr 2011.\nLIU, H.-W. et al. The Algorithm of High Order Finite Difference Pre-Stack Reverse Time Migration and GPU Implementation. Chinese Journal of Geophysics, [S.l.], v. 53, n. 4, p. 600-10, 2010.\nLIU, M. et al. System-on-an-FPGA Design for Real-time Particle Track Recognition and Reconstruction in Physics Experiments. In: EUROMICRO CONFERENCE ON DIGITAL SYSTEM DESIGN ARCHITECTURES, METHODS AND TOOLS (DSD\u201908), 11., Parma, Italy. New York. Proceedings... IEEE, 2008. p. 599-605.\nMARTIN, G. S.; WILEY, R.; MARFURT, K. J. Marmousi2: an elastic upgrade for marmousi. The Leading Edge, [S.l.], v. 25, n. 2, p. 156-66, 2006.\nMaxeler Tecnologies. Oil &amp; gas platforms. Acessado em: 25 nov. 2013., Dispon\u00edvel em:&lt;https://www.maxeler.com/solutions/oil-gas/>.\nMCMECHAN, G. A. Migration by extrapolation of time-dependent boundary values. Geophysical Prospecting, [S.l.], v. 31, n. 3, p. 413-20, 1983.\nMEDEIROS, V. et al. High Performance Implementation of RTM Seismic Modeling on FPGAs: architecture, arithmetic and power issues. In: VANDERBAUWHEDE, W.; BENKRID, K. (Ed.). High-Performance Computing Using FPGAs. New York: Springer, 2013. p. 305-34.\nMENCER, O.; MORF, M.; FLYNN, M. PAM-Blox: high performance fpga design for adaptive computing. In: IEEE SYMPOSIUM ON FPGAS FOR CUSTOM COMPUTING MACHINES, Napa Valley, CA. New York. Proceedings... IEEE, 1998. p. 167-74.\nMENEZES, G. et al. Energy Estimation Tool FPGA-based Approach for Petroleum Industry. In: INTERNATIONAL CONFERENCE ON PARALLEL PROCESSING WORKSHOPS (ICPPW), 2012, 41., Pittsburgh, PA. New York. Proceedings... [S.l.: s.n.], 2012. p. 600-1.\nNEMETH, T et al. Design space analysis for the acoustic wave equation implementation on FPGA circuits. In: EAGE CONFERENCE &amp; EXHIBITION, 70., Rome, Italy. Proceedings... [S.l.: s.n.], 2008.\nNEMETH, T. et al. An implementation of the acoustic wave equation on FPGAs. In: SEG TECHNICAL PROGRAM EXPANDED ABSTRACTS 2008. Anais... Society of Exploration Geophysicists, 2008. p. 2874-2878. (SEG Technical Program Expanded Abstracts).\nNIEMEYER, P. Os riscos do pr\u00e9-sal. O Estado de S. Paulo, S\u00e3o Paulo. Economia &amp; Neg\u00f3cios. Acessado em 27 out. 2013, Dispon\u00edvel em:&lt;http://www.estadao.com.br/ noticias/impresso, os-riscos-do-pre-sal, 670213, 0 .htm>.\nNVIDIA. Tesla C1060 computing processor board: board specification. Acessado em 20 nov. 2013, Dispon\u00edvel em:\n<www.nvidia.com/docs/IO/56483/Tesla_C1060_boardSpec_v03.pdf>.\nOCEANA. Seismic Airgun Testing: overview. Acessado em: 31 out. 2013, Dispon\u00edvel em:&lt;http://oceana.org/en/our-work/climate-energy/ seismic-airgun-testing/overview>.\nINSTITUTE, A. N. S. (Ed.). ANSI/IEEE 754-1985, Standard for Binary Floating-Point Arithmetic. [S.l.]: pub-IEEE-STD, 1985. 18p..\nPANETTA, J. et al. Computational characteristics of production seismic migration and its performance on novel processor architectures. In: INTERNATIONAL SYMPOSIUM ON COMPUTER ARCHITECTURE AND HIGH PERFORMANCE COMPUTING, 2007. SBAC-PAD 2007., 19. Proceedings... [S.l.: s.n.], 2007. p. 11- 8.\nPELL, O. Accelerating seismic processing applications with FPGAs. In: EAGE CONFERENCE &amp; EXHIBITION-WORKSHOPS AND FIELDTRIPS, 72., Barcelona, Spain. Proceedings... [S.l.: s.n.], 2010.\nPELL, O.; CLAPP, R. G. Accelerating subsurface offset gathers for 3D seismic applications using FPGAs. In: ANNUAL MEETING SOCIETY OF EXPLORATION GEOPHYSICISTS (SEG), 77., San Antonio, Texas. Proceedings... [S.l.: s.n.], 2007. p. 1839-43.\nPELL, O. et al. Finite-Difference Wave Propagation Modeling on Special-Purpose Dataflow Machines. IEEE Transactions on Parallel and Distributed Systems, [S.l.], v. 24, n. 5, p. 906-15, 2013.\nPETROBRAS. Atua\u00e7\u00e3o no pr\u00e9-sal. Acessado em 31 out. 2013, Dispon\u00edvel em:&lt;http://www.petrobras.com.br/pt/energia-e-tecnologia/ fontes-de-energia/petroleo/presal/>.\nQUACK, N.; KAKAQI, N.; FLYNN, M. On fast IEEE rounding: technical report csl-tr-91-459. Stanford, CA: Stanford University, 1991.\nROBERT E. SHERIFF, L. P. G. Exploration Seismology. 2a ed..ed. [S.l.]: Cambridge: Cambridge University Press;, 1995.\nSANTORO, M. R.; BEWICK, G.; HAROWITZ, M. A. Rounding Algorithm for IEEE multiplier. In: PROCEEDING OF 9TH SYMPOSIUM ON COMPUTER ARITHMETIC. Anais... Stanford University, 1989. p. 176-83.\nSANTOS, J. L. R. dos. Modelagem da equa\u00e7\u00e3o da onda ac\u00fastica aplicada ao imageamento de estruturas geol\u00f3gicas. 2012. Disserta\u00e7\u00e3o de Mestrado \u2014 Maste\u2019s thesis, Coppe UFRJ. Rio de Janeiro: Instituto Alberto Luiz Coimbra de P\u00f3s-Gradua\u00e7\u00e3o e Pesquisa de Engenharia.\nSCHRYVER, C. de et al. An energy efficient FPGA accelerator for Monte Carlo option pricing with the Heston model. In: INTERNATIONAL CONFERENCE ON RECONFIGURABLE COMPUTING AND FPGAS (RECONFIG), Canc\u00fan, Mexico. New York. Proceedings... IEEE, 2011. p. 468-74.\nSEVERANCE, C. Standards: IEEE 754: an interview with William Kahan. j-COMPUTER, [S.l.], v. 31, n. 3, p. 114-5, mar 1998.\nSOARES, P. Explora\u00e7\u00e3o do pr\u00e9-sal traz mais riscos. Folha de S. Paulo, S\u00e3o Paulo, 2012 mar. 25. Mercado. Acessado em: 27 out. 2013, Dispon\u00edvel em:\n<http://www1.folha.uol.com.br/mercado/ 1066916-exploracao-do-pre-sal-traz-mais-riscos.shtml>.\nVOSSEN, R. van; ROBERTSSON, J. O.; CHAPMAN, C. H. Finite-difference modeling of wave propagation in a fluid-solid configuration. Rev Geophys, [S.l.], v. 67, n. 2, p. 618-24, 2002.\nWANG, Z.; BOVIK, A. C. A universal image quality index. IEEE Signal Processing Letters, [S.l.], v. 9, n. 3, p. 81-4, Mar. 2002.\nWHITMORE, N. Iterative depth migration by backward time propagation. In: ANNUAL INTERNATIONAL MEETING - SEG, EXPANDED ABSTRACTS;, 53. Proceedings... [S.l.: s.n.], 1983. p. 827-30.\nWU, E.; LIU, Y. Emerging technology about GPGPU. In: IEEE ASIA PACIFIC CONFERENCE ON CIRCUITS AND SYSTEMS (APCCAS), Macao, China. Proceedings... [S.l.: s.n.], 2008. p. 618-22.\nYAMAGUCHI, Y. et al. FPGA-Based HPRC for Bioinformatics Applications. In: VANDERBAUWHEDE, W.; BENKRID, K. (Ed.). High-Performance Computing Using FPGAs. New York: Springer, 2013. p. 137-75.\nAp\u00eandice\nA\nImagens do Modelo 1\n150\n250\n100\nI\n200\nI\n2200 m/s\n1900 m/s\nh=110\nh=125\n2600 m/s\n/t-160\n3500 m/s\n4200 m/s\nh=145\nModelo_l\nFigura A.2: Imageamento de refer\u00eancia para o modelo 1 gerado no padr\u00e3o de ponto-flutuante.\nB\nImagens do Modelo 2\nFigura B.1: Estrutura geol\u00f3gica do modelo 2.\nximage\nFigura B.2: Imageamento de refer\u00eancia para o modelo 2 gerado no padr\u00e3o de ponto-flutuante.\n0\t50\t100\t150\t200\t250\nAntonio2_24bits\nC\nImagens do Modelo 3\nFigura C.1: Estrutura geol\u00f3gica do modelo 3.\n0\t50\t100\t150\t200\t250\nModelo3_Float\nFigura C.2: Imageamento de refer\u00eancia para o modelo 3 gerado no padr\u00e3o de ponto-flutuante.\nModelo3_19bits\nM\u00fcdel\u00fc3_17bits\nModelo3_12bits\nModelo3_llbits\n500 \u2014\n600 \u2014\n700-\n0*001465\n200-\n0*000732.\n-0*0007324\n400-\n-0*001465\n300 \u2014\n0\nD\nImagens do Modelo 4\nFigura D.1: Estrutura geol\u00f3gica do modelo 4.\nFigura D.2: Imageamento de refer\u00eancia para o modelo 4 gerado no padr\u00e3o de ponto-flutuante.\nE\nImagens do Modelo 5\nFigura E.1: Estrutura geol\u00f3gica do modelo 5.\n4300 m/s\tA=54\n\th=90\n3000 m/s\th=246\n1900 m/s\th=29\n3800 m/s\th=150\n5100 m/s\th=24\n4600 m/s\th=114\n0\t50\t100\t150\t200\t250\nModelo5_Float\nFigura E.2: Imageamento de refer\u00eancia para o modelo 5 gerado no padr\u00e3o de ponto-flutuante.\nFigura E.5: Imageamento do modelo 5 obtido com 19 bits de precis\u00e3o.\nF\nImagens do modelo de Marmousi\n0\t500\t1000\t1500\t2000\n0|I I I L\n100\nMarmousi\nFigura F.2: Imageamento de refer\u00eancia para o modelo de Marmousi gerado no padr\u00e3o de ponto-flutuante.\nG\nImplementa\u00e7\u00e3o do PE-ASM\nPE FIXO.h\t1\n//............................................................\n// CONFIG. OPERANDOS\n#define PRECIS\u00c3O OPERANDOS 20\n#define RANGE OPERANDOS 8\n#define NUMBITSOPERANDOS RANGEOPERANDOS+PRECISAO OPERANDOS //............................................................\n// VEL2FAT\n#define PRECIS\u00c3O FAT 28\n#define RANGE FAT 2\n#define NUMBITS FAT RANGE FAT + PRECIS\u00c3O FAT\n#define PRECIS\u00c3O VEL 6\n#define RANGE VEL 14\n#define NUMBITS_VEL RANGE VEL + PRECIS\u00c3O VEL\n#define PRECIS\u00c3O VEL2 PRECIS\u00c3O VEL*2\n#define RANGE VEL2 RANGE VEL *2\n#define NUMBITS VEL2 PRECIS\u00c3O VEL2 + RANGE VEL2\n#define PRECIS\u00c3O VEL2FAT PRECIS\u00c3O FAT\n#define RANGE VEL2FAT RANGE VEL2\n#define NUMBITS_VEL2FAT RANGE VEL2FAT + PRECIS\u00c3O VEL2FAT //............................................................\n// MVEL2_FATxSl_16_60\n#define PRECIS\u00c3O MVEL2 FATxSl 16 60 PRECIS\u00c3O VEL2FAT+PRECISAO OPERANDOS\n#define RANGE MVEL2 FATxSl 16 60 RANGE VEL2FAT + RANGE OPERANDOS\n#define NUMBITS MVEL2 FATxSl 1660 RANGE MVEL2 FATxSl 1690+ PRECIS\u00c3O MVEL2 FATxSl 1690 //............................................................\n// MMENOSAIJk\n#define PRECIS\u00c3O MMENOS AUk PRECIS\u00c3O MVEL2 FATxSl 16 60\n#define RANGE MMENOSAIJk RANGE MVEL2 FATxSl 1660+1 \"\nSdefine NUMBITS MMENOS AUk RANGE MMENOS_AUk+ PRECIS\u00c3O MMENOSAIJk\n#define AJUSTE MENOSAIJ PRECIS\u00c3O MVEL2 FATxSl 16 60-PRECIS\u00c3O OPERANDOS //............................................................\n// MABSIxABSJxABSK\n#define PRECIS\u00c3O ABSIABSJ 24\n#define RANGE ABSIABSJ 2\n#define NUMBITS ABSIABSJ RANGE ABSIABSJ+PRECISAO ABSIABSJ\n#define POSICAO_ROUND_ABSIABSJ (PRECIS\u00c3O ABSIABSJ)-1 //............................................................\n// MmultBordal\n#define PRECIS\u00c3O MULTB0RDA1 PRECIS\u00c3O MMENOSAIJk\n#define RANGE MULTB0RDA1 RANGE MMENOS AUk\n#define NUMBITS MULTB0RDA1 RANGE MULTB0RDA1+PRECISA0 MULTB0RDA1\n#define POS ROUD MULTB0RDA1 (PRECIS\u00c3O ABSIABSJ-1) //............................................................\n// Msoma2Bijk\n#define PRECIS\u00c3O S0MA2BUK PRECIS\u00c3O MMENOS AUk\n#define RANGE S0MA2BUK RANGE MMEN0S_AUk+2\n#define NUMBITS S0MA2BIJK RANGE S0MA2BUK + PRECIS\u00c3O S0MA2BUK\n#define POS ROUD MULTB0RDA2 (PRECIS\u00c3O ABSIABSJ+PRECISAO S0MA2BUK-PRECIS\u00c3O MULTB0RDA2-1)\n#define AJUSTE MS0MA2BU PRECI5A0 MULTB0RDA1 - PRECISAO_OPERANDOS + 1 //............................................................\n// MmultBorda2\n#define PRECIS\u00c3O MULTB0RDA2 PRECISAOOPERANDOS\n#define RANGE MULTB0RDA2 RANGE OPERANDOS\nSdefine NUMBITS MULTB0RDA2 RANGE MULTB0RDA2+PRECISA0 MULTB0RDA2\npe_fixo_2D asm.cpp\n1\n#include \"PE FIXO.h\"\nlong long int pe_fixo_asm(\nint b i_j, int a i_j, int i menos 1, int j menos 1, int i mais 1, int j mais 1, int imenos 2, int jjrienos 2, int i mais 2, int j mais 2, int velvel fat, int absi, int absj\n){\nlong long int sresultadoM16S; 7/14,23 long long int sresultadoMIS; 7/14,23 long long int sresultadoM\u00f5G; //14,23 long long int ssoma 1 16_6G; //16,23 long long int smultabs; // 1,24 my \u00cd128 sma_i_j;\nmy \u00cd128 smultbordal; //19,54 my \u00cd128 smult_borda2; //20,54 my \u00cd128 s2Bij;//21,54 my il28 svel2Fat_soma; // 17,54 my il28 svel2 FatxSl 16 60; // 13,54\n5ma_i_j //\n);\nlong long int smult_s;\nMabsixabsj_asm(\nabsi,\nabsj, smult abs\n);\nMmultBordalasmf smultabs, sma_i_j, smultbordal//\n);\nMsoma2Bij_asm( b iJ, smultbordal, s2Bij/7\nMmultBorda2 asm( smult abs, s2Bij, smult borda2\n);\nreturn (smult borda2.Io64);\nMlSoma_asm(\ni menos 2,\ni mais 2,\nj menos 2,\nj mais 2, sresultadoMIS // );\nM16Soma_asm(\ni menos 1,\ni mais 1, j_menos_l, j_mai5 1,\nsresultadoM16S // );\nM60_asm( b _i_j, sresultadoM6G\n);\nMSomal 16_60_asm( sresultadoM16S, s resultadoMIS, sresultadoM\u00f5G, ssomal_16_60 //\n);\nMvel2 FatxSl 16_60_asm( velvelfat, ssomal1660, svel2 FatxSl_16_60 );\nMmenosAij_asm(\nsvel2 FatxSl 16 60,\na. i j,\npe fixo 2D asm.h\t1\n#inctude \"PE_FIXO.h\"\ntypedef struct {\ntong tong int to64;\ntong tong int hi64;\n} my_il28;\n#define neg!28(dado)\\\nmov %0,\t%%rax;\t\"\\\t\n\" mov\t0,4 Q-Q-\trbx;\t\"\\\n\" not\t%%rax\t;\"\\\t\n\" not\t%%rbx\t;\"\\\t\n\" add\t$1,%%\trax;\t\"\\\n\" adc\t$0,%%\trbx;\t\"\\\n\" mov\t%%rax\t,%0;\t\"\\\n\" mov\t%%rbx\t,%1;\t\"\\\n: \"=m\"(dado.to64),\"=m\"(dado.hi64)\\\n: \"m\"(dado.to64),\"m\"(dado.hi64)\\\n: \"rax\",\"rbx\"\\\n);\\\n#define MlSoma_asm(\t\\\t\ni_menos_2,\\\t\t\ni_mais_2,\\\t\t\nj_menos_2, \\\t\t\nj_mais_2,\\\t\t\nretorno) \\\t\t\n\tasm\t(\" movsxd\t%1, %%rax;\t\"\\\n\" movsxd\t%2, %%rbx;'\t\\\n\" addq %%\t>rbx, %%rax;\t;\"\\\n\" movsxd\t%3, %%rbx;'\t\\\n\" adcq %%\t>rbx, %%rax;\t;\"\\\n\" movsxd\t%4, %%rbx;'\t\\\n\" adcq %%rbx, %%rax;\"\\\n\" negq %%rax;\"\\\n\" movq %%rax, %0;\"\\\n: \"=m\"(retorno)\\\n:\"m\" (j_menos_2), \"m\"(j_mais_2), \"m\"(i_menos_2), \"m\"(i_mais_2)\\ : \"rax\");\n#define M16Soma_asm(\\\ni_menos_l,\\ i_mais_l,\\ j_menos_l,\\ j_mais_l,\\ retorno)\\\nmovsxd %1, %%rax;\t\"\\\nmovsxd %2, %%rbx;'\t\\\naddq %%rbx, %%rax;\t;\"\\\nmovsxd %3, %%rbx;'\t\\\nadcq %%rbx, %%rax;\t;\"\\\nmovsxd %4, %%rbx;'\t\\\nadcq %%rbx, %%rax;\t;\"\\\nmovq $16,\t%%rbx;\"\t\nmutq %%rbx;\"\\ movq %%rax,%0;\"\\\t\n:\"=m\"(retorno)\\\n:\"m\" (j_menos_l), \"m\"(j_mais_l), \"m\"(i_menos_l), \"m\"( i_mais_l)\\ : \"rbx\", \"rax\", \"rdx\", \"rex\");\n#define M60_asm(\\\nb_i_j,\\ retorno)\\ retorno=-60LL*(tong tong int)b_i_j;\n#define MSomal_16_60_asm(\\\npe fixo 2D asm.h\t2\nM16,\\\nMl, \\\nM60,\\\nretorno)\\\nasm\t(\" movq\t%1,\t%%rax\t\n\" addq\t%2,\t%%rax;\t\"\\\n\" addq\t%3,\t%%rax;\t\"\\\n\" movq\t%%rax,%0;\"\t\t\\\n=m\" (retorno)\t\\\t\t\n:\u201dm\u201d (M16),\t\u201dm\"(M60)\\\n: \u2019\u2019 rax\");\n#define Mabsixabsj_asm( \\\nabsi,\t\\\nabsj,\t\\\nretorno\t)\\\t\t\n\tasm\t(\"\t1 xor\t%%rax, %%rax;\t\"\\\n\txor\t%%rbx, %%rbx;\t\"\\\n\tmov\t%1, %%eax;\"\\\t\n\tmov\t%2, %%ebx;\"\\\t\n\tmui\t%%rbx;\"\\\t\n\tmov\t%3, %%d;\" \\\t\n\tshrd %%rdx,%%rax;\t\t\"\\\n\tshr\t$3,%%rdx;\"\\\t\n\tadd\t$l,%%rax;\"\\\t\n\tshr\t$l,%%rax;\"\\\t\n11\tmov\t%%eax,%0;\"\\\t\n\"=m\" (retorno)\t\t\\\t\n:\u201dm\u201d(absi), \u201dm\"(absj), \"i\"(POSICAO_ROUND_ABSIABSJ)\\\n: \"rax\", \"d\",\"rdx\", \"r8\");\n#define MmenosAij_asm(\\ vel2f_s, \\ a_i_j, \\ retorno)\\\n__asm__( \" mov %2, %%rax;\"\\\n\" mov %3, %%rdx;\"\\\n\" movsxd %4, %%rbx;\"\\\n\" prep_negativo: movq $0xFFFFFFFFFFFFFFFF,%%r8;\"\\\n\" test %%rbx,%%rbx;\"\\\n\" js negativo; \"\\\n\" positivo: xor %%r8,%%r8;\"\\\n\" negativo: \"\\\n\" mov %5,%%d;\"\\\n\" shtd %%rbx, %%r8;\"\\\n\" sht %5, %%rbx;\"\\\n\" sub %%rbx,%%rax;\"\\\n\" sbb %%r8, %%rdx;\"\\\n\" mov %%rax,%0;\"\\\n\" mov %%rdx,%l;\"\\\n: \"=m\"(retorno,to64),\"=m\"(retorno.hi64) \\\n:\"m\"(vet2f_s.to64), \"m\"(vet2f_s.hi64),\"m\"(a_i_j), \"i\"(AJUSTE_MENOSAIJ)\\ : \" rax\",\" rbx\",\" rdx\",\" r8\");\n#define Mvet2_FatxSl_16_60_asm(\\\nvet2_fat, \\ sl_16_60, \\ retorno)\\ __asm__( \" movsxd %2,%%rax;\"\\\n\" mov %3,%%r8;\"\\\n\" imut %%r8;\"\\\n\" mov %%rax,%0;\"\\\n\" mov %%rdx,%l;\"\\\n: \"=m\"(retorno,to64),\"=m\"(retorno.hi64) \\\n:\"m\"(vet2_fat), \"m\"(sl_16_60)\\\n: \"r8\",\"rax\",\"rdx\");\n#define MmuttBordal_asm(\\\npe fixo 2D asm.h\t3\nabs, \\ dado,\\ retorno)\\\nif (dado.hi64<0){\\\nmov\t%2,%%rax;\t\"\\\t\nmov\t%3,%%rbx;\t\"\\\t\nnot\t%%rax; \"\\\t\t\nnot\t%%rbx;\"\\\t\t\nadd\t$l,%%rax;\t\"\\\t\nade\t$0,%%rbx;\t\"\\\t\nmovsxd %4,%!\t\t%r8;\t\"\\\nmul\t%%r8;\"\\\t\t\nmov\t9-9-r*3Y 9-9-r\t9;\"\\\t\nmov\t%%rdx,%%r\t10;\"\t\\\nmov\t%%rbx,%%\trax;\t\"\\\nmul\t%%r8;\"\\\t\t\nadd\t9-9--r* s y 9-9-r IdX,1\t10;\"\t\\\nmov\tQ-C, 9-9-z-l \u25a0 11\t\\\t\nshrd %%rl0,%%\t\tr9;\"\t\\\nshr\t%5,%%rl0;\t\"\\\t\nnot\t%%r9;\"\\\t\t\nnot\t%%rl0;\"\\\t\t\nadd\t$l,%%r9;\"\t\\\t\nade\t$0,%%rl0;\t\"\\\t\nmov\t%%r9,%0;\"\t\\\t\nmov\t%%rl0,%l;\t\"\\\t\n: \"=m\"(retorno.lo64),\"=m\"(retorno.hi64) \\\n:\"m\"(dado.lo64),\"m\"(dado.hi64), \"m\"(abs),\"i\"(POS_ROUD_MULTBORDAl+l), \"i\"(64-POS_ROUD_MULTBORDA1)\\\n: \"r8\",\"r9\", \"rl0\", \"rax\",\"rbx\",\"rdx\");\\\n} \\\n{\tasm\t(\" mov %2,\t\t%%rax; \"\\\n\" movsxd %4,%%r8;\t\t\"\\\n\" mul\t%%r8;\"\\\t\n\" mov\t%%rax,%%r9; \"\\\t\n\" mov\t%%rdx,%%rl0;\"\t\\\n\" mov\t%3,%%rax;\"\\\t\n\" mul\t%%r8;\"\\\t\n\" add\t%%rax,%%rl0;\"\t\\\n\" mov\t%5,%%cl;\"\\\t\n\" shrd %%rl0,%%r9;\"\t\t\\\n\" shr\t%5,%%rl0;\"\\\t\n\" mov\t%%r9,%0;\"\\\t\n\" mov\t%%rl0,%l;\"\\\t\n:\"=m\"(retorno.lo64),\"=m\"(retorno.hi64) \\\n:\"m\"(dado.lo64),\"m\"(dado.hi64), \"m\"(abs),\"i\"(POS_ROUD_MULTBORDAl+l), \"i\"(64-POS_ROUD_MULTBORDA1)\\\n: \"r8\",\"r9\", \"rl0\",\"rax\",\"rdx\");\\\n}\n#define MmultBorda2_asm(\\\nabs, \\\ndado,\\\nretorno)\\\nif (dado.hi64<0){\\\n___asm__(\" mov %2,%%rax;\"\\\n\" mov %3,%%rbx;\"\\\n\" not %%rax;\"\\\n\" not %%rbx;\"\\\n\" add $l,%%rax;\"\\\n\" ade $0,%%rbx;\"\\\n\" movsxd %4,%%r8;\"\\\n\" mui %%r8;\"\\\n\" mov %%rax,%%r9;\"\\\n\" mov %%rdx,%%rl0;\"\\\n\" mov %%rbx,%%rax;\"\\\n\" mui %%r8;\"\\\n\" add %%rax,%%rl0;\"\\\n\" mov %5,%%d;\"\\\npe fixo 2D asm.h\t4\n\" shrd %%rl0,%%r9;\"\\\n\" shr %5,%%rl0;\"\\\n\" not %%r9;\"\\\n\" not %%rlO;\"\\\n\" add $l,%%r9;\"\\\n\" adc $0,%%rlO;\"\\\n\" mov %%r9,%0;\"\\\n\" mov %%rlO,%l;\"\\\n: \"=m\"(retorno.to64),\"=m\"(retorno.hi64) \\\n: \"m\"(dado.lo64),\"m\"(dado.hi64), \"m\"(abs),\"i\"(P0S_R0UD_MULTB0RDA2+l), \"i\"(64-P0S_R0UD_MULTB0RDA2)\\\n: \"r8\",\"r9\", \"rlO\", \" rax\",\"rbx\",\"rdx\") ;\\\n} \\\n{\tasm\t(\" mov %2\t,%%rax; \"\\\n\" movsxd %4,%%r8;\t\n\" mul %%r8;\"\\\t\n\" mov %%rax,%%r9;\"\t\\\n\" mov %%rdx,%%rlO;\t\"\\\n\" mov %3,%%rax;\"\\\t\n\" mul %%r8;\"\\\t\n\" add %%rax,%%rlO;\t\"\\\n\" mov %5,%%cl;\"\\\t\n\" shrd %%rl0,%%r9;\t\"\\\n\" shr %5,%%rl0;\"\\\t\n\" mov %%r9,%0;\"\\\t\n\" mov %%rlO,%l;\"\\\t\n:\"=m\"(retorno.to64),\"=m\"(retorno.hi64) \\\n: \"m\"(dado.lo64),\"m\"(dado.hi64), \"m\"(abs),\"i\"(P0S_R0UD_MULTB0RDA2+l), \"i\"(64-P0S_R0UD_MULTB0RDA2)\\\n: \"r8\",\"r9\", \"rlO\",\"rax\",\"rdx\");\\\n}\n#define Msoma2Bij_asm(\\\nb_i_j, \\\nmutt_b,\\\nretorno)\\\n__asm___( \" movsxd %2,%%rax;\"\\\n\" pl: movq $0xFFFFFFFFFFFFFFFF,%%r8;\"\\\n\" test %%rax,%%rax;\"\\\n\" js p3;\"\\\n\" p2: xor %%r8,%%r8;\"\\\n\" p3: \"\\\n\" mov %5,%%cl;\"\\\n\" shtd %%rax, %%r8;\"\\\n\" sht %5, %%rax;\"\\\n\" add %3, %%rax;\"\\\n\" adc %4, %%r8;\"\\\n\" mov %%rax,%0;\"\\\n\" mov %%r8,%l;\"\\\n:\"=m\"(retorno.to64),\"=m\"(retorno.hi64) \\\n:\"m\"(b_i_j),\"m\"(mult_b.lo64),\"m\"(mutt_b.hi64),\"i\"(AJUSTE_MS0MA2BIJ)\\\n: \"rax\",\"r8\");\\\nfloat my_128_toFloat(my_il28 dado, int precisao);\nvoid floatTo_my_128(float dado, int precisao, my_il28 &amp;retorno);\nlong long int pe_fixo_asm(\nint\tb_\t\nint\ta_\t\nint\ti\t_menos_l\nint\tj_\t_menos_l\nint\ti\t_mais_l,\nint\tj_\t_mais_l,\nint\ti\t_menos_2\nint\tj_\t_menos_2\nint\ti\t_mais_2,\nint\t\t_mais_2,\npe fixo 2D asm.h\t5\nint vet_vet_fat,\nint absi,\nint absj\n);\nH\nImplementa\u00e7\u00e3o do algoritmo de predi\u00e7\u00e3o\npredi\u00e7\u00e3o.cpp\n/*\nprograma de modelagem\n*/\n#indude&lt;stdio.h>\n#indude&lt;string.h>\n#indude&lt;stdlib.h>\n#indude cmath. h>\n//#indude&lt;omp.h>\n#indude \"libcenpes_FPGA.h\"\n#indude \"arqMaxPulsolOO.h\"\nvoid\tinicia_var(int nnoib,int nnojb,float**AO,float**Al, float**A2, float**A3);\nvoid\tinicia_vel(int ni,int nj,float**AO,int vel);\nvoid inicia_com_2_vel(int ni,int nj,float**AO,int veil, int hl, int vel2, int h2); void calculoDensidadeEnergiaRms(float *buffer, float *rms, float *energia, int tamanhoBuffer, float velocidade, int janela, float raio);\nfloat rmsPulso(float *buffer, int vel);\nint inicia_com_N_vel_2D(int nCamadas, int largura, float**AO,int amort, int \u2666profundidades, float *velocidades, int nFiltro);\nvoid calculaAtenuacao( int largura, int profundidade, float**A0);\nfloat atn(int coluna, int camada, int hO, int profundidade, float**VEL, float pulso, float sensibilidade);\nfloat atnMod(int coluna, int camada, int hO, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,\nfloat VelPrimeiraCamada, float &amp; AmplitudeRetorno, float &amp; RaioRetorno); float atnMig(int coluna, int camada, int hO, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,\nfloat VelPrimeiraCamada, float &amp; menorAmplitude);\nvoid eqnl(float A_incidente, float VI, float V3, float ^refletida, float &amp;refratada);\nvoid teste (int &amp;al, float &amp;a2){\nprintf (\"%f %d\\n\",a2, al);\n}\nint main (int argc, char** argv) {\n//defini\u00e7\u00e3o de variaveis\t\t\t\t\nfloat\tenergiaPulso, energiaMeio;\t\t\t\nfloat\tFCorte;\t//\tFrequ\u00eancia maxima do pulso sismico em Hertz\t\nfloat\tFC;\t//\tParametro relacionado com FCorte usado na funcao ricker\t\t\nfloat\tvmax;\t//\tMaior velocidade do modelo\t\nfloat\tvmin;\t//\tMenor velocidade do modelo\t\ncha r\tFile 0ut[250];\t\t// Arquivo de saida\t\nint\tnnoi,nnoj;\t//\tDimens\u00e3o do modelo\t\t\nint\tnnoib,\tnnoj\tb;\t// Dimens\u00e3o do modelo com bordas de amortecimento\t\ncha r\tN0ME[30];\t//\tNome do arquivo\t\ncha r\tCMDLINE[500];\t\t// linha de comando\t\nint\tflag;\t//\tTeste de abertura de arquivo bem sucedida\t\t\nfloat\t**VEL;\t//\tMatriz campo de velocidades sismicas\t\nfloat\t\u25a0\t//\tMatriz campo\t\nfloat\t\u25a0\t//\tMatriz campo de press\u00e3o em t-1\t\nfloat\t\t//\tMatriz campo de press\u00e3o em t\t\nfloat\t**Amax;\t//\tMatriz condicao de imagem - amplitudes\t\nfloat\t**Tt ra;\t//\tMatriz condicao de imagem - tempos de transito\t\nfloat\t*absi,*absj;\t\t// Vetores de absorcao para CERJAN\t\nint\tij;\t//\tContadores para loops espaciais\t\nint\tt;\t// Contado\t\tr para o loop temporal\t\nfloat\tdt;\t//\tIntervalo de amostragem temporal\t\t\nfloat\th;\t//\tIntervalo de amostragem espacial (tamanho do grid)\t\t\nfloat\ttempo;\t//\tTempo da simulacao\t\nFILE\t*fl;\t//\tPonteiro para arquivo de entrada do modelo de velocidades\t\nFILE\t*f2;\t//\tPonteiro para arquivo de saida de snapshots (EM TESTE)\t\nFILE\t*f3;\t//\tPonteiro para arquivo de saida do sismograma\t\nFILE\t*f4;\t\t// Ponteiro para arquivo de saida da matriz\tde tempo\nFILE\t*f5;\t\t// Ponteiro para arquivo de saida da matriz\tde\namplitudes\npredicao.cpp\t2\nFILE\t*onda;\t// Ponteiro para arquivo de saida de propagacao\nFILE\t*fmedidas;//\nFILE\t*testeConfiguracao;\nFILE\t*fdesvio;\nFILE\t*fsisrnograrna;\nfloat\tfat;\t\t// Fator constante usado dentro do loop mais interno\nfloat\ttf;\t//\tDistancia em tempo do centro da wavelet a origem do eixo do\ntempo\t\t\t\nint\tntf;\t\tII Distancia em amostras de tempo da wavelte ate a origirn\nfloat\tpi;\t//\t0 numero PI=3.141592654\nint\talpha;\t//\tParametro relacionado com a dispers\u00e3o num\u00e9rica\nint\tbeta;\t\tII Parametro relacionado com a estabilidade\nint\tcont_snap;\t//\tTempo final do sismograma\nint\tamort;\t//\tEspessura da borda de amortecimento\nint\tdist_recv;\t//\tDistancia entre receptores em pontos do grid\nint\tnrecv;\t//\tNumero do receptor\nfloat\tsis_dt;\t\tII Intervalo de amostragem do sismograma em segundos\nint\tsis_ntr;\t//\tNumero de traeos do sismograma\nfloat\tcoef;\t// Coeficiente de absorcao de Cerjan\n// int cnt;\t// Contador para loop de sismograma\nfloat\t*slice;\t// Buffer para armazenar as amostras correntes do sismograma\nint\tcl,c2,c3;\t// Criterios para condicao de imagem\nint\tposxTiro;\t// N\u00famero do tiro usado no nome dos arqs de entrada/saida\nint\toperacao;\t// 0=sismograma, l=matrizes de tempo e amplitude\nsnap;\t// Flag para saida de snapshots: 0=nao, l=saida de snapshots\nchar\t*arqvel; // Caminho/nome do arquivo de velocidade\nchar\tnomesaidas[100]; // Caminho/nome dos arquivos de saida\nfloat score[10][15];\nint posX, posY;\nfloat refPulse, maxRefPulse, medPulse, maxMedPulse;\nfloat *medPts, *medidas, *pulsolnserido, *pulsoMedido, *rmsPl, *energiaPl, *rmsP2, *energiaP2, *sismograma;\nint profundidadeModelo;\nint larguraModelo;\nfloat correcaoPulso;\nfloat AmplitudeRetornoMod, AmplitudeRetornoMig ;\nfloat RaioRetornoMod, RaioRetornoMig;\nfloat menorAmplitudeMig, menorAmplitudeMod, amplitude;\nint profundidadeMedida;\nint nCamadas;\nint pl,p2;\nint posyTiro;\nint ptr;\nfloat maxPulso;\nint coluna;\nfloat pulso;\nfloat sensibilidade;\nsprintf(nomesaidas,\"desvio. csv\");\nint al; float a2;\nfloat raioMigracao;\nfdesvio = fopen(nomesaidas,\"wb\"); fprintf(fdesvio,\"alpha, beta, desvio\\n\");\nif (atoi(argv[5])!=0 &amp;&amp; (argc != 9+atoi(argv[5])*2)||(atoi(argv[5])==0 &amp;&amp; argc !=\n11)){\nprintff'ERRO %d %d\\n\",argc, (atoi(argv[5])*2)+8);\n//\t1\t2\t3\t4\t5\t6\n7\t6\nputsf'./predicao pulso sensibilidade profundidadeMedida coluna nCamadas [larguraModelo ,ProfundidadeModelo, arqvel] [larguraModelo, vl,hl,v2,h2.....vn,hn], alpha\nbeta\");\nputsf'pulso - amplitude do pulso introduzido no meio\");\nputs(\"sensibilidade - diferen\u00e7a percentual de velocidades entre camadas defec\u00e1veis\");\nputsCprofundidadeMedida-profundidade em espa\u00e7os do grid para fazer a predi\u00e7\u00e3o\");\npredicao.cpp\t3\nputs(\"coluna, coluna a ser analizada (0=analiza todo o modelo)\"); puts(\"nCamadas - numero de camadas do modelo\");\nputs(\"[larguraModelo, ProfundidadeModelo, arqvel] - largura e profundidade do modelo a ser lido de arqvel\");\nputs(\"[larguraModelo, vl,hl,v2,h2,...,vn,hn] - largura do modelo a ser construido com as velocidade e profundidades indicadas (metros)\");\nputs(\"alpha beta - parametros de configura\u00e7\u00e3o\");\nreturn\n}\namort=100; coef=0.00202; dist recv=l; sis dt=0.002f;\t// Espessura da borda de amortecimento // Coeficiente de absorcao da camada de amortecimento // Distancia entre receptores em pontos do grid // Intervalo de amostragem do sismograma em segundos\nalpha=12;\t// Criterio para evitar dispers\u00e3o num\u00e9rica\nbeta=2;\npulso = atof(argv[l]);\nsensibilidade = atof(argv[2]);\nvmin=1000;\nvmax=5500;\n//Inicializacao de variaveis\npi = 4.0f*atan(1.0f);\t// 0 numero PI=3.141592654...\nFCorte=60;\t// Frequ\u00eancia maxima do pulso sismico\n// Criterio para garantir estabilidade\nFC=FCorte/2.0f;\t// Relacao entre a freq, maxima e o valor de FC em ricker\nh = vmin/(alpha*FC);\t// Def. espacam. grid em X e Z p/ satisf. cond.\nestabilidade\ndt= h/(beta*vmax);\t// Def. interv. amostragem temporal p/ satisf. crit.\ndispers\u00e3o num\u00e9rica\nfat = (dt*dt)/(h*h*12.0f);\t// Fator constante usado dentro do loop mais interno\nsis_ntr = nnoi/dist_recv; // Calcula o numero de traeos do sismograma tf=2.0f*sqrt(pi)/FC;\t// Distancia em tempo do centro da wavelet a origem do\neixo do tempo\nntf=tf/dt;\t// Distancia em amostras de tempo do centro da wavelet a origem\nprofundidadeMedida = atoi(argv[3]);\ncoluna = atoi(argv[4]);\nnCamadas = atoi(argv[5]);\nif (nCamadas==0){\nlarguraModelo = atoi(argv[6]);\nprofundidadeModelo = atoi(argv[7]);\narqvel = argv[8];\nputs(\"\\nl_endo arquivo...\");\nVEL = libcenpes_aloca2Df(larguraModelo,profundidadeModelo,&amp;flag);// Aloca matriz para o campo de velocidades sismicas com bordas\nlibcenpes_read_mat2Df(arqvel,la rguraModelo,profundidadeModelo,\u00a9,0,0,0,VEL); // Le arquivo com modelo de velocidades sem bordas\n}else{ larguraModelo=ceil(atoi(argv[6])/h);\t// Dimens\u00e3o X do modelo\nfloat *velocidades = (float *)calloc(nCamadas,sizeof(int));\nint *profundidades = (int *)calloc(nCamadas,sizeof(int));\nint *profundidadesEmPts = (int *)calloc(nCamadas,sizeof(int));\nfloat\t*precisaoModelagem\t=\t(float\t*)calloc(nCamadas,sizeof(int));\nfloat\t*precisaoMigracao\t=\t(float\t*)calloc(nCamadas,sizeof(int));\nfloat\t*precisaoNaCamada\t=\t(float\t*)calloc(nCamadas,sizeof(int));\nint profundidaCamadaAnterior=0;\nprofundidadeModelo =0;\nfor(i=0; i<nCamadas; i++){\nvelocidades[i] = atoi(argv[7+(2*i)]); profundidades[i] = atoi(argv[7+(2*i+l)])-profundidaCamadaAnterior; profundidaCamadaAnterior = atoi(argv[7+(2*i+l)]); profundidaCamadaAnterior = atoi(argv[7+(2*i+l)]); profundidadesEmPts[i] = ceil(profundidades[i]/h); profundidadeModelo+=profundidadesEmPts[i];\n}\n//Alocacao de memoria do Campo de Velocidades\npredicao.cpp\t4\nVEL = Libcenpes_aloca2Df(larguraModelo,profundidadeModelo,&amp;flag); // Aloca matriz para o campo de velocidades sismicas com bordas\nprofundidadeModelo = inicia_com_N_vel_2D(nCamadas, larguraModelo, VEL, 0, profundidadesEmPts, velocidades, 1);\n//\tfor (i=0; icprofundidadeModelo; i++)\n//\tprintf(\"VEL[0][%d]=%f\\n\",i,VEL[0][i]);\n}\nint alarrne=0;\nfor (i=0; idarguraModelo; i++)\nfor (j=0; jcprofundidadeModelo; j++){\nif (VEL[i][j]<1500){\nVEL[i][j]=1500;\nalarrne=l;\n}\n}\nif (alarme)\nputs(\"Este modelo possui camadas com velocidades abaixo de 1500 m/s que foram ajustadas para 1500 m/s\");\nprintf(\"Pulso:%f sensibilidade:%f\\n\",pulso, sensibilidade);\nmenorAmplitudeMod = 1000;\nmenorAmplitudeMig = 1000;\nfloat menorAmplitude = 1000;\nfloat pulsoEntrada = pulso;\nraioMigracao=0;\ni=0;\nif (coluna==0) II se coluna=0 analiza todo o modelo\nfor (i=0; idarguraModelo; i = i+10){\npulso = pulsoEntrada*FATOR[(int)VEL[coluna][0]-1500];\namplitude= atnMod(i, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0, AmplitudeRetornoMod, RaioRetornoMod);\nif (amplitudecmenorAmplitudeMod)\nmenorAmplitudeMod = amplitude;\namplitude= atnMig(i, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0, menorAmplitude);\nif (amplitude<menorAmplitudeMig)\nmenorAmplitudeMig = amplitude;\n}\nelse{\npulso = pulsoEntrada*FATOR[(int)VEL[coluna][0]-1500];\nmenorAmplitudeMod= atnMod(coluna, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0, AmplitudeRetornoMod, RaioRetornoMod);\nmenorAmplitudeMig= atnMig(coluna, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0,menorAmplitude);\n}\nprintf(\"Modelo: %s Profundidade: %d Largura: %d Velocidade da Primeira Camada: %e\nAmplitude do Pulso Inicial: %e\\n\",\narqvel, profundidadeModelo, larguraModelo, VEL[larguraModelo/2][0],\nFAT0R[(int)VEL[larguraModelo/2][0] -1500]);\nprintf(\"Menor amplitude na Modelagem:%e precis\u00e3o na base 2:%d bits \\n\", menorAmplitudeMod, (int)ceil(fabs(Log2(menorAmplitudeMod/100))));\nprintf(\"Menor amplitude na Migra\u00e7\u00e3o:%e precis\u00e3o na base 2:%d bits \\n \\n \", menorAmplitudeMig, (int)ceil(fabs(Log2(menorAmplitudeMig/100))));\nreturn 1;\n}\n// Subrotina para inicializacao de variaveis\nvoid inicia_var(int ni,int nj,float**A0,float**Al, float**A2, float**A3) { int i,j;\n//Criacao dos campos de press\u00e3o\nfor (i=0;i<ni;++i) {\nfor (j=0;j<nj;++j) {\npredicao.cpp\t5\n} } return;\nA0[i]\t[j]\t= 0.0f;\t//\tInicializa\t0\tcampo\tde\tpressao\tem\tt-2\nAl[i]\t[j]\t= 0.0f;\t//\tInicializa\t0\tcampo\tde\tpress\u00e3o\tem\tt-1\nA2[i]\t[j]\t= 0.0f;\t//\tInicializa\t0\tcampo\tde\tpressao\tem\tt\nA3[i]\t[j]\t= 0.0f;\t\t// Inicializa matriz\t\t\t\tde amplitudes\t\t\nvoid inicia_vet(int ni,int nj,ftoat**A0,int vet) { int i,j;\nfor (i=0;i<ni;++i) {\nfor (j=0;j<nj;++j) {\nA0[i][j] = (float)vel;\n}\n}\nreturn;\nfloat rmsPulso(float *buffer, int vel){ int i;\nfloat media=0;\nfor (i=0; i<270; i++)\nmedia += buffer[280+i]*buffer[280+i]; media /=270;\nmedia =sqrt(rnedia);\nreturn media;\nvoid inicia_com_2_vel(int ni,int nj,float**A0,int veil, int hl, int vel2, int h2){ int i,j, x,y;\nfloat media;\nfor (i=0;i<ni;++i) {\nfor (j=0;j<nj;++j) {\nif (j<hl)\nA0[i][j] = (float)vell; else A0[i][j] = (float)vel2;\n}\n}\nvoid calculoDensidadeEnergiaRms(float *buffer, float *rms, float *energia, int tamanhoBuffer, float velocidade, int janela, float raio){\nfloat frms;\nint ent, cntFim, inincio,fim, achei;\nint i, j, down, up;\nint ptr;\nprintff'Medidas em velocidade:%f raio:%f janela:%d \\n\", velocidade, raio, janela);\nfor (i=0; ictarnanhoBuffer-janela; i++ ){ frrns=0;\nfor (j=0; jcjanela; j++){ frms=frms+ (buffer[i+j]*buffer[i+j]);\n}\nfrms = sqrt(frms/janela); rms[i]=frms;\nenergia[i]=frms*frms/velocidade;\n}\nfrms =0;\nup=0;\nfor (i=0; ictarnanhoBuffer-janela; i++ ){\nif (rms[i+l]-rms[i]>0.001){\nptr = i;\nup++; if(up>5) down=0;\n}else{\npredicao.cpp\t6\ndown++;\nif ((down>50)){\nif (up>50)\nprintf(\"Pulso:[%d,%d] Energia:%10e Amplitude(rms)=%10e\\n\",ptr,\nptr+janela, energia[ptr], rms[ptr]);\nup=0;\n}\n}\n}\n}\nint inicia_com_N_vel_2D(int nCamadas, int largura, float* **A0,int amort, int *profundidades, float Velocidades, int nFiltro) {\nint i, j, cnt, h, p, np,v;\nfloat media;\ncnt=0;\nnp = amort;\nfor (i=0;i<amort;++i) // camada de absor\u00e7\u00e3o\nA0[0][i] = (float)velocidades[0];\nfor (p=0; p<nCamadas; p++){\nfor (i=0;i<profundidades[p];++i)\nA0[0][i+np] = (float)velocidades[p];\nnp +=profundidades[p];\n}\nfor (i=0;i<amort;++i) // camada de absor\u00e7\u00e3o A0[0][i+np] = (float)velocidades[nCamadas-l]; np +=amort;\nfor (i=0;i<np-nFiltro;++i){ // filtro media=0;\nfor (p=0; p<nFiltro; p++) media += A0[0][i+p];\nmedia /=nFiltro; A0[0][i]=media;\n}\nfor (i=0;i<np;++i){\t// converte de ld para 2d\nfor (j=0; j<largura; j++)\nA0[j][i]=A0[0][i];\n}\nreturn np;\n}\nfloat atnMod(int coluna, int camada, int h0, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,\nfloat VelPrimeiraCamada, float &amp; AmplitudeRetorno, float &amp; RaioRetorno){\n*\n*int coluna:coluna do modelo a ser analizada\n*int camada: camada atual, indica a \u00faltima camada a ser visitada\n*int h0: profundidade atual, indica a profundidade da \u00faltima camada visitada, j\u00e1 considera corre\u00e7\u00f5es por velocidade\n*int profundidade: profundidade do modelo\n*float**VEL: modelo de velocidades\n*float pulso: amplitude do pulso ao deixar a \u00faltima camada visutada\n*float sensibilidade: sensibilidade de detec\u00e7\u00e3o de camadas, definido como percentual de varia\u00e7\u00e3o de velocidade em rela\u00e7\u00e3o a velocidade da \u00faltima camada\n*\n*/\nfloat reflexaolnterna=0;\nfloat retorno;\npredi\u00e7\u00e3o.cpp\nfloat velCamadaAnteriror, velPxCamada, velCamada;\nint i=h0;\nfloat raio, raioRefletido;\nfloat indiceRefracao;\nfloat AmplitudeRetornoI;\nfloat RaioRetornoI;\nint profundidadeDaCamada;\nfloat indiceTransmissao, indiceRetorno, indiceRefracaoRetorno;\nvelCamada = VEL[coluna][h0];\nif (h0>0) velCamadaAnteriror= VEL[coluna][h0-l];\nelse {\nvelCamadaAnteriror=0;\nVelPrimeiraCamada = velCamada;\n}\n// procura pr\u00f3xima camada\n{\nwhile ((i<profundidade)&amp;&amp;(fabs(VEL[coluna][i]-velCamada))<velCamada*sensibilidade){ II verifica a profundidade da camada\ni++;\n}\n}\nprofundidadeDaCamada = i-h0;\nvelPxCamada = VEL[coluna][i];\nif (i==profundidade) { // verifica se chegou ao fim do modelo, a \u00faltima camada n\u00e3o retorna nada e n\u00e3o acrescenta nada ao raio da frente de ona\nRaioRetorno=l;\nAmplitudeRetorno = 100000; return 1000;\n}\n//\t// Calcula o raio\n{\nif (camada==0) { // se esta \u00e9 aprimeira camada\nraio = profundidadeDaCamada; raioRefletido = 2*profundidadeDaCamada;\n}else { // se o pulso j\u00e1 vem propagado de outras camadas raio = (profundidadeDaCamada*velCamada/VelPrimeiraCamada)+raioAnteior; // diminui o raio da camada atual caso a velocidade da camada atual seja menor que a anteior raioRefletido = (2*profundidadeDaCamada*velCamada/VelPrimeiraCamada)+raioAnteior;\n}\n}\n//\tCalcula a atenua\u00e7\u00e3o\n{\nif (velPxCamada>velCamada) indiceTransmissao = velPxCamada/velCamada;\nelse indiceTransmissao=l;\nif (velCamadaAnteriror> velCamada) indiceRetorno = velCamadaAnteriror/velCamada;\nelse indiceRetorno=l;\nreflexaolnterna = fabs(velPxCamada-velCamada)/(velPxCamada+velCamada); indiceRefracao = (l-reflexaolnterna);\nindiceRefracaoRetorno = l-(fabs(velCamadaAnteriror-velCamada)/(velCamadaAnteriror+velCamada));\nindiceTransmissao = indiceRefracao*indiceTransmissao;\natnMod(coluna, camada+1, i, raio, profundidade, VEL, indiceTransmissao, sensibilidade, pMedicao, VelPrimeiraCamada, AmplitudeRetornoI, RaioRetornoI);\nif ((reflexaolnterna/sqrt(raioRefletido-\npredicao.cpp\t8\npMedicao)<AmplitudeRetornoI/sqrt(RaioRetornoI+raio-pMedicao))){\nAmplitudeRetorno=reflexaoInterna*pulso;\nRaioRetorno = raioRefletido;\n}else{\nAmplitudeRetorno=AmplitudeRetornoI*pulso; RaioRetorno = RaioRetornoI+raio;\n}\nif (camada!=0)\nAmplitudeRetorno=AmplitudeRetorno*indiceRefracaoRetorno*indiceRetorno;\nelse {\nRaioRetorno=RaioRetorno-pMedicao;\n}\nretorno = AmplitudeRetorno/sqrt(RaioRetorno);\n}\nreturn (retorno);\n}\nfloat atnMig(int coluna, int camada, int h0, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,\nfloat VelPrimeiraCamada, float &amp; menorAmplitude){\n*\n*int coluna:coluna do modelo a ser analizada\n*int camada: camada atual, indica a \u00faltima camada a ser visitada\n*int h0: profundidade atual, indica a profundidade da \u00faltima camada visitada, j\u00e1 considera corre\u00e7\u00f5es por velocidade\n*int profundidade: profundidade do modelo\n*float**VEL: modelo de velocidades\n*float pulso: amplitude do pulso ao deixar a \u00faltima camada visutada\n*float sensibilidade: sensibilidade de detec\u00e7\u00e3o de camadas, definido como percentual de varia\u00e7\u00e3o de velocidade em rela\u00e7\u00e3o a velocidade da \u00faltima camada\n*\n*/\nfloat reflexaolnterna=0;\nfloat velCamadaAnteriror, velPxCamada, velCamada;\nint i=h0;\nfloat raio;\nfloat indiceRefracao;\nint profundidadeDaCamada;\nfloat indiceTransmissao;\nfloat amplitudePulso;\nvelCamada = VEL[coluna][h0];\nif (h0>0)\nvelCamadaAnteriror= VEL[coluna][h0-l];\nelse {\nvelCamadaAnteriror=0;\nVelPrimeiraCamada = velCamada;\n}\n// procura pr\u00f3xima camada\n{\nwhile ((i<profundidade)&amp;&amp;(fabs(VEL[coluna][i]-velCamada))<velCamada*sensibilidade){\nII verifica a profundidade da camada\ni++;\n}\n}\nprofundidadeDaCamada = i-h0; velPxCamada = VEL[coluna][i];\nif (i==profundidade) { // verifica se chegou ao fim do modelo, a \u00faltima camada n\u00e3o retorna nada e n\u00e3o acrescenta nada ao raio da frente de ona\npredicao.cpp\t9\nreturn menorAmptitude;\n}\n//\t// Calcula o raio\nraio = ((profundidadeDaCamada*velCamada/VelPrimeiraCamada)+raioAnteior); // utilizado para calcular a atenua\u00e7\u00e3o por migra\u00e7\u00e3o\nII\tCalcula a atenua\u00e7\u00e3o\nreflexaolnterna = fabs(velPxCamada-velCamada)/(velPxCamada+velCamada);\nindiceRefracao = l-reflexaolnterna;\nif (velPxCamada>velCamada){\nindiceTransmissao =\npulso*indiceRefracao*indiceRefracao*indiceRefracao*velPxCamada/velCamada*velPxCamada/velC amada;\n}else {\nindiceT ransmissao = pulso*indiceRefracao*indiceRefracao*indiceRefracao *velCamada/velPxCamada;\n}\namplitudePulso = reflexaolnterna*pulso/(raio*sqrt(2));\nif (amplitudePulsocmenorAmplitude)\nmenorAmptitude = amplitudePulso;\natnMig(coluna, camada+1, i, raio, profundidade, VEL, indiceTransmissao,\nsensibilidade, pMedicao, VelPrimeiraCamada, menorAmptitude);\nreturn (menorAmptitude);\n}\nfloat atn(int coluna, int camada, int h0, int profundidade, float**VEL, float pulso, float sensibilidades\nfloat reftexaolnterna=0;\nfloat reftexaoExterna=0;\nfloat amplitudeNaInterface=0;\nfloat velCamada = VEL[coluna][h0];\nint i=h0;\nwhile ((i<profundidade)&amp;&amp;(fabs(VEL[coluna][i]-velCamada))<velCamada*sensibilidade){ i++;\n}\nprintf(\"velocidade:%f profundidade:%d\\n\", velCamada,i);\nif (i==profundidade) { amplitudeNalnterface = pulso*sqrt(h0+l)/sqrt(fabs(i)); printf(\"Ultima camada %d coluna%d\\n\",camada,coluna); printf(\"Velocidade:%f Profundidade:%d h0:%d Pulso: %e PulsoAtenuado: %e\\n\\n\",velCamada, i-h0, h0, pulso, amplitudeNalnterface);\nfflush(stdout);\nreturn (1000);//(amplitudeNaInterface);// amplitude na \u00faltima camada, esta camada n gera reflex\u00e3o\n}\nelse {\ncamada++;\neqnl( pulso, velCamada, VEL[coluna][i], reflexaolnterna, amplitudeNalnterface); reflexaolnterna = fabs(reflexaolnterna);\namplitudeNalnterface = fabs(amplitudeNalnterface); reflexaoExterna = atn(coluna, camada, i, profundidade, VEL, amplitudeNalnterface, sensibilidade);\nprintf(\"Camada Interna %d coluna %d\\n\",camada-l, coluna); printf(\"Velocidade:%f VelocidadePrxCamada:%f Profundidade:%d [%d-%d] Pulso: %e \\n\",velCamada,VEL[coluna][i], i-h0, h0, i, pulso);\nprintf(\"reflexaolnterna:%e reflexaoExterna:%e\n\\n\\n\",reflexaolnterna,reflexaoExterna ); fflush(stdout);\nif (reflexaolnternacreflexaoExterna)\nreturn (reflexaolnterna);\nelse return (reflexaoExterna);\npredicao.cpp\t10\n}\nvoid calculaAtenuacao( int largura, int profundidade, float**A0){\nint i, j, hl,h2, coluna, camada, ptrColuna, ptrCamada;\nfloat velocidade;\nfloat amplitudePulso=l;\nfloat velocidades[100][100];\nint profundidades[100][100];\nint ptr=0;\nhl=0;\nh2=0;\nvelocidade = A0[0][0];\nptrCamada = 0;\nptrColuna = 0;\nfor (coluna=0; colunac largura; coluna=coluna+10){ ptrCarnada=0;\nfor (camada=0; carnadacprofundidade; camada++) {\nif (A0[coluna][camada]!=velocidade){ velocidades[ptrColuna][ptrCamada] = velocidade; profundidades[ptrColuna][ptrCamada]=camada-hl; hl =camada; ptrCamada++; velocidade =A0[coluna][camada];\n}\n} velocidades[ptrColuna][ptrCamada] = velocidade; profundidades[ptrColuna][ptrCamada]=camada-hl; ptrColuna++;\n}\nptrCamada;\nfloat amplitudeReflexao,pulso ;\npulso = 1;\nfor (camada=0; carnadacptrCarnada; camada++){\nprintf(\"Camada:%d\\n\",camada);\nprintf(\"Velocidade:%f Profundidade:%d \\n\\n\",velocidades[0][camada], profundidades!\u00a9][camada]);\namplitudeReflexao= (pulso/profundidades[0][i])* //atenua\u00e7\u00e3o por divergencia cilindrica nos dois sentidos de propaga\u00e7\u00e3o\n(fabs(velocidades[0][0] -velocidades!\u00a9][i+1][/(velocidades!\u00a9] [\u00a9]+velocidades[0][i+l])); // indice de reflex\u00e3o\npulso =(pulso/sqrt(profundidades[\u00a9][i]))* // atenua\u00e7\u00e3o por divergencia cilindrica (1-(fabs(velocidades[0][0]-velocidades!\u00a9][i+1])/(velocidades[0] [O]+velocidades[0][i+l])))* // parcela da onda que ser\u00e1 retratada\n(velocidades[0][i+l]/velocidades[0][i]);//* // indice de retra\u00e7\u00e3o printf(\"Amplitude do pulso na camada:%f \\n\\n\",pulso);\n}\nvoid eqnl( float A_incidente, float VI, float V3, float &amp;refletida, float &amp;refratada){ float alfa=Vl/V3;\nfloat beta=(alfa*A_incidente*A_incidente)-(A_incidente*A_incidente);\nfloat psi=-2*A_incidente;\nfloat gama=l+alfa;\nfloat delta=(psi*psi)+(4*gama*beta);\nfloat refletidal=(-psi+sqrt(delta))/(2*gama);\nfloat refletida2=(-psi-sqrt(delta))/(2*gama);\nfloat refratadal = (A_incidente-refletidal)*V3/Vl;\nfloat refratada2 = (A_incidente-refletida2)*V3/Vl;\nfloat el = fabs(A_incidente/Vl-refratadal/Vl-refratadal/V3);\nfloat e2 = fabs(A_incidente/Vl-refratada2/Vl-refratada2/V3);\nif (refratadal==\u00a9){\nrefletida = refletida2;\nretratada = refratada2;\n}else\nif (refratada2==\u00a9){\nrefletida = refletidal;\npredicao.cpp\t11\nretratada = refratadal;\n}else\nif ((el)<(e2)){\nrefletida = refletidal;\nretratada = refratadal;\n}\nelse {\nrefletida = refletida2;\nretratada = refratada2;\n}\n}\nI\nRevis\u00e3o sobre padr\u00f5es de representa\u00e7\u00e3o nu\nX \u2022\nm\u00e9rica\nO conte\u00fado desta se\u00e7\u00e3o \u00e9 uma transcri\u00e7\u00e3o com adapta\u00e7\u00f5es do conte\u00fado publicado em (BARROS, 2008).\nA defini\u00e7\u00e3o das caracter\u00edsticas de um padr\u00e3o de representa\u00e7\u00e3o num\u00e9rica est\u00e1 diretamente ligada ao conjunto de valores a ser representado e \u00e0 capacidade de representa\u00e7\u00e3o do sistema em que este ser\u00e1 utilizado.\nEsse problema torna-se mais grave em se tratando do conjunto dos n\u00fameros reais, o qual representa o cont\u00ednuo, o infinito n\u00e3o numer\u00e1vel.\nUma solu\u00e7\u00e3o para esse problema foi proposta na forma de uma expans\u00e3o num\u00e9rica denominada expans\u00e3o b-\u00e1dica (KULISCH; MIRANKER, 1981).\nPela expans\u00e3o b-\u00e1dica, um n\u00famero real qualquer pode ser univocamente representado por meio de um somat\u00f3rio ponderado infinito de termos de uma base num\u00e9rica, atrav\u00e9s da seguinte express\u00e3o:\nx=s \u00a3 dtfik\nk=-tt\nem que x \u00e9 o n\u00famero representado, 8 \u00e9 o sinal alg\u00e9brico, p \u00e9 a base num\u00e9rica adotada, d representa o valor de cada um dos termos utilizados.\nA representa\u00e7\u00e3o de valores num\u00e9ricos por meio de um somat\u00f3rio ponderado de termos \u00e9 tamb\u00e9m conhecida como nota\u00e7\u00e3o posicional.\nNos sistemas computacionais, em consequ\u00eancia de limita\u00e7\u00f5es de natureza tecnol\u00f3gica, adotam-se representa\u00e7\u00f5es finitas da expans\u00e3o b-\u00e1dica para representar conjuntos num\u00e9ricos espec\u00edficos, tais como o conjunto dos n\u00fameros inteiros, dos inteiros relativos e dos n\u00fameros reais.\nI.1\tNota\u00e7\u00e3o de inteiros\nA nota\u00e7\u00e3o de inteiros \u00e9 o padr\u00e3o de representa\u00e7\u00e3o num\u00e9rico mais simples de todos os suportados pelos sistemas computacionais. Ele apresenta a vantagem de ter um baix\u00edssimo custo de implementa\u00e7\u00e3o em hardware, motivo pelo qual \u00e9 suportado por todos os processadores.\nNa nota\u00e7\u00e3o de inteiros, um n\u00famero z pode ser representado por uma base num\u00e9rica p atrav\u00e9s da seguinte express\u00e3o:\nz = \u00b1 \u00a3 di X p\t@\ni=0\nem que di representa a sequ\u00eancia dos n d\u00edgitos utilizados.\nApesar de sua simplicidade, essa nota\u00e7\u00e3o tem um razo\u00e1vel poder de representa\u00e7\u00e3o, pois os n\u00fameros s\u00e3o formados por arranjos com repeti\u00e7\u00e3o dos valores num\u00e9ricos contidos na base adotada. Em uma representa\u00e7\u00e3o com n d\u00edgitos mais uma representa\u00e7\u00e3o para o sinal alg\u00e9brico \u00e9 poss\u00edvel formar\n2\tX pn\nn\u00fameros ou valores distintos. Em especial na base bin\u00e1ria, em que normalmente se reserva o bit mais significativo exclusivamente para a indica\u00e7\u00e3o do sinal alg\u00e9brico, considerando uma representa\u00e7\u00e3o com n bits, teremos:\n\u00b1(2n-1\n+ 2n-2 + \u2022\u2022\u2022 + 21 + 20)\nou seja, 2n n\u00fameros represent\u00e1veis.\nI.2\tNota\u00e7\u00e3o de ponto-fixo\nA nota\u00e7\u00e3o de ponto-fixo estende a nota\u00e7\u00e3o de inteiros de forma a permitir a representa\u00e7\u00e3o tanto de n\u00fameros inteiros quanto de n\u00fameros fracion\u00e1rios.\nNessa nota\u00e7\u00e3o dividem-se os d\u00edgitos da representa\u00e7\u00e3o em dois grupos distintos, os quais ficam separados pelo ponto decimal. Os d\u00edgitos \u00e0 direita do ponto ficam reservados \u00e0 representa\u00e7\u00e3o da parte inteira do n\u00famero, e os d\u00edgitos \u00e0 esquerda, \u00e0 sua parte fracion\u00e1ria.\nDessa forma, considerando-se a representa\u00e7\u00e3o de um n\u00famero z qualquer, em uma nota\u00e7\u00e3o de ponto-fixo com n d\u00edgitos, estando k desses d\u00edgitos reservados \u00e0 representa\u00e7\u00e3o da parte fracion\u00e1ria, ou seja, estando o ponto separador colocado entre k-\u00e9simo e o k-\u00e9simo + 1 d\u00edgitos, teremos:\nz = \u00b1 \u00a3 di x pi-1-k\t@\ni=1\nDeve-se observar que o acr\u00e9scimo de expressividade obtido com a inclus\u00e3o da parte\nfracion\u00e1ria veio com o preju\u00edzo do intervalo de n\u00fameros inteiros represent\u00e1veis, que passa dos poss\u00edveis pn da nota\u00e7\u00e3o de inteiros para pn-k.\nEntretanto, como a cada n\u00famero inteiro represent\u00e1vel foram acrescentados pk parti\u00e7\u00f5es decimais, verifica-se que a quantidade total de valores represent\u00e1veis n\u00e3o se altera, ou seja,\npn-k x pk = pn.\nApesar da redu\u00e7\u00e3o no intervalo de n\u00fameros inteiros represent\u00e1veis, a quantidade de valores represent\u00e1veis continua sendo pn.\nUm detalhe importante relativo \u00e0 nota\u00e7\u00e3o de ponto-fixo \u00e9 que a sua precis\u00e3o de representa\u00e7\u00e3o depende da quantidade de d\u00edgitos reservados \u00e0 representa\u00e7\u00e3o da parte fracion\u00e1ria do n\u00famero. Para a configura\u00e7\u00e3o de ponto-fixo apresentada na Equa\u00e7\u00e3o I.3, essa precis\u00e3o \u00e9 de 2-k.\n1.3\tNota\u00e7\u00e3o de ponto-flutuante\nA nota\u00e7\u00e3o de ponto-flutuante pode ser considerada uma extens\u00e3o da nota\u00e7\u00e3o de ponto-fixo, a qual teve seu poder de representa\u00e7\u00e3o ampliado pelo acr\u00e9scimo de mais um grupo de d\u00edgitos denominado campo expoente.\nOutra mudan\u00e7a implementada pela nota\u00e7\u00e3o de ponto-flutuante em rela\u00e7\u00e3o \u00e0 nota\u00e7\u00e3o de ponto-fixo \u00e9 que os d\u00edgitos reservados \u00e0 representa\u00e7\u00e3o da parte inteira e da parte fracion\u00e1ria passam a receber o nome de significando, indicando que estes armazenam conjuntamente os d\u00edgitos significativos do valor representado.\nDiferentemente do que ocorre nas nota\u00e7\u00f5es de inteiros e de ponto-fixo, na nota\u00e7\u00e3o de ponto-flutuante, o valor expresso deixa de ser uma aplica\u00e7\u00e3o direta da nota\u00e7\u00e3o posicional para ser o resultado da intera\u00e7\u00e3o dos valores representados no expoente e no significando. Seu valor pode ser calculado por meio da seguinte express\u00e3o:\n\u00b1S x pe,\nem que S denota o valor representado pelo campo significando, p a base num\u00e9rica adotada e e o valor representado pelo campo expoente.\n1.4\tO padr\u00e3o IEEE 754\nO padr\u00e3o IEEE 754 (P754, 1985) define os requisitos m\u00ednimos a serem seguidos na implementa\u00e7\u00e3o da aritm\u00e9tica de ponto-flutuante para a base bin\u00e1ria.\nNo padr\u00e3o de ponto-flutuante, o valor expresso deixa de ser representado diretamente por meio da nota\u00e7\u00e3o posicional para ser representado por conven\u00e7\u00e3o, mediante uma estrutura de dados com tr\u00eas campos distintos denominados sinal, expoente e significando. Esses tr\u00eas campos\nficam armazenados em uma mesma palavra bin\u00e1ria, distribu\u00eddos conforme indicado na Figura\nI.1.\nBit de Sinal\nBits do campo expoente\nBits da fra\u00e7\u00e3o do campo significando\nFigura I.1: Organiza\u00e7\u00e3o dos campos que formam a representa\u00e7\u00e3o do padr\u00e3o de ponto-flutuante.\nO sinal alg\u00e9brico \u00e9 representado por um \u00fanico bit, que \u00e9 carregado com zero para indicar que o n\u00famero \u00e9 positivo e com um para indicar que esse \u00e9 negativo.\nO campo expoente \u00e9 representado por refer\u00eancia, mediante a diferen\u00e7a entre o valor nele armazenado e um valor de refer\u00eancia ou bias, o qual est\u00e1 associado ao expoente zero. Essa estrat\u00e9gia permite, ao mesmo tempo, tanto a representa\u00e7\u00e3o de valores positivos e negativos quanto simplifica o projeto do hardware necess\u00e1rio para as opera\u00e7\u00f5es de compara\u00e7\u00e3o de magnitude entre dois ou mais n\u00fameros.\nO campo signficando \u00e9 representado na nota\u00e7\u00e3o de ponto-fixo normalizado, ou seja, com apenas um d\u00edgito na sua parte inteira, sendo este diferente de zero.\n\u00c9 o processo de normaliza\u00e7\u00e3o do significando que garante toda a plasticidade do padr\u00e3o de ponto-flutuante, ou seja, a sua capacidade de se autoadaptar ao valor a ser representado, permitindo que o valor armazenado seja sempre representado com a melhor precis\u00e3o poss\u00edvel.\n\u00c9 ainda o processo de normaliza\u00e7\u00e3o do significando que determina o valor a ser armazenado no campo expoente. Como cada deslocamento do significando \u00e0 direita equivale na pr\u00e1tica a multiplic\u00e1-lo por dois, da mesma forma que cada deslocamento \u00e0 esquerda corresponde a dividi-lo por dois, para manter o valor originalmente representado pelo significando, cada deslocamento deve ser compensado respectivamente por incrementos ou decrementos do valor atribu\u00eddo ao campo expoente.\nEm consequ\u00eancia da ado\u00e7\u00e3o da representa\u00e7\u00e3o normalizada do significando, como uma forma de economizar espa\u00e7o de armazenamento, o padr\u00e3o IEEE 754 estabelece que apenas os bits que representam a parte decimal do significando sejam armazenados. Por essa raz\u00e3o, o conjunto de bits armazenado recebe o nome de mantissa ou fra\u00e7\u00e3o do significando. Por ter seu valor definido implicitamente, a partir da ado\u00e7\u00e3o do padr\u00e3o normalizado, e n\u00e3o por ter sido armazenado, o bit que representa a parte inteira do significando \u00e9 muitas vezes denominado de bit impl\u00edcito.\nAl\u00e9m dos valores normalizados, o padr\u00e3o IEEE 754 prev\u00ea que valores com magnitude menor que o menor valor pass\u00edvel de reapresenta\u00e7\u00e3o normalizada, os quais exigiriam que o expoente assumisse um valor menor que o menor expoente represent\u00e1vel, possam ser armazenados de forma n\u00e3o normalizada, ou desnormalizada. Nesse caso, a fim de sinalizar essa ocorr\u00eancia, o campo expoente deve ser carregado com o valor absoluto zero, o qual passa ent\u00e3o a ser reservado apenas para a indica\u00e7\u00e3o desse tipo de ocorr\u00eancia. Esses valores s\u00e3o designados como valores denormais. Um exemplo not\u00e1vel de valor denormal \u00e9 o pr\u00f3prio n\u00famero zero.\nO padr\u00e3o determina tamb\u00e9m que valores com magnitude maior que o maior valor represent\u00e1vel, os quais exigiriam que o expoente assumisse um valor maior que o maior expoente v\u00e1lido, devem ser sinalizados como infinito. Essa sinaliza\u00e7\u00e3o \u00e9 feita carregando todos os bits do campo expoente com um e todos os bits do significando com o valor zero. Nessa representa\u00e7\u00e3o o valor do bit que representa o sinal alg\u00e9brico \u00e9 preservado a fim de permitir a indica\u00e7\u00e3o da ocorr\u00eancia do mais e do menos infinito, (\u00b1\u00ab>).\n\u00c9 determinada tamb\u00e9m uma representa\u00e7\u00e3o especial para sinalizar resultados de opera\u00e7\u00f5es que n\u00e3o resultam em n\u00famero, como o caso da divis\u00e3o de zero por zero. Ocorr\u00eancias desse tipo s\u00e3o sinalizadas carregando todos os bits do campo expoente com um e o campo significando com um valor diferente de zero. Esses valores s\u00e3o denominados pela sigla NaN, acr\u00f4nimo do termo em ingl\u00eas Not a Number, que significa literalmente que o valor armazenado n\u00e3o \u00e9 um n\u00famero.\nDessa forma, o valor de um n\u00famero armazenado em uma representa\u00e7\u00e3o de ponto-flutuante com n bits no campo significando e k bits no campo expoente pode ser recuperado por meio da seguinte express\u00e3o:\n- 1s x \u00bf bi x 2i-n-1 x 2e-bias+1 i=1\nna qual s representa o sinal alg\u00e9brico, bi representa cada um dos bits do campo significando, e representa o valor armazenado nos bits do campo expoente e bias representa o valor de refer\u00eancia para o campo expoente. O valor do bias \u00e9 definido atrav\u00e9s da seguinte express\u00e3o:\nbias = 2k-1-1.\nI.4.1\tFormato de representa\u00e7\u00e3o dos dados\nO padr\u00e3o IEEE 754 estabelece quatro formatos de representa\u00e7\u00e3o dos dados, os quais est\u00e3o divididos pelo tipo de nota\u00e7\u00e3o adotada, que pode ser b\u00e1sica ou estendida, e pela sua precis\u00e3o, podendo ser de precis\u00e3o simples ou dupla.\nOs formatos estabelecidos s\u00e3o:\n\u25a0\tponto-flutuante de nota\u00e7\u00e3o b\u00e1sica e precis\u00e3o simples, tamb\u00e9m conhecido como float, com 32 bits;\n\u25a0\tponto-flutuante de nota\u00e7\u00e3o b\u00e1sica e precis\u00e3o dupla, ou double, com 64 bits;\n\u25a0\tponto-flutuante de nota\u00e7\u00e3o estendida e precis\u00e3o simples, ou float extended, com 43 bits ou mais;\n\u25a0\tponto-flutuante de nota\u00e7\u00e3o estendida e precis\u00e3o dupla, ou double extended, com 79 bits ou mais.\nSegundo esse padr\u00e3o, um formato de ponto-flutuante pode ser totalmente definido pela especifica\u00e7\u00e3o dos seguintes par\u00e2metros de configura\u00e7\u00e3o:\n206 AP\u00caNDICE I. REVIS\u00c3O SOBRE PADR\u00d5ES DE REPRESENTA\u00c7\u00c3O NUM\u00c9RICA\n\u25a0\tp: que representa o n\u00fameros de bits do campo significando;\n\u25a0\tEmin e Emax: representando respectivamente o expoente m\u00ednimo e m\u00e1ximo represent\u00e1veis;\n\u25a0\tBias: que representa o valor de refer\u00eancia para o campo expoente.\nA Tabela I.1, a seguir, apresenta os valores dos par\u00e2metros de configura\u00e7\u00e3o dos quatro formatos de ponto-flutuante definidos pelo padr\u00e3o IEEE 754.\nTabela I.1: Valores padr\u00e3o para os par\u00e2metros de configura\u00e7\u00e3o dos quatro formatos de ponto-flutuante.\nCampos\tSimples Float\tSimples Estendido Extended float\tDuplo Double\tDuplo estendido Estendido Extended double\nSinal( S )\t1 bit\t1 bit\t1 bit\t1 bit\nSignificando( P )\t24 bits\t> 32 bits\t53 bits\t> 64 bits\nExpoente(E)\t8 bits\t> 11 bits\t11 bits\t> 15 bits\nExpoente emax\t+127\t> +1023\t+1023\t> +16383\nExpoente emin\t-126\t> -1022\t-1022\t> -16382\nBias\t+127\tN\u00e3o definido\t1023\tN\u00e3o definido\nA fim de garantir a unicidade da representa\u00e7\u00e3o, evitando, com isso, representa\u00e7\u00f5es num\u00e9ricas redundantes, o padr\u00e3o 1EEE 754 estabeleceu que o significando de todos os n\u00fameros seja expresso com a sua parte inteira representada por um \u00fanico bit, sendo este diferente de zero. Essa medida impede que n\u00fameros como o 1,0, por exemplo, tenham diversas representa\u00e7\u00f5es redundantes, tais como 1,0 x 20 ou 0,1 x 21 ou ainda 0,01 x 22. Al\u00e9m de garantir a unicidade de representa\u00e7\u00e3o, isso permite tamb\u00e9m para a dispensa do armazenamento do d\u00edgito que representa a parte inteira do significando, uma vez que que o seu conte\u00fado \u00e9 conhecido a priori.\nPor esse motivo, o padr\u00e3o 1EEE 754 estabelece que apenas os bits que formam a parte fracion\u00e1ria do significando seja armazenada, ou seja, a sua fra\u00e7\u00e3o. Ao bit que n\u00e3o \u00e9 armazenad, d\u00e1-se o nome de bit impl\u00edcito, visto que sua representa\u00e7\u00e3o \u00e9 impl\u00edcita pelo uso da representa\u00e7\u00e3o normalizada. Essa \u00e9 a forma de representa\u00e7\u00e3o considerada padr\u00e3o para todas as nota\u00e7\u00f5es de ponto-flutuante que atendem ao padr\u00e3o 1EEE 754. Assim, todo e qualquer n\u00famero que atende a essa nota\u00e7\u00e3o \u00e9 definido como normalizado e, qualquer representa\u00e7\u00e3o diferente dessa, \u00e9 considerada desnormalizada.\nI.4.2\tRepresenta\u00e7\u00e3o de valores especiais\nA fim de corrigir incongru\u00eancias de representa\u00e7\u00e3o entre a nota\u00e7\u00e3o adotada no padr\u00e3o 1EEE 754 e a aritm\u00e9tica cl\u00e1ssica, foram definidas algumas representa\u00e7\u00f5es especiais para valores que, de outra forma, n\u00e3o seriam represent\u00e1veis.\nEssa abordagem adotada pelo 1EEE 754 n\u00e3o encontra equival\u00eancia em outros padr\u00f5es de representa\u00e7\u00e3o num\u00e9rica utilizado nos sistemas computacionais. No padr\u00e3o adotado no sistema 1BM 370, por exemplo, todos os padr\u00f5es de bits poss\u00edveis s\u00e3o utilizados para representar valores num\u00e9ricos v\u00e1lidos. Dessa forma, nos sistemas 1BM 370, todas as opera\u00e7\u00f5es que possam dar origem a valores n\u00e3o represent\u00e1veis s\u00e3o encerradas como uma exce\u00e7\u00e3o acompanhada de uma mensagem de texto indicando a condi\u00e7\u00e3o de falha (GOLDBERG, 1991).\nNo padr\u00e3o 1EEE754 foram definidas representa\u00e7\u00f5es especiais para os seguintes casos:\n\u25a0\tZero: no padr\u00e3o IEEE 754, o zero \u00e9 representado por conven\u00e7\u00e3o, com os campos mantissa e expoente iguais a zero. Essa padroniza\u00e7\u00e3o se fez necess\u00e1ria porque, por motivos \u00f3bvios, o zero n\u00e3o pode ser expresso de maneira normalizada. Outro detalhe importante na representa\u00e7\u00e3o do zero no padr\u00e3o IEEE 754 \u00e9 que este disp\u00f5e de sinal, ou seja, existem +0 e -0. Entretanto, a opera\u00e7\u00e3o de compara\u00e7\u00e3o entre dois zeros retorna sempre verdadeira, independentemente do sinal que estes assumam. A representa\u00e7\u00e3o do zero com sinal \u00e9 \u00fatil para definir o sinal do resultado de opera\u00e7\u00f5es envolvendo o zero, as quais, em alguns casos, podem dar origem a \u25a0 ^ e \u2014<*>.\n\u25a0\tNaN: essa sinaliza\u00e7\u00e3o, que literalmente significa que o valor armazenado n\u00e3o \u00e9 um n\u00famero, \u00e9 reservada para ser utilizada como resultado de diversas opera\u00e7\u00f5es aritm\u00e9tica, tais como 0/0 e 0 x&lt;\u00bb que, por defini\u00e7\u00e3o, devem ser sinalizadas como inconsistentes. Qualquer opera\u00e7\u00e3o aritm\u00e9tica em que pelo menos um dos operandos seja NaN deve tamb\u00e9m retornar um NaN como resultado. Todas as opera\u00e7\u00f5es aritm\u00e9ticas de compara\u00e7\u00e3o =,&lt;,&lt;, >, >) exceto =, em que pelo menos um dos operandos seja NaN devem retornar falso. O bit de sinal n\u00e3o tem fun\u00e7\u00e3o associada na representa\u00e7\u00e3o do NaN. O NaN \u00e9 representado com o campo expoente carregado com todos os seus bits iguais a 1, e o campo mantissa com um valor diferente de zero.\n\u25a0\tInfinito: a representa\u00e7\u00e3o de Infinito (\u00ab>) est\u00e1 reservada para demonstrar que um determinado n\u00famero \u00e9, em m\u00f3dulo, maior que o maior n\u00famero represent\u00e1vel. A sinaliza\u00e7\u00e3o de Infinito tanto pode ser gerada em resposta a uma opera\u00e7\u00e3o aritm\u00e9tica como durante o processo de normaliza\u00e7\u00e3o e arredondamento. A semelhan\u00e7a da representa\u00e7\u00e3o do valor zero, o Infinito tamb\u00e9m tem sinal associado, o qual \u00e9 \u00fatil para preservar o sinal das opera\u00e7\u00f5es aritm\u00e9ticas. O Infinito \u00e9 representado com o campo expoente carregado com todos os seus bits iguais a um e o campo mantissa com o valor zero\n\u25a0\tDenormal: esta representa\u00e7\u00e3o foi adotada para suprir a necessidade de sinalizar corretamente uma faixa de valores que, por serem em m\u00f3dulos menores que o menor valor represent\u00e1vel de maneira normalizada, acabam sendo convertidos para zero durante o processo de normaliza\u00e7\u00e3o e arredondamento. A Figura I.2 destaca a localiza\u00e7ao desses valores e o resultado da sua inclus\u00e3o destes na distribui\u00e7\u00e3o dos valores represent\u00e1veis. A fim de sinalizar que esses valores n\u00e3o atendem \u00e0 norma, \u00e0 semelhan\u00e7a do que ocorre com o n\u00famero zero, eles s\u00e3o representados com o campo expoente igual a zero.\nFigura I.2: Distribui\u00e7\u00e3o dos valores represent\u00e1veis em ponto-flutuante, destacando a faixa de valores que seria representada pelos valores denormalizados.\nA Tabela I.2 traz um resumo dos valores especiais e suas representa\u00e7\u00f5es no padr\u00e3o IEEE 754.\nTabela I.2: Valores especiais e suas representa\u00e7\u00f5es segundo o padr\u00e3o IEEE 754.\n\tSinal\tExpoente\t\tFra\u00e7\u00e3o do significando\n+Zero\t0\t000 \u2022\u2022\t0\t000---0\n-Zero\t1\t000 \u2022\u2022\t0\t000---0\n+Infinito\t1\t111 \u2022\u2022\t1\t000---0\n- 1n finito\t0\t111 \u2022\u2022\t1\t000---0\nDenormal\t1\t000 \u2022\u2022\t0\tNNN- N\nObs.: Na Tabela I.2 NNN...N denota uma palavra bin\u00e1ria onde pelo menos um dos seus bits \u00e9 diferente de zero.\nI.4.3\tArredondamento\nO termo arredondamento, segundo o padr\u00e3o IEEE 754 \u00e9 o processo de ajustar ou encaixar um n\u00famero tido como infinitamente preciso para um formato de menor precis\u00e3o (P754, 1985).\nAo trabalhar com n\u00fameros em ponto-flutuante, deve-se ter em mente que o processo de arredondamento introduzir\u00e1 um erro no n\u00famero arredondado, uma vez que este \u00e9, na verdade, uma aproxima\u00e7\u00e3o do valor original.\nDiversos s\u00e3o os relatos de falhas em sistemas ocasionadas por esses erros de arredondamento (HUCKLE, 2014). Padr\u00f5es mais recentes de representa\u00e7\u00e3o, tais como o IEEE 854 e o IEEEP 754, buscam minimizar esses erros adotando outras bases num\u00e9ricas e/ou uma representa\u00e7\u00e3o com maior precis\u00e3o.\nExistem, a princ\u00edpio, duas situa\u00e7\u00f5es nas quais um n\u00famero real n\u00e3o pode ser representado de forma exata em uma nota\u00e7\u00e3o de ponto-flutuante. A primeira \u00e9 quando o n\u00famero n\u00e3o encontra representa\u00e7\u00e3o finita na base bin\u00e1ria, e a segunda \u00e9 quando, ainda que encontrando uma\nrepresenta\u00e7\u00e3o, esta exige uma precis\u00e3o maior que a dispon\u00edvel no formato de ponto-flutuante adotado.\nOutra situa\u00e7\u00e3o que impede que um n\u00famero seja representado \u00e9 quando este \u00e9 menor que o menor ou maior que o maior n\u00famero represent\u00e1vel no formato de ponto-flutuante adotado. Nesses casos o n\u00famero \u00e9 convertido para + ou \u2014infinito ou para zero.\nDo ponto de vista da implementa\u00e7\u00e3o, a opera\u00e7\u00e3o de arredondamento nada mais \u00e9 que um processo de mapeamento, em que se busca identificar, dentre todos os n\u00fameros represent\u00e1veis na nota\u00e7\u00e3o destino, aquele que melhor represente o valor a ser arredondado.\nConsiderem-se, por exemplo, F1 e F2, dois sistemas de ponto-flutuante. F1 representado com um significando com n1 d\u00edgitos e F2 representado com n2 d\u00edgitos, sendo n1 > n2. Verificase que todo o n\u00famero represent\u00e1vel em F1 ou ser\u00e1 precisamente represent\u00e1vel em F2 ou sua representa\u00e7\u00e3o estar\u00e1 entre dois outros n\u00fameros represent\u00e1veis em F1, aos quais denominaremos de adjacente superior e adjacente inferior.\nEssa caracter\u00edstica pode ser explicada pelo fato de o significando ser representado em uma nota\u00e7\u00e3o de ponto-fixo com apenas um bit na sua parte inteira. Por esse motivo, a diferen\u00e7a de representa\u00e7\u00e3o dos significandos se dar\u00e1 sempre pela sua capacidade de expressar a parte fracion\u00e1ria do n\u00famero representado. A Figura I.3 demonstra a diferen\u00e7a entre o poder de representa\u00e7\u00e3o de um significando com 5 bits quando comparado com um de 3 bits.\np=5\t-1\t0\t1\n2'1\t2\"22 32 4\t11111111111111111111111111111111111111111111111111111111111111\np=3\t-1\t0\t1\n\u2022po 2 2\"^\tl\tI\tl\tI\tl\tI\tl\nI I\tI I I I I I I I I I I I\nFigura I.3: Diferen\u00e7a na representa\u00e7\u00e3o entre um significando com 3 e um com 5 bits.\nComo se pode perceber, valores m\u00faltiplos de 2\u20142 como 0, 1, 1/2 ou 3/4 podem ser representados precisamente tanto na primeira quanto na segunda nota\u00e7\u00e3o. Entretanto, valores m\u00faltiplos de 2\u20143 e 2\u20144 que n\u00e3o forem m\u00faltiplo de 2\u20142, tais como 1/8 ou3/16, s\u00f3 podem ser representados precisamente em F1, tendo que ser aproximados, ou arredondados, em F2.\nNa Figura I.4, ve-se em destaque um conjunto de valores existentes no intervalo entre 0 e 1/4 de F1 que precisam ser arredondados para serem representados em F2.\nNesse caso, cada um dos valores representados ter\u00e1 de ser arredondado ou para 0 ou para 1/4, uma vez que estes s\u00e3o, respectivamente, seus adjacentes inferior e superior em F2. A escolha de qual desses valores ser\u00e1 utilizado \u00e9 determinada conforme o modo de arredondamento adotado.\nO padr\u00e3o IEEE 754 prev\u00ea quatro modos de arredondamento:\n\u25a0\tArredondamento em dire\u00e7\u00e3o ao zero (Round to Zero)\n\u25a0\tArredondamento em dire\u00e7\u00e3o ao +Infinito (Round to +Infinity)\nFigura I.4: Compara\u00e7\u00e3o entre valores represent\u00e1veis com significandos com 5 e 3 bits.\n\u25a0\tArredondamento em dire\u00e7\u00e3o ao -Infinito (Round to -Infinity)\n\u25a0\tArredondamento para o mais pr\u00f3ximo ou par (Round to Nearest Even).\nI.4.3.1\tModos de Arredondamento\n\u25a0 Arredondamento em dire\u00e7\u00e3o ao zero (Round to Zero) : neste modo, conforme ilustrado na Figura I.5, o n\u00famero a ser operado \u00e9 arredondado para o primeiro valor represent\u00e1vel em dire\u00e7\u00e3o ao zero. Essa \u00e9, certamente, a forma mais simples e direta de arredondamento. Na pr\u00e1tica, apenas se eliminam os bits al\u00e9m do \u00faltimo bit represent\u00e1vel fazendo com que o n\u00famero resultante esteja assim mais pr\u00f3ximo do zero que o n\u00famero original.\nRound to Zero\n----\u25ba \u25c4------\n1 0 1\nFigura I.5: Arredondamento em dire\u00e7\u00e3o ao Zero.\n\u25a0 Arredondamento em dire\u00e7\u00e3o ao +Infinito (Round to +Infinity): Neste modo, arredonda-se o n\u00famero para o n\u00famero represent\u00e1vel mais pr\u00f3ximo em dire\u00e7\u00e3o ao infinito positivo. Desta forma, n\u00fameros negativos devem que ser arredondados para o seu adjacente inferior, enquanto n\u00fameros positivos devem ser arredondados para o seu adjacente superior.\nRound to +oo\nFigura I.6: Dire\u00e7\u00e3o do arredondamento em dire\u00e7\u00e3o ao +~.\n\u25a0 Arredondamento em dire\u00e7\u00e3o ao -Infinito (Round to -Infinity):este formato \u00e9 semelhante ao anterior, diferindo apenas pelo fato de que o arredondamento se dar\u00e1 sempre para o n\u00famero represent\u00e1vel mais pr\u00f3ximo em dire\u00e7\u00e3o ao infinito negativo. Dessa forma, n\u00fameros negativos devem que ser arredondados para o seu adjacente superior, enquanto n\u00fameros positivos devem ser arredondados para o seu adjacente inferior.\nRound to -oo\n1 0 1\nFigura I.7: Dire\u00e7\u00e3o do arredondamento em dire\u00e7\u00e3o ao -~.\n\u25a0 Arredondamento para o mais pr\u00f3ximo ou par (Round to Nearest Even): neste modo busca-se o arredondamento para o n\u00famero represent\u00e1vel mais pr\u00f3ximo do valor originalmente calculado e, havendo empate entre dois n\u00fameros igualmente distantes, decide-se sempre pelo adjacente que for par.\nEsse \u00e9 o formato mais utilizado nas implementa\u00e7\u00f5es do padr\u00e3o IEEE 754, tanto em software quanto em hardware. Tamb\u00e9m \u00e9 aquele que apresenta os resultados mais exatos. Em contrapartida, \u00e9 tamb\u00e9m aquele que exige mais recurso computacional para ser implementado. Esse modo de arredondamento s\u00f3 n\u00e3o apresenta os melhores resultados quando a sua aplica\u00e7\u00e3o resulta em um n\u00famero que, ap\u00f3s a normaliza\u00e7\u00e3o, se transforme em um n\u00famero maior que o maior ou menor que o menor n\u00famero represent\u00e1vel, o qual acaba sendo convertido ou para infinito ou para zero.\nExistem na literatura diversas propostas de implementa\u00e7\u00e3o para esse modo de arredondamento, incluindo varia\u00e7\u00f5es que, de modo geral, buscam melhorar o seu desempenho ou reduzir o hardware e/ou o tamanho de c\u00f3digo necess\u00e1rio \u00e0 sua implementa\u00e7\u00e3o (EVEN; PAUL, 2000; QUACK; KAKAQI; FLYNN, 1991; SANTORO; BEWICK; HAROWITZ, 1989).\nFigura I.8: Dire\u00e7\u00e3o do arredondamento para o mais pr\u00f3ximo ou par.\nAs Figuras I.10 e I.11 trazem dois exemplos de n\u00fameros gerados originalmente com um significando com 5 bits e suas representa\u00e7\u00f5es ap\u00f3s terem sido arredondados, seguindo os m\u00e9todos apresentados, para um significando com apenas 3 bits.\nFigura I.10: Exemplo de Arredondamento para o mais pr\u00f3ximo e em dire\u00e7\u00e3o ao zero.\nOs quatro modos de arredondamento definidos no padr\u00e3o IEEE 754 compartilham de um mesmo processo inicial de pr\u00e9- processamento, que tem como objetivo a gera\u00e7\u00e3o de um\nsignificando pr\u00e9- arredondado e a obten\u00e7\u00e3o de algumas outras informa\u00e7\u00f5es que orientar\u00e3o o restante do processo de arredondamento.\nDe modo geral, dado um n\u00famero em ponto-flutuante com um significando com m bits, que se deseja arredondar para uma representa\u00e7\u00e3o com n bits, primeiramente separam-se os n bits mais significativos do significando original, a fim de formar o significando pr\u00e9-arredondado. Em seguida, identificam-se tr\u00eas bits especiais denominados LSB-Bit (Least Significant Bit), Guard-Bit e Sticky-Bit, que s\u00e3o obtidos do significando original conforme indicado no esquema da Figura 4.2.\nFigura I.11: Esquema para obten\u00e7\u00e3o do LSB bit, do Guard bit e do Sticky bit.\nPor fim, durante o processo de arredondamento, a partir da an\u00e1lise do modo de arredondamento, do sinal do n\u00famero a ser arredondado e dos tr\u00eas bits especiais, define-se o valor a ser atribu\u00eddo a um quarto bit, denominado Round-Bit, que deve ser adicionado ao significando pr\u00e9-arredondado a fim de obter o significando final arredondado, conforme mostra a figura I.12.\nnBits\n2\u00bb 2-' 2-2 2-\u2019 2-\n\t!\u2022\u00ab\n\ti\t_A\nn Bits\t1\u20141\t\" s Y Stickybit\nA,\t\n2\u00b0^ 2'1 2J 2J 2<\u201d>\t\n\t\t\u00ae \t!\u2022 1 \u2022\nt'\n~\tSticky bit\nFigura I.12: Nova organiza\u00e7\u00e3o dos bits para simplificar a an\u00e1lise do processo de arredondamento.\nCom rela\u00e7\u00e3o aos bits especiais, o bit Guard-Bit, conforme se pode observar na Figura\n4.2,\tdividir\u00e1 os bits do significando original em dois grupos, um \u00e0 esquerda, com os n bits mais significativos, os quais formar\u00e3o o significando pr\u00e9- arredondado, e um \u00e0 direita, com o\nrestante dos bits que ser\u00e3o descartados. O Sticky-Bit indica se algum bit do grupo de bits \u00e0 direita do Guard-Bit \u00e9 diferente de zero. O LSB-Bit \u00e9 o bit menos significativo do significando pr\u00e9-arredondado.\nNeste ponto, apenas para simplificar a an\u00e1lise do processo de arredondamento, os bits do significando foram reorganizados, deslocando o ponto separador da sua posi\u00e7\u00e3o original para a posi\u00e7\u00e3o entre o LSB-Bit e o Guard-Bit, conforme disposto na Figura I.12.\nEssa nova organiza\u00e7\u00e3o dos bits torna-se interessante porque nos permite visualizar o processo de arredondamento de um n\u00famero qualquer como o processo de arredondamento de um n\u00famero fracion\u00e1rio para um n\u00famero inteiro. Dado que todo n\u00famero fracion\u00e1rio situa-se no intervalo definido por seus dois inteiros adjacentes, como se pode ver no esquema a seguir, pode-se resumir o nosso processo de arredondamento como o processo de escolha para qual desses dois inteiros adjacentes o n\u00famero fracion\u00e1rio dever\u00e1 ser arredondado.\n(n +1)\nn x zzz \u2022\u2022\u2022 zz\n(n)\nDessa forma, considerando o esquema proposto, t\u00eam-se os seguintes exemplos:\na)\t10 \u2014 9.2F \u2022 \u2022 \u2014> 9 (9.21 pode ser arrendondado para 9 ou para 10);\nb)\t3 \u2014 2.73- \u2022 \u2022 \u2014> 2 (2.73 pode ser arrendondado para 2 ou para 3);\nc)\t236 \u2014 235.21 \u2022 \u2022 \u2022 \u2014> 235 (235.21 pode ser arrendondado para 235 ou para 236).\nAssim, pode-se perceber que o que est\u00e1 envolvido no processo de arredondamento de um n\u00famero Real qualquer, n\u00e3o represent\u00e1vel em uma determinada nota\u00e7\u00e3o de ponto-flutuante, \u00e9 o processo de mapeamento ou escolha entre qual dos seus adjacentes represent\u00e1veis nessa nota\u00e7\u00e3o o substituir\u00e1. Nessa escolha, o modo de arredondamento adotado \u00e9 que nortear\u00e1, em \u00faltima inst\u00e2ncia, a escolha de qual dos dois adjacentes dever\u00e1 ser utilizado.\nDesse modo, ap\u00f3s a execu\u00e7\u00e3o dos passos iniciais, aplica-se o algoritmo de arredondamento espec\u00edfico associado ao modo de arredondamento escolhido de forma a poder valorar adequadamente o Round-Bit.\nFigura I.13: Gera\u00e7\u00e3o do novo significando por meio dos bits extra\u00eddos do significando original e do Round bit obtido durante o processo de arredondamento.\n2<n-n\tX 2\u201c\nl\u00b0l\u00b0l\u00b0H\tl\u00abl\n\tpo o\n\t\u00a7\n\ttf\n\tX\n\t2\u00b0\nswwrz\t1*1\nO valor atribu\u00eddo ao Round-Bit definir\u00e1, em \u00faltima inst\u00e2ncia, para qual dos n\u00fameros adjacentes represent\u00e1veis o n\u00famero original ser\u00e1 arredondado, de tal forma que:,\nQuando o Round Bit for zero, arredondar-se-\u00e1 o n\u00famero para o valor adjacente inferior, ou seja, para aquele com o menor valor em m\u00f3dulo.\nPor outro lado, quando o Round Bit for um, arredondar-se-\u00e1 o n\u00famero para o adjacente superior, ou seja, para aquele que tem o maior valor em m\u00f3dulo.\n1.4.3.2\tAlgoritmo do modo de arredondamento em dire\u00e7\u00e3o ao zero\nNeste modo de arredondamento o n\u00famero ser\u00e1 sempre arredondado para o seu adjacente inferior, ou para aquele adjacente que esteja mais pr\u00f3ximo do zero, conforme indica a Figura I.5. Para tanto, simplesmente atribui-se zero ao Round Bit. Em s\u00edntese, simplesmente se eliminam os bits excedentes do significando a ser arredondado, preservando os n bits mais significativos como o significando arredondado.\n1.4.3.3\tAlgoritmo do modo de arredondamento em dire\u00e7\u00e3o ao + e ao - Infinito\nUma vez que o algoritmo utilizado no modo de arredondamento em dire\u00e7\u00e3o ao +Infinito \u00e9 muito semelhante ao aplicado no modo de arredondamento em dire\u00e7\u00e3o ao -Infinito, ser\u00e3o apresentados primeiramente os detalhes do algoritmo para o modo de arredondamento em Dire\u00e7\u00e3o ao -Infinito; em seguida, apenas ser\u00e3o indicados os passos que diferenciam esse procedimento do adotado no modo de arredondamento em dire\u00e7\u00e3o ao +Infinito.\nNo modo de Arredondamento em Dire\u00e7\u00e3o ao -Infinito, conforme se pode observar da Figura I.7 , os n\u00fameros positivos devem ser arredondados para o seu adjacente inferior, enquanto os n\u00fameros negativos devem ser arredondados para o seu adjacente superior. Para atingir tal objetivo, aproveita-se o fato de o bit de sinal ter valor zero para n\u00fameros positivos e um para n\u00fameros negativos, e apenas atribui-se o bit de sinal diretamente ao Round-Bit, de tal forma que o Round-Bit seja igual a zero para os n\u00fameros positivos e um para os n\u00fameros negativos.\nNo modo de Arredondamento em Dire\u00e7\u00e3o ao +Infinito, aplica-se a mesma l\u00f3gica, com a \u00fanica diferen\u00e7a que o Round-Bit \u00e9 obtido por meio do inverso do bit de Sinal. Assim esse bit ser\u00e1 zero quando se estiver arredondando um n\u00famero negativo e um quando o n\u00famero for positivo.\n1.4.3.4\tAlgoritmo do modo de arredondamento em dire\u00e7\u00e3o ao mais pr\u00f3ximo ou par\nComo o pr\u00f3prio nome diz, neste modo busca-se arredondar o n\u00famero para o adjacente represent\u00e1vel que estiver mais pr\u00f3ximo do n\u00famero original, ou, em caso de empate, para o adjacente que for par.\nDessa forma, conforme indicado na Figura I.8, n\u00e3o se pode definir para qual dos adjacentes um determinado n\u00famero ser\u00e1 arredondado sem antes proceder a uma an\u00e1lise do n\u00famero a ser arredondado, o que \u00e9 feito atrav\u00e9s do Guard-Bit, do Sticky-Bit e do LSB-Bit.\nSegundo o esquema proposto na Figura I.12, o Guard Bit estar\u00e1 diretamente associado ao valor atribu\u00eddo ao bit ponderado com 2-1, ou 0,5, no somat\u00f3rio das partes que comp\u00f5em essa nova parte fracion\u00e1ria do n\u00famero. O Sticky Bit, por sua vez, est\u00e1 associado \u00e0 ocorr\u00eancia de um valor diferente de zero no somat\u00f3rio dos bits que tenham peso associado menor que2-1. O esquema proposto na Figura I.14 demonstra como se procede a essa an\u00e1lise.\nFigura I.14: Localiza\u00e7\u00e3o do valor relativo do n\u00famero a ser arredondado por meio do Guard Bit e do Sticky Bit.\nPrimeiramente, observa-se a parte fracion\u00e1ria do n\u00famero atrav\u00e9s dos valores atribu\u00eddos ao Guard-bit e ao Sticky-bit. Nessa observa\u00e7\u00e3o podem-se chegar \u00e0s seguintes situa\u00e7\u00f5es:\na)\tO Guard-bit e o Sticky-bit s\u00e3o ambos iguais a \u20191\u2019, o que indica que a parte fracion\u00e1ria do n\u00famero \u00e9 maior que 0,5; portanto, o n\u00famero a ser arredondado est\u00e1 mais pr\u00f3ximo do seu adjacente superior do que do seu adjacente inferior. Nesse caso o Round-bit deve ser feito igual a \u20191\u2019.\nb)\tO Guard-bit e o Sticky-bit s\u00e3o ambos iguais a \u20190\u2019, o que indica que a parte fracion\u00e1ria do n\u00famero \u00e9 tamb\u00e9m igual a \u20190\u2019; portanto, o n\u00famero \u00e9 coincidente com o seu adjacente inferior. Nesse caso o Round-bit deve ser feito igual a \u20190\u2019.\nc)\tO Guard-bit \u00e9 \u20190\u2019 e o Sticky-bit \u00e9 \u20191\u2019, o que indica que a parte fracion\u00e1ria do n\u00famero \u00e9 menor que 0,5, mas maior que \u20190\u2019, estando, dessa forma, o n\u00famero mais pr\u00f3ximo do seu adjacente inferior do que do adjacente superior. Nesse caso o Round-bit deve ser feito igual a \u20190\u2019.\nd)\tO Guard-bit \u00e9 \u20191\u2019 e o Sticky-bit \u00e9 \u20190\u2019, o que indica que a parte fracion\u00e1ria do n\u00famero \u00e9 exatamente igual a 0,5, estando o n\u00famero, desse modo, a igual dist\u00e2ncia dos seus dois adjacentes represent\u00e1veis. Nesse caso o n\u00famero deve ser arredondado para o adjacente par. Uma forma pr\u00e1tica de identificar o adjacente par \u00e9 observando o LSB. Uma vez que, por esta an\u00e1lise, o adjacente inferior \u00e9 o pr\u00f3prio n\u00famero representado sem os bits que ser\u00e3o eliminados, quando o LSB for igual a zero, ou seja, quando o bit menos significativo da parte que ser\u00e1 preservada for igual a zero, o n\u00famero e, consequentemente, o adjacente inferior, ser\u00e1 par. De maneira an\u00e1loga, quando o LSB\nfor igual a \u20191\u2019, o adjacente inferior ser\u00e1 \u00edmpar, por conseguinte, o adjacente superior ser\u00e1 par. Dessa forma, pode-se simplesmente atribuir o valor do LSB ao Round- bit a fim de concluir o processo de arredondamento.\nA Tabela I.3 demonstra de maneira sucinta os poss\u00edveis valores para os bits Guard Bit, Sticky Bit e LSB e o valor a ser associado ao Round Bit para cada uma das combina\u00e7\u00f5es.\nTabela I.3: Defini\u00e7\u00e3o do Round-Bit no arredondamento para mais pr\u00f3ximo ou par.\nGuard-Bit\tStick-Bit\tLSB-Bit\tRound-Bit\n0\tX\tX\t0\n1\t0\t0\t0\n0\t0\t1\t1\n1\t1\tX\t0\nI.4.4\tNormaliza\u00e7\u00e3o\nConforme descrito na se\u00e7\u00e3o I.4.1, a fim de garantir a unicidade de representa\u00e7\u00e3o dos n\u00fameros em ponto-flutuante, o padr\u00e3o IEEE 754 adota o padr\u00e3o de representa\u00e7\u00e3o normalizada para todos os valores represent\u00e1veis. Como o IEEE 754 adota a base bin\u00e1ria, significa dizer que todo n\u00famero deve ser representado com a parte inteira do significando igual a 1. Toda a representa\u00e7\u00e3o que n\u00e3o atenda a esse padr\u00e3o \u00e9 considerada desnormalizada.\nMesmo que opere apenas com n\u00fameros normalizados, as opera\u00e7\u00f5es aritm\u00e9ticas podem dar origem a resultados desnormalizados. A Figura I.15 traz alguns exemplos de opera\u00e7\u00f5es entre operandos normalizados que apresentam resultados desnormalizados.\na)\t3,0* 10\u00b0*3,0* 10\u00b0=9,0* 10\u00b0\nJZL\n(1.100,..00b*2')*( 1.100...00b*2\u2018)=( 10.010 ...00b*22)\nb)\t1,0* 10\u00fc+l,0*10\"=2,0*10\u00b0\nJZL\n(1.000...00b*2\u00b0)+(l.000...00b*2\u00b0)=( 10.000.,.00b*2\u00b0)\nc)\tl,0*10\u00b0-5,0*10\u201c' = 0,5*10\"\nJZL\n(1,000...00b*2\u00b0)-( 1.000 ...00b\u00ab2\u201c')=(0.100 ...00b*2\u00b0)\nFigura I.15: Exemplos de opera\u00e7\u00f5es efetuadas em ponto-flutuante de base bin\u00e1ria com valores normalizados que geram valores desnormalizados.\nComo se pode perceber, apesar de expressarem corretamente os resultados da opera\u00e7\u00f5es, todos os exemplos apresentam resultados em desacordo com o padr\u00e3o de representa\u00e7\u00e3o adotado no padr\u00e3o IEEE 754, sendo, portanto, considerados desnormalizados.\nNos dois primeiros exemplos, os resultados s\u00e3o considerados desnormalizados por apresentarem a parte inteira do significando maior que 1. No terceiro exemplo, o resultado \u00e9 considerado desnormalizado por apresentar a parte inteira igual a zero. A seguir \u00e9 apresentado o algoritmo de normaliza\u00e7\u00e3o adotado neste projeto.\nI.4.4.1\tAlgoritmo de Normaliza\u00e7\u00e3o\nO algoritmo aqui apresentado destina-se a implementa\u00e7\u00f5es de ponto flutuante em representa\u00e7\u00e3o bin\u00e1ria, entretanto, com os devidos ajustes, esse algoritmo pode tamb\u00e9m ser aplicado a implementa\u00e7\u00f5es de ponto-flutuante em representa\u00e7\u00e3o decimal:\na)\tIdentifica-se a posi\u00e7\u00e3o do primeiro bit igual a um no significando.\nb)\tCalcula-se a dist\u00e2ncia da posi\u00e7\u00e3o do primeiro bit em \u20191\u2019 encontrado, para a posi\u00e7\u00e3o padr\u00e3o em que este deveria encontrar-se para n\u00fameros normalizados. Ou seja, calculase a dist\u00e2ncia deste para a primeira posi\u00e7\u00e3o \u00e0 esquerda do ponto separador. Se este estiver \u00e0 esquerda da posi\u00e7\u00e3o esperada, a dist\u00e2ncia \u00e9 considerada positiva; se estiver \u00e0 direita, a dist\u00e2ncia \u00e9 considerada negativa.\nc)\tEfetua-se o deslocamento dos bits do significando de forma a colocar o primeiro bit na posi\u00e7\u00e3o correta, ou seja, na primeira posi\u00e7\u00e3o \u00e0 esquerda do ponto separador.\nd)\tUma vez que o procedimento de deslocar um n\u00famero para a direita equivale a dividi-lo pela base adotada, ao mesmo tempo em que desloca para a esquerda, equivale a multiplic\u00e1-lo pela mesma base; a cada deslocamento do significando, tanto para a direita como para a esquerda, deve-se proceder \u00e0 corre\u00e7\u00e3o do expoente, de forma a manter o valor originalmente expresso pelo n\u00famero representado.\ne)\tDeve-se ter em mente que o procedimento de normaliza\u00e7\u00e3o n\u00e3o deve modificar o valor originalmente expresso pelo n\u00famero representado. Dessa forma, n\u00e3o deve haver descarte dos d\u00edgitos que forem sendo deslocados.\nf)\tPor fim, havendo necessidade, deve-se proceder um novo arredondamento do significando ap\u00f3s o processo de normaliza\u00e7\u00e3o.\nDesse modo, tomando como exemplo os resultados obtidos nos exemplos anteriores, verifica-se que:\n\u20191\u2019 est\u00e1 deslocado uma posi\u00e7\u00e3o \u00e0 esquerda da posi\u00e7\u00e3o em que se deveria encontrar. Portanto, deve-se ao mesmo tempo proceder ao deslocamento do significando em uma posi\u00e7\u00e3o \u00e0 direita e efetuar o incremento proporcional do expoente. Dessa forma, respectivamente se teria:\n10.010\u2022\u2022\u2022 00b x 22 \u2014> 1.0010\u2022\u2022\u2022 00b x 23\n10.000\u2022\u2022\u2022 00b x 20 \u2014> 1.0000\u2022\u2022\u2022 00b x 21\n\u25a0 Para o resultado obtido no exemplo (c), 0.100...00b x 20, tem-se: o primeiro bit em \u20191\u2019 est\u00e1 deslocado uma posi\u00e7\u00e3o \u00e0 direita da posi\u00e7\u00e3o em que se deveria encontrar. Nesse caso deve-se, ao mesmo tempo, proceder ao deslocamento do significando em uma posi\u00e7\u00e3o \u00e0 esquerda e efetuar o decremento proporcional do expoente. Como resultado, tem-se:\n0.100-\u2022-00b x 20 \u2014> 1.000-\u2022-00b x 2-1\nI.4.5\tOpera\u00e7\u00f5es aritm\u00e9ticas\nO 1EEE 754 determina que todas as suas implementa\u00e7\u00f5es deem suporte \u00e0s opera\u00e7\u00f5es aritm\u00e9ticas de soma, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o, divis\u00e3o e resto da divis\u00e3o inteira.\nApesar de n\u00e3o fazer restri\u00e7\u00f5es no tocante aos algoritmos a serem adotados, o padr\u00e3o emphIEEE 754 define que todas as opera\u00e7\u00f5es aritm\u00e9ticas devem ser implementadas de modo a produzir um resultado definido por esse padr\u00e3o como infinitamente preciso, com tantos d\u00edgitos quantos forem necess\u00e1rios \u00e0 sua representa\u00e7\u00e3o exata, o qual deve ent\u00e3o ser arredondado e normalizado para o formato de ponto-flutuante adotado.\nTamb\u00e9m est\u00e3o definidos os resultados esperados para as opera\u00e7\u00f5es em que um ou os dois operandos envolvidos n\u00e3o estejam normalizados. Nessas situa\u00e7\u00f5es deve-se observar um fluxo alternativo de execu\u00e7\u00e3o de modo a obter os resultados identificados nas Tabelas I.4, I.5, I.6 e I.7.\nTabela I.4: Resultados esperados para opera\u00e7\u00f5es de multiplica\u00e7\u00e3o dos elementos da linha\ninicial pelos elementos da coluna inicial.\n\tZero\tNumero\tNan\tInfinito\nZero\tZero\tZero\tNan\tZero\nN\u00famero\tZero\tNumero\tNan\tInfinito\nNan\tNan\tNan\tNan\tNan\nInfinito\tNaN\tInfinito\tNan\tInfinito\nTabela I.5: Resultados esperados para opera\u00e7\u00f5es de divis\u00e3o dos elementos da linha inicial pelos elementos da coluna inicial.\n\tZero\tNumero\tNan\tInfinito\nZero\tNaN\tNaN\tNan\tNaN\nN\u00famero\tZero\tNumero\tNan\tInfinito\nNan\tNan\tNan\tNan\tNan\nInfinito\tZero\tZero\tNan\tNaN\nTabela I.6: Resultados esperados para opera\u00e7\u00f5es de adi\u00e7\u00e3o dos elementos da linha inicial pelos elementos da coluna inicial.\n\tZero\tNumero\tNan\tInfinito\nZero\tZero\tNumero\tNan\tInfinito\nN\u00famero\tZero\tNumero\tNan\tInfinito\nNan\tNan\tNan\tNan\tNan\nInfinito\tInfinito\tInfinito\tNan\tInfinito\nTabela I.7: Resultados esperados para opera\u00e7\u00f5es de subtra\u00e7\u00e3o dos elementos da linha inicial pelos elementos da coluna inicial.\n\tZero\tNumero\tNan\tInfinito\nZero\tZero\tNumero\tNan\tInfinito\nN\u00famero\tZero\tNumero\tNan\tInfinito\nNan\tNan\tNan\tNan\tNan\nInfinito\tInfinito\tInfinito\tNan\tNaN\nI.4.5.1\tOpera\u00e7\u00f5es de Soma e Subtra\u00e7\u00e3o\nAs opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o em ponto-flutuante compartilham de um mesmo algoritmo de execu\u00e7\u00e3o. Em ambos os casos, deve-se primeiramente preparar os operandos, efetuar a opera\u00e7\u00e3o desejada e, por fim, normalizar e arredondar o resultado para o formato de ponto-flutuante adotado.\nO procedimento de prepara\u00e7\u00e3o dos operandos tem como objetivo alinhar os pesos atribu\u00eddos ao bits dos dois significandos entre si, de tal forma que a opera\u00e7\u00e3o de soma ou subtra\u00e7\u00e3o ocorra somente entre bits que estejam sendo associados a pesos equivalentes.\nEsse procedimento se faz necess\u00e1rio uma vez que o expoente ir\u00e1 alterar os pesos atribu\u00eddos aos bits do significando, fazendo com que o ponto separador seja virtualmente deslocado da sua posi\u00e7\u00e3o original.\nConsiderem-se, para melhor compreens\u00e3o, dois operandos Op1 e Op2, os quais poderiam ser expressos da seguinte forma:\nOp1\t\u25a0\t1' x (bnpe1 + bn-1Pe1-1 + \u2022\u2022\u2022 + b1pe1-(n+1) + bope1-n)\nOp2\t- 1sinal x (bnpe2 + bn-1pe2-1 + \u2022 \u2022 \u2022 + b1pe2-(n+1) + bope2-n)\nSendo e1 o expoente de Op1 e e2 o expoente de Op2, verifica-se que s\u00f3 se pode proceder uma opera\u00e7\u00e3o de soma ou subtra\u00e7\u00e3o entre Op1 e Op2 se e1 = e2 , uma vez que s\u00f3 nessa condi\u00e7\u00e3o os seus bits estar\u00e3o perfeitamente alinhados entre si.\nPercebe-se que, se e1 > e2, t\u00eam-se os pesos associados aos bits de Op1 maior que os seus correspondentes em Op2, exigindo dessa forma que se proceda a um realinhamento nos bits de um dos significandos antes de poder oper\u00e1-los. De maneira an\u00e1loga, o mesmo ocorre se e2 > e1.\nA fim de garantir maior precis\u00e3o nos resultados, deve-se sempre realinhar o significando do operando com o menor expoente em fun\u00e7\u00e3o do significando do operando com maior expoente, de tal forma a poder expressar ambos em fun\u00e7\u00e3o do maior expoente.\nO realinhamento dos bits se faz atrav\u00e9s de deslocamentos sucessivos \u00e0 direita dos bits do significando a ser realinhado, conforme demonstrado na Figura I.16. Desloca-se, desse modo, o significando que est\u00e1 sendo realinhado at\u00e9 que a posi\u00e7\u00e3o do seu ponto separador coincida com a posi\u00e7\u00e3o do ponto separador do significando que n\u00e3o ser\u00e1 alterado.\nn bits\nSignificando\nFigura I.16: Realinhamento do significando.\ndeslocado, uma vez que a opera\u00e7\u00e3o de deslocamento de um n\u00famero \u00e0 direita equivale a dividi-lo pela base num\u00e9rica adotada, a cada deslocamento, deve-se incrementar o valor do expoente associado.\nAp\u00f3s esse procedimento, tem-se os dois operandos expressos em fun\u00e7\u00e3o de um mesmo expoente e, por conseguinte, os pontos separadores e todos os bits realinhados, podendo-se oper\u00e1-los normalmente.\nApenas como um exemplo pr\u00e1tico, considerem-se duas opera\u00e7\u00f5es de soma entre os operandos Op1, Op2, Op3 e Op4, respectivamente 12,5,4,5 , 14,5 e 4,75 , representados no formato de ponto-flutuante hipot\u00e9tico apresentado na Tabela I.8.\nTabela I.8: Formato de ponto-flutuante com 9 bits, formulado apenas para fins did\u00e1ticos.\nCampo\tValor\tObserva\u00e7\u00f5es\nSinal(s)\t1 bit\tTamanho em bits\nSignificando\t6 bits\t5 bits armazenados + 1 bit impl\u00edcito\nExpoente M\u00e1ximo (emax)\t3\trepresentado pelo bin\u00e1rio 110\nExpoente M\u00ednimo (emin )\t-2\trepresentado pelo bin\u00e1rio 001\nRefer\u00eancia do\tEx- poente Bias\t3\trepresentado pelo bin\u00e1rio 011\nAs Figuras 2.20,I.17,I.18 e I.19, demonstram o processo de convers\u00e3o e a representa\u00e7\u00e3o dos operandos Op1, Op2, Op3 e Op4 para o formato de ponto-flutuante proposto.\nFigura I.17: Representa\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op2 para o formato de ponto-flutuante proposto.\nFigura I.18: Representa\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op3 para o formato de ponto-flutuante proposto.\nOp4 = 2,375 \u2014>1 *21+0*2\u00b0+0*2 *+1*2 2+l*2 3+0*2 4->10.0110\n3\n1.00110 *2*\nSinal -0 positivo \\\t\u25a0\nSignificando \u201c1.00110\nExpoente \u201cl + 2fos\u201c4 \u2014100\n000110100\nV\nOp4 Formatado em\nPonto Flutuante\nFigura I.19: Representa\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op4 para o formato de ponto-flutuante proposto.\nConsidere-se primeiramente a opera\u00e7\u00e3o de soma entre os operandos Op1 e Op2. Essa opera\u00e7\u00e3o pode ser feita de duas maneiras, com e sem o realinhamento do significando, conforme apresentado na Figura I.20.\nNa Figura I.20(a), temos a opera\u00e7\u00e3o sendo efetuada sem o realinhamento do significando. Como se pode observar, ao se tentar efetuar a opera\u00e7\u00e3o sem proceder ao realinhamento, acaba-se por se obter n\u00e3o apenas um significando resultante incorreto, mas tamb\u00e9m o expoente associado fica indefinido.\n12.50\n+ 2.25\n1.10010*23\n\"*\u201d1.00100 *2*\n12.50\n2.25\n1.10010*23\n+1.00100*2*\n1 10010*23\n.--K 0.01001 *23\n111011*23\nFigura I.20: Diagrama esquem\u00e1tico da opera\u00e7\u00e3o de soma entre Op1 e Op2.\nexemplo, uma vez que Op1 tem o maior expoente, procede-se ao realinhamento do significando de Op2 seguindo o esquema apresentado na Figura I.16.\nDepois de haver conclu\u00eddo o realinhamento, efetua-se a soma direta, bit a bit dos dois significandos.\nO resultado obtido \u00e9 considerado no padr\u00e3o IEEE 754 como infinitamente preciso, ou seja, est\u00e1 expresso na maior precis\u00e3o alcan\u00e7\u00e1vel para o formato de ponto-flutuante adotado para os operandos.\nComo o resultado obtido j\u00e1 est\u00e1 normalizado, e n\u00e3o necessita ser\nExpoente = 3+ Bias~ 6\u2014110\nSinal ~ 0 positivo 1\nSignificando ~ 1.11011\n011011110\nV\nFormatado em Ponto Flutuante\nFigura I.21: Representa\u00e7\u00e3o do resultado da opera\u00e7\u00e3o entre Op1 e Op2 no formato de ponto-flutuante proposto.\nConsidere-se agora a opera\u00e7\u00e3o de soma entre Op3 e Op4, que est\u00e1 demonstrada esquematicamente na Figura I.22.\nFigura I.22: Representa\u00e7\u00e3o esquem\u00e1tica da opera\u00e7\u00e3o de adi\u00e7\u00e3o entre Op3 e Op4.\nDe maneira semelhante \u00e0 adotada na opera\u00e7\u00e3o anterior, antes de serem realinhados, os operandos s\u00e3o primeiramente convertidos do formato de ponto-flutuante para o formato bin\u00e1rio.\nComo se pode observar, em raz\u00e3o do descarte dos bits menos significativos, o que normalmente ocorre durante o processo de realinhamento do significando, ap\u00f3s a opera\u00e7\u00e3o de realinhamento, o significando do operando Op4 passou de 2,375 para 2,25. A express\u00e3o a seguir demonstra o que ocorreu com a representa\u00e7\u00e3o de Op4.\n(2,375io) 10011102 \u2014> (2,25io)OOO1O.O12\nPor fim, estando os bits dos significandos j\u00e1 realinhados, pode-se efetuar a opera\u00e7\u00e3o de soma dos significandos, obtendo como resultado um significando dito infinitamente preciso.\nNessa opera\u00e7\u00e3o, diferentemente da anterior, obteve-se um resultado desnormalizado, que precisar\u00e1 ser normalizado, e o arredondado antes que se possa obter o resultado final da opera\u00e7\u00e3o.\nO procedimento de normaliza\u00e7\u00e3o se dar\u00e1 conforme descrito na Se\u00e7\u00e3o 2.3.6 desta tese. Na Figura I.23 a seguir, apresenta-se o resultado obtido ap\u00f3s a normaliza\u00e7\u00e3o.\n10.00011*23\nNormaliza\u00e7\u00e3o \u2014\u25baJJJ\n1.000011*24\nFigura I.23: Opera\u00e7\u00e3o de normaliza\u00e7\u00e3o sobre resultado da adi\u00e7\u00e3o de Op3 e Op4.\nPor fim, aplica-se o algoritmo de arredondamento para o mais pr\u00f3ximo ou par ao significando j\u00e1 normalizado, conforme descrito na Se\u00e7\u00e3o , obtendo o significando final da opera\u00e7\u00e3o. Para o formato de ponto flutuante adotado neste exemplo, primeiramente reservam-se os 6 bits mais significativos para formar o significando pr\u00e9-arredondado, ficando o bit menos significativo do significando original exercendo a fun\u00e7\u00e3o de Guard-Bit. Nesse caso o Guard-Bit ser\u00e1 igual a um, e, como n\u00e3o restam mais bits para formarem o Sticky-Bit, assume-se que o Sticky-Bit \u00e9 igual a zero. O LSB-Bit, neste exemplo, \u00e9 igual a um. A Figura I.24, a seguir, demonstra como ficam distribu\u00eddos os bits do significando original durante o processo de arredondamento.\n100001 1 000...0\nSignificando Guard Bit Sticky Pr\u00e9-Arredondado\tBit\nFigura I.24: Distribui\u00e7\u00e3o dos bits durante o processo de arredondamento.\nPor fim, aplicando-se os valores obtidos \u00e0 Tabela 5, verifica-se que o Round bit deve ser feito igual a um. O resultado final do procedimento de arredondamento pode ser visto na Figura I.25 a seguir.\nSignificando\nPr\u00e9-Arredondado\n1.00001 + 0.00001\t\u2014 Round Bit\n1.00010 ^^.Significando\nArredondado\nFigura I.25: Resultado do processo de arredondamento.\nA Figura I.26 traz o fluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o.\nFigura I.26: Fluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o.\nI.4.5.2\tOpera\u00e7\u00e3o de Multiplica\u00e7\u00e3o\nDiferentemente das opera\u00e7\u00f5es de soma e subtra\u00e7\u00e3o, a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o dispensa qualquer prepara\u00e7\u00e3o pr\u00e9via dos operandos.\nO algoritmo de multiplica\u00e7\u00e3o pode ser resumido em:\na)\tsomar os expoentes;\nb)\tnormalizar e arredondar o resultado obtido;\nc)\tcalcular o sinal do resultado atrav\u00e9s da aplica\u00e7\u00e3o da fun\u00e7\u00e3o l\u00f3gica OU-EXCLUSIVO com os sinais dos operandos.\nDois detalhes importantes devem ser observados durante a execu\u00e7\u00e3o das opera\u00e7\u00f5es de multiplica\u00e7\u00e3o dos significandos e de soma dos expoentes.\nCom rela\u00e7\u00e3o \u00e0 multiplica\u00e7\u00e3o dos significandos, uma vez que a multiplica\u00e7\u00e3o de dois inteiros com n bits resulta em um inteiro 2n bits, e considerando que o ponto separador divide o significando em duas partes distintas: uma representando a parte inteira, com 1 bit, e outra representando a parte fracion\u00e1ria, com n-1 bits restantes, tem-se que o resultado da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o entre os significandos resultar\u00e1 em um significando com 2n bits, com 2 bits representando a parte inteira e 2n-2 bits para a parte fracion\u00e1ria, conforme pode ser visto na Figura I.27.\nn Bits\t\tn Bits\t\n\t\"X\t\t\n20 2'^ 2*2\t2H-1\t2 o 2\u2019^ 2\u20192\t2n'\n\tl*l*l*l\tX @.I\u00bbH\t\nFigura I.27: Distribui\u00e7\u00e3o dos bits como resultado de uma opera\u00e7\u00e3o de multiplica\u00e7\u00e3o entre dois inteiros de tamanho n.\nO outro detalhe diz respeito \u00e0 necessidade do cancelamento do Bias, ou zero de refer\u00eancia, durante a opera\u00e7\u00e3o de soma dos expoentes. Uma vez que o valor do expoente \u00e9 formado pela soma do expoente desejado com o valor do Bias, deve-se evitar a soma duplicada do Bias durante a soma dos expoentes, subtraindo o seu valor do resultado final obtido.\nA Figura I.28, a seguir, demonstra o fluxo de execu\u00e7\u00e3o das opera\u00e7\u00f5es desse algoritmo.\nFigura I.28: Fluxo de execu\u00e7\u00e3o da opera\u00e7\u00e3o de multiplica\u00e7\u00e3o.\nApenas como um exemplo, considere-se a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o entre os operandos Op1 e Op2, respectivamente 1,65625 e 6,125, representados no formato de ponto-flutuante apresentado na Tabela I.8.\nNesse formato, Op1 e Op2 seriam representados da seguinte forma:\n\nOp1 =\nOp1 = 1,65625-1*2\u00b0 +1*2 *+0*2 a+l*2 3 + 0*2 4+l*2 5\n010101011\n+-\u25a0 Formatado em Ponto Flutuante\n{Sina l ~ 0( positivo1\t,\nSignificando -1.10101\nExpoente ~0 + Bias ~ 3 \u2014 011\nFigura I.29: Representa\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op1 para o formato de ponto-flutuante proposto.\nOp2 = 6,125-1 *2a + l*21 + 0*2\u00b0 + 0*2 J + 0*2 a+l*2 3 {Sinal - 01 positivo\nSignificando -\\ .10001\nExpoente 2 + 5zas~5 \u2014101\nOp2 =\n4 010001101\nT---------'\n_____________ v Formatado em Ponto Flutuante\nFigura I.30: Representa\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o de Op2 para o formato de ponto-flutuante proposto.\nMultiplicando os Significandos, tem-se:\n1.10101 x 1.10001 = 10.1000100101\nEm seguida, somando os expoentes, tem-se:\ne1 + e2 \u2014 Bias = 0 + 5 \u2014 3 = 2\nOperando os sinais\n0(Positivo)XOR0(Positivo) = 0(Positivo)\nOs quais, operado, resultam em:\n23 + 21 + 2-3 + 2-6 + 2-8 = 10,14453125\nPelo padr\u00e3o IEEE 754, esse seria considerado o resultado infinitamente preciso para essa opera\u00e7\u00e3o. Entretanto, esse resultado n\u00e3o pode ser diretamente representado no formato de ponto-flutuante adotado, devendo ser primeiramente normalizado e arredondado seguindo o que foi j\u00e1 foi apresentado. Nesse exemplo, aplicando-se o modo de arredondamento para o mais pr\u00f3ximo ou par, ap\u00f3s a normaliza\u00e7\u00e3o, tem-se:\nsignificando = 10.1000100101 \u2014> 1.01000100101\nExpoente = 2 \u2014> 3\nAp\u00f3s a aplica\u00e7\u00e3o do algoritmo de arredondamento, tem-se:\nsignificando = 1.01000100101 \u2014> 1.0100101\nExpoente = 3\n3\nPor fim, convertendo os resultados obtidos do significando e do expoente para o formato de n\u00famero real, obt\u00e9m-se:\n23+21+2-2=10.25\nEsse \u00e9 considerado o resultado mais preciso para essa opera\u00e7\u00e3o nessa nota\u00e7\u00e3o de ponto-flutuante.\nO resultado obtido pode ent\u00e3o ser convertido para o formato de ponto-flutuante adotado conforme disposto na Figura I.31 a seguir:\nSinal = 0 &lt;positivo\nSignificando = 1.01001\nExpoente \u2014 3 + Bias = 6\u2014110\n001001110\nV\nFormatado em\nPonto Flutuante\nFigura I.31: Representa\u00e7\u00e3o esquem\u00e1tica da convers\u00e3o do resultado para o formato de ponto-flutuante proposto."}]}}}