{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.12040"}, {"@name": "filename", "#text": "17528_arquivo2469_1.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Jos\u00e9 Edenilson Oliveira Reges\n\nImplementa\u00e7\u00e3o em VHDL de Sensor Inteligente\ncom M\u00f3dulo CAN e Ampli?cador Sens\u00edvel \u00e0 Fase\n\nRecife\n\n2010\n\n\n\nUniversidade Federal de Pernambuco\n\nPrograma de P\u00f3s-gradua\u00e7\u00e3o em Engenharia El\u00e9trica\n\nImplementa\u00e7\u00e3o em VHDL de Sensor Inteligente\n\ncom M\u00f3dulo CAN e Ampli?cador Sens\u00edvel \u00e0 Fase\n\nDisserta\u00e7\u00e3o\n\nsubmetida \u00e0 Universidade Federal de Pernambuco\n\ncomo parte dos requisitos para obten\u00e7\u00e3o do grau de\n\nMestre em Engenharia El\u00e9trica\n\nJos\u00e9 Edenilson Oliveira Reges\n\nRecife, Junho de 2010.\n\n\n\n \n\n \n\nR333i Reges, Jos\u00e9 Edenilson Oliveira. \nImplementa\u00e7\u00e3o em VHDL de Sensor Inteligente com \n\nM\u00f3dulo CAN e Amplificador Sens\u00edvel \u00e0 Fase  / Jos\u00e9 \n\nEdenilson Oliveira Reges. Recife: O Autor, 2010. \n\nxix, 206 folhas., il., gr\u00e1fs., tabs. \n\n \n\nDisserta\u00e7\u00e3o (Mestrado) \u2013 Universidade Federal de \n\nPernambuco. CTG. Programa de P\u00f3s-Gradua\u00e7\u00e3o em \n\nEngenharia El\u00e9trica, 2010. \n\n \n\nOrientador: Prof. Edval Jos\u00e9 Pinheiro Santos.  \n\nInclui Refer\u00eancias e Ap\u00eandice. \n\n \n\n1. Engenharia El\u00e9trica. 2. Sensores Inteligentes. \n\n3.Redes de Sensores. 4.Amplificador Sens\u00edvel. 5.Rede \n\nCAN.  I. T\u00edtulo. \n\n \n\n     UFPE \n\n621.3   CDD (22. ed.)    BCTG/2010-166 \n\n\n\n\n\nAos meus pais.\n\n\n\nAgradecimentos\n\n\u00c0 Deus, pela Luz que Ele tem colocado em meus caminhos durante todos os momen-\n\ntos de minha vida.\n\nAos meus pais, pelo carinho e pela dedica\u00e7\u00e3o proporcionados ao longo de todos esses\n\nanos de luta.\n\nAo professor Edval Jos\u00e9 Pinheiro Santos, pela orienta\u00e7\u00e3o, compreens\u00e3o e, principal-\n\nmente, pela con?an\u00e7a depositada na execu\u00e7\u00e3o deste trabalho.\n\nAos meus amigos do LDN, em especial \u00e0 Filipe Esteves T\u00e1vora, pelo enorme apoio\n\noferecido durante o per\u00edodo em que, por motivos pro?ssionais, precisei me ausentar\n\ndo Mestrado.\n\nAos meus ex-colegas de trabalho do CESAR e agora amigos, em especial \u00e0 Mar\u00edlia\n\nSouto Maior Lima, pela compreens\u00e3o durante o per\u00edodo em que precisei me afastar\n\ndas atividades na Design House e priorizar meus estudos no Mestrado.\n\nAos meus colegas de trabalho da PETROBRAS, em especial \u00e0 Walmy Andr\u00e9 Caval-\n\ncante Melo da Silva, pela compreens\u00e3o durante o per\u00edodo em que precisei me afastar\n\ndas atividades no ATP-ARG e concentrar meus esfor\u00e7os na conclus\u00e3o deste trabalho.\n\nJos\u00e9 Edenilson Oliveira Reges\n\nUniversidade Federal de Pernambuco\n\n14 de Junho de 2010\n\niv\n\n\n\nResumo da Disserta\u00e7\u00e3o apresentada \u00e0 UFPE como parte dos requisitos necess\u00e1rios\n\npara obten\u00e7\u00e3o do grau de Mestre em Engenharia El\u00e9trica.\n\nImplementa\u00e7\u00e3o em VHDL de Sensor Inteligente\n\ncom M\u00f3dulo CAN e Ampli?cador Sens\u00edvel \u00e0 Fase\n\nJos\u00e9 Edenilson Oliveira Reges\n\nJunho/2010\n\nOrientador: Edval Jos\u00e9 Pinheiro Santos, Ph.D.\n\u00c1rea de Concentra\u00e7\u00e3o: Eletr\u00f4nica\nPalavras-chave: Sensores Inteligentes, Redes de Sensores, IEEE 1451, Rede CAN,\nAmpli?cador Sens\u00edvel \u00e0 Fase\nN\u00famero de p\u00e1ginas: xix+206\n\nNeste trabalho s\u00e3o apresentadas a descri\u00e7\u00e3o em linguagem VHDL e a implemen-\n\nta\u00e7\u00e3o em FPGA de um ampli?cador sens\u00edvel \u00e0 fase(lock-in) e de um m\u00f3dulo de comu-\n\nnica\u00e7\u00e3o CAN para o desenvolvimento de um sensor inteligente inspirado na fam\u00edlia de\n\npadr\u00f5es IEEE 1451. O ampli?cador sens\u00edvel \u00e0 fase \u00e9 utilizado para detec\u00e7\u00e3o e condi-\n\ncionamento de sinais. Sua implementa\u00e7\u00e3o em formato digital possibilita a utiliza\u00e7\u00e3o\n\nde t\u00e9cnicas de processamento digital de sinais. A s\u00edntese do ampli?cador utilizou ape-\n\nnas 6% dos recursos l\u00f3gicos da FPGA escolhida, possibilitando a implementa\u00e7\u00e3o de\n\nv\u00e1rios ampli?cadores em paralelo, na mesma FPGA. O m\u00f3dulo CAN implementado\n\n\u00e9 capaz de se comunicar em rede com outros m\u00f3dulos CAN, dispon\u00edveis comercial-\n\nmente. A utiliza\u00e7\u00e3o l\u00f3gica do m\u00f3dulo CAN implementado foi comparada \u00e0 do m\u00f3dulo\n\nHurriCANe, desenvolvido pela ESA. O funcionamento dos circuitos foi veri?cado com\n\n\u00eaxito a partir de simula\u00e7\u00f5es e de testes realizados ap\u00f3s a implementa\u00e7\u00e3o em FPGA. A\n\ninterliga\u00e7\u00e3o do m\u00f3dulo CAN ao ampli?cadorlock-in foi realizada com sucesso, sendo\n\nocupados apenas 14% dos recursos da FPGA.\n\nv\n\n\n\nAbstract of Dissertation presented to UFPE as a partial ful?llment of the\n\nrequirements for the degree of Master in Electrical Engineering.\n\nVHDL Implementation of a Smart Sensor\n\nwith CAN Module and Lock-in Ampli?er\n\nJos\u00e9 Edenilson Oliveira Reges\n\nJune/2010\n\nSupervisor: Edval Jos\u00e9 Pinheiro Santos, Ph.D.\nArea of Concentration: Electronics\nKeywords: Smart Sensors, Sensors Networks, IEEE 1451, CAN Network, Lock-in\nAmpli?er\nNumber of pages: xix+206\n\nIn this work, the VHDL description and the FPGA implementation of both a lock-\n\nin ampli?er, and a CAN communication module are presented for the development of\n\na smart sensor inspired in the IEEE 1451 family of standards. The lock-in ampli?er\n\nis used for signal detection and conditioning. Its implementation in digital format\n\nallows for the application of digital signal processing techniques. The lock-in ampli?er\n\nsynthesis used only 6% of the logic resources for the selected FPGA, allowing for\n\nthe implementation of many parallel ampli?er in the same FPGA. The implemented\n\nCAN module is capable of communicating in a network with other CAN modules,\n\navailable in the market. The logic utilization of this CAN module is compared to\n\ntheHurriCANe module, developed by ESA. The correct operation of the circuits was\n\nveri?ed with simulations, and tests performed after the FPGA implementation. The\n\ninterligation of the CAN module to the lock-in ampli?er was succesfully carried out,\n\nusing only 14% of the FPGA resources.\n\nvi\n\n\n\nConte\u00fado\n\nAgradecimentos iv\n\nResumo v\n\nAbstract vi\n\nLista de Tabelas xii\n\nLista de Figuras xiii\n\nCap\u00edtulo 1 Introdu\u00e7\u00e3o 1\n\n1.1 Sensores Inteligentes . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n\n1.2 Redes Industriais de Comunica\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . 3\n\n1.2.1 Evolu\u00e7\u00e3o dos Sistemas de Automa\u00e7\u00e3o Industrial . . . . . . . . 4\n\n1.3 IEEE 1451 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n\n1.3.1 Smart Transducer Interface Module (STIM) . . . . . . . . . . 12\n\n1.3.2 Network Capable Application Processor (NCAP) . . . . . . . . 13\n\n1.3.3 Transducer Electronic Data Sheet (TEDS) . . . . . . . . . . . 15\n\n1.3.4 IEEE P1451.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n1.3.5 IEEE 1451.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n1.3.6 IEEE 1451.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n1.3.7 IEEE 1451.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n1.3.8 IEEE 1451.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n1.3.9 IEEE P1451.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n1.3.10 IEEE P1451.6 . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n1.3.11 IEEE P1451.7 . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\nvii\n\n\n\n1.3.12 Aplica\u00e7\u00f5es da Fam\u00edlia de Padr\u00f5es IEEE 1451 . . . . . . . . . . 20\n\n1.4 Arquitetura do Sensor Inteligente Proposto . . . . . . . . . . . . . . . 23\n\n1.4.1 Exemplo de Aplica\u00e7\u00e3o: Medi\u00e7\u00e3o de Vaz\u00e3o de Fluxos Multif\u00e1si-\n\ncos utilizando Tomogra?a por Imped\u00e2ncia El\u00e9trica . . . . . . 23\n\n1.4.2 Objetivo do Trabalho . . . . . . . . . . . . . . . . . . . . . . . 28\n\n1.5 Organiza\u00e7\u00e3o do Texto . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\nCap\u00edtulo 2 Metodologia 31\n\n2.1 Ampli?cador Sens\u00edvel \u00e0 Fase . . . . . . . . . . . . . . . . . . . . . . . 31\n\n2.2 M\u00f3dulo de Comunica\u00e7\u00e3o CAN . . . . . . . . . . . . . . . . . . . . . . 31\n\n2.3 Etapas de Prototipa\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n2.3.1 Ampli?cador Sens\u00edvel \u00e0 Fase Digital utilizando Microcomputa-\n\ndor e Placa de Aquisi\u00e7\u00e3o de Dados . . . . . . . . . . . . . . . 32\n\n2.3.2 Rede de Comunica\u00e7\u00e3o CAN utilizando Placa de Desenvolvi-\n\nmento Comercial e Microcontroladores PIC . . . . . . . . . . . 34\n\n2.4 Etapas de Implementa\u00e7\u00e3o em FPGA . . . . . . . . . . . . . . . . . . 37\n\n2.5 Projeto de Circuitos Integrados . . . . . . . . . . . . . . . . . . . . . 38\n\n2.6 FPGA - Field Programmable Gate Array . . . . . . . . . . . . . . . . 41\n\n2.7 VHDL -VHSIC Hardware Description Language . . . . . . . . . . . . 44\n\n2.8 Fluxo de Projeto de Circuitos Digitais em FPGA utilizando VHDL . 46\n\n2.8.1 Especi?ca\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\n2.8.2 Descri\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n2.8.3 Simula\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n\n2.8.4 S\u00edntese . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n\n2.8.5 Rede de Liga\u00e7\u00f5es, Posicionamento, Interliga\u00e7\u00e3o e Constru\u00e7\u00e3o . 49\n\n2.8.6 Materiais e M\u00e9todos . . . . . . . . . . . . . . . . . . . . . . . 50\n\n2.9 Considera\u00e7\u00f5es Finais . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n\nCap\u00edtulo 3 Ampli?cador Sens\u00edvel \u00e0 Fase 55\n\n3.1 Discuss\u00e3o Te\u00f3rica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n\n3.1.1 Caso 1: Sinal de Entrada em Fase com o Sinal de Refer\u00eancia . 58\n\n3.1.2 Caso 2: Sinal de Entrada Defasado de 45 Graus com Rela\u00e7\u00e3o\n\nao Sinal de Refer\u00eancia . . . . . . . . . . . . . . . . . . . . . . 59\n\nviii\n\n\n\n3.1.3 Caso 3: Sinal de Entrada em Quadratura com o Sinal de Refe-\n\nr\u00eancia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\n3.2 Exemplo de Aplica\u00e7\u00e3o: Medi\u00e7\u00e3o de Imped\u00e2ncias . . . . . . . . . . . . 61\n\n3.3 Ampli?cador Sens\u00edvel \u00e0 Fase Digital Utilizando Microcomputador com\n\nPlaca de Aquisi\u00e7\u00e3o de Dados e MATLAB . . . . . . . . . . . . . . . . 63\n\n3.3.1 Implementa\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n\n3.3.2 Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n\n3.4 Ampli?cador Sens\u00edvel \u00e0 Fase Descrito em VHDL e Implementado em\n\nFPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71\n\n3.4.1 Detector de Fase . . . . . . . . . . . . . . . . . . . . . . . . . 72\n\n3.4.2 Filtro Passa-Baixa . . . . . . . . . . . . . . . . . . . . . . . . 74\n\n3.4.3 Mem\u00f3ria ROM . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\n3.4.4 Sequenciador . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\n3.4.5 Simula\u00e7\u00f5es do Ampli?cador Lock-in Digital em VHDL . . . . 77\n\n3.4.6 S\u00edntese do Ampli?cador Lock-in Digital em VHDL . . . . . . . 80\n\n3.4.7 Valida\u00e7\u00e3o em FPGA do Ampli?cador Lock-in Digital em VHDL 80\n\n3.5 Considera\u00e7\u00f5es Finais . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n\nCap\u00edtulo 4 M\u00f3dulo de Comunica\u00e7\u00e3o CAN 83\n\n4.1 Protocolo de Comunica\u00e7\u00e3o CAN . . . . . . . . . . . . . . . . . . . . . 83\n\n4.1.1 Camada de Enlace . . . . . . . . . . . . . . . . . . . . . . . . 84\n\n4.1.2 Camada F\u00edsica . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n\n4.2 Implementa\u00e7\u00e3o de uma Rede CAN utilizando Placas SBC28PC e Mi-\n\ncrocontroladores PIC\n\n18F258 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n\n4.3 M\u00f3dulo de Comunica\u00e7\u00e3o CAN Descrito em VHDL e Implementado em\n\nFPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\n\n4.3.1 Simula\u00e7\u00f5es do M\u00f3dulo CAN em VHDL . . . . . . . . . . . . . 95\n\n4.3.2 S\u00edntese do M\u00f3dulo CAN em VHDL . . . . . . . . . . . . . . . 101\n\n4.3.3 Valida\u00e7\u00e3o em FPGA do M\u00f3dulo CAN em VHDL . . . . . . . 104\n\n4.4 Implementa\u00e7\u00e3o em VHDL de Sensor Inteligente com M\u00f3dulo CAN e\n\nAmpli?cador Sens\u00edvel \u00e0 Fase . . . . . . . . . . . . . . . . . . . . . . . 105\n\nix\n\n\n\n4.4.1 S\u00edntese do Sensor Inteligente Implementado em FPGA . . . . 106\n\n4.4.2 Valida\u00e7\u00e3o do Sensor Inteligente Implementado em FPGA . . . 106\n\n4.5 Considera\u00e7\u00f5es Finais . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n\nCap\u00edtulo 5 Conclus\u00f5es e Trabalhos Futuros 108\n\n5.1 Conclus\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\n\n5.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n\nAp\u00eandice A C\u00f3digos VHDL 111\n\nA.1 Sensor Inteligente . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n\nA.2 Ampli?cador Sens\u00edvel \u00e0 Fase . . . . . . . . . . . . . . . . . . . . . . . 117\n\nA.2.1 Sequenciador . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n\nA.2.2 ROM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\n\nA.2.3 Registrador . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n\nA.2.4 Detector de Fase . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\nA.2.5 Complemento2 . . . . . . . . . . . . . . . . . . . . . . . . . . 133\n\nA.2.6 Multiplexador . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n\nA.2.7 Multiplicador . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n\nA.2.8 Filtro Passa-Baixa . . . . . . . . . . . . . . . . . . . . . . . . 135\n\nA.2.9 Somador . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n\nA.2.10 Registrador de Deslocamento . . . . . . . . . . . . . . . . . . 138\n\nA.3 M\u00f3dulo CAN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n\nA.3.1 CAN TX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\n\nA.3.2 CAN RX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\n\nA.3.3 CRC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161\n\nA.3.4 STUFF HANDLER . . . . . . . . . . . . . . . . . . . . . . . . 163\n\nA.3.5 BIT TIMING 1 . . . . . . . . . . . . . . . . . . . . . . . . . . 166\n\nA.3.6 BIT TIMING 2 . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n\nAp\u00eandice B C\u00f3digos C e MATLAB 172\n\nB.1 Programa de Aquisi\u00e7\u00e3o de Dados com a Placa DAS-20 em Linguagem C172\n\nB.2 Programas Usados na Implementa\u00e7\u00e3o da T\u00e9cnicaLock-in em MATLAB 175\n\nB.2.1 lockincal.m . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175\n\nx\n\n\n\nB.2.2 lockinmed.m . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\n\nAp\u00eandice C C\u00f3digos ASM 179\n\nC.1 N\u00f3 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\n\nC.2 N\u00f3 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n\nAp\u00eandice D SOTR para Aquisi\u00e7\u00e3o de Dados e Comunica\u00e7\u00e3o 186\n\nD.1 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187\n\nD.2 Especi?ca\u00e7\u00e3o doHardware . . . . . . . . . . . . . . . . . . . . . . . . 188\n\nD.2.1 Microcontrolador LAMPI\u00c3O . . . . . . . . . . . . . . . . . . . 188\n\nD.3 Especi?ca\u00e7\u00e3o do Software - Modelo Ambiental . . . . . . . . . . . . . 190\n\nD.3.1 Diagrama de Contexto . . . . . . . . . . . . . . . . . . . . . . 190\n\nD.3.2 Lista de Eventos . . . . . . . . . . . . . . . . . . . . . . . . . 190\n\nD.4 Especi?ca\u00e7\u00e3o do Software - Modelo Comportamental . . . . . . . . . 191\n\nD.4.1 Arquitetura do Sistema Operacional . . . . . . . . . . . . . . . 191\n\nD.4.2 Tratamento de uma Interrup\u00e7\u00e3o de Rel\u00f3gio . . . . . . . . . . . 192\n\nD.4.3 Tratamento de uma Interrup\u00e7\u00e3o Externa . . . . . . . . . . . . 193\n\nD.4.4 Tratamento de uma Chamada ao Sistema para Solicita\u00e7\u00e3o de\n\num Recurso . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193\n\nD.5 Estrutura do Sistema Operacional . . . . . . . . . . . . . . . . . . . . 194\n\nD.6 Processos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n\nD.6.1 Diagrama de Estados dos Processos . . . . . . . . . . . . . . . 195\n\nD.6.2 Implementa\u00e7\u00e3o de Processos . . . . . . . . . . . . . . . . . . . 196\n\nD.6.3 Comunica\u00e7\u00e3o entre Processos . . . . . . . . . . . . . . . . . . 196\n\nD.7 Algoritmo de Agendamento (Despachante) . . . . . . . . . . . . . . . 197\n\nD.7.1 Estimativa doQuantum . . . . . . . . . . . . . . . . . . . . . . 198\n\nAp\u00eandice E Publica\u00e7\u00f5es 201\n\nBibliogra?a 202\n\nxi\n\n\n\nLista de Tabelas\n\n2.1 Comparativo entre os estilos de descri\u00e7\u00e3o dehardware. . . . . . . . . . 46\n\n3.1 Resultados obtidos na caracteriza\u00e7\u00e3o de um resistor de 1 k? com o\n\nampli?cador lock-in. . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n3.2 Utiliza\u00e7\u00e3o de recursos l\u00f3gicos da FPGA ap\u00f3s a s\u00edntese doLock-in. . . 80\n\n4.1 Utiliza\u00e7\u00e3o de recursos l\u00f3gicos da FPGA ap\u00f3s a s\u00edntese do m\u00f3dulo CAN\n\nem VHDL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n4.2 Comparativo entre as entidades descritas no m\u00f3dulo de comunica\u00e7\u00e3o\n\nCAN implementado neste trabalho (A) e as entidades correspondentes\n\nno M\u00f3dulo HurriCANe (B), desenvolvido pela ESA (European Space\n\nAgency). O crit\u00e9rio de avalia\u00e7\u00e3o usado foi a utiliza\u00e7\u00e3o l\u00f3gica do dis-\n\npositivo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n4.3 Utiliza\u00e7\u00e3o de recursos l\u00f3gicos da FPGA ap\u00f3s a s\u00edntese do sensor in-\n\nteligente em VHDL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\n\nD.1 Especi?ca\u00e7\u00f5es do microcontrolador LAMPI\u00c3O . . . . . . . . . . . . . 189\n\nD.2 Lista de eventos do sistema e a\u00e7\u00f5es a serem realizadas. . . . . . . . . 191\n\nD.3 N\u00famero de processos por n\u00edvel de prioridade. . . . . . . . . . . . . . . 198\n\nxii\n\n\n\nLista de Figuras\n\n1.1 Diagrama em blocos de um transdutor inteligente gen\u00e9rico . . . . . . 2\n\n1.2 Exemplo t\u00edpico de controle de processo manual e local. O processo de\n\naquecimento de \u00e1gua \u00e9 controlado manualmente, na planta de processo,\n\npelo operador . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n\n1.3 Exemplo t\u00edpico de controle de processo autom\u00e1tico e local. O processo\n\nde aquecimento de \u00e1gua \u00e9 controlado automaticamente, na planta de\n\nprocesso, pelo controlador de temperatura . . . . . . . . . . . . . . . 6\n\n1.4 Exemplo t\u00edpico de controle de processo autom\u00e1tico e remoto. O pro-\n\ncesso de aquecimento de \u00e1gua \u00e9 controlado automaticamente, a partir\n\nde um painel remoto na sala de controle . . . . . . . . . . . . . . . . 7\n\n1.5 Ilustra\u00e7\u00e3o de um antigo painel de controle de uma re?naria de petr\u00f3leo.\n\nNa parte superior do painel \u00e9 representado o ?uxograma de engen-\n\nharia da planta de processo. Na parte inferior est\u00e3o presentes os con-\n\ntroladores de processo, as chaves de con?gura\u00e7\u00e3o, as botoeiras e as\n\nindica\u00e7\u00f5es das vari\u00e1veis do processo . . . . . . . . . . . . . . . . . . . 7\n\n1.6 Ilustra\u00e7\u00e3o dos controladores de processo no painel . . . . . . . . . . . 8\n\n1.7 Arquitetura t\u00edpica de um sistema de controle centralizado. Um \u00fanico\n\ncomputador central \u00e9 utilizado para controlar todo o processo . . . . 8\n\n1.8 Arquitetura t\u00edpica de um sistema DCS . . . . . . . . . . . . . . . . . 10\n\n1.9 Arquitetura t\u00edpica de um sistema SCADA . . . . . . . . . . . . . . . 10\n\n1.10 Interliga\u00e7\u00e3o em rede de dispositivos de campo. Atrav\u00e9s da rede de\n\ncampo, sensores, atuadores e outros equipamentos de campo podem\n\ncomunicar-se entre si e/ou com o controlador . . . . . . . . . . . . . . 11\n\n1.11 Diagrama em blocos de um STIM sensor . . . . . . . . . . . . . . . . 14\n\nxiii\n\n\n\n1.12 Diagrama em blocos de um STIM atuador . . . . . . . . . . . . . . . 14\n\n1.13 Diagrama em blocos de um STIM sensor e atuador . . . . . . . . . . 14\n\n1.14 Diagrama em blocos de um NCAP . . . . . . . . . . . . . . . . . . . 15\n\n1.15 Arquitetura de rede de sensores inteligentes baseada na fam\u00edlia de\n\npadr\u00f5es IEEE 1451. Nesta ilustra\u00e7\u00e3o, o mesmo m\u00f3dulo transdutor\n\n(STIM) \u00e9 utilizado, independentemente da rede de comunica\u00e7\u00e3o. Por\n\noutro lado, o NCAP \u00e9 projetado de acordo com o tipo de rede . . . . 17\n\n1.16 Exemplo de aplica\u00e7\u00e3o dos padr\u00f5es IEEE 1451.1 e IEEE 1451.2. O mod-\n\nelo orientado \u00e0 objeto do m\u00f3dulo de transdu\u00e7\u00e3o (STIM) \u00e9 padronizado\n\nde acordo com IEEE 1451.1. Por outro lado, a interface normalizada\n\nentre o STIM e o NCAP \u00e9 de?nida no padr\u00e3o IEEE 1451.2 . . . . . . 18\n\n1.17 Exemplo de aplica\u00e7\u00e3o do padr\u00e3o IEEE 1451.3 de?nindo uma interface\n\nnormalizada entre o NCAP e uma rede de transdutores . . . . . . . . 19\n\n1.18 Exemplo de aplica\u00e7\u00e3o do padr\u00e3o IEEE 1451.6 de?nindo uma interface\n\nnormalizada entre o NCAP e uma rede de transdutoresCANopen . . . 21\n\n1.19 Exemplos de aplica\u00e7\u00e3o da fam\u00edlia de padr\u00f5es IEEE 1451 . . . . . . . 22\n\n1.20 Arquitetura do sensor inteligente proposto . . . . . . . . . . . . . . . 22\n\n1.21 Con?gura\u00e7\u00e3o de uma tubula\u00e7\u00e3o com eletrodos de medi\u00e7\u00e3o e sua se\u00e7\u00e3o\n\ntransversal ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n1.22 Topologia de inje\u00e7\u00e3o de corrente e medi\u00e7\u00e3o de potencial nos diversos\n\neletrodos do tom\u00f3grafo. Na ilustra\u00e7\u00e3o \"A\", uma corrente el\u00e9trica \u00e9\n\ninjetada entre os eletrodos 1 e 2 e as tens\u00f5es el\u00e9tricas resultantes s\u00e3o\n\nmedidas nos demais eletrodos. Este procedimento \u00e9 refeito (ilustra\u00e7\u00e3o\n\n\"B\") at\u00e9 que as N(N ? 1)/2 medidas (combina\u00e7\u00f5es lineares) sejam\n\nrealizadas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\nxiv\n\n\n\n1.23 Esquema de um equipamento de tomogra?a por imped\u00e2ncia el\u00e9trica.\n\nUma corrente el\u00e9trica senoidal, produzida por uma fonte de corrente\n\ncontrolada por um gerador de sinal de 50 kHz, \u00e9 multiplexada e inje-\n\ntada nos diversos eletrodos do tom\u00f3grafo. Utilizando a t\u00e9cnicalock-in,\n\nas medi\u00e7\u00f5es resultantes s\u00e3o demultiplexadas, ampli?cadas e demodu-\n\nladas, a partir do sinal de refer\u00eancia (gerador de sinal). O ?ltro passa-\n\nbaixa separa a componente CC do sinal demodulado, proporcional \u00e0\n\ncondutividade e/ou permissividade da se\u00e7\u00e3o transversal da matriz de\n\neletrodos. Finalmente, a imagem da se\u00e7\u00e3o transversal, obtida a par-\n\ntir de um algoritmo de reconstru\u00e7\u00e3o de imagens, \u00e9 exibida na tela do\n\nmicrocomputador. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\n1.24 Sensor inteligente aplicado a um sistema de tomogra?a por imped\u00e2ncia\n\nel\u00e9trica. A interface entre o STIM e o NCAP \u00e9 realizada utilizando a\n\nredeCANopen, conforme de?nido no padr\u00e3o IEEE 1451.6 . . . . . . . 29\n\n2.1 Ilustra\u00e7\u00e3o da placa de aquisi\u00e7\u00e3o de dados DAS-20 . . . . . . . . . . . 33\n\n2.2 Ilustra\u00e7\u00e3o do ambiente de programa\u00e7\u00e3o em linguagem C . . . . . . . 33\n\n2.3 Ilustra\u00e7\u00e3o do ambiente MATLAB . . . . . . . . . . . . . . . . . . . . 34\n\n2.4 Ilustra\u00e7\u00e3o da placa de desenvolvimento SBC28PC . . . . . . . . . . . 35\n\n2.5 Ilustra\u00e7\u00e3o da ferramenta de projeto MPLAB . . . . . . . . . . . . . . 36\n\n2.6 Ilustra\u00e7\u00e3o do programador e depurador ICD3 . . . . . . . . . . . . . 36\n\n2.7 Ilustra\u00e7\u00e3o do programa Terminal . . . . . . . . . . . . . . . . . . . . 37\n\n2.8 Etapas de projeto de circuitos integrados . . . . . . . . . . . . . . . . 38\n\n2.9 Segmenta\u00e7\u00e3o proposta da \u00e1rea de projeto de circuitos integrados . . . 39\n\n2.10 FPGAs dos principais fabricantes: Actel, Altera e Xilinx . . . . . . . 41\n\n2.11 Arquitetura b\u00e1sica de uma FPGAXilinx . . . . . . . . . . . . . . . . 42\n\n2.12 Arranjo de slices num CLB . . . . . . . . . . . . . . . . . . . . . . . 43\n\n2.13 Arquitetura de um slice numa FPGA Xilinx Spartan II . . . . . . . . 43\n\n2.14 Etapas gerais de um processo de s\u00edntese em FPGA utilizando VHDL 47\n\n2.15 Descri\u00e7\u00e3o VHDL da porta NAND: entidade e arquitetura . . . . . . . 48\n\n2.16 Resultados da simula\u00e7\u00e3o comportamental da porta NAND . . . . . . 49\n\n2.17 Circuito sintetizado a partir da descri\u00e7\u00e3o VHDL da porta NAND . . 49\n\nxv\n\n\n\n2.18 Ilustra\u00e7\u00e3o da janela utilizada na assinala\u00e7\u00e3o dos pinos de E/S da porta\n\nNAND na FPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n\n2.19 Ilustra\u00e7\u00e3o da janela utilizada para posicionamento e interliga\u00e7\u00e3o dos\n\ncomponentes na FPGA . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n\n2.20 Ilustra\u00e7\u00e3o da janela para gera\u00e7\u00e3o do arquivo de con?gura\u00e7\u00e3o da FPGA 51\n\n2.21 Ilustra\u00e7\u00e3o da janela para grava\u00e7\u00e3o do arquivo de con?gura\u00e7\u00e3o da FPGA\n\nnuma mem\u00f3ria PROM externa . . . . . . . . . . . . . . . . . . . . . . 51\n\n2.22 Fluxo de projeto utilizado . . . . . . . . . . . . . . . . . . . . . . . . 52\n\n2.23 Fluxo de projeto utilizado (continua\u00e7\u00e3o) . . . . . . . . . . . . . . . . 52\n\n2.24 Ilustra\u00e7\u00e3o do ambiente de projeto Xilinx ISE 11 . . . . . . . . . . . . 53\n\n2.25 Ilustra\u00e7\u00e3o da ferramenta de simula\u00e7\u00e3o ModelSim XE III 6.4 . . . . . 53\n\n2.26 Ilustra\u00e7\u00e3o da plataforma de desenvolvimento Spartan 3E . . . . . . . 54\n\n3.1 Diagrama em blocos de um ampli?cador sens\u00edvel \u00e0 fase . . . . . . . . 56\n\n3.2 Gr\u00e1?cos das tens\u00f5es presentes no ampli?cador sens\u00edvel \u00e0 fase para um\n\nsinal de entrada em fase com o sinal de refer\u00eancia . . . . . . . . . . . 59\n\n3.3 Gr\u00e1?cos das tens\u00f5es presentes no ampli?cador sens\u00edvel \u00e0 fase para um\n\nsinal de entrada defasado de 45 graus com rela\u00e7\u00e3o ao sinal de refer\u00eancia 60\n\n3.4 Gr\u00e1?cos das tens\u00f5es presentes no ampli?cador sens\u00edvel \u00e0 fase para um\n\nsinal de entrada em quadratura com o sinal de refer\u00eancia . . . . . . . 61\n\n3.5 Diagrama esquem\u00e1tico de um circuito experimental para medi\u00e7\u00e3o de\n\nimped\u00e2ncias utilizando um ampli?cador sens\u00edvel \u00e0 fase . . . . . . . . 62\n\n3.6 Diagrama em blocos do ampli?cador lock-in digital utilizando micro-\n\ncomputador com placa de aquisi\u00e7\u00e3o de dados e MATLAB . . . . . . . 64\n\n3.7 Fluxograma dosoftware de controle da placa DAS-20 . . . . . . . . . 65\n\n3.8 Tela principal do programa de aquisi\u00e7\u00e3o de dados . . . . . . . . . . . 66\n\n3.9 Fluxograma do algoritmo desenvolvido no MATLAB . . . . . . . . . 67\n\n3.10 Tela do programa desenvolvido em MATLAB para medi\u00e7\u00e3o de imped\u00e2n-\n\ncias com o ampli?cador lock-in . . . . . . . . . . . . . . . . . . . . . 68\n\n3.11 Diagrama esquem\u00e1tico de um circuito Experimental para medi\u00e7\u00e3o de\n\nimped\u00e2ncias utilizando o ampli?cador lock-in digital com placa de\n\naquisi\u00e7\u00e3o de dados e MATLAB . . . . . . . . . . . . . . . . . . . . . 68\n\nxvi\n\n\n\n3.12 Ampli?cador lock-in digital com placa de aquisi\u00e7\u00e3o de dados e MAT-\n\nLAB utilizado na medi\u00e7\u00e3o de imped\u00e2ncias . . . . . . . . . . . . . . . 69\n\n3.13 Gr\u00e1?co da tens\u00e3o de sa\u00edda do canal X em fun\u00e7\u00e3o da condut\u00e2ncia do\n\ndispositivo sob teste (teoria e pr\u00e1tica) . . . . . . . . . . . . . . . . . . 70\n\n3.14 Diagrama em blocos do ampli?cador sens\u00edvel \u00e0 fase digital . . . . . . 71\n\n3.15 Diagrama em blocos do detector de fase . . . . . . . . . . . . . . . . 72\n\n3.16 Esquem\u00e1tico RTL do bloco de c\u00e1lculo do complemento a 2 . . . . . . 73\n\n3.17 Esquem\u00e1tico RTL do bloco multiplexador 2-1 (1 bit) . . . . . . . . . 73\n\n3.18 Esquem\u00e1tico RTL do bloco multiplexador 2-1 (12 bits) . . . . . . . . 73\n\n3.19 Esquem\u00e1tico RTL do bloco multiplicador bin\u00e1rio . . . . . . . . . . . 74\n\n3.20 Diagrama em blocos do ?ltro passa-Baixa . . . . . . . . . . . . . . . . 75\n\n3.21 Esquem\u00e1tico RTL do bloco somador . . . . . . . . . . . . . . . . . . 75\n\n3.22 Esquem\u00e1tico RTL do bloco registrador de deslocamento . . . . . . . . 75\n\n3.23 Esquem\u00e1tico RTL do bloco registradorbu?er . . . . . . . . . . . . . . 75\n\n3.24 Esquem\u00e1tico RTL da mem\u00f3ria ROM . . . . . . . . . . . . . . . . . . 76\n\n3.25 Gr\u00e1?co dos valores armazenados na mem\u00f3ria ROM . . . . . . . . . . 77\n\n3.26 Formas de onda obtidas na simula\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase\n\n(Sinal de entrada em fase com o sinal de refer\u00eancia) . . . . . . . . . . 79\n\n3.27 Formas de onda obtidas na simula\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase\n\n(Sinal de entrada em quadratura com o sinal de refer\u00eancia) . . . . . . 79\n\n3.28 Formas de onda obtidas na simula\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase\n\n(Sinal de entrada defasado de 180 graus com rela\u00e7\u00e3o ao sinal de refer\u00eancia) 80\n\n4.1 Modelo de refer\u00eancia ISO/OSI aplicado ao protocolo CAN . . . . . . 84\n\n4.2 Exemplo de arbitragem numa rede CAN . . . . . . . . . . . . . . . . 86\n\n4.3 Quadro padr\u00e3o com identi?cador de 11bits (CAN 2.0A) . . . . . . . . 86\n\n4.4 Quadro estendido com identi?cador de 29bits (CAN 2.0B) . . . . . . 87\n\n4.5 Gr\u00e1?co dos n\u00edveis de tens\u00e3o num barramento CAN . . . . . . . . . . 89\n\n4.6 Divis\u00e3o em quatro segmentos de umbit no protocolo CAN . . . . . . 90\n\n4.7 Montagem da rede CAN com m\u00f3dulos SBC28PC e microcontroladores\n\nPIC 18F258 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\n\nxvii\n\n\n\n4.8 Quadro remoto enviado pelo N\u00f3 0 ao barramento CAN com o N\u00f3 1\n\ndesconectado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93\n\n4.9 Visualiza\u00e7\u00e3o das mensagens transmitidas na rede CAN a partir de um\n\nterminal serial no PC . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\n\n4.10 Visualiza\u00e7\u00e3o do estado dos registradores internos do N\u00f3 0 . . . . . . . 95\n\n4.11 Diagrama em blocos do m\u00f3dulo CAN descrito em VHDL . . . . . . . 96\n\n4.12 Resutados obtidos na simula\u00e7\u00e3o da entidade BIT TIMING 1. O ponto\n\nde amostragem ocorre entre PHASE_SEG1 e PHASE_SEG2. Dois\n\npontos de amostragem consecutivos est\u00e3o separados por 8 Tq . . . . . 97\n\n4.13 Resultados obtidos na simula\u00e7\u00e3o da entidade BIT TIMING 2. Dois\n\npontos de transmiss\u00e3o consecutivos est\u00e3o separados por 8 Tq . . . . . 97\n\n4.14 Resultados obtidos na simula\u00e7\u00e3o da entidade STUFF HANDLER. Um\n\nstu? bit \u00e9 gerado ap\u00f3s a amostragem de cincobits recessivos consecutivos 98\n\n4.15 Resultados obtidos na simula\u00e7\u00e3o da entidade STUFF HANDLER. Um\n\nstu? error ocorre ap\u00f3s a amostragem do sextobit recessivo consecutivo 98\n\n4.16 Resultados obtidos na simula\u00e7\u00e3o da entidade CRC. O c\u00e1lculo de CRC\n\n\u00e9 realizado ap\u00f3s cada bit recebido . . . . . . . . . . . . . . . . . . . . 98\n\n4.17 Resultados obtidos na simula\u00e7\u00e3o da entidade CRC. O c\u00e1lculo de CRC\n\n\u00e9 interrompido na ocorr\u00eancia de umstu? bit . . . . . . . . . . . . . . 99\n\n4.18 Resultados obtidos na simula\u00e7\u00e3o da entidade CAN RX. O identi?cador\n\nda mensagem recebida (id_rx = 110011001112) \u00e9 armazenado ap\u00f3s\n\ndoze pontos de amostragem . . . . . . . . . . . . . . . . . . . . . . . 99\n\n4.19 Resultados obtidos na simula\u00e7\u00e3o da entidade CAN RX. Mensagem re-\n\ncebida: msg_rx = 0001110102. CRC calculado: crc = 0100110011010002100\n\n4.20 Resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX. Identi?cador\n\na ser transmitido: id_tx = 199C00016. Dado a ser transmitido:\n\nmsg_tx = 3A16. CRC a ser transmitido: crc_tx = 266816 . . . . . . 100\n\n4.21 Resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX. Identi?cador\n\nrecebido: id_tx = 199C00016. Dado recebido: msg_tx = 3A16. CRC\n\nrecebido: crc_tx = 266816 . . . . . . . . . . . . . . . . . . . . . . . . 101\n\n4.22 Resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX. Um bit de\n\nreconhecimento \u00e9 enviado, ack_tx = 0, validando a transmiss\u00e3o . . . 102\n\nxviii\n\n\n\n4.23 Resultados obtidos na simula\u00e7\u00e3o de uma rede CAN com tr\u00eas n\u00f3s. O N\u00f3\n\n0 envia um quadro remoto solicitando um dado do N\u00f3 1. Em seguida,\n\no N\u00f3 1 envia o dado solicitado . . . . . . . . . . . . . . . . . . . . . . 102\n\n4.24 Resultados obtidos na simula\u00e7\u00e3o de uma rede CAN com tr\u00eas n\u00f3s. O N\u00f3\n\n0 envia um quadro remoto solicitando um dado do N\u00f3 2. Em seguida,\n\no N\u00f3 2 envia o dado solicitado . . . . . . . . . . . . . . . . . . . . . . 102\n\n4.25 Montagem experimental da rede CAN com placas SBC28PC e micro-\n\ncontroladores PIC 18F258, incluindo o m\u00f3dulo CAN implementado em\n\nFPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\n\n4.26 Forma de onda obtida com o oscilosc\u00f3pio de um quadro de dados ap\u00f3s\n\nimplementa\u00e7\u00e3o do m\u00f3dulo CAN em FPGA . . . . . . . . . . . . . . . 105\n\n4.27 Representa\u00e7\u00e3o, a partir do programa Terminal, dosbytes menos signi-\n\n?cativos dos sinais de sa\u00edda dos canais X e Y : \"00011000\"e \"00000000\",\n\nrespectivamente . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n\nD.1 Diagrama em blocos do microcontrolador LAMPI\u00c3O (Vers\u00e3o Inicial) [3]189\n\nD.2 Diagrama em blocos do microcontrolador LAMPI\u00c3O (Vers\u00e3o Atual) [31]190\n\nD.3 Diagrama de contexto do sistema . . . . . . . . . . . . . . . . . . . . 191\n\nD.4 Diagrama em blocos dos elementos do Sistema Operacional . . . . . . 192\n\nD.5 Fluxograma da rotina de tratamento de uma interrup\u00e7\u00e3o de rel\u00f3gio . 192\n\nD.6 Fluxograma da rotina de tratamento de uma interrup\u00e7\u00e3o externa . . 193\n\nD.7 Fluxograma da rotina de tratamento de uma chamada ao sistema para\n\nsolicita\u00e7\u00e3o de recurso . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n\nD.8 Estrutura do Sistema Operacional Monol\u00edtico . . . . . . . . . . . . . 195\n\nD.9 Diagrama de estados dos processos . . . . . . . . . . . . . . . . . . . 196\n\nD.10 Fluxograma de opera\u00e7\u00e3o do despachante . . . . . . . . . . . . . . . . 198\n\nxix\n\n\n\nCap\u00edtulo 1\n\nIntrodu\u00e7\u00e3o\n\n1.1 Sensores Inteligentes\n\nUm sensor inteligente \u00e9 um dispositivo que combina circuitos de sensoriamento, trans-\n\ndu\u00e7\u00e3o, condicionamento, medi\u00e7\u00e3o, aquisi\u00e7\u00e3o de dados e comunica\u00e7\u00e3o digital [1, 2, 3, 4].\n\nSensores inteligentes possuem internamente fun\u00e7\u00f5es de compensa\u00e7\u00e3o e de processa-\n\nmento de dados, sendo capazes de detectar valores anormais e de fazer tratamento dos\n\nvalores normais atrav\u00e9s de seus algoritmos e de par\u00e2metros gravados em sua mem\u00f3ria;\n\npossuem ainda a capacidade de se comunicar com outros dispositivos, utilizando uma\n\nrede de comunica\u00e7\u00e3o [3, 4].\n\nCaso o dispositivo seja capaz de atuar num determinado processo, de acordo com\n\num algoritmo pr\u00e9-de?nido, tem-se um atuador inteligente. De maneira geral, utiliza-\n\nse o termo transdutor inteligente para se referir tanto a um dispositivo sensor quanto\n\na um dispositivo atuador [5]. O diagrama em blocos de um transdutor inteligente\n\ngen\u00e9rico \u00e9 apresentado na Figura 1.1.\n\nSensores inteligentes possuem in\u00fameras aplica\u00e7\u00f5es nas ind\u00fastrias petroqu\u00edmica,\n\nautomotiva e aeroespacial; no controle de processos, na biomedicina, na agropecu\u00e1ria,\n\nentre outros segmentos de mercado [6]. Devido a essa diversidade, os fabricantes de\n\nsensores t\u00eam buscado desenvolver dispositivos cada vez mais \"inteligentes\", disponi-\n\nbilizando novas funcionalidades, adicionando maior capacidade de processamento e\n\ninterligando estes dispositivos a uma rede de comunica\u00e7\u00e3o. Tudo isso aliado a uma\n\nmaior autonomia (baixo consumo de energia) e a um menor custo.\n\n1\n\n\n\n2\n\nFigura 1.1: Diagrama em blocos de um transdutor inteligente gen\u00e9rico.\n\nUm sensor inteligente tradicional compreende tanto o sistema de medi\u00e7\u00e3o quanto\n\na interface de comunica\u00e7\u00e3o com a rede no mesmo dispositivo. Desse modo, o desen-\n\nvolvimento do sensor est\u00e1 fortemente relacionado ao tipo de rede na qual o dispositivo\n\nser\u00e1 inserido [5].\n\nExistem atualmente diversas implementa\u00e7\u00f5es de redes de sensores e protocolos\n\nde comunica\u00e7\u00e3o, cada qual com suas vantagens e desvantagens, dependendo do tipo\n\nde aplica\u00e7\u00e3o. Dessa forma, os fabricantes de sensores se depararam com o seguinte\n\nproblema: como integrar os seus dispositivos a toda essa variedade de protocolos\n\nde comunica\u00e7\u00e3o existentes? Obviamente que o desenvolvimento de um dispositivo\n\npara cada tipo de rede existente se tornaria um processo tecnicamente complexo e\n\nde custo bastante elevado. Surgiu, ent\u00e3o, a necessidade da cria\u00e7\u00e3o de um padr\u00e3o,\n\naceito universalmente, que permitisse o desenvolvimento e a integra\u00e7\u00e3o de novos dis-\n\npositivos aos sistemas existentes e emergentes [5]. Nesse sentido, o IEEE (Institute of\n\nElectrical and Electronic Engineers), em parceria com o NIST (National Institute of\n\nStandards and Technology) e representantes da ind\u00fastria, criou um projeto com o ob-\n\njetivo de conceber uma fam\u00edlia de padr\u00f5es que tornasse mais f\u00e1cil o desenvolvimento\n\nde transdutores inteligentes e a integra\u00e7\u00e3o desses dispositivos \u00e0s redes, sistemas e ins-\n\n\n\n3\n\ntrumentos baseados nas tecnologias atuais e futuras. Nascia a\u00ed a fam\u00edlia de padr\u00f5es\n\nIEEE 1451 [5].\n\nNeste trabalho \u00e9 apresentada a proposta de um sensor inteligente baseado na\n\nfam\u00edlia de padr\u00f5es IEEE 1451 e a implementa\u00e7\u00e3o dos circuitos de medi\u00e7\u00e3o e de co-\n\nmunica\u00e7\u00e3o utilizados neste dispositivo.\n\nNa pr\u00f3xima se\u00e7\u00e3o, ser\u00e3o apresentados alguns dos principais tipos de redes indus-\n\ntriais de comunica\u00e7\u00e3o existentes. Uma vez que o estado da arte do desenvolvimento\n\ndas redes industriais de comunica\u00e7\u00e3o est\u00e1 associado \u00e0 evolu\u00e7\u00e3o dos sistemas de au-\n\ntoma\u00e7\u00e3o industrial, ser\u00e1 realizada uma breve revis\u00e3o hist\u00f3rica das arquiteturas dos\n\nsistemas de controle de processos industriais.\n\nEm seguida, ser\u00e3o apresentados os v\u00e1rios subconjuntos da fam\u00edlia de padr\u00f5es IEEE\n\n1451. Posteriormente, ser\u00e1 discutida a arquitetura do sensor inteligente proposto\n\nneste trabalho. Finalmente, ser\u00e1 apresentado um exemplo de aplica\u00e7\u00e3o deste sensor\n\ninteligente na medi\u00e7\u00e3o de imped\u00e2ncias utilizando tomogra?a por imped\u00e2ncia el\u00e9trica.\n\n1.2 Redes Industriais de Comunica\u00e7\u00e3o\n\nUma rede industrial de comunica\u00e7\u00e3o \u00e9 um sistema que permite a troca de informa\u00e7\u00f5es\n\nentre dispositivos como: sensores, atuadores, controladores e esta\u00e7\u00f5es de supervis\u00e3o.\n\n\u00c9, em geral, mais robusta que uma rede de comunica\u00e7\u00e3o convencional. Apresenta,\n\ntipicamente, os seguintes requisitos [7, 8]:\n\n\u2022 Alta disponibilidade: garantia de que o sistema de comunica\u00e7\u00e3o estar\u00e1 dispon\u00edvel,\n\napresentando um baixo \u00edndice de falhas e um alto tempo m\u00e9dio entre falhas;\n\n\u2022 Comunica\u00e7\u00e3o em tempo real: a comunica\u00e7\u00e3o deve apresentar tempo de resposta\n\nprevis\u00edvel;\n\n\u2022 Con?abilidade: garantia de que em determinado momento a comunica\u00e7\u00e3o ser\u00e1\n\nrealizada;\n\n\u2022 Escalonamento: a rede deve possuir uma pol\u00edtica de comunica\u00e7\u00e3o bem de?nida,\n\ncontrolando o acesso dos seus componentes ao meio de comunica\u00e7\u00e3o;\n\n\n\n4\n\n\u2022 Escalabilidade: a rede deve est\u00e1 preparada para se expandir, sem que a tecnolo-\n\ngia utilizada se torne obsoleta ou deixe de atender \u00e0s necessidades do usu\u00e1rio;\n\n\u2022 Facilidade de opera\u00e7\u00e3o e manuten\u00e7\u00e3o: o sistema de comunica\u00e7\u00e3o deve utilizar\n\ndispositivos plug-and-play, facilitando, por exemplo, a substitui\u00e7\u00e3o de compo-\n\nnentes defeituosos;\n\n\u2022 Robustez mec\u00e2nica: os sistemas de conex\u00e3o utilizados devem ser mais resistentes\n\n\u00e0 desconex\u00f5es acidentais e \u00e0 condi\u00e7\u00f5es ambientais adversas;\n\n\u2022 Robustez el\u00e9trica: a camada f\u00edsica deve utilizar cabeamento mais imune \u00e0\n\nru\u00eddos, al\u00e9m de possuir dispositivos de prote\u00e7\u00e3o, por exemplo, contra curto-\n\ncircuitos.\n\nO estado da arte do desenvolvimento das redes industriais de comunica\u00e7\u00e3o est\u00e1\n\nassociado \u00e0 evolu\u00e7\u00e3o dos sistemas de automa\u00e7\u00e3o industrial. Um breve hist\u00f3rico dessa\n\nevolu\u00e7\u00e3o \u00e9 apresentado a seguir.\n\n1.2.1 Evolu\u00e7\u00e3o dos Sistemas de Automa\u00e7\u00e3o Industrial\n\nAt\u00e9 o in\u00edcio dos anos 40, a instrumenta\u00e7\u00e3o existente disponibilizava apenas a indica\u00e7\u00e3o\n\nlocal das vari\u00e1veis de processo. Dessa forma, o controle de processos industriais era\n\npredominantemente manual, realizado localmente pelo pr\u00f3prio operador do processo.\n\nConsequentemente, existia uma grande demanda de operadores no campo. Essa ar-\n\nquitetura de controle al\u00e9m de ine?ciente e lenta, era bastante insegura e suscept\u00edvel\n\n\u00e0 falhas [8].\n\nUm exemplo t\u00edpico de controle de processo manual e local \u00e9 apresentado na\n\nFigura 1.2. Trata-se de um processo de aquecimento de \u00e1gua fria a partir da troca\n\nde calor com o vapor. A temperatura da sa\u00edda de \u00e1gua quente (vari\u00e1vel controlada\n\nou vari\u00e1vel de processo) \u00e9 medida por um sensor e indicada localmente para o ope-\n\nrador do processo. O operador (controlador do processo), baseado na indica\u00e7\u00e3o da\n\ntemperatura, ajusta manualmente a abertura da v\u00e1lvula de controle da vaz\u00e3o de en-\n\ntrada de vapor (vari\u00e1vel manipulada), de forma a manter a sa\u00edda de \u00e1gua quente na\n\ntemperatura desejada (valor de refer\u00eancia ouset-point).\n\n\n\n5\n\nFigura 1.2: Exemplo t\u00edpico de controle de processo manual e local. O processo de\naquecimento de \u00e1gua \u00e9 controlado manualmente, na planta de processo, pelo operador.\n\nEntre 1940 e 1960 surgiram os primeiros transmissores1 pneum\u00e1ticos. Com a\n\nutiliza\u00e7\u00e3o desses transmissores, a grandeza medida passou a ser enviada para os con-\n\ntroladores autom\u00e1ticos e locais de processo.\n\nOs controladores, baseados no sinal pneum\u00e1tico dos transmissores e utilizando\n\nestrat\u00e9gias de controle con?guradas no campo, calculavam a a\u00e7\u00e3o de corre\u00e7\u00e3o a ser rea-\n\nlizada numa determinada vari\u00e1vel manipulada. Consequentemente, o controle passou\n\na ser realizado de forma autom\u00e1tica, demandando um menor n\u00famero de operadores,\n\naumentando a e?ci\u00eancia, a velocidade de resposta e a seguran\u00e7a do processo. Al\u00e9m\n\ndisso, como os controladores estavam espalhados na planta de processo, o sistema de\n\ncontrole era totalmente distribu\u00eddo [8]. Um exemplo t\u00edpico de controle de processo\n\nautom\u00e1tico e local \u00e9 apresentado na Figura 1.3.\n\nNa d\u00e9cada de 60, com o aumento da complexidade das plantas de processo, se\n\nfazia necess\u00e1rio o acompanhamento e o controle remoto das vari\u00e1veis de processo.\n\nSurgiu, ent\u00e3o, a sala de controle contendo um painel el\u00e9trico com os controladores\n\nde processo e as informa\u00e7\u00f5es das principais vari\u00e1veis da planta. Consequentemente,\n\nhouve a migra\u00e7\u00e3o do operador e dos controladores de processo do campo para a sala\n\n1Os transmissores s\u00e3o dispositivos capazes de transmitir um sinal proporcional a uma determi-\nnada grandeza medida (press\u00e3o, n\u00edvel, temperatura, etc.). No caso de dispositivos pneum\u00e1ticos,\npor exemplo, o sinal transmitido \u00e9 tipicamente uma press\u00e3o de ar na faixa de 3 a 15 psi. J\u00e1 os\ntransmissores eletr\u00f4nicos utilizam um sinal de corrente ou de tens\u00e3o (normalmente 4 a 20 mA ou 0\na 5V, respectivamente).\n\n\n\n6\n\nFigura 1.3: Exemplo t\u00edpico de controle de processo autom\u00e1tico e local. O processo\nde aquecimento de \u00e1gua \u00e9 controlado automaticamente, na planta de processo, pelo\ncontrolador de temperatura.\n\nde controle. Entretanto, apesar dos controladores serem colocados no mesmo painel,\n\no controle continuou a ser distribu\u00eddo, pois cada controlador era respons\u00e1vel por\n\numa determinada malha de controle [8]. Um exemplo t\u00edpico de controle de processo\n\nautom\u00e1tico e remoto \u00e9 apresentado na Figura 1.4.\n\nCom esse novo paradigma, aumentou-se a seguran\u00e7a do processo e das pessoas,\n\numa vez que o operador n\u00e3o precisaria estar presente no campo durante toda a jornada\n\nde trabalho. Al\u00e9m disso, com a migra\u00e7\u00e3o dos controladores para o painel de controle,\n\naumentou-se a prote\u00e7\u00e3o dos equipamentos, pois grande parte desses n\u00e3o ?cavam mais\n\nexpostos ao tempo [8].\n\nEm contrapartida, essa nova arquitetura ocasionou um maior atraso na resposta\n\ndo sistema. Al\u00e9m disso, o grande n\u00famero de cabos e o comprimento destes aumentou\n\no custo de instala\u00e7\u00e3o e manuten\u00e7\u00e3o do sistema. Finalmente, novos modos de falha\n\nforam criados (por exemplo, o rompimento de um cabo interligando um transmissor\n\nno campo e o controlador no painel de controle) [8].\n\nNa Figura 1.5 \u00e9 apresentado um antigo painel utilizado numa sala de controle de\n\numa re?naria de petr\u00f3leo. O detalhe dos controladores no painel \u00e9 apresentado na\n\nFigura 1.6.\n\nEm meados dos anos 70 passaram a ser utilizados instrumentos e transmissores\n\neletr\u00f4nicos anal\u00f3gicos, em substitui\u00e7\u00e3o aos instrumentos e transmissores pneum\u00e1ti-\n\ncos. Al\u00e9m disso, com o desenvolvimento dos microcomputadores e de dispositivos\n\neletr\u00f4nicos mais resistentes \u00e0s condi\u00e7\u00f5es de opera\u00e7\u00e3o industriais, o controle do pro-\n\n\n\n7\n\nFigura 1.4: Exemplo t\u00edpico de controle de processo autom\u00e1tico e remoto. O processo\nde aquecimento de \u00e1gua \u00e9 controlado automaticamente, a partir de um painel remoto\nna sala de controle.\n\nFigura 1.5: Ilustra\u00e7\u00e3o de um antigo painel de controle de uma re?naria de petr\u00f3leo.\nNa parte superior do painel \u00e9 representado o ?uxograma de engenharia da planta de\nprocesso. Na parte inferior est\u00e3o presentes os controladores de processo, as chaves de\ncon?gura\u00e7\u00e3o, as botoeiras e as indica\u00e7\u00f5es das vari\u00e1veis do processo.\n\n\n\n8\n\nFigura 1.6: Ilustra\u00e7\u00e3o dos controladores de processo no painel.\n\ncesso passou a ser realizado por um computador central, respons\u00e1vel por controlar\n\ntoda a planta. O sistema de controle passou ent\u00e3o a utilizar uma arquitetura centrali-\n\nzada, conforme ilustrado na Figura 1.7 [7].\n\nFigura 1.7: Arquitetura t\u00edpica de um sistema de controle centralizado.Um \u00fanico com-\nputador central \u00e9 utilizado para controlar todo o processo.\n\nUma vez que os processos se tornaram cada vez mais complexos, aumentando o\n\nn\u00famero de entradas e sa\u00eddas e a complexidade dos algoritmos de controle, o com-\n\nputador central passou a necessitar de uma maior capacidade de processamento, de\n\nmem\u00f3ria e de armazenamento para satisfazer aos requisitos de tempo de resposta,\n\ncon?abilidade e disponibilidade do sistema. Entretanto, a grande desvantagem desse\n\nsistema era a possibilidade de falha no computador central e consequente parada de\n\ntoda a planta industrial [7].\n\nA partir da d\u00e9cada de 80, os sistemas de controle se tornaram parcialmente dis-\n\n\n\n9\n\ntribu\u00eddos, utilizando v\u00e1rios computadores interligados desenvolvendo tarefas espec\u00ed?-\n\ncas, descentralizando a capacidade de processamento. Al\u00e9m disso, os dispositivos de\n\naquisi\u00e7\u00e3o de dados tamb\u00e9m passaram a ser distribu\u00eddos (unidades terminais remo-\n\ntas). Surgem, ent\u00e3o, as redes de supervis\u00e3o e controle e os sistemas DCS2(Distributed\n\nControl System) e SCADA(Supervisory Control and Data Acquisition) [7, 8].\n\nNos sistemas DCS, os n\u00edveis de supervis\u00e3o e controle s\u00e3o fornecidos no mesmo\n\npacote, utilizando normalmente uma rede de comunica\u00e7\u00e3o propriet\u00e1ria. Sistemas\n\nDCS s\u00e3o geralmente utilizados em aplica\u00e7\u00f5es que demandam estrat\u00e9gias de controle\n\nmuito complexas e intertravamentos simples, admitindo tempos de resposta mais altos\n\n[8]. Al\u00e9m disso, por serem constitu\u00eddos por um pacote fechado, os sistemas DCS s\u00e3o\n\ntipicamente utilizados em locais de pequena dispers\u00e3o geogr\u00e1?ca, como por exemplo,\n\numa re?naria de petr\u00f3leo ou uma usina termoel\u00e9trica.\n\nPor outro lado, nos sistemas SCADA, os n\u00edveis de supervis\u00e3o e controle s\u00e3o forneci-\n\ndos em pacotes distintos, utilizando tipicamente uma rede de comunica\u00e7\u00e3o aberta.\n\nO n\u00edvel de controle \u00e9 geralmente composto por CLP (Controladores L\u00f3gicos Pro-\n\ngram\u00e1veis). Sistemas SCADA s\u00e3o geralmente utilizados em aplica\u00e7\u00f5es que demandam\n\nestrat\u00e9gias de controle simples e intertravamentos mais complexos, apresentando um\n\nmenor tempo de resposta [8]. S\u00e3o utilizados normalmente em locais de grande disper-\n\ns\u00e3o geogr\u00e1?ca, tais como: campos de produ\u00e7\u00e3o de petr\u00f3leo (terrestres e mar\u00edtimos),\n\nmonitoramento de dutos, etc.\n\nVale salientar, entretanto, que as diferen\u00e7as entre os sistemas DCS e SCADA v\u00eam\n\ndesaparecendo ao longo do tempo, uma vez que os sistemas DCS v\u00eam apresentando\n\ntempo de resposta cada vez menor e os CLPs utilizados em sistemas SCADA est\u00e3o\n\ncada vez mais poderosos e com maior capacidade de processamento. As arquiteturas\n\ndos sistemas DCS e SCADA s\u00e3o apresentadas nas Figuras 1.8 e 1.9, respectivamente.\n\nFinalmente, em meados dos anos 90 at\u00e9 os dias atuais, com o acelerado desen-\n\nvolvimento da microeletr\u00f4nica, surgiram novos dispositivos cada vez mais baratos,\n\nde menores dimens\u00f5es e com capacidade cada vez maior de processamento. Os dis-\n\npositivos de campo (sensores e atuadores) passaram a englobar novas fun\u00e7\u00f5es, entre\n\nelas as de processamento de sinais e de controle. Isso fez com que a descentraliza\u00e7\u00e3o\n\ngeogr\u00e1?ca dos controladores se tornasse vi\u00e1vel. Al\u00e9m disso, esses dispostivos pas-\n\n2Tamb\u00e9m conhecido como SDCD, Sistema Digital de Controle Distribu\u00eddo.\n\n\n\n10\n\nFigura 1.8: Arquitetura t\u00edpica de um sistema DCS.\n\nFigura 1.9: Arquitetura t\u00edpica de um sistema SCADA.\n\n\n\n11\n\nsaram a ser interligados em rede. Dessa forma, o controle do processo volta ao campo\n\n(controle local) e o sistema volta a ser totalmente distribu\u00eddo. Surgem as redes de\n\ncampo [7, 8].\n\nA interliga\u00e7\u00e3o em rede de dispositivos de campo \u00e9 ilustrada na Figura 1.10. Al-\n\nguns exemplos de redes de dispositivos de campo: Foundation Fieldbus, DeviceNet,\n\nCANopen, Pro?bus, Seriplex, FIP I/O, ASi, Interbus, entre outros [7].\n\nFigura 1.10: Interliga\u00e7\u00e3o em rede de dispositivos de campo. Atrav\u00e9s da rede de\ncampo, sensores, atuadores e outros equipamentos de campo podem comunicar-se\nentre si e/ou com o controlador.\n\nConforme discutido anteriormente, toda essa variedade de protocolos de comuni-\n\nca\u00e7\u00e3o tem di?cultado o desenvolvimento de transdutores inteligentes e a integra\u00e7\u00e3o\n\nde novos dispositivos \u00e0 diversidade de redes de campo e sistemas existentes. Uma\n\nalternativa de padroniza\u00e7\u00e3o \u00e9 proposta na fam\u00edlia de padr\u00f5es IEEE 1451, que ser\u00e1\n\ndiscutida na pr\u00f3xima se\u00e7\u00e3o.\n\n1.3 IEEE 1451\n\nA fam\u00edlia IEEE 1451 \u00e9 composta por oito padr\u00f5es e descreve um conjunto aberto de\n\ninterfaces de comunica\u00e7\u00e3o que permite o acesso a dados do transdutor inteligente,\n\nindependente da rede na qual o dispositivo est\u00e1 inserido, conectando sensores e atua-\n\ndores a microprocessadores, sistemas de instrumenta\u00e7\u00e3o, redes industriais de comu-\n\n\n\n12\n\nnica\u00e7\u00e3o, tanto ao n\u00edvel de campo quanto ao n\u00edvel de controle [5]. \u00c9 composta pelos\n\nseguintes padr\u00f5es:\n\n\u2022 IEEE P1451.0: Common Functions, Communications Protocols and Transducer\n\nElectronic Data Sheets (TEDS) Formats;\n\n\u2022 IEEE 1451.1: Network Capable Application Processor (NCAP) Information\n\nModel;\n\n\u2022 IEEE 1451.2: Transducer to Microprocessor Communication Protocols and\n\nTransducer Electronic Data Sheet (TEDS) Formats;\n\n\u2022 IEEE 1451.3: Digital Communication and Transducer Electronic Data Sheet\n\n(TEDS) Formats for Distributed Multidrop Systems;\n\n\u2022 IEEE 1451.4: Mixed-Mode Communication Protocols and Transducer Electronic\n\nData Sheet (TEDS) Formats;\n\n\u2022 IEEE P1451.5: Wireless Communication Protocols and Transducer Electronic\n\nData Sheets (TEDS) Formats;\n\n\u2022 IEEE P1451.6: A High-Speed CANOpen Based Transducer Network Interface\n\nfor Intrinsically Safe and non-Intrinsically Safe Applications;\n\n\u2022 IEEE P1451.7: Transducers to Radio Frequency Identi?cation (RFID) Systems\n\nCommunication Protocols and Transducer Electronic Data Sheet Formats.\n\nAlguns padr\u00f5es encontram-se na fase de desenvolvimento (proposta). Isto \u00e9 indi-\n\ncado pela letra \"P\", antecedendo o n\u00famero do padr\u00e3o. A seguir, ser\u00e3o apresentados\n\nalguns conceitos fundamentais existentes na descri\u00e7\u00e3o de cada padr\u00e3o.\n\n1.3.1 Smart Transducer Interface Module (STIM)\n\nO STIM \u00e9 o m\u00f3dulo transdutor propriamente dito e independe do tipo rede de co-\n\nmunica\u00e7\u00e3o na qual o transdutor inteligente ser\u00e1 inserido. Cont\u00e9m os circuitos de\n\ntransdu\u00e7\u00e3o, condicionamento de sinal, medi\u00e7\u00e3o, convers\u00e3o e aquisi\u00e7\u00e3o de dados. \u00c9\n\ncomposto por sensores, atuadores, conversores anal\u00f3gico-digital (AD), conversores\n\n\n\n13\n\ndigital-anal\u00f3gico (DA), entradas e sa\u00eddas digitais, em qualquer combina\u00e7\u00e3o. O STIM\n\npode conter mais de um transdutor. Neste caso, tem-se um STIM multicanal ou\n\nmultivari\u00e1vel [5].\n\nO STIM tamb\u00e9m possui o TEDS (Transducer Electronic Data Sheet), dispositivo\n\nde mem\u00f3ria que armazena os dados e as informa\u00e7\u00f5es de con?gura\u00e7\u00e3o do transdutor.\n\nEstes dados e informa\u00e7\u00f5es, por sua vez, s\u00e3o transferidos entre o STIM e o NCAP\n\n(Network Capable Application Processor) atrav\u00e9s de uma l\u00f3gica de controle. Esta\n\nl\u00f3gica pode ser implementada, por exemplo, por um circuito discreto, por um ASIC\n\n(Application Speci?c Integrated Circuit) ou por um microprocessador [5].\n\nO diagrama em blocos de um STIM sensor, um STIM atuador e um STIM sensor\n\ne atuador s\u00e3o ilustrados nas Figuras 1.11, 1.12 e 1.13, respectivamente.\n\n1.3.2 Network Capable Application Processor (NCAP)\n\nO NCAP \u00e9 o dispositivo que implementa a interface entre o STIM e a rede de comu-\n\nnica\u00e7\u00e3o. Consequentemente, o NCAP depende do tipo de rede na qual o transdutor\n\ninteligente ser\u00e1 inserido. \u00c9 respons\u00e1vel pela solicita\u00e7\u00e3o e obten\u00e7\u00e3o de dados do STIM,\n\ntransmiss\u00e3o e recep\u00e7\u00e3o de mensagens via rede de comunica\u00e7\u00e3o e pela execu\u00e7\u00e3o das\n\nfun\u00e7\u00f5es de aplica\u00e7\u00e3o. Tamb\u00e9m prov\u00ea alimenta\u00e7\u00e3o ao circuito do STIM [5].\n\nO NCAP \u00e9 composto basicamente por umDriver STIM, por um programa aplica-\n\ntivo (usualmente gravado em Firmware), por um controlador de protocolo de rede e\n\npor um modelo orientado \u00e0 objeto, conforme especi?cado no padr\u00e3o IEEE 1451.1,\n\nque ser\u00e1 descrito posteriomente.\n\nOdriver STIM possui quatro fun\u00e7\u00f5es principais [5]:\n\n\u2022 Analisador do TEDS: conhece a estrutura do TEDS e monta o dado em pe\u00e7as\n\nsigni?cativas;\n\n\u2022 Driver de Interface: software respons\u00e1vel pela aquisi\u00e7\u00e3o de dados atrav\u00e9s da\n\ninterface com o STIM;\n\n\u2022 Driver API: prov\u00ea acesso aos blocos do TEDS, leitura dos sensores, controle dos\n\natuadores, disparos e interrup\u00e7\u00f5es, conforme descrito no padr\u00e3o IEEE 1451.2;\n\n\n\n14\n\nFigura 1.11: Diagrama em blocos de um STIM sensor.\n\nFigura 1.12: Diagrama em blocos de um STIM atuador.\n\nFigura 1.13: Diagrama em blocos de um STIM sensor e atuador.\n\n\n\n15\n\n\u2022 Corre\u00e7\u00e3o de Dados: algoritmo que converte os dados brutos lidos do STIM em\n\nunidades especi?cadas no TEDS.\n\nUm NCAP inicia a medi\u00e7\u00e3o ou uma determinada a\u00e7\u00e3o ap\u00f3s disparar uma requi-\n\nsi\u00e7\u00e3o ao STIM. Uma vez que a medi\u00e7\u00e3o foi realizada ou a a\u00e7\u00e3o completada, o STIM\n\nresponde com um sinal de reconhecimento. Al\u00e9m disso, o STIM pode interromper o\n\nNCAP se uma exce\u00e7\u00e3o ocorrer. Tipos comuns de exce\u00e7\u00e3o: erro dehardware, falha de\n\ncalibra\u00e7\u00e3o, falha de auto-teste, etc.\n\nO diagrama em blocos de um NCAP \u00e9 ilustrado na Figura 1.14.\n\nFigura 1.14: Diagrama em blocos de um NCAP.\n\n1.3.3 Transducer Electronic Data Sheet (TEDS)\n\nO TEDS \u00e9 um dispositivo de mem\u00f3ria presente no transdutor, que armazena infor-\n\nma\u00e7\u00f5es como: identi?ca\u00e7\u00e3o do transdutor, nome do fabricante, modelo do equipa-\n\nmento, n\u00famero de s\u00e9rie, dados de calibra\u00e7\u00e3o, faixa de medi\u00e7\u00e3o, etc. \u00c9 a documen-\n\nta\u00e7\u00e3o, a folha de dados eletr\u00f4nica do transdutor [5].\n\nO TEDS permite que o transdutor se auto identi?que na rede, facilitando a con?-\n\ngura\u00e7\u00e3o autom\u00e1tica do sistema. Esta capacidade de auto-identi?ca\u00e7\u00e3o do transdutor\n\n\u00e9 importante na manuten\u00e7\u00e3o do sistema, no diagn\u00f3stico de falhas, etc. O TEDS\n\n\n\n16\n\npode ser atualizado para o sistema na sua energiza\u00e7\u00e3o(power-up) ou a partir de uma\n\nrequisi\u00e7\u00e3o.\n\nUma vez que o STIM \u00e9 energizado, os dados contidos no TEDS tornam-se dispo-\n\nn\u00edveis ao NCAP para uso local e para serem enviados a outros dispositivos a partir da\n\nrede de comunica\u00e7\u00e3o, caso necess\u00e1rio. A partir da leitura do TEDS, o NCAP conhece\n\nqu\u00e3o rapidamente ele pode se comunicar com o STIM, qual o n\u00famero de canais do\n\nSTIM e qual o formato de dados de cada canal.\n\nA estrutura de dados do TEDS \u00e9 dividida em cinco partes [5]: Meta-TEDS, TEDS\n\nde Canal, TEDS de Calibra\u00e7\u00e3o, TEDS de Aplica\u00e7\u00e3o e TEDS de Expans\u00e3o.\n\n\u2022 Meta-TEDS: cont\u00e9m o campo de dados comum a todos os transdutores conec-\n\ntados ao STIM. Tamb\u00e9m cont\u00e9m uma descri\u00e7\u00e3o geral da estrutura de dados do\n\nTEDS, par\u00e2metros de temporiza\u00e7\u00e3o, etc.;\n\n\u2022 TEDS de Canal: cont\u00e9m informa\u00e7\u00f5es sobre unidades f\u00edsicas, incerteza, faixa de\n\nmedi\u00e7\u00e3o, etc.;\n\n\u2022 TEDS de Calibra\u00e7\u00e3o: cont\u00e9m informa\u00e7\u00f5es sobre os par\u00e2metros de calibra\u00e7\u00e3o\n\ne o intervalo de calibra\u00e7\u00e3o de um transdutor. Tamb\u00e9m prov\u00ea as constantes\n\nnecess\u00e1rias \u00e0 convers\u00e3o dos dados brutos para unidades de engenharia, no caso\n\nde sensores, ou \u00e0 convers\u00e3o de dados em unidades de engenharia para a forma\n\nrequerida por um atuador;\n\n\u2022 TEDS de Aplica\u00e7\u00e3o: cont\u00e9m a aplica\u00e7\u00e3o espec\u00ed?ca de acordo com o uso do\n\ntransdutor pelo usu\u00e1rio ?nal;\n\n\u2022 TEDS de Expans\u00e3o: disponibilizada para futuras implementa\u00e7\u00f5es.\n\nA arquitetura de rede de sensores inteligentes baseada no padr\u00e3o IEEE 1451 \u00e9\n\napresentada na Figura 1.15, ilustrando como a aplica\u00e7\u00e3o dos conceitos de STIM e\n\nNCAP podem facilitar o desenvolvimento de transdutores inteligentes. Os fabricantes\n\npodem desenvolver m\u00f3dulos transdutores (STIM) mais gen\u00e9ricos, independentes da\n\nrede de comunica\u00e7\u00e3o. Em paralelo ao desenvolvimento de STIM independentes, os\n\nfabricantes podem desenvolver m\u00f3dulos processadores de comunica\u00e7\u00e3o voltados \u00e0 uma\n\ndeterminada rede, ou \u00e0 v\u00e1rias redes diferentes, e integrar estes m\u00f3dulos de comuni-\n\nca\u00e7\u00e3o ao STIM gen\u00e9rico. Al\u00e9m disso, surge a ?gura do integrador de sistemas, que\n\n\n\n17\n\npode utilizar um STIM e um NCAP de fabricantes diferentes, uma vez que as inter-\n\nfaces de comunica\u00e7\u00e3o entre STIM e NCAP seguem um padr\u00e3o aberto. O usu\u00e1rio ?nal\n\ntem, portanto, uma vasta gama de possibilidades, podendo implementar sua rede de\n\nsensores inteligentes de acordo com as suas necessidades, sem que seja necess\u00e1ria a\n\ncria\u00e7\u00e3o de um projeto espec\u00ed?co, iniciado do zero, restrito \u00e0 aplica\u00e7\u00e3o transdutora e\n\n\u00e0 interface de comunica\u00e7\u00e3o.\n\nFigura 1.15: Arquitetura de rede de sensores inteligentes baseada na fam\u00edlia de\npadr\u00f5es IEEE 1451. Nesta ilustra\u00e7\u00e3o, o mesmo m\u00f3dulo transdutor (STIM) \u00e9 utilizado,\nindependentemente da rede de comunica\u00e7\u00e3o. Por outro lado, o NCAP \u00e9 projetado de\nacordo com o tipo de rede.\n\n1.3.4 IEEE P1451.0\n\nNo padr\u00e3o proposto IEEE P1451.0 s\u00e3o de?nidos o TEDS e um conjunto de comandos e\n\nopera\u00e7\u00f5es comuns \u00e0 fam\u00edlia de padr\u00f5es IEEE 1451, de maneira a permitir que o acesso\n\naos transdutores seja realizado independentemente do meio f\u00edsico de comunica\u00e7\u00e3o\n\nentre os transdutores e o NCAP. Consequentemente, o acesso ao transdutor pelo\n\nNCAP deve ser realizado da mesma forma, independentemente se o meio f\u00edsico entre\n\ntransdutor e NCAP \u00e9 implementado utilizando rede cabeada ou sem ?o [5].\n\nO padr\u00e3o IEEE P1451.0 encontra-se atualmente em desenvolvimento.\n\n1.3.5 IEEE 1451.1\n\nNo padr\u00e3o IEEE 1451.1 \u00e9 de?nido um modelo orientado \u00e0 objeto, presente no NCAP,\n\nque descreve o comportamento do m\u00f3dulo de transdu\u00e7\u00e3o inteligente (STIM). S\u00e3o\n\nde?nidos ainda os modelos de comunica\u00e7\u00e3o suportados. Entre eles est\u00e3o os modelos\n\ncliente-servidor e produtor-consumidor. O programa aplicativo executado no NCAP\n\n\n\n18\n\ncomunica-se com os transdutores atrav\u00e9s de diferentes camadas f\u00edsicas, de acordo com\n\na aplica\u00e7\u00e3o [5].\n\nO padr\u00e3o IEEE 1451.1 j\u00e1 foi publicado e pode ser adquirido atrav\u00e9s do IEEE.\n\n1.3.6 IEEE 1451.2\n\nNo padr\u00e3o IEEE 1451.2 \u00e9 de?nida uma interface ponto-a-ponto entre o STIM e o\n\nNCAP. O padr\u00e3o original descreve a camada de comunica\u00e7\u00e3o baseada na interface\n\nSPI (Serial Peripheral Interface), adicionando linhas HW para controle de ?uxo e\n\ntemporiza\u00e7\u00e3o. Entretanto, o padr\u00e3o est\u00e1 sendo revisado no intuito de oferecer suporte\n\ntamb\u00e9m \u00e0 interface UART(Universal Asynchronous Receiver and Transmitter) [5].\n\nO padr\u00e3o IEEE 1451.2 j\u00e1 foi publicado e pode ser adquirido atrav\u00e9s do IEEE.\n\nNa Figura 1.16 \u00e9 ilustrada a aplica\u00e7\u00e3o dos padr\u00f5es IEEE 1451.1 e IEEE 1451.2.\n\nEnquanto no IEEE 1451.1 \u00e9 de?nido o modelo orientado \u00e0 objeto do STIM (indepen-\n\ndente da interface STIM-NCAP), no padr\u00e3o IEEE 1451.2 \u00e9 de?nida a interface de\n\ncomunica\u00e7\u00e3o entre o STIM e o NCAP.\n\nFigura 1.16: Exemplo de aplica\u00e7\u00e3o dos padr\u00f5es IEEE 1451.1 e IEEE 1451.2. O\nmodelo orientado \u00e0 objeto do m\u00f3dulo de transdu\u00e7\u00e3o (STIM) \u00e9 padronizado de acordo\ncom IEEE 1451.1. Por outro lado, a interface normalizada entre o STIM e o NCAP\n\u00e9 de?nida no padr\u00e3o IEEE 1451.2.\n\n1.3.7 IEEE 1451.3\n\nNo padr\u00e3o IEEE P1451.3 \u00e9 de?nida uma interface entre o STIM e o NCAP, baseada\n\nnuma arquitetura de comunica\u00e7\u00e3o distribu\u00edda. Essa interface permite que v\u00e1rios\n\n\n\n19\n\nSTIMs sejam interligados entre si e ao NCAP a partir de uma rede multi-ponto,\n\ncompartilhando o mesmo par de ?os [5].\n\nO padr\u00e3o IEEE 1451.3 j\u00e1 foi publicado e pode ser adquirido atrav\u00e9s do IEEE.\n\nNa Figura 1.17 \u00e9 ilustrada a aplica\u00e7\u00e3o do padr\u00e3o IEEE 1451.3, de?nindo uma\n\ninterface de comunica\u00e7\u00e3o entre o NCAP e uma rede de transdutores.\n\nFigura 1.17: Exemplo de aplica\u00e7\u00e3o do padr\u00e3o IEEE 1451.3 de?nindo uma interface\nnormalizada entre o NCAP e uma rede de transdutores.\n\n1.3.8 IEEE 1451.4\n\nNo padr\u00e3o IEEE 1451.4 \u00e9 de?nida uma interface mista para transdutores anal\u00f3gicos,\n\ncom modos de opera\u00e7\u00e3o anal\u00f3gico e digital. Um TEDS \u00e9 adicionado a um sensor\n\ntradicional, contendo um ampli?cador FET, excitado por uma corrente constante\n\natrav\u00e9s de um par de ?os. O modelo de TEDS tamb\u00e9m \u00e9 re?nado para permitir que\n\num m\u00ednimo de dados pertinentes fossem armazenados num dispositivo de mem\u00f3ria\n\n?sicamente pequena, como requerido por pequenos sensores (mais simples). Modelos\n\n(padronizados) s\u00e3o usados para descrever a estrutura de dados da TEDS. Os modelos\n\natuais abrangem aceler\u00f4metros, extens\u00f4metros(strain gauges), sensores de malha de\n\ncorrente, microfones, etc. [5].\n\nO padr\u00e3o IEEE 1451.4 j\u00e1 foi publicado e pode ser adquirido atrav\u00e9s do IEEE.\n\n1.3.9 IEEE P1451.5\n\nNo padr\u00e3o IEEE P1451.5 \u00e9 de?nida uma interface sem ?o entre o STIM e o NCAP.\n\nAlgumas das interfaces f\u00edsicas suportadas s\u00e3o de?nidas nos padr\u00f5es IEEE 802.11\n\n\n\n20\n\n(WiFi), IEEE 802.15.1(Bluetooth) e IEEE 802.15.4(ZigBee) [5].\n\nA interface sem ?o de?nida no padr\u00e3o IEEE P1451.5 em conjunto com a TEDS,\n\nas opera\u00e7\u00f5es e os comandos de?nidos no padr\u00e3o IEEE P1451.0, visam proporcionar\n\na interoperabilidade entre os dados transmitidos a partir de qualquer um dos tr\u00eas\n\nprotocolos sem ?o considerados [5].\n\nO padr\u00e3o IEEE P1451.5 encontra-se atualmente em desenvolvimento.\n\n1.3.10 IEEE P1451.6\n\nNo padr\u00e3o IEEE P1451.6 \u00e9 de?nida uma interface de rede de alta velocidadeCANopen\n\npara comunica\u00e7\u00e3o entre o STIM e o NCAP, suportando aplica\u00e7\u00f5es nas \u00e1reas de ins-\n\ntrumenta\u00e7\u00e3o e controle de processos industriais, tanto em ambientes intr\u00ednsecamente\n\nseguros quanto n\u00e3o-intr\u00ednsecamente seguros [5].\n\nOs par\u00e2metros do TEDS s\u00e3o de?nidos de forma a permitir a compatibilidade de\n\ndados entre os dispositivos na rede CANopen, que podem ser desde um simples sensor\n\nat\u00e9 um controlador de malha fechada de alto desempenho [5].\n\nNesse sentido, \u00e9 de?nido um mapeamento do TEDS no dicion\u00e1rio objetoCANopen,\n\ncomo tamb\u00e9m mensagens de comunica\u00e7\u00e3o, dados de processo, par\u00e2metros de con?-\n\ngura\u00e7\u00e3o e diagn\u00f3stico, adotando como refer\u00eancia o per?l de dispositivo CiA(CAN in\n\nAutomation) 404 (CANopen Device Pro?le for Measuring Devices and Closed-Loop\n\nControllers).\n\nO padr\u00e3o IEEE P1451.6 encontra-se atualmente em desenvolvimento.\n\nUm exemplo de aplica\u00e7\u00e3o do padr\u00e3o IEEE P1451.6 \u00e9 apresentado na Figura 1.18.\n\n1.3.11 IEEE P1451.7\n\nNo padr\u00e3o IEEE P1451.7 s\u00e3o descritos m\u00e9todos de comunica\u00e7\u00e3o, formatos de dados\n\ne TEDS para sensores trabalhando em coopera\u00e7\u00e3o com sistemas de identi?ca\u00e7\u00e3o por\n\nr\u00e1dio-frequ\u00eancia, RFID(Radio Frequency Identi?cation).\n\nO padr\u00e3o IEEE P1451.7 encontra-se atualmente em desenvolvimento.\n\n1.3.12 Aplica\u00e7\u00f5es da Fam\u00edlia de Padr\u00f5es IEEE 1451\n\nA fam\u00edlia de padr\u00f5es IEEE 1451 pode ser aplicada, por exemplo, em [5]:\n\n\n\n21\n\nFigura 1.18: Exemplo de aplica\u00e7\u00e3o do padr\u00e3o IEEE 1451.6 de?nindo uma interface\nnormalizada entre o NCAP e uma rede de transdutoresCANopen.\n\n\u2022 Monitora\u00e7\u00e3o Remota: os par\u00e2metros f\u00edsicos medidos por um STIM sensor po-\n\ndem ser monitorados remotamente atrav\u00e9s do NCAP, que possui a capacidade\n\nde enviar os dados resultantes das medi\u00e7\u00f5es do sensor atrav\u00e9s da rede de comu-\n\nnica\u00e7\u00e3o. Cada esta\u00e7\u00e3o conectada \u00e0 rede pode monitorar as medi\u00e7\u00f5es realizadas\n\ne os demais dados do sensor. Dependendo da necessidade, essas informa\u00e7\u00f5es\n\npodem at\u00e9 mesmo serem enviadas atrav\u00e9s da Internet;\n\n\u2022 Atua\u00e7\u00e3o Remota: permite que uma esta\u00e7\u00e3o remota possa manipular a sa\u00edda de\n\num STIM atuador a partir do NCAP;\n\n\u2022 Controle Distribu\u00eddo (atua\u00e7\u00e3o baseada em medi\u00e7\u00e3o local): um STIM contendo\n\ntanto sensores quanto atuadores pode realizar a medi\u00e7\u00e3o de uma vari\u00e1vel de\n\nprocesso e executar a a\u00e7\u00e3o de corre\u00e7\u00e3o numa determinada vari\u00e1vel manipulada,\n\nexercendo a fun\u00e7\u00e3o de controle local. A fun\u00e7\u00e3o de controle pode ser con?gurada\n\npor qualquer NCAP da rede;\n\n\u2022 Controle e Medi\u00e7\u00e3o Colaborativa: um conjunto formado por um NCAP conec-\n\ntado a um STIM sensor e outro NCAP conectado a um STIM atuador pode\n\nrealizar medi\u00e7\u00f5es remotas e controlar opera\u00e7\u00f5es, de forma colaborativa, comu-\n\nnicando-se um ao outro atrav\u00e9s de uma rede de NCAPs.\n\nEstes exemplos de aplica\u00e7\u00e3o s\u00e3o apresentados de forma simpli?cada na Figura 1.19.\n\n\n\n22\n\nFigura 1.19: Exemplos de aplica\u00e7\u00e3o da fam\u00edlia de padr\u00f5es IEEE 1451.\n\nFigura 1.20: Arquitetura do sensor inteligente proposto.\n\n\n\n23\n\n1.4 Arquitetura do Sensor Inteligente Proposto\n\nNa Figura 1.20 \u00e9 apresentada a arquitetura do sensor inteligente integrado em desen-\n\nvolvimento no LDN (Laborat\u00f3rio de Dispositos e Nanoestruturas) da UFPE (Univer-\n\nsidade Federal de Pernambuco). Este dispositivo re\u00fane, no mesmochip:\n\n\u2022 Circuitos de aquisi\u00e7\u00e3o de dados e gera\u00e7\u00e3o de sinal: conversores AD e DA;\n\n\u2022 Circuito de medi\u00e7\u00e3o, condicionamento e processamento de sinais: ampli?cador\n\nsens\u00edvel \u00e0 fase (LOCK-IN);\n\n\u2022 L\u00f3gica de Controle: microcontrolador LAMPI\u00c3O (LDN - Arquitetura de Mi-\n\ncrocontrolador e Propriedade Intelectual para automa\u00e7\u00c3O) com um SOTR (Sis-\n\ntema Operacional de Tempo Real) embarcado para aquisi\u00e7\u00e3o de dados e comu-\n\nnica\u00e7\u00e3o;\n\n\u2022 Interface de Rede: m\u00f3dulo MARIA (M\u00f3dulo de Acesso \u00e0 Rede para Instrumen-\n\nta\u00e7\u00e3o Avan\u00e7ada), contendo uma implementa\u00e7\u00e3o do protocolo CAN (Controller\n\nArea Network);\n\n\u2022 Mem\u00f3ria PROM: para armazenamento da folha de dados eletr\u00f4nica do sensor;\n\n\u2022 Mem\u00f3ria RAM: para armazenamento de dados durante a execu\u00e7\u00e3o da aplica\u00e7\u00e3o.\n\nUm exemplo de aplica\u00e7\u00e3o do sensor inteligente proposto neste trabalho \u00e9 discutido\n\nna pr\u00f3xima se\u00e7\u00e3o.\n\n1.4.1 Exemplo de Aplica\u00e7\u00e3o: Medi\u00e7\u00e3o de Vaz\u00e3o de Fluxos\n\nMultif\u00e1sicos utilizando Tomogra?a por Imped\u00e2ncia El\u00e9-\n\ntrica\n\nFluxos multif\u00e1sicos s\u00e3o ?uidos em movimento em que est\u00e3o presentes mais de um\n\ncomponente. Eles ocorrem em diversos sistemas reais, desde a medicina (por exemplo,\n\nno ?uxo sangu\u00edneo) at\u00e9 a ind\u00fastria de petr\u00f3leo.\n\nEm particular, na ind\u00fastria de petr\u00f3leo, o \u00f3leo extra\u00eddo \u00e9 uma mistura de \u00f3leo\n\npesado, \u00e1gua, g\u00e1s, al\u00e9m de alguns sedimentos [9]. Com a quebra de monop\u00f3lio do\n\n\n\n24\n\nsetor, tornou-se interessante o desenvolvimento de medidores de vaz\u00e3o para ?uxos\n\nmultif\u00e1sicos desse tipo. Esses medidores ser\u00e3o de grande import\u00e2ncia na determina\u00e7\u00e3o\n\nprecisa da produ\u00e7\u00e3o de um po\u00e7o e para a correta cobran\u00e7a de impostos [10].\n\nA medi\u00e7\u00e3o de vaz\u00e3o em ?uxos multif\u00e1sicos pode ser dividida em duas etapas.\n\nNa primeira, mede-se a vaz\u00e3o total e na segunda mede-se a fra\u00e7\u00e3o de volume dos\n\ncomponentes do ?uxo [10].\n\nPara medir a vaz\u00e3o total pode-se utilizar uma das diversas t\u00e9cnicas existentes para\n\nmedi\u00e7\u00e3o de vaz\u00e3o em ?uxo monof\u00e1sico: Placa de Orif\u00edcio, Venturi, V-Cone, Annubar,\n\nVortex, Coriolis, Ultrassom, Rot\u00e2metro, Medidor T\u00e9rmico, Deslocamento Rotativo,\n\nTurbina, Medidor Magn\u00e9tico, etc.\n\nPara medir a fra\u00e7\u00e3o de volume pode-se utilizar uma t\u00e9cnica tomogr\u00e1?ca n\u00e3o-\n\ninvasiva, como a Tomogra?a por Imped\u00e2ncia El\u00e9trica. Com esta t\u00e9cnica, a dis-\n\ntribui\u00e7\u00e3o de fases no interior de uma tubula\u00e7\u00e3o de petr\u00f3leo pode ser obtida, estimando-\n\nse o percentual de \u00f3leo, \u00e1gua e g\u00e1s que comp\u00f5em o \u00f3leo extra\u00eddo.\n\nTomogra?a por Imped\u00e2ncia El\u00e9trica \u00e9 uma t\u00e9cnica n\u00e3o-intrusiva de reconstru\u00e7\u00e3o\n\nde imagens baseada no princ\u00edpio que materiais diferentes t\u00eam propriedades el\u00e9tricas\n\ndiferentes. Consiste em medir a imped\u00e2ncia el\u00e9trica (resist\u00eancia, capacit\u00e2ncia, in-\n\ndut\u00e2ncia ou combina\u00e7\u00e3o dessas quantidades) usando uma matriz de eletrodos insta-\n\nlados ao redor de uma tubula\u00e7\u00e3o [11, 12, 13, 14], conforme ilustrado na Figura 1.21.\n\nUm algoritmo de reconstru\u00e7\u00e3o de imagens explora estas propriedades el\u00e9tricas de\n\nmaneira a produzir uma imagem da se\u00e7\u00e3o transversal sobre a qual os eletrodos est\u00e3o\n\ndistribu\u00eddos.\n\nFigura 1.21: Con?gura\u00e7\u00e3o de uma tubula\u00e7\u00e3o com eletrodos de medi\u00e7\u00e3o e sua se\u00e7\u00e3o\ntransversal ?.\n\nExistem basicamente dois m\u00e9todos de medi\u00e7\u00e3o utilizados em Tomogra?a por\n\n\n\n25\n\nImped\u00e2ncia el\u00e9trica. No primeiro m\u00e9todo, um dos eletrodos de medi\u00e7\u00e3o \u00e9 aterrado\n\neletricamente e uma tens\u00e3o el\u00e9trica conhecida \u00e9 aplicada em cada um dos eletrodos de\n\nmedi\u00e7\u00e3o restantes, medindo-se as correntes el\u00e9tricas resultantes. As correntes el\u00e9tri-\n\ncas resultantes s\u00e3o desconhecidas a priori e dependem da distribui\u00e7\u00e3o de imped\u00e2ncia\n\nel\u00e9trica no interior da tubula\u00e7\u00e3o [15].\n\nTipicamente, por quest\u00f5es de seguran\u00e7a, um segundo m\u00e9todo de medi\u00e7\u00e3o \u00e9 uti-\n\nlizado. Nesse m\u00e9todo alternativo, aterra-se eletricamente um dos eletrodos de medi\u00e7\u00e3o\n\ne injeta-se uma corrente el\u00e9trica conhecida em cada um dos eletrodos de medi\u00e7\u00e3o\n\nrestantes, medindo-se as tens\u00f5es el\u00e9tricas resultantes. Neste caso, as tens\u00f5es el\u00e9tri-\n\ncas resultantes s\u00e3o desconhecidas a priori e dependem da distribui\u00e7\u00e3o de imped\u00e2ncia\n\nel\u00e9trica no interior da tubula\u00e7\u00e3o [15].\n\nA inje\u00e7\u00e3o de corrente el\u00e9trica e a medi\u00e7\u00e3o dos potenciais nos eletrodos podem\n\nseguir diversas topologias [15]. Uma delas \u00e9 apresentada na Figura 1.22.\n\nFigura 1.22: Topologia de inje\u00e7\u00e3o de corrente e medi\u00e7\u00e3o de potencial nos diversos\neletrodos do tom\u00f3grafo. Na ilustra\u00e7\u00e3o \"A\", uma corrente el\u00e9trica \u00e9 injetada entre\nos eletrodos 1 e 2 e as tens\u00f5es el\u00e9tricas resultantes s\u00e3o medidas nos demais eletro-\ndos. Este procedimento \u00e9 refeito (ilustra\u00e7\u00e3o \"B\") at\u00e9 que as N(N ? 1)/2 medidas\n(combina\u00e7\u00f5es lineares) sejam realizadas.\n\nA partir das medi\u00e7\u00f5es realizadas, aplica-se um algoritmo de reconstru\u00e7\u00e3o para\n\nse obter o per?l de condutividade e permissividade el\u00e9trica da \u00e1rea investigada. S\u00e3o\n\nnecess\u00e1rias pelo menos N(N ?1)/2 medidas para se obter os per?s de condutividade e\n\npermissividade da tubula\u00e7\u00e3o, onde N \u00e9 o n\u00famero de eletrodos. Com um conhecimento\n\npr\u00e9vio da condutividade e permissividade dos v\u00e1rios componentes contidos na \u00e1rea\n\ninvestigada, pode-se determinar a composi\u00e7\u00e3o do material no interior do tubo.\n\n\n\n26\n\nUma vez que as propriedades el\u00e9tricas do \u00f3leo, da \u00e1gua e do g\u00e1s s\u00e3o bem conheci-\n\ndas, pode-se obter a distribui\u00e7\u00e3o de fases no interior da tubula\u00e7\u00e3o de petr\u00f3leo, a partir\n\nda medi\u00e7\u00e3o das tens\u00f5es nos eletrodos e da utiliza\u00e7\u00e3o de um algoritmo de reconstru\u00e7\u00e3o\n\nde imagens. Dessa forma pode-se estimar o percentual de \u00e1gua, \u00f3leo e g\u00e1s presentes\n\nna tubula\u00e7\u00e3o.\n\nA grande di?culdade da t\u00e9cnica de imped\u00e2ncia el\u00e9trica \u00e9 que ela \u00e9 muito sens\u00edvel\n\n\u00e0 ru\u00eddo e a qualidade da reconstru\u00e7\u00e3o deteriora com o aumento da resolu\u00e7\u00e3o espacial.\n\nA precis\u00e3o da medida \u00e9 fundamental para se obter uma boa resolu\u00e7\u00e3o [10].\n\nNa Figura 1.23 \u00e9 ilustrado o diagrama esquem\u00e1tico de um equipamento de Tomo-\n\ngra?a por Imped\u00e2ncia El\u00e9trica [10]. O equipamento consiste de um gerador de sinal,\n\numa fonte de corrente controlada por tens\u00e3o, um multiplexador, um demultiplexador,\n\num ampli?cador de instrumenta\u00e7\u00e3o, um demodulador, um ?ltro passa-baixa, e um\n\nmicrocomputador com placa de aquisi\u00e7\u00e3o de dados.\n\nEsse equipamento usa a t\u00e9cnica do ampli?cador sens\u00edvel \u00e0 fase(lock-in) para medir\n\nimped\u00e2ncias [16]. Um sinal de 50 kHz \u00e9 utilizado para modular a fonte de corrente\n\ncontrolada por tens\u00e3o. Um dos eletrodos \u00e9 aterrado (retorno de corrente) e o multi-\n\nplexador \u00e9 utilizado para selecionar o eletrodo em que ser\u00e1 injetada a corrente. Isso\n\n\u00e9 feito para cada um dos eletrodos. Cada vez que um eletrodo \u00e9 selecionado para a\n\ninje\u00e7\u00e3o de corrente, a tens\u00e3o el\u00e9trica \u00e9 medida em cada um dos N-1 eletrodos atrav\u00e9s\n\ndo demultiplexador e do ampli?cador de instrumenta\u00e7\u00e3o acoplado. O sinal medido \u00e9\n\nent\u00e3o demodulado, gerando um sinal constante e um sinal de 100 kHz, que \u00e9 eliminado\n\npelo ?ltro passa baixa. A tens\u00e3o constante, proporcional \u00e0 imped\u00e2ncia, \u00e9 ent\u00e3o me-\n\ndida pelo microcomputador, para ser utilizada pelo algoritmo de reconstru\u00e7\u00e3o. Essa\n\nt\u00e9cnica permite reduzir o n\u00edvel de ru\u00eddo, aumentando a resolu\u00e7\u00e3o da imagem.\n\nNa constru\u00e7\u00e3o de um sistema desse tipo \u00e9 necess\u00e1rio levar em considera\u00e7\u00e3o os\n\nseguintes aspectos [13]:\n\n\u2022 Geometria dos eletrodos;\n\n\u2022 T\u00e9cnica de medi\u00e7\u00e3o e aquisi\u00e7\u00e3o de dados;\n\n\u2022 Algoritmo de invers\u00e3o tomogr\u00e1?ca.\n\nEm particular, este trabalho est\u00e1 diretamente relacionado \u00e0 t\u00e9cnica de medi\u00e7\u00e3o\n\ne aquisi\u00e7\u00e3o de dados. Um sensor utilizado nesta aplica\u00e7\u00e3o deve, portanto, ser capaz\n\n\n\n27\n\nFigura 1.23: Esquema de um equipamento de tomogra?a por imped\u00e2ncia el\u00e9trica.\nUma corrente el\u00e9trica senoidal, produzida por uma fonte de corrente controlada por\num gerador de sinal de 50 kHz, \u00e9 multiplexada e injetada nos diversos eletrodos do\ntom\u00f3grafo. Utilizando a t\u00e9cnica lock-in, as medi\u00e7\u00f5es resultantes s\u00e3o demultiplexa-\ndas, ampli?cadas e demoduladas, a partir do sinal de refer\u00eancia (gerador de sinal).\nO ?ltro passa-baixa separa a componente CC do sinal demodulado, proporcional \u00e0\ncondut\u00e2ncia ou capacit\u00e2ncia da se\u00e7\u00e3o transversal da matriz de eletrodos. Finalmente,\na imagem da se\u00e7\u00e3o transversal, obtida a partir de um algoritmo de reconstru\u00e7\u00e3o de\nimagens, \u00e9 exibida na tela do microcomputador.\n\nde realizar uma medi\u00e7\u00e3o de tens\u00e3o bastante precisa. Al\u00e9m disso, \u00e9 interessante que o\n\nsensor seja capaz de processar o sinal medido e transmitir os resultados em formato\n\ndigital para serem usados em algum algoritmo de reconstru\u00e7\u00e3o de imagens.\n\nA t\u00e9cnica lock-in permite realizar medi\u00e7\u00f5es bastante precisas e de alta resolu\u00e7\u00e3o\n\nde sinais relativamente limpos, isto \u00e9, essencialmente sem ru\u00eddo. Al\u00e9m disso, essa\n\nt\u00e9cnica \u00e9 bastante e?ciente na recupera\u00e7\u00e3o de sinais que est\u00e3o efetivamente abaixo\n\ndo n\u00edvel de ru\u00eddo, isto \u00e9, com baixa rela\u00e7\u00e3o sinal-ru\u00eddo. O ampli?cador sens\u00edvel \u00e0\n\nfase tamb\u00e9m pode ser utilizado na caracteriza\u00e7\u00e3o el\u00e9trica de dispositivos, na medi\u00e7\u00e3o\n\nde imped\u00e2ncias, entre outras aplica\u00e7\u00f5es. Portanto, o ampli?cador sens\u00edvel \u00e0 fase \u00e9\n\num m\u00e9todo de medi\u00e7\u00e3o vers\u00e1til, sendo a t\u00e9cnica lock-in bastante apropriada para ser\n\nusada em Tomogra?a por Imped\u00e2ncia El\u00e9trica.\n\nA maior parte do processamento realizado em Tomogra?a por Imped\u00e2ncia El\u00e9trica\n\n\n\n28\n\nse deve ao algoritmo de reconstru\u00e7\u00e3o de imagens. Este algoritmo possui uma comple-\n\nxidade computacional elevada, sendo tipicamente executado por um microcomputa-\n\ndor. Uma vez que o sensor inteligente n\u00e3o ser\u00e1 respons\u00e1vel pela execu\u00e7\u00e3o do algoritmo\n\nde reconstru\u00e7\u00e3o, ele n\u00e3o necessita possuir uma grande capacidade de processamento.\n\nEntretanto, \u00e9 interessante que o dispositivo seja capaz de realizar fun\u00e7\u00f5es simples\n\nde controle, de acordo com algum algoritmo espec\u00ed?co do processo no qual o sensor\n\nest\u00e1 inserido. Estas fun\u00e7\u00f5es podem estar relacionadas, por exemplo, com a detec\u00e7\u00e3o\n\nde algumas anomalias no processo. Nesse sentido, ser\u00e1 utilizado o microcontrolador\n\nLAMPI\u00c3O, em desenvolvimento no LDN, executando um SOTR embarcado para\n\naquisi\u00e7\u00e3o de dados e comunica\u00e7\u00e3o. A arquitetura do microcontrolador LAMPI\u00c3O e\n\na especi?ca\u00e7\u00e3o do SOTR embarcado s\u00e3o apresentados no Ap\u00eandice D.\n\nFinalmente, o m\u00f3dulo MARIA ser\u00e1 respons\u00e1vel por conectar o sensor inteligente\n\n\u00e0 rede de comunica\u00e7\u00e3o. Nesse caso, ser\u00e1 utilizado um m\u00f3dulo de comunica\u00e7\u00e3o CAN.\n\nO protocolo CAN suporta e?cientemente controle distribu\u00eddo em tempo-real com ele-\n\nvado n\u00edvel de seguran\u00e7a. Por ser um protocolo robusto, vem sendo bastante utilizado\n\nem aplica\u00e7\u00f5es industriais.\n\nNa Figura 1.24 \u00e9 apresentado um exemplo de aplica\u00e7\u00e3o do sensor inteligente pro-\n\nposto num sistema de tomogra?a por imped\u00e2ncia el\u00e9trica.\n\nConsiderando a arquitetura proposta no padr\u00e3o IEEE 1451, o STIM \u00e9 representado\n\npelo sensor inteligente proposto. O NCAP \u00e9 implementado num microcomputador\n\nque executa o algoritmo de reconstru\u00e7\u00e3o de imagens a partir das medi\u00e7\u00f5es realizadas\n\npelo STIM. A interface entre o STIM e o NCAP \u00e9 realizada utilizando a redeCANopen,\n\nconforme proposto no padr\u00e3o IEEE P1451.6. Al\u00e9m disso, outros dispositivos STIM\n\npodem ser inseridos na rede de sensores, enviando ao NCAP medi\u00e7\u00f5es de outras\n\nvari\u00e1veis como temperatura e press\u00e3o, por exemplo, para corre\u00e7\u00e3o da vaz\u00e3o medida.\n\n1.4.2 Objetivo do Trabalho\n\nO objetivo deste trabalho \u00e9 a descri\u00e7\u00e3o em linguagem VHDL(VHSIC3 Hardware Des-\n\ncription Language) e a implementa\u00e7\u00e3o em FPGA (Field Programmable Gate Array)\n\nde um ampli?cador sens\u00edvel \u00e0 fase digital e de um m\u00f3dulo de comunica\u00e7\u00e3o CAN para\n\n3VHSIC: Very High Speed Implementation Circuit\n\n\n\n29\n\nFigura 1.24: Sensor inteligente aplicado a um sistema de tomogra?a por imped\u00e2ncia\nel\u00e9trica. A interface entre o STIM e o NCAP \u00e9 realizada utilizando a redeCANopen,\nconforme de?nido no padr\u00e3o IEEE 1451.6.\n\nutiliza\u00e7\u00e3o no sensor inteligente proposto.\n\nUma vez que o ampli?cador sens\u00edvel \u00e0 fase e o m\u00f3dulo de comunica\u00e7\u00e3o CAN este-\n\njam devidamente validados, eles podem ser integrados ao microcontrolador LAMPI\u00c3O,\n\nao m\u00f3dulo de acesso \u00e0 rede MARIA, \u00e0s mem\u00f3rias PROM e RAM e aos circuitos de\n\naquisi\u00e7\u00e3o de dados e gera\u00e7\u00e3o de sinal, tamb\u00e9m em desenvolvimento no LDN, numa\n\nmesma pastilha de sil\u00edcio. Neste caso, tem-se um sensor inteligente integrado.\n\n1.5 Organiza\u00e7\u00e3o do Texto\n\nEsta Disserta\u00e7\u00e3o de Mestrado est\u00e1 dividida em cinco cap\u00edtulos:\n\n\u2022 Cap\u00edtulo 1, contendo esta introdu\u00e7\u00e3o;\n\n\u2022 Cap\u00edtulo 2, no qual \u00e9 apresentada a metodologia utilizada neste trabalho;\n\n\u2022 Cap\u00edtulo 3, no qual \u00e9 discutida a teoria do ampli?cador sens\u00edvel \u00e0 fase e apre-\n\nsentados os resultados obtidos na implementa\u00e7\u00e3o deste dispositivo, utilizando,\n\nnum primeiro momento, um microcomputador com placa de aquisi\u00e7\u00e3o de dados\n\ne MATLAB e, em seguida, desenvolvendo o circuito em FPGA;\n\n\n\n30\n\n\u2022 Cap\u00edtulo 4, no qual s\u00e3o apresentados o protocolo de comunica\u00e7\u00e3o CAN, a imple-\n\nmenta\u00e7\u00e3o de uma rede CAN utilizando placas SBC28PC e microcontroladores\n\nPIC 18F258, os resultados da implementa\u00e7\u00e3o de um m\u00f3dulo CAN em FPGA e\n\nda integra\u00e7\u00e3o deste m\u00f3dulo ao ampli?cador sens\u00edvel \u00e0 fase;\n\n\u2022 Cap\u00edtulo 5, no qual s\u00e3o apresentadas as conclus\u00f5es deste trabalho e as pr\u00f3ximas\n\netapas do projeto do sensor inteligente integrado.\n\nNeste texto tamb\u00e9m foram inclu\u00eddos cinco ap\u00eandices:\n\n\u2022 Ap\u00eandice A, no qual s\u00e3o fornecidos os c\u00f3digos em linguagem VHDL dos circuitos\n\ndesenvolvidos em FPGA;\n\n\u2022 Ap\u00eandice B, no qual s\u00e3o fornecidos os c\u00f3digos nas linguagens C e MATLAB do\n\nampli?cador lock-in utilizando microcomputador e placa de aquisi\u00e7\u00e3o de dados;\n\n\u2022 Ap\u00eandice C, no qual s\u00e3o fornecidos os c\u00f3digos em linguagem ASSEMBLY dos\n\nm\u00f3dulos CAN implementados com microcontroladores PIC 18F258;\n\n\u2022 Ap\u00eandice D, no qual \u00e9 apresentada uma discuss\u00e3o te\u00f3rica sobre um Sistema\n\nOperacional de Tempo Real embarcado para gerenciamento de aquisi\u00e7\u00e3o de\n\ndados e comunica\u00e7\u00e3o com o microcontrolador LAMPI\u00c3O e m\u00f3dulo de acesso \u00e0\n\nrede MARIA;\n\n\u2022 Ap\u00eandice E, no qual s\u00e3o apresentados os artigos publicados a partir deste tra-\n\nbalho.\n\n\n\nCap\u00edtulo 2\n\nMetodologia\n\nNeste cap\u00edtulo ser\u00e1 apresentada a metodologia utilizada neste trabalho. Ser\u00e3o abor-\n\ndadas todas as etapas utilizadas no desenvolvimento do ampli?cador sens\u00edvel \u00e0 fase\n\ndigital (lock-in) e do m\u00f3dulo de comunica\u00e7\u00e3o CAN (Controller Area Network), desde\n\na implementa\u00e7\u00e3o de prot\u00f3tipos utilizando placa de aquisi\u00e7\u00e3o de dados e microcontro-\n\nladores PIC at\u00e9 a implementa\u00e7\u00e3o dos circuitos em FPGA(Field Programmable Gate\n\nArray).\n\n2.1 Ampli?cador Sens\u00edvel \u00e0 Fase\n\nA implementa\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase digital foi realizada atrav\u00e9s das\n\nseguintes etapas:\n\n\u2022 Estudo da t\u00e9cnica lock-in para medi\u00e7\u00e3o de sinais;\n\n\u2022 Implementa\u00e7\u00e3o de um prot\u00f3tipo para avalia\u00e7\u00e3o da t\u00e9cnica lock-in utilizando\n\num microcomputador com placa de aquisi\u00e7\u00e3o de dados;\n\n\u2022 Implementa\u00e7\u00e3o do circuito ?nal em FPGA.\n\n2.2 M\u00f3dulo de Comunica\u00e7\u00e3o CAN\n\nA implementa\u00e7\u00e3o do m\u00f3dulo de comunica\u00e7\u00e3o CAN foi realizada atrav\u00e9s das seguintes\n\netapas:\n\n31\n\n\n\n32\n\n\u2022 Estudo do protocolo de comunica\u00e7\u00e3o CAN;\n\n\u2022 Implementa\u00e7\u00e3o de uma rede CAN utilizando microcontroladores PIC para avali-\n\na\u00e7\u00e3o do protocolo de comunica\u00e7\u00e3o;\n\n\u2022 Implementa\u00e7\u00e3o do circuito ?nal em FPGA.\n\n2.3 Etapas de Prototipa\u00e7\u00e3o\n\nNesta se\u00e7\u00e3o ser\u00e3o apresentadas as principais etapas da implementa\u00e7\u00e3o de um ampli-\n\n?cador sens\u00edvel \u00e0 fase digital utilizando um microcomputador com placa de aquisi\u00e7\u00e3o\n\nde dados e de uma rede CAN utilizando placa de desenvolvimento comercial e micro-\n\ncontroladores PIC.\n\n2.3.1 Ampli?cador Sens\u00edvel \u00e0 Fase Digital utilizando Micro-\n\ncomputador e Placa de Aquisi\u00e7\u00e3o de Dados\n\nNo sentido de avaliar a t\u00e9cnica lock-in, foi implementado um ampli?cador sens\u00edvel \u00e0\n\nfase digital utilizando inicialmente um microcomputador e uma placa de aquisi\u00e7\u00e3o de\n\ndados. O desenvolvimento deste prot\u00f3tipo, por sua vez, foi segregado em tr\u00eas tarefas\n\nprincipais:\n\n\u2022 Gera\u00e7\u00e3o do sinal de teste (tens\u00e3o de excita\u00e7\u00e3o);\n\n\u2022 Aquisi\u00e7\u00e3o do sinal de entrada do ampli?cador (resposta \u00e0 excita\u00e7\u00e3o);\n\n\u2022 Execu\u00e7\u00e3o do algoritmo utilizado na descri\u00e7\u00e3o da t\u00e9cnica lock-in.\n\nPara gera\u00e7\u00e3o do sinal de teste (tens\u00e3o de excita\u00e7\u00e3o) e aquisi\u00e7\u00e3o do sinal de entrada\n\ndo ampli?cador (resposta \u00e0 excita\u00e7\u00e3o), foi utilizada a placa de aquisi\u00e7\u00e3o de dados\n\nDAS-20, desenvolvida pelaKeithley Instruments e ilustrada na Figura 2.1. O controle\n\nda placa \u00e9 realizado a partir de um microcomputador IBM/PC atrav\u00e9s do barramento\n\nISA e de um driver de comunica\u00e7\u00e3o, desenvolvido por Tony L. Keiser. Este driver \u00e9\n\nconstitu\u00eddo por uma biblioteca de fun\u00e7\u00f5es que implementam diversos comandos da\n\nplaca DAS-20 e s\u00e3o chamadas no c\u00f3digo de um programa de aquisi\u00e7\u00e3o de dados\n\nescrito em linguagem C utilizando o compilador Dev-C++ 4.9.8.0. Este compilador,\n\n\n\n33\n\nilustrado na Figura 2.2, foi obtido gratuitamente a partir da p\u00e1gina na Internet de\n\nseu desenvolvedor, oBloodshed Software [17].\n\nFigura 2.1: Ilustra\u00e7\u00e3o da placa de aquisi\u00e7\u00e3o de dados DAS-20.\n\nFigura 2.2: Ilustra\u00e7\u00e3o do ambiente de programa\u00e7\u00e3o em linguagem C.\n\nO programa de aquisi\u00e7\u00e3o de dados gera um arquivo de texto contendo os dados\n\nadquiridos (tens\u00f5es medidas na entrada do ampli?cador). Este arquivo, por sua vez,\n\n\u00e9 acessado por um programa implementado no MATLAB, software desenvolvido pela\n\nMathWorks e ilustrado na Figura 2.3. Este programa executa o algoritmo utilizado\n\nna descri\u00e7\u00e3o da t\u00e9cnica lock-in e exibe os resultados dos c\u00e1lculos realizados.\n\nOs materiais utilizados na implementa\u00e7\u00e3o deste prot\u00f3tipo est\u00e3o resumidos a seguir:\n\n\n\n34\n\nFigura 2.3: Ilustra\u00e7\u00e3o do ambiente MATLAB.\n\n\u2022 Microcomputador IBM/PC com barramento ISA;\n\n\u2022 Placa de Aquisi\u00e7\u00e3o de Dados DAS-20, desenvolvida pelaKeithley Instruments;\n\n\u2022 Compilador Dev-C++ 4.9.8.0, desenvolvido pela Bloodshed Software;\n\n\u2022 Biblioteca de fun\u00e7\u00f5es desenvolvida em linguagem C por Tony L. Keiser para\n\nacesso aos comandos da placa DAS-20;\n\n\u2022 Software MATLAB, desenvolvido pela MathWorks.\n\nA implementa\u00e7\u00e3o deste prot\u00f3tipo e os resultados obtidos s\u00e3o descritos detalhada-\n\nmente no Cap\u00edtulo 3.\n\n2.3.2 Rede de Comunica\u00e7\u00e3o CAN utilizando Placa de Desen-\n\nvolvimento Comercial e Microcontroladores PIC\n\nCom o objetivo de avaliar o protocolo de comunica\u00e7\u00e3o CAN, foi implementada uma\n\nrede de comunica\u00e7\u00e3o CAN utilizando dispositivos comerciais. Os materiais utilizados\n\nest\u00e3o descritos a seguir:\n\n\n\n35\n\n\u2022 Placa de desenvolvimento SBC28PC, desenvolvida pela Modtronix Engineering;\n\n\u2022 Microcontrolador PIC 18F258, desenvolvido pela Microchip;\n\n\u2022 Transceptor CAN MCP2551, desenvolvido pela Microchip;\n\n\u2022 Programador e Depurador ICD3, desenvolvido pela Microchip;\n\n\u2022 Software MPLAB 8.36, desenvolvido pela Microchip;\n\n\u2022 Microcomputador IBM/PC com porta serial;\n\n\u2022 Software Terminal v.19b;\n\n\u2022 Oscilosc\u00f3pio.\n\nA SBC28PC, ilustrada na Figura 2.4, \u00e9 uma placa comercial de baixo custo, desen-\n\nvolvida para microcontroladores PIC de 28 pinos, disponibilizando tanto uma porta\n\nde comunica\u00e7\u00e3o serial RS-232 quanto uma interface CAN.\n\nFigura 2.4: Ilustra\u00e7\u00e3o da placa de desenvolvimento SBC28PC.\n\nO microcontrolador PIC 18F258 possui uma UART e um m\u00f3dulo de comunica\u00e7\u00e3o\n\nCAN integrados. O m\u00f3dulo transceptor CAN MCP2551 \u00e9 respons\u00e1vel pela convers\u00e3o\n\ndos sinais de 0V e 5V do microcontrolador para os n\u00edveis de tens\u00e3o padronizados pelo\n\nprotocolo CAN.\n\nPara programa\u00e7\u00e3o dos microcontroladores PIC foi utilizada a ferramenta de pro-\n\njeto MPLAB 8.36, desenvolvida pela Microchip e ilustrada na Figura 2.5. Para\n\n\n\n36\n\nFigura 2.5: Ilustra\u00e7\u00e3o da ferramenta de projeto MPLAB.\n\nFigura 2.6: Ilustra\u00e7\u00e3o do programador e depurador ICD3.\n\ngrava\u00e7\u00e3o e depura\u00e7\u00e3o do programa foi utilizado o programador e depurador ICD3,\n\ntamb\u00e9m daMicrochip e ilustrado na Figura 2.6.\n\nNeste trabalho foi constru\u00edda uma rede CAN contendo dois n\u00f3s, implementa-\n\ndos com a placa SBC28PC, o microcontrolador PIC 18F258 e o transceptor CAN\n\nMCP2551. Um desses n\u00f3s, al\u00e9m de enviar e receber mensagens na rede CAN, envia\n\nas mensagens trafegadas no barramento CAN para o microcomputador atrav\u00e9s da\n\nporta serial. As mensagens trafegadas na rede CAN s\u00e3o ent\u00e3o exibidas na tela do\n\nmicrocomputador, a partir de um programa terminal, ilustrado na Figura 2.7. Este\n\nprograma foi obtido gratuitamente a partir da p\u00e1gina na Internet de seu desenvolvedor\n\n[18].\n\nFinalmente, para uma avalia\u00e7\u00e3o mais detalhada do protocolo CAN, cada campo\n\nda mensagem trafegada \u00e9 analisado com aux\u00edlio do oscilosc\u00f3pio.\n\n\n\n37\n\nFigura 2.7: Ilustra\u00e7\u00e3o do programa Terminal.\n\nA implementa\u00e7\u00e3o desta rede CAN e os resultados obtidos s\u00e3o descritos detalhada-\n\nmente no Cap\u00edtulo 4.\n\n2.4 Etapas de Implementa\u00e7\u00e3o em FPGA\n\nAp\u00f3s entender e avaliar a t\u00e9cnica lock-in e o protocolo CAN atrav\u00e9s dos prot\u00f3tipos\n\ndesenvolvidos, foi realizada a implementa\u00e7\u00e3o em FPGA de um ampli?cador sens\u00edvel\n\n\u00e0 fase digital e de um m\u00f3dulo de comunica\u00e7\u00e3o CAN. Estes dois dispositivos foram de-\n\nsenvolvidos e testados individualmente. Em seguida, os dois blocos foram integrados\n\nna mesma FPGA.\n\nNa pr\u00f3xima se\u00e7\u00e3o ser\u00e1 revisado, de forma simpli?cada, o ?uxo gen\u00e9rico de projeto\n\nde circuitos integrados, desde a especi?ca\u00e7\u00e3o do circuito at\u00e9 a fabrica\u00e7\u00e3o do chip. Em\n\nseguida, ser\u00e3o discutidas as principais caracter\u00edsticas de uma FPGA e da descri\u00e7\u00e3o\n\nde circuitos digitais em linguagem VHDL(VHSIC1 Hardware Description Language).\n\nFinalmente, ser\u00e1 apresentado o ?uxo de projeto de circuitos digitais em FPGA des-\n\ncritos na linguagem VHDL, utilizado na implementa\u00e7\u00e3o ?nal do ampli?cador sens\u00edvel\n\n\u00e0 fase e do m\u00f3dulo de comunica\u00e7\u00e3o CAN.\n\n1VHSIC: Very High Speed Implementation Circuit\n\n\n\n38\n\n2.5 Projeto de Circuitos Integrados\n\nO projeto de circuitos integrados envolve uma s\u00e9rie de etapas que v\u00e3o desde a es-\n\npeci?ca\u00e7\u00e3o do sistema at\u00e9 a fabrica\u00e7\u00e3o e a caracteriza\u00e7\u00e3o do chip. Essas etapas s\u00e3o\n\napresentadas, de maneira geral e simpli?cada, no ?uxograma da Figura 2.8.\n\nFigura 2.8: Etapas de projeto de circuitos integrados.\n\nA primeira etapa \u00e9 a especi?ca\u00e7\u00e3o do circuito. Nessa etapa s\u00e3o de?nidas as fun\u00e7\u00f5es\n\ndo circuito, suas entradas e sa\u00eddas, sua topologia, a tecnologia a ser utilizada, entre\n\noutras caracter\u00edsticas.\n\nUma vez de?nidos os requisitos do sistema, o circuito \u00e9 desenvolvido de acordo\n\ncom a topologia escolhida utilizando-se, por exemplo, captura esquem\u00e1tica ou uma\n\nlinguagem de descri\u00e7\u00e3o de hardware. Em seguida, o circuito \u00e9 simulado com o objetivo\n\nde veri?car se a sua funcionalidade est\u00e1 adequada, isto \u00e9, se o seu comportamento\n\nest\u00e1 de acordo com o esperado. Nessa etapa, entretanto, ainda n\u00e3o s\u00e3o considerados\n\nos elementos parasitas (resist\u00eancias, capacit\u00e2ncias, indut\u00e2ncias, etc.) presentes no\n\ncircuito.\n\nCaso os resultados obtidos na simula\u00e7\u00e3o comportamental estejam de acordo com\n\no especi?cado, inicia-se o desenvolvimento do leiaute. Caso contr\u00e1rio, refaz-se o es-\n\nquem\u00e1tico ou a descri\u00e7\u00e3o do hardware, corrigindo-se os eventuais erros. Nesse ponto\n\npodem ser necess\u00e1rias ainda algumas modi?ca\u00e7\u00f5es na especi?ca\u00e7\u00e3o do circuito.\n\nNa etapa de desenvolvimento do leiaute, o circuito \u00e9 implementado ao n\u00edvel de\n\ntransistores, respeitando-se as regras de projeto de?nidas na tecnologia escolhida.\n\n\n\n39\n\nAp\u00f3s a confec\u00e7\u00e3o do leiaute, o circuito \u00e9 novamente simulado, extraindo-se as re-\n\nsist\u00eancias e capacit\u00e2ncias parasitas e os modelos dos dispositivos utilizados.\n\nDepois de avaliado o desempenho do circuito, a partir da simula\u00e7\u00e3o do leiaute,\n\nalgumas modi?ca\u00e7\u00f5es ainda podem ser necess\u00e1rias no leiaute, no esquem\u00e1tico ou at\u00e9\n\nmesmo na especi?ca\u00e7\u00e3o. Quando os resultados obtidos via simula\u00e7\u00e3o forem satis-\n\nfat\u00f3rios, o circuito integrado \u00e9 enviado para a fabrica\u00e7\u00e3o. Nessa etapa s\u00e3o confec-\n\ncionadas as m\u00e1scaras, as quais s\u00e3o utilizadas durante o processamento do sil\u00edcio para,\n\nem seguida, formar-se o chip.\n\nFinalmente, o chip \u00e9 testado e encapsulado, passando ainda pelos processos de\n\ncontrole de qualidade. Se durante a caracteriza\u00e7\u00e3o do dispositivo for veri?cado algum\n\nproblema em seu funcionamento, a etapa de fabrica\u00e7\u00e3o e, eventualmente, as etapas\n\nanteriores, devem ser revistas.\n\nO projeto de circuitos integrados pode ser segmentado de acordo com os tipos\n\nde sinais a serem manipulados pelo circuito em desenvolvimento. Uma forma de\n\nsegmenta\u00e7\u00e3o \u00e9 proposta pelo autor deste trabalho na Figura 2.9.\n\nFigura 2.9: Segmenta\u00e7\u00e3o proposta da \u00e1rea de projeto de circuitos integrados.\n\n\n\n40\n\nEm linhas gerais, a metodologia de projeto de circuitos integrados segue o mesmo\n\n?uxo de desenvolvimento discutido anteriormente, independente do segmento. En-\n\ntretanto, cada segmento de projeto apresenta suas particularidades na forma de de-\n\nsenvolvimento, ferramentas de projeto, simula\u00e7\u00e3o e modelagem, constru\u00e7\u00e3o f\u00edsica,\n\ncaracteriza\u00e7\u00e3o e testes, etc. Estas particularidades s\u00e3o discutidas a seguir:\n\n\u2022 Projeto de circuitos integrados anal\u00f3gicos: engloba tipicamente o projeto em\n\nbaixas frequ\u00eancias de circuitos como ampli?cadores operacionais, refer\u00eancias\n\nde tens\u00e3o, espelhos de corrente, etc. O projeto \u00e9 realizado a n\u00edvel f\u00edsico, isto\n\n\u00e9, a n\u00edvel de transistores. Utiliza geralmente ferramentas de projeto baseadas\n\nem captura esquem\u00e1tica. O leiaute do circuito \u00e9 realizado manualmente. As\n\nferramentas de simula\u00e7\u00e3o s\u00e3o baseadas em modelos SPICE. Em geral, s\u00e3o im-\n\nplementados em circuitos integrados para aplica\u00e7\u00f5es espec\u00ed?cas, denominados\n\nASIC (Application Speci?ed Integrated Circuits);\n\n\u2022 Projeto de circuitos integrados digitais: engloba o projeto de circuitos baseados\n\nem microprocessadores, DSPs (Digital Signal Processors), FPGAs (Field Pro-\n\ngrammable Gate Arrays), etc. O projeto \u00e9 realizado a n\u00edvel l\u00f3gico, utilizando\n\ncaptura esquem\u00e1tica ou linguagem de descri\u00e7\u00e3o de hardware. O leiaute do cir-\n\ncuito \u00e9 gerado automaticamente pela ferramenta de s\u00edntese e implementa\u00e7\u00e3o.\n\nAs ferramentas de simula\u00e7\u00e3o se baseiam em modelos temporais dos dispositivos\n\nl\u00f3gicos, levando em conta apenas os parasitas das interconex\u00f5es, reduzindo o\n\ntempo de simula\u00e7\u00e3o.\n\n\u2022 Projeto de circuitos integrados de sinal misto: engloba o projeto de circuitos\n\nanal\u00f3gicos e digitais no mesmo chip, utilizando conversores AD e DA. Utiliza\n\nferramentas de modelagem baseadas em linguagens de descri\u00e7\u00e3o de circuitos\n\nanal\u00f3gicos e de sinal misto, de forma a reduzir o tempo de simula\u00e7\u00e3o. Entre-\n\ntanto, o leiaute do circuito anal\u00f3gico continua sendo feito manualmente;\n\n\u2022 Projeto de circuitos integrados de RF: engloba tipicamente o projeto de circuitos\n\nde transmiss\u00e3o e recep\u00e7\u00e3o em r\u00e1dio-frequ\u00eancia, moduladores, demoduladores,\n\nampli?cadores de RF, ampli?cadores de pot\u00eancia, etc. Utiliza metodologia de\n\nprojeto semelhante aos circuitos anal\u00f3gicos. Entretanto, utiliza ferramentas de\n\n\n\n41\n\nsimula\u00e7\u00e3o mais poderosas, capazes de realizar simula\u00e7\u00f5es de campos eletromag-\n\nn\u00e9ticos e de sinais em altas frequ\u00eancias, englobando modelos mais re?nados de\n\nparasitas.\n\nNa implementa\u00e7\u00e3o ?nal do ampli?cador sens\u00edvel \u00e0 fase e do m\u00f3dulo de comuni-\n\nca\u00e7\u00e3o CAN foi utilizada a metodologia de projeto de circuitos digitais em FPGA.\n\nEsta metodologia \u00e9 discutida em mais detalhes nas pr\u00f3ximas se\u00e7\u00f5es.\n\n2.6 FPGA - Field Programmable Gate Array\n\nA FPGA \u00e9 uma matriz de portas program\u00e1vel em campo. Trata-se de um m\u00f3dulo\n\nprogram\u00e1vel capaz de implementar sistemas digitais complexos, sendo utilizado tanto\n\nna prototipa\u00e7\u00e3o de sistemas digitais que ser\u00e3o implementados em ASIC quanto como\n\ndispositivo ?nal. Na Figura 2.10 s\u00e3o apresentadas FPGAs dos principais fabricantes:\n\nActel, Altera e Xilinx.\n\nFigura 2.10: FPGAs dos principais fabricantes: Actel, Altera e Xilinx.\n\nNeste trabalho foi utilizada uma FPGA Xilinx XC3S500E -5 FG320. A arquite-\n\ntura b\u00e1sica de uma FPGA Xilinx [19, 20] \u00e9 apresentada na Figura 2.11.\n\nA fam\u00edlia Spartan-3E da Xilinx possui 5 elementos fundamentais [20]:\n\n\u2022 Blocos l\u00f3gicos con?gur\u00e1veis (CLB - Con?gurable Logic Blocks);\n\n\u2022 Blocos de entrada e sa\u00edda (IOB - Input/Output Blocks);\n\n\u2022 Blocos de mem\u00f3ria RAM;\n\n\u2022 Blocos multiplicadores dedicados;\n\n\u2022 Blocos de gerenciamento de rel\u00f3gio digital (DCM - Digital Clock Manager).\n\n\n\n42\n\nFigura 2.11: Arquitetura b\u00e1sica de uma FPGAXilinx.\n\nOs CLBs cont\u00eam tabelas de pesquisa (Look up Tables - LUTs) para implementar e-\n\nlementos l\u00f3gicos e de armazenamento (portas l\u00f3gicas, ?ip-?ops e latches). Constituem\n\nos principais recursos l\u00f3gicos para a implementa\u00e7\u00e3o de circuitos combinacionais e\n\nsequenciais.\n\nCada CLB \u00e9 composto por quatro slices interconectados. Os slices s\u00e3o agrupados\n\nem pares. Cada par \u00e9 organizado como uma coluna com um canal de carry indepen-\n\ndente. Um slice possui os seguintes elementos: geradores de fun\u00e7\u00e3o l\u00f3gica, elementos\n\nde armazenamento, multiplexadores, l\u00f3gica de carry e portas aritm\u00e9ticas. O arranjo\n\nde slices num CLB e o diagrama simpli?cado de um slice de uma FPGA Xilinx\n\nSpartan II [21] s\u00e3o apresentados nas Figuras 2.12 e 2.13.\n\nCada slice numa FPGA Xilinx Spartan II cont\u00e9m duas c\u00e9lulas l\u00f3gicas (LC - Logic\n\nCells). Por sua vez, cada LC possui os seguintes componentes:\n\n\u2022 Um gerador de fun\u00e7\u00f5es de quatro entradas, implementado como uma LUT (Look\n\nUp Table);\n\n\u2022 Uma l\u00f3gica de controle e carry(Carry and Control Logic);\n\n\u2022 Um elemento de armazenamento.\n\nAl\u00e9m dos sinais de Clock e Clock Enable, cada slice possui sinais de set e reset\n\ns\u00edncronos (SR e BY). Alternativamente, estes sinais podem ser con?gurados para\n\noperar de maneira ass\u00edncrona.\n\n\n\n43\n\nFigura 2.12: Arranjo de slices num CLB.\n\nFigura 2.13: Arquitetura de um slice numa FPGA Xilinx Spartan II.\n\n\n\n44\n\nCada slice possui ainda um multiplexador, denominado F5 (n\u00e3o apresentado na\n\nFigura 2.13). Este multiplexador combina as sa\u00eddas do gerador de fun\u00e7\u00f5es. Esta\n\ncombina\u00e7\u00e3o pode ser utilizada para implementar qualquer fun\u00e7\u00e3o de 5 entradas, um\n\nmultiplexador 4:1 ou fun\u00e7\u00f5es selecionadas de at\u00e9 9 entradas.\n\nSimilarmente, outro multiplexador, denominado F6, combina as sa\u00eddas de todos\n\nos quatro geradores de fun\u00e7\u00e3o num CLB, selecionando uma das sa\u00eddas dos multi-\n\nplexadores F5. Isto permite a implementa\u00e7\u00e3o de qualquer fun\u00e7\u00e3o de 6 entradas, um\n\nmultiplexador 8:1 ou fun\u00e7\u00f5es selecionadas de at\u00e9 19 entradas.\n\nOs IOBs controlam o ?uxo de dados entre os pinos de entrada e sa\u00edda e a l\u00f3gica\n\ninterna do dispositivo. Cada IOB suporta ?uxo de dados bidirecional e opera\u00e7\u00e3o\n\n3-estados.\n\nOs blocos de mem\u00f3ria RAM permitem o armazenamento de dados na forma de\n\nblocos duais de 18-kbit. Os blocos multiplicadores calculam o produto de dois n\u00fameros\n\nbin\u00e1rios de 18 bits. Finalmente, os blocos de gerenciamento de rel\u00f3gio digital s\u00e3o\n\nutilizados na calibra\u00e7\u00e3o de sinais de rel\u00f3gio.\n\nNormalmente a FPGA \u00e9 con?gurada a partir de um ambiente de desenvolvimento,\n\nutilizando uma linguagem de descri\u00e7\u00e3o de hardware (HDL - Hardware Description\n\nLanguage). Neste trabalho foi escolhida a linguagem VHDL.\n\n2.7 VHDL - VHSIC Hardware Description Lan-\n\nguage\n\nVHDL (VHSIC Hardware Description Language) \u00e9 uma linguagem de descri\u00e7\u00e3o de\n\nhardware utilizada na simula\u00e7\u00e3o e na s\u00edntese de circuitos digitais, possibilitando o\n\ninterc\u00e2mbio de informa\u00e7\u00f5es entre fabricantes, fornecedores de sistemas e empresas de\n\nprojetos. Surgiu a partir da necessidade de uma ferramenta de projeto e documen-\n\nta\u00e7\u00e3o padr\u00e3o para o projeto VHSIC (Very High Speed Integrated Circuit) da DARPA\n\n(Defense Advanced Research Projects Agency) [22].\n\nVHDL suporta projetos com m\u00faltiplos n\u00edveis de hierarquia, tornando mais f\u00e1cil\n\no desenvolvimento de projetos mais complexos utilizando a metodologia top-down.\n\nTamb\u00e9m suporta diversos n\u00edveis de abstra\u00e7\u00e3o. Al\u00e9m disso, VHDL permite a de?ni\u00e7\u00e3o\n\n\n\n45\n\nde subprogramas, fun\u00e7\u00f5es, bibliotecas, pacotes, novos tipos de dados, etc. [22].\n\nDiferentemente da maioria das linguagens de programa\u00e7\u00e3o, os comandos em VHDL\n\ns\u00e3o executados concorrentemente, exceto em regi\u00f5es espec\u00ed?cas do c\u00f3digo. Essa \u00e9\n\numa das caracter\u00edsticas mais importantes da linguagem, uma vez que os elementos\n\ndos sistemas digitais trabalham em paralelo, realizando suas fun\u00e7\u00f5es conjuntamente.\n\nVale salientar que a linguagem VHDL n\u00e3o foi concebida inicialmente para s\u00edntese\n\nde circuitos. O objetivo inicial era a modelagem de circuitos digitais e a documen-\n\nta\u00e7\u00e3o de projetos. Consequentemente, nem todas as constru\u00e7\u00f5es da linguagem s\u00e3o\n\nsuportadas por uma ferramenta de s\u00edntese, respons\u00e1vel por compilar o c\u00f3digo VHDL\n\ne gerar o circuito digital [22].\n\nPor exemplo, um registrador com dois sinais de rel\u00f3gio pode ser facilmente mo-\n\ndelado e seu comportamento simulado em VHDL. Entretanto, esse circuito n\u00e3o pode\n\nser sintetizado, devido \u00e0 inexist\u00eancia de um dispositivo f\u00edsico desse tipo.\n\nOutro exemplo simples \u00e9 a impossibilidade da s\u00edntese direta de um multiplicador de\n\ndois n\u00fameros reais, embora um dispositivo desse tipo possa ser modelado e simulado\n\nfacilmente utilizando VHDL.\n\nA descri\u00e7\u00e3o de um circuito em VHDL pode ser realizada seguindo tr\u00eas estilos:\n\ncomportamental, RTL (Register Transfer Level) e estrutural.\n\nNa descri\u00e7\u00e3o comportamental, o circuito \u00e9 modelado a partir das especi?ca\u00e7\u00f5es do\n\ncomportamento do sistema, atingindo um maior n\u00edvel de abstra\u00e7\u00e3o. Uma descri\u00e7\u00e3o\n\nneste n\u00edvel de abstra\u00e7\u00e3o \u00e9 geralmente mais r\u00e1pida de ser desenvolvida, podendo ser\n\nutilizada para modelagem e simula\u00e7\u00f5es de sistemas digitais. Entretanto, em geral,\n\num circuito digital descrito de forma comportamental leva \u00e0 um maior n\u00famero de\n\nrecursos l\u00f3gicos utilizados (e, consequentemente, uma maior \u00e1rea no chip) e a um\n\nmenor desempenho (caracterizado por uma menor frequ\u00eancia de opera\u00e7\u00e3o m\u00e1xima).\n\nAl\u00e9m disso, nem sempre um circuito digital descrito de forma comportamental poder\u00e1\n\nser sintetizado.\n\nJ\u00e1 na descri\u00e7\u00e3o RTL, o circuito \u00e9 descrito de maneira a separar o ?uxo de da-\n\ndos (registradores, somadores, contadores, etc.) do ?uxo de controle (m\u00e1quina de\n\nestados). Consequentemente, a descri\u00e7\u00e3o RTL apresenta um n\u00edvel de descri\u00e7\u00e3o mais\n\npr\u00f3ximo do circuito implementado. Apesar de apresentar um tempo de desenvolvi-\n\nmento maior que na descri\u00e7\u00e3o comportamental, este n\u00edvel de abstra\u00e7\u00e3o \u00e9 mais f\u00e1cil\n\n\n\n46\n\nde ser sintetizado pela ferramenta de s\u00edntese, apresentando melhores resultados na\n\nimplementa\u00e7\u00e3o (menor utiliza\u00e7\u00e3o de recursos l\u00f3gicos e maior frequ\u00eancia de opera\u00e7\u00e3o\n\nm\u00e1xima).\n\nFinalmente, na descri\u00e7\u00e3o estrutural, o sistema \u00e9 composto pela interconex\u00e3o de\n\noutros circuitos que executam fun\u00e7\u00f5es mais b\u00e1sicas (por exemplo, portas l\u00f3gicas, mul-\n\ntiplexadores, somadores e registradores). Estes circuitos (componentes) interligados\n\nformam a estrutura do sistema global. Este estilo, portanto, possui um menor n\u00edvel\n\nde abstra\u00e7\u00e3o. Um comparativo entre os estilos de descri\u00e7\u00e3o dehardware s\u00e3o ilustrados\n\nna Tabela 2.1.\n\nTabela 2.1: Comparativo entre os estilos de descri\u00e7\u00e3o dehardware.\nDom\u00ednio Descreve N\u00edvel\n\nComportamental Funcionalidade Algoritmo\nRTL Fluxo de Dados e Unidades Funcionais e\n\nFluxo de Controle M\u00e1quina de Estados\nEstrutural Arquitetura Interconex\u00e3o entre os m\u00f3dulos\n\n2.8 Fluxo de Projeto de Circuitos Digitais em FPGA\n\nutilizando VHDL\n\nConforme mencionado nas se\u00e7\u00f5es anteriores, a implementa\u00e7\u00e3o ?nal do ampli?cador\n\nsens\u00edvel \u00e0 fase e do m\u00f3dulo de comunica\u00e7\u00e3o CAN foi realizada de acordo com o ?uxo\n\nde projeto de circuitos digitais em FPGA utilizando VHDL, que ser\u00e1 descrito a seguir.\n\nO processo de s\u00edntese de circuitos digitais em VHDL pode ser dividido em sete\n\netapas, conforme ilustrado na Figura 2.14. Cada etapa \u00e9 discutida a seguir, atrav\u00e9s\n\nda implementa\u00e7\u00e3o de uma porta l\u00f3gica b\u00e1sica: a porta NAND (n\u00e3o-e).\n\n2.8.1 Especi?ca\u00e7\u00e3o\n\nNessa etapa \u00e9 realizada a formula\u00e7\u00e3o do problema, ou seja, a especi?ca\u00e7\u00e3o do projeto\n\na ser desenvolvido. Nesse sentido, a fun\u00e7\u00e3o do sistema, suas entradas e sa\u00eddas s\u00e3o\n\nde?nidas.\n\n\n\n47\n\nFigura 2.14: Etapas gerais de um processo de s\u00edntese em FPGA utilizando VHDL.\n\n\u2022 De?ni\u00e7\u00e3o do projeto: descrever em VHDL uma porta NAND;\n\n\u2022 Entradas: X e Y;\n\n\u2022 Sa\u00edda: Z\n\n\u2022 Fun\u00e7\u00e3o l\u00f3gica: Z = XnandY ;\n\n2.8.2 Descri\u00e7\u00e3o\n\nNessa etapa, o projetista descreve o funcionamento do circuito, de acordo com a\n\nsua especi?ca\u00e7\u00e3o. A descri\u00e7\u00e3o \u00e9 composta por uma entidade de projeto (ou por um\n\n\n\n48\n\nconjunto de entidades interligadas na forma de componentes) que pode representar\n\ndesde uma simples porta l\u00f3gica at\u00e9 um sistema digital completo.\n\nA entidade de projeto \u00e9 constitu\u00edda por uma declara\u00e7\u00e3o da entidade e por uma\n\narquitetura, conforme ilustrado na Figura 2.15. A declara\u00e7\u00e3o da entidade de?ne as\n\nportas de entrada e sa\u00edda, enquanto a arquitetura descreve como o circuito funciona\n\n(rela\u00e7\u00f5es entre as portas).\n\nFigura 2.15: Descri\u00e7\u00e3o VHDL da porta NAND: entidade e arquitetura.\n\n2.8.3 Simula\u00e7\u00e3o\n\nAp\u00f3s a descri\u00e7\u00e3o do circuito e a compila\u00e7\u00e3o do c\u00f3digo \u00e9 realizada a simula\u00e7\u00e3o compor-\n\ntamental. Nessa etapa, est\u00edmulos de teste s\u00e3o gerados e o comportamento do circuito\n\n\u00e9 veri?cado. Se os resultados da simula\u00e7\u00e3o forem satisfat\u00f3rios o circuito est\u00e1 pronto\n\npara ser sintetizado. Caso contr\u00e1rio, a descri\u00e7\u00e3o deve ser revista.\n\nNa Figura 2.16 \u00e9 apresentada as formas de onda obtidas na simula\u00e7\u00e3o da descri\u00e7\u00e3o\n\nVHDL de uma porta NAND.\n\n2.8.4 S\u00edntese\n\nNessa etapa s\u00e3o executadas a infer\u00eancia e a interliga\u00e7\u00e3o das estruturas necess\u00e1rias\n\n\u00e0 gera\u00e7\u00e3o do circuito descrito. No processo de s\u00edntese dois fatores s\u00e3o levados em\n\n\n\n49\n\nFigura 2.16: Resultados da simula\u00e7\u00e3o comportamental da porta NAND.\n\nconsidera\u00e7\u00e3o: as primitivas dispon\u00edveis na ferramenta de s\u00edntese e os recursos presentes\n\nna FPGA escolhida.\n\nInicialmente, a ferramenta de s\u00edntese gera um circuito no n\u00edvel RTL utilizando\n\ndispositivos b\u00e1sicos dispon\u00edveis na ferramenta, como portas l\u00f3gicas e registradores.\n\nEm seguida, um novo circuito \u00e9 criado contendo apenas dispositivos dispon\u00edveis na\n\nFPGA escolhida.\n\nO resultado da s\u00edntese da porta NAND \u00e9 ilustrado na Figura 2.17.\n\nFigura 2.17: Circuito sintetizado a partir da descri\u00e7\u00e3o VHDL da porta NAND.\n\n2.8.5 Rede de Liga\u00e7\u00f5es, Posicionamento, Interliga\u00e7\u00e3o e Cons-\n\ntru\u00e7\u00e3o\n\nAp\u00f3s a etapa de s\u00edntese, \u00e9 de?nida a rede de liga\u00e7\u00f5es a ser implementada. Nesse\n\nmomento, s\u00e3o assinalados os pinos da FPGA a serem utilizados. Em seguida, a\n\nferramenta de s\u00edntese posiciona e interliga os componentes do circuito. Finalmente, o\n\ncircuito \u00e9 implementado, a partir da grava\u00e7\u00e3o dos arquivos de con?gura\u00e7\u00e3o da FPGA.\n\nNas Figuras 2.18 e 2.19 s\u00e3o ilustradas algumas janelas da ferramenta de posiciona-\n\nmento e interliga\u00e7\u00e3o, nas quais os pinos da FPGA s\u00e3o assinalados, os componentes\n\n\n\n50\n\nposicionados e interligados.\n\nFigura 2.18: Ilustra\u00e7\u00e3o da janela utilizada na assinala\u00e7\u00e3o dos pinos de E/S da porta\nNAND na FPGA.\n\nFigura 2.19: Ilustra\u00e7\u00e3o da janela utilizada para posicionamento e interliga\u00e7\u00e3o dos\ncomponentes na FPGA.\n\nAp\u00f3s todas essas etapas, um arquivo de con?gura\u00e7\u00e3o da FPGA \u00e9 gerado e, poste-\n\nriormente, gravado na FPGA ou numa mem\u00f3ria PROM externa, conforme ilustrado\n\nnas Figuras 2.20 e 2.21.\n\n2.8.6 Materiais e M\u00e9todos\n\nUm resumo do ?uxo de projeto utilizado na implementa\u00e7\u00e3o ?nal em FPGA do am-\n\npli?cador sens\u00edvel \u00e0 fase e do m\u00f3dulo CAN \u00e9 apresentado nas Figuras 2.22 e 2.23.\n\n\n\n51\n\nFigura 2.20: Ilustra\u00e7\u00e3o da janela para gera\u00e7\u00e3o do arquivo de con?gura\u00e7\u00e3o da FPGA.\n\nFigura 2.21: Ilustra\u00e7\u00e3o da janela para grava\u00e7\u00e3o do arquivo de con?gura\u00e7\u00e3o da FPGA\nnuma mem\u00f3ria PROM externa.\n\n\n\n52\n\nFigura 2.22: Fluxo de projeto utilizado.\n\nFigura 2.23: Fluxo de projeto utilizado (continua\u00e7\u00e3o).\n\n\n\n53\n\nNa descri\u00e7\u00e3o e s\u00edntese dos circuitos digitais desenvolvidos foi utilizado o conjunto\n\nde ferramentas de projeto Xilinx ISE 11, ilustrado na Figura 2.24. Para simula\u00e7\u00e3o\n\ndos circuitos foi utilizada a ferramenta ModelSim XE III 6.4 (Figura 2.25). Final-\n\nmente, para implementa\u00e7\u00e3o f\u00edsica e teste do circuito foi utilizada a plataforma de\n\ndesenvolvimento Spartan 3E Starter Kit, do fabricante Digilent (Figura 2.26).\n\nFigura 2.24: Ilustra\u00e7\u00e3o do ambiente de projeto Xilinx ISE 11.\n\nFigura 2.25: Ilustra\u00e7\u00e3o da ferramenta de simula\u00e7\u00e3o ModelSim XE III 6.4.\n\n\n\n54\n\nFigura 2.26: Ilustra\u00e7\u00e3o da plataforma de desenvolvimento Spartan 3E.\n\n2.9 Considera\u00e7\u00f5es Finais\n\nNeste cap\u00edtulo foi apresentada a metodologia utilizada neste trabalho, sendo abor-\n\ndadas todas as etapas utilizadas no desenvolvimento do ampli?cador sens\u00edvel \u00e0 fase\n\ndigital (lock-in) e do m\u00f3dulo de comunica\u00e7\u00e3o CAN (Controller Area Network).\n\nForam apresentados os materiais e m\u00e9todos utilizados na implementa\u00e7\u00e3o de um\n\nampli?cador sens\u00edvel \u00e0 fase utilizando microcomputador com a placa de aquisi\u00e7\u00e3o de\n\ndados DAS-20 e de uma rede CAN utilizando os m\u00f3dulos SBC28PC e microcontro-\n\nladores PIC 18F258, dispon\u00edveis comercialmente.\n\nFinalmente, foi discutida a metologia de projeto de circuitos integrados digitais\n\ndescritos em VHDL e implementados em FPGA. Os materiais e m\u00e9todos utilizados\n\nno desenvolvimento em VHDL/FPGA de um ampli?cador sens\u00edvel \u00e0 fase e de um\n\nm\u00f3dulo CAN foram apresentados. O ?uxo de projeto ilustrado tamb\u00e9m pode ser\n\nutilizado na implementa\u00e7\u00e3o de outros trabalhos.\n\n\n\nCap\u00edtulo 3\n\nAmpli?cador Sens\u00edvel \u00e0 Fase\n\nNeste cap\u00edtulo ser\u00e1 realizada uma discuss\u00e3o te\u00f3rica da t\u00e9cnica lock-in, abordando o\n\nprinc\u00edpio de funcionamento do ampli?cador sens\u00edvel \u00e0 fase1. Em seguida, ser\u00e1 apresen-\n\ntada a implementa\u00e7\u00e3o de um ampli?cadorlock-in digital utilizando microcomputador\n\ncom placa de aquisi\u00e7\u00e3o de dados e MATLAB. Finalmente, ser\u00e1 discutida a descri\u00e7\u00e3o\n\nem VHDL e o desenvolvimento em FPGA deste dispositivo.\n\n3.1 Discuss\u00e3o Te\u00f3rica\n\nO ampli?cador sens\u00edvel \u00e0 fase \u00e9 um dispositivo utilizado na medi\u00e7\u00e3o de sinais el\u00e9tricos\n\nque est\u00e3o efetivamente abaixo do n\u00edvel de ru\u00eddo. O conceito utilizado \u00e9 o de estreitar\n\na banda de frequ\u00eancia, de forma que o sinal se sobressaia ao ru\u00eddo [23].\n\nO sinal de sa\u00edda do ampli?cador sens\u00edvel \u00e0 fase \u00e9 um sinal CC proporcional a um\n\nsinal CA sob investiga\u00e7\u00e3o que, por sua vez, possui informa\u00e7\u00f5es sobre determinadas\n\npropriedades el\u00e9tricas (resist\u00eancia, capacit\u00e2ncia, etc.) de um dispositivo sob teste.\n\nO princ\u00edpio fundamental de funcionamento de um ampli?cador sens\u00edvel \u00e0 fase\n\nse baseia na t\u00e9cnica da detec\u00e7\u00e3o de fase, que reti?ca apenas o sinal de interesse,\n\nsuprimindo os efeitos indesejados devidos ao ru\u00eddo. Um sinal senoidal com ampli-\n\ntude, frequ\u00eancia e fase ajust\u00e1veis \u00e9 aplicado a um dispositivo sob teste. A resposta\n\n\u00e0 excita\u00e7\u00e3o \u00e9 ent\u00e3o capturada e demodulada internamente pelo sinal de refer\u00eancia.\n\nEm seguida, um ?ltro passa-baixa separa a componente cont\u00ednua proporcional \u00e0 pro-\n\npriedade el\u00e9trica desejada.\n\n1Tamb\u00e9m conhecido como ampli?cador travado em fase ou ampli?cadorlock-in.\n\n55\n\n\n\n56\n\nA seguir ser\u00e3o discutidos os blocos que comp\u00f5em um ampli?cador sens\u00edvel \u00e0 fase\n\ne a formula\u00e7\u00e3o matem\u00e1tica que torna poss\u00edvel a sua implementa\u00e7\u00e3o digital.\n\nNa Figura 3.1 \u00e9 apresentado o diagrama em blocos de um ampli?cador sens\u00edvel \u00e0\n\nfase.\n\nFigura 3.1: Diagrama em blocos de um ampli?cador sens\u00edvel \u00e0 fase.\n\nAs medi\u00e7\u00f5es utilizando um ampli?cador sens\u00edvel \u00e0 fase s\u00e3o realizadas numa fre-\n\nqu\u00eancia ?xa. Um sinal de frequ\u00eancia conhecida \u00e9 aplicado a um dispositivo sob teste\n\ne a resposta \u00e0 excita\u00e7\u00e3o \u00e9 capturada. Um sinal de refer\u00eancia, de mesma frequ\u00eancia, \u00e9\n\ngerado internamente pelo ampli?cador e utilizado para demodular o sinal de entrada.\n\nO sinal de entrada \u00e9 multiplicado pelas componentes em fase e em quadratura\n\ndo sinal de refer\u00eancia. Na sa\u00edda de cada detector \u00e9 obtido um sinal composto por\n\num n\u00edvel constante e outro modulado ao dobro da frequ\u00eancia de refer\u00eancia. O n\u00edvel\n\nconstante \u00e9 proporcional \u00e0 amplitude do sinal de entrada e ao cosseno (ou seno) do\n\n\u00e2ngulo de fase entre o sinal de entrada e o sinal de refer\u00eancia.\n\nUtilizando um ?ltro passa-baixa na sa\u00edda do demodulador separa-se o n\u00edvel cons-\n\ntante, livre de ru\u00eddo, recuperando assim as propriedades do dispositivo sob investi-\n\nga\u00e7\u00e3o.\n\nA formula\u00e7\u00e3o matem\u00e1tica no dom\u00ednio temporal de um ampli?cador sens\u00edvel \u00e0 fase\n\n\u00e9 descrita a seguir.\n\n\n\n57\n\nConsidere o sinal de entrada dado por\n\nVen(t) = Asen(?t + ?), (3.1)\n\nonde A \u00e9 a amplitude do sinal de entrada em Volts; ? = 2?f, com f igual \u00e0 frequ\u00eancia\n\ndo sinal de entrada em Hertz; e ? \u00e9 a fase do sinal de entrada em radianos.\n\nConsidere tamb\u00e9m as componentes em fase e em quadratura do sinal de refer\u00eancia,\n\ndescritas por\n\nVfase(t) = Bsen(?t + ?), (3.2)\n\nVquad(t) = Bcos(?t + ?), (3.3)\n\nonde B \u00e9 a amplitude das componentes do sinal de refer\u00eancia em Volts; ? = 2?f,\n\ncom f igual \u00e0 frequ\u00eancia do sinal de refer\u00eancia em Hertz; e ? \u00e9 a fase do sinal de\n\nrefer\u00eancia em radianos. Note que a frequ\u00eancia do sinal de entrada \u00e9 considerada igual\n\n\u00e0 frequ\u00eancia do sinal de refer\u00eancia.\n\nOs detectores de fase multiplicam o sinal de entrada pelas componentes em fase e\n\nem quadratura do sinal de refer\u00eancia. Ap\u00f3s os detectores de fase, tem-se que\n\nVdet,fase(t) = ABsen(?t + ?)sen(?t + ?), (3.4)\n\nVdet,quad(t) = ABsen(?t + ?)cos(?t + ?). (3.5)\n\nAs Equa\u00e7\u00f5es 3.4 e 3.5 podem ser reescritas de forma que\n\nVdet,fase(t) =\n1\n\n2\nAB[cos(? ? ?) ? cos(2?t + ? + ?)], (3.6)\n\nVdet,quad(t) =\n1\n\n2\nAB[sen(? ? ?) + sen(2?t + ? + ?)]. (3.7)\n\nComo pode ser observado a partir das Equa\u00e7\u00f5es 3.6 e 3.7, na sa\u00edda de cada detector\n\nde fase \u00e9 obtido um sinal composto por um n\u00edvel constante, proporcional \u00e0s amplitudes\n\ne ao cosseno (e seno) da diferen\u00e7a de fase do sinal de entrada e de refer\u00eancia, e um\n\nsinal modulado ao dobro da frequ\u00eancia de refer\u00eancia.\n\nOs ?ltros passa-baixa separam o n\u00edvel constante, rejeitando a componente modu-\n\nlada ao dobro da frequ\u00eancia de refer\u00eancia. Portanto, ap\u00f3s os ?ltros, tem-se que\n\nX =\n1\n\n2\nABcos(? ? ?), (3.8)\n\nY =\n1\n\n2\nABsen(? ? ?). (3.9)\n\n\n\n58\n\nDe maneira geral, as equa\u00e7\u00f5es de sa\u00edda de um ampli?cador sens\u00edvel \u00e0 fase anal\u00f3gico,\n\ncujos sinais envolvidos s\u00e3o de tempo cont\u00ednuo, podem ser escritas na forma\n\nX =\n1\n\nT\n\n? T\n0\n\nVen(t) \u00d7 Vfase(t)dt, (3.10)\n\nY =\n1\n\nT\n\n? T\n0\n\nVen(t) \u00d7 Vquad(t)dt, (3.11)\n\nonde T \u00e9 uma janela de tamanho igual a um per\u00edodo (ou m\u00faltiplos inteiros de um\n\nper\u00edodo) do sinal de entrada.\n\nNo caso de um ampli?cador sens\u00edvel \u00e0 fase digital, os sinais envolvidos s\u00e3o prove-\n\nnientes de conversores anal\u00f3gico-digital (AD) e digital-anal\u00f3gico (DA), ou seja, s\u00e3o\n\nsinais de tempo discreto. Portanto, as equa\u00e7\u00f5es de sa\u00edda podem ser escritas como\n\nX =\n1\n\nN\n\nN?1?\n0\n\nVen[i] \u00d7 Vfase[i], (3.12)\n\nY =\n1\n\nN\n\nN?1?\n0\n\nVen[i] \u00d7 Vquad[i], (3.13)\n\nonde N \u00e9 o n\u00famero de pontos amostrados do sinal de entrada durante um per\u00edodo\n\n(ou m\u00faltiplos inteiros de um per\u00edodo).\n\nA seguir ser\u00e3o apresentados alguns exemplos ilustrando gra?camente o princ\u00edpio\n\nde funcionamento do ampli?cador sens\u00edvel \u00e0 fase.\n\n3.1.1 Caso 1: Sinal de Entrada em Fase com o Sinal de Refe-\n\nr\u00eancia\n\nConsidere um sinal de entrada de mesma amplitude e em fase com o sinal de refer\u00eancia.\n\nO sinal de refer\u00eancia possui amplitude unit\u00e1ria e frequ\u00eancia igual a 1 kHz. Os diversos\n\nsinais presentes no ampli?cador sens\u00edvel \u00e0 fase s\u00e3o ilustrados na Figura 3.2.\n\nObserva-se, a partir da Figura 3.2, que os sinais ap\u00f3s os detectores em fase e\n\nem quadratura apresentam uma freq\u00fbencia igual ao dobro da frequ\u00eancia do sinal de\n\nrefer\u00eancia. Al\u00e9m disso, como o sinal de entrada est\u00e1 em fase com o sinal de refer\u00eancia,\n\na tens\u00e3o de sa\u00edda do Canal X atinge seu valor m\u00e1ximo (igual \u00e0 metade da amplitude\n\ndo sinal de entrada), enquanto a tens\u00e3o de sa\u00edda do Canal Y atinge seu valor m\u00ednimo\n\n(igual \u00e0 zero).\n\n\n\n59\n\nFigura 3.2: Gr\u00e1?cos das tens\u00f5es presentes no ampli?cador sens\u00edvel \u00e0 fase para um\nsinal de entrada em fase com o sinal de refer\u00eancia.\n\n3.1.2 Caso 2: Sinal de Entrada Defasado de 45 Graus com\n\nRela\u00e7\u00e3o ao Sinal de Refer\u00eancia\n\nConsidere agora um sinal de entrada de mesma amplitude e defasado de 45 graus\n\nem rela\u00e7\u00e3o ao sinal de refer\u00eancia. Novamente, o sinal de refer\u00eancia possui amplitude\n\nunit\u00e1ria e frequ\u00eancia igual a 1 kHz. Os diversos sinais presentes no ampli?cador\n\nsens\u00edvel \u00e0 fase, para este caso, s\u00e3o ilustrados na Figura 3.3.\n\nObserva-se, a partir da Figura 3.3, que os sinais ap\u00f3s os detectores em fase e\n\nem quadratura apresentam o mesmo valor m\u00e9dio (aproximadamente 0,35V). Con-\n\nsequentemente, a tens\u00e3o de sa\u00edda do Canal X \u00e9 igual \u00e0 tens\u00e3o de sa\u00edda do Canal\n\nY.\n\n\n\n60\n\nFigura 3.3: Gr\u00e1?cos das tens\u00f5es presentes no ampli?cador sens\u00edvel \u00e0 fase para um\nsinal de entrada defasado de 45 graus com rela\u00e7\u00e3o ao sinal de refer\u00eancia.\n\n3.1.3 Caso 3: Sinal de Entrada em Quadratura com o Sinal\n\nde Refer\u00eancia\n\nNa Figura 3.4 s\u00e3o ilustrados os diversos sinais presentes num ampli?cador sens\u00edvel \u00e0\n\nfase, considerando um sinal de entrada de mesma amplitude e defasado de 90 graus\n\ncom rela\u00e7\u00e3o ao sinal de refer\u00eancia. O sinal de refer\u00eancia possui amplitude unit\u00e1ria e\n\nfrequ\u00eancia de 1 kHz.\n\nNeste caso, como o sinal de entrada est\u00e1 em quadratura com o sinal de refer\u00eancia,\n\na tens\u00e3o de sa\u00edda do Canal X atinge seu valor m\u00ednimo (igual \u00e0 zero), enquanto a\n\ntens\u00e3o de sa\u00edda do Canal Y atinge seu valor m\u00e1ximo (igual \u00e0 metade da amplitude\n\ndo sinal de entrada).\n\n\n\n61\n\nFigura 3.4: Gr\u00e1?cos das tens\u00f5es presentes no ampli?cador sens\u00edvel \u00e0 fase para um\nsinal de entrada em quadratura com o sinal de refer\u00eancia.\n\n3.2 Exemplo de Aplica\u00e7\u00e3o: Medi\u00e7\u00e3o de Imped\u00e2ncias\n\nNa Figura 3.5 \u00e9 apresentado um diagrama esquem\u00e1tico de um circuito experimental\n\nutilizando um ampli?cador sens\u00edvel \u00e0 fase para medi\u00e7\u00e3o de imped\u00e2ncias. Nesta ?gura,\n\nVteste \u00e9 o sinal de excita\u00e7\u00e3o gerado pelo ampli?cador lock-in, Y \u00e9 um dispositivo sob\n\nteste, representado por uma admit\u00e2ncia, e Vent \u00e9 o sinal de entrada do ampli?cador.\n\nConsiderando-se que o dispositivo sob teste da Figura 3.5 \u00e9 uma admit\u00e2ncia Y\n\ndada por uma condut\u00e2ncia G e uma capacit\u00e2ncia C, e aplicando-se um sinal Vteste\n\ncuja amplitude Vref, frequ\u00eancia angular ? e fase ? s\u00e3o ajustadas pelo experimentador,\n\nobt\u00e9m-se um sinal Vent, conforme descrito a seguir.\n\nVteste = Vrefsen(?t + ?), (3.14)\n\n\n\n62\n\nFigura 3.5: Diagrama esquem\u00e1tico de um circuito experimental para medi\u00e7\u00e3o de\nimped\u00e2ncias utilizando um ampli?cador sens\u00edvel \u00e0 fase.\n\nY = G + j?C =\n1\n\nR\n+ j?C, (3.15)\n\nVent = ?RcI = ?RcY Vteste, (3.16)\n\nVent = ?RcVref [Gsen(?t + ?) + ?Ccos(?t + ?)], (3.17)\n\nonde I \u00e9 a corrente el\u00e9trica sobre o resitor Rc; Rc \u00e9 a resist\u00eancia do ampli?cador\n\ninversor (conversor corrente-tens\u00e3o) implementado com o ampli?cador operacional; e\n\nR \u00e9 a resist\u00eancia do dispositivo sob teste.\n\nOs sinais de sa\u00edda dos detectores em fase e em quadratura s\u00e3o dados por\n\nVdet,fase = ?\n1\n\n2\nRcVref [G(1 ? cos(2?t + 2?)) + ?Csen(2?t + 2?)], (3.18)\n\nVdet,quad = ?\n1\n\n2\nRcVref [Gsen(2?t + 2?)) + ?C(1 ? cos(2?t + 2?))]. (3.19)\n\nFinalmente, os sinais de sa\u00edda dos canaix X e Y s\u00e3o dados por\n\nX = ?\n1\n\n2\nRcVrefG, (3.20)\n\nY = ?\n1\n\n2\nRcVref?C. (3.21)\n\nNota-se que os valores CC das tens\u00f5es nos canais X e Y s\u00e3o diretamente propor-\n\ncionais \u00e0 condut\u00e2ncia e capacit\u00e2ncia do dispositivo sob teste, respectivamente. Logo,\n\na resist\u00eancia e a capacit\u00e2ncia do dispositivo s\u00e3o dadas por\n\nR = ?\n1\n\n2\nRcVref\n\n1\n\nX\n, (3.22)\n\nC = ?\n2\n\n?RcVref\nY. (3.23)\n\n\n\n63\n\nPortanto, uma vez que o sinal de teste \u00e9 conhecido, pode-se determinar as pro-\n\npriedades el\u00e9tricas (resist\u00eancia e capacit\u00e2ncia) de um dispositivo sob teste analisando-\n\nse a resposta \u00e0 excita\u00e7\u00e3o. A partir do sinal de tens\u00e3o obtido no canal X determina-se\n\na resist\u00eancia. Por outro lado, o canal Y informa a capacit\u00e2ncia do dispositivo sob\n\ninvestiga\u00e7\u00e3o.\n\nNa pr\u00f3xima se\u00e7\u00e3o ser\u00e1 discutida a implementa\u00e7\u00e3o de um ampli?cador sens\u00edvel \u00e0\n\nfase digital utilizando, inicialmente, um microcomputador com placa de aquisi\u00e7\u00e3o de\n\ndados e MATLAB. Em seguida, ser\u00e1 apresentada a implementa\u00e7\u00e3o do ampli?cador\n\nlock-in digital em FPGA.\n\n3.3 Ampli?cador Sens\u00edvel \u00e0 Fase Digital Utilizando\n\nMicrocomputador com Placa de Aquisi\u00e7\u00e3o de Da-\n\ndos e MATLAB\n\nNesta se\u00e7\u00e3o ser\u00e1 apresentada a implementa\u00e7\u00e3o de um ampli?cador lock-in digital\n\nutilizando um microcomputador com placa de aquisi\u00e7\u00e3o de dados DAS-20 e MAT-\n\nLAB. Tamb\u00e9m ser\u00e3o discutidos os resultados obtidos em sua aplica\u00e7\u00e3o na medi\u00e7\u00e3o\n\nde imped\u00e2ncias.\n\n3.3.1 Implementa\u00e7\u00e3o\n\nNa Figura 3.6 \u00e9 apresentado o diagrama em blocos do ampli?cador lock-in digital\n\nutilizando a placa de aquisi\u00e7\u00e3o de dados DAS-20 e MATLAB. Com a placa DAS-20,\n\no sinal de teste \u00e9 gerado e a aquisi\u00e7\u00e3o da resposta \u00e0 excita\u00e7\u00e3o (sinal de entrada) \u00e9 rea-\n\nlizada. No MATLAB \u00e9 executado o algoritmo no qual a t\u00e9cnica lock-in propriamente\n\ndita \u00e9 implementada.\n\nA DAS-20, desenvolvida pela Keithley Instruments, \u00e9 uma placa de aquisi\u00e7\u00e3o de\n\ndados para computadores IBM/PC e compat\u00edveis. A interface entre o computador e\n\na placa \u00e9 realizada via barramento ISA, de forma que a DAS-20 pode ser utilizada\n\ntamb\u00e9m em computadores mais antigos. Na implementa\u00e7\u00e3o do ampli?cador lock-in\n\ndigital foram utilizados um canal de sa\u00edda anal\u00f3gico operando de -5 V a +5 V e um\n\ncanal de entrada anal\u00f3gica operando de -10 V a +10 V.\n\n\n\n64\n\nFigura 3.6: Diagrama em blocos do ampli?cadorlock-in digital utilizando microcom-\nputador com placa de aquisi\u00e7\u00e3o de dados e MATLAB.\n\nA placa DAS-20 \u00e9 empregada na gera\u00e7\u00e3o do sinal de teste (utilizado para excitar o\n\ndispositivo a ser analisado) e na aquisi\u00e7\u00e3o do sinal de entrada (resposta \u00e0 excita\u00e7\u00e3o).\n\nPara realizar o controle da placa foi utilizado um driver desenvolvido por Tony L.\n\nKeiser [24]. Essedriver \u00e9 constitu\u00eddo por uma biblioteca de fun\u00e7\u00f5es que implementam\n\ndiversos comandos da DAS-20 e podem ser utilizadas no c\u00f3digo de um programa\n\nescrito em linguagem C.\n\nO ?uxograma do software de controle da placa DAS-20, desenvolvido para a im-\n\nplementa\u00e7\u00e3o do ampli?cadorlock-in digital \u00e9 ilustrado na Figura 3.7.\n\nAo iniciar a execu\u00e7\u00e3o do programa, o usu\u00e1rio informa os par\u00e2metros do sinal de\n\nteste, o qual ser\u00e1 utilizado para excitar o dispositivo sob an\u00e1lise. Nesta etapa, s\u00e3o\n\nde?nidos: amplitude, frequ\u00eancia e fase do sinal de refer\u00eancia. \u00c9 de?nido, tamb\u00e9m, o\n\ntempo no qual o dispositivo sob teste ser\u00e1 excitado.\n\nO pr\u00f3ximo passo \u00e9 a inicializa\u00e7\u00e3o da placa DAS-20, que \u00e9 realizada automati-\n\ncamente pelo programa. Nesse momento, \u00e9 realizado um reset geral da placa. Em\n\nseguida, a frequ\u00eancia de amostragem \u00e9 de?nida, as interrup\u00e7\u00f5es s\u00e3o con?guradas e os\n\n\n\n65\n\nFigura 3.7: Fluxograma dosoftware de controle da placa DAS-20.\n\ntemporizadores selecionados.\n\nAp\u00f3s o processo de inicializa\u00e7\u00e3o da placa, s\u00e3o iniciadas a gera\u00e7\u00e3o do sinal de teste\n\ne a aquisi\u00e7\u00e3o do sinal de entrada (resposta \u00e0 excita\u00e7\u00e3o do dispositivo sob an\u00e1lise).\n\nO sinal de teste \u00e9 gerado durante o intervalo de tempo determinado pelo usu\u00e1rio\n\nna de?ni\u00e7\u00e3o dos par\u00e2metros. Durante a aquisi\u00e7\u00e3o dos dados, um arquivo de texto\n\n\u00e9 criado para armazenar as informa\u00e7\u00f5es obtidas pela placa DAS-20. Esse arquivo \u00e9\n\nutilizado posteriormente pelo MATLAB na execu\u00e7\u00e3o do algoritmo desenvolvido para\n\na implementa\u00e7\u00e3o da t\u00e9cnicalock-in.\n\nAo t\u00e9rmino do tempo de excita\u00e7\u00e3o, \u00e9 realizado um novoreset geral da placa DAS-\n\n20 e o programa \u00e9 encerrado. A tela do principal do programa de aquisi\u00e7\u00e3o de dados,\n\nescrito em linguagem C, \u00e9 apresentada na Figura 3.8.\n\nAp\u00f3s a aquisi\u00e7\u00e3o de dados, as opera\u00e7\u00f5es de multiplica\u00e7\u00e3o e c\u00e1lculo da m\u00e9dia\n\n(detectores de fase e ?ltros passa-baixa, respectivamente) s\u00e3o executadas a partir\n\n\n\n66\n\nFigura 3.8: Tela principal do programa de aquisi\u00e7\u00e3o de dados.\n\ndo algoritmo implementado no MATLAB. O programa desenvolvido no MATLAB\n\n\u00e9 constitu\u00eddo de dois arquivos: lockincal.m e lockinmed.m. O arquivo lockincal.m \u00e9\n\nutilizado na calibra\u00e7\u00e3o do ampli?cador lock-in digital e no ajuste de fase. Essa etapa\n\n\u00e9 necess\u00e1ria para eliminar os erros de fase inerentes ao circuito de medi\u00e7\u00e3o, externo\n\nao ampli?cador, causados, por exemplo, por capacit\u00e2ncias parasitas. J\u00e1 o arquivo\n\nlockinmed.m retorna os valores dos canais X e Y, calculando os valores de resist\u00eancia\n\ne capacit\u00e2ncia do dispositivo sob teste.\n\nA Figura 3.9 ilustra o ?uxograma b\u00e1sico do algoritmo desenvolvido no MATLAB.\n\nInicialmente, \u00e9 realizada a calibra\u00e7\u00e3o do ampli?cador lock-in, a partir do ajuste\n\nde fase. Em seguida, o sinal de refer\u00eancia, constitu\u00eddo pelas componentes em fase\n\ne em quadratura, \u00e9 ajustado de acordo com o sinal de excita\u00e7\u00e3o aplicado com a\n\nplaca DAS-20. Vetores s\u00e3o de?nidos de forma a armazenarem os sinais de refer\u00eancia\n\n(componentes em fase e quadratura) e de entrada (obtido do arquivo de texto gerado\n\nna aquisi\u00e7\u00e3o dos dados).\n\nO detector de fase digital \u00e9 modelado matematicamente como uma opera\u00e7\u00e3o de\n\nmultiplica\u00e7\u00e3o de vetores (elemento-a-elemento). O n\u00edvel constante \u00e9 obtido calculando-\n\nse o valor m\u00e9dio do sinal demodulado. Uma vez que o sinal demodulado \u00e9 discreto, o\n\n?ltro passa-baixa consiste de uma simples m\u00e9dia aritm\u00e9tica dos dados armazenados\n\n\n\n67\n\nFigura 3.9: Fluxograma do algoritmo desenvolvido no MATLAB.\n\ndurante um per\u00edodo do sinal de entrada, produzindo os valores dos canais X e Y.\n\nFinalmente, os valores de resist\u00eancia e capacit\u00e2ncia s\u00e3o determinados.\n\nA tela com as sa\u00eddas produzidas pelo programa em MATLAB \u00e9 apresentada na\n\nFigura 3.10. Os c\u00f3digos desenvolvidos em linguagem C e MATLAB s\u00e3o apresentados\n\nno Ap\u00eandice B.\n\n3.3.2 Resultados\n\nNesta se\u00e7\u00e3o ser\u00e3o analisados os resultados obtidos na medi\u00e7\u00e3o de imped\u00e2ncias com\n\no ampli?cador lock-in digital utilizando microcomputador com placa de aquisi\u00e7\u00e3o de\n\ndados DAS-20 e MATLAB.\n\nO diagrama esquem\u00e1tico do circuito experimental para medi\u00e7\u00e3o de imped\u00e2ncias\n\nutilizando o ampli?cador lock-in desenvolvido \u00e9 apresentado na Figura 3.11. Este\n\n\n\n68\n\nFigura 3.10: Tela do programa desenvolvido em MATLAB para medi\u00e7\u00e3o de imped\u00e2n-\ncias com o ampli?cador lock-in.\n\nesquema \u00e9 baseado no circuito gen\u00e9rico da Figura 3.5, com a inser\u00e7\u00e3o de um ampli-\n\n?cador operacional na con?gura\u00e7\u00e3o Bu?er. A fun\u00e7\u00e3o deste ampli?cador operacional\n\n\u00e9 isolar o circuito de condicionamento do ampli?cador lock-in digital, protegendo a\n\nplaca de aquisi\u00e7\u00e3o de dados.\n\nFigura 3.11: Diagrama esquem\u00e1tico de um circuito experimental para medi\u00e7\u00e3o de\nimped\u00e2ncias utilizando o ampli?cadorlock-in digital com placa de aquisi\u00e7\u00e3o de dados\ne MATLAB.\n\nO circuito experimental montado em laborat\u00f3rio \u00e9 apresentado na Figura 3.12.\n\nInicialmente, foi utilizado um sinal de teste, com amplitude igual a 1V e frequ\u00eancia\n\nigual a 1kHz. Como dispositivo sob teste foi utilizado um resistor de 1k? (valor\n\n\n\n69\n\nFigura 3.12: Ampli?cadorlock-in digital com placa de aquisi\u00e7\u00e3o de dados e MATLAB\nutilizado na medi\u00e7\u00e3o de imped\u00e2ncias.\n\nnominal) e toler\u00e2ncia de 5%. O valor de resist\u00eancia medido com um mult\u00edmetro\n\ndigital foi de 998?. No circuito conversor corrente-tens\u00e3o, tamb\u00e9m foi utilizado um\n\nresistor Rc = 1k?.\n\nUma vez que o dispositivo sob teste \u00e9 constitu\u00eddo apenas por um resistor R = Rc,\n\nos valores te\u00f3ricos de sa\u00edda s\u00e3o iguais a X = ?0, 5V e Y = 0V .\n\nAp\u00f3s a excita\u00e7\u00e3o do dispositivo sob teste (resistor), aquisi\u00e7\u00e3o de dados (resposta\n\n\u00e0 excita\u00e7\u00e3o) e execu\u00e7\u00e3o do algoritmo no MATLAB, foram obtidos os valores de sa\u00edda\n\nX = ?0, 4963V e Y = 1, 439 \u00d7 10?15V .\n\nOs valores de resist\u00eancia e capacit\u00e2ncia fornecidos pelo programa lockinmed.m\n\nforam: R = 996, 3263? e C = 4, 6322 \u00d7 10?22F . Portanto, o valor de resist\u00eancia\n\nmedido com o ampli?cador lock-in apresentou um desvio de 0,37 % em rela\u00e7\u00e3o ao\n\nvalor nominal e 0,16 % em rela\u00e7\u00e3o ao valor medido com o mult\u00edmetro. Al\u00e9m disso, o\n\nvalor de capacit\u00e2ncia \u00e9 aproximadamente zero.\n\nOs resultados obtidos est\u00e3o resumidos na Tabela 3.1.\n\nA depend\u00eancia linear do sinal de sa\u00edda do canal X em fun\u00e7\u00e3o da condut\u00e2ncia do\n\ndispositivo sob teste \u00e9 observada na Figura 3.13. Veri?ca-se, a partir desta ?gura,\n\nque os resultados experimentais obtidos com o ampli?cador lock-in digital utilizando\n\nplaca de aquisi\u00e7\u00e3o de dados e MATLAB apresentam um alto grau de concord\u00e2ncia\n\ncom os resultados te\u00f3ricos.\n\n\n\n70\n\nTabela 3.1: Resultados obtidos na caracteriza\u00e7\u00e3o de um resistor de 1 k? com o\nampli?cador lock-in.\n\nValor Te\u00f3rico Valor Obtido Desvio\nCanal X -0,5V -0,4963V 0,7 %\nCanal Y 0 1,4392 \u00d710?15V -\n\nR 1k? 996,3263 ? 0,37 %\nC 0 4,6322 \u00d710?22 F -\n\nFigura 3.13: Gr\u00e1?co da tens\u00e3o de sa\u00edda do canal X em fun\u00e7\u00e3o da condut\u00e2ncia do\ndispositivo sob teste (teoria e pr\u00e1tica).\n\nEste prot\u00f3tipo, entretanto, apresentou limita\u00e7\u00f5es na medi\u00e7\u00e3o de capacit\u00e2ncias.\n\nInserindo-se uma capacit\u00e2ncia no dispositivo sob teste Y da Figura 3.11, o circuito\n\nde condicionamento torna-se um circuito derivador [25]. A tens\u00e3o de excita\u00e7\u00e3o (Vteste)\n\n\u00e9 um sinal produzido por um conversor DA da placa DAS-20, apresentando, portanto,\n\ndescontinuidades. Estas descontinuidades, por sua vez, aumentam \u00e0 medida que a\n\nvelocidade de atualiza\u00e7\u00e3o das sa\u00eddas do conversor DA diminui.\n\nUma vez que a derivada de uma fun\u00e7\u00e3o pulso produz a fun\u00e7\u00e3o impulso [26], o\n\nsinal de excita\u00e7\u00e3o, ao passar pelo circuito derivador, gera picos de tens\u00e3o a cada\n\ndescontinuidade. Estes picos de tens\u00e3o impossibilitaram a obten\u00e7\u00e3o de uma resposta\n\n\u00e0 excita\u00e7\u00e3o adequada, de forma que n\u00e3o foi poss\u00edvel a medi\u00e7\u00e3o de capacit\u00e2ncias.\n\n\n\n71\n\n3.4 Ampli?cador Sens\u00edvel \u00e0 Fase Descrito em VHDL\n\ne Implementado em FPGA\n\nNesta se\u00e7\u00e3o ser\u00e1 apresentada a descri\u00e7\u00e3o VHDL de um ampli?cador sens\u00edvel \u00e0 fase\n\ndigital e sua implementa\u00e7\u00e3o em FPGA.\n\nFigura 3.14: Diagrama em blocos do ampli?cador sens\u00edvel \u00e0 fase digital.\n\nO diagrama em blocos do ampli?cador sens\u00edvel \u00e0 fase digital \u00e9 apresentado na\n\nFigura 3.14. Os detectores em fase e em quadratura s\u00e3o representados pelos blocos de\n\nmultiplica\u00e7\u00e3o. Os ?ltros passa-baixa (c\u00e1lculo da m\u00e9dia aritm\u00e9tica) s\u00e3o representados\n\npelos blocos acumuladores e de divis\u00e3o por N (n\u00famero de pontos amostrados num\n\nper\u00edodo do sinal de entrada). O sinal de refer\u00eancia \u00e9 gravado na mem\u00f3ria ROM,\n\ncontendo um per\u00edodo completo da sen\u00f3ide. O sequenciador \u00e9 o bloco respons\u00e1vel pela\n\nexecu\u00e7\u00e3o das opera\u00e7\u00f5es internas do ampli?cador lock-in digital.\n\nNo desenvolvimento deste projeto foi utilizada a estrat\u00e9gia de \"dividir para con-\n\nquistar\". Inicialmente, o sistema digital foi fragmentado em v\u00e1rios blocos. Em\n\nseguida, cada bloco foi descrito em VHDL, a n\u00edvel RTL, seguindo uma metodolo-\n\ngia de projeto top-down. Finalmente, todos os blocos foram interconectados numa\n\nmesma entidade principal, utilizando uma descri\u00e7\u00e3o estrutural.\n\nAlguns blocos mais complexos, tais como o multiplicador, foram ainda divididos\n\n\n\n72\n\nem sub-blocos, que tamb\u00e9m foram descritos a n\u00edvel RTL e em seguida interconectados\n\nde forma estrutural.\n\nO c\u00f3digo VHDL do ampli?cador sens\u00edvel \u00e0 fase \u00e9 apresentado no Ap\u00eandice A.\n\n3.4.1 Detector de Fase\n\nFigura 3.15: Diagrama em blocos do detector de fase.\n\nA Figura 3.15 apresenta o diagrama em blocos do detector de fase. O n\u00facleo do\n\ndetector de fase consiste de um multiplicador bin\u00e1rio de n\u00fameros positivos. Para lidar\n\ncom n\u00fameros negativos, foram acrescentados blocos para c\u00e1lculo do complemento a\n\n2 e alguns multiplexadores.\n\nAp\u00f3s a descri\u00e7\u00e3o VHDL individual de cada bloco, foi criada uma arquitetura estru-\n\ntural para o detector de fase, interligando os componentes de c\u00e1lculo do complemento\n\na dois, os multiplexadores e o multiplicador.\n\nO esquem\u00e1tico RTL de cada bloco do detector de fase gerado pela ferramenta de\n\ns\u00edntese \u00e9 apresentado nas Figuras 3.16 a 3.19.\n\nDe acordo com o ilustrado na Figura 3.16, o complemento a 2 \u00e9 calculado invertendo-\n\nse os 12 bits da palavra de entrada e somando-se 1 ao resultado. A partir da\n\nFigura 3.17, observa-se que o multiplexador 2-1 foi implementado utilizando-se por-\n\ntas l\u00f3gicas. Por sua vez, o multiplexador 2-1 de 12 bits foi implementado a partir da\n\ninstancia\u00e7\u00e3o de 12 multiplexadores 2-1 de 1 bit, conforme ilustrado na Figura 3.18.\n\nFinalmente, na Figura 3.19, pode-se veri?car a infer\u00eancia de um ?ip-?op ap\u00f3s o\n\nmultiplicador bin\u00e1rio, de forma a armazenar o \u00faltimo resultado.\n\n\n\n73\n\nFigura 3.16: Esquem\u00e1tico RTL do bloco de c\u00e1lculo do complemento a 2.\n\nFigura 3.17: Esquem\u00e1tico RTL do bloco multiplexador 2-1 (1 bit).\n\nFigura 3.18: Esquem\u00e1tico RTL do bloco multiplexador 2-1 (12 bits).\n\n\n\n74\n\nFigura 3.19: Esquem\u00e1tico RTL do bloco multiplicador bin\u00e1rio.\n\n3.4.2 Filtro Passa-Baixa\n\nUm ?ltro passa-baixa de primeira ordem pode ser visto como um circuito para c\u00e1lculo\n\nda m\u00e9dia aritm\u00e9tica de N termos. Um circuito para c\u00e1lculo da m\u00e9dia aritm\u00e9tica pode\n\nser implementado com um somador (acumulador) e um divisor. Se o n\u00famero de termos\n\n\u00e9 uma pot\u00eancia de 2, um registrador de deslocamento pode ser usado para efetuar a\n\ndivis\u00e3o por N.\n\nO c\u00e1lculo da m\u00e9dia \u00e9 realizado a cada per\u00edodo do sinal de refer\u00eancia. Ao ?nal\n\nde um per\u00edodo, o registrador de deslocamento \u00e9 reinicializado, de forma a recome\u00e7ar\n\nos c\u00e1lculos. Para manter o \u00faltimo valor calculado nos canais de sa\u00edda (X e Y), um\n\nregistrador debits \u00e9 utilizado comobu?er.\n\nOs sinais de entrada e de refer\u00eancia s\u00e3o armazenados em registradores de 12bits.\n\nJ\u00e1 os sinais demodulados (ap\u00f3s os multiplicadores), por sua vez, s\u00e3o armazenados em\n\nregistradores de 24bits. Para prevenir a ocorr\u00eancia de um over?ow no acumulador de\n\nsa\u00edda, foi utilizado umbu?er (e, consequentemente, um registrador de deslocamento)\n\nde 64bits.\n\nO diagrama em blocos do ?ltro passa-baixa e o esquem\u00e1tico RTL de cada bloco\n\ngerado pela ferramenta de s\u00edntese est\u00e3o ilustrados nas Figuras 3.20 a 3.23.\n\nA infer\u00eancia de um somador de 64 bits \u00e9 ilustrada na Figura 3.21. A partir da\n\nFigura 3.22 observa-se a s\u00edntese de uma estrutura com 64 blocos em cascata, onde\n\ncada bloco representa um?ip-?op, implementando o registrador de deslocamento. J\u00e1\n\nna Figura 3.23, veri?ca-se a infer\u00eancia de um registrador de 64 bits, implementando\n\nobu?er.\n\n\n\n75\n\nFigura 3.20: Diagrama em blocos do ?ltro passa-Baixa.\n\nFigura 3.21: Esquem\u00e1tico RTL do bloco somador.\n\nFigura 3.22: Esquem\u00e1tico RTL do bloco registrador de deslocamento.\n\nFigura 3.23: Esquem\u00e1tico RTL do bloco registrador bu?er.\n\n\n\n76\n\n3.4.3 Mem\u00f3ria ROM\n\nPara armazenar o sinal de refer\u00eancia, \u00e9 utilizada uma mem\u00f3ria ROM na qual est\u00e1\n\ngravado um per\u00edodo completo do sinal senoidal de refer\u00eancia. Foi considerado, inicial-\n\nmente, que o sinal de refer\u00eancia possui frequ\u00eancia de 1 kHz, amostrado a uma taxa de\n\n128 kSPS, por conversores de 12 bits. Nesse sentido, foi implementada uma mem\u00f3ria\n\nROM de 128 x 12 bits.\n\nO esquem\u00e1tico RTL da mem\u00f3ria ROM gerado pela ferramenta de s\u00edntese \u00e9 ilustrado\n\nna Figura 3.24. Nesta ?gura, cada bloco representa uma c\u00e9lula b\u00e1sica de mem\u00f3ria.\n\nEstas c\u00e9lulas b\u00e1sicas de mem\u00f3ria s\u00e3o interligadas, formando a estrutura da mem\u00f3ria\n\nROM.\n\nFigura 3.24: Esquem\u00e1tico RTL da mem\u00f3ria ROM.\n\n3.4.4 Sequenciador\n\nPara realizar as opera\u00e7\u00f5es de convers\u00e3o AD, convers\u00e3o DA, armazenamento nos re-\n\ngistradores, multiplica\u00e7\u00e3o, c\u00e1lculo da m\u00e9dia, atualiza\u00e7\u00e3o das sa\u00eddas X e Y, etc., de\n\nforma sincronizada, \u00e9 necess\u00e1rio um circuito de sequenciamento. Nesse sentido, foi\n\nimplementada uma m\u00e1quina de estados ?nitos, denominada Sequenciador.\n\nTamb\u00e9m foram implementados contadores auxiliares, indicando o n\u00famero de pon-\n\ntos calculados, o n\u00famero de deslocamentos realizados na divis\u00e3o e a posi\u00e7\u00e3o da\n\n\n\n77\n\nmem\u00f3ria ROM.\n\nAp\u00f3s a descri\u00e7\u00e3o de todos os blocos, uma entidade principal foi criada, realizando\n\nas interconex\u00f5es entre os blocos descritos anteriormente, numa descri\u00e7\u00e3o estrutural.\n\n3.4.5 Simula\u00e7\u00f5es do Ampli?cador Lock-in Digital em VHDL\n\nAp\u00f3s o desenvolvimento do circuito e a cria\u00e7\u00e3o do ambiente de teste (TestBench),\n\nforam realizadas v\u00e1rias simula\u00e7\u00f5es funcionais.\n\nA mem\u00f3ria ROM foi preenchida de modo que seus valores correspondessem a\n\numa sen\u00f3ide de amplitude igual a 1V, para o conversor DA de 12 bits escolhido. O\n\nconversor DA considerado foi o AD5447 [27], desenvolvido pela Analog Devices. Os\n\nvalores armazenados na ROM s\u00e3o apresentados na Figura 3.25.\n\nFigura 3.25: Gr\u00e1?co dos valores armazenados na mem\u00f3ria ROM.\n\nComo pode ser observado na Figura 3.25, para VDA = 1V (sa\u00edda do conversor\n\nDA), o valor bin\u00e1rio armazenado na mem\u00f3ria corresponde a 410 (na base decimal). O\n\nper\u00edodo do sinal de refer\u00eancia \u00e9 de 1 ms (frequ\u00eancia de refer\u00eancia de 1 kHz), amostrado\n\na uma taxa de 128 kSPS. Logo, s\u00e3o utilizados 128 pontos na tabela, ou seja, 128\n\nposi\u00e7\u00f5es de mem\u00f3ria.\n\nNas Figuras 3.26 a 3.28, o funcionamento do ampli?cador sens\u00edvel \u00e0 fase digital \u00e9\n\n\n\n78\n\napresentado, para tr\u00eas situa\u00e7\u00f5es:\n\n\u2022 Sinal de entrada em fase com o sinal de refer\u00eancia;\n\n\u2022 Sinal de entrada em quadratura com o sinal de refer\u00eancia;\n\n\u2022 Sinal de entrada defasado de 180 graus em rela\u00e7\u00e3o ao sinal de refer\u00eancia.\n\nEm todas as situa\u00e7\u00f5es, os sinais de entrada e de refer\u00eancia (ROM) t\u00eam a mesma\n\namplitude e frequ\u00eancia.\n\nConsideremos as Equa\u00e7\u00f5es 3.8 e 3.9 reapresentadas, por comodidade, abaixo:\n\nX =\n1\n\n2\nABcos(? ? ?), (3.24)\n\nY =\n1\n\n2\nABsen(? ? ?). (3.25)\n\nNo primeiro caso, temos que a diferen\u00e7a de fase \u00e9 zero. Logo, os valores esperados\n\nde X e Y s\u00e3o:\n\nX =\n1\n\n2\nA2 =\n\n1\n\n2\n(410)2 = 84050, (3.26)\n\nY = 0. (3.27)\n\nComo pode ser observado na Figura 3.26, foram obtidos X = 83992 e Y = 0. Logo,\n\na sa\u00edda X apresenta um erro de aproximadamente 0,069 %. Este erro \u00e9 inerente ao\n\nalgoritmo de divis\u00e3o utilizado. A divis\u00e3o consiste no deslocamento para direita de\n\num registrador (divis\u00e3o por 2). Quando o n\u00famero armazenado no registrador \u00e9 par, a\n\ndivis\u00e3o \u00e9 realizada corretamente. Quando o n\u00famero \u00e9 \u00edmpar, ocorre uma aproxima\u00e7\u00e3o\n\nlevando ao erro observado.\n\nNo segundo exemplo, temos que a diferen\u00e7a de fase \u00e9 de 90 graus. Logo, os valores\n\nesperados de X e Y s\u00e3o:\n\nX = 0, (3.28)\n\nY =\n1\n\n2\nA2 =\n\n1\n\n2\n(410)2 = 84050. (3.29)\n\nComo pode ser observado na Figura 3.27, foram obtidos X = 0 e Y = 83992.\n\nLogo, a sa\u00edda Y apresenta um erro de aproximadamente 0,069% pelo mesmo motivo\n\ndiscutido anteriormente.\n\n\n\n79\n\nFigura 3.26: Formas de onda obtidas na simula\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase\n(Sinal de entrada em fase com o sinal de refer\u00eancia).\n\nFigura 3.27: Formas de onda obtidas na simula\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase\n(Sinal de entrada em quadratura com o sinal de refer\u00eancia).\n\nFinalmente, no terceiro caso, temos que a diferen\u00e7a de fase \u00e9 de 180 graus. Logo,\n\nos valores esperados de X e Y s\u00e3o:\n\nX = ?\n1\n\n2\nA2 = ?\n\n1\n\n2\n(410)2 = ?84050, (3.30)\n\nY = 0. (3.31)\n\nComo pode ser observado na Figura 3.28, foram obtidos X = ?83993 e Y =\n\n0. Novamente a sa\u00edda X apresenta um erro de aproximadamente 0,069% devido \u00e0s\n\naproxima\u00e7\u00f5es realizadas durante a divis\u00e3o.\n\n\n\n80\n\nFigura 3.28: Formas de onda obtidas na simula\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase\n(Sinal de entrada defasado de 180 graus com rela\u00e7\u00e3o ao sinal de refer\u00eancia).\n\n3.4.6 S\u00edntese do Ampli?cador Lock-in Digital em VHDL\n\nOs resultados obtidos na s\u00edntese do ampli?cador sens\u00edvel \u00e0 fase digital descrito em\n\nVHDL s\u00e3o apresentados na Tabela 3.2. Neste trabalho foi utilizada a FPGA Xilinx\n\nSpartan 3E XC3S500E -5 FG320. A partir destes resultados, veri?ca-se que o am-\n\npli?cador sens\u00edvel \u00e0 fase digital ocupa cerca de 6% dos recursos l\u00f3gicos da FPGA\n\nescolhida.\n\nTabela 3.2: Utiliza\u00e7\u00e3o de recursos l\u00f3gicos da FPGA ap\u00f3s a s\u00edntese doLock-in.\nUsado Dispon\u00edvel Utiliza\u00e7\u00e3o\n\nSlice Flip-Flops 219 9312 2 %\nLUTs de 4 entradas 564 9312 6%\n\nSlices 318 4656 6%\n\n3.4.7 Valida\u00e7\u00e3o em FPGA do Ampli?cador Lock-in Digital em\n\nVHDL\n\nPara valida\u00e7\u00e3o do ampli?cador sens\u00edvel \u00e0 fase implementado em FPGA, foi utilizada\n\na seguinte metodologia:\n\n\u2022 Simular os resultados das medi\u00e7\u00f5es, gravando numa mem\u00f3ria ROM os valores\n\nque seriam fornecidos por um conversor AD. Essa mem\u00f3ria foi descrita em\n\n\n\n81\n\nVHDL e implementada em FPGA, externamente ao ampli?cador sens\u00edvel \u00e0\n\nfase;\n\n\u2022 Realizar o processamento dessas medi\u00e7\u00f5es com o ampli?cador sens\u00edvel \u00e0 fase;\n\n\u2022 Apresentar o resultado desse processamento a partir dos LEDs presentes na\n\nplaca de desenvolvimento. Uma vez que a placa possui apenas 8 LEDs, o resul-\n\ntado apresentado \u00e9 o byte menos signi?cativo dos canais de sa\u00edda X e Y .\n\nNa Figura ?? s\u00e3o ilustradas as representa\u00e7\u00f5es, a partir dos 8 LEDs dispon\u00edveis\n\nna placa de desenvolvimento, dos bytes menos signi?cativos dos sinais de sa\u00edda dos\n\ncanais X e Y . Nesse exemplo, a ROM que simula os valores fornecidos pelo conversor\n\nAD possui a mesma tabela de valores da ROM que armazena o sinal de refer\u00eancia.\n\nConsequentemente, tem-se o caso do sinal de entrada de mesma amplitude, frequ\u00eancia\n\ne fase do sinal de refer\u00eancia.\n\nConforme a Figura 3.26, tem-se X = 8399210 = 101001000000110002 e Y = 0.\n\nPortanto, as sa\u00eddas esperadas nos LEDs seriam \"00011000\"e \"00000000\", para os\n\ncanais X e Y , respectivamente. Estes resultados foram obtidos corretamente na\n\nplaca de desenvolvimento.\n\n3.5 Considera\u00e7\u00f5es Finais\n\nNeste cap\u00edtulo foram apresentados os resultados obtidos na implementa\u00e7\u00e3o de um\n\nampli?cador sens\u00edvel \u00e0 fase digital utilizando, inicialmente, um microcomputador com\n\nplaca de aquisi\u00e7\u00e3o de dados e MATLAB e, em seguida, descrito em VHDL e gravado\n\nem FPGA.\n\nEmbora o prot\u00f3tipo implementado com a placa DAS-20 e MATLAB tenha apre-\n\nsentado limita\u00e7\u00f5es na medi\u00e7\u00e3o de capacit\u00e2ncias, o algoritmo de detec\u00e7\u00e3o de fase da\n\nt\u00e9cnica lock-in p\u00f4de ser validado. Al\u00e9m disso, este prot\u00f3tipo foi utilizado com \u00eaxito\n\nna medi\u00e7\u00e3o de resist\u00eancias.\n\nUma alternativa para solucionar a limita\u00e7\u00e3o do prot\u00f3tipo na medi\u00e7\u00e3o de capacit\u00e2n-\n\ncias \u00e9 modi?car o circuito de condicionamento, alterando a sua fun\u00e7\u00e3o de transfer\u00eancia\n\ne, consequentemente, anulando o efeito derivativo. Outra solu\u00e7\u00e3o seria utilizar con-\n\n\n\n82\n\nversores DA mais r\u00e1pidos. Finalmente, pode-se realizar uma ?ltragem preliminar do\n\nsinal de teste, reduzindo as suas descontinuidades.\n\nUma vez validada a t\u00e9cnica lock-in, foi realizada a descri\u00e7\u00e3o VHDL de um ampli-\n\n?cador sens\u00edvel \u00e0 fase digital para implementa\u00e7\u00e3o em FPGA.\n\nO funcionamento do ampli?cador lock-in digital descrito em VHDL foi veri?cado\n\ncom \u00eaxito a partir de simula\u00e7\u00f5es e de testes realizados ap\u00f3s a grava\u00e7\u00e3o da FPGA.\n\nEntretanto, o circuito ?nal n\u00e3o foi utilizado em medi\u00e7\u00f5es reais de imped\u00e2ncias. Para\n\ntal, \u00e9 necess\u00e1ria a integra\u00e7\u00e3o do ampli?cador lock-in digital em FPGA aos circuitos\n\nde convers\u00e3o AD e DA da placa de desenvolvimento utilizada.\n\nO circuito sintetizado ocupou cerca de 6% dos recursos l\u00f3gicos da FPGA alvo.\n\nIsto signi?ca que v\u00e1rios ampli?cadores lock-in podem ser utilizados em paralelo,\n\nnum mesmochip. Este \u00e9 um resultado importante, considerando-se a aplica\u00e7\u00e3o deste\n\ndispositivo na medi\u00e7\u00e3o de vaz\u00e3o utilizando a t\u00e9cnica da tomogra?a por imped\u00e2ncia\n\nel\u00e9trica.\n\nNesta t\u00e9cnica, s\u00e3o necess\u00e1rias pelo menos N(N ? 1)/2 medidas para se obter\n\nos per?s de condutividade e permissividade da tubula\u00e7\u00e3o, onde N \u00e9 o n\u00famero de\n\neletrodos. \u00c0 medida que o n\u00famero de eletrodos aumenta, aumenta-se o n\u00famero de\n\nmedi\u00e7\u00f5es e, consequentemente, o tempo de resposta do sistema torna-se cr\u00edtico. A\n\nutiliza\u00e7\u00e3o de ampli?cadores lock-in em paralelo torna-se, portanto, uma alternativa\n\nde grande interesse.\n\n\n\nCap\u00edtulo 4\n\nM\u00f3dulo de Comunica\u00e7\u00e3o CAN\n\nNeste cap\u00edtulo ser\u00e1 realizada, inicialmente, uma breve revis\u00e3o do protocolo de co-\n\nmunica\u00e7\u00e3o CAN (Controller Area Network), com \u00eanfase na descri\u00e7\u00e3o da camada de\n\nenlace de dados. Em seguida, ser\u00e1 apresentada a constru\u00e7\u00e3o de uma rede CAN, na\n\nqual cada m\u00f3dulo da rede \u00e9 implementado utilizando a placa de desenvolvimento com-\n\nercial SBC28PC, desenvolvida pela Moditronix Engineering, e o microntrolador PIC\n\n18F258, desenvolvido pela Microchip. Finalmente, ser\u00e3o discutidos a descri\u00e7\u00e3o em\n\nVHDL e o desenvolvimento em FPGA de um m\u00f3dulo CAN, al\u00e9m da sua integra\u00e7\u00e3o\n\n\u00e0 rede montada.\n\n4.1 Protocolo de Comunica\u00e7\u00e3o CAN\n\nCAN (Controller Area Network) \u00e9 um protocolo de comunica\u00e7\u00e3o serial desenvolvido\n\npela empresa alem\u00e3 Robert BOSCH, em meados dos anos 80 [28]. Foi inicialmente\n\nusado na automa\u00e7\u00e3o de autom\u00f3veis, com o objetivo de reduzir o cabeamento. At-\n\nualmente, o protocolo CAN vem sendo utilizado tamb\u00e9m em aplica\u00e7\u00f5es industriais,\n\nem redes de sensores e atuadores, incluindo ambientes intr\u00ednsecamente seguros. Al\u00e9m\n\ndisso, o protocolo CAN tamb\u00e9m vem sendo implementado em redes sem ?o.\n\nO protocolo CAN \u00e9 padronizado internacionalmente pela ISO 11898. Sua especi-\n\n?ca\u00e7\u00e3o abrange a Camada de Enlace e uma parte da Camada F\u00edsica, considerando o\n\nmodelo de refer\u00eancia ISO/OSI [28].\n\nNa descri\u00e7\u00e3o da Camada F\u00edsica, \u00e9 tratada a forma na qual s\u00e3o transmitidos os\n\nbits, de?nindo-se os valores f\u00edsicos para os bits 0 e 1, al\u00e9m dos tipos de cabeamento.\n\n83\n\n\n\n84\n\nA Camada de Enlace, por sua vez, \u00e9 subdividida nas camadas de Controle L\u00f3gico de\n\nEnlace e de Controle de Acesso ao Meio.\n\nNa subcamada de Controle L\u00f3gico de Enlace s\u00e3o determinadas as mensagens que\n\ndevem ser transmitidas no barramento. Tamb\u00e9m nesta subcamada s\u00e3o de?nidas quais\n\ndas mensagens recebidas ser\u00e3o descartadas e quais ser\u00e3o processadas pelo m\u00f3dulo\n\nreceptor. A descri\u00e7\u00e3o desta subcamada est\u00e1, portanto, mais voltada \u00e0 aplica\u00e7\u00e3o.\n\nO escopo da subcamada de Controle de Acesso ao Meio \u00e9 o protocolo de transfer-\n\n\u00eancia das mensagens. Nesta subcamada s\u00e3o realizadas as seguintes fun\u00e7\u00f5es: o controle\n\ndos quadros transmitidos, a execu\u00e7\u00e3o da arbitragem, a detec\u00e7\u00e3o e a corre\u00e7\u00e3o de erros.\n\nO foco deste trabalho \u00e9 a Camada de Enlace. Especi?camente, o objetivo inicial\n\n\u00e9 a implementa\u00e7\u00e3o das fun\u00e7\u00f5es realizadas pela subcamada de Controle de Acesso ao\n\nMeio, conforme ilustrado na Figura 4.1.\n\nFigura 4.1: Modelo de refer\u00eancia ISO/OSI aplicado ao protocolo CAN.\n\n4.1.1 Camada de Enlace\n\nA Camada de Enlace do protocolo CAN possui as seguintes caracter\u00edsticas principais:\n\n\u2022 Mensagens: as mensagens num barramento CAN s\u00e3o enviadas num formato\n\n?xo, podendo ter tamanhos diferentes, por\u00e9m limitados;\n\n\u2022 Roteamento de informa\u00e7\u00e3o: \u00e9 realizada considerando a estrat\u00e9gia produtor-\n\nconsumidor. Nenhum m\u00f3dulo no barramento CAN precisa possuir informa\u00e7\u00f5es\n\nsobre a con?gura\u00e7\u00e3o do sistema como, por exemplo, o endere\u00e7o das esta\u00e7\u00f5es.\n\nA transmiss\u00e3o no protocolo CAN \u00e9 orientada, portanto, pelo conte\u00fado da men-\n\nsagem. Toda mensagem possui um identi?cador, o qual \u00e9 \u00fanico na rede e de?ne\n\n\n\n85\n\no conte\u00fado e a prioridade da mensagem. O identi?cador n\u00e3o indica o destino\n\nda mensagem, por\u00e9m descreve o signi?cado dos dados. Portanto, cada m\u00f3dulo\n\nreceptor \u00e9 respons\u00e1vel pela ?ltragem das mensagens recebidas;\n\n\u2022 Multicast: todas as mensagens s\u00e3o enviadas para todos os m\u00f3dulos existentes\n\nna rede, cabendo a cada m\u00f3dulo decidir se ir\u00e1 ou n\u00e3o utilizar essa informa\u00e7\u00e3o\n\n(modelo de comunica\u00e7\u00e3o produtor-consumidor);\n\n\u2022 Multimestre: quando o barramento est\u00e1 livre, qualquer unidade conectada pode\n\niniciar a transmiss\u00e3o de uma nova mensagem. Portanto, todos os m\u00f3dulos\n\npodem ser tornar mestre num determinado momento e escravo em outro;\n\n\u2022 Arbitragem: se dois ou mais m\u00f3dulos iniciam a transmiss\u00e3o de mensagens si-\n\nmultaneamente, o con?ito de acesso ao barramento \u00e9 resolvido a partir de uma\n\narbitragem bit-a-bit n\u00e3o destrutiva. Todos os m\u00f3dulos veri?cam o estado do\n\nbarramento, analisando se outro m\u00f3dulo est\u00e1 enviando uma mensagem com\n\nmaior prioridade. Nesse sentido, os m\u00f3dulos comparam os n\u00edveis dosbits trans-\n\nmitidos e recebidos no barramento. Se esses n\u00edveis s\u00e3o iguais, o m\u00f3dulo deve\n\ncontinuar transmitindo. Quando umbit recessivo (n\u00edvel l\u00f3gico 1) \u00e9 transmitido\n\ne um bit dominante (n\u00edvel l\u00f3gico 0) \u00e9 recebido, o m\u00f3dulo perde a arbitragem\n\ne interrompe a transmiss\u00e3o. Ap\u00f3s a mensagem de maior prioridade ter sido\n\nrecebida, o m\u00f3dulo que perdeu a arbitragem reinicia a transmiss\u00e3o, de modo\n\nque nenhuma informa\u00e7\u00e3o \u00e9 perdida.\n\nO processo de arbitragem numa rede CAN \u00e9 ilustrado na Figura 4.2. Note que,\n\nneste exemplo, o n\u00f3 2 de comunica\u00e7\u00e3o est\u00e1 transmitindo uma mensagem de maior de\n\nprioridade que os n\u00f3s 1 e 3. O n\u00f3 2, portanto, assume o controle do barramento. Os\n\nn\u00f3s 1 e 3, por sua vez, interrompem a transmiss\u00e3o e aguardam at\u00e9 que o barramento\n\nesteja novamente livre.\n\nExistem quatro tipos de quadros utilizados no protocolo CAN:\n\n\u2022 Quadro de dados: utilizado na transfer\u00eancia de dados de um transmissor para\n\nos receptores;\n\n\u2022 Quadro remoto: enviado por uma unidade que solicita a transmiss\u00e3o de um\n\nquadro de dados com o mesmo identi?cador;\n\n\n\n86\n\nFigura 4.2: Exemplo de arbitragem numa rede CAN.\n\n\u2022 Quadro de erro: transmitido por uma unidade que detectou um erro no barra-\n\nmento;\n\n\u2022 Quadro de sobrecarga: transmitido para fornecer um retardo extra entre dois\n\nquadros de dados (ou remotos) consecutivos.\n\nNeste trabalho \u00e9 dada \u00eanfase na transmiss\u00e3o e recep\u00e7\u00e3o de quadros de dados e\n\nremotos.\n\nO protocolo CAN utiliza dois formatos de mensagens que se diferenciam pelo\n\ntamanho do campo de arbitragem. O primeiro formato (padr\u00e3o), denominado CAN\n\n2.0A, possui um identi?cador de 11 bits. O segundo formato (estendido), denomi-\n\nnado CAN 2.0B, possui um identi?cador de 29 bits. Cada formato \u00e9 ilustrado nas\n\nFiguras 4.3 e 4.4.\n\nFigura 4.3: Quadro padr\u00e3o com identi?cador de 11bits (CAN 2.0A).\n\nCada campo dos quadros das Figuras 4.3 e 4.4 \u00e9 apresentado a seguir:\n\n\n\n87\n\nFigura 4.4: Quadro estendido com identi?cador de 29bits (CAN 2.0B).\n\n\u2022 SOF(Start of Frame): marca o in\u00edcio dos quadros de dados e remotos. Consiste\n\nde um \u00fanicobit dominante (n\u00edvel l\u00f3gico 0);\n\n\u2022 IDENTIFIER: identi?cador da mensagem. No formato CAN 2.0A \u00e9 constitu\u00eddo\n\napenas do identi?cador padr\u00e3o de 11bits. J\u00e1 no formato CAN 2.0B s\u00e3o utilizados\n\nmais 18bits, pertencentes ao identi?cador estendido;\n\n\u2022 RTR (Remote Transmission Request): indica se o quadro \u00e9 de dados (RTR =\n\n0) ou remoto (RTR = 1). Como umbit dominante possui maior prioridade em\n\nrela\u00e7\u00e3o a um recessivo, um quadro de dados possui maior prioridade em rela\u00e7\u00e3o\n\na um quadro remoto de mesmo identi?cador;\n\n\u2022 SRR(Substitute Remote Request): bit transmitido apenas no formato estendido\n\n(CAN 2.0 B). \u00c9 sempre enviado como recessivo;\n\n\u2022 IDE (IDenti?er Extension): indica se a mensagem utiliza o formato padr\u00e3o\n\n(IDE = 0) ou estendido (IDE = 1). Note que uma mensagem no formato\n\npadr\u00e3o possui maior prioridade em rela\u00e7\u00e3o ao formato estendido;\n\n\u2022 R1 e R0: bits reservados. Devem ser sempre enviados como bits dominantes,\n\nembora os m\u00f3dulos receptores aceitem dominante e recessivo em qualquer com-\n\nbina\u00e7\u00e3o;\n\n\u2022 DLC(Data Length Code): campo formado por quatrobits que indicam o n\u00famero\n\ndebytes de dados da mensagem. Uma mensagem CAN pode conter at\u00e9 8bytes\n\nde dados (64bits).\n\n\u2022 DATA: consiste do dado a ser transmitido. Pode conter de 0 a 64bits;\n\n\u2022 CRC(Cyclical Redundance Check): constitu\u00eddo da sequ\u00eancia de CRC calculada\n\n(15bits) e de umbit delimitador enviado como recessivo;\n\n\n\n88\n\n\u2022 ACK(ACKnowledge): formado pelos bits ACK Slot e ACK Delimiter. ACK Slot\n\n\u00e9 sempre enviado como recessivo. Todas as esta\u00e7\u00f5es que receberam a mensagem\n\ncorretamente enviam nesse momento umbit dominante, validando a mensagem.\n\nObitACK Delimiter \u00e9 sempre recessivo;\n\n\u2022 EOF(End of Frame): sequ\u00eancia formada por 7bits recessivos que indicam o ?m\n\nde quadro;\n\n\u2022 IFS (Intermission Frame Space): n\u00famero m\u00ednimo de bits separando mensagens\n\nconsecutivas.\n\nA detec\u00e7\u00e3o de erros em sistemas CAN envolve basicamente os seguintes aspectos:\n\n\u2022 Monitoramento: ap\u00f3s a escrita de um bit dominante, o m\u00f3dulo transmissor\n\nveri?ca o estado do barramento. Se for recebido umbit recessivo, signi?ca que\n\nhouve um erro;\n\n\u2022 Bit Stu?ng: apenas cincobits consecutivos podem ter o mesmo valor (dominan-\n\nte ou recessivo). Caso seja necess\u00e1rio transmitir mais do que cincobits de mesmo\n\nvalor, o transmissor inserir\u00e1 umbit de valor contr\u00e1rio, o qual ser\u00e1 exclu\u00eddo pelo\n\nreceptor na reconstru\u00e7\u00e3o da mensagem;\n\n\u2022 Veri?ca\u00e7\u00e3o de quadro: os receptores analisam o conte\u00fado de alguns bits da\n\nmensagem recebida, os quais n\u00e3o mudam de mensagem para mensagem;\n\n\u2022 Reconhecimento de quadro: os receptores escrevem umbit dominante no campo\n\nde ACK(Acknowledgement) da mensagem, em resposta a uma mensagem rece-\n\nbida corretamente.\n\n\u2022 CRC(Cyclic Redundancy Check): o transmissor calcula um valor em fun\u00e7\u00e3o dos\n\nbits da mensagem e o transmite junto com ela. Os receptores recalculam o CRC\n\ne veri?cam se \u00e9 igual ao recebido.\n\nPara efetuar o c\u00e1lculo de CRC, \u00e9 de?nido um polin\u00f4mio cujos coe?cientes s\u00e3o da-\n\ndos pela sequ\u00eancia formada pelobit de In\u00edcio de Quadro e pelos campos de Arbitragem,\n\nControle e Dados. UmStu? Bit n\u00e3o \u00e9 considerado na forma\u00e7\u00e3o dessa sequ\u00eancia. Este\n\npolin\u00f4mio \u00e9 dividido pelo seguinte polin\u00f4mio gerador:\n\n\n\n89\n\nX15 + X14 + X10 + X8 + X7 + X4 + X3 + 1. (4.1)\n\nO CRC calculado \u00e9, portanto, igual ao resto dessa divis\u00e3o polinomial [29].\n\nSeja NXTBIT o pr\u00f3ximobit da sequ\u00eancia formada pelobit de In\u00edcio de Quadro at\u00e9\n\no \u00faltimobit do Campo de Dados. A sequ\u00eancia de CRC, armazenada num registrador\n\nde deslocamento de 15 bits denominado CRC_RG, pode ser calculada a partir do\n\nseguinte algoritmo:\n\nCRC_RG = 0;\n\nRepita at\u00e9 que inicie a transmiss\u00e3o do CRC ou ocorra um erro\n\nCRCNXT = NXTBIT exor CRC_RG(14);\n\nCRC_RG(14:1) = CRC_RG(13:0);\n\nCRC_RG(0) = 0;\n\nSe CRCNXT ent\u00e3o\n\nCRC_RG(14:0) = CRC_RG(14:0) exor (4599hex);\n\nFim Se\n\n4.1.2 Camada F\u00edsica\n\nNa Figura 4.5 s\u00e3o apresentados os n\u00edveis de tens\u00e3o num barramento CAN e suas\n\ncorrespond\u00eancias com as de?ni\u00e7\u00f5es debits dominantes e recessivos (n\u00edveis l\u00f3gicos 0 e\n\n1, respectivamente).\n\nFigura 4.5: Gr\u00e1?co dos n\u00edveis de tens\u00e3o num barramento CAN.\n\nPara efeitos de temporiza\u00e7\u00e3o e sincroniza\u00e7\u00e3o, umbit no protocolo CAN \u00e9 dividido\n\nem quatro segmentos de tempo, ilustrados na Figura 4.6. O comprimento de cada\n\n\n\n90\n\nsegmento de tempo \u00e9 dado por um m\u00faltiplo do time quantum (Tq). O time quantum\n\n\u00e9 uma unidade ?xa de tempo, derivada do per\u00edodo do oscilador (sinal de rel\u00f3gio do\n\nm\u00f3dulo CAN). A taxa de transmiss\u00e3o nominal dosbits no barramento CAN pode ser\n\nescolhida na faixa de 125 kbps a 1 Mbps.\n\nFigura 4.6: Divis\u00e3o em quatro segmentos de umbit no protocolo CAN.\n\n\u2022 SYNC_SEG: usado para sincronizar os v\u00e1rios n\u00f3s no barramento. A ocorr\u00eancia\n\nde uma transi\u00e7\u00e3o do sinal no barramento \u00e9 esperada durante este segmento.\n\nPossui o comprimento de 1 Tq;\n\n\u2022 PROP_SEG: usado para compensar os retardos f\u00edsicos no barramento. Possui\n\ncomprimento program\u00e1vel de 1 a 8 Tq;\n\n\u2022 PHASE_SEG1: usado para compensar os erros de fase. Possui comprimento\n\nprogram\u00e1vel de 1 a 8 Tq;\n\n\u2022 PHASE_SEG2: tamb\u00e9m usado para compensar os erros de fase. Possui com-\n\nprimento igual ao m\u00e1ximo entre o PHASE_SEG1 e o tempo de processamento\n\nda informa\u00e7\u00e3o, IPT(Information Processing Time).\n\nO IPT \u00e9 o segmento de tempo reservado para c\u00e1lculo do n\u00edvel dobit. Em outras\n\npalavras, \u00e9 o tempo que o m\u00f3dulo CAN leva para detectar se o bit lido no barra-\n\nmento possui n\u00edvel l\u00f3gico 0 ou n\u00edvel l\u00f3gico 1. O IPT inicia no ponto de amostragem\n\ndo barramento, que ocorre entre o PHASE_SEG1 e o PHASE_SEG2, possuindo\n\ncomprimento menor ou igual a 2 Tq.\n\nPara compensar os desvios de fase entre os osciladores de cada um dos n\u00f3s no\n\nbarramento, cada m\u00f3dulo CAN deve ser capaz de sincronizar-se durante uma tran-\n\nsi\u00e7\u00e3o do sinal no barramento de recessivo para dominante. Existem dois tipos de\n\nsincroniza\u00e7\u00e3o:\n\n\n\n91\n\n\u2022 Sincroniza\u00e7\u00e3o dura: ocorre sempre durante uma transi\u00e7\u00e3o de recessivo para\n\ndominante no in\u00edcio de quadro;\n\n\u2022 Resincroniza\u00e7\u00e3o: durante uma resincroniza\u00e7\u00e3o, o PHSEG1 pode ser aumen-\n\ntado (ou PHSEG2 reduzido). O quanto PHSEG1 \u00e9 aumentado (ou PHSEG2\n\nreduzido) \u00e9 de?nido pelo SJW (Synchronization Jump Width).\n\nNa pr\u00f3xima se\u00e7\u00e3o ser\u00e1 apresentada a implementa\u00e7\u00e3o de uma rede CAN utilizando\n\ndispositivos comerciais. Em seguida ser\u00e1 a discutida a implementa\u00e7\u00e3o em VHDL de\n\num m\u00f3dulo CAN, considerando os aspectos do protocolo CAN abordados nesta se\u00e7\u00e3o\n\nintrodut\u00f3ria.\n\n4.2 Implementa\u00e7\u00e3o de uma Rede CAN utilizando\n\nPlacas SBC28PC e Microcontroladores PIC\n\n18F258\n\nCom o objetivo de realizar um estudo pr\u00e1tico do protocolo CAN, foram realizados o\n\nprojeto, a constru\u00e7\u00e3o e a montagem de uma rede CAN, composta por dois m\u00f3dulos\n\nCAN, utilizando componentes comerciais.\n\nNeste trabalho foi utilizada a placa SBC28PC, desenvolvida pelaModtronix Engi-\n\nneering, contendo um microcontrolador PIC 18F258 e um transceptor CAN MCP2551,\n\ndesenvolvidos pelaMicrochip. O microcontrolador PIC 18F258 j\u00e1 possui um m\u00f3dulo\n\nde comunica\u00e7\u00e3o CAN integrado. O m\u00f3dulo transceptor CAN \u00e9 respons\u00e1vel apenas\n\npela convers\u00e3o dos sinais de 0V e 5V do microcontrolador para os n\u00edveis de tens\u00e3o\n\npadronizados pelo protocolo CAN.\n\nEsta rede tamb\u00e9m foi utilizada na valida\u00e7\u00e3o do m\u00f3dulo CAN descrito em VHDL\n\ne implementado em FPGA, que ser\u00e1 apresentado na pr\u00f3xima se\u00e7\u00e3o.\n\nPara programa\u00e7\u00e3o dos microcontroladores PIC foi utilizada a ferramenta de pro-\n\njeto MPLAB 8.36, da Microchip. Para grava\u00e7\u00e3o e depura\u00e7\u00e3o do programa foi utilizado\n\no programador e depurador ICD3, tamb\u00e9m da Microchip.\n\nPara visualiza\u00e7\u00e3o dos sinais no barramento CAN e veri?ca\u00e7\u00e3o da comunica\u00e7\u00e3o\n\nentre dois n\u00f3s na rede CAN (denominados N\u00f3 0 e N\u00f3 1), foi desenvolvida uma apli-\n\n\n\n92\n\nca\u00e7\u00e3o consistindo de dois m\u00f3dulos CAN implementados com duas placas SBC28PC,\n\nrealizando as seguintes opera\u00e7\u00f5es:\n\n\u2022 O N\u00f3 0 envia um quadro remoto solicitando um dado ao N\u00f3 1;\n\n\u2022 O N\u00f3 1 reconhece a solicita\u00e7\u00e3o do N\u00f3 0 e envia o dado solicitado (neste exemplo\n\n\u00e9 enviado o caractere ASCII \"A\");\n\n\u2022 O N\u00f3 0, ao receber a resposta do N\u00f3 1, envia o dado recebido ao PC (caractere\n\nASCII \"A\") atrav\u00e9s da interface serial RS-232.\n\nOs c\u00f3digos em linguagem ASSEMBLY utilizados na programa\u00e7\u00e3o dos microcon-\n\ntroladores PIC 18F258 s\u00e3o disponibilizados no Ap\u00eandice C.\n\nA montagem da rede CAN utilizando os m\u00f3dulos implementados com a placa\n\nSBC28PC e o microcontrolador PIC 18F258 \u00e9 apresentada na Figura 4.7. Os dois\n\nm\u00f3dulos CAN est\u00e3o interligados atrav\u00e9s de um par de ?os ao barramento CAN. Um\n\ntransceptor MCP 2551 extra, montado na matriz de contatos, tamb\u00e9m foi interligado\n\nao barramento para inser\u00e7\u00e3o do m\u00f3dulo CAN implementado em FPGA.\n\nFigura 4.7: Montagem da rede CAN com m\u00f3dulos SBC28PC e microcontroladores\nPIC 18F258.\n\nO quadro remoto enviado pelo N\u00f3 0 ao barramento CAN, com o N\u00f3 1 desconectado\n\ndo barramento, \u00e9 apresentado na Figura 4.8. A desconex\u00e3o do N\u00f3 1 neste exemplo\n\n\n\n93\n\nvisava o n\u00e3o reconhecimento da mensagem transmitida pelo N\u00f3 0, causando retrans-\n\nmiss\u00f5es, pelo N\u00f3 0, desta mensagem, de forma que fosse poss\u00edvel a visualiza\u00e7\u00e3o dos\n\nsinais no oscilosc\u00f3pio.\n\nFigura 4.8: Quadro remoto enviado pelo N\u00f3 0 ao barramento CAN com o N\u00f3 1\ndesconectado.\n\nNa Figura 4.8, as setas de n\u00famero 1 e 3 indicam o in\u00edcio de quadro. Os ret\u00e2ngulos\n\nA, B e C representam o identi?cador de 11 bits, o campo de controle e a sequ\u00eancia\n\nde CRC, respectivamente.\n\nUma vez que o N\u00f3 1 est\u00e1 desconectado do barramento, nenhum m\u00f3dulo ir\u00e1 enviar\n\no reconhecimento da mensagem do N\u00f3 0. Isto \u00e9 observado nobit ACK = 1, indicado\n\npela seta de n\u00famero 2. Consequentemente, o N\u00f3 0 enviar\u00e1 uma mensagem de erro (se-\n\nqu\u00eancia debits recessivos), representadada pelo ret\u00e2ngulo D e iniciar\u00e1 a retransmiss\u00e3o\n\nda mensagem.\n\nAp\u00f3s inserir o N\u00f3 1 na rede, a retransmiss\u00e3o da mensagem CAN pelo N\u00f3 0 foi\n\ninterrompida, uma vez que a mensagem passou a ser reconhecida. O N\u00f3 1, ent\u00e3o,\n\nenvia do dado solicitado. O N\u00f3 0, por sua vez, recebe a resposta do N\u00f3 1 e envia o\n\ncampo de dados da mensagem para o PC, via interface serial RS-232. O resultado \u00e9\n\napresentado no programa terminal, conforme ilustrado na Figura 4.9.\n\nNa Figura 4.9 s\u00e3o apresentados diversos caracteres ASCII \"A\". Cada caractere\n\nfoi recebido ap\u00f3s uma reinicializa\u00e7\u00e3o dos dispositivos presentes na rede CAN. \u00c0 cada\n\nreinicializa\u00e7\u00e3o, o N\u00f3 0 solicitava um dado e o N\u00f3 1 enviava a resposta (caractere\n\nASCII \"A\").\n\nO estado dos registradores internos do N\u00f3 0, obtidos com a ferramenta MPLAB e\n\no depurador ICD3 s\u00e3o apresentados na Figura 4.10.\n\n\n\n94\n\nFigura 4.9: Visualiza\u00e7\u00e3o das mensagens transmitidas na rede CAN a partir de um\nterminal serial no PC.\n\nObserva-se, a partir dos endere\u00e7os F41 e F42, o identi?cador da mensagem enviada\n\npelo N\u00f3 0: \"1110011001\". Os endere\u00e7os F61 e F62 apresentam o identi?cador da\n\nmensagem recebida pelo N\u00f3 0: \"1110011000\". E, ?nalmente, o endere\u00e7o F66 apresenta\n\no dado recebido: \"01000001\", que representa o caractere \"A\"no c\u00f3digo ASCII.\n\n4.3 M\u00f3dulo de Comunica\u00e7\u00e3o CAN Descrito em VHDL\n\ne Implementado em FPGA\n\nO projeto de um m\u00f3dulo de comunica\u00e7\u00e3o CAN possui uma complexidade relativa-\n\nmente alta. Por este motivo, foi utilizado novamente o conceito de \"dividir para\n\nconquistar\". Nesse sentido, entidades mais simples foram descritas em VHDL, no\n\nestilo RTL, desempenhando as fun\u00e7\u00f5es b\u00e1sicas do protocolo. Ap\u00f3s ser avaliado o\n\nfuncionamento dessas entidades mais simples, uma nova entidade foi de?nida, interli-\n\ngando hierarquicamente as entidades b\u00e1sicas, no estilo estrutural.\n\nO diagrama em blocos do m\u00f3dulo CAN \u00e9 apresentado na Figura 4.11. O m\u00f3dulo\n\n\u00e9 composto por quatro entidades b\u00e1sicas: CAN TX, CAN RX, STUFF HANDLER\n\ne CRC. A fun\u00e7\u00e3o de cada entidade \u00e9 discutida a seguir.\n\n\u2022 CAN TX: entidade respons\u00e1vel pelo envio das mensagens;\n\n\u2022 CAN RX: entidade respons\u00e1vel pelo empacotamento das mensagens recebidas;\n\n\u2022 STUFF HANDLER: entidade respons\u00e1vel pelo gerenciamento do stu? bit. In-\n\ndica \u00e0s entidades CAN TX e CAN RX a necessidade do envio ou o recebimento\n\nde umstu? bit;\n\n\n\n95\n\nFigura 4.10: Visualiza\u00e7\u00e3o do estado dos registradores internos do N\u00f3 0.\n\n\u2022 CRC: entidade respons\u00e1vel pelo c\u00e1lculo da sequ\u00eancia de CRC;\n\n\u2022 BIT TIMING 1 e BIT TIMING 2: entidades utilizadas para gerar os sinais de\n\ntemporiza\u00e7\u00e3o e o ponto de amostragem do barramento CAN.\n\n4.3.1 Simula\u00e7\u00f5es do M\u00f3dulo CAN em VHDL\n\nEsta se\u00e7\u00e3o apresenta, inicialmente, os resultados obtidos na simula\u00e7\u00e3o das entidades\n\nb\u00e1sicas atuando isoladamente. Em seguida, \u00e9 apresentada a simula\u00e7\u00e3o de todos os\n\ncomponentes interligados numa entidade principal.\n\nNa Figura 4.12 s\u00e3o apresentados os resultados obtidos na simula\u00e7\u00e3o da entidade\n\nBIT TIMING 1. Esta entidade tem a fun\u00e7\u00e3o principal de gerar o ponto de amostragem\n\npara a recep\u00e7\u00e3o de umbit no barramento CAN.\n\nNesta simula\u00e7\u00e3o foram utilizadas as seguintes premissas:\n\n\u2022 Frequ\u00eancia do Oscilador(Clock): 50 MHz;\n\n\n\n96\n\nFigura 4.11: Diagrama em blocos do m\u00f3dulo CAN descrito em VHDL.\n\n\u2022 Baud Rate Prescaler (BRP): 50;\n\n\u2022 PROP_SEG (PRSEG): 1 Tq;\n\n\u2022 PHASE_SEG1 (PSEG1): 3 Tq;\n\n\u2022 PHASE_SEG2 (PSEG2): 3 Tq;\n\n\u2022 SJW: 0.\n\nO time quantum (Tq) \u00e9 igual a\n\nTq =\nBRP\n\nClock\n=\n\n50\n\n50MHz\n= 1\u00b5s. (4.2)\n\nO tempo nominal de 1bit \u00e9 dado por\n\nTnominal,CAN = SY NC_SEG + PRSEG + PSEG1 + PSEG2. (4.3)\n\nLogo,\n\nTnominal,CAN = (1 + 1 + 3 + 3)Tq = 8Tq = 8\u00b5s. (4.4)\n\nPortanto, a taxa de transmiss\u00e3o \u00e9 dada por\n\nfnominal,CAN =\n1\n\nTnominal,CAN\n=\n\n1\n\n8\u00b5s\n= 125kbps. (4.5)\n\nA partir da Figura 4.12, observa-se que o ponto de amostragem(sample point) do\n\nbarramento ocorre entre PHASE_SEG1 e PHASE_SEG2. Al\u00e9m disso, dois pontos\n\nde amostragem consecutivos est\u00e3o separados por 8 Tq ou 1Tnominal,CAN.\n\n\n\n97\n\nFigura 4.12: Resutados obtidos na simula\u00e7\u00e3o da entidade BIT TIMING 1. O\nponto de amostragem ocorre entre PHASE_SEG1 e PHASE_SEG2. Dois pontos\nde amostragem consecutivos est\u00e3o separados por 8 Tq.\n\nNa Figura 4.13 s\u00e3o apresentados os resultados obtidos na simula\u00e7\u00e3o da entidade\n\nBIT TIMING 2. Esta entidade tem a fun\u00e7\u00e3o principal de gerar o ponto de transmiss\u00e3o\n\n(txpoint) para a transmiss\u00e3o de umbit no barramento CAN.\n\nNa simula\u00e7\u00e3o representada pela Figura 4.13 foram consideradas as mesmas pre-\n\nmissas utilizadas anteriormente. Note que dois pontos de transmiss\u00e3o consecutivos\n\nest\u00e3o separados por 8 Tq ou 1Tnominal,CAN.\n\nFigura 4.13: Resultados obtidos na simula\u00e7\u00e3o da entidade BIT TIMING 2. Dois\npontos de transmiss\u00e3o consecutivos est\u00e3o separados por 8 Tq.\n\nOs resultados obtidos na simula\u00e7\u00e3o da entidade STUFF HANDLER s\u00e3o apresen-\n\ntados nas Figuras 4.14 e 4.15.\n\nConforme ilustrado na Figura 4.14, um stu? bit \u00e9 gerado ap\u00f3s a amostragem de\n\ncincobits recessivos consecutivos no barramento.\n\nNa Figura 4.15 \u00e9 ilustrada a ocorr\u00eancia de um stu? error, ap\u00f3s a amostragem do\n\nsextobit recessivo consecutivo.\n\n\n\n98\n\nFigura 4.14: Resultados obtidos na simula\u00e7\u00e3o da entidade STUFF HANDLER. Um\nstu? bit \u00e9 gerado ap\u00f3s a amostragem de cincobits recessivos consecutivos.\n\nFigura 4.15: Resultados obtidos na simula\u00e7\u00e3o da entidade STUFF HANDLER. Um\nstu? error ocorre ap\u00f3s a amostragem do sextobit recessivo consecutivo.\n\nOs resultados obtidos na simula\u00e7\u00e3o da entidade CRC s\u00e3o apresentados nas Fi-\n\nguras 4.16 e 4.17.\n\nA partir da Figura 4.16 pode-se observar que a sequ\u00eancia de CRC \u00e9 calculada em\n\ncada amostragem do barramento, isto \u00e9, ap\u00f3s cada bit recebido.\n\nO c\u00e1lculo de CRC \u00e9 interrompido na ocorr\u00eancia de umstu? bit, conforme ilustrado\n\nna Figura 4.17. O c\u00e1lculo \u00e9 ?nalizado quandocrc_stop \u00e9 igual a 1.\n\nFigura 4.16: Resultados obtidos na simula\u00e7\u00e3o da entidade CRC. O c\u00e1lculo de CRC \u00e9\nrealizado ap\u00f3s cada bit recebido.\n\n\n\n99\n\nFigura 4.17: Resultados obtidos na simula\u00e7\u00e3o da entidade CRC. O c\u00e1lculo de CRC \u00e9\ninterrompido na ocorr\u00eancia de umstu? bit.\n\nNas Figuras 4.18 e 4.19 s\u00e3o apresentados os resultados obtidos na simula\u00e7\u00e3o da\n\nentidade CAN RX.\n\nConforme ilustrado na Figura 4.18, o identi?cador da mensagem recebida (id_rx =\n\n110011001112) \u00e9 armazenado ap\u00f3s doze pontos de amostragem, referentes ao bit de\n\nin\u00edcio de quadro e aos 11bits do identi?cador padr\u00e3o.\n\nO campo de dados da mensagem recebida \u00e9 composto por 1byte apenas (msg_rx =\n\n0001110102), conforme ilustrado na Figura 4.19. O CRC calculado \u00e9 dado por crc =\n\n0100110011010002.\n\nFigura 4.18: Resultados obtidos na simula\u00e7\u00e3o da entidade CAN RX. O identi?cador\nda mensagem recebida (id_rx = 110011001112) \u00e9 armazenado ap\u00f3s doze pontos de\namostragem.\n\nFinalmente, os resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX s\u00e3o ap-\n\nresentados nas Figuras 4.20, 4.21 e 4.22. Nesta simula\u00e7\u00e3o, foram instanciados um\n\nm\u00f3dulo transmissor, contendo a entidade CAN TX e um m\u00f3dulo receptor, contendo\n\numa entidade CAN RX. Tanto o transmissor quanto o receptor tamb\u00e9m possuiam\n\n\n\n100\n\nFigura 4.19: Resultados obtidos na simula\u00e7\u00e3o da entidade CAN RX. Mensagem re-\ncebida: msg_rx = 0001110102. CRC calculado: crc = 0100110011010002.\n\ncomponentes formados pelas entidades BIT TIMING 1, BIT TIMING 2, STUFF\n\nHANDLER e CRC.\n\nFigura 4.20: Resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX. Identi?cador a\nser transmitido: id_tx = 199C00016. Dado a ser transmitido: msg_tx = 3A16. CRC\na ser transmitido: crc_tx = 266816.\n\nA mensagem a ser transmitida possui identi?cador id_tx = 199C00016 e campo\n\nde dados composto por um byte, msg_tx = 3A16. O CRC calculado pelo m\u00f3dulo\n\ntransmissor \u00e9 crc_tx = 266816, conforme ilustrado na Figura 4.20.\n\nNa Figura 4.21 pode ser observado que o identi?cador, o campo de dados e o CRC\n\n\n\n101\n\nFigura 4.21: Resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX. Identi?cador\nrecebido: id_tx = 199C00016. Dado recebido: msg_tx = 3A16. CRC recebido:\ncrc_tx = 266816.\n\nrecebidos s\u00e3o iguais aos transmitidos. Al\u00e9m disso, conforme ilustrado na Figura 4.22,\n\numbit de reconhecimento \u00e9 enviado, ack_tx = 0, validando a transmiss\u00e3o.\n\nAp\u00f3s a valida\u00e7\u00e3o de todos os blocos individuais, uma entidade principal foi cri-\n\nada, interligando os componentes de forma estrutural. Em seguida, foi realizada a\n\nsimula\u00e7\u00e3o de uma rede CAN contendo tr\u00eas n\u00f3s de comunica\u00e7\u00e3o. Os resultados desta\n\nsimula\u00e7\u00e3o s\u00e3o apresentados nas Figuras 4.23 e 4.24.\n\nInicialmente, o N\u00f3 0 envia um quadro remoto solicitando um dado do N\u00f3 1, con-\n\nforme ilustrado na Figura 4.23. Tanto o N\u00f3 1 quanto o N\u00f3 2 validam a mensagem\n\ntransmitida pelo N\u00f3 0, enviando um bit de reconhecimento (ACK = 0). Em seguida,\n\no N\u00f3 1 envia o dado solicitado.\n\nAo receber a resposta do N\u00f3 1, o N\u00f3 0 envia um quadro remoto solicitando um\n\ndado ao N\u00f3 2, conforme ilustrado na Figura 4.24. Novamente, tanto o N\u00f3 1 quanto o\n\nN\u00f3 2 validam a mensagem do N\u00f3 0, enviando um bit de reconhecimento (ACK = 0).\n\nFinalmente, o N\u00f3 2 envia o dado solicitado.\n\n4.3.2 S\u00edntese do M\u00f3dulo CAN em VHDL\n\nOs resultados obtidos na s\u00edntese do m\u00f3dulo de comunica\u00e7\u00e3o CAN s\u00e3o apresentados a\n\nseguir. Neste trabalho foi utilizada a FPGAXilinx Spartan-3E XC3S500E -5 FG320.\n\n\n\n102\n\nFigura 4.22: Resultados obtidos na simula\u00e7\u00e3o da entidade CAN TX. Umbit de recon-\nhecimento \u00e9 enviado, ack_tx = 0, validando a transmiss\u00e3o.\n\nFigura 4.23: Resultados obtidos na simula\u00e7\u00e3o de uma rede CAN com tr\u00eas n\u00f3s. O N\u00f3\n0 envia um quadro remoto solicitando um dado do N\u00f3 1. Em seguida, o N\u00f3 1 envia\no dado solicitado.\n\nFigura 4.24: Resultados obtidos na simula\u00e7\u00e3o de uma rede CAN com tr\u00eas N\u00f3s. O N\u00f3\n0 envia um quadro remoto solicitando um dado do N\u00f3 2. Em seguida, o N\u00f3 2 envia\no dado solicitado.\n\n\n\n103\n\nTabela 4.1: Utiliza\u00e7\u00e3o de recursos l\u00f3gicos da FPGA ap\u00f3s a s\u00edntese do m\u00f3dulo CAN\nem VHDL.\n\nUsado Dispon\u00edvel Utiliza\u00e7\u00e3o\nSlice Flip-Flops 246 9312 2%\n\nLUTs de 4 entradas 507 9312 5%\nSlices 271 4656 5%\n\nTabela 4.2: Comparativo entre as entidades descritas no m\u00f3dulo de comunica\u00e7\u00e3o\nCAN implementado neste trabalho (A) e as entidades correspondentes no M\u00f3dulo\nHurriCANe (B), desenvolvido pela ESA (European Space Agency). O crit\u00e9rio de\navalia\u00e7\u00e3o usado foi a utiliza\u00e7\u00e3o l\u00f3gica do dispositivo.\n\nSlices Slice FFs LUTs\nA B A B A B\n\nBIT TIMING 1 31 31 22 22 58 56\nSTUFF HANDLER 9 6 13 6 15 9\n\nCRC 9 21 15 31 8 27\nCAN RX 141 264 131 258 258 202\nCAN TX 203 99 144 113 394 188\nTOTAL 393 421 325 430 733 482\n\nDe acordo com a Tabela 4.1, o m\u00f3dulo de comunica\u00e7\u00e3o CAN desenvolvido neste\n\ntrabalho utilizou apenas cerca de 5% dos recursos l\u00f3gicos da FPGA escolhida.\n\nNo sentido de avaliar a aloca\u00e7\u00e3o de recursos no projeto desenvolvido, foi realizado\n\num comparativo, ilustrado na Tabela 4.2, entre as entidades descritas no m\u00f3dulo de\n\ncomunica\u00e7\u00e3o CAN implementado neste trabalho, o qual ser\u00e1 integrado futuramente \u00e0\n\ninterface de rede MARIA (M\u00f3dulo de Acesso \u00e0 Rede para Instrumenta\u00e7\u00e3o Avan\u00e7ada),\n\ne as entidades correspondentes no M\u00f3dulo HurriCANe [47], desenvolvido pela ESA\n\n(European Space Agency). O crit\u00e9rio de avalia\u00e7\u00e3o usado foi a utiliza\u00e7\u00e3o l\u00f3gica do\n\ndispositivo. O c\u00f3digo VHDL do M\u00f3dulo HurriCANe, no passado disponibilizado\n\ngratuitamente, n\u00e3o estava mais \u00e0 disposi\u00e7\u00e3o durante a execu\u00e7\u00e3o deste trabalho, de\n\nforma que os resultados da s\u00edntese deste m\u00f3dulo foram obtidos na refer\u00eancia [49].\n\nComo pode ser observado na Tabela 4.2, a entidade BIT TIMING 1 do m\u00f3dulo de-\n\nsenvolvido neste trabalho utiliza praticamente a mesma quantidade de recursos l\u00f3gicos\n\nda entidade correspondente no m\u00f3dulo HurriCANe, com uma pequena desvantagem\n\nno n\u00famero de LUTs (Look-Up Tables). A entidade BIT TIMING 2 n\u00e3o possui cor-\n\n\n\n104\n\nrespondente no m\u00f3duloHurriCANe.\n\nAs entidades STUFF HANDLER e CAN TX desenvolvidas neste trabalho uti-\n\nlizam um n\u00famero maior de recursos l\u00f3gicos, comparado ao m\u00f3dulo HurriCANe. Em\n\ncompensa\u00e7\u00e3o, as entidades CRC e CAN RX utilizam uma quantidade de recursos\n\nl\u00f3gicos signi?cativamente menor, comparadas \u00e0s entidades correspondentes no m\u00f3-\n\nduloHurriCANe.\n\nDe modo geral, neste trabalho foi utilizada uma menor quantidade de Slices e\n\nSlices Flip-Flops. Em contrapartida, o m\u00f3duloHurriCANe utiliza um menor n\u00famero\n\nde LUTs de 4 entradas.\n\n4.3.3 Valida\u00e7\u00e3o em FPGA do M\u00f3dulo CAN em VHDL\n\nPara valida\u00e7\u00e3o do m\u00f3dulo CAN descrito em VHDL e implementado em FPGA, foi\n\nutilizada a rede CAN formada pelos m\u00f3dulos SBC28PC e microcontroladores PIC\n\n18F258.\n\nNa aplica\u00e7\u00e3o desenvolvida para teste do dispositivo, o m\u00f3dulo CAN implementado\n\nem FPGA \u00e9 respons\u00e1vel por enviar um byte de dados para um n\u00f3 da rede implemen-\n\ntado com o microcontrolador PIC atrav\u00e9s do barramento CAN. Este n\u00f3, por sua vez,\n\nenvia o byte de dados recebido pelo PIC para um PC via porta serial (RS-232).\n\nA montagem experimental do circuito \u00e9 apresentada na Figura 4.25.\n\nNesse exemplo, foi utilizado um quadro de dados com identi?cador padr\u00e3o re-\n\npresentado, em bin\u00e1rio, por \"11001100111\". O dado transmitido \u00e9 representado em\n\nbin\u00e1rio por \"00111010\". Os resultados obtidos s\u00e3o apresentados na Figura 4.26.\n\nNa Figura 4.26, as setas 1 e 3 indicam o in\u00edcio de um novo quadro de dados. J\u00e1\n\na seta 2 representa o bit de reconhecimento, ACK = 0, gerado pelos m\u00f3dulos PIC.\n\nPor sua vez, cada ret\u00e2ngulo representa um campo da mensagem, conforme descrito a\n\nseguir:\n\n\u2022 A: identi?cador da mensagem;\n\n\u2022 B: campo de controle;\n\n\u2022 C: campo de dados;\n\n\u2022 D: campo de CRC;\n\n\n\n105\n\nFigura 4.25: Montagem experimental da rede CAN com placas SBC28PC e micro-\ncontroladores PIC 18F258, incluindo o m\u00f3dulo CAN implementado em FPGA.\n\nFigura 4.26: Forma de onda obtida com o oscilosc\u00f3pio de um quadro de dados ap\u00f3s\nimplementa\u00e7\u00e3o do m\u00f3dulo CAN em FPGA.\n\n\u2022 E: ?m da mensagem.\n\n4.4 Implementa\u00e7\u00e3o em VHDL de Sensor Inteligente\n\ncom M\u00f3dulo CAN e Ampli?cador Sens\u00edvel \u00e0 Fase\n\nAp\u00f3s descri\u00e7\u00e3o em VHDL, exaustivas simula\u00e7\u00f5es, s\u00edntese, implementa\u00e7\u00e3o e veri?ca\u00e7\u00e3o\n\ndo funcionamento de cada bloco em FPGA, foi realizada a integra\u00e7\u00e3o do ampli?cador\n\nsens\u00edvel \u00e0 fase digital, apresentado no Cap\u00edtulo 3, ao m\u00f3dulo de comunica\u00e7\u00e3o CAN,\n\nabordado neste cap\u00edtulo. Os resultados obtidos s\u00e3o discutidos nesta se\u00e7\u00e3o.\n\n\n\n106\n\n4.4.1 S\u00edntese do Sensor Inteligente Implementado em FPGA\n\nOs resultados da s\u00edntese do sensor inteligente s\u00e3o apresentados na Tabela 4.3. Como\n\npode ser observado, o sensor utilizou cerca de 14% dos recursos l\u00f3gicos da FPGA.\n\nTabela 4.3: Utiliza\u00e7\u00e3o de recursos l\u00f3gicos da FPGA ap\u00f3s a s\u00edntese do sensor inteligente\nem VHDL.\n\nUsado Dispon\u00edvel Utiliza\u00e7\u00e3o\nSlice Flip-Flops 502 9312 5%\n\nLUTs de 4 entradas 1177 9312 12%\nSlices 652 4656 14%\n\n4.4.2 Valida\u00e7\u00e3o do Sensor Inteligente Implementado em FPGA\n\nPara valida\u00e7\u00e3o do sensor inteligente implementado em FPGA, foi criada uma apli-\n\nca\u00e7\u00e3o na qual os resultados das medi\u00e7\u00f5es efetuadas pelo ampli?cador sens\u00edvel \u00e0 fase\n\ns\u00e3o enviados atrav\u00e9s da rede de comunica\u00e7\u00e3o CAN.\n\nConforme discutido no Cap\u00edtulo 3, n\u00e3o foi poss\u00edvel realizar medi\u00e7\u00f5es reais com\n\no ampli?cador lock-in digital em FPGA, uma vez que a integra\u00e7\u00e3o deste dispositivo\n\naos conversores AD e DA da placa de desenvolvimento n\u00e3o foi efetuada. Portanto,\n\npara simular o sinal de entrada do ampli?cador sens\u00edvel \u00e0 fase, os valores que seriam\n\nfornecidos por um conversor AD foram gravados numa mem\u00f3ria ROM, descrita em\n\nVHDL e implementada na FPGA, externa ao sensor.\n\nEm seguida, os valores gravados nesta mem\u00f3ria ROM s\u00e3o processados pelo ampli-\n\n?cador sens\u00edvel \u00e0 fase e osbytes menos signi?cativos das palavras de 64bits correspon-\n\ndentes \u00e0s sa\u00eddas X e Y do ampli?cador lock-in s\u00e3o enviados atrav\u00e9s da rede CAN para\n\num m\u00f3dulo implementado com a placa SBC28PC e o microcontrolador PIC 18F258.\n\nEste m\u00f3dulo, por sua vez, envia os resultados obtidos para um PC atrav\u00e9s da porta\n\nserial. Finalmente, os resultados s\u00e3o exibidos no programa Terminal.\n\nNa Figura 4.27 s\u00e3o apresentados os valores dos bytes menos signi?cativos dos sinais\n\nde sa\u00edda dos canais X e Y. Neste caso, o sinal de entrada possui mesma amplitude,\n\nfrequ\u00eancia e fase do sinal de refer\u00eancia.\n\nConforme discutido no Cap\u00edtulo 3, as sa\u00eddas esperadas s\u00e3o X = 8399210 =\n\n101001000000110002 e Y = 0. Consequentemente, os valores dos bytes menos sig-\n\n\n\n107\n\nni?cativos dos sinais de sa\u00edda dos canais X e Y s\u00e3o \"00011000\"e \"00000000\", respec-\n\ntivamente.\n\nFigura 4.27: Representa\u00e7\u00e3o, a partir do programa Terminal, dosbytes menos signi?ca-\ntivos dos sinais de sa\u00edda dos canais X e Y : \"00011000\"e \"00000000\", respectivamente.\n\n4.5 Considera\u00e7\u00f5es Finais\n\nNeste cap\u00edtulo foram apresentados os resultados obtidos na implementa\u00e7\u00e3o de um\n\nm\u00f3dulo de comunica\u00e7\u00e3o CAN em VHDL e na integra\u00e7\u00e3o deste m\u00f3dulo ao ampli-\n\n?cador sens\u00edvel \u00e0 fase digital, abordado no Cap\u00edtulo 3. Tamb\u00e9m foi discutida a\n\nimplementa\u00e7\u00e3o de uma rede CAN utilizando m\u00f3dulos constru\u00eddos com placas de de-\n\nsenvolvimento SBC28PC e microcontroladores PIC.\n\nO funcionamento do m\u00f3dulo CAN descrito em VHDL foi validado a partir de sim-\n\nula\u00e7\u00f5es e de testes realizados ap\u00f3s a grava\u00e7\u00e3o da FPGA. Em particular, foi observado\n\na partir da inser\u00e7\u00e3o deste m\u00f3dulo \u00e0 rede CAN implementada, que este dispositivo\n\n\u00e9 capaz de se comunicar com outros m\u00f3dulos CAN, desenvolvidos por fabricantes\n\ncomerciais.\n\nO circuito sintetizado ocupou cerca de 5% dos recursos l\u00f3gicos da FPGA alvo.\n\nComparado ao m\u00f3dulo HurriCANe, desenvolvido pela ESA(European Space Agency),\n\nfoi observado que, de modo geral, neste trabalho foi utilizada uma menor quantidade\n\nde Slices e Slices Flip-Flops. Em compensa\u00e7\u00e3o, o m\u00f3dulo HurriCANe utiliza um\n\nmenor n\u00famero de LUTs de 4 entradas.\n\nA integra\u00e7\u00e3o do m\u00f3dulo CAN ao ampli?cador sens\u00edvel \u00e0 fase digital foi realizada\n\ncom sucesso. Al\u00e9m disso, foram ocupados apenas 14% dos recursos l\u00f3gicos da FPGA.\n\nIsto torna poss\u00edvel a futura integra\u00e7\u00e3o, numa mesma FPGA, destes m\u00f3dulos ao mi-\n\ncrocontrolador LAMPI\u00c3O e ao m\u00f3dulo de acesso \u00e0 rede MARIA.\n\n\n\nCap\u00edtulo 5\n\nConclus\u00f5es e Trabalhos Futuros\n\n5.1 Conclus\u00f5es\n\nEste trabalho \u00e9 uma contribui\u00e7\u00e3o para o projeto e o desenvolvimento de sensores\n\ninteligentes, na qual \u00e9 apresentada a arquitetura de um sensor inteligente integrado\n\nbaseada na fam\u00edlia de padr\u00f5es IEEE 1451. Em particular, neste trabalho s\u00e3o discu-\n\ntidas a descri\u00e7\u00e3o em VHDL e a implementa\u00e7\u00e3o em FPGA dos circuitos de medi\u00e7\u00e3o\n\ne condicionamento de sinais (ampli?cador sens\u00edvel \u00e0 fase) e de comunica\u00e7\u00e3o (m\u00f3dulo\n\nCAN).\n\nAs simula\u00e7\u00f5es realizadas e os resultados experimentais obtidos ap\u00f3s a implemen-\n\nta\u00e7\u00e3o em FPGA mostram que o ampli?cador sens\u00edvel \u00e0 fase desenvolvido funciona\n\nconforme esperado e pode, portanto, ser aplicado na medi\u00e7\u00e3o e no condicionamento\n\nde sinais, em especial na medi\u00e7\u00e3o de imped\u00e2ncias, desde que seja realizada a inte-\n\ngra\u00e7\u00e3o do ampli?cadorlock-in digital aos circuitos de convers\u00e3o AD e DA. Al\u00e9m disso,\n\numa vez que o circuito sintetizado ocupou apenas 6% dos recursos l\u00f3gicos da FPGA,\n\nv\u00e1rios ampli?cadores podem ser utilizados em paralelo, no mesmochip. Consequente-\n\nmente, aumenta-se o desempenho das medi\u00e7\u00f5es num equipamento de tomogra?a por\n\nimped\u00e2ncia el\u00e9trica para medi\u00e7\u00e3o de vaz\u00e3o de ?uxos multif\u00e1sicos, uma vez que a\n\nmedi\u00e7\u00e3o das tens\u00f5es em v\u00e1rios eletrodos podem ser feitas paralelamente, reduzindo o\n\ntempo de resposta do sistema de medi\u00e7\u00e3o.\n\nDo mesmo modo, as simula\u00e7\u00f5es realizadas e os resultados experimentais obtidos\n\nmostram que o m\u00f3dulo CAN, descrito em VHDL e implementado em FPGA, \u00e9 capaz\n\n108\n\n\n\n109\n\nde se comunicar em rede com outros m\u00f3dulos CAN, desenvolvidos por fabricantes\n\ncomerciais. O circuito sintetizado ocupou cerca de apenas 5% dos recursos l\u00f3gicos\n\nda FPGA alvo. O comparativo entre o m\u00f3dulo CAN desenvolvido e o m\u00f3dulo Hur-\n\nriCANe demonstra que as descri\u00e7\u00f5es em VHDL das entidades STUFF HANDLER e\n\nCAN TX podem ser melhoradas, a ?m de atingir uma menor utiliza\u00e7\u00e3o de recursos\n\nl\u00f3gicos. Em compensa\u00e7\u00e3o, as entidades CRC e CAN RX utilizam uma quantidade de\n\nrecursos l\u00f3gicos signi?cativamente menor, comparadas \u00e0s entidades correspondentes\n\nno m\u00f3duloHurriCANe.\n\nFinalmente, a integra\u00e7\u00e3o do m\u00f3dulo CAN ao ampli?cador sens\u00edvel \u00e0 fase digital\n\nfoi realizada com sucesso, sendo ocupados apenas 14% dos recursos l\u00f3gicos da FPGA,\n\no que possibilita a futura integra\u00e7\u00e3o destes m\u00f3dulos ao microcontrolador LAMPI\u00c3O\n\ne ao m\u00f3dulo de acesso \u00e0 rede MARIA, numa mesma FPGA.\n\nNa elabora\u00e7\u00e3o deste trabalho foram abordados diversos assuntos das \u00e1reas de\n\nmicroeletr\u00f4nica, projeto de circuitos integrados, sensores, instrumenta\u00e7\u00e3o, controle\n\nde processos, automa\u00e7\u00e3o industrial, redes de comunica\u00e7\u00e3o, entre outros. Esta vis\u00e3o\n\nmultidisciplinar possibilita que o conhecimento adquirido durante este trabalho possa\n\nser usado em outras implementa\u00e7\u00f5es.\n\n5.2 Trabalhos Futuros\n\nAlgumas sugest\u00f5es para continuidade do trabalho realizado s\u00e3o apresentadas a seguir:\n\n\u2022 Veri?car o desempenho do ampli?cador sens\u00edvel \u00e0 fase desenvolvido em FPGA\n\nna medi\u00e7\u00e3o de imped\u00e2ncias e estimar seus limites de opera\u00e7\u00e3o: faixa de medi\u00e7\u00e3o,\n\nresolu\u00e7\u00e3o, etc.;\n\n\u2022 Veri?car o desempenho do m\u00f3dulo de comunica\u00e7\u00e3o CAN desenvolvido em FPGA\n\nnuma rede com maior n\u00famero de n\u00f3s, sujeito a maior tr\u00e1fego de mensagens e\n\nseguindo padr\u00f5es de certi?ca\u00e7\u00e3o internacionais;\n\n\u2022 Veri?car o desempenho do sensor inteligente proposto aplicado \u00e0 tomogra?a por\n\nimped\u00e2ncia el\u00e9trica;\n\n\u2022 Implementar o ampli?cador sens\u00edvel \u00e0 fase, o m\u00f3dulo de comunica\u00e7\u00e3o CAN, o\n\nmicrocontrolador LAMPI\u00c3O e a interface de rede MARIA numa mesma FPGA;\n\n\n\n110\n\n\u2022 Integrar o ampli?cador sens\u00edvel \u00e0 fase, o m\u00f3dulo de comunica\u00e7\u00e3o CAN, o mi-\n\ncrocontrolador LAMPI\u00c3O e a interface de rede MARIA em ASIC.\n\n\n\nAp\u00eandice A\n\nC\u00f3digos VHDL\n\nNeste ap\u00eandice est\u00e3o listados os c\u00f3digos VHDL do sensor inteligente desenvolvido e\n\nde seus subcircuitos.\n\nA.1 Sensor Inteligente\n\n--------------------------------------------------------------------------\n-- UFPE - Universidade Federal de Pernambuco\n-- PPGEE - Programa de P\u00f3s-Gradua\u00e7\u00e3o em Engenharia El\u00e9trica\n-- LDN - Laborat\u00f3rio de Dispositivos e Nanoestruturas\n--------------------------------------------------------------------------\n-- PROJETO : Sensor Inteligente (Smart Transducer Interface Module)\n-- SUBPROJETO : STIM\n-- DESCRI\u00c7\u00c3O : M\u00f3dulo principal da arquitetura estrutural do STIM Sensor\n-- VERS\u00c3O : 0.0\n-- CRIADO : 20/05/2010\n-- MODIFICADO : 20/05/2010\n-- SIMULADO : 20/05/2010\n-- SINTETIZADO : 20/05/2010\n-- IMPLEMENTADO: 20/05/2010\n-- TESTADO : 20/05/2010\n-- PROJETISTA : Eng. Jos\u00e9 E. O. Reges\n-- ORIENTADOR : Prof. Edval J. P. Santos\n--------------------------------------------------------------------------\n-- COMENT\u00c1RIOS :\n-- [1] M\u00f3dulo principal da arquitetura estrutural do STIM Sensor\n-- CONTROLE DE VERS\u00c3O\n-- [1] Vers\u00e3o 0.0 - 20/05/2010 - Vers\u00e3o inicial.\n--------------------------------------------------------------------------\n\nlibrary ieee;\n\n111\n\n\n\n112\n\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\nuse ieee.numeric_std.all;\n\nentity STIM is\ngeneric (N1: integer := 12 ;\n\nN2: integer := 64);\nport (Clock : in std_logic;\nReset : in std_logic;\nLOCK_IN_Canal : in std_logic;\nCAN_Tx_Req : in std_logic;\nCAN_Rx_Bit : in std_logic;\nCAN_Tx_Bit : out std_logic;\nLOCK_IN_Saida : out std_logic_vector (7 downto 0));\nend STIM;\n\narchitecture Estrutural of STIM is\n\n-- Declara\u00e7\u00e3o dos componentes\n\n-- M\u00f3dulo CAN\n\ncomponent CAN_Module\nport (Clock : in std_logic;\nReset : in std_logic;\nCAN_Rx_Bit : in std_logic;\nCAN_Tx_Req : in std_logic;\nCAN_RTR : in std_logic;\nCAN_IDE : in std_logic;\nCAN_DLC : in std_logic_vector( 3 downto 0);\nCAN_BRP : in std_logic_vector( 5 downto 0);\nCAN_PRSEG : in std_logic_vector( 2 downto 0);\nCAN_PSEG1 : in std_logic_vector( 2 downto 0);\nCAN_PSEG2 : in std_logic_vector( 2 downto 0);\nCAN_SJW : in std_logic_vector( 1 downto 0);\nCAN_ID_Tx : in std_logic_vector(28 downto 0);\nCAN_MSG_Tx : in std_logic_vector(63 downto 0);\nCAN_ID_Rx : out std_logic_vector(28 downto 0);\nCAN_MSG_Rx : out std_logic_vector(63 downto 0);\nCAN_Tx_Busy: out std_logic;\nCAN_Tx_Comp: out std_logic;\nCAN_Rx_Busy: out std_logic;\nCAN_Rx_Comp: out std_logic;\nCAN_Tx_Bit : out std_logic);\nend component;\n\n-- Amplificador Lock-in\n\n\n\n113\n\ncomponent Lockin\ngeneric (N1: integer := 12 ;\n\nN2: integer := 64);\nport (Relogio : in std_logic ;\n\nReinicio : in std_logic ;\nFim_Conv_AD : in std_logic ;\nEntrada_REG_AD: in std_logic_vector (N1-1 downto 0) ;\nFaca_Conv_DA : out std_logic ;\nFaca_Conv_AD : out std_logic ;\nSaida_REG_DA : out std_logic_vector (N1-1 downto 0) ;\nSaida_X : out std_logic_vector (N2-1 downto 0) ;\nSaida_Y : out std_logic_vector (N2-1 downto 0));\nend component;\n\n-- Simula Conversor AD\n\ncomponent ROM is\nport (Endereco : in STD_LOGIC_VECTOR ( 6 downto 0 );\nSaida : out STD_LOGIC_VECTOR ( 11 downto 0 ));\nend component;\n\n-- Declara\u00e7\u00e3o dos sinais internos\n\n-- M\u00f3dulo CAN\n\nsignal CAN_RTR : std_logic := '0';\nsignal CAN_IDE : std_logic := '0';\nsignal CAN_DLC : std_logic_vector( 3 downto 0) := (others => '0');\nsignal CAN_BRP : std_logic_vector( 5 downto 0) := (others => '0');\nsignal CAN_PRSEG : std_logic_vector( 2 downto 0) := (others => '0');\nsignal CAN_PSEG1 : std_logic_vector( 2 downto 0) := (others => '0');\nsignal CAN_PSEG2 : std_logic_vector( 2 downto 0) := (others => '0');\nsignal CAN_SJW : std_logic_vector( 1 downto 0) := (others => '0');\nsignal CAN_ID_Tx : std_logic_vector(28 downto 0) := (others => '0');\nsignal CAN_MSG_Tx : std_logic_vector(63 downto 0) := (others => '0');\nsignal CAN_ID_Rx : std_logic_vector(28 downto 0) := (others => '0');\nsignal CAN_MSG_Rx : std_logic_vector(63 downto 0) := (others => '0');\nsignal CAN_Tx_Busy: std_logic := '0';\nsignal CAN_Tx_Comp: std_logic := '0';\nsignal CAN_Rx_Busy: std_logic := '0';\nsignal CAN_Rx_Comp: std_logic := '0';\n\n-- Amplificador Lock-in\n\nsignal Fim_Conv_AD : std_logic := '1';\nsignal Entrada_REG_AD: std_logic_vector (N1-1 downto 0);\n\n\n\n114\n\nsignal Faca_Conv_DA : std_logic ;\nsignal Faca_Conv_AD : std_logic ;\nsignal Saida_REG_DA : std_logic_vector (N1-1 downto 0);\nsignal Saida_X : std_logic_vector (N2-1 downto 0);\nsignal Saida_Y : std_logic_vector (N2-1 downto 0);\n\n-- Simula Conversor AD\n\nsignal Temporizador : integer range 0 to 19;\nsignal contador : std_logic_vector (6 downto 0);\n\nbegin\n\n-- Interliga\u00e7\u00e3o dos componentes\n\n-- M\u00f3dulo CAN\n\nX2: CAN_Module port map\n(\nClock => Clock,\nReset => Reset,\nCAN_Rx_Bit => CAN_Rx_Bit,\nCAN_Tx_Req => CAN_Tx_Req,\nCAN_RTR => CAN_RTR,\nCAN_IDE => CAN_IDE,\nCAN_DLC => CAN_DLC,\nCAN_BRP => CAN_BRP,\nCAN_PRSEG => CAN_PRSEG,\nCAN_PSEG1 => CAN_PSEG1,\nCAN_PSEG2 => CAN_PSEG2,\nCAN_SJW => CAN_SJW,\nCAN_ID_Tx => CAN_ID_Tx,\nCAN_MSG_Tx => CAN_MSG_Tx,\nCAN_ID_Rx => CAN_ID_Rx,\nCAN_MSG_Rx => CAN_MSG_Rx,\nCAN_Tx_Busy => CAN_Tx_Busy,\nCAN_Tx_Comp => CAN_Tx_Comp,\nCAN_Rx_Busy => CAN_Rx_Busy,\nCAN_Rx_Comp => CAN_Rx_Comp,\nCAN_Tx_Bit => CAN_Tx_Bit\n);\n\n-- Amplificador Lock-in\n\nX1: Lockin port map (Clock,\nReset,\n\nFim_Conv_AD,\n\n\n\n115\n\nEntrada_REG_AD,\nFaca_Conv_DA,\nFaca_Conv_AD,\nSaida_REG_DA,\nSaida_X,\nSaida_Y);\n\n-- Simula Conversor AD\n\nX0: ROM port map (contador, Entrada_REG_AD);\n\n-- L\u00f3gica de Controle do STIM\n\n-- Escolhe o canal de sa\u00edda do Lock-in que ser\u00e1 exibido\nnos LEDs da Placa e enviado pelo CAN\n\nprocess(LOCK_IN_Canal, Saida_X, Saida_Y)\nbegin\nif LOCK_IN_Canal = '0' then\nLOCK_IN_Saida (7 downto 0)&lt;= Saida_X (7 downto 0);\nCAN_MSG_Tx(63 downto 56)&lt;= Saida_X (7 downto 0);\nelse\nLOCK_IN_Saida (7 downto 0)&lt;= Saida_Y (7 downto 0);\nCAN_MSG_Tx(63 downto 56)&lt;= Saida_Y (7 downto 0);\nend if;\nend process;\n\n--CAN_MSG_Tx(63 downto 56)&lt;= \"11001110\";\n\n-- Simula fim de convers\u00e3o AD\n\nprocess (Clock)\nbegin\n\nif Reset = '1' then\nTemporizador&lt;= 0;\nFim_Conv_AD&lt;= '1';\n\nelsif Clock'event and Clock = '1' then\nif Temporizador = 19 then\n\nTemporizador&lt;= 0;\nFim_Conv_AD&lt;= '0';\n\nelse\nTemporizador&lt;= Temporizador + 1;\nFim_Conv_AD&lt;= '1';\n\nend if;\nend if;\n\nend process;\n\n\n\n116\n\n-- Incrementa endere\u00e7o da ROM que simula sinal de saida do\nconversor AD\n\nprocess(Faca_Conv_AD, Reset)\nbegin\n\nif Reset = '1' then\ncontador&lt;= (others => '0');\n\nelsif Faca_Conv_AD'event and Faca_Conv_AD = '1' then\nif contador = \"1111111\" then\n\ncontador&lt;= (others => '0');\nelse\n\ncontador&lt;= contador+1;\nend if;\n\nend if;\nend process;\n\n-- Configura os campos da mensagem a ser transmitida\n\nCAN_RTR&lt;= '0'; -- Transmiss\u00e3o de Quadro de Dados\nCAN_IDE&lt;= '0'; -- Transmiss\u00e3o de Identificador Padr\u00e3o\nCAN_DLC&lt;= \"0001\"; -- Transmiss\u00e3o de 01 Byte de Dados\n\n-- Configura os segmentos de tempo de um bit CAN\n\n-- SyncSeg = 1 Tq\n-- PropSeg = 1 Tq\n-- PhaseSeg1 = 3 Tq\n-- PhaseSeg2 = 3 Tq\n-- SJW = 0 Tq\n\n-- Nominal Bit Rate = 125 kbps\n-- Nominal Bit Time = 8 us\n-- TimeQuantum (Tq) = 1 us\n-- Baud Rate (BRP) = 50\n\nCAN_BRP&lt;= \"110010\";\nCAN_PRSEG&lt;= \"001\";\nCAN_PSEG1&lt;= \"011\";\nCAN_PSEG2&lt;= \"011\";\nCAN_SJW&lt;= \"00\" ;\n\n-- Configura mensagem a ser transmitida\n\nCAN_ID_Tx (28 downto 18)&lt;= \"11100110000\";\n\nend Estrutural;\n\n\n\n117\n\nA.2 Ampli?cador Sens\u00edvel \u00e0 Fase\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Lockin is\ngeneric (N1: integer := 12 ;\n\nN2: integer := 64);\nport (Relogio : in std_logic ;\n\nReinicio : in std_logic ;\nFim_Conv_DA : in std_logic ;\nFim_Conv_AD : in std_logic ;\nEntrada_REG_AD: in std_logic_vector (N1-1 downto 0) ;\nFaca_Conv_DA : out std_logic ;\nFaca_Conv_AD : out std_logic ;\nSaida_REG_DA : out std_logic_vector (N1-1 downto 0) ;\nSaida_X : out std_logic_vector (N2-1 downto 0) ;\nSaida_Y : out std_logic_vector (N2-1 downto 0));\nend Lockin;\n\narchitecture Estrutural of Lockin is\n\ncomponent Sequenciador is\nport (Relogio : in std_logic;\n\nReinicio : in std_logic;\nFim_Conv_DA : in std_logic;\nFim_Conv_AD : in std_logic;\nLimpe_Registradores: out std_logic;\nCarregue_REG_DA : out std_logic;\nFaca_Conv_DA : out std_logic;\nFaca_Conv_AD : out std_logic;\nCarregue_REG_AD : out std_logic;\nCarregue_REG_FASE: out std_logic;\nCarregue_REG_QUAD: out std_logic;\nMultiplique : out std_logic;\nSome : out std_logic;\nDesloque_Soma : out std_logic;\nCarregue_X_Y : out std_logic;\nEndereco : out std_logic_vector (6 downto 0));\nend component;\n\ncomponent ROM is\nport (\n\nEndereco : in STD_LOGIC_VECTOR ( 6 downto 0 );\nSaida : out STD_LOGIC_VECTOR ( 11 downto 0 ));\n\nend component;\n\n\n\n118\n\ncomponent Registrador is\ngeneric (N: integer := 12);\nport (Relogio: in std_logic;\n\nLimpa : in std_logic;\nEntrada: in std_logic_vector (N-1 downto 0) ;\n\nSaida : out std_logic_vector (N-1 downto 0));\nend component;\n\ncomponent Detetor_Fase is\ngeneric (N : integer := 12 ;\n\nN2 : integer := 24);\nport (Relogio : in std_logic;\n\nLimpa : in std_logic;\nEntrada0: in std_logic_vector (N-1 downto 0);\nEntrada1: in std_logic_vector (N-1 downto 0);\n\nSaida : out std_logic_vector (2*N-1 downto 0));\nend component;\n\ncomponent Filtro_PB is\ngeneric (N1: integer := 24 ;\n\nN2: integer := 64);\nport (Relogio : in std_logic;\n\nLimpa_Parcial : in std_logic;\nLimpa : in std_logic;\n\nSome : in std_logic;\nDesloque : in std_logic;\nCarregue_Saida: in std_logic;\n\nEntrada : in std_logic_vector (N1-1 downto 0);\nSaida : out std_logic_vector (N2-1 downto 0));\n\nend component;\n\nsignal Limpe_Registradores, Carregue_REG_DA, Carregue_REG_AD,\nCarregue_REG_FASE, Carregue_REG_QUAD,\nMultiplique, Some, Desloque_Soma, Carregue_X_Y : std_logic;\n\nsignal Saida_ROM, Saida_REG_AD, Saida_REG_FASE,\nSaida_REG_QUAD: std_logic_vector (N1-1 downto 0);\nsignal Saida_Detector_X, Saida_Detector_Y:\nstd_logic_vector (2*N1-1 downto 0);\n\nsignal Endereco : std_logic_vector (6 downto 0);\n\nbegin\n\nREG_DA: Registrador generic map (N1) port map (Carregue_REG_DA,\n\n\n\n119\n\nReinicio ,\nSaida_ROM ,\nSaida_REG_DA );\n\nREG_AD: Registrador generic map (N1) port map (Carregue_REG_AD,\nReinicio ,\n\nEntrada_REG_AD ,\nSaida_REG_AD );\n\nREG_FASE: Registrador generic map (N1) port map (Carregue_REG_FASE,\nReinicio ,\n\nSaida_ROM ,\nSaida_REG_FASE );\n\nREG_QUAD: Registrador generic map (N1) port map (Carregue_REG_QUAD,\nReinicio ,\n\nSaida_ROM ,\nSaida_REG_QUAD );\n\nSEQUENCIADOR0: Sequenciador port map (Relogio,\nReinicio,\n\nFim_Conv_DA,\nFim_Conv_AD,\nLimpe_Registradores,\nCarregue_REG_DA,\nFaca_Conv_DA,\nFaca_Conv_AD,\nCarregue_REG_AD,\nCarregue_REG_FASE,\nCarregue_REG_QUAD,\nMultiplique,\nSome,\nDesloque_Soma,\nCarregue_X_Y,\nEndereco);\n\nROM0: ROM port map (Endereco, Saida_ROM);\n\nDETECTOR_X: Detetor_Fase port map (Multiplique,\nReinicio,\n\nSaida_REG_AD,\nSaida_REG_FASE,\nSaida_Detector_X);\n\nDETECTOR_Y: Detetor_Fase port map (Multiplique,\nReinicio,\n\nSaida_REG_AD,\n\n\n\n120\n\nSaida_REG_QUAD,\nSaida_Detector_Y);\n\nFILTRO_X: Filtro_PB port map (Relogio,\nLimpe_Registradores,\nReinicio,\n\nSome,\nDesloque_Soma,\nCarregue_X_Y,\nSaida_Detector_X,\nSaida_X);\n\nFILTRO_Y: Filtro_PB port map (Relogio,\nLimpe_Registradores,\nReinicio,\n\nSome,\nDesloque_Soma,\nCarregue_X_Y,\nSaida_Detector_Y,\nSaida_Y);\n\nend Estrutural;\n\nA.2.1 Sequenciador\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Sequenciador is\nport (Relogio : in std_logic;\n\nReinicio : in std_logic;\nFim_Conv_DA : in std_logic;\nFim_Conv_AD : in std_logic;\nLimpe_Registradores : out std_logic;\nCarregue_REG_DA : out std_logic;\nFaca_Conv_DA : out std_logic;\nFaca_Conv_AD : out std_logic;\nCarregue_REG_AD : out std_logic;\nCarregue_REG_FASE : out std_logic;\nCarregue_REG_QUAD : out std_logic;\nMultiplique : out std_logic;\nSome : out std_logic;\nDesloque_Soma : out std_logic;\nCarregue_X_Y : out std_logic;\nEndereco : out std_logic_vector (6 downto 0));\n\n\n\n121\n\nend Sequenciador;\n\narchitecture RTL of Sequenciador is\n\n-- Defini\u00e7\u00e3o dos estados da m\u00e1quina seq\u00fcencial. A fun\u00e7\u00e3o de cada\n-- estado est\u00e1 expl\u00edcita pelo r\u00f3tulo utilizado.\n\ntype estados is (Reiniciar ,\nCarregar_REG_DA ,\nFazer_Conv_DA ,\n\nFazer_Conv_AD ,\nCarregar_REG_AD ,\n\nCarregar_REG_FASE,\nCarregar_REG_QUAD,\nMultiplicar ,\nSomar ,\nDeslocar_Soma ,\nCarregar_X_Y );\n\nsignal estado : estados ;\nsignal contador_7 : std_logic_vector (2 downto 0);\nsignal contador_128 : std_logic_vector (6 downto 0);\nsignal contador_endereco: std_logic_vector (6 downto 0);\nsignal end_reg_fase : std_logic_vector (6 downto 0);\nsignal end_reg_quad : std_logic_vector (6 downto 0);\n\nsignal contador_amostragem: std_logic_vector (8 downto 0);\nsignal Tamostragem : std_logic;\n\nbegin\n\n-- Rel\u00f3gio de amostragem\n\nprocess (Relogio, Reinicio)\nbegin\nif Reinicio = '1' then\ncontador_amostragem&lt;= (others => '0');\nTamostragem&lt;= '0';\nelsif Relogio'event and Relogio = '1' then\nif contador_amostragem = \"110000111\" then -- 391\ncontador_amostragem&lt;= (others => '0');\nTamostragem&lt;= '1';\nelse\ncontador_amostragem&lt;= contador_amostragem+1;\nTamostragem&lt;= '0';\nend if;\n\n\n\n122\n\nend if;\nend process;\n\n-- In\u00edcio da Transi\u00e7\u00e3o de Estados\n\nprocess (Relogio, Reinicio)\nbegin\nif Reinicio = '1' then\nestado&lt;= Reiniciar;\nelsif Relogio'event and Relogio = '1' then\ncase estado is\nwhen Reiniciar =>\nif Tamostragem = '1' then\nestado&lt;= Carregar_REG_DA ;\nend if;\nwhen Carregar_REG_DA => estado&lt;= Fazer_Conv_DA ;\nwhen Fazer_Conv_DA => estado&lt;= Fazer_Conv_AD ;\nif Fim_Conv_DA = '1' then\nestado&lt;= Fazer_Conv_AD;\nend if;\nwhen Fazer_Conv_AD =>\nif Fim_Conv_AD = '0' then\nestado&lt;= Carregar_REG_AD;\nend if;\nwhen Carregar_REG_AD => estado&lt;= Carregar_REG_FASE;\nwhen Carregar_REG_FASE => estado&lt;= Carregar_REG_QUAD;\nwhen Carregar_REG_QUAD => estado&lt;= Multiplicar ;\nwhen Multiplicar => estado&lt;= Somar ;\nwhen Somar =>\nif contador_128 = \"1111111\" then\nestado&lt;= Deslocar_Soma;\nelse\nestado&lt;= Carregar_REG_DA;\nend if;\nwhen Deslocar_Soma =>\nif contador_7 = \"111\" then -- 111\nestado&lt;= Carregar_X_Y ;\nend if;\nwhen Carregar_X_Y => estado&lt;= Reiniciar; -- Carregar_REG_DA ;\nend case;\nend if;\nend process;\n\n-- Fim da Transi\u00e7\u00e3o de Estados\n\n-- In\u00edcio das Equa\u00e7\u00f5es de Sa\u00edda\n\n\n\n123\n\nprocess (estado)\nbegin\ncase estado is\nwhen Reiniciar =>\nLimpe_Registradores&lt;= '1';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= (others => '0');\nwhen Carregar_REG_DA =>\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '1';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\nwhen Fazer_Conv_DA =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '1';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\nwhen Fazer_Conv_AD =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '0';\n\n\n\n124\n\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\nwhen Carregar_REG_AD =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '1';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= end_reg_fase;\nwhen Carregar_REG_FASE =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '1';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= end_reg_quad;\nwhen Carregar_REG_QUAD =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '1';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\n\n\n\n125\n\nwhen Multiplicar =>\nLimpe_Registradores&lt;= '0';\n\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '1';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\nwhen Somar =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '1';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\nwhen Deslocar_Soma =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '1';\nCarregue_X_Y&lt;= '0';\nEndereco&lt;= contador_endereco;\nwhen Carregar_X_Y =>\n\nLimpe_Registradores&lt;= '0';\nCarregue_REG_DA&lt;= '0';\nFaca_Conv_DA&lt;= '0';\nFaca_Conv_AD&lt;= '1';\nCarregue_REG_AD&lt;= '0';\nCarregue_REG_FASE&lt;= '0';\nCarregue_REG_QUAD&lt;= '0';\n\n\n\n126\n\nMultiplique&lt;= '0';\nSome&lt;= '0';\nDesloque_Soma&lt;= '0';\nCarregue_X_Y&lt;= '1';\nEndereco&lt;= contador_endereco;\nend case;\nend process;\n\n-- Fim das Equa\u00e7\u00f5es de Sa\u00edda\n\n-- In\u00edcio do Contador Mod(7)\n\n-- Usado para realizar o deslocamento da soma para direita 7 vezes,\n-- isto \u00e9, dividir o total acumulado por 128 (n\u00famero de pontos).\n\nprocess (Relogio, Reinicio)\nbegin\nif Reinicio = '1' then\ncontador_7&lt;= (others => '0');\nelsif Relogio'event and Relogio = '1' then\nif estado = Deslocar_Soma then\nif contador_7 = \"111\" then\ncontador_7&lt;= (others => '0');\nelse\ncontador_7&lt;= contador_7 + 1;\nend if;\nend if;\nend if;\nend process;\n\n-- Fim do Contador Mod(7)\n\n-- In\u00edcio do Contador Mod(128)\n\n-- Usado para contar o n\u00famero de pontos que foram gerados,\nadquiridos e tratados.\n\nprocess (Relogio, Reinicio)\nbegin\nif Reinicio = '1' then\ncontador_128&lt;= (others => '0');\nelsif Relogio'event and Relogio = '1' then\nif estado = Somar then\nif contador_128 = \"1111111\" then\ncontador_128&lt;= (others => '0');\nelse\ncontador_128&lt;= contador_128 + 1;\n\n\n\n127\n\nend if;\nend if;\nend if;\nend process;\n\n-- Fim do Contador Mod(128)\n\n-- In\u00edcio do Contador de Endere\u00e7os\n\n-- Usado para fornecer o endere\u00e7o da mem\u00f3ria ROM.\n-- Como o deslocador de fase ainda n\u00e3o foi implementado,\no Contador de Endere\u00e7os\n-- apresenta sempre o mesmo valor do Contador mod128.\nQuando o deslocador de fa-\n-- se for implementado, o Contador de Endere\u00e7os ter\u00e1 um\noffset relativo ao erro\n-- de fase inerente ao circuito de medi\u00e7\u00e3o para\ncalibra\u00e7\u00e3o do LOCK-IN.\n\nprocess (Relogio, Reinicio)\nbegin\nif Reinicio = '1' then\ncontador_endereco&lt;= (others => '0');\nelsif Relogio'event and Relogio = '1' then\nif estado = Multiplicar then\nif contador_endereco = \"1111111\" then\ncontador_endereco&lt;= (others => '0');\nelse\ncontador_endereco&lt;= contador_endereco + 1;\nend if;\nend if;\nend if;\nend process;\n\n-- Fim do Contador de Endere\u00e7os\n\n-- In\u00edcio da L\u00f3gica de Endere\u00e7os\n\n-- L\u00f3gica combinacional que calcula os endere\u00e7os da ROM que ser\u00e3o carregados\n-- em REG_FASE e REG_QUAD. O endere\u00e7o carregado em REG_FASE \u00e9 dado pelo pr\u00f3-\n-- prio Contador de Endere\u00e7os. J\u00e1 o endere\u00e7o carregado em REG_QUAD apresenta\n-- um deslocamento de 32 posi\u00e7\u00f5es de mem\u00f3ria, relativos aos 90 graus de fase.\n\n-- OBS: quando o endere\u00e7o de REG_FASE = 96, o endere\u00e7o de REG_QUAD ser\u00e1 igual\n-- a 96 + 32 = 128 mod 128 = 0. Portanto, a partir do endere\u00e7o 96, o desloca-\n-- mento (negativo) ser\u00e1 de 96 posi\u00e7\u00f5es de mem\u00f3ria.\n\n\n\n128\n\nprocess (contador_endereco)\nbegin\nif contador_endereco > \"1011111\" then\nend_reg_quad&lt;= contador_endereco - 96;\nelse\nend_reg_quad&lt;= contador_endereco + 32;\nend if;\nend process;\n\nend_reg_fase&lt;= contador_endereco;\n\n-- Fim da L\u00f3gica de Endere\u00e7os\n\nend RTL;\n\nA.2.2 ROM\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_arith.all;\nuse ieee.std_logic_unsigned.all;\n\nentity ROM is\ngeneric (i : integer := 7 ;\n\nj : integer := 12) ;\nport (Endereco: in std_logic_vector (i-1 downto 0);\n\nSaida : out std_logic_vector (j-1 downto 0));\nend ROM;\n\narchitecture RTL of ROM is\ntype arranjo_memoria is array (0 to 127) of integer range -2048 to 2047;\nconstant dados: arranjo_memoria := (410,\n\n409,\n408,\n405,\n402,\n398,\n392,\n386,\n379,\n370,\n361,\n352,\n341,\n329,\n317,\n\n\n\n129\n\n304,\n290,\n275,\n260,\n244,\n228,\n211,\n193,\n175,\n157,\n138,\n119,\n100,\n80,\n60,\n40,\n20,\n\n0,\n-20,\n-40,\n-60,\n-80,\n-100,\n-119,\n-138,\n-157,\n-175,\n-193,\n-211,\n-228,\n-244,\n-260,\n-275,\n-290,\n-304,\n-317,\n-329,\n-341,\n-352,\n-361,\n-370,\n-379,\n-386,\n-392,\n-398,\n-402,\n-405,\n\n\n\n130\n\n-408,\n-409,\n-410,\n-409,\n-408,\n-405,\n-402,\n-398,\n-392,\n-386,\n-379,\n-370,\n-361,\n-352,\n-341,\n-329,\n-317,\n-304,\n-290,\n-275,\n-260,\n-244,\n-228,\n-211,\n-193,\n-175,\n-157,\n-138,\n-119,\n-100,\n-80,\n-60,\n-40,\n-20,\n0,\n20,\n40,\n60,\n80,\n100,\n119,\n138,\n157,\n175,\n193,\n211,\n228,\n\n\n\n131\n\n244,\n260,\n275,\n290,\n304,\n317,\n329,\n341,\n352,\n361,\n370,\n379,\n386,\n392,\n398,\n402,\n405,\n408,\n409);\n\nbegin\n\nSaida&lt;= conv_std_logic_vector(dados(conv_integer(Endereco(i-1 downto 0))),12);\n\nend RTL;\n\nA.2.3 Registrador\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Registrador is\ngeneric (N: integer := 12);\nport (Relogio: in std_logic;\n\nLimpa : in std_logic;\nEntrada: in std_logic_vector (N-1 downto 0) ;\n\nSaida : out std_logic_vector (N-1 downto 0));\nend Registrador;\n\narchitecture RTL of Registrador is\n\nbegin\n\nprocess (Relogio, Limpa)\n\n\n\n132\n\nbegin\nif Limpa = '1' then\nSaida&lt;= (others => '0');\nelsif Relogio'event and Relogio = '1' then\nSaida&lt;= Entrada;\nend if;\nend process;\n\nend RTL;\n\nA.2.4 Detector de Fase\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Detetor_Fase is\ngeneric (N : integer := 12 ;\n\nN2 : integer := 24);\nport (Relogio : in std_logic;\n\nLimpa : in std_logic;\nEntrada0: in std_logic_vector (N-1 downto 0);\nEntrada1: in std_logic_vector (N-1 downto 0);\n\nSaida : out std_logic_vector (2*N-1 downto 0));\nend Detetor_Fase;\n\narchitecture Estrutural of Detetor_Fase is\n\ncomponent Complemento2 is\ngeneric (N : integer := 12);\nport (Entrada: in std_logic_vector (N-1 downto 0);\n\nSaida : out std_logic_vector (N-1 downto 0));\nend component;\n\ncomponent Multiplexador is\ngeneric (N : integer := 12);\nport (Selecao : in std_logic;\n\nEntrada0: in std_logic_vector (N-1 downto 0);\nEntrada1: in std_logic_vector (N-1 downto 0);\nSaida : out std_logic_vector (N-1 downto 0));\n\nend component;\n\ncomponent Multiplicador is\ngeneric (N : integer := 12);\nport (Relogio : in std_logic;\n\n\n\n133\n\nLimpa : in std_logic;\nEntrada0: in std_logic_vector (N-1 downto 0);\nEntrada1: in std_logic_vector (N-1 downto 0);\n\nSaida : out std_logic_vector (2*N-1 downto 0));\nend component;\n\nsignal fio : std_logic;\nsignal cmpl0 , cmpl1 : std_logic_vector (N-1 downto 0);\nsignal opr0 , opr1 : std_logic_vector (N-1 downto 0);\nsignal result, cmplresult : std_logic_vector (2*N-1 downto 0);\n\nbegin\n\nfio&lt;= Entrada0(N-1) xor Entrada1(N-1);\n\nX0: Complemento2 port map (Entrada0, cmpl0);\n\nX1: Complemento2 port map (Entrada1, cmpl1);\n\nX2: Multiplexador port map (Entrada0(N-1),\nEntrada0 ,\ncmpl0 ,\nopr0 );\n\nX3: Multiplexador port map (Entrada1(N-1),\nEntrada1 ,\ncmpl1 ,\nopr1 );\n\nX4: Multiplicador port map (Relogio,\nLimpa ,\nopr0 ,\nopr1 ,\nresult );\n\nX5: Complemento2 generic map (N2) port map (result, cmplresult);\n\nX6: Multiplexador generic map (N2) port map (fio,\nresult,\ncmplresult,\nSaida);\n\nend Estrutural;\n\nA.2.5 Complemento2\n\n\n\n134\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Complemento2 is\ngeneric (N : integer := 12);\nport (Entrada: in std_logic_vector (N-1 downto 0);\n\nSaida : out std_logic_vector (N-1 downto 0));\nend Complemento2;\n\narchitecture RTL of Complemento2 is\n\nsignal Ent_Inv : std_logic_vector (N-1 downto 0);\n\nbegin\n\nEnt_Inv&lt;= not Entrada;\nSaida&lt;= Ent_Inv+1;\n\nend RTL;\n\nA.2.6 Multiplexador\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Multiplexador is\ngeneric (N : integer := 12);\nport (Selecao : in std_logic;\n\nEntrada0: in std_logic_vector (N-1 downto 0);\nEntrada1: in std_logic_vector (N-1 downto 0);\nSaida : out std_logic_vector (N-1 downto 0));\nend Multiplexador;\n\narchitecture RTL of Multiplexador is\n\nbegin\n\nSaida&lt;= Entrada0 when Selecao = '0' else\nEntrada1;\n\nend RTL;\n\n\n\n135\n\nA.2.7 Multiplicador\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Multiplicador is\ngeneric (N : integer := 12);\nport (Relogio : in std_logic;\n\nLimpa : in std_logic;\nEntrada0: in std_logic_vector (N-1 downto 0);\nEntrada1: in std_logic_vector (N-1 downto 0);\n\nSaida : out std_logic_vector (2*N-1 downto 0));\nend Multiplicador;\n\narchitecture RTL of Multiplicador is\n\nbegin\n\nprocess (Relogio, Limpa)\nbegin\n\nif (Limpa = '1') then\nSaida&lt;= (others => '0');\n\nelsif (Relogio'event and Relogio = '1') then\nSaida&lt;= Entrada0 * Entrada1;\nend if;\n\nend process;\n\nend RTL;\n\nA.2.8 Filtro Passa-Baixa\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Filtro_PB is\ngeneric (N1: integer := 24 ;\n\nN2: integer := 64);\nport (Relogio : in std_logic;\n\nLimpa_Parcial : in std_logic;\nLimpa : in std_logic;\nSome : in std_logic;\n\n\n\n136\n\nDesloque : in std_logic;\nCarregue_Saida: in std_logic;\n\nEntrada : in std_logic_vector (N1-1 downto 0);\nSaida : out std_logic_vector (N2-1 downto 0));\n\nend Filtro_PB;\n\narchitecture Estrutural of Filtro_PB is\n\ncomponent Somador is\ngeneric (N : integer := 64);\nport (Entrada0: in std_logic_vector (N-1 downto 0);\n\nEntrada1: in std_logic_vector (N-1 downto 0);\nSaida : out std_logic_vector (N downto 0));\nend component;\n\ncomponent Reg_Desl is\ngeneric (N: integer := 64);\nport (Relogio : in std_logic;\n\nLimpa : in std_logic;\nDesloque: in std_logic;\nEntrada : in std_logic_vector (N-1 downto 0) ;\nSaida : out std_logic_vector (N-1 downto 0));\nend component;\n\ncomponent Registrador is\ngeneric (N : integer := 12);\nport (Relogio : in std_logic;\n\nLimpa : in std_logic;\nEntrada : in std_logic_vector (N-1 downto 0);\nSaida : out std_logic_vector (N-1 downto 0));\nend component;\n\nsignal ent : std_logic_vector (N2-1 downto 0);\nsignal fio1: std_logic_vector (N2 downto 0);\nsignal fio2: std_logic ;\nsignal sai : std_logic_vector (N2-1 downto 0);\n\nbegin\n\n-- In\u00edcio Ajuste do sinal demodulado (24 -> 64 bits)\n\nprocess (Entrada)\nbegin\n\nif Entrada(N1-1) = '1' then\nent (N2-1 downto N1)&lt;= (others => '1');\n\nelse\n\n\n\n137\n\nent (N2-1 downto N1)&lt;= (others => '0');\nend if;\n\nend process;\n\nent (N1-1 downto 0)&lt;= Entrada;\n\n-- Fim Ajuste do sinal demodulado (24 -> 64 bits)\n\n-- In\u00edcio Componentes\n\nX0: Somador generic map (N2) port map (ent ,\nsai ,\nfio1);\n\nfio2&lt;= (Relogio and Desloque) or Some;\n\nX1: Reg_Desl generic map (N2) port map (fio2 ,\nLimpa_Parcial ,\n\nDesloque ,\nfio1(N2-1 downto 0),\nsai );\n\nX2: Registrador generic map (N2) port map (Carregue_Saida,\nLimpa ,\n\nsai ,\nSaida );\n\nend Estrutural;\n\nA.2.9 Somador\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Somador is\ngeneric (N : integer := 64);\nport (Entrada0: in std_logic_vector (N-1 downto 0);\n\nEntrada1: in std_logic_vector (N-1 downto 0);\nSaida : out std_logic_vector (N downto 0));\nend Somador;\n\narchitecture RTL of Somador is\n\nbegin\n\n\n\n138\n\nSaida&lt;= ('0' &amp; Entrada0) + ('0' &amp; Entrada1);\n\nend RTL;\n\nA.2.10 Registrador de Deslocamento\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity Reg_Desl is\ngeneric (N: integer := 64);\nport (Relogio : in std_logic;\n\nLimpa : in std_logic;\nDesloque: in std_logic;\nEntrada : in std_logic_vector (N-1 downto 0) ;\nSaida : out std_logic_vector (N-1 downto 0));\nend Reg_Desl;\n\narchitecture RTL of Reg_Desl is\n\nsignal Saida_aux : std_logic_vector (N-1 downto 0);\n\nbegin\n\nSaida&lt;= Saida_aux;\n\nprocess (Relogio, Limpa)\nbegin\nif Limpa = '1' then\nSaida_aux&lt;= (others => '0');\nelsif Relogio'event and Relogio = '1' then\nif Desloque = '1' then\nif Saida_aux(N-1) = '1' then\nSaida_aux(N-1)&lt;= '1';\nSaida_aux(N-2 downto 0)&lt;= Saida_aux(N-1 downto 1);\nelse\nSaida_aux(N-1)&lt;= '0';\nSaida_aux(N-2 downto 0)&lt;= Saida_aux(N-1 downto 1);\nend if;\nelse\nSaida_aux&lt;= Entrada;\nend if;\nend if;\nend process;\n\n\n\n139\n\nend RTL;\n\nA.3 M\u00f3dulo CAN\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\nuse ieee.numeric_std.all;\n\nentity CAN_Module is\nport (Clock : in std_logic;\nReset : in std_logic;\nCAN_Rx_Bit : in std_logic;\nCAN_Tx_Req : in std_logic;\nCAN_RTR : in std_logic;\nCAN_IDE : in std_logic;\nCAN_DLC : in std_logic_vector( 3 downto 0);\nCAN_BRP : in std_logic_vector( 5 downto 0);\nCAN_PRSEG : in std_logic_vector( 2 downto 0);\nCAN_PSEG1 : in std_logic_vector( 2 downto 0);\nCAN_PSEG2 : in std_logic_vector( 2 downto 0);\nCAN_SJW : in std_logic_vector( 1 downto 0);\nCAN_ID_Tx : in std_logic_vector(28 downto 0);\nCAN_MSG_Tx : in std_logic_vector(63 downto 0);\nCAN_ID_Rx : out std_logic_vector(28 downto 0);\nCAN_MSG_Rx : out std_logic_vector(63 downto 0);\nCAN_Tx_Busy: out std_logic;\nCAN_Tx_Comp: out std_logic;\nCAN_Rx_Busy: out std_logic;\nCAN_Rx_Comp: out std_logic;\nCAN_Tx_Bit : out std_logic);\nend CAN_Module;\n\narchitecture Estrutural of CAN_Module is\n\n-- Declara\u00e7\u00e3o dos Componentes\n\ncomponent CAN_Tx\nport(\nClock : in std_logic;\nReset : in std_logic;\nTxClock : in std_logic;\nSamplePoint : in std_logic;\nRTR_Tx : in std_logic;\n\n\n\n140\n\nIDE_Tx : in std_logic;\nDLC : in std_logic_vector( 3 downto 0);\nID_Tx : in std_logic_vector(28 downto 0);\nMSG_Tx : in std_logic_vector(63 downto 0);\nCRC : in std_logic_vector(14 downto 0);\nRx_Bit : in std_logic;\nRx_Error : in std_logic;\nStuff_Bit : in std_logic;\nStuff_Error : in std_logic;\nCRC_Reset : out std_logic;\nCRC_Stop : out std_logic;\nLostArbitration: out std_logic;\nTx_Bit : out std_logic;\nTxBusy : out std_logic;\nTxComp : out std_logic;\nTx_Error : out std_logic\n);\nend component;\n\ncomponent CAN_Rx\nport(\nClock : in std_logic;\nReset : in std_logic;\nSamplePoint : in std_logic;\nACKPoint : in std_logic;\nTxBusy : in std_logic;\nRxBit : in std_logic;\nStuff_Bit : in std_logic;\nStuff_Error : in std_logic;\nCRC : in std_logic_vector(14 downto 0);\nCRC_Reset : out std_logic;\nCRC_Stop : out std_logic;\nStuff_Disable: out std_logic;\nACK_Tx : out std_logic;\nRxBusy : out std_logic;\nRx_Completed : out std_logic;\nRx_Error : out std_logic;\nID_Rx : out std_logic_vector(28 downto 0);\nMSG_Rx : out std_logic_vector(63 downto 0)\n);\nend component;\n\ncomponent CAN_CRC\nport(\nClock : in std_logic;\nReset : in std_logic;\nSamplePoint : in std_logic;\n\n\n\n141\n\nCAN_Bit : in std_logic;\nStuff_Bit : in std_logic;\nCRC_Stop : in std_logic;\nCRC_Sequence: out std_logic_vector(14 downto 0)\n);\nend component;\n\ncomponent CAN_Bit_Stuffing\nport(\nClock : in std_logic;\nReset : in std_logic;\nRxBit : in std_logic;\nSamplePoint: in std_logic;\nStuff_Bit : out std_logic;\nStuff_Error: out std_logic\n);\nend component;\n\ncomponent CAN_Bit_Timing2\nport(\nClock : in std_logic;\nReset : in std_logic;\nTxReq : in std_logic;\nRxBusy : in std_logic;\nTxComp : in std_logic;\nBRP : in std_logic_vector(5 downto 0);\nPRSEG : in std_logic_vector(2 downto 0);\nPSEG1 : in std_logic_vector(2 downto 0);\nPSEG2 : in std_logic_vector(2 downto 0);\nResetTx: out std_logic;\nTxPoint: out std_logic\n);\nend component;\n\ncomponent CAN_Bit_Timing\nport(\nClock : in std_logic;\nReset : in std_logic;\nRxBit : in std_logic;\nEndFr : in std_logic;\nBRP : in std_logic_vector(5 downto 0);\nPRSEG : in std_logic_vector(2 downto 0);\nPSEG1 : in std_logic_vector(2 downto 0);\nPSEG2 : in std_logic_vector(2 downto 0);\nSJW : in std_logic_vector(1 downto 0);\nACKPoint : out std_logic;\nSamplePoint: out std_logic\n\n\n\n142\n\n);\nend component;\n\n-- Declara\u00e7\u00e3o dos Sinais Internos\n\nsignal TxClock : std_logic := '0';\nsignal SamplePoint : std_logic := '0';\nsignal RTR_Tx : std_logic := '0';\nsignal IDE_Tx : std_logic := '0';\nsignal DLC : std_logic_vector( 3 downto 0) := (others=>'0');\nsignal ID_Tx : std_logic_vector(28 downto 0) := (others=>'0');\nsignal MSG_Tx : std_logic_vector(63 downto 0) := (others=>'0');\nsignal CRC_Tx : std_logic_vector(14 downto 0) := (others=>'0');\nsignal Rx_Bit : std_logic := '0';\nsignal Rx_Error : std_logic := '0';\nsignal Stuff_Bit : std_logic := '0';\nsignal Stuff_Error : std_logic := '0';\nsignal CRC_Reset_Tx : std_logic := '0';\nsignal CRC_Stop_Tx : std_logic := '0';\nsignal LostArbitration : std_logic := '0';\nsignal Tx_Bit : std_logic := '0';\nsignal TxBusy : std_logic := '0';\nsignal TxComp : std_logic := '0';\nsignal Tx_Error : std_logic := '0';\nsignal ACKPoint : std_logic := '0';\nsignal CRC_Rx : std_logic_vector(14 downto 0) := (others=>'0');\nsignal CRC_Reset_Rx : std_logic := '0';\nsignal CRC_Stop_Rx : std_logic := '0';\nsignal Stuff_Disable : std_logic := '0';\nsignal ACK_Tx : std_logic := '0';\nsignal RxBusy : std_logic := '0';\nsignal Rx_Completed : std_logic := '0';\nsignal ID_Rx : std_logic_vector(28 downto 0) := (others=>'0');\nsignal MSG_Rx : std_logic_vector(63 downto 0) := (others=>'0');\nsignal CAN_CRC_Reset_Tx : std_logic := '0';\nsignal CAN_CRC_Reset_Rx : std_logic := '0';\nsignal CAN_Bit_Stuffing_Reset : std_logic := '0';\nsignal CAN_Bit_Timing2_Reset : std_logic := '0';\nsignal TxReq : std_logic := '0';\nsignal BRP : std_logic_vector(5 downto 0) := (others=>'0');\nsignal PRSEG : std_logic_vector(2 downto 0) := (others=>'0');\nsignal PSEG1 : std_logic_vector(2 downto 0) := (others=>'0');\nsignal PSEG2 : std_logic_vector(2 downto 0) := (others=>'0');\nsignal SJW : std_logic_vector(1 downto 0) := (others=>'0');\nsignal ResetTx : std_logic;\nsignal CAN_Tx_Reset : std_logic;\n\n\n\n143\n\nbegin\n\n-- Equa\u00e7\u00f5es de Sa\u00edda\n\nCAN_ID_Rx&lt;= ID_Rx;\nCAN_MSG_Rx&lt;= MSG_Rx;\nCAN_Tx_Busy&lt;= TxBusy;\nCAN_Tx_Comp&lt;= TxComp;\nCAN_Rx_Busy&lt;= RxBusy;\nCAN_Rx_Comp&lt;= Rx_Completed;\nCAN_Tx_Bit&lt;= Tx_Bit and ACK_Tx;\n\n-- Sinais Internos\n\nRx_Bit&lt;= CAN_Rx_Bit;\nTxReq&lt;= CAN_Tx_Req;\nRTR_Tx&lt;= CAN_RTR;\nIDE_Tx&lt;= CAN_IDE;\nDLC&lt;= CAN_DLC;\nBRP&lt;= CAN_BRP;\nPRSEG&lt;= CAN_PRSEG;\nPSEG1&lt;= CAN_PSEG1;\nPSEG2&lt;= CAN_PSEG2;\nSJW&lt;= CAN_SJW;\nID_Tx&lt;= CAN_ID_Tx;\nMSG_Tx&lt;= CAN_MSG_Tx;\nCAN_CRC_Reset_Tx&lt;= Reset or CRC_Reset_Tx or (not TxBusy);\nCAN_CRC_Reset_Rx&lt;= Reset or CRC_Reset_Rx;\nCAN_Bit_Stuffing_Reset&lt;= Reset or Stuff_Disable;\nCAN_Bit_Timing2_Reset&lt;= Reset or LostArbitration;\nCAN_Tx_Reset&lt;= Reset or ResetTx;\n\n-- Interliga\u00e7\u00e3o dos componentes\n\n-- M\u00f3dulo de transmiss\u00e3o CAN\n\nX6: CAN_Tx port map\n(\nClock => Clock,\nReset => CAN_Tx_Reset,\nTxClock => TxClock,\nSamplePoint => SamplePoint,\nRTR_Tx => RTR_Tx,\nIDE_Tx => IDE_Tx,\nDLC => DLC,\nID_Tx => ID_Tx,\nMSG_Tx => MSG_Tx,\n\n\n\n144\n\nCRC => CRC_Tx,\nRx_Bit => Rx_Bit,\nRx_Error => Rx_Error,\nStuff_Bit => Stuff_Bit,\nStuff_Error => Stuff_Error,\nCRC_Reset => CRC_Reset_Tx,\nCRC_Stop => CRC_Stop_Tx,\nLostArbitration => LostArbitration,\nTx_Bit => Tx_Bit,\nTxBusy => TxBusy,\nTxComp => TxComp,\nTx_Error => Tx_Error\n);\n\n-- M\u00f3dulo de recep\u00e7\u00e3o CAN\n\nX5: CAN_Rx port map\n(\nClock => Clock,\nReset => Reset,\nSamplePoint => SamplePoint,\nACKPoint => ACKPoint,\nTxBusy => TxBusy,\nRxBit => Rx_Bit,\nStuff_Bit => Stuff_Bit,\nStuff_Error => Stuff_Error,\nCRC => CRC_Rx,\nCRC_Reset => CRC_Reset_Rx,\nCRC_Stop => CRC_Stop_Rx,\nStuff_Disable => Stuff_Disable,\nACK_Tx => ACK_Tx,\nRxBusy => RxBusy,\nRx_Completed => Rx_Completed,\nRx_Error => Rx_Error,\nID_Rx => ID_Rx,\nMSG_Rx => MSG_Rx\n);\n\n-- M\u00f3dulo de c\u00e1lculo de CRC para CAN_Tx\n\nX4: CAN_CRC port map\n(\nClock => Clock,\nReset => CAN_CRC_Reset_Tx,\nSamplePoint => SamplePoint,\nCAN_Bit => Tx_Bit,\nStuff_Bit => Stuff_Bit,\n\n\n\n145\n\nCRC_Stop => CRC_Stop_Tx,\nCRC_Sequence => CRC_Tx\n);\n\n-- M\u00f3dulo de c\u00e1lculo de CRC para CAN_Rx\n\nX3: CAN_CRC port map\n(\nClock => Clock,\nReset => CAN_CRC_Reset_Rx,\nSamplePoint => SamplePoint,\nCAN_Bit => Rx_Bit,\nStuff_Bit => Stuff_Bit,\nCRC_Stop => CRC_Stop_Rx,\nCRC_Sequence => CRC_Rx\n);\n\n-- M\u00f3dulo detector e gerador de \"Stuff Bit\"\n\nX2: CAN_Bit_Stuffing port map\n(\n\nClock => Clock,\nReset => CAN_Bit_Stuffing_Reset,\nRxBit => Rx_Bit,\nSamplePoint => SamplePoint,\nStuff_Bit => Stuff_Bit,\nStuff_Error => Stuff_Error\n);\n\n-- M\u00f3dulo de sincroniza\u00e7\u00e3o 2\n\nX1: CAN_Bit_Timing2 port map\n(\nClock => Clock,\nReset => CAN_Bit_Timing2_Reset,\nTxReq => TxReq,\nRxBusy => RxBusy,\nTxComp => TxComp,\nBRP => BRP,\nPRSEG => PRSEG,\nPSEG1 => PSEG1,\nPSEG2 => PSEG2,\nResetTx=> ResetTx,\nTxPoint=> TxClock\n);\n\n-- M\u00f3dulo de sincroniza\u00e7\u00e3o\n\n\n\n146\n\nX0: CAN_Bit_Timing port map\n(\nClock => Clock,\nReset => Reset,\nRxBit => Rx_Bit,\nEndFr => Rx_Completed,\nBRP => BRP,\nPRSEG => PRSEG,\nPSEG1 => PSEG1,\nPSEG2 => PSEG2,\nSJW => SJW,\nACKPoint => ACKPoint,\nSamplePoint => SamplePoint\n);\n\nend Estrutural;\n\nA.3.1 CAN TX\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\nentity CAN_Tx is\nport (Clock : in std_logic ;\n\nReset : in std_logic ;\nTxClock : in std_logic ;\n\nSamplePoint : in std_logic ;\n-- ErrorPassive : in std_logic ;\n--BusOff : in std_logic ;\n\nRTR_Tx : in std_logic ;\nIDE_Tx : in std_logic ;\nDLC : in std_logic_vector ( 3 downto 0) ;\nID_Tx : in std_logic_vector (28 downto 0) ;\n\nMSG_Tx : in std_logic_vector (63 downto 0) ;\nCRC : in std_logic_vector (14 downto 0) ;\n\nRx_Bit : in std_logic ;\nRx_Error : in std_logic ;\nStuff_Bit : in std_logic ;\n\nStuff_Error : in std_logic ;\nTx_Bit : out std_logic ;\nLostArbitration: out std_logic ;\n\nCRC_Reset : out std_logic ;\nCRC_Stop : out std_logic ;\n\nTxBusy : out std_logic ;\nTxComp : out std_logic ;\n\n\n\n147\n\nTx_Error : out std_logic);\nend CAN_Tx;\n\narchitecture RTL of CAN_Tx is\n\n-- M\u00e1quina sequencial de estados\n\ntype states is (StartOfFrame, BaseID, IDEBit, ExtendedID, R1Bit,\nCtrlField, DataField, CRCField, ACKSlotBit,\nACKDelimitBit, EndOfFrame, ErrorFrame);\nsignal state : states;\n\n-- Sinais auxiliares\n\nsignal busmonitor : std_logic;\nsignal biterror : std_logic;\nsignal counter : std_logic_vector ( 6 downto 0);\n\n-- Entradas\n\nsignal rxbit : std_logic;\nsignal rtr : std_logic;\nsignal ide : std_logic;\nsignal controlfield : std_logic_vector ( 4 downto 0);\nsignal msgid : std_logic_vector (28 downto 0);\nsignal msg : std_logic_vector (63 downto 0);\nsignal crcsequence : std_logic_vector (14 downto 0);\n\n-- Sa\u00eddas\n\nsignal txbit : std_logic;\nsignal lostarb : std_logic;\n\nbegin\n\nLostArbitration&lt;= lostarb;\nTx_Bit&lt;= txbit;\n\n-- Processo que monitora o barramento (amostra o bit recebido)\n\nprocess (Clock, Reset)\nbegin\nif Reset = '1' then\nrxbit&lt;= '1';\nelsif (Clock'event and Clock = '1') then\nif SamplePoint = '1' then\nrxbit&lt;= Rx_Bit;\n\n\n\n148\n\nend if;\nend if;\nend process;\n\n-- Processo que compara os bits transmitido e recebido\n\nprocess (Clock, Reset)\nbegin\nif Reset = '1' then\nlostarb&lt;= '0';\nbiterror&lt;= '0';\nelsif (Clock'event and Clock = '1') then\nif TxClock = '1' and busmonitor = '1' then\nif txbit = '1' and rxbit = '0' then\nlostarb&lt;= '1';\nbiterror&lt;= '0';\nelsif txbit = '0' and rxbit = '1' then\nlostarb&lt;= '0';\nbiterror&lt;= '1';\nelse\nlostarb&lt;= '0';\nbiterror&lt;= '0';\nend if;\nend if;\nend if;\nend process;\n\n-- Controlador de transmiss\u00e3o de mensagem CAN\n\nprocess (Clock, Reset)\nbegin\n\nif Reset = '1' then -- Reset ass\u00edncrono\n-- M\u00e1quina de estados\nstate&lt;= StartOfFrame;\n-- Sinais auxiliares\nbusmonitor&lt;= '0';\ncounter&lt;= (others => '0');\n-- Entradas\nrtr&lt;= '0';\nide&lt;= '0';\ncontrolfield&lt;= (others => '0');\nmsgid&lt;= (others => '0');\nmsg&lt;= (others => '0');\ncrcsequence&lt;= (others => '0');\n-- Sa\u00eddas\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\n\n\n\n149\n\ntxbit&lt;= '1';\nTxBusy&lt;= '0';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nelsif (Clock'event and Clock = '1') then\n\nif TxClock = '1' then\nif biterror = '0' and Rx_Error = '0' and Stuff_Error = '0' then\n\ncase state is\nwhen StartOfFrame =>\n\nstate&lt;= BaseID;\nbusmonitor&lt;= '1';\ncounter&lt;= (others => '0');\nrtr&lt;= RTR_Tx;\nide&lt;= IDE_Tx;\ncontrolfield&lt;= '0' &amp; DLC;\nmsgid&lt;= ID_Tx;\nmsg&lt;= MSG_Tx;\ncrcsequence&lt;= (others => '0');\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\ntxbit&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\n\nwhen BaseID =>\nbusmonitor&lt;= '1';\n\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif lostarb = '1' then\nstate&lt;= StartOfFrame;\nbusmonitor&lt;= '0';\nTxBusy&lt;= '0';\nelsif counter = \"0001011\" then\n\nif ide = '0' and Stuff_Bit = '0' then\ntxbit&lt;= RTR;\n\nstate&lt;= IDEBit;\ncounter&lt;= (others => '0');\n\nelsif ide = '1' and Stuff_Bit = '0' then\ntxbit&lt;= '1'; -- SRR\n\nstate&lt;= IDEBit;\ncounter&lt;= (others => '0');\n\nelse\ntxbit&lt;= not txbit;\n\nstate&lt;= BaseID;\n\n\n\n150\n\nend if;\nelse\n\nstate&lt;= BaseID;\nif Stuff_Bit = '0' then\n\ntxbit&lt;= msgid(28);\ncounter&lt;= counter+1;\n\nmsgid(28 downto 18)&lt;= msgid(27 downto 18) &amp; msg(28);\nelse\ntxbit&lt;= not txbit;\n\nend if;\nend if;\n\nwhen IDEBit =>\nbusmonitor&lt;= '1';\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif lostarb = '1' then\nstate&lt;= StartOfFrame;\nbusmonitor&lt;= '0';\nTxBusy&lt;= '0';\nelsif ide = '1' and Stuff_Bit = '0' then\ntxbit&lt;= IDE;\nstate&lt;= ExtendedID;\n\nelsif ide = '0' and Stuff_Bit = '0' then\ntxbit&lt;= IDE;\nstate&lt;= CtrlField;\n\nelse\ntxbit&lt;= not txbit;\nstate&lt;= IDEBit;\nend if;\n\nwhen ExtendedID =>\nbusmonitor&lt;= '1';\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif lostarb = '1' then\nstate&lt;= StartOfFrame;\nbusmonitor&lt;= '0';\nTxBusy&lt;= '0';\nelsif counter = \"0010010\" then\n\nif Stuff_Bit = '0' then\ntxbit&lt;= RTR;\n\nstate&lt;= R1Bit;\n\n\n\n151\n\ncounter&lt;= (others => '0');\nelse\n\ntxbit&lt;= not txbit;\nstate&lt;= ExtendedID;\nend if;\n\nelse\nstate&lt;= ExtendedID;\n\nif Stuff_Bit = '0' then\ntxbit&lt;= msgid(17);\n\ncounter&lt;= counter+1;\nmsgid(17 downto 0)&lt;= msgid(16 downto 0) &amp; msgid(17);\n\nelse\ntxbit&lt;= not txbit;\nend if;\nend if;\nwhen R1Bit =>\nbusmonitor&lt;= '1';\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif Stuff_Bit = '0' then\ntxbit&lt;= '0'; -- R1\n\nstate&lt;= CtrlField;\nelse\n\ntxbit&lt;= not txbit;\nstate&lt;= R1Bit;\n\nend if;\nwhen CtrlField =>\nbusmonitor&lt;= '1';\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif counter = \"0000100\" then -- Transmitindo DLC0\n\nif rtr = '1' and Stuff_Bit = '0' then\ntxbit&lt;= controlfield(4); -- DLC0\n\nstate&lt;= CRCField;\ncounter&lt;= (others => '0');\n\ncontrolfield (4 downto 0)&lt;= controlfield(3 downto 0) &amp; controlfield(4);\nelsif rtr = '0' and Stuff_Bit = '0' then\ntxbit&lt;= controlfield(4); -- DLC0\n\nstate&lt;= DataField;\ncounter&lt;= (others => '0');\n\ncontrolfield (4 downto 0)&lt;= controlfield(3 downto 0) &amp; controlfield(4);\n\n\n\n152\n\nelse\ntxbit&lt;= not txbit;\nstate&lt;= CtrlField;\nend if;\n\nelse\nstate&lt;= CtrlField;\nif Stuff_Bit = '0' then\ntxbit&lt;= controlfield(4);\n\ncounter&lt;= counter+1;\ncontrolfield (4 downto 0)&lt;= controlfield(3 downto 0) &amp; controlfield(4);\n\nelse\ntxbit&lt;= not txbit;\nend if;\n\nend if;\nwhen DataField =>\nbusmonitor&lt;= '1';\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif controlfield(3 downto 0) > \"1000\" and Stuff_Bit = '0' then\n\ncontrolfield(3 downto 0)&lt;= \"1000\";\nend if;\nif counter = (controlfield(3 downto 0)&amp;\"000\"-1) then\nif Stuff_Bit = '0' then -- Transmitindo \u00faltimo bit de dados\ntxbit&lt;= msg(63);\nstate&lt;= CRCField;\ncounter&lt;= (others => '0');\nmsg(63 downto 0)&lt;= msg(62 downto 0) &amp; msg(63);\nelse\ntxbit&lt;= not txbit;\nstate&lt;= DataField;\nend if;\n\nelse\nstate&lt;= DataField;\n\nif Stuff_Bit = '0' then\ntxbit&lt;= msg(63);\ncounter&lt;= counter+1;\n\nmsg(63 downto 0)&lt;= msg(62 downto 0) &amp; msg(63);\nelse\ntxbit&lt;= not txbit;\nend if;\n\nend if;\nwhen CRCField =>\n\nbusmonitor&lt;= '1';\nCRC_Reset&lt;= '0';\n\n\n\n153\n\nCRC_Stop&lt;= '1';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif counter = \"0001111\" and Stuff_Bit = '0' then\ntxbit&lt;= '1';\nstate&lt;= ACKSlotBit;\ncounter&lt;= (others => '0');\nelsif counter = \"0000000\" and Stuff_Bit = '0' then\nstate&lt;= CRCField;\ncounter&lt;= counter+1;\ntxbit&lt;= CRC(14);\ncrcsequence&lt;= CRC (13 downto 0) &amp; CRC(14);\nelse\nstate&lt;= CRCField;\n\nif Stuff_Bit = '0' then\ntxbit&lt;= crcsequence(14);\ncounter&lt;= counter+1;\ncrcsequence(14 downto 0)&lt;= crcsequence(13 downto 0) &amp; crcsequence(14);\nelse\ntxbit&lt;= not txbit;\nend if;\nend if;\n\nwhen ACKSlotBit =>\nstate&lt;= ACKDelimitBit;\nbusmonitor&lt;= '0';\nCRC_Reset&lt;= '1';\nCRC_Stop&lt;= '1';\ntxbit&lt;= '1';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nwhen ACKDelimitBit =>\n\nstate&lt;= EndOfFrame;\nbusmonitor&lt;= '0';\nCRC_Reset&lt;= '1';\nCRC_Stop&lt;= '1';\ntxbit&lt;= '1';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\nif rxbit = '0' then -- ACK recebido\nstate&lt;= EndOfFrame;\nelse\nTx_Error&lt;= '1';\nstate&lt;= ErrorFrame;\nend if;\n\n\n\n154\n\nwhen EndOfFrame =>\nstate&lt;= EndOfFrame;\nbusmonitor&lt;= '0';\nCRC_Reset&lt;= '1';\nCRC_Stop&lt;= '1';\ntxbit&lt;= '1';\nTxBusy&lt;= '1';\nTxComp&lt;= '0';\nTx_Error&lt;= '0';\n\nif counter = \"0000111\" then\nstate&lt;= StartOfFrame;\nbusmonitor&lt;= '0';\ncounter&lt;= (others => '0');\ncrcsequence<= (others => '0');\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\ntxbit&lt;= '1';\nTxBusy&lt;= '0';\nTxComp&lt;= '1';\nTx_Error&lt;= '0';\nelse\ncounter&lt;= counter+1;\nend if;\n\nwhen ErrorFrame =>\n-- Enviar quadro de erro ativo ou passivo\n\nend case;\nelse\n\nstate&lt;= ErrorFrame;\nend if;\n\nend if;\nend if;\n\nend process;\n\nend RTL;\n\nA.3.2 CAN RX\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\nentity CAN_Rx is\nport (Clock : in std_logic ;\n\nReset : in std_logic ;\nSamplePoint : in std_logic ;\n\nACKPoint : in std_logic ;\n\n\n\n155\n\nTxBusy : in std_logic ;\nRxBit : in std_logic ;\n\nStuff_Bit : in std_logic ;\nStuff_Error : in std_logic ;\nCRC : in std_logic_vector (14 downto 0) ;\nCRC_Reset : out std_logic ;\nCRC_Stop : out std_logic ;\nStuff_Disable : out std_logic ;\nACK_Tx : out std_logic ;\n\nRxBusy : out std_logic ;\nRx_Completed : out std_logic ;\nRx_Error : out std_logic ;\nID_Rx : out std_logic_vector (28 downto 0) ;\nMSG_Rx : out std_logic_vector (63 downto 0));\n\nend CAN_Rx;\n\narchitecture RTL of CAN_Rx is\n\ntype estados is (StartOfFrame, BaseID, IDEBit, ExtendedID,\nRemFrCtrlField, DataFrCtrlField, DataField,\nCRCField, ACKSlotBit, ACKDelimitBit, EndOfFrame, qerror, R1Bit);\n\nsignal estado : estados;\nsignal ACK : std_logic;\nsignal contador : std_logic_vector (6 downto 0);\nsignal campo_controle: std_logic_vector (5 downto 0);\nsignal crc_recebido : std_logic_vector (14 downto 0);\nsignal MSG_ID : std_logic_vector (28 downto 0);\nsignal MSG : std_logic_vector (63 downto 0);\n\nbegin\n\nID_Rx&lt;= MSG_ID;\nMSG_Rx&lt;= MSG;\n\n-- Processo que gera o Bit ACK\n\nprocess (Clock, Reset)\nbegin\nif Reset = '1' then\nACK_Tx&lt;= '1';\nelsif (Clock'event and Clock = '1') then\nif ACKPoint = '1' then\nif ACK = '0' then\nACK_Tx&lt;= '0';\nelse\nACK_Tx&lt;= '1';\n\n\n\n156\n\nend if;\nend if;\nend if;\nend process;\n\n-- Controlador de recep\u00e7\u00e3o de mensagem CAN\n\nprocess (Clock, Reset)\nbegin\n\nif Reset = '1' then -- Reset ass\u00edncrono\nestado&lt;= StartOfFrame;\n\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\n\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\n\nRxBusy&lt;= '0';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\nMSG_ID&lt;= (others => '0');\nMSG&lt;= (others => '0');\n\ncontador&lt;= (others => '0');\ncampo_controle&lt;= (others => '0');\ncrc_recebido&lt;= (others => '0');\n\nelsif (Clock'event and Clock = '1') then\nif SamplePoint = '1' then\n\nif Stuff_Error = '0' then\ncase estado is\n\nwhen StartOfFrame =>\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '0';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\nMSG_ID&lt;= (others => '0');\nMSG&lt;= (others => '0');\ncontador&lt;= (others => '0');\ncampo_controle&lt;= (others => '0');\ncrc_recebido&lt;= (others => '0');\n\nif RxBit = '0' then\nestado&lt;= BaseID;\n\nRxBusy&lt;= '1';\nelse\nestado&lt;= qerror;\nend if;\n\nwhen BaseID =>\n\n\n\n157\n\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\nif contador = \"0001011\" then\n\nif RxBit = '1' and Stuff_Bit = '0' then\nestado&lt;= IDEBit;\n\ncontador&lt;= (others => '0');\nelsif RxBit = '0' and Stuff_Bit = '0' then\n\nestado&lt;= DataFrCtrlField;\ncontador&lt;= (others => '0');\n\nelse\nestado&lt;= BaseID;\n\nend if;\nelse\n\nestado&lt;= BaseID;\nif Stuff_Bit = '0' then\n\ncontador&lt;= contador+1;\nMSG_ID(28 downto 18)&lt;= MSG_ID(27 downto 18) &amp; RxBit;\n\nend if;\nend if;\n\nwhen IDEBit =>\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\nif RxBit = '1' and Stuff_Bit = '0' then\nestado&lt;= ExtendedID;\n\nelsif RxBit = '0' and Stuff_Bit = '0' then\nestado&lt;= RemFrCtrlField;\n\nelse\nestado&lt;= IDEBit;\nend if;\n\nwhen ExtendedID =>\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\n\n\n158\n\nif contador = \"0010010\" then\nif RxBit = '1' and Stuff_Bit = '0' then\n\nestado&lt;= R1Bit;\ncontador&lt;= (others => '0');\n\nelsif RxBit = '0' and Stuff_Bit = '0' then\nestado&lt;= DataFrCtrlField;\n\ncontador&lt;= (others => '0');\nelse\n\nestado&lt;= ExtendedID;\nend if;\n\nelse\nestado&lt;= ExtendedID;\n\nif Stuff_Bit = '0' then\ncontador&lt;= contador+1;\n\nMSG_ID(17 downto 0)&lt;= MSG_ID(16 downto 0) &amp; RxBit;\nend if;\nend if;\n\nwhen RemFrCtrlField =>\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\nif contador = \"0000100\" then\n\nif Stuff_Bit = '0' then\nestado&lt;= CRCField;\n\ncontador&lt;= (others => '0');\ncampo_controle (5 downto 0)&lt;= campo_controle(4 downto 0) &amp; RxBit;\n\nCRC_Stop&lt;= '1';\nend if;\n\nelse\nestado&lt;= RemFrCtrlField;\nif Stuff_Bit = '0' then\ncontador&lt;= contador+1;\ncampo_controle (5 downto 0)&lt;= campo_controle(4 downto 0) &amp; RxBit;\n\nend if;\nend if;\n\nwhen DataFrCtrlField =>\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\n\n\n159\n\nif contador = \"0000101\" then\nif Stuff_Bit = '0' then\nestado&lt;= DataField;\ncontador&lt;= (others => '0');\ncampo_controle (5 downto 0)&lt;= campo_controle(4 downto 0) &amp; RxBit;\nend if;\nelse\nestado&lt;= DataFrCtrlField;\nif Stuff_Bit = '0' then\ncontador&lt;= contador+1;\ncampo_controle (5 downto 0)&lt;= campo_controle(4 downto 0) &amp; RxBit;\nend if;\nend if;\n\nwhen DataField =>\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\nif campo_controle(3 downto 0) > \"1000\" and Stuff_Bit = '0' then\n\ncampo_controle(3 downto 0)&lt;= \"1000\";\nend if;\n\nif contador = (campo_controle(3 downto 0)&amp;\"000\"-1) then\nif Stuff_Bit = '0' then\nestado&lt;= CRCField;\ncontador&lt;= (others => '0');\nMSG(63 downto 0)&lt;= MSG(62 downto 0) &amp; RxBit;\nCRC_Stop&lt;= '1';\nend if;\n\nelse\nestado&lt;= DataField;\n\nif Stuff_Bit = '0' then\ncontador&lt;= contador+1;\n\nMSG(63 downto 0)&lt;= MSG(62 downto 0) &amp; RxBit;\nend if;\n\nend if;\nwhen CRCField =>\n\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '1';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\nif contador = \"0001111\" and Stuff_Bit = '0' then\n\n\n\n160\n\nStuff_Disable&lt;= '1';\nif TxBusy = '0' then\nif crc_recebido = CRC then\nACK&lt;= '0';\nestado&lt;= ACKSlotBit; => ack_slot\ncontador&lt;= (others => '0');\nelse\nRx_Error&lt;= '1';\nestado&lt;= qerror;\nend if;\nelse\nestado&lt;= ACKSlotBit;\ncontador&lt;= (others => '0');\nend if;\nelse\nestado&lt;= CRCField;\n\nif Stuff_Bit = '0' then\ncontador&lt;= contador+1;\ncrc_recebido(14 downto 0)&lt;= crc_recebido(13 downto 0) &amp; RxBit;\nend if;\nend if;\n\nwhen ACKSlotBit =>\nCRC_Reset&lt;= '1';\n\nCRC_Stop&lt;= '1';\nStuff_Disable&lt;= '1';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\nestado&lt;= ACKDelimitBit;\nwhen ACKDelimitBit =>\n\nCRC_Reset&lt;= '1';\nCRC_Stop&lt;= '1';\nStuff_Disable&lt;= '1';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\nestado&lt;= EndOfFrame;\nwhen EndOfFrame =>\n\nCRC_Reset&lt;= '1';\nCRC_Stop&lt;= '1';\nStuff_Disable&lt;= '1';\nACK&lt;= '1';\nRxBusy&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\n\n\n161\n\nestado&lt;= EndOfFrame;\nif contador = \"0000110\" then\n\nif RxBit = '1' then\nRxBusy&lt;= '0';\nRx_Completed&lt;= '1';\nStuff_Disable&lt;= '0';\nestado&lt;= StartOfFrame;\nelse\nestado&lt;= qerror;\nend if;\nelse\nif RxBit = '1' then\ncontador&lt;= contador+1;\nelse\nestado&lt;= qerror;\nend if;\n\nend if;\nwhen R1Bit =>\n\nCRC_Reset&lt;= '0';\nCRC_Stop&lt;= '0';\nStuff_Disable&lt;= '0';\nACK&lt;= '1';\nRx_Completed&lt;= '0';\nRx_Error&lt;= '0';\n\nif Stuff_Bit = '0' then\nestado&lt;= RemFrCtrlField;\n\nelse\nestado&lt;= R1Bit;\n\nend if;\nwhen qerror =>\nStuff_Disable&lt;= '1';\n\nRx_Error&lt;= '1';\nend case;\n\nelse\nestado&lt;= qerror;\n\nend if;\nend if;\nend if;\n\nend process;\n\nend RTL;\n\nA.3.3 CRC\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\n\n\n162\n\nuse ieee.std_logic_unsigned.all;\n\nentity CAN_CRC is\nport (Clock : in std_logic;\nReset : in std_logic;\n\nSamplePoint : in std_logic;\nCAN_Bit : in std_logic;\n\nStuff_Bit : in std_logic;\nCRC_Stop : in std_logic;\nCRC_Sequence: out std_logic_vector (14 downto 0));\n\nend CAN_CRC;\n\narchitecture Comportamental of CAN_CRC is\n\nsignal NXTBIT: std_logic;\n\nbegin\n\nNXTBIT&lt;= CAN_Bit;\n\n-- Processo que calcula a sequ\u00eancia de CRC\n\nprocess (Clock, Reset)\nvariable CRCNXT : std_logic;\nvariable CRC_RG : std_logic_vector (14 downto 0);\nbegin\n\nif Reset = '1' then\nCRCNXT := '1';\n\nCRC_RG := (others => '0');\nCRC_Sequence&lt;= (others => '0');\nelsif (Clock'event and Clock = '1') then\n\nif CRC_Stop = '0' then\nif SamplePoint = '1' then\n\nif Stuff_Bit = '0' then\nCRCNXT := NXTBIT xor CRC_RG(14);\n\nCRC_RG(14 downto 1) := CRC_RG(13 downto 0);\nCRC_RG(0) := '0';\nif CRCNXT = '1' then\nCRC_RG(14 downto 0) := CRC_RG(14 downto 0) xor \"100010110011001\";\nend if;\n\nCRC_Sequence&lt;= CRC_RG;\nend if;\n\nend if;\nend if;\n\nend if;\nend process;\n\n\n\n163\n\nend Comportamental;\n\nA.3.4 STUFF HANDLER\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\nentity CAN_Bit_Stuffing is\nport (Clock : in std_logic ;\n\nReset : in std_logic ;\nRxBit : in std_logic ;\n\nSamplePoint: in std_logic ;\nStuff_Bit : out std_logic ;\nStuff_Error: out std_logic);\n-- Stuff_Rx : out std_logic ;\n-- Stuff_Tx : out std_logic ;\nend CAN_Bit_Stuffing;\n\narchitecture RTL of CAN_Bit_Stuffing is\n\ntype estados is (Idle, Dominant1, Dominant2, Dominant3,\nDominant4, Dominant5, Recessive1,\nRecessive2, Recessive3, Recessive4,\nRecessive5, Error);\n\nsignal estado: estados;\n\nbegin\n\n-- Processo que realiza o controle de \"Bit Stuffing\"\n\nprocess (Clock, Reset)\nbegin\nif Reset = '1' then\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nestado&lt;= Idle;\nelsif (Clock'event and Clock = '1') then\n\nif SamplePoint = '1' then\ncase estado is\n\nwhen Idle =>\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant1;\n\n\n\n164\n\nelse\nStuff_Error&lt;= '1';\n\nestado&lt;= Error; resetado por CAN_Tx.\nend if;\n\nwhen Dominant1 =>\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant2;\n\nelse\nestado&lt;= Recessive1;\n\nend if;\nwhen Dominant2 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant3;\n\nelse\nestado&lt;= Recessive1;\n\nend if;\nwhen Dominant3 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant4;\n\nelse\nestado&lt;= Recessive1;\n\nend if;\nwhen Dominant4 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nStuff_Bit&lt;= '1';\nestado&lt;= Dominant5;\n\nelse\nestado&lt;= Recessive1;\n\nend if;\nwhen Dominant5 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\nif RxBit = '0' then\n\nStuff_Error&lt;= '1';\nestado&lt;= Error;\nelse\nestado&lt;= Recessive1;\nend if;\n\nwhen Recessive1 =>\n\n\n\n165\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant1;\n\nelse\nestado&lt;= Recessive2;\n\nend if;\nwhen Recessive2 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant1;\n\nelse\nestado&lt;= Recessive3;\n\nend if;\nwhen Recessive3 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant1;\n\nelse\nestado&lt;= Recessive4;\n\nend if;\nwhen Recessive4 =>\n\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\n\nif RxBit = '0' then\nestado&lt;= Dominant1;\n\nelse\nStuff_Bit&lt;= '1';\n\nestado&lt;= Recessive5;\nend if;\n\nwhen Recessive5 =>\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '0';\nif RxBit = '0' then\nestado&lt;= Dominant1;\nelse\nStuff_Error&lt;= '1';\nestado&lt;= Error;\nend if;\nwhen Error =>\nStuff_Bit&lt;= '0';\nStuff_Error&lt;= '1';\nestado&lt;= Error;\n\nend case;\nend if;\n\n\n\n166\n\nend if;\nend process;\nend RTL;\n\nA.3.5 BIT TIMING 1\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\nentity CAN_Bit_Timing is\nport (Clock: in std_logic;\nReset: in std_logic;\nRxBit: in std_logic;\nEndFr: in std_logic;\nBRP : in std_logic_vector(5 downto 0);\nPRSEG: in std_logic_vector(2 downto 0);\nPSEG1: in std_logic_vector(2 downto 0);\nPSEG2: in std_logic_vector(2 downto 0);\nSJW : in std_logic_vector(1 downto 0);\nACKPoint : out std_logic;\nSamplePoint: out std_logic);\nend CAN_Bit_Timing;\n\narchitecture RTL of CAN_Bit_Timing is\n\ntype estados is (Idle, SyncSeg, PropSeg, PhaseSeg1, PhaseSeg2);\n\nsignal estado : estados;\nsignal liberaTq : std_logic;\nsignal TimeQuantum : std_logic;\nsignal BRPCounter : std_logic_vector(5 downto 0);\nsignal PRSEGCounter: std_logic_vector(2 downto 0);\nsignal PSEG1Counter: std_logic_vector(2 downto 0);\nsignal PSEG2Counter: std_logic_vector(2 downto 0);\n\nbegin\n\n-- Processo que gera o TimeQuantum a partir do Clock e do\nBRP (Baud Rate Prescaler)\n\nprocess (Clock, Reset)\nbegin\nif (Reset = '1') then\nTimeQuantum&lt;= '0';\n\n\n\n167\n\nBRPCounter&lt;= (others => '0');\nelsif (Clock'event and Clock = '1') then\nif liberaTq = '1' then\nif (BRPCounter = BRP-1) then\nTimeQuantum&lt;= '1';\nBRPCounter&lt;= (others => '0');\nelse\nTimeQuantum&lt;= '0';\nBRPCounter&lt;= BRPCounter+1;\nend if;\nelse\nTimeQuantum&lt;= '0';\nBRPCounter&lt;= (others => '0');\nend if;\nend if;\nend process;\n\n-- Processo que controla a transi\u00e7\u00e3o de estados entre os\nsegmentos de tempo de um bit CAN\n\nprocess (Clock, Reset)\nbegin\nif (Reset = '1') then\nPRSEGCounter&lt;= (others => '0');\nPSEG1Counter&lt;= (others => '0');\nPSEG2Counter&lt;= (others => '0');\nestado&lt;= Idle;\nelsif (Clock'event and Clock = '1') then\ncase estado is\nwhen Idle =>\nACKPoint&lt;= '0';\nSamplePoint&lt;= '0';\nliberaTq&lt;= '0';\nif RxBit = '0' then\nliberaTq&lt;= '1';\nestado&lt;= SyncSeg;\nend if;\nwhen SyncSeg =>\nACKPoint&lt;= '1';\nSamplePoint&lt;= '0';\nliberaTq&lt;= '1';\nif TimeQuantum = '1' then\nestado&lt;= PropSeg;\nend if;\nwhen PropSeg =>\nACKPoint&lt;= '0';\nSamplePoint&lt;= '0';\n\n\n\n168\n\nliberaTq&lt;= '1';\nif TimeQuantum = '1' then\nif (PRSEGCounter = PRSEG-1) then\nestado&lt;= PhaseSeg1;\nPRSEGCounter&lt;= (others => '0');\nelse\nPRSEGCounter&lt;= PRSEGCounter+1;\nend if;\nend if;\nwhen PhaseSeg1 =>\nACKPoint&lt;= '0';\nSamplePoint&lt;= '0';\nliberaTq&lt;= '1';\nif TimeQuantum = '1' then\nif (PSEG1Counter = PSEG1-1) then\nSamplePoint&lt;= '1';\nestado&lt;= PhaseSeg2;\nPSEG1Counter&lt;= (others => '0');\nelse\nPSEG1Counter&lt;= PSEG1Counter+1;\nend if;\nend if;\nwhen PhaseSeg2 =>\nACKPoint&lt;= '0';\nSamplePoint&lt;= '0';\nliberaTq&lt;= '1';\nif TimeQuantum = '1' then\nif (PSEG2Counter = PSEG2-1) and EndFr = '1' then\nliberaTq&lt;= '0';\nestado&lt;= Idle;\nPSEG2Counter&lt;= (others => '0');\nelsif (PSEG2Counter = PSEG2-1) then\nestado&lt;= SyncSeg;\nPSEG2Counter&lt;= (others => '0');\nelse\nPSEG2Counter&lt;= PSEG2Counter+1;\nend if;\nend if;\nend case;\nend if;\nend process;\n\nend RTL;\n\nA.3.6 BIT TIMING 2\n\n\n\n169\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\nentity CAN_Bit_Timing2 is\nport (Clock : in std_logic;\nReset : in std_logic;\nTxReq : in std_logic;\nRxBusy : in std_logic;\nTxComp : in std_logic;\nBRP : in std_logic_vector(5 downto 0);\nPRSEG : in std_logic_vector(2 downto 0);\nPSEG1 : in std_logic_vector(2 downto 0);\nPSEG2 : in std_logic_vector(2 downto 0);\nResetTx: out std_logic;\nTxPoint: out std_logic);\nend CAN_Bit_Timing2;\n\narchitecture RTL of CAN_Bit_Timing2 is\n\ntype estados is (Idle, Transmission);\n\nsignal estado : estados;\nsignal liberaTq : std_logic;\nsignal TimeQuantum : std_logic;\nsignal BRPCounter : std_logic_vector(5 downto 0);\nsignal Counter : std_logic_vector(4 downto 0);\n\nbegin\n\n-- Processo que gera o TimeQuantum a partir do Clock e do\nBRP (Baud Rate Prescaler)\n\nprocess (Clock, Reset)\nbegin\nif (Reset = '1') then\nTimeQuantum&lt;= '0';\nBRPCounter&lt;= (others => '0');\nelsif (Clock'event and Clock = '1') then\nif liberaTq = '1' then\nif (BRPCounter = BRP-1) then\nTimeQuantum&lt;= '1';\nBRPCounter&lt;= (others => '0');\nelse\nTimeQuantum&lt;= '0';\nBRPCounter&lt;= BRPCounter+1;\nend if;\n\n\n\n170\n\nelse\nTimeQuantum&lt;= '0';\nBRPCounter&lt;= (others => '0');\nend if;\nend if;\nend process;\n\n-- Processo que gera o TxPoint a partir do TimeQuantum\n\nprocess (Clock, Reset)\nbegin\nif (Reset = '1') then\nestado&lt;= Idle;\nliberaTq&lt;= '0';\nCounter&lt;= (others => '0');\nelsif (Clock'event and Clock = '1') then\ncase estado is\nwhen Idle =>\nTxPoint&lt;= '0';\nliberaTq&lt;= '0';\nResetTx&lt;= '0';\nestado&lt;= Idle;\nCounter&lt;= (others => '0');\nif TxReq = '1' and RxBusy = '0' then\nTxPoint&lt;= '1';\nliberaTq&lt;= '1';\nResetTx&lt;= '1';\nestado&lt;= Transmission;\nend if;\nwhen Transmission =>\nTxPoint&lt;= '0';\nliberaTq&lt;= '1';\nResetTx&lt;= '0';\nestado&lt;= Transmission;\nif TxComp = '1' then\nliberaTq&lt;= '0';\nestado&lt;= Idle;\nCounter&lt;= (others => '0');\nelsif TimeQuantum = '1' then\n--if TimeQuantum = '1' then\nif Counter = PRSEG+PSEG1+PSEG2 then\nTxPoint&lt;= '1';\nCounter&lt;= (others => '0');\nelse\nCounter&lt;= Counter+1;\nend if;\nend if;\n\n\n\n171\n\nend case;\nend if;\nend process;\n\nend RTL;\n\n\n\nAp\u00eandice B\n\nC\u00f3digos C e MATLAB\n\nNeste ap\u00eandice est\u00e3o listados os c\u00f3digos do ampli?cador sens\u00edvel \u00e0 fase digital imple-\n\nmentado utilizando microcomputador com placa de aquisi\u00e7\u00e3o de dados, escritos nas\n\nlinguagens C e MATLAB .\n\nB.1 Programa de Aquisi\u00e7\u00e3o de Dados com a Placa\n\nDAS-20 em Linguagem C\n\n/* Aquisi\u00e7\u00e3o de Dados */\n\n#include \"lockin.h\"\n\n/* Imprime as informa\u00e7\u00f5es sobre o programa e retorna os par\u00e2metros do\nsinal de teste */\n\ndouble parametros (void)\n\n{\ndouble amplitude;\n\nprintf (\"\\t\\t%s\\n \\t\\t%s\\n \\t\\t%s\\n \\t\\t%s\\n \\t\\t%s\\n\\n \\t\\t%s\\n\\n\",\n\" ********************************************** \",\n\" Universidade Federal de Pernambuco \",\n\" Departamento de Eletronica e Sistemas \",\n\" Laboratorio de Dispositivos e Nanoestruturas \",\n\" ********************************************** \",\n\" Amplificador Lock-in Digital \");\n\nprintf (\"Parametros pre-definidos: \\n\");\n\n172\n\n\n\n173\n\nprintf (\" - Frequencia: 1000 Hz \\n\");\nprintf (\" - Fase: 0 graus \\n\\n\");\nprintf (\"Parametros a definir: \\n\");\nprintf (\" - Amplitude: - 5 V a + 5 V \\n\");\nprintf (\"Digite a amplitude do sinal (V): \");\nscanf (\"%lf\", &amp;amplitude);\n\nwhile (amplitude &lt;-5 || amplitude > 5)\n{\n\nprintf (\"Amplitude invalida. Por favor, digite novamente\\n\\n\");\nprintf (\"Digite a amplitude do sinal (V): \");\nscanf (\"%lf\", &amp;amplitude);\n\n}\n\nreturn amplitude;\n}\n\n/* Inicializa e configura a Placa DAS-20 */\n\nvoid inicializa_placa (void)\n\n{\n/* Reseta a Placa DAS-20 */\n\nprintf (\"Iniciando o Programa ... \\n\\n\");\n\nprintf(\"Resetando a Placa DAS-20 ... \");\ndas20_master_reset();\nprintf(\"OK\\n\");\n\n/* Gera a Taxa de Amostragem */\n\nprintf(\"Gerando a Taxa de Amostragem ... \");\ngenerate_freq(2, 100000, 0.50);\n\n/* Timer = 2, Frequencia = 100 kHz, Ciclo de Trabalho = 50% */\nprintf(\"OK\\n\");\n\n/* Seleciona o Timer 2 para causar uma interrup\u00e7\u00e3o */\n\nprintf(\"Configurando Interrupcoes ... \");\nset_int_source(INT_TMR2);\nprintf(\"OK\\n\");\n\n/* Dispara o Timer 2 */\n\nprintf(\"Selecionando Temporizadores ... \");\narm_timers(2, 0);\n\n\n\n174\n\nprintf(\"OK\\n\\n\");\n\nprintf(\"Iniciando a Aquisicao de Dados ... \\n\");\n}\n\n/* Realiza a aquisicao de dados */\n\nvoid aquisicao (double amplitude)\n\n{\nint k;\ndouble T[80000], Vteste[80000], Vent[80000];\nFILE* arquivo;\n\narquivo = fopen(\"aquisicao.txt\",\"w\");\n\nfor (k=0; k &lt;10000; k++)\n{\n\nwhile (int_pending() == 0);\n/* Fica aqui at\u00e9 ocorrer uma interrup\u00e7\u00e3o */\n\nint_clear(); /* Limpa \"flag\" de interrup\u00e7\u00e3o */\n\n/* Tempo da amostragem */\nT[k] = 0.00001 * k;\n\n/* Sinal de teste */\nVteste[k] = (double) amplitude * cos (2 * 3.1415 * 10000 * T[k]);\n\n/* Faz a convers\u00e3o D/A no Canal 0 com valor Vteste) */\nsingle_dac(0,Vteste[k]);\n\n/* Faz a Convers\u00e3o A/D no Canal 0 e\nFaixa de Opera\u00e7\u00e3o 2 (-10 V a 10 V)*/\n\nVent[k] = single_adc(0,2);\n\n}\n\nfor (k = 0; k&lt;10000; k ++)\n\n{\n\nfprintf(arquivo,\" %9.6lf, %9.6lf, %9.6lf \\n\", T[k], Vteste[k],Vent[k]);\n\n}\n\n\n\n175\n\nfclose(arquivo);\n}\n\n/* Reseta a Placa DAS-20 e finaliza o Programa */\n\nvoid finaliza_placa (void)\n\n{\nprintf(\"Finalizando o Programa ... \\n\\n\");\n\ndas20_master_reset();\ndas20_cleanup();\n\n}\n\nB.2 Programas Usados na Implementa\u00e7\u00e3o da T\u00e9c-\n\nnicaLock-in em MATLAB\n\nB.2.1 lockincal.m\n\n% Amplificador Lock-in Digital utilizando o MATLAB %\n\n% Programa de Calibra\u00e7ao do Amplificador Lock-in Digital %\n\n% AUTOR: Jos\u00e9 Edenilson Oliveira Reges %\n\n% LDN - Laborat\u00f3rio de Dispositivos e Nanoestruturas %\n% DES - Departamento de Eletr\u00f4nica e Sistemas %\n% UFPE - Universidade Federal de Pernambuco %\n\nload aquisicao.txt;\n\n% Par\u00e2metros utilizados %\n\nf = 1000; % Freq\u00fc\u00eancia do sinal de refer\u00eancia %\nA = max (aquisicao(:,2)) % Amplitude do sinal de refer\u00eancia %\nRc = 993; % Resistor do conversor corrente/tensao %\n\n% 1. Calibra\u00e7\u00e3o do Amplificador Lock-in Digital %\n\n% 1. Sinal de Referencia\n\n% 1.2 Componente em fase %\n\nVfase = 1 * sin (2 * pi * f * aquisicao(:,1));\nplot (aquisicao(:,1), Vfase);\nxlabel ('Tempo (s)'), ylabel ('Vfase (V)');\n\n\n\n176\n\n% 1.3 Componente em quadratura %\n\nVquad = 1 * cos (2 * pi * f * aquisicao(:,1));\nplot (aquisicao(:,1), Vquad);\nxlabel ('Tempo (s)'), ylabel ('Vquad (V)');\n\n% 2. Aquisi\u00e7ao dos Sinais\n\n% 2.1 Sinal de Teste\n\nVteste = aquisicao(:,2);\nplot (aquisicao(:,1),aquisicao(:,2));\nxlabel ('Tempo (s)'), ylabel ('Vteste (V)');\n\n% 2.2 Sinal de Entrada\n\nVent = aquisicao(:,3);\nplot (aquisicao(:,1),aquisicao(:,3));\nxlabel ('Tempo (s)'), ylabel ('Vent (V)');\n\n% 4. Multiplicador %\n\nVdet1 = Vent .* Vfase;\nplot (aquisicao(:,1), Vdet1);\nxlabel ('Tempo (s)'), ylabel ('Vdet1 (V)');\n\nVdet2 = Vent .* Vquad;\nplot (aquisicao(:,1), Vdet2);\nxlabel ('Tempo (s)'), ylabel ('Vdet2 (V)');\n\n% 5. Filtro Passa-Baixa %\n\nX = mean (Vdet1)\nplot (aquisicao(:,1), X);\nxlabel ('Tempo (s)'), ylabel ('Canal X');\n\nY = mean (Vdet2)\nplot (aquisicao(:,1), Y);\nxlabel ('Tempo (s)'), ylabel ('Canal Y');\n\n% 1.7. Ajuste de Fase %\n\nerro_graus = -((atan2(X,Y) * (180/pi)) - 90)\n\nerro_rad = erro_graus * (pi/180)\n\n\n\n177\n\nB.2.2 lockinmed.m\n\n% Amplificador Lock-in Digital utilizando o MATLAB %\n\n% Programa de medi\u00e7ao com o amplificador lock-in %\n\n% AUTOR: Jos\u00e9 Edenilson Oliveira Reges %\n\n% LDN - Laborat\u00f3rio de Dispositivos e Nanoestruturas %\n% DES - Departamento de Eletr\u00f4nica e Sistemas %\n% UFPE - Universidade Federal de Pernambuco %\n\nload aquisicao.txt;\n\n% Par\u00e2metros utilizados %\n\nf = 1000; % Freq\u00fc\u00eancia do sinal de refer\u00eancia %\nA = max (aquisicao(:,2)) % Amplitude do sinal de refer\u00eancia %\nRc = 993; % Resistor do conversor corrente/tensao %\n\n% Simula\u00e7ao de Medi\u00e7\u00f5es utilizando o Amplificador Lock-in Digital %\n\n% 1. Sinal de Referencia\n\n% 1.2 Componente em fase %\n\nVfase = 1 * sin (2 * pi * f * aquisicao(:,1) + erro_rad);\nplot (aquisicao(:,1), Vfase);\nxlabel ('Tempo (s)'), ylabel ('Vfase (V)');\n\n% 1.3 Componente em quadratura %\n\nVquad = 1 * cos (2 * pi * f * aquisicao(:,1) + erro_rad);\nplot (aquisicao(:,1), Vquad);\nxlabel ('Tempo (s)'), ylabel ('Vquad (V)');\n\n% 2. Aquisi\u00e7ao dos Sinais\n\n% 2.1 Sinal de Teste\n\nVteste = aquisicao(:,2);\nplot (aquisicao(:,1),aquisicao(:,2));\nxlabel ('Tempo (s)'), ylabel ('Vteste (V)');\n\n% 2.2 Sinal de Entrada\n\nVent = aquisicao(:,3);\n\n\n\n178\n\nplot (aquisicao(:,1),aquisicao(:,3));\nxlabel ('Tempo (s)'), ylabel ('Vent (V)');\n\n% 4. Multiplicador %\n\nVdet1 = Vent .* Vfase;\nplot (aquisicao(:,1), Vdet1);\nxlabel ('Tempo (s)'), ylabel ('Vdet1 (V)');\n\nVdet2 = Vent .* Vquad;\nplot (aquisicao(:,1), Vdet2);\nxlabel ('Tempo (s)'), ylabel ('Vdet2 (V)');\n\n% 5. Filtro Passa-Baixa %\n\nX = mean (Vdet1)\nplot (aquisicao(:,1), X);\nxlabel ('Tempo (s)'), ylabel ('Canal X');\n\nY = mean (Vdet2)\nplot (aquisicao(:,1), Y);\nxlabel ('Tempo (s)'), ylabel ('Canal Y');\n\n% 6. C\u00e1lculo da Resist\u00eancia %\n\nR = - (1/2) * (A / X) * Rc\n\n% 7. C\u00e1lculo da Capacit\u00e2ncia %\n\nC = - 2 * (Y / A) * (1 / (Rc * 2 * pi * f))\n\n\n\nAp\u00eandice C\n\nC\u00f3digos ASM\n\nNeste ap\u00eandice est\u00e3o listados os c\u00f3digos ASM utilizados na programa\u00e7\u00e3o dos m\u00f3dulos\n\nCAN implementados com microcontroladores PIC 18F258.\n\nC.1 N\u00f3 0\n\nCONFIG DEBUG = ON ; HABILITA DEPURA\u00c7\u00c3O DE ERROS VIA ICD3 DEBUGGER\n\n#INCLUDE&lt;P18F258.INC> ; INCLUI O ARQUIVO DE DEFINI\u00c7\u00d5ES DO PIC18F258\n\nORG 0X0000 ; VETOR RESET.\n\nMOVLB B'00001111' ; BANCO 15\n\n;************************************************************************\n; CONFIGURA\u00c7\u00c3O DOS PINOS DE E/S *\n;************************************************************************\n\nBSF TRISC,7 ; DEFINE RC7/RX/DT COMO ENTRADA.\nBCF TRISC,6 ; DEFINE RC6/TX/CK COMO SA\u00cdDA.\nBSF TRISB,3 ; DEFINE RB3/CANRX COMO ENTRADA.\nBCF TRISB,2 ; DEFINE RB2/CANTX/INT2 COMO SA\u00cdDA.\n\n;************************************************************************\n; CONFIGURA\u00c7\u00c3O DA USART *\n;************************************************************************\n\nMOVLW .129 ; FOSC = 20 MHz, BAUD RATE = 9600 bps, BRGH = 1.\nMOVWF SPBRG ; DEFINE BAUD RATE = 9600 bps.\n\n179\n\n\n\n180\n\nMOVLW B'00100100' ; TXEN = 1 (HABILITA TRANSMISS\u00c3O), BRGH = 1 (ALTA VELOCIDADE).\nMOVWF TXSTA ; CONFIGURA TRANSMISS\u00c3O.\n\nMOVLW B'10010000' ; SPEN = 1 (HABILITA RECEP\u00c7\u00c3O), CREN = 1 (RECEP\u00c7\u00c3O CONT\u00cdNUA).\nMOVWF RCSTA ; CONFIGURA RECEP\u00c7\u00c3O.\n\n;************************************************************************\n; CONFIGURA\u00c7\u00c3O DO M\u00d3DULO CAN *\n;************************************************************************\n\nMOVLW B'10000000' ; REQOP2 = 1.\nMOVWF CANCON ; HABILITA MODO DE CONFIGURA\u00c7\u00c3O DO M\u00d3DULO CAN.\n\nAGUARDA_OPMODE2\n\nBTFSS CANSTAT,OPMODE2 ; M\u00d3DULO CAN PRONTO PARA SER CONFIGURADO ?\nGOTO AGUARDA_OPMODE2 ; N\u00c3O. AGUARDA OPMODE2 IR PARA N\u00cdVEL ALTO.\n; SIM. CONFIGURA M\u00d3DULO CAN.\n\nMOVLW B'00000100' ; SJW = 1TQ, BRP = 04h, TQ = 500ns, BAUD RATE = 125 kHz\nMOVWF BRGCON1 ; CONFIGURA BAUD RATE CONTROL REGISTER 1.\n\nMOVLW B'10110001' ; PHASE_SEG1 = 7 TQ, PROP_SEG = 2 TQ\nMOVWF BRGCON2 ; CONFIGURA BAUD RATE CONTROL REGISTER 2.\n\nMOVLW B'00000101' ; PHASE_SEG2 = 6 TQ\nMOVWF BRGCON3 ; CONFIGURA BAUD RATE CONTROL REGISTER 3.\n\nMOVLW B'11111111' ; TODAS AS M\u00c1SCARAS HABILITADAS PARA O BUFFER 0\nMOVWF RXM0SIDH\n\nMOVLW B'11100000' ; TODAS AS M\u00c1SCARAS HABILITADAS PARA O BUFFER 0\nMOVWF RXM0SIDL\n\nMOVLW B'11111111' ; TODAS AS M\u00c1SCARAS HABILITADAS PARA O BUFFER 1\nMOVWF RXM1SIDH\n\nMOVLW B'11100000' ; TODAS AS M\u00c1SCARAS HABILITADAS PARA O BUFFER 1\nMOVWF RXM1SIDL\n\nMOVLW B'11100110' ; N\u00d3 0: ID = 11100110000\nMOVWF RXF0SIDH\n\nMOVLW B'00000000'\nMOVWF RXF0SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\n\n\n\n181\n\nMOVWF RXF1SIDH\n\nMOVLW B'00000000'\nMOVWF RXF1SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF2SIDH\n\nMOVLW B'00000000'\nMOVWF RXF2SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF3SIDH\n\nMOVLW B'00000000'\nMOVWF RXF3SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF4SIDH\n\nMOVLW B'00000000'\nMOVWF RXF4SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF5SIDH\n\nMOVLW B'00000000'\nMOVWF RXF5SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXB0CON ; RXM1:RXM0 = 00 (RECEBE TODAS MENSAGENS V\u00c1LIDAS)\n\nMOVLW B'00000000' ; REQOP = 000 (MODO DE OPERA\u00c7\u00c3O NORMAL).\nMOVWF CANCON ; PASSA O M\u00d3DULO CAN PARA O MODO DE OPERA\u00c7\u00c3O NORMAL.\n\n;************************************************************************\n; PROGRAMA PRINCIPAL *\n;************************************************************************\n\nENVIA_MENSAGEM_NO_1\n\nMOVLW B'11100110'; N\u00d3 1: ID = 11100110001\nMOVWF TXB0SIDH ; CARREGA SID10:SID3\n\nMOVLW B'00100000'; CARREGA SID2:SID1\nMOVWF TXB0SIDL ; TXB0SIDL,3 = EXIDE = 0 (ID PADR\u00c3O)\n\n\n\n182\n\nMOVLW B'01000000'; QUADRO REMOTO (RTR = 1), 0 BYTES DE DADOS\nMOVWF TXB0DLC\n\nBSF TXB0CON,TXREQ ; ENVIA MENSAGEM QUANDO O BARRAMENTO CAN ESTIVER LIVRE\n\nAGUARDA_ENVIO_NO_1\n\nBTFSS PIR3,TXB0IF ; MENSAGEM ENVIADA ?\nGOTO AGUARDA_ENVIO_NO_1 ; N\u00c3O. AGUARDA ENVIO.\nBCF TXB0CON,TXREQ ; SIM. LIMPA FLAG DE REQUISI\u00c7\u00c3O DE TRANSMISS\u00c3O.\n\nAGUARDA_RESPOSTA_NO_1\n\nBTFSS PIR3,RXB0IF ; FOI RECEBIDA MENSAGEM NO BUFFER 0 ?\nGOTO AGUARDA_RESPOSTA_NO_1; N\u00c3O. AGUARDA.\nBCF PIR3,RXB0IF ; SIM. LIMPA FLAG DE MENSAGEM RECEBIDA NO BUFFER 0.\nMOVF RXB0D0,W ; MOVE DADO DA MENSAGEM RECEBIDA PARA W.\n\nENVIA_DADO_PC\n\nBTFSS TXSTA,TRMT ; PRONTO PARA TRANSMITIR PARA O PC ?\nGOTO ENVIA_DADO_PC ; N\u00c3O. ESPERA.\nMOVWF TXREG ; SIM. ENVIA DADO PARA O PC.\nGOTO ENVIA_MENSAGEM_NO_1 ;\n\n;************************************************************************\n; FIM DO PROGRAMA *\n;************************************************************************\n\nEND\n\nC.2 N\u00f3 1\n\nCONFIG DEBUG = ON ; HABILITA DEPURA\u00c7\u00c3O DE ERROS VIA ICD3 DEBUGGER\n\n#INCLUDE&lt;P18F258.INC> ; INCLUI O ARQUIVO DE DEFINI\u00c7\u00d5ES DO PIC18F258\n\nORG 0X0000 ; VETOR RESET.\n\nMOVLB B'00001111' ; BANCO 15\n\n;************************************************************************\n; CONFIGURA\u00c7\u00c3O DOS PINOS DE E/S *\n;************************************************************************\n\nBSF TRISB,3 ; DEFINE RB3/CANRX COMO ENTRADA.\n\n\n\n183\n\nBCF TRISB,2 ; DEFINE RB2/CANTX/INT2 COMO SA\u00cdDA.\n\n;************************************************************************\n; INICIA CONFIGURA\u00c7\u00c3O DO M\u00d3DULO CAN *\n;************************************************************************\n\nMOVLW B'10000000' ; REQOP2 = 1.\nMOVWF CANCON ; HABILITA MODO DE CONFIGURA\u00c7\u00c3O DO M\u00d3DULO CAN.\n\nAGUARDA_OPMODE2\n\nBTFSS CANSTAT,OPMODE2 ; M\u00d3DULO CAN PRONTO PARA SER CONFIGURADO ?\nGOTO AGUARDA_OPMODE2 ; N\u00c3O. AGUARDA OPMODE2 IR PARA N\u00cdVEL ALTO.\n; SIM. CONFIGURA M\u00d3DULO CAN.\n\nMOVLW B'00000100' ; SJW = 1TQ, BRP = 04h, TQ = 500ns, BAUD RATE = 125 kHz\nMOVWF BRGCON1 ; CONFIGURA BAUD RATE CONTROL REGISTER 1.\n\nMOVLW B'10110001' ; PHASE_SEG1 = 7 TQ, PROP_SEG = 2 TQ\nMOVWF BRGCON2 ; CONFIGURA BAUD RATE CONTROL REGISTER 2.\n\nMOVLW B'00000101' ; PHASE_SEG2 = 6 TQ\nMOVWF BRGCON3 ; CONFIGURA BAUD RATE CONTROL REGISTER 3.\n\nMOVLW B'11111111' ; HABILITA TODAS AS M\u00c1SCARAS DO BUFFER 0\nMOVWF RXM0SIDH\n\nMOVLW B'11100000' ; HABILITA TODAS AS M\u00c1SCARAS DO BUFFER 0\nMOVWF RXM0SIDL\n\nMOVLW B'11111111' ; HABILITA TODAS AS M\u00c1SCARAS DO BUFFER 1\nMOVWF RXM1SIDH\n\nMOVLW B'11100000' ; HABILITA TODAS AS M\u00c1SCARAS DO BUFFER 1\nMOVWF RXM1SIDL\n\nMOVLW B'11100110' ; N\u00d3 1: ID = 11100110001\nMOVWF RXF0SIDH\n\nMOVLW B'00100000'\nMOVWF RXF0SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF1SIDH\n\nMOVLW B'00000000'\nMOVWF RXF1SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\n\n\n184\n\nMOVLW B'00000000'\nMOVWF RXF2SIDH\n\nMOVLW B'00000000'\nMOVWF RXF2SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF3SIDH\n\nMOVLW B'00000000'\nMOVWF RXF3SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF4SIDH\n\nMOVLW B'00000000'\nMOVWF RXF4SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'00000000'\nMOVWF RXF5SIDH\n\nMOVLW B'00000000'\nMOVWF RXF5SIDL ; RXF0SIDL,3 = EXIDEN = 0 (ID PADR\u00c3O).\n\nMOVLW B'01100000' ; RXM1:RXM0 = 11: RECEBE TODAS AS MENSAGENS (QUADRO REMOTO)\nMOVWF RXB0CON\n\nMOVLW B'00000000' ; REQOP = 000 (MODO DE OPERA\u00c7\u00c3O NORMAL).\nMOVWF CANCON ; PASSA O M\u00d3DULO CAN PARA O MODO DE OPERA\u00c7\u00c3O NORMAL.\n\n;************************************************************************\n; PROGRAMA PRINCIPAL *\n;************************************************************************\nINICIO\n\nAGUARDA_MENSAGEM_NO_0\n\nBTFSS PIR3,RXB0IF ; FOI RECEBIDA MENSAGEM NO BUFFER 0 ?\nGOTO AGUARDA_MENSAGEM_NO_0; N\u00c3O. AGUARDA.\nBCF PIR3,RXB0IF ; SIM. LIMPA FLAG DE MENSAGEM RECEBIDA NO BUFFER 0.\n\nENVIA_MENSAGEM_NO_0\n\nMOVLW B'11100110'; N\u00d3 0: ID = 11100110000\nMOVWF TXB0SIDH ; CARREGA SID10:SID3\n\n\n\n185\n\nMOVLW B'00000000'; CARREGA SID2:SID1\nMOVWF TXB0SIDL ; TXB0SIDL,3 = EXIDE = 0 (ID PADR\u00c3O)\n\nMOVLW B'00000001'; QUADRO DE DADOS (RTR = 0), 1 BYTE DE DADOS\nMOVWF TXB0DLC\n\nMOVLW B'01000001'; DADO = 01000001 = A (ASCII)\nMOVWF TXB0D0\n\nBSF TXB0CON,TXREQ ; ENVIA MENSAGEM QUANDO O BARRAMENTO CAN ESTIVER LIVRE\n\nAGUARDA_ENVIO_NO_0\n\nBTFSS PIR3,TXB0IF ; MENSAGEM ENVIADA ?\nGOTO AGUARDA_ENVIO_NO_0 ; N\u00c3O. AGUARDA ENVIO.\nBCF TXB0CON,TXREQ ; SIM. LIMPA FLAG DE REQUISI\u00c7\u00c3O DE TRANSMISS\u00c3O.\nGOTO AGUARDA_MENSAGEM_NO_0\n\n;************************************************************************\n; FIM DO PROGRAMA *\n;************************************************************************\n\nEND\n\n\n\nAp\u00eandice D\n\nSOTR para Aquisi\u00e7\u00e3o de Dados e\n\nComunica\u00e7\u00e3o\n\nNeste ap\u00eandice \u00e9 apresentada a especi?ca\u00e7\u00e3o de um Sistema Operacional de Tempo\n\nReal (SOTR) embarcado para gerenciamento de aquisi\u00e7\u00e3o de dados e comunica\u00e7\u00e3o\n\nutilizando o microcontrolador LAMPI\u00c3O e o m\u00f3dulo de acesso \u00e0 rede MARIA.\n\nA motiva\u00e7\u00e3o deste trabalho \u00e9 desenvolver um SOTR embarcado que possa ser\n\nimplementado no microcontrolador LAMPI\u00c3O. Este SOTR embarcado deve ser ca-\n\npaz de gerenciar a aquisi\u00e7\u00e3o de dados realizada por um ampli?cador sens\u00edvel \u00e0 fase\n\ndigital e a transfer\u00eancia de dados realizada pela interface de rede MARIA, via bar-\n\nramento CAN. O conjunto formado pelo microcontrolador LAMPI\u00c3O, ampli?cador\n\nlock-in digital e interface de rede MARIA faz parte do sensor inteligente integrado\n\nem desenvolvimento no LDN.\n\nTipicamente, sistemas microcontrolados s\u00e3o implementados utilizando-se uma \u00fa-\n\nnica rotina (principal) e algumas sub-rotinas (auxiliares). Basicamente, o programa\n\nprincipal l\u00ea as entradas do microcontrolador, executa o algoritmo de controle do\n\nprocesso e atualiza as sa\u00eddas do microcontrolador. Esta estrat\u00e9gia funciona bem em\n\nsistemas \"pequenos\", nos quais poucas decis\u00f5es s\u00e3o tomadas e poucos recursos s\u00e3o\n\ngerenciados. Al\u00e9m disso, esta estrat\u00e9gia \u00e9 f\u00e1cil de ser implementada, dado que a\n\nrotina principal, em geral, utiliza poucas instru\u00e7\u00f5es, n\u00e3o sendo necess\u00e1rio estruturar\n\no sistema.\n\nEntretanto, com o crescimento acelerado do n\u00famero de sensores, houve um au-\n\n186\n\n\n\n187\n\nmento na quantidade de informa\u00e7\u00e3o trafegando nas redes industriais. Consequente-\n\nmente, cresceu tamb\u00e9m a quantidade de decis\u00f5es a serem tomadas pelos controladores\n\n(microcontroladores, controladores l\u00f3gicos program\u00e1veis, etc.). Al\u00e9m disso, os sis-\n\ntemas de controle passaram a cada vez mais exigirem uma resposta em tempo real.\n\nPortanto, com o aumento na complexidade dos sistemas de controle, surge a necessi-\n\ndade de estruturar o sistema, de forma que diversas solicita\u00e7\u00f5es possam ser atendidas\n\n\"em paralelo\".\n\nA utiliza\u00e7\u00e3o de um SOTR embarcado permite que problemas complexos sejam\n\nquebrados em tarefas mais simples, utilizando o conceito do \"dividir para conquistar\".\n\nAl\u00e9m disso, o sistema pode ser projetado para responder mais rapidamente a eventos\n\nmais importantes, por exemplo, a partir da de?ni\u00e7\u00e3o de prioridades. Outra vantagem\n\nde se utilizar um SOTR embarcado \u00e9 que uma tarefa pode ser executada enquanto\n\noutras tarefas est\u00e3o esperando por algum evento, pela libera\u00e7\u00e3o de um recurso, etc.,\n\nimplementando o conceito de pseudoparalelismo. Finalmente, a utiliza\u00e7\u00e3o de um\n\nSOTR embarcado torna o projeto do sistema de controle modular, de maneira que,\n\nse o processo muda, n\u00e3o \u00e9 necess\u00e1rio reprojetar todo o sistema, reescrevendo todo\n\no programa principal. A estrutura b\u00e1sica (SOTR) permanece inalterada. Basta\n\nmodi?car as tarefas a serem executadas.\n\nEste ap\u00eandice apresenta a especi?ca\u00e7\u00e3o do SOTR embarcado proposto. Inicial-\n\nmente, s\u00e3o de?nidos os requisitos de hardware e software. Em seguida, \u00e9 realizada\n\na modelagem do sistema utilizando a metodologia Yourdon [30], sendo discutidos os\n\nmodelos ambiental e comportamental do SOTR. Finalmente, o projeto do SOTR \u00e9\n\napresentado, discutindo-se a aplica\u00e7\u00e3o de diversos conceitos de Sistemas Operacionais\n\nde Tempo Real.\n\nD.1 Objetivos\n\nEste trabalho tem por objetivo desenvolver um SOTR embarcado capaz de: gerenciar\n\na aquisi\u00e7\u00e3o de dados realizada pelo ampli?cador lock-in digital; gerenciar a transmis-\n\ns\u00e3o e a recep\u00e7\u00e3o de dados realizadas pela interface de rede MARIA; gerenciar a utiliza-\n\n\u00e7\u00e3o de recursos, tais como o acesso \u00e0 mem\u00f3ria externa (RAM); gerenciar a execu\u00e7\u00e3o\n\ndo(s) processo(s) dependente(s) da aplica\u00e7\u00e3o, isto \u00e9, a(s) tarefa(s) relacionada(s) ao\n\n\n\n188\n\nalgoritmo de controle do processo no qual o sensor inteligente est\u00e1 inserido.\n\nD.2 Especi?ca\u00e7\u00e3o doHardware\n\nO hardware envolvido no projeto \u00e9 composto por:\n\n\u2022 Ampli?cador lock-in digital (LOCK-IN): circuito utilizado para a medi\u00e7\u00e3o e o\n\ncondicionamento de sinais. Aplicado, por exemplo, na medi\u00e7\u00e3o de imped\u00e2ncias\n\ne em tomogra?a por imped\u00e2ncia el\u00e9trica. Aciona uma interrup\u00e7\u00e3o peri\u00f3dica\n\nindicando ao microcontrolador LAMPI\u00c3O que uma nova medi\u00e7\u00e3o foi realizada;\n\n\u2022 M\u00f3dulo de acesso \u00e0 rede (MARIA): respons\u00e1vel pela implementa\u00e7\u00e3o do proto-\n\ncolo de rede (TCP/IP e CAN). Aciona um ?ag sempre que uma nova mensagem\n\n\u00e9 recebida;\n\n\u2022 Microcontrolador (LAMPI\u00c3O): respons\u00e1vel pelo controle do processo;\n\n\u2022 Mem\u00f3ria externa (RAM): utilizada como mem\u00f3ria de dados, por exemplo, para\n\narmazenamento da medi\u00e7\u00e3o realizada pelo LOCK-IN ou da mensagem recebida\n\npor MARIA.\n\nD.2.1 Microcontrolador LAMPI\u00c3O\n\nInicialmente desenvolvido por H\u00e9rcules Padilha [3] e atualmente em fase de expans\u00e3o\n\npor Marco Ant\u00f4nio Diniz [31], o microcontrolador LAMPI\u00c3O possui as especi?ca\u00e7\u00f5es\n\napresentadas na Tabela D.1.\n\nComo pode ser observado na Tabela D.1, a vers\u00e3o atual do microcontrolador\n\nLAMPI\u00c3O apresenta um maior n\u00famero de recursos de hardware, como por exemplo,\n\nmem\u00f3ria de programa, n\u00edveis de pilha e registradores (mem\u00f3ria de dados). Entre-\n\ntanto, a principal diferen\u00e7a entre as duas vers\u00f5es do LAMPI\u00c3O est\u00e1 no fato de que a\n\nvers\u00e3o atual est\u00e1 sendo desenvolvida para permitir a implementa\u00e7\u00e3o de um Sistema\n\nOperacional em camadas. Neste sentido, torna-se poss\u00edvel, por exemplo, o acesso \u00e0\n\npilha, a implementa\u00e7\u00e3o de exclus\u00e3o m\u00fatua, etc. Os diagramas em blocos das duas\n\nvers\u00f5es do microcontrolador LAMPI\u00c3O s\u00e3o apresentados nas Figuras D.1 e D.2.\n\n\n\n189\n\nTabela D.1: Especi?ca\u00e7\u00f5es do microcontrolador LAMPI\u00c3O\nVers\u00e3o Inicial (Padilha) Vers\u00e3o Atual (Diniz)\nArquitetura Harvard Arquitetura Harvard\n\n2 portas de E/S de 8 bits 3 portas de E/S de 8 bits\n1 temporizador guarda 1 temporizador guarda\n1 rel\u00f3gio de tempo real 1 rel\u00f3gio de tempo real\n2 interrup\u00e7\u00f5es externas 4 interrup\u00e7\u00f5es externas\n\n256 posi\u00e7\u00f5es de mem\u00f3ria de programa 1024 posi\u00e7\u00f5es de mem\u00f3ria de programa\n8 n\u00edveis de pilha 256 n\u00edveis de pilha\n32 registradores 2048 registradores\n\nFigura D.1: Diagrama em blocos do microcontrolador LAMPI\u00c3O (Vers\u00e3o Inicial) [3].\n\nA proposta inicial deste trabalho seria projetar um SOTR embarcado a ser im-\n\nplementado na vers\u00e3o inicial do LAMPI\u00c3O. Entretanto, do ponto de vista pr\u00e1tico,\n\na implementa\u00e7\u00e3o de um Sistema Operacional na vers\u00e3o inicial do LAMPI\u00c3O \u00e9 in-\n\nvi\u00e1vel por limita\u00e7\u00f5es de hardware. Por exemplo, nenhuma instru\u00e7\u00e3o na vers\u00e3o inicial\n\npermite o acesso \u00e0 pilha. Nesse sentido, ser\u00e1 discutida a especi?ca\u00e7\u00e3o de um SOTR\n\nembarcado a ser implementado na vers\u00e3o atual do LAMPI\u00c3O, sem considerar, entre-\n\ntanto, as suas novas funcionalidades relativas a um Sistema Operacional em camadas.\n\n\n\n190\n\nFigura D.2: Diagrama em blocos do microcontrolador LAMPI\u00c3O (Vers\u00e3o Atual) [31].\n\nD.3 Especi?ca\u00e7\u00e3o do Software - Modelo Ambiental\n\nNesta se\u00e7\u00e3o \u00e9 discutida a modelagem ambiental do sistema, de acordo com a Metodolo-\n\ngiaYourdon.\n\nD.3.1 Diagrama de Contexto\n\nNa Figura D.3 \u00e9 ilustrado o diagrama de contexto do sistema. No centro do dia-\n\ngrama est\u00e1 o SOTR a ser desenvolvido. O SOTR \u00e9 respons\u00e1vel pelo gerenciamento\n\ndos recursos, das chamadas ao sistema, das interrup\u00e7\u00f5es e dos diversos processos de\n\n\"usu\u00e1rio\"envolvidos, representados no diagrama por ret\u00e2ngulos.\n\nD.3.2 Lista de Eventos\n\nA lista de eventos \u00e9 apresentada na Tabela D.2.\n\n\n\n191\n\nFigura D.3: Diagrama de contexto do sistema.\n\nTabela D.2: Lista de eventos do sistema e a\u00e7\u00f5es a serem realizadas.\nEvento A\u00e7\u00e3o\n\nInterrup\u00e7\u00e3o de rel\u00f3gio Execute algoritmo de agendamento\nInterrup\u00e7\u00e3o externa Execute rotina de tratamento de interrup\u00e7\u00e3o\nMedi\u00e7\u00e3o realizada Armazene na RAM\nMensagem recebida Armazene na RAM\nRecurso solicitado Disponibilize recurso\n\nD.4 Especi?ca\u00e7\u00e3o do Software - Modelo Compor-\n\ntamental\n\nNesta se\u00e7\u00e3o \u00e9 discutida a modelagem comportamental do sistema, de acordo com a\n\nMetodologia Yourdon.\n\nD.4.1 Arquitetura do Sistema Operacional\n\nA arquitetura do Sistema Operacional proposto \u00e9 apresentada na Figura D.4 . O\n\nSOTR \u00e9 composto por: rotinas de tratamento de chamadas ao sistema e interrup\u00e7\u00f5es;\n\num algoritmo de troca de contexto; uma ?la de processos e despachante.\n\n\n\n192\n\nFigura D.4: Diagrama em blocos dos elementos do Sistema Operacional.\n\nD.4.2 Tratamento de uma Interrup\u00e7\u00e3o de Rel\u00f3gio\n\nFigura D.5: Fluxograma da rotina de tratamento de uma interrup\u00e7\u00e3o de rel\u00f3gio.\n\nNa Figura D.5 \u00e9 ilustrado o ?uxograma da rotina de tratamento de uma inter-\n\nrup\u00e7\u00e3o de rel\u00f3gio. Sempre que ocorre uma interrup\u00e7\u00e3o de rel\u00f3gio, o algoritmo de\n\nagendamento (despachante) \u00e9 executado e a troca de contexto \u00e9 realizada ou n\u00e3o,\n\ndependendo da ?la de processos prontos. Nesse sentido, o SOTR guarda o contador\n\nde programa, a pilha e o registrador de STATUS. Em seguida, o SOTR executa o\n\n\n\n193\n\ndespachante, que decide qual ser\u00e1 o pr\u00f3ximo processo a ser executado. Finalmente,\n\no SOTR carrega o novo registrador de STATUS, a nova pilha e o novo contador de\n\nprograma.\n\nD.4.3 Tratamento de uma Interrup\u00e7\u00e3o Externa\n\nFigura D.6: Fluxograma da rotina de tratamento de uma interrup\u00e7\u00e3o externa.\n\nNa Figura D.6 \u00e9 ilustrado o ?uxograma da rotina de tratamento de uma inter-\n\nrup\u00e7\u00e3o externa, de uma medi\u00e7\u00e3o realizada e de uma mensagem recebida ocorrem de\n\nforma similar \u00e0 interrup\u00e7\u00e3o de rel\u00f3gio. Entretanto, antes do algoritmo de agenda-\n\nmento ser realizado, a ?la de processos prontos \u00e9 atualizada, incluindo o processo\n\nrelativo ao evento (interrup\u00e7\u00e3o externa, medi\u00e7\u00e3o realizada ou mensagem recebida).\n\nD.4.4 Tratamento de uma Chamada ao Sistema para Solici-\n\nta\u00e7\u00e3o de um Recurso\n\nNa Figura D.7 \u00e9 apresentado o ?uxograma da rotina de tratamento de uma chamada\n\nao sistema para solicita\u00e7\u00e3o de recurso. Nenhum processo possui acesso direto a re-\n\ncursos, tais como mem\u00f3ria externa. Esse acesso \u00e9 feito por meio de uma chamada\n\n\n\n194\n\nFigura D.7: Fluxograma da rotina de tratamento de uma chamada ao sistema para\nsolicita\u00e7\u00e3o de recurso.\n\nao sistema. Portanto, quando um recurso \u00e9 solicitado, a rotina de tratamento da\n\nchamada ao sistema \u00e9 executada. Em seguida, \u00e9 realizada a troca de contexto.\n\nPara implementar a exclus\u00e3o m\u00fatua, \u00e9 utilizada a t\u00e9cnica de desabilitar inter-\n\nrup\u00e7\u00f5es. Tipicamente, o pr\u00f3prio processo \u00e9 respons\u00e1vel por desabilitar e habilitar as\n\ninterrup\u00e7\u00f5es. Entretanto, pode acontecer de um determinado processo n\u00e3o habilitar\n\nas interrup\u00e7\u00f5es novamente. Nesse caso, nem mesmo a interrup\u00e7\u00e3o de rel\u00f3gio ser\u00e1\n\ntratada. Conseq\u00fcentemente, o Sistema Operacional n\u00e3o ter\u00e1 novamente o controle.\n\nPara evitar este problema, sempre que uma chamada ao sistema \u00e9 realizada o\n\npr\u00f3prio Sistema Operacional desabilita as interrup\u00e7\u00f5es. Ap\u00f3s a chamada ao sistema\n\nser tratada, o Sistema Operacional imediatamente habilita as interrup\u00e7\u00f5es, antes de\n\nexecutar o despachante.\n\nD.5 Estrutura do Sistema Operacional\n\nA estrutura do SOTR embarcado \u00e9 apresentada na Figura D.8. Trata-se de um\n\nSistema Operacional Monol\u00edtico, composto por procedimentos principais e de servi\u00e7o.\n\n\n\n195\n\nFigura D.8: Estrutura do Sistema Operacional Monol\u00edtico.\n\nOs procedimentos utilit\u00e1rios s\u00e3o auxiliares aos de servi\u00e7o, n\u00e3o sendo considerados\n\nneste projeto, dada a simplicidade do sistema proposto.\n\nOs procedimentos principais s\u00e3o aqueles dependentes da aplica\u00e7\u00e3o. Podem imple-\n\nmentar, por exemplo:\n\n\u2022 O algoritmo de controle do processo;\n\n\u2022 O algoritmo de tratamento da medi\u00e7\u00e3o realizada pelo LOCK-IN;\n\n\u2022 O algoritmo de tratamento das mensagens recebidas por MARIA.\n\nOs procedimentos de servi\u00e7o s\u00e3o as chamadas ao sistema e as rotinas de tratamento\n\nde interrup\u00e7\u00f5es. As chamadas de sistema, por sua vez, s\u00e3o classi?cadas em:\n\n\u2022 Chamadas ao sistema para gerenciamento de E/S: aquisi\u00e7\u00e3o do resultado do\n\nLOCK-IN, aquisi\u00e7\u00e3o da mensagem recebida por MARIA, transmiss\u00e3o de men-\n\nsagens por MARIA;\n\n\u2022 Chamadas ao sistema para gerenciamento de recursos: acesso \u00e0 mem\u00f3ria RAM\n\nexterna.\n\nD.6 Processos\n\nD.6.1 Diagrama de Estados dos Processos\n\nNa Figura D.9 \u00e9 ilustrado o diagrama de estados do Sistema Operacional. Neste\n\nprojeto s\u00e3o considerados tr\u00eas estados dos processos: pronto, executando e bloqueado.\n\nAs transi\u00e7\u00f5es de estados s\u00e3o fun\u00e7\u00f5es do sistema operacional e est\u00e3o descritas a seguir.\n\n\n\n196\n\nFigura D.9: Diagrama de estados dos processos.\n\n\u2022 O processo \u00e9 bloqueado esperando por um recurso que ainda n\u00e3o est\u00e1 dispon\u00edvel;\n\n\u2022 O tempo de execu\u00e7\u00e3o do processo terminou. O despachante seleciona outro\n\nprocesso a ser executado;\n\n\u2022 Um novo slot de tempo \u00e9 dedicado \u00e0 execu\u00e7\u00e3o do processo. O despachante\n\nseleciona esse processo para ser executado;\n\n\u2022 O processo que estava bloqueado esperando recurso passa ao estado pronto\n\nquando o recurso estiver dispon\u00edvel.\n\nD.6.2 Implementa\u00e7\u00e3o de Processos\n\nO Sistema Operacional mant\u00e9m uma tabela de processos, com uma entrada por pro-\n\ncesso, com todos os dados necess\u00e1rios \u00e0 execu\u00e7\u00e3o dos processos. Esta tabela possui:\n\n\u2022 Identi?cador do processo;\n\n\u2022 Estado do processo;\n\n\u2022 Contador de programa;\n\n\u2022 Ponteiro da pilha;\n\n\u2022 Aloca\u00e7\u00e3o de mem\u00f3ria.\n\nD.6.3 Comunica\u00e7\u00e3o entre Processos\n\nComo foi discutido anteriormente, a exclus\u00e3o m\u00fatua \u00e9 implementada desabilitando-se\n\nas interrup\u00e7\u00f5es. Esta t\u00e9cnica \u00e9 utilizada neste projeto, uma vez que a implementa\u00e7\u00e3o\n\n\n\n197\n\ninicial do LAMPI\u00c3O \u00e9 simples, com poucas instru\u00e7\u00f5es. Al\u00e9m disso, os processos ex-\n\necut\u00e1veis estar\u00e3o gravados na mem\u00f3ria de programa antes do LAMPI\u00c3O ser inserido\n\nna planta, de forma que novos processos n\u00e3o ser\u00e3o criados dinamicamente.\n\nTipicamente, nesta t\u00e9cnica, cada processo desabilita todas as instru\u00e7\u00f5es imediata-\n\nmente ap\u00f3s entrar em sua se\u00e7\u00e3o cr\u00edtica, reativando-as imediatamente ap\u00f3s sair dela.\n\nEntretanto, neste projeto, para garantir o funcionamento do sistema, as interrup\u00e7\u00f5es\n\ns\u00e3o desabilitadas pelo SOTR ao entrar na rotina de atendimento \u00e0 chamada de sis-\n\ntema, sendo habilitadas novamente pelo SOTR ao sair da rotina de tratamento da\n\nchamada ao sistema (vide Figura D.7).\n\nD.7 Algoritmo de Agendamento (Despachante)\n\nNeste projeto \u00e9 utilizado o agendamento tipo carrossel(round-robin) com prioridade.\n\nEste algoritmo de agendamento \u00e9 preemptivo, atribuindo um intervalo de tempo (slot\n\nde tempo ou quantum) para a execu\u00e7\u00e3o de cada processo. Um novo slot de tempo de\n\nexecu\u00e7\u00e3o \u00e9 iniciado sempre que ocorre uma interrup\u00e7\u00e3o do rel\u00f3gio de tempo real.\n\nA preemp\u00e7\u00e3o \u00e9 realizada em tr\u00eas situa\u00e7\u00f5es:\n\n\u2022 Quando o tempo de execu\u00e7\u00e3o acaba;\n\n\u2022 Quando o processo bloqueia ou termina;\n\n\u2022 Quando ocorre uma interrup\u00e7\u00e3o.\n\nO tempo de execu\u00e7\u00e3o \u00e9 determinado por:\n\n\u2022 Frequ\u00eancia de rel\u00f3gio do LAMPI\u00c3O;\n\n\u2022 Constante de tempo do processo;\n\n\u2022 Tempo de atualiza\u00e7\u00e3o do resultado do LOCK-IN;\n\n\u2022 Tempo de transmiss\u00e3o e recep\u00e7\u00e3o de mensagens por MARIA;\n\n\u2022 Tempo utilizado para troca de contexto.\n\n\n\n198\n\nS\u00e3o de?nidos cinco n\u00edveis (?las) de prioridades. Os n\u00edveis 4 a 1 s\u00e3o alocados\n\n\u00e0s interrup\u00e7\u00f5es externas. O n\u00edvel 0 \u00e9 alocado aos processos de \"usu\u00e1rio\". Neste\n\nalgoritmo de agendamento, a prioridade \u00e9 decrementada cada vez que o processo \u00e9\n\nexecutado e o processo passa para uma ?la de menor prioridade. O n\u00famero m\u00e1ximo\n\nde processos em cada ?la \u00e9 apresentado na Tabela D.3. N \u00e9 o n\u00famero de processos\n\nde \"usu\u00e1rio\".\n\nTabela D.3: N\u00famero de processos por n\u00edvel de prioridade.\nN\u00edvel 4 N\u00edvel 3 N\u00edvel 2 N\u00edvel 1 N\u00edvel 0\n\nN\u00famero m\u00e1ximo de processos 1 2 3 4 N+4\n\nO ?uxograma de opera\u00e7\u00e3o do despachante \u00e9 apresentado na Figura D.10.\n\nFigura D.10: Fluxograma de opera\u00e7\u00e3o do despachante.\n\nD.7.1 Estimativa doQuantum\n\nPara estimar o valor doquantum de tempo, \u00e9 necess\u00e1rio avaliar os fatores listados no\n\nestudo do despachante. Uma an\u00e1lise r\u00e1pida \u00e9 realizada a seguir.\n\n1. Frequ\u00eancia de rel\u00f3gio do LAMPI\u00c3O:\n\n\n\n199\n\n\u2022 fLampiao > 1MHz;\n\n\u2022 Tempo de execu\u00e7\u00e3o de 01 instru\u00e7\u00e3o: TLampiao &lt;1\u00b5s;\n\n\u2022 Consideremos fLampiao = 4MHz, isto \u00e9, TLampiao = 0, 25\u00b5s.\n\n2. Constante de tempo do processo (planta):\n\n\u2022 T = 1ms.\n\n3. Tempo de atualiza\u00e7\u00e3o do resultado do LOCK-IN:\n\n\u2022 Frequ\u00eancia do sinal de refer\u00eancia: fLock?in = 10kHz;\n\n\u2022 Tempo de atualiza\u00e7\u00e3o da sa\u00edda: TLock?in = 100\u00b5s.\n\n4. Tempo de recep\u00e7\u00e3o e transmiss\u00e3o de mensagens:\n\n\u2022 N\u00famero de bits por mensagem: Nbits > 60;\n\n\u2022 Taxa de transmiss\u00e3o: fMaria?CAN &lt;1Mbps;\n\n\u2022 Tempo de transmiss\u00e3o: TMaria?CAN > 60\u00b5s.\n\n5. Tempo utilizado na troca de contexto:\n\n\u2022 Guardar contador de programa e pilha: 2 instru\u00e7\u00f5es;\n\n\u2022 Guardar registrador de STATUS: 2 instru\u00e7\u00f5es;\n\n\u2022 Executar despachante: 30 instru\u00e7\u00f5es (pior caso);\n\n\u2022 Carregar novo registrador de STATUS: 2 instru\u00e7\u00f5es;\n\n\u2022 Carregar novo registrado de programa e pilha: 2 instru\u00e7\u00f5es;\n\n\u2022 Tempo total: Tcontexto = 10\u00b5s (considerando TLampiao = 0, 25\u00b5s).\n\n\n\n200\n\nEmbora nenhum processo espec\u00ed?co (planta) tenha sido de?nido neste trabalho, \u00e9\n\nrazo\u00e1vel estimar uma constante de tempo da ordem de alguns mil\u00e9simos de segundo,\n\numa vez que grande parte dos processos industriais apresenta constante de tempo\n\ndesta magnitude.\n\nEmbora o tempo de transmiss\u00e3o e recep\u00e7\u00e3o de mensagens seja aleat\u00f3rio (depen-\n\ndendo do tamanho da mensagem, da taxa de transmiss\u00e3o e da necessidade de enviar\n\numa mensagem na rede), foi considerado no c\u00e1lculo anterior que a mensagem mais\n\ncurta est\u00e1 sendo recebida na taxa de transmiss\u00e3o mais r\u00e1pida, durante todo o tempo.\n\nEste seria o pior caso no qual o sensor inteligente estaria inserido, exigindo uma\n\nresposta mais r\u00e1pida do SOTR. Entretanto, esse caso \u00e9 imposs\u00edvel de acontecer na\n\npr\u00e1tica. Portanto, \u00e9 uma boa estimativa considerar que o evento mais r\u00e1pido a ocorrer\n\n\u00e9 a interrup\u00e7\u00e3o do LOCK-IN, indicando que uma nova medi\u00e7\u00e3o foi realizada.\n\nAp\u00f3s examinar as restri\u00e7\u00f5es temporais acima, acredita-se que seja razo\u00e1vel utilizar\n\num quantum de 20\u00b5s. Nesse caso, cada processo poder\u00e1 executar at\u00e9 80 instru\u00e7\u00f5es.\n\nAl\u00e9m disso, at\u00e9 3 processos poder\u00e3o ser executados durante o intervalo de tempo no\n\nqual espera-se a interrup\u00e7\u00e3o do LOCK-IN, o que deve ser su?ciente para executar o\n\nalgoritmo de controle e o tratamento de mensagens \"paralelamente\".\n\n\n\nAp\u00eandice E\n\nPublica\u00e7\u00f5es\n\nDesta disserta\u00e7\u00e3o, foram publicados os seguintes artigos:\n\n1. J. E. O. Reges e E. J. P. Santos. VHDL Digital Lock-in Ampli?er for Smart\n\nSensors. XIV Iberchip, 2008.\n\n2. J. E. O. Reges e E. J. P. Santos. A VHDL CAN Module for Smart Sensors.\n\nSouthern Programmable Logic Conference, 2008.\n\n201\n\n\n\nBibliogra?a\n\n[1] The Free Dictionary. http://encyclopedia2.thefreedictionary.com/smart+sensor,\n\nacessado em 14/06/2010.\n\n[2] Wikipedia. A Enciclop\u00e9dia Livre. http://en.wikipedia.org/wiki/Smart_transducer,\n\nacessado em 14/06/2010.\n\n[3] H. Padilha. Descri\u00e7\u00e3o VHDL de Microcontrolador para Sensores Inteligentes.\n\nTrabalho de Gradua\u00e7\u00e3o. Universidade Federal de Pernambuco, 2003.\n\n[4] D. Dubey. Smart Sensor. M. Tech. Credit Seminar Report. Electronic Systems\n\nGroup. EE Dept. IIT Bombay, 2002.\n\n[5] National Institute of Standards and Technology. http://ieee1451.nist.gov/, aces-\n\nsado em 14/06/2010.\n\n[6] F. K. Tani. Proposta de Desenvolvimento de Transdutores Inteligentes baseados\n\nna Norma IEEE 1451 aplicados a Redes Lonworks. Disserta\u00e7\u00e3o de Mestrado.\n\nEscola Polit\u00e9cnica da Universidade de S\u00e3o Paulo, 2006.\n\n[7] R. D. Regazzi, P. S. Pereira e M. F. da Silva Jr. Solu\u00e7\u00f5es Pr\u00e1ticas de Instrumen-\n\nta\u00e7\u00e3o e Automa\u00e7\u00e3o. Rio de Janeiro, 2005.\n\n[8] P. Vieira. Redes de Computa\u00e7\u00e3o Industrial. Notas de Aula do Curso de Forma\u00e7\u00e3o\n\nem Automa\u00e7\u00e3o Industrial. Petrobras. Rio de Janeiro, 2009.\n\n[9] J. E. Thomas, et al. Fundamentos de Engenharia de Petr\u00f3leo. Rio de Janeiro,\n\n2001.\n\n202\n\n\n\n203\n\n[10] E. J. P. Santos, P. L. Guzzo, A. H. Shinohara, et al. Sensores Inteligentes\n\nde Vaz\u00e3o, Press\u00e3o e Temperatura para Monitoramento de Fluxos Multif\u00e1sicos\n\n(Petr\u00f3leo, \u00c1gua e G\u00e1s).\n\n[11] S. L. Ceccio and D. L. George. A review of electrical impedance techniques for\n\nthe measurement of multiphase ?ow. J. of Fluids Eng., 118, 391-399, 1996.\n\n[12] G. J. Saulnier, R. S. Blue, J. C. Newell, D. Isaacson, and P. M. Edic. Electrical\n\nimpedance tomography. IEEE Signal Processing Magazine, 11, 31-43, 2001.\n\n[13] H. Lemonnier. Multiphase Instrumentation: The Keystone of Multidimensional\n\nMultiphase Flow Modeling. Exper. Thermal and Fluid Sci., 15, 154-162, 1997.\n\n[14] Z. Szczepanik and Z. Rucki. Frequency Analysis of Electrical Impedance Tomog-\n\nraphy System. IEEE Trans on Inst. and Meas., 49, 844-851, 2000.\n\n[15] D. Holder. Electrical Impedance Tomography. Inst of Physics Pub Inc, 2005.\n\n[16] D. L. George, K. A. Shollenberger, J. R. Torczynski, T. J. O'Hern e S. L. Cec-\n\ncio. Three-phase Material Distribution Measurements in a Vertical Flow using\n\ngamma-densitomwtry tomography and electrical-impedance tomography. Int. J.\n\nMultiphase Flow, 27, 1903-1930, 2001.\n\n[17] Bloodshed Software. http://www.bloodshed.net, acessado em jan./2004.\n\n[18] Terminal v.19b. Dispon\u00edvel em http://bray.velenje.cx/avr/terminal, set./2006.\n\n[19] Xilinx. Basic FPGA. Architecture. Xilinx Inc, 2005.\n\n[20] Xilinx. Spartan-3E FPGA FAmily: Complete Data Sheet. Xilinx Inc, 2006.\n\n[21] Xilinx. Spartan-II 2.5V FPGA Family: Complete Data Sheet. Xilinx Inc, 2003.\n\n[22] R. d'Amore. VHDL - Descri\u00e7\u00e3o e S\u00edntese de Circuitos Digitais. LTC, 2005.\n\n[23] E. J. P. Santos. Eletr\u00f4nica Anal\u00f3gica Integrada e Aplica\u00e7\u00f5es. UFPE, 2003.\n\n[24] T. L. Keiser. The DAS-20 Software Library and its use for Control System\n\nImplementation. 1995.\n\n\n\n204\n\n[25] D. E. Johnson, J. L. Hilburn, J. R. Johnson. Fundamentos de An\u00e1lise de Circuitos\n\nEl\u00e9tricos. PHB, 1990.\n\n[26] A. V. Oppenheim, A. S. Willsky, S. H. Nawab. Signals &amp; Systems. Prentice Hall,\n\n1996.\n\n[27] Analog Devices. AD5447 Data Sheet. Analog Devices Inc, 2005.\n\n[28] CAN in Automation. http://www.can-cia.org, acessado em 14/06/2010.\n\n[29] R. Bosch. CAN Speci?cation. Version 2.0, Parts A and B, Sept. 1991.\n\n[30] E. Yourdon. Analisis Estructurado Moderno. Prentice-Hall, 1993.\n\n[31] M. A. Diniz. LAMPI\u00c3O - Microcontrolador para Sensores Inteligentes. UFPE,\n\n2008.\n\n[32] E-Sensors. http://www.eesensors.com/, acessado em 14/06/2010.\n\n[33] Smart Sensors Systems. http://www.smartsensorsystems.com/, acessado em\n\n14/06/2010.\n\n[34] Sensors Synerg., http://www.sensorsynergy.com/, acessado em 14/06/2010.\n\n[35] Industrial Embedded Systems. http://www.industrial-embedded.com/, acessado\n\nem 14/06/2010.\n\n[36] A. Hac. Wireless Sensor Network Designs. John Wiley &amp; Sons Ltd, 2003.\n\n[37] L. B. Torri. A Norma IEEE 1451 aplicada a Redes Heterog\u00eaneas de Sensores sem\n\nFio. Trabalho de Conclus\u00e3o de Curso. Universidade Federal de Santa Catarina,\n\n2008.\n\n[38] A. S. Tanembaum. Redes de Computadores. Quarta Edi\u00e7\u00e3o, 2003.\n\n[39] Jener T. L. e Silva. Instrumenta\u00e7\u00e3o virtual para microscopia de varredura. Dis-\n\nserta\u00e7\u00e3o de Mestrado. Universidade Federal de Pernambuco, 2002.\n\n[40] A. Restelli, R. Abbiati e A. Geraci. Digital ?eld programmable gate array-based\n\nlock-in ampli?er for high performance photon counting applications. Rev. Sci.\n\nInstrum., 2005.\n\n\n\n205\n\n[41] M. O. Sonnaillon e F. J. Bonetto. A low-cost, highperformance, digital signal\n\nprocessor-based lock-in ampli?ercapable of measuring multiple frequency sweeps\n\nsimultaneously. Rev. Sci. Instrum., 2005.\n\n[42] P-A. Probst e A. Jaquier. Multiple-channel digital lock-in ampli?er with PPM\n\nresolution. Rev. Sci. Instrum., 1994.\n\n[43] P. K Dixon e L. Wu. Broadband digital lock-in ampli?er techniques. Rev. Sci.\n\nInstrum., 1989.\n\n[44] J. S. Sco?eld. A Frequency-Domain Description of a Lockin Ampli?er. American\n\nJournal of Physics,1994.\n\n[45] J. E. O. Reges e E. J. P. Santos. Ampli?cador Lock-in Digital utilizando Placa\n\nde Aquisi\u00e7\u00e3o de Dados e MATLAB. XXXIII Congresso Brasileiro de Ensino de\n\nEngenharia. Campina Grande, 2005.\n\n[46] S. Corrigan. Introduction to Controller Area Network (CAN). Texas Instruments\n\nInc, Application Report, 2002.\n\n[47] L. Stagnaro. HurriCANe - Free VHDL CAN Controller Core. European Space\n\nAgency, 2000.\n\n[48] R. Stoneking. A Simple CAN Node Using the MCP2510 and PIC12C67. Mi-\n\ncrochip Technology Inc, Application Note, 2002.\n\n[49] A. Amory and J. P. J\u00fanior. Sistema Integrado e Multiplataforma para controle\n\nremoto de resid\u00eancias. Pontif\u00edcia Universidade Cat\u00f3lica do Rio Grande do Sul,\n\n2000.\n\n[50] R. J. Tocci e N. S. Widmer. Sistemas Digitais - Princ\u00edpio e Aplica\u00e7\u00f5es. Prentice-\n\nHall, 2004.\n\n[51] R. Airiau, J. M. Berg\u00e9 e V. Olive. Circuit Synthesis with VHDL. Kluwer Aca-\n\ndemic Publishers, 1994.\n\n[52] J. Bhasker. A VHDL Synthesis Primer. Star Galaxy Publishing, 1996.\n\n\n\n206\n\n[53] A. V. Oppenheim, A. S. Willsky e S. H. Nawab. Signals and Systems. Prentice\n\nHall, 1996.\n\n[54] C. H. Chen. Signal Processing Handbook. New York, Marcel Dekker, 1988.\n\n[55] E. C. Ifeachor and B. W. Jervis. Digital Signal Processing - A Practical Approach.\n\nAddison-Wesley, 1993.\n\n[56] J. H. Mcclellan, J. C. Burrus, et al. Computer-Based Exercises for Signal Pro-\n\ncessing using MATLAB 5. New Jersey: Prentice Hall, 1998.\n\n[57] E. R. Davies. Electronics Noise and Signal Recovery. Academic Press, 1993.\n\n[58] A. S. Tanembaum. Operating Systems - Design and Implementation. Second\n\nEdition, 1997."}]}}}