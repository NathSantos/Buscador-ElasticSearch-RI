{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.11185"}, {"@name": "filename", "#text": "16385_FernandoGeremiasToniCorr18.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "FERNANDO GEREMIAS TONI \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nParallelized element-by-element architecture for structural analysis of \n\nflexible pipes using finite macroelements \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nSao Paulo \n\n2018  \n\n\n\n \n\n \n\nFERNANDO GEREMIAS TONI \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nParallelized element-by-element architecture for structural analysis of \n\nflexible pipes using finite macroelements \n\n \n\n \n\n \n\n Master\u2019s thesis presented to Escola \n\nPolit\u00e9cnica da Universidade de S\u00e3o Paulo in \n\nfulfillment of the requirements for the Master \n\nof Science degree \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nSao Paulo \n\n2018  \n\n\n\n \n\n \n\nFERNANDO GEREMIAS TONI \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nParallelized element-by-element architecture for structural analysis of \n\nflexible pipes using finite macroelements \n\n \n\n \n\n \n\n Master\u2019s thesis presented to Escola \n\nPolit\u00e9cnica da Universidade de S\u00e3o Paulo in \n\nfulfillment of the requirements for the Master \n\nof Science degree \n\n \n\nArea: Mechanical Engineering \n\n \n\nAdvisor: Professor Doutor Cl\u00f3vis de Arruda \n\nMartins \n\n \n\n \n\n \n\n \n\n \n\nSao Paulo \n\n2018 \n\n\n\n \n\n \n\nAutorizo a reprodu\u00e7\u00e3o e divulga\u00e7\u00e3o total ou parcial deste trabalho, por qualquer meio \nconvencional ou eletr\u00f4nico, para fins de estudo e pesquisa, desde que citada a fonte. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\nAcknowledgments \n\nTo my parents, for all the support provided during the accomplishment of this work \n\nand for always encouraging me to invest in my personal education. To my advisor, by \n\nwhom I have great admiration for his vast experience and wisdom. To the \u201cLaborat\u00f3rio \n\nde Mec\u00e2nica Offshore - LMO\u201d of the Polytechnic School of the University of Sao Paulo, \n\nfor providing all the necessary infrastructure to this work, and to CNPq for the financial \n\nsupport (161991/2015-7). \n\n\n\n \n\n \n\nAbstract \n\nFlexible pipes are used in the offshore oil production to transport fluid and gas from \n\nthe sea bead to the floating stations, and vice versa. These pipes have several concentric \n\nlayers, of different materials, geometries and structural functions, since they are exposed \n\nto adverse operating environments, subjected to high internal and external pressures, high \n\naxial stresses and a series of dynamic loads. The local analysis is an important stage of a \n\nflexible pipe design and it consists on determining the stresses and strains distributions \n\nalong the layers of the pipe. Multipurpose finite element packages are commonly used in \n\nthe local analysis of flexible pipes, but they possess many limitations due to its generic \n\nnature, varying from the absence of specific tools for model creation to heavy restrictions \n\nof the number of degrees-of-freedom to make computational processing feasible. \n\nAt the Polytechnic School of the University of S\u00e3o Paulo, within a research line in \n\nprogress, several finite macroelements were formulated specifically for structural analysis \n\nof flexible pipes, taking into account their particularities, such as geometric patterns and \n\nlayers assemblage. However, the numerical tools that implement these elements present \n\nvery high memory and processing consumptions, limiting its usage for large-scale \n\nmodels. Therefore, this work has been motivated by memory and processing limitations \n\nof finite element structural analysis of flexible pipes for offshore applications.  \n\nIn this context, the Element-by-Element method, which does not require the global \n\nstiffness matrix, was chosen for its potential in memory reduction and processing \n\ncapabilities, given its scalability and ease of parallelization. After an extensive literature \n\nreview on numerical methods regarding the EBE method, it was chosen the Element-by-\n\nElement Diagonal Preconditioned Conjugate Gradient Method (EBE-PCG) algorithm. \n\nAiming higher computational performance, the finite macroelements formulated by \n\n(PROVASI, 2013) were converted to the C++ language, implemented and parallelized in \n\na new analysis tool, named as PipeFEM. \n\nThe diagonal preconditioned EBE-PCG algorithm was implemented and parallelized \n\nwith OpenMP. The scalability of the PCG algorithm is directly influenced by the \n\nefficiency of the matrix-vector product, an operation that, in the element-by-element \n\nmethod, is computed in a local basis with the blocks that comprise the model, and that \n\nrequires synchronization techniques when performed in parallel. Four different \n\n\n\n \n\n \n\nsynchronization strategies were developed, being the one based on geometric- and mesh- \n\nbased mappings the most efficient of them. Numerical experiments showed a reduction \n\nof almost 92% in the EBE-PCG solution time of the parallelized version in comparison \n\nto the sequential one. \n\nIn order to compare the efficiency of PipeFEM with the well-established finite \n\nelement package ANSYS, a simplified flexible pipe was modeled in both software. \n\nPipeFEM was approximately 82 times faster than ANSYS to solve the problem, spending \n\n24.27 seconds against 33 minutes and 18 seconds. In addition to this, PipeFEM required \n\nmuch less memory, 61.8MB against 6.8GB in ANSYS. In comparison to the dense \n\nversion of MacroFEM, a reduction of more than three orders of magnitude was achieved \n\nin memory consumption.  \n\nDespite the low the rate of convergence presented by the diagonal preconditioner, the \n\nimplementation is very efficient in computational terms. Therefore, the objectives of this \n\nwork were fulfilled with the development and application of the EBE method, allowing a \n\nreduction of memory and simulation costs. \n\n \n\nKeywords: Flexible pipes, finite element method, numerical methods, parallel \n\narchitectures. \n\n \n\n \n\n \n\n\n\n \n\n \n\nResumo \n\nTubos flex\u00edveis s\u00e3o utilizados na produ\u00e7\u00e3o offshore de petr\u00f3leo para o transporte de \n\nfluidos e g\u00e1s natural das estruturas submersas at\u00e9 as esta\u00e7\u00f5es flutuantes, e vice-versa. \n\nEstes tubos possuem diversas camadas conc\u00eantricas, de diferentes materiais, geometrias \n\ne fun\u00e7\u00f5es estruturais, pois s\u00e3o expostos a ambientes adversos de opera\u00e7\u00e3o, nos quais s\u00e3o \n\nsubmetidos \u00e0 elevadas press\u00f5es internas e externas, elevados carregamentos e tens\u00f5es \n\naxiais, al\u00e9m de uma s\u00e9rie de carregamentos din\u00e2micos. A an\u00e1lise local \u00e9 uma etapa \n\nimportante do dimensionamento de um tubo flex\u00edvel e consiste em determinar as \n\ndistribui\u00e7\u00f5es de tens\u00f5es e deforma\u00e7\u00f5es ao longo das camadas do tubo. Pacotes multiuso \n\nde elementos finitos s\u00e3o comumente utilizados na an\u00e1lise local de tubos flex\u00edveis, mas, \n\ndevido as suas naturezas gen\u00e9ricas,  possuem limita\u00e7\u00f5es que variam desde a aus\u00eancia de \n\nferramentas espec\u00edficas para a cria\u00e7\u00e3o de modelos at\u00e9 restri\u00e7\u00f5es pesadas no n\u00famero total \n\nde graus de liberdade para tornar exequ\u00edvel o processo computacional. \n\nNa Escola Polit\u00e9cnica da Universidade de S\u00e3o Paulo, dentro de uma linha de pesquisa \n\nem andamento, diversos macroelementos finitos foram formulados especificamente para \n\na an\u00e1lise estrutural de tubos flex\u00edveis, levando em considera\u00e7\u00e3o as suas particularidades, \n\ncomo por exemplo padr\u00f5es de geometrias e de montagem de camadas. Entretanto, a \n\nferramenta num\u00e9rica que implementa esses elementos apresenta elevado consumo de \n\nmem\u00f3ria e de processamento, o que limita o seu uso para modelos de grande escala. \n\nPortanto, este trabalho foi motivado por limita\u00e7\u00f5es de mem\u00f3ria e processamento em \n\nan\u00e1lises estruturais com o m\u00e9todo dos elementos finitos para tubos flex\u00edveis de aplica\u00e7\u00f5es \n\noffshore. \n\nNeste contexto, o m\u00e9todo elemento-a-elemento, caracterizado pela elimina\u00e7\u00e3o da \n\nmatriz global de rigidez, foi escolhido devido ao seu potencial de redu\u00e7\u00e3o de consumo de \n\nmem\u00f3ria e \u00e0s suas capacidades de processamento, dada a sua escalabilidade e facilidade \n\nde paraleliza\u00e7\u00e3o. Ap\u00f3s uma extensa revis\u00e3o bibliogr\u00e1fica em m\u00e9todos num\u00e9ricos a \n\nrespeito do m\u00e9todo EBE, foi escolhido a vers\u00e3o diagonalmente precondicionada do \n\nm\u00e9todo do gradiente conjugado (EBE-PCG). \n\nCom o intuito de se obter maior performance computacional, os macroelementos \n\nfinitos formulados por (PROVASI, 2013) foram convertidos para a linguagem C++, \n\n\n\n \n\n \n\nparalelizados e implementado em uma nova ferramenta de an\u00e1lise chamada de PipeFEM, \n\ntotalmente escrita em C++ e que explora paralelismo em todos as etapas. \n\nO algoritmo EBE-PCG foi implementado e paralelizado com OpenMP. A \n\nescalabilidade do algoritmo PCG \u00e9 diretamente influenciada pela efici\u00eancia do produto \n\nentre matriz e vetor, uma opera\u00e7\u00e3o que no m\u00e9todo elemento-a-elemento \u00e9 calculada na \n\nbase local com os blocos que comp\u00f5em o modelo, o que requer t\u00e9cnicas de sincroniza\u00e7\u00e3o \n\nquando realizada de modo paralelo. Quatro diferentes estrat\u00e9gias de sincroniza\u00e7\u00e3o foram \n\ndesenvolvidas, sendo a mais eficiente delas a que utilizada mapeamentos baseados em \n\ncaracter\u00edsticas da geometria e malha. Experimentos num\u00e9ricos mostraram uma redu\u00e7\u00e3o \n\nde quase 92% no tempo de simula\u00e7\u00e3o do algoritmo PCG da vers\u00e3o paralelizada em \n\nrela\u00e7\u00e3o \u00e0 sequencial. \n\nDe modo a comparar a efici\u00eancia do PipeFEM com o pacote bem estabelecido de \n\nelementos finitos, ANSYS, um tubo simplificado foi modelado em ambos os programas. \n\nPipeFEM foi aproximadamente 82 vezes mais r\u00e1pido do que o ANSYS, gastando 24.27 \n\nsegundos contra 33 minutos e 18 segundos. Al\u00e9m disso, PipeFEM consumiu muito menos \n\nmem\u00f3ria, 61.8MB contra 6.8GB in ANSYS. Em compara\u00e7\u00e3o com a vers\u00e3o densa do \n\nMacroFEM, uma redu\u00e7\u00e3o superior a tr\u00eas ordens de grandeza no consum e de mem\u00f3ria foi \n\nobtida. \n\nAssim, apesar da baixa taxa de converg\u00eancia apresentada pelo precondicionador \n\ndiagonal, a implementa\u00e7\u00e3o est\u00e1 muito eficiente em termos computacionais. Portanto, os \n\nobjetivos deste trabalho foram alcan\u00e7ados com o desenvolvimento e aplica\u00e7\u00e3o do m\u00e9todo \n\nEBE, o que permitiu uma redu\u00e7\u00e3o consider\u00e1vel dos custos de simula\u00e7\u00e3o e mem\u00f3ria. \n\n \n\nPalavras-chave: Tubos flex\u00edveis, m\u00e9todo dos elementos finitos, m\u00e9todos num\u00e9ricos, \n\narquiteturas paralelas. \n\n\n\n \n\n \n\nList of Acronyms  \n\nAPI American Petroleum Institute \n\nBiCG Bi-Conjugate Gradient Method \n\nCAD Computer Aided Design \n\nCISC Complex Instruction Set Computing \n\nEBE Element-by-Element \n\nFEM Finite Element Method \n\nGMRES Generalized Minimal Residual Method \n\nHDPE High-density polyethylene \n\nHW Hughes-Winget Preconditioner \n\nLMO \nLaboratory of Offshore Mechanics of the University of Sao Paulo \n\n\u201cLaborat\u00f3rio de Mec\u00e2nica Offshore da Universidade de S\u00e3o Paulo\u201d \n\nOpenMP Open Multi-Processing \n\nMPI Message Passing Interface \n\nPA-11 Polyamide 11 or Nylon 11 \n\nPA-12 Polyamide 12 or Nylon 12 \n\nPCG Preconditioned Conjugate Gradient Method \n\nPSD Preconditioned Steepest Descent Method \n\nPVDF Polyvinylidene Difluoride \n\nRISC Reduced Instruction Set Computer \n\nVIV Vortex-induced Vibration \n\nXLPE Cross-linked Polyethylene \n\n \n\n \n\n \n\n\n\n \n\n \n\nList of Illustrations \n\nFig. 1.1 \u2013 Flexible pipe. Source: own authorship. .......................................................... 24 \n\nFig. 1.2 \u2013 Layers of a unbonded flexible pipe. Source: own authorship. ....................... 26 \n\nFig. 1.3 \u2013 Interlocked carcass. Source: own authorship. ................................................ 26 \n\nFig. 1.4 \u2013 Example of interlocked carcass profile. Source: (API RP 17B , 2002). ........ 27 \n\nFig. 1.5 \u2013 Carcass being manufactured. Source: (BARTELL, 2016). ............................ 27 \n\nFig. 1.6 \u2013 Interlocked pressure armor. Source: own authorship. .................................... 30 \n\nFig. 1.7 \u2013 Pressure armor profiles. Source: (API RP 17B , 2002). ................................. 30 \n\nFig. 1.8 \u2013 Caterpillar tensioner machine for flexible pipe launching. Source: (HUISMAN, \n\n2008). .............................................................................................................................. 31 \n\nFig. 1.9 \u2013 Manufacturing process of the anti-wear layers. Source: (BARTELL, 2016). 31 \n\nFig. 1.10 \u2013 Tensile armor manufacturing process. Source: (MALI, 2016). ................... 32 \n\nFig. 1.11 \u2013 Reinforcement tape being applied over the tensile layer. Source: (MALI, \n\n2016). .............................................................................................................................. 33 \n\nFig. 1.12 \u2013 Birdcaging of the tensile armors. Source: (BRAGA &amp; KALLEF, 2004). ... 33 \n\nFig. 1.13 \u2013 Bonded flexible pipe. Source: (CONTINENTAL, 2014) ............................ 34 \n\nFig. 1.14 \u2013 Unbonded flexible Pipe. Source: own authorship. ....................................... 35 \n\nFig. 1.15 \u2013 Static application design flowchart. Source: (API RP 17B , 2002). ............ 39 \n\nFig. 1.16 \u2013 Dynamic application design flowchart. Source: (API RP 17B , 2002). ....... 40 \n\nFig. 1.17 \u2013 Global analysis performed on Orcaflex. Source: (PDL GROUP, 2015). .... 41 \n\nFig. 1.18 \u2013 Detailed stresses analysis of an interlocked carcass. Source: (MUREN, 2007).\n\n ........................................................................................................................................ 42 \n\nFig. 1.19 \u2013 Simplified pipe simulated by (TONI, F.G., 2014). ...................................... 45 \n\nFig. 1.20 \u2013 Boundary conditions applied to the simplified pipe. Source: (TONI, F.G., \n\n2014). .............................................................................................................................. 46 \n\nFig. 1.21 \u2013 Radial displacement of a tendon from internal and external tensile armor layers \n\nalong the axial length of the pipe. Source: (TONI, F.G., 2014). .................................... 47 \n\nFig. 1.22 \u2013 Element mesh, with active beam section rendering option. Source: own \n\nauthorship. ...................................................................................................................... 48 \n\nFig. 1.23 \u2013 Radial displacements along the pipe axial coordinate. Left: internal armor; \n\nright: external armor. Source: own authorship. .............................................................. 48 \n\n\n\n \n\n \n\nFig. 1.24 \u2013 Circumferential displacements along the pipe axial coordinate. Left: internal \n\narmor; right: external armor. Source: own authorship. .................................................. 49 \n\nFig. 1.25 \u2013 Axial displacements along the pipe axial coordinate. Left: internal armor; \n\nright: external armor. Source: own authorship. .............................................................. 49 \n\nFig. 1.26 \u2013 Radial displacement along the pipe coordinate axis for the internal armor. \n\nSource: own authorship. ................................................................................................. 50 \n\nFig. 1.27 \u2013 Radial displacement along the pipe coordinate axis for the external armor. \n\nSource: own authorship. ................................................................................................. 50 \n\nFig. 1.28 \u2013 Sparsity pattern of global stiffness matrix of the simplified pipe simulated by \n\n(TONI, F.G., 2014). ........................................................................................................ 51 \n\nFig. 2.1 \u2013 Four nodes that compose the finite macroelement for orthotropic cylindrical \n\nlayer modeling. Source: own authorship. ....................................................................... 57 \n\nFig. 2.2 \u2013 Bridge contact macroelement with different nodes displacements natures. \n\nSource: (PROVASI &amp; MARTINS, 2013-a). .................................................................. 74 \n\nFig. 2.3 \u2013 First case: block in initial condition; Second: sticking condition; Third: sliding \n\ncondition. Source: (PROVASI, 2013). ........................................................................... 77 \n\nFig. 2.4 \u2013 Node-to-node contact: node 1 (Fourier) and node 2 (conventional). Source: \n\n(TONI, F.G., 2014). ........................................................................................................ 78 \n\nFig. 3.1 \u2013 Schematic diagram of parallel implementation of EBE-PCG algorithm. Source: \n\n(KING &amp; SONNAD, 1987). ......................................................................................... 100 \n\nFig. 3.2 \u2013 Parallel speedup ratios achieved on the 1CAP computer, corrected for effect of \n\nelement reordering on convergence. Source: (KING &amp; SONNAD, 1987). ................. 101 \n\nFig. 3.3 \u2013 Distribution of elements among subdomains. Source: (ADELI &amp; KUMAR, \n\n1995). ............................................................................................................................ 101 \n\nFig. 3.4 \u2013 Two level partitioning scheme. Mesh is first partitioned into subdomains for \n\nthe processors, then each subdomain is further divided into blocks of elements with the \n\nsame type, constitutive model, etc. Source: (GULLERUD &amp; DODDS JR, 2001). ..... 102 \n\nFig. 3.5 \u2013 Parallel solution of a load increment. Source: (GULLERUD &amp; DODDS JR, \n\n2001). ............................................................................................................................ 103 \n\nFig. 3.6 \u2013 Multiplication of ???? for a block of elements. Source: (GULLERUD &amp; \n\nDODDS JR, 2001). ....................................................................................................... 106 \n\nFig. 3.7 \u2013 Flowchart of FEM method based on EBE policy. Source: (LIU, ZHOU, &amp; \n\nYANG, 2007). .............................................................................................................. 107 \n\nFig. 4.1 \u2013 Flowchart of PipeFEM. Source: own authorship. ........................................ 108 \n\n\n\n \n\n \n\nFig. 4.2 \u2013 Libraries that compose the PipeFEM program. Source: own authorship. ... 109 \n\nFig. 4.3 \u2013 Finite elements. Source: own authorship. .................................................... 111 \n\nFig. 4.4 \u2013 Material library. Source: own authorship. .................................................... 112 \n\nFig. 4.5 \u2013 Section library. Source: own authorship. ..................................................... 112 \n\nFig. 5.1 \u2013 Vector memory management. Source: own authorship. .............................. 114 \n\nFig. 5.2 \u2013 Example of double starred pointer for matrix allocation. Source: own \n\nauthorship. .................................................................................................................... 115 \n\nFig. 5.3 \u2013 Memory hierarchy and indexing for the double starred pointer allocation. \n\nSource: own authorship. ............................................................................................... 115 \n\nFig. 5.4 \u2013 Single array scheme of storage. Source: own authorship............................. 115 \n\nFig. 5.5 \u2013 Memory management for fast resizing capability. Source: own authorship. 116 \n\nFig. 5.6 \u2013 Addition of a new line. Source: own authorship. ......................................... 116 \n\nFig. 5.7 \u2013 Addition of a new column. Source: own authorship. ................................... 117 \n\nFig. 5.8 \u2013 Examples of resizing cases with necessary memory reallocation. Source: own \n\nauthorship. .................................................................................................................... 117 \n\nFig. 5.9 \u2013 Memory management for additional pre-allocated lines. Source: own \n\nauthorship. .................................................................................................................... 118 \n\nFig. 5.10 \u2013 Memory management for additional pre-allocated columns. Source: own \n\nauthorship. .................................................................................................................... 118 \n\nFig. 5.11 \u2013 Memory management for both additional pre-allocated lines and columns. \n\nSource: own authorship. ............................................................................................... 118 \n\nFig. 5.12 \u2013 Single array memory allocation. Source: own authorship. ........................ 119 \n\nFig. 5.13 \u2013 Cache optimized product between two symmetric matrices, for (?, ?) indexes \n\nwhere ? ? ?. Source: own authorship. .......................................................................... 120 \n\nFig. 5.14 \u2013 Cache optimized product between two symmetric matrices, for (?, ?) indexes \n\nwhere ? > ?. Source: own authorship. .......................................................................... 120 \n\nFig. 5.15 \u2013 Performance comparison of the product between two matrices. Source: own \n\nauthorship. .................................................................................................................... 122 \n\nFig. 5.16 \u2013 One single large dynamically allocated array ensures the contiguous memory \n\nallocation. Source: own authorship. ............................................................................. 123 \n\nFig. 5.17 \u2013 EBE Matrix object. Source: own authorship. ............................................. 124 \n\nFig. 5.18 \u2013 Global degrees-of-freedom renumbering, the imposed ones are shifted to the \n\nend of the queue. Source: own authorship. ................................................................... 125 \n\n\n\n \n\n \n\nFig. 5.19 \u2013 Data rearrangement for the block, moving to the extremities the values \n\ncorresponding to the imposed degrees-of-freedom. Source: own authorship. ............. 126 \n\nFig. 6.1 \u2013 Hierarchical relations at the geometric level. Source: own authorship. ....... 127 \n\nFig. 6.2 \u2013 Volume, area, line and point of a cube. Source: own authorship. ................ 128 \n\nFig. 6.3 \u2013 Point object. Source: own authorship. .......................................................... 128 \n\nFig. 6.4 \u2013 Abstract line object. Source: own authorship............................................... 129 \n\nFig. 6.5 \u2013 Class hierarchy from curve. Source: own authorship. ................................. 130 \n\nFig. 6.6 \u2013 Half-lines indexing for a straight line. Source: own authorship. ................. 130 \n\nFig. 6.7 \u2013 Indexing changes when connecting two lines. Source: own authorship. ..... 131 \n\nFig. 6.8 \u2013 Half-line object. Source: own authorship. .................................................... 131 \n\nFig. 6.9 \u2013 Area object. Source: own authorship. .......................................................... 132 \n\nFig. 6.10 \u2013 Class hierarchy from Area. Source: own authorship.................................. 133 \n\nFig. 6.11 \u2013 Half-Area. Source: own authorship. ........................................................... 133 \n\nFig. 6.12 \u2013 Half-Area object. Source: own authorship. ................................................ 134 \n\nFig. 6.13 \u2013 Hierarchical relations at mesh level. Source: own authorship. .................. 135 \n\nFig. 6.14 \u2013 Node object. Source: own authorship. ....................................................... 136 \n\nFig. 6.15 \u2013 Node polymorphism. Source: own authorship. .......................................... 136 \n\nFig. 6.16 \u2013 Edge object. Source: own authorship. ........................................................ 137 \n\nFig. 6.17 \u2013 Linear and quadratic edges. Source: own authorship. ................................ 137 \n\nFig. 6.18 \u2013 Linear and quadratic versions of the triangular and rectangular shaped faces. \n\nSource: own authorship. ............................................................................................... 138 \n\nFig. 6.19 \u2013 Face object. Source: own authorship.......................................................... 138 \n\nFig. 6.20 \u2013 Meshing processes. Source: own authorship.............................................. 139 \n\nFig. 6.21 \u2013 Hierarchical levels of geometry and mesh and their relationships. Source: own \n\nauthorship. .................................................................................................................... 140 \n\nFig. 6.22 \u2013 Cascade methodology of the geometric meshing. Source: own authorship.\n\n ...................................................................................................................................... 140 \n\nFig. 6.23 \u2013 Indexed data-structure enables efficient entity selections. ......................... 142 \n\nFig. 7.1 \u2013 Global hierarchical level. Source: own authorship. ..................................... 143 \n\nFig. 7.2 \u2013 Example of the hierarchical levels application for a layer of tensile armors. \n\nSource: own authorship. ............................................................................................... 144 \n\nFig. 7.3 \u2013 Layer hierarchy. Source: own authorship. *Not explored at the current version.\n\n ...................................................................................................................................... 145 \n\nFig. 7.4 \u2013 Layer interfaces. Source: own authorship .................................................... 145 \n\n\n\n \n\n \n\nFig. 7.5 \u2013 Layer object. Source: own authorship. ......................................................... 146 \n\nFig. 7.6 \u2013 Layer polymorphism. Source: own authorship. ........................................... 146 \n\nFig. 7.7 \u2013 Pipe object. Source: own authorship. ........................................................... 147 \n\nFig. 7.8 \u2013 Pipe interfaces hierarchy. *Not yet implemented. Source: own authorship. 147 \n\nFig. 7.9 \u2013 Possibilities of contact between layers. Source: own authorship. ................ 148 \n\nFig. 8.1 \u2013 The Database object  Source: own authorship............................................. 149 \n\nFig. 8.2 \u2013 Solver flowchart. Source: own authorship. .................................................. 150 \n\nFig. 8.3 \u2013 Global degrees-of-freedom renumbering, shifting the imposed ones to the end. \n\nSource: own authorship. ............................................................................................... 158 \n\nFig. 8.4 \u2013 Linear system sub-regions. Source: own authorship. ................................... 158 \n\nFig. 9.1 \u2013 Example of update overlapping during the parallel evaluation of the global \n\ndiagonal. Source: own authorship. ............................................................................... 167 \n\nFig. 9.2 \u2013 Synchronization method based on local copies............................................ 168 \n\nFig. 9.3 \u2013 Each block has an array of indexes and a stiffness matrix. Source: own \n\nauthorship. .................................................................................................................... 169 \n\nFig. 9.4 \u2013 Gathering operation: the indexes are used to gather the local values of step \n\ndirections. Source: own authorship. ............................................................................. 170 \n\nFig. 9.5 \u2013 Local product operation. Source: own authorship. ...................................... 170 \n\nFig. 9.6 \u2013 Scattering operation. Source: own authorship. ............................................ 171 \n\nFig. 9.7 \u2013 The distribution of blocks into sets considers the squares of their dimensions. \n\nSource: own authorship. ............................................................................................... 176 \n\nFig. 9.8 \u2013 Table of booleans specifies the degrees-of-freedom that each thread modifies, \n\nwith which it is possible to generate the maps. Source: own authorship. .................... 177 \n\nFig. 9.9 \u2013 Tensile armor: the elements that belong to a wire are independent in relation to \n\nthe remaining wires. The contacts are handled separately. Source: own authorship. .. 180 \n\nFig. 9.10 \u2013 Continuously connect beam elements can be grouped into two single \n\nindependent sets. ........................................................................................................... 180 \n\nFig. 9.11 \u2013 Geometry and mesh of the polymeric sheath. Source: own authorship. .... 181 \n\nFig. 9.12 \u2013 Two-step procedure: in the first step, only the columns designated by 1 are \n\nconsidered; in the second, the ones designated by 2. Source: own authorship. ........... 181 \n\nFig. 9.13 \u2013 Four-step procedure. Source: own authorship............................................ 182 \n\nFig. 9.14 \u2013 Illustrative representation of the contact pairs for a pipe model with two tensile \n\narmors and an external polymeric sheath. Source: own authorship. ............................ 182 \n\nFig. 9.15 \u2013 Domain subdivision. Source: own authorship............................................ 183 \n\n\n\n \n\n \n\nFig. 9.16 \u2013 Problematic situation: contact pair located between two different domains. \n\nSource: own authorship. ............................................................................................... 183 \n\nFig. 10.1 \u2013 Simplified model of flexible pipe. Image generated in ANSYS\u00ae. Source: own \n\nauthorship. .................................................................................................................... 185 \n\nFig. 10.2 \u2013 Inner tensile armor layer. Image generated with ANSYS\u00ae. Source: own \n\nauthorship. .................................................................................................................... 186 \n\nFig. 10.3 \u2013 Outer tensile armor layer. Image generated with ANSYS\u00ae.  Source: own \n\nauthorship. .................................................................................................................... 187 \n\nFig. 10.4 \u2013 Polymeric sheath. Image generated with ANSYS\u00ae.  Source: own authorship.\n\n ...................................................................................................................................... 188 \n\nFig. 10.5 \u2013 The element mesh is illustrated in dark grey. Source: own authorship. Source: \n\nown authorship. ............................................................................................................ 188 \n\nFig. 10.6 \u2013 Simulation time of the computation of the element stiffness matrices for Mesh \n\nA (Table 10.6). Source: own authorship....................................................................... 194 \n\nFig. 10.7 \u2013 Speedup of the computation of the element stiffness matrices for Mesh A \n\n(Table 10.6). Source: own authorship. ......................................................................... 195 \n\nFig. 10.8 \u2013 Simulation time of the computation of the element stiffness matrices for Mesh \n\nB (Table 10.7). Source: own authorship. ...................................................................... 196 \n\nFig. 10.9 \u2013 Speedup of the computation of the element stiffness matrices for Mesh B \n\n(Table 10.7). Source: own authorship. ......................................................................... 197 \n\nFig. 10.10 \u2013 Simulation time, in milliseconds, of the matrix-vector product for Mesh A \n\n(Table 10.6). Source: own authorship. ......................................................................... 199 \n\nFig. 10.11 \u2013 Speedup of the matrix-vector product operation for Mesh A (Table 10.6). \n\nSource: own authorship. ............................................................................................... 200 \n\nFig. 10.12 \u2013 Simulation time, in milliseconds, of the matrix-vector product for Mesh B \n\n(Table 10.7). Source: own authorship. ......................................................................... 201 \n\nFig. 10.13 \u2013 Speedup of the matrix-vector product operation for Mesh B (Table 10.7). \n\nSource: own authorship. ............................................................................................... 202 \n\nFig. 10.14 \u2013 Simulation time, in seconds, of the PCG algorithm in function of the number \n\nof threads for Mesh A (Table 10.6). Source: own authorship. ..................................... 204 \n\nFig. 10.15 \u2013 Speedup of the PCG algorithm in function of the number of threads for Mesh \n\nA (Table 10.6). Source: own authorship....................................................................... 205 \n\nFig. 10.16 \u2013 Residual curve for the diagonal Jacobi preconditioned algorithm for Mesh A \n\n(Table 10.6). Source: own authorship. ......................................................................... 206 \n\n\n\n \n\n \n\nFig. 10.17 \u2013 Comparison of residual curves for different models. Source: own authorship.\n\n ...................................................................................................................................... 207 \n\nFig. 10.18 \u2013 Convergence in PipeFEM: radial displacements, in mm, along a tendon from \n\nthe internal tensile layer (Fixed: 100 axial and 2 radial divisions). Source: own authorship.\n\n ...................................................................................................................................... 209 \n\nFig. 10.19 \u2013 Convergence in PipeFEM: circumferential displacements, in mm, along a \n\ntendon from the internal tensile layer (Fixed: 100 axial and 2 radial divisions). Source: \n\nown authorship. ............................................................................................................ 210 \n\nFig. 10.20 \u2013 Convergence in PipeFEM: axial displacements, in mm, along a tendon from \n\nthe internal tensile layer (Fixed: 100 axial and 2 radial divisions). Source: own authorship.\n\n ...................................................................................................................................... 210 \n\nFig. 10.21 \u2013 Convergence in PipeFEM: radial displacements, in mm, along a tendon from \n\nthe internal tensile layer (Fixed: 2 radial divisions and 0 Order). Source: own authorship.\n\n ...................................................................................................................................... 211 \n\nFig. 10.22 \u2013 Convergence in PipeFEM: circumferential displacements, in mm, along a \n\ntendon from the internal tensile layer (Fixed: 2 radial divisions and 0 Order). Source: own \n\nauthorship. .................................................................................................................... 211 \n\nFig. 10.23 \u2013 Convergence in PipeFEM: axial displacements, in mm, along a tendon from \n\nthe internal tensile layer (Fixed: 2 radial divisions and 0 Order). Source: own authorship.\n\n ...................................................................................................................................... 212 \n\nFig. 10.24 \u2013 Convergence in PipeFEM: radial displacements, in mm, along a tendon from \n\nthe internal tensile layer (Fixed: 1 radial division and 0 Order). Source: own authorship.\n\n ...................................................................................................................................... 213 \n\nFig. 10.25 \u2013 Convergence in PipeFEM: circumferential displacements, in mm, along a \n\ntendon from the internal tensile layer (Fixed: 1 radial division and 0 Order). Source: own \n\nauthorship. .................................................................................................................... 213 \n\nFig. 10.26 \u2013 Convergence in PipeFEM: axial displacements, in mm, along a tendon from \n\nthe internal tensile layer (Fixed: 1 radial division and 0 Order). Source: own authorship.\n\n ...................................................................................................................................... 214 \n\nFig. 10.27 \u2013 Memory consumption in function of the number of degrees-of-freedom in \n\nPipeFEM (Fixed: 2 radial divisions). Source: own authorship. ................................... 216 \n\nFig. 10.28 \u2013 PCG simulation time in function of the number of degrees-of-freedom in \n\nPipeFEM. (Fixed: 2 radial divisions). Source: own authorship. .................................. 217 \n\n\n\n \n\n \n\nFig. 10.29 \u2013 Time per iteration of the PCG algorithm in function of the number of degrees-\n\nof-freedom in PipeFEM (Fixed: 2 radial divisions). Source: own authorship. ............ 217 \n\nFig. 10.30 \u2013 Convergence in ANSYS\u00ae: radial displacements, in mm, along a tendon from \n\nthe internal tensile layer. Source: own authorship. ....................................................... 219 \n\nFig. 10.31 \u2013 Convergence in ANSYS\u00ae: circumferential displacements, in mm, along a \n\ntendon from the internal tensile layer. Source: own authorship. .................................. 219 \n\nFig. 10.32 \u2013 Convergence in ANSYS\u00ae: axial displacements, in mm, along a tendon from \n\nthe internal tensile layer. Source: own authorship. ....................................................... 220 \n\nFig. 10.33 \u2013 Radial displacement of a tendon in the internal armor, traction loading. \n\nSource: own authorship. ............................................................................................... 221 \n\nFig. 10.34 \u2013 Circumferential displacement of a tendon in the internal armor, traction \n\nloading. Source: own authorship. ................................................................................. 222 \n\nFig. 10.35 \u2013 Axial displacement of a tendon in the internal armor, traction loading. \n\nSource: own authorship. ............................................................................................... 222 \n\n \n\n\n\n \n\n \n\nList of Tables \n\nTable 1.1 \u2013 Typically thermoplastic polymer materials used for flexible pipes. ........... 29 \n\nTable 1.2 \u2013 Description of the bonded family of flexible pipes. .................................... 35 \n\nTable 1.3 \u2013 Description of the unbonded family of flexible pipes. ................................ 36 \n\nTable 1.4 \u2013 Check list of failure modes for primary structural design of unbonded flexible \n\npipe. ................................................................................................................................ 37 \n\nTable 1.5 \u2013 Geometry properties. ................................................................................... 45 \n\nTable 1.6 \u2013 Material properties. ..................................................................................... 45 \n\nTable 3.1 \u2013 Standard version of the Preconditioned Conjugate Gradient Method (PCG).\n\n ........................................................................................................................................ 85 \n\nTable 3.2 \u2013 The Lanczos biorthogonalization procedure (SAAD, 2003). ...................... 88 \n\nTable 3.3 \u2013 Multi-component splitting. Adapted from: (WINGET &amp; HUGHES, 1985).\n\n ........................................................................................................................................ 94 \n\nTable 3.4 \u2013 EBE multi-component splitting. Adapted from (WINGET &amp; HUGHES, \n\n1985). .............................................................................................................................. 95 \n\nTable 3.5 \u2013 One-pass EBE multi-component splitting. .................................................. 96 \n\nTable 3.6 \u2013 Symmetric factorizations for one-pass EBE multi-component splitting. .... 96 \n\nTable 3.7 \u2013 Two-pass EBE multi-component splitting. ................................................. 97 \n\nTable 3.8 \u2013 Reordered one-pass EBE multi-component splitting. ................................. 98 \n\nTable 3.9 \u2013 Choice of parameters ? and ?.................................................................... 98 \n\nTable 3.10 \u2013 EBE Preconditioned Conjugate Gradient Algorithm. ............................. 104 \n\nTable 5.1 \u2013 Optimized algorithm for the product between two symmetric matrices. .. 121 \n\nTable 8.1 \u2013 First implementation of the d.o.f.s numbering algorithm. Source: own \n\nauthorship. .................................................................................................................... 151 \n\nTable 8.2 \u2013 Second implementation of the d.o.f.s numbering algorithm. ?????: \n\nmaximum Fourier order. ............................................................................................... 153 \n\nTable 8.3 \u2013 Blocks numbering algorithm. .................................................................... 155 \n\nTable 8.4 \u2013 EBE Matrix allocation and parallel computation of the element stiffness \n\nmatrices. ........................................................................................................................ 156 \n\nTable 8.5 \u2013 Logics of computation of the global arrays of loads, initial conditions and \n\nd.o.f. statuses. ............................................................................................................... 157 \n\n\n\n \n\n \n\nTable 9.1 \u2013 PCG Algorithm, solution of the linear system ?? = ?. ........................... 161 \n\nTable 9.2 \u2013 Implemented EBE-PCG algorithm. ........................................................... 162 \n\nTable 9.3 \u2013 Definition and allocation of the array of locks. ......................................... 172 \n\nTable 9.4 \u2013 Matrix-vector product using locks. ........................................................... 173 \n\nTable 9.5 \u2013 Definition and allocation of the local copy arrays..................................... 174 \n\nTable 9.6 \u2013 Matrix-vector product using the local copy arrays as synchronization \n\nmethodology. ................................................................................................................ 175 \n\nTable 9.7 \u2013 Mapped-optimized parallel summation of the local copy arrays. ............. 178 \n\nTable 10.1 \u2013 Parameters of the inner layer of tensile armor. Source: own authorship. 186 \n\nTable 10.2 \u2013 Parameters of the outer layer of tensile armor......................................... 187 \n\nTable 10.3 \u2013 Parameters of the polymeric sheath layer. ............................................... 189 \n\nTable 10.4 \u2013 Summary of the layers. ............................................................................ 189 \n\nTable 10.5 \u2013 Contact between layers. ........................................................................... 190 \n\nTable 10.6 \u2013 Mesh A. ................................................................................................... 190 \n\nTable 10.7 \u2013 Mesh B. ................................................................................................... 191 \n\nTable 10.8 \u2013 Workstation specifications: 16 real cores available for scalability tests. 191 \n\nTable 10.9 \u2013 Iteration procedure to compute the element stiffness matrices. .............. 195 \n\nTable 10.10 \u2013 Synchronization methods. ..................................................................... 198 \n\nTable 10.11 \u2013 Result comparison between Mesh A and Mesh B. ................................ 203 \n\nTable 10.12 \u2013 Execution time and memory consumption in PipeFEM. ...................... 215 \n\nTable 10.13 \u2013 Element meshes tested in ANSYS\u00ae for the convergence analysis. ....... 218 \n\nTable 10.14 \u2013 Execution time and memory consumption in ANSYS\u00ae. ....................... 220 \n\n \n\n\n\n \n\n \n\nContents \n\n Introduction .............................................................................................................. 24 \n\n1.1 Flexible Pipe ..................................................................................................... 24 \n\n1.1.1 Flexible Pipes Layers ................................................................................... 25 \n\n1.1.2 Flexible Pipe Classification ......................................................................... 34 \n\n1.2 Flexible Pipe Design ........................................................................................ 36 \n\n1.2.1 Global Analysis ........................................................................................... 41 \n\n1.2.2 Local Analysis ............................................................................................. 42 \n\n1.2.3 Finite Macroelements Introduction.............................................................. 44 \n\n1.3 Element-by-Element Method ........................................................................... 52 \n\n1.4 Objectives ......................................................................................................... 53 \n\n Finite Macroelement Theory .................................................................................. 55 \n\n2.1 Finite Macroelement for Orthotropic Cylindrical Layer Modeling ................. 56 \n\n2.2 Three-Dimensional Curved Helical Beam Element ......................................... 64 \n\n2.3 Bridge Finite Macroelement for Contact of Nodes with Different Displacement \n\nDescriptions ................................................................................................................ 73 \n\n2.4 Standard Finite Macroelement for Contact of Nodes with Different \n\nDisplacement Descriptions ......................................................................................... 77 \n\n Element-by-Element Method .................................................................................. 83 \n\n3.1 Iterative Algorithms for Linear System Solution ............................................. 84 \n\n3.1.1 Preconditioned Conjugate Gradient Method (PCG) .................................... 85 \n\n3.1.2 Lanczos Biorthogonalization (Lanczos) ...................................................... 87 \n\n3.2 EBE Preconditioners ........................................................................................ 89 \n\n3.2.1 Jacobi Diagonal Preconditioner ................................................................... 90 \n\n3.2.2 Hughes-Winget Preconditioner ................................................................... 90 \n\n3.3 Parallelization of the EBE method ................................................................... 99 \n\n\n\n \n\n \n\n PipeFEM ................................................................................................................. 108 \n\n4.1 ELIB \u2013 Element Library ................................................................................. 110 \n\n4.1.1 Element ...................................................................................................... 110 \n\n4.1.2 Element Type ............................................................................................. 111 \n\n4.2 MATLIB \u2013 Material Library .......................................................................... 112 \n\n4.3 SECLIB \u2013 Section Library ............................................................................. 112 \n\n Data Containers ..................................................................................................... 113 \n\n5.1 Vector ............................................................................................................. 113 \n\n5.2 Matrix ............................................................................................................. 114 \n\n5.3 Symmetric Matrix........................................................................................... 119 \n\n5.4 EBE Matrix..................................................................................................... 122 \n\n Geometry and Mesh ............................................................................................... 127 \n\n6.1 Geometry ........................................................................................................ 127 \n\n6.1.1 Point ........................................................................................................... 128 \n\n6.1.2 Line ............................................................................................................ 129 \n\n6.1.3 Area............................................................................................................ 132 \n\n6.1.4 Volume ...................................................................................................... 134 \n\n6.2 Mesh ............................................................................................................... 134 \n\n6.2.1 Node ........................................................................................................... 135 \n\n6.2.2 Edge ........................................................................................................... 136 \n\n6.2.3 Face ............................................................................................................ 137 \n\n6.2.4 Cell ............................................................................................................. 139 \n\n6.3 Parallel Mesh Generation ............................................................................... 139 \n\n6.4 Indexed Data Structure ................................................................................... 141 \n\n Layer and Pipe ....................................................................................................... 143 \n\n7.1 Layer ............................................................................................................... 144 \n\n7.2 Pipe ................................................................................................................. 146 \n\n7.3 Contact Between Layers ................................................................................. 148 \n\n\n\n \n\n \n\n Solver ....................................................................................................................... 149 \n\n Element-by-Element Preconditioned Conjugate Gradient Method ................. 160 \n\n9.1 Numerical Implementation ............................................................................. 162 \n\n9.2 Diagonal Preconditioner Computation ........................................................... 167 \n\n9.3 EBE Matrix-Vector Product ........................................................................... 168 \n\n9.3.1 Synchronization I: Global Array of Locks ................................................ 171 \n\n9.3.2 Synchronization II: Local Copies .............................................................. 174 \n\n9.3.3 Synchronization III: Mapped Local Copies ............................................... 176 \n\n9.3.4 Synchronization IV: Geometry- and Mesh-Based Mapped Solution ........ 179 \n\n Results ..................................................................................................................... 185 \n\n10.1 Finite Macroelement Model ........................................................................... 185 \n\n10.1.1 Inner Tensile Armor Layer ........................................................................ 186 \n\n10.1.2 Outer Tensile Armor Layer ....................................................................... 187 \n\n10.1.3 External Polymeric Sheath ........................................................................ 188 \n\n10.1.4 Contacts Between Layers .......................................................................... 189 \n\n10.1.5 Meshes ....................................................................................................... 190 \n\n10.2 Hardware ........................................................................................................ 191 \n\n10.3 Definition of Speedup .................................................................................... 192 \n\n10.4 Results of the Computation of the Element Stiffness Matrices...................... 193 \n\n10.5 Results of the EBE Matrix-Vector Product .................................................... 197 \n\n10.6 Results of the EBE-PCG Algorithm ............................................................... 203 \n\n10.7 Additional Results and Comparison with ANSYS\u00ae ...................................... 208 \n\n Conclusions ............................................................................................................. 224 \n\n References ............................................................................................................... 226 \n\n \n\n \n\n \n\n \n\n\n\n \n\n24 \n\n \n\n Introduction \n\n1.1 Flexible Pipe \n\nFlexible pipes, Fig. 1.1, are essential components in the offshore oil production, since \n\nthey are responsible for connecting the floating stations to the submerged equipment. \n\nBesides the transportation of oil and natural gas, they are also employed in the processes \n\nknown as gas lift that consists of the fluid injection in the wells with the objective of \n\nincreasing their productivity or service life. \n\n \n\n \n\n \n\nFig. 1.1 \u2013 Flexible pipe. Source: own authorship. \n\n \n\nFlexible pipes are characterized by having high axial stiffness, but low bending \n\nstiffness, allowing deflections of large amplitude without being damaged. This flexibility \n\nis essential, since, during its operation, the pipe is subjected to a wide range of static and \n\ndynamic loads. \n\nSeveral technological challenges are imposed by the hostile environment in which \n\nflexible pipes are immersed, starting with the high water depths in the extraction point \n\n\n\n \n\n25 \n\n \n\nthat can surpass three thousand meters in some cases of Brazilian pre-salt area. In these \n\ndepths, the pipe is subjected to very high external pressures that could collapse it. Great \n\ndepths are also a problem for risers (a flexible pipe configuration that connects a platform \n\nor ship to the seafloor installations), since longer hanging cable lengths means higher \n\naxial stresses. Besides that, flexible pipes are also subjected to very high internal \n\npressures, from the internal fluid pumping process that could cause the explosion of the \n\npipe, a phenomenon known as burst. Dynamic loads are also applied to flexible pipes \n\nduring its installation and operation. Platform movements and sea currents generate \n\ntraction, compressive, torsional and bending loads that could lead to its structural failure. \n\nThese dynamic loads, in conjunction with vibration phenomenon, such as VIV (vortex-\n\ninduced vibrations), could also lead the pipe to fatigue failure. Besides mechanical loads, \n\nflexible pipes are also exposed to sharp temperature variations and to corrosive agents. In \n\norder to support these loads and meet the functionality requirements, a flexible pipe must \n\ncontain several layers of helically extruded metallic wires, helically extruded interlocked \n\nprofiles and also extruded thermoplastics. Each of these layers is carefully designed to \n\ncarry out important structural and non-structural functions that must work together for the \n\nfull operation of the flexible pipe. \n\n \n\n1.1.1 Flexible Pipes Layers \n\nIn this section, a general overview of the typical layers of a flexible pipe will be \n\nprovided, emphasizing their main characteristics and structural functions. The typical \n\nnomenclature used for the layers of a flexible pipe is illustrated in Fig. 1.2, although it \n\nmay vary slightly according to the manufacturer. In the following items, these layers will \n\nbe individually described. \n\n \n\n\n\n \n\n26 \n\n \n\n \n\nFig. 1.2 \u2013 Layers of a unbonded flexible pipe. Source: own authorship. \n\n \n\n1.1.1.1 Interlocked Carcass \n\nThe interlocked carcass (Fig. 1.3) is a metallic layer manufactured through the \n\nhelically extrusion of a profile similar to the one illustrated in Fig. 1.4. That extrusion is \n\nperformed by a series of forming rolls that progressively transform steel stripes into a \n\nfully interlocked section, as shown in Fig. 1.5. The carcass provides collapse resistance \n\nto the pipe, allowing it to support high external pressures. \n\n \n\n \n\nFig. 1.3 \u2013 Interlocked carcass. Source: own authorship. \n\n\n\n \n\n27 \n\n \n\n \n\n \n\nFig. 1.4 \u2013 Example of interlocked carcass profile. Source: (API RP 17B , 2002). \n\n \n\n \n\nFig. 1.5 \u2013 Carcass being manufactured. Source: (BARTELL, 2016). \n\n \n\nFor being in constant contact with the transported fluid, the carcass material must \n\nsupport the wear generated by the flow, which may contain aggressive agents, such as \n\nsand or corrosive products. According to (API RP 17B , 2002), the materials typically \n\nused for the carcass are: \n\n\u2022 Carbon steel; \n\n\u2022 Ferritic stainless steel (AISIs 409 and 430); \n\n\u2022 Austenitic stainless steel (AISIs 304, 304L, 316, 316L); \n\n\u2022 High-alloyed stainless steel (e.g., Duplex UNS S31803); \n\n\u2022 Nickel based alloys (e.g., N08825). \n\n \n\n\n\n \n\n28 \n\n \n\nCarbon steel is the cheapest option, but appropriate just for non-corrosive fluids. \n\nHigh-alloyed stainless steels are more expensive, but suitable for corrosive conditions. \n\nThe material selection must also consider the fluid temperature and the presence of \n\nhydrogen sulfide (H2S), carbon dioxide (CO2), chlorides and oxygen in the transported \n\nfluid. Therefore, the material selection depends on the application particularities. \n\n \n\n1.1.1.2 Internal Pressure Sheath \n\nThe main function of the internal pressure sheath is to seal the interlocked carcass, \n\nwhich is not waterproof, containing the fluid and maintaining the flow integrity. \n\nCompared with the others, this is a layer of simplified geometry, manufactured through \n\nthe direct extrusion of a polymeric material over the carcass.  \n\nThe typical materials used for the pressure sheath are thermoplastic polymers: high-\n\ndensity polyethylene (HDPE), cross-linked polyethylene (XLPE), Nylon or Polyamide \n\n11 and 12 (PA 11 and PA12) and polyvinylidene difluoride (PVDF). The main \n\ncharacteristics of these materials are summarized in Table 1.1. \n\nWhen selecting the material, it should be considered the aging of the polymer, once \n\nits mechanical properties degrade with time. If the transported fluid is a gas, it is important \n\nto consider the blistering resistance and the permeability of the selected material to the \n\ninternal pressure sheath. \n\n \n\n\n\n \n\n29 \n\n \n\nTable 1.1 \u2013 Typically thermoplastic polymer materials used for flexible pipes. \n\n \n\nSource: (API RP 17B , 2002). \n\n \n\n1.1.1.3 Pressure Armor \n\nThe pressure armor, Fig. 1.6, is a metallic layer manufactured through the helically \n\nextrusion of profiles similar to the ones from Fig. 1.7. By supporting internal loads in the \n\nradial direction generated by the fluid pumping process, the main function of the pressure \n\narmor is to prevent the occurrence of burst, a failure mode which causes the rupture of \n\npressure armor due to excess of internal pressure. \n\n \n\n\n\n \n\n30 \n\n \n\n \n\nFig. 1.6 \u2013 Interlocked pressure armor. Source: own authorship. \n\n \n\n \n\nFig. 1.7 \u2013 Pressure armor profiles. Source: (API RP 17B , 2002). \n\n \n\nIn conjunction with the interlocked carcass, the pressure armor also provides collapse \n\nresistance. During the pipe installation and launching, the caterpillar tensioners, Fig. 1.8, \n\nmay cause the pipe crush and a part of these external radial loads is transmitted to the \n\npressure armor. In addition, this layer also resists to constriction that arises from tensile \n\narmors traction, a phenomenon known as squeeze. \n\n \n\n\n\n \n\n31 \n\n \n\n \n\nFig. 1.8 \u2013 Caterpillar tensioner machine for flexible pipe launching. Source: (HUISMAN, 2008). \n\n \n\n1.1.1.4 Antiwear layers \n\nThe anti-wear layers are tapes of polymeric material helically wrapped between the \n\ntensile armors and the pressure armor with the objective of reducing the friction wear \n\nbetween them, increasing the service life of the flexible pipe. \n\n \n\n \n\nFig. 1.9 \u2013 Manufacturing process of the anti-wear layers. Source: (BARTELL, 2016). \n\n \n\n1.1.1.5 Tensile Armor \n\nAccording to (API RP 17B , 2002), the tensile armor layers typically use flat, round \n\nor shaped metallic wires, in two or four layers cross-wound at an angle between 20 \n\ndegrees and 60 degrees. These wires are helically wounded by large rotating machines, \n\nlike the one from Fig. 1.10. The main function of a tensile layer is to resist the axial loads \n\n\n\n \n\n32 \n\n \n\nand to the stresses caused by the action of environmental loads and by the platform \n\nmovement. In general, a pipe must contain an even number of tensile layers, in a crossed \n\nconfiguration, i.e., intercalating layers whose helices grow in clockwise and anti-\n\nclockwise directions respectively, in order to obtain a torsionally balanced pipe. When \n\nthe pipe has at least one pressure armor, lay angles near 35 degrees are used. In the \n\nabsence of pressure armor, the tensile armors must have larger lay angles (close to 55 \n\ndegrees), providing radial stiffness to the pipe. \n\n \n\n \n\nFig. 1.10 \u2013 Tensile armor manufacturing process. Source: (MALI, 2016). \n\n \n\nThe typical material used for tensile armors is carbon steel. For great depths, which \n\nrequire very high axial strength, it is used high carbon steel instead of the conventional. \n\n \n\n1.1.1.6 Antibuckling Tape \n\nReinforcement tapes are usually made of aramid, a heat-resistant and very strong \n\nsynthetic fiber. They are applied over the outermost tensile armor layer, as shown in  Fig. \n\n1.11, in order to prevent the occurrence of birdcaging, Fig. 1.12, an instability \n\nphenomenon caused by the tensile armors buckling when they are excessively \n\ncompressed. The reinforcement tape increases the critical compressive load that a pipe \n\ncan endure before failing. \n\n \n\n\n\n \n\n33 \n\n \n\n \n\nFig. 1.11 \u2013 Reinforcement tape being applied over the tensile layer. Source: (MALI, 2016).  \n\n \n\n \n\nFig. 1.12 \u2013 Birdcaging of the tensile armors. Source: (BRAGA &amp; KALLEF, 2004). \n\n \n\n1.1.1.7 Outer Sheath \n\nThe outer sheath has the function of sealing the pipe and protecting its internal layers \n\nagainst sea water corrosion and small impacts. It also provides additional radial stiffness \n\nto the tensile armors when they are compressed, acting in conjunction with the \n\nantibuckling tape to prevent  the bird caging instability phenomenon. Like the internal \n\npressure sheath, this layer is extruded directly over the former one. \n\n \n\n\n\n \n\n34 \n\n \n\n1.1.2 Flexible Pipe Classification \n\nIn general, flexible pipes are specifically designed for every application, due to the \n\nparticularities of each extraction region, such as water depth, sea conditions and specific \n\noperational requirements. Customized design enables optimized solutions, but generates \n\na wide variety of existing pipe configurations. \n\nFor clarifying and organizational purposes, flexible pipes can be classified into the \n\nbonded and unbonded families. Illustrated in Fig. 1.13, \u201ca typical bonded flexible pipe \n\nconsists of several layers of elastomer either wrapped or extruded individually and then \n\nbonded together through the use of adhesives or by applying heat and/or pressure to fuse \n\nthe layers into a single construction\u201d (API RP 17B , 2002). Bonded flexible pipes can be \n\nfurther classified into \u201csmooth bore\u201d or \u201crough bore\u201d, as shown in Table 1.2 \n\n \n\n \n\nFig. 1.13 \u2013 Bonded flexible pipe. Source: (CONTINENTAL, 2014) \n\n \n\n\n\n \n\n35 \n\n \n\nTable 1.2 \u2013 Description of the bonded family of flexible pipes. \n\nLayer \n\nNo. \n\nLayer Primary  \n\nFunction \n\nBonded Flexible Pipe \n\nSmooth Bore Pipe Rough Bore Pipe \n\n1 Prevent collapse  Carcass \n\n2 Internal fluid integrity Liner Liner \n\n3 \nHoop and tensile load \n\nresistance \nReinforcement layer(s) Reinforcement layer(s) \n\n4 \nExternal fluid integrity and \n\nprotection \nCover Cover \n\nNotes: \n\n1. All pipe constructions may include various non-structural layers, such as filler layers and breaker fabrics. \n2. An external carcass may be added for protection purposes. \n\n3. The number of crosswound reinforcement plies may vary, though generally is either two, four or six.  \n\nAdapted from: (API RP 17B , 2002). \n\n \n\nUnbonded flexible pipes, Fig. 1.14, consist of concentric unbonded metallic helically \n\nextruded and unbonded polymeric extruded layers, with relative movement between \n\nthem. According to (API RP 17B , 2002), unbonded flexible pipes can be further \n\nclassified into \u201csmooth bore\u201d, \u201crough bore\u201d and \u201crough bore reinforced\u201d, as shown in \n\nTable 1.3. \n\n \n\n \n\nFig. 1.14 \u2013 Unbonded flexible Pipe. Source: own authorship. \n\n \n\n\n\n \n\n36 \n\n \n\nTable 1.3 \u2013 Description of the unbonded family of flexible pipes. \n\nLayer \n\nNo. \n\nLayer Primary \n\nFunction \n\nUnbonded Flexible Pipe \n\nSmooth Bore \n\nPipe \nRough Bore Pipe \n\nRough Bore \n\nReinforced Pipe \n\n1 Prevent collapse  Carcass Carcass \n\n2 Internal fluid integrity \nInternal pressure \n\nsheath \n\nInternal pressure \n\nsheath \n\nInternal pressure \n\nsheath \n\n3 Hoop stress resistance \nPressure armor \n\nlayer(s) \n \n\nPressure armor \n\nlayer(s) \n\n4 External fluid integrity Intermediate sheath   \n\n5 \nTensile stress \n\nresistance \n\nCrosswound tensile \n\narmors \n\nCrosswound tensile \n\narmors \n\nCrosswound tensile \n\narmors \n\n6 External fluid integrity Outer sheath Outer sheath Outer sheath \n\nNotes: \n\n1. All pipe constructions may include various nonstructural layers, such as anti-wear layers, tapes, \nmanufacturing aid layers, etc. \n\n2. An external carcass may be added for protection purposes. \n3. The pressure layer may be subdivided into an interlocked layer(s) and back-up layer(s). \n4. The number of crosswound armor layers may vary, though generally is either two or four. \n5. Thermal insulation may be added to the pipe. \n6. The internal pressure and outer sheaths may consist of a number of sublayers. \n7. Rough bore reinforced pipes are generally used for higher pressure applications. \n\n8. The intermediate sheath for smooth bore pipes is optional when there is no external pressure or external \npressure is less than the collapse pressure of the internal pressure sheath for the given application. \n\nAdapted from: (API RP 17B , 2002). \n\n \n\nCurrently, unbonded flexible pipes are the most commonly used type, once they \n\npermit larger deflections than bonded flexible pipes (i.e. smaller radius of curvature). \n\nThey also impose greater design challenges, due to the interactions between layers. The \n\noccurrence of relative movement with friction between layers makes the behavior of the \n\npipe highly nonlinear. The understanding and prediction of this complex behavior is of \n\ngreat and practical interest for offshore pipe industry and therefore this work will focus \n\non unbonded flexible pipes. \n\n \n\n1.2 Flexible Pipe Design \n\nFor being employed in offshore applications to transport oil from great depths to the \n\nsurface and also to pump fluids to the extraction wells, flexible pipes must be well- \n\ndimensioned; otherwise an accident would cause serious environmental and economic \n\nprejudices. The design of a flexible pipe consists, therefore, in the determination of an \n\n\n\n \n\n37 \n\n \n\neconomically feasible configuration which satisfies the requirements of functionality, \n\nperformance and safety. \n\nDue to the wide variety of loads and environmental conditions, a flexible pipe may \n\npresent several failure modes. In Table 1.4 are summarized the most important structural \n\nfailure modes of an unbonded flexible pipe and some alternatives to prevent them. The \n\npipe design must therefore ensure that these failure modes will not occur during its \n\ninstallation and operation. \n\n \n\nTable 1.4 \u2013 Check list of failure modes for primary structural design of unbonded flexible pipe. \n\nSource: (API RP 17B , 2002). \n\n \n\n\n\n \n\n38 \n\n \n\nPredicting the effect of the loads that are applied on a flexible pipe is not a trivial task \n\nand requires advanced engineering techniques, once the structural behavior of the pipe is \n\nhighly nonlinear. This nonlinearity arises not only from the material and geometry, but \n\nalso from the several frictional interactions between the layers. Thus, the flexible pipe \n\ndesign is a complex procedure and requires a multi-stage iterative process. \n\nAs can be seen in Fig. 1.15, the (API RP 17B , 2002) subdivides the design of flexible \n\npipes for static applications into five stages: \n\n\u2022 Stage 1 \u2013 Material Selection: in this stage the materials are selected in \n\naccordance to the environment characteristics (temperature, transported fluid \n\ncorrosivity, etc.) and to the functional requirements.  \n\n\u2022 Stage 2 \u2013 Cross-section configuration design: the cross-section is defined \n\nbased on the functional requirements of the pipe, such as a predetermined \n\ninternal diameter to achieve the desired fluid flow rate. This stage requires \n\nthe use of specific tools for structural calculations and checks. \n\n\u2022 Stage 3 \u2013 System configuration design: this stage consists on determining \n\nthe system configuration. For static applications, this stage is much simpler \n\nin comparison to the dynamic ones. \n\n\u2022 Stage 4 \u2013 Detail and service life design: \u201cthis stage includes the detailed \n\ndesign of ancillary components and corrosion protection. Service life \n\nanalysis is also performed at this stage as it applies to the pipe and \n\ncomponents\u201d. \n\n\u2022 Stage 5 \u2013 Installation design: \u201cthis stage completes the design process and \n\ninvolves the selection/design of the installation system, including vessel, \n\nequipment, methodology, and environment conditions. Stage 5 requires \n\ndetailed global and local analyses to confirm the feasibility of the selected \n\ninstallation system. For flowlines, this stage is-in many cases-critical for the \n\npipe design, and it is therefore recommended that preliminary installation \n\nanalyses be performed at an early stage in the design process\u201d. \n\n \n\n\n\n \n\n39 \n\n \n\n \n\nFig. 1.15 \u2013 Static application design flowchart. Source: (API RP 17B , 2002). \n\n \n\nThe design for dynamic applications also follows a multi-stage iterative scheme, but \n\nwith the particularities and complications of dynamic analysis, as shown in Fig. 1.16. \n\n \n\n\n\n \n\n40 \n\n \n\n \n\nFig. 1.16 \u2013 Dynamic application design flowchart. Source: (API RP 17B , 2002). \n\n \n\nIt is important to notice that, the global and local analyses are included in most of the \n\ndesign phases for both the static and dynamic applications. Due to the importance of these \n\nanalyses, they will be discussed individually in the next items. \n\n\n\n \n\n41 \n\n \n\n \n\n1.2.1 Global Analysis \n\n\u201cGlobal analysis is performed to evaluate the global load effects on the pipe during \n\nall stages of installation, operation, and retrieval, as applicable. The static configuration \n\nand extreme response of displacement, curvature, force and moment from environmental \n\neffects should be evaluated in the global analysis\u201d (API RP 17B , 2002). \n\nIn the global analysis, the pipe is modeled as a curved line on the global scale. After \n\nthe cross-section definition, the equivalent properties of the pipe can be evaluated, such \n\nas mass per unit length and axial, bending and torsional stiffnesses. These equivalent \n\nproperties are employed in the global analysis to determine the efforts distribution along \n\nthe pipe, without worrying about the stresses and strains values on the layers and the \n\npossible interaction effects between them. \n\nThis stage may require the use of specific numeric computational tools. Flexcom, \n\nOrcaFlex, Deeplines and Riflex are examples of dedicated commercial software for global \n\nanalysis of flexible pipes. Fig. 1.17 illustrates an example of a global analysis performed \n\nwith the software OrcaFlex. \n\n \n\n \n\nFig. 1.17 \u2013 Global analysis performed on Orcaflex. Source: (PDL GROUP, 2015). \n\n \n\n\n\n \n\n42 \n\n \n\n1.2.2 Local Analysis \n\n\u201cBecause of the composite layer structure of a flexible pipe, local cross-section \n\nanalysis is a complex subject, particularly for combined loads. Local analysis is required \n\nto relate global loadings to stresses and strains in the pipe. The calculated stresses and \n\nstrains are then compared to the specified design criteria for the load cases identified in \n\nthe project design premise\u201d (API RP 17B , 2002). \n\nTherefore, the local analysis consists of a more refined analysis, which objective is \n\nto determine the stresses and strains distributions along the flexible pipe layers, being of \n\nfundamental importance for the correct dimensioning of the same. Fig. 1.18 illustrates \n\none example of local analysis, in which it can be seen the stress distribution along an \n\ninterlocked carcass. \n\n \n\n \n\nFig. 1.18 \u2013 Detailed stresses analysis of an interlocked carcass. Source: (MUREN, 2007). \n\n \n\nOver the last decades, several approaches were developed for the solution of the local \n\nanalysis. They can be classified into analytical and numerical, each of them with \n\nadvantages and disadvantages, that complement each other. The analytical methods \n\nconsists of modeling the flexible pipe beyond a system of equations that can be \n\nanalytically solved with a computer. In this case, the modeling of the pipe is the most \n\ncomplex activity in most of the time and often a number of hypothesis, assumptions or \n\n\n\n \n\n43 \n\n \n\nsimplifications are needed to simplify or make feasible the modeling. However, with \n\nmodelling challenges overcome, the analytical methods are characterized by fast \n\nsolutions. The numerical methods are mainly based on the finite element method (FEM) \n\nand, comparatively, require a much lower number of assumptions, which confers greater \n\ncapability of solving more generic problems. Despite the advantages, the computational \n\ncosts from numerical methods can become very high and even infeasible in some cases. \n\nThe analytical methods for local analysis present so far are not able to solve sliding \n\nproblems of tensile armors with friction. Therefore, numerical methods are the only \n\nalternative in this case, in special the finite element method, which stands out for its ability \n\nof solving problems of complex and irregular geometries, besides the inclusion of \n\nnonlinearities in the model, such as material plasticity and nonlinear interactions between \n\ncomponents involving friction. The finite element method also has disadvantages. \n\nSimulations of flexible pipes are problems of difficult convergence, given the high level \n\nof nonlinearity of the models. It is also possible to achieve incoherent or without physical \n\nsense solutions, requiring a critical evaluation of results by an experienced analyst. \n\nSimulation time and cost may not be viable for models with some millions of degrees of \n\nfreedom, thus limiting its applicability. In some situations, the model can be simplified, \n\nassuming plan or axisymmetric hypothesis, or limiting the analysis to the essential layers \n\nfor the understanding of the phenomenon of interest. \n\nMultipurpose software, such ANSYS\u00ae and ABAQUS\u00ae, are generic packages for the \n\nfinite element method, designed to meet the widest range possible of applications. Despite \n\nall available resources and solution methods, these computer programs show many \n\nlimitations regarding the simulation of flexible pipes. In the preprocessing stage, the \n\nabsence of specific CAD tools makes the pipe drawing a costly activity and difficult to \n\nbe automatized.  In some cases, the definition of contact pairs must be performed \n\nindividually, making it a laborious task, given the high number of interactions between \n\ncomponents. In the processing stage, limitations on the number of degrees of freedom \n\nmake unfeasible the analysis of a model of flexible pipe with several layers. Moreover, \n\nthese programs require extensive training periods until the user is able to use them and \n\ncapable of circumventing their limitations. \n\nThe limitations and problems found in multipurpose finite element software have \n\nmotivated the development of dedicated tools for the design of flexible pipes. BFLEX, \n\nUFLEX, UmbiliCAD are examples of commercial software specifically developed to the \n\nlocal analysis of flexible pipes and umbilicals. However, in many cases, the use of specific \n\n\n\n \n\n44 \n\n \n\nsoftware is restricted to large pipe manufacturers, which financed their developments. \n\nBesides, even if they were available, these programs would be of limited academic \n\ninterest, once they would be black box solutions, i.e., the implemented mathematical and \n\nnumerical models would not be known for commercial and confidential reasons, being \n\npossible only application-based developments with these tools. \n\nIn this context lies the finite macroelements field, which are finite elements \n\nformulated to solve a specific problem. Finite macroelements enable the reduction of \n\ncomputational costs and facilitate the implementation of the model by considering the \n\nparticularities of the problem. Therefore, finite macroelements possess great potential for \n\nlocal structural analysis of flexible pipes, allowing simulation of pipes that were not \n\npossible or that were very costly with conventional elements. \n\n \n\n1.2.3 Finite Macroelements Introduction \n\nIn his PhD work, (PROVASI, 2013) developed several finite macroelements for \n\nmodeling layers of a flexible pipe and a full description of these elements is presented in \n\nChapter 2. In order to validate the formulations, (PROVASI, 2013) also implemented \n\nthese finite macroelements in an analysis tool called MacroFEM. For prioritizing the \n\nvalidation process, little attention was initially given to the performance of the \n\nimplemented code, making this promising analysis tool impractical, due to the \n\nexcessively high computational demands and simulation times. With the objective of \n\nobtaining an efficient tool for structural analysis of flexible pipes, (TONI, F.G., 2014) \n\nperformed an extension of PROVASI\u2019s work. A series of modifications in the code \n\nstructure were made, implementation bugs were fixed and a new library of solution of \n\nlinear systems was adopted, which allowed a reduction of up to 95% of the global stiffness \n\nmatrix assemblage and a reduction of two orders of magnitude in time resolution of the \n\nlinear systems. This increase in performance allowed the simulation of a more complex, \n\nbut still simplified, three-layered flexible pipe illustrated in Fig. 1.19: \n\n\u2022 one internal tensile armor layer with 16 tendons; \n\n\u2022 one external tensile armor layer with 18 tendons; \n\n\u2022 one external polymeric sheath. \n\n \n\n\n\n \n\n45 \n\n \n\n \n\nFig. 1.19 \u2013 Simplified pipe simulated by (TONI, F.G., 2014). \n\n \n\nIt was assumed an isotropic linear elastic constitutive law for all materials. All \n\ngeometry and material properties from this simplified model are summarized in Table 1.5 \n\nand Table 1.6, respectively. \n\n \n\nTable 1.5 \u2013 Geometry properties. \n\nProperty Internal Armor External Armor Polymeric Sheath \n\nMean Radius (mm) 101.25 105.25 110.75 \n\nCross Section \n\nW x H (mm) \n8 x 4 8 x 4 --- \n\nNumber of Tendons 16 18 --- \n\nLay Angle (deg.) 36 -38 --- \n\nThickness (mm) --- --- 7 \n\nSource: own authorship. \n\n \n\nTable 1.6 \u2013 Material properties. \n\nProperty Internal Armor External Armor Polymeric Sheath \n\nYoung Modulus (MPa) 207,000 207,000 570.88 \n\nPoisson Ratio 0.3 0.3 0.45 \n\nSource: own authorship. \n\n\n\n \n\n46 \n\n \n\n \n\nThe armor layers were modeled with helical beam elements, the polymeric sheath \n\nwith orthotropic cylinder and the rigid connections with bonded and bridge node-to-node \n\ncontact elements. For comparison, the same pipe was modeled in ABAQUS, Fig. 1.20, \n\nusing 3D linear 8-node solid elements without reduced integration for the tensile armors \n\nand 3D quadratic 8-node doubly curved thick shell with reduced integration for the \n\npolymeric sheath. Regarding the contact, it was used the General Contact method, which \n\ndetermines automatically the contact pairs. In the same Fig. 1.20 are also illustrated the \n\nboundaries conditions: an end fully constrained and an axial traction-displacement of 10 \n\nmm applied to the other. \n\n \n\n \n\nFig. 1.20 \u2013 Boundary conditions applied to the simplified pipe. Source: (TONI, F.G., 2014). \n\n \n\nThe graph of Fig. 1.21 shows the radial displacements of a tendon of the internal and \n\nexternal tensile armor layers along the axial length of the pipe obtained with both \n\nprograms.  \n\n\n\n \n\n47 \n\n \n\n \n\nFig. 1.21 \u2013 Radial displacement of a tendon from internal and external tensile armor layers along the axial \n\nlength of the pipe. Source: (TONI, F.G., 2014). \n\n \n\nFor a fairer comparison, the same pipe was modeled in ANSYS\u00ae with second-order \n\nbeam elements for the helices (BEAM189) and second-order isoparametric solid elements \n\nfor the external sheath (SOLID186). Orientation keypoints were used to rotate correctly \n\nthe cross section of the beam elements. The final mesh is illustrated in Fig. 1.22. The \n\ninterface between the two armors is modeled with 3D line-to-line contact elements \n\n(CONTA176) in crossing condition, which enables great results for beam-to-beam \n\ncontact. The interface between the external armor and the external sheath used 3D line-\n\nto-surface contact elements (CONTA177). The contact behavior was selected as bonded \n\nalways for both interfaces. \n\n \n\n-1.2\n\n-1.0\n\n-0.8\n\n-0.6\n\n-0.4\n\n-0.2\n\n0.0\n\n0 250 500 750 1000 1250 1500 1750\n\nR\na\nd\n\nia\nl \n\nd\nis\n\np\nla\n\nc\ne\nm\n\ne\nn\n\nt \n(m\n\nm\n)\n\nPipe's Axial Length (mm)\n\nAbaqus - Internal Abaqus External MacroFEM - Internal MacroFEM - External\n\n\n\n \n\n48 \n\n \n\n \n\nFig. 1.22 \u2013 Element mesh, with active beam section rendering option. Source: own authorship. \n\n \n\nThe radial, circumferential and axial displacements along a tendon of the internal and \n\nexternal tensile armors obtained with ANSYS and MacroFEM can be seen in Fig. 1.23 to \n\nFig. 1.25, respectively. \n\n \n\n  \nFig. 1.23 \u2013 Radial displacements along the pipe axial coordinate. Left: internal armor; right: external \n\narmor. Source: own authorship. \n\n \n\n\n\n \n\n49 \n\n \n\n  \nFig. 1.24 \u2013 Circumferential displacements along the pipe axial coordinate. Left: internal armor; right: \n\nexternal armor. Source: own authorship. \n\n \n\n  \nFig. 1.25 \u2013 Axial displacements along the pipe axial coordinate. Left: internal armor; right: external \n\narmor. Source: own authorship. \n\n \n\nComparing both implementations, the differences of displacements in radial and \n\naxial directions are under 1%. The most noticeable difference appears in circumferential \n\ndirection, which is an order lower than the radial one, but even so it is still less than 10%. \n\nTherefore, it can be concluded that the results obtained with MacroFEM are pretty good \n\nwhen compared with the well-established multipurpose software ANSYS\u00ae. \n\nFor comparison, a full solid model was also implemented and tested in ANSYS\u00ae. In \n\nthis case, the tensile armors were modeled with second-order SOLID186 elements and all \n\ninteractions were of the type surface-to-surface (CONTA174/TARGE170). The radial \n\ndisplacements along a tendon from the internal and external armors are in Fig. 1.26 and \n\nFig. 1.27, respectively. \n\n \n\n\n\n \n\n50 \n\n \n\n \n\nFig. 1.26 \u2013 Radial displacement along the pipe coordinate axis for the internal armor. Source: own \n\nauthorship. \n\n \n\n \n\nFig. 1.27 \u2013 Radial displacement along the pipe coordinate axis for the external armor. Source: own \n\nauthorship. \n\n \n\nAnalyzing these results, it is concluded that the magnitude of the radial displacements \n\nfrom the full solid models are approximately between 10% to 15% lower, what can be \n\nexplained by modelling differences: the surface-to-surface contact type between armors \n\nused in ABAQUS\u00ae and ANSYS\u00ae contributed to rigidly connect hundreds of small contact \n\nareas, making the structure stiffer in comparison to the node-to-node model in \n\nMacroFEM. \n\nDespite the progress in performance and simulation time, MacroFEM still possesses \n\na serious limitation regarding the amount of consumed memory. This is because most of \n\nthe data, including the global stiffness matrix, is stored in dense matrices and, therefore, \n\nmemory consumption grows quadratically with the number of degrees of freedom of the \n\n\n\n \n\n51 \n\n \n\nmodel. To get an idea of the magnitude of this consumption, the simulation of the \n\nsimplified pipe of Fig. 1.19 required more than 60 GB of RAM, eliminating any \n\npossibility of simulating pipes with more layers or components. \n\nThe global stiffness matrix is the main responsible for the excessively high memory \n\nconsumption, once its dimensions are determined by the total number of degrees of \n\nfreedom of the model. Fig. 1.28 shows the global stiffness matrix from the simplified pipe \n\nsimulated by (TONI, F.G., 2014), in which the non-zero elements are represented in \n\nblack. The contact elements occupy the distant positions from the main diagonal, which \n\nincreases the bandwidth of the matrix. An important conclusion can be made after \n\nanalyzing this matrix: a drastic reduction in memory consumption can be obtained with \n\nthe implementation of a convenient data structure. \n\n \n\n \n\nFig. 1.28 \u2013 Sparsity pattern of global stiffness matrix of the simplified pipe simulated by (TONI, F.G., \n\n2014). \n\n \n\n\n\n \n\n52 \n\n \n\n1.3 Element-by-Element Method \n\nGiven the sparsity pattern of the matrix of Fig. 1.28, a data structure that utilizes \n\nsparse matrices could significantly reduce the amount of consumed memory. Sparse \n\nmatrices are vastly used in the literature and commercial finite element packages. \n\nHowever, a generic implementation of sparse matrices would hardly be competitive with \n\nconsolidated and well-established existing linear algebra libraries, such as Pardiso. \n\nA possible solution to this problem is the development and implementation of \n\ncustomized sparse matrices specifically to the finite elements used to simulate a flexible \n\npipe. By knowing beforehand which the global matrix sparsity pattern is, it is possible to \n\noptimize mathematical operators, eliminating the execution of unnecessary numerical \n\noperations and develop a specific algorithm of linear system resolution and, this way, \n\nachieve an efficient solution for problem. This, nevertheless, would be a very low flexible \n\nsolution. The data structure of sparse matrices should be parametric enough to meet the \n\ncombinations and variations in the type and arrangement of elements, what is a very \n\ncomplex task to be determined and predicted. In addition, this solution also would hold \n\nthe risk of not being able to receive new types of elements in the future, due to probable \n\ndifferences in element stiffness matrices patterns, freezing future improvements of the \n\nanalysis tool. \n\nIn this context, arises the element-by-element method (EBE), which is an alternative \n\nto the sparse formulation. In this method, the global stiffness matrix is eliminated and all \n\ncalculations are performed in an element level. Therefore, the memory consumption \n\nincreases linearly with the number of elements. The sparse form requires a smaller \n\nnumber of mathematical operations to execute the same algorithm than the EBE form, \n\nbut with a potential increase in memory depending on the details of the implementation. \n\nHowever, the main advantage of the EBE formulation consists on the scalability and \n\nease of parallelization of the numerical solution. The larger number of numeric operations \n\nrequired by the EBE, in comparison to the sparse formulation, is rapidly compensated by \n\ntechniques of parallel programming and element based domain decompositions, taking \n\nadvantage from clusters and modern processors, which have several processing cores. \n\nThe easiness of adding new types of elements also must be highlighted in the EBE \n\nmethod. As the calculations are carried out in a local basis, it is necessary to implement \n\nonly a matrix-vector multiplication for this element and a scattering method between the \n\nlocal and global degrees-of-freedom. \n\n\n\n \n\n53 \n\n \n\n \n\n1.4 Objectives \n\nThe sparsity pattern of the global stiffness matrix of Fig. 1.28 illustrates the potential \n\nin memory reduction that can be obtained with the application of the element-by-element \n\nmethod. From the point of view of processing capacity, the EBE presents advantages for \n\nits scalability and easy of parallelization.  A considerable reduction in both memory \n\nconsumption and processing time when simulating large-scale structural problems of \n\nflexible pipes can be achieved with the application of the EBE method, being of great \n\ninterest for the development of flexible pipes and in practical industry applications. \n\nThe implementation of the EBE method imposes some challenges, since it requires a \n\nproper data structure for storing and manipulating with efficiency the element stiffness \n\nmatrices. A suitable indexing system is also needed, since it is responsible for relating the \n\nlocal and global degrees-of-freedom from the elements that comprise the model. Lastly, \n\nan EBE iterative algorithm for solving of linear system of equations also must be \n\nimplemented. \n\nWhen developing a program for large-scale applications, it is important to employ \n\nproper data structures, algorithms and programming languages. In this context, the EBE \n\nmethod already meets these first two requirements. Concerning the third one, it was \n\ndecided to carry out this work in C++, aiming higher computational performance. Besides \n\nthat, although third-party linear algebra libraries accelerate the implementation, their use \n\nwas banned in this work, because they may pose obstructions on the development for \n\nbeing black-box solutions. \n\nTherefore, his work consists in the development and implementation of a new \n\nanalysis tool that utilizes the EBE method and the finite macroelements developed by \n\n(PROVASI, 2013) for large-scale structural analysis of flexible pipes. This involves the \n\ndevelopment of a proper data structure in C++, an indexing system that relates local and \n\nglobal degrees-of-freedom, and a parallelized EBE algorithm for solution of linear system \n\nof equations. By combining memory reduction with parallelized data processing, it is \n\npossible to obtain a balanced and efficient analysis tool of large-scale models of flexible \n\npipes. \n\nIn Chapter 2, a complete bibliographic review of the finite macro element theory is \n\nperformed. The deep knowledge of the characteristics of the elements is of fundamental \n\nimportance for a successful implementation. In sequence, the element-by-element method \n\n\n\n \n\n54 \n\n \n\nis reviewed in detail in Chapter 3, with the purpose of determining the most appropriate \n\nalgorithms and methods to be implemented for the solution of large-scale problems of \n\nflexible pipes. In Chapter 4, the new analysis tool developed in this work for the local \n\nanalysis of flexible pipes is presented. It is entirely written in C++ and explores \n\nparallelism at all stages. Chapter 5 presents the developed containers of the implemented \n\nlinear algebra library, used for data storage and manipulation, besides mathematical \n\noperations, which are widely employed in the computation of the element stiffness \n\nmatrices, for instance. Aiming high computational performance also in the model \n\ngeneration (what includes geometry and mesh), a fully indexed data structure was \n\ndeveloped in conjunction with parallel meshing methods, which are presented in Chapters \n\n6 to 7. The numerical solution of the problem is presented in Chapters 8 and 9, which \n\ndescribes the implementation of the solver and the EBE-PCG algorithm, respectively. A \n\nseries of numerical results and comparisons are presented in Chapter 10 and, lastly, the \n\nfinal conclusions are made in the Chapter 11. \n\n   \n\n\n\n \n\n55 \n\n \n\n Finite Macroelement Theory \n\nFinite macroelements are finite elements formulated for the solution of a specific \n\nproblem, considering and taking advantage of its particularities, such as geometry \n\npatterns, and thereby, due to a better quality in the representation of the problem, reduce \n\nthe total number of elements and degrees-of-freedom, besides advantages related to ease \n\nof use and implementation. \n\nOver the last years, several finite macroelements were formulated specifically for \n\nmodeling and solving problems involving flexible pipes, allowing improved \n\ncomputational performance and simpler layer descriptions, among other advantages. \n\nThese elements are presented throughout this chapter. It is important to note that this work \n\ndoes not aim the development of new finite macroelements, but the application of already \n\nexisting ones into a convenient data structure, suitable for large-scale models. This work \n\nfocus on the finite macroelements formulated by PROVASI &amp; MARTINS, given \n\ncontinuity to a research line of the Laboratory of Offshore Mechanics of the University \n\nof Sao Paulo (LMO-USP), and they are presented as follows: \n\n\u2022 Orthotropic cylindrical element: this finite macroelement, fully described in \n\nitem 2.1, can be used to model polymeric sheaths and equivalent cylindrical \n\nlayers. An equivalent reinforcement tape layer may also be modeled with this \n\nelement, due to its orthotropic characteristic. This three-dimensional element has \n\n4 nodes, whose displacements are expanded in a Fourier series.  \n\n\u2022 Three-dimensional curved helical beam: this helically curved beam element, \n\npresented in item 2.2, can be used to model the tensile armors of  a flexible pipe. \n\nConventional beams would require cross-section rotations, besides a considerably \n\nlarger number of elements to represent the tensile armor tendons with the same \n\nquality. \n\n\u2022 Bridge contact element with nodes of different displacements natures: this \n\nelement (item 2.3) can be employed to simulate rigid connections between the first \n\ntwo previously finite macroelements. Due the different nodal natures (cylinder \n\nnodes have Fourier expanded displacements), this specific element had to be \n\nformulated. \n\n\n\n \n\n56 \n\n \n\n\u2022 Standard contact element with nodes of different displacements natures: for \n\nthe same reasons of the bridge contact, this element (2.4) simulates standard \n\ninteractions between the cylindrical and helix elements, which may involve gap \n\nformation, tangential sliding and friction. \n\n \n\n2.1 Finite Macroelement for Orthotropic Cylindrical \nLayer Modeling \n\nThis finite macroelement, illustrated in Fig. 2.1, was formulated by (PROVASI &amp; \n\nMARTINS, 2013-c) and consists in an extension of the isotropic cylinder shown in \n\n(COOK, MALKUS, PLESHA, &amp; WITT, 2002). It belongs to a special class of elements \n\nknown as Solids of Revolution, once its formulation differs from the conventional ones \n\nby having the nodal displacements expanded into a Fourier series using a cylindrical \n\ncoordinate system: \n\n \n\n \n\n{\n \n \n \n \n\n \n \n \n ? = ? ????(?,?)cos??\n\n?\n\n?=0\n\n+ ?????(?,?)sin??\n\n?\n\n?=0\n\n? = ?????(?,?)sin??\n\n?\n\n?=0\n\n? ?????(?,?)cos??\n\n?\n\n?=0\n\n? = ?????(?,?)cos??\n\n?\n\n?=0\n\n+ ?????(?,?)sin??\n\n?\n\n?=0\n\n Eq. 2.1 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the displacement in the radial direction; \n\n\u2022 ? \u2013 is the displacement in the circumferential direction; \n\n\u2022 ? \u2013 is the displacement in the axial direction; \n\n\u2022 ? \u2013 denotes the circumferential direction; \n\n\u2022 ? \u2013 is the order of the Fourier series expansion; \n\n\u2022 ? \u2013 represents an infinite sum of the expansion terms. Computationally, it is \n\nreplaced by a user-defined maximum expansion order, ????. \n\n\u2022 ????, ????, ????, ????, ???? and ???? \u2013 are amplitudes of displacements that may depend \n\non ?, ? and/or ? but are independent of ?. \u201cSingle-barred series describe \n\ndisplacements states that are symmetric with respect to ? = 0; double-barred \n\n\n\n \n\n57 \n\n \n\nseries describe displacements states that are antisymmetric with respect to \n\n? = 0\u201d  (Cook et al., 2002). \n\n  \n\n \n\nFig. 2.1 \u2013 Four nodes that compose the finite macroelement for orthotropic cylindrical layer modeling. \n\nSource: own authorship. \n\n \n\n\u201cThe advantage of this element is that no division in the ? direction is required, so \n\nthat instead of solving one large 3D problem, we instead solve a few 2D problems and \n\ncombine results. Thus, data preparation is simplified and the analysis is much less \n\ndemanding of computer resources\u201d (COOK, MALKUS, PLESHA, &amp; WITT, 2002). \n\nIt was adopted a linear elastic material model. Thus, the infinitesimal deformations \n\nare given by: \n\n \n\n ? =\n??\n\n??\n Eq. 2.2 \n\n \n\n ? =\n?\n\n?\n+\n1\n\n?\n\n??\n\n??\n Eq. 2.3 \n\n \n\n ? =\n??\n\n??\n Eq. 2.4 \n\n \n\n ??? =\n1\n\n?\n\n??\n\n??\n+\n??\n\n??\n?\n?\n\n?\n Eq. 2.5 \n\n\n\n \n\n58 \n\n \n\n \n\n ??? =\n??\n\n??\n+\n??\n\n??\n Eq. 2.6 \n\n \n\n ??? =\n??\n\n??\n+\n1\n\n?\n\n??\n\n??\n Eq. 2.7 \n\n \n\nwhere: \n\n\u2022 ? \u2013 are the strains in the direction given by the subscript ?; \n\n\u2022 ??? \u2013 are the shear strains in the plane given by the subscript ??; \n\n \n\nThe strain-displacements relations in cylindrical coordinates can be rewritten in \n\nmatrix form: \n\n \n\n ? = [?] ? Eq. 2.8 \n\n \n\n \n\n{\n \n \n\n \n \n\n?\n\n?\n\n?\n\n???\n???\n???}\n\n \n \n\n \n \n\n= \n\n[\n \n \n \n \n \n \n \n \n \n \n \n \n?\n\n??\n0 0\n\n1\n\n?\n\n?\n\n???\n0\n\n0 0\n?\n\n??\n?\n\n??\n0\n\n?\n\n??\n?\n\n???\n(\n?\n\n??\n?\n1\n\n?\n) 0\n\n0\n?\n\n??\n\n?\n\n???]\n \n \n \n \n \n \n \n \n \n \n \n \n\n {\n?\n?\n?\n} Eq. 2.9 \n\n \n\nThe stress-strains relations are given by: \n\n \n\n ? =  ? ? Eq. 2.10 \n\n \n\n ? = [?? ?? ?? ??? ??? ???]? Eq. 2.11 \n\n \n\nThe most generic expression for the material elasticity matrix, E, when ? is a \n\nprincipal material direction is given by: \n\n \n\n\n\n \n\n59 \n\n \n\n \n\n ? =\n\n[\n \n \n \n \n \n?11 ?12 ?13 ?14 0 0\n?21 ?22 ?23 ?24 0 0\n?31 ?32 ?33 ?34 0 0\n?41 ?42 ?43 ?44 0 0\n0 0 0 0 ?55 ?56\n0 0 0 0 ?65 ?66]\n\n \n \n \n \n \n\n Eq. 2.12 \n\n \n\nWhen ? and ? are also principal material directions, or when the material is isotropic \n\n(i.e. uniform property in all orientations), are the terms ?14 = ?24 = ?34 = ?41 = ?42 =\n\n?43 = ?56 = ?65 = 0. For an orthotropic material with principal material directions \n\naligned with the principal element directions, the material stiffness matrix can be obtained \n\nfrom the compliance material matrix, ?: \n\n \n\n ? = ??1 Eq. 2.13 \n\n \n\n ? =\n\n[\n \n \n \n \n \n \n \n \n \n \n \n \n \n1\n\n??\n?\n???\n??\n\n?\n???\n??\n\n0 0 0\n\n?\n???\n??\n\n1\n\n??\n?\n???\n??\n\n0 0 0\n\n?\n???\n??\n\n?\n???\n??\n\n1\n\n??\n0 0 0\n\n0 0 0\n1\n\n2???\n0 0\n\n0 0 0 0\n1\n\n2???\n0\n\n0 0 0 0 0\n1\n\n2???]\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n Eq. 2.14 \n\n \n\n \n???\n??\n\n=\n???\n??\n  ;  \n\n???\n??\n\n=\n???\n??\n  ;  \n\n???\n??\n\n=\n???\n??\n\n Eq. 2.15 \n\n \n\nwhere: \n\n\u2022 ?? \u2013 is the Young modulus in the ? direction; \n\n\u2022 ??? \u2013 is the Poisson ration in the ?? plane; \n\n\u2022 ??? \u2013 is the shear modulus in the ?? plane. \n\n \n\nAs can be seen in Fig. 2.1, this element has four nodes, whose displacements are used \n\nto interpolate the displacements within this element: \n\n\n\n \n\n60 \n\n \n\n \n\n {\n?\n?\n?\n} = [?1 ?2 ?3 ?4] ? {?} Eq. 2.16 \n\n \n\nwith: \n\n \n\n ?? = [\n\n?? 0 0\n0 ?? 0\n0 0 ??\n\n]  ,   ? = 1,\u2026,4 Eq. 2.17 \n\n \n\n ? = \n\n{\n  \n \n\n  \n [\n\ncos?? 0 0\n0 sin?? 0\n0 0 cos??\n\n] ??? ??????-??????\n\n0 0\n\n[\nsin?? 0 0\n0 ?cos?? 0\n0 0 sin??\n\n] ??? ??????-??????\n\n Eq. 2.18 \n\n \n\n {?} = {???} + {???} Eq. 2.19 \n\n \n\n {???} = ? {????}\n\n????\n\n?=0\n\n Eq. 2.20 \n\n {???\n?} = {???1\n\n? ???1\n? ???1\n\n? ? ???4\n? ???4\n\n? ???4\n?}? Eq. 2.21 \n\n \n\n {???} = ? {????}\n\n????\n\n?=0\n\n Eq. 2.22 \n\n {????} = {???1\n? ???1\n\n? ???1\n? ? ???4\n\n? ???4\n? ???4\n\n?}? Eq. 2.23 \n\n \n\nwhere: \n\n\u2022 ? \u2013 refers to the nodal index, varying from 1 to 4; \n\n\u2022 ? \u2013 refers to the expansion order; \n\n\u2022 ???? \u2013 is the maximum adopted expansion order; \n\n\u2022 ?? \u2013 are the element shape functions; \n\n\u2022 ? \u2013 is the vector of nodal displacements; \n\n\u2022 ??? \u2013 is the vector of nodal single-barred displacement terms; \n\n\n\n \n\n61 \n\n \n\n\u2022 ??? \u2013 is the vector of nodal double-barred displacement terms; \n\n\u2022 ???? \u2013 is the vector of nodal single-barred displacement terms for the order ?; \n\n\u2022 ???? \u2013 is the vector of nodal double-barred displacement terms for the order n. \n\n \n\nThe shape functions ?? are given by: \n\n \n\n \n?1 =\n\n(\n?\n2\n? (? ? ??))(\n\n?\n2\n? ?)\n\n? ?\n \n\nEq. 2.24 \n\n \n\n \n?2 =\n\n(\n?\n2\n+ (? ? ??))(\n\n?\n2\n? ?)\n\n? ?\n \n\nEq. 2.25 \n\n \n\n \n?3 =\n\n(\n?\n2\n+ (? ? ??))(\n\n?\n2\n+ ?)\n\n? ?\n \n\nEq. 2.26 \n\n \n\n \n?4 =\n\n(\n?\n2\n? (? ? ??))(\n\n?\n2\n+ ?)\n\n? ?\n \n\nEq. 2.27 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the cylinder thickness (measured in radial direction); \n\n\u2022 ? \u2013 is the element length (measured in axial direction). \n\n\u2022 ?? \u2013 is the mean radius of the element; \n\n\u2022 ? \u2013 is the mean axial coordinate of the element. \n\n \n\nThe displacements can be broken into the sum of the single-barred and double-barred \n\nterms of the Fourier expansion series: \n\n \n\n {\n?\n?\n?\n} = ? {\n\n??\n\n??\n\n??\n}\n\n????\n\n?=0\n\n= ? {\n????\n\n????\n\n????\n}\n\n????\n\n?=0\n\n+ ? {\n????\n\n????\n\n????\n}\n\n????\n\n?=0\n\n Eq. 2.28 \n\n \n\n \n\n?? = ???? + ????\n\n?? = ???? + ????\n\n?? = ???? + ????\n Eq. 2.29 \n\n \n\n\n\n \n\n62 \n\n \n\nFor each expansion order ? (or harmonic number): \n\n \n\n {\n????\n\n????\n\n????\n} = [?1 ?2 ?3 ?4][\n\ncos?? 0 0\n0 sin?? 0\n0 0 cos??\n\n]{????} Eq. 2.30 \n\n \n\n {\n????\n\n????\n\n????\n} = [?1 ?2 ?3 ?4][\n\nsin?? 0 0\n0 ?cos?? 0\n0 0 sin??\n\n]{????} Eq. 2.31 \n\n \n\nFor ease in notation, the shape functions are combined with the harmonic matrix for \n\neach case: \n\n \n\n ???? = [\n\n?? cos?? 0 0\n0 ?? sin?? 0\n0 0 ?? cos??\n\n]  Eq. 2.32 \n\n \n\n ???? = [\n\n?? sin?? 0 0\n0 ? ?? cos?? 0\n0 0 ?? sin??\n\n]  Eq. 2.33 \n\n \n\nThen, \n\n \n\n {\n????\n\n????\n\n????\n} = [???1 ???2 ???3 ???4] {???\n\n?} Eq. 2.34 \n\n \n\n {\n????\n\n????\n\n????\n} = [???1 ???2 ???3 ???4]{???\n\n?} Eq. 2.35 \n\n \n\nApplying Eq. 2.34 and Eq. 2.35 into Eq. 2.8, the strain can be expressed in function \n\nof the nodal displacements: \n\n \n\n ? = ?[???1 ???2 ???3 ???4] {???} + ?[???1 ???2 ???3 ???4]{???} \nEq. 2.36 \n\n \n\nThe strain-displacement matrix can be defined as ?? =  ? ??. It will be shown the \n\ncalculations of the single-barred terms, but the procedure is analogous to the double-\n\n\n\n \n\n63 \n\n \n\nbarred terms. For the order ?, the strain-displacement matrix for the single-barred terms \n\nis given by: \n\n \n\n \n\n{\n  \n \n\n  \n \n\n?\n?\n\n?\n?\n\n?\n?\n\n???\n?\n\n???\n?\n\n???\n?\n}\n  \n \n\n  \n \n\n=\n\n[\n \n \n \n \n \n \n \n \n \n?1,? cos?? 0 0 \u2026\n\n?1\n?\ncos??\n\n??1\n?\ncos?? 0 \u2026\n\n0 0 ?1,? cos?? \u2026\n\n?\n??1\n?\nsin?? (?1,? ?\n\n?1\n?\n)sin?? 0 \u2026\n\n?1,? cos?? 0 ?1,? cos?? \u2026\n\n0 ?1,? sin?? ?\n??1\n?\nsin?? \u2026\n\n]\n \n \n \n \n \n \n \n \n \n\n \n\n{\n \n \n \n\n \n \n \n???1\n?\n\n???1\n?\n\n???1\n?\n\n?\n???4\n?\n\n???4\n?\n\n???4\n?}\n \n \n \n\n \n \n \n\n Eq. 2.37 \n\n \n\n [??] =\n\n[\n \n \n \n \n \n \n \n \n \n?1,? cos?? 0 0 \u2026\n\n?1\n?\ncos??\n\n??1\n?\ncos?? 0 \u2026\n\n0 0 ?1,? cos?? \u2026\n\n?\n??1\n?\nsin?? (?1,? ?\n\n?1\n?\n)sin?? 0 \u2026\n\n?1,? cos?? 0 ?1,? cos?? \u2026\n\n0 ?1,? sin?? ?\n??1\n?\nsin?? \u2026\n\n]\n \n \n \n \n \n \n \n \n \n\n  Eq. 2.38 \n\n \n\nConsidering all expansion orders, \n\n \n\n [?] = [?0 ?1 \u2026 ?????]  Eq. 2.39 \n\n \n\nFor the single-barred terms, the element stiffness matrix is given by: \n\n \n\n ? = ? ?\n???\n\n?\n\n ?? = ????? ????\n\n?\n\n??\n\n Eq. 2.40 \n\n \n\n ? = [\n\n?00 ?01 ? ?0?\n\n?10 ?11 ? ?1?\n\n? ? ? ?\n??0 ??1 ? ???\n\n] Eq. 2.41 \n\n \n\n\u201cLet there be ? nodes per element and ? harmonics included. Then the integrand \n\nmatrix ???? is full and of size 3?? by 3??. It is composed of an ? by ? array of 3? by \n\n3? submatrices. Off-diagonal submatrices contain (??????????) or (??????????) \n\n\n\n \n\n64 \n\n \n\nin every term, where ? and ? are different integers that represent different harmonics. \n\nWith limits -? to +?, integrals of these terms are zero. We are left with only ? submatrices \n\non the diagonal, which means that different Fourier harmonics are uncoupled. Each on-\n\ndiagonal submatrix is 3? by 3? and contains (???2 ??) or (???2 ??) in every term. With \n\nlimits -? to +?, (???2 ??) and (???2 ??) each integrate to ? (or to 2? for ???2 ?? when \n\n? = 0)\u201d (Cook et al., 2002). \n\n \n\n  [\n\n?0 0 0 0\n0 ?1 0 0\n0 0 ?2 0\n0 0 0 ?\n\n]\n\n{\n \n\n \n???0\n???1\n???2\n? }\n \n\n \n= {\n\n???0\n???1\n???2\n?\n\n} Eq. 2.42 \n\n \n\n\u201cIf the double-barred series is used rather than the single barred series, one finds \n\nthat ????? and ????? are interchanged in Eq. 2.32, Eq. 2.37 and Eq. 2.38. Also, \n\nalgebraic signs are reversed in the fourth and sixth rows of the matrix from Eq. 2.38. \n\nHowever, for ? > 0, submatrices [??] turn out to be the same as those produced by the \n\nsingle-barred series. This convenience is the motivation for the arbitrarily chosen \n\nnegative sign in Eq. 2.1\u201d (Cook et al., 2002). \n\n(PROVASI &amp; MARTINS, 2013-c) have further expanded Eq. 2.42 and obtained \n\nanalytical solutions for the stiffness matrix terms. These expressions are omitted here, but \n\ncan be found in the original work. \n\n \n\n2.2 Three-Dimensional Curved Helical Beam Element \n\n(PROVASI &amp; MARTINS, 2014) formulated a three-dimensional curved beam \n\nelement that considers the effects of curvature and tortuosity, making it ideal for modeling \n\ntensile armor tendons of a flexible pipe. \n\nThe displacements are described in a cylindrical coordinate system, making easier its \n\nintegration with other types of finite elements. The beam cross-section system is chosen \n\nto be coincident with the Fernet system, this requires a coordinate system rotation to the \n\ncylindrical one. The strain-displacement relations are given by: \n\n \n\n ? =\n??(?)\n\n??\n? ? ?(?) Eq. 2.43 \n\n \n\n\n\n \n\n65 \n\n \n\n ?? =\n???(?)\n\n??\n? ? ??(?) + ???(?) \n\nEq. 2.44 \n\n \n\n ?? =\n???(?)\n\n??\n+ ? ??(?) \n\nEq. 2.45 \n\n \n\n ?? =\n???(?)\n\n??\n? ???(?) \n\nEq. 2.46 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the curvilinear coordinate; \n\n\u2022 ? \u2013 is the axial strain or the strain in ? direction; \n\n\u2022 ??, ?? and ?? \u2013 are the angular strain around the ? (normal), ? (binormal) \n\nand ? (tangent) axis, respectively; \n\n\u2022 ??, ?? and ?? \u2013 are the angles around the ?, ? and ? axis, respectively; \n\n\u2022 ? \u2013 is the displacement in ? direction; \n\n\u2022 ? \u2013 is the initial tortuosity; \n\n\u2022 ? \u2013 is the initial curvature. \n\n \n\nDifferently from conventional curved beam elements, the curvature and tortuosity \n\nare not variables, but input parameters, which need to be calculated previously. Their final \n\nvalues are given by variation of angles, calculated from the nodal displacements. \n\nThe formulation of this element considers the following hypothesis:  \n\n\u2022 Small displacements and deformations; \n\n\u2022 No cross-section warp; \n\n\u2022 Linear elastic isotropic material. \n\n\u2022 Linear variation from the variables ? and ?? within the element, in order to \n\navoid the shear locking phenomenon. \n\n \n\nThe displacements for normal (?) and bi-normal (?) directions are given by fifth \n\norder polynomials: \n\n \n\n ?(?) = ?0 + ?1? + ?2?\n2 + ?3?\n\n3 + ?4?\n4 + ?5?\n\n5 Eq. 2.47 \n\n \n\n\n\n \n\n66 \n\n \n\n ?(?) = ?0 + ?1? + ?2?\n2 + ?3?\n\n3 + ?4?\n4 + ?5?\n\n5 Eq. 2.48 \n\n \n\nThe following expressions are also valid: \n\n \n\n ?? = ?\n??\n\n??\n? ? ? Eq. 2.49 \n\n \n\n ?? =\n??\n\n??\n? ? ? + ?? Eq. 2.50 \n\n \n\nEq. 2.43 can be manipulated to obtain the axial displacement, remembering that it \n\nwas assumed a linear behavior to ?: \n\n \n\n ?(?) = ?( ? + ??) ?? Eq. 2.51 \n\n \n\n \n\n?(?) = ?6 + (?7 + ??0)? + (\n?8\n2\n+ ?\n\n?1\n2\n)?2 + ?\n\n?2\n3\n?3\n\n+ ?\n?3\n4\n?4 + ?\n\n?4\n5\n?5 + ?\n\n?5\n6\n?6 \n\nEq. 2.52 \n\n \n\nFor being a locking-free element, the displacement interpolation functions must \n\nrecover the inextensible bending of the curved beam in Eq. 2.43: \n\n \n\n ? =\n??(?)\n\n??\n? ? ?(?) Eq. 2.53 \n\n \n\n \n? = (?7 + ??0) +  2(\n\n?8\n2\n+ ?\n\n?1\n2\n)? + ??2?\n\n2 + ??3?\n3\n\n+ ??4?\n4 + ??5?\n\n5 \n\nEq. 2.54 \n\n \n\n?? can be calculated from Eq. 2.44: \n\n \n\n ?? = ?(?? ? ?\n??\n\n??\n? ???) ?? Eq. 2.55 \n\n \n\n\n\n \n\n67 \n\n \n\n \n\n??(?) = ?6 + (?7 ? ? ?1 ? ???0)? + (\n?8\n2\n? ??2 ?\n\n??\n\n2\n?1)?\n\n2\n\n? ?(?3 +\n?\n\n3\n?2)?\n\n3 ? ?(?4 +\n?\n\n4\n?3)?\n\n4\n\n? ?(?5 +\n?\n\n5\n?4)?\n\n5 ?\n??\n\n6\n?5?\n\n6 \n\nEq. 2.56 \n\n \n\n?? and ?? are calculated by: \n\n \n\n ?? = ?\n??\n\n??\n? ?? Eq. 2.57 \n\n \n\n \n??(?) = ?(??0 + ?1) ? (??1 + 2?2)? ? (??2 + 3?3)?\n\n2\n\n? (??3 + 4?4)?\n3 ? (??4 + 5?5)?\n\n4 ? ??5?\n5 \n\nEq. 2.58 \n\n \n\n ?? = \n??\n\n??\n? ?? + ?? Eq. 2.59 \n\n \n\n \n\n??(?) = (?1 ? ??0 + ??6) + (2?2 ? ??1 + ?(?7 + ??0))?\n\n+ (3?3 ? ??2 + ?(?8 + ?\n?1\n2\n))?2\n\n+ (4?4 ? ??3 + ?\n2\n?2\n3\n)?3 + (5?5 ? ??4?\n\n2\n?3\n4\n)?4\n\n+ (???5 + ?\n2\n?4\n5\n)?5 + ?2\n\n?5\n6\n?6 \n\nEq. 2.60 \n\n \n\nThree nodes, each one with 6 degrees-of-freedom, are enough to obtain all constants \n\n(?? = [?0 ? ?8 ?0 ? ?8]). The vector of nodal displacements is written by: \n\n \n\n ??????\n? = [?1\n\n? ?2\n? ?2\n\n?] Eq. 2.61 \n\n \n\n ??\n? = [?\n\n? ?? ?? ?\n?\n? ?\n\n?\n? ?\n\n?\n?\n]     for  ? = 1,\u2026,3 Eq. 2.62 \n\n \n\nA relation between the nodal displacements and the constants ? can be written as: \n\n \n\n ?????? = ?? Eq. 2.63 \n\n \n\n\n\n \n\n68 \n\n \n\n ? = [\n\n?1 ?2 ?3\n?4 ?5 ?6\n?7 ?8 ?9\n\n] Eq. 2.64 \n\n \n\nEach of the terms of ? (?1,\u2026, ?9) is a 6 by 6 matrix: \n\n \n\n \n\n \n\nEq. 2.65 \n\n \n\n \n\n \n\nEq. 2.66 \n\n \n\n \n\n \n\nEq. 2.67 \n\n \n\n\n\n \n\n69 \n\n \n\n \n\n \n\nEq. 2.68 \n\n \n\n \n\n \n\nEq. 2.69 \n\n \n\n \n\n \n\nEq. 2.70 \n\n \n\n \n\n \n\nEq. 2.71 \n\n \n\n\n\n \n\n70 \n\n \n\n \n\n \n\nEq. 2.72 \n\n \n\n \n\n \n\nEq. 2.73 \n\n \n\nThe displacements of the element can be defined through the interpolation of the \n\nnodal ones: \n\n \n\n ? = ?? = ???????? Eq. 2.74 \n\n \n\nwhere: \n\n\u2022 ?? = [? ? ? ?? ?? ??]; \n\n\u2022 ? = [?1 ?2 ?3]. \n\n \n\n\n\n \n\n71 \n\n \n\n \n\n \n\nEq. 2.75 \n\n \n\n \n\n \n\nEq. 2.76 \n\n \n\n \n\n \n\nEq. 2.77 \n\n \n\nThe strain-displacement relations are given in the matrix form as: \n\n \n\n ?? = [ ? ?? ?? ??] Eq. 2.78 \n\n \n\n ? = ?? = ??? = ????????? = ???????? Eq. 2.79 \n\n \n\nThe strain-displacement matrix is given by: \n\n \n\n ? = [?1 ?2 ?3 ?4 ?5] Eq. 2.80 \n\n \n\n\n\n \n\n72 \n\n \n\n \n\n \n\nEq. 2.81 \n\n \n\n \n\n \n\nEq. 2.82 \n\n \n\n \n\n \n\nEq. 2.83 \n\n \n\n \n\n \n\n \n\nEq. \n\n2.84 \n\n \n\n \n\n \n\nEq. 2.85 \n\n \n\nThe element stiffness matrix is then calculated by: \n\n \n\n ??? = ?\n?????? Eq. 2.86 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the material elasticity matrix. \n\n \n\n\n\n \n\n73 \n\n \n\nAfter defining the stiffness matrix on the local cross-section coordinate system \n\n(which is aligned with the Fr\u00e9net triad), it must be rotated to the cylindrical coordinate \n\nsystem: \n\n  \n\n ? = ?\n??? Eq. 2.87 \n\n \n\nwith: \n\n \n\n ? =\n\n[\n \n \n \n \n \n? ? ? ? ? ?\n? ? ? ? ? ?\n? ? ? ? ? ?\n? ? ? ? ? ?\n? ? ? ? ? ?\n? ? ? ? ? ?]\n\n \n \n \n \n \n\n Eq. 2.88 \n\n \n\nwhere: \n\n \n\n ? = [\n?1 0 0\n0 ?cos? sin?\n0 sin? cos?\n\n] Eq. 2.89 \n\n \n\n2.3 Bridge Finite Macroelement for Contact of Nodes \nwith Different Displacement Descriptions \n\nThe nodes of the orthotropic cylinder element (2.1) and the helical beam element \n\n(2.2) have different displacement descriptions: in the first case, each node has 3 degrees \n\nof freedom (??,??,??) expanded in Fourier series, dependent on an expansion order \n\nparameter; while in the second case the nodes are conventional, with 6 degrees of freedom \n\n(??,??,??,????,????,????). Thus, in order to simulate a rigid connection between \n\nthese two elements, which could occur when modeling the interaction between a \n\npolymeric sheath and a tensile armor, for instance, (PROVASI &amp; MARTINS, 2013-a) \n\nhad to formulate a rigid-connection finite macroelement for nodes with different natures. \n\nAs shown in Fig. 2.2, this is a node-to-node contact element, wherein each node is \n\ndescribed in its correspondent nature. \n\n \n\n\n\n \n\n74 \n\n \n\n \n\nFig. 2.2 \u2013 Bridge contact macroelement with different nodes displacements natures. Source: (PROVASI \n\n&amp; MARTINS, 2013-a). \n\n \n\nThis element is ruled by the condition: \n\n \n\n ?2 ? ?1 = ? = {\n??\n??\n??\n} Eq. 2.90 \n\n \n\n ?2 ? ?1?  = ? = {\n??\n0\n??\n} Eq. 2.91 \n\n \n\nwhere: \n\n\u2022 ?? \u2013 is the variation in radial direction; \n\n\u2022 ?? \u2013 is the variation in circumferential direction; \n\n\u2022 ?? \u2013 is the variation in axial direction; \n\n\u2022 ?1 \u2013 denotes the coordinates of node ? (Fourier); \n\n\u2022 ?1? \u2013 denotes the coordinates of point ?\u2019, which is equal to the position of \n\nnode ? updated by the circumferential variation; \n\n\u2022 ?2 \u2013 denotes the coordinates of node ? (conventional). \n\n \n\nIn the deformed configuration, \n\n \n\n ?2\n? ? ?\n\n1?\n?\n? ? = ? Eq. 2.92 \n\n \n\n\n\n \n\n75 \n\n \n\nThe main condition governing this element is the inexistence of relative displacement \n\nbetween the nodes, given by: \n\n \n\n ?2 ? ?1\n? = 0 Eq. 2.93 \n\n \n\n \n\n?1\n? = [???\n\n1?\n0\n\n????\n1?\n0\n\n???\n1?\n0\n]\n?\n?0 + ?[???1?\n\n?\n???\n1?\n?\n\n???\n1?\n? ]\n?\n\n?\n\n?=1\n\n??\n\n+ ?[???\n1?\n?\n\n???\n1?\n?\n\n???\n1?\n? ]\n?\n\n?\n\n?=1\n\n?? \n\nEq. 2.94 \n\n \n\n ?2 = [?? ?? ?? ?? ?? ??]\n? Eq. 2.95 \n\n \n\nwhere: \n\n\u2022 ??, ?? and ?? \u2013 are the displacements for node 2 in radial, circumferential \n\nand axial direction, respectively; \n\n\u2022 ??, ?? and ?? \u2013 are the rotations for node 2 around radial, circumferential \n\nand axial axis, respectively; \n\n\u2022 ???\n1?\n0\n\n , ????\n1?\n0\n\n and ???\n1?\n0\n\n are the order ? displacements of point ?\u2019; \n\n\u2022 [???\n1?\n? ???\n\n1?\n? ???\n\n1?\n? ] and [???\n\n1?\n? ???\n\n1?\n? ???\n\n1?\n? ] \u2013 are the higher order single-barred and \n\ndouble-barred displacements in radial, circumferential and axial directions, \n\nrespectively. \n\n \n\n ?? = [\ncos??? 0 0\n0 sin??? 0\n0 0 cos???\n\n] Eq. 2.96 \n\n \n\n ?? = [\nsin??? 0 0\n0 ?cos??? 0\n0 0 sin???\n\n] Eq. 2.97 \n\n \n\n ?0 = ?0 + ?0 = [\n1 0 0\n0 ?1 0\n0 0 1\n\n] Eq. 2.98 \n\n \n\n\n\n \n\n76 \n\n \n\nDuring the review of this paper, it was noted two signs typos in the original \n\nformulation. The first is at the order 0 circumferential displacement, ????\n1?\n0\n\n, which must be \n\nnegative. The second one lies in Eq. 2.97, since the term ??(2,2) = ?cos??? was positive \n\nin the original formulation, but it also needs to be negative. \n\nThe condition in Eq. 2.93 is then expressed as a constraint: \n\n \n\n ??????????? = [??0 ??1 ??1 ? ??? ??? ?]\n\n{\n \n \n \n\n \n \n \n???\n1?\n0\n\n???\n1?\n1\n\n???\n1?\n1\n\n?\n???\n1?\n?\n\n???\n1?\n?\n\n?2}\n \n \n \n\n \n \n \n\n Eq. 2.99 \n\n \n\n ??????????? = ?? Eq. 2.100 \n\n \n\nIn (PROVASI &amp; MARTINS, 2013-a), Eq. 2.99 has also some sign typos, but here it \n\nis presented the corrected version. Applying a penalty methodology, the stiffness matrix \n\nis given by: \n\n \n\n ? = ?\n??  Eq. 2.101 \n\n \n\n ? =\n\n[\n \n \n \n \n \n \n?0?0 ?0?1 ?0?1 ? ?0?? ?0?? ??0\n?1?0 ?1?1 ?1?1 ? ?1?? ?1?? ??1\n?1?0 ?1?1 ?1?1 ? ?1?? ?1?? ??1\n? ? ? ? ? ? ?\n\n???0 ???1 ???1 ? ???? ???? ???\n???0 ???1 ???1 ? ???? ???? ???\n??0 ??1 ??1 ? ??? ??? ? ]\n\n \n \n \n \n \n \n\n Eq. 2.102 \n\n \n\nwhere: \n\n\u2022  \u2013 is the penalty coefficient, which has to be large for obtaining an accurate \n\nresult, but not large enough to make the stiffness matrix ill-conditioned. \n\n \n\n\n\n \n\n77 \n\n \n\n2.4 Standard Finite Macroelement for Contact of Nodes \nwith Different Displacement Descriptions \n\n(PROVASI &amp; MARTINS, 2013-b) also proposed a contact finite macroelement for \n\nnodes with different displacement natures that considers normal and tangential \n\ndisplacements, as well as frictional effects. (TONI, F.G., 2014) noticed some signal typos \n\nin the original formulation and proposed a revised formulation to this element stiffness \n\nmatrix. \n\nThis element considers the following modes concerning friction, which are also \n\nillustrated on Fig. 2.3, : \n\n\u2022 Sticking \u2013 with no relative movement between nodes; \n\n\u2022 Sliding \u2013 with relative movement between nodes. \n\n \n\n \n\n \n\nFig. 2.3 \u2013 First case: block in initial condition; Second: sticking condition; Third: sliding condition. \n\nSource: (PROVASI, 2013). \n\n \n\nIt is important to note that this element applies only to small displacements due its \n\nnode-to-node characteristic. For large displacements and deformations, a node-to-surface \n\nand beam-to-surface approaches are more suitable, but these elements have not yet been \n\nformulated to the present date. However, when the use limitations are not violated, this \n\nfinite macroelement permits the simulation of more realistic flexible pipe behaviors, that \n\ninclude friction effects and nodal relative displacements. \n\nAs illustrated in Fig. 2.4, this contact element possesses two nodes: the first one is of \n\nthe Fourier type, with displacements expanded in Fourier series; the second one is a \n\nconventional node, with six degrees-of-freedom. \n\n \n\n\n\n \n\n78 \n\n \n\n \n\nFig. 2.4 \u2013 Node-to-node contact: node 1 (Fourier) and node 2 (conventional). Source: (TONI, F.G., 2014). \n\n \n\nThe following parameters are known in advance: \n\n\u2022 ?0 \u2013 the angle difference between both nodes, measured in a cylindrical \n\ncoordinate system; \n\n\u2022 ?1 and ?2 \u2013 are the nodal coordinates; \n\n\u2022 ???? 1 \u2013 is the surface normal at node 1; \n\n\u2022 ???? 1 and ???? 2 \u2013 are the directions tangential to the surface at node 1. \n\nThe following vectors are defined: \n\n \n\n ??????1 = ?1\n?    and     ??????1\n\n? = ?1 Eq. 2.103 \n \n\n \n?????? 2 = ?2\n\n?    and    ?????? 2\n? = ?2 \n\n \nEq. 2.104 \n\n \n\nwhere: \n\n\u2022 ?1\n? \u2013 is the coordinate of node 1 in the reference configuration; \n\n\u2022 ?2\n? \u2013 is the coordinate of node 2 in the reference configuration; \n\n\u2022 ?1 \u2013 is the coordinate of node 1 in the deformed configuration; \n\n\u2022 ?2 \u2013 is the coordinate of node 2 in the deformed configuration. \n\n \n\nThe displacements are defined by: \n\n \n\n\n\n \n\n79 \n\n \n\n ?? = ?1 ? ?1 = {\n\n?1\n?1\n?1\n} = \n\n{\n \n \n \n \n\n \n \n \n ????1\n\n?\n\n?\n\n?=0\n\ncos??0 + ????1\n?  sin ??0\n\n?\n\n?=0\n\n????1\n?\n\n?\n\n?=0\n\nsin ??0 ? ????1\n?\n\n?\n\n?=0\n\ncos??0\n\n????1\n?\n\n?\n\n?=0\n\ncos??0 + ????1\n? sin ??0\n\n?\n\n?=0 }\n \n \n \n \n\n \n \n \n \n\n Eq. 2.105 \n\n \n\n ?? = ?2 ? ?2 = {\n\n?2\n?2\n?2\n} Eq. 2.106 \n\n \n\n ?? = \n\n{\n \n \n \n \n\n \n \n \n ???1\n\n0 + ????1\n?\n\n?\n\n?=1\n\ncos??0 + ????1\n?  sin ??0\n\n?\n\n?=1\n\n????1\n0 + ????1\n\n?\n\n?\n\n?=1\n\nsin ??0 ? ????1\n?\n\n?\n\n?=1\n\ncos??0\n\n???1\n0 + ????1\n\n?\n\n?\n\n?=1\n\ncos??0 + ????1\n? sin ??0\n\n?\n\n?=1 }\n \n \n \n \n\n \n \n \n \n\n Eq. 2.107 \n\n \n\n \n\n ?1 = ?1\n0 + ?[?????1\n\n? + ?????1\n? ]\n\n?\n\n?=1\n\n Eq. 2.108 \n\n \n\nwith: \n\n \n\n ?1 = {\n\n?1\n?1\n?1\n} Eq. 2.109 \n\n \n\n ?1\n0 = {\n\n???1\n0\n\n????1\n0\n\n???1\n0\n\n}   ,  ???1\n? = {\n\n???1\n?\n\n???1\n?\n\n???1\n?\n\n}   and   ???1\n? = {\n\n???1\n?\n\n???1\n?\n\n???1\n?\n\n} Eq. 2.110 \n\n \n\n ?? = [\n\ncos??0 0 0\n0 sin ??0 0\n0 0 cos??0\n\n] Eq. 2.111 \n\n \n\n\n\n \n\n80 \n\n \n\n ?? = [\n\nsin ??0 0 0\n0 ?cos??0 0\n0 0 sin ??0\n\n] Eq. 2.112 \n\n \n\nA normal gap function is then defined: \n\n \n\n ?? = (?2 ? ?1) . ???? ? Eq. 2.113 \n\n \n\nAnd also a tangential gap function: \n\n \n\n ?? = ??1 ???? ? + ??2 ???? ? Eq. 2.114 \n\n \n\nwith: \n\n ??? = (?2 ? ?1). ???? ?    for ? = 1,2 Eq. 2.115 \n\n \n\nFrom the Principle of Virtual Work, the virtual work is given by: \n\n \n\n ????????? = ??? .??? + ??? .???  Eq. 2.116 \n\n \n\nDeriving Eq. 2.116, \n\n \n\n ?(?????????) = ???? .??? + ???? .???  Eq. 2.117 \n\n \n\nRewriting it in matrix form: \n\n \n\n ?(?????????) = ??????? + ????\n?\n???  Eq. 2.118 \n\n \n\nwith: \n\n \n\n ??? =  ???1 ?? + ???2 ?? Eq. 2.119 \n\n \n\n ? = {\n1\n0\n0\n}    ,    ?? = {\n\n0\n1\n0\n}   and   ?? = {\n\n0\n0\n1\n}  Eq. 2.120 \n\n \n\n\n\n \n\n81 \n\n \n\n \n\n???? = ?\n???? ? ?\n\n???? \n\n???1 = ??\n???? ? ??\n\n???? \n\n???2 = ??\n???? ? ?2\n\n????  \n\nEq. 2.121 \n\n \n\nThe following relations are valid: \n\n \n\n ??? = ???  ,   ?????\n? = ?????\n\n?     ,    ?????\n? = ?????\n\n?  Eq. 2.122 \n\n \n\nHowever, the derivatives for the order 0 displacements of node 1 are not trivial: \n\n \n\n ???\n?  ? ???\n\n? Eq. 2.123 \n\n \n\nRemembering that ??\n? = [???1\n\n0 ????1\n0 ???1\n\n0]?, where ????1\n0 is the first term of sum \n\n?? ???1\n??\n\n?=0 cos??0 for when ? = 0, the following transformation is required: \n\n \n\n ??\n? = [\n\n1 0 0\n0 ?1 0\n0 0 1\n\n]{\n\n???1\n0\n\n???1\n0\n\n???1\n0\n\n} =  ? {\n\n???1\n0\n\n???1\n0\n\n???1\n0\n\n} Eq. 2.124 \n\n \n\nThen, \n\n \n\n ? ???\n? = ???\n\n?  Eq. 2.125 \n\n \n\n \n\n? = [\n1 0 0\n0 ?1 0\n0 0 1\n\n] \n\n( ? = ??    e     ??? = ?  ) \n\nEq. 2.126 \n\n \n\nThen expressions in Eq. 2.121 are then calculated by: \n\n \n\n ??? = ?\n???? ?  ?\n\n?????\n? ? ?[ ?????????\n\n? + ?????????\n? ]\n\n?\n\n?=1\n\n Eq. 2.127 \n\n\n\n \n\n82 \n\n \n\n???1 = ??\n???? ?  ??\n\n?????\n? ? ?[ ??\n\n????????\n? + ??\n\n????????\n? ]\n\n?\n\n?=1\n\n \n\n??2 = ??\n???? ?  ??\n\n?????\n? ? ?[ ??\n\n????????\n? + ??\n\n????????\n? ]\n\n?\n\n?=1\n\n \n\n \n\nThe stiffness matrix for the sticking case are given by: \n\n \n\n ????????? = ??? + ???1 + ???2  Eq. 2.128 \n\n \n\nWith: \n\n \n\n ?? =\n\n[\n \n \n \n \n \n \n \n??? ?????1 ???\n\n??1 \u2026 ???\n??? ???\n\n??? ????\n?\n\n??1??\n? ?1??\n\n??1 ?1??\n??1 \u2026 ?1??\n\n??? ?1??\n??? ??1??\n\n?\n\n??1??\n? ?1??\n\n??1 ?1??\n??1 \u2026 ?1??\n\n??? ?1??\n??? ??1??\n\n?\n\n? ? ? ? ? ? ?\n?????\n\n? ????\n??1 ????\n\n??1 \u2026 ????\n??? ????\n\n??? ?????\n?\n\n?????\n? ????\n\n??1 ????\n??1 \u2026 ????\n\n??? ????\n??? ?????\n\n?\n\n????? ?????1 ???\n??1 \u2026 ???\n\n??? ???\n??? ??\n\n? ]\n \n \n \n \n \n \n \n\n  Eq. 2.129 \n\n \n\n \n\n??1\n\n=\n\n[\n \n \n \n \n \n \n \n????\n\n? ?????\n??1 ?????\n\n??1 \u2026 ?????\n??? ?????\n\n??? ??????\n?\n\n??1????\n? ?1????\n\n??1 ?1????\n??1 \u2026 ?1????\n\n??? ?1????\n??? ??1????\n\n?\n\n??1????\n? ?1????\n\n??1 ?1????\n??1 \u2026 ?1????\n\n??? ?1????\n??? ??1????\n\n?\n\n? ? ? ? ? ? ?\n???????\n\n? ??????\n??1 ??????\n\n??1 \u2026 ??????\n??? ??????\n\n??? ???????\n?\n\n???????\n? ??????\n\n??1 ??????\n??1 \u2026 ??????\n\n??? ??????\n??? ???????\n\n?\n\n??????\n? ?????\n\n??1 ?????\n??1 \u2026 ?????\n\n??? ?????\n??? ????\n\n? ]\n \n \n \n \n \n \n \n\n  \nEq. 2.130 \n\n \n\n \n\n??2\n\n=\n\n[\n \n \n \n \n \n \n \n????\n\n? ?????\n??1 ?????\n\n??1 \u2026 ?????\n??? ?????\n\n??? ??????\n?\n\n??1????\n? ?1????\n\n??1 ?1????\n??1 \u2026 ?1????\n\n??? ?1????\n??? ??1????\n\n?\n\n??1????\n? ?1????\n\n??1 ?1????\n??1 \u2026 ?1????\n\n??? ?1????\n??? ??1????\n\n?\n\n? ? ? ? ? ? ?\n???????\n\n? ??????\n??1 ??????\n\n??1 \u2026 ??????\n??? ??????\n\n??? ???????\n?\n\n???????\n? ??????\n\n??1 ??????\n??1 \u2026 ??????\n\n??? ??????\n??? ???????\n\n?\n\n??????\n? ?????\n\n??1 ?????\n??1 \u2026 ?????\n\n??? ?????\n??? ????\n\n? ]\n \n \n \n \n \n \n \n\n  \nEq. 2.131 \n\n \n\nThe stiffness matrices for the sliding condition were omitted here, but can be found \n\nin (PROVASI &amp; MARTINS, 2013-b). \n\n\n\n \n\n83 \n\n \n\n Element-by-Element Method \n\nThis chapter consists of a review on the application of the element-by-element \n\nmethod (EBE) to the conventional finite element method. When developing a program \n\nfor large-scale model, it is important to use proper algorithms and data structures due to \n\nlimitations of computational resources. The EBE method fits in this context, since it is \n\ncharacterized by the global stiffness matrix elimination, so that most calculations are \n\nperformed in an element basis using a proper indexing system which relates the local \n\ndegrees-of-freedom of the elements with the global ones. Thus, the storage cost increases \n\nlinearly with model size in the EBE method, being, therefore, an efficient alternative to \n\nthe conventional sparse formulation. \n\nFurthermore, the main advantage of the EBE formulation regards on the scalability \n\nand ease of parallelization of the numerical solution. When compared to the sparse \n\nformulation, the EBE requires a larger number of operations to execute the same \n\nalgorithm. However, this is rapidly compensated by techniques of parallel programming \n\nand element based domain decompositions, taking advantage from clusters and modern \n\nprocessors with several processing cores. \n\nThe EBE allows a fully customized solution for the elements described in Chapter 2, \n\naiming high computational performance. The ease of adding new types of elements also \n\nmust be highlighted in the EBE method, providing the necessary flexibility for future \n\nworks. As the calculations are carried out in a local basis, it is necessary to implement \n\nonly a matrix-vector multiplication and a scattering method between the local and global \n\ndegrees-of-freedom for this element. \n\nOther advantages of the EBE methods are: optimized cache usage by the allocation \n\nand management of blocks of similar elements; simpler algorithm implementation; \n\ndomain subdivision procedure of reduced complexity in comparison to the sparse \n\nformulation. \n\nAccording to (WINGET &amp; HUGHES, 1985), there are three main ingredients in an \n\nEBE iterative linear equation solution algorithm: \n\n1) An iterative driver algorithm; \n\n2) A matrix which approximates the global implicit matrix and is amenable to EBE \n\napproximation; \n\n\n\n \n\n84 \n\n \n\n3) The EBE approximation scheme itself. \n\n \n\nRegarding the first ingredient, the vast majority of the EBE implementations utilizes \n\niterative methods for solving linear systems of equations. These iterative algorithms are \n\nadapted versions of the conventional ones, such as the preconditioned conjugate gradient \n\nmethod, and will be presented in section 3.1. The choice of iterative methods is justified \n\nby the fact that they are easier to be implemented and require matrix-vector \n\nmultiplications, which can trivially be done in the local basis. There are some reasons for \n\nnot using direct methods for solving linear system with the EBE method. First, because \n\nthey change the sparsity pattern of the global matrix, what can significantly increase the \n\nnumber of nonzero entries. If not properly implemented, direct methods could \u2018explode\u2019 \n\nmemory consumption. Second, the pivoting process, common in direct methods, would \n\ncreate many crossed numerical terms between elements, so that the indexing would be \n\nextremely complex, becoming almost inevitably a standard sparse method, losing all the \n\nadvantages of the EBE method. \n\nFor finite element structural problems, the matrix from the second ingredient is the \n\nglobal stiffness matrix. In the EBE method, an approximation of the global stiffness \n\nmatrix is computed and used as preconditioner of the iterative methods aforementioned. \n\nThe quality of this approximation has direct influence on the convergence rate of the \n\niterative algorithm. Several approximation techniques were developed for the EBE \n\nmethod and they will be presented and discussed in section 3.2. \n\n \n\n3.1 Iterative Algorithms for Linear System Solution \n\nIterative methods for solving linear system of equations are a very extensive research \n\nfield, with many published books about this subject. Therefore, this section presents only \n\nthe most common iterative methods which are used in conjunction with the element-by-\n\nelement method. This section is subdivided into the sections 3.1.1 and 3.1.2 that refer to \n\nmethods for symmetric linear systems. \n\n \n\n\n\n \n\n85 \n\n \n\n3.1.1 Preconditioned Conjugate Gradient Method (PCG) \n\nThe preconditioned conjugate gradient method is by far the most widely used \n\niterative method for solving symmetric linear system of equations, due its simplicity and \n\nefficiency. Its standard version is shown in Table 3.1.  \n\n \n\nTable 3.1 \u2013 Standard version of the Preconditioned Conjugate Gradient Method (PCG). \n\nLinear System:     ? ? = ? \n\n1.  ?? = ? ? ? ?? \n\n2. ?0 = ?\n???? \n\n3. ?? = ?? \n\n4. for ? = ?,?,?,\u2026 \n\n5.  ?? =\n??\n???\n\n??\n? ? ??\n\n \n\n6.  ??+? = ?? + ?? ?? \n\n7.  ??+? = ?? ? ?? ? ?? \n\n8.  if ???+?? ? ????????? \n\n9.   Solution converged! \n\n10.  end if \n\n11.  ?? = ?\n????+? \n\n12.  ?? =\n??+?\n? ??+?\n\n??\n? ??\n\n \n\n13.  ??+? = ??+? + ?? ?? \n\n14. end for \n\ndd \n\nSource: (SAAD, 2003). \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the iteration count; \n\n\u2022 ? \u2013 is the global stiffness matrix; \n\n\u2022 ? \u2013 is the linear residue; \n\n\u2022 ?? \u2013 is the initial guess or a prediction; \n\n\u2022 ? \u2013 is the trial displacement vector; \n\n\u2022 ? \u2013 is the preconditioning matrix; \n\n\n\n \n\n86 \n\n \n\n\u2022 ? \u2013 denotes the step direction; \n\n\u2022 ? \u2013 is the step length; \n\n\u2022 ? \u2013 defines the correction factor. \n\n \n\nUsually, the initial guess, ?0, is a null vector, simplifying the initial residual \n\nexpression to ?? = ?. The preconditioning matrix, ?, is a matrix designed to improve \n\nthe rate of convergence of the method, being, therefore, very important for its efficiency, \n\nespecially for ill-conditioned linear systems. \n\nAs the global stiffness matrix, ?, is not assembled in the EBE method, the matrix-\n\nvector product ? ??, necessary for the computations of ?? and ??+?, is not a trivial \n\noperation. Thus, the EBE method requires an adapted version of the PCG method. \n\nThe following works have employed the PCG algorithm on the development of the \n\nEBE method: (WINGET &amp; HUGHES, 1985), (CAREY &amp; JIANG, 1986), (HUGHES &amp; \n\nFERENCZ, 1987), (LEVIT, 1987), (KING &amp; SONNAD, 1987), (HUGHES &amp; \n\nFERENCZ, 1988), (ADELI &amp; KUMAR, 1995), (GULLERUD &amp; DODDS JR, 2001), \n\n(THIAGARAJAN &amp; ARAVAMUTHAN, 2002), (LIU, ZHOU, &amp; YANG, 2007), \n\n(MART\u00cdNEZ-FRUTOS &amp; HERRERO-P\u00c9REZ, 2015) and (MART\u00cdNEZ-FRUTOS, \n\nMART\u00cdNEZ-CASTEJ\u00d3N, &amp; HERRERO-P\u00c9REZ, 2015). \n\nDespite the differences on notations, these works share the same concept, i.e., the \n\nglobal matrix is defined as a sum of a series of element matrices and the matrix-vector \n\nmultiplication can be performed as follows: \n\n \n\n ? = ???\n\n???\n\n?=1\n\n \nEq. 3.1 \n\n \n\n ? = ? ?? = (??\n?\n\n???\n\n?=1\n\n)?? = ??\n???\n\n?\n\n???\n\n?=1\n\n Eq. 3.2 \n\n \n\n ?? = ????\n? Eq. 3.3 \n\n \n\n ? = ???\n\n???\n\n?=1\n\n \nEq. 3.4 \n\n \n\n\n\n \n\n87 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the element counter; \n\n\u2022 ??? \u2013 refers to the total number of elements; \n\n\u2022 ?? \u2013 is the stiffness matrix of element ?; \n\n\u2022 ?? \u2013 is the local product ????\n? for the element ?; \n\n\u2022 ? \u2013 is the global product of ? ??. \n\n \n\n?? is the ??? element contribution to ?. Globalized element matrices ?? are used in \n\norder to simplify the notation, but in practice, only local element matrices ?? and their \n\ncorresponding indexing arrays are stored. \n\nWhen performed in a parallel way, this operation is not trivial. Gathering the ??\n? \n\nvalues and the local matrix-vector products ????\n? are independent operations and easily \n\nparallelizable. However, as the elements share nodes and degrees-of-freedom, the \n\nspreading operation from Eq. 3.4 represents a bottleneck to the EBE method and requires \n\nsyncronization, once the terms of ? are accessed and updated several times during the \n\ncomplete operation. As this syncronization is highly dependent on the hardware \n\narchitecture and on the programming techniques, it will be presented and discussed in \n\ngreater detail in the section 3.3. \n\n \n\n3.1.2 Lanczos Biorthogonalization (Lanczos) \n\nThe Lanczos biorthogonalization method is an alternative to the PCG. Its standard \n\nversion is shown in Table 3.2. \n\n \n\n\n\n \n\n88 \n\n \n\nTable 3.2 \u2013 The Lanczos biorthogonalization procedure (SAAD, 2003). \n\n1. Choose two vectors ?? and ?? such that ??.?? = ? \n2. Set ?? = ?? = ? and ?? = ?? = ? \n\n3. For j=1, 2, \u2026, m \n\n4.     ?? = ??? .?? \n\n5.     ????+? = ??? ? ???? ? ?????? \n\n6.     ????+? = ?\n??? ? ???? ? ?????? \n\n7.     ??+? = (????+? . ????+?)\n?/?\n\n . If ??+? = ? Stop \n\n8.     ??+? = (????+? . ????+? )/??+? \n\n9.     ??+? = ????+?/??+? \n\n10.     ??+? = ????+?/??+? \n\n11. Endfor \n\n \n\n(COUTINHO, ALVES, LANDAU, LIMA, &amp; EBECKEN, 1987) applied the EBE \n\nprocedure and developed an EBE version of the symmetric diagonal preconditioned \n\nLanczos method. This algorithm was applied in large-scale offshore engineering \n\nstructural problems which can be ill-conditioned in some cases. The authors of the \n\naforementined work concluded that the EBE Lanczos achieved, without loss of accuracy, \n\na better computer perfomance than the EBE Conjugate Gradient for the noticeably ill-\n\nconditioned analysed problems.  \n\n(NOUR-OMID, PARLETT, &amp; RAEFSKY, 1987) compared the EBE preconditioned \n\nversions of Lanczos against the CG algorithms. They tested both algorithms for fluid and \n\nstructural ill-conditioned problems. The Lanczos versions showed a better convergence \n\nrate, requiring, in some cases, a significantly smaller number of iterations. However, as \n\nthe simulation times were not provided, the efficiency comparison becomes \n\ncompromised, since the PCG iterations are faster. \n\n(COUTINHO, ALVES, LANDAU, EBECKEN, &amp; TROINA, 1991) implemented \n\nand compared the EBE versions of the Preconditioned Lanczos and PCG algorithms, and \n\nconcluded that although both algorithms are theoretically related, they present important \n\nimplementational differences. Lanczos based procedures require a lot of I/O operations \n\nto save and restore the Lanczos vectors. The operations are of course non-vectorizable \n\nand the correspondent overhead makes Lanczos algorithms slower than their conjugate \n\ngradient counterparts. \n\n\n\n \n\n89 \n\n \n\nTherefore, it can be concluded that the Lanczos biorthogonalization is an important \n\nalternative to be considered for ill-conditioned problems. However, as only linear finite \n\nelements and material models will be used (which have been already extensively tested \n\nin MacroFEM), ill-conditioning and slow convergence rate problems are not expected. \n\nThus, EBE-PCG is the most logical alternative for a first implementation, due to its \n\nsimpler implementation, slightly lower memory requirements and high efficiency for \n\nwell-conditioned problems. \n\n \n\n3.2 EBE Preconditioners \n\nPreconditioners are mathematical transformations developed to improve the \n\nnumerical solution of a given problem. For linear systems, preconditioners usually act by \n\nreducing the condition number of the matrices, thus, increasing the rate of convergence \n\nof iterative methods. Condition number is a measure of how much a function is sensitive \n\nto errors in the input, given by the ratio between maximum and minimum (in modulus) \n\neigenvalues of the global matrix. Consider the following linear system: \n\n \n\n ? ? = ? Eq. 3.5 \n\n \n\nThis linear system can be multiplied by the preconditioning matrix ?, \n\n \n\n ??1? ? = ??1? Eq. 3.6 \n\n \n\nFor a better convergence rate, the product ??1? should have a lower condition \n\nnumber than the original matrix ?. The preconditioner matrix ? is an approximation of \n\n??1 and the convergence rate is directly associated to the quality of this approximation. \n\nThere are many types of numerical preconditioners, such as: Jacobi, Successive Over \n\nrelaxation (SOR), Symmetric SOR (SSOR), Cholesky and LU factorizations, Block and \n\nMultilevel Block-Matrix Preconditioners, Polynomial Preconditioners, among many \n\nothers. \n\nNot all of these preconditioners are available in the EBE forms, which are adapted or \n\nderived versions of the conventional ones. This is because EBE preconditioners must be \n\ncomputed without the assemblage of a global preconditioner matrix using the element-\n\nbased indexing system, which, for computational efficiency, restricts the creation of \n\n\n\n \n\n90 \n\n \n\ncrossed numerical terms between elements. In this section are presented the two most \n\nimportant EBE preconditioners: the Jacobi Diagonal Preconditioner (item 3.2.1) and the \n\nHughes-Winget Preconditioner (item 3.2.2). \n\n \n\n3.2.1 Jacobi Diagonal Preconditioner \n\nThe Jacobi Diagonal Preconditioner is given by the diagonal of the global matrix: \n\n \n\n ? = ????? = ??????\n?\n\n???\n\n?=1\n\n \nEq. 3.7 \n\n \n\nIn the EBE method, this preconditioner is given by the global sum of the diagonal \n\nvalues of each element stiffness matrix. A scattering operation between the local and \n\nglobal degrees-of-freedom values must be performed, which requires synchronization if \n\nit is performed in parallel. In practice, only a vector with the inverse values of the global \n\ndiagonal must be stored. \n\n  \n\n3.2.2 Hughes-Winget Preconditioner \n\nThe Hughes-Winget preconditioner was developed in (WINGET &amp; HUGHES, 1985) \n\nand has been employed in many of the subsequent works in this research field. Proceeding \n\nto (WINGET &amp; HUGHES, 1985), the same authors have published two other works that \n\nwere the basis for the development of the Hughes-Winget preconditioner. These works \n\nwill be briefly described as follows in order to contextualize the reader.  \n\nIn the first one, (HUGHES, LEVIT, &amp; WINGET, 1983-A) introduced the EBE \n\nmethod for implicit and unconditionally stable solution of heat conduction problems, \n\nwhich typically required the assemblage of a global matrix of conductivity coefficients. \n\nIt was proposed an element-by-element splitting algorithm, which eliminated the global \n\nmatrix and allowed a solution procedure with arrays of element size. The storage \n\nrequirements were equivalent to explicit methods for heat conduction, with considerable \n\nreduction of memory consumption, but with stability and accuracy of implicit methods. \n\nBased on the potential of this technique, the authors extended EBE method to \n\nproblems of structural and solid mechanics (HUGHES, LEVIT, &amp; WINGET, 1983-B). \n\nAn iterative time-discretization algorithm to solve a linear system of equations by using \n\n\n\n \n\n91 \n\n \n\napproximate factorization techniques was developed, allowing it to occur on an element-\n\nby-element basis. The aforementioned authors replaced the linear system (a discrete \n\nelliptic problem) by a differential equation (an associated equivalent parabolic problem), \n\nused a trapezoidal integration algorithm and defined others auxiliary variables in order to \n\nsolve this differential equation. The complete resolution is found in (HUGHES, LEVIT, \n\n&amp; WINGET, 1983-B). When compared with direct elimination algorithms, this EBE \n\nversion showed a reduced number of operations and I/O (disk input / output) advantages. \n\nDespite the good numerical results, this approach of transforming the linear system into \n\na parabolic problem is not usual and was not taken forward in the subsequent works of \n\nthe same authors.  \n\nThe greatest contribution of these two publications comes from an approximation of \n\na global matrix by a series of element matrices products: \n\n \n\n ? ? ???\n\n???\n\n?=1\n\n= ?1?2 \u2026???? Eq. 3.8 \n\n \n\nThis approximate factorization scheme was further improved in (WINGET &amp; \n\nHUGHES, 1985), originating the Hughes-Winget preconditioner.  \n\nFollowing the same strategy from (WINGET &amp; HUGHES, 1985), these \n\napproximation techniques will be here firstly presented generically and, after that, \n\nparticularized to the EBE method, evidencing its potential.  \n\nA two-stage factorization is performed for ease in representation. The first stage is a \n\nreduction of ? into a form ???, which is \u2018close\u2019 to ?, has a known form and can be easily \n\nfactored: \n\n \n\n ? ? ??? = ?1/2(? +   ???)?1/2 Eq. 3.9 \n\n \n\n ? = ????? Eq. 3.10 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is a scaling or normalizing diagonal, symmetric, positive-definite matrix. \n\nIt reduces the order of ? to O(1); \n\n\u2022   \u2013 is a positive real number that should be a \u201csmall\u201d parameter; \n\n\n\n \n\n92 \n\n \n\n\u2022 ??? \u2013 is a pre-scaled approximation and that maintains the same sparsity \n\nstructure of ?. \n\n \n\nAppropriate choices for the parameters ?,  and ??? will be discussed at the end of \n\nthis section.  \n\nThe second stage is the definition of the splitting matrix ? (preconditioner matrix) \n\nas an approximation of ???. \n\n \n\n ? = ?1/2 ? ?1/2  Eq. 3.11 \n\n \n\n ? ?  ? +   ??? Eq. 3.12 \n\n \n\nFor computational reasons, the matrix ? should be easily factorable and its inverse \n\nmatrix, ??1, should be well behaved and storable in a compact form.  \n\n(WINGET &amp; HUGHES, 1985) \u201cconsidered definitions of ? based on sum-to-product \n\napproximations. A sum-to-product approximation approximates the sum of a number of \n\nterms by the product of scaled terms augmented by the identity\u201d.  \n\n \n\n3.2.2.1 Two-component splitting \n\nThe two-component splitting is the easiest of the sum-to-product type approximation \n\nand is given by: \n\n \n\n ??? = ???1 + ???2 \nEq. 3.13 \n\n \n\nUsing this sum-decomposition of ???, the matrix ? could be defined as: \n\n \n\n ? = (? +   ???1)(? +   ???2) \nEq. 3.14 \n\n \n\n ? =  ? +  ??? + 2???1???2 = ? +  ??? + ?(\n2) Eq. 3.15 \n\n \n\n\u201cComputational simplicity is gained if ???1 and ???2 are very sparse and are easier to \n\nfactor than ???. Note that if ???1 and ???2 do not commute, ? will not in general be symmetric \n\n\n\n \n\n93 \n\n \n\neven if ??? is symmetric. In addition, the ordering of terms in the product approximation \n\ninfluences the error in the approximation\u201d (WINGET &amp; HUGHES, 1985). \n\n \n\n3.2.2.2 Multi-component splitting \n\nThe multi-component splitting is a generalization of the two-component splitting, in \n\nwhich ??? is defined by a multi-component sum of ? operators: \n\n \n\n ??? = ?????\n\n?\n\n?=1\n\n Eq. 3.16 \n\n \n\nAnalogously to the previously presented procedure, ? can be approximated by a \n\nproduct formed of its ? components: \n\n \n\n ? = ?(? +   ????)\n\n?\n\n?=1\n\n Eq. 3.17 \n\n \n\n ? = (? +   ???1)(?+   ???2)\u2026(? +   ????) \nEq. 3.18 \n\n \n\n ? = ? +   ???? +\n2 ? (???? ? ????\n\n?\n\n?=?+1\n\n)\n\n??1\n\n?=1\n\n+ ?( 2) Eq. 3.19 \n\n \n\n ? = ? +  ??? + ?( 2) Eq. 3.20 \n\n \n\nThis approximation is known as one-pass multi-component splitting, the simplest of \n\nthe multi-component splitting category. The quality of this approximation is influenced \n\nby the form and order of the terms in the product. \n\nThe one-pass procedure can be generalized for the two-pass and multi-pass multi-\n\ncomponent splitting approximations. The most important expressions for these three \n\ncases are summarized in Table 3.3. \n\n\n\n \n\n94 \n\n \n\nTable 3.3 \u2013 Multi-component splitting. Adapted from: (WINGET &amp; HUGHES, 1985). \n\nOne-pass: \n\n ? = ?(? +   ????)\n\n?\n\n?=1\n\n Eq. 3.21 \n\nTwo-pass: \n\n ? = ?(? +\n1\n\n2\n  ????)\n\n?\n\n?=1\n\n?(? +\n1\n\n2\n  ????)\n\n1\n\n?=?\n\n Eq. 3.22 \n\nMulti-pass: \n\n ? = ? [?(? +\n?????\n\n  ?????(?))\n\n?\n\n?=1\n\n]\n\n?????\n\n?=1\n\n Eq. 3.23 \n\n.Where: \n\n\u2022 ????? is the number of passes; \n\n\u2022 ??(?) defines the order of the components for pass ?. \n\n \n\nWhen ? is a symmetric matrix, the multi-pass multi-component splitting can by \n\nsimplified by: \n\n \n\n ???? = ? [?(? +\n?????\n\n  ????)\n\n?\n\n?=1\n\n?(? +\n?????\n\n  ????)\n\n1\n\n?=?\n\n]\n\n?????/2\n\n?=1\n\n \nEq. 3.24 \n\n \n\nDespite being a better qualitative approximation for some cases, the multi-pass multi-\n\ncomponent splitting demands a significantly larger number of operations, so that only the \n\none-pass and two-pass procedures are used in practice. \n\n \n\n3.2.2.3 Element-by-element splits \n\nParticularizing these approximations to the element-by-element method, the \n\ncomponents of the matrix are the pre-scaled finite element contributions to the global \n\nmatrix: \n\n \n\n ??? = ?????\n\n???\n\n?=1\n\n \nEq. 3.25 \n\n\n\n \n\n95 \n\n \n\n \n\n???? is the ??? element contribution to ???. Globalized element arrays ???? are used in \n\norder to simplify the notation, but in practice, only local element arrays ?? and their \n\ncorresponding indexing arrays are stored. Substituting the definition of ???? into the \n\nexpressions of Table 3.3, the one-pass and two-pass EBE multi-component splitting for \n\n? can be defined. These expressions are shown in Table 3.4. \n\n \n\nTable 3.4 \u2013 EBE multi-component splitting. Adapted from (WINGET &amp; HUGHES, 1985). \n\nOne-pass: \n\n ? = ?(? +   ????)\n\n???\n\n?=1\n\n Eq. 3.26 \n\nTwo-pass: \n\n ? = ?(? +\n2\n ????)\n\n???\n\n?=1\n\n?(? +\n2\n ????)\n\n1\n\n???\n\n Eq. 3.27 \n\n\u2026 \n\n \n\nThe pseudo-residual, ???1, from the iterative methods (Table 3.1, for example) can \n\nbe calculated directly multiplying the inverse of ? by the linear residual ???1: \n\n \n\n ???1 = ?\n?1???1 = (?\n\n1/2 ? ?1/2)\n?1\n???1  \n\nEq. 3.28 \n\n \n\nor solving the linear system: \n\n \n\n (?1/2 ? ?1/2) ???1 = ???1 \nEq. 3.29 \n\n \n\nThis operation becomes much easier if a factored form of ? is found. In this case, \n\n???1 is computed using standard direct solution techniques that require diagonal scaling, \n\nforward reductions and back substitutions. Based on this, (WINGET &amp; HUGHES, 1985) \n\ndeveloped three factored forms of the one-pass EBE multi-component splitting, which \n\nare in Table 3.5. The expressions for the symmetric case are summarized in Table 3.6. \n\n \n\n\n\n \n\n96 \n\n \n\nTable 3.5 \u2013 One-pass EBE multi-component splitting.  \n\nStandard: \n\n ? = ?(? +   ????)\n\n???\n\n?=1\n\n Eq. 3.30 \n\n \n\nCrout factored form: \n\n ? = ???(?+ ????)??(? + ????)??(? + ????)\n\n???\n\n?=1\n\n \nEq. 3.31 \n\n \n\nCholesky factored form: \n\n ? = ?????(? + ????)????(? + ????)\n\n???\n\n?=1\n\n \nEq. 3.32 \n\n \n\nGauss-Seidel approximate factored form:  \n\n ? = ?(? + ?????(????))(? + ?????(????))\n\n???\n\n?=?\n\n \nEq. 3.33 \n\n \n\nAdapted from: (WINGET &amp; HUGHES, 1985). \n\n \n\nTable 3.6 \u2013 Symmetric factorizations for one-pass EBE multi-component splitting.  \n\nCrout (?) \n\n ? = ???(? + ????)??(? + ????)??\n? (? + ????)\n\n???\n\n?=1\n\n Eq. 3.34 \n\n \n\nCholesky (???) \n\n ? = ?????(? + ????)????\n? (? + ????)\n\n???\n\n?=1\n\n Eq. 3.35 \n\n \n\nSymmetric Gauss-Seidel (???) \n\n ? = ?(? + ????(????))(? + ????\n? (????))\n\n???\n\n?=1\n\n \nEq. 3.36 \n\n. \n\nSource: (WINGET &amp; HUGHES, 1985). \n\n\n\n \n\n97 \n\n \n\n \n\nThe factored forms of the two-pass EBE multi-component splitting are shown in \n\nTable 3.7. \n\n \n\nTable 3.7 \u2013 Two-pass EBE multi-component splitting.  \n\nStandard \n\n ? = ?(? +\n2\n ????)\n\n???\n\n?=1\n\n?(? +\n2\n ????)\n\n1\n\n???\n\n Eq. 3.37 \n\n \n\nCrout factored form \n\n \n\n? = ??? (? +\n2\n????)?? (? +\n\n2\n????)?? (? +\n\n2\n????)\n\n???\n\n?=1\n\n             \n\n      \u00d7   ? ?? (? +\n2\n????)?? (? +\n\n2\n????)?? (? +\n\n2\n????)\n\n1\n\n?=???\n\n \n\nEq. 3.38 \n\n \n\nCholesky factored form \n\n \n\n? = ????? (? +\n2\n????)???? (? +\n\n2\n????)\n\n???\n\n?=1\n\n               \n\n             \u00d7  ? ???? (? +\n2\n????)???? (? +\n\n2\n????)\n\n1\n\n?=???\n\n \n\nEq. 3.39 \n\n \n\nGauss-Seidel approximate factored form \n\n \n\n? = ?(? +\n2\n????(????))(? +\n\n2\n????(????))\n\n???\n\n?=1\n\n        \n\n              \u00d7  ? (? +\n2\n????(????))(? +\n\n2\n????(????))\n\n1\n\n?=???\n\n \n\nEq. 3.40 \n\n. \n\nAdapted from: (WINGET &amp; HUGHES, 1985). \n\n \n\n(WINGET &amp; HUGHES, 1985) also noticed that the ordering of the factors influences \n\nhow well ? approximates ? +   ??? and therefore developed a reordered version of the \n\nEBE split factorizations, which expressions are in for the one-pass can be found in Table \n\n3.8. \n\n\n\n \n\n98 \n\n \n\nTable 3.8 \u2013 Reordered one-pass EBE multi-component splitting. \n\nCrout factored form: \n\n ? = [???(? + ????)\n\n???\n\n?=1\n\n][???(? + ????)\n\n???\n\n?=1\n\n][ ? ??(?+ ????)\n\n1\n\n?=???\n\n] Eq. 3.41 \n\n \n\nCholesky factored form: \n\n ? = [?????(? + ????)\n\n???\n\n?=1\n\n][ ? ????(?+ ????)\n\n1\n\n?=???\n\n]  Eq. 3.42 \n\n \n\nGauss-Seidel approximate factored form: \n\n ? = [?(? + ????(????))\n\n???\n\n?=?\n\n][ ? (? + ????(????))\n\n?\n\n?=???\n\n]      \n\n \n\nEq. 3.43 \n\n. \n\nAdapted from: (WINGET &amp; HUGHES, 1985). \n\n \n\nIn order to complete the formulation, parameters ?,  and ??? from Eq. 3.9 must be \n\nconsidered. There are two options for the parameters ? and ???, and they are summarized \n\nin Table 3.9. \n\n \n\nTable 3.9 \u2013 Choice of parameters ? and ???. \n\nParabolic regularization parameters: \n\n ? = ??         \nEq. 3.44 \n\n \n\n ??? = \n1\n ??1/2? ??1/2        Eq. 3.45 \n\n \n\nOptimum parameters: \n\n ? = ??         \nEq. 3.46 \n\n \n\n ??? = \n1\n ??1/2(? ? ??(?)) ?\n\n?1/2        Eq. 3.47 \n\n. \n\nAdapted from: (WINGET &amp; HUGHES, 1985). \n\n \n\n\n\n \n\n99 \n\n \n\nAccording to (WINGET &amp; HUGHES, 1985), the approximate factorizations under \n\nconsideration have all had error terms of order 2 and higher. The \u201cquality\u201d of the \n\napproximation is governed by the size of these error terms. \n\nBased on obtained numerical results, (WINGET &amp; HUGHES, 1985) concluded that \n\nthe one-pass, reordered, Crout EBE factorization, applied to the optimal definition of ??? \n\nand coupled with a preconditioned conjugate gradient iteration algorithm is particularly \n\neffective for solving symmetric positive-definite matrix systems. This version corresponds \n\nto the Hughes-Winget Preconditioner (HW). \n\n \n\n3.3 Parallelization of the EBE method \n\nThe scalability and ease of parallelization characteristhics are among the main \n\nreasons that explain the success of the EBE method. At the same time, as parallel \n\ncomputing has evolved a lot on the last three decades, both in terms of programming and \n\nhardware technologies, the first EBE-PCG implementations have become outdated. \n\n(HUGHES, LEVIT, &amp; WINGET, 1983-A) introduced the EBE method. Given its \n\npotential, these authors have further developed the research line, publishing also \n\n(HUGHES, LEVIT, &amp; WINGET, 1983-B), (WINGET &amp; HUGHES, 1985) and \n\n(HUGHES &amp; FERENCZ, 1987). In these works, significative advances have been \n\nachieved in order to establish and develop the EBE method, that led, for example, in the \n\ndevelopment of the Hughes-Winget preconditioner. However, in terms of parallelization, \n\nthe employed techniques are obsolete in relation to modern computers and programming \n\nlanguage, since they were oriented to CRAY vectorial supercomputers from the 80\u2019s, \n\nusing, for example, specific data structures of blocks of 64 elements. \n\n(CAREY &amp; JIANG, 1986) proposed an element-by-element scheme that employs \n\npreconditioned conjugate gradient algorithms for nonlinear problems. Their \n\nimplementation was tested on several computers of that time and compared it with a direct \n\nsolution method, obtaining great results regarding the processing time and memory \n\nconsumption. However, despite discussing the necessity of synchronization, they have \n\nnot presented or discussed the aspects involving the parallelism of the solution. \n\n(KING &amp; SONNAD, 1987) introduced a parallel implementation of the Crout EBE \n\npreconditioned conjugate gradient method. The architecture of the computer used to run \n\nthe code consisted of an array of loose processors, each one with a large memory (to the \n\nstardards of that time) and all of them connected to a shared memory  via communication \n\n\n\n \n\n100 \n\n \n\nbus. Despite the outdate hardware, the synchronization logics and challenges resulting \n\nfrom this architecture are similar to those found with MPI programming. (KING &amp; \n\nSONNAD, 1987) subdivided the element mesh into ?? regions (where ?? is the number \n\nof available processors), each of which was handled by a separate processor, as shown in \n\nFig. 3.1. \n\n \n\n \n\nFig. 3.1 \u2013 Schematic diagram of parallel implementation of EBE-PCG algorithm. Source: (KING &amp; \n\nSONNAD, 1987). \n\n \n\nThe backward product from Crout preconditioner, for example, was carried in each \n\nprocessor over the all elements except to those touching the top boundary of each \n\nprocessor. The shared memory was then used to pass the resulting vector components at \n\nthe degrees of freedom on the bottom boundary. This procedure is repeated until the end, \n\nconcentrating the maximum possible amount of operations in each processor and using \n\nthe shared memory to synchronize informations between neighbor regions or, in some \n\ncases, globally.   (KING &amp; SONNAD, 1987) found an ingenius solution with the limited \n\ncomputational tools available that time to generate an element-based domain \n\ndecomposition in order to apply the EBE procedure. This allowed them to obtain very \n\nhigh speedup values in numerical experiments, as shown in Fig. 3.2. \n\n \n\n\n\n \n\n101 \n\n \n\n \n\nFig. 3.2 \u2013 Parallel speedup ratios achieved on the 1CAP computer, corrected for effect of element \n\nreordering on convergence. Source: (KING &amp; SONNAD, 1987). \n\n \n\n(ADELI &amp; KUMAR, 1995) presented a distributed algorithm for solving linear \n\nsystem of equations with a coarse-grained element-by-element preconditioned conjugate \n\ngradient method. They proposed an algorithm that divides the problem into different \n\nsubdomains with overlapping regions, with the objective of reducing comunnication costs \n\nthrough redundant computations. Fig. 3.3 is an example with four overlapping \n\nsubdomains, such that the element 31 belongs to all sets in this case. \n\n \n\n \n\nFig. 3.3 \u2013 Distribution of elements among subdomains. Source: (ADELI &amp; KUMAR, 1995). \n\n \n\n(GULLERUD &amp; DODDS JR, 2001) developed a MPI-based implementation of a \n\nPCG solver using an EBE architecture and preconditioner for implicit 3D finite element \n\nanalysis for shared, distributed and distributed-shared memory computers. In this \n\n\n\n \n\n102 \n\n \n\nimplementation, the mesh is divided into subdomains, each of which assigned to a \n\ndifferent processor, responsible for the local computations. In order to achieve a load \n\nbalanced solution and minimize boundaries and communication costs, (GULLERUD &amp; \n\nDODDS JR, 2001) used the graph partitioning software METIS to perform this task. As \n\nshown in Fig. 3.4, a second level of partitioning was performed inside of each subdomain, \n\ngrouping similar elements, i.e. same type, properties, constitutive model, etc\u2026 for further \n\nimprovement of computational performance, once this framework creates inner loops \n\nwith significant work loads, which expose opportunites for local parallelism. \n\n \n\n \n\nFig. 3.4 \u2013 Two level partitioning scheme. Mesh is first partitioned into subdomains for the processors, \n\nthen each subdomain is further divided into blocks of elements with the same type, constitutive model, \n\netc. Source: (GULLERUD &amp; DODDS JR, 2001).  \n\n \n\nIn a very complete work, (GULLERUD &amp; DODDS JR, 2001) detail several aspects \n\nregarding parallelization of the implementation, which was performed in WARP3D, a \n\nresearch code developed by the aforementioned authors. According to them, \u201cthe \n\nWARP3D architecture employs a manager-work approach to organize and drive parallel \n\nexecution. The manager (root) processor serves as the controller for the computations by \n\nconducting necessary serial calculations and initializing parallel computation through \n\nnotification of the worker processors. The worker processors, when not conducting \n\ncomputations, wait for the manager processor to initiate a new set of calculations. Each \n\nprocessor stores the data for the elements within its domain, and conducts the \n\ncorresponding local element calculations, including tangent stiffness computation, \n\nstrain/stress/internal force resolution, contact evaluation. The manager processor \n\n\n\n \n\n103 \n\n \n\ncomputes and stores most nodal quantities (e.g. the applied load vector). For nodal \n\nquantities derived from element values (e.g. diagonal terms of structure stiffness), each \n\nprocessor stores values for all nodes connected to the elements within its domain and \n\nemploys special MPI communication datatypes to update values for nodes shared \n\nbetween processors. Every processor stores the basic geometry data for the model (e.g. \n\nnode coordinates, element connectivity, displacement constraints). The manager \n\nprocessor currently conducts all input activities while each worker processor generates \n\noutput for the domain data\u201d. The aspects involving possibility of parallelization and \n\ncommunication requirements for a load increment are displayed in Fig. 3.5. \n\n \n\n \n\nFig. 3.5 \u2013 Parallel solution of a load increment. Source: (GULLERUD &amp; DODDS JR, 2001). \n\n \n\nThe EBE preconditioned conjugate gradient algorithm implemented by \n\n(GULLERUD &amp; DODDS JR, 2001) is summarized in Table 3.10. With respect to the \n\npreconditioning matrix, ?, they implemented and tested the diagonal (Jacobi) and the \n\nHughes-Winget (HW) versions. (GULLERUD &amp; DODDS JR, 2001) also proposed a new \n\nparallel implementation of the Hughes-Winget EBE preconditioner, that couples an \n\nunstructured dependency graph with a new balanced graph-coloring algorithm to \n\nschedule parallel computations within and across domains. \n\n\n\n \n\n104 \n\n \n\n \n\nTable 3.10 \u2013 EBE Preconditioned Conjugate Gradient Algorithm. \n\nLinear System:     ?? ? = ? \n\nStep 1 - Initialization: \n\n1. ? =  ?, ?? = ??????????  \n\n2. for ? = ?,\u2026??? \n\n3.        if ? is a constrained dof, \n\n4.             ?? = ? \n\n5.        else \n\n6.             ?? = ?? \n\n7.        end if \n\n8. end for \n\nStep 2 - Iterations: \n\n1. for ? =  ?,?,?,\u2026. \n\n2.  ???? = ?\n?? ???? \n\n3.  ?? = \n????\n? ????\n\n????\n? ????\n\n (?? = ?) \n\n4.  ?? = ???? + ?? ????  (?? = ?) \n\n5.  ?? =\n????\n?  ????\n\n??\n? ?? ??\n\n \n\n6.  ?? = ???? + ?? ?? \n\n7.  ?? = ???? ? ???? ?? \n\n8. end for \n\nStep 3 - Convergence Check: \n\n1. if ???? ? tolerance \n\n2.  Solution converged \n\n3. else \n\n4.  if ? > ???.????????? ????? \n\n5.  Solution did not converged \n\n6.  else \n\n7.  ? = ? + ? \n\n8.  Return to Step 2 \n\n9.  end if \n\n10. end if \n\nSource: (GULLERUD &amp; DODDS JR, 2001). \n\n \n\n\n\n \n\n105 \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the iteration count; \n\n\u2022 ?? \u2013 is the global stiffness matrix; \n\n\u2022 ? \u2013 is the linear residual; \n\n\u2022 ? \u2013 is the trial displacement vector; \n\n\u2022 ? \u2013 is the preconditioning matrix; \n\n\u2022 ? \u2013 denotes the step direction; \n\n\u2022 ? \u2013 is the step length; \n\n\u2022 ? \u2013 defines the correction factor. \n\n \n\nIn this implementation, the calculation of the preconditioning matrix ? and the \n\nmatrix vector product [?T]{?k} are responsible for most of the computation time. As in \n\nthe EBE formulation the global stiffness matrix assembling is avoided, the contributions \n\nof each element (??\n(?)\n ?? (?)) are summed together to form the global result. \n\nAccording to (GULLERUD &amp; DODDS JR, 2001), \u201cthe parallel version of the LPCG \n\nalgorithm uses a domain decomposition of both element and nodal data. Processors own \n\nall relevant data for elements in their domain and the data for internal nodes; data is \n\nshared between processors for nodes on domain boundaries. Between each step in the \n\nLPCG algorithm, communications synchronize terms for nodes on the boundary between \n\ndomains for nodal vectors. Fig. 3.6 illustrates the computation of the matrix-vector \n\nproduct [??]{??} using the previously described blocking of the elements. A gather-\n\ncompute-scatter cycle, as shown within the shaded region, defines the computational \n\nkernel. This process collects terms required for the multiplication of an entire block into \n\ndata structures contiguous in memory. The blocking approach provides a simple means \n\nto tune for optimal cache memory utilization by altering block sizes and takes full \n\nadvantage of platforms that provide vector processors\u201d.  \n\n \n\n\n\n \n\n106 \n\n \n\n \n\nFig. 3.6 \u2013 Multiplication of [??]{??} for a block of elements. Source: (GULLERUD &amp; DODDS JR, \n\n2001). \n\n \n\n(GULLERUD &amp; DODDS JR, 2001) have presented by far the most detailed and \n\ndidactic implementation of the EBE method. They have discussed several aspects \n\nregarding parallelization, synchronization and how the gather and scatter operations \n\nshould be performed in order to achieve a better performance. In addition, they used MPI \n\nto parallelize their solution, which is still widely used in the academy and industry for \n\nparallelization in distributed processing hardware. Their domain subdivision \n\nmethodology is also fully applicable to the finite element problem of a flexible pipe, \n\nwhich, for its simplified cylindrical element, has simplified logics of domain subdivision, \n\ndiscarding the use of dedicated auxiliary software (such as METIS) for this. Therefore, \n\nthis very efficient strategy adopted by (GULLERUD &amp; DODDS JR, 2001) will be the \n\nbasis for the development of a parallel implementation customized to the finite element \n\nanalysis of a flexible pipe. \n\n(LIU, ZHOU, &amp; YANG, 2007) developed a distributed memory parallel EBE scheme \n\nfor tridimensional finite element analysis that employs the Jacobi preconditioned \n\nconjugate gradient method. The flowchart from Fig. 3.7 illustrates the implemented \n\nprocedure to parallelize the solution, in which each processor stores data and performs \n\ncalculation only to the elements assigned to them.     \n\n \n\n\n\n \n\n107 \n\n \n\n \n\nFig. 3.7 \u2013 Flowchart of FEM method based on EBE policy. Source: (LIU, ZHOU, &amp; YANG, 2007). \n\n \n\nMore recent works, for example (KISS, GYIMOTHY, BADICS, &amp; PAVO, 2012), \n\n(KISS, BADICS, GYIMOTHY, &amp; PAVO, 2012), (MART\u00cdNEZ-FRUTOS, MART\u00cdNEZ-\n\nCASTEJ\u00d3N, &amp; HERRERO-P\u00c9REZ, 2015) and (MART\u00cdNEZ-FRUTOS &amp; HERRERO-\n\nP\u00c9REZ, 2015), have focused on GPU applications to the EBE method, extrapolating the \n\nscope of this work. \n\n \n\n\n\n \n\n108 \n\n \n\n PipeFEM \n\nIn general, the final solution of the system of equations is the main bottleneck of a \n\nfinite element simulation. However, when dealing with large scale models, it is important \n\nto look for a balanced tool in terms of computational performance, since other processes \n\nmay also become bottlenecks, such as geometry creation, mesh generation and element \n\nstiffness matrices computation. In this context, aiming the simulation of large scale \n\nmodels of flexible pipes, a new analysis tool was developed, named as PipeFEM, entirely \n\nwritten in C++ and that explores parallelism in the geometry and mesh generation and in \n\nthe numerical solution. Its functioning follows the standard flowchart of the finite element \n\nmethod, illustrated in Fig. 4.1. After the numerical solution, the program exports the nodal \n\nresults into an output \u201c.txt\u201d file, which is then used to post process the results and to \n\ngenerate the displacements graphs. \n\n \n\n \n\nFig. 4.1 \u2013 Flowchart of PipeFEM. Source: own authorship. \n\n \n\n\n\n \n\n109 \n\n \n\nIn order to implement the flowchart of Fig. 4.1, it was necessary to develop a series \n\nof additional modules and libraries, shown in Fig. 4.2. \n\n \n\n \n\nFig. 4.2 \u2013 Libraries that compose the PipeFEM program. Source: own authorship. \n\n \n\nA Linear Algebra library was developed for PipeFEM. It includes a series of \n\ncontainers for data storage and manipulation, such as Vector and Matrix, and which are \n\npresented in greater detail in Chapter 5. The linear algebra library also contains the EBE-\n\nPCG algorithm, presented in Chapter 9. \n\nAs the name suggests, Base is responsible for the definition of most of the objects of \n\nthe program, including, for instance, geometric and mesh entities, coordinate systems \n\n(CSYS), among others. For this reason, it can be considered the base library of the \n\nprogram and directly employed by the following ones. The most important items of the \n\nBASE library are presented in detail in chapters 6 and 7. \n\nAiming high computational performance, the element definitions of MacroFEM were \n\nconverted to the C++ language, parallelized, optimized and implemented in the element \n\nlibrary, ELIB. This library also contains a useful feature, called \u201celement type\u201d, which is \n\nresponsible for standardizing and systematizing the storage of user-defined element \n\nparameters, besides acting as element allocators during mesh generations. The materials \n\nand sections definitions were also converted from MacroFEM and implemented in the \n\nMATLIB and SECLIB libraries, respectively. These three libraries are presented in the \n\nfollowing sections. \n\nDatabase library is responsible for the definition of the \u201cdatabase\u201d object, which is \n\nemployed to store and transmit data in an organized and encapsulated way. Basically, it \n\n\n\n \n\n110 \n\n \n\nconsists of a structured container of pointers to all entities that comprise the model (which \n\nare presented in the next chapters). It also facilitates data manipulation, by allowing the \n\nselection of specific items or the iteration along all items of a desired type. In addition, \n\nthe database object provides all necessary statistics of the model, such as the total number \n\nof nodes or elements. \n\nCAD library is responsible for the construction of the flexible pipe models. It \n\nprovides methods for geometry creation and manipulation, and is also responsible for \n\nmesh generations and contact definitions between layers of the pipe. It is also responsible \n\nfor applying the loads and boundary conditions to the modeled flexible pipe. For these \n\nreasons, it is the library with the highest degree of interaction with the user. Internally, \n\nthe CAD library allocates the objects defined in the BASE library and includes them to \n\nthe database object. \n\nSolver, fully described in Chapter 7.3, is responsible for the numerical solution of \n\nthe problem. The complete model data is transmitted from CAD to the solver through the \n\ndatabase object. The solver is responsible for computing the element stiffness matrices, \n\nglobal degrees-of-freedom numbering and for employing the developed EBE-PCG \n\nalgorithm. \n\n \n\n4.1 ELIB \u2013 Element Library \n\nELIB implements the finite macroelements from chapter 2. It is subdivided into two \n\nbranches, that are related to each other: \n\n\u2022 Elements: responsible for the definitions of the element objects; \n\n\u2022 Element Types (or Element Allocators): stores user-defined parameters \n\nregarding the finite elements and works as their allocators.  \n\n \n\n4.1.1 Element \n\nThe finite elements are the basis of the method. Each element object stores its nodal \n\nconnectivity, material, section and other parameters, which are later used to compute the \n\nelement stiffness matrices and to relate the global and local connectivity basis. Aiming \n\nhigher computational performance, the finite macroelements from MacroFEM were \n\nconverted to the C++ language, parallelized, optimized and implemented in PipeFEM \n\nusing polymorphism. The derived classes from the main class Element are illustrated in \n\n\n\n \n\n111 \n\n \n\nFig. 4.3. Element, as well as the classes that directly derive from it, are abstract classes. \n\nThis allows the manipulation of the objects from the lowest level derived classes as if \n\nthey were Element objects. \n\n \n\n \n\nFig. 4.3 \u2013 Finite elements. Source: own authorship. \n\n \n\nThe branch Beam includes the beam elements, in special the helical element; while \n\nthe branch Solid of Revolution is responsible for the Fourier cylindrical element; and \n\nfinally Contact relates to the implementation of the contact elements. \n\n \n\n4.1.2 Element Type \n\nAs each derived element has its own Element Type object, both of them follow \n\nexactly the same hierarchy from Fig. 4.3. Element Type has two important functions. The \n\nfirst is to store both intrinsic and user-defined parameters from each type of element, such \n\nas the number of degrees-of-freedom, nodal type (Standard or Fourier), the element \n\nFourier order, element applicability (if it can be used to mesh lines or areas, for example), \n\nand others. The second function is to act as an element allocator: during the mesh \n\nmethods, the element type is employed to allocate new elements, which can be done in a \n\nconcise way, since all necessary parameters and properties are already encapsulated in it.  \n\n \n\nElement\n\nBeam\n\nHelix\n\nSolid of \nRevolution\n\nOrthotropic \nFourier \nCylinder\n\nContact\n\nNode to Node\n\nStandard-\nStandard\n\nFourier-\nStandard\n\n\n\n \n\n112 \n\n \n\n4.2 MATLIB \u2013 Material Library \n\nMATLIB is responsible for the material definitions. The hierarchical relationships of \n\nthe material objects are illustrated in Fig. 4.4. So far, only linear elastic materials are \n\ncontemplated, although the basis for a future implementation of nonlinear materials has \n\nbeen left.  \n\n \n\n \n\nFig. 4.4 \u2013 Material library. Source: own authorship. \n\n \n\n4.3 SECLIB \u2013 Section Library \n\nSECLIB is responsible for the sections definitions, by creating their objects and \n\nstoring the user-defined section parameters, being a relatively simple class in comparison \n\nto the other. It is subdivided into circular and rectangular beam cross-sections, as \n\nillustrated in Fig. 4.5. Object-oriented concepts were applied in order to facilitate future \n\ninclusions of new types of cross-sections. \n\n \n\n \n\nFig. 4.5 \u2013 Section library. Source: own authorship. \n\nMaterial\n\nElastic\n\nLinear\n\nIsotropic Orthotropic \n\nSection\n\nBeam\n\nRectangular Circular\n\n\n\n \n\n113 \n\n \n\n Data Containers \n\nIn order to store and manipulate data in PipeFEM in an efficient way, it was necessary \n\nthe development of the following data containers: \n\n\u2022 Vector: a single-dimensional data container; \n\n\u2022 Matrix: a two-dimensional data container; \n\n\u2022 Symmetric Matrix: a symmetric two-dimensional data container; \n\n\u2022 EBE Matrix: a two-dimensional data container composed of several other \n\nsmaller matrices. \n\n \n\nWhen designing these containers, generic programming techniques of C++ were \n\nexplored by employing Templates, in which the developed code is independent of any \n\nparticular type. In other words, the code is generic and can be applied to different types. \n\nVector, for instance, can be used to store from simple types such as int and double, to \n\nmore complex objects (geometry, mesh and element objects), pointers to objects and so \n\non. \n\n \n\n5.1 Vector \n\nVector is a sequential container that can stores ? user-defined objects of the same \n\ntype. It is dynamically and contiguously allocated, i.e., the memory is allocated in \n\nconsecutive address memory blocks, making the iteration process a very fast and efficient \n\nprocedure. All the work relative to memory allocation and management is encapsulated \n\nwithin the vector object, making very simple its usage. \n\nResizing a vector can be an expensive procedure. When the desired size exceeds the \n\ntotal amount of allocated memory, there is no alternative other than to dynamically \n\nallocate a new array and in sequence move the contents of the old array to the new one. \n\nIn order to minimize its cost, additional memory is also pre-allocated, as illustrated in Fig. \n\n5.1, being possible the rapid inclusion of some new elements. With an acceptable \n\nadditional memory cost, this strategy reduces significantly the total number of resizing \n\noperations, bringing performance to the implementation. The amounts of allocated and \n\n\n\n \n\n114 \n\n \n\npre-allocated memories can be controlled by the user through the resize and reserve \n\nmethods, respectively. \n\n \n\n \n\nFig. 5.1 \u2013 Vector memory management. Source: own authorship. \n\n \n\nThe functioning of the implemented Vector container is very similar to the available \n\nin the C++ Standard Library (STD). Nevertheless, it was decided to develop a proprietary \n\nvector template instead of using the one from STD due to the following reasons: absolute \n\ncontrol of memory allocation (especially in \u201cresizing\u201d and \u201cpush back\u201d operations), since \n\nthe STD version uses its internal allocator, whose behavior is not completely clear in the \n\nspecifications, which can be harmful for parallel applications; and also due to some \n\nobserved unexpected behaviors of the STD version for parallel manipulations of large-\n\nscale vectors. Additionally, the implemented Vector explores an interesting feature of the \n\nC++ language called \u201ctemplate specialization\u201d, which allows the customization of the \n\nalgorithm for a particular type. In this case, it was done a specialization for the double \n\ntype, and specific methods (such as vector norms) and mathematical operators were \n\nimplemented. \n\n \n\n5.2 Matrix \n\nMatrix template is an extension of the concept of vector to the two-dimensional field, \n\nin which the stored data is accessed via row and column indexes. \n\nIn its first implementation, a double starred pointer was used to allocate and \n\nmanipulate the memory, as exemplified in Fig. 5.2 for the double type. In this case, an \n\narray of pointers is dynamically allocated. Then, for each of its elements, a new array is \n\ndynamically allocated. This approach has the advantage of the direct indexing (for \n\ninstance, the position (2,3) in the matrix is accessed directly by ?[2][3]), as shown in \n\n\n\n \n\n115 \n\n \n\nFig. 5.3, but leaves data scattered in memory, since each row of the matrix is allocated \n\nindependently, losing memory contiguity. \n\n \n\n \n\nFig. 5.2 \u2013 Example of double starred pointer for matrix allocation. Source: own authorship. \n\n \n\n \n\nFig. 5.3 \u2013 Memory hierarchy and indexing for the double starred pointer allocation. Source: own \n\nauthorship. \n\n \n\nThis way, in order to take advantage of the benefits of contiguous memory allocation, \n\nthe single array methodology was employed, as illustrated in Fig. 5.4. In this case, a single \n\nlarge array is dynamically allocated, concatenating all the lines of the matrix. The position \n\nin memory of the pair (?, ?) is given by mathematical operation:  \n\n \n\n ?????? ???????? ?? ?(?, ?) =  ? .  ???????? + ?   Eq. 5.1 \n\n \n\n \n\nFig. 5.4 \u2013 Single array scheme of storage. Source: own authorship. \n\n \n\n\n\n \n\n116 \n\n \n\nIn order to optimize the resizing capability of the matrix, it was developed a \n\nprocedure of additional pre-allocated memory, as illustrated in Fig. 5.5. In this example, \n\nthe useful size of the matrix is (3?3), but the pre-allocated size is (5?8). It means that up \n\nto two rows or four columns can be added without any memory reallocation. \n\n \n\n \n\nFig. 5.5 \u2013 Memory management for fast resizing capability. Source: own authorship. \n\n \n\nFig. 5.6 shows the pre-allocated memory regions that start being used when a new \n\nline is added to the matrix. \n\n \n\n \n\nFig. 5.6 \u2013 Addition of a new line. Source: own authorship. \n\n \n\nFig. 5.7 shows the pre-allocated memory regions that start being used when a new \n\ncolumn is added to the matrix. \n\n\n\n \n\n117 \n\n \n\n \n\nFig. 5.7 \u2013 Addition of a new column. Source: own authorship. \n\n \n\nIn this scheme, the position in memory does not depend on the number of columns \n\nof the matrix, but on the total number of pre-allocated columns and is given by: \n\n \n\n ?????? ???????? ?? ?(?, ?) =  ? .  ? ?????????.  ??????? + ?   Eq. 5.2 \n\n \n\nAlthough this methodology reduces the number of memory reallocations, there are \n\nstill necessary situations, as the exemplified in Fig. 5.8.  \n\n \n\n \n\nFig. 5.8 \u2013 Examples of resizing cases with necessary memory reallocation. Source: own authorship. \n\n \n\nFig. 5.9 shows the procedure for the addition of four pre-allocated lines. In this case, \n\na new array must be dynamically allocated and after that the useful entries of the old array \n\nmust be moved to this new one. \n\n \n\n\n\n \n\n118 \n\n \n\n \n\nFig. 5.9 \u2013 Memory management for additional pre-allocated lines. Source: own authorship. \n\n  \n\nAnalogous, Fig. 5.10 shows the procedure for the addition of two pre-allocated \n\ncolumns, and Fig. 5.11 shows the procedures for the inclusion in both directions. \n\n \n\n \n\nFig. 5.10 \u2013 Memory management for additional pre-allocated columns. Source: own authorship. \n\n  \n\n \n\n \n\nFig. 5.11 \u2013 Memory management for both additional pre-allocated lines and columns. Source: own \n\nauthorship. \n\n \n\n\n\n \n\n119 \n\n \n\nTemplate specialization was also explored for the double type, enabling the \n\nimplementation of specific methods (such as matrix determinant) and numerical operators \n\n(such as matrix-vector and matrix-matrix products). \n\n \n\n5.3 Symmetric Matrix \n\nThe Symmetric Matrix is a particular case of the Matrix, in which the following \n\nrelation is always valid: \n\n  \n\n ?(?, ?) = ?(?, ?)  Eq. 5.3 \n\n \n\nThis property is explored to reduce memory consumption in almost 50%, since the \n\nsymmetric values are stored only once. As illustrated in Fig. 5.12, a single array is \n\ndynamically allocated to store the elements of the symmetric matrix. \n\n \n\n \n\nFig. 5.12 \u2013 Single array memory allocation. Source: own authorship. \n\n \n\nThe memory indexing is given by the arithmetic progression from Eq. 5.4. In the case \n\nof accessing an element situated above the main diagonal, the values of ? and ? are \n\nswapped, as shown in this equation. \n\n \n\n ?????? ???????? ?? ?(?, ?) = {\n ? +\n\n? .(1 + ?)\n\n2\n, ? ? ?\n\n ? +\n? .(1 + ?)\n\n2\n, ? > ?\n\n  Eq. 5.4 \n\n \n\nAs can be seen in Eq. 5.4, every indexing operation requires a costly \u201cif/else\u201d \n\noperation to verify if the input pair is situated below or above the main diagonal. This \n\nresults in a trade-off between improved memory consumption and higher indexing costs. \n\n\n\n \n\n120 \n\n \n\nIf the number of indexing operations is very high during the manipulation of the stored \n\ndata, it might be better to use conventional matrices instead of the symmetric ones. \n\nIn order to minimize this indexing costs, the implementation counts also with non-\n\nsafe accessing methods and operators that do not perform this \u201cif/else\u201d verification, giving \n\nthe user full responsibility for their correct use. \n\nThe development of customized algorithms was also another explored alternative to \n\nimprove the efficiency of the symmetric matrix implementation, which is clear in the \n\nfollowing example, the product operation between two symmetric matrices. This \n\noperation is very important for finite elements, since it can be performed several times \n\nduring the evaluation of each of the element stiffness matrices depending on the \n\nformulations. The matrix-matrix product is a costly operation, for both the high number \n\nof mathematical operations and memory accesses. However, as the indexing follows well-\n\ndefined patterns, it was possible to develop an optimized logic using only indexes pairs \n\nsituated exclusively below the main diagonal, with direct access and eliminating all \n\n\u201cif/else\u201d verifications. It is illustrated in Fig. 5.13 and Fig. 5.14, and the complete \n\nalgorithm is found in Table 5.1. \n\n \n\n \n\nFig. 5.13 \u2013 Cache optimized product between two symmetric matrices, for (?, ?) indexes where ? ? ?. \n\nSource: own authorship. \n\n \n\n \n\nFig. 5.14 \u2013 Cache optimized product between two symmetric matrices, for (?, ?) indexes where ? > ?. \n\nSource: own authorship. \n\n  \n\n \n\n\n\n \n\n121 \n\n \n\nTable 5.1 \u2013 Optimized algorithm for the product between two symmetric matrices. \n\nConventional Algorithm Optimized Algorithm \n\n \n\n \nSource: own authorship. \n\n \n\nIn order to evaluate the efficiency of the implementations, a parametric analysis of \n\nthe simulation time of the matrix-matrix product in function of the size of the matrix for \n\nfour different methodologies is available at Fig. 5.15. These results show that the \n\noptimized logic for symmetric matrices (Table 5.1) have reduced the simulation time by \n\n11% in comparison to the standard algorithm. However, despite these advances in \n\nperformance, the product between two symmetric matrices is still slower than the product \n\nbetween two standard (non-symmetric) matrices, especially with the increase of the \n\ndimensions of the involved matrices. The choice of the most appropriate container \n\ndepends then on how the matrix is used. If the purpose is merely to store data, then the \n\nsymmetric container is the best alternative, for its lower memory consumption. However, \n\nif  the symmetric matrix is very used in the product with other matrices or vectors, then it \n\nis more efficient to store it through a standard matrix container. \n\n  \n\n\n\n \n\n122 \n\n \n\n \n\nFig. 5.15 \u2013 Performance comparison of the product between two matrices. Source: own authorship. \n\n \n\n5.4 EBE Matrix \n\nThe element-by-element method consists of solving the linear system of equations in \n\na local basis with the element stiffness matrices, so that the assembly of the global \n\nstiffness matrix is no longer necessary. It means that, instead of a single, very large and \n\nalmost always sparse matrix, the EBE requires the manipulation of hundreds of thousands \n\n(or even millions) of small matrices. The computational performance of the EBE \n\nalgorithm is directly related to how these matrices are manipulated and managed. \n\nThe previously presented containers proved to be very important and efficient in the \n\nmathematical operations of the computations of the element stiffness matrices. They \n\ncould even be used directly in the EBE algorithm, through vectors of pointers to \n\ndynamically allocated matrices or vectors, for example. However, this would not be the \n\nmost suitable strategy. As each matrix dynamically allocates its own array, it would result \n\nin several arrays randomly allocated in memory, losing data contiguity. In addition, the \n\nimplemented algorithm would be extensive and difficult to understand. \n\n0.E+00\n\n5.E+03\n\n1.E+04\n\n2.E+04\n\n2.E+04\n\n3.E+04\n\n0 100 200 300 400 500 600 700 800 900 1000\n\nT\nim\n\ne\n (\n\nm\ns)\n\nMatrix dimension\n\nNon. Sym. Mat. Non. Sym. Mat. Blocked\n\nSym. Mat. - Stand. Alg. Sym. Mat. - Opt. Alg.\n\n\n\n \n\n123 \n\n \n\nIn this way, it was decided to implement a container exclusively to the EBE method, \n\nwhich ensures contiguous memory allocation and also encapsulates internal operations, \n\nmaking the code as concise as possible and easy to use. The term Block was defined in \n\nthis implementation as the set composed by one element stiffness matrix and one vector \n\nof integers that relates local degrees-of-freedom with the global basis. \n\nThe EBE Matrix container is created by specifying the global dimension and a vector \n\nof integers with the sizes from each block. Internally, it sums the sizes of each block and \n\ndynamically allocates a single large array, as illustrated in Fig. 5.16, ensuring thus, the \n\ncontiguous memory allocation. After that, the EBE Matrix is fulfilled with each of the \n\nblocks, using a block definition method. \n\n \n\n \n\nFig. 5.16 \u2013 One single large dynamically allocated array ensures the contiguous memory allocation. \n\nSource: own authorship. \n\n \n\nThe EBE Matrix object, Fig. 5.17, has four groups of properties: \n\n\u2022 Global Properties: they are related to the global aspect of the matrix; \n\n\u2022 Block Properties: properties related to or arrays of size equal to the number \n\nof blocks; \n\n\u2022 1D Properties: properties related to or arrays of size equal to the sum of the \n\ndimensions of the blocks; \n\n\u2022 2D Properties: properties related to or arrays of size equal to the sum of the \n\nsquare of dimensions of the blocks; \n\n \n\n\n\n \n\n124 \n\n \n\n \n\nFig. 5.17 \u2013 EBE Matrix object. Source: own authorship. \n\n \n\nThe global properties branch has the following items: \n\n\u2022 global_size_orig: it is the original size of the global matrix;  \n\n\u2022 global_size_cond: it is the final size of the global matrix after the removal of \n\nthe imposed degrees-of-freedom; \n\n\u2022 global_size_remo: it specifies how many degrees-of-freedom have been \n\nremoved; \n\n\u2022 corr_glob_dir and corr_glob_rev: the renumbering of the degrees-of-\n\nfreedom is necessary after the removal of the imposed ones; these two \n\nproperties are arrays of integers that correlates the original with the new \n\nordered d.o.f.s in direct and reverse way, respectively. \n\n \n\nThe block properties branch has the following items: \n\n\u2022 nb: the total number of blocks; \n\n\u2022 bk_siz_orig: an array of integers that stores the original sizes from each \n\nblock; \n\n\u2022 bk_siz_cond: an array of integers that stores the final sizes from each block \n\n(after the removal of the imposed degrees-of-freedom); \n\n\u2022 bk_ini_1D: an array of integers that stores the 1D initial position in memory \n\nfor each block, for direct indexing;   \n\n\u2022 bk_ini_2D: an array of integers that stores the 2D initial position in memory \n\nfor each block, for direct indexing;   \n\n \n\n\n\n \n\n125 \n\n \n\nThe 1D properties branch has the following items: \n\n\u2022 n1: the sum of dimensions of all blocks; \n\n\u2022 indexes: a dynamically allocated array of integers that stores for each of the \n\nlocal degrees-of-freedom their respective and correspondent global ones. \n\n\u2022 corr_local_dir and corr_local_rev: after the removal of the imposed d.o.f.s, \n\na local reordering is performed on each block. These arrays of integers store \n\nthe new ordering sequence in direct and reverse way, so that the reordering \n\ncan be undone in the future if desired. \n\n \n\nThe 2D properties branch has the following items: \n\n\u2022 n2: the sum of the square of the dimensions of all blocks; \n\n\u2022 p: a dynamically allocated array corresponding to the values of the \n\nstiffness matrices of each of the blocks. \n\n \n\nIn the finite element method, the imposed degrees-of-freedom need to be removed \n\nfrom the global stiffness matrix before the solution of the linear system, otherwise it \n\nwould result in null determinant, and it is still necessary in the EBE method. In order to \n\naccomplish this, the first procedure is to renumber all degree-of-freedom, shifting the \n\nimposed ones to the end of the queue, as illustrated in Fig. 5.18. \n\n \n\n \n\nFig. 5.18 \u2013 Global degrees-of-freedom renumbering, the imposed ones are shifted to the end of the queue. \n\nSource: own authorship. \n\n \n\nThe second procedure is to update the indexes from each block. And finally, a data \n\nrearrangement is performed for each block (including indexes and stiffness values), as \n\n\n\n \n\n126 \n\n \n\nshown in Fig. 5.19. It is important to note that this image is merely illustrative, the data \n\nis concentrated in the single allocated array, so that this rearrangement operation will act \n\nin the region that corresponds to the addressed block.  \n\n \n\n \n\nFig. 5.19 \u2013 Data rearrangement for the block, moving to the extremities the values corresponding to the \n\nimposed degrees-of-freedom. Source: own authorship. \n\n \n\nThis data structure of EBE Matrix container is responsible for storing all blocks in \n\nan organized pattern, allowing their efficient access and manipulation. Instead of a large \n\nnumber of objects, the implemented EBE-PCG algorithm receives only one object, which \n\nalready encapsulates and organizes all necessary data. \n\n\n\n \n\n127 \n\n \n\n Geometry and Mesh \n\nThis chapter presents the complete implementation and data structure in what \n\nconcerns geometry and mesh. \n\n \n\n6.1 Geometry \n\nThe development of the geometry data structure was inspired by the boundary \n\nrepresentation techniques from (STROUD, 2006). Obviously, since the objective of this \n\nwork is not the development of a complete CAD, but rather a specific analysis tool for \n\nflexible pipes, it was necessary to focus only on the essential data structure and methods. \n\n The geometry is subdivided into hierarchical levels, illustrated in Fig. 6.1. The \n\nhighest one consists of volumes, which are delimited by areas, which in turn are \n\ndelineated by lines, and, finally, points are the lowest level of the geometric hierarchy. \n\nFig. 6.2 exemplifies this hierarchy for a simple cube. In the next items, each of these \n\nlevels are presented in detail. \n\n \n\n \n\nFig. 6.1 \u2013 Hierarchical relations at the geometric level. Source: own authorship. \n\nGeometry\n\nVolumes\n\nAreas\n\nLines\n\nPoints\n\n\n\n \n\n128 \n\n \n\n  \n\n \n\nFig. 6.2 \u2013 Volume, area, line and point of a cube. Source: own authorship. \n\n \n\n6.1.1 Point \n\nThe point object, Fig. 6.3, is very simple to be represented, since it does not have any \n\nlength, area, volume or any other dimensional attribute other than its coordinate. \n\n \n\n \n\nFig. 6.3 \u2013 Point object. Source: own authorship. \n\n \n\nThe attributes of the Point are: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Coordinate: it is an object that encapsulates an array with the coordinates, \n\nand that converts and return the coordinates to some requested coordinate \n\nsystem (cartesian or cylindrical). \n\n\u2022 Selection Status: used for global selection of entities; \n\n\u2022 Node: a pointer that stores the address of the node attached to this point; \n\n\u2022 Mesh Status: used for parallel meshing, it checks whether the point already \n\nhas a node and, if not, only one thread proceeds to meshing. \n\n \n\n\n\n \n\n129 \n\n \n\n6.1.2 Line \n\nThe Line object is illustrated in Fig. 6.4 and consists of: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Length: the line length; \n\n\u2022 Curve: it is the geometric curve that defines the line (straight, arc, splines, \n\netc.); \n\n\u2022 Half Lines: the positive and negative half lines; \n\n\u2022 Points: a vector of pointers to the points; \n\n\u2022 Mesh: vectors of pointers to nodes, edges and elements; \n\n\u2022 Mesh Status: used for parallel meshing, it checks whether the line is already \n\nmeshed and for permission to proceed. \n\n \n\n \n\nFig. 6.4 \u2013 Abstract line object. Source: own authorship. \n\n \n\nThe curve is responsible for the geometric definition of the line. Polymorphism was \n\nemployed to implement the relationships represented in Fig. 6.5. As the name suggests, \n\nthe common lines are the most used, since they are composed of straight, arc and quadratic \n\n(interpolated with second order isoparametric shape functions) curves. Primitive helical \n\ncurves were also necessary, since they are very used to construct the tendons of the tensile \n\narmor layers. Due to the way that it was implemented, the code is also ready to receive \n\nmore complex curves, such as BSPLINES or NURBS. The specific definitions for each \n\ntype of curve are encapsulated. To the line object, it does not matter how simple or \n\ncomplex the curve definition is, whether it is defined by just two points or by an \n\ninterpolation of several, it is all encapsulated in the curve object and the polymorphism \n\nallows the manipulation between the various derived types. \n\n\n\n \n\n130 \n\n \n\n  \n\n \n\nFig. 6.5 \u2013 Class hierarchy from curve. Source: own authorship. \n\n1: not implemented, but the code is ready to receive it. \n\n \n\nHalf-Line is an adaptation of a well-defined method in the literature called \u201cHalf-\n\nEdges\u201d. The change in name is justified by the fact that, in this case, the term \u201cedges\u201d is \n\nemployed in the mesh context. Each line possesses a pair of half-lines, as exemplified in \n\nFig. 6.6 for a straight line. The purposes of half-lines are: to define two orientations to a \n\nline, allowing its manipulation regardless of the orientation in which it was created; to \n\npoint to other half-lines, creating well defined paths when connecting two or more lines, \n\nas illustrated in Fig. 6.7. \n\n \n\n \n\nFig. 6.6 \u2013 Half-lines indexing for a straight line. Source: own authorship. \n\nCurve\n\nCommon\n\nStraight Arc Quadratic\n\nPrimitive\n\nHelix\n\nAdvanced Curves \u00b9\n(BSPLINES, NURBS)\n\n\n\n \n\n131 \n\n \n\n \n\n \n\nFig. 6.7 \u2013 Indexing changes when connecting two lines. Source: own authorship. \n\n \n\nThe half-line object is shown in Fig. 6.8. In addition to the conventional twin, \n\nprevious and next half-lines indexing, the implementation also incorporated geometric \n\nand mesh information, stored in the form of vectors of pointers to the objects. In this case, \n\nthe positive and negative half-lines of the same line are differentiated by the fact that their \n\nvectors of pointers are defined in a reverse order in relation to the same from the other \n\nhalf-line, maintaining coherence in orientation and allowing the immediate iteration in \n\nboth directions of the line. \n\n \n\n \n\nFig. 6.8 \u2013 Half-line object. Source: own authorship. \n\n \n\n\n\n \n\n132 \n\n \n\n6.1.3 Area \n\nThe Area object, Fig. 6.9, consists of: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Area: a double that stores the area value; \n\n\u2022 Surface: it is the geometric surface that defines the area; \n\n\u2022 Half Area: the positive and negative half areas (defined next); \n\n\u2022 Geometry: pointers to the points, lines and half-lines; \n\n\u2022 Mesh: vectors of pointers to nodes, edges, faces and elements; \n\n\u2022 Mesh Status: used for parallel meshing, it checks whether the area is already \n\nmeshed and for permission to proceed. \n\n \n\n \n\nFig. 6.9 \u2013 Area object. Source: own authorship. \n\n \n\nAgain, polymorphism was employed to implement the surfaces, as illustrated in Fig. \n\n6.10. A flat surface is created when the area is composed exclusively of straight lines, \n\notherwise it will be a quadratic surface, i.e., interpolated with the quadratic isoparametric \n\nshape functions. Until the present moment, the implementation allows only triangular and \n\nrectangular shapes, without any voids. The development of area generic shapes is a very \n\ncomplex task, that requires a lot of verifications, and may be included in the future if \n\nnecessary, as well as more complex surfaces. \n\n \n\n\n\n \n\n133 \n\n \n\n \n\nFig. 6.10 \u2013 Class hierarchy from Area. Source: own authorship. \n\n1: not implemented, but the code is ready to receive it. \n\n \n\nHalf-Area is an extrapolation of the concept of Half-Line. Each half-area is defined \n\nby a counter-clock wise, closed and continuously connected set of half-lines, as illustrated \n\nin Fig. 6.11. In this case, a rectangular area is given by the lines L1, L2, L3 and L4. As \n\nthe lines L2 and L4 were defined with opposite orientation, the positive half-area was \n\ndefined with their respective negative half-lines, maintaining thus the orientation \n\ncoherence. The negative half-area is given by the twins of the half-lines that defines the \n\npositive half-area, and, by observing this image from the other side, it is concluded that \n\nthe counter-clockwise orientation is also maintained for the negative half-area. When \n\ncreating the area, the compatibility and connectivity between the lines are easily checked \n\nby verifying if the given lines share the correspondent points. \n\n \n\n \n\nFig. 6.11 \u2013 Half-Area. Source: own authorship. \n\n \n\nThe half-area concept is very useful for constructing the geometries, since each pair \n\ncorresponds to a side of the area, and also for finite element applications, since this \n\norientation is important for shell elements, for example. The Half-Area object, Fig. 6.12, \n\nSurface\n\nFlat / Quadratic\n\nTriangle Rectangle\n\nAdvanced Surfaces\u00b9\n\n(BSPLINES, \nNURBS)\n\n\n\n \n\n134 \n\n \n\nbesides the geometric links, also stores pointers to the mesh entities attached to the area. \n\nThis direction indexing system makes the selection process for contact applications a very \n\nsimple task. \n\n \n\n \n\nFig. 6.12 \u2013 Half-Area object. Source: own authorship. \n\n \n\n6.1.4 Volume \n\nSince there are still no solid finite macroelements for modelling flexible pipes, \n\nvolumetric entities have not been developed in this work. \n\n \n\n6.2 Mesh \n\nThe mesh hierarchical levels are represented in Fig. 6.13. Cells are employed for \n\nsolid finite elements. Faces are used for shells or solids of revolution, and also in surface \n\ncontact applications. Edges are utilized for beam elements and in contacts involving lines. \n\nNodes are the basis of the finite element and are also employed in node-to-node contact \n\nelements. In the next items, each of these levels are presented in detail. \n\n \n\n\n\n \n\n135 \n\n \n\n \n\nFig. 6.13 \u2013 Hierarchical relations at mesh level. Source: own authorship. \n\n \n\n6.2.1 Node \n\nThe Node object is illustrated in Fig. 6.14 and consists of: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Order: an integer the stores the order of the node (for standard nodes it is \n\nalways equals to zero); \n\n\u2022 Node Type: an enumerator that specifies if the node is of standard of Fourier \n\ntype; \n\n\u2022 Nr of DOFs: an integer that stores the total number of degrees-of-freedom; \n\n\u2022 DOF indexes: a vector of integer with the global values for each local degree-\n\nof-freedom; \n\n\u2022 DOF statuses: a vector of enumerators that specifies the status from each \n\nlocal degree-of-freedom (free, imposed, etc.); \n\n\u2022 DOF values: a series of vectors that stores important values of the nodal \n\ndegrees-of-freedom, such as initial displacements, applied loads, etc. \n\n \n\nMesh\n\nCells\n\nFaces\n\nEdges\n\nNodes\n\n\n\n \n\n136 \n\n \n\n \n\nFig. 6.14 \u2013 Node object. Source: own authorship. \n\n \n\nAs shown in Fig. 6.15, polymorphism was employed to derive the abstract node class \n\ninto the Standard and Fourier classes, so that the program is able to handle and manipulate \n\nthese two types of nodes without major problems. \n\n \n\n \n\nFig. 6.15 \u2013 Node polymorphism. Source: own authorship. \n\n \n\n6.2.2 Edge \n\nThe Edge object, Fig. 6.16, consists of: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Edge Order: an enumerator that specifies if the edge is linear or quadratic; \n\n\u2022 Half-Edges: the positive and negative half-edges from this edge; \n\n\u2022 Nodes: two nodes, in the linear case, or three, in the quadratic one; \n\n\u2022 Selection Status: used for global selection of entities. \n\n \n\nNode\n\nStandard Fourier\n\n\n\n \n\n137 \n\n \n\n \n\nFig. 6.16 \u2013 Edge object. Source: own authorship. \n\n \n\nAs illustrated in Fig. 6.17, linear and quadratic edges can be created. Higher-order \n\nedges can be included in the future if necessary. \n\n \n\n \n\nFig. 6.17 \u2013 Linear and quadratic edges. Source: own authorship. \n\n \n\nHalf-Edges act very similar to the half-lines, since their purpose is justified by \n\norientation and indexing reasons. \n\n \n\n6.2.3 Face \n\nThe faces are used to mesh areas, being directly applied in FEM for shell and solid \n\nof revolution elements. They are also used to form the cells, which are then applied for \n\nsolid elements.  A face is defined by a continuous and closed set of edges. As illustrated \n\nin Fig. 6.18, linear and quadratic versions of the triangular and rectangular shaped faces \n\nwere implemented in PipeFEM, which is enough to cover most of the shape functions \n\nused for finite elements.  \n\n \n\n\n\n \n\n138 \n\n \n\n \n\nFig. 6.18 \u2013 Linear and quadratic versions of the triangular and rectangular shaped faces. Source: own \n\nauthorship. \n\n \n\nThe Face object is illustrated in Fig. 6.19 and consists of: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Edge Order: an enumerator that specifies if the face is linear or quadratic. \n\nFaces with mixed edge order are not possible; \n\n\u2022 Face Type: specifies whether the face is triangular or quadratic; \n\n\u2022 Half-Faces: the positive and negative half faces (defined next); \n\n\u2022 Nodes: vector of pointers to the nodes attached to this face; \n\n\u2022 Edges: vector of pointers to the edges attached to this face; \n\n\u2022 Half-Edges: the positive and negative half-edges; \n\n\u2022 Selection Status: used for global selection of entities. \n\n \n\n \n\nFig. 6.19 \u2013 Face object. Source: own authorship. \n\n \n\nHalf-faces are very similar to the half-areas previously presented. They are very \n\nuseful for selecting the sets of nodes and edges in the already correct sequence, \n\n\n\n \n\n139 \n\n \n\neliminating the large amount of verifications that would be necessary for a not indexed \n\ndata structure. \n\n \n\n6.2.4 Cell \n\nTetrahedral and hexahedral versions of the cells were implemented in PipeFEM. \n\nHowever, since there are still no solid finite macroelements for modelling flexible pipes, \n\nthe cell objects have not been completely developed. \n\n \n\n6.3 Parallel Mesh Generation \n\nPipeFEM provides a series of methods for mesh generation, in which the user must \n\nspecify the input parameters, such the list of geometric entities to be meshed, element \n\ntypes, materials and sections. Then, the meshing procedure follows the sequence of steps \n\nfrom Fig. 6.20. The first one consists of a series of compatibility verifications, which can \n\nbe a check of the consistency of the input data (for example, whether the specified \n\nmaterial exists or not) or if the specified element really applies to the type of geometry \n\nthat is being meshed. If any incompatibility is found, the method is aborted, a message is \n\nprinted to the user and no elements are created. Otherwise, it proceeds to the next step, \n\nwhich is a geometric meshing, in this case, the items of the aforementioned data structure \n\n(nodes, edges and faces). The last step consists in creating the finite elements and \n\nassociating them with their geometric mesh (edges for beam elements and faces for solids \n\nof revolution, for example), resulting then in the final meshed geometry. \n\n \n\n \n\nFig. 6.20 \u2013 Meshing processes. Source: own authorship. \n\n \n\nThe geometric meshing is parallelized with OpenMP, a set of compiler directives and \n\nroutines for shared memory multiprocessing programming in C++. A cascade \n\nMeshless \nGeometry\n\nCompatibility \nVerifications\n\nGeometric \nMeshing\n\nFinite Element \nCreation\n\nMeshed \nGeometry\n\n\n\n \n\n140 \n\n \n\nmethodology was developed in order to avoid conflicts between threads and to allow the \n\nparallel accomplishment of this task. This cascade methodology is based in the \n\nhierarchical levels of the geometry, Fig. 6.21. Before a level starts the generation of its \n\nown geometric mesh, it must certify that the immediately below level is already meshed, \n\nas illustrated in Fig. 6.22. \n\n \n\n \n\nFig. 6.21 \u2013 Hierarchical levels of geometry and mesh and their relationships. Source: own authorship. \n\n \n\n \n\nFig. 6.22 \u2013 Cascade methodology of the geometric meshing. Source: own authorship. \n\n \n\nThis cascade methodology ensures that the entity creation always starts from the \n\nlowest level that is not meshed yet. When two different areas share the same line, for \n\n\n\n \n\n141 \n\n \n\nexample, and the mesh operation is performed in parallel, it may occur the situation in \n\nwhich two or more threads try to mesh the same line more than once, and worst, at the \n\nsame time. In this case, if the implementation is not correctly synchronized, it would result \n\nin duplicate and poorly connected meshes. This problem was solved with the inclusion of \n\naforementioned \u201cMesh Status\u201d object for each geometric entity of the program. As the \n\nname suggests, it stores the information of whether the entity has already been meshed or \n\nnot. Right at the beginning of the method it is consulted and, if the mesh already exists, \n\nnothing new is created. In addition, the Mesh Status also works similarly to a lock. When \n\ntwo or more threads simultaneously check the inexistence of the mesh and try to create \n\nit, only one thread receives the permission to continue and the others remain idle until the \n\noperation is completed. \n\n \n\n6.4 Indexed Data Structure \n\nThe hierarchical levels from Geometry (Fig. 6.1) and Mesh (Fig. 6.13) enable a high \n\ndegree of modularization of the data structure. Volumes are made of areas, which in turn \n\nare delimited by lines, which are defined by points. Analogously, cells are composed of \n\nfaces, which are delimited by edges, which are defined by nodes.  \n\nIn addition to this, as it can be seen in the descriptions of the objects along items 6.1 \n\nand 6.2, every entity can directly access all other lower-level entities that belong to it. In \n\nthis case, the direct accesses are done via pointers, which stores the memory addresses of \n\nthe objects in question, conferring high computational performance. The geometry \n\ncreation methods are responsible for the initialization of the pointers related to indexing \n\nbetween different hierarchical levels of geometry. The meshing methods are responsible \n\nfor indexing between geometry and mesh levels, besides the indexing between different \n\nmesh hierarchical levels. \n\nThe combination of these two characteristics, modularization and direct access, \n\nresulted in a fully integrated and indexed data structure. One of the main advantages of \n\nthis relies in the ease of selecting items. As illustrated in Fig. 6.23, it is a trivial task to \n\nselect specific nodes, edges or faces from a meshed area. Therefore, PipeFEM presents \n\nthe same facilities and features found in the multi-purpose finite element package \n\nANSYS\u00ae for items selections, which are extremely useful for contact and load \n\napplications, and, at the same time, it has an internally very organized and stratified data \n\n\n\n \n\n142 \n\n \n\nstructure that takes advantage of the computational benefits of the direct indexing and \n\nthat facilitates the implementation and manipulation of three-dimensional finite elements. \n\n \n\n \n\n \n\nFig. 6.23 \u2013 Indexed data-structure enables efficient entity selections. \n\n\n\n \n\n143 \n\n \n\n Layer and Pipe \n\nDue to its generic nature, modeling a flexible pipe only with the methods and \n\nresources provided by the geometry and mesh data structure from the previous chapter \n\nwould be as laborious as modeling the pipe in a multi-purpose finite element package, \n\nsuch as ANSYS\u00ae or ABAQUS\u00ae. In order to circumvent this problem, by exploring the \n\nencapsulations levels provided by the C++ language, a specific methodology for the \n\nhierarchical representation and modelling of a flexible pipe was developed and \n\nimplemented in PipeFEM. Geometry, mesh, loads and contact generations are \n\nencapsulated and automatized, so that, given a set of user-defined parameters, only simple \n\ninstructions are necessary to construct a model of flexible pipe and simulate it.    \n\nIn this methodology, two new hierarchical levels, Layer and Pipe, are introduced to \n\nthe already existing ones from Geometry and Mesh, as illustrated in Fig. 7.1.  \n\n \n\n \n\nFig. 7.1 \u2013 Global hierarchical level. Source: own authorship. \n\n \n\nThe pipe is composed of several layers. Each of these layers have their own \n\ngeometry, as well as element meshes attached to them. This is exemplified in Fig. 7.2 for \n\na tensile armor layer. In this case, the geometry consists of a user-define number of lines, \n\nthat are meshed with the helical beam elements. \n\nPipe\n\nLayers\n\nGeometry\n\nMesh\n\n\n\n \n\n144 \n\n \n\n \n\nFig. 7.2 \u2013 Example of the hierarchical levels application for a layer of tensile armors. Source: own \n\nauthorship. \n\n \n\n7.1 Layer \n\nAs already mentioned, Layer is the second in global hierarchy. In PipeFEM, it were \n\nimplemented pre-defined types of layers, such as the cylindrical and tensile armor layers. \n\nFor these cases, all geometry and mesh generation is encapsulated and automated, so that \n\nit can be done with simple instructions. As shown in Fig. 7.3, each layer has a material, \n\ndefined by the user during its creation. The nature of the geometry and mesh depend on \n\nhow the layer is modeled and which elements it utilizes. Layer self-contacts were included \n\nin this hierarchy, since it could occur for the interlocked layers. In this case, the layer \n\nobject must be able to verify and treat correctly its occurrence. However, since there are \n\nstill no macroelements for modelling these layers, self-contacts are not exploited in this \n\nversion of the program. \n\n \n\n\n\n \n\n145 \n\n \n\n \n\nFig. 7.3 \u2013 Layer hierarchy. Source: own authorship. *Not explored at the current version.  \n\n \n\nThe layer interfaces are illustrated in Fig. 7.4. These interfaces are linked to the \n\ngeometry and mesh of the layers, thus allowing a direct access to load applications and \n\ncontact definitions. The bottom and top layer interfaces are responsible for the traction, \n\ncompression, torsion and bending loads. The outer and internal interfaces are employed \n\nmostly for contacts between layers, except when they coincide with the inner and outer \n\nside of the tube, when they are used for pressure application. \n\n \n\n  \n\nFig. 7.4 \u2013 Layer interfaces. Source: own authorship \n\n \n\nThe Layer object, Fig. 7.5, consists of: \n\n\u2022 ID: an integer that stores its identification; \n\n\u2022 Layer Type: an enumerator that specifies the type of the layer; \n\n\u2022 Geometry: pointers and indexing to the attached geometry; \n\n\u2022 Mesh: pointer and indexing to the attached mesh; \n\nLayer\n\nMaterial Geometry Mesh\nLayer \n\nInterfaces\nSelf \n\nContacts*\n\n\n\n \n\n146 \n\n \n\n\u2022 Layer Interfaces: the interfaces described in Chapter 4; \n\n\u2022 Selection Status: used for global selection of entities. \n\n \n\n \n\nFig. 7.5 \u2013 Layer object. Source: own authorship. \n\n \n\nPolymorphism was employed to derive an abstract layer class into derived ones, \n\ncorresponding to the layer types which can be modeled so far, as illustrated in Fig. 7.6. \n\nEach of the derived classes stores specific parameters, such as layer length, number of \n\ntendons, lay angle, layer thickness, etc. \n\n \n\n \n\nFig. 7.6 \u2013 Layer polymorphism. Source: own authorship. \n\n \n\n \n\n7.2 Pipe \n\nPipe represents the highest level of hierarchy and is the main object when creating a \n\nmodel of flexible pipe. As shown in Fig. 7.7, it is responsible for the definition and storage \n\nof the layers. Through the polymorphism from C++ language, the program is able to \n\nmanipulate different pre-defined layer types. The pipe object is also responsible of the \n\nLayer\n\nTensile \nArmor\n\nHelical \nBeam\n\nCylindrical\n\nFourier \nCylinder\n\n\n\n \n\n147 \n\n \n\ncontact definitions related to the layers. Through a simple instruction, the user just need \n\nto tell the program that layer A is in contact with layer B, and internally all necessary \n\ncontact pairs are created. \n\n \n\n \n\nFig. 7.7 \u2013 Pipe object. Source: own authorship. \n\n \n\nThe pipe interfaces, shown in Fig. 7.8, were created to facilitate load applications. \n\nThe two end extremities of the pipe are represented by the Bottom and Top interfaces, \n\nwhich, in turn, are linked to the respective Bottom and Top interfaces from all layers. \n\nWhen a compression load is applied at the Top interface, for instance, it is automatically \n\ntransmitted to all respective interfaces of layer level. The Outer and Internal interfaces \n\nare used for external and internal pressure loads, respectively. The definitions of the \n\ninnermost and the outermost layers are not yet automated, they need to be done by the \n\nuser. By comparing the layer diameters, these interfaces could be automatically \n\ndetermined, a possible upgrade for PipeFEM in the future. \n\n \n\n \nFig. 7.8 \u2013 Pipe interfaces hierarchy. *Not yet implemented. Source: own authorship. \n\n  \n\nPipe\n\nLayers\nContacts \nbetween \n\nlayers\n\nPipe \nInterfaces\n\nApplicable \n\nLoads\n\nLayer \n\nInterfaces\n\nPipe \n\nInterfaces\n\nPipe Interfaces\n\nBottom\n\nBottoms of all \nlayers\n\nTraction, \ncompression, \ntorsion* and \n\nbending*\n\nTop\n\nTops of all layers\n\nTraction, \ncompression, \ntorsion* and \n\nbending*\n\nOuter\n\nOuter of the \noutermost layer\n\nExternal pressure\n\nInternal\n\nInternal of the \ninnermost layer \n\nInternal pressure\n\n\n\n \n\n148 \n\n \n\n \n\n7.3 Contact Between Layers \n\nWith the finite macroelements developed so far, two situations of contact between \n\nlayers are possible, as shown in Fig. 7.9. \n\n \n\n \n\nFig. 7.9 \u2013 Possibilities of contact between layers. Source: own authorship. \n\n \n\nIn order to create the contact between two layers, the user only needs to specify the \n\ncontact behavior (bonded or frictional), the layers and their respective interfaces that will \n\nbe in contact (internal or external), so that PipeFEM automatically detects the contact \n\ncase (helix-to-helix or helix-to-cylinder) and creates in parallel all the contact elements \n\nbetween the two specified layers. \n\nA specific logics of contact detection for helix-to-helix contacts was developed by \n\n(TONI, F.G., 2014). This algorithm was implemented, optimized and parallelized in \n\nPipeFEM, reducing the total number of operations and the processing time. \n\n \n\nLayer-to-Layer\n\nHelix-to-Helix Helix-to-Cylinder\n\n\n\n \n\n149 \n\n \n\n Solver \n\nSolver is responsible for the numerical solution of the finite element model. It \n\nreceives everything that has been defined up to the moment prior to its use (such as, \n\nelement meshes and boundary conditions, among others), and organizes it in a structured \n\nway to mount and compute the linear system of equations. In general, the solver demands \n\nmost of the processing time of the simulation due to the high number of mathematical \n\noperations that must be performed by it. Therefore, the overall performance of the \n\nprogram is strongly related to the efficiency of the solver. \n\nIn PipeFEM, the model data is transmitted to the solver fully encapsulated in the \n\n\u201cdatabase\u201d object from Fig. 8.1. Basically, it consists of a structured container of pointers \n\nto all entities that comprise the model. It also facilitates data manipulation, by allowing \n\nthe selection of specific items or the iteration along all items of a desired type. In addition, \n\nthe database object provides all necessary statistics of the model, such as the total number \n\nof nodes or elements. \n\n \n\n \n\nFig. 8.1 \u2013 The Database object  Source: own authorship. \n\n \n\nWith all model data at hand, the solver then follows the flowchart illustrated in Fig. \n\n8.2. Aiming computational performance and efficiency, the parallelism of the solution \n\nwas explored whenever possible in all these steps.  \n\n \n\n\n\n \n\n150 \n\n \n\n \n\nFig. 8.2 \u2013 Solver flowchart. Source: own authorship. \n\n \n\nThe first step consists of the numbering of the degrees-of-freedom, which, in turn, \n\nare given by the nodes of the model. By choosing to perform this numbering operation \n\nduring the solution, instead of in the pre-processing stage, when the nodes are created, it \n\nis obtained more flexibility for their creation or removal in parallel. \n\nTable 8.1 shows the first developed logics to accomplish this numbering task. It \n\nbegins with the allocation of the temporary vector \u201cinitial_dof_indexes\u201d of size equal to \n\nthe total number of nodes. The purpose of this vector is to store the initial values of \n\ndegree-of-freedom (to be defined) for each node of the model. Then, a sequential iteration \n\nis performed across all nodes (unfortunately it cannot be parallelized) to update the values \n\nof \u201cinitial_dof_indexes\u201d using the method \u201cNrDOFs()\u201d, that returns the total number of \n\nd.o.f.s. from the selected node, including all higher-order d.o.f.s if the node is Fourier \n\nexpanded, and is given by the equation: \n\nStep 6\n\nEBE PCG Algorithm\n\nStep 5\n\nRemoval of Imposed Degrees-of-Freedom\n\nStep 4\n\nGlobal Arrays ofLoads, Initial Conditions and Statuses Computation\n\nStep 3\n\nStiffness Matrices Computation\n\nStep 2\n\nGlobal Blocks Numering\n\nStep 1\n\nGlobal Degres-of-Freedom Numbering\n\n\n\n \n\n151 \n\n \n\n \n\n ?????? = {\n\n?????? ?? ????????\n\n?????? (2 .????? + 1) ?? ???????\n  Eq. 8.1 \n\n \n\nwhere ?????? is the number of degrees-of-freedom intrinsic to the node (defined by the \n\ntype of element that allocated it) and ????? is the Fourier expansion order. Once \n\ndetermined the initial d.o.f. values from all nodes, the remaining values share no \n\ndependency and can be filled in parallel. Lastly, the total number of degrees of freedom \n\nis computed. \n\n \n\nTable 8.1 \u2013 First implementation of the d.o.f.s numbering algorithm. Source: own authorship. \n\n \n\n \n// Vector that stores the first d.o.f. value from each node of the model \n\n1. Vector<int> initial_dof_indexes(database->nodes.size()); \n \n\n2. initial_dof_indexes[0] = 0; // The first d.o.f of the first node is Zero \n \n// Iteration over all nodes to define the initial_dof_indexes \n\n3. for (int i = 0; i &lt;database->nodes.size() - 1; i++) \n { \n          // NrDOFs() returns the total number of d.o.f.s from the node \n          int inc = database->nodes[i]->NrDOFs(); \n          initial_dof_indexes[i + 1] = initial_dof_indexes[i] + inc; \n  } \n\n \n// Parallel iteration to fulfill the remaining d.o.f.s \n\n4. #pragma omp parallel for num_threads(nrThreads) \nfor (int i = 0; i &lt;database->nodes.size(); i++) \n\n { \n          database->nodes[i]->AssignGlobalDOFValues(initial_dof_indexes[i]); \n\n} \n\n \n       // Total number of degrees-of-freedom \n\n5. int  n = initial_dof_indexes.last() + database->nodes.last()->NrDOFs(); \n \n\n \n\nAlthough the global matrix is eliminated in the EBE method, its sparsity pattern \n\nremains valid and may influence the convergence rate of the iterative methods of linear \n\nsystem solution. The algorithm from Table 8.1 is very efficient in computational terms. \n\nHowever, it has a weak point, that lies the fact that the numbering pattern is exclusively \n\ndetermined by the sequence with which the nodes are added to the database. Since the \n\nmesh is performed in parallel, this nodal addition to the database is random and follows \n\n\n\n \n\n152 \n\n \n\nno predefined logical sequence, what generates a sparsity pattern of higher bandwidth and \n\nmore dispersed than the ideal. Besides that, all d.o.f. values of the same node are defined \n\nin a single pass (step 4 from Table 8.1), which is not the best procedure for the Fourier \n\nnodes. For them, ideally, the numbering process should be incremented by Fourier order \n\nvalue, i.e., it should define all d.o.f.s relative to the zero order, then all of them relative to \n\nthe first order, and so on. \n\nThese questions about the first implementation motivated the development of a \n\nsecond version of the numbering logics, shown in Table 8.2. It takes advantage of the \n\ngeometric entities to perform the numbering in a more structured and deterministic way. \n\nThe sparsity pattern obtained with this new logic is the same from MacroFEM. \n\n \n\n\n\n \n\n153 \n\n \n\nTable 8.2 \u2013 Second implementation of the d.o.f.s numbering algorithm. ?????: maximum Fourier order. \n\n \n\n1. For each area of the model: \n\n1.1. Iterates over all nodes of the current area and gets the ????? \n\n1.2. For ???? = 0,1,2,\u2026,????? \n\n1.2.1. For each node of the current order and area: \n\n1.2.1.1. Verify whether the node is already numbered or not \n\n1.2.1.2. If not, assign d.o.f. values to the specified order \n\n1.2.1.3. Increments the total number of d.o.f.s of the model \n\n1.3. Set all nodes of the current area as already numbered \n\n \n\n2. For each line of the model: \n\n2.1. Iterates over all nodes of the current line and gets the ?????  \n\n2.2. For ???? = 0,1,2,\u2026,????? \n\n2.2.1. For each node of the current order and line: \n\n2.2.1.1. Verify whether the node is already numbered or not \n\n2.2.1.2. If not, assign d.o.f. values to the specified order \n\n2.2.1.3. Increments the total number of d.o.f.s of the model \n\n2.3. Set all nodes of the current line as already numbered \n\n \n\n3. For each node of the model: \n\n3.1. Iterates over all nodes and gets the ????? \n\n3.2. For ???? = 0,1,2,\u2026,????? \n\n3.2.1. For each node of the model: \n\n3.2.1.1. Verify whether the node is already numbered or not \n\n3.2.1.2. If not, assign d.o.f. values to the specified order \n\n3.2.1.3. Increments the total number of d.o.f.s of the model \n\n3.3. Set all nodes as already numbered \n\n \n\nSource: own authorship. \n\n \n\nThis second implementation increases the number of operations, since it requires \n\nadditional iteration passes. However, as these iterations are very fast in modern \n\nprocessors, the impact on the simulation time was negligible. It is also important to note \n\n\n\n \n\n154 \n\n \n\nthat, despite the better sparsity pattern, the numbering sequence of this second \n\nimplementation is still not optimum. The optimality is achieved with bandwidth \n\noptimization algorithms, a feature that can be included in future versions of this analysis \n\ntool if necessary. \n\nThe second step of the flowchart from Fig. 8.1 consists in the numbering of the blocks \n\nof the model, which, in this case, is the same as the numbering of the element stiffness \n\nmatrices. The term block was defined in the EBE Matrix (item 5.4) and, in this work, it \n\ncomprises not only the element stiffness matrix, but also the local-global indexing array.  \n\nThe main reason for numbering the blocks is explained by the fact that the Fourier \n\nelements (such as Solids of Revolution) possess more than one stiffness matrix, one for \n\neach expanded order value, more exactly. Therefore, it is important to number these \n\nblocks so that the EBE Matrix can be defined and fulfilled in parallel. The procedure used \n\nin the numbering of the blocks is presented in Table 8.3, and is analogous to the one from \n\nTable 8.1. \n\nAnother important feature of this algorithm, is the definition of the vector parameter \n\ncalled \u201cBlockDimensions\u201d. It consists of a vector of integers, that stores the dimension of \n\neach of blocks that comprises the model. The BlockDimensions is directly used to create \n\nthe EBE Matrix object, that employs the values specified in this vector to allocate the \n\nproper amount of memory to store all blocks. \n\n\n\n \n\n155 \n\n \n\nTable 8.3 \u2013 Blocks numbering algorithm. \n\n \n// Vector that stores the first block value from each element of the model \n\n1. Vector<int> element_initial_block(database->nodes.size()); \n \n// The first block of the first element is Zero \n\n2. element_initial_block[0] = 0;  \n \n// Iteration over all element to define the element_initial_block \n\n3. for (int I = 0; I &lt;database->elements.size() \u2013 1; i++) \n{ \n  // NumberOfBlockMatrices returns the total number of blocks \n  int inc = database->elements[i]->NumberOfBlockMatrices(); \n  element_initial_block[I + 1] = element_initial_block[i] + inc; \n} \n\n \n// Parallel iteration to fulfill the remaining blocks \n\n4. #pragma omp parallel for num_threads(nrThreads) \nfor (int I = 0; I &lt;database->elements.size(); i++) \n{ \n   int val = element_initial_block[i]; \n   database->elements[i]SetInitialBlockNumber(val); \n} \n\n \n// nb: total number of blocks \n\n5. int inc = database->elements.last()->NumberOfBlockMatrices(); \nint nb = element_initial_block.last() + inc; \n \n// Block Dimensions \u2013 Necessary for Allocation of the EBE Matrix \n\n6. Vector<int> BlockDimensions(nb); \n#pragma omp parallel for num_threads(nrThreads) \nfor (int I = 0; I &lt;database->elements.size(); i++) \n{ \n for (int j = 0; j &lt;database->elements[i]->NumberOfBlockMatrices(); j++) \n { \n    int id = element_initial_block_id[i] + j; // ID of the block \n    BlockDimensions[id] = database->elements[i]->BlockSize(j); \n } \n} \n\n  \n\nSource: own authorship. \n\n \n\nThe third step of the flowchart from Fig. 8.1 consists in the allocation EBE Matrix \n\nand the parallel computation of all element stiffness matrices. As the block numbers have \n\nalready been fully mapped and the BlockDimensions vector was defined in the previous \n\nstep, all necessary memory is pre-allocated through the EBE Matrix object and the \n\nparallelization is trivial. The implemented algorithm is shown in Table 8.4. \n\n \n\n\n\n \n\n156 \n\n \n\nTable 8.4 \u2013 EBE Matrix allocation and parallel computation of the element stiffness matrices. \n\n \n\n// EBE Matrix Allocation \n\nLAP::Containers::Parallel::EBE::EbeMatrix* K = new \n\n LAP::Containers::Parallel::EBE::EbeMatrix(n, nrThreads, BlockDimensions); \n\n \n\n// Parallel Element Stiffness Matrices Computation \n\n#pragma omp parallel for num_threads(nrThreads) \nfor (int i = 0; i &lt;database->elements.size(); i++) \n{ \n  for (int j = 0; j &lt;database->elements[i]->NumberOfBlockMatrices(); j++) \n  { \n    // Block ID \n    int id = element_initial_block_id[i] + j; \n \n    // Vector of integers, the indexation between local and global basis \n    Vector<int> indexes = database->elements[i]->Indexes(j); \n \n    // The Element Stiffness Matrix \n    SymMatrix<double> stiffness = database->elements[i]->StiffnessMatrix(j); \n \n    // Block Definition \n    K->DefineBlock(id, indexes, stiffness); \n  } \n\n} \n\n \n\nSource: own authorship. \n\n \n\nThe fourth step of flowchart from Fig. 8.1 consists in the computations of the global \n\narrays of loads, initial conditions and d.o.f. statuses. Despite eliminating the global \n\nstiffness matrix, the EBE method still requires the aforementioned global arrays.  \n\nAs the name suggests, the global array of loads is a dynamically allocated array that \n\nstores the final external loads applied to all degrees-of-freedom. The term final means \n\nthat it can be the result of a single load application, a combination of various applications \n\nor no loading at all (in this case, equals to zero). The array of initial conditions and the \n\narray of d.o.f.s statuses are intrinsically related to each other. When a degree-of-freedom \n\nis fixed or imposed, an initial value must be specified, zero if it is constrained or another \n\nvalue if an imposed displacement is applied, for example. \n\nUntil this portion of the implementation, these global data are contained exclusively \n\nwithin the nodes. They can be accessed, but only indirectly, through the pointers to the \n\nnodes given by the database. By organizing these data in the form of global arrays, the \n\nmanipulation becomes direct and much more efficient. Table 8.5 shows the logics of the \n\nimplemented algorithm. \n\n\n\n \n\n157 \n\n \n\n \n\nTable 8.5 \u2013 Logics of computation of the global arrays of loads, initial conditions and d.o.f. statuses.  \n\n \n\n1. Dynamically allocation of the arrays \n\n2. In parallel, for each node of the database: \n\n2.1. Allocates a local temporary vector of statuses with the values gathered from \n\nthe nodes (it remains the same, regardless of the Fourier expansion order) \n\n2.2. For ???? = 0,1,2,\u2026,????? (maximum Fourier order) \n\n2.2.1. For each degree-of-freedom of the specific order and node: \n\n2.2.1.1. Sets the loads \n\n2.2.1.2. Sets the initial conditions \n\n2.2.1.3. Sets the statuses \n\n  \n\nSource: own authorship. \n\n \n\nIn the finite element method, the imposed degrees-of-freedom need to be removed \n\nfrom the global stiffness matrix before the solution of the linear system, otherwise it \n\nwould result in null determinant, and it is still necessary in the EBE method. The fifth \n\nstep of flowchart from Fig. 8.1 consists, then, of the elimination of the imposed degrees-\n\nof-freedom, which, in turn, are specified by the global array of statuses defined in the \n\nprevious step. \n\nBefore the removal, a renumbering of the degrees-of-freedom is necessary, shifting \n\nthe imposed ones to the end of the queue, as illustrated in Fig. 8.3. This example shows \n\nthe case of a global stiffness matrix, for which it is easier to understand the removal \n\nprocedure, but it is analogous in the EBE method. The only difference is that, instead of \n\none single large matrix, this data rearrangement is performed to the many several blocks \n\nthat comprises the model. \n\n \n\n\n\n \n\n158 \n\n \n\n \n\nFig. 8.3 \u2013 Global degrees-of-freedom renumbering, shifting the imposed ones to the end. Source: own \n\nauthorship. \n\n \n\nAfter the renumbering procedure and shifting the imposed d.o.f.s to the end of que \n\nqueue, the linear system of equations can be divided into four sub-regions as shown in \n\nFig. 8.4, in which: \n\n\u2022 The free degrees-of-freedom are denoted by the subscript \u201c?\u201d  \n\n\u2022 The imposed degrees-of-freedom are denoted by the subscript \u201c?\u201d  \n\n\u2022 ?? denotes the free or unknown degrees-of-freedom; \n\n\u2022 ?? are the imposed or known degrees-of-freedom; \n\n\u2022 ?? represent the external applied loads; \n\n\u2022 ?? denotes the unknown boundary reactions; \n\n\u2022 ??? are the stiffness terms exclusively from the free degrees-of-freedom; \n\n\u2022 ??? are the stiffness terms related to the imposed degrees-of-freedom; \n\n\u2022 ??? and ??? are the crossed stiffness terms. \n\n \n\n \n\nFig. 8.4 \u2013 Linear system sub-regions. Source: own authorship. \n\n \n\n\n\n \n\n159 \n\n \n\nThe following equation is valid: \n\n \n\n ??? ?? + ??? ?? = ??  Eq. 8.2 \n\n \n\nIn this equation, the only unknown term is ??. Then, the product ??? ?? is a vector \n\nof known values and it can be moved to the right side of the equation: \n\n \n\n ??? ??  = ?? ? ??? ??  Eq. 8.3 \n\n \n\nObtaining, thus, the final linear system of equations: \n\n \n\n ??? ??  = ??????   with    ?????? = ?? ? ??? ?? Eq. 8.4 \n\n \n\nAs already mentioned in item 5.4, the EBE Matrix has two methods, that \n\nautomatically rearranges its internal data in order to remove the imposed degrees-of-\n\nfreedom, and that computes the terms ??? and ??????. It is interesting to note that, the \n\nproduct ??? ?? is performed in a local element basis on the EBE method. \n\nThe sixth and final step of flowchart from Fig. 8.1 consists of the solution of linear \n\nsystem of equations with the implemented EBE-PCG algorithm. Since this algorithm is \n\nthe core of the work, it is presented individually in the next chapter. \n\n \n\n\n\n \n\n160 \n\n \n\n Element-by-Element Preconditioned \n\nConjugate Gradient Method  \n\nIn this chapter, it is presented the complete implementation of the element-by-\n\nelement version of the preconditioned conjugate gradient method.  This algorithm was \n\ndeveloped for structural mechanics applications, more specifically to solve large-scale \n\nproblems of flexible pipes modeled with the finite macroelements developed by \n\nPROVASI &amp; MARTINS (Chapter 2). \n\nIn PipeFEM, this EBE-PCG algorithm is employed by the Solver in the solution of \n\nthe linear system ??? ?? = ?????? from Eq. 8.4. In order to make the notation more \n\nconcise and facilitate the reading, these subscripts are removed in this chapter, so that this \n\nsame linear system, with the imposed degrees-of-freedom already removed, is \n\nrepresented by ?? = ?. \n\nAiming computational performance, the implementation was performed in the C++ \n\nlanguage and parallelized with OpenMP, enabling, thus, the complete utilization of the \n\nprocessing capacity of modern multi-core processors. But, before the discussion of the \n\ndetails of the parallelization, it is important to carefully analyze the PCG algorithm, \n\nshown in Table 9.1. \n\nThe first four operations are introductory. The first one consists of specifying the \n\ninitial guess, ?0. In most cases, the null vector ?0 = ? is adopted, without any loss of \n\ngenerality. In some cases, it is possible to determine a better initial guess, with the \n\nadvantage that, the closer it is to the exact solution, in less iterations the algorithm will \n\nconverge. In the second operation, the initial vector of linear residuals is computed. If the \n\ninitial guess is the null vector, there is no need to perform the costly matrix-vector product \n\noperation given by ? ?0. The third one corresponds to the preconditioning application, \n\nwhich it is a trivial operation in the case of the diagonal version, as well as the fourth \n\noperation, which consists of a simple copy of array. \n\n \n\n\n\n \n\n161 \n\n \n\nTable 9.1 \u2013 PCG Algorithm, solution of the linear system ?? = ?.  \n\n \n\n1. ?0 = ?????? \n\n2. ?0 = ? ? ? ?0 \n\n3. ?0 = ?\n?1 ?0  \n\n4. ?0 = ?0 \n\n5. ??? ? = 0,1,\u2026,??????? \n\n5.1. ?? = \n??\n? ??\n\n??\n? ? ??\n\n \n\n5.2. ??+1 = ?? + ?? ?? \n\n5.3. ??+1 = ?? ? ?? ? ?? \n\n5.4. if ???+1? &lt;?????????, then solution converged, exit loop \n\n5.5. ??+1 = ?\n?1 ??+1 \n\n5.6. ?? =\n??+1\n?  ??+1\n\n??\n? ??\n\n \n\n5.7. ??+1 = ??+1 + ?? ?? \n\n??? ??? \n\n6. If the solution converged, the result is ??+1  \n\n \n\nSource: (SAAD, 2003). \n\n \n\nwhere: \n\n\u2022 ? \u2013 is the iteration count; \n\n\u2022 ? \u2013 is the stiffness matrix; \n\n\u2022 ? \u2013 is the linear residual; \n\n\u2022 ?? \u2013 is the initial guess or a prediction; \n\n\u2022 ? \u2013 is the trial displacement vector; \n\n\u2022 ? \u2013 is the preconditioning transformation; \n\n\u2022 ? \u2013 denotes the step direction; \n\n\u2022 ? \u2013 is the step length; \n\n\u2022 ? \u2013 defines the correction factor. \n\n \n\n\n\n \n\n162 \n\n \n\nIt can be noted that, from the second to the fourth operation, there is a dependence \n\non the values of the immediately preceding one. It means that the execution sequence \n\nmust be respected, i.e., they cannot be concomitantly performed. Nevertheless, each of \n\nthese four operations is easily parallelizable with the OpenMP directives, with only the \n\nexception of the matrix-vector product ? ?0, which requires synchronization in the EBE \n\nversion. This matrix-vector product is also performed in each iteration of the algorithm \n\nand, given its direct importance and influence on the performance of the algorithm, it will \n\nbe addressed individually and in greater detail further on in this chapter. \n\nThe fifth step is the main core of the algorithm and it is responsible for the iterative \n\nprocedure until the achievement of the convergence or the maximum predefined number \n\nof iterations. Again, each of the operations from this iterative scheme has a value \n\ndependency with the immediately preceding one. With the exception of the matrix-vector \n\nproduct, all other operations are easily parallelizable with the directives from OpenMP. \n\nThe sixth and last operation consists of return the final solution if the convergence was \n\nachieved. \n\n \n\n9.1 Numerical Implementation \n\nThe numerical implementation of the method is not exactly a direct transcription of \n\nthe algorithm from Table 9.1. Aiming the computational performance, in some points, \n\nsmall modifications were necessary in the way that the variables are calculated or \n\nmanipulated, most of them justified mainly by working in parallel. The complete \n\nimplementation of the aforementioned algorithm is found in  Table 9.2.  \n\n \n\nTable 9.2 \u2013 Implemented EBE-PCG algorithm. \n\n \ndouble* Solve(LAP::Containers::Parallel::EBE::EbeMatrix* K, double* F) \n{    \n\n \n/* CONTROL VARIABLES \u2013 THEY CAN BE SPECIFIED BY THE USER */ \nint nrThreads; // Number of Threads for Parallelization \nint maxit;     // Maximum Number of Iterations \ndouble tol;    // Numerical Tolerance or Admissible Error \n\n \n\n/* INTERNAL VARIABLES */ \nbool converged = false;   // Converged? \ndouble res = 0.0;         // Residual \nint n = K->size();        // Linear Syst. Size or Dimension \ndouble num = 0, den = 0;  // Auxiliary Numerator and Denominator \n \n\n\n\n \n\n163 \n\n \n\n/* ALLOCATION OF THE VARIABLES OF THE PCG ALGORITHM */ \nint k = 0;             // Iteration Counter \ndouble alfa, beta;     // Step Length and Correction Factor \n \ndouble* x = new double[n];    // Solution Array \ndouble* Kpk = new double[n];  // Array of the Mat-Vect Prod Result \n \ndouble* rk = new double[n];   // ?? \ndouble* zk = new double[n];   // ?? \ndouble* pk = new double[n];   // ??     \n \ndouble* rkp1 = new double[n]; // ??+1 \ndouble* zkp1 = new double[n]; // ??+1 \ndouble* pkp1 = new double[n]; // ??+1 \n \ndouble* DiagPrec = new double[n]; // Diagonal Preconditioner \n \n/* BEGINNING OF THE METHOD */ \n \nK->DiagonalPreconditioner(DiagPrec); // Comp. Diagonal Prec. \n \n#pragma omp parallel for // Initial Guess x0 = 0 \nfor (int i = 0; i &lt;n; i++) \n x[i] = 0.0; \n \nK->MatrixVectorProduct(x, Kpk); // Comp. Mat-Vect Prod.: ? ?0 \n \n#pragma omp parallel for // Initial Linear Residual \nfor (int i = 0; i &lt;n; i++) \n rk[i] = F[i] - Kpk[i]; \n\n \n#pragma omp parallel for reduction(+: res) // Initial Residual \nfor (int i = 0; i &lt;n; i++) \n{ \n double value = rk[i]; // Square \n res += value * value; // Sum of the square \n} \n \nres = sqrt(res); // residual value \n \nif(res&lt;= tol) \n converged = true; // Initial Guess, x0, is already the solution! \nelse \n{ \n\nres = 0.0; // Resets the Residual Value \n \n// Resets the Residual Value  \n#pragma omp parallel for \nfor (int i = 0; i &lt;n; i++) \n{ \n\nzk[i] = DiagPrec[i] * rk[i]; \npk[i] = zk[i]; \n\n} \n \n// ITERATIVE SCHEME \nwhile (k &lt;maxit) \n{ \n\nK->MatrixVectorProduct(pk, Kpk); // EBE-Matrix Vector Product \n \n\n\n\n \n\n164 \n\n \n\n// Computation of Alfa \n#pragma omp parallel for reduction(+: num, den) \nfor (int i = 0; i &lt;n; i++) \n{ \n    num += rk[i] * zk[i]; \n    den += pk[i] * Kpk[i]; \n} \nalfa = num / den; \nnum = 0, den = 0; \n \n// Updates the solution array \"x\" and the new residuals \n#pragma omp parallel for \nfor (int i = 0; i &lt;n; i++) \n{ \n   x[i] += alfa * pk[i]; \n   rkp1[i] = rk[i] - alfa * Kpk[i]; \n} \n \n// Computation of the Norm of the Residual \nres = 0.0; \n#pragma omp parallel for reduction(+: res) \nfor (int i = 0; i &lt;n; i++) \n{ \n   double value = rkp1[i]; \n   res += value * value; \n} \nres = sqrt(res); \n \nif (res&lt;= tol) { converged = true; break;} // Convergence check \n \n// Computation of the Pseudo Residual \n#pragma omp parallel for \nfor (int i = 0; i &lt;n; i++) \n{ \n   zkp1[i] = DiagPrec[i] * rkp1[i]; \n} \n \n// Computation of Beta \n#pragma omp parallel for reduction(+: num, den) \nfor (int i = 0; i &lt;n; i++) \n{ \n   num += zkp1[i] * rkp1[i]; \n   den += zk[i] * rk[i]; \n}       \nbeta = num / den; \nnum = 0.0, den = 0.0; \n \n// Computation of the new Step Direction \n#pragma omp parallel for \nfor (int i = 0; i &lt;n; i++) \n   pkp1[i] = zkp1[i] + beta * pk[i]; \n \nk++; \n \nstd::swap(rk, rkp1); \nstd::swap(zk, zkp1); \nstd::swap(pk, pkp1); \n\n \n} // End while / Iterative scheme \n\n} // End if \n \n\n\n\n \n\n165 \n\n \n\n/* DEALLOCATION */ \ndelete[] DiagPrec; DiagPrec = nullptr; \ndelete[] Kpk; Kpk = nullptr; \ndelete[] zk; zk = nullptr; \ndelete[] rk; rk = nullptr; \ndelete[] pk; pk = nullptr;  \ndelete[] rkp1; rkp1 = nullptr; \ndelete[] zkp1; zkp1 = nullptr; \ndelete[] pkp1; pkp1 = nullptr; \n \nreturn x; \n \n\n} // End Solve Method \n \n\nSource: own authorship. \n\n \n\nThe implementation still remains very simple, an acknowledged characteristic of the \n\nPCG algorithm, and that helps to explain its success in the literature. It has three control \n\nparameters with default values, but that can be changed by the user, if necessary: the \n\nnumerical tolerance, the maximum number of iterations and the number of threads (for \n\nparallelism). It also possesses internal auxiliary variables. In addition to these, it also \n\ncounts with variables directly associated with the PCG algorithm, mostly of them \n\ndynamically allocated arrays of doubles. After defining and allocating the variables, the \n\nmethod is then ready to begin. \n\nBefore detailing all the operations, it is important to say that two of them will be \n\nexplained separately in the next items: the computation of the diagonal preconditioner \n\nand the element-by-element matrix-vector product. This is justified by the fact that, due \n\nto the EBE method, these two operations are carried out in a very particular way. Besides \n\nthat, they have a great impact on the over-all performance of the implementation, \n\ndeserving, therefore, a more detailed description. \n\nAfter computing the diagonal preconditioner, it proceeds to the definition of the \n\ninitial guess array (?0). The null vector option was adopted, and this operation is easily \n\nparallelizable with OpenMP. \n\nIn sequence, the matrix-vector product ? ?0 is calculated, so that it is possible to \n\ndetermine the initial linear residuals. At this point, it was necessary to include a \n\nverification of the norm of the initial residuals (?0). That is because, if the array on the \n\nright side of the linear system is null (in FEM it may happens when no external load is \n\napplied to the model and no displacements are prescribed), the null initial guess is already \n\nthe exact solution of the problem. In this case, the iterative scheme cannot be started, \n\n\n\n \n\n166 \n\n \n\nsince there would occur a division by zero right in the first calculation of the step length, \n\n?0.  \n\nIf the residual is higher than the specified tolerance, the program computes the \n\npseudo-residuals (?0), the array of step directions (?0) and then proceeds to the iterative \n\nscheme. The first operation of this iterative scheme is the determination of the step length, \n\n??, given by the division of ??\n? ?? with ??\n\n? ? ??. Both these numerator and denominator \n\nare calculated by a parallel sum of ? values in to the auxiliary variables ??? and ???. A \n\n\u201ccritical section\u201d or a \u201clock\u201d could be employed to avoid race condition, but in practice \n\nthis would serialize the computation and jeopardize the scalability. For situations like \n\nthese, the OpenMP has a \u201creduction\u201d clause, which is responsible for automatically \n\nmaking copies of the specified reduction variable for each thread, which in turn will act \n\nand update only its local copy. At the end of the loop, the local variables are combined to \n\nform the final result, a strategy that ensures a good scalability of the solution.  \n\nWith the step length at hand, it is possible to update the solution array (??+1) and to \n\ncompute the new residuals (??+1 ). For advantages in cache memory and speed, these two \n\noperations were unified in the same loop. Then, the new residual is computed and, if the \n\nnorm of the array of residuals is smaller than the tolerance, converged is set as true and \n\nthe while loop is broken. Otherwise, the iterative scheme proceeds to the computation of \n\nthe new pseudo residuals (??), an operation that is easily done and parallelized in the case \n\nof the diagonal preconditioner. The parallelization strategy in the computation of the \n\ncorrection factor, ??, is the same as the one from ??. Lastly the new step directions (??+1) \n\nare determined. \n\nAfter incrementing the iteration counter and swapping the pointers, a new iteration \n\nis ready to start. This swapping operation consists of switching with each other the \n\nmemory addresses to which the two pointers are pointing. Instead of copying the contents \n\nof one array to the other, the exactly same effect is obtained with only one swapping \n\noperation. Besides that, the swap eliminates new memory allocations and reallocations, \n\nbeing, therefore, an extremely efficient way to set the arrays for the next iteration. \n\nThis iterative scheme is executed until the convergence or the maximum number of \n\niterations is achieved. At last, the dynamically allocated variables must be deleted, so \n\nthere is no memory leak.  \n\n \n\n\n\n \n\n167 \n\n \n\n9.2 Diagonal Preconditioner Computation \n\nAs the name suggests, the diagonal preconditioner consists of using the values of the \n\nmain diagonal of the global stiffness matrix to increase the convergence rate of the \n\nsolution. When the global matrix is stored in a dense or sparse format, its diagonal is \n\nreadily available. In the EBE method, however, it is obtained indirectly, through a \n\nprocedure that consists of summing into a global array the values of the diagonals of each \n\nof the blocks of the model. Despite the simplicity of this procedure, when performed in \n\nparallel, it will occur situations in which two or more blocks share the same position in \n\nthe global array, as illustrated in Fig. 9.1. In this case, multiple threads will try to \n\nconcomitantly update a single memory location, generating the need for synchronization \n\nmechanisms, otherwise the calculated values would be wrong. \n\n \n\n \n\nFig. 9.1 \u2013 Example of update overlapping during the parallel evaluation of the global diagonal. Source: \n\nown authorship. \n\n\n\n \n\n168 \n\n \n\n \n\nIn order to synchronize the operation, the method based on local copies was adopted. \n\nIllustrated in Fig. 9.2, it consists of allocating a local global array to each thread (initially \n\nwith all null values), so that each thread can operate on a set of blocks and updates these \n\nlocal copies independently. At the end of the iterations, the local copies are summed in \n\nparallel in the final global array. \n\n \n\n \n\nFig. 9.2 \u2013 Synchronization method based on local copies. \n\n \n\nAs it will be seen in the next item, this synchronization technique is not the most \n\nefficient. However, it has been maintained in the implementation for the diagonal \n\npreconditioner for two reasons: it is executed only once (thus not compromising the \n\noverall performance of the algorithm); and second because it is completely generic and \n\nworks regardless of the blocks indexes. \n\nLastly, the diagonal values are inverted, since the multiplication operation is less \n\ncostly than the division one, thus saving time during the iterative process. If any value of \n\nthe diagonal is null, the implementation generates a warning and the inversion is replaced \n\nby one. \n\n \n\n9.3 EBE Matrix-Vector Product \n\nBoth the preconditioner and the matrix-vector product are the most critical operations \n\nof the PCG algorithm. While the relevance of the first is justified by convergence \n\nimprovement and consequent reduction in the number of iterations, the importance of \n\nmatrix-vector product is due to the high number of mathematical operations that must be \n\nexecuted at every iteration. In this way, the overall performance of the algorithm is \n\ndirectly affected to the efficiency of the matrix-vector operation. \n\n\n\n \n\n169 \n\n \n\nThe objective of this operation is to perform the product between the global stiffness \n\nmatrix and the global array of step directions. In the EBE method, however, this product \n\nis performed in a local basis, employing all blocks that comprise the model. The detailed \n\nexplanation of this procedure begins with Fig. 9.3, in which it can be seen that each block \n\ncontains an element stiffness matrix and an array of integer indexes that relate the local \n\ndegrees-of-freedom with the global ones. A gathering operation is then performed as \n\nillustrated in Fig. 9.4. It consists of selecting the corresponding values of the array of \n\nglobal step directions and mounting its own local version. Following the gathering \n\noperation, a local matrix-vector product is performed between the element stiffness \n\nmatrix and the array of element step directions, as shown in Fig. 9.5. The last step is the \n\nscattering operation, Fig. 9.6, which consists of spreading the results of the local product \n\ninto the global product array. \n\nThese procedures from Fig. 9.3 to Fig. 9.6 are illustrative. As already mentioned in \n\nitem 5.4, the element stiffness matrices are stored in a single array of doubles, as well as \n\nthe indexes in a single array of integers, in order to ensure contiguous memory allocation. \n\nAll the necessary manipulations to implement this procedure are encapsulated in the EBE \n\nMatrix container. \n\n \n\n \n\nFig. 9.3 \u2013 Each block has an array of indexes and a stiffness matrix. Source: own authorship. \n\n \n\n\n\n \n\n170 \n\n \n\n \n\nFig. 9.4 \u2013 Gathering operation: the indexes are used to gather the local values of step directions. Source: \n\nown authorship. \n\n \n\n \n\nFig. 9.5 \u2013 Local product operation. Source: own authorship. \n\n \n\n\n\n \n\n171 \n\n \n\n \n\nFig. 9.6 \u2013 Scattering operation. Source: own authorship. \n\n \n\nThe gathering and local product operations are completely independent between the \n\nblocks and, therefore, they are easily parallelized. It is important to note that, in the \n\ngathering operation, the several threads will act concomitantly in the global array of step \n\ndirections, but only with reading operations, that can be executed in parallel without the \n\nneed for synchronization. The local matrix-vector product is strictly local and \n\nindependent. On the other hand, the scattering consists of several writing operations into \n\nthe same global result array. When it is performed in parallel, update overlays as the ones \n\nillustrated in Fig. 9.1 will occur, demanding synchronization techniques. Given the \n\nimportance of the matrix-vector product operation, four different synchronization \n\ntechniques were developed and explored in this work and are explained in detail in the \n\nnext items. \n\n \n\n9.3.1 Synchronization I: Global Array of Locks \n\nThe first adopted strategy to synchronize the scattering operation consists of a global \n\narray of locks. When applied to a block of code, the lock acts as a semaphore, allowing \n\nonly one thread at a time to execute it. The first thread that reaches the lock obtains \n\npermission to execute the code and triggers it, while the others remain in hold, waiting \n\n\n\n \n\n172 \n\n \n\nfor the release of the lock. This method ensures no concomitant execution of the piece of \n\ncode surrounded by the lock. \n\nThe global array of locks consists of creating a lock for each degree-of-freedom of \n\nthe model. Table 9.3 shows the procedure for defining and allocating this array. It is \n\nimportant to note that, for each element of this array, the lock must be initialized (and \n\ndestroyed in the deallocation at the end of the execution).  \n\n \n\nTable 9.3 \u2013 Definition and allocation of the array of locks.  \n\n \n\n/* Parameters*/ \n\nint nrThreads;   // Number of threads, user-specified value \n\nint n;           // Final global dimension of the linear system \n\nint nmax;        // Maximum block size \n\n \n\n// Dynamically Allocation of the Global Array of OpenMP Locks \n\nomp_lock_t* lock = new omp_lock_t[n];  \n        \n// Each Lock of the Array Must Be Initialized  \nfor(int i = 0; i &lt;n; i++) \n   omp_init_lock(&amp;(lock[i])); \n\n \n\n//////////////////////////////////////////////////////////////////////// \n//////////////////////////////////////////////////////////////////////// \n \n// Deallocation at the end of the EBE-PCG algorithm \nfor(int i = 0; i &lt;n; i++) \n   omp_destroy_lock(&amp;(lock[i])); \n\n \n\ndelete[] lock; \n\n \n\nSource: own authorship. \n\n \n\nThe algorithm for the matrix-vector product is then shown in Table 9.4. It starts with \n\nthe creation of the parallel region. The code that is within this region is run in parallel by \n\nthe specified number of threads. The first step consists of resetting the values of the \n\n?????? array, since it is reused from one iteration to another, avoiding, thus, unnecessary \n\nreallocations. The second step is the iteration over all blocks of the model. A dynamic \n\nscheduling for this for loop was chosen, because the blocks have varied sizes. The \n\nschedule clause specifies how the loop is distributed into the threads. When it is set as \n\ndynamic, this distribution is defined during the execution of the program, each thread \n\nreceives a new chunk-sized block of loops when the previously received one has already \n\nbeen executed, with extra overhead associated, but more appropriate when the processes \n\ndiffer considerably in execution time. For each block, auxiliary variables are gathered, \n\n\n\n \n\n173 \n\n \n\nsuch as block sizes and position in memory, and then it proceeds to the local product. The \n\nscattering is performed in the three last commands, when the lock is set, the global array \n\nis updated with the increment value and lastly the lock is unset. \n\n \n\nTable 9.4 \u2013 Matrix-vector product using locks.  \n\n \n\nvoid MatrixVectorProduct(double*&amp; Input, double*&amp; Output) \n{ \n\n// Definition of the Parallel Region \n#pragma omp parallel num_threads(nrThreads) \n{ \n    // Cleaning the Output values \n\n#pragma omp for \nfor (int i = 0; i &lt;n; i++) \n   Output[i] = 0.0; \n \n/* Gather, Product and Scatter */ \n#pragma omp for schedule(dynamic, 1) \nfor (int bk = 0; bk &lt;nb; bk++) \n{ \n\nint dimc = _bksiz_cond[bk]; // Final bk dimension \nint dimo = _bksiz_orig[bk]; // Orig. bk dimension \nint i1D  = _bk_ini_1D[bk];  // 1D initial position in memory \nint i2D  = _bk_ini_2D[bk];  // 2D initial position in memory \n \n/* Local Product */ \nfor (int i = 0; i &lt;dimc; i++) \n{ \n\nint id = _index[i1D + i]; // Global index to be updated \n \ndouble inc = 0.0; // Increment \n \n// Product \nfor (int j = 0; j &lt;dimc; j++)  \n   inc += p[i2D + i * dimo + j] * Input[_index[i1D + j]]; \n \nomp_set_lock(&amp;(lock[id]));     // Set lock for position \u201cid\u201d \n \nOutput[id] += inc;             // Scatter \n \nomp_unset_lock(&amp;(lock[id]));   // Unset lock for position \u201cid\u201d \n \n\n} \n} \n\n} \n} \n\n \n\nSource: own authorship. \n\n \n\nThis algorithm with locks is very simple and straightforward. However, for each \n\nincrement in the global result array, two additional and costly operations are required (the \n\nlock set and unset operations). \n\n \n\n\n\n \n\n174 \n\n \n\n9.3.2 Synchronization II: Local Copies \n\nThe second synchronization strategy consists of using local copies of the global result \n\narray. It has the advantage of completely eliminating the locks, since each thread works \n\nwith its own array and the increments can be made without the risk of overlapping values. \n\nAfter the product operations, these local copies are summed in parallel into the global \n\noutput array. \n\nTable 9.5 shows the definitions and allocation of the local arrays, named as \n\n???????????. To avoid unnecessary reallocations, they are defined only once and reused \n\nat each iteration. Additionally, local copies of the input arrays were also created (that \n\nform the element local step directions), avoiding reallocations, for a better computational \n\nperformance of the algorithm. \n\n \n\nTable 9.5 \u2013 Definition and allocation of the local copy arrays.  \n\n \n\n/* Parameters*/ \n\nint nrThreads;   // Number of threads, user-specified value \n\nint n;           // Final global dimension of the linear system \n\nint nmax;        // Maximum block size \n\n \n\n/* Definition and allocation of the local input arrays */ \n\ndouble** localInput = new double*[nrThreads]; // Local Input Array \n\nfor (int i = 0; i &lt;_nrThreads; i++) \n\n   localInput[i] = new double[nmax]; \n\n \n\n/* Definition and allocation of the local copy arrays */ \n\ndouble** localResult = new double*[nrThreads]; // Local Copy Array \n\nfor (int i = 0; i &lt;_nrThreads; i++) \n\n   localResult[i] = new double[n]; \n\n \n\nSource: own authorship. \n\n \n\nThe matrix-vector algorithm that uses the local copies as synchronization strategy is \n\nshown in Table 9.6. Right after the creation of the parallel region, thread local variables \n\nare defined and consists of: the current thread identification and pointers to the thread-\n\nrespective input and result arrays. Setting these pointers right at the beginning optimizes \n\nvariables indexing, with benefits in performance. The first procedure is then to reset the \n\nvalues of the local copy array. After that, it proceeds to the iteration over the blocks of \n\nthe model. The gathering is performed updating the local input array, which is employed \n\nin the local product. All these operations, including the local scatter, are completely \n\n\n\n \n\n175 \n\n \n\nthread-independent. Lastly, the local result arrays are summed together in the output \n\narray. \n\nTable 9.6 \u2013 Matrix-vector product using the local copy arrays as synchronization methodology.  \n\n \nvoid MatrixVectorProduct(double*&amp; Input, double*&amp; Output) \n{ \n\n#pragma omp parallel num_threads(nrThreads) \n{ \n\nint td = omp_get_thread_num();   // Thread number \ndouble* linp = localInput[td];   // Local Input Array \ndouble* lres = localResult[td];  // Local Result Array \n \n/* Cleans the Local Result Array */ \nfor (int j = 0; j &lt;n; j++) \n  lres[j] = 0.0;        \n \n/* Gather, Product and Local-Scatter */ \n#pragma omp for schedule(dynamic, 1) \nfor (int bk = 0; bk &lt;nb; bk++) \n{ \n\nint dimc = _bksiz_cond[bk]; // Final bk dimension \nint dimo = _bksiz_orig[bk]; // Orig. bk dimension \nint i1D  = _bk_ini_1D[bk];  // 1D initial position in memory \nint i2D  = _bk_ini_2D[bk];  // 2D initial position in memory \n \n/* Gather */ \nfor (int i = 0; i &lt;dimc; i++)  \n   linp[i] = Input[_index[i1D + i]]; \n \n/* Block Product  */ \nfor (int i = 0; i &lt;dimc; i++)  \n{  \n   double inc = 0.0; // Increment variable \n \n   for (int j = 0; j &lt;dimc; j++) // Product  \n      inc += p[i2D + i * dimo + j] * linp[j]; \n \n   /* Local Scatter */ \n   lres[_index[i1D + i]] += inc; \n} \n\n} \n \n/* Parallel Summation of the Local Result Arrays */ \n#pragma omp for  \nfor (int i = 0; i &lt;n; i++) \n{ \n   Output[i] = 0.0; \n   for (int j = 0; j &lt;nrThreads; j++)    \n      Output[i] += localResult[j][i]; \n} \n\n} \n} \n\n \n\nSource: own authorship. \n\n \n\nThis technique presents, however, scalability limitations. The gather, product and \n\nlocal-scatter are very scalable operations. The initial local array resetting and the final \n\n\n\n \n\n176 \n\n \n\narrays summation operations are, nevertheless, not accelerated with the increase of the \n\nnumber of threads. This is because the number of actions that they must perform increases \n\nlinearly with the number of employed threads. \n\n \n\n9.3.3 Synchronization III: Mapped Local Copies \n\nThe aforementioned limitations of the previous synchronization strategy motivated \n\nthe development of an optimized algorithm. This new algorithm is based on the fact that, \n\nif the blocks are assembled into sets, each of which assigned to a different thread, it is \n\npossible to map all the degrees-of-freedom that each thread will modify, thereby reducing \n\nsignificantly the amount of operations performed in the initial resetting and in the final \n\nsummation of the local copy arrays. \n\nThe first step consists of distributing the blocks into balanced sets. The simplest way \n\nto perform this is to divide the total number of blocks by the total number of threads, \n\ncreating sets with the same number of blocks. However, this is not the best alternative, \n\nsince the blocks have varying sizes, what would result in unbalanced sets and in \n\nconsequent reduction of the overall available processing capacity. In addition to this, it is \n\nimportant to notice that the number of operations of the matrix-vector product is a \n\nquadratic function with respect to the dimensions of the blocks. The implemented method \n\nof division considers these question by employing the cumulative distribution function of \n\nthe square of the block dimensions, as exemplified in  Fig. 9.7 for a situation with 20 \n\nblocks and 4 threads, allowing the achievement of highly balanced sets. \n\n \n\n \n\nFig. 9.7 \u2013 The distribution of blocks into sets considers the squares of their dimensions. Source: own \n\nauthorship. \n\n \n\n\n\n \n\n177 \n\n \n\nWith the sets of blocks, the algorithm proceeds then to mapping operation. A matrix \n\nof booleans is defined and initialized only with false values. As shown in Fig. 9.8, the \n\ndimensions of this matrix are given by the total number of degrees-of-freedom and the \n\nnumber of threads. \n\n \n\n \n\nFig. 9.8 \u2013 Table of booleans specifies the degrees-of-freedom that each thread modifies, with which it is \n\npossible to generate the maps. Source: own authorship. \n\n \n\n0 1 2 3\n\n0 0\n\n1 1 2\n\n2 0 3\n\n3 0 1 2\n\n4 1 3\n\n5 0 1 3\n\n6 1 2 3\n\n7 1\n\n8 0\n\n9 1 2 3 4\n\n10 3\n\n11 0 1\n\n12 1 3\n\n13 2\n\n14 0 1\n\n? ? ? ? ? ?\n\nn 1 3\n\n0 1 1 2\n\n2 3 3 4\n\n3 4 6 4\n\n5 5 9 5\n\n8 6 13 6\n\n9 7 ? 9\n\n11 9 10\n\n14 11 12\n\n? 12 ?\n\n14 n\n\n?\n\nn\n\nD\ne\n\ng\nre\n\ne\ns\n\n-o\nf-\n\nfr\ne\n\ne\nd\n\no\nm\n\nThread Map to iterate \n\nover d.o.f.s \nM\n\na\np\n\n t\no\n\n i\nte\n\nra\nte\n\n o\nv\n\ne\nr \n\nth\nre\n\na\nd\n\ns\n\n\n\n \n\n178 \n\n \n\nIn each column, the degrees-of-freedom in dark-gray are the ones modified by the \n\nrespective thread. They are defined through the iteration along the set of blocks that \n\nbelongs to the thread, and the degrees-of-freedom specified by the arrays of indexes have \n\ntheir values in the table switched from false to true. This table is employed to generate \n\ntwo different mappings. The first one specifies, for each available thread, all the degrees-\n\nof-freedom that are modified by it. The second mapping specifies, for each degree-of-\n\nfreedom of the model, the threads that modify it. \n\nThe first mapping is then employed to improve the initial resetting of the local copy \n\narrays. For each thread, only the degrees-of-freedom specified by the mapping have their \n\nvalues set to zero. The values of the remaining ones have no importance to the algorithm.  \n\nThe second mapping is employed in the final summation of the local copy arrays, as \n\nshown in Table 9.7. For each of degree-of-freedom, only the threads specified by the \n\nmapping have their value summed into the output array.  \n\n \n\nTable 9.7 \u2013 Mapped-optimized parallel summation of the local copy arrays.  \n\n \n/* Parallel Summation of the Local Result Arrays */ \n/* The mapping-by-dof is used to eliminate unnecessary summations */ \n#pragma omp parallel for num_threads(nrThreads) \nfor (int i = 0; i &lt;n; i++) \n{ \n   int* loc_mapping_by_dof = mapping_by_dof[i]; \n \n   double val = 0.0; \n \n   for (int j = 0; j &lt;mbd_siz[i]; j++)  \n   { \n      int td = loc_mapping_by_dof[j]; \n      val += localResult[td][i]; \n   } \n \n   Output[i] += val; \n} \n\n \n\nSource: own authorship. \n\n \n\nSmall additional improvements were made in this algorithm, such as to utilize the \n\noutput array itself as the local copy for the first thread, what already eliminates one global \n\narray to be summed in the final operation. \n\nBy reducing the unnecessary operations from the resetting and summation \n\noperations, some level of scalability is obtained in these steps from this new algorithm. \n\nHowever, the main advantage of this synchronization technique consists in the fact that it \n\n\n\n \n\n179 \n\n \n\nis completely generic. It works independently of the indexing system, of the dimensions \n\nof the blocks and it will still be valid if new types of finite macroelements are included in \n\nthe future. \n\n \n\n9.3.4 Synchronization IV: Geometry- and Mesh-Based \n\nMapped Solution \n\nIf the blocks are distributed in sets totally independent between each other, or if a \n\nlarge number of independent blocks is grouped into a set, it is possible to perform the \n\naforementioned global scatter operations for these sets without worrying about \n\nsynchronization, as the initial conditions ensure that there will be no simultaneous writing \n\noperations in the global result array.  \n\nHowever, the development of completely generic mappings procedures for the \n\ndistribution of the blocks into independent sets is a very complex task. The contact \n\nelements increase significantly the matrix bandwidth and leave the indexing very \n\ndispersed, since one node can be in contact with several others (this occurs in the case of \n\nthe bridge contact, for example, in which, for each wire of the armor, the same Fourier \n\nnode is connected to another standard node). Nonetheless, by taking into account the \n\ncharacteristics of the geometry and mesh, it is possible to generate improved mappings \n\nof block distribution for certain predicted situations. \n\nThe explanation of this methodology starts then with the tensile armors, Fig. 9.9, \n\nwhich are composed by a predefined number of helical tendons, each of them modeled \n\nwith the helical beam elements. It is interesting to note that the beam elements from a \n\nwire do not cause or suffer interference with the elements situated on the other wires (the \n\ncontacts are handled separately). It means that, between the tendons, the elements are \n\nalready distributed into independent sets. During the computation, each thread receives \n\nthe elements from a specified wire and the global result array can be updated in parallel \n\nwithout any problem. \n\n\n\n \n\n180 \n\n \n\n \n\n \n\nFig. 9.9 \u2013 Tensile armor: the elements that belong to a wire are independent in relation to the remaining \n\nwires. The contacts are handled separately. Source: own authorship. \n\n \n\nThere is another possibility of element distribution for continuously connected beam, \n\nwhich is the case of the tensile armors. As illustrated in Fig. 9.10, the elements are \n\ngrouped into two independent sets in this case. Then a two-step procedure is adopted, \n\nmeaning that, firstly, the iteration must occur only on all elements of set 1. In the \n\nsequence, the iteration occurs for the elements from set 2. \n\n \n\n \n\nFig. 9.10 \u2013 Continuously connect beam elements can be grouped into two single independent sets.  \n\n \n\nThe first approach has cache advantages. When a thread iterates through the elements \n\nof a wire, there is greater continuity in the numbering of blocks and degrees-of-freedom. \n\nHowever, this parallelization is limited by the total number of wires of the pipe. If a \n\ncomputer with some hundreds of cores is available, a portion of the processing capacity \n\nwould be wasted, which does not occur in the second approach, that is completely generic \n\nin this sense. \n\nWith respect to the polymeric sheath, modeled with the Fourier expanded solids of \n\nrevolution, the geometry is a rectangle and the mesh is perfectly mapped, as illustrated \n\nby the gray region in Fig. 9.11. \n\n \n\n\n\n \n\n181 \n\n \n\n \n\nFig. 9.11 \u2013 Geometry and mesh of the polymeric sheath. Source: own authorship. \n\n \n\nIn this case, the two-step procedure from Fig. 9.12 was developed and implemented. \n\nIt is based on the fact that, in the first step, if considered only the columns designated by \n\n1, there is no degree-of-freedom sharing among these columns. If each of them is assigned \n\nto a different thread, the global scatter can be simultaneously performed without any \n\nproblem or need for synchronization. The second step is analogous the first by \n\nconsidering only the columns designated by the number 2. \n\n \n\n \n\nFig. 9.12 \u2013 Two-step procedure: in the first step, only the columns designated by 1 are considered; in the \n\nsecond, the ones designated by 2. Source: own authorship. \n\n \n\nA four-step procedure was also developed, as shown in Fig. 9.13. If the blocks \n\nnumbering is well-behaved, this technique has great potential for parallelization methods \n\nthat explore vectorization. \n\n \n\n\n\n \n\n182 \n\n \n\n \n\nFig. 9.13 \u2013 Four-step procedure. Source: own authorship. \n\n \n\nLastly, it is considered the distribution of the blocks relative the contact elements. As \n\nillustrated in Fig. 9.14, the contact pairs are dispersed through the model, making it \n\ndifficult to determine logical patterns. The solution found consists of employing \n\nexclusively geometric properties, more specifically the fact that the pipe axial dimension \n\nis much higher in comparison to the others.  \n\n \n\n \n\nFig. 9.14 \u2013 Illustrative representation of the contact pairs for a pipe model with two tensile armors and an \n\nexternal polymeric sheath. Source: own authorship. \n\n \n\nThis strategy enables the creation of subdomains with minimized overlapping \n\nfrontiers, as shown in Fig. 9.15. In this case the pipe is axially subdivided into four \n\nequidistant domains.  \n\n \n\n\n\n \n\n183 \n\n \n\n \n\nFig. 9.15 \u2013 Domain subdivision. Source: own authorship. \n\n \n\nFor each contact pair, the nodal coordinates are verified and classified into a domain. \n\nThe ideal (and most frequent) case is when both nodes are located in the same domain. If \n\nthis does not occur, i.e., if each node is situated in different domains, the block \n\ncorresponding to this element is identified and receives special treatment with \n\nsynchronization. It is interesting to note that, if all layers have the same number of axial \n\ndivisions, this problematic situation does not occur. \n\n \n\n \n\nFig. 9.16 \u2013 Problematic situation: contact pair located between two different domains. Source: own \n\nauthorship. \n\n \n\nIt is important to note that this parallelization strategy is not generic, since the \n\niteration maps are based on the geometry and mesh of the model. If new finite \n\nmacroelements or new rearrangements between layers are developed in the future, it is \n\nvery likely that this algorithm will have to be complemented in order to contemplate the \n\nnew scenarios. Despite this, it is also important to note that, only by rearranging and \n\ncreating an intelligent sequence of execution of the local matrix-vector products, it was \n\npossible to completely eliminate the synchronization mechanisms, making this algorithm \n\nvery efficient and fast in computational terms. \n\n\n\n \n\n184 \n\n \n\nIn the next chapter, numerical results are presented, in conjunction with a detailed \n\nanalysis of the execution times and scalability, allowing thereby the comparison of the \n\nparallelization strategies presented in this chapter. \n\n\n\n \n\n185 \n\n \n\n Results \n\nIn this chapter, the results of the implemented EBE-PCG algorithm are presented, \n\nwith emphasis on simulation time, scalability and memory consumption. In addition to \n\nthe PCG algorithm itself, the four synchronization strategies for the matrix-vector product \n\ndiscussed in detail in the previous chapter have also been evaluated and compared. \n\nBefore the results, however, a simplified model of flexible pipe is introduced. It \n\nconsists of a flexible pipe modeled with the finite macroelements presented in Chapter 2 \n\nwith the objective of testing and validating the implementation of the EBE-PCG solver. \n\n \n\n10.1 Finite Macroelement Model \n\nThe flexible pipe illustrated in Fig. 10.1 was modeled with the finite macroelements \n\nfrom Chapter 2 with the objective of testing the implementation of the EBE-PCG \n\nalgorithm. It contains three layers, from the inner to the outermost: an inner and an outer \n\ntensile armor layers; and an external polymeric sheath. This pipe is simplified with respect \n\nto the total number of layers (only three), but all of them are consistent with those of a \n\npossible real pipe with 4 inches of internal diameter. All the characteristics and properties \n\nof these layers are presented in greater detail in the next items. \n\n \n\n \n\nFig. 10.1 \u2013 Simplified model of flexible pipe. Image generated in ANSYS\u00ae. Source: own authorship. \n\n\n\n \n\n186 \n\n \n\n \n\n10.1.1 Inner Tensile Armor Layer \n\nThe inner tensile armor layer, Fig. 10.2, consists of 56 helically extruded metallic \n\ntendons of rectangular shaped cross-sections. The tendons are modeled with the helical \n\nbeam element from item 2.2, so that the only control parameter of the element mesh is \n\nthe number of axial divisions. All geometric and material properties are found in Table \n\n10.1. \n\n \n\n \n\nFig. 10.2 \u2013 Inner tensile armor layer. Image generated with ANSYS\u00ae. Source: own authorship. \n\n \n\nTable 10.1 \u2013 Parameters of the inner layer of tensile armor. Source: own authorship. \n\nParameter Value \n\nLength (mm) 1,692.00 \n\nMean Radius (mm) 101.25 \n\nLay Angle (deg.) 36.00 \n\nCross-section W x H (mm) 8.00 x 4.00 \n\nNumber of Tendons 56 \n\nMaterial Young Modulus (MPa) 207,000.00 \n\nMaterial Poisson Ratio 0.30 \n\n \n\n\n\n \n\n187 \n\n \n\n10.1.2 Outer Tensile Armor Layer \n\nThe outer tensile armor layer, Fig. 10.3, consists of 63 helically extruded metallic \n\ntendons of rectangular shaped cross-sections. The tendons are modeled with the helical \n\nbeam element from item 2.2, so that the only control parameter of the element mesh is \n\nthe number of axial divisions. All the geometric properties of this layer are found in Table \n\n10.2, as well as the material properties. \n\n \n\n \n\nFig. 10.3 \u2013 Outer tensile armor layer. Image generated with ANSYS\u00ae.  Source: own authorship. \n\n \n\n  \n\nTable 10.2 \u2013 Parameters of the outer layer of tensile armor. \n\nParameter Value \n\nLength (mm) 1,692.00 \n\nMean radius (mm) 105.25 \n\nLay angle (deg.) -38.00 \n\nCross-section W x H (mm) 8.00 x 4.00 \n\nNumber of tendons 63 \n\nMaterial Young Modulus (MPa) 207,000.00 \n\nMaterial Poisson Ratio 0.30 \n\nSource: own authorship. \n\n \n\n\n\n \n\n188 \n\n \n\n10.1.3 External Polymeric Sheath \n\nThe outermost layer is a cylindrical sheath, as illustrated in Fig. 10.4, made of \n\npolymeric material. \n\n \n\n \n\nFig. 10.4 \u2013 Polymeric sheath. Image generated with ANSYS\u00ae.  Source: own authorship. \n\n \n\nIt is important to note that, for being modeled in PipeFEM with the Fourier expanded \n\ncylindrical element (2.1), the element mesh is a simplified surface, as shown in the gray \n\nregion of Fig. 10.5. It has three control parameters, the number of axial and radial \n\ndivisions and the maximum expansion order of the Fourier series, which must be varied \n\nto verify the numerical convergence of the model. \n\n \n\n \n\nFig. 10.5 \u2013 The element mesh is illustrated in dark grey. Source: own authorship. Source: own authorship. \n\n \n\n\n\n \n\n189 \n\n \n\nAll material and geometric properties are found in Table 10.3. Although the \n\nemployed material (HDPE) has non-linear characteristics, it was employed a linear elastic \n\nmaterial model, since material non-linearities are not explored by the program.  \n\n \n\nTable 10.3 \u2013 Parameters of the polymeric sheath layer.  \n\nParameter Value \n\nLength (mm) 1,692.00 \n\nMean radius (mm) 110.75 \n\nThickness (mm) 7.00 \n\nMaterial Young Modulus (MPa) 570.88 \n\nMaterial Poisson Ratio 0.45 \n\nSource: own authorship. \n\n \n\n10.1.4 Contacts Between Layers \n\nBefore discussing the contacts, a brief summary of the layers is available in Table \n\n10.4, including the finite macroelements used to mesh them. \n\n \n\nTable 10.4 \u2013 Summary of the layers. \n\nID Layer Finite Macroelement \n\n1 Inner Tensile Armor (10.1.1) Curved Helical Beam (2.2) \n\n2 Outer Tensile Armor (10.1.2) Curved Helical Beam (2.2) \n\n3 Polymeric Sheath (10.1.3) Fourier Cylinder (2.1) \n\nSource: own authorship. \n\n \n\nAll the interactions between these layers were modeled as completely rigid, that is, \n\nwithout relative displacements between the nodes that compose the contact pairs. The \n\ncontact between the inner and the outer layers of tensile armor was done with \n\nconventional node-to-node bonded contact elements, since both layers have the same \n\nstandard nodal type. As for the contact between the outer tensile armor layer and the \n\npolymeric sheath, due to the nodal different natures, it was employed the bridge contact \n\nelements from item 2.3. All these contacts are summarized in Table 10.5. \n\n \n\n\n\n \n\n190 \n\n \n\nTable 10.5 \u2013 Contact between layers. \n\nContact ID Between layers Finite Macroelement \n\n1 1 and 2 Bonded Contact \n\n2 2 and 3 Bridge Contact (2.3) \n\nSource: own authorship. \n\n \n\n10.1.5 Meshes \n\nIn order to evaluate the computational performance (mainly the scalability) of the \n\nimplementation for large-scale models, two different levels of mesh refinement were \n\ndefined, named as \u201cMesh A\u201d and \u201cMesh B\u201d. All parameters and statistics of these two \n\nmeshes are shown in Table 10.6 and Table 10.7, respectively. For Mesh B, a non-round \n\nvalue was chosen as the number of axial divisions, with the objective of avoiding any \n\npossible influence on scalability due the multiplicity between this number of divisions \n\nand the number of employed threads. In addition to this, a complete convergence analysis \n\nis performed in item 10.7, in which several other combinations of mesh parameters are \n\ntested. As it will be seen, Mesh A and Mesh B can be considered very refined, but it is \n\nworth remembering once again that they were created with the purpose of evaluating the \n\nbehavior of the implementation for large-scale situations. \n\n \n\nTable 10.6 \u2013 Mesh A. \n\nParameters Value \n\nAxial divisions in the tensile armors 200 \n\nAxial divisions in the cylinder 400 \n\nRadial divisions in the cylinder 2 \n\nFourier order 4 \n\nNumber of nodes 48,922 \n\nNumber of elements 63,744 \n\nNumber of d.o.f.s 318,795 \n\nNumber of blocks 66,944 \n\nSource: own authorship. \n\n \n\n\n\n \n\n191 \n\n \n\nTable 10.7 \u2013 Mesh B. \n\nParameters Value \n\nAxial divisions in the tensile armors 973 \n\nAxial divisions in the cylinder 1946 \n\nRadial divisions in the cylinder 2 \n\nFourier order 6 \n\nNumber of nodes 237,534 \n\nNumber of elements 256,221 \n\nNumber of d.o.f.s 1,617,957 \n\nNumber of blocks 279,573 \n\nSource: own authorship. \n\n \n\n10.2 Hardware \n\nAll results from this chapter were generated with the workstation available in LMO \n\n(Laboratory of Offshore Mechanics) from the Polytechnic School of the University of \n\nSao Paulo, for which the complete specifications are listed in Table 10.8. This workstation \n\nhas an Intel\u00ae based motherboard that has the Turbo Boost Technology. \n\n \n\nTable 10.8 \u2013 Workstation specifications: 16 real cores available for scalability tests. \n\nWorkstation Super Micro: Super Server SYS-7048R-TR \n\nMotherboard X10DRi (Intel\u00ae C612 chipset; 16x DIMM slots) \n\n(2x) Intel Xeon E5-2630v4 (8cores, 25M Cache, 2.20 GHz) \n\n256GB (8x32GB) RAM Memory DDR4-2400 ECC LRDIMM \n\n12TB (2x6TB raid 0) Seagate 3.5\" 7.200 RPM 128MB cache 6GB/s \n\nSSD Intel P3500 1.2TB, NVMe PCIe 3.0 x4, MLC HHHL AIC 20nm 0.3DWPD \n\nNVIDIA PNY Quadro K1200 4GB DDR5 PCIe 2.0 \n\nWindows 10 Pro English \n\nSource: own authorship. \n\n \n\nAccording to (INTEL, 2018), \u201cIntel\u00ae Turbo Boost Technology  accelerates \n\nprocessor and graphics performance for peak loads, automatically allowing \n\n\n\n \n\n192 \n\n \n\nprocessor cores to run faster than the rated operating frequency if they\u2019re operating \n\nbelow power, current, and temperature specification limits. Whether the processor \n\nenters into Intel\u00ae Turbo Boost Technology 2.0 and the amount of time the \n\nprocessor spends in that state depends on the workload and operating \n\nenvironment\u201d. \n\n \n\nThis technology automatically increases the clock of the processor when it is at low \n\nload, which ends up accelerating the solution when few threads (or processors) are being \n\nused in the parallelization. Although very useful in practical situations, the Turbo Boost \n\nfeature misrepresents the scalability results and creates the false impression that the \n\nresults are not good enough. In this way, for a fair performance comparison, the Turbo \n\nBoost was disabled directly in the machine's BIOS. \n\n \n\n10.3 Definition of Speedup \n\nIn a perfectly parallel code, the simulation time is reduced by half by doubling the \n\nnumber of processors. However, this is not always achievable. System overheads, \n\nsynchronization points, barriers, sequential passages, among others, are examples of \n\nsituations that decrease the efficiency of the parallelization. In this way, in order to \n\nmeasure the success of the implementation, the parallel speedup is defined and given by \n\nthe formula: \n\n \n\n ? = \n?1\n??\n?  Eq. 10.1 \n\n \n\nwhere: \n\n\u2022 ?1 \u2013 is the sequential execution time or on 1 processor; \n\n\u2022 ?p \u2013 denotes the execution time on ? processors. \n\n \n\nThe speedup is used to evaluate the quality of the implementation and to compare \n\ndifferent parallelization strategies. \n\n \n\n\n\n \n\n193 \n\n \n\n10.4 Results of the Computation of the Element Stiffness \nMatrices \n\nThe computation of the element stiffness matrices is characterized by the high \n\nnumber of mathematical operations. However, since the elements are independent \n\nbetween each other, this operation is easily and also highly scalable. The simulation time \n\nof the computation of the element stiffness matrices in function of the number of threads \n\nfor Mesh A (Table 10.6) is shown in Fig. 10.6, while the speedup is represented in Fig. \n\n10.7. Before analyzing the results, it is important to discuss a feature from OpenMP, \n\ncalled schedule, which defines the loop distribution to the threads. In the implementation, \n\ntwo scheduling options were tested: the static, in which the loop is divided into equal-\n\nsized chunks (or as close to) with little system overhead; and dynamic, in which each \n\nthread receives a new chunk-sized block of loops when the previously received one has \n\nalready been executed, with extra overhead associated, but more appropriate when the \n\nprocesses differ considerably in execution time. With scheduling options already \n\nclarified, it proceeds then to the analysis of the results. Both graphs show that the static \n\nscheduling has limited scalability and is considerably slower than the dynamic one. Two \n\nreasons justify the low computational performance of the static scheduling: several types \n\nof finite elements, with different formulations and distinct stiffness matrices computation \n\ntimes; and the iteration through the elements of the model, as shown in Table 10.9, since \n\nan element may have only one stiffness matrix, which is the case of the helical beam, or \n\nmay have one stiffness matrix for each Fourier expansion order, which is the case of the \n\nsolids of revolution. These two reasons generate an imbalance in the static scheduling, \n\nmaking the dynamic one the most appropriate solution, despite the extra overhead, \n\nachieving results very close to the perfect scalability and attesting the quality of the \n\nimplementation. By using the EBE Matrix object, the necessary memory is allocated only \n\nonce at the beginning of the solver, since the dimensions of the blocks are known \n\nbeforehand, which avoids unnecessary reallocations and contributes to performance. \n\n \n\n \n\n\n\n \n\n194 \n\n \n\n \n\nFig. 10.6 \u2013 Simulation time of the computation of the element stiffness matrices for Mesh A (Table 10.6). \n\nSource: own authorship. \n\n \n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nT\nim\n\ne\n (\n\ns)\n\nThreads\n\nStatic Schedule Dynamic Schedule\n\n\n\n \n\n195 \n\n \n\n \n\nFig. 10.7 \u2013 Speedup of the computation of the element stiffness matrices for Mesh A (Table 10.6). \n\nSource: own authorship. \n\n \n\nTable 10.9 \u2013 Iteration procedure to compute the element stiffness matrices. \n\n \n\n1. Iteration over all elements \n \n\n1.1. Iteration over all orders/blocks of the element \n \n\n1.1.1. Computation of the stiffness matrix for the specified element and order \n \n\nSource: own authorship. \n\n \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nS\np\n\ne\ne\n\nd\nu\n\np\n\nThreads\n\nRef Static Schedule Dynamic Schedule\n\n\n\n \n\n196 \n\n \n\nAnalogous results were also obtained for Mesh B and are available in Fig. 10.8 and \n\nFig. 10.9. All analyses and conclusions made for the previous case remain valid for this \n\nnew mesh configuration. \n\n \n\n \n\nFig. 10.8 \u2013 Simulation time of the computation of the element stiffness matrices for Mesh B (Table 10.7). \n\nSource: own authorship. \n\n \n\n0\n\n5\n\n10\n\n15\n\n20\n\n25\n\n30\n\n35\n\n40\n\n45\n\n50\n\n55\n\n60\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nT\nim\n\ne\n (\n\ns)\n\nThreads\n\nStatic Schedule Dynamic Schedule\n\n\n\n \n\n197 \n\n \n\n \n\nFig. 10.9 \u2013 Speedup of the computation of the element stiffness matrices for Mesh B (Table 10.7). \n\nSource: own authorship. \n\n \n\nIn the EBE method, this operation is already completed after allocating and \n\ncomputing the element stiffness matrices. In the conventional finite element method, \n\nhowever, the sparse global stiffness matrix must be assembled, an operation that, if not \n\nproperly implemented, may compromise seriously the scalability.  \n\n \n\n10.5 Results of the EBE Matrix-Vector Product \n\nFor being executed at each iteration, the scalability of matrix-vector product affects \n\ndirectly the efficiency of the EBE-PCG algorithm. In this way, due to its importance, it \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nS\np\n\ne\ne\n\nd\nu\n\np\n\nThreads\n\nRef Static Schedule Dynamic Schedule\n\n\n\n \n\n198 \n\n \n\nwas decided to individually analyze the efficiency of this operation for the different types \n\nof developed synchronization mechanisms (discussed in Chapter 9), whose nomenclature \n\nused in the graph legends is in Table 10.10. \n\n \n\nTable 10.10 \u2013 Synchronization methods. \n\nSymbol Synchronization Method \n\nSYNC 1 Locks \n\nSYNC 2 Local Copies \n\nSYNC 3 Mapped Local Copies \n\nSYNC 4 Geometric- and Mesh-Mapped \n\nSource: own authorship. \n\n \n\nThe execution time, in milliseconds, of the matrix-vector product in function of the \n\nnumber of threads for Mesh A (Table 10.6) is illustrated in Fig. 10.10, while the speedup \n\ncurves are shown in Fig. 10.11. These results show that the synchronization method based \n\non geometric and mesh-mappings is the fastest alternative to perform the EBE matrix-\n\nvector product. The first two methods show limited scalability, mainly the method based \n\non local copies, because, as aforementioned, the number of operations to clean and to \n\nsynchronize the local copies grows linearly with the number of threads. This problem is \n\nmitigated in the third synchronization strategy, since the mapping of the local copies \n\nallows a reduction in the number of operations and thus obtain greater scalability. In this \n\nthird curve, there is an unexpected increase in the speedup for 10 threads, what is \n\nsuspected to be due the fact that the number of threads is a round and multiple number of \n\nthe total axial divisions. \n\n \n\n\n\n \n\n199 \n\n \n\n \n\nFig. 10.10 \u2013 Simulation time, in milliseconds, of the matrix-vector product for Mesh A (Table 10.6). \n\nSource: own authorship. \n\n \n\n0\n\n25\n\n50\n\n75\n\n100\n\n125\n\n150\n\n175\n\n200\n\n225\n\n250\n\n275\n\n300\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nT\nim\n\ne\n (\n\nm\ns)\n\nThreads\n\nSYNC 1 SYNC 2 SYNC 3 SYNC 4\n\n\n\n \n\n200 \n\n \n\n \n\nFig. 10.11 \u2013 Speedup of the matrix-vector product operation for Mesh A (Table 10.6). Source: own \n\nauthorship. \n\n \n\nAiming the understanding of the effect of model size on the efficiency of the \n\nimplemented EBE matrix-vector product, this operation was also tested for Mesh B \n\n(Table 10.7). The execution times in function of the number of threads for the different \n\nsynchronization mechanisms is shown in Fig. 10.12, while the speedup curves are in Fig. \n\n10.13. \n\n \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nS\np\n\ne\ne\n\nd\nu\n\np\n\nThreads\n\nRef SYNC 1 SYNC 2 SYNC 3 SYNC 4\n\n\n\n \n\n201 \n\n \n\n \n\nFig. 10.12 \u2013 Simulation time, in milliseconds, of the matrix-vector product for Mesh B (Table 10.7). \n\nSource: own authorship. \n\n \n\n0\n\n125\n\n250\n\n375\n\n500\n\n625\n\n750\n\n875\n\n1000\n\n1125\n\n1250\n\n1375\n\n1500\n\n1625\n\n1750\n\n1875\n\n2000\n\n2125\n\n2250\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nT\nim\n\ne\n (\n\nm\ns)\n\nThreads\n\nSYNC 1 SYNC 2 SYNC 3 SYNC 4\n\n\n\n \n\n202 \n\n \n\n \n\nFig. 10.13 \u2013 Speedup of the matrix-vector product operation for Mesh B (Table 10.7). Source: own \n\nauthorship. \n\n \n\nThe sequence of the fastest synchronization methods has remained the same in \n\nrelation to Mesh A, being the fourth method the most efficient of them. Nevertheless, it \n\nis interesting to note an increase in the speedup curves, mainly for the third and fourth \n\nsynchronization methods. Additionally, there was a performance approximation from the \n\nthird to the fourth method, which may justify the adoption of the mapped local copies as \n\nthe synchronization strategy for large-scale models, due to its generic nature, since the \n\nfourth method requires external mappings based on geometry and mesh.  \n\nA comparison between Mesh A and Mesh B is available in Table 10.11. Despite \n\nbeing in the same order of magnitude, the increase of the simulation time was slightly \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nS\np\n\ne\ne\n\nd\nu\n\np\n\nThreads\n\nRef SYNC 1 SYNC 2 SYNC 3 SYNC 4\n\n\n\n \n\n203 \n\n \n\nhigher than the increase of the number of degrees-of-freedom and the number of blocks. \n\nHowever, when comparing both meshes, it is important to consider the fact that the \n\nincrease of the Fourier expansion order generate element stiffness matrices of larger \n\ndimensions (for bridge contact element, for example), which consequently demands more \n\nmathematical operations for the execution of the product. By dividing the simulation time \n\nby the number of mathematical operations to perform the matrix vector product, although \n\nsimplistic, it shows that the relative cost has been maintained, indicating that the \n\nimplementation of this matrix-vector product is suitable for large-scale models. \n\n \n\nTable 10.11 \u2013 Result comparison between Mesh A and Mesh B. \n\nParameter Mesh A Mesh B Variation \n\nNumber of d.o.f.s 318,795 1,617,957 4.1x \n\nNumber of blocks 66,944 279,573 3.2x \n\nMinimum matrix-vector product \n\nsimulation time \n14.03 s 96.29 s 5.9x \n\nNumber of mathematical operations to \n\nexecute the matrix-vector product \n34,261,992 276,326,274 7.1x \n\nSimulation time / Nr of Operations 4.09E-07 3.48E-07 -0.15x \n\nSource: own authorship. \n\n \n\n10.6 Results of the EBE-PCG Algorithm \n\nThe analysis of the results proceeds then to the implemented EBE-PCG algorithm. \n\nThe graph from  Fig. 10.14 consists of the simulation time, in seconds, of the PCG \n\nalgorithm in function of the number of threads for Mesh A (Table 10.6), measured for the \n\ndifferent developed synchronization mechanisms. As expected, these results show that \n\nthe fourth synchronization strategy is the most efficient alternative to be applied to the \n\nPCG algorithm, taking around 315 seconds to solve a model with approximately 320,000 \n\ndegrees-of-freedom, with a total consumption of 421MB of RAM memory.  \n\n \n\n\n\n \n\n204 \n\n \n\n \n\nFig. 10.14 \u2013 Simulation time, in seconds, of the PCG algorithm in function of the number of threads for \n\nMesh A (Table 10.6). Source: own authorship. \n\n \n\nThe speedup curves from Fig. 10.14 show a good scalability of the fourth \n\nimplemented synchronization method, so that the algorithm could be further accelerated \n\nif more computational resources were available. It can also be noted a slight reduction of \n\nthe total scalability in comparison to the matrix-vector product results from item 10.5. \n\nThis is because, although the scalability of the PCG algorithm is strongly influenced by \n\nthe matrix-vector product, additional system overheads are introduced by the other \n\noperations of the method. \n\n \n\n0\n\n600\n\n1200\n\n1800\n\n2400\n\n3000\n\n3600\n\n4200\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nT\nim\n\ne\n (\n\ns)\n\nThreads\n\nSYNC 1 SYNC 2 SYNC 3 SYNC 4\n\n\n\n \n\n205 \n\n \n\n \n\nFig. 10.15 \u2013 Speedup of the PCG algorithm in function of the number of threads for Mesh A (Table \n\n10.6). Source: own authorship. \n\n \n\nThe PCG algorithm is composed of a series of very scalable and parallelizable \n\noperations, but that depend on the values of the previous ones. In other words, the iterative \n\nscheme is composed of a series of operations that cannot be performed concomitantly. \n\nThe reduce operations, for example, necessary to evaluate the values of alpha and beta, \n\nrepresent synchronization points, with associated system overhead, but these costs are \n\ndiluted as the size of the model increases. In addition to this, improved scalability of the \n\nmatrix-vector product was obtained with the larger model from Mesh B. Therefore, an \n\nincrease of the scalability of the implemented EBE-PCG algorithm is expected as model \n\nsize increases. \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nS\np\n\ne\ne\n\nd\nu\n\np\n\nThreads\n\nRef SYNC 1 SYNC 2 SYNC 3 SYNC 4\n\n\n\n \n\n206 \n\n \n\n \n\nFig. 10.16 illustrates the residue curve as function of the number of iterations for \n\nMesh A. This curve is important for the understanding of the convergence rate of the \n\nproblem and its format is directly associated with the used preconditioner. To achieve a \n\nresidual less than 1.0E-06, around 22,000 iterations were necessary. This considerably \n\nhigh number of iterations is due to the diagonal Jacobi preconditioner, which is \n\ncharacterized by simplicity and low computational cost, but with the disadvantage of the \n\nlimited convergence rate. \n\n \n\n \n\nFig. 10.16 \u2013 Residual curve for the diagonal Jacobi preconditioned algorithm for Mesh \n\nA (Table 10.6). Source: own authorship. \n\n \n\nThe low convergence rate of the Jacobi diagonal preconditioner represents a \n\nbottleneck to this implementation. That is because, by increasing the number of layers or \n\nfurther refining the mesh, not only does each iteration become more costly to be computed \n\n(what is expected and inevitable), but it also increases the total number of iterations to \n\nachieve the numerical convergence of the problem. The simulation of Mesh B, for \n\ninstance, required over 320,000 iterations and took around 9 hours to be completed with \n\n16 threads. \n\n\n\n \n\n207 \n\n \n\nThe efficiency of the preconditioner depends on the pattern of the global stiffness \n\nmatrix, in this case, of the types and combination of the finite macroelements being used. \n\nTo illustrate this, four different models with approximately 320,000 degrees-of-freedom \n\nwere simulated and the residual curves are shown in Fig. 10.17. To obtain approximate \n\nvalues of this amount of degrees-of-freedom, only the number of axial divisions was \n\nvaried (or increased). The first model consists of two layers of tensile armors, meshed \n\nwith helical beam macroelements. The second consists of the same two layers, but with \n\nthe addition of bonded contact between them. The third model is a single polymeric \n\nsheath, meshed with Fourier cylindrical macroelements. The last and fourth model is \n\nexactly the same three-layered simplified flexible pipe from Mesh A (Table 10.6). The \n\ncylindrical layer model was the one that converged with the smallest number of iterations. \n\nThese results show that the efficiency of the diagonal preconditioner is strongly affected \n\nby the presence of beam elements in the model.  \n\n \n\n \n\nFig. 10.17 \u2013 Comparison of residual curves for different models. Source: own authorship. \n\n \n\nMost examples in the literature deal with structural solid elements, including \n\n(GULLERUD &amp; DODDS JR, 2001), for instance. One of the examples presented by the \n\nauthors of the aforementioned work consists of a three-dimensional structure modeled \n\n\n\n \n\n208 \n\n \n\nwith 96,120 second-order isoparametric solid elements and 107,436 nodes (322,308 \n\ndegrees-of-freedom). Adopted a tolerance of 1.0 x 10-4, it were necessary 1,463 iterations \n\nfor convergence with the diagonal preconditioner, and 890 iterations with the Hughes-\n\nWinget version. When using the diagonal preconditioner, the difference in the number of \n\niterations between beam and solid elements is remarkable, showing that this version of \n\npreconditioner is not adequate for models with beam elements. \n\n \n\n10.7 Additional Results and Comparison with ANSYS\u00ae \n\nIn order to compare the efficiency of PipeFEM with a well-established finite element \n\nsoftware, the same simplified flexible pipe from Fig. 10.1 was also modeled in ANSYS\u00ae, \n\nin which the both tensile armor layers were meshed with second-order beam elements, \n\nBEAM189. Orientation keypoints were necessary to correctly rotate the cross-sections of \n\nthe beam elements in accordance with the helical pattern, otherwise they would be \n\nerroneously twisted. The polymeric sheath was meshed with second-order isoparametric \n\nsolid elements, SOLID186. The interface between both armor layers was modeled with \n\n3D line-to-line contact elements, CONTA176, in crossing condition and with contact \n\nradius stipulated as half of the cross-sections heights, which enables great results for \n\nbeam-to-beam contacts. In the interface between external armor and the external sheath \n\nit were employed 3D line-to-surface contact elements, CONTA177. For both interfaces, \n\nthe contact behavior was selected as \u201cbonded always\u201d. \n\nFor the aforementioned comparison, the flexible pipe models were submitted to a \n\ntraction case. The pipe was constrained in one of the ends and a traction-displacement of \n\n10 mm was imposed to all the three layers. Before proceeding to the performance \n\ncomparisons, however, it is important to consider that ANSYS\u00ae and PipeFEM have \n\ndistinct formulations. While ANSYS\u00ae uses the conventional finite element method, \n\nPipeFEM employs the finite macroelements formulated by PROVASI &amp; MARTINS \n\nspecifically for the modelling of flexible pipe. Therefore, for a fair comparison between \n\nANSYS\u00ae and PipeFEM, it is necessary to ensure that the element meshes are converged \n\nin both programs. In this way, convergence analyzes were carried out, always starting \n\nwith a coarse mesh and refining it incrementally. The convergence is certified by \n\nmonitoring the variation of the displacements (radial, circumferential and axial \n\ndirections) along the axial length of a tendon from the internal tensile armor. \n\n\n\n \n\n209 \n\n \n\nIt was decided to start the convergence analysis with PipeFEM, in which the element \n\nmesh has three control parameters: the number of axial divisions in the tensile armors (the \n\nnumber of axial divisions in the polymeric sheath is always the double); the number of \n\nradial divisions in the polymeric sheath; and the Fourier expansion order.  \n\nFirstly, the influence of the Fourier expansion order was analyzed. By fixing the \n\nnumber of axial and radial divisions (one hundred and two divisions, respectively), the \n\nFourier order was varied from zero to four. The displacements results, illustrated from \n\nFig. 10.18 to Fig. 10.20, show that order zero is enough for the problem. Despite the non-\n\nsymmetric geometry of each tendon, both tensile armor layers behave very closely to the \n\naxisymmetric for the traction case. This can be explained by the high number of tendons \n\nin both tensile layers (that are compatible with real project applications) and by the \n\nbonded contact interactions between all layers.  \n\n \n\n \n\nFig. 10.18 \u2013 Convergence in PipeFEM: radial displacements, in mm, along a tendon from the internal \n\ntensile layer (Fixed: 100 axial and 2 radial divisions). Source: own authorship. \n\n \n\n\n\n \n\n210 \n\n \n\n \n\nFig. 10.19 \u2013 Convergence in PipeFEM: circumferential displacements, in mm, along a tendon from the \n\ninternal tensile layer (Fixed: 100 axial and 2 radial divisions). Source: own authorship. \n\n \n\n \n\nFig. 10.20 \u2013 Convergence in PipeFEM: axial displacements, in mm, along a tendon from the internal \n\ntensile layer (Fixed: 100 axial and 2 radial divisions). Source: own authorship. \n\n \n\nIn sequence, the number of axial divisions were modified, while maintaining the \n\nnumber of radial divisions as 2 and the Fourier order as zero. The results are shown from \n\n\n\n \n\n211 \n\n \n\nFig. 10.21 to Fig. 10.23. It can be observed that the second case, with 50 divisions, is \n\nalready converged in all directions. \n\n \n\n \n\nFig. 10.21 \u2013 Convergence in PipeFEM: radial displacements, in mm, along a tendon from the internal \n\ntensile layer (Fixed: 2 radial divisions and 0 Order). Source: own authorship. \n\n \n\n \n\nFig. 10.22 \u2013 Convergence in PipeFEM: circumferential displacements, in mm, along a tendon from the \n\ninternal tensile layer (Fixed: 2 radial divisions and 0 Order). Source: own authorship.  \n\n\n\n \n\n212 \n\n \n\n \n\n \n\nFig. 10.23 \u2013 Convergence in PipeFEM: axial displacements, in mm, along a tendon from the internal \n\ntensile layer (Fixed: 2 radial divisions and 0 Order). Source: own authorship. \n\n \n\nLastly, another convergence analysis was also performed for PipeFEM. The number \n\nof radial divisions was fixed as one and the Fourier order as zero, while the number of \n\naxial divisions was changed. The graphs from Fig. 10.24 to Fig. 10.26 show that the \n\nnumerical convergence of the model is achieved with 30 axial divisions in the tensile \n\narmor layers, 1 radial division in the polymeric sheath and Fourier order 0. \n\n \n\n\n\n \n\n213 \n\n \n\n \n\nFig. 10.24 \u2013 Convergence in PipeFEM: radial displacements, in mm, along a tendon from the internal \n\ntensile layer (Fixed: 1 radial division and 0 Order). Source: own authorship. \n\n \n\n \n\nFig. 10.25 \u2013 Convergence in PipeFEM: circumferential displacements, in mm, along a tendon from the \n\ninternal tensile layer (Fixed: 1 radial division and 0 Order). Source: own authorship. \n\n \n\n\n\n \n\n214 \n\n \n\n \n\nFig. 10.26 \u2013 Convergence in PipeFEM: axial displacements, in mm, along a tendon from the internal \n\ntensile layer (Fixed: 1 radial division and 0 Order). Source: own authorship. \n\n \n\nThe statistics of execution time and memory consumption for several combinations \n\nof mesh parameters are presented in Table 10.12. The previous charts showed that \n\nconvergence was achieved in PipeFEM with 50 axial divisions, 1 radial division and \n\nOrder 0. With these mesh parameters, the flexible pipe model was built almost \n\nimmediately (0.102 seconds) and the numerical solution took 24.27 seconds, with a very \n\nlow RAM memory consumption of 61.8 MB. When considering a more conservative \n\nmesh, containing 50 axial divisions, 2 radial divisions and Order 4, the model still was \n\nbuilt in a fraction of seconds, while the solver took approximately 1 minute and consumed \n\n113.9 MB. \n\n \n\n\n\n \n\n215 \n\n \n\nTable 10.12 \u2013 Execution time and memory consumption in PipeFEM. \n\nMesh \n\nMesh parameters \n\nDOFs \nPCG  \n\niterations \n\nExecution time \nRAM \n\nmemory \nAxial Radial Order Model PCG Solver \n\nM1 30 1 0 21,354 9,900 0.075s 12.98s 13.25s 37.6 MB \n\nM2 50 1 0 72,720 12,800 0.102s 23.89s 24.27s 61.8 MB \n\nM3 50 2 0 73,023 12,800 0.104s 24.08s 24.47s 62.4 MB \n\nM4 50 2 4 80,295 13,800 0.107s 59.46s 59.94s 113.9 MB \n\nM5 100 1 0 144,720 15,800 0.167s 50.93s 51.63s 114.6 MB \n\nM6 100 2 0 145,323 15,800 0.167s 52.06s 52.75s 114.9 MB \n\nM7 100 2 4 159,795 16,600 0.168s 129.36s 130.19s 215.9 MB \n\nM8 200 2 0 289,923 21,600 0,290s 120.31s 121.59s 219.8 MB \n\nM9 200 2 4 318,795 22,800 0.297s 320.06s 326.66s 420.4 MB \n\n \n\nFig. 10.27 illustrates a parametric analysis of the memory consumption from \n\nPipeFEM in function of the number of the degrees-of-freedom, for the orders 0, 2 and 4, \n\nmaintaining constant the number of radial divisions as two and varying the number of \n\naxial divisions. These curves show that, for a fixed Fourier order, PipeFEM presents \n\nlinear growth in memory consumption, which is in complete agreement with the EBE \n\nmethod and demonstrates the quality of the implementation in this aspect. The change in \n\nthe Fourier expansion order has great impact in memory consumption, since it increases \n\nthe dimensions of a large portion of the element stiffness matrices of the model. \n\n \n\n\n\n \n\n216 \n\n \n\n \n\nFig. 10.27 \u2013 Memory consumption in function of the number of degrees-of-freedom in PipeFEM (Fixed: \n\n2 radial divisions). Source: own authorship. \n\n \n\nThe parametric analysis of the solver simulation time in function of the number of \n\ndegrees-of-freedom is illustrated in Fig. 10.28. The growth rate of the PCG simulation \n\ntime is a little higher than linear. This is because, when increasing model size, not only \n\nthe iterations become more costly, but also a higher number of them is required to the \n\nnumerical convergence of the algorithm (with the diagonal preconditioner). By dividing \n\nthese execution times by the respective total number of iterations, the graph from Fig. \n\n10.29 was obtained, which consists of the timer per iteration in function of the number of \n\ndegrees-of-freedom from PipeFEM. These results show that the cost per iteration \n\nincreases almost linearly with the number of degrees-of-freedom, indicating the \n\neffectiveness of the implementation.  \n\n \n\n0\n\n50\n\n100\n\n150\n\n200\n\n250\n\n300\n\n350\n\n400\n\n450\n\n0 50,000 100,000 150,000 200,000 250,000 300,000 350,000\n\nM\ne\n\nm\no\n\nry\n (\n\nM\nB\n\n)\n\nDegrees-of-freedom\n\nOrder 0 Order 2 Order 4\n\n\n\n \n\n217 \n\n \n\n \n\nFig. 10.28 \u2013 PCG simulation time in function of the number of degrees-of-freedom in PipeFEM. (Fixed: 2 \n\nradial divisions). Source: own authorship. \n\n \n\n \n\nFig. 10.29 \u2013 Time per iteration of the PCG algorithm in function of the number of degrees-of-freedom in \n\nPipeFEM (Fixed: 2 radial divisions). Source: own authorship. \n\n \n\nThe convergence analysis proceeds then to the ANSYS\u00ae software. In this mesh has \n\nfour control parameters: the number of axial divisions from the tensile armors; the number \n\n0\n\n50\n\n100\n\n150\n\n200\n\n250\n\n300\n\n350\n\n0 50,000 100,000 150,000 200,000 250,000 300,000 350,000\n\nP\nC\n\nG\n s\n\nim\nu\n\nla\nti\n\no\nn\n\n t\nim\n\ne\n  \n\n(s\n)\n\nDegrees-of-freedom\n\nOrder 0 Order 2 Order 4\n\n0.00\n\n2.00\n\n4.00\n\n6.00\n\n8.00\n\n10.00\n\n12.00\n\n14.00\n\n16.00\n\n0 50,000 100,000 150,000 200,000 250,000 300,000 350,000\n\nT\nim\n\ne\n p\n\ne\nr \n\nit\ne\n\nra\nti\n\no\nn\n\n (\nm\n\ns)\n\nDegrees-of-freedom\n\nOrder 0 Order 2 Order 4\n\n\n\n \n\n218 \n\n \n\nof radial, circumferential and axial divisions from the polymeric sheath. Nine \n\ncombinations of mesh parameters were simulated in ANSYS\u00ae and they are listed in Table \n\n10.13. \n\n \n\nTable 10.13 \u2013 Element meshes tested in ANSYS\u00ae for the convergence analysis. \n\nMesh \nTensile Armors Polymeric Sheath \n\nD.O.F.s \nAxial Radial Circumferential Axial \n\nM1 20 1 12 10 37,206 \n\nM2 20 1 12 20 47,286 \n\nM3 40 1 12 20 75,846 \n\nM4 40 1 12 40 96,006 \n\nM5 40 1 20 40 122,406 \n\nM6 40 1 40 40 188,406 \n\nM7 80 1 40 80 379,926 \n\nM8 80 2 40 80 532,086 \n\nM9 100 2 40 100 666,246 \n\n \n\nFig. 10.30 illustrates the convergence test in ANSYS\u00ae of the radial displacements, in \n\nmillimeters, along the axial length of a tendon from the inner tensile armor. Analogously, \n\nFig. 10.31 and Fig. 10.32 illustrate the convergence tests for the circumferential and axial \n\ndirections. These results show that the circumferential direction is the most sensitive one \n\nin relation to convergence, which only was completely obtained from the seventh mesh. \n\n \n\n\n\n \n\n219 \n\n \n\n \n\nFig. 10.30 \u2013 Convergence in ANSYS\u00ae: radial displacements, in mm, along a tendon from the internal \n\ntensile layer. Source: own authorship. \n\n \n\n \n\nFig. 10.31 \u2013 Convergence in ANSYS\u00ae: circumferential displacements, in mm, along a tendon from the \n\ninternal tensile layer. Source: own authorship. \n\n \n\n\n\n \n\n220 \n\n \n\n \n\nFig. 10.32 \u2013 Convergence in ANSYS\u00ae: axial displacements, in mm, along a tendon from the internal \n\ntensile layer. Source: own authorship. \n\n \n\nThe construction of the \u201cM7\u201d mesh in ANSYS\u00ae took 12 minutes and 55 seconds. \n\nThis high processing time is due the fact that the contact between the two tensile armor \n\nlayers had to be made helix-by-helix, what created 3,528 different contact pairs (the \n\nnumerical combination of the 56 tendons of internal tensile armor and the 63 tendons of \n\nthe external). A simpler unique contact pair methodology was also tested, with 56 lines \n\nin the master and 63 lines the contact regions, but this approach has lost robustness and \n\nstopped converging for some types of external applied loads, such as external pressure. \n\nIn addition to this, ANSYS\u00ae took 33 minutes and 18 seconds to numerically solve the \n\n\u201cM7\u201d model, and consumed approximately 12.5 GB of RAM memory (5.7 GB is relative \n\nto the graphic interface). Table 10.14 summarizes these numbers and also the \n\nconsumptions from the \u201cM8\u201d mesh. \n\n \n\nTable 10.14 \u2013 Execution time and memory consumption in ANSYS\u00ae. \n\nMesh Model construction Numerical solution \nMemory consumption  \n\n(graphic interface) \n\nM7 12min 55s 33min 18s 12.5 GB (5.7 GB) \n\nM8 25min 56s 41min 33s 18.5 GB (7.8 GB) \n\n \n\n\n\n \n\n221 \n\n \n\nLastly, the results of the converged mesh from PipeFEM (\u201cM2\u201d from Table 10.12) \n\nare compared with the results of the converged mesh from ANSYS\u00ae (\u201cM7\u201d from Table \n\n10.13). The radial, circumferential and axial displacements of a tendon in the internal \n\narmor as illustrated in Fig. 10.33, Fig. 10.34 and Fig. 10.35, respectively. There is no \n\nnotable differences in the results, attesting that the EBE-PCG algorithm was correctly \n\nimplemented in PipeFEM. It is important to consider, however, the performance \n\ndifferences between both programs. Regarding the construction of the model, it was \n\naccomplished in 0.102 seconds in PipeFEM, against 12 minutes and 55 seconds in \n\nANSYS\u00ae. Significant performance differences were also registered in the total simulation \n\ntime:  24.27 seconds in PipeFEM, versus 33 minutes and 18 seconds in ANSYS\u00ae. In \n\naddition, memory consumption was much lower in the developed program \n\n(approximately 12.5 GB in ANSYS\u00ae versus 61.8 MB in PipeFEM).  \n\n \n\n \n\nFig. 10.33 \u2013 Radial displacement of a tendon in the internal armor, traction loading. Source: own \n\nauthorship. \n\n \n\n\n\n \n\n222 \n\n \n\n \n\nFig. 10.34 \u2013 Circumferential displacement of a tendon in the internal armor, traction loading. Source: own \n\nauthorship. \n\n \n\n \n\nFig. 10.35 \u2013 Axial displacement of a tendon in the internal armor, traction loading. Source: own \n\nauthorship. \n\n \n\n\n\n \n\n223 \n\n \n\nTo solve the same simplified flexible pipe from Fig. 10.1, PipeFEM was 82 times \n\nfaster than ANSYS\u00ae, a reduction of almost two orders of magnitude, with a much lower \n\nmemory consumption (only 0.89% of the memory required by ANSYS\u00ae).  \n\nIn comparison to the dense version of MacroFEM, a massive reduction in memory \n\nconsumption was achieved, in more than three orders of magnitude. MacroFEM required \n\nmore than 60 GB of RAM memory to solve the pipe from Fig. 1.19, while it can be done \n\nin PipeFEM with less than 60 MB. In this case, gains were also obtained in simulation \n\ntime: the dense version of MacroFEM employs the MKL solver from the library \n\n\u201cMath.NET Numerics\u201d, which took approximately 15 minutes to solve the problem, while \n\nPipeFEM demanded only 34 seconds to solve the same problem. \n\nTherefore, it can be concluded that, despite the limitations of the rate of convergence \n\nof the diagonal preconditioner employed in the EBE-PCG algorithm, the implementation \n\nis very efficient in computational terms. If necessary, additional performance gains could \n\nbe achieved with the implementation and development of more complex preconditioners \n\nin the future. \n\n \n\n \n\n \n\n\n\n \n\n224 \n\n \n\n Conclusions \n\nThis work was motivated by memory and processing limitations on finite element \n\nstructural analysis of flexible pipes for offshore applications. The Element-by-Element \n\nmethod, characterized by the global stiffness matrix elimination, was chosen for its \n\npotential in memory reduction and processing capabilities, given its scalability and ease \n\nof parallelization. After an extensive literature review on numerical methods regarding \n\nthe EBE method, it was chosen the EBE Diagonal Preconditioned Conjugate Gradient \n\nMethod (EBE-PCG) algorithm. \n\nAiming higher computational performance, the finite macroelements formulated by \n\n(PROVASI, 2013) were converted to the C++ language, parallelized and implemented in \n\na new analysis tool, named as PipeFEM, entirely written in C++ and that explores \n\nparallelism. \n\nA fully indexed geometry and mesh data structure was developed, with the same \n\nfacilities of the item selection features found in the multi-purpose finite element package \n\nANSYS\u00ae (that are extremely useful for contact and load applications), but that also takes \n\nadvantage of the computational benefits of direct indexing and facilitates the \n\nimplementation and manipulation of three-dimensional finite elements. \n\nRegarding the numerical solution of the problem, the EBE-PCG algorithm was \n\nimplemented and parallelized with OpenMP. The scalability of the PCG algorithm is \n\ndirectly influenced by the efficiency of the matrix-vector product, an operation that, in \n\nthe element-by-element method, is computed in a local basis with the blocks that \n\ncomprise the model, and that requires synchronization techniques when performed in \n\nparallel. Four different synchronization strategies were developed, being the one based \n\non geometric- and mesh- based mappings the most efficient of them. Numerical \n\nexperiments showed a reduction of almost 92% in the EBE-PCG solution time of the \n\nparallelized version in comparison to the sequential one.  \n\nIn order to compare the efficiency of PipeFEM with the well-established finite \n\nelement package ANSYS\u00ae, a simplified flexible pipe was modeled in both software, \n\ncontaining two tensile armor layers and one polymeric sheath. Convergence tests were \n\ncarried out for a valid comparison. The displacement results from PipeFEM are in great \n\nagreement with ANSYS\u00ae and, thus, reliable. Regarding the construction of the flexible \n\n\n\n \n\n225 \n\n \n\npipe model, ANSYS\u00ae spent 12 minutes and 55 seconds, while PipeFEM took 0.102 \n\nseconds, a reduction of almost four orders of magnitude. To numerically solve the \n\nproblem, ANSYS\u00ae spent 33 minutes and 18 seconds, against 24.27 seconds in PipeFEM, \n\na difference of almost 82 times. In addition to this, PipeFEM presented a much lower \n\nmemory consumption, 61.8MB against 6.8GB in ANSYS\u00ae (already discount the graphic \n\ninterface).  \n\nIn comparison to the dense version of MacroFEM, a massive reduction in memory \n\nconsumption was achieved, in more than three orders of magnitude. MacroFEM required \n\nmore than 60 GB of RAM memory to solve the pipe from Fig. 1.19, while it can be done \n\nin PipeFEM with less than 60 MB. In this case, gains were also obtained in simulation \n\ntime: the dense version of MacroFEM employs the MKL solver from the library \n\n\u201cMath.NET Numerics\u201d, which took approximately 15 minutes to solve the problem, while \n\nPipeFEM demanded only 34 seconds to solve the same problem. \n\nDespite the limitations of the rate of convergence of the diagonal preconditioner \n\nemployed in the EBE-PCG algorithm, the implementation is very efficient in \n\ncomputational terms. Therefore, with the gains obtained in processing time and memory \n\nconsumption, it can be concluded that the objectives of this work were fulfilled. \n\nAs future activities, more complex preconditioners can be implemented or \n\ndeveloped, which would enable additional performance gains. \n\n\n\n \n\n226 \n\n \n\n References \n\nADELI, H., &amp; KUMAR, S. (1995). Distributed Finite-Element Analysis on Network of \n\nWorkstations \u2014 Algorithms. Journal of Structural Engineering, 10, 1448-1455. \n\ndoi:10.1061/(ASCE)0733-9445(1995)121:10(1448) \n\nAPI RP 17B . (2002). API RP 17B - Recommended Practice for Flexible Pipe (3rd ed.). \n\nAmerican Petroleum Institute. \n\nASEN 6367 - Chapter 11. (2013). Advanced Finite Element Methods (ASEN 6367) - \n\nSpring 2013. Retrieved 04 26, 2016, from Department of Aerospace Engineering \n\nSciences - University of Colorado at Boulder: \n\nhttp://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch11.d/A\n\nFEM.Ch11.pdf \n\nBARTELL. (2016). Carcass Machines. Retrieved 06 03, 2016, from Martell Machinery: \n\nhttp://www.bartellmachinery.com/carcass-machines?page_id=55 \n\nBARTELL. (2016). Pad Style Taping Heads. Retrieved 06 03, 2016, from Bartell \n\nMachinery: http://www.bartellmachinery.com/taping-heads?page_id=53 \n\nBRAGA, M., &amp; KALLEF, P. (2004). Flexible Pipe Sensitivity to Birdcaging and Armor \n\nWire Lateral Buckling. 23rd International Conference on Offshore Mechanics \n\nand Arctic Engineering (OMAE 2004), 139-146. doi:10.1115/OMAE2004-51090 \n\nCAREY, G., &amp; JIANG, B. (1986). Element-by-element linear and nonlinear solution \n\nschemes. Communications in Applied Numerical Methods, 145-153. \n\ndoi:10.1002/cnm.1630020205 \n\nCONTINENTAL. (2014). High Performance Flexible Lines. ContiTech Oil &amp; Marine. \n\nRetrieved from http://www.taurus-\n\nemerge.com/pages/brochures/downloads/Taurus_Oil_Marine_Hoses_20141201\n\n_en.pdf \n\nCOOK, R., MALKUS, D., PLESHA, M., &amp; WITT, R. (2002). Concepts and Applications \n\nof Finite Element Analysis (4rd ed ed.). New York, USA: Wiley,. \n\nCOUTINHO, A., ALVES, J., LANDAU, L., EBECKEN, N., &amp; TROINA, L. (1991). \n\nComparison of lanczos and conjugate gradients for the element-by-element \n\nsolution of finite element equations on the ibm 3090 vector computer. Computers \n\n&amp; Structures, 39(1-2), 47-55. doi:10.1016/0045-7949(91)90071-S \n\n\n\n \n\n227 \n\n \n\nCOUTINHO, A., ALVES, J., LANDAU, L., LIMA, E., &amp; EBECKEN, N. (1987). On the \n\napplication of an element-by-element lanczos solver to large offshore structural \n\nengineering problems. Computers &amp; Structures, 27-37. doi:10.1016/0045-\n\n7949(87)90179-9  \n\nGULLERUD, A., &amp; DODDS JR, R. (2001). MPI-based implementation of a PCG solver \n\nusing an EBE architecture and preconditioner for implicit, 3-D finite element \n\nanalysis. Computers and Structures, 79(5), 553-575. \n\ndoi:http://doi.org/10.1016/S0045-7949(00)00153-X \n\nHUGHES, J., LEVIT, I., &amp; WINGET, J. (1983-B). An element-by-element solution \n\nalgorithm for problems of structural and solid mechanics. Computer Methods in \n\nApplied Mechanics and Engineering, 36(2), 241\u2013254. \n\ndoi:http://doi.org/10.1016/0045-7825(83)90115-9 \n\nHUGHES, J., LEVIT, M., &amp; WINGET, J. (1983-A). Element-by-Element Implicit \n\nAlgorithms for Heat Conduction. Journal of Engineering Mechanics, 109(2), 576-\n\n585. \n\nHUGHES, T., &amp; FERENCZ, R. (1987). Large-scale vectorized implicit calculations in \n\nsolid mechanics on a Cray X-MP/48 utilizing EBE preconditioned conjugate \n\ngradients. Computer Methods in Applied Mechanics and Engineering, 215-248. \n\ndoi:10.1016/0045-7825(87)90005-3  \n\nHUGHES, T., &amp; FERENCZ, R. (1988). Fully vectorized EBE preconditioners for \n\nnonlinear solid mechanics: Applications to large-scale three-dimensional \n\ncontinuum, shell and contact/impact problems. in: R. Glowinski et al., eds., \n\nDomain Decomposition Methods for Partial Differential Equations , 261-280. \n\nHUISMAN. (2008). Pipe Tensioners. Retrieved 06 03, 2016, from Huisman Equipment: \n\nhttp://www.huismanequipment.com/en/products/pipelay/pipelay_components/pi\n\npe_tensioners \n\nINTEL. (2018, 02 19). Intel\u00ae Turbo Boost Technology 2.0. Retrieved from Higher \n\nPerformance When You Need It Most: \n\nhttps://www.intel.com/content/www/us/en/architecture-and-technology/turbo-\n\nboost/turbo-boost-technology.html \n\nKING, R., &amp; SONNAD, V. (1987). Implementation of an element-by-element solution \n\nalgorithm for the finite element method on a coarse-grained parallel computer. \n\nComputer Methods in Applied Mechanics and Engineering, 47-59. \n\ndoi:10.1016/0045-7825(87)90182-4 \n\n\n\n \n\n228 \n\n \n\nKISS, I., BADICS, Z., GYIMOTHY, S., &amp; PAVO, J. (2012). High locality and increased \n\nintra-node parallelism for solving finite element models on GPUs by novel \n\nelement-by-element implementation. 2012 IEEE Conference on High \n\nPerformance Extreme Computing (HPEC) (pp. 1 - 5). Waltham, MA: IEEE. \n\ndoi:10.1109/HPEC.2012.6408659  \n\nKISS, I., GYIMOTHY, S., BADICS, Z., &amp; PAVO, J. (2012). Parallel Realization of the \n\nElement-by-Element FEM Technique by CUDA. IEEE Transactions on \n\nMagnetics, 48(2), 507 - 510. doi:10.1109/TMAG.2011.2175905 \n\nLEVIT, I. (1987). Element by element solvers of order N. Computers &amp; Structures, 27(3), \n\n357-360. doi:10.1016/0045-7949(87)90058-7  \n\nLIU, Y., ZHOU, W., &amp; YANG, Q. (2007). A distributed memory parallel element-by-\n\nelement scheme based on Jacobi-conditioned conjugate gradient for 3D finite \n\nelement analysis. Finite Elements in Analysis and Design, 43, 494-503. \n\ndoi:10.1016/j.finel.2006.12.007 \n\nMALI. (2016). MALI Ges.m.b.H. Retrieved 06 03, 2016, from Machines for the Cable \n\nand Wire Industries - Flat Wire: http://www.mali.at/eng/proj_02.htm \n\nMART\u00cdNEZ-FRUTOS, J., &amp; HERRERO-P\u00c9REZ, D. (2015). Efficient matrix-free GPU \n\nimplementation of Fixed Grid Finite Element Analysis. Finite Elements in \n\nAnalysis and Design, 104, 61-71. doi:10.1016/j.finel.2015.06.005 \n\nMART\u00cdNEZ-FRUTOS, J., MART\u00cdNEZ-CASTEJ\u00d3N, P., &amp; HERRERO-P\u00c9REZ, D. \n\n(2015). Fine-grained GPU implementation of Assembly-Free Iterative Solver for \n\nFinite Element Problems. Computers &amp; Structures, 157, 9-18. \n\ndoi:10.1016/j.compstruc.2015.05.010 \n\nMUREN, J. (2007). Failure modes, inspection, testing and monitoring. PSA - NORWAY \n\n- Flexible Pipes. \n\nNOUR-OMID, B., PARLETT, B., &amp; RAEFSKY, A. (1987). Comparison of Lanczos with \n\nConjugate Gradient Using Element Preconditioning. Proceedings of the 1st \n\nInternational Conference on Domain Decomposition Methods. Paris, France. \n\nPDL GROUP. (2015, 09 11). PDL Global Dynamic Analysis: FPSO and Steep WAve \n\nRisers. Retrieved 06 05, 2016, from \n\nhttps://www.youtube.com/watch?v=irJBimOilNg \n\nPROVASI, R. (2013). Contribui\u00e7\u00e3o ao Projeto de Cabos Umbilicais e Tubos Flex\u00edveis: \n\nFerramentas de CAD e Modelo de Macro Elementos. Tese de Doutorado, Escola \n\nPolit\u00e9cnica da Universidade de S\u00e3o Paulo. \n\n\n\n \n\n229 \n\n \n\nPROVASI, R., &amp; MARTINS, C. (2014). A Three-Dimensional Curved Beam Element \n\nfor Helical Components Modeling. Journal of Offshore Mechanics and Arctic \n\nEngineering, 136(4). doi:10.1115/1.4027956 \n\nPROVASI, R., &amp; MARTINS, C. A. (2013-a). A rigid connection for macro-elements with \n\ndifferent node displacement natures. International Offshore and Polar \n\nEngineering Anchorage, International Society of Offshore and Polar Engineers \n\n(ISOPE). Alaska, USA. \n\nPROVASI, R., &amp; MARTINS, C. A. (2013-b). A Contact Element for Macro-Elements \n\nwith Different Node Displacement Natures. International Offshore and Polar \n\nEngineering Anchorage, International Society of Offshore and Polar Engineers \n\n(ISOPE). Alaska, USA. \n\nPROVASI, R., &amp; MARTINS, C. A. (2013-c). A Finite Macro-Element for Orthotropic \n\nCylindrical Layer Modeling. Journal of Offshore Mechanics and Arctic \n\nEngineering, Volume 135, Issue 3. \n\nSAAD, Y. (2003). Iterative Methods for Sparse Linear Systems (2nd ed.). SIAM, ISBN \n\n978-0-898715-34-7. \n\nSTROUD, I. (2006). Boundary Representation Modelling Techniques. London: Springer. \n\nTHIAGARAJAN, G., &amp; ARAVAMUTHAN, V. (2002). Parallelization Strategies for \n\nElement-by-Element Preconditioned Conjugate Gradient Solver Using High-\n\nPerformance Fortran for Unstructured Finite-Element Applications on Linux \n\nClusters. Journal of Computing in Civil Engineering, 1-10. \n\ndoi:10.1061/(ASCE)0887-3801(2002)16:1(1) \n\nTONI, F.G. (2014). Ferramenta Eficiente para An\u00e1lise Estrutural de Tubos Flex\u00edveis \n\nUsando Macroelementos Finitos. In Projeto de Conclus\u00e3o de Curso. Escola \n\nPolit\u00e9cnica da Universidade de S\u00e3o Paulo. \n\nWINGET, J., &amp; HUGHES, T. (1985). Solution algorithms for nonlinear transient heat \n\nconduction analysis employing element-by-element iterative strategies. Computer \n\nMethods in Applied Mechanics and Engineering, 52 (1-3), 711-815. \n\ndoi:10.1016/0045-7825(85)90015-5"}]}}}