{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-BP.03761"}, {"@name": "filename", "#text": "15-Romulo_Albuquerque_Pereira.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "| Romulo Albuquerque Pereira | Arnaldo Vieira Moura | Cid Carvalho de Souza\nEstrat\u00e9gia GRASP para escalonar atividades de desenvolvimento de po\u00e7os de petr\u00f3leo /grasp strategy for the scheduling of oil well development activities\nresumo\nPALAVRA-CHAVE:\n\u25a1\tprodu\u00e7\u00e3o de petr\u00f3leo offshore\n\u25a1\tdesenvolvimento de po\u00e7os de petr\u00f3leo\n\u25a1\tGRASP\n\u25a1\tprograma\u00e7\u00e3o por restri\u00e7\u00f5es\n\u25a1\tescalonamento\n\u25a1\totimiza\u00e7\u00e3o combinat\u00f3ria\n\u25a1\theur\u00edsticas.\nKEYWORDS:\n\u25a1\toffshore oil production\n\u25a1\tdevelopment of oil wells\n\u25a1\tGRASP\n\u25a1\tconstraint program\n\u25a1\tscheduling\n\u25a1\tcombinatorial optimization\n\u25a1\theuristics.\nAntes que locais promissores de bacias petrol\u00edferas sejam efetivamente desenvolvidos em po\u00e7os de petr\u00f3leo produtivos, \u00e9 necess\u00e1rio realizar diversas atividades de perfura\u00e7\u00e3o, completa\u00e7\u00e3o e interliga\u00e7\u00e3o nesses locais. O escalonamento dessas atividades deve satisfazer v\u00e1rias restri\u00e7\u00f5es conflitantes e buscar a maximiza\u00e7\u00e3o da produ\u00e7\u00e3o de petr\u00f3leo em um dado horizonte de tempo. Este artigo descreve um Greedy Randomized Adaptive Search Procedure (GRASP) para o escalonamento das atividades de desenvolvimento de po\u00e7os de petr\u00f3leo offshore. Os resultados s\u00e3o comparados com uma ferramenta de Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (PR), desenvolvida pela\nI abstract\nBefore promising oil basins are effectively developed into productive oil wells, it is necessary to conduct several drilling, completion and interconnection activities at such sites. The scheduling of these activities must satisfy several conflicting restrictions and also try to maximize the oil production within a given time frame. The present study describes a Greedy Randomized Adaptive Search Procedure (GRASP) to schedule the development of offshore oil wells. The results are compared to a Constraint Program (CP) tool developed by Petrobras, used and well accepted. Comparative results conducted in real instances indicate that the implementation of GRASP exceeds the RP tool, and produces significant production increase solutions.\n(Expanded abstract available at the end of the paper).\nPetrobras, em uso e bem aceita. Resultados comparativos realizados em inst\u00e2ncias reais indicam que a implementa\u00e7\u00e3o GRASP supera a ferramenta de PR, produzindo solu\u00e7\u00f5es com expressivos aumentos de produ\u00e7\u00e3o.\nintrodu\u00e7\u00e3o\nPetr\u00f3leo e g\u00e1s s\u00e3o combust\u00edveis f\u00f3sseis de larga utiliza\u00e7\u00e3o na sociedade atual, sendo aproveitados na fabrica\u00e7\u00e3o de pl\u00e1sticos, tintas, querosene, combust\u00edvel veicular e de avia\u00e7\u00e3o, g\u00e1s de cozinha e em muitas outras aplica\u00e7\u00f5es. Boa parte desses combust\u00edveis f\u00f3sseis \u00e9 hoje extra\u00edda de bacias oce\u00e2nicas, como a de Marlim, no Estado do Rio de Janeiro. A Petrobras \u00e9 umas das empresas pioneiras e l\u00edderes na explora\u00e7\u00e3o de petr\u00f3leo em \u00e1guas profundas, sendo tamb\u00e9m uma das 20 maiores empresas petrol\u00edferas do planeta. A Companhia explora diversas bacias petrol\u00edferas, cada uma com centenas de locais promissores onde po\u00e7os de petr\u00f3leo podem ser colocados em produ\u00e7\u00e3o. Entretanto, esses locais precisam ser desenvolvidos antes de se tornarem produtivos. Para realizar as atividades envolvidas no desenvolvimento de um po\u00e7o de petr\u00f3leo, a Petrobras utiliza sondas e navios; alguns alugados, outros de sua propriedade. Esses recursos s\u00e3o limitados e de alto custo, seja em sua aquisi\u00e7\u00e3o, seja no pre\u00e7o de aluguel. Dessa forma, os recursos devem ser utilizados eficientemente.\nO problema do Escalonamento no Desenvolvimento de Po\u00e7os de Petr\u00f3leo (EDP) pode ser definido como: dados um conjunto de po\u00e7os e as atividades a serem executadas em cada po\u00e7o e os recursos dispon\u00edveis para a execu\u00e7\u00e3o dessas atividades, determinar um se-q\u00fcenciamento das atividades em um dado horizonte de tempo, indicando seus instantes de in\u00edcio e fim e o recurso que a realizar\u00e1, de forma a otimizar uma fun\u00e7\u00e3o objetivo. Ou seja: maximizar a produ\u00e7\u00e3o de petr\u00f3leo. Este seq\u00fcenciamento leva em conta o deslocamento dos recursos e as diversas restri\u00e7\u00f5es operacionais. Nesse trabalho, o EDP \u00e9 estudado levando-se em conta as especificidades encontradas pela Petrobras na explora\u00e7\u00e3o de petr\u00f3leo em \u00e1guas profundas. As restri\u00e7\u00f5es operacionais e de engenharia ser\u00e3o apresentadas em\ndetalhes, bem como uma metaheur\u00edstica para a resolu\u00e7\u00e3o do problema.\nPropostas de solu\u00e7\u00e3o j\u00e1 foram desenvolvidas para problemas similares (Nascimento, 2002). Entretanto, o EDP inclui restri\u00e7\u00f5es de grande relev\u00e2ncia pr\u00e1tica que n\u00e3o s\u00e3o tratadas em outros trabalhos. Por exemplo, no EDP considera-se que o deslocamento dos recursos entre os po\u00e7os consome tempo e que, nesse per\u00edodo, o recurso fica indispon\u00edvel.\nNossas implementa\u00e7\u00f5es GRASP para resolver o EDP foram constru\u00eddas e testadas em diversas inst\u00e2ncias reais fornecidas pela Petrobras. A melhor implementa\u00e7\u00e3o GRASP para o EDP levaria a Companhia a um ganho de cerca de 16 milh\u00f5es de barris de petr\u00f3leo ou, aproximadamente, US$ 830 milh\u00f5es, na soma das solu\u00e7\u00f5es m\u00e9dias para todas as inst\u00e2ncias, quando comparado \u00e0s solu\u00e7\u00f5es geradas pelo resolvedor ILOG em uso na empresa. A vantagem do m\u00e9todo proposto fica ainda mais evidente quando se nota que o algoritmo foi integralmente desenvolvido com ferramentas gratuitas.\nO restante deste artigo est\u00e1 organizado como segue. A pr\u00f3xima se\u00e7\u00e3o descreve o EDP em detalhes. O algoritmo GRASP, proposto para o EDP, \u00e9 descrito em \"Uma Implementa\u00e7\u00e3o GRASP\". Em \"Resultados Computacionais\" s\u00e3o relatados os experimentos realizados com este algoritmo, incluindo an\u00e1lises comparativas \u00e0 ferramenta desenvolvida na Petrobras com o aux\u00edlio de um resolvedor comercial de PR. Finalmente, conclus\u00f5es s\u00e3o feitas na \u00faltima se\u00e7\u00e3o.\no escalonamento no desenvolvimento de po\u00e7os de petr\u00f3leo\nQuando um ponto \u00e9 considerado um promissor po\u00e7o de petr\u00f3leo, sondas s\u00e3o enviadas ao local para realizar as devidas opera\u00e7\u00f5es de perfura\u00e7\u00e3o. O desenvolvimento de um po\u00e7o, desde a determina\u00e7\u00e3o da sua localiza\u00e7\u00e3o at\u00e9 ser colocado em produ\u00e7\u00e3o, envolve v\u00e1rias etapas.\nAp\u00f3s perfurado, inicia-se o processo de prepara\u00e7\u00e3o do po\u00e7o para a extra\u00e7\u00e3o de petr\u00f3leo (completa\u00e7\u00e3o). Em\nprimeiro lugar \u00e9 instalada a \u00e1rvore de natal molhada (ANM) sobre a cabe\u00e7a do po\u00e7o para que a mat\u00e9ria-prima n\u00e3o extravase para o mar. Posteriormente, um navio LSV (logistic support vessel) leva uma tubula\u00e7\u00e3o da qual uma extremidade \u00e9 conectada \u00e0 ANM e a outra extremidade \u00e9 encaixada num manifold. Ou ent\u00e3o, sobe direto para a superf\u00edcie, sendo conectada a uma plataforma. Esse est\u00e1gio \u00e9 conhecido como interliga\u00e7\u00e3o. O manifold \u00e9 instalado por uma sonda ou por uma BGL (balsa guindaste de lan\u00e7amento), e seu uso evita que cada po\u00e7o necessite de tubula\u00e7\u00f5es exclusivas que o conecte desde o fundo do mar at\u00e9 a superf\u00edcie. Assim, as mangueiras de v\u00e1rios po\u00e7os relativamente pr\u00f3ximos podem se interligar ao manifold e, deste, uma \u00fanica tubula\u00e7\u00e3o sobe at\u00e9 a superf\u00edcie. Na aus\u00eancia de manifolds, e com o metro de tubula\u00e7\u00e3o tendo alto valor, o processo todo teria um valor excessivamente elevado.\nCompletado o processo de interliga\u00e7\u00e3o, parte-se para a extra\u00e7\u00e3o do petr\u00f3leo. Para isso, s\u00e3o colocadas bases de captura de petr\u00f3leo na superf\u00edcie do mar, conhecidas como UEP (Unidade Estacion\u00e1ria de Produ\u00e7\u00e3o), onde se armazenar\u00e1 o produto at\u00e9 que os navios venham recolh\u00ea-lo e lev\u00e1-lo para a terra. Se a vaz\u00e3o de petr\u00f3leo for muito elevada, pode-se optar pela instala\u00e7\u00e3o local de uma plataforma petrol\u00edfera.\nAs principais restri\u00e7\u00f5es envolvidas no processo de escalonamento das atividades de desenvolvimento dos po\u00e7os de petr\u00f3leo s\u00e3o:\n\u2022\tCl-Preced\u00eancia tecnol\u00f3gica: estabelece uma ordem entre as atividades. H\u00e1 quatro categorias de preced\u00eancia tecnol\u00f3gica:\n-\tFS(A,B): Atividade A deve terminar depois do in\u00edcio da atividade B;\n-\tSS(A,B): Atividade A deve iniciar depois do in\u00edcio da atividade B;\n-\tSF(A,B): Atividade A deve iniciar depois do fim da atividade B;\n-\tFF(A,B): Atividade A deve terminar depois do fim da atividade B.\n\u2022\tC2-Marco-atividade: uma atividade deve terminar antes ou iniciar depois de uma determinada data, ou marco, com ou sem lag. Essa data\nest\u00e1 geralmente relacionada com algum evento externo, e.g., a instala\u00e7\u00e3o de uma plataforma petrol\u00edfera.\n\u2022\tC3-Baseline: estabelece uma data de in\u00edcio para uma determinada atividade.\n\u2022\tC4-Restri\u00e7\u00f5es no uso dos recursos: para executar uma atividade, dependendo da sua natureza, \u00e9 necess\u00e1rio um recurso que atenda \u00e0s suas caracter\u00edsticas operacionais. Para uma atividade que requer um barco, deve ser verificado se os equipamentos dele podem operar na profundidade especificada. Para uma atividade que requer uma sonda, deve ser verificado:\n-\tseu tipo: ancorada, semi-submers\u00edvel com posicionamento din\u00e2mico (SSDP), navio sonda de posicionamento din\u00e2mico (NSDP) ou navio-sonda;\n-\tsuas caracter\u00edsticas: capacidades de carga, disponibilidade de top drive, opera\u00e7\u00e3o de condi\u00e7\u00f5es de alta press\u00e3o e alta temperatura (HPHT), caracter\u00edsticas do blowout preventer (BOP);\n-\tsua m\u00e1xima e m\u00ednima profundidade de opera\u00e7\u00e3o;\n-\tsua m\u00e1xima profundidade de perfura\u00e7\u00e3o.\n\u2022\tC5-Concorr\u00eancia: duas atividades do mesmo po\u00e7o n\u00e3o podem ser executadas simultaneamente. Similarmente, duas atividades n\u00e3o podem ser executadas por um mesmo recurso simultaneamente.\n\u2022\tC6-Indisponibilidade: os recursos podem estar indispon\u00edveis por um per\u00edodo de tempo por estar em manuten\u00e7\u00e3o ou devido ao t\u00e9rmino do contrato.\n\u2022\tC7-Seq\u00fc\u00eancias de po\u00e7os definidas pelo usu\u00e1rio: o usu\u00e1rio pode especificar uma seq\u00fc\u00eancia desejada para as atividades de perfura\u00e7\u00e3o ou para as atividades de in\u00edcio de produ\u00e7\u00e3o de diferentes po\u00e7os. A seq\u00fc\u00eancia \u00e9 uma lista ordenada de dois ou mais po\u00e7os, de tal forma que se o po\u00e7o A precede o po\u00e7o B na lista, ent\u00e3o a atividade Fa do po\u00e7o A deve terminar antes do in\u00edcio da atividade SB do po\u00e7o B. As atividades FA e SB\ns\u00e3o: atividades de perfura\u00e7\u00e3o ou atividades de in\u00edcio de produ\u00e7\u00e3o de seus respectivos po\u00e7os, dependendo do tipo da seq\u00fc\u00eancia. Essas seq\u00fc\u00ean-cias s\u00e3o especificadas por engenheiros de modo a evitar perda de press\u00e3o no campo petrol\u00edfero.\n\u2022\tC8-Restri\u00e7\u00e3o de superf\u00edcie: tamb\u00e9m conhecida como \"bolha assassina\", essa restri\u00e7\u00e3o representa uma \u00e1rea de seguran\u00e7a definida pelo usu\u00e1rio ao redor de cada po\u00e7o para que as sondas usadas em atividades desses po\u00e7os n\u00e3o colidam. A \u00e1rea restrita \u00e9 especificada por um pol\u00edgono fechado definido por coordenadas ao redor do po\u00e7o. Quando o centro do primeiro po\u00e7o est\u00e1 dentro da \u00e1rea restrita do segundo, as atividades executadas por sondas nesses po\u00e7os n\u00e3o podem ser simult\u00e2neas. Essas restri\u00e7\u00f5es devem ser verificadas entre cada par de sondas m\u00f3veis e entre cada par de sondas m\u00f3veis e ancoradas.\n\u2022\tC9-Cluster: uma atividade pode ser parte de um cluster, que \u00e9 um conjunto de atividades que devem usar o mesmo recurso.\n\u2022\tC10-Deslocamento de sonda: quando uma sonda se deslocar de um po\u00e7o para outro, um tempo de set-up ser\u00e1 considerado. Dessa forma, deslocamentos desnecess\u00e1rios devem ser evitados, por exemplo, fazendo com que uma sonda execute o m\u00e1ximo de atividades em um mesmo po\u00e7o.\nA produ\u00e7\u00e3o de petr\u00f3leo de um po\u00e7o \u00e9 calculada da seguinte forma: cada po\u00e7o tem uma vaz\u00e3o associada e uma atividade cujo prop\u00f3sito \u00e9 indicar o in\u00edcio da produ\u00e7\u00e3o. Quando esta \u00faltima atividade \u00e9 conclu\u00edda, o po\u00e7o \u00e9 considerado em produ\u00e7\u00e3o. A produ\u00e7\u00e3o \u00e9 calculada multiplicando-se a vaz\u00e3o de petr\u00f3leo do po\u00e7o pelo tempo restante desde o in\u00edcio da produ\u00e7\u00e3o at\u00e9 o horizonte de produ\u00e7\u00e3o estabelecido. Se o in\u00edcio da produ\u00e7\u00e3o ocorrer ap\u00f3s o horizonte de produ\u00e7\u00e3o, o montante de produ\u00e7\u00e3o correspondente ao po\u00e7o n\u00e3o ser\u00e1 considerado.\nO objetivo \u00e9 obter um escalonamento para todas as atividades de desenvolvimento, satisfazendo todas as restri\u00e7\u00f5es e maximizando a produ\u00e7\u00e3o de petr\u00f3leo. Outros objetivos a serem atingidos s\u00e3o (j\u00e1 obtidos pela ferramenta desenvolvida pela Petrobras):\n\u2022\tgerar solu\u00e7\u00f5es mais rapidamente. Solu\u00e7\u00f5es criadas por engenheiros levam muitas horas, at\u00e9 dias, para serem constru\u00eddas. Um m\u00e9todo mais r\u00e1pido permitiria a an\u00e1lise de diferentes cen\u00e1rios para o mesmo problema, por exemplo, acrescentando ou removendo recursos. Al\u00e9m disso, altera\u00e7\u00f5es nos planos n\u00e3o resultariam em novas horas ou dias em replanejamento;\n\u2022\tcom a automa\u00e7\u00e3o do escalonamento, engenheiros especializados que antes eram respons\u00e1veis por planejar o escalonamento podem ser realo-cados para outras \u00e1reas da empresa.\nPela descri\u00e7\u00e3o do problema e de suas restri\u00e7\u00f5es, pode ser observado que, al\u00e9m de lidarmos com uma aplica\u00e7\u00e3o real e de grande import\u00e2ncia, trata-se de um problema com v\u00e1rias particularidades, que o diferencia em rela\u00e7\u00e3o a problemas descritos na literatura (Nascimento, 2002). Para tratar desse mesmo problema, uma equipe da Petrobras desenvolveu um modelo de Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (Marriot e Stuckey, 1998) - usando as bibliotecas ILOG Solver e ILOG Scheduler (ILOG, 1999). Depois de quatro anos de planejamento, desenvolvimento e testes, a ferramenta, de nome ORCA (Otimiza\u00e7\u00e3o de Recursos Cr\u00edticos na Atividade de Produ\u00e7\u00e3o) tornou-se operacional e bem-sucedida. Atualmente, o resolvedor ORCA \u00e9 utilizado por engenheiros tanto para definir um bom escalonamento para as atividades de desenvolvimento de po\u00e7os, quanto para analisar a necessidade de adquirir ou alugar novos recursos. Os engenheiros confirmaram que o ORCA gera solu\u00e7\u00f5es t\u00e3o boas ou melhores que as feitas por humanos, al\u00e9m de levar poucos minutos de execu\u00e7\u00e3o. Como exemplo podemos citar que para uma inst\u00e2ncia real, o ORCA mostrou que comprar uma terceira sonda era desnecess\u00e1ria e que era melhor acrescentar um novo barco LSV.\nComo resultado, a Petrobras evitou o gasto de US$ 15 milh\u00f5es, al\u00e9m de antecipar o in\u00edcio de produ\u00e7\u00e3o dos po\u00e7os em 26 dias.\nApesar do bom desempenho do ORCA, buscar solu\u00e7\u00f5es ainda melhores \u00e9 importante para a Companhia, pois uma melhora, mesmo que percentualmente pequena, pode representar ganhos de milh\u00f5es de d\u00f3lares para a Petrobras.\nrela\u00e7\u00e3o entre o edp e o job shop scheduling\nEm v\u00e1rias decis\u00f5es e escolhas de par\u00e2metros em nosso resolvedor, tomamos como base alguns estudos e t\u00e9cnicas utilizadas para o problema cl\u00e1ssico do Job Shop Scheduling (JSP). Isso foi feito porque o EDP e o JSP podem ser facilmente relacionados, apesar de o EDP ser um problema bem mais complexo.\numa implementa\u00e7\u00e3o GRASP\nComo mencionado anteriormente, o resolvedor ILOG produziu bons resultados. Entretanto, para testar se outras abordagens gerariam solu\u00e7\u00f5es melhores - e tamb\u00e9m para efeito comparativo - outras t\u00e9cnicas foram consideradas para resolver o EDP. Entre elas, a Busca Tabu (Glover e Laguna, 1997 e 2000), a Ant Colony (Dorigo et al. 1996 e 1999) e a GRASP (Resende e Ribeiro, 2002; Binato et al. 2002). Busca Tabu \u00e9 uma metaheur\u00edstica muito estudada na literatura e que foi utilizada em uma vers\u00e3o mais simples deste problema (Nascimento, 2002). Por\u00e9m, algumas quest\u00f5es se mostraram dif\u00edceis de tratar, especialmente a defini\u00e7\u00e3o de uma vizinhan\u00e7a adequada e modos de explor\u00e1-la eficientemente. Ant Colony foi aplicado com sucesso num JSP (Colorni et al. 1994), mas sem resultados excepcionais (Dorigo et al. 1999). GRASP foi a abordagem que nos pareceu mais apropriada para\no EDP, pois se trata de uma metaheur\u00edstica bem-sucedida no tratamento de problemas de escalonamento (Aiex et al. 2003; Bard e Feo, 1989; Feo et al. 1995; Binato et al. 2002). Al\u00e9m disso, ao contr\u00e1rio do que ocorre com outras metaheur\u00edsticas, como a Busca Tabu e algoritmos gen\u00e9ticos, a vers\u00e3o b\u00e1sica do GRASP requer o ajuste de poucos par\u00e2metros.\nA pr\u00f3xima subse\u00e7\u00e3o descreve o GRASP, paradigma utilizado aqui para a constru\u00e7\u00e3o de um resolvedor denominado GRASPS. Posteriormente, s\u00e3o apresentadas t\u00e9cnicas avan\u00e7adas do GRASP, as quais s\u00e3o utilizadas para aprimorar o resolvedor. Em seguida, descrevemos o modelo e o algoritmo, i.e., o resolvedor propriamente dito.\ngreedy randomized adaptive search procedure (GRASP)\nA metodologia GRASP \u00e9 um processo iterativo onde cada itera\u00e7\u00e3o consiste de duas fases: Constru\u00e7\u00e3o e Busca Local (Resende e Ribeiro, 2002). A fase Constru\u00e7\u00e3o usa uma estrat\u00e9gia gulosa, acrescida de aleatoriedade para construir uma solu\u00e7\u00e3o fact\u00edvel, cuja vizinhan\u00e7a \u00e9 explorada posteriormente na fase Busca Local. Este processo \u00e9 repetido por diversas itera\u00e7\u00f5es, e a melhor solu\u00e7\u00e3o dentre as geradas em todas itera\u00e7\u00f5es do GRASP \u00e9 selecionada como resultado final.\nA Figura 1 ilustra uma implementa\u00e7\u00e3o gen\u00e9rica do bloco principal do GRASP em um pseudo-c\u00f3digo. As entradas para o algoritmo incluem par\u00e2metros para o ajuste do tamanho da lista de candidatos (TamLista), o n\u00famero m\u00e1ximo de itera\u00e7\u00f5es do GRASP (MaxIter), al\u00e9m\n\t1: 2:\tprocedure GRASP (TamLista, MaxIter, Semente) for k = 1 a MaxIter do\nFigura 1 - Pseudo-c\u00f3digo da\t3:\tSolucao&lt;\u2014 Constru\u00e7\u00e3o Solucao(TamLista, Semente);\nmetaheur\u00edstica da GRASP.\t4:\tSolucao&lt;\u2014 Busca Local (Solucao);\nFigure 1 - GRASP metaheuristic pseudo-code.\t5:\tAtualiza_Solucao(Solucao, Melhor_Solucao_Encontrada);\n\t6:\tend for\n\t7:\tretorna Melhor_Solucao_Encontrada;\n\t8:\tfim GRASP\nda Semente para o uso inicial na gera\u00e7\u00e3o de valores aleat\u00f3rios. As itera\u00e7\u00f5es do GRASP s\u00e3o mostradas nas linhas na seq\u00fc\u00eancia de 2 a 6. Cada itera\u00e7\u00e3o do GRASP, como dito anteriormente, consiste de uma fase Constru\u00e7\u00e3o (Construcao_Solucao), linha 3, uma fase Busca Local (Busca_Local), linha 4 e, se necess\u00e1rio, uma atualiza\u00e7\u00e3o da solu\u00e7\u00e3o encontrada (linha 5). O algoritmo Construcao_Solucao gera uma solu\u00e7\u00e3o fact\u00edvel para o problema, atualizando a vari\u00e1vel Solucao. De posse da solu\u00e7\u00e3o fact\u00edvel gerada, o algoritmo Busca_Local procura por uma solu\u00e7\u00e3o melhor que miniminiza ou maximiza uma fun\u00e7\u00e3o objetivo e atualiza a vari\u00e1vel Solucao. O algoritmo Atualiza_Solucao compara Solucao com Melhor_Solucao_Encontrada. Se a primeira for melhor, substitui a \u00faltima. Este processo de constru\u00e7\u00e3o, busca e atualiza\u00e7\u00e3o \u00e9 repetido MaxIter vezes.\nNa fase Constru\u00e7\u00e3o \u00e9 preparada uma solu\u00e7\u00e3o fact\u00edvel; um elemento de cada vez. Em cada itera\u00e7\u00e3o da Constru\u00e7\u00e3o, o pr\u00f3ximo elemento a ser adicionado \u00e9 determinado ordenando-se todos os poss\u00edveis elementos em uma lista de candidatos com respeito a uma fun\u00e7\u00e3o gulosa (greedy) que mede o benef\u00edcio de selecionar cada elemento nesse momento. Esta lista \u00e9 chamada de RCL (Restricted Candidate List). A componente adapt\u00e1vel da heur\u00edstica vem do fato de que os benef\u00edcios associados com cada elemento s\u00e3o atualizados a cada itera\u00e7\u00e3o da\nfase Constru\u00e7\u00e3o a fim de refletir as altera\u00e7\u00f5es incorporadas pela sele\u00e7\u00e3o dos elementos anteriores. A componente probabil\u00edstica do GRASP \u00e9 caracterizada pela escolha aleat\u00f3ria de um dos melhores candidatos da RCL, mas n\u00e3o necessariamente o melhor deles. Esta maneira de realizar a escolha permite a obten\u00e7\u00e3o de diferentes solu\u00e7\u00f5es fact\u00edveis em cada itera\u00e7\u00e3o do GRASP As solu\u00e7\u00f5es geradas pela fase Constru\u00e7\u00e3o do GRASP n\u00e3o s\u00e3o garantidamente \u00f3timas com respeito \u00e0s defini\u00e7\u00f5es da vizinhan\u00e7a usadas na fase Busca Local. Portanto, \u00e9 quase sempre ben\u00e9fico aplicar uma Busca Local para tentar melhorar cada solu\u00e7\u00e3o constru\u00edda.\nA Figura 2 ilustra uma implementa\u00e7\u00e3o gen\u00e9rica do bloco Construcao_Solucao do GRASP, em pseudo-c\u00f3-digo. As entradas para o algoritmo incluem par\u00e2metros para o ajuste do tamanho da lista de candidatos (TamLista), al\u00e9m da Semente para uso inicial na gera\u00e7\u00e3o de valores aleat\u00f3rios. As itera\u00e7\u00f5es do bloco Constru-cao_Solucao s\u00e3o mostradas nas linhas de 2 a 8.\nUm algoritmo de busca local funciona de modo ite-rativo, trocando, sucessivamente, a solu\u00e7\u00e3o atual por uma solu\u00e7\u00e3o melhor de sua vizinhan\u00e7a. O algoritmo termina quando n\u00e3o \u00e9 encontrada solu\u00e7\u00e3o melhor para a fun\u00e7\u00e3o objetivo.\nA Figura 3 ilustra uma implementa\u00e7\u00e3o gen\u00e9rica do bloco Busca_Local do GRASP em pseudo-c\u00f3digo. A en-\n1: procedure Construcao_Solucao(TamLista, Semente)\n2: Solucao&lt;\u2014 0;\n3: Avaliar o custo incrementai dos candidatos;\n4: while A Solucao nao eh a solucao completa do\n5:\tConstruir a lista RCL(TamLista);\n6:\tSelecionar um elemento s da lista RCL aleatoriamente;\n7:\tSolucao&lt;r- Solucao U {s};\n8:\tReavaliar os incrementos nos custos;\n9: end while\n10: retorna Solucao;\n11: fim Construcao_Solucao\nFigura 2 - Pseudo-c\u00f3digo da fase constru\u00e7\u00e3o.\nFigure 2 - Construction phase pseudo-code.\n1: procedure Busca_Local(Solucao)\n2: while A Solucao nao eh otima localmente do\n3:\tEncontrar s\u2019c Vizinhanca(Solucao) com f(s\u2019) &lt;f(Solucao);\n4:\tSolucao&lt;\u2014 s\u2019;\n5: end while\n6: retorna Solucao;\n7: fim Busca_Local\nFigura 3 - Pseudo-c\u00f3digo da fase busca local.\nFigure 3 - Local search phase pseudo-code.\ntrada para o algoritmo inclui como par\u00e2metro a Solu\u00e7\u00e3o encontrada na fase Constru\u00e7\u00e3o (Solu\u00e7\u00e3o). As itera\u00e7\u00f5es do bloco Busca_Local s\u00e3o mostradas nas linhas de 2 a 4.\nEste algoritmo procura otimizar a solu\u00e7\u00e3o encontrada na fase Constru\u00e7\u00e3o atrav\u00e9s da busca de um vizinho melhor s'. Isto \u00e9, um elemento de menor (minimiza\u00e7\u00e3o) ou maior (maximiza\u00e7\u00e3o) valor, segundo a fun\u00e7\u00e3o objetivo (f ()). No caso de algoritmos de melhoria iterativa, a regra sobre qual vizinho ser\u00e1 selecionado \u00e9 chamada de pivoting rule (Yannakakis, 1997). Os exemplos dela s\u00e3o: first improvement rule (FIR) e best improvement rule (BIR). Na primeira, o algoritmo se move para a solu\u00e7\u00e3o vizinha t\u00e3o logo se encontre uma solu\u00e7\u00e3o melhor, enquanto na \u00faltima todos os vizinhos s\u00e3o verificados e o melhor \u00e9 escolhido.\nA metaheur\u00edstica GRASP tem sido aplicada com sucesso em diversos tipos de problemas de otimiza\u00e7\u00e3o combinat\u00f3ria, tais como: set covering, quadratic assigment, roteamento de ve\u00edculos, problemas de localiza\u00e7\u00e3o, conjunto m\u00e1ximo independente, feedback vertex set, planejamento de redes de transmiss\u00e3o, pla-nariza\u00e7\u00e3o de grafos, entre outros (Resende e Ribeiro, 2002). Para uma bibliografia detalhada vide (Binato et al. (2002) e Resende e Festa (2003).\nt\u00e9cnicas avan\u00e7adas do GRASP\nNesta se\u00e7\u00e3o consideraremos as melhorias e as t\u00e9cnicas alternativas para aprimorar o GRASP padr\u00e3o.\n\u2022 Fun\u00e7\u00f5es tendenciosas: Na fase Constru\u00e7\u00e3o do GRASP padr\u00e3o, o pr\u00f3ximo elemento a ser introduzido na solu\u00e7\u00e3o \u00e9 escolhido aleatoriamente\ndentre os candidatos da RCL. Aos elementos da RCL s\u00e3o atribu\u00eddas as mesmas probabilidades de serem escolhidos. Entretanto, qualquer distribui\u00e7\u00e3o de probabilidades pode ser utilizada. Bresina (1996) prop\u00f4s um mecanismo de constru\u00e7\u00e3o baseado no ranking r(a) atribu\u00eddo a cada elemento candidato a, dependendo do valor da fun\u00e7\u00e3o gulosa v(a). Todavia, como a ordena\u00e7\u00e3o para a obten\u00e7\u00e3o do ranking \u00e9 O(nlog(n)), onde n \u00e9 o n\u00famero de elementos da RCL - e deve ser repetido a cada escolha de elemento e para cada solu\u00e7\u00e3o\n-\tesse processo poderia prejudicar o desempenho do algoritmo. Assim, decidimos n\u00e3o adot\u00e1-lo. Utilizamos apenas o valor v (a) dos candidatos para criarmos as seguintes fun\u00e7\u00f5es tendenciosas:\n-\tuniforme: bias(a)=1\n-\tlinear: bias(a)=v(a)\n-\tlogar\u00edtmica: bias(a)=ln(v(a))\n-\texponencial: bias(a)=e<v(a\u00ed)\n-\tquadr\u00e1tica: bias(a)=v(a)2\n-\tbaseada em raiz quadrada: bias(a)=lv(a)\nTendo sido calculado o valor da fun\u00e7\u00e3o tendenciosa escolhida, a probabilidade do candidato a ser escolhido \u00e9 (equa\u00e7\u00e3o 1):\n(1) ^bias (a1)\naeRCL\n\u2022 Proximate optimality principle (POP): Esta t\u00e9cnica se baseia na id\u00e9ia de que se temos uma boa solu\u00e7\u00e3o em um n\u00edvel da \u00e1rvore de decis\u00f5es,\nent\u00e3o \u00e9 muito prov\u00e1vel que no pr\u00f3ximo n\u00edvel teremos uma solu\u00e7\u00e3o pelo menos quase t\u00e3o boa (Glover e Manuel Laguna, 1997). Fleurent e Glover (1999) deram uma interpreta\u00e7\u00e3o GRASP para esse princ\u00edpio. Eles sugeriram que imperfei\u00e7\u00f5es introduzidas durante os passos da fase Constru\u00e7\u00e3o do GRASP poderiam ser minimizadas ao se aplicar uma busca local ao longo (e n\u00e3o apenas no fim) dessa fase. Por raz\u00f5es de efici\u00eancia, uma implementa\u00e7\u00e3o pr\u00e1tica do POP para GRASP seria aplicar a busca local em alguns pontos da fase de Constru\u00e7\u00e3o, e n\u00e3o ap\u00f3s a escolha de cada elemento. Binato et al. (2002) propuseram para um problema JSP que a busca local fosse aplicada quando 40% e 80% dos elementos tivessem sido escolhidos, assim como ao final da fase Constru\u00e7\u00e3o. Devido \u00e0 relativa semelhan\u00e7a entre o JSP e o EDP (vide item \"Rela\u00e7\u00e3o entre o EDP e o Job Shop Scheduling\"), e com testes bem-sucedidos realizados, os mesmos valores foram adotados para o resolvedor GRASP\nUma poss\u00edvel defici\u00eancia no GRASP padr\u00e3o \u00e9 a independ\u00eancia de suas itera\u00e7\u00f5es, i.e., o fato de n\u00e3o aprender com as solu\u00e7\u00f5es encontradas em itera\u00e7\u00f5es anteriores. Isso acontece porque o algoritmo padr\u00e3o descarta informa\u00e7\u00f5es a respeito das solu\u00e7\u00f5es encontradas, armazenando somente a melhor solu\u00e7\u00e3o at\u00e9 ent\u00e3o. Informa\u00e7\u00f5es obtidas de boas solu\u00e7\u00f5es podem ser utilizadas para implementar estrat\u00e9gias baseadas em mem\u00f3ria. Mostramos algumas dessas estrat\u00e9gias a seguir:\n\u2022 Intensifica\u00e7\u00e3o: Fleurent e Glover (1999) observaram que o GRASP padr\u00e3o n\u00e3o usava uma mem\u00f3ria de longo prazo (informa\u00e7\u00e3o obtida de itera\u00e7\u00f5es anteriores), e propuseram um esquema para uso dessa mem\u00f3ria em heur\u00edsticas. Mem\u00f3ria de longo prazo \u00e9 um dos fundamentos da Busca Tabu. O esquema criado mant\u00e9m um conjunto de solu\u00e7\u00f5es elites, sendo que para pertencer a esse conjunto, uma solu\u00e7\u00e3o deve ser a melhor dentre as solu\u00e7\u00f5es elites em rela\u00e7\u00e3o a uma fun\u00e7\u00e3o objetivo ou ser melhor que a pior entre as solu\u00e7\u00f5es elites e, suficientemente, diferente das outras solu\u00e7\u00f5es do conjunto. Em nosso proble\nma, uma solu\u00e7\u00e3o \u00e9 suficientemente diferente da outra se o n\u00famero de atividades que t\u00eam in\u00edcio, ou recurso diferente, entre as solu\u00e7\u00f5es for maior que o n\u00famero de atividades dividido pelo n\u00famero de recursos. Como o n\u00famero de recursos \u00e9 usualmente menor que cinco, duas solu\u00e7\u00f5es ser\u00e3o suficientemente diferentes se pelo menos 20% de suas atividades diferirem no tempo de in\u00edcio ou no recurso. Para o problema sendo tratado, mostramos agora como as solu\u00e7\u00f5es elites influenciar\u00e3o a escolha dos candidatos na fase Constru\u00e7\u00e3o do GRASP Para cada candidato a calculamos a fun\u00e7\u00e3o intensidade Int(a) da seguinte forma (equa\u00e7\u00e3o 2):\nZProd(e)\nInt (a) = \u2014\u2014-----------\nMaxe.e\u00a3 Prod(ey)\n(2)\nPara essa fun\u00e7\u00e3o, S \u00e9 o conjunto formado pelas solu\u00e7\u00f5es elites em que o elemento a tem a mesma data de in\u00edcio e recurso que na solu\u00e7\u00e3o sendo constru\u00edda, Prod() retorna o valor da produ\u00e7\u00e3o de petr\u00f3leo total da solu\u00e7\u00e3o, E \u00e9 o conjunto de solu\u00e7\u00f5es elites e Max retorna o m\u00e1ximo dentre os valores. Sendo qtasIter a quantidade de itera\u00e7\u00f5es realizadas pelo GRASP at\u00e9 o momento, e k um fator a ser fixado, determinamos ent\u00e3o a fun\u00e7\u00e3o tendenciosa usando tamb\u00e9m a de intensidade (equa\u00e7\u00e3o 3):\nbiaSlnt(a)=biaS(\u00ab) + lnt(a)x,>taslter k\n(3)\nA fra\u00e7\u00e3o qtasIter/k tem o prop\u00f3sito de dar mais peso \u00e0 intensidade \u00e0 medida que aumenta o n\u00famero de itera\u00e7\u00f5es e a qualidade das solu\u00e7\u00f5es elites nas quais a fun\u00e7\u00e3o se baseia.\n\u2022 Path-relinking (P-R): essa t\u00e9cnica foi proposta originalmente por Glover (1996) como uma estrat\u00e9gia de intensifica\u00e7\u00e3o que explora trajet\u00f3rias entre solu\u00e7\u00f5es elites obtidas pela Busca Tabu ou na t\u00e9cnica scatter search (Glover, 2000; Glover e Laguna, 1997; Glover et al. 2000). Iniciando com uma ou mais solu\u00e7\u00f5es elite, os caminhos no espa-\n\u00e7o de busca de uma solu\u00e7\u00e3o indo em dire\u00e7\u00e3o as solu\u00e7\u00f5es elite s\u00e3o gerados e usados para se obter melhores resultados. Isso \u00e9 feito atrav\u00e9s da sele\u00e7\u00e3o de movimentos que introduzam bons atributos da solu\u00e7\u00e3o guia. O uso do path-relinking num procedimento GRASP foi proposto inicialmente por Glover et al. (2000). Posteriormente, diversas extens\u00f5es, melhorias e aplica\u00e7\u00f5es bem-sucedidas foram desenvolvidas (Aiex et al. 2001; Canuto et al. 2001; Resende e Ribeiro, 2001). Duas estrat\u00e9gias b\u00e1sicas consideradas s\u00e3o:\n-\tterminada toda a busca, aplicar o P-R entre os pares de solu\u00e7\u00f5es elites;\n-\taplicar o P-R ap\u00f3s a busca local de cada itera\u00e7\u00e3o, entre a solu\u00e7\u00e3o obtida e algumas das solu\u00e7\u00f5es elites.\nDe acordo com Resende e Ribeiro (2002), a segunda alternativa \u00e9 a mais promissora. Outra considera\u00e7\u00e3o, tamb\u00e9m citada em Resende e Ribeiro (2002), \u00e9 que ir e voltar no P-R, i.e., ir da solu\u00e7\u00e3o X para a Y, e da Y para a X, resulta em poucos ganhos e demanda o dobro do tempo. Assim, \u00e9 recomend\u00e1vel explorar um \u00fanico caminho e sempre o da melhor solu\u00e7\u00e3o para a pior, j\u00e1 que as solu\u00e7\u00f5es de qualidade superior tendem a ser encontradas numa vizinhan\u00e7a pr\u00f3xima a melhor (Resende e Ribeiro, 2002).\n\u2022\tBusca local seletiva: outra alternativa a ser aplicada no GRASP padr\u00e3o \u00e9 a aplica\u00e7\u00e3o da busca local apenas nas solu\u00e7\u00f5es razoavelmente diferentes das solu\u00e7\u00f5es elites, ou que tenham uma qualidade boa, e.g., melhor que a pior dentre as elites. Com isso, tenta-se aplicar a busca local apenas onde h\u00e1 mais chances de se obter solu\u00e7\u00f5es melhores, aumentando a efici\u00eancia do algoritmo.\no resolvedor GRASPS\nO Resolvedor GRASPS foi desenvolvido usando a linguagem de programa\u00e7\u00e3o C/C++, atrav\u00e9s da defini\u00e7\u00e3o das classes apropriadas para o problema. Nesse modelo h\u00e1 dois tipos de vari\u00e1veis de valor inteiro:\n\u2022\tum tipo representa o in\u00edcio da execu\u00e7\u00e3o de uma\natividade de um po\u00e7o. Ele \u00e9 caracterizado por um m\u00ednimo e um m\u00e1ximo tempo de in\u00edcio. Para uma atividade ser escalonada, esse m\u00ednimo e m\u00e1ximo devem possuir o mesmo valor;\n\u2022\toutro tipo representa o recurso que executar\u00e1 uma atividade de um po\u00e7o. Ele \u00e9 caracterizado por um conjunto de poss\u00edveis recursos, que precisa ser unit\u00e1rio para a atividade estar escalonada.\nTodas as restri\u00e7\u00f5es descritas em \"O Escalonamento no Desenvolvimento de Po\u00e7os de Petr\u00f3leo\" foram impostas ao modelo. Tr\u00eas restri\u00e7\u00f5es, a saber, C2, C3 e C4, foram for\u00e7adas j\u00e1 na leitura dos dados do problema, antes do in\u00edcio da busca. Note que, nesses casos, todos os valores necess\u00e1rios para se impor as restri\u00e7\u00f5es j\u00e1 est\u00e3o definidos. As outras sete restri\u00e7\u00f5es foram tratadas durante a busca por solu\u00e7\u00e3o, ao serem disponibilizados valores \u00fanicos \u00e0s vari\u00e1veis.\nO bloco principal do GRASP, ilustrado na Figura 1, foi mantido quase intacto. As seguintes modifica\u00e7\u00f5es foram introduzidas:\n\u2022\to procedimento ser\u00e1 interrompido por tempo, e n\u00e3o pelo n\u00famero de itera\u00e7\u00f5es;\n\u2022\to par\u00e2metro TamLista \u00e9 atualizado iterativamente durante a busca. O valor de TamLista \u00e9 monoto-nicamente decrementado ou monotonicamente incrementado por um determinado valor quando uma certa quantidade de tempo \u00e9 alcan\u00e7ada sem se encontrar solu\u00e7\u00e3o melhor. Isso, respectivamente, nos permite focar numa heur\u00edstica mais gulosa, ou ent\u00e3o passar a explorar regi\u00f5es mais vastas do espa\u00e7o de busca. Com esse esquema, obtemos uma RCL de tamanho din\u00e2mico em oposi\u00e7\u00e3o a original RCL de tamanho est\u00e1tico.\nA fun\u00e7\u00e3o objetivo \u00e9 a maximiza\u00e7\u00e3o da produ\u00e7\u00e3o de petr\u00f3leo.\nNa fase Constru\u00e7\u00e3o, ilustrada na Figura 2, v\u00e1rias modifica\u00e7\u00f5es foram introduzidas. Descritas abaixo:\n\u2022\tna primeira vez que a fase Constru\u00e7\u00e3o \u00e9 iniciada, usamos o valor do par\u00e2metro TamLista igual a um, o que faz o algoritmo se comportar como uma heur\u00edstica gulosa pura. Note que, se h\u00e1\npoucas restri\u00e7\u00f5es obstruindo a heur\u00edstica gulosa, a tend\u00eancia \u00e9 gerar solu\u00e7\u00f5es boas ou at\u00e9 muito boas. Por exemplo: em seis inst\u00e2ncias entre as 17 testadas, a melhor solu\u00e7\u00e3o \u00e9 gerada pela estrat\u00e9gia puramente gulosa;\n\u2022\tos candidatos s\u00e3o definidos como sendo os po\u00e7os produtores dispon\u00edveis - ou seja, que ainda n\u00e3o foram escalonados e cujos po\u00e7os que devem preced\u00ea-los j\u00e1 foram escalonados - e os po\u00e7os injetores que devem preceder po\u00e7os produtores. Po\u00e7os injetores que n\u00e3o precisam necessariamente preceder po\u00e7os produtores s\u00e3o deixados para serem escalonados por \u00faltimo, j\u00e1 que n\u00e3o interferem na produ\u00e7\u00e3o de petr\u00f3leo. Escalonamos os po\u00e7os e n\u00e3o as atividades individuais porque, nesse \u00faltimo caso, a solu\u00e7\u00e3o apresentaria in\u00fameros deslocamentos de recursos entre po\u00e7os, havendo perda de tempo efetivamente produtivo;\n\u2022\ta avalia\u00e7\u00e3o do custo incremental (linha 3 da Figura 2) representa o quanto de petr\u00f3leo o po\u00e7o pode produzir at\u00e9 o fim do horizonte de produ\u00e7\u00e3o. A RCL \u00e9 constru\u00edda com aqueles po\u00e7os com a maior oferta de petr\u00f3leo. Consideramos tamb\u00e9m a oferta de petr\u00f3leo de po\u00e7os que precisam aguardar necessariamente o escalonamento do po\u00e7o em quest\u00e3o para passarem a serem considerados;\n\u2022\tna fase Constru\u00e7\u00e3o do GRASP padr\u00e3o, o pr\u00f3ximo elemento a ser introduzido na solu\u00e7\u00e3o \u00e9 escolhido aleatoriamente dentre os candidatos da RCL (linha 5 da Figura 2). Todos os elementos da RCL, ent\u00e3o, t\u00eam as mesmas probabilidades de serem escolhidos. Entretanto, qualquer distribui\u00e7\u00e3o de probabilidades poderia ser atribu\u00edda (vide \"T\u00e9cnicas Avan\u00e7adas do GRASP''). Algumas fun\u00e7\u00f5es tendenciosas foram experimentadas para a sele\u00e7\u00e3o dos candidatos;\n\u2022\tpara escalonar o po\u00e7o candidato (linha 7 da Figura 2), o seguinte algoritmo foi utilizado: Enquanto existir atividades n\u00e3o escalonadas no po\u00e7o:\n- escolha qualquer atividade dispon\u00edvel no po\u00e7o, i.e., uma atividade n\u00e3o escalonada e cujas atividades que devem preced\u00ea-la estejam escalonadas;\n-\tescolha o recurso para executar a atividade que atenda a todos os requisitos e que possa terminar a atividade o quanto antes;\n-\tatribua como tempo de in\u00edcio da atividade o instante mais cedo poss\u00edvel, i.e., o m\u00e1ximo entre o menor tempo a partir do qual o recurso est\u00e1 dispon\u00edvel e o m\u00ednimo tempo de in\u00edcio da atividade;\n-\tatualize os m\u00ednimos tempos de in\u00edcio de todas as atividades em que h\u00e1 a restri\u00e7\u00e3o de suceder \u00e0 atividade sendo tratada;\n-\tO escalonamento do po\u00e7o \u00e9 feito tentando satisfazer a todas as restri\u00e7\u00f5es, especialmente \u00e0quelas sete restri\u00e7\u00f5es ainda n\u00e3o impostas. Se alguma restri\u00e7\u00e3o \u00e9 violada, o que \u00e9 verificado ap\u00f3s o escalonamento de cada atividade, a constru\u00e7\u00e3o da solu\u00e7\u00e3o \u00e9 interrompida e uma nova constru\u00e7\u00e3o \u00e9 iniciada. Uma outra op\u00e7\u00e3o seria retornar um ou mais passos (backtrack) na tarefa de constru\u00e7\u00e3o. Contudo, isso poderia levar a um uso excessivo de tempo se houver a necessidade de v\u00e1rios backtracks, especialmente se o erro fosse causado por decis\u00f5es tomadas nas primeiras escolhas.\n\u2022 ap\u00f3s um po\u00e7o ser escalonado, todas as atividades que devem obrigatoriamente suced\u00ea-lo t\u00eam seus tempos m\u00ednimos de in\u00edcio atualizados de acordo com as restri\u00e7\u00f5es impostas. Se alguma inconsist\u00eancia surgir, a constru\u00e7\u00e3o da solu\u00e7\u00e3o \u00e9 interrompida e uma nova \u00e9 iniciada.\nJ\u00e1 que n\u00e3o h\u00e1 garantias de que a solu\u00e7\u00e3o encontrada na fase Constru\u00e7\u00e3o \u00e9 localmente \u00f3tima, uma busca local \u00e9 usada na tentativa de melhorar a solu\u00e7\u00e3o.\nO bloco principal da fase Busca Local, ilustrada na Figura 3, foi mantido. Um algoritmo de busca local foi escolhido e uma vizinhan\u00e7a apropriada foi definida a fim de permitir r\u00e1pidas explora\u00e7\u00f5es e solu\u00e7\u00f5es melhores. O algoritmo de busca local usado nesse resolvedor GRASP \u00e9 conhecido como two exchange, sendo baseado no modelo de grafos disjuntivos de Roy e Sussmann (1964). Esse mesmo algoritmo foi usado em Binato et al. (2002) para resolver um JSP, e devido a semelhan\u00e7a do JSP com\no EDP, utilizamos esse mesmo algoritmo aqui (vide \"Rela\u00e7\u00e3o entre o EDP e o Job Shop Scheduling\").\nPara aplicar a busca local two exchange ao EDP, dois elementos no escalonamento devem ser trocados. Por exemplo: se podemos trocar os elementos A e B e o escalonamento no recurso X fosse ... w X1 w A w X2 ... e no recurso Y fosse ... w Y1 B Y2 ..., o resultado da troca seria um escalonamento ... w X1 B\tX2\t... e ... w Y1 w A\tY2\t..., respec-\ntivamente, nos recursos X e Y Note tamb\u00e9m que os tempos de execu\u00e7\u00e3o dos elementos A e B podem ser diferentes. Portanto, todas as atividades ap\u00f3s eles precisam ter seus tempos de in\u00edcio atualizados.\nPrecisamos, agora, definir o que \u00e9 um elemento. Algumas op\u00e7\u00f5es s\u00e3o:\n\u2022\tAtividade: Usada em Nascimento (2002) numa vers\u00e3o mais simples deste problema. Apresenta uma granularidade muito pequena, o que leva a formar de vizinhan\u00e7as extensas. Al\u00e9m disso, na maioria das vezes, mover uma atividade para outra posi\u00e7\u00e3o nos for\u00e7aria a mover tamb\u00e9m seus predecessores e sucessores no po\u00e7o para evitar deslocamentos dos recursos, como previsto na restri\u00e7\u00e3o C10 (vide \"O Escalonamento no Desenvolvimento de Po\u00e7os de Petr\u00f3leo'');\n\u2022\tPo\u00e7o: Alta granularidade. O problema \u00e9 que as seq\u00fc\u00eancias de atividades de um mesmo po\u00e7o podem estar separadas no escalonamento, (e.g.: ... w A\n... A ...) devido a restri\u00e7\u00f5es de Preced\u00eancia Tecnol\u00f3gica (vide \"O Escalonamento no Desenvolvimento de Po\u00e7os de Petr\u00f3leo'') entre po\u00e7os. Ent\u00e3o, mover todas as partes demandaria um significativo tempo de execu\u00e7\u00e3o para verificar muitas restri\u00e7\u00f5es. Al\u00e9m disso, trocar um po\u00e7o inteiro pode n\u00e3o ser poss\u00edvel, e parte dele poderia ser;\n\u2022\tParte de um po\u00e7o: Define-se parte de um po\u00e7o como um conjunto m\u00e1ximo de atividades no po\u00e7o, escalonadas, consecutivamente, em um mesmo recurso. Possui granularidade m\u00e9dia e leva a poucos deslocamentos de sonda.\nNa nossa implementa\u00e7\u00e3o, escolhemos a \u00faltima op\u00e7\u00e3o. Dessa forma, o algoritmo de busca local tenta trocar todos os pares de partes de po\u00e7os, formando uma vizi\nnhan\u00e7a de ordem O(n2), onde n \u00e9 o n\u00famero de partes de po\u00e7os. Em m\u00e9dia, inst\u00e2ncias reais consistem de cerca de 26 po\u00e7os e cerca de 116 atividades. O n\u00famero de partes de po\u00e7os \u00e9, em m\u00e9dia, 7/6 do n\u00famero de po\u00e7os, ou 30 partes de po\u00e7os no total. O n\u00famero de trocas seria ent\u00e3o da ordem de (30 x 29)/2, ou 435. Se tom\u00e1ssemos atividades como nossos elementos, a vizinhan\u00e7a seria da ordem de (117 x 116)/2, ou 6 786, i.e., 15 vezes maior.\nPara terminar a especifica\u00e7\u00e3o do algoritmo de busca local, precisamos definir como a vizinhan\u00e7a ser\u00e1 explorada e qual solu\u00e7\u00e3o vizinha substituir\u00e1 a solu\u00e7\u00e3o corrente. Conforme pode ser visto em \"Greedy Randomized Adaptive Search Procedure (GRASP)\", pode-se optar pela estrat\u00e9gia FIR ou pela estrat\u00e9gia BIR. Em qualquer um dos casos, para a busca local two exchange, o tempo de execu\u00e7\u00e3o no pior caso \u00e9 de O(n2), onde n \u00e9 o n\u00famero de elementos da vizinhan\u00e7a. Ambas foram testadas.\nAl\u00e9m das modifica\u00e7\u00f5es ao GRASP padr\u00e3o assinaladas acima, todas as t\u00e9cnicas avan\u00e7adas apontadas em \"T\u00e9cnicas Avan\u00e7adas do GRASP\" foram implementadas e testadas.\nresultados computacionais\nNessa se\u00e7\u00e3o, resultados computacionais da implementa\u00e7\u00e3o GRASPS s\u00e3o apresentados e comparados aos obtidos com o resolvedor ILOG da Petrobras sobre as mesmas inst\u00e2ncias reais. Todos os testes foram executados em uma plataforma equipada com uma Sun SPARC Ultra 60 sob sistema operacional Solaris 9, processador de 450MHz e mem\u00f3ria RAM de 1 024 Mb. Tanto o GRASPS, quanto o resolvedor ILOG foram executados durante 1 800 segundos para cada inst\u00e2ncia.\ninst\u00e2ncias t\u00edpicas\nVinte e duas inst\u00e2ncias fornecidas pela Petrobras foram usadas em nossos testes. A Tabela 1 apresenta o conjunto de inst\u00e2ncias. Colunas com os mesmos dados referem-se a inst\u00e2ncias distintas, que diferem no n\u00famero de restri\u00e7\u00f5es n\u00e3o assinaladas na Tabela, como a C9.\nInst\u00e2ncia\t\t1\t2\t\t3\t4\t\t5\t\t6\t7\t8\t9\t\t10\t\t11\t12\t\n# po\u00e7os\t\t29\t22\t\t29\t29\t\t17\t\t22\t22\t29\t29\t\t22\t\t29\t22\t\n# atividades\t\t98\t107\t\t98\t98\t\t111\t\t107\t128\t98\t98\t\t107\t\t98\t107\t\n# barcos\t\t1\t1\t\t2\t1\t\t1\t\t2\t1\t1\t1\t\t2\t\t1\t2\t\n# sondas\t\t3\t2\t\t3\t3\t\t2\t\t2\t1\t3\t3\t\t2\t\t3\t2\t\n# C7\t\t0\t0\t\t0\t0\t\t0\t\t0\t0\t0\t0\t\t0\t\t0\t0\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tInst\u00e2ncia\t\t\t13\t14\t\t15\t\t16\t17\t18\t19\t\t20\t\t21\t22\t\t\n\t# po\u00e7os\t\t\t22\t22\t\t22\t\t22\t22\t22\t22\t\t22\t\t29\t65\t\t\n\t# atividades\t\t\t107\t107\t\t107\t\t107\t107\t107\t107\t\t107\t\t98\t338\t\t\n\t# barcos\t\t\t2\t2\t\t2\t\t1\t2\t2\t2\t\t2\t\t1\t1\t\t\n\t# sondas\t\t\t2\t2\t\t2\t\t2\t2\t2\t2\t\t2\t\t3\t2\t\t\n\t# C7\t\t\t1\t1\t\t1\t\t1\t1\t1\t1\t\t1\t\t2\t2\t\t\nTabela 1 - Inst\u00e2ncias testadas.\nTable 1 - Tested instances.\nA primeira parte da Tabela mostra as inst\u00e2ncias onde n\u00e3o havia restri\u00e7\u00f5es C7. Para reduzir a quantidade de tempo usado em testes, em alguns experimentos utilizamos apenas as sete inst\u00e2ncias mais representativas, eliminando as outras que diferiam por uma ou outra restri\u00e7\u00e3o apenas. A segunda parte da Tabela mostra as dez inst\u00e2ncias onde h\u00e1 restri\u00e7\u00f5es C7. Vale lembrar que, como o GRASP faz uso de aleatoriedade, cada inst\u00e2ncia foi testada cinco vezes, sendo reportada sempre uma m\u00e9dia dos resultados.\nO horizonte de produ\u00e7\u00e3o varia entre mil e tr\u00eas mil dias. Note que, quando todos os po\u00e7os est\u00e3o escalonados, a produ\u00e7\u00e3o \u00e9 igual entre todas as solu\u00e7\u00f5es at\u00e9 o horizonte de produ\u00e7\u00e3o. Assim sendo, os ganhos entre uma solu\u00e7\u00e3o e outra se d\u00e1 antes de todos os po\u00e7os estarem escalonados. Dessa forma, se consideramos todo o horizonte de produ\u00e7\u00e3o, diluem-se esses ganhos percentualmente ao total, diminuindo tamb\u00e9m a signifi-c\u00e2ncia dos resultados. Dessa forma, para cada inst\u00e2ncia utilizamos como horizonte de produ\u00e7\u00e3o o fim da \u00faltima atividade do po\u00e7o escalonado mais tarde entre todas as solu\u00e7\u00f5es dos resolvedores.\ndefinindo os par\u00e2metros do GRASPS\nEm \"O Resolvedor GRASPS\" apresentamos a id\u00e9ia de uma RCL de tamanho din\u00e2mico, na qual o n\u00famero de candidatos varia com o tempo. H\u00e1 duas formas de explorar uma RCL de tamanho din\u00e2mico: uma na qual o n\u00famero de candidatos decresce monotonicamente com o tempo sem melhorias para que, ap\u00f3s uma busca ampla, o algoritmo passe a focar em uma heur\u00edstica mais gulosa; e outra na qual cresce monotonicamente o n\u00famero de candidatos com o tempo sem melhorias para que, ampliando o espa\u00e7o de busca, consiga-se ir al\u00e9m de \u00f3timos locais. No primeiro caso, a RCL inicial tem tamanho max(13,w), sendo w o n\u00famero de po\u00e7os, onde \u00e9 decrescido de 1 a cada 300 s sem gera\u00e7\u00e3o de solu\u00e7\u00f5es melhores. No segundo caso, iniciamos com max(5,w) para o tamanho da RCL inicial, sendo esse valor acrescido de 1 a cada 300s sem gera\u00e7\u00e3o de melhores solu\u00e7\u00f5es. A primeira abordagem n\u00e3o gerou resultados satisfat\u00f3rios quando aplicada ao EDP, gerando as mesmas ou piores solu\u00e7\u00f5es comparadas \u00e0quelas geradas pelo GRASPS com RCL de tamanho est\u00e1tico. J\u00e1 a segunda estrat\u00e9gia se mostrou promissora. Na Figura 4, mostramos o comportamento do algoritmo em duas inst\u00e2ncias reais do EDP. Na Figura 4a, o algoritmo com\nBoletim t\u00e9cnico da Produ\u00e7\u00e3o de Petr\u00f3leo, Rio de Janeiro - volume 2, n\u00b0 1, p. 2 1 7 -23 9 \u25a1\n5\t'\t'\t' r\toe JHJMOLDGIA\nRCL de tamanho din\u00e2mico gera solu\u00e7\u00f5es melhores ap\u00f3s 150 mil itera\u00e7\u00f5es, quando a RCL \u00e9 aumentada. O mesmo acontece na Figura 4b, ap\u00f3s 50 mil itera\u00e7\u00f5es. Entre as doze inst\u00e2ncias testadas, quatro tiveram solu\u00e7\u00f5es melhores com a RCL de tamanho din\u00e2mico, totalizando um aumento na produ\u00e7\u00e3o de petr\u00f3leo de cerca de 261 mil barris. Nas outras oito inst\u00e2ncias, as mesmas solu\u00e7\u00f5es foram geradas.\nForam consideradas duas op\u00e7\u00f5es para a busca na vizinhan\u00e7a e selec\u00e3o de um novo vizinho: a first\nimprovement rule (FIR) e a best improvement rule (BIR) (vide \"Greedy Randomized Adaptive Search Procedure (GRASP)\"). Testes realizados com resolvedores utilizando essas t\u00e9cnicas mostraram uma superioridade da estrat\u00e9gia FIR. Em geral, um resolvedor usando a estrat\u00e9gia BIR encontra sua melhor solu\u00e7\u00e3o em menos itera\u00e7\u00f5es que um resolvedor usando a estrat\u00e9gia FIR, conforme pode ser visto na Figura 5a. Como as itera\u00e7\u00f5es FIR s\u00e3o mais r\u00e1pidas, na maioria dos casos o resolvedor equipado com a estrat\u00e9gia FIR encontra sua\n- -A- - BIR\t\u2014\u2666\u2014 FIR\n109.545- 2 109.540\t\tA\n\tA'\t\n\u00ae 109.530\tz\t\n\tA\t\no 109.520 7 109.515&lt;1> \u201d inQ Rin .\t1\t\n\t\t\n\t1 \"Ca i T\t\n\u00f5 109.505 109.500\t> 1\t\n\t\u25a0 Y\t\n0\t500\t1.000\t1.500\t2.000\t2.500\nTempo (s)\n-A--BIR\t\u2014\u2666\u2014 FIR\nTempo (s)\n(a)\n(b)\nI\nFigura 5 - BIR x FIR: exemplo 1.\nFigure 5 - BIR vs. FIR: example 1.\nmelhor solu\u00e7\u00e3o em um tempo de execu\u00e7\u00e3o menor; vide Figura 5b. Vale lembrar que, para o usu\u00e1rio, o tempo de execu\u00e7\u00e3o \u00e9 mais importante que o n\u00famero de itera\u00e7\u00f5es. Outro fator importante \u00e9 o valor da produ\u00e7\u00e3o das solu\u00e7\u00f5es encontradas. O resolvedor com a estrat\u00e9gia FIR se mostrou levemente superior, como pode ser visto nas Figuras 5 e 6. No total de todas as inst\u00e2ncias, o ganho foi de quase 80 mil barris de petr\u00f3leo, embora seja um ganho pequeno percentualmente. Dessa forma, o resolvedor que usa a estrat\u00e9gia FIR se mostrou o melhor para tratar o problema.\nOutra t\u00e9cnica considerada era a de distribui\u00e7\u00f5es de probabilidades tendenciosas a alguns candida\ntos com a maior oferta ou vaz\u00e3o de petr\u00f3leo. Cinco distribui\u00e7\u00f5es de probabilidades, al\u00e9m da totalmente uniforme, foram consideradas, conforme pode ser visto em \"T\u00e9cnicas Avan\u00e7adas do GRASP\". Testes comparativos foram realizados para avaliar qual das fun\u00e7\u00f5es tendenciosas seria mais adequada ao EDP. As fun\u00e7\u00f5es exponenciais e quadr\u00e1ticas geraram solu\u00e7\u00f5es bem piores, com produ\u00e7\u00e3o na soma de todas as inst\u00e2ncias de mais de dois milh\u00f5es de barris de petr\u00f3leo inferior \u00e0s outras alternativas. Entre as outras fun\u00e7\u00f5es, nota-se uma leve superioridade da estrat\u00e9gia denominada Raiz Quadrada, conforme pode ser visto na Figura 7.\n(a)\t(b)\nFigura 7 - Fun\u00e7\u00f5es tendenciosas.\tFigure 7 - Tendentious functions.\nas v\u00e1rias implementa\u00e7\u00f5es do GRASPS\nComo existem v\u00e1rias t\u00e9cnicas avan\u00e7adas que podem ser acrescidas ao GRASP (vide \"T\u00e9cnicas Avan\u00e7adas do GRASP\"), foram realizados testes com v\u00e1rias combina\u00e7\u00f5es, mas n\u00e3o com todas. Como s\u00e3o seis t\u00e9cnicas, todas as combina\u00e7\u00f5es poss\u00edveis totalizam 64, o que inviabiliza testes expressivos com cada uma delas. Dessa forma, s\u00e3o escolhidas as melhores combina\u00e7\u00f5es baseadas em experimentos r\u00e1pidos, formando 27 resolvedores. Para simplificar a visualiza\u00e7\u00e3o e a an\u00e1lise dos dados, s\u00e3o apresentados apenas 14 destes resolvedores, al\u00e9m do resolvedor ILOG, conforme pode ser visto na Tabela 2. Como se tratam de v\u00e1rios resolvedores, e em v\u00e1rios tipos de testes havia empates entre eles, foram elabo\nrados cinco quesitos para escolher o melhor resolvedor, listados a seguir:\n\u2022\tsoma total das melhores solu\u00e7\u00f5es;\n\u2022\tsoma total das solu\u00e7\u00f5es m\u00e9dias;\n\u2022\tm\u00e9dia das posi\u00e7\u00f5es obtidas, ordenando, decrescentemente, os resolvedores para cada teste, usando Rankingl (R1), tendo em vista as m\u00e9dias de produ\u00e7\u00e3o e tempo. Na classifica\u00e7\u00e3o s\u00e3o utilizados todos os resolvedores;\n\u2022\tm\u00e9dia das posi\u00e7\u00f5es obtidas, ordenando, decrescentemente, os resolvedores para cada teste, usando Ranking2 (R2), tendo em vista as m\u00e9dias de produ\u00e7\u00e3o e tempo. Na classifica\u00e7\u00e3o s\u00e3o utilizados todos os resolvedores;\n\u2022\tn\u00famero de inst\u00e2ncias em que o resolvedor obteve a melhor solu\u00e7\u00e3o conhecida para a mesma.\nRankingl seria uma classifica\u00e7\u00e3o onde, se r resolvedores est\u00e3o empatados na posi\u00e7\u00e3o p, ent\u00e3o o pr\u00f3ximo resolvedor, que \u00e9 inferior, viria na posi\u00e7\u00e3o p+1. J\u00e1 em Ranking2, nas mesmas circunst\u00e2ncias, o pr\u00f3ximo resolvedor viria na posi\u00e7\u00e3o p+r. A Tabela 3 mostra os valores dos quesitos dos 15 resolvedores para todas as inst\u00e2ncias reais do problema. De acordo com esses\nvalores, elabora-se a Tabela 4, onde \u00e9 mostrada a classifica\u00e7\u00e3o dos resolvedores para cada quesito. Pode-se notar por essa Tabela uma grande varia\u00e7\u00e3o nos melhores resolvedores entre quesitos diferentes.\nPara decidir qual seria o melhor resolvedor, faz-se novamente uma classifica\u00e7\u00e3o baseada na m\u00e9dia das coloca\u00e7\u00f5es para cada quesito. Faz-se essa classifica\u00e7\u00e3o\n\tQuesito\t1\t2\t3\t4\t5\n\tILOG\t338.990.507\t331.043.827\t9,588235\t23,47059\t2\n\tG1\t354.428.768\t346.325.637\t7,682353\t10,47059\t7\nTabela 3 - Valores\tG2\t354.421.217\t346.255.908\t8,035294\t11,11765\t6\n\tG3\t354.528.275\t346.318.220\t7,470588\t10,23529\t6\ndos resolvedores nos quesitos comparativos.\tG4\t354.379.849\t346.255.508\t8\t11,41176\t6\n\tG5\t354.428.768\t346.342.803\t6,8235529\t9,176471\t7\nTable 3 - Solver values\tG6\t354.432.875\t346.377.716\t4,623529\t8,235294\t7\nin comparative issues.\tG7\t354.838.320\t346.807.529\t2,941176\t4,352941\t8\n\tG8\t354.838.320\t346.744.587\t4,352941\t5,764706\t8\n\tG9\t354.838.320\t346.801.864\t3,470588\t5,294118\t8\n\tG10\t354.929.689\t346.782.341\t4,411765\t6,588235\t7\n\tG11\t354.929.689\t346.762.940\t4,294118\t6,411765\t9\n\tG12\t354.929.689\t346.762.060\t4,588235\t6,941176\t7\n\tG13\t354.932.391\t346.765.955\t4,058824\t6\t7\n\tG14\t354.888.020\t346.814.967\t2,941176\t4,764706\t9\nQuesito\t1\t2\t3\t4\t5\n1\u00b0\tG13\tG14\tG7-G14\tG7\tG11-G14\n2\u00b0\tG10-G11-G12\tG7\tG9\tG14\tG7-G8-G9\n3\u00b0\tG14\tG9\tG13\tG9\tG1-G5-G6-G10-G12-G13\n4\u00b0\tG7-G8-G9\tG10\tG11\tG8\tG2-G3-G4\n5\u00b0\tG3\tG13\tG8\tG13\tILOG\n6\u00b0\tG6\tG11\tG10\tG11\t\n7\u00b0\tG1-G5\tG12\tG12\tG10\t\n8\u00b0\tG2\tG8\tG6\tG12\t\n9\u00b0\tG4\tG6\tG5\tG6\t\n10\u00b0\tILOG\tG5\tG3\tG5\t\n11\u00b0\t\tG1\tG1\tG3\t\n12\u00b0\t\tG3\tG4\tG1\t\n13\u00b0\t\tG2\tG2\tG2\t\n14\u00b0\t\tG4\tILOG\tG4\t\n15\u00b0\t\tILOG\t\tILOG\t\nTabela 4 - Ranking entre os resolvedores.\nTable 4 - Ranking of solvers.\nBoletim t\u00e9cnico da Produ\u00e7\u00e3o de Petr\u00f3leo, Rio de Janeiro - volume 2, n\u00b0 1, p. 2 1 7 -23 9 \u25a1\n5\t'\t'\t' r\toe THJVOLDGIA\nAn\u00e1lise dos quesitos\tR1\tR2\tM\u00e9dia R2-R2\nILOG\t11,8\t15\t13,4\nG1\t8,8\t10,4\t9,6\nG2\t10,2\t13\t11,6\nG3\t8,4\t11\t9,7\nG4\t10,6\t13,4\t12\nG5\t7,8\t9,4\t8,6\nG6\t7\t8,6\t7,8\nG7\t7\t2,6\t2,3\nG8\t4,6\t5,4\t5\nG9\t2,8\t3,6\t3,2\nG10\t4,4\t5,2\t4,8\nG11\t3,8\t4\t3,9\nG12\t5,4\t6,2\t5,8\nG13\t3,4\t4,2\t3,8\nG14\t1,6\t2\t1,8\nTabela 5 - An\u00e1lise do ranking entre os resolvedores.\nTable 5 - Solver ranking analysis.\nClassifica\u00e7\u00e3o\tResolvedor\n1o\tG14\n2\u00b0\tG7\n3o\tG9\n4\u00b0\tG13\n5o\tG11\n6o\tG10\n7\u00b0\tG8\n8o\tG12\n9o\tG6\n10\u00b0\tG5\n11\u00b0\tG1\n12\u00b0\tG3\n13\u00b0\tG2\n14\u00b0\tG4\n15\u00b0\tILOG\nTabela 6 - Ordem dos melhores resolvedores.\nTable 6 - Ranking of best solvers.\ncom R1 e R2, como pode ser visto na Tabela 5. A partir dessa Tabela, obt\u00e9m-se a ordem dos melhores resolvedores constru\u00eddos, o que \u00e9 mostrado na Tabela 6.\nresultados comparativos entre o resolvedor ILOG e o GRASPS\nComo pode ser visto em \"As V\u00e1rias Implementa\u00e7\u00f5es do GRASPS\", o resolvedor G14 foi considerado o melhor entre as implementa\u00e7\u00f5es do GRASPS. Esse resolvedor engloba v\u00e1rias t\u00e9cnicas avan\u00e7adas do GRASP, como o POP, fun\u00e7\u00e3o tendenciosa baseada em raiz quadrada, intensifica\u00e7\u00e3o, Path-Relinking e BLS (vide \"T\u00e9cnicas Avan\u00e7adas do GRASP\"). Pode-se notar tamb\u00e9m que o resolvedor de Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (o resolvedor ILOG), foi muito inferior a todos os resolvedores GRASP, at\u00e9 mesmo ao GRASP padr\u00e3o.\nJ\u00e1 o G14 superou o resolvedor ILOG em mais de 16 milh\u00f5es de barris de petr\u00f3leo na soma das solu\u00e7\u00f5es m\u00e9dias de todas as inst\u00e2ncias. Isso representa um total de produ\u00e7\u00e3o 4,5% superior. Note que, com o petr\u00f3leo estando em torno dos US$ 52, o uso do G14, ao inv\u00e9s do resolvedor ILOG nessas inst\u00e2ncias, levaria a Petrobras a um ganho de quase US$ 832 milh\u00f5es. Al\u00e9m disso, mesmo gerando solu\u00e7\u00f5es melhores, o G14, para chegar \u00e0 sua melhor solu\u00e7\u00e3o, precisa de somente 95% do tempo usado pelo resolvedor ILOG. E, para superar a melhor solu\u00e7\u00e3o do resolver ILOG, utiliza apenas 45% do tempo do mesmo. Entre as 17 inst\u00e2ncias analisadas, o G14 supera a melhor solu\u00e7\u00e3o do ILOG no primeiro segundo de execu\u00e7\u00e3o em 14 inst\u00e2ncias. Dois exemplos disso podem ser vistos na Figura 8. Na Figura 9, mostramos duas inst\u00e2ncias em que o G14 n\u00e3o supera a melhor solu\u00e7\u00e3o do resolvedor ILOG no primeiro segundo de execu\u00e7\u00e3o. Dessa forma, conclu\u00edmos que nosso resolvedor GRASPS \u00e9 mais eficiente e gera melhores solu\u00e7\u00f5es que o ILOG.\n--Ar-ILOG \u2014G14\nTempo (s)\n(a)\n\u00f5\nQ.\n- -A- - ILOG\nG14\n0\n100\n200\t300\t400\nTempo (s)\n500\n(b)\nFigura 8 - ILOG x G14.\nFigure 8 - ILOG vs. G14.\n--A--ILOG \u2666\tG14\nTempo (s)\n(a)\n-\u25a0Ar-ILOG \u2666\tG14\nTempo (s)\n(b)\nFigure 9 - ILOG vs. G14.\nFigura 9 - ILOG x G14.\nconclus\u00f5es\nResolver problemas de escalonamento eficientemente \u00e9 um problema de grande import\u00e2ncia para a ind\u00fastria em geral. A Petrobras, uma das companhias l\u00edderes na explora\u00e7\u00e3o de petr\u00f3leo em \u00e1guas profundas, apresenta o problema de escalonamento no desenvolvimento de po\u00e7os de petr\u00f3leo (EDP). Neste artigo s\u00e3o contrastadas duas abordagens para resolver o EDP: a primeira baseada em Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (resol-vedor ILOG), e a segunda uma implementa\u00e7\u00e3o GRASP, de nome GRASPS.\nExperimentos computacionais foram conduzidos em inst\u00e2ncias reais do problema. Conclui-se que o GRASPS gera solu\u00e7\u00f5es com maior produ\u00e7\u00e3o petrol\u00edfera\nque aquelas geradas pelo resolvedor ILOG. Os resultados tamb\u00e9m provam que o GRASPS supera o ILOG na gera\u00e7\u00e3o de solu\u00e7\u00f5es de mesma produ\u00e7\u00e3o em menor tempo de execu\u00e7\u00e3o.\n\u00c9 v\u00e1lido mencionar que o resolvedor ILOG foi constru\u00eddo com a su\u00edte de Programa\u00e7\u00e3o por Restri\u00e7\u00f5es da ILOG, que consiste de sofisticadas bibliotecas com mais de uma d\u00e9cada de desenvolvimento. Al\u00e9m disso, essa su\u00edte \u00e9 de pre\u00e7o elevado, tanto no valor de aquisi\u00e7\u00e3o, quanto no valor de manuten\u00e7\u00e3o da licen\u00e7a. Dessa forma, usando GRASPS, a Petrobras pode evitar esses custos. Note, entretanto, que a su\u00edte da ILOG favorece a facilidade de desenvolvimento, de manuten\u00e7\u00e3o e de entendimento do c\u00f3digo fonte. Repare tamb\u00e9m que os resultados gerados pelo resolvedor ILOG superam os resultados manuais, i.e., solu\u00e7\u00f5es desenvolvidas por engenheiros.\nrefer\u00eancias bibliogr\u00e1ficas\n| AIEX, R. M.; BINATO, S.; RESENDE, M. G. C. Parallel GRASP with pathrelinking for job shop scheduling. PARALLEL COMPUTING, v. 29, n. 4, p. 393-430, Apr. 2003.\n| AIEX, R. M.; RESENDE, M. G. C.; PARDALOS, P. M.; TORALDO, G. Grasp with path relinking for the three-index assignment problem. AT&amp;T Labs Research Technical Report, Florham Park, NJ, 2001.43 p.\n| BARD, J. F.; FEO, T. A. Operations sequencing in discrete parts manufacturing. Management Science, Hannover, v. 35, n. 2, p. 249-255, Feb. 1989.\n| BINATO, S.; HERY, W. J.; LOEWENSTERN, D.; RESENDE, E M. G. C. A greedy randomized adaptive search procedure for job shop scheduling. In: Essays and Surveys on Metaheuristics. Dordrecht: Kluwer Academic, 2002. p. 59-79.\n| BRESINA J. L. Heuristic-biased stochastic sampling. In: NATIONAL CONFERENCE ON ARTIFICIAL INTELLIGENCE, 13., 1996, Portland. Proceedings of the... [S.l.: s.n.], 1996. p. 271-278.\n| CANUTO, S. A.; RESENDE, M. G. C.; RIBEIRO, E C. C. Local search with perturbations for the prize-collecting steiner tree problem in graphs. Networks, [S.l.], v. 38, p. 50-58, 2001.\n| COLORNI, A.; DORIGO, M.; MANIEZZO, V Ant system for job-shop scheduling. Belgian Journal of Operations Research, Statistics, and Computer Science, [S.l.], v. 1, n. 34, p. 39-53, 1994.\n| DORIGO, M.; DI CARO, G.; GAMBARDELLA, L. M. Ant algorithms for discrete otimization. Bruxelles: Universite Libre de Bruxelles, 1998. 36 p. (Technical Report IRIDIA/98-10). To appear in Artificial Life, MIT Press, 1999.\n| FEO, T. A.; BARD, J.F.; HOLLAND, E S. Facility-wide planning and scheduling of printed wiring board assembly. Operations Research, New York, v. 43, p. 219-230, 1995.\n| FLEURENT, C.; GLOVER, F.. Improved constructive multistart strategies for the quadratic assignment problem using adaptive memory. Informs Journal on Computing, Cincinnati, v. 11, n. 2, p.198-204, 1999.\n| GLOVER, F. Tabu search and adaptive memory programming: advances, applications and challenges. In: BARR, R.S.; HELGASON, R.V.; KENNINGTON, J.L. (Ed.). Interfaces in computer science and operations research. [Dordrecht]: Kluwer Academic, 1996. 75 p.\n| GLOVER, F. Multi-start and strategic oscillation methods: principles to exploit adaptive memory. In: BARR, R.S.; HELGASON, R.V.; KENNINGTON, J.L. (Ed.). Interfaces in computer science and operations research. [Dordrecht]: Kluwer Academic, 2000. 24 p.\n| GLOVER, F.; LAGUNA, M. Tabu Search. Boston: Kluwer Academic, 1997. 382 p.\n| GLOVER, F.; LAGUNA, M.; MART\u00cd, E. R. Fundamentals of scatter search and path relinking. Control and Cybernetics, Warszawa, v. 39, n. 3, p. 653-684, 2000.\n| ILOG. ILOG Solver 4.4 Reference Manual. [S.l.]: ILOG, 1999.\n| NASCIMENTO J.M. Hybrid computational tools for the optimization of the production of petroleum in deep waters. Disserta\u00e7\u00e3o (Mestrado) - Universidade de Campinas, 2002.\n| MARRIOTT, K.; STUCKEY, P. J. Programming with constraints: an introduction. Cambridge: Massachusetts Institute of Technology Press, 1998. 467 p.\n| RESENDE, M. G. C.; FESTA, P. An updated bibliography of GRASP. AT&amp;T Labs Research Technical Report TD-5SB7BK, Florham Park, NJ, October 14, 2003. 10 p.\n| RESENDE, M. G. C.; RIBEIRO, C. C. A GRASP with path-relinking for private virtual circuit routing. AT&amp;T Labs Research Technical Report, Florham Park, NJ, June 15, 2001. 19 p.\nbibliografia\n| RESENDE, M. G. C.; RIBEIRO, C. C. Greedy randomized adaptive search procedure. AT&amp;T Labs Research Technical Report, Florham Park, NJ, Sept. 2001. 29 p. Revision 2, Aug. 29, 2002. To appear in \u201cState of the Art Handbook in Metaheuristics\", F. Glover and G. Kochenberger, eds., Kluwer, 2002.\n| RODRIGO, M.; MANIEZZO, V; COLORNI, A. The Ant System: Optimization by a colony of cooperating agents. IEE Transactions on Systems, Man and Cybernetics, v. 26, n. 1, p. 1-13, 1996.\n| ROY, B.; SUSSMANN, B. Les probl\u00e8mes d'ordonnancement avec con-traintes disjonctive. In: NOTE DS No. 9 bis. Paris: SEMA, 1964.\n| YANNAKAKIS, M. Computational complexity. In: AARTS, E.; LENSTRA, J.K. (Ed.). Local search in combinatorial optimization. Chichester: J. Wiley, 1997. p. 19-55\nwebgrafia\n| GLOVER, F.; LAGUNA, M. Tabu Search. [S.l.: s.n., 1997?]. Dispon\u00edvel em:<www-bus.colorado.Edu/faculty/laguna/Papers/ts.pdf>. Acesso em: ago., 2000.\nautores\nRomulo Albuquerque Pereira\n| Banco Central do Brasil\n| Departamento de Inform\u00e1tica romulo_a_pereira@yahoo.com.br\nArnaldo Vieira Moura\n| Universidade Estadual de Campinas (Unicamp)\n| Instituto de Computa\u00e7\u00e3o\narnaldo@ic.unicamp.br\nRomulo Albuquerque Pereira \u00e9 Cientista da Computa\u00e7\u00e3o, com gradua\u00e7\u00e3o e Mestrado pela Universidade Estadual de Campinas (Unicamp). Recebeu o 3\u00b0 lugar na categoria Tecnologia de Produ\u00e7\u00e3o da 1a edi\u00e7\u00e3o do Pr\u00eamio Petrobras e Tecnologia em 2005, categoria Produ\u00e7\u00e3o. Trabalhou quatro anos entre Uniway, Accenture, Stefanini e Magna prestando servi\u00e7os especializados para desenvolvimento de sistemas de Intelig\u00eancia Artificial para a Petrobras. Hoje \u00e9 Analista de Sistemas concursado do Banco Central do Brasil.\nArnaldo Vieira Moura \u00e9 Engenheiro Eletr\u00f4nico formado pelo Instituto Tecnol\u00f3gico de Aeron\u00e1utica (ITA), Mestre em Ci\u00eancias, com \u00eanfase em Matem\u00e1tica Aplicada pelo mesmo Instituto, e Ph.D. em Ci\u00eancias da Computa\u00e7\u00e3o pela Universidade da Calif\u00f3rnia, Berkeley. Atuou como Pesquisador do Centro Cient\u00edfico e do Instituto de Sofware da IBM Brasil. \u00c9 professor livre-docente do Instituto de Computa\u00e7\u00e3o da Universidade Estadual de Campinas (UNICAMP), onde ministra disciplinas nas \u00e1reas de fundamentos da computa\u00e7\u00e3o, verifica\u00e7\u00e3o de sistemas e engenharia de software. Atua em pesquisas nas \u00e1reas de Algoritmos, Otimiza\u00e7\u00e3o Combinat\u00f3ria e Verifica\u00e7\u00e3o e Valida\u00e7\u00e3o de sistemas, utilizando modelos e m\u00e9todos formais.\nfase em Sistemas, pela Pontif\u00edcia Universidade Cat\u00f3lica do Rio de Janeiro (1985), Mestrado em Engenharia El\u00e9trica pela Pontif\u00edcia Universidade Cat\u00f3lica do Rio de Janeiro (1989), Doutorado em Ci\u00eancias Aplicadas pela Universit\u00e9 Catholique de Louvain (1993), P\u00f3s-Doutorado pela Uni-versit\u00e9 Catholique de Louvain (1994) e pela Carnegie Mellon University (2003). Atualmente \u00e9 professor titular da Universidade Estadual de Campinas. Tem experi\u00eancia na \u00e1rea de Ci\u00eancia da Computa\u00e7\u00e3o, com \u00eanfase em Teoria da Computa\u00e7\u00e3o. Atua principalmente com temas relacionados a An\u00e1lise de Algoritmos, Otimiza\u00e7\u00e3o Combinat\u00f3ria, Programa\u00e7\u00e3o Matem\u00e1tica, Combinat\u00f3ria Poli\u00e9drica e Pesquisa Operacional.\nI expanded abstract\nPetrobras is one of the forerunners and leaders in deepwater petroleum exploration, and also one of the 20 oil majors in the world. It explores various oil-bearing basins, each with hundreds of promising sites where oil wells can start producing. However, these sites need to be developed before they become productive. To undertake the activities involved in developing an oil well, Petrobras used some chartered and some of its own rigs and vessels. These resources are restricted and costly whether in procurement or leasing and, therefore, must be used efficiently.\nThe problem of Oil Well Development Schedule (OWD) can be defined as follows: data of a group of wells, activities to be performed in each well and the resources available for performing them, determining a sequence of activities in a given time frame, indicating their start and finish and the resource to perform them, in order to optimize an objective function, namely, maximize oil production. This sequence must consider the displacement of resources and different operational restraints. This paper studies the OWD, considering the specificities found by Petrobras in deepwater oil exploration.\nThe operational restraints discussed in the paper are the following: technological precedence, activity benchmark, baseline, restricted use of resources, competition, non-availability, well sequences defined by users, surface constraints, clustering and drilling rig displacement.\nTo address this same problem a Petrobras team designed a constraint programming model using the ILOG Solver and ILOG Scheduler li braries. After four years of planning, development and testing, the tools called ORCA (Optimization of Resources Crucial to the production Activity) started operating with success. Today the ORCA solver is used by engineers to define a good schedule for well-development activities and to analyze the need to procure or lease new resources.\nWhen addressing OWD, the GRASP (Greedy Randomized Search Procedure) heuristic was the approach that seemed most appropriate, since it is a success\nful metaheuristic in dealing with schedule problems. GRASP methodology is an interactive process, where each interaction consists of two phases, Construction and Local Search. The Construction phase uses a greedy randomized strategy to build a feasible solution, whose neighborhood is explored later in the Local Search phase. This process is repeated using various interactions and their best solution in all GRASP interactions is selected as the end result.\nTo create even better solutions for Petrobras, a number of advanced techniques were studied for GRASP, such as: bias functions, Proximate Optimality Principle (POP), Intensification, Path-Relinking and Selective Local Search.\nThe GRASP solver was designed using the C/C++ programming language. In this model two types of variables were considered as follows: one type representing the start of performing a well activity, and the other is the resource to perform a well activity.\nIn GRASP, the Restricted Candidate List (RCL) is made using those wells that retain the largest supply of petroleum. The next element to be introduced into the solution is chosen randomly from among the RCL candidates, using bias functions.\nTo schedule the candidate well, the following algorithm was used: while there are unscheduled activities in the well:\n\u2022\tchoose any available activity in the well, namely, an unscheduled activity and whose activities preceding it are scheduled;\n\u2022\tin perform this activity, choose the resource that meets all requirements and that can finish the activity as soon as possible;\n\u2022\tstart the activity as soon as possible, i.e., the maximum between the shortest time after which the resource is available and the shortest time to start the activity;\n\u2022\tupdate the shortest times to start all activities on which there is a restraint on the next activity to be performed.\nexpanded abstract\nThe local search algorithm used in this GRASP solver is known as \"two exchange\", based on Roy and Suss-mann's disjunctive graph model. It consists of changing a position of two elements in the schedule. \"Well parts\" are exchanged: a maximum set of activities in the same well scheduled consecutively in the same resource. Therefore, the local search algorithm tries to change all pairs of well parts, forming an order neighborhood O(n2), where n is the number of well parts.\nPetrobras provided real instances of the problem to be used in the tests. Since there are a number of advanced techniques that can be added to GRASP, some mentioned earlier, tests were made using various combinations of these techniques.\nOne of these combinations, called G14 solver, was considered the best of all other GRASP implementations tested. This solver includes various advanced techniques of GRASP, such as POP, bias function based on a square root, intensification, Path-Relinking and Selective Local Search. The ORCA solver, based on constraint programming, can also be found to be inferior to every GRASP solver, even the standard GRASP. G14, on the other hand, surpassed the ILOG solver by more than 16 million barrels of petroleum when adding the average solutions of all instances. This is a 4.5% higher total production. Note that, with one barrel of petroleum around US$ 52, by using G14 instead of the ORCA solver, when applied to these instances, Petrobras would gain almost US$ 832 million. Moreover, even when creating better solutions, the G14, to reach its best solution, only needs 95% of the time spent by the ORCA solver. And to surpass the best solution of the ORCA solver, G14 uses only 45% of the time of the ORCA solver. Of the 17 instances studied, the G14 surpasses the best ORCA solution in the first second of performing 14 of the test instances.\nAccordingly, the conclusion is that the GRASPS solver is more efficient and creates better solutions than the ORCA solver. The benefit of the proposed method is also more evident when it is found that the algorithm was fully developed with no-cost tools."}]}}}