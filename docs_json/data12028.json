{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.15694"}, {"@name": "filename", "#text": "22169_000982785.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL\nESCOLA DE ENGENHARIA\n\nDEPARTAMENTO DE ENGENHARIA EL\u00c9TRICA\nPROGRAMA DE P\u00d3S-GRADUA\u00c7\u00c3O EM ENGENHARIA EL\u00c9TRICA\n\nCARLOS SOLON SOARES GUIMAR\u00c3ES\nJUNIOR\n\nPROPOSTA DE UM FRAMEWORK\nBASEADO EM ARQUITETURA\n\nORIENTADA A SERVI\u00c7OS PARA A\nROB\u00d3TICA\n\nPorto Alegre\n2015\n\n\n\n\n\nCARLOS SOLON SOARES GUIMAR\u00c3ES\nJUNIOR\n\nPROPOSTA DE UM FRAMEWORK\nBASEADO EM ARQUITETURA\n\nORIENTADA A SERVI\u00c7OS PARA A\nROB\u00d3TICA\n\nDisserta\u00e7\u00e3o de mestrado apresentada ao Programa\nde P\u00f3s-Gradua\u00e7\u00e3o em Engenharia El\u00e9trica da Uni-\nversidade Federal do Rio Grande do Sul como\nparte dos requisitos para a obten\u00e7\u00e3o do t\u00edtulo de\nMestre em Engenharia El\u00e9trica.\n\u00c1rea de concentra\u00e7\u00e3o: Controle e Automa\u00e7\u00e3o\n\nORIENTADOR: Prof. Dr. Renato Ventura Bayan\nHenriques\n\nCO-ORIENTADOR: Prof. Dr. Carlos Eduardo\nPereira\n\nPorto Alegre\n2015\n\n\n\n\n\nCARLOS SOLON SOARES GUIMAR\u00c3ES\nJUNIOR\n\nPROPOSTA DE UM FRAMEWORK\nBASEADO EM ARQUITETURA\n\nORIENTADA A SERVI\u00c7OS PARA A\nROB\u00d3TICA\n\nEsta disserta\u00e7\u00e3o foi julgada adequada para a ob-\nten\u00e7\u00e3o do t\u00edtulo de Mestre em Engenharia El\u00e9trica\ne aprovada em sua forma final pelo Orientador e\npela Banca Examinadora.\n\nOrientador:\nProf. Dr. Renato Ventura Bayan Henriques, UFRGS\nDoutor pela Universidade Federal de Minas Gerais \u2013 Belo Ho-\nrizonte, Brasil\n\nBanca Examinadora:\n\nProf. Dr. Lu\u00eds Fernando Alves Pereira, UFRGS\nDoutor pelo Instituto Tecnol\u00f3gico de Aeron\u00e1utica \u2013 S\u00e3o Jos\u00e9 dos Campos, Brasil\n\nProf. Dr. Rodrigo Da Silva Guerra, UFSM\nDoutor pela Universidade de Osaka - Osaka, Jap\u00e3o\n\nProf. Dr. Jose Barata Oliveira, UNINOVA\nDoutor pela Universidade Nova de Lisboa - Lisboa, Portugal\n\nCoordenador do PPGEE:\nProf. Dr. Alexandre Sanfelice Bazanella\n\nPorto Alegre, outubro de 2015.\n\n\n\n\n\nDEDICAT\u00d3RIA\n\nDedico este trabalho primeiramente a Deus, por ser essencial em minha vida, autor\nde meu destino, ao meu pai Carlos Solon Soares Guimar\u00e3es, minha m\u00e3e Maria Iolema\nSantiago Guimar\u00e3es e aos meus irm\u00e3os. A todos os professores do curso, que foram\nt\u00e3o importantes na minha vida acad\u00eamica e no desenvolvimento desta disserta\u00e7\u00e3o, em\nespecial ao Prof. Renato Ventura Bayan Henriques e o Prof. Carlos Eduardo Pereira, pela\npaci\u00eancia nas orienta\u00e7\u00f5es e incentivos que tornaram poss\u00edveis a conclus\u00e3o deste trabalho.\n\n\n\n\n\nRESUMO\n\nSistemas embarcados, em especial aqueles utilizados em rob\u00f3tica, apresentam, em sua\nestrutura, uma multiplicidade de dispositivos que resultam em uma arquitetura bastante\nheterog\u00eanea e bem distribu\u00edda. Para auxiliar na resolu\u00e7\u00e3o dessa complexidade inerente,\neste trabalho resgata os conceitos de frameworks, buscando na sua integra\u00e7\u00e3o e modelo\nconceitual, desenvolver um conjunto de ferramentas que gerencia a media\u00e7\u00e3o entre siste-\nmas embarcados e demais aplica\u00e7\u00f5es de software, fornecendo bibliotecas e componentes\nreutiliz\u00e1veis para aplica\u00e7\u00f5es na rob\u00f3tica. Prop\u00f5e-se utilizar framework e middleware de\nsistemas open-source para integra\u00e7\u00e3o entre a plataforma de software e hardware. Um dos\nobjetivos do projeto \u00e9 criar um framework multi-plataforma com diferentes tipos de servi-\n\u00e7os para o de desenvolvimento de aplica\u00e7\u00f5es no campo da rob\u00f3tica. O projeto tem como\nestudo de caso sistemas embarcados aplicados em rob\u00f3tica m\u00f3vel e tecnologia assistiva.\n\nPalavras-chave: Engenharia de Software, Arquitetura Orientada a Servi\u00e7os, Fra-\nmeworks, Middleware, Sistema Embarcado, Rob\u00f3tica.\n\n\n\n\n\nABSTRACT\n\nEmbedded systems, especially those used in robotics, present in its structure, a plural-\nity of devices that result in a very heterogeneous and well distributed architecture. To help\nresolve this inherent complexity, the work rescues the concepts of frameworks, seeking\ntheir integration and conceptual model, develop a set of tools that manage to mediate be-\ntween embedded systems and other of software applications, providing reusable libraries\nand components for applications in robotics. It is proposed to use framework and middle-\nware systems open source for integration between the platform software and hardware.\nOne of the project objectives is to create a multi-platform framework with different types\nof services, considering the programming and compatibility with hardware for the de-\nvelopment of applications in the field of robotics. The project\u2019s case study developing\nembedded applied in mobile and Assistive Technology robotics.\n\nKeywords: Software Engineering, Service Oriented Architecture, Frameworks, Mid-\ndleware, Embedded System, Robotics.\n\n\n\n\n\nLISTA DE ILUSTRA\u00c7\u00d5ES\n\nFigura 1: Aplica\u00e7\u00e3o desenvolvida totalmente (SILVA, 2000) . . . . . . . . . . 31\nFigura 2: Aplica\u00e7\u00e3o desenvolvida reutilizando classes de biblioteca (SILVA,\n\n2000) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nFigura 3: Aplica\u00e7\u00e3o desenvolvida reutilizando um framework OO (SILVA, 2000) 31\nFigura 4: Combina\u00e7\u00e3o de frameworks OO (SILVA, 2000) . . . . . . . . . . . . 33\nFigura 5: Interliga\u00e7\u00e3o de componentes atrav\u00e9s de seus canais de comunica\u00e7\u00e3o\n\n(SILVA, 2000) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nFigura 6: Adapta\u00e7\u00e3o de componente atrav\u00e9s de empacotamento (wrapping) (SILVA,\n\n2000) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nFigura 7: Adapta\u00e7\u00e3o de componente atrav\u00e9s de colagem (glueing) (SILVA, 2000) 36\nFigura 8: Padr\u00f5es de diagramas de componentes segundo a UML . . . . . . . . 37\nFigura 9: Agentes de uma arquitetura SOA (FUGITA, 2009) . . . . . . . . . . 40\nFigura 10: Camadas de uma arquitetura SOA (FUGITA, 2009) . . . . . . . . . . 41\nFigura 11: Camadas de servi\u00e7os (ERL, 2007) (FUGITA, 2009) . . . . . . . . . . 42\nFigura 12: Esquema dos n\u00edveis de encapsulamento com servi\u00e7os (SERAFIM,\n\n2009) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nFigura 13: Camadas de uma implementa\u00e7\u00e3o SOA (SERAFIM, 2009) . . . . . . 44\nFigura 14: Ciclo de vida de desenvolvimento SOA (ERL, 2007) . . . . . . . . . 48\nFigura 15: An\u00e1lise Orientada a Servi\u00e7os (ERL, 2005) . . . . . . . . . . . . . . 49\nFigura 16: Modelagem de servi\u00e7os candidatos (ERL, 2005) . . . . . . . . . . . 50\nFigura 17: Nota\u00e7\u00e3o ERL para representar um servi\u00e7o (ERL, 2005) . . . . . . . 51\nFigura 18: Projeto orientado a servi\u00e7os (ERL, 2007) . . . . . . . . . . . . . . . 51\nFigura 19: N\u00edveis de abstra\u00e7\u00e3o para o processo de projeto de sistemas embarca-\n\ndos. Fonte: (LEE; SESHIA, 2011). . . . . . . . . . . . . . . . . . . 56\nFigura 20: Diagrama de bloco da arquitetura dos estudos de caso do projeto.\n\nFonte: (LEE; SESHIA, 2011). . . . . . . . . . . . . . . . . . . . . . 57\nFigura 21: Microcontrolador ATmega328P e driver L293D. Fonte: (GUIBOT,\n\n2014). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\nFigura 22: Conversor USB-TTL FTDI. Fonte: (GUIBOT, 2014). . . . . . . . . 58\nFigura 23: Circuito para controlar motores CC open-source . . . . . . . . . . . 59\nFigura 24: Diagrama de blocos parcial para Frameworks baseados na API Wiring. 60\nFigura 25: IDE\u2019s dos Frameworks citados. . . . . . . . . . . . . . . . . . . . . 61\nFigura 26: IDE\u2019s dos Frameworks citados. . . . . . . . . . . . . . . . . . . . . 64\nFigura 27: Projeto EduBOT-v0.1. Fonte: (EDUBOT, 2014; MARTINS, 2011). . 65\nFigura 28: Torneios de rob\u00f3tica libre utilizando as plataformas rob\u00f3ticas monta-\n\ndas. Fonte: (EDUBOT, 2014; MARTINS, 2011). . . . . . . . . . . . 65\n\n\n\nFigura 29: Projeto EduBOT-V0.2. Fonte: (GUIMAR\u00c3ES; TAMAYO; HENRI-\nQUES, 2014). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\nFigura 30: Valida\u00e7\u00e3o do projeto EduBOT-V0.2 com os estudantes. Fonte: (GUI-\nMAR\u00c3ES; TAMAYO; HENRIQUES, 2014). . . . . . . . . . . . . . 67\n\nFigura 31: Fluxograma para algoritmo seguidor de parede. Fonte: (GUIMA-\nR\u00c3ES; TAMAYO; HENRIQUES, 2014). . . . . . . . . . . . . . . . 68\n\nFigura 32: Diagrama de blocos para o rob\u00f4 m\u00f3vel uniciclo. Fonte: Autor. . . . 72\nFigura 33: Projeto EduBOT-v0.3. Fonte: Eduardo Henrique Maciel e Autor. . . . 73\nFigura 34: Tabela com mapeamento parcial dos diferentes componentes de hard-\n\nware do projeto EduBOT-v0.3. Fonte: Eduardo Henrique Maciel e\nAutor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\nFigura 35: Esquema para obten\u00e7\u00e3o do modelo cinem\u00e1tico do rob\u00f4 m\u00f3vel uniciclo. 75\nFigura 36: Representa\u00e7\u00e3o do CIR do rob\u00f4 m\u00f3vel uniciclo. . . . . . . . . . . . . 76\nFigura 37: Diagrama de blocos do modelo din\u00e2mico completo do rob\u00f4 m\u00f3vel\n\nuniciclo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\nFigura 38: Modelagem do diagrama de implanta\u00e7\u00e3o parcial para o subsistema\n\nde movimento do rob\u00f4. O diagrama de implanta\u00e7\u00e3o \u00e9 composto por\nprocessadores, componentes e dispositivos, alocados conforme as ne-\ncessidades do projeto. . . . . . . . . . . . . . . . . . . . . . . . . . 79\n\nFigura 39: Subsistema de movimento com girosc\u00f3pio. . . . . . . . . . . . . . . 81\nFigura 40: Controle PID. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\nFigura 41: Diagrama de estados. . . . . . . . . . . . . . . . . . . . . . . . . . . 82\nFigura 42: Subsistema de movimento com encoders. . . . . . . . . . . . . . . . 82\nFigura 43: Controle PID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\nFigura 44: Diagrama de estado . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\nFigura 45: Hardware Subsistema de movimento com bussola e girosc\u00f3pio . . . . 84\nFigura 46: Diagrama de estados . . . . . . . . . . . . . . . . . . . . . . . . . . 85\nFigura 47: Ilustra\u00e7\u00e3o do movimento caracter\u00edstico de uma bengala branca, dei-\n\nxando por sondar a maioria do espa\u00e7o na frente do utilizador. A ver-\nmelho est\u00e3o representados os par\u00e2metros medidos e calculados a par-\ntir dos ensaios realizados (ROSA, 2009). . . . . . . . . . . . . . . . 86\n\nFigura 48: Modelo conceitual do projeto da bengala eletr\u00f4nica . . . . . . . . . 88\nFigura 49: Modelo conceitual do projeto da bengala eletr\u00f4nica . . . . . . . . . 89\nFigura 50: Diagrama de Blocos do projeto da Bengala Eletr\u00f4nica. . . . . . . . . 90\nFigura 51: Diagrama de Contexto do Dispositivo Eletr\u00f4nico. Fonte: Autor. . . . 92\nFigura 52: Extens\u00e3o Representando Ward e Mellor - DFD n\u00edvel 1 . . . . . . . . 92\nFigura 53: diagrama de transi\u00e7\u00e3o de estado . . . . . . . . . . . . . . . . . . . . 93\nFigura 54: Diagramas de classes de an\u00e1lise do projeto. Fonte: Autor. . . . . . . 94\nFigura 55: Diagrama de classes parciais do projeto, desenvolvido para testes e\n\nimplementa\u00e7\u00f5es. Fonte: Autor. . . . . . . . . . . . . . . . . . . . . 95\nFigura 56: Diagrama de caso de uso do projeto . . . . . . . . . . . . . . . . . . 95\nFigura 57: diagrama de sequ\u00eancia parcial . . . . . . . . . . . . . . . . . . . . . 96\nFigura 58: Arquitetura do sistema de rastreamento. Fonte: Autor. . . . . . . . . 97\nFigura 59: Descri\u00e7\u00e3o do sistema com Servidor de Aplica\u00e7\u00e3o, Banco de Dados e\n\nWeb Browsers Clientes para o sistema de rastreamento . . . . . . . . 98\nFigura 60: Arquitetura de camadas do Framework SOA. Fonte: Autor. . . . . . . 102\nFigura 61: Elementos do desenvolvimento tradicional de aplica\u00e7\u00f5es. Fonte: (SILVA,\n\n2000). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\n\n\n\nFigura 62: Elementos do desenvolvimento de aplica\u00e7\u00f5es baseado em frameworks.\nFonte: (SILVA, 2000). . . . . . . . . . . . . . . . . . . . . . . . . . 104\n\nFigura 63: Os elementos utilizados nas aplica\u00e7\u00f5es s\u00e3o baseados nos servi\u00e7os for-\nnecidos pelo framework. Fonte: Autor. . . . . . . . . . . . . . . . . 104\n\nFigura 64: Reposit\u00f3rio dos pacotes Myrobotlab. Fonte: (MYROBOTLAB, 2014).\n106\n\nFigura 65: Modelo parcial para o diagrama de implanta\u00e7\u00e3o do rob\u00f4 m\u00f3vel. N\u00f3s\ndispositivos (ou processadores) podem ser adicionados ou removidos\nconforme as necessidades do problema a ser resolvido. Fonte: Autor. 107\n\nFigura 66: Modelo parcial para o diagrama de implanta\u00e7\u00e3o da bengala eletr\u00f4-\nnica. N\u00f3s dispositivos (ou processadores) podem ser adicionados ou\nremovidos conforme as necessidades do problema a ser resolvido.\nFonte: Autor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\n\nFigura 67: Modelo parcial para o diagrama de implanta\u00e7\u00e3o do computador Host.\nN\u00f3s podem ser adicionados ou removidos, as defini\u00e7\u00f5es s\u00e3o estabe-\nlecidas conforme as necessidades do problema. Fonte: Autor. . . . . 109\n\nFigura 68: Sistemas de diret\u00f3rios parciais do framework SOA Myrobotlab para\ndesenvolvedores. Fonte: Autor. . . . . . . . . . . . . . . . . . . . . 110\n\nFigura 69: Representa\u00e7\u00e3o da estrutura interna da classe Runtime do pacote de\nservi\u00e7os. Fonte: (MYROBOTLAB, 2014). . . . . . . . . . . . . . . 111\n\nFigura 70: Representa\u00e7\u00e3o da estrutura interna da classe GUIService do pacote\nde servi\u00e7os. Fonte: (MYROBOTLAB, 2014). . . . . . . . . . . . . 112\n\nFigura 71: Primeira inicializa\u00e7\u00e3o do Runtime ap\u00f3s configura\u00e7\u00f5es dos argumen-\ntos do sistema. Execu\u00e7\u00e3o da GUI do framework SOA Myrobotlab\nv1.0.12. Fonte: Autor. . . . . . . . . . . . . . . . . . . . . . . . . . 113\n\nFigura 72: Acesso a aba do frame \"gui\". Respons\u00e1vel por fornecer o controle\ndos servi\u00e7os em execu\u00e7\u00e3o. Fonte: Autor. . . . . . . . . . . . . . . . 114\n\nFigura 73: Servi\u00e7os dispon\u00edveis na aba \"runtime\" da GUI. Fonte: Autor. . . . . 115\nFigura 74: Frame \"runtime\"da GUI do framework SOA Myrobotlab inicializado\n\ncom todos os servi\u00e7os instalados e atualizados. Fonte: Autor. . . . . 116\nFigura 75: Iniciando um servi\u00e7o do Frame \"runtime\". Fonte: Autor. . . . . . . . 117\nFigura 76: O Servi\u00e7o \"RasPi\"tem o frame vazio. Fonte: Autor. . . . . . . . . . 118\nFigura 77: Servi\u00e7o OpenCV executado em uma nova aba frame chamada \"ser-\n\nvice camera\". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\nFigura 78: Aplicando o filtro canny no arquivo JPEG. Fonte: Autor. . . . . . . . 120\nFigura 79: Filtro de detec\u00e7\u00e3o de face. Fonte: Autor. . . . . . . . . . . . . . . . 121\nFigura 80: O Frame \"gui\"mostra os servi\u00e7os atuais em execu\u00e7\u00e3o. Fonte: Autor. 122\nFigura 81: Tela inicial do novo Framework SOA estendido. Fonte: Autor. . . . 125\nFigura 82: Tela de servi\u00e7os implementados para utilizar com estudantes de gra-\n\ndua\u00e7\u00e3o da UFRGS. Fonte: Autor. . . . . . . . . . . . . . . . . . . . 126\nFigura 83: Tela do servi\u00e7o para intera\u00e7\u00e3o com a plataforma de hardware. Fonte:\n\nAutor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\nFigura 84: Diagrama de blocos com o computador hospedeiro rodando o fra-\n\nmework SOA Myrobotlab com o servi\u00e7o Arduino conectado com o\nhardware. Fonte: Autor. . . . . . . . . . . . . . . . . . . . . . . . . 127\n\nFigura 85: Plataforma Rob\u00f3tica Educacional EduRobot v0.4. . . . . . . . . . . 129\nFigura 86: Principais dimens\u00f5es do EduBOT v0.4. . . . . . . . . . . . . . . . . 130\nFigura 87: Tela inicial do novo framework SOA estendido. Fonte: Autor. . . . . 132\n\n\n\nFigura 88: Tela de servi\u00e7os implementados para utilizar com estudo de caso da\nbengala eletr\u00f4nica. Fonte: Autor. . . . . . . . . . . . . . . . . . . . 133\n\nFigura 89: Bibliotecas C++ rodando com API de mapas. Fonte: Autor. . . . . . 134\nFigura 90: Front End aberto ap\u00f3s inicializar o servi\u00e7o \"WebGUI\" . Fonte: Autor. 134\n\n\n\nLISTA DE TABELAS\n\nTabela 1: Rela\u00e7\u00e3o dos componentes eletr\u00f4nicos com as marca\u00e7\u00f5es da Figura 48. 88\nTabela 2: Rela\u00e7\u00e3o dos componentes eletr\u00f4nicos com as marca\u00e7\u00f5es da Figura 49. 90\n\n\n\n\n\nLISTA DE ABREVIATURAS\n\nBPM Business Process Management\n\nCC Corrente Cont\u00ednua\n\nCCC Central de Comuta\u00e7\u00e3o e Controle\n\nCIR Centro Instant\u00e2neo de Rota\u00e7\u00e3o\n\nEAI Enterprise Application Integration)\n\nERB Esta\u00e7\u00e3o R\u00e1dio Base\n\nESB Enterprise Service Bus\n\nGSM Global System for Mobile Communications\n\nICE Internet Comunications Engine\n\nIMEI International Mobile Equipment Identity\n\nJVM Java Virtual Machine\n\nROS Robot Operating System\n\nSART Structured Analysis Real-Time\n\nSAW Surgical Assistant Workstation\n\nSIM Subscriber Identity Module\n\nTA Tecnologia assistiva\n\nTDMA Time Division Multiple Access\n\nUML Unified Modeling Language\n\nCBD Desenvolvimento Baseado em Componentes\n\nOO Orientado \u00e0 Objetos\n\nSOA Service-Oriented Architecture\n\n\n\n\n\nLISTA DE S\u00cdMBOLOS\n\n? \u00c2ngulo que define a orienta\u00e7\u00e3o do rob\u00f4;\n\n0??c Pose do rob\u00f4 m\u00f3vel;\n\niRj Matriz de rota\u00e7\u00e3o do sistema de coordenadas j em rela\u00e7\u00e3o ao sistema de coorde-\nnadas i;\n\nRC Raio de curvatura instant\u00e2neo da trajet\u00f3ria do rob\u00f4;\n\nvi Velocidades das rodas, onde i representa as velocidades tangenciais da roda es-\nquerda e \u00e0 direita;\n\n?i Velocidades angulares, onde i representa as velocidades a roda esquerda e \u00e0 di-\nreita;\n\ny Sa\u00edda controlada;\n\nyR Sinal de refer\u00eancia;\n\nx0 Estado inicial do sistema;\n\nt0 Instante em que o controle se inicia;\n\nr Raio da roda;\n\nV Velocidade linear;\n\nR Dist\u00e2ncia radial do rob\u00f4 a partir da posi\u00e7\u00e3o inicial;\n\nl Dist\u00e2ncia entre as rodas;\n\nn Eixo da roda de redu\u00e7\u00e3o;\n\nCe Resolu\u00e7\u00e3o do encoder;\n\nki Constantes do modelo;\n\n\n\n\n\nSUM\u00c1RIO\n\n1 INTRODU\u00c7\u00c3O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n1.1 Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n1.2 Organiza\u00e7\u00e3o do Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n2 FUNDAMENTA\u00c7\u00c3O TE\u00d3RICA . . . . . . . . . . . . . . . . . . . . . . 27\n2.1 Sistemas Embarcados . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n2.2 Engenharia de Software . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n2.3 Classifica\u00e7\u00e3o e Defini\u00e7\u00e3o de Frameworks . . . . . . . . . . . . . . . . . . 29\n2.3.1 Frameworks Orientado a Objetos . . . . . . . . . . . . . . . . . . . . . . 30\n2.4 Engenharia de Software Baseado em Componentes . . . . . . . . . . . . 33\n2.4.1 Frameworks Orientado a Componentes . . . . . . . . . . . . . . . . . . . 34\n2.5 Frameworks Caixa-branca, Caixa-preta e Caixa-cinza . . . . . . . . . . 37\n2.6 Engenharia de Software de Servi\u00e7o . . . . . . . . . . . . . . . . . . . . . 38\n2.6.1 Arquitetura Orientada a Servi\u00e7os . . . . . . . . . . . . . . . . . . . . . . 39\n2.7 Rela\u00e7\u00e3o entre os paradigmas OO, CBD e SOA . . . . . . . . . . . . . . . 42\n\n3 METODOLOGIA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n3.1 Ciclo de Vida . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n3.2 Atividades de An\u00e1lise . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n3.2.1 Defini\u00e7\u00e3o dos requisitos de neg\u00f3cio . . . . . . . . . . . . . . . . . . . . . 49\n3.2.2 Identifica\u00e7\u00e3o de sistemas existentes . . . . . . . . . . . . . . . . . . . . . 49\n3.2.3 Modelagem de servi\u00e7os candidatos . . . . . . . . . . . . . . . . . . . . . 49\n3.3 Atividades de Projeto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n3.3.1 Composi\u00e7\u00e3o da arquitetura orientada a servi\u00e7os . . . . . . . . . . . . . . 51\n3.3.2 Projeto de servi\u00e7os baseados em entidades . . . . . . . . . . . . . . . . . 51\n3.3.3 Projeto de servi\u00e7os de aplica\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . 52\n3.3.4 Projeto de servi\u00e7os baseados em tarefas . . . . . . . . . . . . . . . . . . 52\n3.3.5 Projeto de processo orientado a servi\u00e7os . . . . . . . . . . . . . . . . . . 52\n3.3.6 Artefatos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\n3.3.7 An\u00e1lise do M\u00e9todo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\n\n4 ESTUDOS DE CASOS: ROB\u00d3TICA M\u00d3VEL E TECNOLOGIA ASSIS-\nTIVA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n\n4.1 Metodologias no desenvolvimento dos sistemas embarcados . . . . . . . 55\n4.1.1 Especifica\u00e7\u00e3o do Hardware . . . . . . . . . . . . . . . . . . . . . . . . . 56\n4.1.2 Especifica\u00e7\u00e3o do Software . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n4.2 Introdu\u00e7\u00e3o \u00e0 proposta EduBOT . . . . . . . . . . . . . . . . . . . . . . . 64\n\n\n\n4.3 Rob\u00f4 M\u00f3vel N\u00e3o-Holon\u00f4mico com Acionamento Diferencial . . . . . . . 72\n4.3.1 Modelo Cinem\u00e1tico e Din\u00e2mico . . . . . . . . . . . . . . . . . . . . . . 74\n4.3.2 Modelo Cinem\u00e1tico do Rob\u00f4 Uniciclo . . . . . . . . . . . . . . . . . . . 74\n4.3.3 Modelo Din\u00e2mico do Rob\u00f4 Uniciclo . . . . . . . . . . . . . . . . . . . . 76\n4.3.4 Controle de Sistemas N\u00e3o-Holon\u00f4micos . . . . . . . . . . . . . . . . . . 77\n4.3.5 Projeto de Controle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n4.4 Telemetria e Telecontrole de um Sistema Embarcado Aplicado na Ma-\n\ncro e Micro Navega\u00e7\u00e3o de Deficientes Visuais . . . . . . . . . . . . . . . 85\n4.4.1 Tecnologia Assistiva . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86\n4.4.2 O Movimento da Bengala . . . . . . . . . . . . . . . . . . . . . . . . . . 86\n4.4.3 Bengala Eletr\u00f4nica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\n4.4.4 Desenvolvimento do Sistema com An\u00e1lise Estruturada . . . . . . . . . . . 91\n4.4.5 Desenvolvimento do Sistema com An\u00e1lise Orientada a Objetos . . . . . . 93\n4.4.6 Sistema de Rastreamento . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n\n5 FRAMEWORK SOA E OS ESTUDOS DE CASOS . . . . . . . . . . . 101\n5.1 Proposta de Arquitetura para o Framework SOA . . . . . . . . . . . . . 101\n5.2 Pap\u00e9is Envolvidos no Uso e Desenvolvimento do Framework SOA . . . . 103\n5.3 Reposit\u00f3rio do Framework SOA . . . . . . . . . . . . . . . . . . . . . . . 105\n5.4 Implanta\u00e7\u00e3o do Projeto . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\n5.4.1 Resultados do Computador Host com Framework SOA Myrobotlab . . . . 109\n5.4.2 Integra\u00e7\u00e3o do Framework SOA com o Rob\u00f4 m\u00f3vel Acionamento Diferencial125\n5.4.3 Integra\u00e7\u00e3o do Framework SOA com a Macro e Micro Navega\u00e7\u00e3o da Ben-\n\ngala Eletr\u00f4nica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\n6 CONCLUS\u00c3O E TRABALHOS FUTUROS . . . . . . . . . . . . . . . . 139\n\nREFER\u00caNCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141\n\n\n\n23\n\n1 INTRODU\u00c7\u00c3O\n\nO ramo da rob\u00f3tica costuma atrair a aten\u00e7\u00e3o de leigos e profissionais, explorando\num campo onde a imagina\u00e7\u00e3o trabalha ao m\u00e1ximo. A rob\u00f3tica de servi\u00e7o em espec\u00edfico\ntem levado esses sistemas para mais perto da popula\u00e7\u00e3o e trazendo desafios aos desen-\nvolvedores destas tecnologias. Para construir uma m\u00e1quina aut\u00f4noma h\u00e1 uma s\u00e9rie de\ndificuldades. Para mover entre dois pontos \u00e9 preciso o controle de motores, mapeamento\ne sensoriamento da regi\u00e3o, estudo da cinem\u00e1tica do rob\u00f4, planejamento da trajet\u00f3ria e\nmonitoramento do movimento. Algumas plataformas de rob\u00f3tica, possuem manuais e um\nfirmware para facilitar a programa\u00e7\u00e3o. Por\u00e9m cada plataforma funciona de forma dife-\nrente e seus c\u00f3digos seguem diferentes pr\u00e1ticas de programa\u00e7\u00e3o. Atualmente existe muito\nprojetos abertos e de f\u00e1cil utiliza\u00e7\u00e3o para quem busca desenvolver na \u00e1rea, tendo-se mui-\ntas vezes adaptar e implementar tudo desde as fun\u00e7\u00f5es mais b\u00e1sicas. Parte disso acontece\npelas diferen\u00e7as f\u00edsicas entre as m\u00e1quinas e devido a se desenvolver projetos n\u00e3o pen-\nsando em reuso de software e em boas pr\u00e1ticas de programa\u00e7\u00e3o. As solu\u00e7\u00f5es existentes\nfuncionam apenas na plataforma no qual foram desenvolvidas e com interfaces diferentes,\nmuitas vezes impedindo que o desenvolvedor reutilize seu c\u00f3digo em outra plataforma.\nComo s\u00e3o poucas as bibliotecas e ferramentas projetadas para funcionarem em v\u00e1rias\nplataformas, cada sistema fica acoplado \u00e0s bibliotecas de suas respectivas plataformas.\nEste problema diminui a reusabilidade e quase anula a chance de portabilidade. Para de-\nsenvolvermos sistemas com produtividade e qualidade diversos aspectos do processo de\ndesenvolvimento devem ser observados. No que concerne ao c\u00f3digo desenvolvido, dois\nitens merecem aten\u00e7\u00e3o especial quando desejamos obter uma arquitetura sustent\u00e1vel: a\ncoes\u00e3o e o acoplamento. O acoplamento refere-se ao quanto uma unidade funcional de-\npende de outra para funcionar. Uma unidade funcional pode ser um m\u00e9todo, fun\u00e7\u00e3o ou\nmesmo uma classe. Quanto maior a depend\u00eancia entre as unidades funcionais, mais for-\ntemente acopladas elas est\u00e3o. Uma das formas de se medir o acoplamento de um m\u00e9todo,\npor exemplo, \u00e9 a quantidade de par\u00e2metros de entrada e suas respectivas complexidades.\nQuanto mais par\u00e2metros e mais complexos eles forem, maior o acoplamento do m\u00e9todo.\nA coes\u00e3o est\u00e1 ligada \u00e0 responsabilidade \u00fanica da unidade funcional. Demonstra coer\u00eancia\ne unidade conceitual no relacionamento com os outros componentes da unidade funcio-\nnal. Ou seja, um m\u00e9todo coeso realiza uma \u00fanica fun\u00e7\u00e3o conceitual, servindo a apenas\num prop\u00f3sito espec\u00edfico (ERL, 2007). Dadas as defini\u00e7\u00f5es acima, podemos concluir que o\ndesej\u00e1vel ao se desenvolver um m\u00f3dulo, m\u00e9todo ou fun\u00e7\u00e3o \u00e9 que o mesmo seja altamente\ncoeso e com o mais baixo acoplamento poss\u00edvel. M\u00e9todos com muitas linhas de c\u00f3digos\ns\u00e3o poss\u00edveis candidatos a refactoring, dada a possibilidade de baixa coes\u00e3o. O mesmo\npode ser aplicado para m\u00e9todos com muitos par\u00e2metros (RINCON, 2014).\n\nEscrever um c\u00f3digo reutiliz\u00e1vel e extens\u00edvel n\u00e3o \u00e9 algo trivial. Para garantir que o\nmesmo c\u00f3digo possa ser replicado em diferentes contextos com nenhuma ou m\u00ednima de\n\n\n\n24\n\naltera\u00e7\u00e3o \u00e9 preciso de uma arquitetura bem projetada e uma correta modulariza\u00e7\u00e3o das\ntarefas do sistema. Uma vez que \u00e9 conhecido o escopo com que se ir\u00e1 trabalhar, um\nplanejamento da melhor forma de estrutur\u00e1-lo \u00e9 necess\u00e1rio para garantir que todas as\nfuncionalidades sejam separadas e suas comunica\u00e7\u00f5es o menos acopladas poss\u00edvel. Isso\nleva ao estudo de padr\u00f5es arquiteturais, encapsulamento e padr\u00f5es de projeto, que nos\najudam a realizar essa tarefa.\n\nUma linha de pesquisa em constante crescimento na rob\u00f3tica s\u00e3o os frameworks. Fra-\nmeworks s\u00e3o estruturas de classes que constituem implementa\u00e7\u00f5es incompletas que, es-\ntendidas, permitem produzir diferentes artefatos de software. Uma das vantagens desta\nabordagem \u00e9 a promo\u00e7\u00e3o de reuso de c\u00f3digo e projeto, que pode diminuir o tempo e o\nesfor\u00e7o exigidos na produ\u00e7\u00e3o de software. A abordagem de frameworks pode se valer\nde padr\u00f5es para a obten\u00e7\u00e3o de estruturas de classes e Component-Based Development\nou simplesmente Desenvolvimento Baseado em Componentes (DBC) bem organizadas\ne mais aptas a modifica\u00e7\u00f5es e extens\u00f5es. O desenvolvimento orientado a componen-\ntes pretende organizar a estrutura de um software como uma interliga\u00e7\u00e3o de artefatos de\nsoftware independentes, os componentes. O reuso de componentes previamente desen-\nvolvidos, permite a redu\u00e7\u00e3o de tempo e esfor\u00e7o para a obten\u00e7\u00e3o de um framework para\nrob\u00f3tica baseado em arquiteturas orientadas a servi\u00e7os (Service-Oriented Architecture -\nSOA). Uma arquitetura SOA tem como seu componente fundamental o conceito de servi-\n\u00e7os. O conceito de servi\u00e7o \u00e9 definido de diversas formas, como mostram Silva (2000a) e\nMaxwell (2011).\n\nPortanto, o conceito do que \u00e9 uma arquitetura orientada a servi\u00e7os ainda n\u00e3o \u00e9 consen-\nsual, uma vez que servi\u00e7o n\u00e3o \u00e9 um termo bem definido e se confunde com os conceitos de\ncomponente e de contrato. Atrav\u00e9s do trabalho de Silva (2000a) e Fugita (1993) foi pos-\ns\u00edvel identificar algumas caracter\u00edsticas relevantes que todas aplica\u00e7\u00f5es e frameworks que\nse dizem orientados a objetos (OO), componentes e servi\u00e7os, possuem. O uso do padr\u00e3o\nSOA est\u00e1 evoluindo e est\u00e1 cada vez mais presente em aplica\u00e7\u00f5es nos mais diversos seg-\nmentos, sejam eles em n\u00edvel de dispositivos, na implementa\u00e7\u00e3o de camadas de neg\u00f3cios\nou mesmo no setor industrial, como apresentado em Giacomolli (2014). \u00c9 um conceito\nde arquitetura que suporta acoplamento m\u00ednimo entre componentes, possibilitando ga-\nnhos em flexibilidade e interoperabilidade. Por conseguinte, qualquer tipo de aplica\u00e7\u00e3o\npode ser representada como um conjunto complexo de servi\u00e7os. Com a utiliza\u00e7\u00e3o de\nSOA, um recurso ou componente \u00e9 identificado como um servi\u00e7o. As funcionalidades\nagregadas a um servi\u00e7o s\u00e3o publicadas e disponibilizadas atrav\u00e9s de uma interface padr\u00e3o\nou classe abstrata, o que possibilita a troca de informa\u00e7\u00f5es ou requisi\u00e7\u00e3o da execu\u00e7\u00e3o\nde alguma tarefa entre os componentes. A reutiliza\u00e7\u00e3o de artefatos de software em larga\nescala \u00e9 um dos argumentos a favor da abordagem de orienta\u00e7\u00e3o a servi\u00e7os. A express\u00e3o\nartefato de software \u00e9 usada aqui de forma gen\u00e9rica, n\u00e3o se referindo necessariamente a\nc\u00f3digo (podendo abranger os produtos da an\u00e1lise e do projeto) (SILVA, 2000).\n\nAtualmente, existe uma infra-estrutura tecnol\u00f3gica pronta, que suporta CBD e SOA\nsem muito esfor\u00e7o, mas n\u00e3o garante, apenas permite a aplica\u00e7\u00e3o das abordagens citadas.\nUma compara\u00e7\u00e3o de CBD versus SOA \u00e9 muito abrangente e, portanto, envolve quest\u00f5es\nde v\u00e1rias dimens\u00f5es. Sendo assim, este trabalho focar\u00e1 nos servi\u00e7os que refletem os\nprocessos do projeto. Isto porque, \u00e9 apenas nesse \u00e2mbito que o SOA pode cumprir sua\npromessa de alinhar servi\u00e7os com neg\u00f3cio. A relev\u00e2ncia dessa pesquisa est\u00e1 na fus\u00e3o\nde diferentes conhecimentos te\u00f3ricos das distintas \u00e1reas das engenharia e ci\u00eancias que,\nintegradas, proporcionaram a implementa\u00e7\u00e3o de um framework aplicado a rob\u00f3tica.\n\n\n\n25\n\n1.1 Objetivo\n\nObserva-se em comum nas abordagens de frameworks OO e CBD a possibilidade de\nreutiliza\u00e7\u00e3o de artefatos de software de alta granularidade, e a caracteriza\u00e7\u00e3o de reuso de\nprojeto e c\u00f3digo. A ado\u00e7\u00e3o destas abordagens no desenvolvimento de software - em con-\njunto ou isoladamente - pode diminuir significativamente o tempo para o desenvolvimento\nde novas aplica\u00e7\u00f5es orientadas a servi\u00e7os, bem como a quantidade de c\u00f3digo a desenvol-\nver, na medida em que parte das responsabilidades das novas aplica\u00e7\u00f5es s\u00e3o atribu\u00eddas a\nartefatos de software reutilizados. O presente trabalho se preocupa com a integra\u00e7\u00e3o das\nabordagens de middleware, independ\u00eancia de plataforma, encapsulamento, reusabilidade,\nescalabilidade, simplicidade de integra\u00e7\u00e3o, simplicidade de estender as funcionalidades\nexistentes, para desenvolver um conjunto de bibliotecas e componentes, que gerenciam\na media\u00e7\u00e3o entre as demais aplica\u00e7\u00f5es do sistema, fornecendo bibliotecas reutiliz\u00e1veis e\nferramentas, para o desenvolvimento de um framework baseado em SOA para rob\u00f3tica,\nque t\u00eam em comum a reutiliza\u00e7\u00e3o, seja de projeto ou de c\u00f3digo, isto \u00e9, o aproveitamento\nde experi\u00eancias de desenvolvimentos de hardwares e softwares open-source, para criar\num ambiente que disponibilize servi\u00e7os e integra\u00e7\u00e3o de diferentes aplica\u00e7\u00f5es. A integra-\n\u00e7\u00e3o se concentra principalmente em pacotes de classes e componentes, que permitam o\naplicativo do software simular, controlar e interagir com os diferentes sistemas integra-\ndos. Como objetivos do trabalho, est\u00e3o a integra\u00e7\u00e3o e especifica\u00e7\u00e3o do modelo conceitual\nda arquitetura orientada a servi\u00e7o do framework, implementa\u00e7\u00e3o de uma cole\u00e7\u00e3o de pa-\ncotes de classes e componentes, para auxiliar na percep\u00e7\u00e3o, controle e desenvolvimento\nde dispositivos, fornecendo servi\u00e7os para projetos de rob\u00f3tica. Para valida\u00e7\u00e3o do artefato\nde software pretendido, dois estudos de casos foram aplicados no framework, um baseado\nem rob\u00f3tica m\u00f3vel (EDUBOT, 2014); (GUIMAR\u00c3ES; TAMAYO; HENRIQUES, 2014)\ne outro em tecnologia assistiva (GUIMAR\u00c3ES; HENRIQUES; PEREIRA, 2012); (GUI-\nMAR\u00c3ES; HENRIQUES; PEREIRA, 2013); (GUIMAR\u00c3ES; PEREIRA; HENRIQUES,\n2014).\n\n1.2 Organiza\u00e7\u00e3o do Trabalho\n\nNo Cap\u00edtulo 2 s\u00e3o apresentados os fundamentos te\u00f3ricos, que descrevem resumida-\nmente alguns conceitos sobre Engenharia de Software e os diferentes paradigmas de fra-\nmeworks. O Cap\u00edtulo 3 apresenta alguns frameworks Open-source para rob\u00f3tica. No\nCap\u00edtulo 4 s\u00e3o apresentadas as an\u00e1lises e projetos dos estudos de caso do trabalho. O\nCap\u00edtulo 5 aborda a metodologia de desenvolvimento utilizada para o framework. No\nCap\u00edtulo 6 \u00e9 apresentada a proposta do framework pretendido. O Cap\u00edtulo 7 apresenta\na implementa\u00e7\u00e3o e resultados e por fim, o Cap\u00edtulo 8 s\u00e3o feitas as considera\u00e7\u00f5es finais\nsobre o trabalho desenvolvido e sugest\u00f5es para trabalhos futuros.\n\n\n\n\n\n27\n\n2 FUNDAMENTA\u00c7\u00c3O TE\u00d3RICA\n\nUm dos principais objetivos da Engenharia de Software \u00e9 o reuso. Atrav\u00e9s da reu-\ntiliza\u00e7\u00e3o de software obt\u00e9m-se o aumento da qualidade e redu\u00e7\u00e3o do esfor\u00e7o de desen-\nvolvimento. A orienta\u00e7\u00e3o a objetos fornece funcionalidades para que classes possam ser\nreutilizadas, bem como m\u00e9todos por meio de seus mecanismos de heran\u00e7a e polimor-\nfismo. Componentes de software definem unidades reutiliz\u00e1veis que oferecem servi\u00e7os\natrav\u00e9s de interfaces bem definidas. Al\u00e9m destas formas de reutiliza\u00e7\u00e3o, a tecnologia de\nframeworks possibilita que uma fam\u00edlia de produtos seja gerada a partir de uma \u00fanica\nestrutura que captura os conceitos mais gerais da fam\u00edlia de aplica\u00e7\u00f5es para criar um\nframework orientado a servi\u00e7os (MAXWELL, 2014, 2013).\n\nEste cap\u00edtulo apresenta os principais conceitos sobre frameworks encontrados na li-\nteratura. Primeiramente, s\u00e3o revistas algumas defini\u00e7\u00f5es sobre frameworks. Logo ap\u00f3s,\ns\u00e3o apresentados os conceitos da Engenharia de software de servi\u00e7os e sua rela\u00e7\u00e3o com\nos paradigmas OO e CBD. E por \u00faltimo s\u00e3o apresentados alguns dos conceitos referentes\naos estudos de casos do projeto.\n\n2.1 Sistemas Embarcados\n\nExistem muitas defini\u00e7\u00f5es de sistemas embarcados, mas todas estas defini\u00e7\u00f5es podem\nser combinadas em um conceito simples. Este sistema computacional \u00e9 normalmente me-\nnos poderoso que os sistemas computacionais de prop\u00f3sito geral, embora em alguns casos\nexistam sistemas embarcados que sejam complexos, desempenhando v\u00e1rias fun\u00e7\u00f5es dife-\nrentes. Quase todos dispositivos eletr\u00f4nicos modernos utilizam processadores para ajudar\na controlar f\u00e1bricas, gerenciar sistemas e habilitar a comunica\u00e7\u00e3o entre pessoas e produ-\ntos. Normalmente em sistemas embarcados \u00e9 utilizado um processador de baixo consumo\nde pot\u00eancia com uma quantidade limitada de mem\u00f3ria. Alguns destes sistemas embarca-\ndos utilizam sistemas operacionais otimizados, que possuem uma capacidade limitada de\nfun\u00e7\u00f5es de opera\u00e7\u00e3o. Contudo, a escolha dos componentes do sistema sempre deve ser\nbaseada nas caracter\u00edsticas da aplica\u00e7\u00e3o para a qual o sistema embarcado est\u00e1 sendo pro-\nposto. Muitos sistemas embarcados s\u00e3o concebidos partindo do pressuposto que devem\nser utilizados por um longo per\u00edodo de tempo sem necessitarem manuten\u00e7\u00e3o. Estes tipos\nde componentes sofrem desgaste natural com o tempo e periodicamente necessitam ser\ntrocados e/ou reparados.\n\nUm projeto de Software Embarcado inicia-se primeiramente estudando todas as possi-\nbilidades e desafios que ser\u00e3o enfrentados durante tal projeto. Basicamente seria entender\nas suas caracter\u00edsticas, que v\u00e3o desde a quantidade da mem\u00f3ria do software (o que faz\ntoda a diferen\u00e7a em um projeto) at\u00e9 os conceitos de programa\u00e7\u00e3o em tempo real. Ou-\ntra caracter\u00edstica importante \u00e9 o custo total desse desenvolvimento, pois, como a cada\n\n\n\n28\n\ndia os softwares se tornam mais complexos, aumenta-se, assim, os seus custos, sendo\nimportante, ent\u00e3o, analis\u00e1-los. Com o aumento do custo, aumenta-se tamb\u00e9m a press\u00e3o\npara que o projeto seja conclu\u00eddo o mais r\u00e1pido poss\u00edvel, podendo haver alguns proble-\nmas no final do projeto. Falar de Sistemas Embarcados abrange uma \u00e1rea grande de\ndiferentes conceitos, envolvendo tipos de hardwares e softwares, sendo a base f\u00edsica da\ntecnologia o hardware e a l\u00f3gica o software. Os principais componentes de hardware de\nsistema embarcado s\u00e3o os processadores e chips, algumas tecnologias de conectividade,\ncomo Acesso M\u00faltiplo por Divis\u00e3o de C\u00f3digo (CDMA), Acesso M\u00faltiplo por Divis\u00e3o de\nTempo (TDMA) e Sistema Global para Comunica\u00e7\u00f5es M\u00f3veis (GSM), bluetooth e uma\ndas mais usadas, a wireless.\n\nO firmware \u00e9 um software interpolado num dispositivo de hardware que permite a\nleitura e execu\u00e7\u00e3o de software, por\u00e9m n\u00e3o permite modifica\u00e7\u00e3o. O termo firmware foi\noriginado para indicar um substituinte de hardware em microcontroladores. Em outras\npalavras, o firmware \u00e9 um controlador de entrada e sa\u00edda de baixo n\u00edvel que gerencia\ndispositivos de hardware. No computador, ele permite a comunica\u00e7\u00e3o entre software e\nhardware. A linguagem de programa\u00e7\u00e3o dos firmwares \u00e9, primordialmente, a linguagem\nde m\u00e1quina, cada arquitetura de computador tem a sua pr\u00f3pria linguagem de m\u00e1quina e,\nportanto, a sua pr\u00f3pria linguagem de montagem (Assembly). A linguagem de m\u00e1quina,\nque \u00e9 um mero padr\u00e3o de bits, torna-se leg\u00edvel pela substitui\u00e7\u00e3o dos valores em bruto por\ns\u00edmbolos chamados mnem\u00f3nicos. Essas linguagens de montagem diferem no n\u00famero e\ntipo de opera\u00e7\u00f5es que suportam. Tamb\u00e9m t\u00eam diferentes tamanhos e n\u00fameros de regis-\ntradores, e diferentes representa\u00e7\u00f5es dos tipos de dados armazenados. Enquanto todos\nos computadores de utiliza\u00e7\u00e3o gen\u00e9rica s\u00e3o capazes de desempenhar essencialmente as\nmesmas fun\u00e7\u00f5es, o modo como o fazem \u00e9 diferente. Al\u00e9m disso, podem existir conjuntos\nm\u00faltiplos de mnem\u00f3nicas, ou sintaxes de linguagem de montagem, para um \u00fanico con-\njunto de instru\u00e7\u00f5es. Nestes casos, o conjunto mais popular \u00e9 aquele que \u00e9 utilizado pelo\nfabricante na sua documenta\u00e7\u00e3o. Por\u00e9m, hoje alguns microcontroladores interpretam,\ntamb\u00e9m, fun\u00e7\u00f5es e classes de linguagens como C/C++ e Java, linguagens de programa-\n\u00e7\u00e3o de alto n\u00edvel para implementa\u00e7\u00e3o de sistemas, permitindo uma descri\u00e7\u00e3o com um alto\nn\u00edvel de abstra\u00e7\u00e3o tornando os programas mais f\u00e1ceis de serem lidos e escritos.\n\nSer desenvolvedor de um projeto de software embarcado n\u00e3o \u00e9 uma tarefa trivial,\npois se deve ter um cuidado muito grande no desenvolvimento do projeto em rela\u00e7\u00e3o\n\u00e0s demandas de desempenho, espa\u00e7o e pot\u00eancia consumida. Sistemas Embarcados s\u00e3o\nsistemas computacionais especialistas. Estes sistemas s\u00e3o constitu\u00eddos por um conjunto\nhardware, software e perif\u00e9ricos, sendo respons\u00e1veis por uma fun\u00e7\u00e3o espec\u00edfica ou um\nconjunto restrito de fun\u00e7\u00f5es espec\u00edficas (WEHRMEISTER, 2005).\n\n2.2 Engenharia de Software\n\nUma primeira defini\u00e7\u00e3o de engenharia de software foi proposta por Fritz Bauer na\nprimeira grande confer\u00eancia dedicada ao assunto: \"O estabelecimento e uso de s\u00f3lidos\nprinc\u00edpios de engenharia para que se possa obter economicamente um software que fun-\ncione eficientemente com m\u00e1quinas reais\". A Engenharia de Software atua na aplica\u00e7\u00e3o\nde abordagens sistem\u00e1ticas ao desenvolvimento e manuten\u00e7\u00e3o de software. Os objetivos\nprincipais da Engenharia de Software s\u00e3o a melhora da qualidade do software e o aumento\nda produtividade da atividade de desenvolvimento de software.\n\nNa literatura, (PRESSMAN, 2010; SOMMERVILLE, 2011) pode-se encontrar diver-\nsas defini\u00e7\u00f5es da Engenharia de Software:\n\n\n\n29\n\n\u2022 \"O estabelecimento e uso de s\u00f3lidos princ\u00edpios de engenharia para que se possa ob-\nter economicamente um software que seja confi\u00e1vel e que funcione eficientemente\nem m\u00e1quinas reais\".\n\n\u2022 \"Engenharia de Software \u00e9 um ramo da engenharia cujo foco \u00e9 o desenvolvimento\nde softwares de alta qualidade e dentro de custos adequados\".\n\n\u2022 \"Aplica\u00e7\u00e3o de uma abordagem sistem\u00e1tica, disciplinada e qualific\u00e1vel, para o de-\nsenvolvimento, opera\u00e7\u00e3o e manuten\u00e7\u00e3o do software\".\n\nA engenharia de software \u00e9 uma deriva\u00e7\u00e3o da engenharia de sistemas e de hardware.\nEla abrange um conjunto de tr\u00eas elementos fundamentais - m\u00e9todos, ferramentas e proce-\ndimentos - que possibilita ao gerente o controle do processo de desenvolvimento do soft-\nware e oferece ao profissional uma base para a constru\u00e7\u00e3o produtiva de software de alta\nqualidade. Os m\u00e9todos de engenharia de software proporcionam os detalhes de \"como\nfazer\"para construir o software. Os m\u00e9todos envolvem um amplo conjunto de tarefas\nque incluem: planejamento, estimativa de projeto, an\u00e1lise de requisitos de software e de\nsistemas, projeto da estrutura de dados, arquitetura de programa e algoritmo de proces-\nsamento, codifica\u00e7\u00e3o, teste e manuten\u00e7\u00e3o. Os m\u00e9todos da engenharia de software muitas\nvezes introduzem uma nota\u00e7\u00e3o gr\u00e1fica ou orientada a linguagem especial e introduzem um\nconjunto de crit\u00e9rios para a qualidade do software. Um dos principais objetivos da Enge-\nnharia de Software \u00e9 o reuso. Atrav\u00e9s da reutiliza\u00e7\u00e3o de software obt\u00e9m-se o aumento da\nqualidade e redu\u00e7\u00e3o do esfor\u00e7o de desenvolvimento.\n\nDe modo mais objetivo, pode-se dizer que a Engenharia de Software busca prover\na tecnologia necess\u00e1ria para produzir software de alta qualidade a um baixo custo. Os\ndois fatores motivadores s\u00e3o essencialmente a qualidade e o custo. A qualidade de um\nproduto de software \u00e9 um par\u00e2metro cuja quantifica\u00e7\u00e3o n\u00e3o \u00e9 trivial, apesar dos esfor\u00e7os\ndesenvolvidos nesta dire\u00e7\u00e3o. Por outro lado, o fator custo pode ser facilmente quantifi-\ncado desde que os procedimentos de contabilidade tenham sido corretamente efetuados\n(MAXWELL, 2014, 2013).\n\n2.3 Classifica\u00e7\u00e3o e Defini\u00e7\u00e3o de Frameworks\n\nFrameworks podem ser classificados de diversas formas. Inicialmente, s\u00e3o classifica-\ndos em dois grupos principais: frameworks orientados a objetos e frameworks de compo-\nnentes (SILVA, 2000) (MAXWELL, 2014, 2013). O primeiro define uma estrutura para o\ndesenvolvimento de aplica\u00e7\u00f5es orientados a objetos (OO) enquanto que o segundo define\numa infra-estrutura de execu\u00e7\u00e3o onde componentes (DBC) podem ser conectados. Fra-\nmeworks OO e CBD podem ainda ser classificados quanto ao seu uso como frameworks\ncaixa branca, que exige um bom conhecimento da estrutura interna do framework por\nparte do usu\u00e1rio do framework, caixa preta, que \u00e9 menos flex\u00edvel que o framework caixa\nbranca, mas possibilita o seu uso sem que o desenvolvedor precise conhecer a estrutura\ninterna do framework, e caixa cinza, que tenta combinar as vantagens dos frameworks\ncaixa branca e preta.\n\nAl\u00e9m disso, um framework agiliza o processo de desenvolvimento de software que\nlida com determinado tipo de problema, provendo recursos que fornecem flexibilidade\npara os desenvolvedores adequarem-no \u00e0s suas necessidades, reusando a solu\u00e7\u00e3o da parte\ncomum dos problemas. Tamb\u00e9m pode ser definido como um projeto reus\u00e1vel de todo\nou de parte de um sistema, fornecendo um conjunto de classes abstratas e a forma com\n\n\n\n30\n\nque suas sub-classes interagem. Um framework \u00e9 um esqueleto de um sistema, que \u00e9\ninstanciado e especializado para gerar uma fam\u00edlia de aplica\u00e7\u00f5es.\n\nA literatura \u00e9 repleta de defini\u00e7\u00f5es de frameworks. A seguir, as principais s\u00e3o descritas\nsegundo os trabalhos seguidos:\n\n\u2022 \"Um framework \u00e9 um conjunto de classes que constitui um projeto abstrato para a\nsolu\u00e7\u00e3o de uma fam\u00edlia de problemas.\"\n\n\u2022 \"Um framework \u00e9 uma arquitetura desenvolvida com o objetivo de atingir a m\u00e1xima\nreutiliza\u00e7\u00e3o, representada como um conjunto de classes abstratas e concretas, com\ngrande potencial de especializa\u00e7\u00e3o.\"\n\n\u2022 \"Um framework \u00e9 um conjunto de objetos que colaboram com o objetivo de atender\na um conjunto de responsabilidades para uma aplica\u00e7\u00e3o espec\u00edfica ou um dom\u00ednio\nde aplica\u00e7\u00e3o.\"\n\n\u2022 \"Um framework \u00e9 definido como um software parcialmente completo projetado\npara ser instanciado. O framework define uma arquitetura para uma fam\u00edlia de\nsubsistemas e oferece os construtores b\u00e1sicos para cri\u00e1 los.\"\n\nApesar de diferentes, as defini\u00e7\u00f5es encontradas na literatura n\u00e3o s\u00e3o contradit\u00f3rias. A\ndefini\u00e7\u00e3o adotada nesta disserta\u00e7\u00e3o \u00e9 a de (SILVA, 2000; FUGITA, 2009) e (MAXWELL,\n2014, 2013).\n\n2.3.1 Frameworks Orientado a Objetos\n\nA abordagem de framework Orientado a Objetos (OO) utiliza o paradigma de ori-\nenta\u00e7\u00e3o a objetos para produzir uma descri\u00e7\u00e3o de um dom\u00ednio para ser reutilizada. Um\nframework OO \u00e9 uma estrutura de classes inter-relacionadas, que corresponde a uma im-\nplementa\u00e7\u00e3o incompleta para um conjunto de aplica\u00e7\u00f5es de um dom\u00ednio. Esta estrutura de\nclasses deve ser adaptada para a gera\u00e7\u00e3o de aplica\u00e7\u00f5es espec\u00edficas, gerando um esqueleto\nde implementa\u00e7\u00e3o de uma aplica\u00e7\u00e3o ou de um subsistema de aplica\u00e7\u00e3o, em um dom\u00ednio\nde problema particular. \u00c9 composto de classes abstratas e concretas e prov\u00ea um modelo\nde intera\u00e7\u00e3o ou colabora\u00e7\u00e3o entre as inst\u00e2ncias de classes definidas pelo framework OO.\nUm framework OO \u00e9 utilizado atrav\u00e9s de configura\u00e7\u00e3o ou conex\u00e3o de classes concretas\ne deriva\u00e7\u00e3o de novas classes concretas a partir das classes abstratas do framework OO. A\ndiferen\u00e7a fundamental entre framework OO e a reutiliza\u00e7\u00e3o de classes de uma biblioteca,\n\u00e9 que neste caso s\u00e3o usados artefatos de software isolados, cabendo ao desenvolvedor\nestabelecer sua interliga\u00e7\u00e3o, e no caso do framework OO, \u00e9 procedida a reutiliza\u00e7\u00e3o de\num conjunto de classes inter-relacionadas estabelecido no projeto do framework OO. As\nFiguras 1, 2 e 3 abaixo, ilustram esta diferen\u00e7a (a parte sombreada representa classes e\nassocia\u00e7\u00f5es que s\u00e3o reutilizadas).\n\nDois aspectos caracterizam um framework OO:\n\n\u2022 Os frameworks OO fornecem infraestrutura e projeto: frameworks OO portam\ninfraestrutura de projeto disponibilizada ao desenvolvedor da aplica\u00e7\u00e3o, que reduz a\nquantidade de c\u00f3digo a ser desenvolvida, testada e depurada. As interconex\u00f5es pre-\nestabelecidas definem a arquitetura da aplica\u00e7\u00e3o, liberando o desenvolvedor desta\nresponsabilidade. O c\u00f3digo escrito pelo desenvolvedor visa estender ou particula-\nrizar o comportamento do framework OO, de forma a mold\u00e1-lo a uma necessidade\nespec\u00edfica.\n\n\n\n31\n\nFigura 1: Aplica\u00e7\u00e3o desenvolvida totalmente (SILVA, 2000)\n\nFigura 2: Aplica\u00e7\u00e3o desenvolvida reutilizando classes de biblioteca (SILVA, 2000)\n\nFigura 3: Aplica\u00e7\u00e3o desenvolvida reutilizando um framework OO (SILVA, 2000)\n\n\n\n32\n\n\u2022 Os frameworks OO \"chamam\", n\u00e3o s\u00e3o \"chamados\": um papel do framework\nOO \u00e9 fornecer o fluxo de controle da aplica\u00e7\u00e3o. Assim, em tempo de execu\u00e7\u00e3o,\nas inst\u00e2ncias das classes desenvolvidas esperam ser chamadas pelas inst\u00e2ncias das\nclasses do framework OO.\n\nUm framework OO se destina a gerar diferentes aplica\u00e7\u00f5es para um dom\u00ednio. Pre-\ncisa, portanto, conter uma descri\u00e7\u00e3o dos conceitos deste dom\u00ednio. As classes abstratas\nde um framework OO s\u00e3o os reposit\u00f3rios dos conceitos gerais do dom\u00ednio de aplica\u00e7\u00e3o.\nNo contexto de um framework OO, um m\u00e9todo de uma classe abstrata pode ser deixado\npropositalmente incompleto para que sua defini\u00e7\u00e3o seja acabada na gera\u00e7\u00e3o de uma apli-\nca\u00e7\u00e3o. Apenas atributos a serem utilizados por todas as aplica\u00e7\u00f5es de um dom\u00ednio s\u00e3o\ninclu\u00eddos em classes abstratas.\n\nNo processo de desenvolvimento de um framework OO, deve-se produzir uma estru-\ntura de classes com a capacidade de adaptar-se a um conjunto de aplica\u00e7\u00f5es diferentes.\nPara construir um framework OO, \u00e9 fundamental que se disponha de modelagens de um\nconjunto significativo de aplica\u00e7\u00f5es do dom\u00ednio. Este conjunto pode se referir a aplica-\n\u00e7\u00f5es previamente desenvolvidas, ou a aplica\u00e7\u00f5es que se deseja produzir a partir do fra-\nmework OO. A \u00f3tica de diferentes aplica\u00e7\u00f5es \u00e9 o que d\u00e1 ao desenvolvedor a capacidade\nde diferenciar conceitos gerais de conceitos espec\u00edficos.\n\nEm termos pr\u00e1ticos, dotar um framework OO de generalidade, alterabilidade e exten-\nsibilidade requer uma cuidadosa identifica\u00e7\u00e3o das partes que devem ser mantidas flex\u00edveis\ne a sele\u00e7\u00e3o de solu\u00e7\u00f5es de projeto de modo a produzir uma arquitetura bem estruturada.\nIsto passa pela observa\u00e7\u00e3o de princ\u00edpios de projeto OO, como o uso de heran\u00e7a para reuti-\nliza\u00e7\u00e3o de interfaces (ao inv\u00e9s do uso de heran\u00e7a para reutiliza\u00e7\u00e3o de c\u00f3digo); reutiliza\u00e7\u00e3o\nde c\u00f3digo atrav\u00e9s de composi\u00e7\u00e3o de objetos; preocupa\u00e7\u00e3o em promover polimorfismo, na\ndefini\u00e7\u00e3o das classes e m\u00e9todos, de modo a possibilitar acoplamento din\u00e2mico. No con-\ntexto de frameworks OO, o uso adequado de heran\u00e7a implica na concentra\u00e7\u00e3o das gene-\nralidades do dom\u00ednio em classes abstratas, no topo da hierarquia de classes. Isto promove\nuso adequado de heran\u00e7a, pois a principal finalidade destas classes abstratas \u00e9 definir as\ninterfaces a serem herdadas pelas classes concretas das aplica\u00e7\u00f5es.\n\nPode-se afirmar que o desenvolvimento de um framework OO \u00e9 mais complexo que o\ndesenvolvimento de aplica\u00e7\u00f5es espec\u00edficas do mesmo dom\u00ednio, devido:\n\n\u2022 \u00c0 necessidade de considerar os requisitos de um conjunto significativo de aplica-\n\u00e7\u00f5es, de modo a dotar a estrutura de classes do framework OO de generalidade, em\nrela\u00e7\u00e3o ao dom\u00ednio tratado;\n\n\u2022 \u00c0 necessidade de ciclos de evolu\u00e7\u00e3o voltados a dotar a estrutura de classes do fra-\nmework OO de alterabilidade e extensibilidade.\n\nA pesquisa sobre identifica\u00e7\u00e3o de padr\u00f5es fornece estruturas de projeto semiprontas\nque podem ser reutilizadas, contribuindo no desenvolvimento de frameworks OO, no sen-\ntido de produzir uma organiza\u00e7\u00e3o de classes bem estruturada. Padr\u00f5es promovem o uso\nadequado de heran\u00e7a e o desenvolvimento de projetos em que o acoplamento entre classes\n\u00e9 minimizado.\n\nO processo de desenvolvimento de frameworks OO pode envolver a tarefa de combinar\nframeworks OO para uso conjunto. A Figura 4 ilustra o uso de composi\u00e7\u00e3o de objetos\npara a combina\u00e7\u00e3o de objetos respons\u00e1veis pela l\u00f3gica de controle.\n\n\n\n33\n\nFigura 4: Combina\u00e7\u00e3o de frameworks OO (SILVA, 2000)\n\n2.4 Engenharia de Software Baseado em Componentes\n\nA Engenharia de Software baseado no desenvolvimento baseado em componentes ou\nCBD \u00e9 uma abordagem que surgiu na comunidade de engenharia de software na \u00faltima\nd\u00e9cada. Destina-se a mudar a \u00eanfase na constru\u00e7\u00e3o do sistema de programa\u00e7\u00e3o tradi-\ncional para compor sistemas de software com uma mistura de componentes padr\u00f5es e\ncomponentes customizados. A utiliza\u00e7\u00e3o desta abordagem permite a reutiliza\u00e7\u00e3o de com-\nponentes de software em diversas aplica\u00e7\u00f5es, ao inv\u00e9s de se construir um sistema intei-\nramente novo, o que diminui significativamente a quantidade de c\u00f3digo gerado. Al\u00e9m da\ndiminui\u00e7\u00e3o do esfor\u00e7o empregado, outros benef\u00edcios s\u00e3o evidentes, pois um componente\namplamente usado torna-se confi\u00e1vel, robusto, eficiente e bem conhecido quanto as suas\nfuncionalidades, interfaces e limita\u00e7\u00f5es. Tendo-se em vista um projeto complexo que en-\nvolva diferentes funcionalidades, pode-se mais facilmente constru\u00ed-lo utilizando blocos\nfuncionais, a partir do re\u00faso de componentes prontos. Assim, o projetista n\u00e3o necessita\nconhecer a implementa\u00e7\u00e3o espec\u00edfica de cada funcionalidade, focando apenas na de seu\ninteresse. Al\u00e9m disso, este sistema torna-se modular, o que ajuda nas depend\u00eancias de\ncontrole e aumenta a exigibilidade do sistema para futuras altera\u00e7\u00f5es e manuten\u00e7\u00f5es. Os\ntestes no sistema tamb\u00e9m ficam mais f\u00e1ceis, uma vez que pode-se testar cada componente\nseparadamente. Contundo, desenvolvimento de software baseado em componentes e a\nreutiliza\u00e7\u00e3o de c\u00f3digo ainda n\u00e3o s\u00e3o pr\u00e1ticas amplamente utilizadas na rob\u00f3tica.\n\nHoje em dia a maioria das pesquisas e desenvolvimento de software ainda s\u00e3o base-\nadas em arquiteturas de software personalizadas, constru\u00eddas a partir do zero. Portanto\na maioria das aplica\u00e7\u00f5es na rob\u00f3tica s\u00e3o sistemas desenvolvidos com uma finalidade es-\npec\u00edfica, os quais acumulam grande quantidade de software que implementam sistemas\ncompletos. No entanto, isso n\u00e3o favorece o re\u00faso de software, pois este torna-se espec\u00ed-\nfico para um determinado hardware, sistema operacional ou meio de comunica\u00e7\u00e3o, al\u00e9m\ndo que toda funcionalidade e conhecimento est\u00e1 dentro do c\u00f3digo, e n\u00e3o exposta de forma\nclara e organizada em uma interface (FUGITA, 2009); (MAXWELL, 2014, 2013). Afim\nde superar tais dificuldades, a engenharia software baseada em componentes possui tr\u00eas\nprincipais fun\u00e7\u00f5es:\n\n\u2022 Desenvolver software a partir de partes pr\u00e9 produzidas;\n\n\u2022 Reutilizar tais partes em diferentes aplica\u00e7\u00f5es;\n\n\n\n34\n\n\u2022 Ser capaz de oferecer f\u00e1cil manuten\u00e7\u00e3o e customiza\u00e7\u00e3o a estas partes para desen-\nvolver novas fun\u00e7\u00f5es e funcionalidades;\n\n2.4.1 Frameworks Orientado a Componentes\n\nPara acessar e interconectar componentes, s\u00e3o utilizadas suas portas. Uma porta \u00e9\num meio identific\u00e1vel de conex\u00e3o, por onde um componente oferece seus servi\u00e7os ou\nacessa os servi\u00e7os dos outros. As portas s\u00e3o ligadas atrav\u00e9s de conectores, implementa-\ndos atrav\u00e9s de chamada de m\u00e9todos, propaga\u00e7\u00e3o de eventos, fluxo de dados, transfer\u00eancia\nde arquivos, etc. Os tipos de conectores variam para cada tecnologia e possibilitam a\nconex\u00e3o em tempo de codifica\u00e7\u00e3o, compila\u00e7\u00e3o, inicializa\u00e7\u00e3o ou execu\u00e7\u00e3o. A interface \u00e9\no contrato de utiliza\u00e7\u00e3o do componente. Respeitando-se os contratos, pode-se alterar a\nimplementa\u00e7\u00e3o interna do componente ou substitu\u00ed-lo por outro, sem modificar seus cli-\nentes. A interface define as maneiras de utilizar o componente, separando a especifica\u00e7\u00e3o\nda implementa\u00e7\u00e3o. Um componente apresenta m\u00faltiplas interfaces correspondendo aos\nconjuntos de servi\u00e7os que visam diferentes necessidades dos clientes. Normalmente, o\ncomponente possui pelo menos uma interface relativa aos servi\u00e7os disponibilizados (in-\nterface de neg\u00f3cio) e outra \u00e0 conex\u00e3o com a infra-estrutura de execu\u00e7\u00e3o (interface de\nsistema), onde s\u00e3o tratados servi\u00e7os t\u00e9cnicos, como os relacionados ao ciclo de vida, \u00e0\ninstala\u00e7\u00e3o e \u00e0 persist\u00eancia.\n\nA forma usual de descrever um componente consiste na descri\u00e7\u00e3o de sua interface.\nPor\u00e9m, os mecanismos de descri\u00e7\u00e3o de interface existentes, em geral, s\u00e3o pobres para\ndescrever componentes porque produzem apenas uma vis\u00e3o externa incapaz de descrever\nsuas funcionalidades e como estes interagem, Silva (2000b) especifica os diagramas de\ncomponentes conforme sua abstra\u00e7\u00e3o. Na vis\u00e3o do desenvolvimento orientado a compo-\nnentes do autor, comunica\u00e7\u00e3o unidirecional \u00e9 um caso particular, pois a intera\u00e7\u00e3o de um\ncomponente com o meio externo pode ser bidirecional, ou seja, em geral o componente\npode fornecer servi\u00e7os mas tamb\u00e9m requer\u00ea-los. \u00c9 poss\u00edvel que um componente pre-\ncise interagir com mais de um componente simultaneamente. Neste caso a interface deve\ndispor de mecanismos de acesso bidirecionais e que possibilitem a conex\u00e3o de um com-\nponente a mais de um componente. Cada um destes pontos de acesso \u00e9 chamado de canal\nde comunica\u00e7\u00e3o. Assim, no trabalho de Silva (2000b), um componente possui uma inter-\nface, composta de um ou mais canais de comunica\u00e7\u00e3o, atrav\u00e9s dos quais o componente\nse comunica com o meio externo. A Figura 5 ilustra um artefato de software constitu\u00eddo\npela interliga\u00e7\u00e3o de um conjunto de componentes, atrav\u00e9s dos canais de comunica\u00e7\u00e3o de\nsuas interfaces.\n\nDificilmente componentes s\u00e3o reus\u00e1veis tal qual foram desenvolvidos. Normalmente\nprecisam ser adaptados para se moldarem aos requisitos do sistema a que ser\u00e3o acopla-\ndos. Duas abordagens t\u00eam sido usadas para adaptar um componente: altera\u00e7\u00e3o e em-\npacotamento (wrapping). O empacotamento, ao inv\u00e9s de modificar o componente, cria\numa vis\u00e3o externa diferente para ele. Outra alternativa para interconectar componentes\noriginalmente incompat\u00edveis consiste em criar um componente intermedi\u00e1rio para mediar\na comunica\u00e7\u00e3o. Este componente intermedi\u00e1rio \u00e9 genericamente chamado cola (glue).\n\nO empacotamento consiste em produzir uma vis\u00e3o externa para um componente, isto\n\u00e9, uma interface, diferente de sua interface original com vista a adapt\u00e1-lo a requisitos\nespec\u00edficos. A Figura 6 ilustra esta situa\u00e7\u00e3o. Apresenta dois componentes, Componente1\ne Componente2, com interfaces incompat\u00edveis, isto \u00e9, n\u00e3o podem ser conectados para\nopera\u00e7\u00e3o conjunta. Na parte inferior da figura o bloco que representa o Componente2 \u00e9\ninserido em uma estrutura de empacotamento com uma interface diferente da interface\n\n\n\n35\n\nFigura 5: Interliga\u00e7\u00e3o de componentes atrav\u00e9s de seus canais de comunica\u00e7\u00e3o (SILVA,\n2000)\n\ndefinida neste componente. O resultado \u00e9 que a interface da estrutura de empacotamento\n\u00e9 compat\u00edvel com a interface do componente Componente1, possibilitando a interliga\u00e7\u00e3o\nde suas interfaces. Com isto, obt\u00e9m-se a situa\u00e7\u00e3o inicialmente imposs\u00edvel: a opera\u00e7\u00e3o\nconjunta dos componentes Componente1 e Componente2, com interfaces incompat\u00edveis.\n\nFigura 6: Adapta\u00e7\u00e3o de componente atrav\u00e9s de empacotamento (wrapping) (SILVA,\n2000)\n\nO recurso do empacotamento pode ser usado com diferentes finalidades. Uma pri-\nmeira situa\u00e7\u00e3o \u00e9 que a \u00fanica incompatibilidade seja a estrutura de interface, isto \u00e9, com-\nponentes comportamental e funcionalmente compat\u00edveis com interfaces n\u00e3o conect\u00e1veis.\nIsto pode ser causado por assinaturas de m\u00e9todos diferentes em um ambiente homog\u00eaneo\n(diferen\u00e7as em nome de m\u00e9todo, ordem de par\u00e2metros, previs\u00e3o de retorno), ou por hete-\nrogeneidade dos componentes (que pode incluir diferen\u00e7a de linguagem de programa\u00e7\u00e3o,\nde plataforma de execu\u00e7\u00e3o e de localiza\u00e7\u00e3o f\u00edsica).\n\nA colagem de componentes (glueing) trata o mesmo problema do empacotamento, isto\n\n\n\n36\n\n\u00e9, viabilizar a opera\u00e7\u00e3o conjunta de componentes originalmente incompat\u00edveis. Como\nno caso anterior, esta incompatibilidade pode estar associada a sintaxe das interfaces,\nheterogeneidade ou necessidade de extens\u00f5es ou altera\u00e7\u00f5es funcionais. A diferen\u00e7a neste\ncaso \u00e9 que o tratamento dado ao problema \u00e9 a inclus\u00e3o de um novo elemento, a cola (glue),\nentre os componentes incompat\u00edveis, possibilitando sua opera\u00e7\u00e3o conjunta. A Figura 7\nilustra a compatibiliza\u00e7\u00e3o de componentes atrav\u00e9s de colagem.\n\nFigura 7: Adapta\u00e7\u00e3o de componente atrav\u00e9s de colagem (glueing) (SILVA, 2000)\n\nO elemento cola nada mais \u00e9 sen\u00e3o um terceiro componente, cuja interface possibi-\nlita sua conex\u00e3o aos componentes Componente1 e Componente2 e cuja funcionalidade\nconsiste em compatibilizar a opera\u00e7\u00e3o conjunta destes componentes.\n\nAs interfaces s\u00e3o classificadas em fornecidas (provided interfaces) e requeridas (re-\nquired interfaces). Um componente possui uma interface fornecida ao implementar todas\nas opera\u00e7\u00f5es definidas naquela interface e uma interface requerida ao usar pelo menos\numa opera\u00e7\u00e3o definida na interface. Na UML 2.0, interfaces fornecidas s\u00e3o representadas\npor uma circunfer\u00eancia fechada, enquanto as interfaces requeridas s\u00e3o semicircunfer\u00ean-\ncia. Conforme ilustrado na Figura 8, componentes se conectam por meio da interface\nrequerida de um com a interface fornecida de outro. Para conectar componentes com co-\nnectores incompat\u00edveis, desenvolve-se um c\u00f3digo adicional chamado de adaptador, que\nfaz as convers\u00f5es e opera\u00e7\u00f5es necess\u00e1rias para compatibilizar interfaces.\n\nO modelo de componentes (component model) define v\u00e1rios aspectos da constru\u00e7\u00e3o\ne da intera\u00e7\u00e3o dos componentes, entre eles, a forma de implementar as interfaces e os\nconectores. V\u00e1rios modelos apoiam-se na orienta\u00e7\u00e3o a objetos para a implementa\u00e7\u00e3o\nde interfaces e mensagens, entretanto, esta tecnologia n\u00e3o prov\u00ea suporte \u00e0 representa\u00e7\u00e3o\nde interfaces requeridas e aspectos n\u00e3o-funcionais. O modelo de componentes define\ntamb\u00e9m o padr\u00e3o de nomea\u00e7\u00e3o dos componentes, de composi\u00e7\u00e3o, de versionamento e de\nempacotamento. O empacotamento possibilita que um componente seja instalado como\numa unidade, contendo arquivos, m\u00f3dulos, c\u00f3digo execut\u00e1vel, c\u00f3digo fonte, c\u00f3digo de\nvalida\u00e7\u00e3o, etc.\n\nUm exemplo de arquitetura para projetos que envolvam o reuso de componentes \u00e9\nService Oriented Architecture, SOA , pois nela dividi-se as funcionalidades do sistema\nnos chamados servi\u00e7os. Esses servi\u00e7os representam para os requisitos o mesmo que os\ncomponentes representam para a arquitetura da aplica\u00e7\u00e3o. Sendo assim, pode-se dizer\nque um sistema que ser\u00e1 desenvolvido utilizando uma arquitetura SOA pode ser visto\ncomo uma composi\u00e7\u00e3o de funcionalidades e essas funcionalidades podem ser desenvol-\nvidas baseadas em componentes. O Gartner Group descreve SOA da seguinte maneira:\n\"Mais do que uma tecnologia, SOA tamb\u00e9m influencia regras e processos de neg\u00f3cios,\n\n\n\n37\n\nComponente\n\nComponente\n\nComponente\n\nComponente\n\nComponente\n\n<<componente>>\n\n: Nome\n\n<<componente>>&lt;<componente>>\n\n<<componente>>\n\n: Nome : Nome\n\n: Nome\n\nInterface Requerida 1\n\nInteface Fornecida 1 e 2\n\nInterface\n\nDepend\u00eancia\n\nInteface Fornecida\n\nUML 2.0\n\nUML 1.x\n\n<<interface>>\n\nNome\n\nFigura 8: Padr\u00f5es de diagramas de componentes segundo a UML\n\nal\u00e9m de muitas vezes implicar reengenharia de software simultaneamente\". Apesar das\nfacilidades apresentadas em se trabalhar com SOA e componentes, n\u00e3o se pode restringir\num ao outro. O desenvolvimento de componentes tamb\u00e9m pode ser usado quando s\u00e3o\nempregados outros estilos de arquiteturas.\n\n2.5 Frameworks Caixa-branca, Caixa-preta e Caixa-cinza\n\nRincon (2014) descreve frameworks OO e componentes como podendo ser caixa-\npreta, caixa-branca ou caixa-cinza. Um framework caixa-preta s\u00f3 revela suas interfaces\ne como us\u00e1-la. Neste tipo de abordagem n\u00e3o h\u00e1 nenhum tipo de informa\u00e7\u00e3o sobre seu\ncomportamento ou subclasses. Essa abordagem \u00e9 raramente usada para frameworks e mal\naconselhada pelo autor, se encaixando melhor para projeto de componentes. Ainda assim,\no sistema caixa-preta n\u00e3o \u00e9 todo fechado a extens\u00e3o. Novos comportamentos podem ser\nadicionados atrav\u00e9s de plugins que estendem das interfaces e unidos via composi\u00e7\u00e3o.\nPor\u00e9m, este tipo de abordagem \u00e9 mais dif\u00edcil de desenvolver (MAXWELL, 2014, 2013).\n\nJ\u00e1 a abordagem caixa-branca revela sua estrutura, permite extens\u00e3o de suas classes e\npersonaliza\u00e7\u00e3o de seu comportamento. Ela \u00e9 muito mais usada para frameworks e acon-\nselhada por Rincon (2014). J\u00e1 Fugita (1993) diz que, apesar de ser largamente utilizada,\na estrutura caixa-branca exige que o programador conhe\u00e7a profundamente a estrutura\ninterna do framework e que o uso de heran\u00e7a \u00e9 muito mais comum em caixa-branca,\nenquanto no caixa-preta usa-se mais composi\u00e7\u00e3o e delega\u00e7\u00e3o. Em compara\u00e7\u00e3o com o\nmodelo caixa-preta, este \u00e9 mais f\u00e1cil de se desenvolver, por\u00e9m mais dif\u00edcil de estender.\n\nO padr\u00e3o caixa-cinza revela alguns detalhes de seu funcionamento e permite exten-\n\n\n\n38\n\ns\u00e3o e colabora\u00e7\u00e3o com alguns de seus pacotes, por\u00e9m mant\u00e9m algumas partes totalmente\nfechadas em seus componentes. Frameworks caixa-cinza tem flexibilidade suficiente e\nextensibilidade, e ainda tem a habilidade de esconder informa\u00e7\u00f5es desnecess\u00e1rias do de-\nsenvolvedor da aplica\u00e7\u00e3o (RINCON, 2014).\n\n2.6 Engenharia de Software de Servi\u00e7o\n\nA discuss\u00e3o sobre o tema Engenharia de Software de Servi\u00e7o foi incentivada pela\nrepercuss\u00e3o a respeito da utiliza\u00e7\u00e3o da Arquitetura Orientada \u00e0 Servi\u00e7o, que apresenta\nmuitas vantagens (e desafios) em sua aplica\u00e7\u00e3o, por\u00e9m, ainda necessita de metodologia\nque norteie o desenvolvimento de sistemas baseados neste paradigma de arquitetura, uma\nvez que a Engenharia de Software Tradicional apresenta-se muito limitada para esse tipo\nde arquitetura.\n\nCom sistemas de Arquitetura Orientada a Servi\u00e7os (SOA) operando em ambiente de\nexecu\u00e7\u00e3o distribu\u00eddo e heterog\u00eaneo, os engenheiros de tais sistemas s\u00e3o confinados pelos\nlimites da engenharia de software tradicional. SOA est\u00e1 rapidamente emergindo como\nprincipal paradigma de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento, integra\u00e7\u00e3o e ma-\nnuten\u00e7\u00e3o de aplica\u00e7\u00f5es corporativas. Muitas organiza\u00e7\u00f5es est\u00e3o agora em seu uso precoce\nde SOA, e assumem que eles podem simplesmente aplicar princ\u00edpios e t\u00e9cnicas dos para-\ndigmas pr\u00e9-existentes da engenharia de software. Aplica\u00e7\u00f5es habilitadas SOA operam em\nambientes de execu\u00e7\u00e3o heterog\u00eaneos, distribu\u00eddos, n\u00e3o-deterministas, imprevis\u00edveis e al-\ntamente din\u00e2micos, portanto, engenheiros SOA rapidamente encontram os limites de tais\nparadigmas da engenharia de software tradicional, que n\u00e3o fornecem qualquer conselho\nde estilo espec\u00edfico.\n\nDiante desse contexto, tornou-se cada vez mais evidente a necessidade de sistemas\nmais flex\u00edveis, aderentes e de f\u00e1cil e r\u00e1pida adapta\u00e7\u00e3o aos processos de neg\u00f3cio. Surge\nent\u00e3o um novo paradigma de arquitetura de software, baseado no conceito de Servi\u00e7o,\ne que tem como principais caracter\u00edsticas o baixo acoplamento, dinamismo e adaptabi-\nlidade, a reutiliza\u00e7\u00e3o de servi\u00e7os, interoperabilidade e a independ\u00eancia de tecnologia:\nArquitetura Orientada a Servi\u00e7o.\n\nCome\u00e7a-se ent\u00e3o a discutir a Engenharia de Software de Servi\u00e7o como uma disciplina\nemergente que envolve parte da Engenharia de Software Tradicional e introduz outros\nnovos conceitos para o desenvolvimento de sistemas baseados em SOA.\n\nEngenharia de Software de Servi\u00e7o \u00e9 a ci\u00eancia e aplica\u00e7\u00e3o de conceitos, modelos, m\u00e9-\ntodos e ferramentas para projetar, desenvolver (fonte), implantar, testar, fornecer e manter\nsistemas de software alinhados ao neg\u00f3cio e baseados em SOA de forma disciplinada,\nreprodut\u00edvel e repet\u00edveis.\n\nDiante de tantas vantagens proporcionadas pela Arquitetura Orientada a Servi\u00e7o, surge\na necessidade de revisitar os m\u00e9todos e ferramentas utilizadas para o desenvolvimento de\nsistemas baseados em servi\u00e7os, uma vez que a Engenharia de Software Tradicional n\u00e3o\nconsegue atender \u00e0s peculiaridades de tais sistemas: passa-se ent\u00e3o a discutir \u00e0 respeito\nda Engenharia de Software de Servi\u00e7os. A Engenharia de Software de Servi\u00e7o tem seus\nprimeiros relatos em meados de 2009 em um semin\u00e1rio (KUROIWA, 2011), e \u00e9 definida\na seguir:\n\nSoftware service engineering is the science and application of concepts,\n\nmodels, methods, and tools to design, develop (source), deploy, test, pro-\n\nvision, and maintain usiness-aligned and SOA-based software systems\n\nin a disciplined, reproducible, and repeatable manner.\n\n\n\n39\n\nOs principais desafios listados para a evolu\u00e7\u00e3o da Engenharia de Software de Servi\u00e7o\ns\u00e3o: Alinhamento Neg\u00f3cio-TI, adaptabilidade; Novos modelos e abstra\u00e7\u00f5es para repre-\nsentar e lidar com a din\u00e2mica SOA; Como lidar com a heterogeneidade; O mapeamento\nde requisitos; Componibilidade e Testes (MAXWELL, 2014, 2013).\n\n2.6.1 Arquitetura Orientada a Servi\u00e7os\n\nUma arquitetura de software \u00e9 um conceito abstrato que d\u00e1 margem a uma s\u00e9rie de\ndefini\u00e7\u00f5es. A defini\u00e7\u00e3o usada pelo ANSI/IEEE afirma que uma arquitetura de software\ntrata basicamente de como os componentes fundamentais de um sistema se relacionam\nintrinsecamente e extrinsecamente (MAXWELL, 2014, 2013).\n\nBasicamente, Arquitetura Orientada a Servi\u00e7os (SOA) \u00e9 um paradigma de constru-\n\u00e7\u00e3o e integra\u00e7\u00e3o de software que estrutura aplica\u00e7\u00f5es em elementos modulares chamados\nservi\u00e7os. O servi\u00e7o, a unidade fundamental de uma arquitetura SOA, \u00e9 um elemento com-\nputacional que tem como prop\u00f3sito desempenhar uma fun\u00e7\u00e3o espec\u00edfica e que pode ser\nutilizado por um cliente. Segundo os conceitos b\u00e1sicos de SOA, um servi\u00e7o \u00e9 composto\npor uma interface e uma implementa\u00e7\u00e3o. Geralmente, um servi\u00e7o consiste em uma fun\u00e7\u00e3o\nde neg\u00f3cio desempenhada por um m\u00f3dulo de software (a implementa\u00e7\u00e3o) e encapsulada\npor uma interface bem definida e acess\u00edvel \u00e0queles que desejam utilizar o servi\u00e7o, ou\nseja, os potenciais clientes. Os clientes do servi\u00e7o n\u00e3o t\u00eam acesso aos detalhes de como\nele foi constru\u00eddo, mas apenas aos detalhes expostos em sua interface. A interface de-\nfine as fun\u00e7\u00f5es desempenhadas pelo servi\u00e7o e eventuais precondi\u00e7\u00f5es para utiliz\u00e1-lo, mas\nn\u00e3o revela como estas fun\u00e7\u00f5es s\u00e3o realizadas. Esta forma de encapsulamento \u00e9 conhecida\ncomo caixa-preta e \u00e9 um princ\u00edpio caracter\u00edstico de paradigmas como orienta\u00e7\u00e3o a objetos\ne componentes de software. Por\u00e9m, diferentemente destes, servi\u00e7os representam fun\u00e7\u00f5es\ncompletas de neg\u00f3cio e s\u00e3o projetados de modo a serem usados n\u00e3o somente no \u00e2mbito\nde um programa ou sistema, mas no \u00e2mbito da organiza\u00e7\u00e3o ou at\u00e9 entre organiza\u00e7\u00f5es\n(PAPAZOGLOU, 2003).\n\nDesta maneira, uma arquitetura SOA possibilita uma infra-estrutura para computa\u00e7\u00e3o\ndistribu\u00edda, por meio de servi\u00e7os que podem ser fornecidos e consumidos dentro de uma\norganiza\u00e7\u00e3o e entre organiza\u00e7\u00f5es, por meio de redes de comunica\u00e7\u00e3o como a Internet.\nUma arquitetura SOA b\u00e1sica \u00e9 caracterizada pelas intera\u00e7\u00f5es entre tr\u00eas tipos de agentes\nde software: os Provedores de Servi\u00e7o, os Consumidores (ou Clientes) de Servi\u00e7o e o\nRegistro de Servi\u00e7o (FUGITA, 2009). As intera\u00e7\u00f5es entre estes agentes podem ser visua-\nlizadas na Figura 9.\n\nOs servi\u00e7os s\u00e3o oferecidos pelos Provedores de Servi\u00e7o, organiza\u00e7\u00f5es respons\u00e1veis\npor desenvolver suas implementa\u00e7\u00f5es, fornecer suas descri\u00e7\u00f5es e prestar suporte t\u00e9cnico\ne de neg\u00f3cio. De modo geral, os Provedores disponibilizam m\u00f3dulos de software (as\nimplementa\u00e7\u00f5es dos servi\u00e7os) que podem ser acessados atrav\u00e9s de uma rede e publicam\nsuas descri\u00e7\u00f5es em um Registro de Servi\u00e7os, agente que abriga informa\u00e7\u00f5es sobre as fun-\n\u00e7\u00f5es oferecidas, os requisitos para se utilizar o servi\u00e7o e orienta\u00e7\u00f5es sobre como realizar\na intera\u00e7\u00e3o. \u00c9 o Registro de Servi\u00e7os que torna essas informa\u00e7\u00f5es dispon\u00edveis para serem\nconsultadas por clientes em potencial. Por sua vez, os Consumidores de Servi\u00e7o s\u00e3o os\nagentes que necessitam solicitar a execu\u00e7\u00e3o de um Servi\u00e7o. Os Consumidores buscam nos\nRegistros a descri\u00e7\u00e3o de um servi\u00e7o que satisfa\u00e7a \u00e0s suas necessidades e, ao encontr\u00e1-la,\nutilizam esta descri\u00e7\u00e3o para ligar-se ao Provedor e realizar a invoca\u00e7\u00e3o do servi\u00e7o. Note\nque os pap\u00e9is de Provedor e Consumidor s\u00e3o l\u00f3gicos, de modo que um mesmo agente\npode exibir caracter\u00edsticas de ambos dependendo do contexto (PAPAZOGLOU, 2003).\n\nA palavra servi\u00e7o pode ser definida como a execu\u00e7\u00e3o de trabalho ou desempenho de\n\n\n\n40\n\nRegistro de \n\nServi\u00e7os\n\nProvedor de \n\nServi\u00e7os\n\nConsumidor \n\nde Servi\u00e7o\nBUSCA\n\nLIGA\u00c7\u00c3OPUBLICA\u00c7\u00c3O\n\nFigura 9: Agentes de uma arquitetura SOA (FUGITA, 2009)\n\nfun\u00e7\u00f5es, ordenados por um requisitante. No contexto espec\u00edfico de sistemas de software,\nservi\u00e7o ainda est\u00e1 ligado a conceitos como a capacidade de realizar trabalho para outro, a\nespecifica\u00e7\u00e3o do trabalho oferecido e a oferta de realizar trabalho para outro. No contexto\nde SOA, um servi\u00e7o tem significado semelhante, j\u00e1 que consiste em um software capaz\nde realizar uma fun\u00e7\u00e3o espec\u00edfica quando solicitado por seus consumidores.\n\nOs diversos autores da literatura sobre o assunto citam e descrevem seus pr\u00f3prios\nconjuntos de caracter\u00edsticas de um servi\u00e7o, mas n\u00e3o h\u00e1 um consenso sobre o que define\nexatamente um servi\u00e7o, pois cada um foca em aspectos diferentes do paradigma. Por isso,\ncada uma destas caracter\u00edsticas deve ser analisada para chegar-se a um entendimento do\nque vem a ser orienta\u00e7\u00e3o a servi\u00e7os (MAXWELL, 2014, 2013).\n\nA orienta\u00e7\u00e3o a servi\u00e7os pode trazer uma abstra\u00e7\u00e3o entre a l\u00f3gica de neg\u00f3cio e a infra-\nestrutura de TI, gerando um desacoplamento entre os modelos de processos de neg\u00f3cios e\na arquitetura de sistemas de informa\u00e7\u00e3o. Em uma arquitetura orientada a servi\u00e7os dando\nsuporte tecnol\u00f3gico aos processos de neg\u00f3cio de uma empresa, a camada de servi\u00e7os\nlocaliza-se exatamente entre a camada de processos e a infra-estrutura de aplica\u00e7\u00f5es de\nTecnologia da Informa\u00e7\u00e3o (TI) (ERL, 2007). A camada de servi\u00e7os cria uma abstra\u00e7\u00e3o\nentre os processos de neg\u00f3cio e as aplica\u00e7\u00f5es, conforme mostra a Figura 10\n\nBaseado no princ\u00edpio de composi\u00e7\u00e3o, \u00e9 poss\u00edvel dividir a camada de servi\u00e7os em mais\ntr\u00eas camadas de abstra\u00e7\u00e3o que determinam o tipo e a granularidade dos servi\u00e7os. Assim,\ntemos: a camada de servi\u00e7os de aplica\u00e7\u00e3o, a camada de servi\u00e7os de neg\u00f3cio e a camada\nde orquestra\u00e7\u00e3o de servi\u00e7os. Na Figura 10, pode ser visualizada a hierarquia das camadas\nde servi\u00e7os.\n\nFrequentemente, relaciona-se SOA \u00e0 integra\u00e7\u00e3o de sistemas, o que n\u00e3o condiz com a\nrealidade. Basta observar que EAI (Enterprise Application Integration) surgiu com o ob-\njetivo principal de resolver os problemas da integra\u00e7\u00e3o ponto a ponto, tamb\u00e9m conhecido\ncomo \"spaghetti integration\", fornecendo um meio uniforme de integra\u00e7\u00e3o, SOA tem am-\nbi\u00e7\u00f5es muito maiores. Al\u00e9m disso, EAI possui caracter\u00edsticas algumas vezes conflitantes\ncom SOA, como o fato de ser centrado em dados e n\u00e3o em processos e de n\u00e3o se direcio-\nnar pelo neg\u00f3cio. O que motiva a cria\u00e7\u00e3o de um servi\u00e7o n\u00e3o \u00e9 a integra\u00e7\u00e3o ponto a ponto.\nEntretanto, SOA d\u00e1 grande \u00eanfase \u00e0s interfaces que, quando bem definidas, facilitam a\n\n\n\n41\n\nESB\n  Enterprise\n\n Service Bus\n\nFigura 10: Camadas de uma arquitetura SOA (FUGITA, 2009)\n\nintegra\u00e7\u00e3o e, at\u00e9 mesmo, o reuso de c\u00f3digo. Para atender as necessidades de integra-\n\u00e7\u00e3o no contexto de SOA, evitando integra\u00e7\u00e3o ponto a ponto, temos o Enterprise Service\nBus (ESB). O ESB \u00e9 um conceito, com algumas caracter\u00edsticas de EAI, que fornece uma\ncamada para a l\u00f3gica de integra\u00e7\u00e3o de servi\u00e7os. Existem ferramentas para ESB que dis-\nponibilizam uma infra-estrutura flex\u00edvel de conectividade para integra\u00e7\u00e3o de aplica\u00e7\u00f5es e\nservi\u00e7os, suportando. Enterprise Service Bus (ESB) SOA. O ESB tem como caracter\u00edsti-\ncas: roteamento de mensagens entre servi\u00e7os; convers\u00e3o de protocolos de transporte entre\nrequisitante e servi\u00e7os; transforma\u00e7\u00e3o do conte\u00fado de mensagens entre o requisitante e o\nservi\u00e7o; Mensagens S\u00edncronas e Ass\u00edncronas.\n\nO foco nas interfaces \u00e9 o que d\u00e1 ao SOA a habilidade de obter acoplamento fraco,\ncomposi\u00e7\u00e3o, reuso e v\u00e1rios outros objetivos do projeto (design goals). A ess\u00eancia de SOA\nest\u00e1 mais relacionada \u00e0 habilidade de atender o neg\u00f3cio rapidamente. Para tanto, obter\num n\u00edvel de granularidade para os servi\u00e7os identific\u00e1veis nos processos de neg\u00f3cio \u00e9 uma\nabordagem fundamental. Isto contribui principalmente em quest\u00f5es como a orquestra\u00e7\u00e3o\nno contexto de BPM (Business Process Management) e a justificativa de investimentos em\nTI, uma vez que permite a visibilidade da associa\u00e7\u00e3o do servi\u00e7o com o neg\u00f3cio. Podemos\nresumir BPM como a combina\u00e7\u00e3o de pessoas, tecnologia e processos. BPM \u00e9 uma pr\u00e1tica\npara melhorar a efici\u00eancia das organiza\u00e7\u00f5es, automatizando os processos de neg\u00f3cios.\n\nOs servi\u00e7os de aplica\u00e7\u00e3o possuem menor granularidade e representam os servi\u00e7os de\ninfra-estrutura de uma arquitetura SOA, oferecendo fun\u00e7\u00f5es espec\u00edficas de tecnologia. O\nprop\u00f3sito dos servi\u00e7os de aplica\u00e7\u00e3o \u00e9 prover fun\u00e7\u00f5es reus\u00e1veis e processar dados conti-\ndos em sistemas legados e novas aplica\u00e7\u00f5es desenvolvidas. Os servi\u00e7os de neg\u00f3cio s\u00e3o\nos elementos fundamentais da arquitetura SOA, pois s\u00e3o aqueles que representam a l\u00f3-\ngica de neg\u00f3cio da organiza\u00e7\u00e3o. S\u00e3o formados pela composi\u00e7\u00e3o de diversos servi\u00e7os de\naplica\u00e7\u00e3o para implementar a l\u00f3gica de neg\u00f3cio. Podem representar tarefas de processo\nou entidades de neg\u00f3cio. Por fim, a camada de orquestra\u00e7\u00e3o de servi\u00e7os realiza a liga\u00e7\u00e3o\n\n\n\n42\n\nFigura 11: Camadas de servi\u00e7os (ERL, 2007) (FUGITA, 2009)\n\nentre os modelos de processos de neg\u00f3cio e os servi\u00e7os da arquitetura SOA. O conceito de\norquestra\u00e7\u00e3o baseia-se na constru\u00e7\u00e3o de processos de neg\u00f3cio a partir da composi\u00e7\u00e3o de\ndiversos servi\u00e7os, por exemplo, utilizando uma linguagem de orquestra\u00e7\u00e3o como o Web\nServices Business Process Execution Language (OASIS, 2013). Trata-se de uma lingua-\ngem para se especificar o fluxo de trabalho e l\u00f3gica de neg\u00f3cio envolvidos nas chamadas\nde Web Services. Nesta camada est\u00e3o os servi\u00e7os de processo, que possuem alta granula-\nridade e representam processos de neg\u00f3cio completos, encapsulando a l\u00f3gica e regras de\nneg\u00f3cio envolvidas (FUGITA, 2009; MAXWELL, 2014, 2013).\n\nDepois de encontrados os componentes e servi\u00e7os, a fim de se atender a uma apli-\nca\u00e7\u00e3o espec\u00edfica, s\u00e3o necess\u00e1rios que se efetue a orquestra\u00e7\u00e3o, ou seja, que tais servi\u00e7os\nsejam chamados em uma ordem l\u00f3gica, e que sejam cumpridas todas as pr\u00e9-condi\u00e7\u00f5es\ndas interfaces envolvidas (L\u00f3gica de Processo).\n\n2.7 Rela\u00e7\u00e3o entre os paradigmas OO, CBD e SOA\n\nMuitas compara\u00e7\u00f5es j\u00e1 foram feitas entre desenvolvimento orientado a objetos (OO)\ne o desenvolvimento baseado em componentes (CBD). Componentes e objetos, possuem\ncaracter\u00edsticas similares, como a necessidade de interfaces bem definidas e a disponibili-\nza\u00e7\u00e3o de opera\u00e7\u00f5es aos seus clientes. Essas semelhan\u00e7as dificultam ainda mais o enten-\ndimento de OO e CBD. Algo muito parecido vem acontecendo no caso de CBD e SOA.\nExistem conceitos de CBD e SOA similares, por exemplo, encapsulamento, contratos e\nreuso, que podem dificultar a compara\u00e7\u00e3o dessas abordagens. Para uma melhor compara-\n\u00e7\u00e3o \u00e9 necess\u00e1rio compreender os conceitos essenciais envolvidos, quais sejam, processos\nde neg\u00f3cio, componentes realizadores dos servi\u00e7os, entre outros.\n\nAtualmente, existe uma infra-estrutura tecnol\u00f3gica pronta, que suporta o desenvolvi-\nmento OO, CBD e SOA sem muito esfor\u00e7o, mas n\u00e3o garante, apenas permite a aplica\u00e7\u00e3o\ndas abordagens citadas. Uma compara\u00e7\u00e3o de CBD e SOA \u00e9 muito abrangente e, portanto,\nenvolve quest\u00f5es de v\u00e1rias dimens\u00f5es.\n\nSolu\u00e7\u00f5es como CBD e SOA se destinam, na maioria das vezes, a superar limita\u00e7\u00f5es\n\n\n\n43\n\nhumanas, como lidar com grande quantidade de informa\u00e7\u00f5es complexas. Para lidar com\ntal complexidade, a abstra\u00e7\u00e3o \u00e9 uma ferramenta chave, e est\u00e1 intimamente relacionada\ncom o conceito de encapsulamento. Focando nesse aspecto essencial, Serafim (2009)\ndescreve em seu artigo os n\u00edveis de encapsulamento. Baseando-se nesses n\u00edveis, \u00e9 pos-\ns\u00edvel partir de simples linhas de c\u00f3digo e chegar ao SOA, passando por CBD, mesmo\nconsiderando que essas abordagens foram concebidas em contextos diferentes. Para uma\nvis\u00e3o geral desses dois conceitos, observe o esquema da Figura 12.\n\n.....\n\n.....\n\n.....\n\n.....\n\n.....\n\n.....\n\n.....\n\n.....\n\n.....\n\n.....\n1 2 3\n\n4\n\n5\n1- Linhas prim\u00e1rias de c\u00f3digo\n2 - M\u00f3dulo procedural\n3 - Estrutura classe/objeto \n\n4 - Componentes (Subsitemas)\n\n5 - Servi\u00e7os\n\nFigura 12: Esquema dos n\u00edveis de encapsulamento com servi\u00e7os (SERAFIM, 2009)\n\nNo in\u00edcio, eram apenas linhas de c\u00f3digo e v\u00e1rios comandos de salto de instru\u00e7\u00f5es\n(GOTO). Sua sintaxe \u00e9, em geral: goto destino, onde destino pode ser um label (r\u00f3tulo\nou nome de um endere\u00e7o) ou um n\u00famero, que representa um determinado endere\u00e7o. As\ninstru\u00e7\u00f5es passam a ser executadas no endere\u00e7o apontado por destino. Muitas vezes, face\n\u00e0 necessidade de se fazer uma altera\u00e7\u00e3o, era mais f\u00e1cil reedificar o programa inteiro em\nfun\u00e7\u00e3o da desorganiza\u00e7\u00e3o que existia. Al\u00e9m disso, para realizar qualquer manuten\u00e7\u00e3o, era\npreciso memorizar todo o c\u00f3digo envolvido. Com a ado\u00e7\u00e3o de sub-rotinas (primeiro n\u00edvel\nde encapsulamento), foi poss\u00edvel reaproveitar as linhas de c\u00f3digo. Estas linhas, encapsu-\nladas atrav\u00e9s de uma sub-rotina, podiam ser chamadas quantas vezes fossem necess\u00e1rias.\nAl\u00e9m disso, usava-se a decomposi\u00e7\u00e3o funcional, ou seja, um problema era dividido em\nproblemas menores (sub-rotinas) sucessivamente, e depois, as opera\u00e7\u00f5es eram agrupadas\nem m\u00f3dulos l\u00f3gicos. Infelizmente, a maioria das hierarquias de sub-rotinas geradas com\nessa abordagem n\u00e3o s\u00e3o suficientemente independentes para garantir reuso ou altera\u00e7\u00f5es\ncontroladas, pois, existe um acoplamento forte e sem controle. Assim, apenas esse n\u00edvel\nde encapsulamento deixava a manuten\u00e7\u00e3o cara em ambientes com aplica\u00e7\u00f5es numerosas\nou complexas. Neste caso, uma altera\u00e7\u00e3o no c\u00f3digo poderia afetar de forma imprevis\u00edvel\ntodo o sistema, sendo necess\u00e1rio test\u00e1-lo novamente por completo (SERAFIM, 2009).\n\nOs componentes s\u00e3o a melhor abordagem para implementar servi\u00e7os, embora se deva\nentender que um aplicativo baseado em componente bem projetado n\u00e3o \u00e9 necessariamente\numa abordagem SOA. Conforme mostrado, temos que considerar muitas quest\u00f5es para\nmelhor atender as mudan\u00e7as no neg\u00f3cio, que \u00e9 o objetivo. Uma abordagem orientada\na servi\u00e7os implica em uma camada de arquitetura de aplicativo adicional. A Figura 13\ndemonstra como as camadas podem ser aplicadas \u00e0 arquitetura.\n\n\u2022 Camada de Servi\u00e7os: A camada de servi\u00e7os \u00e9 caracterizada por processos que re-\nalizam fun\u00e7\u00f5es individuais de um neg\u00f3cio ou aplica\u00e7\u00e3o. Servi\u00e7os s\u00e3o compostos de\ncontrato, interface, l\u00f3gica de neg\u00f3cios e s\u00e3o identificados no processo de neg\u00f3cio.\n\n\n\n44\n\nCamada de Servi\u00e7os\n\n  Camada de \n\nComponentes\n\n  Camada de \n\nClasses/objetos\n\nFigura 13: Camadas de uma implementa\u00e7\u00e3o SOA (SERAFIM, 2009)\n\n\u2022 Camada de Componentes de neg\u00f3cio (Subsistemas): Um componente de neg\u00f3-\ncio \u00e9 uma parte de um sistema que encapsula as regras de neg\u00f3cio e as exp\u00f5e atrav\u00e9s\nde interfaces bem definidas. Componentes s\u00e3o independentes, substitu\u00edveis e mo-\ndulares, eles ajudam a gerenciar a complexidade e encorajam a reutiliza\u00e7\u00e3o. Estes\ns\u00e3o identificados decompondo-se o modelo de classe conceitual (de an\u00e1lise).\n\n\u2022 Camada de Classes e Objetos: Na camada de Classes e objetos \u00e9 onde est\u00e3o as\nclasses, atributos e relacionamentos de um objeto. Os objetos colaboram entre si\npara realizar as regras de neg\u00f3cio de um componente espec\u00edfico. Por fim, o exemplo\nda Figura 6 mostra que SOA absorve o projeto baseado em componentes, ou seja,\no servi\u00e7o vai ser implementado por um ou mais componentes.\n\nA partir disso, podemos analisar que o paradigma de orienta\u00e7\u00e3o a servi\u00e7os n\u00e3o signi-\nfica uma ruptura com rela\u00e7\u00e3o a outros paradigmas de desenvolvimento de software, pois\nrepresenta uma evolu\u00e7\u00e3o derivada da orienta\u00e7\u00e3o a objetos e do desenvolvimento baseado\nem componentes e pode inclusive ser aplicado juntamente com eles. A seguir, \u00e9 descrita\na rela\u00e7\u00e3o da orienta\u00e7\u00e3o a servi\u00e7os com os outros paradigmas e suas diferen\u00e7as.\n\n\u2022 Orienta\u00e7\u00e3o a objetos: Conforme citado anteriormente, o paradigma de orienta\u00e7\u00e3o\na servi\u00e7os tem como ponto em comum com o paradigma de orienta\u00e7\u00e3o a objetos o\nfato de ambas serem maneiras de se construir software com base na separa\u00e7\u00e3o de\nassuntos (ERL, 2007). Princ\u00edpios como abstra\u00e7\u00e3o, encapsulamento e composi\u00e7\u00e3o\nde servi\u00e7os foram formulados a partir de conceitos de orienta\u00e7\u00e3o a objetos. Al\u00e9m\ndisso, orienta\u00e7\u00e3o a objetos \u00e9 comumente utilizada para implementar a l\u00f3gica de\naplica\u00e7\u00e3o encapsulada em um servi\u00e7o. Entretanto, os dois paradigmas possuem\nalgumas diferen\u00e7as que ser\u00e3o discutidas a seguir.\n\nA orienta\u00e7\u00e3o a servi\u00e7os prega o baixo acoplamento entre suas unidades (os servi-\n\u00e7os). Apesar de objetos possu\u00edrem rotinas desacopladas e at\u00e9 reus\u00e1veis, as classes\npor defini\u00e7\u00e3o possuem relacionamentos entre si (agrega\u00e7\u00e3o, heran\u00e7a), o que gera\ncerto grau de depend\u00eancia entre os objetos. Na orienta\u00e7\u00e3o a servi\u00e7os, muito das in-\nforma\u00e7\u00f5es necess\u00e1rias para o processamento est\u00e1 contido nas mensagens, de forma\n\n\n\n45\n\nque os servi\u00e7os guardem o m\u00ednimo poss\u00edvel de informa\u00e7\u00e3o de estado. A orienta\u00e7\u00e3o\na servi\u00e7os encoraja a amarra\u00e7\u00e3o da l\u00f3gica de processamento com dados, mantendo\nmais informa\u00e7\u00e3o contida nos objetos e criando uma depend\u00eancia de estado.\n\n\u2022 Orienta\u00e7\u00e3o a componentes: Apesar de serem relacionados, os conceitos de com-\nponente e de servi\u00e7o guardam diferen\u00e7as entre si e n\u00e3o devem ser confundidos.\nAlguns princ\u00edpios da orienta\u00e7\u00e3o a servi\u00e7o, como a abstra\u00e7\u00e3o de interface e imple-\nmenta\u00e7\u00e3o e a transpar\u00eancia de localiza\u00e7\u00e3o, s\u00e3o oriundos de boas pr\u00e1ticas da orien-\nta\u00e7\u00e3o a componentes. Por\u00e9m, o servi\u00e7o difere dos componentes ao n\u00e3o se limitar a\numa determinada plataforma, linguagem ou tecnologia de implementa\u00e7\u00e3o.\n\nAlgumas fontes afirmam que servi\u00e7os podem ser implementados utilizando-se com-\nponentes, o que pode levar \u00e0 falsa ideia de que componentes e servi\u00e7os podem ser\nmapeados de um para um. Existem dois pontos a serem considerados que desfazem\nesse tipo de conclus\u00e3o. O primeiro \u00e9 a granularidade de componentes e servi\u00e7os.\nAs fun\u00e7\u00f5es oferecidas por componentes em geral possuem granularidade baixa, n\u00e3o\npossuindo valor direto para os processos de neg\u00f3cio. Servi\u00e7os devem possuir gra-\nnularidade um pouco mais alta, pois representam atividades de neg\u00f3cio e prov\u00eam\nfun\u00e7\u00f5es de utilidade direta para o neg\u00f3cio. Portanto, a implementa\u00e7\u00e3o de um ser-\nvi\u00e7o geralmente \u00e9 constru\u00edda pela composi\u00e7\u00e3o de mais de um componente de baixa\ngranularidade, resultando em algo de granularidade um pouco mais alta.\n\nO segundo \u00e9 o fato de, apesar de possu\u00edrem interface e implementa\u00e7\u00e3o separados\nassim como os componentes, os servi\u00e7os operam sob um tipo de contrato que esta-\nbelece um acordo e cria expectativas com base em suas caracter\u00edsticas sem\u00e2nticas.\nTais caracter\u00edsticas, pelo fato de serem complexas e de natureza humana, n\u00e3o po-\ndem ser representadas por um simples conjunto de assinaturas de fun\u00e7\u00f5es, como as\ndescri\u00e7\u00f5es de interface de arcabou\u00e7os de componentes atuais. Mesmo a tecnolo-\ngia de Web Services, que \u00e9 frequentemente empregada na implementa\u00e7\u00e3o de SOA,\nainda n\u00e3o oferece uma maneira consolidada de representar estas caracter\u00edsticas se-\nm\u00e2nticas.\n\nO paradigma de orienta\u00e7\u00e3o a servi\u00e7os tende a ser cada vez mais adotado pelas orga-\nniza\u00e7\u00f5es industriais, tendo em vista benef\u00edcios que se espera que ele traga. Por\u00e9m, esta\ntransi\u00e7\u00e3o imp\u00f5e alguns desafios a serem considerados. Um novo m\u00e9todo de an\u00e1lise e pro-\njeto orientado a servi\u00e7os deve buscar resolver de modo direto a complexidade de an\u00e1lise\ne projeto, e indiretamente tratar requisitos de desempenho, seguran\u00e7a e governan\u00e7a. Na\nelabora\u00e7\u00e3o deste m\u00e9todo, \u00e9 especialmente importante focar nos princ\u00edpios de orienta\u00e7\u00e3o a\nservi\u00e7os e em conceitos como granularidade e camadas de servi\u00e7os (MAXWELL, 2014,\n2013; FUGITA, 2009).\n\n\n\n\n\n47\n\n3 METODOLOGIA\n\nComo se pode inferir a partir da an\u00e1lise das propostas existentes em rela\u00e7\u00e3o aos re-\nquisitos do projeto para o desenvolvimento do framework, torna-se necess\u00e1rio consolidar\nos m\u00e9todos analisados em um m\u00e9todo que unifique as boas pr\u00e1ticas de cada um e que\natenda aos requisitos de an\u00e1lise e projeto orientados a servi\u00e7os. Este cap\u00edtulo descreve o\nM\u00e9todo escolhido de An\u00e1lise e Projeto Orientado a Servi\u00e7os ERL (20015), uma proposta\nde m\u00e9todo elaborada a partir do estudo e an\u00e1lise dos m\u00e9todos existentes e dos princ\u00edpios\nde orienta\u00e7\u00e3o a servi\u00e7o.\n\nThomas Erl \u00e9 um autor de publica\u00e7\u00f5es sobre SOA e membro de organiza\u00e7\u00f5es de pa-\ndroniza\u00e7\u00e3o nas \u00e1reas de SOA. Em suas publica\u00e7\u00f5es (ERL, 2007), o autor descreve um\nm\u00e9todo para o desenvolvimento de uma arquitetura SOA e seus servi\u00e7os.\n\nErl descreve o desenvolvimento de uma arquitetura SOA por meio de um ciclo de\nvida de desenvolvimento de servi\u00e7os, focando principalmente nas atividades de an\u00e1lise\ne projeto, que s\u00e3o as etapas em que os servi\u00e7os s\u00e3o identificados e especificados. O\nautor destaca o uso dos princ\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os durante estas atividades, para\ngarantir que os servi\u00e7os desenvolvidos sejam efetivos dentro da arquitetura SOA. Em\ndeterminados pontos, tanto da an\u00e1lise quanto do projeto, a ader\u00eancia aos princ\u00edpios de\norienta\u00e7\u00e3o a servi\u00e7os \u00e9 verificada.\n\n3.1 Ciclo de Vida\n\nO m\u00e9todo procura oferecer flexibilidade em sua aplica\u00e7\u00e3o por meio de itera\u00e7\u00f5es du-\nrante a fase de An\u00e1lise e de Projeto. O ciclo de vida descrito inicia-se com a Modelagem\nde Neg\u00f3cio, passa pelas fases de An\u00e1lise e Projeto (abrangidas pelo m\u00e9todo), seguindo\nadiante com atividades de Constru\u00e7\u00e3o, como Implementa\u00e7\u00e3o e Testes, conforme pode ser\nvisualizado na Figura 14.\n\nA fase de An\u00e1lise Orientada a Servi\u00e7os \u00e9 o est\u00e1gio inicial em que \u00e9 determinado o\nescopo da arquitetura SOA em desenvolvimento. As camadas de servi\u00e7os (orquestra\u00e7\u00e3o,\nneg\u00f3cio e aplica\u00e7\u00e3o) s\u00e3o mapeadas e servi\u00e7os preliminares s\u00e3o modelados na forma de\nservi\u00e7os candidatos.\n\nNa fase seguinte, Projeto Orientado a Servi\u00e7os, os servi\u00e7os que far\u00e3o parte da arqui-\ntetura SOA j\u00e1 est\u00e3o definidos, sendo necess\u00e1rio ent\u00e3o determinar como eles ser\u00e3o cons-\ntru\u00eddos. A atividade de projeto \u00e9 altamente baseada em padr\u00f5es e influenciada pelos prin-\nc\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os. Quatro diferentes estrat\u00e9gias podem ser utilizadas para\nse projetar um servi\u00e7o: servi\u00e7os baseados em entidades, servi\u00e7os de aplica\u00e7\u00e3o, servi\u00e7os\nbaseados em tarefas e servi\u00e7os de processo.\n\nA fase de Desenvolvimento de Servi\u00e7os \u00e9 o momento em que os servi\u00e7os s\u00e3o efetiva-\nmente constru\u00eddos. Nesta fase s\u00e3o considerados os aspectos t\u00e9cnicos e especificidades da\n\n\n\n48\n\nA????se Orientada\n\na Servi\u00e7os\n\nProjeto Orientado \n\na Servi\u00e7os\n\nD?????????mento \n\nde Servi\u00e7os\n\nI?\t?\n??\n?\n? ??\n\nServi\u00e7os\n\nTestes de \n\nServi\u00e7os\n\nAdministra?\n? ??\n\nServi\u00e7os\n\nFigura 14: Ciclo de vida de desenvolvimento SOA (ERL, 2007)\n\ntecnologia de implementa\u00e7\u00e3o, como linguagens de programa\u00e7\u00e3o, ambiente de desenvol-\nvimento e plataformas.\n\nPelo fato de poderem ser reusados e participar de composi\u00e7\u00f5es de maneira n\u00e3o pre-\nvistas, os servi\u00e7os devem ser rigorosamente testados. Na fase de Teste de Servi\u00e7os, deve\nser verificada uma s\u00e9rie de requisitos dos servi\u00e7os, como ader\u00eancia aos padr\u00f5es, comuni-\nca\u00e7\u00e3o com diversos tipos de consumidores, aspectos de QoS e tratamento de exce\u00e7\u00f5es e\ncompensa\u00e7\u00e3o.\n\nA fase de Implanta\u00e7\u00e3o de Servi\u00e7os trata de instalar e configurar os componentes distri-\nbu\u00eddos que implementam os servi\u00e7os, as interfaces de servi\u00e7os e produtos de middleware\nassociados em ambiente de produ\u00e7\u00e3o. Deve-se definir a aloca\u00e7\u00e3o f\u00edsica de cada com-\nponente, avaliar a capacidade da infra-estrutura satisfazer aos requisitos de desempenho\nesperados, estabelecer as configura\u00e7\u00f5es de seguran\u00e7a e verificar as integra\u00e7\u00f5es com siste-\nmas e aplica\u00e7\u00f5es.\n\nFinalmente, a fase de Administra\u00e7\u00e3o de Servi\u00e7os acompanha a execu\u00e7\u00e3o dos servi\u00e7os,\nmonitorando seu uso e desempenho, realizando o controle de vers\u00e3o dos artefatos relaci-\nonados e dando manuten\u00e7\u00e3o para que os servi\u00e7os operem de modo satisfat\u00f3rio (FUGITA,\n2009).\n\n3.2 Atividades de An\u00e1lise\n\nAs atividades de an\u00e1lise no m\u00e9todo proposto por Erl (ERL, 2007) correspondem \u00e0\nfase de An\u00e1lise Orientada a Servi\u00e7os do ciclo de vida. O objetivo principal desta fase \u00e9\ndeterminar quais os servi\u00e7os que devem ser constru\u00eddos e o escopo de cada um deles, ou\nseja, qual a l\u00f3gica deve ser encapsulada por cada um.\n\nOs passos para a realiza\u00e7\u00e3o da An\u00e1lise Orientada a Servi\u00e7os s\u00e3o exibidos na Figura\n15, e s\u00e3o descritos a seguir.\n\n\n\n49\n\nFigura 15: An\u00e1lise Orientada a Servi\u00e7os (ERL, 2005)\n\n3.2.1 Defini\u00e7\u00e3o dos requisitos de neg\u00f3cio\n\nNesta atividade, os requisitos de neg\u00f3cio relacionados \u00e0 solu\u00e7\u00e3o orientada a servi-\n\u00e7os sendo constru\u00edda s\u00e3o levantados e documentados. Esta documenta\u00e7\u00e3o de requisitos\nservir\u00e1 como ponto de partida para a An\u00e1lise Orientada a Servi\u00e7os. Os requisitos de ne-\ng\u00f3cio devem estar definidos o suficiente para que um processo de automa\u00e7\u00e3o possa ser\nespecificado e utilizado no desenvolvimento da solu\u00e7\u00e3o SOA (FUGITA, 2009).\n\n3.2.2 Identifica\u00e7\u00e3o de sistemas existentes\n\nO objetivo espec\u00edfico desta atividade \u00e9 identificar se existe alguma l\u00f3gica de aplica\u00e7\u00e3o\nj\u00e1 existente que satisfa\u00e7a total ou parcialmente a algum dos requisitos levantados na ativi-\ndade anterior. Neste momento ainda n\u00e3o \u00e9 necess\u00e1rio concentrar-se em como os servi\u00e7os\ninteragir\u00e3o com as aplica\u00e7\u00f5es legadas, mas apenas realizar um levantamento de alto n\u00edvel\npara prever quais sistemas podem ser afetados. Este tipo de informa\u00e7\u00e3o ser\u00e1 \u00fatil para a\nidentifica\u00e7\u00e3o dos servi\u00e7os candidatos na etapa de modelagem (FUGITA, 2009).\n\n3.2.3 Modelagem de servi\u00e7os candidatos\n\nA atividade de Modelagem de Servi\u00e7os \u00e9 o principal passo da fase de An\u00e1lise Orien-\ntada a Servi\u00e7os proposta por Erl. Nesta fase, s\u00e3o identificadas opera\u00e7\u00f5es candidatas que\ndevem ser agrupadas segundo seu contexto l\u00f3gico, dando origem a servi\u00e7os candidatos.\nEventualmente, os servi\u00e7os candidatos podem ser combinados em modelos de composi-\n\u00e7\u00e3o para formar a solu\u00e7\u00e3o orientada a servi\u00e7os. A Modelagem de Servi\u00e7os compreende\numa s\u00e9rie de sub-tarefas, apresentadas na Figura 16 .\n\n\u2022 No primeiro passo, ocorre a decomposi\u00e7\u00e3o do processo de neg\u00f3cio documentado\nem uma s\u00e9rie de passos de baixa granularidade, sendo que este n\u00edvel de granulari-\ndade obtido pode diferir do n\u00edvel original.\n\n\u2022 Em seguida, s\u00e3o identificadas as opera\u00e7\u00f5es candidatas dos servi\u00e7os de neg\u00f3cio. Ba-\nsicamente, os candidatos a opera\u00e7\u00f5es ser\u00e3o os passos do processo identificados na\netapa anterior, exceto aquelas atividades que s\u00e3o tarefas humanas que n\u00e3o dever\u00e3o\nser automatizadas e passos que j\u00e1 s\u00e3o executados por aplica\u00e7\u00f5es legadas que n\u00e3o\npodem ser encapsuladas por servi\u00e7os.\n\n\n\n50\n\nFigura 16: Modelagem de servi\u00e7os candidatos (ERL, 2005)\n\n\u2022 Caso a arquitetura SOA em quest\u00e3o possua uma camada de orquestra\u00e7\u00e3o de servi-\n\u00e7os, ent\u00e3o se deve definir que partes da l\u00f3gica de aplica\u00e7\u00e3o ser\u00e3o abstra\u00eddas pela\nl\u00f3gica de orquestra\u00e7\u00e3o. Isto \u00e9, deve-se definir qual a l\u00f3gica estar\u00e1 representada no\nprocesso ao inv\u00e9s de ser executada por um servi\u00e7o de neg\u00f3cio. Regras de neg\u00f3cio,\nl\u00f3gica condicional, l\u00f3gica de exce\u00e7\u00e3o e l\u00f3gica sequencial s\u00e3o alguns exemplos de\nl\u00f3gica que podem ser abstra\u00eddos pela camada de orquestra\u00e7\u00e3o.\n\n\u2022 As opera\u00e7\u00f5es candidatas devem ent\u00e3o ser analisadas para se criar os candidatos a\nservi\u00e7os de neg\u00f3cio. As opera\u00e7\u00f5es dever\u00e3o assim ser agrupadas de acordo com o\ncontexto l\u00f3gico correspondente. Por exemplo, servi\u00e7os baseados em tarefas seriam\nagrupamentos de acordo com processo ou servi\u00e7os baseados em entidades seriam\nagrupamentos de opera\u00e7\u00f5es segundo os relacionamentos entre entidades. Opera-\n\u00e7\u00f5es podem ser adicionadas aos servi\u00e7os para aumentar sua reusabilidade.\n\n\u2022 Definidos os servi\u00e7os candidatos, aplicam-se os princ\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os\npara garantir que eles realmente atendam aos requisitos de uma arquitetura SOA.\nAs opera\u00e7\u00f5es candidatas devem ter seus escopos e l\u00f3gica revisados para que sejam\nrealmente reus\u00e1veis e aut\u00f4nomas (sem depend\u00eancias entre si).\n\n\u2022 Para se identificar composi\u00e7\u00f5es de servi\u00e7os candidatos, devem ser analisados diver-\nsos cen\u00e1rios de execu\u00e7\u00e3o do processo de neg\u00f3cio. Destas an\u00e1lises, podem-se inferir\nposs\u00edveis composi\u00e7\u00f5es de servi\u00e7os e concluir se os agrupamentos de opera\u00e7\u00f5es s\u00e3o\nadequados. Nos cen\u00e1rios, devem ser considerados os casos de falha ou exce\u00e7\u00e3o.\n\n\u2022 Baseados nos resultados do passo anterior, revisam-se os agrupamentos de opera-\n\u00e7\u00f5es candidatas em servi\u00e7os.\n\n\u2022 Por \u00faltimo, opcionalmente, podem-se revisar os requisitos de processamento dos\nservi\u00e7os candidatos. Tal revis\u00e3o tem o prop\u00f3sito de determinar qual a l\u00f3gica ne-\ncess\u00e1ria para executar as opera\u00e7\u00f5es candidatas e se tal l\u00f3gica j\u00e1 existe ou deve ser\ndesenvolvida.\n\nPara documentar os servi\u00e7os em seu m\u00e9todo de an\u00e1lise de projeto, Erl prop\u00f5e uma\nnota\u00e7\u00e3o semelhante a uma nota\u00e7\u00e3o de classe da UML, que exibe um servi\u00e7o com suas\nopera\u00e7\u00f5es. Esta nota\u00e7\u00e3o \u00e9 utilizada em diagramas que exibem composi\u00e7\u00f5es de servi\u00e7os.\nA nota\u00e7\u00e3o utilizada por Erl pode ser vista na Figura 17.\n\n\n\n51\n\nFigura 17: Nota\u00e7\u00e3o ERL para representar um servi\u00e7o (ERL, 2005)\n\n3.3 Atividades de Projeto\n\nO m\u00e9todo descrito por Erl tem suas atividades de projeto especificadas na fase de\nProjeto Orientado a Servi\u00e7os do ciclo de vida. Os principais objetivos desta fase s\u00e3o defi-\nnir as interfaces dos servi\u00e7os candidatos modelados na An\u00e1lise, garantir a adequa\u00e7\u00e3o aos\nprinc\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os e definir quais padr\u00f5es ser\u00e3o suportados e utilizados\nna implementa\u00e7\u00e3o dos servi\u00e7os. Como resultados, tem as especifica\u00e7\u00f5es dos servi\u00e7os nas\ncamadas de neg\u00f3cio, aplica\u00e7\u00e3o e orquestra\u00e7\u00e3o. Os passos do Projeto Orientado a Servi-\n\u00e7os podem ser visualizados na Figura 18 e s\u00e3o descritos nas se\u00e7\u00f5es seguintes (FUGITA,\n2009).\n\nFigura 18: Projeto orientado a servi\u00e7os (ERL, 2007)\n\n3.3.1 Composi\u00e7\u00e3o da arquitetura orientada a servi\u00e7os\n\nNesta primeira atividade, s\u00e3o determinadas quais camadas de servi\u00e7os ser\u00e3o utilizadas\nna arquitetura sendo constru\u00edda. Devem-se definir tamb\u00e9m os padr\u00f5es que ser\u00e3o utilizados\nna especifica\u00e7\u00e3o e implementa\u00e7\u00e3o dos servi\u00e7os. Por exemplo, se for utilizada a tecnologia\nWeb Services, deve-se estabelecer quais especifica\u00e7\u00f5es de XML e Web Services ser\u00e3o\nutilizadas e quais extens\u00f5es ser\u00e3o necess\u00e1rios (FUGITA, 2009).\n\n3.3.2 Projeto de servi\u00e7os baseados em entidades\n\nServi\u00e7os de neg\u00f3cio baseados em entidades representam entidades de dados definidas\nno modelo de neg\u00f3cio da organiza\u00e7\u00e3o. Este tipo de servi\u00e7o \u00e9 completamente independente\nde processo de neg\u00f3cio, podendo ser reusado por qualquer solu\u00e7\u00e3o que necessite acessar\n\n\n\n52\n\ndados relacionados a uma entidade particular. Servi\u00e7os baseados em entidades fazem\nparte da camada de servi\u00e7os de neg\u00f3cio.\n\nA atividade de projeto de servi\u00e7os baseados em entidade tem como prop\u00f3sito espe-\ncificar as interfaces e a l\u00f3gica encapsulada por eles. Para a especifica\u00e7\u00e3o das interfaces,\nErl prop\u00f5e o uso de documentos WSDL, que podem ser utilizados posteriormente para\nimplementa\u00e7\u00e3o com Web Services. Os esquemas de dados das entidades tratadas pelo ser-\nvi\u00e7o s\u00e3o definidos e representados na forma de esquemas XSD e compor\u00e3o as mensagens\ntrocadas pelas opera\u00e7\u00f5es do servi\u00e7o.\n\nPrinc\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os devem ser tamb\u00e9m aplicados aos servi\u00e7os. Ser-\nvi\u00e7os baseados em entidades s\u00e3o intrinsecamente aut\u00f4nomos pelo fato de cada um ser\nrespons\u00e1vel por manipular uma entidade ou grupo de entidades espec\u00edfico. Tamb\u00e9m n\u00e3o\npreservam informa\u00e7\u00e3o de estado, uma vez que possuem pouca l\u00f3gica de fluxo de trabalho\nencapsulada. Deve-se atentar para a reusabilidade do servi\u00e7o, possivelmente adicionando\nopera\u00e7\u00f5es que podem ser \u00fateis em outros contextos al\u00e9m do considerado para uma solu\u00e7\u00e3o\nem particular (FUGITA, 2009).\n\n3.3.3 Projeto de servi\u00e7os de aplica\u00e7\u00e3o\n\nOs servi\u00e7os da camada de aplica\u00e7\u00e3o s\u00e3o a principal for\u00e7a de trabalho da arquitetura\nSOA, executando fun\u00e7\u00f5es demandadas pelas camadas de orquestra\u00e7\u00e3o e de servi\u00e7os de\nneg\u00f3cio. S\u00e3o abstra\u00e7\u00f5es orientadas a servi\u00e7o do ambiente tecnol\u00f3gico da organiza\u00e7\u00e3o,\nn\u00e3o sendo por isso necess\u00e1rio considerar aspectos de neg\u00f3cio em seu projeto. A ativi-\ndade de projeto de servi\u00e7os de aplica\u00e7\u00e3o inicia-se com a an\u00e1lise das opera\u00e7\u00f5es candidatas\npropostas, para verificar se possuem o n\u00edvel de granularidade e reusabilidade adequados.\nDevem ent\u00e3o ser definidos os dados de entrada e sa\u00edda para cada uma das opera\u00e7\u00f5es,\npossivelmente na forma de esquemas XSD. Finalmente, a defini\u00e7\u00e3o da interface WSDL\ndeve ser completada com as opera\u00e7\u00f5es correspondentes. Como servi\u00e7os de aplica\u00e7\u00e3o de-\nvem poder ser utilizados por diversos tipos de servi\u00e7os de neg\u00f3cio, os dados de entrada\ne sa\u00edda definidos para as opera\u00e7\u00f5es devem ser definidos de modo simples e gen\u00e9rico.\nAo aplicarem-se os princ\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os, deve-se atentar para que eles se\nmantenham aut\u00f4nomos sem depend\u00eancias entre sua l\u00f3gica de neg\u00f3cio. Por fim, devem\nser identificadas as poss\u00edveis restri\u00e7\u00f5es de ordem t\u00e9cnica que se aplicam ao servi\u00e7o de\naplica\u00e7\u00e3o, como componentes, Application Programming Interface (API\u2019s) e adaptadores\nnecess\u00e1rios para a realiza\u00e7\u00e3o de conex\u00f5es, restri\u00e7\u00f5es de seguran\u00e7a e poss\u00edveis requisitos\nde SLA (FUGITA, 2009).\n\n3.3.4 Projeto de servi\u00e7os baseados em tarefas\n\nServi\u00e7os baseados em tarefas pertencem \u00e0 camada de servi\u00e7os de neg\u00f3cio e geralmente\nt\u00eam seu projeto simplificado por possu\u00edrem pouca necessidade de serem reus\u00e1veis. Tipi-\ncamente encapsulam l\u00f3gica de fluxo de trabalho e realizam a orquestra\u00e7\u00e3o de servi\u00e7os de\naplica\u00e7\u00e3o. A l\u00f3gica de fluxo de trabalho deve ser especificada, podendo ser representada\npor diagramas de atividades. Esta l\u00f3gica especificada pode auxiliar na descoberta de no-\nvas opera\u00e7\u00f5es necess\u00e1rias. As opera\u00e7\u00f5es candidatas t\u00eam suas entradas e sa\u00eddas mapeadas\ne s\u00e3o representadas por meio de documentos XSD e WSDL (FUGITA, 2009).\n\n3.3.5 Projeto de processo orientado a servi\u00e7os\n\nOs processos de neg\u00f3cio orientados a servi\u00e7os correspondem \u00e0 camada de orques-\ntra\u00e7\u00e3o da arquitetura SOA. O processo corresponde ao fluxo de execu\u00e7\u00e3o de servi\u00e7os de\n\n\n\n53\n\nneg\u00f3cio, com suas regras e l\u00f3gica, descrevendo o que \u00e9 chamado de orquestra\u00e7\u00e3o de ser-\nvi\u00e7os. No m\u00e9todo proposto por Erl, a linguagem WS-BPEL \u00e9 utilizada para representar as\ndefini\u00e7\u00f5es dos processos de neg\u00f3cio, por\u00e9m esse processo pode ser adaptado para outras\nlinguagens. Nesse caso, Enquanto o projeto de servi\u00e7os baseados em tarefas e em entida-\ndes concentrava-se em definir as interfaces dos servi\u00e7os e as mensagens das opera\u00e7\u00f5es, o\nprojeto de processos de neg\u00f3cio busca criar um fluxo WS-BPEL que implemente a l\u00f3gica\nde neg\u00f3cio relegada \u00e0 camada de orquestra\u00e7\u00e3o durante a An\u00e1lise Orientada a Servi\u00e7os.\nTal l\u00f3gica que foi deixada de fora dos servi\u00e7os especificados \u00e9 abstra\u00edda em um processo\nde neg\u00f3cio separado. O primeiro passo do projeto de processos recebe como entrada a\ndescri\u00e7\u00e3o da l\u00f3gica de fluxo de trabalho a ser abstra\u00edda pela orquestra\u00e7\u00e3o, o servi\u00e7o de\nprocesso candidato e os servi\u00e7os de neg\u00f3cio projetados nas atividades de projeto ante-\nriores. Devem-se levantar quais os tipos de dados e informa\u00e7\u00f5es ser\u00e3o necess\u00e1rios para\nexecutar a l\u00f3gica e invocar os servi\u00e7os de neg\u00f3cio. Com base neste levantamento, devem-\nse especificar os esquemas de dados das mensagens utilizadas no processo e a interface\ndo servi\u00e7o de processo. Neste ponto muitos esquemas definidos para os servi\u00e7os de ne-\ng\u00f3cio poder\u00e3o ser reaproveitados. Definidas a interface e as mensagens, parte-se para o\ndesenvolvimento da especifica\u00e7\u00e3o WS-BPEL do processo. Neste passo, ser\u00e1 especificado\ncomo os servi\u00e7os ser\u00e3o orquestrados. Devem-se definir quais servi\u00e7os ser\u00e3o invocados,\ncriar as regras de neg\u00f3cio envolvidas nas invoca\u00e7\u00f5es e o tratamento dos dados trocados\ncom os servi\u00e7os. Com os processos WS-BPEL especificados, deve-se analisar a l\u00f3gica de\nfluxo de trabalho criada frente aos cen\u00e1rios de execu\u00e7\u00e3o discutidos anteriormente. Neste\npasso, pode ocorrer um refinamento do processo e dos servi\u00e7os de neg\u00f3cio, dando origem\na algumas altera\u00e7\u00f5es necess\u00e1rias de acordo com os cen\u00e1rios (FUGITA, 2009).\n\n3.3.6 Artefatos\n\nA documenta\u00e7\u00e3o dos requisitos de neg\u00f3cio \u00e9 um artefato utilizado na fase inicial de\nAn\u00e1lise Orientada a Servi\u00e7os e especifica os requisitos relacionados \u00e0 solu\u00e7\u00e3o em de-\nsenvolvimento. Estes requisitos podem ser obtidos por meio de t\u00e9cnicas convencionais\nde levantamento utilizadas em m\u00e9todos de desenvolvimento de software distribu\u00eddo. A\ndocumenta\u00e7\u00e3o dos servi\u00e7os candidatos \u00e9 o resultado da An\u00e1lise Orientada a Servi\u00e7os e\nconsiste em uma descri\u00e7\u00e3o em alto n\u00edvel dos servi\u00e7os criados a partir do agrupamento\nde opera\u00e7\u00f5es candidatas identificadas. Este artefato descreve a l\u00f3gica de neg\u00f3cio execu-\ntada por cada opera\u00e7\u00e3o candidata do servi\u00e7o. Durante o Projeto Orientado a Servi\u00e7os, as\nmensagens trocadas pelas opera\u00e7\u00f5es s\u00e3o definidas na forma de esquemas XSD e a descri-\n\u00e7\u00e3o das interfaces \u00e9 realizada por meio da linguagem de defini\u00e7\u00e3o de interfaces WSDL.\nOs servi\u00e7os de processo desenvolvidos para a camada de orquestra\u00e7\u00e3o s\u00e3o especificados\nutilizando-se a linguagem de defini\u00e7\u00e3o de processos WS-BPEL (FUGITA, 2009).\n\n3.3.7 An\u00e1lise do M\u00e9todo\n\nO m\u00e9todo proposto por Erl consiste em uma abordagem puramente top-down para\nidentifica\u00e7\u00e3o e especifica\u00e7\u00e3o de servi\u00e7os. Na atividade de modelagem de servi\u00e7os can-\ndidatos, Erl descreve de forma detalhada os passos a serem executados para identificar\nopera\u00e7\u00f5es candidatas e descrever os servi\u00e7os candidatos resultantes. O autor coloca a\nmodelagem de processo como parte da atividade de defini\u00e7\u00e3o de requisitos de neg\u00f3cio,\nseparando-a das atividades de identifica\u00e7\u00e3o e descri\u00e7\u00e3o dos servi\u00e7os que ocorrem durante\na modelagem de servi\u00e7os candidatos. Apesar de n\u00e3o serem especificados os pap\u00e9is associ-\nados \u00e0s atividades, esta separa\u00e7\u00e3o permite que cada atividade seja executada por pessoas\ncom conhecimentos espec\u00edficos. Apesar de os recursos existentes serem identificados\n\n\n\n54\n\ndurante a An\u00e1lise Orientada a Servi\u00e7os, o reuso destes recursos n\u00e3o \u00e9 considerado para\ncompor os servi\u00e7os descritos na modelagem de servi\u00e7os candidatos. Tal identifica\u00e7\u00e3o\nservir\u00e1 para definir se um passo do processo ser\u00e1 executado por um servi\u00e7o ou por uma\naplica\u00e7\u00e3o legada, sendo que no segundo caso n\u00e3o \u00e9 considerado como uma execu\u00e7\u00e3o de\nservi\u00e7o. Consequentemente, n\u00e3o h\u00e1 descrita no m\u00e9todo nenhuma atividade para defini\u00e7\u00e3o\nde como cada servi\u00e7o ser\u00e1 realizado. O conceito de servi\u00e7os candidatos \u00e9 utilizado pelo\nm\u00e9todo de Erl como transi\u00e7\u00e3o da An\u00e1lise para o Projeto. Os servi\u00e7os s\u00e3o considerados\ncandidatos desde sua modelagem at\u00e9 o momento em que t\u00eam sua especifica\u00e7\u00e3o definida.\nTrata-se de uma proposta bastante alinhada ao conceito de BPM, que \u00e9 aplicado tanto du-\nrante a decomposi\u00e7\u00e3o de processos de neg\u00f3cio em servi\u00e7os quanto no projeto de processo\nde neg\u00f3cio orientado a servi\u00e7o, atividade em que \u00e9 aplicada a orquestra\u00e7\u00e3o de processos\nem WS-BPEL. Na fase de Projeto, o m\u00e9todo leva em considera\u00e7\u00e3o as camadas de ser-\nvi\u00e7os, ao descrever atividades de projeto voltadas para cada tipo de servi\u00e7o: entidade,\ntarefa e aplica\u00e7\u00e3o. Cada uma destas atividades tem como objetivo especificar servi\u00e7os\nfocando nas particularidades de um determinado tipo de servi\u00e7o. Erl d\u00e1 bastante \u00eanfase\naos princ\u00edpios de orienta\u00e7\u00e3o a servi\u00e7os, incluindo atividades espec\u00edficas para valida\u00e7\u00e3o\ntanto na An\u00e1lise quanto no Projeto (ERL, 2007). Na atividade de modelagem de servi\u00e7os\ncandidatos, realiza-se uma avalia\u00e7\u00e3o para verificar se os servi\u00e7os candidatos modelados\npossuem caracter\u00edsticas de reusabilidade e autonomia. J\u00e1 durante as atividades de projeto\nde servi\u00e7os, s\u00e3o verificados os princ\u00edpios de reusabilidade, autonomia, independ\u00eancia de\nestado e baixo acoplamento, dependendo do tipo de servi\u00e7o sendo projetado. Como o\nm\u00e9todo adota a tecnologia Web Services para a realiza\u00e7\u00e3o dos servi\u00e7os, s\u00e3o utilizados os\npadr\u00f5es XSD e WSDL para especificar os contratos de servi\u00e7os (FUGITA, 2009).\n\n\n\n55\n\n4 ESTUDOS DE CASOS: ROB\u00d3TICA M\u00d3VEL E TECNO-\nLOGIA ASSISTIVA\n\nNeste cap\u00edtulo ser\u00e1 apresentada a abordagem pr\u00e1tica realizada para estudo do pro-\ncesso de desenvolvimento baseado em todos os paradigmas vistos nas se\u00e7\u00f5es anteriores.\nVisando o desenvolvimento de uma biblioteca de componentes, bem especificada e devi-\ndamente documentada para a proposta de um framework para projetos de sistemas embar-\ncados e rob\u00f3tica. Para valida\u00e7\u00e3o do framework dois estudos de casos foram desenvolvidos\ncomo servi\u00e7os: Rob\u00f3tica M\u00f3vel e Tecnologia Assistiva.\n\n4.1 Metodologias no desenvolvimento dos sistemas embarcados\n\nA utiliza\u00e7\u00e3o de sistemas computacionais vem crescendo na sociedade, com isso, apli-\nca\u00e7\u00f5es de tempo real tornam-se frequentes. As aplica\u00e7\u00f5es de tempo real variam em re-\nla\u00e7\u00e3o \u00e0 complexidade e \u00e0s necessidades de garantia no atendimento dos requisitos tem-\nporais. As aplica\u00e7\u00f5es embarcadas possuem caracter\u00edsticas que os diferem dos demais\nsistemas. Caracter\u00edsticas como: sistemas dedicados, sistemas reativos, confiabilidade,\nrestri\u00e7\u00f5es de tempo real, tamanho do c\u00f3digo, desempenho, baixo consumo de pot\u00eancia e\nenergia, f\u00edsicas (tamanho e peso), devem ser consideradas no desenvolvimento de um sis-\ntema embarcado. Para lidar com essas restri\u00e7\u00f5es na constru\u00e7\u00e3o de um sistema embarcado\ns\u00e3o utilizadas as linguagens de modelagem de alto n\u00edvel de abstra\u00e7\u00e3o. Sendo assim, o pro-\njeto de um sistema embarcado parte de uma vis\u00e3o abstrata e ao longo do desenvolvimento\ns\u00e3o feitos refinamentos at\u00e9 o produto finalizado.\n\nO processo de desenvolvimento do projeto embarcado utilizar\u00e1 paradigma de ciclo de\nvida em cascata (waterfall), estruturado em cascatas de fases, como ilustra a Figura 19\nonde o final de uma fase implica no in\u00edcio de outra. Este tipo de comportamento ressalta\na qualidade de um modelo r\u00edgido e linear para o desenvolvimento de software embarcado\nde tempo real no sentido que uma fase come\u00e7a ap\u00f3s a outra numa dire\u00e7\u00e3o linear. Para que\no software embarcado tenha uma maior flexibilidade, caso seja necess\u00e1rio, a arquitetura\ndo software embarcado poder\u00e1 fazer uso do modelo em cascata revisto, o qual prev\u00ea a\npossibilidade de, a qualquer tarefa do ciclo, regressar a uma tarefa anterior de forma a\ncontemplar altera\u00e7\u00f5es funcionais ou t\u00e9cnicas, caso a coordena\u00e7\u00e3o dos softwares embarca-\ndos venha requerer.\n\nDe acordo com este fluxo, as etapas de projeto compreendem:\n\n\u2022 An\u00e1lise de Requisitos: defini\u00e7\u00e3o dos requisitos do sistema,\n\n\u2022 Especifica\u00e7\u00e3o: detalhamento das funcionalidades do sistema,\n\n\n\n56\n\nAn\u00e1lise de\nRequisitos\n\nEspecifica\u00e7\u00e3o\n\nArquitetura do \nSistema\n\nIntegra\u00e7\u00e3o de \nComponentes\n\nProjeto de \nComponentes\n\nFigura 19: N\u00edveis de abstra\u00e7\u00e3o para o processo de projeto de sistemas embarcados. Fonte:\n(LEE; SESHIA, 2011).\n\n\u2022 Arquitetura do Sistema: detalhamento interno do sistema, bem como os compo-\nnentes que comp\u00f5em o sistema,\n\n\u2022 Projeto de Componentes: projetar os componentes do sistema,\n\n\u2022 Integra\u00e7\u00e3o do Sistema: integra\u00e7\u00e3o dos componentes desenvolvidos para o sistema\ne a valida\u00e7\u00e3o dos mesmos.\n\nExistem v\u00e1rios modelos de ciclo de vida, no projeto dos sistemas embarcados dos es-\ntudos de caso s\u00e3o utilizadas duas estrat\u00e9gias de desenvolvimento: a abordagem top-down,\nem que o projeto inicia com uma vis\u00e3o mais abstrata e atrav\u00e9s de refinamentos sucessivos\nobt\u00eam-se o sistema propriamente dito e a abordagem bottom-up, o qual o projeto \u00e9 inici-\nado com uma descri\u00e7\u00e3o em n\u00edvel de componentes e a partir destes componentes constr\u00f3i-\nse o sistema completo permitindo tomar decis\u00f5es quanto ao custo dos componentes e qual\nser\u00e1 a melhor arquitetura para o sistema. Sendo um misto das duas abordagens para que\nas decis\u00f5es cr\u00edticas possam ser tomadas a tempo evitando o retrabalho (LEE; SESHIA,\n2011).\n\n4.1.1 Especifica\u00e7\u00e3o do Hardware\n\nPara o hardware dos estudos de caso do projeto, \u00e9 proposto o desenvolvimento de uma\nplataforma de hardware, para uma melhor descri\u00e7\u00e3o geral do sistema foi desenvolvido um\ndiagrama de blocos, Figura 20, que \u00e9 um diagrama cujo objetivo \u00e9 a representa\u00e7\u00e3o gr\u00e1fica\ndo processo e modelo dos projetos embarcados. Atrav\u00e9s de figuras geom\u00e9tricas e liga\u00e7\u00f5es,\ndescrevem-se as rela\u00e7\u00f5es entre cada subsistema e o fluxo de informa\u00e7\u00e3o. O prot\u00f3tipo do\nhardware pode ser composto de sensores, m\u00f3dulos e atuadores que s\u00e3o configurados le-\nvando em considera\u00e7\u00e3o a morfologia mec\u00e2nica e as rela\u00e7\u00f5es geom\u00e9tricas de cada projeto,\ne assim poder determinar a melhor adapta\u00e7\u00e3o poss\u00edvel dos componentes.\n\nO tratamento das informa\u00e7\u00f5es captadas e transmitidas pelos m\u00f3dulos e sensores s\u00e3o\nprocessados atrav\u00e9s de um microcontrolador, dotado de um algoritmo de controle para\nativar os atuadores. Os m\u00f3dulos e sensores estimulam os atuadores conforme a l\u00f3gica de\n\n\n\n57\n\nFigura 20: Diagrama de bloco da arquitetura dos estudos de caso do projeto. Fonte: (LEE;\nSESHIA, 2011).\n\nprograma\u00e7\u00e3o e controle dos estudos de caso. O prot\u00f3tipo \u00e9 um trabalho de hardware e\nsoftware baseados em plataformas flex\u00edveis open-source para o desenvolvimento. Para a\nconstru\u00e7\u00e3o do hardware dos estudos de caso do projeto vem sendo utilizado inicialmente\nplataformas open-hardware. A reutiliza\u00e7\u00e3o dos circuitos proporciona a cria\u00e7\u00e3o de novas\nplataformas. A Figura 21, mostra o projeto do circuito e layout parcialmente modelado\nem software CAD (EAGLE, 2014).\n\nFigura 21: Microcontrolador ATmega328P e driver L293D. Fonte: (GUIBOT, 2014).\n\nTestes e valida\u00e7\u00f5es de alguns dos componentes de harware dos estudos de caso, utili-\nzam inicialmente o microcontrolador ATmega328P (ATMEL, 2015). O microcontrolador\n\u00e9 conectado com um driver ponte-h para o acionamento dos motores independentes do\nrob\u00f4 m\u00f3vel ou dos motores de vibra\u00e7\u00e3o t\u00e1til da tecnologia assistiva. A ponte-h utiliza duas\npontes completas independentes (full-bridge drive), cujo objetivo \u00e9 ativar os motores de\nCorrente Cont\u00ednua (CC) dos projetos, uma vez que no projeto s\u00e3o utilizados motores CC,\nque exigem tens\u00e3o maior do que a sa\u00edda do microcontrolador pode fornecer. O projeto\nprop\u00f5e uma plataforma de hardware como uma op\u00e7\u00e3o de baixo custo, para controlar o\nsentido de rota\u00e7\u00e3o dos motores e, por consequ\u00eancia, o sentido da corrente que circula\nentre os polos dos motores, visto que os motores CC alteram seus sentidos de rota\u00e7\u00e3o\n\n\n\n58\n\nquando inverte-se sua polaridade. O driver \u00e9 controlado por tr\u00eas entradas, onde a pri-\nmeira entrada \u00e9 de habilita\u00e7\u00e3o (EnA) que ativa ou desativa a ponte-h e as outras duas (In1\ne In2) determinam a circula\u00e7\u00e3o interna da corrente.\n\nA escolha dos componentes se deu por uma combina\u00e7\u00e3o de fatores: baixo custo,\ntempo de desenvolvimento, facilidade de encontrar no mercado e programa\u00e7\u00e3o do micro-\ncontrolador em tr\u00eas n\u00edveis (AVR Assembler, AVR GCC e Wiring C/C++). A comunica\u00e7\u00e3o\nentre a interface de controle do framework e o dispositivo se d\u00e1 atrav\u00e9s de uma conex\u00e3o\nserial padr\u00e3o. O ATmega328P permite comunica\u00e7\u00e3o serial no padr\u00e3o Universal asynch-\nronous receiver/transmitter (UART) TTL (5 V), dispon\u00edvel nos pinos digitais 0 (RX) e 1\n(TX), a Figura 22, apresenta o driver FTDI USB para conex\u00e3o serial.\n\nFigura 22: Conversor USB-TTL FTDI. Fonte: (GUIBOT, 2014).\n\nUm conversor USB-TTL Future Technology Devices International (FTDI), d\u00e1 suporte\npara os drivers relacionados \u00e0 convers\u00e3o TTL para sinais USB respons\u00e1vel pela comuni-\nca\u00e7\u00e3o serial. Um chip FTDI MM232 encaminha esta comunica\u00e7\u00e3o serial atrav\u00e9s da USB\ne os drivers FTDI fornecem uma porta virtual para o software no computador.\n\nO circuito completo pode ser visualizado na Figura 23. O circuito \u00e9 um projeto de\nhardware open-source, projeto Motoruino, uma placa baseada na plataforma Arduino, ele\n\u00e9 projetado para trabalhar com motores, servos e sensores.\n\nO projeto \u00e9 f\u00e1cil de usar, entender e estender, projeto \u00e9 compat\u00edvel com Arduino e\nShields, o circuito possui um microcontrolador Atmega328P para o processamento e um\ndriver Ponte-H (L293D), que permite controlar dois motores de corrente cont\u00ednua. O\nL293D, suporta correntes de sa\u00edda de 600mA por canal, isso \u00e9, voc\u00ea pode ligar at\u00e9 dois\nmotores de 600mA cada. A voltagem suportada \u00e9 de 4.5 \u00e0 36 volts. Isso permite contro-\nlar diversos tipos de motores respeitando-se, \u00e9 claro, a corrente m\u00e1xima suportada pelo\nchip. Recomenda-se utilizar motores com menos de 600 mA, apesar do CI suportar pi-\ncos de 1.2A. Tamb\u00e9m \u00e9 recomendado utilizar um dissipador de calor caso o CI comece a\nesquentar (GUIBOT, 2014).\n\n4.1.2 Especifica\u00e7\u00e3o do Software\n\nPara conhecer melhor a API de programa\u00e7\u00e3o Wiring C/C++ escolhido para imple-\nmenta\u00e7\u00e3o das bibliotecas do firmware do microcontrolador, utilizado para os estudos de\ncaso, foi elaborado uma pesquisa dos principais conceitos da estrutura que envolvem a\nplataforma de software e hardware do framework Wiring.\n\nPara come\u00e7ar precisamos come\u00e7ar contextualizando o framework Processing, uma\nlinguagem de programa\u00e7\u00e3o e ambiente de desenvolvimento integrado (IDE) open-source,\nconstru\u00eddo para as comunidades de artes eletr\u00f4nicas e design visual, com o objetivo de en-\nsinar os fundamentos da programa\u00e7\u00e3o de computador em um contexto visual. O projeto\nfoi iniciado em 2001 por Casey Reas e Benjamin Fry, no Grupo de Est\u00e9tica e Compu-\nta\u00e7\u00e3o no MIT Media Lab. Um dos objetivos declarados do Processing \u00e9 fazer com que\n\n\n\n59\n\nFigura 23: Circuito para controlar motores CC open-source\n.\n\nn\u00e3o-programadores comecem com a programa\u00e7\u00e3o, atrav\u00e9s da gratifica\u00e7\u00e3o instant\u00e2nea de\nfeedback visual. A linguagem baseia-se na linguagem Java, mas usa um modelo de pro-\ngrama\u00e7\u00e3o sintaxe simplificada e gr\u00e1ficos.\n\nPosteriormente ao Processing, veio a plataforma de hardware Wiring, uma plataforma\neletr\u00f4nica de prototipagem composto de uma linguagem de programa\u00e7\u00e3o, um ambiente de\ndesenvolvimento integrado (IDE), e um microcontrolador single-board open-source. Ele\nfoi desenvolvido a partir de 2003 por Hernando Barrag\u00e1n. Barrag\u00e1n come\u00e7ou o projeto\nno Interaction Design Institute Ivrea. O projeto est\u00e1 atualmente desenvolvido na Escola\nde Arquitetura e Design na Universidade de Los Andes, em Bogot\u00e1, Col\u00f4mbia. Wiring\nfoi constru\u00eddo sobre o projeto Processing. A documenta\u00e7\u00e3o foi criado pensando na comu-\nnidade onde especialistas, desenvolvedores intermedi\u00e1rios e iniciantes de todo o mundo\ncompartilham ideias, conhecimentos e sua experi\u00eancias coletivas. O foco principal do\nprojeto \u00e9 criar um quadro multi-plataforma para todos diferentes tipos de microcontrola-\ndores. A plataforma Wiring fornece um ambiente de desenvolvimento integrado (IDE),\nque inclui suporte para linguagens de programa\u00e7\u00e3o C, C++ e Java. Wiring suporta quase\n80-90% dos microcontroladores Atmel da serie AVR 8 Bit e outros microcontroladores\ncomo PIC32, ARM Cortex M3 e MSP430. Considerando a programa\u00e7\u00e3o e a compatibili-\ndade com diversos hardware isso abre mais portas para o de desenvolvimento de projetos.\n\nE assim surgiu o Arduino em 2005, uma plataforma de hardware e software open-\nsource, que \u00e9 um misto entre Processing e Wiring, sendo um fork desta segunda, uma pla-\ntaforma de prototipagem r\u00e1pida para eletr\u00f4nica. O projeto \u00e9 baseado em uma fam\u00edlia de\ndesenhos de placa de microcontroladores fabricados principalmente por SmartProjects na\nIt\u00e1lia, e tamb\u00e9m por v\u00e1rios outros fornecedores, usando v\u00e1rios microcontroladores 8 bits\nAtmel AVR ou 32 bits Atmel ARM processadores. Esses sistemas fornecem conjuntos\nde pinos I/O digitais e anal\u00f3gicos que podem ser conectados a v\u00e1rias placas de expan-\ns\u00e3o (\"escudos\") e outros circuitos. As placas possuem interfaces de comunica\u00e7\u00e3o serial,\nincluindo USB em alguns modelos, para carregamento de programas de computadores\n\n\n\n60\n\npessoais. Para a programa\u00e7\u00e3o dos microcontroladores, a plataforma Arduino fornece um\nambiente de desenvolvimento integrado (IDE), que inclui suporte para linguagens de pro-\ngrama\u00e7\u00e3o C, C++ e Java.\n\nA IDE Arduino parece praticamente o mesmo que a IDE Wiring e Processing, e fun-\nciona da mesma maneira, voc\u00ea pode trabalhar com sketch (esbo\u00e7os) com ambas as IDE\u2019s\nutilizando suas API\u2019s e bibliotecas. Atualmente est\u00e3o surgindo muitas outras plataformas\nde hardware e software para diferentes arquiteturas de microcontroladores, onde a maioria\nde suas ferramentas de hardware e software, s\u00e3o baseados em Processing, Wiring e Ar-\nduino. A Figura 24, apresenta o diagrama de blocos parcial de como funciona a estrutura\ndo framework para plataformas de hardware. Por exemplo, para gerar a API de programa-\n\u00e7\u00e3o de alto n\u00edvel utilizado em Wiring C/C++, s\u00e3o encapsulados os registradores de baixo e\nm\u00e9dio n\u00edvel dos microcontroladores em estruturas de programa\u00e7\u00e3o em C e C++. Os arqui-\nvos implementados para API podem ser visualizados acessando os diret\u00f3rios do software\nArduino no computador host onde o mesmo foi instalado ou baixado, assim devem ser\nacessados os seguintes diret\u00f3rios: arduino-vX\\hardware\\arduino\\avr\\cores\\arduino.\n\nFrameworks:\n- Wiring\n\n- Arduino\n- Arduino Intel\n\n- Mpide\n- Energia\n\n:\n\nMCU\nArduino\n\nMCU\nPIC\n\nSOC\nArduino \n\nIntel Galileo\n\nlibraries (.h, .c e .cpp)\nhardware (mcu-gcc, cores)\n\n  /*sketch*/\n\nvoid setup(){\n    ...\n}\n\nvoid loop(){\n    ...\n}\n\n...\n\nFigura 24: Diagrama de blocos parcial para Frameworks baseados na API Wiring.\n\nO software \u00e9 uma IDE, que \u00e9 executado em um computador host onde \u00e9 feita a progra-\nma\u00e7\u00e3o, conhecida como sketch, na qual ser\u00e1 feita upload para a placa de prototipagem,\natrav\u00e9s de uma comunica\u00e7\u00e3o serial. O sketch feito pelo projetista dir\u00e1 \u00e0 placa o que deve\nser executado durante o seu funcionamento. Para um melhor entendimento s\u00e3o apresen-\ntados na Figura ??, imagens dos tr\u00eas frameworks descritos at\u00e9 agora. Cada um possui\num ambiente de desenvolvimento integrado ou IDE, programa do computador que re\u00fane\ncaracter\u00edsticas e ferramentas de apoio ao desenvolvimento de software com o objetivo de\nagilizar este processo.\n\nPor\u00e9m, n\u00e3o s\u00e3o as \u00fanicas IDE\u2019s existentes para programa\u00e7\u00e3o dos hardwares, exis-\ntem outras variedades de ferramentas que podem ser utilizados. Conforme a arquitetura\nutilizada, cada fabricante possui framework pr\u00f3prio para dar suporte aos seus micropro-\n\n\n\n61\n\nFigura 25: IDE\u2019s dos Frameworks citados.\n\ncessadores, como por exemplo Atmel Studio para Atmel ou MPLAB para PIC, e assim por\ndiante. Para programar no alto n\u00edvel utilizando API Wiring, \u00e9 necess\u00e1rio utilizar IDE\u2019s\nque deem suporte para as bibliotecas de programa\u00e7\u00e3o, hoje muitas ferramentas est\u00e3o su-\nportando a API de programa\u00e7\u00e3o Wiring, como as IDE\u2019s Eclipse Arduino ou CodeBlocks\nArduino, entre uma variedade enorme de possibilidades. Neste trabalho, para os estudos\nde caso, o principal objetivo \u00e9 o desenvolvimento da programa\u00e7\u00e3o em C++ das bibliotecas\ndos componentes eletr\u00f4nicos dos projetos, utilizando a API Wiring. A IDE de programa-\n\u00e7\u00e3o utilizada foram as IDE\u2019s Atmel Studio, Eclipse e Arduino.\n\nPara demonstrar a efici\u00eancia e flexibilidade da API Wiring para microcontrolado-\nres vamos dispor de dois c\u00f3digos de programa\u00e7\u00e3o. Os dois c\u00f3digos implementam a\nmesma l\u00f3gica, por\u00e9m cada um implementa a linguagem de programa\u00e7\u00e3o em C base-\nado no GNU Compiler Collection (GCC) do microprocessador. Um pequeno exemplo de\npisca LED (Light Emitting Diode) para microcontroladores Atmel-Atmega328P e Texas-\nMSP430G2553 s\u00e3o apresentados.\n\nO microcontrolador ATmega328P faz parte da popular fam\u00edlia de microcontroladores\nde 8 bits CMOS baseado na arquitetura AVR lan\u00e7ada pela ATMEL. Este microcontro-\nlador possui alt\u00edssima performance podendo executar instru\u00e7\u00f5es com um ciclo de clock,\nfazendo com que o mesmo alcance 1 MIPS/MHz (1 Milh\u00e3o de Instru\u00e7\u00f5es por Segundo\npor Mega Hertz), possibilitando ao programador otimizar o projeto combinando consumo\nde pot\u00eancia versus velocidade de processamento. O ATmega328P \u00e9 utilizado nas placas\nArduino e oferece performance que permite executar desde um simples programa que\nfaz piscar um LED at\u00e9 um controle de um rob\u00f4 ou ainda um programa de controle de\nacesso controlado por rede. A seguir o c\u00f3digo para piscar um LED utilizando a API de\nprograma\u00e7\u00e3o nativa do processador AVR.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / / P i s c a Led ? Atm eg a3 2 8 P\n5\n\n6 # i n c l u d e &lt;a v r / i o . h >\n7 # i n c l u d e &lt;u t i l / d e l a y . h >\n8\n\n9 enum {\n10 BLINK_DELAY_MS = 1 0 0 0 ,\n11 } ;\n\n\n\n62\n\n12\n\n13 i n t m a i n ( v o i d )\n14 {\n15 / ? s e t a p i n o 5 d a PORTB p a r a o u t p u t ? /\n16 DDRB | = _BV ( DDB5 ) ;\n17\n\n18 / ? DDRB | = 1<<PB5 ; / / D e f i n i r o p i n o como s a \u00ed d a\n19 DDRD &amp;= ~(1 &lt;<PD2 ) ; / / D e f i n i r o p i n o como e n t r a d a ? /\n20\n\n21 w h i l e ( 1 ) {\n22 / ? s e t a p i n o 5 como a l t o p a r a l i g a r o l e d ? /\n23 PORTB | = _BV ( PORTB5 ) ;\n24 _ d e l a y _ m s ( BLINK_DELAY_MS ) ;\n25\n\n26 / ? s e t a p i n o 5 como b a i x o p a r a d e s l i g a r o l e d ? /\n27 PORTB &amp;= ~_BV ( PORTB5 ) ;\n28 _ d e l a y _ m s ( BLINK_DELAY_MS ) ;\n29 }\n30\n\n31 r e t u r n 0 ;\n32 }\n33 }\n\nA fam\u00edlia Texas Instruments MSP430 de microcontroladores cont\u00e9m ultra-baixo con-\nsumo de energia, consiste em v\u00e1rios dispositivos com diferentes conjuntos de perif\u00e9ricos\ndirecionados para v\u00e1rias aplica\u00e7\u00f5es. A arquitetura, combinada com cinco modos de baixo\nconsumo de energia, \u00e9 otimizado para alcan\u00e7ar vida \u00fatil da bateria em aplica\u00e7\u00f5es de me-\ndi\u00e7\u00e3o port\u00e1teis. O dispositivo possui um poderoso CPU RISC de 16 bits, registos de 16\nbits, e geradores constantes que contribuem para a efici\u00eancia m\u00e1xima de c\u00f3digo. O oscila-\ndor controlado digitalmente (DCO) permite wake-up a partir de modos de baixo consumo\npara o modo ativo em menos de 1 mS. Al\u00e9m disso, os membros da fam\u00edlia MSP430 tem\num conversor de 10 bits anal\u00f3gico-para-digital (A/D). As aplica\u00e7\u00f5es t\u00edpicas incluem siste-\nmas de sensores de baixo custo que captura os sinais anal\u00f3gicos, convert\u00ea-los em valores\ndigitais, e depois processar os dados para exibi\u00e7\u00e3o ou para transmiss\u00e3o para um sistema\nhost. A seguir o c\u00f3digo para piscar um LED utilizando a API de programa\u00e7\u00e3o nativa do\nprocessador MSP430.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / / P i s c a Led ? MSP430G2553\n5\n\n6 # i n c l u d e&lt;msp430 . h >\n7\n\n8 i n t m a i n ( v o i d )\n9 {\n\n10 WDTCTL = WDTPW + WDTHOLD; / / D e s a b i l i t a t i m e r d o w a t c h d o g\n11\n\n12 P1DIR = 0 b 0 0 0 0 0 0 0 1 ; / / P1 . 0 \u00e9 uma s a \u00ed d a , P1 .1 ?7 s \u00e3 o e n t r a d a s\n13 P2DIR = 0 b 0 0 0 0 0 0 0 0 ; / / P2 .0 ?7 s \u00e3 o e n t r a d a s\n14\n\n15 / / C o n f i g u r e o M\u00f3dulo B \u00e1 s i c o d o r e l \u00f3 g i o\n16 / / I s s o d e f i n e o r e l \u00f3 g i o d o MSP430 c a l i b r a d o 1 MHz,\n17 DCOCTL = CALDCO_1MHZ ;\n18 BCSCTL1 = CALBC1_1MHZ ;\n19\n\n20 / / l o o p p a r a s e m p r e\n\n\n\n63\n\n21 w h i l e ( 1 )\n22 {\n23 P1OUT = 0 b 0 0 0 0 0 0 0 1 ; / / l i g a d o ? P1 . 0\n24 _ _ d e l a y _ c y c l e s ( 1 0 0 0 0 0 ) ; / / 0 . 1 s e g u n d o d e l a y ( 1 0 0 0 0 0 c i c l o s )\n25 P1OUT = 0 b 0 0 0 0 0 0 0 0 ; / / d e s l i g a d o ? P1 . 0\n26 _ _ d e l a y _ c y c l e s ( 1 0 0 0 0 0 ) ;\n27 }\n28\n\n29 r e t u r n 0 ;\n30 }\n31\n\n32 }\n\nDa para notar que o c\u00f3digo do Pisca LED do microcontrolador Atmega328P e MSP430,\npossuem c\u00f3digos distintos, por\u00e9m executam a mesma a\u00e7\u00e3o, que nesse caso \u00e9 acender e\napagar o LED, cada microcontrolador \u00e9 projetado com um microprocessador, logo cada\num ter\u00e1 seu pr\u00f3prio conjunto de instru\u00e7\u00f5es e bibliotecas. Isso traz pouca flexibilidade\npara o desenvolvimento de sistemas embarcados. N\u00e3o permitindo a extens\u00e3o do c\u00f3digo\ndo projeto para diferentes microprocessadores. Isso pode ser resolvido se ambos os mi-\ncroprocessadores utilizarem a API de desenvolvimento Wiring. Agora, como exemplo,\nser\u00e1 mostrado como utilizar o mesmo c\u00f3digo para o projeto Pisca LED utilizando a API\nWiring para ambos os microcontroladores Atmega328P e MSP430. Isso \u00e9 poss\u00edvel por-\nque cada microcontrolador implementa a API Wiring baseado na arquitetura e instru\u00e7\u00f5es\ndos registradores de cada microprocessador, criando assim um padr\u00e3o de linguagem de\nprograma\u00e7\u00e3o de microcontroladores de alto n\u00edvel.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / / P i s c a Led ? Atm eg a3 2 8 P e MSP430\n5\n\n6 v o i d s e t u p ( ) {\n7 / / i n i c i a l i z a p i n o d i g i t a l 1 3 como o u t p u t .\n8 p in Mo d e ( 7 , OUTPUT ) ;\n9 }\n\n10\n\n11 / / l o o p p a r a s e m p r e\n12 v o i d l o o p ( ) {\n13 d i g i t a l W r i t e ( 1 3 , HIGH ) ; / / L i g a o LED\n14 d e l a y ( 1 0 0 0 ) ; / / E s p e r a 1 s e g u n d o\n15 d i g i t a l W r i t e ( 1 3 , LOW) ; / / a p a g a o LED\n16 d e l a y ( 1 0 0 0 ) ; / / E s p e r a 1 S e g u n d o\n17 }\n18 }\n\nA seguir, \u00e9 apresentado na Figura 26, tr\u00eas IDE\u2019s de microcontroladores distintos que\nimplementam a API Wiring. Da esquerda para direita temos a IDE Energia (Texas), IDE\nArduino (Atmel) e IDE Mpide (PIC). \u00c9 possivel visualizar que ambos os microcontro-\nladores, cada qual com seu microprocessador, agora partilham do mesmo c\u00f3digo para o\nprojeto Pisca LED.\n\nLevando-se em considera\u00e7\u00e3o a flexibilidade e portabilidade de utilizar essas plata-\nformas de hardware e software open-source, as implementa\u00e7\u00f5es dos c\u00f3digos e bibliote-\ncas dos estudos de caso do projeto ser\u00e3o desenvolvidos baseados na API Wiring, assim\n\u00e9 poss\u00edvel desenvolver os m\u00f3dulos dos componentes eletr\u00f4nicos do projeto, com baixo\nacoplamento.\n\n\n\n64\n\nFigura 26: IDE\u2019s dos Frameworks citados.\n\n4.2 Introdu\u00e7\u00e3o \u00e0 proposta EduBOT\n\nBusca-se com o emprego das tecnologias na educa\u00e7\u00e3o, uma melhor qualidade do en-\nsino e ambientes de aprendizagem mais ricos e motivadores para os discentes. Dentre o\namplo espectro de ideias e propostas, no que se refere aos artefatos computacionais, \u00e9 no-\nt\u00f3rio observar que as solu\u00e7\u00f5es exploram, em sua maioria, apenas a vertente de software.\nNo entanto, a demanda por novos aparatos de hardware vem crescendo sendo evidenci-\nada, sobretudo, pelos esfor\u00e7os da comunidade acad\u00eamica em propor a inser\u00e7\u00e3o da rob\u00f3-\ntica com fins pedag\u00f3gicos. No contexto educacional, a utiliza\u00e7\u00e3o da rob\u00f3tica pode ampliar\nsignificativamente a gama de atividades que podem ser desenvolvidas e promover a inte-\ngra\u00e7\u00e3o entre diferentes \u00e1reas do conhecimento. A constru\u00e7\u00e3o de um novo mecanismo, ou\na busca pela solu\u00e7\u00e3o de um novo problema obriga o aluno a buscar conceitos em diver-\nsas disciplinas. A rob\u00f3tica tem, em tal contexto, um grande potencial como ferramenta\ninterdisciplinar, religando fronteiras anteriormente estabelecidas entre v\u00e1rias disciplinas,\npossibilitando aos alunos ter uma viv\u00eancia, na pr\u00e1tica, do m\u00e9todo cient\u00edfico, simulando\nmecanismos, atrav\u00e9s da constru\u00e7\u00e3o de prot\u00f3tipos (SILVA, 2009).\n\nAlguns projetos pedag\u00f3gicos de rob\u00f3tica em sala de aula fazem uso, por exemplo,\nda metarreciclagem de lixo computacional para incentivar a criatividade sustent\u00e1vel na\nera digital, como por exemplo, o projeto EduBOT-v0.1 (EDUBOT, 2014). O projeto\napresenta uma plataforma rob\u00f3tica para educa\u00e7\u00e3o para auxiliar no ensino de componentes\nde hardware (mec\u00e2nica e eletr\u00f4nica) e software (programa\u00e7\u00e3o). O projeto \u00e9 aberto e\nencontra-se dispon\u00edvel na internet. O rob\u00f4 \u00e9 baseado em projetos de desenho CAD abertos\npara a constru\u00e7\u00e3o (MARTINS, 2011), Figura 27 .\n\nO trabalho foi aplicado com alunos dos cursos de gradua\u00e7\u00e3o de Ci\u00eancia da Compu-\nta\u00e7\u00e3o e Sistemas de Informa\u00e7\u00f5es da Universidade Regional Integrada do Alto Uruguai e\ndas Miss\u00f5es, Campus Santo \u00c2ngelo-RS (EDUBOT, 2014). Foram desenvolvidos rob\u00f4s\nm\u00f3veis utilizando equipamentos descartados da universidade (Metareciclagem), dando\norigem ao primeiro (I/2011) e segundo (II/2011) torneio de Rob\u00f3tica Livre da URI. Esse\nprojeto de pesquisa foi desenvolvido em conjunto com o Departamento de Engenharias e\nCi\u00eancia da Computa\u00e7\u00e3o da universidade. Os torneios tiveram como base as plataformas\nrob\u00f3ticas m\u00f3veis desenvolvidas para navega\u00e7\u00e3o dentro de labirintos, o projeto teve inicio\nsobre os estudos e projetos de sistemas computacionais embarcados de software e hard-\nware do autor(2010), durante o curso de Ci\u00eancia da Computa\u00e7\u00e3o. A Figura 28, apresenta\nas valida\u00e7\u00f5es dos rob\u00f4s m\u00f3veis nos torneios.\n\n\n\n65\n\nProjeto C ce \n\nduBOT-v0.1\n\nFigura 27: Projeto EduBOT-v0.1. Fonte: (EDUBOT, 2014; MARTINS, 2011).\n\nFigura 28: Torneios de rob\u00f3tica libre utilizando as plataformas rob\u00f3ticas montadas. Fonte:\n(EDUBOT, 2014; MARTINS, 2011).\n\n\n\n66\n\nCom o decorrer do tempo, o projeto passou a ter novas vers\u00f5es, EduBOT-v2 e v3\n(GUIMAR\u00c3ES; TAMAYO; HENRIQUES, 2014). O novo projeto n\u00e3o utiliza metaricla-\ngem, pois pretende-se navegar de maneira coordenada desde uma localiza\u00e7\u00e3o de origem\nat\u00e9 uma localiza\u00e7\u00e3o final em um ambiente de forma controlada. Para isso os modelos\ncinem\u00e1ticos e din\u00e2micos que permitem a descri\u00e7\u00e3o do sistema de controle devem ser\nconsiderados. O projeto vem sendo aplicado em discentes do ensino superior de engenha-\nria da UFRGS. Para a integra\u00e7\u00e3o dos componentes f\u00edsicos de maneira modular \u00e9 levado\nem considera\u00e7\u00e3o diferentes kits de rob\u00f4s m\u00f3veis existentes (SILVA, 2009; MIRANDA;\nSAMPAIO; BORGES, 2010), o modelo definido para reutiliza\u00e7\u00e3o e refer\u00eancia dos com-\nponentes mec\u00e2nicos e eletromec\u00e2nicos do projeto EduBOT, s\u00e3o baseados nos modelos de\nrob\u00f4s m\u00f3veis da Pololu (POLOLU, 2014), Figura 29.\n\nProjeto C omponentes mec etromec\n\nProjeto e v3\n\nR????\n\nFigura 29: Projeto EduBOT-V0.2. Fonte: (GUIMAR\u00c3ES; TAMAYO; HENRIQUES,\n2014).\n\nO rob\u00f4 tipo uniciclo \u00e9, em geral, o eleito por pesquisadores para experimentar novas\nestrat\u00e9gias de controle por possuir uma cinem\u00e1tica simples. \u00c9 uma estrutura formada por\nduas rodas fixas convencionais, sobre um mesmo eixo, controladas de maneira indepen-\n\n\n\n67\n\ndente, e por uma roda passiva que lhe confere estabilidade. O sistema de tra\u00e7\u00e3o-dire\u00e7\u00e3o\nassociado ao rob\u00f4 lhe permite controlar de forma independente suas velocidades linear e\nangular. As vantagens que derivam de sua estrutura mec\u00e2nica e da eletr\u00f4nica de controle\nfazem desta configura\u00e7\u00e3o a preferida para rob\u00f4s de laborat\u00f3rio (SECCHI, 2008).\n\nOs prot\u00f3tipos desenvolvidos do EduBOT v2 e v3 foram aplicados nos discentes da\ngradua\u00e7\u00e3o de Engenharia da Computa\u00e7\u00e3o, Engenharia El\u00e9trica e Engenharia de Controle e\nAutoma\u00e7\u00e3o da UFRGS, ENG04009 - Turma U (2013/2), ENG04009 - Turma U (2014/1),\nCCA99003 - Turma A (2014/1), ENG04479 -Turma U (2014/2) e ENG04009 - Turma\nU (2014/2). A Figura 30, apresenta algumas imagens das aplica\u00e7\u00f5es do projeto com as\nturmas.\n\nFigura 30: Valida\u00e7\u00e3o do projeto EduBOT-V0.2 com os estudantes. Fonte: (GUIMA-\nR\u00c3ES; TAMAYO; HENRIQUES, 2014).\n\nA seguir \u00e9 apresentado o fluxograma de um algoritmo aplicado com os estudantes de\nsimples solu\u00e7\u00e3o de labirinto, o qual n\u00e3o usa mem\u00f3ria extra e \u00e9 de f\u00e1cil implementa\u00e7\u00e3o,\nFigura 31. O principio \u00e9 come\u00e7ar a seguir paredes, e sempre que voc\u00ea chegar a um\ncruzamento sempre vire \u00e0 direita (ou esquerda, mas sempre para o mesmo lado). Equi-\nvalente a um ser humano resolver um labirinto, colocando a m\u00e3o sobre a parede direita\nou esquerda) e segui-l\u00e1 at\u00e9 encontrar uma sa\u00edda. Tamb\u00e9m \u00e9 poss\u00edvel marcar caminhos ou\nc\u00e9lulas que foram visitadas, para poder refazer a solu\u00e7\u00e3o seguindo essas c\u00e9lulas posteri-\normente. Este m\u00e9todo n\u00e3o ir\u00e1 necessariamente encontrar a solu\u00e7\u00e3o mais curta, mas ir\u00e1\nencontrar a sa\u00edda caso haja uma. Esse algoritmo pode ser visto em funcionamento em\nv\u00eddeo (GUIMAR\u00c3ES, 2015).\n\nPara as turmas de semestres iniciais \u00e9 utilizado paradigma de programa\u00e7\u00e3o procedu-\nral, j\u00e1 para turmas de semestres avan\u00e7ados s\u00e3o utilizados paradigmas da programa\u00e7\u00e3o\norientado a objetos, cada grupo deve desenvolver algoritmos aut\u00f4nomos para resolver um\npequeno labirinto. O c\u00f3digo abaixo, mostra a estrutura parcial de um dos c\u00f3digos que\ns\u00e3o passados aos estudantes, a fim de servir como refer\u00eancia inicial para a programa\u00e7\u00e3o\nprocedural do rob\u00f4 EduBOT v3. O c\u00f3digo \u00e9 passado incompleto para os estudantes para\nque eles completem a estrutura e l\u00f3gica da programa\u00e7\u00e3o procedural atrav\u00e9s do processo\nde heur\u00edstica do projeto.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / ? E s t r u t u r a p a r c i a l d e um d o s c \u00f3 d i g o p r o c e d u r a l d i s t r i b u \u00ed d o p a r a o s\n\ne s t u d a n t e s . O r o b \u00f4 p o s s u i d o i s m o t o r e s DC i n d e p e n d e n t e s , s o n a r ,\n\n\n\n68\n\nINICIO\n\nObst\u00e1culo a Direita?Mover para Frente\n\nObst\u00e1culos a Frente? Girar para Direita 90 graus\n\nGirar para Esquerda 90 graus\n\nN\u00e3o\n\nSim\n\nSim\n\nN\u00e3o\n\nFigura 31: Fluxograma para algoritmo seguidor de parede. Fonte: (GUIMAR\u00c3ES; TA-\nMAYO; HENRIQUES, 2014).\n\nm o t o r s e r v o , b o t \u00f5 e s f i m d e c u r s o e s e n s o r e s i n f r a v e r m e l h o s . Cad a\ng r u p o d e v e i m p l e m e n t a r a s u a l \u00f3 g i c a d e p r o g r a m a \u00e7 \u00e3 o ! ? /\n\n5\n\n6 / / D e c l a r a \u00e7 \u00e3 o d a s b i b l i o t e c a s u t i l i z a d a s\n7 # i n c l u d e &lt;S e r v o . h >\n8 :\n9 :\n\n10 / / p r o t \u00f3 t i p o s d a s f u n \u00e7 \u00f5 e s\n11\n\n12 / / D e c l a r a \u00e7 \u00e3 o d e c o n s t a n t e s e v a r i \u00e1 v e i s g l o b a i s\n13\n\n14 / / p i n o s d i g i t a i s I / O Mo to r , S o n a r , B o t \u00f5 e s , e t c . . .\n15 c o n s t i n t pinEpwm = 3 ; / /PWM p a r a o m o t o r e s q u e r d o\n16 c o n s t i n t p i n E a = 5 ; / / p i n o 1 m o t o r e s q u e r d o\n17 c o n s t i n t p i n E b = 6 ; / / p i n o 2 m o t o r e s q u e r d o\n18 :\n19 :\n20 v o i d s e t u p ( ) {\n21 / / c o m u n i c a \u00e7 \u00e3 o S \u00e9 r i e ? USB .\n22 S e r i a l . b e g i n ( 9 6 0 0 ) ;\n23 / / f u n \u00e7 \u00e3 o p a r a s e t a r o s p i n o s d o s m o t o r e s ( OUTPUT ) .\n24 s e t u p M o v e ( ) ;\n25 / / f u n \u00e7 \u00e3 o p a r a s e t a r o s p i n o s d o S e n s o r SR04\n26 s e t u p U l t r a s o n i c ( ) ;\n27 :\n28 :\n29 }\n30 v o i d l o o p ( ) {\n\n\n\n69\n\n31 u n s i g n e d i n t d i s t = 0 ;\n32 / / r e t o r n a a d i s t \u00e2 n c i a em cm\n33 d i s t = l e D i s t a n c i a ( ) ;\n34 :\n35 :\n36 / / c h a m a d a d a f u n \u00e7 \u00e3 o p a r a o s m o t o r e s\n37 m o v e r F r e n t e ( ) ;\n38 d e l a y ( 1 0 0 0 ) ;\n39 :\n40 :\n41 }\n42 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o d o s m o t o r e s p a r a f r e n t e .\n43 v o i d m o v e r F r e n t e ( ) {\n44 }\n45 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o d o s m o t o r e s p a r a t r \u00e1 s .\n46 v o i d m o v e r T r a s ( ) {\n47 }\n48 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o d o s m o t o r e s p a r a e s q u e r d a .\n49 v o i d m o v e r E s q u e r d a ( ) {\n50 }\n51 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o d o s m o t o r e s p a r a d i r e i t a .\n52 v o i d m o v e r D i r e i t a ( ) {\n53 }\n54 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o p a r a p a r a r o s m o t o r e s .\n55 v o i d m o v e r P a r a ( ) {\n56 }\n57 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o p a r a s e t a r o s p i n o s d o s m o t o r e s como O u t p u t\n58 v o i d s e t u p M o v e r ( ) {\n59 }\n60 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o d o s e n s o r SR04 . R e t o r n a r a d i s t \u00e2 n c i a em cm .\n61 u n s i g n e d i n t l e D i s t a n c i a ( ) {\n62 }\n63 / / I m p l e m e n t a r f u n \u00e7 \u00e3 o p a r a s e t a r o s p i n o s d o s e n s o r SR04\n64 v o i d s e t u p U l t r a s o n i c ( ) {\n65 }\n\nPara os estudantes de semestres mais avan\u00e7ados s\u00e3o pedidos as implementa\u00e7\u00f5es de\npelo menos duas das bibliotecas dos componentes eletr\u00f4nicos utilizados no rob\u00f4 Edu-\nBOT v3. Eles devem criar as classes em C++ seguindo as boas praticas de programa-\n\u00e7\u00e3o, separando a modelagem da estrutura da classe em arquivos com extens\u00f5es .h e .cpp.\nDepois de implementado as bibliotecas os estudantes devem criar um arquivo principal\n(main.ino) para instanciar os objetos das classes e criar a l\u00f3gica de programa\u00e7\u00e3o conforme\nos requisitos do problema ser a resolvido.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / ? P r o g r a m a Main d i s t r i b u \u00ed d o p a r a o s e s t u d a n t e s p a r a p r o g r a m a \u00e7 \u00e3 o\n\no r i e n t a d o a o b j e t o s . Cad a g r u p o d e v e i m p l e m e n t a r p e l o menos d u a s\nb i b l i o t e c a s d o s c o m p o n e n t e s u t i l i z a d o s n o p r o j e t o ! ? /\n\n5\n\n6 / / D e c l a r a \u00e7 \u00e3 o d a s b i b l i o t e c a s u t i l i z a d a s\n7 # i n c l u d e &lt;S e r v o . h > / / r e u t i l i z a d o d o A r d u i n o\n8 # i n c l u d e&lt;DCMotorBot . h > / / i m p l e m e n t a r d o z e r o ( . h e . c p p )\n9 # i n c l u d e &lt;S o n a r . h > / / i m p l e m e n t a r d o z e r o ( . h e . c p p )\n\n10 :\n11 :\n12 / / D e c l a r a \u00e7 \u00e3 o d e c o n s t a n t e s e v a r i \u00e1 v e i s g l o b a i s\n\n\n\n70\n\n13\n\n14 / / p i n o s d i g i t a i s I / O Mo to r , S o n a r , B o t \u00f5 e s , e t c . . .\n15 c o n s t i n t pinE1pwm = 3 ; / /PWM p a r a o m o t o r e s q u e r d o\n16 c o n s t i n t p i n E a = 5 ; / / p i n o 1 m o t o r e s q u e r d o\n17 c o n s t i n t p i n E b = 6 ; / / p i n o 2 m o t o r e s q u e r d o\n18 :\n19 :\n20 / / c r i a \u00e7 \u00e3 o d o s o b j e t o s\n21 S e r v o m y s e r v o ;\n22 DCMotorBot MyMotors = DCMotorBot ( ) ;\n23 S o n a r s r 0 4 ( p i n T r i g , p i n E c h o , MAX_DISTANCE ) ;\n24 :\n25 :\n26 v o i d s e t u p ( ) {\n27 m y s e r v o . a t t a c h ( 1 0 ) ; / / p i n o d i g i t a l\n28 m y s e r v o . w r i t e ( 9 0 ) ; / / m o t o r s e r v o em 9 0 g r a u s\n29 / / o b j e t o MyMotors u t i l i z a n d o o s m \u00e9 t o d o s d a c l a s s e\n30 MyMotors . s e t E n a b l e P i n s ( pinE1pwm , pinE2pwm ) ;\n31 MyMotors . s e t C o n t r o l P i n s ( p i n E a , p i n E b , p i n D a , p i n D b ) ;\n32 :\n33 :\n34 }\n35 v o i d l o o p ( ) {\n36 u n s i g n e d i n t d i s t = 0 ;\n37 / / o g j e t o s r 0 4 r e t o r n a a d i s t \u00e2 n c i a em cm\n38 d i s t = s r 0 4 . p i n g _ c m ( ) ; ;\n39 :\n40 :\n41 / / c h a m a d a d a f u n \u00e7 \u00e3 o p a r a o s m o t o r e s\n42 MyMotors . m o v e F o r w a r d ( ) ;\n43 d e l a y ( 1 0 0 0 ) ;\n44 :\n45 :\n46 }\n\nPara melhorar a manuten\u00e7\u00e3o do c\u00f3digo, \u00e9 prefer\u00edvel sempre manter dois arquivos\npara cada classe, um para declara\u00e7\u00e3o (arquivo .h ou .hpp) e outro para a implementa\u00e7\u00e3o\n(arquivo .cpp). E de prefer\u00eancia evitar colocar mais de uma classe num \u00fanico arquivo,\na n\u00e3o ser que as classes sejam extremamente dependentes uma da outra. Vejamos um\nexemplo de como fica o arquivo .h para a biblioteca do componente eletr\u00f4nico Sonar.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / ? E x em p lo d a m o d elag em d a c l a s s e S o n a r . h ? /\n5\n\n6 / / d i r e t i v a s d e c o m p i l a \u00e7 \u00e3 o c o n d i c i o n a l , v e r i f i c a s e um d e t e r m i n a d o\ni d e n t i f i c a d o r f o i d e f i n i d o\n\n7 # i f n d e f S o n a r _ H\n8\n\n9 / / c o m p i l a n d o o u n \u00e3 o p a r t e d o c \u00f3 d i g o f o n t e . Se v e r d a d e i r o , d e f i n e e\nc o m p i l a t o d o c \u00f3 d i g o f o n t e\n\n10 # d e f i n e S o n a r _ H\n11\n\n12 / / D i r e t i v a d o p r \u00e9?p r o c e s s a d o r com e s t r u t u r a c o n d i c i o n a l\n13 # i f d e f i n e d ( ARDUINO) &amp;&amp; ARDUINO >= 1 0 0\n14 / / Se o H a r d w a r e A r d u i n o e s t i v e r c o n e c t a d o s e r \u00e1 u t i l i z a d o a\n\nb i b l i o t e c a \" A r d u i n o \"\n\n\n\n71\n\n15 # i n c l u d e \" A r d u i n o . h \"\n16 # e l s e\n17 / / C a s o c o n t r a r i o s e r a u t i l i z a d a a b i b l i o t e c a \" W i r i n g \" .\n18 # i n c l u d e \" WProgram . h \"\n19 # e n d i f\n20\n\n21 / / a r q u i v o d e c a b e \u00e7 a l h o q u e f a z p a r t e d o C s t a n d a r d l i b r a r y e API ( known\na s C99 ) .\n\n22 # i n c l u d e &lt;i n t t y p e s . h >\n23\n\n24 / / v a l o r e s c o n s t a n t e s , d a d o s g r a v a d o s em m e m \u00f3 r i a\n25 # d e f i n e PULSE_TIMEOUT 1 5 0 0 0 0L\n26 # d e f i n e DEFAULT_DELAY 1 0\n27 # d e f i n e DEFAULT_PINGS 5\n28\n\n29 c l a s s S o n a r { / / C l a s s e d o s o n a r HC?SR04 ;\n30\n\n31 p u b l i c : / / v i s i b i l i d a d e : v i s \u00ed v e l em q u a l q u e r c l a s s e\n32\n\n33 / ? C o n s t r u t o r\n34 ? S e n s o r d e u l t r a ?SR04 , q u a t r o p i n o s d e c o n e x \u00f5 e s\n35 ? VCC, ECHO, TRIGGER , GND ?\n36 ? Par am e c h o P i n e n t r a d a d i g i t a l P i n o p a r a m e d i r a d i s t \u00e2 n c i a\n37 ? Par am t r i g g e r P i n um s i n a l a l t o d e 1 0 uS e n v i a d o p e l o\n\nm i c r o c o n t r o l a d o r\n38 ? p a r a o t r a n s m i s s o r d o SR04\n39 ? ? /\n40 S o n a r ( i n t e c h o P i n , i n t t r i g g e r P i n ) ;\n41\n\n42 / ? ? F a z uma m e d i \u00e7 \u00e3 o p a r a e s t e s e n s o r . R e t o r n a a d i s t a n c i a em\nc e n t \u00ed m e t r o s ? /\n\n43 l o n g d i s t a n c i a ( ) ;\n44\n\n45 / ? ? c a l c u l a m \u00e9 d i a .\n46 ? Par am a t r a s o d e E s p e r a , p a d r \u00e3 o = DEFAULT_DELAY / ms\n47 ? Par am Co n tag em d e n u m er o d e m e d i \u00e7 \u00f5 e s e P a d r \u00e3 o DEFAULT_PINGS\n48 ? R e t o r n a d i s t a n c i a em c e n t \u00ed m e t r o s ? /\n49 l o n g d i s t a n c i a M e d i a ( i n t w a i t =DEFAULT_DELAY , i n t c o u n t =DEFAULT_PINGS )\n\n;\n50\n\n51 / ? ? E s t e m e t o d o s o n a r P i n g r e c e b e o r e t o r n o d e \" d i s t a n c i a ( ) \" ? /\n52 v o i d s o n a r P i n g ( ) ;\n53\n\n54 / ? ? r e t o r n a a \u00fa l t i m a d i s t \u00e2 n c i a d o m e t o d o \" s o n a r P i n g ( ) \" ? /\n55 l o n g g e t D i s t a n c i a ( ) ;\n56\n\n57 p r i v a t e : / / v i s i b i l i d a d e : v i s \u00ed v e l s o m e n t e d e n t r o d a c l a s s e\n58\n\n59 / ? ? F a z o c \u00e1 l c u l o d e m i l i s e g u n d o s p a r a c e n t i m e t r o s\n60 ? r e c e b e como p a r a m e t r o o t e m p o em m i l i s e g u n d o s d o s o n a r\n61 ? o c a l c u l o l e v a em c o n s i d e r a c a o V e l o c i d a d e d o som 3 4 0m/ s e c ( e s s e\n\nv a l o r v a r i a c o n f o r m e a t e m p e r a t u r a d o a m b i e n t e )\n62 ? A d u r a \u00e7 \u00e3 o em m i l i s e g u n d o s / 5 8 8 2 ? 1 0 0 = d i s t \u00e2 n c i a em cm ? /\n63 l o n g m i c r o s e g u n d o s P C e n t i m e t r o s ( l o n g d u r a c a o ) ;\n64\n\n65 / / p r o p r i a d a d e s d a c l a s s e S o n a r\n66 i n t _ e c h o P i n , _ t r i g g e r P i n ; / / p i n o s d o uC\n67 l o n g _ d u r a c a o , _ d i s t a n c i a ; / / v a r i a v e i s d e a r m a z e n a m e n t o e c o n t r o l e ;\n\n\n\n72\n\n68 b o o l _ a u t o M o d e ;\n69 l o n g _ a t u a l D i s t a n c i a ;\n70 } ;\n71 # e n d i f\n\n4.3 Rob\u00f4 M\u00f3vel N\u00e3o-Holon\u00f4mico com Acionamento Diferencial\n\nA morfologia escolhida para o rob\u00f4 m\u00f3vel educacional EduBOT \u00e9 do tipo uniciclo\n(SIEGWART; NOURBAKHSH, 2004). Os modelos cinem\u00e1ticos e din\u00e2micos ser\u00e3o apre-\nsentados parcialmente nas subse\u00e7\u00f5es posteriores. No que se refere ao projeto do rob\u00f4\nm\u00f3vel, a proposta faz uso de ferramentas open-source para diminuir o tempo e os custos\nde projeto. O software do sistema do rob\u00f4 m\u00f3vel possui componentes implementados\nem C++ e est\u00e3o inseridos na biblioteca do framework SOA. A Figura 32 apresenta a\narquitetura de blocos do rob\u00f4 m\u00f3vel, novos blocos podem ser adicionados ou removidos\nconforme as necessidades dos requisitos do projeto. O rob\u00f4 m\u00f3vel EduBOT vem sendo\nvalidado em diferentes cursos de Engenharia da Universidade Federal do Rio Grande do\nSul (UFRGS): Engenharia El\u00e9trica, Engenharia da Computa\u00e7\u00e3o e Engenharia de Controle\ne Automa\u00e7\u00e3o.\n\nM\u00f3dulos e Sensores\n\nSensor\n\nInercial \n\nSensor\n\nIR\n\nSensor\n\nSonar\n\n  \n\nServo\n\n Motor \n\nFigura 32: Diagrama de blocos para o rob\u00f4 m\u00f3vel uniciclo. Fonte: Autor.\n\nO projeto mec\u00e2nico do projeto foi atualizado recentemente para a vers\u00e3o EduBOT-\nv0.3. Na Figura 33 \u00e9 apresentado o desenho parcial em 2D e 3D do prot\u00f3tipo do rob\u00f4\nm\u00f3vel uniciclo. A plataforma de suporte ou chassi \u00e9 a base para a fixa\u00e7\u00e3o dos componen-\ntes de hardware que constituem o rob\u00f4 m\u00f3vel. O desenho do chassi da base do rob\u00f4 m\u00f3-\nvel \u00e9 mapeado para os elementos mec\u00e2nicos e eletromec\u00e2nicos como: motores, sensores,\nrodas, baterias, parafusos e demais componentes de hardware que s\u00e3o projetados e dese-\nnhados em software CAD de maneira modular e bem organizada (SOLIDWORKS, 2014).\nPara automatizar a fase de projeto, alguns dos componentes de hardware CAD (mec\u00e2nicos\ne eletromec\u00e2nicos) s\u00e3o projetados e alguns componentes reutilizados, podendo-se tornar\num projeto simples ou complexo dependendo dos requisitos necess\u00e1rios para a aplica\u00e7\u00e3o.\n\nExiste uma grande variedade de componentes eletromec\u00e2nicos que podem ser esco-\nlhidos para o prot\u00f3tipo. A Figura 34 apresenta o desenho 3D com mapeamento parcial\ndos componentes do hardware para o projeto do EduBOT-v0.3.\n\nOs sensores s\u00e3o dispositivos essenciais em um sistema de controle para rob\u00f3tica. Eles\n\n\n\n73\n\nFigura 33: Projeto EduBOT-v0.3. Fonte: Eduardo Henrique Maciel e Autor.\n\nFigura 34: Tabela com mapeamento parcial dos diferentes componentes de hardware do\nprojeto EduBOT-v0.3. Fonte: Eduardo Henrique Maciel e Autor.\n\n\n\n74\n\nser\u00e3o utilizados no rob\u00f4 m\u00f3vel para dar sinais de refer\u00eancia sobre cada tarefa a ser exe-\ncutada. Isto significa que um sensor \u00e9 um dispositivo que converte um est\u00edmulo f\u00edsico\nou uma vari\u00e1vel de interesse (tal como uma dist\u00e2ncia de um objeto) em uma forma mais\nconveniente (em geral em um sinal el\u00e9trico), cujo prop\u00f3sito \u00e9 medir o est\u00edmulo.\n\nNos sistemas de controle, um atuador \u00e9 um dispositivo de hardware que converte um\nsinal de comando do controlador em uma mudan\u00e7a em um par\u00e2metro f\u00edsico. Um atuador\n\u00e9 um transdutor, visto que transforma um tipo de quantidade f\u00edsica, como uma corrente\nel\u00e9trica, em outro tipo de quantidade f\u00edsica, como uma velocidade de rota\u00e7\u00e3o de um motor\nel\u00e9trico.\n\nAs duas rodas fixas de tra\u00e7\u00e3o do rob\u00f4 m\u00f3vel s\u00e3o acionadas por motores CC atrav\u00e9s da\nponte-h que envia de acordo com o controle do microcontrolador corrente suficiente para\nproduzir o torque que aciona o rotor. A magnitude do torque do rotor \u00e9 de acordo com a\ncorrente que circula atrav\u00e9s do enrolamento.\n\n4.3.1 Modelo Cinem\u00e1tico e Din\u00e2mico\n\nPara se ter uma ideia clara do movimento de um rob\u00f4 m\u00f3vel, \u00e9 de absoluta necessidade\nconhecer o seu modelo, o qual pode ser dividido em duas partes: um modelo cinem\u00e1tico e\num modelo din\u00e2mico. O modelo cinem\u00e1tico corresponde \u00e0s caracter\u00edsticas geom\u00e9tricas e\n\u00e0s restri\u00e7\u00f5es de movimentos do rob\u00f4 m\u00f3vel, enquanto que o modelo din\u00e2mico representa\ncomo o rob\u00f4 m\u00f3vel responde \u00e0s entradas de controle que produzem o seu movimento no\ndecorrer do tempo, levando em conta a sua massa e o modelo din\u00e2mico dos seus atuadores,\npor exemplo. (LAGES, 1998).\n\n4.3.2 Modelo Cinem\u00e1tico do Rob\u00f4 Uniciclo\n\nO rob\u00f4 m\u00f3vel possui uma estrutura formada por duas rodas fixas convencionais, con-\ntroladas de maneira independente, e por uma roda de apoio do tipo rodas esf\u00e9ricas (castor\nwheel), que caracteriza-se como uma roda passiva ou orient\u00e1vel n\u00e3o centrada. O modelo\ncinem\u00e1tico do rob\u00f4 m\u00f3vel do tipo uniciclo est\u00e1 baseado nas seguintes considera\u00e7\u00f5es: o\nrob\u00f4 \u00e9 constitu\u00eddo por um chassi r\u00edgido e rodas n\u00e3o-deform\u00e1veis, que se movem em um\nplano horizontal. Assume-se que o plano das rodas permanece na vertical durante a mo-\nvimenta\u00e7\u00e3o, com a rota\u00e7\u00e3o se dando em torno de um eixo horizontal cuja orienta\u00e7\u00e3o \u00e9\nfixa ou vari\u00e1vel com rela\u00e7\u00e3o a um sistema de coordenadas associado ao corpo do rob\u00f4,\n{Xc, Yc, ?c}, descrito em rela\u00e7\u00e3o ao sistema inercial {X0, Y0, ?0}, com ? sendo o \u00e2ngulo\nque define a orienta\u00e7\u00e3o do rob\u00f4. A partir da Figura 35 pode-se definir o vetor 0?c que\ncont\u00e9m as coordenadas da pose do rob\u00f4 e a matriz 0Rc que expressa a orienta\u00e7\u00e3o do rob\u00f4\nem rela\u00e7\u00e3o ao sistema inercial {X0, Y0, ?0}, dessa forma, tem-se que a sua postura \u00e9 dada\npelo vetor (3x1).\n\n0?c =\n\n?\n\n?\n\nXc\nYc\n?c\n\n?\n\n? (1)\n\n0Rc?c =\n\n?\n\n?\n\ncos(?c) ?sin(?c) 0\nsin(?c) cos(?c) 0\n\n0 0 1\n\n?\n\n? (2)\n\nAinda, a velocidade do rob\u00f4 descrita em rela\u00e7\u00e3o ao sistema inercial pode ser dada por:\n\n\n\n75\n\n0??c =\n\n?\n\n?\n\nX?c\nY?c\n??c\n\n?\n\n? (3)\n\ne descrita no sistema {X0, Y0, ?0} por\nc??c =\n\nc R0\n0??c, com\n\ncR0 dado por:\n\ncR0 =\n0 R?1c =\n\n0 RTc =\n\n?\n\n?\n\ncos(?c) sin(?c) 0\n?sin(?c) cos(?c) 0\n\n0 0 1\n\n?\n\n? (4)\n\nConsidera-se que o contato entre as superf\u00edcies das rodas e do piso satisfaz as con-\ndi\u00e7\u00f5es de rota\u00e7\u00e3o pura, isto \u00e9, uma velocidade constante de rota\u00e7\u00e3o das rodas equivale a\numa velocidade constante de transla\u00e7\u00e3o das mesmas.\n\n?c\n\nX0\n\nY0\n\nX c\nYc\n\nxc\n\nyc\n\nFigura 35: Esquema para obten\u00e7\u00e3o do modelo cinem\u00e1tico do rob\u00f4 m\u00f3vel uniciclo.\n\nAl\u00e9m disso, em cada instante de tempo, o movimento do rob\u00f4 pode ser visto como\numa rota\u00e7\u00e3o instant\u00e2nea ao redor do seu Centro Instant\u00e2neo de Rota\u00e7\u00e3o (CIR), que no\ncaso do rob\u00f4 m\u00f3vel uniciclo encontra-se no eixo central que conecta as suas rodas, con-\nforme mostra a Figura 36. Na figura, ve e vd representam, respectivamente, as velocidades\ndas rodas esquerda e direita, ambas em rela\u00e7\u00e3o ao solo, e R \u00e9 o raio de curvatura instan-\nt\u00e2neo da trajet\u00f3ria do rob\u00f4, isto \u00e9, a dist\u00e2ncia do CIR ao ponto central do eixo virtual que\nconecta as suas rodas.\n\nDesse modo, se ve = vd, ent\u00e3o o raio R \u00e9 infinito e o rob\u00f4 move-se em linha reta. Por\noutro lado, se ve = ?vd, ent\u00e3o o raio R \u00e9 zero e o rob\u00f4 gira ao redor do ponto central do\neixo virtual que conecta as suas rodas. Para qualquer outro valor de ve e vd o rob\u00f4 move-\nse em linha curva, ao redor do seu CIR, o qual est\u00e1 situado a uma dist\u00e2ncia R do ponto\ncentral do eixo virtual que conecta as suas rodas, alterando tanto a sua posi\u00e7\u00e3o quanto a\nsua orienta\u00e7\u00e3o.\n\nAinda, podemos descrever o modelo cinem\u00e1tico de postura do rob\u00f4 uniciclo, em no-\nta\u00e7\u00e3o matricial, dado por\n\n?\n\n?\n\nX?c\nY?c\n??c\n\n?\n\n? =\n\n?\n\n?\n\ncos(?c) ?sin(?c)\nsin(?c) cos(?c)\n\n0 1\n\n?\n\n?\n\n[\n\nu\n?\n\n]\n\n, (5)\n\n\n\n76\n\n0\n\n0\n\nve\n\nvd\n\nFigura 36: Representa\u00e7\u00e3o do CIR do rob\u00f4 m\u00f3vel uniciclo.\n\nonde a velocidade linear u e a velocidade angular ? s\u00e3o as entradas de controle. O\nponto central \u00e9 fixo em rela\u00e7\u00e3o ao eixo que conecta as rodas do rob\u00f4 uniciclo e pode ser\ndeterminado pelos eixos X0 e Y0 do sistema de coordenadas no plano cartesiano. Cabe\nmencionar, no entanto, que em rob\u00f4s reais, sinais de entrada desse tipo n\u00e3o podem ser\naplicados aos rob\u00f4s diretamente, uma vez que o acionamento dos mesmos \u00e9 feito por\nmotores el\u00e9tricos. Em virtude disso, as velocidades s\u00e3o aplicadas indiretamente, atrav\u00e9s\nde um controle de velocidade de baixo n\u00edvel. Al\u00e9m disso, \u00e9 poss\u00edvel considerar que as\nvelocidades u e ? s\u00e3o desenvolvidas instantaneamente, desde que as mesmas sejam baixas\ne a in\u00e9rcia do rob\u00f4 seja pequena.\n\nPor fim, tem-se que o rob\u00f4 m\u00f3vel uniciclo \u00e9 control\u00e1vel. Isto significa que ele sempre\npode ser conduzido de uma postura inicial ?0 a uma postura final ?f em um tempo finito,\npor meio da manipula\u00e7\u00e3o dos seus sinais de entrada (LAGES, 1998).\n\n4.3.3 Modelo Din\u00e2mico do Rob\u00f4 Uniciclo\n\nConforme mencionado na subse\u00e7\u00e3o anterior, pode-se supor que as velocidades de-\nsenvolvidas pelo rob\u00f4 rastreiam perfeitamente as entradas de controle, sob condi\u00e7\u00e3o de\nque as velocidades e a in\u00e9rcia do rob\u00f4 sejam baixas. Sendo assim, essa considera\u00e7\u00e3o\nn\u00e3o \u00e9 v\u00e1lida para muitas aplica\u00e7\u00f5es importantes, onde, por exemplo, os rob\u00f4s precisam\ndesenvolver velocidades altas e/ou transportar cargas pesadas. Nesses casos, \u00e9 essencial\nconsiderar a din\u00e2mica do rob\u00f4, pois ela passa a ter grande influ\u00eancia na realiza\u00e7\u00e3o dos\nseus movimentos.\n\nO modelo din\u00e2mico do rob\u00f4 pode ser obtido de duas formas. Uma delas \u00e9 atrav\u00e9s da\nmodelagem anal\u00edtica, tamb\u00e9m chamada de modelagem fenomenol\u00f3gica, que usa equa\u00e7\u00f5es\ndiferenciais e/ou alg\u00e9bricas para descrever os fen\u00f4menos f\u00edsicos que ocorrem no sistema.\nNo entanto, esse procedimento nem sempre \u00e9 trivial, principalmente quando o sistema \u00e9\nmuito complexo.\n\nA outra forma \u00e9 atrav\u00e9s da modelagem emp\u00edrica, que usa dados de entrada e sa\u00edda\ncoletados do sistema para obter um modelo matem\u00e1tico aproximado. Nesse sentido, os\ndiversos modelos din\u00e2micos de rob\u00f4s uniciclos dispon\u00edveis na literatura diferem, essen-\ncialmente, pelo m\u00e9todo atrav\u00e9s do qual foram obtidos e pelo tipo de suas vari\u00e1veis de\nentrada, na maior parte das vezes tens\u00f5es ou torques. No entanto, assim como os rob\u00f4s da\nlinha Pioneer (MOBILEROBOTS, 2014), a maioria dos rob\u00f4s comerciais geralmente re-\ncebem comandos de controle do tipo velocidade, que s\u00e3o aplicados indiretamente atrav\u00e9s\nde um controle de velocidade de baixo n\u00edvel. Para a futura modelagem din\u00e2mica do pro-\njeto do estudo de caso em quest\u00e3o, ser\u00e3o seguidos os trabalhos de Lages (1998) e Barros\n\n\n\n77\n\n(2014), que apresentam um modelo din\u00e2mico que tem a vantagem de possuir velocidades\nlinear e angular como vari\u00e1veis de entrada do modelo do rob\u00f4 uniciclo, utilizando-se dos\npar\u00e2metros f\u00edsicos do projeto. Agrupando essas informa\u00e7\u00f5es obt\u00e9m-se o chamado modelo\ndin\u00e2mico completo, Figura 37.\n\nMODELO\n\nDIN\u00c2MICO\n\nMODELO\n\nCINEM\u00c1TICO\n\nFigura 37: Diagrama de blocos do modelo din\u00e2mico completo do rob\u00f4 m\u00f3vel uniciclo.\n\nPara movimentar-se em um ambiente e, por conseguinte, ser caracterizado como m\u00f3-\nvel, o rob\u00f4 deve ter seu movimento controlado. Assim ele poder\u00e1 seguir trajet\u00f3rias ou\nmover-se com exatid\u00e3o para um ponto determinado. Para tanto, deve-se projetar um con-\ntrolador que, agindo sobre os atuadores ajuste uma ou mais vari\u00e1veis de estado do sistema\npara um valor desejado. O conhecimento do modelo matem\u00e1tico da planta \u00e9 importante\npara a sele\u00e7\u00e3o da t\u00e9cnica de projeto de controlador a ser usada. O presente trabalho tem\ncomo objetivo desenvolver futuramente o projeto de um controlador de trajet\u00f3ria n\u00e3o-\nlinear para o rob\u00f4 m\u00f3vel uniciclo. Um modelo matem\u00e1tico din\u00e2mico n\u00e3o-linear com\nm\u00faltiplas entradas e m\u00faltiplas sa\u00eddas (ou MIMO, do ingl\u00eas Multiple Inputs, Multiple Out-\nputs).\n\n4.3.4 Controle de Sistemas N\u00e3o-Holon\u00f4micos\n\nO controle de sistemas n\u00e3o-holon\u00f4micos pode ser agrupado como na teoria cl\u00e1ssica\nde controle em: m\u00e9todos de malha aberta e m\u00e9todos de malha fechada. Os m\u00e9todos de\nmalha aberta s\u00e3o tamb\u00e9m conhecidos como planejamento do movimento para sistemas\nn\u00e3o-holon\u00f4micos e buscam leis de controle em malha aberta que desloquem o sistema de\num estado inicial at\u00e9 um estado final. J\u00e1 os m\u00e9todos de malha fechada s\u00e3o aqueles que\npossuem alguma lei de realimenta\u00e7\u00e3o para estabilizar o sistema em torno de um ponto\nde equil\u00edbrio, seguir uma trajet\u00f3ria, ou rejeitar dist\u00farbios (BAZANELLA; GOMES DA\nSILVA, 2005).\n\nTais m\u00e9todos, em contraste com t\u00e9cnicas tradicionais, devem levar em considera\u00e7\u00e3o\nas restri\u00e7\u00f5es instant\u00e2neas ao movimento. As t\u00e9cnicas mais difundidas s\u00e3o as baseadas em:\n\n\u2022 Geometria diferencial e \u00e1lgebra diferencial;\n\n\u2022 Fase geom\u00e9trica;\n\n\u2022 Parametriza\u00e7\u00e3o da entrada;\n\n\u2022 Controle \u00f3timo do movimento;\n\n\u2022 Planejamento do movimento evitando-se obst\u00e1culos.\n\n\n\n78\n\nMuitas vezes \u00e9 necess\u00e1ria a utiliza\u00e7\u00e3o de controle por realimenta\u00e7\u00e3o. Dependendo\ndo tipo de resposta desejada existem diversas formula\u00e7\u00f5es para o problema de controle.\nPode-se destacar tr\u00eas abordagens mais comuns: estabiliza\u00e7\u00e3o, rastreamento, e rejei\u00e7\u00e3o/a-\ntenua\u00e7\u00e3o de dist\u00farbios (e v\u00e1rias combina\u00e7\u00f5es das mesmas). No caso da estabiliza\u00e7\u00e3o,\nprocura-se leis de realimenta\u00e7\u00e3o (variantes ou invariantes no tempo) que estabilizem um\nsistema para um determinado ponto de equil\u00edbrio. Para o rastreamento, a meta b\u00e1sica\n\u00e9 projetar um sinal de controle de forma que a sa\u00edda controlada de y siga um sinal de\nrefer\u00eancia yR, isto \u00e9,\n\ne(t) = y(t) ? yR(t) ? 0, ?t ? t0 (6)\n\nonde t0 \u00e9 o instante em que o controle se inicia. Como o valor inicial de y depende do\nestado inicial (x0), \u00e9 necess\u00e1rio partir de um estado \"pre-estabelecido\".\n\nUm postulado bem conhecido dos pesquisadores em controle n\u00e3o-linear diz que: Um\nsistema n\u00e3o-holon\u00f4mico, embora seja completamente control\u00e1vel, n\u00e3o pode ser estabili-\nzado para uma configura\u00e7\u00e3o final de repouso atrav\u00e9s de leis suaves de realimenta\u00e7\u00e3o nos\nestados. Este postulado se aplica a estabiliza\u00e7\u00e3o em torno de um ponto de equil\u00edbrio e\nleis de controle invariantes no tempo, por\u00e9m n\u00e3o \u00e9 v\u00e1lido para o rastreamento de uma\ntrajet\u00f3ria. Neste ultimo caso, pode-se usar as leis de controle conhecidas se o sistema for\nlineariz\u00e1vel por realimenta\u00e7\u00e3o est\u00e1tica ou din\u00e2mica de estados, e uma vez que a trajet\u00f3ria\nde refer\u00eancia n\u00e3o contenha configura\u00e7\u00f5es de repouso (FIGUEIREDO; JOTA, 2004).\n\nPara sistemas lineares invariantes no tempo, se os autovalores inst\u00e1veis do sistema s\u00e3o\ncontrol\u00e1veis, ent\u00e3o a origem pode ser estabilizada de forma assint\u00f3tica. Sistemas n\u00e3o-\nholon\u00f4micos apresentam caracter\u00edsticas que o diferenciam consideravelmente do caso\nanterior. Mesmo que linearizado em torno de um ponto de opera\u00e7\u00e3o, o sistema n\u00e3o \u00e9\nassintoticamente est\u00e1vel, logo, as estrat\u00e9gias tradicionais n\u00e3o podem ser empregadas. As\nprincipais t\u00e9cnicas de controle desenvolvidas para vencer esta limita\u00e7\u00e3o s\u00e3o:\n\n\u2022 Estabiliza\u00e7\u00e3o variante no tempo;\n\n\u2022 Estabiliza\u00e7\u00e3o usando sinais n\u00e3o cont\u00ednuos ou transforma\u00e7\u00f5es n\u00e3o-lineares;\n\n\u2022 Leis h\u00edbridas de realimenta\u00e7\u00e3o.\n\nRestringe-se a abordagem aqui a exemplos da utiliza\u00e7\u00e3o do m\u00e9todo de rastreamento\nde trajet\u00f3ria por lineariza\u00e7\u00e3o din\u00e2mica, estabiliza\u00e7\u00e3o variante no tempo e n\u00e3o cont\u00ednua\nem um ponto de equil\u00edbrio e uma lei h\u00edbrida (KUHNE, 2005).\n\n4.3.5 Projeto de Controle\n\nPara o controlador do rob\u00f4 m\u00f3vel esta sendo seguido o modelo utilizado em Garro\n(2013). O sistema do rob\u00f4 m\u00f3vel \u00e9 composto por v\u00e1rios subsistemas. Enfatizada, especi-\nficamente, no desenvolvimento de padr\u00f5es de projeto para o subsistema de movimento.\n\nA modelagem do rob\u00f4 m\u00f3vel do estudo de caso \u00e9 representado pelo diagrama de\nimplanta\u00e7\u00e3o, o qual descreve os n\u00f3s do processador e dispositivos (sensores, atuadores\ne m\u00f3dulos). Os dispositivos sensores, por exemplo, s\u00e3o caracterizados por aprender e\nresponder a est\u00edmulos internos e externos. O projeto vem sendo modelado de modo a\nobter tr\u00eas tipos de percep\u00e7\u00f5es no prot\u00f3tipo:\n\n\u2022 Proprioceptivos, fornecem informa\u00e7\u00f5es internas relativas ao sistema rob\u00f3tico, por\nexemplo, velocidade das rodas, posi\u00e7\u00e3o dos motores CC e n\u00edvel da bateria.\n\n\n\n79\n\n\u2022 Exteroceptivos, adquirem informa\u00e7\u00f5es sobre a \u00e1rea de atua\u00e7\u00e3o do rob\u00f4, por exem-\nplo, medidas de dist\u00e2ncia e luminosidade do ambiente.\n\n\u2022 Exproprioceptivos, fornecem informa\u00e7\u00e3o sobre o corpo do rob\u00f4 ou partes dele re-\nlativa ao ambiente, por exemplo, posi\u00e7\u00e3o no ambiente.\n\nUm diagrama de implanta\u00e7\u00e3o pode conter diferentes processadores e dispositivos in-\nterligados entre si, esses n\u00f3s podem ser mantidos, exclu\u00eddos ou adicionados no diagrama\nde implanta\u00e7\u00e3o do projeto. Inicialmente a configura\u00e7\u00e3o do diagrama de implanta\u00e7\u00e3o para\no estudo de caso \u00e9 representado na Figura 38, o qual apresenta a modelagem parcial do\nprojeto, desenvolvido conforme as necessidades do desenvolvedor e da disponibilidade\ndos dispositivos e ferramentas para experimentar diferentes estrategias para navega\u00e7\u00e3o e\ncontrole. N\u00e3o \u00e9 objetivo deste trabalho detalhar a constru\u00e7\u00e3o de um rob\u00f4, portanto ser\u00e3o\nfeitas aqui apenas algumas considera\u00e7\u00f5es sobre algumas poss\u00edveis implementa\u00e7\u00f5es para\no controle do projeto.\n\nControle e Seguimento \n    de Trajet\u00f3ria\n\nM\u00f3dulos e Sensores\n\nPlanifica\u00e7\u00e3o de Tempo Real \n\nControlador de Movimento Embarcado\n\nROB\u00d4 M\u00d3VEL\n\n<<processador>>\n\nPonte H\n\nMotor DC\n\nEncoder\n\nGirosc\u00f3pio  B\u00fassula \n\nSonar\n\n    Servo\n\nInfravermelho\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>&lt;<dispositivo>>\n\n1...*       1\n\n1...*\n\n1...*\n\n1...*\n\n1...*\n\n1...*        1\n\n1          1...*\n\n1          1...*\n\n1          1...*\n\nAceler\u00f4metro\n<<dispositivo>>\n\n    Radio\nFrequ\u00eancia\n\n<<dispositivo>>\n\nLaser\n<<dispositivo>>\n\nC\u00e2mera\n<<dispositivo>>\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\nFigura 38: Modelagem do diagrama de implanta\u00e7\u00e3o parcial para o subsistema de movi-\nmento do rob\u00f4. O diagrama de implanta\u00e7\u00e3o \u00e9 composto por processadores, componentes\ne dispositivos, alocados conforme as necessidades do projeto.\n\nUma das tarefas mais importantes que o subsistema realiza, \u00e9 o de examinar os dados\ncom a frequ\u00eancia definida pelo planificador de tempo real. Os dados s\u00e3o enviados pelos\ndiferentes m\u00f3dulos e sensores para o controlador central, que realiza os c\u00e1lculos de tra-\njet\u00f3ria. Com os dados retornados, o algoritmo de controle e rastreamento de trajet\u00f3ria \u00e9\nexecutado. O rastreamento de trajet\u00f3ria \u00e9 obtido ao atuar com um sinal de controle na\nponte-h, indicando a intensidade e dire\u00e7\u00e3o de rota\u00e7\u00e3o de cada motor individualmente.\n\nNa Figura 38, o subsistema de movimento ocorre com v\u00e1rios m\u00f3dulos e sensores.\nO objetivo \u00e9 que estes dados permitam ao rob\u00f4 realizar um percurso de uma maneira\ncontrolada para se obter uma navega\u00e7\u00e3o eficiente.\n\n\n\n80\n\nSer\u00e1 utilizado como modelo para apresentar a estrutura de padr\u00f5es de projeto, a pro-\nposta apresentado por Pont (2001).\n\nCONTEXTO: Verificar o caminho de um rob\u00f4 m\u00f3vel com acionamento diferencial\nem um ambiente.\n\nPROBLEMA: Devido \u00e0 forma dire\u00e7\u00e3o diferencial escolhida para o rob\u00f4, uma das\nprincipais dificuldades apresentadas por esta configura\u00e7\u00e3o, \u00e9 o de assegurar que ambas\nas rodas movam-se de uma maneira controlada para assegurar que o deslocamento seja\nretil\u00edneo ou seguindo dada uma curva. O objetivo da reutiliza\u00e7\u00e3o deste padr\u00e3o \u00e9 responder\na este problema espec\u00edfico.\n\nANTECEDENTES: A figura 29 da subse\u00e7\u00e3o 4.3.2 mostra um diagrama a partir do\nqual o modelo cinem\u00e1tico do rob\u00f4 diferencial \u00e9 gerado. Um sistema de coordenadas pola-\nres \u00e9 utilizado, permitindo simplificar express\u00f5es matem\u00e1ticas. S\u00e3o ve e vd as velocidades\ntangenciais da roda esquerda e \u00e0 direita; e ?E e ?D suas velocidades angulares. Assim, \u00e9\nposs\u00edvel definir a velocidade linear do rob\u00f4 como:\n\nV = R? =\nvd + ve\n\n2\n=\n\n?d + ?e\n2\n\nr (7)\n\nEm que r \u00e9 o raio da roda, V \u00e9 a velocidade linear; e R \u00e9 a dist\u00e2ncia radial do rob\u00f4 a\npartir da posi\u00e7\u00e3o inicial. A velocidade de rota\u00e7\u00e3o do rob\u00f4, ser\u00e1 proporcional \u00e0 diferen\u00e7a\nnas velocidades angulares das rodas. Expresso como:\n\n?? =\n(?d ? ?e)r\n\nl\n(8)\n\nOnde l \u00e9 a dist\u00e2ncia entre as rodas. Do exposto anteriormente, pode-se ver que, se\na velocidade angular da roda direita ?d e esquerda ?e \u00e9 a mesma, o rob\u00f4 segue um ca-\nminho linear. Se houver uma diferen\u00e7a, \u00e9 apresentado um desvio para um dos lados em\npropor\u00e7\u00e3o com a diferen\u00e7a das velocidades angulares.\n\nPara a medi\u00e7\u00e3o da velocidade angular, est\u00e3o sendo pesquisados e utilizados diferentes\nsensores: girosc\u00f3pio, codificadores e b\u00fassola eletr\u00f4nica. Aqui est\u00e3o tr\u00eas poss\u00edveis solu-\n\u00e7\u00f5es a serem submetidas para o controle, onde cada uma \u00e9 apresentada a partir de tr\u00eas\ncomponentes conceituais: a) Hardware, b) Controle, c) Software.\n\nSOLU\u00c7\u00c3O 1 - Rob\u00f4 m\u00f3vel com girosc\u00f3pio:\nAqui \u00e9 apresentada a solu\u00e7\u00e3o mais simples de implementar, dado que se tenha sido\n\nusado um girosc\u00f3pio anal\u00f3gico como sensor. \u00c9 poss\u00edvel garantir que o rob\u00f4 m\u00f3vel dife-\nrencial se mova ao longo de um caminho reto, por\u00e9m com apenas um sensor deste tipo,\nn\u00e3o \u00e9 poss\u00edvel determinar a dist\u00e2ncia radial do rob\u00f4 m\u00f3vel em rela\u00e7\u00e3o \u00e0 posi\u00e7\u00e3o inicial.\nPara isso, \u00e9 necess\u00e1rio ter uma outra vari\u00e1vel a ser medida. A solu\u00e7\u00e3o 3 apresentada pos-\nteriormente, resolve o problema, incluindo um subsistema com b\u00fassola digital.\n\na) Hardware: Na Figura 39, se observa o esquema do hardware do subsistem a de\nmovimento em que se destacam tr\u00eas componentes principais: microprocessador, girosc\u00f3-\npio e driver de pot\u00eancia (ponte-h). Para as medi\u00e7\u00f5es de velocidades angulares, um giros-\nc\u00f3pio anal\u00f3gico \u00e9 utilizado, o qual \u00e9 amostrado periodicamente, utilizando um conversor\nA/D do microcontrolador. Com o sinal obtido, o microcontrolador executa os c\u00e1lculos\nimplementados no controlador Proporcional, Integral e Derivativo (PID) para determinar\n\n\n\n81\n\no sinal de Pulse-Width Modulation (PWM) necess\u00e1rio, o qual \u00e9 enviado para o driver de\npot\u00eancia. A modula\u00e7\u00e3o por Largura de Pulso ou PWM \u00e9 a modula\u00e7\u00e3o ou altera\u00e7\u00e3o da\nlargura do pulso de um sinal de onda quadrada que pode ser dados \u00e0 ser transmitido. O\nest\u00e1gio de pot\u00eancia \u00e9 respons\u00e1vel pela adapta\u00e7\u00e3o \u00e0s tens\u00f5es nos terminais de cada um dos\nmotores com base no sinal de controle recebido.\n\nPonte H\n\nGirosc\u00f3pio\n\nMicrocontrolador\n\nM1 M2\n\nFigura 39: Subsistema de movimento com girosc\u00f3pio.\n\nb) Controle: Seguindo o modelo cinem\u00e1tico da figura 29 da subse\u00e7\u00e3o 4.3.2, \u00e9 poss\u00edvel\nestimar os valores de ?d e ?e a partir da medi\u00e7\u00e3o da velocidade angular ?? do girosc\u00f3pio.\nNa Figura 40, observa-se um diagrama de um controlador PID, que toma como refer\u00eancia\n?ref uma tens\u00e3o predeterminada. Com base nesta refer\u00eancia e a diferen\u00e7a com o sinal\nobtido a partir da detec\u00e7\u00e3o do girosc\u00f3pio, se obt\u00eam o erro, o qual ir\u00e1 convergir para o\nvalor desejado, neste caso, zero. Quando o erro \u00e9 zero, significa que ?e e ?d s\u00e3o iguais e,\npor consequ\u00eancia, a trajet\u00f3ria do rob\u00f4 \u00e9 retil\u00ednea.\n\nPlantaPID Ponte H\n\nGirosc\u00f3pio\nAdapta\u00e7\u00e3o\n\nSinal\n\n+\n-\n\nerro\n sinal de\n controle sa\u00eddarefer\u00eancia O-\n\nO-\n\nFigura 40: Controle PID.\n\nEsta converg\u00eancia, \u00e9 obtida modificando as velocidades angulares individuais dos mo-\ntores atrav\u00e9s da ponte-h, utilizando para tal um sinal de PWM correspondente.\n\nc) Software: Na Figura 41, \u00e9 apresentado o diagrama de estados para ser implemen-\ntado no microcontrolador. Pode ser observado que, uma vez inicializadas as vari\u00e1veis\npr\u00f3prias do microcontrolador, a detec\u00e7\u00e3o do girosc\u00f3pio \u00e9 realizada utilizando o canal\nA/D do microcontrolador, e o sinal \u00e9 condicionado atrav\u00e9s de um filtro lowpass digital.\nUma vez que o sinal tenha sido filtrado, \u00e9 comparado com o sinal de refer\u00eancia do contro-\nlador PID, e o erro \u00e9 calculado. Com este erro \u00e9 gerado um sinal de controle PWM, que\nage nos motores que utilizam o driver ponte-h. Como j\u00e1 comentado, o objetivo do PID, \u00e9\nigualar as velocidades angulares das rodas para garantir a trajet\u00f3ria retil\u00ednea.\n\nSOLU\u00c7\u00c3O 2 - Sistema implementado com encoders:\n\n\n\n82\n\nInicializa\u00e7\u00e3o\n\nSensor de Velocidade Angular\n\nFiltragem do Sinal\n\nAplica\u00e7\u00e3o PID\n\nAtualiza\u00e7\u00e3o da Sa\u00edda\n\nFigura 41: Diagrama de estados.\n\nEsta solu\u00e7\u00e3o utiliza dois encoders para determinar a velocidade angular, mas tamb\u00e9m\na dist\u00e2ncia radial do rob\u00f4 em rela\u00e7\u00e3o \u00e0 posi\u00e7\u00e3o inicial. Para isso, \u00e9 necess\u00e1rio conhecer\no modo como cada roda se move linearmente para cada impulso registado pelo encoder.\nPortanto, deve-se transformar o movimento angular do eixo em movimento linear da roda.\nA equa\u00e7\u00e3o para calcular o deslocamento linear \u00e9:\n\nCm =\n2?r\n\nn ? Ce\n(9)\n\nOnde n \u00e9 o eixo da roda de redu\u00e7\u00e3o. No nosso caso, o encoder est\u00e1 integrado com\nas rodas de modo a que n=1; Ce \u00e9 a resolu\u00e7\u00e3o do encoder. Com esses dados, podemos\ncalcular a velocidade angular de cada roda e o deslocamento linear.\n\na) Hardware: Na Figura 42, podemos observar o subsistema de movimento, que des-\ntaca tr\u00eas componentes principais: microcontrolador, encoders e o driver de pot\u00eancia. Os\nencoders presentes em cada uma das rodas, geram um impulso, o qual \u00e9 detectado por\ninterrup\u00e7\u00e3o de n\u00edvel de hardware. Estes impulsos permitem medir a velocidade angular\ne o movimento linear, tal como discutido na Equa\u00e7\u00e3o (9). Com o sinal obtido, o micro-\ncontrolador executa os c\u00e1lculos necess\u00e1rios e define o sinal de PWM, o qual \u00e9 enviado\npara o amplificador de pot\u00eancia. Esta etapa, \u00e9 respons\u00e1vel pela adapta\u00e7\u00e3o das tens\u00f5es dos\nterminais dos motores utilizando como driver a ponte-h.\n\nPonte HEncoder\n\nMicrocontrolador\n\nM1 M2\n\nEncoder\n\nFigura 42: Subsistema de movimento com encoders.\n\nb) Controle: A partir do modelo cinem\u00e1tico e conhecendo os valores de ?d e ?e\nobtidos a partir da medi\u00e7\u00e3o dos encoders, a Figura 43 apresenta a solu\u00e7\u00e3o usando um\n\n\n\n83\n\ncontrolador PID. S\u00e3o determinadas duas vari\u00e1veis de refer\u00eancia (\u00e2ngulo: ?ref ; dist\u00e2ncia\nradial Rref ). O objetivo do controlador \u00e9 determinar a velocidade angular e dist\u00e2ncia\nde deslocamento angular do raio R. Por outras palavras, se a diferen\u00e7a da medi\u00e7\u00e3o de\nvelocidade angular determinada pela detec\u00e7\u00e3o dos encoders \u00e9 igual a zero, o rob\u00f4 est\u00e1\nse movendo de maneira retil\u00ednea. Caso contr\u00e1rio, realizar\u00e1 uma corre\u00e7\u00e3o proporcional \u00e0\ndiferen\u00e7a medida. Esta corre\u00e7\u00e3o \u00e9 feito pelo microcontrolador, que resulta no envio de\num sinal PWM para ajustar o caminho pretendido e efetuar os c\u00e1lculos necess\u00e1rios para\ndeterminar a dist\u00e2ncia radial do rob\u00f4 a partir da posi\u00e7\u00e3o inicial.\n\nPlantaPID Ponte H\n\nEncoder\n\nAdapta\u00e7\u00e3o\nSinal\n\n+\n-\n\nerro\n\n sinal de\n controle sa\u00eddaref. O-\n\nO-\n\nPID+\n-\n\nO-\n\nR\n\nO-\n\nR ref. erro\n sinal de\n controle\n\nR\n\nRrealimenta\u00e7\u00e3o\n\nFigura 43: Controle PID\n\nc) Software: A Figura 44, apresenta o diagrama de estados para ser implementado\nno microcontrolador. Uma vez inicializadas as vari\u00e1veis pr\u00f3prias do microcontrolador e\nas do PID, podemos observar como se realiza a detec\u00e7\u00e3o dos impulsos gerados pelos dois\nencoders por meio de interrup\u00e7\u00e3o do hardware. O software calcula a velocidade angular\ne dist\u00e2ncia percorrida pelas rodas de acordo como descrito na Equa\u00e7\u00e3o (9). Tomando\nos sinais de refer\u00eancia ?ref , Rref e a diferen\u00e7a com as vari\u00e1veis detectadas, o erro \u00e9\ndeterminado. O erro ir\u00e1 convergir na velocidade angular, como na dist\u00e2ncia radial do\nrob\u00f4 a partir da posi\u00e7\u00e3o inicial de acordo com os sinais de refer\u00eancia. A converg\u00eancia,\nse d\u00e1 pela a\u00e7\u00e3o do microcontrolador atrav\u00e9s da sa\u00edda de controle PWM gerado, que atua\nsobre os motores utilizando o driver da ponte-h.\n\nInicializa\u00e7\u00e3o\n\nDetermina\u00e7\u00e3o da Trajet\u00f3ria\n\nAtualiza\u00e7\u00e3o da Sa\u00edda Aplica\u00e7\u00e3o PID\n\nSensor Velocidade Angular\n\nFigura 44: Diagrama de estado\n\nSOLU\u00c7\u00c3O 3 - Sistema implementado com girosc\u00f3pio e b\u00fassola:\nComo no sistema proposto na solu\u00e7\u00e3o anterior, com este desenho de hardware, soft-\n\nware e de controle podemos determinar a velocidade angular e a dist\u00e2ncia radial do rob\u00f4\n\n\n\n84\n\nem rela\u00e7\u00e3o \u00e0 posi\u00e7\u00e3o inicial.\na) Hardware : A Figura 45, mostra o esquem\u00e1tico do hardware do subsistema de\n\nmovimento os quais se destacam quatro componentes principais: microprocessador, gi-\nrosc\u00f3pio, b\u00fassola eletr\u00f4nica e driver de pot\u00eancia.\n\nA velocidade angular \u00e9 detectada utilizando um girosc\u00f3pio anal\u00f3gico que \u00e9 periodi-\ncamente amostrado, usando um conversor A/D do microcontrolador. No entanto, esta\nmedida n\u00e3o \u00e9 suficiente para determinar a dist\u00e2ncia radial do rob\u00f4 com respeito \u00e0 posi\u00e7\u00e3o\ninicial. Portanto, \u00e9 adicionada uma b\u00fassola digital, que entre outros par\u00e2metros, transmite\nao microcontrolador a posi\u00e7\u00e3o angular m\u00e9dia em graus norte magn\u00e9tico. Com os par\u00e2me-\ntros recebidos, o microcontrolador executa os c\u00e1lculos definidos nas vari\u00e1veis de estados\n- as quais s\u00e3o apresentadas na se\u00e7\u00e3o seguinte -, e o sinal de PWM necess\u00e1rio, o qual \u00e9\nenviado para a etapa de pot\u00eancia. Esta etapa de pot\u00eancia \u00e9 respons\u00e1vel por ajustar a tens\u00e3o\nde cada um dos motores com base no sinal PWM recebido, um fato que se manifesta nas\nvelocidades angulares ?d e ?e dos motores.\n\nPonte H\n\nB\u00fassula\n\nMicrocontrolador\n\nM1 M2\n\nGirosc\u00f3pio\n\nFigura 45: Hardware Subsistema de movimento com bussola e girosc\u00f3pio\n\nA velocidade angular \u00e9 detectada utilizando um girosc\u00f3pio anal\u00f3gico que \u00e9 periodica-\nmente amostrado usando um conversor A/D do microcontrolador.\n\nb) Controle: Continuando conforme o modelo apresentado em Garro (2013), para\nrealizar o controle do modelo cinem\u00e1tico do rob\u00f4 uniciclo com vari\u00e1veis de estado e\nchegar em suas equa\u00e7\u00f5es diferenciais (10), foi preciso desprezar a indut\u00e2ncia interna do\nmotor, em que k1 e k3 s\u00e3o constantes pr\u00f3prias do motor que relacionam a acelera\u00e7\u00e3o com\na tens\u00e3o (v1 e v2) aos terminais. E k2 e k4 representam os coeficientes de atrito das rodas.\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?d = k1v1 ? k2?d\n?i = k3v2 ? k4?i\n\nR? =\n?d + ?i\n\n2\nr\n\n?? =\n(?d??i)r\n\nl\n\n(10)\n\nLogo, selecionando como vari\u00e1veis de estado ?d, ?i e ?, e a v1 e v2 como as entradas\ndo sistema, se obt\u00eam a seguinte representa\u00e7\u00e3o matricial de estados.\n\nx? = Ax + bu, (11)\n\nOnde:\n\n\n\n85\n\nX =\n\n?\n\n?\n\nx1\nx2\nx3\n\n?\n\n? =\n\n?\n\n?\n\n?d\n?i\n?\n\n?\n\n? , A =\n\n?\n\n?\n\n?k2 0 0\n0 ?k4 0\nr\nl\n\n?r\nl\n\n0\n\n?\n\n? , b =\n\n?\n\n?\n\nk1 0\n0 k3\n0 0\n\n?\n\n? , u =\n\n[\n\nv1\nv2\n\n]\n\n. (12)\n\nConforme em Garro (2013), as constantes ki se relacionam com as caracter\u00edsticas ele-\ntromec\u00e2nicas dos motores e tamb\u00e9m s\u00e3o afetadas por quest\u00f5es mec\u00e2nicas como o sistema\nde transmiss\u00e3o ou o coeficiente de atrito entre as rodas ao deslocar-se sobre a superf\u00edcie.\nO modelo de controle com as vari\u00e1veis de estado s\u00e3o utilizados na implementa\u00e7\u00e3o para o\nsoftware do microcontrolador.\n\nc) Software: Na Figura 46, se apresenta o diagrama de estado que deve ser imple-\nmentado no microcontrolador. Se pode observar que, uma vez inicializada as vari\u00e1veis\ncaracter\u00edsticas do microcontrolador, como as do PID, \u00e9 feita a detec\u00e7\u00e3o da velocidade\nangular do girosc\u00f3pio, assim como o desvio em graus norte magn\u00e9tico da b\u00fassola digital.\n\nCom base nos dados obtidos a partir dos dois sensores, o microcontrolador realizar\u00e1\no c\u00e1lculo da velocidade angular e de dist\u00e2ncia percorrida de cada uma das rodas. Final-\nmente, \u00e9 gerado um sinal de controle PWM, que atua sobre os motores, utilizando como\ndriver a ponte-h. Esta a\u00e7\u00e3o, possibilita que o sistema convirja na velocidade angular, e\nna dist\u00e2ncia radial do rob\u00f4 em rela\u00e7\u00e3o \u00e0 posi\u00e7\u00e3o inicial desejada (GARRO; ORDINEZ;\nSCASSO, 2013).\n\nInicializa\u00e7\u00e3o\n\nDetermina\u00e7\u00e3o da Trajet\u00f3ria\n\nAtualiza\u00e7\u00e3o da Sa\u00edda Filtragem do Sinal\n\nDetec\u00e7\u00e3o da Velocidade Angular\n\nAplica\u00e7\u00e3o do PID\n\nFigura 46: Diagrama de estados\n\n4.4 Telemetria e Telecontrole de um Sistema Embarcado Aplicado\nna Macro e Micro Navega\u00e7\u00e3o de Deficientes Visuais\n\nVisando as dificuldades existentes e as tecnologias dispon\u00edveis, o estudo de caso em\nquest\u00e3o tem por objetivo projetar um sistema nacional de rastreamento de bengalas eletr\u00f4-\nnicas. Aplicado na macro e micro navega\u00e7\u00e3o de deficientes visuais durante seus desloca-\nmentos. A micro navega\u00e7\u00e3o se preocupa com as informa\u00e7\u00f5es ocorridas durante a marcha\nou deslocamento do deficiente visual dentro do ambiente que o circunda. Enquanto que\na macro navega\u00e7\u00e3o \u00e9 referente a posi\u00e7\u00e3o geogr\u00e1fica e monitoramento remoto (GUIMA-\nR\u00c3ES; HENRIQUES; PEREIRA, 2013) do deficiente visual com sua bengala eletr\u00f4nica.\nFrameworks SOA ir\u00e3o auxiliar no desenvolvimento do servi\u00e7o de rastreamento para ma-\ncro e micro navega\u00e7\u00e3o. O projeto \u00e9 aplicado na orienta\u00e7\u00e3o e mobilidade de deficientes\nvisuais, durante o seu deslocamento em curtas e longas dist\u00e2ncias. E todo o acompa-\nnhamento da trajet\u00f3ria e controles de algumas funcionalidades devem estar acess\u00edveis via\nInternet(GUIMAR\u00c3ES; PEREIRA; HENRIQUES, 2014).\n\n\n\n86\n\n4.4.1 Tecnologia Assistiva\n\nTecnologia Assistiva (TA) \u00e9 qualquer item, equipamento ou sistema, adquirido comer-\ncialmente, modificado ou customizado, que \u00e9 usado para aumentar, manter ou melhorar\ncapacidades funcionais de indiv\u00edduos com defici\u00eancia. A defini\u00e7\u00e3o, apesar de bastante\nabrangente, \u00e9 usada no contexto da mesma para referenciar ferramentas usadas para me-\nlhorar ou aumentar a funcionalidade das tecnologias baseadas em software ou hardware.\nDentre os recursos utilizados pelos deficientes visuais para locomo\u00e7\u00e3o, a bengala branca\napresenta-se como um dos mais baratos e seguros, isto \u00e9, quando manipulado correta-\nmente. Mobilidade segura \u00e9 um dos maiores desafios enfrentado pelos deficientes visuais\nem seu dia-a-dia. A bengala branca tradicional \u00e9 da categoria auxilio a mobilidade na TA\ne \u00e9 amplamente utilizado para sondar atrav\u00e9s da percep\u00e7\u00e3o t\u00e1til-cenest\u00e9sica o espa\u00e7o \u00e0\nfrente, Figura 47.\n\nFigura 47: Ilustra\u00e7\u00e3o do movimento caracter\u00edstico de uma bengala branca, deixando por\nsondar a maioria do espa\u00e7o na frente do utilizador. A vermelho est\u00e3o representados os\npar\u00e2metros medidos e calculados a partir dos ensaios realizados (ROSA, 2009).\n\nAl\u00e9m disso, as bengalas brancas tradicionais s\u00e3o mecanismos \u00fateis apenas em ajudar\na detectar obst\u00e1culos dentro de um ambiente imediato que circunda o deficiente visual\n(micro navega\u00e7\u00e3o) e n\u00e3o pode prever obst\u00e1culos com anteced\u00eancias localizadas acima ou\nabaixo da linha da cintura e nem informar a localiza\u00e7\u00e3o ou posi\u00e7\u00e3o global (macro na-\nvega\u00e7\u00e3o). Devido ao avan\u00e7o tecnol\u00f3gico grande parte das tarefas executadas por seres\nhumanos est\u00e3o sendo auxiliadas por computadores. Nesse pressuposto, sistemas compu-\ntacionais embarcados est\u00e3o presentes em diversas atividades, s\u00e3o sistemas dedicados que\npossuem uma funcionalidade restrita para atender uma tarefa espec\u00edfica em sistemas mai-\nores nos quais est\u00e3o inseridos. Estes sistemas s\u00e3o naturalmente heterog\u00eaneos, pois s\u00e3o\nconstitu\u00eddos de componentes de hardware e software.\n\n4.4.2 O Movimento da Bengala\n\nEm Regalado (2009), foi registrado os dados necess\u00e1rios para o c\u00e1lculo dos par\u00e2-\nmetros desejados para o c\u00e1lculo da velocidade de marcha, vx. Tendo sido as filmagens\nrealizadas a 25fps (frames per second), tem-se que:\n\nvx =\npxfinal ? pxinicial\n\nframefinal ? frameinicial\n25\n\n(13)\n\nem que px representa a posi\u00e7\u00e3o do deficiente visual no eixo X (Figura 47).\n\n\n\n87\n\nAs medi\u00e7\u00f5es de bx e by referem-se \u00e0 posi\u00e7\u00e3o da ponta da bengala aquando do toque\nno ch\u00e3o. Com estas medidas \u00e9 poss\u00edvel calcular a amplitude e velocidade de oscila\u00e7\u00e3o da\nbengala (AOSC e vOSC ), respectivamente), bem como o espa\u00e7o invis\u00edvel para a mesma. A\nvelocidade de oscila\u00e7\u00e3o usa o utilizador como refer\u00eancia e consiste na velocidade media,\ntangencial ao arco descrito pela bengala. Como o comprimento do arco descrito pela\nbengala \u00e9 dado por:\n\na = 2.r.arcsin(AOSC/2) (14)\n\ne se mediu que r (raio de rota\u00e7\u00e3o da bengala) \u00e9 aproximadamente 1m, tem-se que:\n\nvOSC =\n2.arcsin(AOSC/2).(n\n\no de toques ? 1)\nframefinal ? frameinicial\n\n25\n\n(15)\n\nsendo que no de toques representa o n\u00famero de vezes que a bengala toca no ch\u00e3o, em\nambos os lados.\n\nAtrav\u00e9s dos resultados obtidos em Regalado (2009), chegou-se a uma conclus\u00e3o im-\nportante, existe uma raz\u00e3o aproximadamente constante entre vx e vOSC. Isto deve-se ao\nfato de o ritmo da bengala ter que acompanhar o ritmo da passada, de forma a estar sempre\nno lado contr\u00e1rio ao do p\u00e9 dianteiro. Quanto \u00e0 amplitude de oscila\u00e7\u00e3o, verificou-se que\nexiste uma maior tend\u00eancia a alargar mais o movimento com o aumento da velocidade de\nmarcha o que, prejudica bastante o espa\u00e7o invis\u00edvel. Neste caso, e apenas para efeitos de\nquantifica\u00e7\u00e3o, considera-se que o espa\u00e7o invis\u00edvel \u00e9 a dist\u00e2ncia que vai desde o ponto em\nque a ponta da bengala passa \u00e0 frente do utilizador at\u00e9 \u00e0 passagem seguinte, no sentido\ncontr\u00e1rio (ilustrado na Figura 47). Assumindo que vOSC \u00e9 constante ao longo de todo o\ntrajeto, tem-se que:\n\nEspa\u00e7o Invis\u00edvel =\nbxfinal ? bxinicial\nno de toques ? 1\n\n(16)\n\nEste par\u00e2metro s\u00f3 foi calculado para o primeiro e terceiro ensaio realizado em Rega-\nlado (2009), pois nestes foi realizada uma filmagem adicional com uma c\u00e2mara de lado,\na acompanhar o deslocamento do cego, facilitando a medida de bx (ROSA, 2009).\n\n4.4.3 Bengala Eletr\u00f4nica\n\nO estudo de caso descreve parte das metodologias e ferramentas utilizadas para a an\u00e1-\nlise e projeto parciais de uma bengala eletr\u00f4nica: Prot\u00f3tipo de um sistema embarcado\npara aux\u00edlio \u00e0 macro e micro navega\u00e7\u00e3o de deficientes visuais. O projeto em desenvolvi-\nmento \u00e9 um sistema eletr\u00f4nico de apoio a mobilidade para substitui\u00e7\u00e3o da vis\u00e3o pelo som\ne tato, Figura 48. Existem muitas configura\u00e7\u00f5es que podem ser definidas para um projeto\nde uma bengala eletr\u00f4nica. Portanto, para a proposta inicial desse estudo de caso, foram\ndefinidos dois modelos conceituais que ser\u00e3o apresentados a seguir.\n\nO projeto vem sendo desenvolvido no PPGEE (Programa de P\u00f3s-Gradua\u00e7\u00e3o em En-\ngenharia El\u00e9trica) e encontra-se como parte da valida\u00e7\u00e3o do trabalho de disserta\u00e7\u00e3o.\n\nA fim de distinguir os obst\u00e1culos acima e abaixo da cintura, as marca\u00e7\u00f5es 1a e 1b das\nfiguras seguintes, indicam o uso de micromotores para informar atrav\u00e9s de vibra\u00e7\u00f5es o\nutilizador quando existem obst\u00e1culos. Para obst\u00e1culos abaixo da linha da cintura \u00e9 aci-\nonado o micromotor referente a marca\u00e7\u00e3o 1a, localizado no cabo ou pega da bengala\neletr\u00f4nica. Assim, quando um obst\u00e1culo \u00e9 detectado acima da linha da cintura do utili-\nzador, o microcontrolador transmite um sinal atrav\u00e9s de um m\u00f3dulo de Radiofrequ\u00eancia\n\n\n\n88\n\nFigura 48: Modelo conceitual do projeto da bengala eletr\u00f4nica\n\n(RF). O receptor de RF faz operar o micromotor de vibra\u00e7\u00e3o 1b, avisando o usu\u00e1rio ante-\ncipadamente sobre a presen\u00e7a de obst\u00e1culos nessa regi\u00e3o.\n\nA Tabela 2, mostra a fus\u00e3o dos componentes eletr\u00f4nicos do sistema com as marca\u00e7\u00f5es\napresentadas na primeira configura\u00e7\u00e3o do modelo conceitual do projeto.\n\nTabela 1: Rela\u00e7\u00e3o dos componentes eletr\u00f4nicos com as marca\u00e7\u00f5es da Figura 48.\nMarca\u00e7\u00f5es na Imagem\n\nComponentes\n1a e 1b 2 3 4 5 6a e 6b 7 8a e 8b 9a e 9b 10 11\n\nMicromotor de Vibra\u00e7\u00e3o X\nMCU ou SoC X\n\nLDR X\nGPS X\nGSM X\n\nRadiofrequ\u00eancia X\nSensor Inercial X\n\nServomotor X\nSonar X\n\u00c1udio X\n\nC\u00e2mera X\n\nO prot\u00f3tipo do hardware eletr\u00f4nico pode ser composto por microprocessadores, atu-\nadores, sensores e m\u00f3dulos, como por exemplo: MicroController Unit Board (MCU) ou\nSystem On Chip (SOC), servomotores, micromotores de vibra\u00e7\u00e3o, radiofrequ\u00eancia, Glo-\nbal Positioning System (GPS), Global System for Mobile Communications (GSM), Light\nDependent Resistor (LDR) e sensores ultrass\u00f4nicos (sonar) que devem estar inseridos na\n\n\n\n89\n\nhaste da bengala eletr\u00f4nica atrav\u00e9s de um modelo anal\u00edtico trigonom\u00e9trico, para calcu-\nlar a dist\u00e2ncia e a altura de obst\u00e1culos, utilizando as rela\u00e7\u00f5es geom\u00e9tricas de inclina\u00e7\u00e3o\n(\u00e2ngulo) da bengala branca no solo e dos sonares na bengala, atrav\u00e9s dessas informa-\n\u00e7\u00f5es pode-se determinar o melhor foco do sensor ultrass\u00f4nico na rela\u00e7\u00e3o bengala-objeto.\nPara garantir o melhor foco dos sensores ultrass\u00f4nicos em \u00e2ngulos retos com os objetos,\ndeve ser utilizado um sistema de controle em malha fechada, realimentado com sensores\ninerciais para garantir a melhor abrang\u00eancia dos sensores ultrass\u00f4nicos com os objetos.\nServomotores precisam estar acoplados ao sensores ultrass\u00f4nicos para ajustar a sua posi-\n\u00e7\u00e3o conforme o \u00e2ngulo da bengala com o solo.\n\nA seguir vemos a configura\u00e7\u00e3o para o segundo modelo conceitual do projeto, a nova\nproposta cont\u00e9m apenas o sistema embarcado referente a micro navega\u00e7\u00e3o na bengala\neletr\u00f4nica. J\u00e1 para a macro navega\u00e7\u00e3o, o sistema embarcado deve ser dedicado e adaptado\nno corpo do deficiente visual, retirando assim, um pouco do peso da bengala eletr\u00f4nica, a\nFigura 49 mostra o projeto do sistema.\n\nFigura 49: Modelo conceitual do projeto da bengala eletr\u00f4nica\n\nA Tabela 3, mostra a fus\u00e3o dos componentes com as marca\u00e7\u00f5es apresentadas, agora\npara a segunda configura\u00e7\u00e3o do modelo conceitual do projeto.\n\nDiferentemente da bengala branca tradicional, que acompanha os desn\u00edveis do piso,\nmas n\u00e3o pode prever objetos em diferentes posi\u00e7\u00f5es e nem informar a localiza\u00e7\u00e3o global,\no equipamento proposto possui sistema embarcado. Para uma melhor descri\u00e7\u00e3o do projeto\nfoi desenvolvido um diagrama de blocos, Figura 50, que \u00e9 um diagrama cujo objetivo \u00e9 a\nrepresenta\u00e7\u00e3o gr\u00e1fica do processo e modelo do sistema. Atrav\u00e9s de figuras geom\u00e9tricas e\nliga\u00e7\u00f5es, descrevem-se as rela\u00e7\u00f5es entre cada subsistema e o fluxo de informa\u00e7\u00e3o.\n\nOs m\u00f3dulos e os sensores estimulam os atuadores indicando a geolocaliza\u00e7\u00e3o, n\u00edvel\nde luz do ambiente e a evid\u00eancia de objetos. A geolocaliza\u00e7\u00e3o e a intensidade de luz s\u00e3o\ninformadas por \u00e1udio, j\u00e1 a exist\u00eancia de obst\u00e1culos \u00e9 confirmada pela vibra\u00e7\u00e3o gerada\npor atuadores vibrat\u00f3rios (micromotores), as intensidades de vibra\u00e7\u00f5es mudam conforme\n\n\n\n90\n\nTabela 2: Rela\u00e7\u00e3o dos componentes eletr\u00f4nicos com as marca\u00e7\u00f5es da Figura 49.\nMarca\u00e7\u00f5es na Imagem\n\nComponentes\n1a e 1b 2a e 2b 3 4a e 4b 5 6a e 6b 7a e 7b 8 9 10 11\n\nMotor Vibra\u00e7\u00e3o X\nMCU ou SoC X\n\nLDR X\nRadiofrequ\u00eancia X\nSensor Inercial X\n\nServomotor X\nSonar X\nGPS X\nGSM X\n\u00c1udio X\n\nC\u00e2mera X\n\nM\u00f3dulos e Sensores\n\nSensor\n\nInercial \nM\u00f3dulo\n\nGSM\n\n Sensor\n\nSonar \n\nServo\n\n motor \n\nFigura 50: Diagrama de Blocos do projeto da Bengala Eletr\u00f4nica.\n\n\n\n91\n\nmudam as distancias da bengala eletr\u00f4nica com os obst\u00e1culos. Um micromotor deve\nser inserido em um dispositivo de tato, localizado no cabo (pega) do prot\u00f3tipo e outro\ninserido no pulso (da m\u00e3o contr\u00e1ria que segura a bengala) do deficiente visual, em forma\nde pulseira eletr\u00f4nica. Assim o usu\u00e1rio do dispositivo pode tomar decis\u00f5es conforme\nas informa\u00e7\u00f5es recebidas dos micromotores de vibra\u00e7\u00e3o e ganhar mais confian\u00e7a no seu\ndeslocamento, podendo detectar previamente poss\u00edveis obst\u00e1culos abaixo (vibra\u00e7\u00f5es no\ncabo) ou acima (vibra\u00e7\u00f5es na pulseira) da linha de cintura.\n\nNo entanto, os est\u00e1gios do desenvolvimento de sistemas de tempo real s\u00e3o modula-\nres e estruturados, como em qualquer projeto de rob\u00f3tica, ferramentas e metodologias\nest\u00e3o dispon\u00edveis para auxiliar no desenvolvimento, dentre as quais podemos citar a es-\npecifica\u00e7\u00e3o utilizando an\u00e1lise estruturada com metodologias SART (Structured Analysis\nReal-Time) e metodologias de projeto baseadas no paradigma de orienta\u00e7\u00e3o a objetos com\nmodelagem UML. Independente da metodologia escolhida ela deve lhe proporcionar a de-\ncomposi\u00e7\u00e3o do projeto em partes de forma a possibilitar sua compreens\u00e3o e administrar\nsua complexidade. Essas partes podem ser representadas como modelos que descrevem e\nabstraem aspectos essenciais do sistema.\n\n4.4.4 Desenvolvimento do Sistema com An\u00e1lise Estruturada\n\nAssim como todas as metodologias de an\u00e1lise de requisitos de software, a an\u00e1lise es-\ntruturada \u00e9 utilizada para ser uma atividade de desenvolvimento de modelos com fluxo\nde dados e conte\u00fado das informa\u00e7\u00f5es divididas em parti\u00e7\u00f5es funcionais, representando as\ncaracter\u00edsticas do que se deve ser desenvolvido. As primeiras metodologias de projeto vol-\ntadas para sistemas tempo real surgiram como extens\u00e3o \u00e0s t\u00e9cnicas de an\u00e1lise estruturada.\nUma das mais importantes destas extens\u00f5es foram as metodologias SA-RT (Structured\nAnalysis Real-Time). A partir do m\u00e9todo SA-RT, podemos descrever o problema a ser\nsolucionada com uma decomposi\u00e7\u00e3o funcional com uso de diagramas, listas, m\u00e1quina de\nestado e dicion\u00e1rios de dados. Os requisitos do projeto s\u00e3o apresentados por Diagrama\nde Fluxo de Dados (DFD) que mostram como os dados s\u00e3o processados pelo sistema em\ntermos de entradas e sa\u00eddas. O modelo fundamental do sistema ou modelo de contexto\n(n\u00edvel 0) representa o controle do sistema atrav\u00e9s de um processo principal e em sua volta\nentidades e fluxos de dados os quais possuem rela\u00e7\u00e3o direta com o sistema do controle.\nA Figura 51 apresenta o diagrama de contexto do projeto.\n\nO DFD de n\u00edvel 1, representado na Figura 52, \u00e9 particionado utilizando as extens\u00f5es\nde Ward e Mellor (1986) para representar mais detalhes do sistema global. O primeiro\nn\u00edvel do DFD mostra os processos principais do sistema. Os processos que comp\u00f5e o\nsistema s\u00e3o subfun\u00e7\u00f5es do sistema global descrito no modelo de contexto e s\u00e3o definidos\ncomo tarefas que s\u00e3o executadas em paralelo. O processo de controle (bolha tracejada)\ndenominado como \"Controle Opera\u00e7\u00f5es\"executa todos os fluxos de dados recebidos dos\ndemais processos de dados do sistema e conforme os fluxos de informa\u00e7\u00e3o realiza o aci-\nonamento dos atuadores de vibra\u00e7\u00e3o e \u00e1udio.\n\nO diagrama de transi\u00e7\u00e3o de estado (DTE), Figura 53, \u00e9 o detalhamento do processo\nde controle \"Controle Opera\u00e7\u00f5es\"e representa o comportamento do sistema mostrando os\nestados e os eventos que fazem o sistema mudar de estado. O DTE indica que a\u00e7\u00f5es s\u00e3o\niniciadas como consequ\u00eancia de eventos. Um estado \u00e9 qualquer modo de comportamento\nobserv\u00e1vel, atrav\u00e9s dele os fluxos de dados do sistema s\u00e3o sequenciados e inicializados\nde acordo com a solicita\u00e7\u00e3o.\n\nA principal vantagem da an\u00e1lise estruturada \u00e9 no desenvolvimento de um requisito\nde sistema. Ter um modelo de requisitos completo em um diagrama estruturado ajuda a\n\n\n\n92\n\nCONTROLADOR\nBENGALA\n\nAMBIENTE\nLUMINISIDADE\n\nPOSI\u00c7\u00c3O\nGEOGR\u00c1FICA\n\nCENTRAL DE \nRASTREAMENTO\n\nOBST\u00c1CULOS\n\nNAVEGA\u00c7\u00c3O\nINERCIAL\n\nDEFICIENTE\nVISUAL\n\nBENGALA\nSOLO\n\nCABO/PEGA\nMICROMOTOR\n\n\u00c1UDIO\n\nLuminosidade  Localiza\u00e7\u00e3o\n\nTrilatera\u00e7\u00e3o\n\nDist\u00e2ncia\n\n Dados\nInerciais \u00c2ngulo\n\nComandos\n\nVibra\u00e7\u00e3o Som\n\nSERVOMOTOR\n\nposi\u00e7\u00e3o\n\nFigura 51: Diagrama de Contexto do Dispositivo Eletr\u00f4nico. Fonte: Autor.\n\nM\u00d3DULOS E\nSENSORES\n\nVERIFICAR\nCOLIS\u00c3O\n\nCONTROLE\nOPERA\u00c7\u00d5ES\n\nBENGALA\nELETR\u00d4NICA\n\nVERIFICAR\nLUZ\n\nVERIFICAR\nIN\u00c9RCIA\n\nLuminosidade\n\nTrilatera\u00e7\u00e3o\n\nDist\u00e2ncia\n\n Dados \nInerciais\n\nVERIFICAR\n\u00c2NGULO\n\nVERIFICAR\nLOCALIZA\u00c7\u00c3O\n\n\u00c2ngulo\n\nDist\u00e2ncia\n Medida\n\nPerigo de\n  Colis\u00e3o\n\nLuminosidade \n    Medida\n\n In\u00e9rcia\n Medida\n\n      N\u00edvel\nLuminosidade\n\nPosi\u00e7\u00e3o Geogr\u00e1fica \n\nLat.Lon.\nDeslocamento\n     Angular\n\nPosi\u00e7\u00e3o Angular\n\n\u00c2ngulo\n\nConfigura\u00e7\u00f5es\n\nComandos\n\n Som\n\nVibra\u00e7\u00e3o\n\nLigar\n\nDesligar\n\nLog de Dados\n\n protocolos de comunica\u00e7\u00e3o\n\n   Posi\u00e7\u00e3o\n Servomotor\n\nLocaliza\u00e7\u00e3o\n\nFigura 52: Extens\u00e3o Representando Ward e Mellor - DFD n\u00edvel 1\n\n\n\n93\n\nBENGALA \nELETR\u00d4NICA\n\nM\u00d3DULOS E \nSENSORES\n\nCONTROLE DA\nOPPERA\u00c7\u00c3O\n\n\"In\u00edcio\"\n\n\"Ligar/Desligar, Comandos\"\n\n\"Ligar\"\n\n     \"N\u00edvel Luminosidade\" \"Localiza\u00e7\u00e3o Lat.Long\"\n\n\"Perigo Colis\u00e3o\" \"Deslocamento Inercial\"\n\nENABLE: Verificar Luminosidade\nENABLE: Verificar Colis\u00e3o\nENABLE: Verificar In\u00e9rcia\nENABLE: Verificar Localiza\u00e7\u00e3o\nENABLE: Verificar \u00c2ngulo\nENABLE: Aquisi\u00e7\u00e3o e Fus\u00e3o dos Dados \n\n\"Sinal do \u00c1udio\"\n\n\"Sinal de Vibra\u00e7\u00e3o\"\n\n\"Sinal de \u00c1udio\"\n\n\"Posi\u00e7\u00e3o\"\n\n\"Posi\u00e7\u00e3o Angular\"\n\n\"\u00c2ngulo\"\n\n\"Desligar\"\n\nDISABLE: M\u00f3dulos e Sensores\nDISABLE: Controle da Opera\u00e7\u00e3o\n\nFigura 53: diagrama de transi\u00e7\u00e3o de estado\n\nassegurar que todos os requisitos s\u00e3o alocados aos componentes da arquitetura do sistema,\nque leva a apresentar uma situa\u00e7\u00e3o do ponto de vista dos dados, ao inv\u00e9s de apresent\u00e1-lo\ndo ponto de vista de qualquer pessoa ou empresa. Os usu\u00e1rios obt\u00eam uma ideia mais clara\ndo sistema proposto pelo diagrama de fluxo de dados, do que a obtida atrav\u00e9s da narrativa\ne fluxograma de sistemas f\u00edsicos, a apresenta\u00e7\u00e3o em termos de fluxo l\u00f3gico consegue\nmostrar mal entendidos e pontos controversos.\n\nComo desvantagem, podemos citar as dificuldades causadas por problemas de comu-\nnica\u00e7\u00e3o, dificuldade em descrever procedimentos, falta de metodologias apropriadas para\najudar na especifica\u00e7\u00e3o dos sistemas, problemas de manuten\u00e7\u00e3o do documento de especi-\nfica\u00e7\u00e3o, grau de detalhamento necess\u00e1rio, principalmente na constru\u00e7\u00e3o do dicion\u00e1rio de\ndados e mudan\u00e7as de requisitos tornam a an\u00e1lise estruturada uma fase cr\u00edtica no desen-\nvolvimento de sistemas (WARD; MELLOR, 1986).\n\n4.4.5 Desenvolvimento do Sistema com An\u00e1lise Orientada a Objetos\n\nNos \u00faltimos anos, as metodologias de projeto baseadas no paradigma de orienta\u00e7\u00e3o\na objetos t\u00eam sido apontadas como uma alternativa interessante para combater as defi-\nci\u00eancias apresentadas pelas t\u00e9cnicas de an\u00e1lise estruturada. Este paradigma apresenta\ndiversas caracter\u00edsticas que facilitam o entendimento do modelo, bem como permite um\nmaior encapsulamento para os dados e facilita o reuso. Consequentemente, o paradigma\nde orienta\u00e7\u00e3o a objetos tamb\u00e9m acabou sendo aplicado com sucesso no desenvolvimento\nde sistemas tempo real. A seguir s\u00e3o apresentados um conjunto de classes e seus relacio-\nnamentos, Figura 54.\n\nA Linguagem de Modelagem Unificada (UML), \u00e9 uma linguagem e n\u00e3o um m\u00e9todo, a\nUML \u00e9 uma linguagem padr\u00e3o de nota\u00e7\u00e3o de projetos. Por nota\u00e7\u00e3o entende-se especificar,\nvisualizar e documentar os elementos de um sistema orientados a objeto.\n\nUm diagrama de classes na UML \u00e9 um tipo de diagrama de estrutura est\u00e1tica que\n\n\n\n94\n\nControleBengalaEletronicaSensores Atuadores\n\nModulos\n\nGSMGPS\n\nServomotor\n\nAmplicicadorAudio\n\nSonar\n\nLuz\n\nCamera\n\nInfraVermelho Bussula\n\nAcelerometro\n\nGiroscopio\n\nRadioFrequencia\n\nPonteH\n\nSom MicromotorVibracaoUsuario\n\nSistemasDeControle\n\nPID OdometriaInercial\n\nFigura 54: Diagramas de classes de an\u00e1lise do projeto. Fonte: Autor.\n\ndescreve a estrutura do sistema, mostrando as classes do projeto, seus atributos, opera-\n\u00e7\u00f5es, e as rela\u00e7\u00f5es de mensagens entre as mesmas. Todas as classes devem fazer sentido\nno dom\u00ednio da aplica\u00e7\u00e3o. Nem todas as classes surgem explicitamente na defini\u00e7\u00e3o do\nproblema; algumas est\u00e3o impl\u00edcitas no dom\u00ednio da aplica\u00e7\u00e3o ou no conhecimento geral.\nPara testar alguns dos dispositivos do estudo de caso em quest\u00e3o, foram desenvolvidos\ndiagramas de classes parciais, como mostra a Figura 55. O modelo de classes parciais do\nprojeto \u00e9 resultante de refinamentos no modelo de classes de an\u00e1lise.\n\nO diagrama de casos de uso, descreve a funcionalidade proposta para o sistema, re-\npresenta uma unidade discreta da intera\u00e7\u00e3o entre um usu\u00e1rio (humano ou m\u00e1quina) e o\nsistema, exercendo um papel importante na an\u00e1lise de sistemas, \u00e9 o principal diagrama\npara ser usado no di\u00e1logo com o usu\u00e1rio na descoberta e valida\u00e7\u00e3o de requisitos, consti-\ntuem elementos que estruturam todas as etapas do processo de software. Em particular, o\ndiagrama de casos de uso, n\u00e3o mostra a ordem na qual as etapas s\u00e3o executadas para atin-\ngir as metas de cada caso de uso. Voc\u00ea pode descrever os detalhes em outros diagramas\ne documentos, que \u00e9 poss\u00edvel vincular a cada caso de uso. O projeto possui nove atores e\nsuas respectivas intera\u00e7\u00f5es com os casos de uso. Desta forma, o diagrama da Figura 56,\nest\u00e1 demostrando a funcionalidade do sistema pretendido.\n\nO diagrama de sequ\u00eancia parcial do projeto, Figura 57, \u00e9 uma esp\u00e9cie de diagrama\nde intera\u00e7\u00e3o que mostra como os processos interagem uns com os outros e em que or-\ndem. \u00c9 uma constru\u00e7\u00e3o de um gr\u00e1fico de sequ\u00eancia de mensagens e intera\u00e7\u00f5es de objetos\ndispostos em sequ\u00eancia temporal. Este diagrama \u00e9 constru\u00eddo a partir do diagrama de\ncasos de usos. Primeiro, define-se qual o papel do sistema (Use Cases), depois, \u00e9 definido\ncomo o software realizar\u00e1 seu papel (Sequ\u00eancia de opera\u00e7\u00f5es). O diagrama de sequ\u00eancia\nd\u00e1 \u00eanfase a ordena\u00e7\u00e3o temporal em que as mensagens s\u00e3o trocadas entre os objetos de\num sistema. Entende-se por mensagens os servi\u00e7os solicitados de um objeto a outro, e as\nrespostas desenvolvidas para as solicita\u00e7\u00f5es.\n\nA vantagem da an\u00e1lise orientada a objetos \u00e9 que ela pode representar melhor o mundo\nreal. A mesma \u00e9 usada desde a an\u00e1lise at\u00e9 o projeto e a implementa\u00e7\u00e3o, de modo que a in-\n\n\n\n95\n\nControleBengalaEletronica\n\n-_distancia: long\n\n-_luz: int\n\n-_deltaGPS: float\n\n-angulo: int\n\n+BengalaEletronica()\n\n+verificarSonar(dist:long): long\n\n+verificarLuz(luz:int): int\n\n+verificarGPS(delta:float): float\n\n+verificarPosicao(rad:long): long\n\nSonar\n\n-_triggerPin: int\n\n-_echoPin: int\n\n-_distanciaAtual: long\n\n-_duracao: long\n\n-_distancia: long\n\n-_autoMode: boolean\n\n+Sonar(echoPin:int,triggerPin:int)\n\n+distancia(): long\n\n+distanciaMedia(): long\n\n+sonarPing(): void\n\n+getDistancia(): long\n\n+convCM(duracao:long): long\n\nMotorVibracao\n\n-_pwmPin: int\n\n-_velocidade: int\n\n-time: int\n\n+MotorVibracao(pwmPin:int)\n\n+acionaMotor(vel:int,tempo:int): void\n\n+desligaMotor(tempo:int): void\n\nGPS\n\n-_time, _newtime: long\n\n-_date, _new_date: long\n\n-_latitude, _new_latitude: long\n\n-_longitude, _new_longitude: long\n\n-_altitude, _new_altitude: long\n\n-speed. _newspeed: long\n\n+GPS(rx:int,tx:int)\n\n+getPosition(): void\n\n+getDateTime(): void\n\n+getGPS(): void\n\n+feedGPS(): boolean\n\n+gpsDump(): void\n\n+speed(): long\n\n+course(): long\n\n+stats(): void\n\n+f_get_position(): void\n\nLuz\n\n-_ldrPin: int\n\n-_auxPing: int\n\n-_leituraSensor: int\n\n+Luz(ldrPin:int)\n\n+luminosidade(): int\n\n+kuzPing(): void\n\n+getLuz(): int\n\nGSM\n\n-gsmOn: int\n\n-gsmReset: int\n\n-dtmfDataValid: int\n\n-rxStart: int\n\n-pCommBuf: byte\n\n-rxState: byte\n\n-moduleStatus: char\n\n-smsText: char\n\n+GSM(rxPin:int,txPin:int)\n\n+turnOn(baudrate:long): void\n\n+initParam(group:byte): void\n\n+SetSpeaker(offOn:byte): void\n\n+callStatus(phoneNr:char): byte\n\n+isRegistered(): byte\n\n+sendSMS(nr_Str:char): char\n\n+getSMS(posisiton:byte): char\n\nAudio\n\n-altofalantePin: int\n\n-notas[]: char\n\n-batidas[]: int\n\n-comprimento: int\n\n-tempo: int\n\n+playNotas(): void\n\n+playTom(): void\n\n+acionarSom(): void\n\n+desligarSom(): void\n\nUsuario\n\n-nome[]: char\n\n+ligar(): void\n\n+desligar(): void\n\n+comandos(): void\n\nFigura 55: Diagrama de classes parciais do projeto, desenvolvido para testes e implemen-\nta\u00e7\u00f5es. Fonte: Autor.\n\nSISTEMA BENGALA EETR\u00d4NICA\n\nOBST\u00c1CULOS\n\n\u00c1UDIO\n\nSAT\u00c9LITES\n\nAMBIENTE\n\nVerificar\nPosi\u00e7\u00e3o Geogr\u00e1fica\n\nVerificar\nLuminosidade\n\nControle da\nOpera\u00e7\u00e3o\n\nVerificar Colis\u00e3o Verificar In\u00e9rcia\n\nM\u00f3dulos e Sensores\n\nMICROMOTOR\n\nSERVOMOTOR\n\n<<include>>&lt;<include>>\n\n<<include>>&lt;<include>>\n\n<<include>>\n\nANTENAS GSM\n\nDEFICIENTE \nVISUAL\n\nBENGALA\nELETR\u00d4NICA\n\nFigura 56: Diagrama de caso de uso do projeto\n\n\n\n96\n\nDeficienteVisual ControleBengala OBJGPSOBJSonar OBJInercial OBJMicromotor OBJSom OBJServomotor\n\nligar()\n\ngetSonar()\n\nverificarSonar()\n\nligar/desligar micromotor vibra\u00e7\u00e3o\n\non/off motor\n\ngetGPS() verificarGPS()\n\nacionar som referente a localiza\u00e7\u00e3o global\nsom do endere\u00e7o no mapa\n\ngetAngBengala()\nverificarPosicao()\n\nAjusta a posi\u00e7\u00e3o do foco do sonar em um \u00e2ngulo reto com objeto\nAjusta o \u00e2ngulo \n\nFigura 57: diagrama de sequ\u00eancia parcial\n\nforma\u00e7\u00e3o adicionada em uma etapa do desenvolvimento n\u00e3o \u00e9 necessariamente perdida ou\ntraduzida para a etapa seguinte. Ocorre uma redu\u00e7\u00e3o na quantidade de erros com conse-\nquente diminui\u00e7\u00e3o do tempo nas etapas de codifica\u00e7\u00e3o e teste. A cria\u00e7\u00e3o de novos objetos\nque se comuniquem com os j\u00e1 existentes n\u00e3o obriga o desenvolvedor a conhecer o inte-\nrior destes \u00faltimos. As an\u00e1lises de projeto orientadas a objetos t\u00eam como meta identificar\no melhor conjunto de objetos para descrever um sistema de software. O funcionamento\ndeste sistema se d\u00e1 atrav\u00e9s do relacionamento e troca de mensagens entre estes objetos.\nAs desvantagens incluem a apropria\u00e7\u00e3o, porque a an\u00e1lise orientada a objetos nem sempre\nsoluciona os problemas elegantemente. Os crit\u00e9rios para classificar objetos podem mudar\nsignificativamente. Al\u00e9m disso, algumas vezes n\u00e3o \u00e9 poss\u00edvel decompor problemas do\nmundo real em uma hierarquia de classes. O paradigma de objetos n\u00e3o trata bem de pro-\nblemas que requerem limites nebulosos e regras din\u00e2micas para a classifica\u00e7\u00e3o de objetos.\nIsto leva ao pr\u00f3ximo problema: fragilidade. Desde que uma hierarquia orientada a obje-\ntos requer defini\u00e7\u00f5es precisas, se os relacionamentos fundamentais entre as classes chave\nmudam, o projeto original orientada a objetos \u00e9 perdido. Torna-se necess\u00e1rio reanalisar\nos relacionamentos entre os objetos principais e reprojetar uma nova hierarquia de classes\n(GUIMAR\u00c3ES; HENRIQUES; PEREIRA, 2013).\n\n4.4.6 Sistema de Rastreamento\n\nO m\u00f3dulo GPS envia as informa\u00e7\u00f5es de posicionamento global utilizando um pro-\ntocolo de comunica\u00e7\u00e3o, como por exemplo, o protocolo NMEA 0183. Nesse caso, o\nprotocolo \u00e9 baseando em American Standard Code for Information Interchange (ASCII)\ne transmitido serialmente para o controlador que transfere os dados atrav\u00e9s de uma co-\nnex\u00e3o GSM para GGSN (Gateway GPRS Support Node do operador m\u00f3vel que fornece\nos dados para um servidor remoto atrav\u00e9s de uma conex\u00e3o TCP (Transmission Control\nProtocol), como mostra a Figura 58.\n\nCada mensagem contida em um pacote come\u00e7ar\u00e1 com s\u00edmbolo $. Os pr\u00f3ximos cinco\ncaracteres identificam a troca de informa\u00e7\u00e3o e o tipo de mensagem. Os dados s\u00e3o sepa-\nrados por uma v\u00edrgula. H\u00e1 quase vinte tipos de frases interpretadas no protocolo NMEA,\n\n\n\n97\n\n  \n\n    Sistema Embarcado - Esta\u00e7\u00e3o M\u00f3vel\n\nINTERNETGGSN-GPRS\n\nSERVIDOR DE \n  APLICA\u00c7\u00c3O\n\nFront End\n\nSAT\u00c9LITES\n\nBENGALA ELETR\u00d4NICA ANTENA GSM\n\nGATEWAY GPRS SUPPORT NODE\n\nFRONT END\n\nSERVIDOR DE\n     MAPAS\n\nDATABASE\n\nFigura 58: Arquitetura do sistema de rastreamento. Fonte: Autor.\n\nmas quando ele \u00e9 usado com um dispositivo GPS, apenas um par s\u00e3o utilizados.\nAtrav\u00e9s das express\u00f5es regulares, correspondentes aos padr\u00f5es das senten\u00e7as, \u00e9 pos-\n\ns\u00edvel extrair do conjunto de informa\u00e7\u00f5es fornecidas pelo m\u00f3dulo receptor GPS somente\nos dados necess\u00e1rios, como latitude, longitude, indicadores Norte, Sul, Este e Oeste, data,\nhora, altitude e velocidade.\n\nA v\u00edrgula \u00e9 um par\u00e2metro importante no protocolo NMEA 0183, pois quando o equi-\npamento n\u00e3o consegue captar as informa\u00e7\u00f5es do sat\u00e9lite somente as v\u00edrgulas s\u00e3o trans-\nmitidas. Com isso, o software implementado no microcontrolador conta as v\u00edrgulas para\nbuscar as informa\u00e7\u00f5es \u00fateis ao projeto. Depois de receber, a conex\u00e3o, todas as informa-\n\u00e7\u00f5es enviadas pela rede de celular s\u00e3o recebidas, processadas e armazenadas no servidor\nda aplica\u00e7\u00e3o com bancos de dados, Figura 59. Deste modo, pretende-se obter um sistema\npara o rastreamento de bengalas eletr\u00f4nicas para as pessoas com defici\u00eancia visual e assim\nauxiliar em seu deslocamento retornando informa\u00e7\u00f5es da macro e micro navega\u00e7\u00e3o.\n\nA primeira camada, chamada Front-End, usualmente s\u00e3o browsers, que servem para\napresenta\u00e7\u00e3o e algumas valida\u00e7\u00f5es. A segunda camada, \u00e9 a de aplica\u00e7\u00e3o, executada no\nservidor de aplica\u00e7\u00e3o, fazendo assim com que seja mais f\u00e1cil o desenvolvimento, manu-\nten\u00e7\u00e3o e gerenciamento de sistemas complexos. E a terceira camada \u00e9 o servidor de um\nsistema de banco de dados para armazenar as informa\u00e7\u00f5es do projeto. O Zope (Z Ob-\nject Publishing Environment) \u00e9 uma plataforma de desenvolvimento de aplica\u00e7\u00f5es Web\nde c\u00f3digo aberto baseada em Python. Zope integra um grande n\u00famero de ferramentas e\nfuncionalidades das quais uma base de dados objeto, um m\u00f3dulo de publica\u00e7\u00e3o de ob-\njetos Web, e uma linguagem de gera\u00e7\u00e3o din\u00e2mica de p\u00e1ginas. Contrariamente \u00e0s outras\nsolu\u00e7\u00f5es do mercado, a finalidade de Zope n\u00e3o \u00e9 publicar p\u00e1ginas HTML mas objetos\nque podem ser montados automaticamente a partir de componentes cujo comportamento,\ndados e a apar\u00eancia s\u00e3o configur\u00e1veis pelo projetista. Esta abordagem torna poss\u00edvel \u00e0\npublica\u00e7\u00e3o de conte\u00fado Web. O servidor de aplica\u00e7\u00e3o, \u00e9 o sistemas de software que for-\nnece a infraestrutura de servi\u00e7os para a execu\u00e7\u00e3o de aplica\u00e7\u00f5es distribu\u00eddas do projeto. Os\nservidores de aplica\u00e7\u00e3o s\u00e3o executados em m\u00e1quinas servidoras e s\u00e3o acessados pelos cli-\n\n\n\n98\n\nSERVIDOR DE APLICA\u00c7\u00c3O\n               TCP\n\nZOPEBANCO DE DADOS\n       MySQL\n\nmySQLdb Z SQL\n\nSERVIDOR DE APLICA\u00c7\u00c2O\n\nServidor com servi\u00e7os de mapas\n\n   SERVIDOR COM API DE MAPAS\n\nHTML com JAVA script embarcado\n\nFRONT END\n\nFigura 59: Descri\u00e7\u00e3o do sistema com Servidor de Aplica\u00e7\u00e3o, Banco de Dados e Web\nBrowsers Clientes para o sistema de rastreamento\n\n\n\n99\n\nentes atrav\u00e9s de uma conex\u00e3o de rede. Em geral estes servi\u00e7os diminuem a complexidade\ndo desenvolvimento, controlam o fluxo de dados e gerenciam a seguran\u00e7a. O servidor de\naplica\u00e7\u00e3o utiliza a arquitetura chamada de 3-camadas ou n-camadas, que permite um me-\nlhor aproveitamento das caracter\u00edsticas de cada componente (servidor de banco de dados,\nservidor de aplica\u00e7\u00e3o e cliente). E por fim o MySQL \u00e9 o sistema de gerenciamento de\nbanco de dados que utiliza a linguagem SQL (Structured Query Language) para realizar\nconsultas a uma base de dados, \u00e9 tamb\u00e9m r\u00e1pido e flex\u00edvel o suficiente para permitir ar-\nmazenar logs e informa\u00e7\u00f5es provenientes da bengala (esta\u00e7\u00e3o m\u00f3vel) para armazenar as\ninforma\u00e7\u00f5es das aquisi\u00e7\u00f5es dos diferentes dispositivos utilizados no projeto. As princi-\npais vantagens do MySQL s\u00e3o velocidade, robustez, facilidade de uso, e tamb\u00e9m por que\ntrabalha com diferentes plataformas de software de sistema (GUIMAR\u00c3ES; PEREIRA;\nHENRIQUES, 2014).\n\n\n\n\n\n101\n\n5 FRAMEWORK SOA E OS ESTUDOS DE CASOS\n\nEste cap\u00edtulo descreve os resultados obtidos dos dois estudos de casos embarcados\nintegrados com um framework SOA. A implementa\u00e7\u00e3o faz refer\u00eancias diretas sobre o que\nfoi apresentado no cap\u00edtulo anterior, onde a proposta geral dos estudos de casos foram\ndefinidos. A forma como as entidades que fazem parte da arquitetura orientada a servi\u00e7os\ns\u00e3o implementadas s\u00e3o descritos e s\u00e3o apresentados resultados parciais do projeto.\n\n5.1 Proposta de Arquitetura para o Framework SOA\n\nA proposta da arquitetura orientada a servi\u00e7os \u00e9 um modelo para constru\u00e7\u00e3o de solu-\n\u00e7\u00f5es de software que utiliza como seu principal elemento unidades de desenvolvimento\ndenominadas servi\u00e7os, que s\u00e3o elementos auto-descritos, agn\u00f3sticos de plataforma, que\nexecutam fun\u00e7\u00f5es e que podem variar desde simples requisi\u00e7\u00f5es at\u00e9 processos de neg\u00f3-\ncio complexos. O modelo em camadas da arquitetura orientada a servi\u00e7os prove servi\u00e7os\nconsumidos por pessoas ou outras organiza\u00e7\u00f5es para executarem suas atividades, viabi-\nlizando a composi\u00e7\u00e3o de novos servi\u00e7os e processos. A arquitetura proposta foi criada a\npartir dos conceitos abstra\u00eddos em Erl (2007, 2005) e Fugita (2009), fazendo uma fus\u00e3o\ndos agentes junto com as camadas de uma arquitetura SOA, Figuras 09 e 10 da subse\u00e7\u00e3o\n2.6.1.\n\nPara iniciar, \u00e9 importante observar que neste contexto dispomos de dois pap\u00e9is: o\nprovedor, que \u00e9 a organiza\u00e7\u00e3o que efetivamente executa o servi\u00e7o; e o consumidor, que\n\u00e9 a organiza\u00e7\u00e3o que consome o servi\u00e7o. Para que a rela\u00e7\u00e3o entre provedor e consumidor\nocorra de maneira adequada, ambos precisam acordar que fun\u00e7\u00f5es ser\u00e3o disponibilizadas\npelos servi\u00e7os, as informa\u00e7\u00f5es que devem ser informadas pelos consumidores para sua\nexecu\u00e7\u00e3o e o n\u00edvel de servi\u00e7o esperado, contemplando vari\u00e1veis como tempo de resposta,\nvolume e disponibilidade do servi\u00e7o. Estas informa\u00e7\u00f5es s\u00e3o descritas de maneira formal\natrav\u00e9s de uma especifica\u00e7\u00e3o denominada contrato. \u00c9 uma solu\u00e7\u00e3o utilizada na integra\u00e7\u00e3o\nde sistemas e na comunica\u00e7\u00e3o entre aplica\u00e7\u00f5es diferentes. Com esta tecnologia \u00e9 poss\u00edvel\nque novas aplica\u00e7\u00f5es possam interagir com aquelas que j\u00e1 existem e que sistemas desen-\nvolvidos em plataformas diferentes sejam compat\u00edveis. A Figura 60 mostra a arquitetura\nde camadas proposta para o desenvolvimento do framework SOA.\n\nOs servi\u00e7os s\u00e3o componentes que permitem \u00e0s aplica\u00e7\u00f5es enviar e receber dados. A\nproposta da arquitetura SOA, desenvolvida \u00e9 constitu\u00edda por tr\u00eas componentes b\u00e1sicos:\no servidor de registro (broker server ou service registry), o provedor de servi\u00e7os (ser-\nvice provider) e o solicitante de servi\u00e7os (service consumer ou service requestor). As\nintera\u00e7\u00f5es entre esses componentes s\u00e3o de busca, publica\u00e7\u00e3o e intera\u00e7\u00e3o de opera\u00e7\u00f5es.\n\nNa opera\u00e7\u00e3o de publica\u00e7\u00e3o o provedor publica a descri\u00e7\u00e3o do servi\u00e7o de tal forma que\num solicitante possa localiz\u00e1-la. Na opera\u00e7\u00e3o de busca o solicitante obt\u00e9m a descri\u00e7\u00e3o\n\n\n\n102\n\nFigura 60: Arquitetura de camadas do Framework SOA. Fonte: Autor.\n\n\n\n103\n\ndo servi\u00e7o diretamente ou consulta o servidor de registro procurando pelo tipo de servi\u00e7o\ndesejado. Essa opera\u00e7\u00e3o pode ser executada em duas fases distintas: desenvolvimento ou\nexecu\u00e7\u00e3o. Na opera\u00e7\u00e3o de intera\u00e7\u00e3o o solicitante chama ou inicia uma intera\u00e7\u00e3o com o\nprovedor, em tempo de execu\u00e7\u00e3o, utilizando os detalhes contidos na descri\u00e7\u00e3o do servi\u00e7o\npara localizar, contactar e chamar o servi\u00e7o.\n\nO provedor de servi\u00e7os representa a camada que hospeda o servi\u00e7o permitindo que os\nclientes acessem o servi\u00e7o. O provedor de servi\u00e7os fornece o servi\u00e7o e \u00e9 respons\u00e1vel por\npublicar a descri\u00e7\u00e3o do servi\u00e7o que prov\u00ea. O solicitante de servi\u00e7os \u00e9 a aplica\u00e7\u00e3o que est\u00e1\nprocurando, invocando uma intera\u00e7\u00e3o com o servi\u00e7o, ou seja, requisita a execu\u00e7\u00e3o de um\nservi\u00e7o. O consumidor de servi\u00e7o pode ser uma pessoa ou organiza\u00e7\u00e3o. O servidor de\nregistro \u00e9 um reposit\u00f3rio central que cont\u00e9m a descri\u00e7\u00e3o (informa\u00e7\u00e3o) de um servi\u00e7o, e \u00e9\npor meio do servidor de registro que essas descri\u00e7\u00f5es s\u00e3o publicadas e disponibilizadas\npara localiza\u00e7\u00e3o. Os consumidores buscam por servi\u00e7os no servidor de registro e recupe-\nram informa\u00e7\u00f5es referentes \u00e0 interface de comunica\u00e7\u00e3o para os servi\u00e7os durante a fase de\ndesenvolvimento ou durante a execu\u00e7\u00e3o do cliente, denominadas intera\u00e7\u00e3o est\u00e1tica (static\nbind) e intera\u00e7\u00e3o din\u00e2mica (dinamic bind), respectivamente. Na intera\u00e7\u00e3o est\u00e1tica, o cli-\nente recupera a assinatura do servi\u00e7o, necess\u00e1ria \u00e0 codifica\u00e7\u00e3o. Na intera\u00e7\u00e3o din\u00e2mica, o\ncliente recupera os valores de par\u00e2metros e a localiza\u00e7\u00e3o do servi\u00e7o.\n\nPor \u00faltimo, os consumidores se comunicam com os diversos servi\u00e7os por meio do\nbarramento ESB (Enterprise Service Bus) como camada de integra\u00e7\u00e3o, tamb\u00e9m respon-\ns\u00e1vel por coordenar os processos e servi\u00e7os. A gest\u00e3o dos processos de neg\u00f3cio (Business\nProcess Management) deve ser realizada entre neg\u00f3cio e TI, a fim de realizar a identifica-\n\u00e7\u00e3o e defini\u00e7\u00e3o dos servi\u00e7os bem como a composi\u00e7\u00e3o dos fluxos de neg\u00f3cio, promovendo\na implementa\u00e7\u00e3o de SOA de forma adequada \u00e0s reais necessidades da aplica\u00e7\u00e3o. SOA,\nent\u00e3o \u00e9 uma evolu\u00e7\u00e3o dos paradigmas de arquitetura existentes at\u00e9 o momento. SOA\ncombina elementos interdisciplinares, tais como modelagem e gest\u00e3o de processos de ne-\ng\u00f3cio, arquitetura de Software, computa\u00e7\u00e3o distribu\u00edda e gest\u00e3o de sistemas (FUGITA,\n2009).\n\n5.2 Pap\u00e9is Envolvidos no Uso e Desenvolvimento do Framework SOA\n\nO desenvolvimento tradicional de aplica\u00e7\u00f5es envolve dois tipos de indiv\u00edduo: desen-\nvolvedor de aplica\u00e7\u00e3o e usu\u00e1rio de aplica\u00e7\u00e3o (nos dois casos isto pode corresponder a\ngrupos de indiv\u00edduos, com diferentes fun\u00e7\u00f5es). Desenvolvedores devem levantar os re-\nquisitos de uma aplica\u00e7\u00e3o, desenvolv\u00ea-la (o que inclui a documenta\u00e7\u00e3o que ensina a usar\na aplica\u00e7\u00e3o, como manuais de usu\u00e1rio) e entreg\u00e1-la aos usu\u00e1rios. Usu\u00e1rios interagem\ncom uma aplica\u00e7\u00e3o apenas atrav\u00e9s de sua interface. A Figura 61 apresenta os indiv\u00edduos\nenvolvidos neste caso.\n\nO desenvolvimento de frameworks introduz outro indiv\u00edduo, al\u00e9m de desenvolvedor\ne usu\u00e1rio de aplica\u00e7\u00e3o: o desenvolvedor de framework. No contexto dos frameworks, o\npapel do usu\u00e1rio de aplica\u00e7\u00e3o \u00e9 o mesmo descrito acima. O papel do desenvolvedor de\naplica\u00e7\u00f5es difere do caso anterior pela inser\u00e7\u00e3o do framework no processo de desenvol-\nvimento de aplica\u00e7\u00f5es. Com isto, o desenvolvedor de aplica\u00e7\u00f5es \u00e9 um usu\u00e1rio de um\nframework, que deve estender e adaptar a estrutura deste framework para a produ\u00e7\u00e3o de\naplica\u00e7\u00f5es. Ele tem as mesmas fun\u00e7\u00f5es do caso anterior: obter os requisitos da aplica-\n\u00e7\u00e3o, desenvolv\u00ea-la usando o framework, (o que em geral, n\u00e3o dispensa completamente do\ndesenvolvedor de aplica\u00e7\u00f5es a necessidade de produzir c\u00f3digo) e desenvolver a documen-\nta\u00e7\u00e3o da aplica\u00e7\u00e3o. O novo papel criado no contexto dos frameworks, o desenvolvedor\n\n\n\n104\n\nDesenvolvedor\nde Aplica\u00e7\u00e3o\n\nUsu\u00e1rio \nde Aplica\u00e7\u00e3o\n\nAplica\u00e7\u00e3o\n\ndesenvolve usa\n\nFigura 61: Elementos do desenvolvimento tradicional de aplica\u00e7\u00f5es. Fonte: (SILVA,\n2000).\n\nde framework, tem a responsabilidade de produzir frameworks e algum modo de ensinar\ncomo us\u00e1-los para produzir aplica\u00e7\u00f5es. A Figura 62 apresenta os indiv\u00edduos envolvidos\nneste \u00faltimo caso\n\nDesenvolvedor\nde Framework\n\nUsu\u00e1rio \nde Framework\n\nFramework\n\ndesenvolve usa\nUsu\u00e1rio \n\nde Aplica\u00e7\u00e3o\n\nAplica\u00e7\u00e3o\n\nusadesenvolve\n\nFigura 62: Elementos do desenvolvimento de aplica\u00e7\u00f5es baseado em frameworks. Fonte:\n(SILVA, 2000).\n\nPara uma melhor abstra\u00e7\u00e3o dos pap\u00e9is envolvidos no projeto do framework SOA, \u00e9\napresentado um modelo conceitual, que prov\u00ea uma solu\u00e7\u00e3o para uma fam\u00edlia de problemas\nsemelhantes, onde as aplica\u00e7\u00f5es possuem em comum um mesmo tipo de problema. Para\ntanto, o framework deve ser constitu\u00eddo por um conjunto de classes abstratas e concretas,\nbibliotecas de c\u00f3digo e componentes de software que colaboram para atingir um mesmo\nobjetivo. A Figura 63 mostra os elementos contidos no modelo conceitual.\n\nA\n\nD\n\nG\n\nB\n\nE\n\nH\n\nC\n\nF\n\nI\n\nG B A\n\nC H F\n\nAn\u00e1lise do Dom\u00ednio Framework Aplica\u00e7\u00f5es\n\nAplica\u00e7\u00e3o 1\n\nAplica\u00e7\u00e3o N\n\nFigura 63: Os elementos utilizados nas aplica\u00e7\u00f5es s\u00e3o baseados nos servi\u00e7os fornecidos\npelo framework. Fonte: Autor.\n\nO uso de framework em projetos apresenta algumas vantagens: modularidade, pois\npermite encapsular implementa\u00e7\u00f5es flex\u00edveis em uma interface est\u00e1vel; reuso, uma vez\n\n\n\n105\n\nque define elementos gen\u00e9ricos que podem ser reaproveitados e ao mesmo tempo per-\nmitir a efici\u00eancia das aplica\u00e7\u00f5es. Na fase de an\u00e1lise do dom\u00ednio \u00e9 feita uma avalia\u00e7\u00e3o\ndo problema a ser tratado para tornar conhecido seu dom\u00ednio e aprofundar a experi\u00eancia\nnuma dada fam\u00edlia de aplica\u00e7\u00f5es (SILVA, 2000).\n\n5.3 Reposit\u00f3rio do Framework SOA\n\nNo contexto da Engenharia de Software, diferentes abordagens buscam melhorar a\nqualidade dos artefatos de software, bem como diminuir o tempo e o esfor\u00e7o necess\u00e1-\nrios para produzi-los. Como j\u00e1 mencionado no cap\u00edtulo 2, frameworks s\u00e3o estruturas de\nclasses que constituem implementa\u00e7\u00f5es incompletas que, estendidas, permitem produzir\ndiferentes artefatos de software. A grande vantagem desta abordagem \u00e9 a promo\u00e7\u00e3o de\nreuso de c\u00f3digo e projeto, que pode diminuir o tempo e o esfor\u00e7o exigidos na produ\u00e7\u00e3o\nde software.\n\nFoi definida a utiliza\u00e7\u00e3o da linguagem de programa\u00e7\u00e3o Java para o desenvolvimento\ndo framework SOA pretendido. Java \u00e9 o termo geral usado para denotar o software e seus\ncomponentes, que incluem Java Runtime Environment (JRE), Java Virtual Machine (JVM)\ne tamb\u00e9m plug-in. A linguagem suporta reflex\u00e3o, o que ajuda a expor de forma din\u00e2mica\na funcionalidade dos servi\u00e7os e prov\u00ea centenas de frameworks e API\u2019s para as mais diver-\nsas finalidades, tamb\u00e9m h\u00e1 uma enorme quantidade de projetos Java bem organizados e\nde c\u00f3digo aberto que s\u00e3o relevantes para a rob\u00f3tica. A linguagem de programa\u00e7\u00e3o foi es-\ncolhido para facilitar a interoperabilidade e alavancar essa funcionalidade potencial, al\u00e9m\nde suportar implementa\u00e7\u00e3o de bibliotecas escrita em C/C++, Assembler, e outras tantas\nlinguagens de programa\u00e7\u00e3o utilizando Java Native Interface (JNI) em conjunto com Java\nNative Access (JNA), que \u00e9 uma biblioteca que abstrai essas chamadas e os tipos de dados\nde uma linguagem para outra que facilita muito a integra\u00e7\u00e3o.\n\nPara fazer a integra\u00e7\u00e3o de um ambiente para a manipula\u00e7\u00e3o e controle de diferentes\nservi\u00e7os de software e hardware foi escolhido o framework SOA Myrobotlab, que dis-\nponibiliza um conjunto de classes, bibliotecas de c\u00f3digo e componentes, que colaboram\npara prestar diferentes tipos de servi\u00e7os. Do ponto de vista pr\u00e1tico do projeto pretendido,\no framework SOA Myrobotlab \u00e9 utilizado como uma semi-aplica\u00e7\u00e3o flex\u00edvel e extens\u00edvel\npara permitir a elabora\u00e7\u00e3o de partes complementares espec\u00edficas das aplica\u00e7\u00f5es poss\u00edveis,\ncomo por exemplo, os estudos de caso apresentados no cap\u00edtulo 5. H\u00e1 duas maneiras de\nusar o framework SOA MyRobotLab. Eles s\u00e3o:\n\n\u2022 Modo Desenvolvedor - modo desenvolvedor \u00e9 algu\u00e9m que est\u00e1 interessado em reu-\ntilizar as classes, bibliotecas de c\u00f3digos e artefatos de software, para adaptar e es-\ntender as funcionalidades para diferentes aplica\u00e7\u00f5es ou criar novos servi\u00e7os. Para\nutilizar o framework no modo desenvolvedor o requisito obrigat\u00f3rio \u00e9 saber pro-\ngramar. No modo desenvolvedor \u00e9 preciso descarregar os pacotes do reposit\u00f3rio\ndo servidor do Myrobotlab, local do armazenamento dos pacotes do software que\npodem ser recuperados e instalados em um computador host. Muitos editores de\nsoftware e outras organiza\u00e7\u00f5es mant\u00eam servidores na internet para este fim. Este\n\u00e9 o modo utilizado para o desenvolvimento da proposta do framework SOA, onde\natrav\u00e9s do reuso \u00e9 poss\u00edvel criar um framework SOA aplicado para os estudos de\ncasos.\n\n\u2022 Usu\u00e1rio - algu\u00e9m que usa o framework SOA Myrobotlab em algum projeto. Eles\nest\u00e3o interessados em utilizar as capacidades atuais do framework SOA e n\u00e3o est\u00e3o\n\n\n\n106\n\ninteressados no desenvolvimento de novos servi\u00e7os. Embora seja poss\u00edvel desen-\nvolver novas funcionalidades em Python dentro de um contexto \u2019Usu\u00e1rio\u2019 e n\u00e3o\nprecisando de uma IDE para desenvolvimento ou quaisquer outras depend\u00eancias.\n\nMyrobotlab \u00e9 executado no Java, portanto \u00e9 multi-plataforma e qualquer computa-\ndor ou dispositivo que suporte esta JVM conceitualmente poder\u00e1 executar o framework.\nAlguns dos servi\u00e7os oferecidos por Myrobotlab incluem, suportar tarefas de multithrea-\nded, solu\u00e7\u00f5es distribu\u00eddas e capacidade de multiprocesso. Integra outros componentes de\nprojetos de c\u00f3digo aberto para as funcionalidade de servi\u00e7os, suporta comunica\u00e7\u00e3o serial\ncom microprocessadores. Possui servi\u00e7o de vis\u00e3o de m\u00e1quina, sistema de controle, reco-\nnhecimento de Voz, s\u00edntese de fala, entre outros servi\u00e7os. A Figura 64 mostra o diagrama\nde blocos da instala\u00e7\u00e3o do reposit\u00f3rio do Myrobotlab.\n\nmyrobotlab\n\nrepo\n\nhttps://github.com/MyRobotLab\ncomputer\n\n1. download myrobotlab.jar\n\nlocal cache\n\n$user.dir/.repo\n\nmyrobotlab install\n\ndirectory\n\n$mrl.dir\n\n2. request for Services 3. Service dependencies downloaded\n\nto local cache via Ivy24. copied from local cache to\n\nlibraries - serviceData.xml updated\n\n\"retrieve\" - copies files, unzips, and\n\nprocesses any dependencies\n\nMyRobotLab Initial Install\n\nService Installs\n\n1\n\n2\n\n3\n\n4\n\nFigura 64: Reposit\u00f3rio dos pacotes Myrobotlab. Fonte: (MYROBOTLAB, 2014).\n\nPara utilizar o Myrobotlab no modo desenvolvedor \u00e9 utilizado o ambiente Eclipse\npara desenvolvimento Java. O Eclipse \u00e9 a IDE (Integrated Development Environment)\nou seja ambiente integrado de desenvolvimento. O que pesou a escolha da IDE foi a\ngrande comunidade open-source do software, cujos projetos est\u00e3o focados em construir\numa plataforma aberta de desenvolvimento composta por ferramentas e runtimes para\na constru\u00e7\u00e3o, implanta\u00e7\u00e3o e gest\u00e3o de software em todo o ciclo de vida, al\u00e9m de ser o\nambiente de desenvolvimento padr\u00e3o do Myrobotlab (MYROBOTLAB, 2014).\n\n5.4 Implanta\u00e7\u00e3o do Projeto\n\nEntre as vers\u00f5es 1.5 e 2.0 da UML, diversas altera\u00e7\u00f5es ou evolu\u00e7\u00f5es foram realiza-\ndas. Muitos dos diagramas abordados ao longo deste artigo s\u00e3o resultados n\u00edtidos de tal\nevolu\u00e7\u00e3o da UML. O Diagrama de Implanta\u00e7\u00e3o determina as necessidades de hardware\ndo sistema, as caracter\u00edsticas f\u00edsicas como servidores, esta\u00e7\u00f5es, topologias e protocolos\nde comunica\u00e7\u00e3o, ou seja, todo o aparato f\u00edsico sobre o qual o sistema dever\u00e1 ser execu-\ntado. Os Diagramas de Componentes e de Implanta\u00e7\u00e3o s\u00e3o bastante associados, podendo\nser representados em separado ou em conjunto. \u00c9 o diagrama com a vis\u00e3o mais f\u00edsica\nda UML. Este diagrama foca a quest\u00e3o da organiza\u00e7\u00e3o da arquitetura f\u00edsica sobe a qual\no software ir\u00e1 ser implantado e executado em termos de hardware, ou seja, as m\u00e1quinas\n\n\n\n107\n\n(computadores pessoais, servidores etc.) que suportam o sistema, al\u00e9m de definir como\nestas m\u00e1quinas ser\u00e3o conectadas e por meio de quais protocolos se comunicar\u00e3o e trans-\nmitir\u00e3o as informa\u00e7\u00f5es.\n\nOs elementos b\u00e1sicos deste diagrama s\u00e3o os N\u00f3s, que representam os componentes,\nAssocia\u00e7\u00f5es entre N\u00f3s, que s\u00e3o as liga\u00e7\u00f5es entre os N\u00f3s do diagrama, e os Artefatos,\nrepresenta\u00e7\u00f5es de entidades f\u00edsicas do mundo real. N\u00f3s podem conter outros n\u00f3s, sendo\ncomum encontrar um n\u00f3 que representa um item de hardware contendo outro n\u00f3 que re-\npresenta um ambiente de execu\u00e7\u00e3o, embora n\u00f3 que represente um item de hardware possa\nconter outros n\u00f3s representando itens de hardware, e um n\u00f3 que represente um ambiente\nde execu\u00e7\u00e3o possa conter outros ambientes de execu\u00e7\u00e3o. Quando um n\u00f3 representa um\nhardware, pode possuir estere\u00f3tipos \u00abdevice\u00bb e \u00abprocessor\u00bb; quando, por\u00e9m, um n\u00f3 re-\npresenta um ambiente de execu\u00e7\u00e3o, pode utilizar o estere\u00f3tipo \u00abExecutionEnvironment\u00bb\n(Da Silva, 2015).\n\nAntes de apresentar os diagramas de implanta\u00e7\u00e3o da integra\u00e7\u00e3o do framework SOA\nMyrobotlab com os estudos de caso do projeto, foram desenvolvidos diagramas de im-\nplanta\u00e7\u00e3o individuais para cada n\u00f3 de hardwaredo projeto: computador servidor, rob\u00f4\nm\u00f3vel e bengala eletr\u00f4nica, cada um dos n\u00f3s modelam o inter-relacionamento entre re-\ncursos de infra-estrutura, de rede ou artefatos de sistemas.\n\nA finalidade do modelo de implanta\u00e7\u00e3o \u00e9 capturar a configura\u00e7\u00e3o dos elementos de\nprocessamento e a conex\u00f5es entre eles no sistema, a Figura 65 apresenta o diagrama de\nimplanta\u00e7\u00e3o parcial do rob\u00f4 m\u00f3vel.\n\nControle e Seguimento \n    de Trajet\u00f3ria\n\nM\u00f3dulos e Sensores\n\nPlanifica\u00e7\u00e3o de Tempo Real \n\nControlador de Movimento Embarcado\n\nROB\u00d4 M\u00d3VEL\n\n<<processador>>\n\nPonte H\n\nMotor DC\n\nEncoder\n\nGirosc\u00f3pio  B\u00fassula \n\nSonar\n\n    Servo\n\nInfravermelho\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>&lt;<dispositivo>>\n\n1...*       1\n\n1...*\n\n1...*\n\n1...*\n\n1...*\n\n1...*        1\n\n1          1...*\n\n1          1...*\n\n1          1...*\n\nAceler\u00f4metro\n<<dispositivo>>\n\n    Radio\nFrequ\u00eancia\n\n<<dispositivo>>\n\nLaser\n<<dispositivo>>\n\nC\u00e2mera\n<<dispositivo>>\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\nFigura 65: Modelo parcial para o diagrama de implanta\u00e7\u00e3o do rob\u00f4 m\u00f3vel. N\u00f3s disposi-\ntivos (ou processadores) podem ser adicionados ou removidos conforme as necessidades\ndo problema a ser resolvido. Fonte: Autor.\n\nO modelo de implanta\u00e7\u00e3o \u00e9 constitu\u00eddo de um ou mais n\u00f3s (elementos de processa-\nmento com pelo menos um processador, mem\u00f3ria e possivelmente outros dispositivos),\ndispositivos (n\u00f3s estereotipados sem capacidade de processamento no n\u00edvel de abstra\u00e7\u00e3o\n\n\n\n108\n\nmodelado) e conectores, entre n\u00f3s, e entre n\u00f3s e dispositivos, a Figura 66 apresenta o\ndiagrama de implanta\u00e7\u00e3o parcial da bengala eletr\u00f4nica.\n\nControle e Seguimento \n    de Trajet\u00f3ria\n\nTriangula\u00e7\u00e3o de Sinal\n\nPlanifica\u00e7\u00e3o de Tempo Real \n\nControlador de Navega\u00e7\u00e3o Embarcado\n\nBengala Eletr\u00f4nica\n<<processador>>\n\n  Driver DC\n\nMicromotor\n Vibra\u00e7\u00e3o\n\nServomotor\n\nGirosc\u00f3pio  B\u00fassula \n\nSonar\n\nPhotoresistor\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>\n\n<<dispositivo>>&lt;<dispositivo>>\n\n1...*       1\n\n1...*\n\n1...*\n\n1...*        1\n\n1          1...*\n\n1          1...*\n\nAceler\u00f4metro\n<<dispositivo>>\n\n    GSM\n\n<<dispositivo>>\n\nGPS\n<<dispositivo>>\n\nC\u00e2mera\n\n<<dispositivo>>\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n1\n\n  Amplificador\n\n\u00c1udio/Mic\n<<dispositivo>>\n\n<<dispositivo>>\n1...*       1\n\n1...*\n\n1...*\n\nM\u00f3dulos e Sensores\n\nDrivers Atuadores\n\nInfravermelho\n\n<<dispositivo>>\n1          1...*\n\n   Radiofrequ\u00eancia\n\n<<dispositivo>>\n1          1...*  \n\nFigura 66: Modelo parcial para o diagrama de implanta\u00e7\u00e3o da bengala eletr\u00f4nica. N\u00f3s\ndispositivos (ou processadores) podem ser adicionados ou removidos conforme as neces-\nsidades do problema a ser resolvido. Fonte: Autor.\n\nO modelo de implanta\u00e7\u00e3o tamb\u00e9m mapeia processos para esses elementos de proces-\nsamento, permitindo a distribui\u00e7\u00e3o do comportamento em n\u00f3s a serem representados. Os\nseguintes pap\u00e9is usam o Modelo de Implanta\u00e7\u00e3o:\n\n\u2022 O arquiteto de software - usa o modelo de implanta\u00e7\u00e3o para capturar e compreender\no ambiente de execu\u00e7\u00e3o f\u00edsico do sistema e compreender as quest\u00f5es de distribui-\n\u00e7\u00e3o;\n\n\u2022 Os designers (inclusive de software e de banco de dados) - para compreender a\ndistribui\u00e7\u00e3o do processamento e dos dados no sistema;\n\n\u2022 Os gerente de sistema - para compreender o ambiente f\u00edsico em que o sistema \u00e9\nexecutado;\n\n\u2022 O gerente de projeto - na estimativa de custos para o caso de neg\u00f3cios e para o\nplanejamento de aquisi\u00e7\u00e3o, instala\u00e7\u00e3o e manuten\u00e7\u00e3o.\n\nNa fase de elabora\u00e7\u00e3o, o modelo de implanta\u00e7\u00e3o ser\u00e1 refinado para um n\u00edvel de espe-\ncifica\u00e7\u00e3o, permitindo que o arquiteto de software preveja o desempenho com confian\u00e7a,\n\n\n\n109\n\nantes de finalmente passar o modelo para o n\u00edvel f\u00edsico, no qual ele especifica a quan-\ntidade real de hardware e modelo a ser usada. Assim, ele se tornar\u00e1 um plano para a\naquisi\u00e7\u00e3o, instala\u00e7\u00e3o e manuten\u00e7\u00e3o do sistema. Se o ambiente de implanta\u00e7\u00e3o j\u00e1 existir,\nser\u00e1 examinado para determinar se \u00e9 capaz de suportar as novas capacidades do sistema\nque est\u00e1 sendo desenvolvido. Se forem necess\u00e1rias mudan\u00e7as no ambiente de implanta-\n\u00e7\u00e3o, elas ser\u00e3o identificadas nessa fase. Se o ambiente de implanta\u00e7\u00e3o ainda n\u00e3o existir,\nser\u00e3o definidos os n\u00fameros, os tipos e as configura\u00e7\u00f5es dos n\u00f3s e da conex\u00e3o entre os n\u00f3s\nnecess\u00e1rios para suportar a arquitetura.\n\n5.4.1 Resultados do Computador Host com Framework SOA Myrobotlab\n\nO diagrama de implanta\u00e7\u00e3o representa como \u00e9 realizada a distribui\u00e7\u00e3o do sistema\natrav\u00e9s de n\u00f3s de hardware, componentes e depend\u00eancias de software e suas devidas\nrela\u00e7\u00f5es de comunica\u00e7\u00e3o. A a Figura 67 apresenta o diagrama de implanta\u00e7\u00e3o parcial do\ncomputador hospedeiro do projeto.\n\nSistema Operacional     \n                                                    \n\n \n\nSistema Computacional\n\n<<processor>>\n\nMonitor\n\nMouse\n\n Disco R\u00edgido<<device>>\n1...*       1\n\n1            1\n\n1          1...*\n\nFramework\n     SOA \n\nBanco de Dados  \n\nDrivers  \n\nI/O       \n\nTeclado\n\nHost\n\nInterface\n de rede\n\n1            1\n\n1\n\n1...*\n\n1          1...*\n<<processor>>\n\n C\u00e2mera\n1          1...*\n\n<<device>>\n\n<<device>>\n\n<<device>>\n\n<<device>>\n\n<<device>>\n        ou\n\n<<device>>\n\nFigura 67: Modelo parcial para o diagrama de implanta\u00e7\u00e3o do computador Host. N\u00f3s\npodem ser adicionados ou removidos, as defini\u00e7\u00f5es s\u00e3o estabelecidas conforme as neces-\nsidades do problema. Fonte: Autor.\n\nPara implementa\u00e7\u00f5es do framework SOA Myrobotlab no modo desenvolvedor, \u00e9 pre-\nciso descarregar os pacotes repo e myrobotlab do reposit\u00f3rio para o computador Host via\nIDE Eclipse para desenvolvimento Java(MYROBOTLAB, 2014), a Figura 68 apresenta\no sistema parcial dos diret\u00f3rios do sistema Myrobotlab vers\u00e3o 1.0.12.\n\nPosteriormente \u00e9 preciso estudar o JavaDoc da API do Myrobotlab, a interface de\nprograma\u00e7\u00e3o \u00e9 o conjunto de padr\u00f5es que permitem a constru\u00e7\u00e3o de novos aplicativos\ne a sua utiliza\u00e7\u00e3o. H\u00e1 uma p\u00e1gina de hierarquia para todos os pacotes, al\u00e9m de uma\nhierarquia para cada pacote. Cada p\u00e1gina hierarquia cont\u00e9m uma lista de classes e uma\nlista de interfaces. As classes s\u00e3o organizadas por heran\u00e7a, come\u00e7ando a estrutura com\njava.lang.Object. As interfaces n\u00e3o herdam java.lang.Object.\n\nA API do Myrobotlab fornece uma lista de todos os pacotes com uma descri\u00e7\u00e3o geral\nde cada pacote com listas de informa\u00e7\u00f5es de classes, interfaces, m\u00e9todos, construtores e\n\n\n\n110\n\nFigura 68: Sistemas de diret\u00f3rios parciais do framework SOA Myrobotlab para desenvol-\nvedores. Fonte: Autor.\n\noutros campos referentes a implementa\u00e7\u00e3o, essas informa\u00e7\u00f5es foram amplamente utiliza-\ndos neste trabalho com objeto de utilizar e estender o sistema para os estudos de casos. O\nMyrobotlab tem alta granularidade de c\u00f3digos e bibliotecas, as quais possuem documenta-\n\u00e7\u00e3o limitada para desenvolvedores menos experientes com linguagens de programa\u00e7\u00e3o de\nalto n\u00edvel. Tamb\u00e9m possui pouca documenta\u00e7\u00e3o de diagramas da arquitetura de software\ndo sistema, o que torna complexo a utiliza\u00e7\u00e3o e entendimento do sistema legado. A falta\nde materiais \u00e9 proporcional ao tempo de vida do framework SOA Myrobotlab, bem como\na quantidade de colaboradores que ajudam no desenvolvimento do projeto. A classe Run-\ntime do sistema, fornece o acesso ao ambiente de tempo de execu\u00e7\u00e3o em que o aplicativo\nest\u00e1 sendo executado. Os m\u00e9todos do tempo de execu\u00e7\u00e3o permitem executar programas\nexternos a partir de um aplicativo Java. Runtime \u00e9 respons\u00e1vel pela cria\u00e7\u00e3o e remo\u00e7\u00e3o\nde todos os servi\u00e7os existentes e registros est\u00e1ticos associados, ele mant\u00e9m informa\u00e7\u00f5es\nde estado em rela\u00e7\u00e3o a poss\u00edveis servi\u00e7os locais em execu\u00e7\u00e3o e mant\u00e9m informa\u00e7\u00f5es de\nestado sobre Runtimes externos.\n\nA classe Runtime deve ser o \u00fanico servi\u00e7o executando em um processo host e regis-\ntros de mapas s\u00e3o utilizados no roteamento de comunica\u00e7\u00e3o para o servi\u00e7o adequado (seja\nele local ou remoto) ser\u00e1 o primeiro servi\u00e7o criado e ele tamb\u00e9m envolve o objeto real\nJVM Runtime. A Figura 69 mostra parte da representa\u00e7\u00e3o da estrutura interna da classe\nRuntime(pacote de servi\u00e7os), o diagrama apresentado, faz parte das poucas documenta-\n\u00e7\u00f5es existentes no diret\u00f3rio \"docs\", baixado do reposit\u00f3rio Myrobotlab (MYROBOTLAB,\n2014).\n\nA classe Runtime \u00e9 um dos principais recursos existentes do pacote de servi\u00e7os e pode\nser acessado dentro do pacote org.myrobotlab.service.Runtime, descarregado do reposi-\nt\u00f3rio. Antes de executar e depurar a classe Runtime, \u00e9 preciso antes configurar o debug,\nconforme os argumentos da Virtual Machine (VM) do sistema operacional utilizado.\n\n\u2022 Windows VM Argumento :-Djava.library.path=\"libraries/native\nx86.32.windows;libraries/native/x86.64.windows\";\n\n\n\n111\n\nFigura 69: Representa\u00e7\u00e3o da estrutura interna da classe Runtime do pacote de servi\u00e7os.\nFonte: (MYROBOTLAB, 2014).\n\n\n\n112\n\n\u2022 Linux VM Argumento: -Djava.library.path=\"./libraries/native\n/x86.32.linux:./libraries/native/x86.64.linux;\n\n\u2022 Mac VM Argumento: -Djava.library.path=\"./libraries/native/\nx86.32.mac\";\n\nPara executar a GUI do framework SOA Myrobotlab \u00e9 preciso configurar o argumento\nde programa com os seguintes par\u00e2metros:\n\n\u2022 Argumento de programa: -service gui GUIService -logToConsole;\n\nA seguir, a Figura 70 mostra parte da representa\u00e7\u00e3o da estrutura interna da classe\nGUIService (pacote de servi\u00e7os). A classe GUIService \u00e9 onde s\u00e3o criados e utilizados\nos servi\u00e7os, permite que recursos de controle de outros servi\u00e7os sejam exibidos. Ele \u00e9\ndefinido para iniciar automaticamente quando um dos scripts (myrobotlab.bat, myrobo-\ntlab.sh, jython.bat, ou jython.sh) s\u00e3o executados. As aplica\u00e7\u00f5es gr\u00e1ficas s\u00e3o aquelas que\npossibilitam o uso ou a cria\u00e7\u00e3o de uma Graphical User Interface (GUI).\n\nFigura 70: Representa\u00e7\u00e3o da estrutura interna da classe GUIService do pacote de servi\u00e7os.\nFonte: (MYROBOTLAB, 2014).\n\nAo desenvolver uma aplica\u00e7\u00e3o dotada de uma GUI, \u00e9 necess\u00e1rio definir quais com-\nponentes (objetos) ser\u00e3o utilizados e a disposi\u00e7\u00e3o que eles ter\u00e3o na janela, conforme o\nprojeto Intera\u00e7\u00e3o Homem-M\u00e1quina (IHM). O swing possui in\u00fameras classes utilizadas na\nconstru\u00e7\u00e3o da GUI do framework SOA Myrobotlab. Neste ponto, o projeto come\u00e7a a ficar\ninteressante, pois as aplica\u00e7\u00f5es s\u00e3o criadas e controladas a partir de janelas gr\u00e1ficas. Ao\nprojetar uma aplica\u00e7\u00e3o gr\u00e1fica, \u00e9 necess\u00e1rio definir todos os componentes que ser\u00e3o utili-\nzados, seus objetivos e sua posi\u00e7\u00e3o na janela. A Figura 71 mostra a primeira execu\u00e7\u00e3o e\ndepura\u00e7\u00e3o da classe Runtime da vers\u00e3o 1.0.12 do framework SOA Myrobotlab.\n\nAp\u00f3s a inicializa\u00e7\u00e3o da GUI, podem ser observadas tr\u00eas abas principais: frame \"wel-\ncome\", frame \"gui\" e frame \"runtime\". A aba do frame \"welcome\", \u00e9 respons\u00e1vel pelas\nboas vindas do sistema e \u00e9 o primeiro frame que o usu\u00e1rio tem contato.\n\n\n\n113\n\nFigura 71: Primeira inicializa\u00e7\u00e3o do Runtime ap\u00f3s configura\u00e7\u00f5es dos argumentos do sis-\ntema. Execu\u00e7\u00e3o da GUI do framework SOA Myrobotlab v1.0.12. Fonte: Autor.\n\n\n\n114\n\nA aba do frame \"gui\", \u00e9 respons\u00e1vel por fornecer servi\u00e7os com mapas de rotas de\nmensagens e \u00edcones dos servi\u00e7os atualmente em execu\u00e7\u00e3o, onde tamb\u00e9m podem ser pas-\nsados par\u00e2metros de entradas e sa\u00eddas para os objetos. A Figura 72 apresenta o frame do\nservi\u00e7o \"gui\".\n\nFigura 72: Acesso a aba do frame \"gui\". Respons\u00e1vel por fornecer o controle dos servi\u00e7os\nem execu\u00e7\u00e3o. Fonte: Autor.\n\nE por \u00faltimo a aba do frame \"runtime\", \u00e9 respons\u00e1vel pelo fornecimento de todos os\nservi\u00e7os dispon\u00edveis, onde o servi\u00e7o requerido pelo consumidor \u00e9 inicializado em uma\nnova aba na GUI do sistema. A Figura 73, mostra alguns dos servi\u00e7os fornecidos por\ndefault na GUI, acessados pela aba runtime.\n\nDo reposit\u00f3rio Myrobotlab v1.0.12, apenas alguns dos servi\u00e7os vem instalados por\ndefault, para fazer a instala\u00e7\u00e3o de todos os servi\u00e7os deve-se inicializar a GUI do usu\u00e1rio e\nacessar a aba \"runtime\", menu \"system\"e \"install all\", assim, todos os servi\u00e7os ser\u00e3o ins-\ntalados e atualizados direto do reposit\u00f3rio do framework SOA Myrobotlab. A instala\u00e7\u00e3o\nde servi\u00e7os tamb\u00e9m pode ser feita individualmente, instalando somente o servi\u00e7o reque-\nrido, caso n\u00e3o haja a necessidade de ter todos os servi\u00e7os instalados. Ap\u00f3s a instala\u00e7\u00e3o ou\natualiza\u00e7\u00e3o \u00e9 preciso reiniciar a execu\u00e7\u00e3o do sistema para os servi\u00e7o ficarem dispon\u00edveis.\nA Figura 74, apresenta todos os servi\u00e7os instalados na GUI, acessados pela aba do frame\n\"runtime\". Vale ressaltar, que alguns servi\u00e7os, mesmo depois de instalados, podem n\u00e3o\nestar ativados ou implementados,\n\n\n\n115\n\nFigura 73: Servi\u00e7os dispon\u00edveis na aba \"runtime\" da GUI. Fonte: Autor.\n\n\n\n116\n\nFigura 74: Frame \"runtime\"da GUI do framework SOA Myrobotlab inicializado com\ntodos os servi\u00e7os instalados e atualizados. Fonte: Autor.\n\n\n\n117\n\nA Figura 75, apresenta como \u00e9 feito o acesso e a inicializa\u00e7\u00e3o de servi\u00e7os no frame\n\"runtime\", como exemplo, usaremos dois servi\u00e7os do Myrobotlab: o primeiro servi\u00e7o \u00e9\npouco implementado e n\u00e3o \u00e9 fornecido(\"RasPi\"), j\u00e1 o segundo servi\u00e7o \u00e9 fornecido e bem\nconsolidado(OpenCV ).\n\nFigura 75: Iniciando um servi\u00e7o do Frame \"runtime\". Fonte: Autor.\n\nPara o primeiro exemplo, de um servi\u00e7o n\u00e3o fornecido, \u00e9 inicializado o servi\u00e7o Rasp-\nberry Pi, a nova aba do frame \"service RasPi\" abre vazia. Para utilizar o servi\u00e7o ou o\nque existe dele, \u00e9 preciso ir ao site e ler as instru\u00e7\u00f5es para o servi\u00e7o n\u00e3o fornecido (MY-\nROBOTLAB, 2014). A Figura 76, apresenta o novoframe aberto ap\u00f3s a inicializa\u00e7\u00e3o do\nservi\u00e7o.\n\nEsses servi\u00e7os n\u00e3o fornecidos, quando acessados apresentam um frame vazio. A usa-\nbilidade e n\u00edvel de implementa\u00e7\u00e3o dos servi\u00e7os instalados do reposit\u00f3rio Myrobotlab,\nest\u00e3o descritos no site do projeto (MYROBOTLAB, 2014), portanto, dependendo do ser-\nvi\u00e7o requerido em \"runtime\", o mesmo pode estar fornecido ou n\u00e3o fornecido, passando\npara o desenvolvedor a responsabilidade de continuar ou come\u00e7ar do zero a implementa-\n\u00e7\u00e3o do servi\u00e7o requerido.\n\nO servi\u00e7o requerido, neste caso, \u00e9 um servi\u00e7o fornecido, com boa implementa\u00e7\u00e3o e\nusabilidade no framework SOA Myrobotlab. O servi\u00e7o trabalha com a API Open Source\nComputer Vision Library (OpenCV), a qual possui m\u00f3dulos de processamento de ima-\ngens e video I/O, estrutura de dados, \u00e1lgebra linear, GUI b\u00e1sica com sistema de janelas\nindependentes, controle de mouse e teclado, al\u00e9m de muitos algoritmos de vis\u00e3o com-\n\n\n\n118\n\nFigura 76: O Servi\u00e7o \"RasPi\"tem o frame vazio. Fonte: Autor.\n\n\n\n119\n\nputacional como: filtros de imagem, calibra\u00e7\u00e3o de c\u00e2mera, reconhecimento de objetos,\nan\u00e1lise estrutural e outros. O seu processamento \u00e9 em tempo real de imagens.\n\nA Figura 77, apresenta o servi\u00e7o inicializado na nova aba do frame \"service camera\",\nposteriormente, \u00e9 preciso fazer a defini\u00e7\u00e3o da entrada da imagem do servi\u00e7o OpenCV,\nque poder\u00e1 ser carregada a partir de um caminho de diret\u00f3rio de um arquivo de imagem\nexistente ou feito atrav\u00e9s de uma captura de c\u00e2mera de video. A seguir, a op\u00e7\u00e3o (\"file\") \u00e9\ndefinida como entrada, a imagem \u00e9 carregada atrav\u00e9s do caminho de diret\u00f3rios da imagem\ndo arquivo fornecido.\n\nFigura 77: Servi\u00e7o OpenCV executado em uma nova aba frame chamada \"service ca-\nmera\".\n\nNa Figura 78, \u00e9 poss\u00edvel visualizar o filtro Canny sendo aplicado na imagem JPEG\ncarregada, Canny \u00e9 um filtro de convolu\u00e7\u00e3o que usa a primeira derivada, suaviza o ru\u00eddo\ne localiza bordas, combinando um operador diferencial com um filtro Gaussiano.\n\nA seguir, \u00e9 escolhido no frame \"service camera\", a op\u00e7\u00e3o pela captura de uma c\u00e2mera\nde video, o driver do perif\u00e9rico instala as depend\u00eancias da API para abrir uma porta virtual\nde comunica\u00e7\u00e3o serial entre o dispositivo e o framework SOA Myrobotlab. A Figura 79,\napresenta a captura da c\u00e2mera, com o filtro para detec\u00e7\u00e3o de face. A face detectada faz\nparte de um reposit\u00f3rio de imagens (FRISCHHOLZ, 2015).\n\nAp\u00f3s iniciar dois servi\u00e7os, \"service camera\" e \"service RasPi\", podemos observar a\naba do frame \"gui\", respons\u00e1vel por fornecer os servi\u00e7os atualmente em execu\u00e7\u00e3o, onde\ntamb\u00e9m podem ser passados par\u00e2metros de entradas e sa\u00eddas para os objetos. A Figura\n\n\n\n120\n\nFigura 78: Aplicando o filtro canny no arquivo JPEG. Fonte: Autor.\n\n\n\n121\n\nFigura 79: Filtro de detec\u00e7\u00e3o de face. Fonte: Autor.\n\n80, apresenta os servi\u00e7os atualmente executados na aba de controle \"gui\".\nTodas os servi\u00e7os do sistema Myrobotlab necessitam de diversas classes externas tanto\n\ndo pacote swing como do awt. Na maioria dos exemplos, os servi\u00e7os ter\u00e3o pelo menos\ntr\u00eas linhas com a diretiva import apontando para pacotes de classes externas, conforme as\ndeclara\u00e7\u00f5es seguintes:\n\n\u2022 importjava.awt.*: Permite a utiliza\u00e7\u00e3o de diversas classes do pacote awt, al\u00e9m de\npossuir uma serie de constantes num\u00e9ricas.\n\n\u2022 importjava.awt.event: Usado para o processamento dos eventos que ocorrem na\njanela, tais como clique do mouse.\n\n\u2022 importjava.swing.*: Permite a utiliza\u00e7\u00e3o de diversas classes do pacote swing.\n\nPara os frames s\u00e3o utilizados \u00e0 classe JFrame dispon\u00edvel no pacote swing, a qual ter\u00e1\numa janela com barra de titulo, bordas e pode ter outros componentes visuais (objetos)\nem seu interior.\n\nOs servi\u00e7os dispon\u00edveis na GUI do framework SOA , est\u00e3o registrados no arquivo ser-\nviceData.xml do Myrobotlab.\n\n\n\n122\n\nFigura 80: O Frame \"gui\"mostra os servi\u00e7os atuais em execu\u00e7\u00e3o. Fonte: Autor.\n\n\n\n123\n\nO XML \u00e9 uma metalinguagem que define as regras para criar as linguagens de \"mar-\nkup\" para codificar exemplos de documentos particulares ou tipos de mensagens. A espe-\ncifica\u00e7\u00e3o formal para qualquer linguagem \"markup\"definida utilizando XML ou SGML\nchama-se Document Type Definition (DTD). \u00c9 uma maneira de organizar informa\u00e7\u00f5es,\nos documentos XML podem ser facilmente compreendidos por programadores facilitando\no desenvolvimento de aplicativos compat\u00edveis. Todas as informa\u00e7\u00f5es contidas no XML\nest\u00e3o dentro de tags. O arquivo serviceData.xml tem uma importante caracter\u00edstica no\nsistema: permite ao desenvolvedor ter acesso as defini\u00e7\u00e3o dos servi\u00e7os existentes ou criar\nseus pr\u00f3prios servi\u00e7os, o qual devem ser implementados. A seguir pode ser observados\nas tags utilizadas para os servi\u00e7os \"OpenCV\"e \"RasPi\"(plataforma de hardware) do My-\nrobotlab. Este arquivo \u00e9 utilizado pela classe \"GUIService.java\"\n\nserviceData.xml\n\n1\n\n2 &lt;S e r v i c e D a t a >\n3 &lt;!?? n t y p e s o f s e r v i c e s ??>\n4 &lt;s e r v i c e T y p e s >\n5 :\n6 &lt;s e r v i c e T y p e name= \" o r g . m y r o b o t l a b . s e r v i c e . OpenCV\" d e s c r i p t i o n = \"\n\nThe OpenCV S e r v i c e i s a l i b r a r y o f v i s i o n f u n c t i o n s \" >\n7 &lt;d e p e n d e n c i e s >\n8 &lt;o r g >com . g o o g l e c o d e . j a v a c v &lt;/ o r g >\n9 &lt;o r g > n e t . s o u r c e f o r g e . o p e n c v &lt;/ o r g >\n\n10 &lt;/ d e p e n d e n c i e s >\n11 &lt;/ s e r v i c e T y p e >\n12 :\n13 &lt;s e r v i c e T y p e name= \" o r g . m y r o b o t l a b . s e r v i c e . R a s P i \" d e s c r i p t i o n = \" a\n\ns e r v i c e t o a l l o w a c c e s s t o t h e R a s p b e r r y P i&amp;a p o s ; s GPIO a n d\nI 2 C o f f e r e d i n P i 4 J \" >\n\n14 &lt;d e p e n d e n c i e s >\n15 &lt;o r g >com . p i 4 j . p i 4 j &lt;/ o r g >\n16 &lt;/ d e p e n d e n c i e s >\n17 &lt;/ s e r v i c e T y p e >\n18 :\n19 &lt;/ s e r v i c e T y p e s >\n20 &lt;!?? n c a t e g o r i e s ??>\n21 &lt;c a t e g o r i e s >\n22 :\n23 &lt;c a t e g o r y name= \" v i s i o n \" >\n24 &lt;s e r v i c e T y p e s > o r g . m y r o b o t l a b . s e r v i c e . OpenCV&lt;/ s e r v i c e T y p e s >\n25 &lt;/ c a t e g o r y >\n26 :\n27 &lt;c a t e g o r y name= \" m i c r o c o n t r o l l e r \" >\n28 &lt;s e r v i c e T y p e s > o r g . m y r o b o t l a b . s e r v i c e . R a s P i &lt;/ s e r v i c e T y p e s >\n29 &lt;/ c a t e g o r y >\n30 :\n31 &lt;/ c a t e g o r y >\n32 &lt;!?? n t h i r d p a r t y l i b s ??>\n33 &lt;t h i r d P a r t y L i b s >\n34 :\n35 &lt;l i b o r g = \" com . p i 4 j . p i 4 j \" r e v i s i o n = \" 0 . 0 . 5 \" r e s o l v e d = \" f a l s e \"\n\nr e l e a s e d = \" t r u e \" / >\n36 :\n37 &lt;l i b o r g = \" n e t . s o u r c e f o r g e . o p e n c v \" r e v i s i o n = \" 2 . 4 . 6 \" r e s o l v e d = \"\n\nf a l s e \" r e l e a s e d = \" t r u e \" / >\n38 :\n\n\n\n124\n\n39 &lt;/ t h i r d P a r t y L i b s >\n40 &lt;/ S e r v i c e D a t a >\n\n\u00c9 nesse arquivo que est\u00e3o registrados todos os servi\u00e7os existentes do sistema. Ele per-\nmite adicionar servi\u00e7os existentes ou adicionar novos servi\u00e7os. No caso de novos servi\u00e7os\n\u00e9 preciso desenvolver o pacote com os componentes, interfaces fornecidas e requeridas,\nbem como ajeitar as depend\u00eancias ocorridas.\n\nO sistema de execu\u00e7\u00e3o da m\u00e1quina virtual Java interage com o sistema operacional\nsubjacente. Tais intera\u00e7\u00f5es incluem executar outros programas, encerrar o sistema de\nexecu\u00e7\u00e3o, ler e escrever as propriedades do sistema que permitem a comunica\u00e7\u00e3o entre\nsistema operacional e o sistema de execu\u00e7\u00e3o. Tr\u00eas classes principais em java.lang, pa-\ncote que cont\u00e9m as classes que constituem recursos b\u00e1sicos da linguagem, necess\u00e1rios \u00e0\nexecu\u00e7\u00e3o de qualquer programa Java, providenciam este acesso, descritos a seguir:\n\n\u2022 A classe System - providencia m\u00e9todos est\u00e1ticos para manipular o estado do sis-\ntema. Ela permite a leitura e a escrita das propriedades do sistema, fornece os\nstreams padr\u00e3o de entrada e sa\u00edda e fornece diversas fun\u00e7\u00f5es utilit\u00e1rias. Por conve-\nni\u00eancia, diversos m\u00e9todos em System operam sobre o objeto Runtime corrente.\n\n\u2022 A classe Runtime - providencia uma interface para o sistema de execu\u00e7\u00e3o da m\u00e1-\nquina virtual que est\u00e1 sendo executada. O objeto Runtime corrente providencia\nacesso a funcionalidades de cada sistema de execu\u00e7\u00e3o, tais como interagir com o\ncoletor de lixo, executar outros programas e desligar o sistema de execu\u00e7\u00e3o.\n\n\u2022 A classe Process - representa um processo em execu\u00e7\u00e3o que foi criado chamando\nRuntime.exec para executar um outro programa, ou atrav\u00e9s do uso direto de um\nobjeto ProcessBuilder.\n\nA API do Myrobotlab, n\u00e3o s\u00e3o compostas apenas de classes, m\u00e9todos e o javadoc\nusado para document\u00e1-lo. O javadoc \u00e9 uma importante ferramenta que fornece uma boa\nvisibilidade da API, por\u00e9m ainda assim uma API \u00e9 um termo muito mais amplo do que\nessa visibilidade poderia indicar. Uma API inclui muitos outros tipos de interfaces. A\ninterface \u00e9 um recurso muito utilizado em Java, bem como na maioria das linguagens\norientadas a objeto, para \"obrigar\"a um determinado grupo de classes a ter m\u00e9todos ou\npropriedades em comum para existir em um determinado contexto, contudo os m\u00e9todos\npodem ser implementados em cada classe de uma maneira diferente. Pode-se dizer, a\ngrosso modo, que uma interface \u00e9 um contrato que quando assumido por uma classe\ndeve ser implementado. Dentro das interfaces existem somente assinaturas de m\u00e9todos e\npropriedades, cabendo \u00e0 classe que a utilizar\u00e1 realizar a implementa\u00e7\u00e3o das assinaturas,\ndando comportamentos pr\u00e1ticos aos m\u00e9todos. Para realizar a chamada ou refer\u00eancia a uma\ninterface por uma determinada classe, \u00e9 necess\u00e1rio adicionar a palavra-chave implements\nao final da assinatura da classe que ir\u00e1 implementar a interface escolhida, com a seguinte\nsintaxe:\n\n\u2022 public class nome_classe implements nome_interface\n\nOnde nome_classe \u00e9 o nome da classe a ser implementada e nome_Interface \u00e9 o nome\nda interface a ser implementada pela classe. Diferentes classes podem usar classes interfa-\nces, por\u00e9m cada classe ir\u00e1 implementar seus m\u00e9todos de maneira diferente. Ao contr\u00e1rio\nda heran\u00e7a que limita uma classe a herdar somente uma classe pai por vez, \u00e9 poss\u00edvel que\n\n\n\n125\n\numa classe implemente varias interfaces ao mesmo tempo. Uma classe interface no Myro-\nbotlab, nada mais \u00e9 que uma esp\u00e9cie de contrato de regras que uma classe deve seguir em\num determinado contexto. Como em Java n\u00e3o existe heran\u00e7a m\u00faltipla, a interface passa a\nser uma alternativa.\n\n5.4.2 Integra\u00e7\u00e3o do Framework SOA com o Rob\u00f4 m\u00f3vel Acionamento Diferencial\n\nPara integra\u00e7\u00e3o entre o estudo de caso do rob\u00f4 m\u00f3vel proposto com o framework SOA\nMyrobotlab, foi utilizado a arquitetura de camadas apresentada na subse\u00e7\u00e3o 6.1, o qual \u00e9\n\u00fatil em organiza\u00e7\u00f5es que utilizam variados tipos de sistemas, com diferentes tecnologias e\nfornecedores, sendo imprescind\u00edvel o atendimento a requisitos como escalabilidade, flexi-\nbilidade e interoperabilidade. Para usufruir dos benef\u00edcios desta arquitetura, \u00e9 necess\u00e1rio\ninvestimento de tempo e aprendizado. Atrav\u00e9s do uso de SOA o entendimento entre os\ncomponentes de servi\u00e7os. A Figura 81, apresenta a tela inicial do framework SOA, o\nqual vem sendo estendido e integrado com a plataforma de hardware do rob\u00f4 m\u00f3vel para\naplica\u00e7\u00f5es com estudantes de gradua\u00e7\u00e3o de Engenharia da UFRGS.\n\nFigura 81: Tela inicial do novo Framework SOA estendido. Fonte: Autor.\n\nA pr\u00f3xima tela, da Figura 82, apresenta os principais itens do SOA que s\u00e3o os servi\u00e7os\nque servem para denominar o relacionamento entre um provedor e um consumidor, que\npossuem o objetivo de solucionar uma determinada atividade em comum. Est\u00e3o sendo\nutilizados e implementados alguns servi\u00e7os previamente escolhidos conforme os requisi-\ntos de projeto, cada servi\u00e7o pode ser definido como uma atividade espec\u00edfica, devido a\nidentifica\u00e7\u00e3o dos servi\u00e7os encontrados e escolhidos conforme a aplica\u00e7\u00e3o.\n\nA seguir, \u00e9 apresentado na Figura 83, o servi\u00e7o que vem sendo criado para intera\u00e7\u00e3o\ncom a plataforma de hardware do rob\u00f4 m\u00f3vel, nesse caso um servi\u00e7o para o \"Intel Galileo\n\n\n\n126\n\nFigura 82: Tela de servi\u00e7os implementados para utilizar com estudantes de gradua\u00e7\u00e3o da\nUFRGS. Fonte: Autor.\n\nGen 2\", a GUI do servi\u00e7o possui tr\u00eas op\u00e7\u00f5es: \"oscope\", \"pins\"e \"editor\".\nA op\u00e7\u00e3o oscilosc\u00f3pio permite a visualiza\u00e7\u00e3o de sinais peri\u00f3dicos tais como ondas qua-\n\ndradas e ondas seno. J\u00e1 a op\u00e7\u00e3o pinos, permite a intera\u00e7\u00e3o do usu\u00e1rio com os pinos do\nhardware. E por fim, a op\u00e7\u00e3o de edi\u00e7\u00e3o, permite criar ou editar c\u00f3digos, fazer compila\u00e7\u00e3o\ne uploading do firmware para o hardware, bem como acessar as bibliotecas ou API do\nmicrocontrolador via menu, as bibliotecas e o \"core\" do framework Arduino Intel fazem\nparte dos pacotes embarcados dentro do framework SOA Myrobotlab estendido. O fra-\nmework Wiring C/C++ encapsula os registradores de baixo n\u00edvel dos microntroladores ou\nSOC\u2019s para criar uma API de alto n\u00edvel.\n\nImportante ressaltar, que para utilizar a GUI do servi\u00e7o Arduino com as op\u00e7\u00f5es os-\ncilosc\u00f3pio e pinos, um firmata chamado \"MRLComm.ino\"precisa ser carregado no mi-\ncrocontrolador ou SOC. O c\u00f3digo \u00e9 um protocolo gen\u00e9rico que permite a comunica\u00e7\u00e3o\ndo computador hospedeiro com o microcontrolador via software. A Figura 84, apre-\nsenta o diagrama de blocos que representa a conex\u00e3o entre o computador hospedeiro com\nmicrocontrolador ou SOC. Com o firmata rodando no microcontrolador conectado ao\nframework SOA Myrobotlab, \u00e9 poss\u00edvel utilizar as op\u00e7\u00f5es de controle dos pinos I/O e\noscilosc\u00f3pio.\n\nAtualmente, o servi\u00e7o vem sendo implementado para fazer a adapta\u00e7\u00e3o e empacota-\nmento do \"core\" do framework Arduino Intel. Para fazer a utiliza\u00e7\u00e3o da API de progra-\nma\u00e7\u00e3o dos registradores do hardware e do compilador para o Intel Galileo Gen 2. Caso\no firmata \"MRLComm.ino\"esteja embarcado no SOC ou microcontrolador, o mesmo se\ntorna um hardware slave, assim o servi\u00e7o Arduino \"Intel Galileo\"do framework SOA se\ncomunica e controla o hardware. Caso contrario, o servi\u00e7o Arduino \"Intel Galileo\"apenas\nedita, compila e carrega firmwares para a plataforma de hardware.\n\nO firmata s\u00f3 tem de ser carregado uma vez no hardware. A \u00fanica vez que teria de\nser re-carregado \u00e9 quando ele precisa ser atualizado. Depois de carregado o firmata no\nmicrocontrolador e inicializado o servi\u00e7o Arduino no Myrobotlab, se estabelece-r\u00e1 uma\nconex\u00e3o entre o software e o hardware, o qual se dar\u00e1 atrav\u00e9s da porta de comunica\u00e7\u00e3o\n\n\n\n127\n\nFigura 83: Tela do servi\u00e7o para intera\u00e7\u00e3o com a plataforma de hardware. Fonte: Autor.\n\nMCU \nServi\u00e7o\n\nComputador Host \n\nFramework SOA \n\nWIRING/ARDUINO\n\nBIBLIOTECAS\nCORE\n\n...\n\n...\nSOC \n\nServi\u00e7o\n\nMCU \nServi\u00e7o\n\nMCU \nHardware\n\nSOC \nHardware\n\nMCU \nHardware\n\nCOM1\n\nCOM2\n\nCOM3\n\nPorta Serial USB\n\nCaso 1: Com arquivo MRLComm.ino \n\n        embarcado no MCU o mesmo\n\n        se torna ESCRAVO;\n\nSen\u00e3o,\n\nCaso 2: conecta com o Host para\n\n        receber grava\u00e7\u00f5es de \n\n        firmware;\n\nFigura 84: Diagrama de blocos com o computador hospedeiro rodando o framework SOA\nMyrobotlab com o servi\u00e7o Arduino conectado com o hardware. Fonte: Autor.\n\n\n\n128\n\nserial apropriada. Se o firmata \"MRLComm.ino\"est\u00e1 atualizado, deve ser impresso a\nmensagem \"goodtimes\" na tela da parte inferior da GUI do servi\u00e7o Arduino.\n\nDesse modo \u00e9 poss\u00edvel que comandos ou dados enviados a partir do framework SOA\nMyRobotLab sejam processados no hardware slave e tamb\u00e9m permite a aquisi\u00e7\u00e3o dos\ndados do hardware slave para o Myrobotlab.\n\n1 / ? ?\n2 ? @ a u t h o r GroG ( a t ) m y r o b o t l a b . o r g\n3 ? T h i s f i l e i s p a r t o f MyRobotLab .\n4 ? MRLComm . i n o\n5 ? ?????????????????\n6 ? P u r p o s e : s u p p o r t s e r v o s , s e n s o r s , a n a l o g &amp; d i g i t a l p o l l i n g\n7 ? o s c o p e , m o t o r s , r a n g e s e n s o r s , p i n g d a r &amp; s t e p p e r s .\n8 ? R e q u i r e m e n t s : MyRobotLab r u n n i n g o n a c o m p u t e r &amp; a s e r i a l c o n n e c t i o n\n9 ? /\n\n10 # i n c l u d e &lt;S e r v o . h >\n11 # i n c l u d e&lt;MRLComm. h >\n12\n\n13\n\n14 MRLComm m r l = MRLComm ( ) ;\n15\n\n16 v o i d s e t u p ( ) {\n17\n\n18 S e r i a l . b e g i n ( 5 7 6 0 0 ) ;\n19 m r l . s e t u p (&amp; S e r i a l ) ;\n20 }\n21\n\n22 v o i d l o o p ( ) {\n23\n\n24 / / p r o c e s s m r l commands\n25 / / s e r v o c o n t r o l , s e n s o r , c o n t r o l s e n d &amp; r e c i e v e\n26 / / o s c o p e , a n a l o g p o l l i n g , d i g i t a l p o l l i n g e t c . .\n27 / / m r l m e s s a g e s\n28 m r l . p r o c e s s ( ) ;\n29\n\n30 / / e x a m p l e how t o\n31 / / s e n d 3 v a r s t o m r l\n32 / ?\n33 i n t a x = 2 8 ;\n34 i n t a y = 5 8 3 ;\n35 i n t a z = 3 2 7 6 7 ;\n36\n\n37 m r l . s t a r t M s g ( ) ;\n38 m r l . a p p e n d ( a x ) ;\n39 m r l . a p p e n d ( a y ) ;\n40 m r l . a p p e n d ( a z ) ;\n41 m r l . sen d Msg ( ) ;\n42 ? /\n43\n\n44 }\n45 }\n\nPor sua vez, o rob\u00f4 m\u00f3vel foi modelado em um software de desenho CAD, que baseia-\nse em computa\u00e7\u00e3o param\u00e9trica, criando formas tridimensionais a partir de formas geom\u00e9-\ntricas elementares (SOLIDWORKS, 2014). No ambiente do programa, a cria\u00e7\u00e3o de um\n\n\n\n129\n\ns\u00f3lido ou superf\u00edcie tipicamente come\u00e7a com a defini\u00e7\u00e3o de topologia em um esbo\u00e7o 2D\nou 3D. Assim, vem sendo desenvolvido o desenho mec\u00e2nico, eletromec\u00e2nico e eletr\u00f4nico\ndo novo EduBOT v0.4. O projeto mec\u00e2nico vem sendo desenvolvido e aperfei\u00e7oado con-\nforme as valida\u00e7\u00f5es dos testes reais e de simula\u00e7\u00f5es, recentemente a plataforma rob\u00f3tica\neducacional vem sendo projetado para suportar a placa Intel Galileo Gen 2. Na Figura\n85 \u00e9 apresentado o desenho 3D do prot\u00f3tipo do rob\u00f4 m\u00f3vel com dire\u00e7\u00e3o diferencial.\nO desenho do chassi \u00e9 mapeado para os elementos mec\u00e2nicos e eletromec\u00e2nicos como:\nmotores,sensores, rodas, baterias, parafusos e demais componentes de hardware que s\u00e3o\nprojetados e desenhados em software CAD de maneira modular e bem organizada. Para\nautomatizar a fase de projeto, alguns dos componentes de hardware CAD (mec\u00e2nicos e\neletromec\u00e2nicos) s\u00e3o projetados e alguns componentes reutilizados e adaptados, podendo-\nse tornar um projeto simples ou complexo dependendo dos requisitos necess\u00e1rios para a\naplica\u00e7\u00e3o.\n\nFigura 85: Plataforma Rob\u00f3tica Educacional EduRobot v0.4.\n\nO projeto do hardware da plataforma EduBOT v0.4, vem sendo projetado para ter\nchassis com di\u00e2metro 180mm de di\u00e2metro, o que resulta em um rob\u00f4 m\u00f3vel com tamanho\nflex\u00edvel o suficiente para diferentes aplica\u00e7\u00f5es educacionais. A Figura 86, apresenta\nalgumas das dimens\u00f5es do desenvolvimento do projeto.\n\nO projeto CAD faz o mapeamento dos componentes utilizados no desenho do projeto.\nExistem uma grande variedade de componentes mec\u00e2nicos e eletromec\u00e2nicos que podem\nser utilizados para o prot\u00f3tipo. Vale ressaltar, que as escolhas dos componentes mec\u00e2nicos\ne eletromec\u00e2nicos utilizados no projeto, se deu atrav\u00e9s de pesquisas de diferentes tipos\nde componentes, priorizando aqueles que possuem qualidade, alta coes\u00e3o, baixo custo e\nacoplamento. Para esta nova plataforma rob\u00f3tica est\u00e3o sendo desenvolvido as bibliotecas\nem C++ para os componentes eletr\u00f4nicos utilizados com o hardware Intel Galileo Gen 2,\n\n\n\n130\n\nFigura 86: Principais dimens\u00f5es do EduBOT v0.4.\n\ninicialmente ser\u00e1 apresentado a estrutura parcial do arquivo da classe \"DCMotorBot.h\".\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / ? B i b l i o t e c a p a r a o s M o t o r e s DC ? I n t e l G a l i l e o Gen 2 ? D r i v e r L298N .\n\nA r q u i v o . h d a c l a s s e DCMotorBot ? /\n5\n\n6 # i f n d e f DCMotorBot_H\n7 # d e f i n e DCMotorBot_H\n8\n\n9 / / C o m p a t i b i l i t y f o r A r d u i n o 1 . 0\n10\n\n11 # i f ARDUINO >= 1 0 0\n12 # i n c l u d e \" A r d u i n o . h \"\n13 # e l s e\n14 # i n c l u d e \" WProgram . h \"\n15 # e n d i f\n16\n\n17 c l a s s DCMotorBot {\n18\n\n19 p u b l i c :\n20\n\n21 / / c o n s t r u t o r e s\n22 DCMotorBot ( ) ; / / c o n s t r u t o r v a z i o\n23 DCMotorBot ( b y t e e l , b y t e e2 , b y t e I 1 , b y t e I 2 , i n t d e l a y , i n t\n\npwmMotors ) ; / / C o n s t r u t o r c o m p l e t o\n24\n\n25 v o i d s e t E n a b l e P i n s ( b y t e e l , b y t e e 2 ) ; / / s e t a r i n d i v i d u a l\n26 v o i d s e t C o n t r o l P i n s ( b y t e I 1 , b y t e I 2 ) ; / / s e t a r i n d i v i d u a l\n27 v o i d s e t D e l a y ( i n t d e l a y ) ; / /\n28 v o i d s e t P w m A l l ( i n t pwmMotors ) ; / /\n29\n\n30 / / A c i o n a r m o t o r e s d e f o r m a c r e s c e n t e e d e c r e s c e n t e ? PWM\n31 v o i d f a d e i n ( ) ;\n32 v o i d f a d e o u t ( ) ;\n33\n\n34 / / F u n \u00e7 \u00f5 e s p a r a m o v i m e n t o s\n35 v o i d s t a r t ( ) ;\n\n\n\n131\n\n36 v o i d m o v e F o r w a r d ( ) ;\n37 v o i d f o r w ( ) ;\n38 v o i d m o v eBack war d ( ) ;\n39 v o i d b a c k ( ) ;\n40 v o i d t u r n L e f t ( ) ;\n41 v o i d t u r n R i g h t ( ) ;\n42 v o i d s t o p ( ) ;\n43 p r i v a t e :\n44 i n t mDelay ;\n45 i n t mPwm; / / pwm\n46\n\n47 / / p i n o s p a r a h a b i l i t a r pwm\n48 b y t e mE1 ;\n49 b y t e mE2 ;\n50\n\n51 / / P i n o s d e c o n t r o l e\n52 b y t e mI1 ;\n53 b y t e mI2 ;\n54 } ;\n55 # e n d i f\n56 }\n\nDepois de implementados os arquivos \"DCMotorBot.h\"e \"DCMotorBot.cpp\"\u00e9 preciso\ncriar um arquivo \"main.ino\", para instanciar a classe e usar os objetos concatenados com\nas fun\u00e7\u00f5es e propriedades da classe dos motores DC para o framework Arduino Intel\nv1.6.x, as bibliotecas implementadas devem estar inseridas dentro do diret\u00f3rio libraries.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / ? A r q u i v o Main p a r a i n s t a n c i a r e u t i l i z a r o b j e t o s d a c l a s s e \"\n\nDCMotorBot \" ? /\n5\n\n6 # i n c l u d e&lt;DCMotorBot . h >\n7\n\n8 / / c r i a o b j e t o\n9 DCMotorBot b o t ;\n\n10\n\n11 v o i d s e t u p ( ) {\n12\n\n13 / / o b j e t o i n i c i a l i z a n d o o s p i n o s\n14 b o t . s e t E n a b l e P i n s ( 3 , 1 1 ) ;\n15 b o t . s e t C o n t r o l P i n s ( 1 2 , 1 3 ) ;\n16 }\n17\n\n18 v o i d l o o p ( ) {\n19 / / o b j e t o a c e s s a n d o o s m \u00e9 t o d o s p a r a m o v i m e n t o s\n20 b o t . m o v e F o r w a r d ( ) ;\n21 d e l a y ( 2 0 0 0 ) ;\n22 b o t . m o v eBack war d ( ) ;\n23 d e l a y ( 2 0 0 0 ) ;\n24 b o t . t u r n L e f t ( ) ;\n25 d e l a y ( 2 0 0 0 ) ;\n26 b o t . t u r n R i g h t ( ) ;\n27 d e l a y ( 2 0 0 0 ) ;\n28 }\n\n\n\n132\n\n5.4.3 Integra\u00e7\u00e3o do Framework SOA com a Macro e Micro Navega\u00e7\u00e3o da Bengala\nEletr\u00f4nica\n\nPara integra\u00e7\u00e3o entre o estudo de caso da bengala eletr\u00f4nica proposto com o fra-\nmework SOA Myrobotlab, foi utilizado a arquitetura de camadas apresentada na subse\u00e7\u00e3o\n6.1. A Figura ??, apresenta a tela inicial do framework SOA, o qual vem sendo esten-\ndido e integrado com a plataforma de hardware da bengala eletr\u00f4nica para aplica\u00e7\u00f5es com\npessoas deficientes visuais. Para os resultados do estudo de caso do projeto da tecnologia\nassistiva, est\u00e3o sendo constru\u00eddos um ambiente para localiza\u00e7\u00e3o de obst\u00e1culos e com um\nsistema de telemetria e telecontrole para geolocaliza\u00e7\u00e3o utilizando o servi\u00e7o \"WebGUI\"\ndo framework, 87.\n\nFigura 87: Tela inicial do novo framework SOA estendido. Fonte: Autor.\n\nO sistema de rastreamento global utiliza GPS para fazer aquisi\u00e7\u00f5es de dados de loca-\nliza\u00e7\u00e3o no framework, A Figura 88, apresenta o servi\u00e7o \"WebGUI\"inicializado na GUI\ndo servi\u00e7o \"runtime\".\n\nOs resultados das aquisi\u00e7\u00f5es dos m\u00f3dulos, sensores e acionamento dos atuadores con-\nsistem em objetos instanciados e podem ser visualizados na tela que disponibiliza as in-\nforma\u00e7\u00f5es em tempo real. O receptor GPS informa a latitude e longitude, os dados de\nposi\u00e7\u00e3o global s\u00e3o passados para um mapa utilizando o GPS Visualizer e API Google\nMaps (GPS, 2014). O sonar informa a distancia de obst\u00e1culos em cent\u00edmetros, caso o\nobst\u00e1culo estiver a uma distancia menor que o limite escolhido, \u00e9 acionado o atuador de\nvibra\u00e7\u00e3o por Pulse-Width Modulation (PWM) ou simplesmente modula\u00e7\u00e3o por largura de\npulso, e por \u00faltimo, o LDR informa o n\u00edvel de luminosidade do ambiente. O sistema em-\nbarcado foi testado na disciplina Sistemas de Automa\u00e7\u00e3o do PGPEE, UFRGS. As classes\n\n\n\n133\n\nFigura 88: Tela de servi\u00e7os implementados para utilizar com estudo de caso da bengala\neletr\u00f4nica. Fonte: Autor.\n\ndesenvolvidas consistem em bibliotecas em C/C++ e devem ser inseridas dentro da pasta\n\"libraries\" do software Arduino, para executar os testes no programa principal, as clas-\nses implementadas utilizam a API da linguagem Wiring para o seu desenvolvimento. As\nbibliotecas est\u00e3o sendo testadas tamb\u00e9m nos ambientes de programa\u00e7\u00e3o Atmel Studio e\nEclipse. A comunica\u00e7\u00e3o serial entre o prot\u00f3tipo do hardware e o computador iniciam\nas amostras dos resultados em tempo real atrav\u00e9s do \"Serial Monitor\" do software que\npermite que dados simples de texto sejam enviados e recebidos, Figura 89.\n\nO rastreador GPS recebe todas essas informa\u00e7\u00f5es e as transmite, utilizando as tecno-\nlogias GSM e GPRS, padr\u00f5es digitais de comunica\u00e7\u00e3o celular de voz e dados, respectiva-\nmente, para os servidores da central de rastreamento, que disponibiliza, via web, todas as\ninforma\u00e7\u00f5es em tempo real, para os clientes. A Figura 90, apresenta o localiza\u00e7\u00e3o global\ndo sistema embarcado.\n\nPara testes iniciais, foram desenvolvidas algumas bibliotecas referentes aos disposi-\ntivos utilizados no projeto. Cada classe \u00e9 desenvolvida conforme os requisitos dos com-\nponentes eletr\u00f4nicos. Uma classe principal (main.ino) deve ser criada para instanciar os\nobjetos das classes implementadas. A seguir \u00e9 apresentado o c\u00f3digo do arquivo main.ino\ncriado para testar as bibliotecas do software do projeto.\n\n1 / ?\n2 @ a u t h o r C a r l o s S o l o n\n3 ?????????????????????? /\n4 / ? A r q u i v o Main c r i a d o p a r a i n s t a n c i a r a s c l a s s e s e c r i a r o b j e t o s d a s\n\nb i b l i o t e c a s i m p l e m e n t a d o s em C+ + , d o p r o j e t o B e n g a l a E l e t r \u00f4 n i c a ? /\n5\n\n6 # i n c l u d e \" C o n t r o l e B e n g a l a . h \" / / B i b l i o t e c a d e c o n t r o l e d o p r o j e t o\n\n\n\n134\n\nFigura 89: Bibliotecas C++ rodando com API de mapas. Fonte: Autor.\n\nFigura 90: Front End aberto ap\u00f3s inicializar o servi\u00e7o \"WebGUI\" . Fonte: Autor.\n\n\n\n135\n\n7 # i n c l u d e \" S o n a r . h \" / / B i b l i o t e c a d o S e n s o r d e o b s t \u00e1 c u l o s d o p r o j e t o\n8 # i n c l u d e \" Luz . h \" / / B i b l i o t e c a d o S e n s o r d e l u z d o p r o j e t o\n9 # i n c l u d e \" SkyGPS . h \" / / B i b l i o t e c a d o r e c e p t o r GPS d o p r o j e t o\n\n10 / / # i n c l u d e \"AUDIO . h \"\n11 # i n c l u d e &lt;N e w S o f t S e r i a l . h > / / B i b l i o t e c a d o a r d u i n o , c r i a i n t e r f a c e\n\nv i r t u a l v i a s o f t w a r e em q u a l q u e r p a r d e p i n o s d i g i t a i s d a p l a c a\ns e n d o um p a r a Rx e o o u t r o Tx . O RX e TX d o uC d o a r d u i n o e s t a\ns e n d o u s a d o p a r a c o m u n i c a \u00e7 \u00e3 o s e r i a l e n t r e a p l a c a e o c o m p u t a d o r\np r e c i s a n d o s i m u l a r um p a r d e p i n o s p a r a o RX e TX d o GPS com o\nA r d u i n o .\n\n12 # i n c l u d e &lt;c s t d l i b > / / B i b l i o t e c a c s t a n d a r d l i b r a r y d o c + + , p o s s u i\nf u n \u00e7 \u00f5 e s d e a l o c a \u00e7 \u00e3 o d e m em \u00f3 r ia , c o n t r o l e d e p r o c e s s o s , c o n v e r s \u00f5 e s ,\ne t c . . .\n\n13 # i n c l u d e &lt;i o s t r e a m > / / d e c l a r a a s q u a t r o c l a s s e s b \u00e1 s i c a s d e e n t r a d a e\ns a \u00ed d a : i o s , i s t r e a m , o s t r e a m e i o s t r e a m\n\n14\n\n15 # d e f i n e l d r P i n A0 / / p i n o d o S e n s o r d e Luz\n16\n\n17 # d e f i n e pinMOTOR 9 / / p i n o pwm d o uC Atm eg a3 2 8 d o a r d u i n o p a r a o m o t o r\nd e v i b r a \u00e7 \u00e3 o ;\n\n18\n\n19 / / P i n o s d o S o n a r , r e c e p t o r e t r a n s m i s s o r ;\n20 # d e f i n e ECHO 7\n21 # d e f i n e TRIGGER 8\n22\n\n23 / / GPS p i n o s\n24 # d e f i n e RX 3\n25 # d e f i n e TX 2\n26\n\n27 / / # d e f i n e pinSOM 6 p i n o p a r a um b u z z e r ;\n28\n\n29 # d e f i n e v e l o 2 5 5 / / v a l o r e s e n t r e 0 e 2 5 5 p a r a c o n t r o l a r a t e n s \u00e3 o d a\nb a t e r i a , p i n o pwm ;\n\n30\n\n31 # d e f i n e t i m e 0 / / v a r i \u00e1 v e l p a r a v a l o r d e D e l a y ;\n32\n\n33 u s i n g n a m e s p a c e s t d ;\n34\n\n35 S t r i n g nome = \" Nome Do U s u \u00e1 r i o \" ;\n36\n\n37 l o n g d i s t a n c i a ; / / a u x i l i a r e s\n38 i n t l d r , c t r l , n i v e l ;\n39\n\n40 u n s i g n e d f l o a t f i x _ a g e ; / / v a r i \u00e1 v e i s p a r a m a n i p u l a r o g p s\n41 f l o a t LAT= 0 , LON= 0 ;\n42\n\n43 N e w S o f t S e r i a l GPS ( RX , TX ) ; / / i n t e r f a c e v i r t u a l p a r a o s p i n o s r x e t x\nd o uC\n\n44\n\n45 v o i d s e t u p ( v o i d ) { / / M\u00e9to d o d a API W i r i n g\n46 GPS . b e g i n ( 9 6 0 0 ) ; / / i n i c i a c o m u n i c a \u00e7 \u00e3 o d e s e r i e d o g p s : b a u d r a t e d e\n\n9 6 0 0\n47 S e r i a l . b e g i n ( 1 1 5 2 0 0 ) ; / / i n i c i a c o m u n i c a \u00e7 \u00e3 o d e s e r i e d o a r d u i n o com o\n\nc o m p u t a d o r : b a u d r a t e d e 1 1 5 2 0 0\n48 }\n49\n\n50 i n t m a i n ( i n t a r g c , c h a r ? a r g v [ ] )\n51 {\n\n\n\n136\n\n52 l o n g l a t , l o n ;\n53 u n s i g n e d l o n g f i x _ a g e , s p e e d , c o u r s e ;\n54 u n s i g n e d l o n g c h a r s ;\n55 u n s i g n e d s h o r t s e n t e n c e s , f a i l e d _ c h e c k s u m ;\n56\n\n57 s e t u p ( ) ;\n58\n\n59 / / o b j e t o s d a s c l a s s e s q u e r e c e b e m como p a r \u00e2 m e t r o s em s e u s c o n s t r u t o r e s\no s p i n o s d e s e n s o r e s e a t u a d o r e s\n\n60\n\n61 M o t o r v i b r a c a o = M o t o r ( pinMOTOR ) ;\n62 S o n a r o b s t a c u l o s = S o n a r ( ECHO, TRIGGER ) ;\n63 Luz i n t e n s i d a d e = Luz ( l d r P i n ) ;\n64 C o n t r o l e B e n g a l a c o n t r o l e = C o n t r o l e B e n g a l a ( nome ) ; / / r e c e b e o nome d o\n\nu s u a r i o como p a r a m e t r o\n65 SkyGPS g p s = SkyGPS ( RX , TX ) ;\n66\n\n67 w h i l e ( 1 )\n68 {\n69\n\n70 / / S e n s o r s o n a r\n71 o b s t a c u l o s . d i s t a n c i a ( ) ; / / o b j e t o o b s t \u00e1 c u l o s c o n c a t e n a o m e t o d o\n\nd i s t a n c i a ( ) p a r a a c i o n a n d o d o t r a n s m i s s o r d o s o n a r e s e u r e c e p t o r\nr e t o r n a n d o um v a l o r em c e n t \u00ed m e t r o ;\n\n72 o b s t a c u l o s . s o n a r P i n g ( ) ; / / o v a l o r d a d i s t a n c i a d o m \u00e9 t o d o d i s t a n c i a ( )\n\u00e9 a r m a z e n a d a n o m \u00e9 t o d o s o n a r P i n g ( ) , com o m \u00e9 t o d o g e t D i s t a n c i a \u00e9\n\nd a d o o r e t o r n o d o v a l o r a r m a z e n a d o em s o n a r P i n g ( ) ;\n73\n\n74 d i s t a n c i a = o b s t a c u l o s . g e t D i s t a n c i a ( ) ; / / R e t o r n a a d i s t a n c i a em\nc e n t \u00ed m e t r o s\n\n75\n\n76 S e r i a l . p r i n t ( \" D i s t a n c i a S o n a r : \" ) ; / / e s c r e v e n a t e l a\n77 S e r i a l . p r i n t l n ( d i s t a n c i a ) ; / / a d i s t a n c i a d o s o b s t \u00e1 c u l o s d e t e c t a d o s\n\nem c e n t \u00ed m e t r o s a r m a z e n a d o s n o m \u00e9 t o d o s o n a r P i n g ;\n78\n\n79 / / S e n s o r s o n a r\n80 c t r l = c o n t r o l e . v e r i f i c a C o l i s a o ( d i s t a n c i a ) ; / / o b j e t o c o n t r o l e\n\nc o n c a t e n a m \u00e9 t o d o v e r i f i c a C o l i s a o ( )\n81 / / r e c e b e como p a r \u00e2 m e t r o a d i s t a n c i a d o s o b s t \u00e1 c u l o s\n82 i f ( c t r l = = 0 ) / / l e i t u r a d e e r r o n a d i a g o n a l d o s o n a r\n83 {\n84 v i b r a c a o . d e s l i g a M o t o r ( ) ; / / d e s l i g a o m o t o r d e v i b r a \u00e7 \u00e3 o\n85 S e r i a l . p r i n t l n ( \" M o t o r P a r a d o \" ) ; / / e s c r e v e n a t e l a\n86 }\n87 i f ( c t r l = = 1 ) / / o b j e t o p r \u00f3 x i m o , m en o r q u e 5 0 c e n t \u00ed m e t r o s a\n\np r i n c i p i o\n88 {\n89 v i b r a c a o . a c i o n a M o t o r ( v e l o , t i m e ) ;\n90 S e r i a l . p r i n t l n ( \" M o t o r A t i v a d o \" ) ;\n91 }\n92 e l s e / / o b j e t o a f a s t a d o , f o r a d o a m b i e n t e d e a \u00e7 \u00e3 o\n93 {\n94 v i b r a c a o . d e s l i g a M o t o r ( ) ;\n95 S e r i a l . p r i n t l n ( \" M o t o r P a r a d o \" ) ;\n96 }\n97 / / S e n s o r d e Luz LDR\n98 i n t e n s i d a d e . l u m i n o s i d a d e ( ) ; / / o b j e t o i n t e n s i d a d e c o n c a t e n a o m \u00e9 t o d o\n\nl u m i n o s i d a d e ( ) e f a z a l e i t u r a d o s e n s o r LDR\n\n\n\n137\n\n99 / / r e t o r n a n d o v a l o r e s d a r e s i s t \u00ea n c i a d o s e n s o r ;\n100 i n t e n s i d a d e . l u z P i n g ( ) ; / / o s v a l o r e s l i d o s d o m \u00e9 t o d o l u m i n o s i d a d e \u00e9\n\na r m a z e n a d a n o m \u00e9 t o d o l u z P i n g ( ) , m a i s t a r d e \u00e9 ch am ad o o m \u00e9 t o d o\ng e t L u z q u e r e t o r n a o v a l o r a r m a z e n a d o em \" l u z P i n g ( ) \" ;\n\n101\n\n102 n i v e l = i n t e n s i d a d e . g e t L u z ( ) ; / / o b j e t o i n t e n s i d a d e c o n c a t e n a m \u00e9 t o d o\ng e t L u z ( ) q u e r e t o r n a v a l o r e s d a l e i t u r a d o LDR\n\n103\n\n104 / / o b j e t o c o n t r o l e c o n c a t e n a m \u00e9 t o d o v e r i f i c a L u m i n o s i d a d e ( ) q u e r e c e b e\ncomo p a r \u00e2 m e t r o o s v a l o r e s d e l e i t u r a d a r e s i s t \u00ea n c i a d o s e n s o r n o\na m b i e n t e ; v e r i f i c a o n \u00ed v e l d e i n t e n s i d a d e d a l u z com o r e t o r n o d o\nm \u00e9 t o d o v e r i f i c a L u m i n o s i d a d e ( )\n\n105\n\n106 l d r = c o n t r o l e . v e r i f i c a L u m i n o s i d a d e ( n i v e l ) ;\n107 i f ( l d r = = 1 )\n108 S e r i a l . p r i n t l n ( \" \\ n A l e r t a : L o c a l A u s e n t e d e Luz \" ) ;\n109 i f ( l d r = = 2 )\n110 S e r i a l . p r i n t l n ( \" \\ n L o c a l E s c u r o \" ) ;\n111 i f ( l d r = = 3 )\n112 S e r i a l . p r i n t l n ( \" \\ n A m b i e n t e Com Luz \" ) ;\n113 i f ( l d r = = 4 )\n114 S e r i a l . p r i n t l n ( \" \\ n A m b i e n t e Com M u i t a Luz \" ) ;\n115 e l s e\n116 S e r i a l . p r i n t l n ( \" \\ n A l e r t a : A m b i e n t e B r i l h a n t e \" ) ;\n117\n\n118 / / r e c e p t o r GPS ?\n119 g etGPS ( ) ; / / F a z c h a m a d a a o m \u00e9 t o d o g e t ,\n120 S e r i a l . p r i n t ( \" \\ n \" ) ;\n121 S e r i a l . p r i n t ( \" L a t i t u d e : \" ) ; / / E s c r e v e n a t e l a\n122 S e r i a l . p r i n t ( LAT / 1 0 0 0 0 0 , 7 ) ; / / l a t i t u d e\n123 S e r i a l . p r i n t ( \" : : L o n g i t u d e : \" ) ;\n124 S e r i a l . p r i n t l n (LON/ 1 0 0 0 0 0 , 7 ) ; / / l o n g i t u d e\n125 S e r i a l . p r i n t ( \" \\ n \" ) ;\n126\n\n127 d e l a y ( 5 0 0 ) ;\n128 }\n129 }\n130 v o i d g etGPS ( ) {\n131 b o o l n e w d a t a = f a l s e ;\n132 u n s i g n e d l o n g s t a r t = m i l l i s ( ) ;\n133 / / A c a d a 1 s e g u n d o i m p r i m e uma a t u a l i z a \u00e7 \u00e3 o\n134 w h i l e ( m i l l i s ( ) ? s t a r t &lt;1 0 0 0 )\n135 {\n136 i f ( f e e d g p s ( ) ) {\n137 n e w d a t a = t r u e ;\n138 }\n139 }\n140 i f ( n e w d a t a )\n141 {\n142 g p sd u m p ( g p s ) ;\n143 }\n144 }\n145 b o o l f e e d g p s ( ) {\n146 w h i l e ( GPS . a v a i l a b l e ( ) )\n147 {\n148 i f ( g p s . e n c o d e ( GPS . r e a d ( ) ) )\n149 r e t u r n t r u e ;\n150 }\n\n\n\n138\n\n151 r e t u r n 0 ;\n152 }\n153 v o i d g p sd u m p ( TinyGPS &amp;g p s )\n154 {\n155 / / b y t e d i a , m\u00eas , h o r a , m i n u t o , s e g u n d o , c e n t \u00e9 s i m o s ;\n156 g p s . g e t _ p o s i t i o n (&amp; l a t , &amp;l o n ) ;\n157 LAT = l a t ;\n158 LON = l o n ;\n159 {\n160 f e e d g p s ( ) ; / / Se n \u00e3 o a l i m e n t a r o g p s d u r a n t e e s t a l o n g a r o t i n a ,\n\np o d em o s o b t e r e r r o s d e c h e c k s u m\n161 }\n162 }\n\nOs resultados dos valores das aquisi\u00e7\u00f5es dos sensores e acionamento dos atuadores\nconsistem em objetos instanciados e podem ser visualizados em uma tela em texto que\ndisponibiliza as informa\u00e7\u00f5es de tempo real do teste. O receptor GPS informa a latitude\ne longitude, os dados de posi\u00e7\u00e3o global s\u00e3o passados para um mapa utilizando o \"GPS\nVisualizer\" para testes iniciais. O sonar informa a distancia de obst\u00e1culos em cent\u00edmetros,\ncaso o obst\u00e1culo estiver a uma distancia menor que o limite escolhido, \u00e9 acionado o\nmicromotor CC, e por \u00faltimo, o LDR informa o n\u00edvel de luminosidade do ambiente. O\nsistema embarcado foi testado no PGPEE - UFRGS.\n\n\n\n139\n\n6 CONCLUS\u00c3O E TRABALHOS FUTUROS\n\nConforme a integra\u00e7\u00e3o do framework SOA com os estudos de casos, foram analisa-\ndas quest\u00f5es como a gerenciamento das an\u00e1lises e equipamentos, bem como a escala-\nbilidade da solu\u00e7\u00e3o. Tamb\u00e9m foram testadas as entidades implementadas, verificando a\ninteroperabilidade entre os diferentes componentes de softwares do projeto. Alguns ex-\nperimentos visam comprovar as vantagens na utiliza\u00e7\u00e3o da proposta SOA definida neste\nestudo. Construir um framework SOA, assim como todo sistema grande e complexo,\nexige um planejamento e uma modelagem pr\u00e9via. Esse planejamento leva \u00e0 constru\u00e7\u00e3o\nde uma arquitetura, definindo m\u00f3dulos, componentes e suas intera\u00e7\u00f5es. Com este tra-\nbalho, espera-se facilitar o desenvolvimento de sistemas embarcados para a comunidade\nde rob\u00f3tica e criar um framework SOA que possa ser utilizado por professores e alu-\nnos em aulas da gradua\u00e7\u00e3o de Engenharia da UFRGS. Fornecendo o manual e c\u00f3digo\nsobre licen\u00e7a aberta, ser\u00e1 dado a qualquer desenvolvedor o direito de implementar este\nframework em sua aplica\u00e7\u00e3o e, com isso, diminuindo pelo menos um pouco o retrabalho\nde construir um projeto de rob\u00f3tica e automa\u00e7\u00e3o. Dividir o projeto em grupos menores\najudou a organizar o c\u00f3digo, garantir que todas as funcionalidades est\u00e3o desenvolvidas e\ndiminuir o acoplamento entre as partes. Ao definir o que \u00e9 vis\u00edvel em um m\u00f3dulo e como\noper\u00e1-lo (interface) e como os componentes se comunicam fica mais f\u00e1cil testar, isolar\nfuncionalidades e garantir o bom funcionamento de cada parte do sistema e dele como\num todo. Os resultados iniciais deste projeto s\u00e3o as modelagens de projeto e a integra\u00e7\u00e3o\ndos equipamentos mec\u00e2nicos, eletromec\u00e2nicos e de computa\u00e7\u00e3o com o framework SOA,\nbem como as implementa\u00e7\u00f5es e adapta\u00e7\u00f5es de bibliotecas, protocolos de comunica\u00e7\u00e3o,\nsensores, atuadores e arquiteturas de controle (PID - proporcional integral derivativo) que\ns\u00e3o fornecidos em forma de servi\u00e7o no Framework SOA. Trabalhos futuros incluem conti-\nnuar a implementa\u00e7\u00e3o dos estudos de caso e do framework SOA. Threads, processamento\nde imagens, \u00e1udio e identifica\u00e7\u00e3o por radio frequ\u00eancia tamb\u00e9m est\u00e3o sendo investigados\ncomo futuros dispositivos para o projeto. Tamb\u00e9m esta sendo estudado a substitui\u00e7\u00e3o\ndo microprocessador ATmega328P pelo ARM Cortex-M3 (32-bit) para ter um melhor\nprocessamento nos sistemas embarcados. Com o sistema de rastreamento, o objetivo \u00e9\nimplementar uma central de localiza\u00e7\u00e3o de bengalas eletr\u00f4nicas, atrav\u00e9s dos dados envi-\nados a um servidor central que ir\u00e1 converter os dados de localiza\u00e7\u00e3o em posi\u00e7\u00f5es em um\nmapa, para criar mapas, rotas de condu\u00e7\u00e3o, endere\u00e7os ou coordenadas simples a partir de\ndados GPS. Os testes finais mostraram que ainda h\u00e1 espa\u00e7o para melhorias no projeto em\ngeral.\n\n\n\n\n\n141\n\nREFER\u00caNCIAS\n\nATMEL. Datasheet ATmega328P. Dispon\u00edvel em:\n<http://www.atmel.com/pt/br/devices/atmega328p.aspx>. Acesso em: 21 Jan. 2015.\n\nBAZANELLA, A. S.; GOMES DA SILVA, J. M. Sistemas de Controle: princ\u00edpios e\nm\u00e9todos de projeto. Porto Alegre: UFRGS, 2005.\n\nDa Silva, P. C. B. Utilizando UML: diagramas de implanta\u00e7\u00e3o, comunica\u00e7\u00e3o e tempo.\nDispon\u00edvel em:&lt;http://www.devmedia.com.br/revista-sql-magazine-134/33353>.\nAcesso em: 14 Set. 2015.\n\nEAGLE, C. CadSoft EAGLE PCB Design Software. Dispon\u00edvel em:\n<http://www.cadsoftusa.com/>. Acesso em: 12 Jul. 2014.\n\nEDUBOT. Prot\u00f3tipo de uma plataforma rob\u00f3tica livre para educa\u00e7\u00e3o utilizando\nmetareciclagem. Dispon\u00edvel em:&lt;https://uriedubot.wordpress.com>. Acesso em: 28\nAgo. 2014.\n\nERL, T. Service-oriented architecture: concepts, technology, and design. Indianapolis,\nIndiana: Prentice Hall, 2005.\n\nERL, T. SOA: principles of service design. Indianapolis, Indiana: Prentice Hall, 2007.\n\nFIGUEIREDO, L. C.; JOTA, F. G. Introdu\u00e7\u00e3o ao Controle de Sistemas\nN\u00e3o-Holon\u00f4micos. Revista Controle Automa\u00e7\u00e3o, Campinas, S\u00e3o Paulo, v.15, n.3,\np.243\u2013268, Set. 2004.\n\nFRISCHHOLZ, R. Face Detection Datasets. Dispon\u00edvel em:\n<https://facedetection.com/datasets/>. Acesso em: 10 Ago. 2015.\n\nFUGITA, H. S. MAPOS: m\u00e9todo de an\u00e1lise e projeto orientado a servi\u00e7os. 2009. 175p.\nDisserta\u00e7\u00e3o (Mestrado em Engenharia da Computa\u00e7\u00e3o e Sistemas Digitais) \u2014 Escola\nPolit\u00e9cnica da Universidade de S\u00e3o Paulo, S\u00e3o Paulo, 2009.\n\nGARRO, R.; ORDINEZ, L.; SCASSO, M. Patrones de Dise\u00f1o para Sistemas Ciber\nF\u00edsicos. In: CONGRESO MICROELECTR\u00d3NICA APLICADA. 4., 2013, Bah\u00eda\nBlanca. Anais. . . Bah\u00eda Blanca: uEA, 2013. n.4, p.17\u201321.\n\nGUIBOT. Driver Motoruino. Dispon\u00edvel em:&lt;http://www.guibot.pt/>. Acesso em: 14\nNov. 2014.\n\n\n\n142\n\nGUIMAR\u00c3ES, C.; HENRIQUES, R.; PEREIRA, C. Prot\u00f3tipo de um Sistema\nEmbarcado para Aux\u00edlio \u00e0 Macro e Micro Navega\u00e7\u00e3o de Deficientes Visuais. In:\nENCUENTROS IBEROAMERICANOS: SEMINARIO CYTED DE LA RED\nTEM\u00c1TICA IBERADA JORNADAS AITADIS DE TECNOLOG\u00cdAS DE APOYO A\nLA DISCAPACIDAD. 5., 2012, Vit\u00f3ria. Anais. . . Vit\u00f3ria: GM, 2012. n.5, p.92\u201397.\n\nGUIMAR\u00c3ES, C.; HENRIQUES, R.; PEREIRA, C. Analysis and Design of an\nEmbedded System to aid the navigation of the Visually Impaired. In: IEEE\nBIOSIGNALS AND BIOROBOTICS CONFERENCE. 4., 2013, Rio de Janeiro.\nAnais. . . Rio de Janeiro: IEEE, 2013. n.4, p.1\u20136.\n\nGUIMAR\u00c3ES, C.; PEREIRA, C.; HENRIQUES, R. Telemetria e Telecontrole de um\nSistema Embarcado Aplicado na Macro e Micro Navega\u00e7\u00e3o de Deficientes Visuais. In:\nINTERNATIONAL CONFERENCE ON REMOTE ENGINEERING AND VIRTUAL\nINSTRUMENTATION. 11., 2014, Porto. Anais. . . Porto: IEEE, 2014. n.11, p.424\u2013433.\n\nGUIMAR\u00c3ES, C. S. S. EduBOT UFRGS - Algoritmo seguidor de parede. Dispon\u00edvel\nem:&lt;https://www.youtube.com/watch?v=Z8KsVS1BubI>. Acesso em: 12 Jun. 2015.\n\nGUIMAR\u00c3ES, C.; TAMAYO, J.; HENRIQUES, R. Robotica para los Procesos de\nEnsenanza de la Mecatronica: desarrollo del prototipo edubotv2 para la mejora de\nprocesos de ingenieria de control. In: CONGRESO INTERNACIONAL SOCIEDAD\nDIGITAL: CIUDADANIA DIGITAL Y NUEVAS ALFABETIZACIONES. 3., 2014,\nMadrid. Anais. . . Madrid: Actas Icono14, 2014. n.16, p.349\u2013376.\n\nKUHNE, F. Controle Preditivo de Rob\u00f4s M\u00f3veis N\u00e3o Holon\u00f4micos. 2005. 155p.\nDisserta\u00e7\u00e3o (Mestrado em Engenharia da El\u00e9trica) \u2014 Universidade Federal do Rio\nGrande do Sul, Porto Alegre, 2005.\n\nKUROIWA, D. M. A. Reflex\u00f5es sobre a Arquitetura Orientada a Servi\u00e7o e o\nSurgimento de uma Nova Disciplina, a Engenharia de Software de Servi\u00e7o. 2011.\n30p. Trabalho de Conclus\u00e3o (Gradua\u00e7\u00e3o) \u2014 Faculdade de Tecnologia de S\u00e3o Paulo,\nBom Retiro, SP - Brasil, 2011.\n\nLAGES, W. F. Controle e Estima\u00e7\u00e3o de Posi\u00e7\u00e3o e Orienta\u00e7\u00e3o de Rob\u00f4s M\u00f3veis.\n1998. 180p. Tese (Doutorado em Engenharia Eletr\u00f4nica e Computa\u00e7\u00e3o) \u2014 Instituto\nTecnol\u00f3gico de Aeron\u00e1utica, S\u00e3o Jos\u00e9 dos Campos, 1998.\n\nLEE, E. A.; SESHIA, S. A. Introduction to Embedded Systems: a cyber physical\nsystems approach. Berkeley: University of California, 2011.\n\nMARTINS, M. d. S. osTWDR - Open source two wheeled differential robot.\nDispon\u00edvel em:&lt;http://msm.no.sapo.pt/osTWDR/>. Acesso em: 01 Nov. 2011.\n\nMAXWELL. Reposit\u00f3rio institucional da Pontif\u00edcia Universidade Cat\u00f3lica do Rio\nde Janeiro: certifica\u00e7\u00e3o digital 0410823/CA. Dispon\u00edvel em:\n<http://www.maxwell.vrac.puc-rio.br/8623/8623_3.PDF>. Acesso em: 08 Set. 2014.\n\nMAXWELL. Reposit\u00f3rio institucional da Pontif\u00edcia Universidade Cat\u00f3lica do Rio\nde Janeiro: certifica\u00e7\u00e3o digital 0210486/CA. Dispon\u00edvel em:\n<http://www.maxwell.vrac.puc-rio.br/5064/5064_3.PDF>. Acesso em: 05 Jun. 2014.\n\n\n\n143\n\nMIRANDA, L. C.; SAMPAIO, F. S.; BORGES, J. A. RoboF\u00e1cil: especifica\u00e7\u00e3o e\nimplementa\u00e7\u00e3o de um kit de rob\u00f3tica para a realidade educacional brasileira. Revista\nBrasileira de Inform\u00e1tica na Educa\u00e7\u00e3o (RBIE), Porto Alegre, v.18, n.3, p.47\u201358,\n2010.\n\nMOBILEROBOTS, A. Pioneer P3-DX. Dispon\u00edvel em:\n<http://www.mobilerobots.com/researchRobots/PioneerP3DX.aspx>. Acesso em: 10\nSep. 2014.\n\nMYROBOTLAB. Open source Java service based framework for robotics.\nDispon\u00edvel em:&lt;http://www.myrobotlab.org>. Acesso em: 16 Oct. 2014.\n\nOASIS, W. Web Services Business Process Execution Language. Dispon\u00edvel em:\n<http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-OS.html>. Acesso em: 06 Out.\n2013.\n\nPAPAZOGLOU, M. Service-Oriented Computing: concepts, characteristics and\ndirections. In: INTERNATIONAL CONFERENCE ON WEB INFORMATION\nSYSTEMS ENGINEERING. 4., 2003, Tilburg. Anais. . . Tilburg: IEEE, 2003. n.4, p.12.\n\nPOLOLU. Pololu Robotics and Electronics. Dispon\u00edvel em:\n<https://www.pololu.com/>. Acesso em: 05 Aug. 2014.\n\nPRESSMAN, R. S. Software Engineering: a practitioner\u2019s approach. New York:\nMcGraw-Hill, 2010.\n\nRINCON, R. L. Framework de Defini\u00e7\u00e3o de Trajet\u00f3ria para Rob\u00f4s M\u00f3veis. 2014.\n71p. Trabalho de Conclus\u00e3o (Gradua\u00e7\u00e3o) \u2014 Universidade de Bras\u00edlia - UnB, Bras\u00edlia,\nDF, 2014.\n\nROSA, P. R. M. Bengala de apoio a cegos com detec\u00e7\u00e3o de buracos. 2009. 81p.\nDisserta\u00e7\u00e3o (Mestre em Engenharia Electr\u00f3nica e Telecomunica\u00e7\u00f5es) \u2014 Universidade\nde Aveiro, Aveiro, 2009.\n\nSECCHI, H. Uma Introdu\u00e7\u00e3o aos Rob\u00f4s M\u00f3veis. 2008. 81p. Trabalho de Conclus\u00e3o\n(Gradua\u00e7\u00e3o) \u2014 Universidade Nacional de San Juan, San Juan - Argentina, 2008.\n\nSERAFIM, G. CBD vs. SOA Servi\u00e7os, processos de neg\u00f3cio e componentes que\nrealizam os servi\u00e7os. Engenharia de Software, S\u00e3o Paulo, v.2, p.243\u2013268, Nov. 2009.\n\nSIEGWART, R.; NOURBAKHSH, I. R. Introduction to Autonomous Mobile Robots:\nautonomous mobile robots. Cambridge, Massachusetts: MIT Press, 2004.\n\nSILVA, A. F. da. RoboEduc: uma metodologia de aprendizado com rob\u00f3tica\neducacional. 2009. 115p. Tese (Doutorado em Engenharia da Computa\u00e7\u00e3o) \u2014\nUniversidade Federal do Rio Grande do Norte, Lagoa Nova, 2009.\n\nSILVA, R. P. e. Suporte ao desenvolvimento e uso de frameworks e componentes.\n2000. 262p. Tese (Doutorado em Ci\u00eancia da Computa\u00e7\u00e3o) \u2014 Universidade Federal do\nRio Grande do Sul, Porto Alegre, 2000.\n\nSOLIDWORKS. 3D CAD Design Software Solidworks. Dispon\u00edvel em:\n<https://www.solidworks.com/>. Acesso em: 13 Jun. 2014.\n\n\n\n144\n\nSOMMERVILLE, I. Software Engineering. Massachusetts: Pearson, 2011.\n\nWARD, P. A.; MELLOR, S. J. Structured Development for Real-Time:\nimplementation modeling techniques. Upper Saddle River, New Jersey: Prentice Hall,\n1986.\n\nWEHRMEISTER, M. A. Framework Orientado a Objetos para Projeto de\nHardware e Software Embarcados para Sistemas Tempo-Real. 2005. 104p.\nDisserta\u00e7\u00e3o (Mestrado em Ci\u00eancia da Computa\u00e7\u00e3o) \u2014 Universidade Federal do Rio\nGrande do Sul, Porto Alegre, 2005."}]}}}