{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.13737"}, {"@name": "filename", "#text": "19852_tese.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Universidade de Aveiro \n\n2017 \n\nDepartamento de Eletr\u00f3nica, Telecomunica\u00e7\u00f5es e        \n\nInform\u00e1tica \n\nJos\u00e9 Hor\u00e1cio Fradique \nDuarte \n\nA Framework for the Management of Deformable \nMoving Objects \n\n \n\nUm Framework para Manipula\u00e7\u00e3o de Objetos M\u00f3veis \nDeform\u00e1veis \n\n \n\n Disserta\u00e7\u00e3o apresentada \u00e0 Universidade de Aveiro para cumprimento dos \nrequisitos necess\u00e1rios \u00e0 obten\u00e7\u00e3o do grau de Mestre em Engenharia \nInform\u00e1tica, realizada sob a orienta\u00e7\u00e3o cient\u00edfica do Doutor Jos\u00e9 Manuel Matos \nMoreira, Professor Auxiliar do Departamento de Eletr\u00f3nica, Telecomunica\u00e7\u00f5es \ne Inform\u00e1tica da Universidade de Aveiro e do Doutor Paulo Miguel de Jesus \nDias, Professor Auxiliar do Departamento de Eletr\u00f3nica, Telecomunica\u00e7\u00f5es e \nInform\u00e1tica da Universidade de Aveiro \n\n \n\n  \n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n  \n\n \n\n \n\n \n\n \n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n \n\n \n \n \n\n \n \n\nO j\u00fari /The jury   \n \n\nPresidente / President Prof. Doutor Joaquim Arnaldo Carvalho Martins \nProfessor Catedr\u00e1tico da Universidade de Aveiro \n\n  \n \n\nVogais / Examiners  Prof. Doutor Alexandre Miguel Barbosa Valle de Carvalho \nProfessor Auxiliar da Faculdade de Engenharia da Universidade do Porto \n\nCommittee  \n\n Prof. Doutor Jos\u00e9 Manuel Matos Moreira  \nProfessor Auxiliar da Universidade de Aveiro (Orientador) \n\n  \n\n Prof. Doutor Paulo Miguel de Jesus Dias  \nProfessor Auxiliar da Universidade de Aveiro (Co-orientador) \n\n  \n \n\n  \n\n  \n \n\n  \n\n  \n\n  \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n  \n \n\nAgradecimentos / \nAcknowledgments \n\n \n\nQuero agradecer aos meus orientadores, Professor Jos\u00e9 Moreira e Professor \nPaulo Dias, pela sua disponibilidade, pela sua ajuda e pelo bom \nrelacionamento que sempre tivemos durante esta aventura. \n \nQuero agradecer \u00e0 Professora Enide Martins pela sua disponibilidade e pelo \nseu tempo para discutirmos algumas quest\u00f5es mais matem\u00e1ticas. \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n  \n\nKeywords \n\n \n\nMoving Objects, Spatiotemporal Data Models, Spatiotemporal Databases, \nCompatible Triangulation, Rigid Interpolation. \n\n Abstract \n\n \n\n \n\nThere is an emergence of a growing number of applications and services \nbased on spatiotemporal data in the most diverse areas of knowledge and \nhuman activity. The Internet of Things (IoT), the emergence of technologies \nthat make it possible to collect information about the evolution of real world \nphenomena and the widespread use of devices that can use the Global \nPositioning System (GPS), such as smartphones and navigation systems, \nsuggest that the volume and value of these data will increase significantly in the \nfuture. It is necessary to develop tools capable of extracting knowledge from \nthese data and for this it is necessary to manage them: represent, manipulate, \nanalyze and store, in an efficient way. But this data can be complex, its \nmanagement is not trivial and there is not yet a complete system capable of \nperforming this task. \nWorks on moving points, that represent the position of objects over time, are \nfrequent in the literature. On the contrary there are much less solutions for the \nrepresentation of moving regions, that represent the continuous changes in \nposition, shape and extent of objects over time, e.g., storms, fires and icebergs. \nThe representation of the evolution of moving regions is complex and requires \nthe use of more elaborate techniques, e.g., morphing and interpolation \ntechniques, capable of producing realistic and geometrically valid \nrepresentations. \nIn this dissertation we present and propose a data model for moving objects \n(moving points and moving regions), in particular for moving regions, based on \nthe concept of mesh and compatible triangulation and rigid interpolation \nmethods. This model was implemented in a framework that is not client or \napplication dependent and we also implemented a spatiotemporal extension for \nPostgreSQL that uses this framework to manipulate and analyze moving \nobjects, as a proof of concept that our framework works with real applications. \nThe tests\u2019 results using real data, obtained from satellite images of the \nevolution of 2 icebergs over time, show that our data model works. Besides the \nresults obtained one important contribution of this work is the development of a \nbasic framework for moving objects that can be used as a basis for further \ninvestigation in this area. A few problems still remain that must be further \nstudied and analyzed, in particular, the ones that were found when using the \ncompatible triangulation and rigid interpolation methods with real data. \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n  \n\n \n\n \n\n \n\n \n\n \n\n  \n\nPalavras-Chave \n\n \n\nObjetos M\u00f3veis, Modelos de Dados Esp\u00e1cio-temporais, Bases de Dados \nEsp\u00e1cio-temporais, Triangula\u00e7\u00e3o Compat\u00edvel, Interpola\u00e7\u00e3o R\u00edgida. \n\nResumo \n\n \n\nAssistimos ao aparecimento de um n\u00famero crescente de aplica\u00e7\u00f5es e servi\u00e7os \nbaseados em dados esp\u00e1cio-temporais nas mais diversas \u00e1reas do \nconhecimento e da atividade humana. A internet das coisas (IoT), o \naparecimento de novas tecnologias que permitem obter dados sobre a \nevolu\u00e7\u00e3o de fen\u00f3menos do mundo real e o uso generalizado de dispositivos \nque usam o sistema de posicionamento global (GPS), por exemplo, \nsmartphones e sistemas de navega\u00e7\u00e3o, sugerem que o volume e o valor \ndestes dados aumente significativamente no futuro. Torna-se necess\u00e1rio \ndesenvolver ferramentas capazes de extrair conhecimento destes dados e \npara isso \u00e9 necess\u00e1rio geri-los: representar, manipular, analisar e armazenar, \nde uma forma eficiente. Mas estes dados podem ser complexos, a sua gest\u00e3o \nn\u00e3o \u00e9 trivial e ainda n\u00e3o existe um sistema completo capaz de executar essa \ntarefa. \nExiste muito trabalho na literatura sobre pontos m\u00f3veis, que representam as \naltera\u00e7\u00f5es da posi\u00e7\u00e3o de objectos ao longo do tempo, mas existe muito menos \ntrabalho realizado sobre regi\u00f5es m\u00f3veis, que representam as altera\u00e7\u00f5es da \nposi\u00e7\u00e3o e da forma de regi\u00f5es ao longo do tempo, por exemplo, uma \ntempestade, um inc\u00eandio ou um derramamento de petroleo. A representa\u00e7\u00e3o \nda evolu\u00e7\u00e3o de regi\u00f5es m\u00f3veis ao longo do tempo \u00e9 complexa e exige o uso \nde t\u00e9cnicas mais elaboradas, por exemplo, t\u00e9cnicas de morphing e \ninterpola\u00e7\u00e3o, capazes de produzir representa\u00e7\u00f5es realistas e geometricamente \nv\u00e1lidas. \nNesta disserta\u00e7\u00e3o apresentamos e propomos um modelo de dados para \ntrabalhar com objetos m\u00f3veis (pontos m\u00f3veis e regi\u00f5es m\u00f3veis), em particular \nregi\u00f5es m\u00f3veis, baseado no conceito de malha e em m\u00e9todos de triangula\u00e7\u00e3o \ncompat\u00edvel e interpola\u00e7\u00e3o r\u00edgida. Este modelo foi implementado num \nframework que \u00e9 independente do cliente e da aplica\u00e7\u00e3o. Tamb\u00e9m \nimplement\u00e1mos uma extens\u00e3o esp\u00e1cio-temporal para o sistema de gest\u00e3o de \nbase de dados PostgreSQL, que usa este framework para manipular e analisar \nobjectos m\u00f3veis, como uma prova de conceito que o nosso framework \nfunciona com aplica\u00e7\u00f5es reais. Os resultados dos testes com dados reais, \nobtidos a partir de imagens de sat\u00e9lite da evolu\u00e7\u00e3o de 2 icebergs ao longo do \ntempo, demonstram que o nosso modelo funciona. Para al\u00e9m dos resultados \nobtidos, um contributo importante desta disserta\u00e7\u00e3o \u00e9 o desenvolvimento de \num framework que pode ser usado como a base para trabalho futuro e \ninvestiga\u00e7\u00e3o nesta \u00e1rea. Existem alguns problemas ainda por resolver e que \ndevem ser analisados e estudados com mais cuidado, em particular, os que \nforam encontrados quando us\u00e1mos os m\u00e9todos de triangula\u00e7\u00e3o compat\u00edvel e \ninterpola\u00e7\u00e3o rig\u00edda em dados reais. \n\n \n \n\n\n\n \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\ni \n\n \n\nContents \n\n1. Introduction .............................................................................................................................................. 1 \n\n1.1 Context, Motivation and Goals ......................................................................................................... 2 \n\n1.2 Outline of this Dissertation ............................................................................................................... 3 \n\n2. Representation and Management of Spatiotemporal Data ....................................................................... 5 \n\n2.1 Concepts ........................................................................................................................................... 5 \n\n2.2 Spatiotemporal Databases................................................................................................................. 6 \n\n2.2.1 Applications ............................................................................................................................ 7 \n\n2.2.2 Architecture ............................................................................................................................. 7 \n\n2.2.3 Data Models and Operations ................................................................................................... 8 \n\n2.2.4 Spatiotemporal Query Languages ......................................................................................... 11 \n\n2.3 Spatiotemporal ORDBMSs .............................................................................................................. 12 \n\n2.4 Representation of Moving Regions.................................................................................................. 15 \n\n2.5 Summary .......................................................................................................................................... 17 \n\n3. A Discrete Data Model for Moving Objects .......................................................................................... 19 \n\n3.1 Overview.......................................................................................................................................... 22 \n\n3.2 Notation and Assumptions ............................................................................................................... 23 \n\n3.3 Type System Data Types ................................................................................................................. 24 \n\n3.3.1 Base Types and Time Types ..................................................................................................... 24 \n\n3.3.2 Interval and Period Types ......................................................................................................... 24 \n\n3.3.3 Spatial types .............................................................................................................................. 24 \n\n3.3.4 Sliced Representation for Moving Objects ............................................................................... 26 \n\n3.3.5 Temporal Units for Base Data Types ........................................................................................ 27 \n\n3.3.6 Temporal Units for Spatial Data Types .................................................................................... 27 \n\n3.3.7 Moving Types ........................................................................................................................... 28 \n\n3.4 Operations on Moving Types ........................................................................................................... 28 \n\n3.4.1 Predicates .................................................................................................................................. 29 \n\n\n\n \n\n \n\n \n\n \n\nii \n\n3.4.2 Set Operations ........................................................................................................................... 29 \n\n3.4.3 Numeric .................................................................................................................................... 30 \n\n3.4.4 Projection to Domain and Range .............................................................................................. 30 \n\n3.4.5 Interaction with Domain and Range ......................................................................................... 30 \n\n3.4.6 Constructors .............................................................................................................................. 31 \n\n3.5 Summary .......................................................................................................................................... 31 \n\n4. Implementation ...................................................................................................................................... 33 \n\n4.1 Overview.......................................................................................................................................... 33 \n\n4.2 Technologies and Architectures ....................................................................................................... 36 \n\n4.2.1 To Implement a Framework for Moving Objects ..................................................................... 37 \n\n4.2.2 To implement a Spatiotemporal Database Extension................................................................ 40 \n\n4.3 SPTMesh - A Framework for Moving Objects ................................................................................ 40 \n\n4.3.1 Dependencies ............................................................................................................................ 40 \n\n4.3.2 Data Structures .......................................................................................................................... 41 \n\n4.3.3 Operations ................................................................................................................................. 43 \n\n4.3.4 Triangulation, Smoothing and Interpolation Methods .............................................................. 46 \n\n4.3.5 Continuity for Unit Types ......................................................................................................... 47 \n\n4.3.6 A Spatiotemporal Well-Known Text Form for Moving Objects .............................................. 47 \n\n4.3.7 Architecture .............................................................................................................................. 49 \n\n4.3.8 Issues ......................................................................................................................................... 50 \n\n4.3.9 Usage and Installation ............................................................................................................... 52 \n\n4.4 MeshGIS - A Spatiotemporal Extension for PostgreSQL ................................................................ 53 \n\n4.4.1 Data Structures .......................................................................................................................... 54 \n\n4.4.2 Operations ................................................................................................................................. 57 \n\n4.4.3 Architecture .............................................................................................................................. 59 \n\n4.4.4 Usage and Installation ............................................................................................................... 60 \n\n4.5 A Framework for Future Work and Investigation ............................................................................ 61 \n\n4.5.1 Code Structure .......................................................................................................................... 61 \n\n4.5.2 Extending the Framework ......................................................................................................... 63 \n\n4.6 Summary .......................................................................................................................................... 64 \n\n\n\n \n\n \n\n \n\n \n\niii \n\n5. Data Model Evaluation .......................................................................................................................... 65 \n\n5.1 Datasets ............................................................................................................................................ 65 \n\n5.2 Tests ................................................................................................................................................. 65 \n\n5.3 Summary .......................................................................................................................................... 72 \n\n6. Discussion .............................................................................................................................................. 75 \n\n6.1 Compatible Triangulation ................................................................................................................ 75 \n\n6.2 Interpolation ..................................................................................................................................... 77 \n\n6.2.1 Degenerated Triangles and Invalid Geometries ........................................................................ 77 \n\n6.2.2 Unwrap Method ........................................................................................................................ 79 \n\n6.2.3 Smoothing Method Relevance .................................................................................................. 80 \n\n6.3 Smoothing Method Performance ..................................................................................................... 81 \n\n6.4 Continuity ........................................................................................................................................ 82 \n\n6.4.1 Mesh Objects ............................................................................................................................ 82 \n\n6.4.2 Unit Real Objects ...................................................................................................................... 83 \n\n6.5 Other Issues ..................................................................................................................................... 83 \n\n6.6 Summary .......................................................................................................................................... 84 \n\n7. Conclusions and Future Work ............................................................................................................... 85 \n\n7.1 Conclusions ...................................................................................................................................... 85 \n\n7.2 Main Contributions .......................................................................................................................... 86 \n\n7.3 Future Work ..................................................................................................................................... 87 \n\n8. Bibliography .......................................................................................................................................... 89 \n\n \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\niv \n\n  \n\n\n\n \n\n \n\n \n\n \n\nv \n\n \n\nList of Figures \n\nFigure 1.1 - 2 observations of the evolution of an iceberg over time. ............................................................... 2 \n\nFigure 2.1 - Sliced representation of: a moving real (left) and 2 moving points (right). Source: (Forlizzi et al., \n\n2000)................................................................................................................................................................ 10 \n\nFigure 2.2 - A Moving point with various types of movement. Source: (Nikos Pelekis &amp; Theodoridis, 2007).\n\n ......................................................................................................................................................................... 10 \n\nFigure 2.3 - Observations of an iceberg evolving continuously over time. ..................................................... 15 \n\nFigure 2.4 - Examples of possible interpolation results that represent the region\u2019s evolution during a slice. . 16 \n\nFigure 2.5 - Two different morphing techniques. Source: image adapted form (Baxter et al., 2008). ............ 17 \n\nFigure 3.1 - 2 observations of the evolution of an iceberg over time. ............................................................. 19 \n\nFigure 3.2 - A geometry with collinear points. ................................................................................................ 20 \n\nFigure 3.3 - 2 meshes. ..................................................................................................................................... 20 \n\nFigure 3.4 - Steiner points. .............................................................................................................................. 21 \n\nFigure 3.5 - A mesh obtained not using (left) and using (right) the smoothing method. ................................. 21 \n\nFigure 3.6 - A mesh of an iceberg, obtained using our framework for moving objects. ................................. 24 \n\nFigure 4.1 - Overall overview of the architecture of a system that uses MeshGIS and SPTMesh. ................. 36 \n\nFigure 4.2 - SPTMesh architecture using C++ and GEOS. ............................................................................. 37 \n\nFigure 4.3 - SPTMesh architecture using Python and Shapely. ...................................................................... 38 \n\nFigure 4.4 - SPTMesh architecture using PostGIS. ......................................................................................... 38 \n\nFigure 4.5 - GEOS Architecture. ..................................................................................................................... 39 \n\nFigure 4.6 - Interpolation of a geometry that coils during an interval. ............................................................ 47 \n\nFigure 4.7 - SPTMesh architecture and available APIs. .................................................................................. 49 \n\nFigure 4.8 - The GEOS type system. Source: GEOS documentation. ............................................................. 49 \n\nFigure 4.9 - The SPTMesh type system. ......................................................................................................... 50 \n\nFigure 4.10 - SPTMesh interpolation method implementation classes and decoupling infrastructure. ........... 51 \n\nFigure 4.11 - A type system with a mobject and uobject types. ...................................................................... 52 \n\nFigure 4.12 - MeshGIS data structures relationships simplified diagram overview. ....................................... 56 \n\nFigure 4.13 - MeshGIS high level architecture overview. ............................................................................... 60 \n\nFigure 4.14 - PostGIS high level architecture overview with its external dependencies. ................................ 60 \n\nFigure 4.15 - Moving types available in PostgreSQL after installing MeshGIS. ............................................. 61 \n\nFigure 5.1 - Coil interpolation test................................................................................................................... 65 \n\nFigure 5.2 - 180\u00ba rotation test. ......................................................................................................................... 65 \n\nFigure 5.3 - The 2 icebergs used for testing in their initial positions after being processed using SPTMesh. 66 \n\nFigure 5.4 - Iceberg 1 interpolation test over an interval of time. ................................................................... 66 \n\n\n\n \n\n \n\n \n\n \n\nvi \n\nFigure 5.5 - Iceberg 2 interpolation test over an interval of time. ................................................................... 66 \n\nFigure 5.6 - The evolution of the 2 icebergs, seen together, over an interval of time. .................................... 67 \n\nFigure 5.7 - Ice 1 at instants 1000 and 2000. ................................................................................................... 68 \n\nFigure 5.8 - Ice 2 at instants 1100, 2000, 3000, 4000 and 4500. ..................................................................... 69 \n\nFigure 5.9 - Ice 1 at instant 1500. .................................................................................................................... 69 \n\nFigure 5.10 - Ice 1 area during the PERIOD(1100 10000). ............................................................................. 70 \n\nFigure 5.11 - 2 Icebergs intersecting over an interval of time. ........................................................................ 71 \n\nFigure 5.12 - ST_Intersection result at instant 1000 in light blue, seen in QGIS. ........................................... 71 \n\nFigure 6.1 - Examples of cloned (left) and collinear (right) vertices. .............................................................. 75 \n\nFigure 6.2 - 3 line segments configurations. .................................................................................................... 76 \n\nFigure 6.3 - Cloned vertex shifted along the line segments. ............................................................................ 76 \n\nFigure 6.4 - Possible new positions for the cloned vertex shifted along the perpendicular line. ..................... 76 \n\nFigure 6.5 - An invalid geometry. Source: smoothing_test_ice1_2_3_GEOS_Clones.m. .............................. 77 \n\nFigure 6.6 - From left to right: source geometry, interpolated geometry at an instant and the target geometry.\n\n ......................................................................................................................................................................... 78 \n\nFigure 6.7 - From left to right: source geometry with a degenerated triangle, the interpolated geometry at 3 \n\ndifferent instants and the target geometry. ...................................................................................................... 78 \n\nFigure 6.8 - From left to right: source geometry without the degenerated triangle, the interpolated geometry at \n\n3 different instants and the target geometry. ................................................................................................... 78 \n\nFigure 6.9 - From left to right: instants 1, 8 and 11. Coil interpolation test during an interval I with a carefully \n\nchosen permutation of A. Source: interpolation_test_coil_tri_order_2.m. ...................................................... 79 \n\nFigure 6.10 - From left to right: instants 1, 8 and 11. Coil interpolation test during an interval I with a random \n\npermutation of A. Source: interpolation_test_coil_tri_order.m. ...................................................................... 79 \n\nFigure 6.11 - A sequence of triangles with ids from 1, \u2026, 18......................................................................... 79 \n\nFigure 6.12 - Triangulated geometry of an iceberg. ........................................................................................ 80 \n\nFigure 6.13 - Interpolation using the smoothing method. ................................................................................ 81 \n\nFigure 6.14 - Interpolation not using the smoothing method. .......................................................................... 81 \n\nFigure 6.15 - A source and target relatively simple smoothed meshes............................................................ 81 \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\nvii \n\n \n\nList of Tables \n\nTable 1.1 - Dissertation structure and content. .................................................................................................. 4 \n\nTable 2.1 - Main concepts used in this dissertation. .......................................................................................... 6 \n\nTable 3.1 - The signature of our discrete data model for moving objects. ...................................................... 23 \n\nTable 3.2 - Notation. ........................................................................................................................................ 23 \n\nTable 3.3 - Type mesh components. ................................................................................................................ 26 \n\nTable 3.4 - The set of operations on MOVING types in our discrete model. .................................................. 29 \n\nTable 3.5 - Predicate operations. ..................................................................................................................... 29 \n\nTable 3.6 - Set operations. ............................................................................................................................... 30 \n\nTable 3.7 - Numeric operations. ...................................................................................................................... 30 \n\nTable 3.8 - Projection of MOVING types to Domain and Range. .................................................................. 30 \n\nTable 3.9 - Restriction of MOVING types to the time and spatial domains. ................................................... 30 \n\nTable 3.10 - Constructors. ............................................................................................................................... 31 \n\nTable 4.1 - Implemented components. ............................................................................................................ 34 \n\nTable 4.2 - Technologies used to implement SPTMesh and MeshGIS. .......................................................... 35 \n\nTable 4.3 - Development environment setup. .................................................................................................. 35 \n\nTable 4.4 - SPTMesh external dependencies. .................................................................................................. 41 \n\nTable 4.5 - SPTMesh data structures to implement our discrete data model data types. ................................. 41 \n\nTable 4.6 - Other relevant SPTMesh data structures. ...................................................................................... 42 \n\nTable 4.7 - Notation. ........................................................................................................................................ 43 \n\nTable 4.8 - Predicate operations. ..................................................................................................................... 44 \n\nTable 4.9 - Set operations. ............................................................................................................................... 44 \n\nTable 4.10 - Numeric operations. .................................................................................................................... 44 \n\nTable 4.11 - Projection of MOVING types to Domain and Range. ................................................................ 44 \n\nTable 4.12 - Interaction of MOVING types with values in Domain and Range. ............................................ 44 \n\nTable 4.13 - Constructors. ............................................................................................................................... 45 \n\nTable 4.14 - Other interesting operations. ....................................................................................................... 46 \n\nTable 4.15 - Triangulation, smoothing and interpolation methods implementation classes. ........................... 46 \n\nTable 4.16 - The SPTMesh values used to help establish a notion of continuity for UNIT types. .................. 47 \n\nTable 4.17 - Notation. ...................................................................................................................................... 48 \n\nTable 4.18 - STWKT formats for UNIT and MOVING types. ....................................................................... 49 \n\nTable 4.19 - Main classes and responsibilities. ............................................................................................... 51 \n\nTable 4.20 - MeshGIS external dependencies. ................................................................................................ 53 \n\nTable 4.21 - PostGIS data structures. .............................................................................................................. 54 \n\n\n\n \n\n \n\n \n\n \n\nviii \n\nTable 4.22 - MeshGIS data structures to represent moving objects. ............................................................... 55 \n\nTable 4.23 - MeshGIS data structures to represent the interpolation components. ......................................... 55 \n\nTable 4.24 - MeshGIS and its binding SQL operations for SPTMesh MovingBool objects. .......................... 57 \n\nTable 4.25 - MeshGIS and its binding SQL operations for SPTMesh MovingReal objects. .......................... 58 \n\nTable 4.26 - MeshGIS and its binding SQL operations for SPTMesh MovingPoint objects. ......................... 58 \n\nTable 4.27 - MeshGIS and its binding SQL operations for SPTMesh MovingMesh objects. ......................... 59 \n\nTable 4.28 - PostGIS external dependencies. .................................................................................................. 60 \n\nTable 4.29 - SPTMesh namespaces. ................................................................................................................ 62 \n\nTable 4.30 - SPTMesh project structure. ......................................................................................................... 62 \n\nTable 4.31 - MeshGIS project structure. ......................................................................................................... 63 \n\nTable 4.32 - Adding a new smoothing method to SPTMesh. .......................................................................... 64 \n\nTable 5.1 - Results of the select command in the icebergs table. .................................................................... 67 \n\nTable 5.2 - Result of the ST_get_Size function after the icebergs\u2019 data was stored in the icebergs table. ...... 68 \n\nTable 5.3 - Period in which the records in the icebergs table are defined. ...................................................... 68 \n\nTable 5.4 - Records in the icebergs table defined in a given period. ............................................................... 69 \n\nTable 5.5 - Records in the icebergs table defined at a given instant. ............................................................... 69 \n\nTable 5.6 - Area of the icebergs in a given instant. ......................................................................................... 70 \n\nTable 5.7 - Evolution of the area of the icebergs in the table icebergs in a given period. ............................... 70 \n\nTable 5.8 - ST_Intersect results. ...................................................................................................................... 71 \n\nTable 5.9 - Using PostGIS to get the area of the intersection of 2 moving objects at instant 1000. ................ 72 \n\nTable 5.10 - ST_ Intersection result when no intersection exists. ................................................................... 72 \n\nTable 5.11 - ST_Present result at instant 2100. Ice 3 and 4 are not defined at that instant. ............................ 72 \n\nTable 5.12 - ST_Get_Present_AtPeriod result at a given period. (x y 0) means that the object is not defined in \n\nthe interval [x, y[. ............................................................................................................................................ 72 \n\nTable 6.1 - Results from a performance test performed in PostgreSQL using and not using the smoothing \n\nmethod. ............................................................................................................................................................ 82 \n\nTable 6.2 - Centroid positions, in the 2D Cartesian plane, of 9 continuous unit mesh objects, obtained from \n\nreal data, and their distances at the continuity instants. ................................................................................... 83 \n\nTable 6.3 - The area differences between 9 continuous unit mesh objects. ..................................................... 83 \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\nix \n\n \n\nList of Acronyms \n\nADT Abstract Data Type OGC The Open Geospatial Organization \n\nADAS Advanced Driver Assistance Systems OODBMS Object-Oriented Database Management \n\nSystem \n\nDBMS Database Management System ORDBMS Object Relational Database Management \n\nSystem \n\nDDL Data Definition Language OSGeo Open Source Geospatial Foundation \n\nDML Data Manipulation Language STIS Spatiotemporal Information System \n\nFTL Future Temporal Logic query language STDBMS Spatiotemporal Database Management System \n\nGPS Global Positioning System TDs Trajectory Databases \n\nGMODs Generic Moving Objects Databases TDWs Trajectory Data Warehouses \n\nIDE Integrated Development Environment SQL Structured Query Language \n\nIoT Internet of Things SVD Singular Value Decomposition \n\nLBSs location-based services   \n\nMOs Moving Objects   \n\nMOST Moving Objects Spatiotemporal data \n\nmodel \n\n  \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\nx \n\n \n\n\n\n \n\n \n\n \n\n \n\n1 \n\nCHAPTER 1 \n\n1.  Introduction \n\nThere is an emergence of a growing number of applications and services based on spatiotemporal data in \n\nthe most diverse areas of knowledge and human activity. The internet of things (IoT), the emergence of \n\ntechnologies that make it possible to collect information about the evolution of real world phenomena and the \n\nwidespread use of global positioning system (GPS) enabled devices, such as smartphones and navigation \n\nsystems, suggest that the volume and value of these data will increase significantly in the future. In this \n\ncontext, it is necessary to develop tools capable of extracting knowledge from these data and efficient ways \n\nto manage them: represent, manipulate, analyze and store. But this data can be complex, its management is \n\nnot trivial and there is not yet a complete system capable of performing this task. \n\nDatabase management systems (DBMSs) are a natural environment to manage data in an efficient way. \n\nHowever, existing DBMSs are not prepared to manage spatiotemporal data. One solution is to use DBMSs \n\nthat provide extensible architectures that allow the implementation of extensions, i.e., user-defined data \n\nmodels, to manage spatiotemporal data. \n\nThe management of spatiotemporal data, in DBMSs, has been studied from different perspectives, using \n\ndifferent techniques and architectures. Several data models have been proposed and there is already a \n\nconsiderable amount of work done and published on this subject. However, this topic is still an open field for \n\nresearch. \n\nSpatiotemporal databases have applications in several fields: \n\n? Advanced driver assistance systems (ADAS) and intelligent transportation systems (Popa &amp; \n\nZeitouni, 2012). \n\n? Environmental information systems (Wahid, Kamruzzaman, &amp; Shariff, 2006). \n\n? Location-based services (LBS) (Nikos Pelekis, Frentzos, Giatrakos, &amp; Theodoridis, 2008; Nikos \n\nPelekis &amp; Theodoridis, 2006). \n\n? Vehicle traffic analysis (Nikos Pelekis, Frentzos, Giatrakos, &amp; Theodoridis, 2010). \n\n? Air traffic control (Hurter, Andrienko, Andrienko, G, &amp; Sakr, 2013). \n\nIn this chapter we present: the context, the motivation, the goals, the structure and content of this \n\ndissertation. \n\n\n\n \n\n \n\n \n\n \n\n2 \n\n1.1 Context, Motivation and Goals \n\nWorking with spatiotemporal data, in particular data that represents the continuous evolution (i.e., the \n\nchanges in position, shape and extent) of some entity (or object) over time is challenging due to several \n\nreasons (Amaral, 2015): \n\n? The need to acquire 2D geometric representations of these entities from real data, e.g., from satellite \n\nimages. \n\n? The impossibility to store unlimited amounts of data. As a consequence, we have to take \n\nobservations at specific instants in time and represent these continuous changes from that set of \n\ndiscrete data. This requires the existence of some interpolation function that should have the \n\nfollowing properties: \n\n? Causes minimal deformation and preserves the physical characteristics of the entity being \n\nrepresented. That is, the function should provide a realistic representation of the entity\u2019s \n\nchanges in position, shape and extent over time. And this function is not necessarily a simple \n\nfunction, e.g., find a function to represent a realistic evolution of an iceberg between 2 known \n\nobservations (see Figure 1.1). \n\n? Generates only valid geometry topologies, i.e., generates geometries with no self-\n\nintersections. \n\n \n\nFigure 1.1 - 2 observations of the evolution of an iceberg over time. \n\nPrevious dissertations, (Paulo, 2012), (Mesquita, 2013) and (Amaral, 2015), studied and proposed \n\nmethods to deal with these issues and this dissertation uses them as the foundation to establish a framework \n\nfor moving objects, in particular objects whose position, shape and extent change continuously over time. \n\nThese methods enable us to obtain spatiotemporal data from real data and a realistic evolution of that data \n\nover time. In this dissertation we want to be able to manipulate, analyse and store this data and to achieve \n\nthat: \n\n? We propose a discrete data model for moving objects based on the methods implemented on these \n\ndissertations. \n\n\n\n \n\n \n\n \n\n \n\n3 \n\n? We implement the proposed data model in a framework for moving objects that is independent from \n\nany client using it. \n\n? We implement a spatiotemporal extension for PostgreSQL that uses our framework for moving \n\nobjects. \n\nThe main goals of this dissertation are the following: \n\n? Propose and establish a discrete data model for moving objects that uses the concept of mesh to \n\nrepresent objects whose position, shape and extent change continuously over time. Such data model \n\nis independent from any specific client or application using it, and that includes DBMSs. \n\n? Implement the proposed discrete data model using the methods implemented in (Amaral, 2015) as \n\npart of our framework for moving objects and evaluate its results using real data obtained by the \n\nmethods implemented in (Paulo, 2012) and (Mesquita, 2013). \n\n? Build a spatiotemporal database extension as a proof of concept that our framework works with real \n\napplications and can be used to implement spatiotemporal extensions. \n\n? Establish a framework for moving objects that can be used as a reference for future work and \n\ninvestigation in this area. \n\n1.2 Outline of this Dissertation \n\nThis dissertation is structured in 7 chapters, see Table 1.1. \n\nChapter Main Objectives and Content \n\n2 In this chapter we review related work found in the literature, in particular about: \n\n? Spatiotemporal databases: applications, architectures, data models and languages. \n\n? Spatiotemporal query languages. \n\n? Spatiotemporal object relational database management systems (ORDBMSs). \n\nAnd we briefly discuss the problems of representing the evolution of objects whose \n\nposition, shape and extent change continuously over time and morphing and shape \n\ninterpolation methods. \n\n3 In this chapter we present and propose a discrete data model for moving objects that uses the \n\nconcept of mesh to represent objects whose position, shape and extent change continuously \n\nover time and we define its data types and operations. \n\n4 In this chapter we discuss implementation details: \n\n? Our main goals and implementation specific needs. \n\n? The technologies and architectures that we considered using, their advantages and \n\ndisadvantages. \n\n? The technologies we used in our implementation. \n\n\n\n \n\n \n\n \n\n \n\n4 \n\n? The implementation details of the components that were implemented: its dependencies, \n\ndata structures, operations, architecture, usage and installation and implementation \n\nissues. \n\nWe also discuss the structure of the implemented components source code and the extension of \n\nour framework for moving objects with new triangulation and smoothing methods. \n\n5 In this chapter we present and discuss the tests that were performed to test and validate the \n\ncomponents and the methods that were implemented. \n\n6 In this chapter we present and discuss the major problems that were found, in particular, when \n\nworking with real data. We present observations, opinions, possible solutions and explanations \n\nbased on experimentation. And we discuss the structure of some of these problems to provide \n\nfuture work on these issues with some initial background on such a structure. \n\n7 In this chapter we present our main conclusions and discuss future work. \n\nTable 1.1 - Dissertation structure and content. \n\n \n\n \n\n \n\n  \n\n\n\n \n\n \n\n \n\n \n\n5 \n\nCHAPTER 2 \n\n2.  Representation and Management of Spatiotemporal \n\nData \n\nThe management of spatiotemporal data, in DBMSs, has been studied from different perspectives, using \n\ndifferent techniques and architectures. Several solutions have been proposed and there is already a \n\nconsiderable amount of work done and published on this subject. However, this topic is still an open field for \n\nresearch. \n\nIn this chapter we start by presenting some of the work done on the field of spatiotemporal databases: \n\ntheir applications and architecture, data models, operations and query languages. It is not, however, a general \n\noverview on the subject. We focus our presentation on work related to: \n\n? The representation of moving objects (MOs) that evolve continuously over time in unconstrained \n\nspace, using abstract data types (ADTs). \n\n? The management of the entire history of the evolution of MOs, i.e., its position or shape and extent \n\nchanges over time. \n\n? Data models that are not application-specific and that are capable of representing both: moving points \n\nand moving regions. \n\n? Data models that extend object-relational database management systems (ORDBMSs) with \n\nspatiotemporal functionality, i.e., data models using an extensible architecture. \n\n? Query languages for spatiotemporal databases. \n\nThen we discuss some of the problems of working with moving regions, morphing and triangulation \n\nmethods. \n\nOther subjects, e.g., MOs moving in networks, constraint databases or MOs with different transportation \n\nmodes, will be briefly discussed, when found relevant, or omitted. \n\n2.1 Concepts \n\nThroughout this dissertation we use some concepts that we define in this subsection. See Table 2.1. \n\nConcept Definition \n\nSpatiotemporal Data Data that has spatial and temporal components or aspects. It is usually \n\nrepresented in 3D, i.e., time + space (2D), can be highly complex and can be \n\nassociated with metadata. Represents the discrete or continuous evolution, \n\n\n\n \n\n \n\n \n\n \n\n6 \n\nwhere evolution refers to the changes in position or shape and extent, of \n\nsome entity or object over time. Some examples of spatiotemporal data \n\ninclude: a hurricane trajectory over time, a ship trajectory during a storm, the \n\npersons' movements during the day, the evolution of cells and biological \n\ntissues over time. \n\nMoving Point A moving entity (or moving object) for which only the position in space is \n\nrelevant, e.g., the position of animals, people, aircrafts or ships. \n\nMoving Region A moving entity (or moving object) for which the position in space and the \n\nshape and extent, e.g., growing and shrinking, are relevant, e.g., hurricanes, \n\nicebergs and forest fires. \n\nMoving Object (MO) Used in the literature with different meanings. It can be used to refer to a \n\nmoving point, a moving region or both. It is also used to represent entities or \n\nphenomena changing in discrete steps or continuously over time. In this \n\ndissertation, a MO is an entity (or object), whose position or shape and \n\nextent change continuously over time. When we want to refer specifically to \n\nmoving points or to moving regions we do so explicitly. The same is true \n\nwhen we want to refer to MOs that change in discrete steps or continuously \n\nover time. \n\nSpatiotemporal Database A database system or a database extension that provides services to \n\nrepresent, manipulate, analyse and store spatiotemporal data in an efficient \n\nand convenient way, e.g., efficient data storage and representation, query \n\noptimization and indexing services. \n\nTable 2.1 - Main concepts used in this dissertation. \n\n2.2 Spatiotemporal Databases \n\nIoT and the widespread use of GPS-enabled devices, such as smartphones and navigation systems, are an \n\nopportunity for the development of new services and applications, e.g., location-based services (LBSs), \n\nadvanced trip planning and recommendation systems, fleet management and logistics and to study real world \n\nphenomena, e.g., people and animal movements and traffic evolution.  \n\nThere is also an increasing range of applications that deal with specific real world phenomena, whose \n\nposition, shape and extent change discretely or continuously over time, e.g., pollution areas, hurricanes and \n\nland usage. These applications due to their impact are important for several areas of human knowledge. \n\nThese applications and services need an efficient and convenient storage, representation, analysis and \n\nmanipulation (providing suitable operations), given their potential to produce large amounts of \n\nspatiotemporal data that can have complex data structures and to ease the extraction of knowledge from \n\nspatiotemporal data and all the information it carries.  \n\n\n\n \n\n \n\n \n\n \n\n7 \n\nDBMSs were built to manage data in an efficient and convenient way, however, existing DBMSs cannot \n\ndeal with spatiotemporal data off-the-shelf and its management is a complex task. \n\nPeople studying the management and representation of spatiotemporal data in DBMSs realized that \n\ntemporal and spatial databases were connected and that it made sense to create a database system that \n\nintegrated the temporal and spatial components together. So, a possible solution for the management of \n\nspatiotemporal data is to develop a spatiotemporal database management system (STDBMS) and such a \n\nsystem can provide support for the services and applications that we mentioned earlier. \n\nThere has been a lot of research on spatiotemporal databases. However, to the best of our knowledge, \n\nspatiotemporal database systems exist only at the prototype level in Secondo (R. H. G\u00fcting, Behr, &amp; \n\nD\u00fcntgen, 2010) and Hermes (Nikos Pelekis, Theodoridis, Vosinakis, &amp; Panayiotopoulos, 2006). The design \n\nand implementation of a complete STDBMS is a complex task that requires among other things: efficient \n\nalgorithms for query operations on MOs, indexing techniques, query optimization, an efficient representation \n\nand storage and a realistic representation of the evolution of moving regions over time. \n\n2.2.1 Applications \n\nSpatiotemporal databases have applications in several fields: \n\n? Social networks (K.-S. Kim, Ogawa, Nakamura, &amp; Kojima, 2014). \n\n? Advanced driver assistance systems (ADAS) and intelligent transportation systems (Popa &amp; \n\nZeitouni, 2012). \n\n? Environmental information systems (Wahid et al., 2006). \n\n? Location-based services (LBS) (Nikos Pelekis et al., 2008; Nikos Pelekis &amp; Theodoridis, 2006). \n\n? Vehicle traffic analysis (Nikos Pelekis et al., 2010). \n\n? Air traffic control (Hurter et al., 2013). \n\n? Maritime surveillance and security (Etienne, Devogele, &amp; Bouju, 2010). \n\n? Trip planning and recommendations systems (Booth, Sistla, Wolfson, &amp; Cruz, 2009; Zheng, Zhang, \n\nMa, Xie, &amp; Ma, 2011). \n\n2.2.2 Architecture \n\nIn (Breunig et al., 2003) the authors present the main system architectures to build a STDBMS: the \n\nlayered architecture, the monolithic architecture and the extensible architecture. According to the authors \n\nthese architectures can be described as follows. \n\nThe layered architecture implements a layer on top of an off-the-shelf DBMS, to provide spatiotemporal \n\nfunctionality. There is a clear separation of responsibilities between the two layers, i.e., the DBMS layer and \n\nthe layer providing the spatiotemporal functionality. Transaction management, query processing and \n\noptimization and indexing services for the standard data types, handled by the DBMS, are provided by the \n\nDBMS level. The new layer has to provide these services for the non-standard data types. Global query \n\n\n\n \n\n \n\n \n\n \n\n8 \n\nprocessing and optimization of combined queries is hard to implement and combined index processing \n\ncannot be used. \n\nThe main advantage of this architecture is to enable a fast development of new services (Matos, Moreira, \n\n&amp; Carvalho, 2012). \n\nIn the monolithic architecture, standard and non-standard data types and operations are integrated into the \n\nDBMS kernel. Because of this tight integration most of the problems found in the layered architecture are \n\novercome. However, implementing such an integrated system, for spatiotemporal data management, has \n\nproved to be a hard task. Monolithic systems can be optimized for specific application domains. \n\nThe extensible architecture gathers the best features of the previous ones, to provide a DBMS that allows \n\nuser-defined extensions (data types and operations) to be plugged into the database system. The new data \n\ntypes and operations are integrated into the DBMS, but outside its kernel. Indexing services, query \n\noptimization and transaction management can be provided at the DBMS level for the new data types and they \n\ncan be manipulated using the structured query language (SQL). Developing new extensions is easier then \n\ndeveloping new services inside the DBMS kernel.  \n\nThe use of this architecture, in general, implies the use of a DBMS that provides extensibility capabilities \n\nand several DBMSs already support some kind of extensibility technology, e.g., Informix datablades, Oracle \n\ncartridges, IBM DB2 extenders. Secondo (R. H. G\u00fcting et al., 2010) is also an example of a system using the \n\nextensible architecture. \n\n2.2.3 Data Models and Operations \n\nSeveral spatiotemporal data models have been proposed in the literature (Nikos Pelekis, Theodoulidis, \n\nKopanakis, &amp; Theodoridis, 2004). Some use existing spatial and temporal data models to develop a \n\nspatiotemporal data model. Others propose their own modelling approach. Not all have been formally defined \n\nor properly evaluated. Some have not been implemented, are incomplete or in an experimental stage. And, in \n\ngeneral, they deal with the needs of specific applications and services. \n\nOur discussion focuses on moving objects data models, since we are interested in the representation of \n\nMOs. Moving objects data models can capture the continuous evolution of moving entities over time, i.e., the \n\nchanges in their position, shape and extent. \n\nMoving Objects Data Models \n\nMOs have been studied from different perspectives (R. G\u00fcting &amp; Schneider, 2005): \n\n? The location management perspective: i.e., manage the position of MOs, ask questions about the \n\ncurrent and expected near future positions and the relationships that might develop between objects. \n\nNo history of movement is kept. \n\n? The spatiotemporal database perspective: i.e., describe the current state of MOs and the whole \n\nhistory of their evolution (the position in the near future might also be considered), understand how \n\n\n\n \n\n \n\n \n\n \n\n9 \n\nthings changed, analyze when certain relationships occurred and retrieve the state at a particular \n\ninstant in the past. Changes in shape and extent are also considered. Our discussion will be centered \n\nin the analysis of data models using this perspective. \n\nIn the following we will briefly discuss data models using the location management perspective, in \n\nparticular the MOST data model (Prasad Sistla, Wolfson, Chamberlain, &amp; Dao, 1997), and then we will \n\ndiscuss data models using the spatiotemporal database perspective in more depth. \n\nThe Location Management Perspective \n\nIn (Prasad Sistla et al., 1997) the authors proposed the moving objects spatiotemporal (MOST) data \n\nmodel.  \n\nAccording to the authors in (R. H. G\u00fcting, De Almeida, &amp; Ding, 2006), MOST allows to model and \n\nquery the current and near future movement of MOs, in a database. Positions are not stored directly, avoiding \n\na high volume of updates. Instead, the database holds a motion vector and updates are executed, only, when \n\nthe position predicted by the motion vector deviates from the real position by more than a given threshold. \n\nThe model introduces the concept of dynamic attributes, i.e., attributes that change implicitly over time, \n\nleading to a notion of continuous queries.  \n\nIn (Prasad Sistla et al., 1997) the authors also proposed the future temporal logic (FTL) query language \n\nthat makes it possible to specify temporal relationships between objects and to formulate queries about near \n\nfuture movements. The MOST data model deals, only, with moving points. \n\nThe Spatiotemporal Database Perspective \n\nAccording to the authors in (Matos et al., 2012):  \n\n? The most well-known paradigms used to develop spatiotemporal data models and query languages \n\nare based on constraint databases (Grumbach, Rigaux, &amp; Segoufin, 2001) and abstract data types \n\n(ADTs) (Cotelo Lema, Forlizzi, Guting, Nardelli, &amp; Schneider, 2003; Forlizzi, Giiting, Nardelli, &amp; \n\nSchneider, 2000; R. H. G\u00fcting et al., 2000). \n\n? The constraint databases data model approach main disadvantage is that it can hardly be integrated \n\ninto ORDBMSs. This model has, however, very interesting properties, e.g., allows the \n\nrepresentation of spatiotemporal data of arbitrary dimension and offers uniformity in its \n\nrepresentation, i.e., objects are represented using linear constraints.  \n\n? The ADTs based data models can be smoothly integrated into ORDBMSs (Matos et al., 2012) and \n\nthe most well-known approach for the representation of spatiotemporal data in databases, proposed \n\nin (R. H. G\u00fcting et al., 2000), uses ADTs. \n\nIn (R. H. G\u00fcting et al., 2000) the authors propose an abstract data model, a system of data types and \n\nappropriate operations forming an algebra that can be embedded in a query language, that sets a solid \n\nfoundation for implementing a spatiotemporal DBMS extension. According to the authors in (Matos et al., \n\n\n\n \n\n \n\n \n\n \n\n10 \n\n2012), an interesting property of this model is that complex data types are constructed from simpler ones, \n\nwhich is particularly appropriate for implementation on extensible database architectures.  \n\nThe abstract data model type system defines the base types (BASE = {int, real, string, bool}), the spatial \n\ntypes (SPATIAL = {point, points, line, region}), the time type (TIME = {instant}), temporal types that are \n\nderived from BASE ? SPATIAL using a moving and an intime type constructors and range types whose \n\nvalues are finite sets of pairwise disjoint intervals over the domain BASE ? TIME. The most important types \n\nare moving point and moving region.  \n\nIt also proposes a set of operations, on temporal and non-temporal types, to support querying and a \n\ngeneralized definition of continuity valid for all the proposed temporal data types, where discontinuity \n\nrepresents the case of values changing in discrete steps. \n\nIn (Forlizzi et al., 2000) the authors propose a discrete data model and data structures, that can be mapped \n\ninto concrete physical data structures in a DBMS environment, that implements the abstract data model \n\nproposed in (R. H. G\u00fcting et al., 2000). This paper introduces the concept of the sliced representation (see \n\nFigure 2.1 and Figure 2.2), to represent the temporal types, i.e., the temporal evolution of a value is \n\ndecomposed into fragments (units) called slices. A slice records the evolution of a value v of some type ? in a \n\ngiven time interval I, using a simple function defined in I, and maintains type-specific constraints during that \n\nevolution. A unit type holds a single slice and a moving type is a set of unit types, whose time intervals are \n\nmutually disjoint. This allows the representation of the evolution of continuous phenomena over time using \n\ndata taken at specific instants in time, i.e., using discrete data. \n\n \n\nFigure 2.1 - Sliced representation of: a moving real (left) and 2 moving points (right). Source: \n\n(Forlizzi et al., 2000). \n\n \n\nFigure 2.2 - A Moving point with various types of movement. Source: (Nikos Pelekis &amp; \n\nTheodoridis, 2007). \n\nIn (T\u00f8ssebro &amp; Nyg\u00e5rd, 2011) the authors propose an extension to the sliced representation, proposed in \n\n(Forlizzi et al., 2000), capable of representing explicit topology. The authors present an analysis to determine \n\n\n\n \n\n \n\n \n\n \n\n11 \n\nwhich topological relationships need to be stored explicitly and which can be computed from the geometry. \n\nThey also take into consideration that storing certain topological relationships, to make sure that the \n\ninterpolation of neighboring geographical objects matches over time, might be of interest. The paper \n\ndescribes how to represent topology for continuously moving or changing objects, how to deal with objects \n\nthat are connected topologically but not necessarily updated at the same time and how to represent changes in \n\ntopology over time. \n\nOperations \n\nIn (R. H. G\u00fcting et al., 2000) the authors present a carefully designed set of operations on non-temporal \n\nand temporal types defined at an abstract level. According to the authors the design of these operations aims \n\nto achieve three main goals: design operations that are as generic as possible, achieve consistency between \n\noperations on non-temporal and temporal types and capture the interesting phenomena. The non-temporal \n\noperations are transformed, using a process of lifting, into temporal operations. The classes of operations on \n\ntemporal types include: projection to domain and range, interaction with points and point sets in domain and \n\nrange, the when operation and rate of change operations. The authors also present operations on sets of \n\nobjects and provide a complete, precise definition of the signature of all the proposed operations. According \n\nto the authors, the idea of lifting is based on the definition of an algebra over non-temporal types that is \n\ntransformed into operations over temporal types and the use of this concept makes it possible to obtain \n\nconsistency between temporal and non-temporal operations. \n\nIn (Cotelo Lema et al., 2003) the authors present a comprehensive and systematic study of algorithms for \n\nimplementing a subset of the operations proposed in (R. H. G\u00fcting et al., 2000), using the data structures \n\npresented in (Forlizzi et al., 2000). Some of these algorithms are complex, e.g., set operations on moving \n\nregions and computations of distance functions involving moving regions. \n\n2.2.4 Spatiotemporal Query Languages \n\nQuery languages for spatiotemporal databases should provide an efficient, simple and natural way to ask \n\nany kind of questions about the movement and evolution of spatiotemporal objects over time. Of special \n\ninterest are query languages able to express such queries about MOs. These query languages should allow \n\nquerying the past and the present, and possibly the near future, evolution of MOs. According to the authors in \n\n(Pozzani &amp; Combi, 2012), a complete query language for spatiotemporal databases does not yet exist and \n\nalthough several spatiotemporal query languages have been proposed, there have not been efforts for \n\nstandardizing a spatiotemporal model and query language. \n\nIn (M. Erwig &amp; Schneider, 1999; Martin Erwig &amp; Schneider, 2002) the authors propose a spatiotemporal \n\nquery language called STQL, as an extension of the SQL query language, that allows to formulate \n\nspatiotemporal queries about the development of topological relationships over time, using spatiotemporal \n\npredicates. Complex predicates can be built from a set of elementary ones. STQL provides a framework \n\nbased on the notion of spatiotemporal predicates. \n\n\n\n \n\n \n\n \n\n \n\n12 \n\nIn (Xinmin Chen &amp; Zaniolo, 2000) the authors present the SQL\nST\n\n query language. SQL\nST\n\n main objective \n\nis to minimize the extensions required in SQL, or other relational languages, to support spatiotemporal \n\nqueries. According to the author in (Noh, 2004), SQL\nST\n\n cannot deal with the specific features of \n\nspatiotemporal data in a natural and convenient way, because of the restrictions of the standard SQL query \n\nlanguage to deal with spatiotemporal queries. \n\nThe STQL query language, proposed and presented in (D. H. Kim, Ryu, &amp; Kim, 2000; D. Kim, Ryu, &amp; \n\nPark, 2002), is based on the SQL3, TSQL2 and the Spatial SQL specifications. It consists on a data definition \n\nlanguage (DDL) and a data manipulation language (DML). In (D. Kim et al., 2002) the authors propose a \n\nspatiotemporal query processing (STQP) system to process queries written with STQL. The STQP system \n\nuses a composite architecture and it is composed by a spatiotemporal syntax analyser, a spatiotemporal \n\nsemantic analyser, a spatiotemporal code generator and a spatiotemporal interpreter. \n\nIn (R. H. Guting et al., 2003) the authors present the design of the core of a spatiotemporal extension to \n\nSQL 92, called STSQL, that provides built-in data management support for spatiotemporal data and makes it \n\npossible for legacy database applications, using a conventional SQL 92-based DBMS, to be migrated to a \n\nSTDBMS without affecting the legacy applications. \n\nIn (Viqueira &amp; Lorentzos, 2007) the authors propose a SQL extension for the management of \n\nspatiotemporal data. The extension considers discrete changes in space and time. The syntax and semantics \n\nare fully consistent with the SQL 2003 standard and it is based on data types, defined in terms of time and \n\nspatial quanta and SQL constructs. \n\nIn (Pozzani &amp; Combi, 2012) the authors present the spatiotemporal query language ST4SQL, to deal with \n\ntemporal and spatial dimensions qualified with granularities. ST4SQL is a SQL-based query language that \n\nextends the SQL syntax and the T4SQL temporal query language. ST4SQL queries and constructs can be \n\ntranslated into equivalent standard SQL queries and constructs. ST4SQL introduces four temporal and spatial \n\nsemantics that add a specific meaning to queries and allow the user to specify how the system has to manage \n\ntemporal and spatial dimensions for evaluating queries. \n\n2.3 Spatiotemporal ORDBMSs \n\nCurrent ORDBMSs, e.g., Oracle, IBM DB2, Informix, PostgreSQL, SQL Server, MySQL, are built using \n\nextensible architectures that provide some kind of extensibility mechanism for user-defined data types and \n\noperations, index structures and query optimization. These extendible architectures can be used to integrate \n\nnew data models, into a DBMS, and its data types can be manipulated using SQL, e.g., spatial extensions. \n\nThese ORDBMSs are being used to develop spatiotemporal extensions and hence the name spatiotemporal \n\nORDMSs. \n\nSeveral spatiotemporal extensions, built on top of ORDBMSs, have been proposed in the literature, \n\ncovering different fields of application. In general, these extensions focus on specific applications and its \n\nimplementation is not trivial. According to the authors in (Matos et al., 2012), these facts seem to indicate \n\n\n\n \n\n \n\n \n\n \n\n13 \n\nthat the management of spatiotemporal data, in standard DBMSs, is a relevant issue and the existence of \n\ngeneral purpose spatiotemporal extensions would be useful in many domains of knowledge. \n\nIn this section we present, to the best of our knowledge, the most relevant ORDBMSs spatiotemporal \n\nextensions, using the ADTs approach, proposed in the literature. \n\nSecondo (de Almeida et al., 2004; R. H. G\u00fcting et al., 2010) is an open-source, fully extensible, database \n\nsystem, built from scratch, that provides a generic environment for building database systems prototypes. It \n\nis, also, a research prototype, supporting spatial and spatiotemporal data management. Offers a collection of \n\ndata structures and operations for representing and querying MOs and MOs can be visualized and animated. \n\nSecondo does not conform to the open geospatial consortium (OGC) standards and it does not follow a \n\npredefined data model. It can be extended with new data models and its core data model can be modified. \n\nAccording to the authors in (R. H. G\u00fcting et al., 2005), Secondo is, or was, used to study moving objects \n\ndatabases (MODs), network models, fuzzy spatial data types and optimization techniques. \n\nSeveral data models have been implemented partially or completely as part of or using Secondo (Behr, \n\nTeixeira de Almeida, &amp; G\u00fcting, 2006; Forlizzi et al., 2000; R. H. G\u00fcting et al., 2000; Hartmut, Zhiming, &amp; \n\nAlmeida, 2006; Xu &amp; G\u00fcting, 2012). Secondo is also the base for other projects: Parallel Secondo (R. Guting \n\n&amp; Lu, 2013), i.e., Secondo enhanced with parallel processing technologies for large scale processing and \n\nanalysis of MOs data in a cluster of computers, and Distributed Secondo (Nidzwetzki &amp; G\u00fcting, 2016), an \n\nextensible highly available and scalable database management system. \n\nHermes (Nikos Pelekis, Frentzos, Giatrakos, &amp; Theodoridis, 2015; Nikos Pelekis &amp; Theodoridis, 2007) is \n\na framework designed as a system extension that provides spatiotemporal functionality to OpenGIS-\n\ncompatible state-of-the-art ORDBMSs. It is, also, a research prototype for efficient location-based data \n\nmanagement. Hermes defines a set of moving type objects and operations (Nikos Pelekis et al., 2006), using \n\nthe temporal types defined in the TAU temporal literal library (TAU-TLL) (N Pelekis, 2002) and the spatial \n\ndata types defined in the underlying ORDBMS OGC-compliant spatial extension. Hermes proposes a data \n\ntype model and a complete set of state-of-the-art query processing algorithms for trajectory databases (TDs). \n\nTakes advantage of the extensibility mechanisms provided by ORDBMSs that offer an OGC-compliant \n\nspatial extension and it was implemented as an extension on two ORDBMSs: Oracle, using Oracle Spatial, \n\nand PostgreSQL. Supports real time dynamic applications, e.g., location-based services (LBS), and it has \n\nbeen successfully used in four different domains (Nikos Pelekis et al., 2015): trajectory data warehouses \n\n(TDWs), moving objects data mining query languages, semantic enrichment of movement patterns and \n\nprivacy-aware trajectory tracking query engines. \n\nIn (Matos et al., 2012) the authors propose a spatiotemporal data model that was implemented and tested \n\non Oracle 11g DBMS using Oracle 11g Spatial. This data model introduces modifications to the internal \n\nstructure of the representation of moving regions, proposed in (Forlizzi et al., 2000; R. H. G\u00fcting et al., \n\n2000), reducing the storage requirements and the size of the temporary data structures used in the evaluation \n\nof spatiotemporal operations. The authors also present algorithms to implement a subset of spatiotemporal \n\noperations, namely, projections and predicates, relying on the spatial features of the underlying DBMS. A \n\n\n\n \n\n \n\n \n\n \n\n14 \n\nmoving region is defined as an ordered collection of units, composed by a time interval and a set of moving \n\npoints identifiers defining its geometry. Moving points may be shared by several moving regions, making it \n\npossible to update a moving point while the corresponding moving region(s) remain(s) unchanged. The costs \n\nof updates and the size of the data structures are reduced and the performance of the operations dealing with \n\nmoving regions is improved. \n\nThe spatiotemporal object cartridge (STOC) data model, presented in (Zhao, Jin, Zhang, Wang, &amp; Lin, \n\n2011), is an extension developed on Oracle, based on Oracle Spatial, that provides support for spatiotemporal \n\ndata management. The data model provides temporal and spatiotemporal data types and operations and \n\nsupports both, continuous and discrete changes of spatial data over time and the following query types: \n\ntemporal range, spatial range, spatiotemporal range, spatiotemporal distance, spatiotemporal topology and \n\nspatiotemporal aggregate queries. \n\nThe Oracle-based spatiotemporal module (OSTM) (P Jin &amp; Sun, 2008) is an extension implemented as a \n\ndata cartridge on top of Oracle providing spatiotemporal data management. It is based on the STORM \n\n(Peiquan Jin, Yue, &amp; Gong, 2005) data model (also proposed by the authors). That is, OSTM can be thought \n\nof as an implementation of the STORM data model on Oracle. In the STORM data model the manipulation \n\nof spatiotemporal data is accomplished by extending the relational algebra with spatial, temporal and \n\nspatiotemporal operations. Complex regions, point sets, and polylines are not defined. STORM defines five \n\nbasic extended relational algebraic operations (spatiotemporal union, spatiotemporal difference, \n\nspatiotemporal product, spatiotemporal selection and spatiotemporal projection) that form a complete set of \n\nrelational algebra (therefore, other operations can be implemented using these five basic operations). \n\nSTORM supports five types of spatiotemporal changes, described as: continuous and discrete spatial \n\nprocesses, continuous and discrete thematic processes and discrete life. \n\nThe component based moving region (CMR) data model (McKenney, Viswanadham, &amp; Littman, 2014) \n\nis a data model to represent moving regions. According to the authors, the data model aligns well with data \n\ncollection techniques, can be implemented easily and allows complex movement patterns to be easily \n\ndescribed. The semantic interpretation of a region is separated from its physical representation, e.g., users are \n\nable to create a region containing what is usually considered to be an invalid structure. The model is designed \n\nto take advantage of simple algorithms for implementing operations on MOs, focusing on using well-known \n\n2D algorithms instead of more complex 3D algorithms. A moving region is defined as a set of interval \n\nregions and an interval region describes the motion of a region over a specified time interval. A structural \n\nregion contains components that, without interpretation, define an invalid region, i.e., they must be \n\ninterpreted using an extraction function to extract the valid region. A structural region is defined as four sets: \n\na set of faces, a set of holes, a set of lines, and a set of points, as a separate structural representation and \n\ninterpretation and lays the foundation for the data model. The model assumes a single movement function for \n\nall moving regions in a particular application. The authors plan to extend the model to include moving points \n\nand lines. \n\n\n\n \n\n \n\n \n\n \n\n15 \n\nThe balloon data model (Praing &amp; Schneider, 2007) uses the metaphor of a balloon to model the \n\nevolution of MOs over time: the string and the body of the balloon object represent the past and the future \n\nevolutions, respectively. The connection point between the string and the body of the balloon represents the \n\npresent state. The authors discuss problems such as, appearing, disappearing, splitting and merging of object \n\ncomponents and they provide a precise specification of the properties of the evolution of MOs, making clear \n\nhow MOs can evolve in space and time, i.e., they define valid and invalid evolutions. Examples of invalid \n\nevolutions are instantaneous shrinking and instantaneous appearance. The model can represent the set of \n\npotential (predicted) future positions of a MO (that can be a simple or a complex spatial object). For that the \n\nauthors introduce the concept of confidence distribution. The confidence distribution concept allows \n\nassociating each potential future position of a MO with a degree of confidence. The model supports past and \n\nfuture queries and queries that start in the past and extend into the future. It\u2019s a general purpose model that \n\ndoes not provide a prediction model for the future evolution of MOs. Although an implementation is not \n\nprovided, the authors plan to implement the balloon model as part of their spatiotemporal algebra (STAL) \n\nsoftware package. \n\n2.4 Representation of Moving Regions \n\nThe sliced representation, (Forlizzi et al., 2000), is used to represent the continuous evolution of MOs. \n\nHowever, the representation of the evolution of moving regions, in particular, is complex. An example \n\nfollows.\\ \n\nGiven a moving region evolving continuously over time, e.g., an iceberg, when using the sliced \n\nrepresentation we proceed as follows. We take observations from its evolution at specific instants in time. In \n\nFigure 2.3 we can see, on top, the observations that were taken, below, the instant in time were each \n\nobservation was taken at and the slices represented in green. \n\n \n\nFigure 2.3 - Observations of an iceberg evolving continuously over time. \n\nThen, we need a function ? to give us the evolution of the region during each slice. ? should have certain \n\nproperties of interest, in particular: \n\n? It should preserve the physical characteristics of the object. We are interested in a realistic and as \n\naccurate as possible representation of the region\u2019s evolution. Figure 2.4 shows examples of possible \n\ninterpolation results, purple dots, that represent the region\u2019s evolution during a slice. The physical \n\ncharacteristics of the object are not preserved generating undesirable results and an unrealistic \n\nrepresentation of the regions\u2019 evolution over time. \n\n\n\n \n\n \n\n \n\n \n\n16 \n\n? It should generate no invalid geometries, i.e., geometries with no self-intersections. \n\n \n\nFigure 2.4 - Examples of possible interpolation results that represent the region\u2019s evolution \n\nduring a slice.  \n\nThe use of a simple function will not produce the desired results for most cases, i.e., a simple function is \n\nnot adequate to obtain a realistic representation of the evolution of moving regions. The solution is to use \n\nmore advanced techniques, e.g., morphing and shape interpolation methods. Figure 2.5 shows the \n\ninterpolation between two known states (observations) of a region at time instants t1 and t2 using two \n\ndifferent morphing techniques (Baxter, Barla, &amp; Anjyo, 2008). The technique shown on top might yield \n\nundesirable results, depending on the phenomena being studied. \n\nFinding a suitable ? for all possible cases is a complex task with some well-known problems, e.g., the \n\ngrowing and shrinking effect shown in Figure 2.4 and invalid geometries. These problems have been studied \n\nand there are proposals in the literature for function ? but they don\u2019t work for all cases. \n\nWe are not going to discuss these advanced techniques and the problems that arise when trying to find ? \n\nin this dissertation, but we leave some interesting references here for the interested reader:  \n\n? Works on finding ?: (Heinz &amp; G\u00fcting, 2016; Mckenney &amp; Webb, 2010; Mckennney &amp; Frye, 2015; \n\nT\u00f8ssebro &amp; G\u00fcting, 2001)  \n\n? Morphing techniques using polygons compatible triangulations and rigidity-preserving interpolation \n\nmethods: (Alexa, Cohen-Or, &amp; Levin, 2000; Baxter et al., 2008; Gong, 2011; Craig Gotsman &amp; \n\nSurazhsky, 2001; Haesevoets &amp; Kuijpers, 2004). \n\n? Dissertations on the study and implementation of methods to get spatiotemporal data from images of \n\nreal world phenomena and defining ? using compatible triangulation methods and rigidity-\n\npreserving interpolation methods: (Paulo, 2012), (Mesquita, 2013) and (Amaral, 2015). \n\n\n\n \n\n \n\n \n\n \n\n17 \n\n \n\nFigure 2.5 - Two different morphing techniques. Source: image adapted form (Baxter et al., \n\n2008). \n\n2.5 Summary \n\nSpatiotemporal data is becoming more important for an increasing number of services and applications. \n\nWith the rise of IoT and the widespread use of GPS-enabled devices its importance and value is expected to \n\nincrease. We need tools to extract knowledge from these data and take full advantage of the information that \n\nthey carry. For this to be possible, we need a system that can manage spatiotemporal data in an efficient and \n\nconvenient way. \n\nSpatiotemporal data can be highly complex and its management is not trivial. Several spatiotemporal data \n\nmodels and query languages have been proposed in the literature and there is already a considerable amount \n\nof work done and published on this subject. However: \n\n? A complete system to manage spatiotemporal data does not yet exist. Only a few prototypes exist: \n\nSecondo and Hermes. \n\n? There is no standard for a spatiotemporal data model and query language. Although no standard for \n\nthe representation of moving objects exist, the open geospatial consortium (OGC) moving features \n\nstandard (OGC Moving Features, 2016) specifies standard encoding representations of the movement \n\nof geographic features for information exchange. This standard applies to features that move as rigid \n\nbodies. It does not apply to all types of moving features, e.g., deforming features, therefore is not \n\nsuitable for moving regions that change their shape over time. \n\n? A lot of work on moving points has already been made. However, few data models exist to manage \n\nmoving regions evolving continuously over time. This seems to be related to two main reasons \n\n(McKenney et al., 2014), generating moving region data from sensors is challenging and the \n\nalgorithms proposed to implement operations on moving regions are complex. \n\n? Several other challenges remain, such as, the development of indexing and query optimization \n\ntechniques, the implementation of spatiotemporal operations on MOs and the representation of the \n\nevolution of moving regions. This topic is still an open field for research. \n\nWe are particularly interested in the representation of entities and phenomena moving in free space that \n\nchange their position, shape and extent continuously over time. Therefore, the following subjects are omitted \n\nin our discussion, although they might be part of active or intense study and research: \n\n? Network-constrained MOs (Ding, Yang, G\u00fcting, &amp; Li, 2015; Hartmut et al., 2006). \n\n\n\n \n\n \n\n \n\n \n\n18 \n\n? Trajectory databases (TDs) (R. H. G\u00fcting, Behr, &amp; Christian, 2012). \n\n? Semantic trajectories (Damiani &amp; Guting, 2014). \n\n? Symbolic trajectories (Damiani, Valdes, &amp; Guting, 2015),  \n\n? MOs with different transportation modes, e.g., generic moving objects databases (GMODs) (Xu, \n\n2012). \n\n? MOs with sensors, periodic MOs, the different types of moving objects databases (MODs), e.g., \n\nEMOD, NMOD, NMTMOD, GMOD, uncertainty and the management of near future positions, \n\nquery processing and optimization, storage and indexing structures. \n\nDBMSs are a natural environment to manage data and there is a lot of work on the management of \n\nspatiotemporal data in the literature based on DBMSs. In this chapter we presented an overview of the main \n\nworks that use this approach. We discussed: \n\n? Spatiotemporal databases and its applications, architecture, data models and operations. \n\n? Spatiotemporal query languages. \n\n? Spatiotemporal ORDBMSs. \n\n? The problems of representing the evolution of moving regions. \n\n  \n\n\n\n \n\n \n\n \n\n \n\n19 \n\nCHAPTER 3 \n\n3.  A Discrete Data Model for Moving Objects \n\nWe start this chapter by giving some initial background that, we think, can help the reader to better \n\nunderstand the context and the objectives of the discrete data model that we present and propose next. \n\nTo the best of our knowledge there is not in the literature a data model for moving objects that uses the \n\nconcept of mesh, obtained by using compatible triangulation methods, to represent moving regions and in the \n\nfollowing we give the context necessary to understand the reasons for using this concept to represent them. \n\nAssuming that, we have a set of satellite images representing the evolution of 2 icebergs over time (these \n\nimages could represent other phenomena as well) and we want to obtain the spatiotemporal data about these \n\n2 moving regions from these images. First we need to get 2D geometric representations of the icebergs\u2019 from \n\nthese images. For this step we use the methods implemented in (Paulo, 2012). We obtain a set of geometries \n\n(polygons) that can have a different number of points in their respective boundaries (see Figure 3.1). \n\n \n\nFigure 3.1 - 2 observations of the evolution of an iceberg over time. \n\nWe use the sliced representation to represent the continuous evolution of these moving regions over time \n\ntherefore we need to interpolate the evolution of these geometries between its known states. This means that \n\nwe need a one to one correspondence between the 2 polygons that we want to interpolate. To get this \n\ncorrespondence we use the methods implemented in (Paulo, 2012) and (Mesquita, 2013). These methods take \n\na source polygon, P, and a target polygon, Q, and find the correspondence between their boundary points. P \n\nand Q may have a different number of boundary points so these methods will add cloned or collinear points \n\nto P and Q boundaries as needed, without changing their shape and extent. Cloned points are points that have \n\nthe exact position of an existing point and collinear points are points lying on an existing boundary line \n\nsegment (see Figure 3.2). \n\n\n\n \n\n \n\n \n\n \n\n20 \n\n \n\nFigure 3.2 - A geometry with collinear points. \n\nOur goal is to obtain a realistic representation of the evolution between these geometries. (Amaral, 2015) \n\nshows that the use of compatible triangulation and rigid interpolation methods obtains more realistic \n\nrepresentations of the evolution of these geometries when compared to other methods proposed in the \n\nliterature (T\u00f8ssebro &amp; G\u00fcting, 2001) and (Mckennney &amp; Frye, 2015). \n\nTherefore we use the methods proposed in (Amaral, 2015) to represent the evolution of these geometries. \n\nThe compatible triangulation method used was proposed in (C. Gotsman &amp; Surazhsky, 2004). The \n\nmethod takes 2 polygons, a source and a target polygon, P and Q, with a one to one correspondence and \n\ngenerates 2 meshes, see Figure 3.3. The method will also add Steiner points to the interior of the polygon as \n\nneeded, see Figure 3.4. The authors also propose methods to smooth the meshes, see Figure 3.5. \n\n \n\nFigure 3.3 - 2 meshes. \n\n\n\n \n\n \n\n \n\n \n\n21 \n\n \n\nFigure 3.4 - Steiner points. \n\n \n\nFigure 3.5 - A mesh obtained not using (left) and using (right) the smoothing method. \n\nThe rigid interpolation method uses the method proposed in (Baxter et al., 2008). This method uses linear \n\nalgebra operations, in particular the pseudo inverse of a matrix and the Singular Value Decomposition (SVD) \n\nof a matrix, to calculate the interpolation components used to interpolate the meshes. The estimated \n\ntransformation includes 3 matrices: a transformation matrix, a rotation matrix and a scale matrix. \n\nThese methods allow us to obtain spatiotemporal data from real data and represent its evolution over time \n\nin a realistic way. Now we want to be able to manipulate, analyse and store this data. This is the main focus \n\nof this dissertation. We want to build a framework for moving objects that uses the methods implemented in \n\n(Paulo, 2012), (Mesquita, 2013) and (Amaral, 2015) and in this chapter we propose a discrete data model for \n\nmoving objects, that uses the concept of mesh to represent moving regions, that allows us to achieve that. \n\nThis concept has its roots in (Amaral, 2015). Moreover, our data model is independent from any specific \n\nclient using it and that includes DBMSs. \n\n\n\n \n\n \n\n \n\n \n\n22 \n\n3.1 Overview \n\nThe main objective of the proposed data model is to define an algebra, i.e., a set of data types and \n\noperations, for moving objects using the methods studied in previous works (Amaral, 2015), (Mesquita, \n\n2013) and (Paulo, 2012). Such algebra should have certain properties, in particular, it should be:  \n\n? Closed, i.e., it should have a closed system of operations. \n\n? Simple and avoid the proliferation of operations and data types.  \n\nWe do not define this algebra at an abstract level, i.e., we do not define an abstract data model. Instead we \n\ndefine a discrete data model that has as a reference the abstract model presented in (R. H. G\u00fcting et al., 2000) \n\nand the discrete model presented in (Forlizzi et al., 2000). We focus on moving regions and on a subset of the \n\noperations presented in (R. H. G\u00fcting et al., 2000) that we find representative and interesting.  \n\nOur model defines moving regions using compatible triangulation methods and thus requires a new \n\nspatial type called mesh. This is not the approach of the models that it has as a reference. \n\nThe data types in our discrete model are divided into BASE types, TIME types, SPATIAL types, i.e., \n\nOGC-compliant spatial types, and the new spatial type mesh, INTERVAL, PERIOD, FUNCTION, UNIT and \n\nMOVING types. Table 3.1 shows the signature of these data types. TIME types represent time, INTERVAL \n\ntypes represent intervals of values, e.g., an interval of time in the form [instanti, instantj[, PERIOD types \n\nrepresent sets of intervals, SPATIAL types represent geometries in the 2D Cartesian plane, FUNCTION \n\ntypes represent functions in the mathematical sense, e.g., ax + b, UNIT types represent the evolution of \n\nmoving objects and the changes of bool and real values during an interval of time and MOVING types \n\nrepresent moving objects and values that change continuously (mreal) and in discrete steps (mbool) over \n\ntime. \n\nThe MOVING types are represented using the sliced representation presented in (Forlizzi et al., 2000) \n\nand we do not consider moving lines, geometries with holes and collections. \n\n ? BASE int, real, bool \n\n ? SPATIAL point, linestring, polygon, multipoint, \n\nmultilinestring, multipolygon, \n\ngeometrycollection, mesh \n\n ? TIME instant \n\nBASE \\ {bool} ? TIME ? INTERVAL interval \n\nINTERVAL ? PERIOD period \n\nBASE ? SPATIAL ? UNIT ubool, ureal, upoint, umesh \n\n ? FUNCTION function \n\nUNIT ? MOVING mbool, mreal, mpoint, mmesh \n\n\n\n \n\n \n\n \n\n \n\n23 \n\nTable 3.1 - The signature of our discrete data model for moving objects. \n\nIn Table 3.1 the words in capital letters can be thought of as sets, e.g., MOVING is the set {mbool, mreal, \n\nmpoint, mmesh}, therefore when we say the MOVING types we mean the mbool, mreal, mpoint and mmesh \n\ntypes. The semantics of BASE \\ {bool} ? TIME ? INTERVAL is that we can have intervals of int, real, and \n\ninstant but not an interval of bool (an interval of bool does not make sense). \n\nIn the next sections of this chapter we define, present and discuss our proposed discrete data model for \n\nmoving objects, in particular, for moving regions. We start by defining its data types. Then we define the set \n\nof operations over those data types. \n\n3.2 Notation and Assumptions \n\nThe notation used in this chapter follows the convention shown in Table 3.2. \n\nSymbol Description \n\nt An instant. \n\nI An interval of time, i.e., interval(instant). \n\nP A period. \n\ns A spatial type, i.e., s ? SPATIAL. \n\n?, ? 2 moving types, i.e., ?, ? ? MOVING. \n\n|a| Gives the number of elements of a. \n\nbool Represents the underlying programming language type used to represent the \n\nvalues {true, false} or equivalently {1, 0}. \n\nTable 3.2 - Notation. \n\nOur discrete data model is built on top of the following assumptions: \n\n? Collections and lines are not considered. \n\n? The model only allows the use of polygons without holes. \n\n? Time advances from past to future in a totally ordered form. Granularity, non-linearity of time and \n\nconsiderations about time being isomorphic to the integer, the rational or the real numbers are left \n\nfor future analysis. Hermes (Nikos Pelekis et al., 2010) is a good starting point for such discussion. \n\n? SPATIAL types are represented in the two-dimensional (2D) Cartesian plane and their \n\nrepresentation is based on linear approximations. \n\n\n\n \n\n \n\n \n\n \n\n24 \n\n3.3 Type System Data Types \n\n3.3.1 Base Types and Time Types \n\nThe BASE types: int, real, bool, and the TIME types: instant, are defined in the same way as in (Forlizzi \n\net al., 2000). These types map to the underlying programming language types that represent the integer \n\nnumbers (int), the real numbers (real and instant) and the values in the set {true, false} (bool). \n\n3.3.2 Interval and Period Types \n\nType interval follows the definition for Interval and type period follows the definition for IntervalSet \n\ngiven in (Forlizzi et al., 2000). \n\n3.3.3 Spatial types \n\nThe spatial types are: point, linestring, polygon, multipoint, multilinestring, multipolygon, \n\ngeometrycollection and mesh. With the exception of mesh they all conform to the Open Geospatial \n\nConsortium\u2019s (OGC) OpenGIS Specifications (OGC Simple Features, 2016) and will not be defined here. \n\nA mesh type represents a region with the characteristics supported by the model. It is essentially a \n\ntriangulated polygon. It has a boundary, Steiner points, and a set of non-overlapping triangles, see Figure 3.6. \n\n \n\nFigure 3.6 - A mesh of an iceberg, obtained using our framework for moving objects. \n\nTo define the mesh type we start by redefining the set of all line segments, Seg, defined in (Forlizzi et al., \n\n2000) to allow a line segment to degenerate to a point. We need to do this because the boundary of a mesh \n\ncan have duplicate points, i.e., points with exactly the same x and y coordinates. \n\n Let Seg+ be the set of all line segments. Then: \n\nSeg+ = {(u, v) | u, v ? point, u ? v} \n\nAs a consequence, we need to redefine a cycle, also defined in (Forlizzi et al., 2000). A cycle is a simple \n\npolygon that is defined using Seg. Our definition of a cycle uses Seg+ as follows: \n\nCycle+ = {S ? Seg+ | |S| ? 3; such that \n\n(i) ?si, sj ? S : (si ? sj ? (si = sj ? p-degenerated(si))) ? (\u00acp-intersect(si, sj) ? \u00actouch(si, sj)) \n\n\n\n \n\n \n\n \n\n \n\n25 \n\n(ii) ?p ? points(S) : card(p, S) = ?} \n\nWhere: p-intersect(si, sj) , touch(si, sj), points(S) and card(p, S) have the meaning given in (Forlizzi et al., \n\n2000), i.e., 2 segments p-intersect if they intersect in their interior (in a point other than an end point), 2 \n\nsegments touch if one end point of one of the segments is in the interior of the other one, points(S) is the set \n\nof all the end points of the segments in S, card(p, S) is a function that computes how often point p occurs in \n\nS, p-degenerated(si) means that si is a line segment degenerated to a point and ? is defined as ? = m + 2, m ? \n\n0, m is the number of duplicates of p. \n\n(i) and (ii) have the same meaning as in (Forlizzi et al., 2000). That is, (i) means that no segments \n\nintersect properly and (ii) means that each end point occurs in exactly ? segments. \n\nNotes: \n\n? In (i) if si = sj then p-degenerated(si) and p-degenerated(sj), so we only show one of them. That is, if \n\nsi = sj they are both p-degenerated. \n\n? 2 line segments can be collinear. \n\n? Because we allow degenerated line segments, a line segment can meet more than 2 other line \n\nsegments. \n\n? Collinear and point-degenerated line segments are mesh properties that deserve a more careful \n\nanalysis in the future. Intuitively, they may give rise to geometries with bad or undesirable \n\nproperties. \n\nWe need to define ? before defining mesh. \n\nLet Triangle be the set of all triangles.  \n\nTriangle = {(p1, p2, p3) | p1, p2, p3 ? point} \n\nWe put no restrictions on the elements of a triangle. As a consequence, a triangle is allowed to degenerate \n\nto a line and to a point. \n\nThen ? is defined as follows: \n\n? = {T ? Triangle | |T| ? 1, such that \n\n(i) ?trii, trij ? T : trii ? trij ? \u00acoverlap(trii, trij)} \n\nWhere \u00acoverlap(trii, trij) has the semantics that 2 triangles can share boundary points but their interiors \n\ncannot intersect. \n\nFinally, we can define a mesh. Formally, Mesh, the set of all meshes, is defined as follows: \n\n Mesh = {(b, o, ?) | b ? Cycle+, o = ul(point) ?  |o| ? 0, |?| > 0, such that \n\n(i) covers(b, o)} \n\nWhere covers(b, o) has the semantics that every point in o is a point of the interior or boundary of b, |o| is \n\nthe number of Steiner points of the mesh and ul represents an unordered list. We allow a Steiner point to be \n\nexactly on the mesh's boundary and this is a discussion for future work. \n\nTable 3.3 gives a description of the components of a mesh. \n\n\n\n \n\n \n\n \n\n \n\n26 \n\nComponent Description \n\nb The mesh\u2019s boundary is a cycle. \n\no The mesh\u2019s Steiner points are represented using an unordered list of n points, ul(point). In \n\nthe current definition there is no restriction on the uniqueness of a point. \n\n? The mesh triangles. This is a finite set of non-overlapping triangles. A mesh has at least \n\none triangle. \n\nTable 3.3 - Type mesh components. \n\nType mesh is used to represent mesh objects (see Figure 3.6). \n\nFinally, we need to define the concept of mesh continuity, i.e., the conditions in which 2 meshes are \n\nconsidered to be continuous. This concept is needed to establish continuity for the umesh type presented in \n\nsection 3.3.6. Given mi, mj ? Mesh, then we define mesh continuity as: \n\ndistance(mi, mj) ? ?p (1) ? \nm?? ??\n\nm? ? ??\n ? ?s (2) \n\nWhere distance(mi, mj) is the distance between the centroids of the 2 meshes mi and mj and ?p and ?s are 2 \n\nconstant values. 2 meshes are continuous if they are very close to each other or as close as we want (1) and if \n\ntheir shapes and extents are similar (2). This concept was not strictly established. \n\n3.3.4 Sliced Representation for Moving Objects \n\nWe use the sliced representation and the temporal unit concepts, proposed and defined in (Forlizzi et al., \n\n2000), to represent the MOVING types: mbool, mreal, mpoint and mmesh. That is, a MOVING type is \n\nrepresented as a set of temporal units or slices. Notice that, mbool represents a value that changes in discrete \n\nsteps over time. \n\nBriefly, a temporal unit, or a unit, seen as a generic concept, represents the evolution of a value of a given \n\ntype ? over an interval of time, i.e.: \n\nUnit(?) = I \u00d7 ?, ?? ? BASE ? SPATIAL \n\nThen, a unit u? ? Unit(?) is defined as a pair of a unit interval and a unit function: \n\nu? = (I, v(t)), v(t) ? UnitFunction \n\nWhere I represents the unit interval, v(t) represents the evolution of a value of a given type ? over I and \n\n(Unit(?),&lt;) is a set with a total order, i.e., we can establish a notion of order between units. \n\nUnitFunction represents a function as in the mathematical sense and it is defined as follows: \n\nUnitFunction = {(a, b, c, type) | a, b, c ? real, type ? {CONST, LINEAR, POLN_2}} \n\nWhere: \n\n? a, b, c are the coefficients of a function: f(t) = ?2? + ?? + ?. \n\n? type is the type of function: CONST: f(t) = ?, LINEAR: f(t) = ?? + ?, POLN_2: f(t) = ?2? + ?? + ?. \n\n\n\n \n\n \n\n \n\n \n\n27 \n\nThese concepts are generic enough to allow the type system to be extended with new UNIT types and \n\ntypes of functions. \n\nIn the next subsections we define the UNIT types of our discrete model: ubool, ureal, upoint and umesh. \n\nThey are specializations of this generic concept. \n\n3.3.5 Temporal Units for Base Data Types \n\nType ubool represents the evolution of a bool type during a given interval of time. \n\nThe set for ubool is defined as: \n\nUBool = {(I, v) | v ? bool} \n\nWhere: \n\n? I is the interval of time in which the unit is defined. \n\n? v is a constant value assumed during I. \n\n \n\nType ureal represents the evolution of a real type during a given interval of time. \n\nThe set for ureal is defined as: \n\nUReal = {(I, v(t)) | v(t) ? UnitFunction} \n\nWhere: \n\n? I is the interval of time in which the unit is defined. \n\n? v(t) is a function that represents the evolution of the real type during I. \n\n3.3.6 Temporal Units for Spatial Data Types \n\nType upoint represents the evolution of a point type, i.e., the evolution of its x and y coordinates, in the \n\n2D Cartesian plane during a given interval of time. \n\nThe set for upoint is defined as: \n\nUPoint = {(I, x(t), y(t)) | x(t), y(t) ? UnitFunction} \n\nWhere: \n\n? I is the interval of time in which the unit is defined. \n\n? x(t) is a function that represents the evolution of the point\u2019s x coordinate during I. \n\n? y(t) is a function that represents the evolution of the point\u2019s y coordinate during I. \n\n \n\nType umesh represents the evolution of a mesh type in the 2D Cartesian plane during a given interval of \n\ntime. \n\nThe set for umesh is defined as: \n\nUMesh = {(I, P, Q, IC) | P, Q ? mesh, such that \n\n\n\n \n\n \n\n \n\n \n\n28 \n\n(i) correspondence(P, Q)} \n\nWhere: \n\n? I is the interval of time in which the unit is defined. \n\n? P and Q represent the original source and target meshes at the begin and end instants of I. \n\n? IC represents the interpolation components, computed by the interpolation method, used to \n\ninterpolate the mesh during I. They will be presented and discussed in chapter 4 that deals with \n\nimplementation details. The umesh type is independent of the interpolation method details. \n\n? correspondence(P, Q) means that P and Q must have an implicit one to one correspondence. This is \n\na restriction imposed by the triangulation method. \n\n3.3.7 Moving Types \n\nThe definition and constraints for the MOVING types follow the ones given for the mapping type \n\nconstructor in (Forlizzi et al., 2000) and we add the following: |?| ? 0, |?| is the number of units of the \n\nmoving type ?. If |?| = 0 we say that ? is empty. That is, we allow a moving type to be empty. \n\nWith the exception of mbool\n1\n, when 2 units u? and v?, u? ? v?, of type ? meet at one of the end points of \n\ntheir respective unit intervals, i.e., u?.I.b = v?.I.e ? u?.I.e = v?.I.b, we need to enforce unit continuity. I.b and \n\nI.e are the begin and end instants of interval I, respectively. u?.I represents the unit interval of unit u?, i.e., the \n\ntime interval in which unit u? is defined. \n\nAs a generic concept, we consider that 2 units of type ? are continuous if the distance between their \n\nvalues at instant t where they meet, is bellow some ?. That is, given u?, v? ? Unit(?) and ?(t), a function that \n\ngives the discrete value of some unit of type ? at instant t: \n\n distance(u?.?(t), v?.?(t)) ? ? ? continuous(u?, v?) \n\nIn the present definition we do not establish a notion of continuity for ureal, see section 6.4.2 for more \n\ndetails on this. Type upoint continuity is checked by computing the distance between the points\u2019 positions. \n\nFor type umesh we use the mesh continuity concept defined in section 3.3.3. \n\n3.4 Operations on Moving Types \n\nThis section presents a subset of the operations proposed in (R. H. G\u00fcting et al., 2000). We chose the ones \n\nthat we found more representative and interesting to include in our model, to prove that our framework for \n\nmoving objects can provide operations from all the classes of operations proposed in the literature. We chose \n\nsome operations because they can be used as a basis for implementing other operations and to be able to use \n\nand test all the MOVING types that our data model defines, see Table 3.4. \n\nClass of Operation Operation \n\n                                                           \n\n1\n mbool represents a data type that changes in discrete steps over time. \n\n\n\n \n\n \n\n \n\n \n\n29 \n\nPredicates equals, intersects \n\nSet Operations intersection, union \n\nNumeric area \n\nProjection to Domain and Range deftime, traversed \n\nInteraction with Domain and Range atinstant, atperiod, present \n\nConstructors unit, moving \n\nTable 3.4 - The set of operations on MOVING types in our discrete model. \n\nNote:  \n\n? The use of ? in operation signatures as in: ? \u00d7 ? ? Type and ? \u00d7 Type ? ?, means that the \n\noperations are applicable to MOVING types of the same type. \n\n? The use of ? and ? in operation signatures as in: ? \u00d7 ? ? Type and ? \u00d7 Type ? ?, means that the \n\noperations are applicable to MOVING types of different types. \n\n3.4.1 Predicates \n\nPredicates are operations that return {true, false} values related to topological and other relationships \n\nbetween MOVING types. See Table 3.5. \n\nOperation Signature Semantics \n\nequals ? \u00d7 ? ? bool Checks if 2 MOVING types are equal. \n\nintersects mmesh \u00d7 mmesh ? mbool Checks if 2 mmesh types intersect. \n\n mmesh \u00d7 mpoint ? mbool Checks if a mmesh and a mpoint type intersect. \n\n mmesh \u00d7 mmesh \u00d7 t ? bool Checks if 2 mmesh types intersect at an instant. \n\n mpoint \u00d7 mpoint ? mbool Checks if 2 mpoint types intersect. \n\n mmesh \u00d7 s ? mbool Checks if a mmesh and a SPATIAL type intersect. \n\n mpoint \u00d7 s ? mbool Checks if a mpoint and a SPATIAL type intersect. \n\nTable 3.5 - Predicate operations. \n\n3.4.2 Set Operations \n\nThe set operations that we considered are shown in Table 3.6. \n\nOperation Signature Semantics \n\nintersection mmesh \u00d7 point ? mpoint Computes the intersection of the arguments. \n\n mmesh \u00d7 polygon ? mmesh  \n\n mmesh \u00d7 mmesh ? mmesh  \n\n mmesh \u00d7 mmesh \u00d7 t ? Computes the intersection at an instant. \n\n\n\n \n\n \n\n \n\n \n\n30 \n\ngeometrycollection ? polygon \n\nunion mmesh \u00d7 mmesh ? mmesh Computes the union of the arguments. \n\nTable 3.6 - Set operations. \n\n3.4.3 Numeric \n\nOperations that compute some numeric value, e.g., the area or the perimeter of a mmesh. See Table 3.7. \n\nOperation Signature Semantics \n\narea mmesh \u00d7 t ? real Returns the area of a mmesh type at an instant. \n\n mmesh \u00d7 P ? mreal Returns the area of a mmesh type at a period. \n\nTable 3.7 - Numeric operations. \n\n3.4.4 Projection to Domain and Range \n\nProjection of MOVING types to the time (range) and spatial domains (domain). See Table 3.8. \n\nOperation Signature Semantics \n\ndeftime ? ? P Returns the period in which a MOVING type is defined. \n\ntraversed mmesh ? geometrycollection Computes the projection of a mmesh type in the 2D \n\nCartesian plane. \n\nTable 3.8 - Projection of MOVING types to Domain and Range. \n\n3.4.5 Interaction with Domain and Range \n\nRestriction of MOVING types to the time (range) and spatial domains (domain). See Table 3.9. \n\nOperation Signature Semantics \n\natinstant mmesh \u00d7 t ? polygon Restricts the MOVING type given as an argument to a \n\nspecified instant. \n\n mpoint \u00d7 t ? point  \n\n mreal \u00d7 t ? real  \n\n mbool \u00d7 t ? bool  \n\natperiod ? \u00d7 P ? ? Restricts the MOVING type given as an argument to a \n\nspecified period. \n\npresent ? \u00d7 t ? bool Checks whether the MOVING type exists at a specified \n\ninstant. \n\n ? \u00d7 P ? mbool Checks whether the MOVING type exists at a specified \n\nperiod. \n\nTable 3.9 - Restriction of MOVING types to the time and spatial domains. \n\n\n\n \n\n \n\n \n\n \n\n31 \n\n3.4.6 Constructors \n\nOperations to construct UNIT and MOVING types. See Table 3.10. \n\nConstructor Signature Semantics \n\nUnitBool I \u00d7 bool ? ubool Constructs an ubool type. \n\nUnitReal I \u00d7 vb \u00d7 ve \u00d7 type ? ureal Constructs a ureal type. \n\n? vb, ve ? real, begin and end \n\nvalues of the unit\u2019s value. \n\n? type ? int, type of function to \n\ninterpolate the unit\u2019s value \n\nduring I. \n\nUnitPoint I \u00d7 xb \u00d7 yb \u00d7 xe \u00d7 ye \u00d7 typeX \u00d7 typeY ? upoint Constructs an upoint type. \n\n? xb, yb ? real, initial position of \n\nthe point. \n\n? xe, ye ? real, end position of the \n\npoint. \n\n? typeX ? int, type of function to \n\ninterpolate the x coordinate. \n\n? typeY ? int, type of function to \n\ninterpolate the y coordinate. \n\nUnitMesh I \u00d7 P \u00d7 Q \u00d7 IC ? umesh Constructs an umesh type. \n\n? See section 3.3.6. \n\nMovingBool \n\nMovingReal \n\nMovingPoint \n\nMovingMesh \n\n? mbool \n\n? mreal \n\n? mpoint \n\n? mmesh \n\nConstructs an empty MOVING type. \n\nTable 3.10 - Constructors. \n\n3.5 Summary \n\nIn this chapter we proposed and presented a discrete data model for moving objects that uses the concept \n\nof mesh to represent moving regions. This model: \n\n? Is independent from any specific client or application using it, and that includes DBMSs.  \n\n? Defines a new spatial type called mesh used to implement the concept of mesh that the model uses. \n\n? Is independent from the compatible triangulation and interpolation methods used as long as they can \n\nwork together. \n\n? Has limitations and defines only a small set of the spatiotemporal operations proposed in the \n\nliterature, e.g., we do not consider lines, geometries with holes and collections. \n\n\n\n \n\n \n\n \n\n \n\n32 \n\nThe MOVING types are represented using the sliced representation proposed in (Forlizzi et al., 2000) \n\nand the data types are divided into: BASE types, TIME types, SPATIAL types, i.e., OGC-compliant spatial \n\ntypes and the new spatial type mesh, INTERVAL, PERIOD, FUNCTION, UNIT and MOVING types.  \n\n\n\n \n\n \n\n \n\n \n\n33 \n\nCHAPTER 4 \n\n4.  Implementation \n\nIn the next chapter we discuss the implementation details of our framework for moving objects and the \n\nimplementation of a spatiotemporal extension for PostgreSQL that uses it. We start with an overview of: our \n\nmain goals, what was implemented, what technologies and architecture were used. Then we discuss \n\nimplementation specific needs and the technologies and architectures that we considered using, their \n\nadvantages and disadvantages. We discuss the implementation details of SPTMesh and MeshGIS (see Table \n\n4.1 for a description of these components): its dependencies, data structures, operations, architecture, usage \n\nand installation and implementation issues. \n\nWe present a \u2018standard\u2019 way of expressing spatiotemporal objects called Spatiotemporal Well-Known \n\nText (STWKT). \n\nFinally, we discuss the structure of the source code of SPTMesh and MeshGIS and the extension of \n\nSPTMesh with new triangulation and smoothing methods. \n\n4.1 Overview \n\nIn this chapter, when we say evolution we mean: the continuous changes in position or shape and extent \n\nover time. \n\nAfter establishing our discrete data model for moving objects, presented in chapter 3, we started the \n\nimplementation phase. Our main goals were: \n\n? Implement the algebra proposed in chapter 3, i.e., the data types and operations defined by our \n\ndiscrete data model, in a framework that is not dependent on a specific client or architecture using it. \n\n? Manipulate and analyse 2D geometries in the 2D Cartesian plane\n2\n. \n\n? Integrate the triangulation (C. Gotsman &amp; Surazhsky, 2004), smoothing (C. Gotsman &amp; Surazhsky, \n\n2004) and interpolation (Alexa et al., 2000; Baxter et al., 2008) methods implemented in (Amaral, \n\n2015) as part of our framework. \n\n? Build a spatiotemporal database extension as a proof of concept that our framework works with real \n\napplications using real data. \n\n? Build a framework that can be used as a reference for future work and investigation in this area. \n\n                                                           \n\n2\n We want to use the Cartesian coordinate system. \n\n\n\n \n\n \n\n \n\n \n\n34 \n\nWe analysed technologies and architectures to support our implementation, see section 4.2 and \n\nimplemented 2 components, called: SPTMesh and MeshGIS. See Table 4.1 for details. \n\nComponent Description \n\nSPTMesh A framework for moving objects, implemented as a C++ library with a C API. It \n\nimplements: \n\n? The data model proposed in chapter 3.  \n\n? The triangulation, smoothing and interpolation methods implemented in (Amaral, \n\n2015). \n\nMeshGIS A spatiotemporal database extension built on top of PostgreSQL, implemented as a C \n\nlibrary. \n\nWe also provide a binding of the MeshGIS functions and data structures to Structured \n\nQuery Language (SQL) functions and types. \n\nTable 4.1 - Implemented components. \n\nThe implementation details of these components are discussed in sections 4.3 and 4.4. \n\nTable 4.2 and Table 4.3, below, present the technologies and the development environment setup that we \n\nused. \n\nComponent Technologies Used \n\nSPTMesh Programming Languages C++11 and C. \n\nExternal Dependencies Armadillo, BLAS, LAPACK, GEOS. \n\n \n\nDependency Usage \n\nArmadillo Linear algebra operations. \n\nBLAS, LAPACK Armadillo dependencies to provide various matrix \n\ndecompositions, e.g., SVD. \n\nGEOS C++ library for manipulation and analysis of 2D \n\ngeometries and spatial operations. \n\n \n\nMeshGIS Programming Languages C. \n\nExternal Dependencies PostgreSQL, SPTMesh. \n\n \n\nDependency Usage \n\n\n\n \n\n \n\n \n\n \n\n35 \n\nPostgreSQL MeshGIS is built on top of PostgreSQL. PostgreSQL \n\nmakes it possible to, among other things: \n\n? Store moving objects in a database. \n\n? Analyse and manipulate moving objects using \n\nSQL. \n\nSPTMesh C++ library for manipulation and analysis of moving \n\nobjects. \n\n \n\nTable 4.2 - Technologies used to implement SPTMesh and MeshGIS. \n\nApplication Usage \n\nWindows 8.1 Pro 32-Bit on a VMware \n\nvirtual machine. \n\nOperating System. \n\nPostgreSQL 9.4 Database Management System that supports MeshGIS. \n\nPostGIS 2.1.8 Store and perform spatial operations on MeshGIS spatial \n\nresults. \n\nMicrosoft Visual Studio Community 2015 Integrated Development Environment (IDE) used to \n\nimplement SPTMesh and MeshGIS. \n\nQGIS 2.16.1 Visualization of geometries and operation results stored in \n\nPostgreSQL. \n\nOctave 4.0.1 Visualization of geometries and operation results, e.g., \n\ntriangulation, smoothing and interpolation. \n\nTable 4.3 - Development environment setup. \n\nFigure 4.1 shows an overall overview of the architecture of a system using SPTMesh, MeshGIS and \n\npossibly other external systems, e.g., PostGIS. PostGIS is used to emphasize the fact that we can do \n\ncomposition of functions to provide further value, using functions provided by MeshGIS and PostGIS. The 2 \n\nsystems can exchange spatial data using the Well-Known Text (WKT) standard form for expressing spatial \n\nobjects given by the OpenGIS Consortium (OGC) standard\n3\n. \n\n                                                           \n\n3\n http://www.opengeospatial.org/standards/wkt-crs \n\n\n\n \n\n \n\n \n\n \n\n36 \n\n \n\nFigure 4.1 - Overall overview of the architecture of a system that uses MeshGIS and SPTMesh.  \n\nIt is important to mention that MeshGIS and PostGIS do not communicate directly with each other. They \n\ncommunicate using the SQL functions that bind to the functions that they provide. \n\nIn the next sections we discuss implementation in more detail. \n\n4.2 Technologies and Architectures \n\nIn this section we discuss the technologies and architectures that we considered using: their advantages \n\nand disadvantages, and the reasons behind some of our choices. \n\nOur implementation has specific needs that we have to consider: \n\n? The triangulation, smoothing and interpolation methods that we use were initially implemented in \n\nMatlab and use linear algebra operations, in particular to compute the Moore-Penrose pseudo-\n\ninverse of a matrix and to perform the Singular Value Decomposition (SVD) of a matrix. \n\n? Our discrete data model uses the SPATIAL types: point, linestring, polygon, multipoint, \n\nmultilinestring, multipolygon and geometrycollection. They are already well-established and various \n\nimplementations are available. This suggests that they can be provided by an external dependency.  \n\n? The architecture of our framework for moving objects, i.e., SPTMesh, should be independent from \n\nany specific client using it, this includes database systems, and it should be portable. \n\nThis project started from scratch so there were no more initial restrictions other than the specific needs \n\nthat were previously identified. \n\n\n\n \n\n \n\n \n\n \n\n37 \n\n4.2.1 To Implement a Framework for Moving Objects \n\nWe considered several programming languages to implement SPTMesh: java, python and C++. They all \n\nprovide tools to manipulate and analyse 2D geometries in the Cartesian plane and to perform linear algebra \n\noperations. Python, in particular, provides some of these tools as wrappers for C++ libraries, e.g., Shapely\n4\n. \n\nWe looked for and analysed well-known and well-established frameworks for spatial and spatiotemporal \n\nobjects, such as: Hermes\n5\n and PostGIS\n\n6\n. PostGIS, in particular, uses GEOS\n\n7\n, a C++ library, for spatial \n\noperations on geometries on the Cartesian plane. And this is particularly relevant for us. \n\nThen, we compared implementation alternatives for SPTMesh. Given the sets: {C++, Python}, that \n\nrepresents the set of programming languages to implement SPTMesh, and {GEOS, Shapely, PostGIS}, that \n\nrepresents the set of tools to perform spatial operations on geometries on the Cartesian plane, we have at least \n\n3 trivial alternatives: \n\n? Scenario 1. Using C++ and GEOS: \n\n \n\nFigure 4.2 - SPTMesh architecture using C++ and GEOS. \n\n This is a simple and elegant solution. \n\n? Scenario 2. Using Python and Shapely: \n\n                                                           \n\n4\n http://toblerity.org/shapely/project.html (Shapely is a wrapper for the GEOS library.) \n\n5\n https://hermes-mod.java.net/manual.html#Architecture_Map \n\n6\n http://postgis.net/ \n\n7\n http://geos.osgeo.org/ \n\n\n\n \n\n \n\n \n\n \n\n38 \n\n \n\nFigure 4.3 - SPTMesh architecture using Python and Shapely. \n\nThis solution is similar to the previous one but, we can have additional levels of indirection because \n\nsome Python tools are actually wrappers for other libraries, e.g., Shapely is a wrapper for the GEOS \n\nlibrary. \n\n? Scenario 3. Using C++ or Python and PostGIS: \n\n \n\nFigure 4.4 - SPTMesh architecture using PostGIS. \n\nThis scenario, if feasible at all, is not an interesting solution. The strong coupling between PostGIS \n\nand PostgreSQL is automatically inherited by SPTMesh compromising the independence and \n\nportability properties of any architecture. \n\nWe also analysed the GEOS C++ library architecture, shown in Figure 4.5. \n\n\n\n \n\n \n\n \n\n \n\n39 \n\n \n\nFigure 4.5 - GEOS Architecture. \n\nBriefly, GEOS is a project of the Open Source Geospatial Foundation (OSGeo\n8\n). It is a C++ library with a \n\nC API used by projects such as PostGIS and Autodesk MapGuide Enterprise, among others. GEOS also \n\nprovides all the SPATIAL data types, with the exception of the mesh type, that our discrete data model uses. \n\nThat is, GEOS is a well-known, well-established project used to analyse and manipulate spatial objects. \n\nThere are several libraries for linear algebra available, such as: Armadillo, Eigen\n9\n, Eigen do Better\n\n10\n, \n\nLAPACK\n11\n\n and OpenBLAS\n12\n\n. In particular, Eigen, Eigen do Better and Armadillo are template-based C++ \n\nlibraries and this is a very interesting property. \n\nEigen is a well-known, well-established library. It has no dependencies other than the C++ standard \n\nlibrary. However, Eigen does not provide a method to compute the pseudo-inverse of a matrix and the \n\nprovided SVD of a matrix does not meet our needs. \n\nEigen do Better is an improved version of the Eigen library. It does provide a method to compute the \n\npseudo-inverse of a matrix but the \u2018SVD problem\u2019 remains unsolved. \n\nArmadillo does provide a method to compute the pseudo-inverse of a matrix and the provided SVD of a \n\nmatrix does meet our needs. Unlike Eigen, Armadillo provides several matrix decompositions using external \n\ndependencies. One of these decompositions is the SVD of a matrix. Therefore, we use LAPACK and \n\nOpenBLAS as Armadillo external dependencies. \n\nAfter this analysis, we established that: \n\n? The SPTMesh architecture follows the architecture presented in Scenario 1 and the GEOS \n\narchitecture. Therefore, SPTMesh provides a C API on top of a C++ implementation and that should \n\nbe the interface used by applications linking to it so that these applications still work without \n\nrelinking when the framework is upgraded.  \n\n? SPTMesh uses GEOS for manipulation and analysis of 2D geometries in the Cartesian plane, i.e., \n\nfor spatial operations. GEOS does not provide any support for the mesh type.  \n\n? SPTMesh uses Armadillo\n13\n\n (Sanderson &amp; Curtin, 2016) for linear algebra operations. \n\n                                                           \n\n8\n http://www.osgeo.org/ \n\n9\n http://eigen.tuxfamily.org/ \n\n10\n http://eigendobetter.com/ \n\n11\n http://www.netlib.org/lapack/ \n\n12\n http://www.openblas.net/ \n\n13\n http://arma.sourceforge.net \n\n\n\n \n\n \n\n \n\n \n\n40 \n\nSPTMesh implementation details are discussed in section 4.3. \n\n4.2.2 To implement a Spatiotemporal Database Extension \n\nTo implement MeshGIS we considered 2 DBMSs: Oracle and PostgreSQL. There is a lot of work done \n\non spatiotemporal database extensions using Oracle in the literature. Not so many using PostgreSQL. \n\nNoticeably, Hermes (Nikos Pelekis et al., 2010) is a spatiotemporal database extension built on top of Oracle \n\nand PostgreSQL. \n\nWe decided to use PostgreSQL because it is a well-established project, allows for the creation of user \n\nextensions with user data types and operations, it is a powerful modern database engine, it is free, easy to use \n\nand install, runs on several operating systems, it has a powerful spatial extension, i.e., PostGIS, and it was \n\nused successfully to implement Hermes. \n\nThe PostgreSQL backend is implemented in C. It might, however, be possible to load functions written in \n\nother languages, namely: C++, FORTRAN or Pascal, into PostgreSQL and we can write PostgreSQL \n\nextensions using C++, if certain guidelines\n14\n\n are followed. PostgreSQL also supports procedural languages\n15\n\n, \n\ne.g., PL/Python that allows PostgreSQL to use functions written using Python, but they have several \n\nsignificant limitations\n16\n\n. Following the examples of PostGIS and Hermes and in order to avoid unnecessary \n\ncomplexity we decided to implement MeshGIS as a C library. Furthermore, MeshGIS follows the \n\narchitecture of PostGIS and its implementation details are discussed in section 4.4. \n\n4.3 SPTMesh - A Framework for Moving Objects \n\nSPTMesh is a framework for moving objects implemented as a C++ library with a C API that follows the \n\narchitecture of GEOS. It implements: \n\n? The data types and part of the operations proposed in the data model for moving objects presented in \n\nchapter 3.  \n\n? The triangulation, smoothing and interpolation methods implemented in (Amaral, 2015). \n\n? A precision model and data structures that handle specific needs. \n\n4.3.1 Dependencies \n\nTable 4.4 presents the SPTMesh external dependencies. \n\nDependency Usage \n\nArmadillo Linear algebra operations. \n\nBLAS, LAPACK Armadillo dependencies to provide various matrix decompositions, e.g., SVD. \n\n                                                           \n\n14\n https://www.postgresql.org/docs/9.4/static/xfunc-c.html \n\n15\n See PostgreSQL documentation: Chapter 39 - Procedural Languages \n\n16\n See PostgreSQL documentation: Chapter 35 - Extending SQL. \n\n\n\n \n\n \n\n \n\n \n\n41 \n\nGEOS Manipulation and analysis of 2D geometries in the Cartesian plane and spatial \n\noperations. \n\nTable 4.4 - SPTMesh external dependencies. \n\n4.3.2 Data Structures \n\nIn this section we discuss the implementation of the main data types in SPTMesh. These include our \n\ndiscrete data model data types. \n\nTable 4.5 presents the SPTMesh data structures used to implement our data model data types. \n\nData Model Data Type Data Structure Implementation \n\nTIME We are not yet using dates with locales and time zones and type instant is \n\nimplemented using the C++ long long data type. This is to be changed in the \n\nfuture. Date\n17\n\n, a template-based C++ date and time library, seems to be a \n\ngood solution to deal with the complexity of dates, locales and time zones. \n\nSPATIAL Type mesh is implemented in class Mesh. \n\nType point is implemented in class Point. The GEOS library provides a type \n\npoint. However, it would be overkill to use the GEOS library to just have a \n\ntype point available, under certain circumstances. Therefore, SPTMesh \n\nimplements type point.  \n\nThe other SPATIAL types are provided by GEOS. \n\nINTERVAL and PERIOD Types: interval and period are implemented in the template classes Interval \n\nand Period, respectively. Interval supports the 4 types of intervals but we \n\nonly use closed-open intervals. A closed-open interval can be used to \n\nconstruct closed-closed, open-closed and open-open intervals. However, no \n\ngranularity is specified in our model, e.g., to convert a closed-open interval \n\nto a closed-closed interval we need a granularity. \n\nUNIT, \n\nMOVING and FUNCTION \n\nUNIT and MOVING types are implemented in classes: UnitBool, UnitReal, \n\nUnitPoint, UnitMesh, MovingBool, MovingReal, MovingPoint and \n\nMovingMesh, respectively.  \n\nType function is implemented in class UnitFunction. \n\nTable 4.5 - SPTMesh data structures to implement our discrete data model data types. \n\nTable 4.6 presents other SPTMesh relevant data structures. \n\n                                                           \n\n17\n https://howardhinnant.github.io/date/date.html \n\n\n\n \n\n \n\n \n\n \n\n42 \n\nData Type Data Structure Implementation \n\nPrecisionModel SPTMesh implements the same precision model that GEOS uses, in class \n\nPrecisionModel. The precision model provides 3 different rounding methods: Fixed \n\nprecision, Floating double-precision and Floating single-precision. When using the \n\nC API SPTMesh will use Floating double-precision. The C++ API is less restrictive \n\nand allows its clients to choose the precision model to be used. However, the \n\nprecision model is something to be looked at more carefully, e.g., we can have: \n\nobjects created with different precision models or user custom precision models. \n\nWKTReader The WKTReader class constructs UNIT and MOVING types from their \n\nSpatiotemporal Well-Known Text (STWKT\n18\n\n) representations and uses a precision \n\nmodel. \n\nCorrespondence The Correspondence class reads the correspondence between 2 polygons, a source \n\nand a target polygons, generated by the data acquisition tools implemented in \n\n(Mesquita, 2013) and it can further process them. \n\nTable 4.6 - Other relevant SPTMesh data structures. \n\nNext we discuss the implementation of the umesh type because it is the most important data structure \n\nproposed in this work. \n\nUnitMesh \n\nThe umesh type implementation, in class UnitMesh, adds 2 new attributes, tb, te, uses a UnitPoint to \n\nrepresent the evolution of the position of the mesh\u2019s centroid and it is not decoupled from the interpolation \n\nmethod. The UnitMesh data structure is defined as follows: \n\nUnitMesh = {(I, tb, te, c, P, Q, pStar, rScale, rGamma) | I ? Interval(long long), tb, te ? long long, c ? \n\nUnitPoint, P, Q ? Mesh, pStar, rScale ? mat,  rGamma ? vector<double> such that \n\n(i) tb &lt;te ? (I.tb ? tb ? I.te ? te)} \n\n(i) I must be equal or contained by the original interval. \n\nWhere: \n\n? I is the interval in which the unit is defined. \n\n? tb and te represent the begin and end instants of the original interval, respectively. \n\n? c represents the evolution of the position of the mesh\u2019s centroid. \n\n? P and Q represent the original source and target meshes at the begin and end instants of the original \n\ninterval, respectively. \n\n? mat is an Armadillo data type that represents a matrix. \n\n? vector is the C++ standard library vector data type. \n\n                                                           \n\n18\n STWKT is not a standard. We are introducing this concept to represent a WKT for unit and moving types. \n\n\n\n \n\n \n\n \n\n \n\n43 \n\n? pStar, rScale and rGamma are the interpolation components, computed by the interpolation method, \n\nused to interpolate the mesh during I. \n\nThe attributes tb and te are introduced because of copy operations. The evolution of the mesh\u00b4s position \n\nduring I is stored using a UnitPoint and an important implementation detail is the fact that UnitMesh is \n\nnot decoupled from the interpolation method. This is discussed in section 4.3.8. \n\nTo avoid a possible successive loss of precision, when creating new unit or moving objects from existing \n\nones, we agreed that: given u, u* ? UnitMesh ? I, I* ? Interval, such that \n\nu = (I, tb, te, c, P, Q, pStar, rScale, rGamma), then \n\n?u*, I*: I* ? I ? copy(u*, u) ? u* = (I*, I.tb, I.te, c, P, Q, pStar, rScale, rGamma) \n\nWhere: \n\n? copy(a, b) means that a is a copy of b. \n\nWhen creating a new UnitMesh object from an existing one if we use interpolated meshes for the new \n\nobject source and target meshes we can induce a possible successive loss of precision. Therefore, we copy \n\nthe source and target meshes, the evolution of the position of the mesh\u2019s centroid and the interpolation \n\ncomponents to the new object without any changes. \n\n4.3.3 Operations \n\nIn this subsection we discuss the SPTMesh implementation of the discrete data model operations \n\nproposed in section 3.4. We present and discuss only the operations that were implemented. \n\nThe notation used in this section follows the convention in Table 4.7. \n\nSymbol Description \n\nt An instant. \n\nP A period(instant). \n\n?, ? 2 moving types, i.e., ?, ? ? MOVING. \n\nTable 4.7 - Notation. \n\nOperation Discrete data model Operation Implementation \n\nequals ? \u00d7 ? ? mbool. Implemented for all MOVING types in their \n\nrespective implementation classes. \n\n2 MOVING types are equal iff they have: \n\n? The same number of units. \n\n? Exactly the same units. \n\nintersects mmesh \u00d7 mmesh \u00d7 t ? bool Implemented in class MovingMesh. \n\n\n\n \n\n \n\n \n\n \n\n44 \n\nTable 4.8 - Predicate operations. \n\nOperation Discrete data model Operation Implementation \n\nintersection mmesh \u00d7 mmesh \u00d7 t ? \n\ngeometrycollection ? polygon \n\nImplemented in class MovingMesh. The operation \n\nreturns a Well-Known Text (WKT) representation of \n\nthe intersection. \n\nTable 4.9 - Set operations. \n\nOperation Discrete data model Operation Implementation \n\narea mmesh \u00d7 t ? real Implemented in class MovingMesh. \n\n mmesh \u00d7 P ? mreal Implemented in class MovingMesh. \n\nTable 4.10 - Numeric operations. \n\nOperation Discrete data model Operation Implementation \n\ndeftime ? ? P Implemented for all MOVING types in their \n\nrespective implementation classes. \n\nTable 4.11 - Projection of MOVING types to Domain and Range. \n\nOperation Discrete data model Operation Implementation \n\natinstant mmesh \u00d7 t ? polygon Class MovingMesh. Implementation does not return \n\na polygon type. It returns a WKT representation of \n\nthe polygon. This is because we are possibly sending \n\nspatial information to an external system. \n\n mpoint \u00d7 t ? point Class MovingPoint. Implementation does not return \n\na point type for the same reason as above. In this \n\ncase 2 options are provided: return a WKT \n\nrepresentation of the point or its x and y values. \n\n mreal \u00d7 t ? real Class MovingReal. \n\n mbool \u00d7 t ? bool Class MovingBool. \n\natperiod ? \u00d7 P ? ? Implemented for all MOVING types in their \n\nrespective implementation classes. \n\npresent ? \u00d7 t ? bool Implemented for mmesh only in class MovingMesh. \n\n ? \u00d7 P ? mbool Implemented for mmesh only in class MovingMesh. \n\nTable 4.12 - Interaction of MOVING types with values in Domain and Range. \n\nConstructor Discrete data model Operation Implementation \n\nUnitBool \n\nUnitReal \n\n(\u2026) ? UNIT \n\n? MOVING \n\nThe constructors are implemented in the classes that \n\nimplement the respective type. \n\n\n\n \n\n \n\n \n\n \n\n45 \n\nUnitPoint \n\nUnitMesh \n\nMovingBool \n\nMovingReal \n\nMovingPoint \n\nMovingMesh \n\n \n\nThe WKTReader class constructs UNIT and \n\nMOVING types from their STWKT forms. \n\nTable 4.13 - Constructors. \n\nOperation Signature Implementation \n\n? List \u00d7 List ? Mesh This operation constructs a mesh type.  \n\nThe triangulation method, used to create mesh \n\nobjects, needs 2 polygons, with a correspondence \n\nbetween them, to work. \n\nMoreover, we don\u2019t work directly with polygons. \n\nInstead, we have a list of their boundary points. But \n\nthis can change in the future. \n\nWe use the following generic algorithm to construct \n\n2 mesh types from the lists of boundary points of 2 \n\npolygons with a correspondence: \n\n     P, Q ? List \n\n     P*, Q* ? Mesh \n\n     copyTo(P, P*) \n\n     copyTo(Q, Q*) \n\n     triangulate(P*, Q*, triangulationMethod) \n\n     smoothing(P*, smoothingMethod)               (1) \n\n     smoothing(Q*, smoothingMethod)              (2) \n\n(1) and (2) are optional. \n\nWhere: \n\n? P, Q are the lists of boundary points of 2 \n\npolygons, a source and a target polygons. \n\n? copyTo(a, b) means that a is copied to b. \n\n? triangulate(a, b, c) means that a and b will be \n\ntriangulated using method c. \n\n? smoothing(a, b) means that a will be smoothed \n\nusing method b. \n\ntoWKT SPATIAL ? string\n19\n\n This operation returns a WKT representation of a \n\n                                                           \n\n19\n Our data model does not define the data type string but we use it in its implementation. Type string is given by the underlyi ng \n\nprogramming language respective type. \n\n\n\n \n\n \n\n \n\n \n\n46 \n\nspatial object. The WKT format is a standard way of \n\nexchanging spatial objects with external systems, \n\ne.g., GEOS and PostGIS. \n\nUnitFunction  (\u2026) ? FUNCTION This operation constructs a function type. It is \n\nimplemented in class UnitFunction. \n\nadd UNIT ? MOVING This operation adds a unit to a moving object. It is \n\nimplemented for all MOVING types in their \n\nrespective implementation classes. \n\ntoSTWKT MOVING ? string \n\nUNIT ? string \n\nThis operation returns a STWKT representation of \n\nUNIT and MOVING types. It is implemented for all \n\nUNIT and MOVING types in their respective \n\nimplementation classes. \n\nTable 4.14 - Other interesting operations. \n\n4.3.4 Triangulation, Smoothing and Interpolation Methods \n\nIn this subsection we discuss the implementation of the triangulation, smoothing and interpolation \n\nmethods. In section 5.2 we present some results obtained using these methods. \n\nMethod Implementation \n\nTriangulation Implemented in class CompatibleTriangulation. \n\nSmoothing Implemented in class SimpleSmoothing. \n\nInterpolation Implemented in class OptimalRigidInterpolation. \n\nTable 4.15 - Triangulation, smoothing and interpolation methods implementation classes. \n\nThe triangulation, smoothing and interpolation methods implementation, see Table 4.15, offers the same \n\nfunctionality as in the original implementation in (Amaral, 2015). The implementation of these methods has \n\nbeen optimized: \n\n? Processing is done in memory. \n\n? We simplified some operations, e.g., the computation of the interpolation components translates the \n\ntriangles directly to the origin, i.e., (0, 0), instead of translating the polygon to the origin and then \n\nthe triangles. \n\n? The triangulation method uses a lookup table to avoid the re-computation of distances between \n\nvertices and uses an algorithm that is different from the original implementation to split a polygon in \n\norder to perform that operation in only one pass. \n\nIn this implementation the triangulation and smoothing methods use the GEOS library to validate the \n\nmesh geometry and to avoid triangle overlaps during the triangulation process. The interpolation method is \n\nnot verifying geometry validity for interpolated meshes. \n\n\n\n \n\n \n\n \n\n \n\n47 \n\nWe also changed the interpolation method to use the area-weighted average rotation over all the triangles \n\nwhen computing the minimized rotation angles, as proposed in (Baxter et al., 2008). This allows us to have \n\nrotations like the one in Figure 4.6. \n\n \n\nFigure 4.6 - Interpolation of a geometry that coils during an interval. \n\n4.3.5 Continuity for Unit Types \n\nSPTMesh defines 2 constant values that are used to help establish continuity for UNIT types, see Table \n\n4.16. \n\nValue Default Value Description \n\nRealContinuityEpsilon (?p) 0.00001 This value is used to help\n20\n\n establish continuity for unit \n\npoint objects. See section 6.4.2 for a discussion on \n\nwhy ?p is not used to establish continuity for unit real \n\nobjects. \n\nMeshContinuityDelta   (?s) 0.85 2 mesh objects are continuous if: \n\n? \nm?? ??\n\nm? ? ??\n ? ?s \n\n? distance(mi, mj) ? ?p, m? , ??  ? Mesh, \n\n,distance(mi, mj) refers to the distance between the \n\nmesh centroids. With this definition we can define \n\ncontinuity for unit mesh objects. \n\nSee section 6.4.1 for a discussion on why \n\ndistance(mi, mj) is not actually used to establish \n\ncontinuity for mesh objects. \n\nTable 4.16 - The SPTMesh values used to help establish a notion of continuity for UNIT types. \n\nBoth ?p And ?s were empirically set during the tests phase using real data. However, given the limited \n\nsize of our dataset the constants and formulas used to establish continuity need further evaluation and might \n\nbe adapted for larger datasets. \n\n4.3.6 A Spatiotemporal Well-Known Text Form for Moving Objects \n\nIn this section we use the notation as given in Table 4.17. \n\nSymbol Description \n\n                                                           \n\n20\n The unit\u2019s interval is also used to establish continuity for unit objects. \n\n\n\n \n\n \n\n \n\n \n\n48 \n\ntb, te ? instant Begin and end instants of an interval. \n\nv ? bool A value in {true, false} or equivalently in {1, 0}. \n\nvb, ve ? double Begin and end values, respectively. \n\ntype, typeX, typeY ? int Type of interpolation function and type of interpolation function for the x and \n\ny components, respectively. \n\nxb, yb, xe, ye ? double Begin and end x and y components, respectively. \n\nTable 4.17 - Notation. \n\nThe STWKT was defined in order to express UNIT and MOVING types in a common format. The \n\nSTWKT form is not a standard. This concept \u2018extends\u2019 the WKT standard form for expressing spatial objects \n\ngiven by the OpenGIS specification. We defined the STWKT form presented in Table 4.18. \n\nType STWKT Format \n\nubool UNITBOOL(tb te v) \n\nE.g.: UNITBOOL(1491214210 1491300610 1) \n\nureal UNITREAL(tb te vb ve type) \n\nE.g.: UNITREAL(1491214210 1491300610 7.1 9.7 1) \n\nupoint UNITPOINT(tb te xb yb xe ye typeX typeY) \n\nE.g.: UNITPOINT(1491214210 1491300610 3.1 4.5 4 7.8 1 1) \n\numesh UNITMESH(tb te, (source_polygon_coordinates), (target_polygon_coordinates)) \n\nUNITMESH(tb te, (x1 y1, \u2026, xn yn), (x1 y1, \u2026, xn yn)) \n\nE.g.: UNITMESH(1491214210 1491300610, (1052 987, \u2026, 1096 1095),  \n\n (1055 999, \u2026, 1104 1074)) \n\n(x1 y1, \u2026, xn yn) is not closed, i.e., x1 = xn ? y1 = yn. \n\nmbool MOVINGBOOL(UNITBOOL1, ..., UNITBOOLn) \n\nMOVINGBOOL(tb1 te1 v1, ..., tbn ten vn) \n\nE.g.:  \n\nMOVINGBOOL EMPTY \n\nMOVINGBOOL(1491041410 1491127810 1, \u2026, 1491214210 1491300610 0) \n\nmreal MOVINGREAL(UNITREAL1, ..., UNITREALn) \n\nMOVINGREAL((tb te vb ve type)1, ..., (tb te vb ve type)n) \n\nE.g.:  \n\nMOVINGREAL EMPTY \n\nMOVINGREAL((1491041410 1491127810 1 5 1), \u2026, (1491214210 1491300610 -7 2 1)) \n\nmpoint MOVINGPOINT(UNITPOINT1, ..., UNITPOINTn) \n\nMOVINGPOINT((tb te xb yb xe ye typeX typeY)1, ..., (tb te xb yb xe ye typeX typeY)n) \n\nE.g.:  \n\nMOVINGPOINT EMPTY \n\nMOVINGPOINT(1491127810 1491214210 2 2 3 4.5 1 1), \u2026, (1491214210 1491300610 3 4.5 \n\n\n\n \n\n \n\n \n\n \n\n49 \n\n4 7.8 1 1) \n\nmmesh MOVINGMESH(UNITMESH1, ..., UNITMESHn) \n\nMOVINGMESH((tb te, (x1 y1, \u2026, xn yn), (x1 y1, \u2026, xn yn))1, ..., (tb te, (x1 y1, \u2026, xn yn), (x1 y1, \u2026, \n\nxn yn))n) \n\nE.g.:  \n\nMOVINGMESH EMPTY \n\nMOVINGMESH((1491041410 1491127810, (0 0, \u2026, 6 0), (6 8, \u2026, 0 8)), \u2026) \n\nTable 4.18 - STWKT formats for UNIT and MOVING types. \n\n4.3.7 Architecture \n\nIn this subsection we discuss the SPTMesh and GEOS architectures. \n\nThe SPTMesh architecture follows the GEOS library architecture. There are naturally differences. E.g., \n\nGEOS: \n\n? Has no external dependencies. \n\n? Has a close system of operations. \n\n? Is a complex, mature, well-established project. \n\nFigure 4.7 shows the SPTMesh architecture and available APIs. \n\n \n\nFigure 4.7 - SPTMesh architecture and available APIs. \n\nFigure 4.8 shows the GEOS type system. \n\n \n\nFigure 4.8 - The GEOS type system. Source: GEOS documentation. \n\n\n\n \n\n \n\n \n\n \n\n50 \n\nFigure 4.9 shows the SPTMesh type system. \n\n \n\nFigure 4.9 - The SPTMesh type system. \n\n4.3.8 Issues \n\nWe think that SPTMesh has some architectural limitations. \n\nType umesh implementation, i.e., the UnitMesh class, is not decoupled from the interpolation method. \n\nSince it would be interesting to use different interpolation methods the SPTMesh architecture should be \n\nmodified in the future to allow the framework to be extended with new interpolation methods in a simple and \n\nnatural way.  \n\nThe infrastructure needed to decouple UnitMesh from the interpolation method is already created and \n\ntested. However, SPTMesh can have clients that store the interpolation components, e.g., MeshGIS, and \n\nrequire them to be constructed at a later time. Therefore, we need a representation that decouples the client \n\nfrom interpolation details. And this is the main reason why UnitMesh is not decoupled from the interpolation \n\nmethod. \n\nThe next definition gives us the representation we need. \n\nGiven IC, the set of all admissible interpolation components, ?, an un-ordered list of real numbers, ?, a \n\nfunction with an inverse function ?\n-1\n\n, assuming: \n\n?? ? IC, ?? : ?(?) = ?, such that \n\n(i) ??i, ?j ? IC : ?i ? ?j ? ?(?i) ? ?(?j) \n\n(ii) ?(?i) = ?(?j) ? ?i = ?j \n\nWhere: \n\n? ? represents the interpolation components of some interpolation method. \n\n\n\n \n\n \n\n \n\n \n\n51 \n\nThat is, we assume that the interpolation components of any admissible interpolation method, \n\nindependently of what they are and the data structures they use, can be represented by an un-ordered list of \n\nreal numbers and this representation is unique. \n\nThen, we only need to provide such ? and ?\n-1\n\n functions for every interpolation method and the SPTMesh \n\nclients can use them to store and construct the interpolation components as needed, without worrying about \n\ninterpolation method details. This is the piece missing in this implementation. \n\nIf we implement ? using a class C, UnitMesh = (I, tb, te, c, P, Q, C), we decouple UnitMesh from the \n\ninterpolation method. Each interpolation method implements its own ? and ?\n-1\n\n functions. \n\nFigure 4.10 shows the infrastructure implemented in SPTMesh to decoupled the UnitMesh class from \n\ninterpolation method details. \n\n \n\nFigure 4.10 - SPTMesh interpolation method implementation classes and decoupling \n\ninfrastructure. \n\nTable 4.19 presents a description for the main classes shown in Figure 4.10. \n\nClass Main Responsibilities \n\nInterpolationComponents Holds the interpolation components of an interpolation method and \n\nprovides an interpolated value at a specified instant in [0, 1], using the \n\nconcrete class implementation of the respective interpolation method, \n\ni.e., when UnitMesh needs an interpolated value it will use the \n\nInterpolationComponents class that it holds to get it. \n\nParameters Used to define the parameters\u2019 values of an interpolation method. \n\nTable 4.19 - Main classes and responsibilities. \n\n\n\n \n\n \n\n \n\n \n\n52 \n\nOther issues include: \n\n? The current implementation does not provide a mobject type that, potentially, can make the API \n\nmore elegant and enable us to have a closed system of operations. A mobject type is an abstract type \n\nthat can represent any MOVING type. \n\n? The current implementation does not provide a uobject type that can represent any UNIT type. \n\n? The precision model is well-defined but it is not well-integrated in the SPTMesh architecture. It \n\nwould be interesting to have a moving object factory to handle the construction of moving objects. \n\nAnd such a factory would own and use the precision model. This follows the architecture of the \n\nGEOS library. \n\n? The architecture does not allow user-defined:  \n\n? Unit functions and this could be particularly interesting for ureal and upoint types. \n\n? Precision models. \n\nFigure 4.11 shows a type system with a mobject and uobject types. \n\n \n\nFigure 4.11 - A type system with a mobject and uobject types. \n\n? We are not working with dates to define the unit\u2019s interval. We want type instant to represent a date \n\nwith a specific locale and time zone. \n\n? MOVING and UNIT types should be associated with a precision model. \n\n4.3.9 Usage and Installation \n\nTo use SPTMesh with MeshGIS just copy SPTMesh and its external dependencies to the bin directory of \n\nthe PostgreSQL installation that is being using. E.g., in a windows operating system with PostgreSQL 9.4: \n\n? Copy the following files to C:\\Program Files\\PostgreSQL\\9.4\\bin: \n\n? lapack_win32_MT.dll \n\n\n\n \n\n \n\n \n\n \n\n53 \n\n? blas_win32_MT.dll \n\n? geos_c.dll \n\n? sptmesh.dll \n\n? sptmesh_c.dll \n\nNotes: \n\n? Assuming that PostgreSQL is installed in C:\\Program Files\\PostgreSQL\\9.4. \n\n? In windows systems the geos_c.dll can be found in the OSGeo4W distribution for windows. \n\n? We obtained lapack_win32_MT.dll and blas_win32_MT.dll from\n21\n\n. \n\nTo use SPTMesh with another application: put SPTMesh and its external dependencies in the same \n\ndirectory with the executable or in some other directory where the application can find them. \n\nIf using the C API the client must call SPTMESH_init_r before using SPTMesh and SPTMESH_finish_r \n\nwhen done. This is mandatory. An example of usage follows: \n\nContextHandle handle = SPTMESH_init_r(ST_callback_function); \n\n// Do work. \n\nSPTMESH_finish_r(handle); \n\n\u2026 \n\nFinally, SPTMesh objects take ownership of other objects. Read the SPTMesh documentation or the \n\nsource code .h files before using the functions provided to destroy SPTMesh objects, to avoid segmentation \n\nerrors when releasing memory owned by SPTMesh objects. This mechanism follows the GEOS architecture. \n\n4.4 MeshGIS - A Spatiotemporal Extension for PostgreSQL \n\nMeshGIS is a C library that follows the architecture of PostGIS: \n\n? It is a spatiotemporal database extension\n22\n\n for PostgreSQL. \n\n? Uses SPTMesh to analyze and manipulate moving objects. \n\n? Allows the moving objects provided by SPTMesh to be stored on PostgreSQL and manipulated \n\nusing SQL. \n\nTable 4.20 shows the MeshGIS external dependencies. \n\nDependency Usage \n\nPostgreSQL MeshGIS is completely dependent on PostgreSQL. That means that MeshGIS is only \n\nguaranteed to work with the PostgreSQL version with which it was compiled. \n\nSPTMesh Manipulation and analysis of moving objects. \n\nTable 4.20 - MeshGIS external dependencies. \n\n                                                           \n\n21\n http://ylzhao.blogspot.pt/2013/10/blas-lapack-precompiled-binaries-for.html \n\n22\n Not a complete spatiotemporal database extension. \n\n\n\n \n\n \n\n \n\n \n\n54 \n\n4.4.1 Data Structures \n\nMeshGIS implementation and data structures are based on PostGIS. Of particular interest in PostGIS is \n\nthe way it uses the GEOS library, how it exchanges data with PostgreSQL and the data structures it defines to \n\nrepresent geometries. The PostGIS data structures used to represent geometries are defined as C typedef \n\nstructs and they include\n23\n\n: POINTARRAY, GSERIALIZED, LWGEOM, LWPOINT, LWLINE, LWPOLY, \n\nLWMPOINT, LWMPOLY and LWCOLLECTION, among others. POINTARRAY, GSERIALIZED and \n\nLWGEOM are particularly interesting, see Table 4.21. The others represent specific geometry types or \n\ncollections of geometries. \n\nData Structure Description \n\nGSERIALIZED The data structure used to exchange data with PostgreSQL, i.e., the data structure \n\nused to send data to and to receive data from PostgreSQL. A PostgreSQL data type \n\nfor variable size user-defined data types. \n\nLWGEOM Represents an abstract type that can represent any geometry type. This is useful and \n\nsimplifies the API. \n\nPOINTARRAY Represents an array of points. The data structures: LWPOINT, LWLINE, \n\nLWTRIANGLE, LWCIRCSTRING and LWPOLY, which are the building blocks \n\nof other data structures, e.g., collections, use POINTARRAY. \n\nTable 4.21 - PostGIS data structures. \n\nAlso interesting for our discussion, is the connection between PostgreSQL, PostGIS and the GEOS \n\nlibrary. We have 2 main use cases: \n\na) We have a geometry stored on PostgreSQL that we want to manipulate or analyze, i.e., we need to \n\nuse the GEOS library. \n\nb) We have a geometry that we want to store on PostgreSQL. It can be a geometry obtained as an \n\nintermediate result or from a standard representation. \n\nIn the first case: \n\n1. PostGIS receives a GSERIALIZED data structure from PostgreSQL. Technically it is a data \n\nstructure with the same structure as GSERIALIZED. \n\n2. That data structure is transformed into a PostGIS data structure for the respective geometry type, \n\ne.g., LWPOLY. \n\n3. The new data structure will pass through the system as a LWGEOM. \n\n4. At the end of the chain, the new data structure is transformed into a GEOS data structure, using the \n\nGEOS C API. \n\n5. The GEOS C API is used to manipulate the geometry. \n\n                                                           \n\n23\n See: http://postgis.net/docs/doxygen/2.2/da/de7/liblwgeom_8h.html or the liblwgeom.h file in the PostGIS source code, for a \n\ncomplete list. \n\n\n\n \n\n \n\n \n\n \n\n55 \n\nIn the second case, we have a GEOS data structure or PostGIS used the GEOS C API to get one. So we \n\nstart with a GEOS data structure: \n\n1. The GEOS data structure is transformed into a PostGIS data structure for the respective geometry \n\ntype, e.g., LWPOLY. \n\n2. The new data structure will pass through the system as a LWGEOM. \n\n3. At the end of the chain, the new data structure is transformed into a GSERIALIZED data structure \n\nand sent to PostgreSQL for storage. \n\nSee POSTGIS2GEOS and GEOS2POSTGIS in lwgeom_geos.c, in the PostGIS source code, for more \n\ndetails. \n\n MeshGIS data structures to represent moving objects are also defined as C typedef structs and they are \n\npresented in Table 4.22. \n\nData Structure Description \n\nArrayOfX A generic array to hold units or other elements, e.g., UnitReal, UnitBool, \n\nUnitPoint and Matrix2x2. \n\nUnitFunction A function type. \n\nUnitInterval An interval type. \n\nUnitBool An ubool type. \n\nUnitReal A ureal type. \n\nUnitPoint An upoint type. \n\nUnitMesh An umesh type. \n\nSerializedPostgreSQLObject This is the GSERIALIZED data structure with a different name. It has the \n\nsame purpose as the GSERIALIZED data structure. \n\nSerializedMovingObject A generic MOVING type. \n\nSerializedMovingX Represents mbool, mreal and mpoint types. \n\nSerializedMovingMesh A mmesh type. \n\nTable 4.22 - MeshGIS data structures to represent moving objects. \n\nMeshGIS also defines data structures to represent the interpolation components, see Table 4.23. \n\nData Structure Description \n\nMatrix2x2 A 2x2 matrix representation. Used to hold the scale matrix of a triangle. \n\nMatrix2x3 A 2x3 matrix representation. Used to hold the transformation matrix of a \n\ntriangle. \n\nTriangles The mesh\u2019s triangles. \n\nTable 4.23 - MeshGIS data structures to represent the interpolation components. \n\nMeshGIS follows the PostGIS paradigm. It provides: \n\n? A generic array data structure that follows the POINTARRAY definition. \n\n\n\n \n\n \n\n \n\n \n\n56 \n\n? A GSERIALIZED data structure. \n\n? A data structure that represents a generic MOVING type. \n\n? Data structures that represent specific MOVING types. Although it uses SerializedMovingX to \n\nrepresent mbool, mreal and mpoint types. \n\nIt also defines data structures to represent interpolation components but this is, we think, a weakness and \n\nit should be changed in the future. We want to decouple MeshGIS from interpolation details. \n\nMeshGIS data structures relationships are somewhat complex to represent in a diagram, e.g., some data \n\nstructures are constructed using arrays of other data structures. A possible simplified diagram of these \n\nrelationships is shown in Figure 4.12. \n\n \n\nFigure 4.12 - MeshGIS data structures relationships simplified diagram overview. \n\nMeshGIS, PostgreSQL and the GEOS library connect in the same way that PostGIS, PostgreSQL and the \n\nGEOS library connect. \n\nUnitMesh is a data structure relatively more complex than the others and it has a variable size. As a \n\nconsequence, MovingMesh objects are treated as a special case, e.g., the other moving objects are passed \n\nthrough the system as a SerializedMovingObject, i.e., a generic MOVING type, while MovingMesh objects \n\nwill use the SerializedMovingMesh data structure. This should change in the future. \n\nIf we have a moving object stored on PostgreSQL that we want to manipulate or analyze, then: \n\n1. MeshGIS receives a SerializedPostgreSQLObject data structure from PostgreSQL. \n\n2. That data structure is transformed into a MeshGIS data structure for the respective MOVING type, \n\ne.g., SerializedMovingX. \n\n3. The new data structure will pass through the system as a SerializedMovingObject or a \n\nSerializedMovingMesh. \n\n\n\n \n\n \n\n \n\n \n\n57 \n\n4. At the end of the chain, the new data structure is transformed into a SPTMesh data structure, using \n\nits C API. \n\n5. The SPTMesh C API is used to manipulate the moving object. \n\nIf we have a SPTMesh data structure that we want to store in PostgreSQL. \n\n1. The SPTMesh data structure is transformed into a MeshGIS data structure for the respective \n\nMOVING type. \n\n2. The new data structure will pass through the system as before. \n\n3. At the end of the chain, the new data structure is transformed into a SerializedPostgreSQLObject \n\ndata structure and sent to PostgreSQL for storage. \n\nSPTMesh does not provide a generic MOVING type. As a consequence, MeshGIS does not have \n\nfunctions that map directly to the POSTGIS2GEOS and GEOS2POSTGIS PostGIS functions. \n\n4.4.2 Operations \n\nTable 4.24, Table 4.25, Table 4.26 and Table 4.27 present the MeshGIS operations on MOVING types. \n\nThe respective binding SQL operations are also given. \n\nMeshGIS Function SQL Binding Operation Description \n\nMovingBool_in a) MovingBool_in \n\nb) ST_MovingBool_FromSTWKT \n\na) Mandatory by the PostgreSQL rules for \n\nuser-defined types. \n\nb) Constructs a MovingBool from its \n\nSTWKT form. \n\nMovingBool_out MovingBool_out Mandatory by the PostgreSQL rules for \n\nuser-defined types. \n\nMovingBool_create ST_MovingBool_CreateEmpty Creates an empty MovingBool. \n\nMovingBool_add ST_Add_UnitBool Adds a UnitBool to a MovingBool. \n\nMovingBool_del ST_Del_UnitBool Deletes a UnitBool from a MovingBool. \n\nMovingBool_size ST_Get_Size Gets the number of units of a MovingBool. \n\nMovingBool_deftime ST_MovingBool_Get_DefTime Gets the period in which a MovingBool is \n\ndefined. \n\nMovingBool_atperiod ST_MovingBool_Get_AtPeriod Gets a MovingBool that is defined: during \n\na given period over a given MovingBool. \n\nMovingBool_equals Equals Checks if 2 MovingBool objects are equal. \n\nMovingBool_atinstant2 ST_MovingBool_Get_AtInstant2 Gets the MovingBool object at an instant. \n\nTable 4.24 - MeshGIS and its binding SQL operations for SPTMesh MovingBool objects. \n\nMeshGIS Function SQL Binding Operation Description \n\nMovingReal_in a) MovingReal_in c) Mandatory by the PostgreSQL rules for \n\n\n\n \n\n \n\n \n\n \n\n58 \n\nb) ST_MovingReal_FromSTWKT user-defined types. \n\nd) Constructs a MovingReal from its \n\nSTWKT. \n\nMovingReal_out MovingReal_out Mandatory by the PostgreSQL rules for \n\nuser-defined types. \n\nMovingReal_create ST_MovingReal_CreateEmpty Creates an empty MovingReal. \n\nMovingReal_add ST_Add_UnitReal Adds a UnitReal to a MovingReal. \n\nMovingReal_del ST_Del_UnitReal Deletes a UnitReal from a MovingReal. \n\nMovingReal_size ST_Get_Size Gets the number of units of a MovingReal. \n\nMovingReal_deftime ST_MovingReal_Get_DefTime Gets the period in which a MovingReal is \n\ndefined. \n\nMovingReal_atperiod ST_MovingReal_Get_AtPeriod Gets a MovingReal that is defined: during \n\na given period over a given MovingReal. \n\nMovingReal_atinstant ST_MovingReal_Get_AtInstant Gets the MovingReal object at an instant. \n\nTable 4.25 - MeshGIS and its binding SQL operations for SPTMesh MovingReal objects. \n\nMeshGIS SQL Binding Operation Description \n\nMovingPoint_in a) MovingPoint_in \n\nb) ST_MovingPoint_FromSTWKT \n\ne) Mandatory by the PostgreSQL rules for \n\nuser-defined types. \n\nf) Constructs a MovingPoint from its \n\nSTWKT. \n\nMovingPoint_out MovingPoint_out Mandatory by the PostgreSQL rules for \n\nuser-defined types. \n\nMovingPoint_create ST_MovingPoint_CreateEmpty Creates an empty MovingPoint. \n\nMovingPoint_add ST_Add_UnitPoint Adds a UnitPoint to a MovingPoint. \n\nMovingPoint_del ST_Del_UnitPoint Deletes a UnitPoint from a MovingPoint. \n\nMovingPoint_size ST_Get_Size Gets the number of units of a \n\nMovingPoint. \n\nMovingPoint_deftime ST_MovingPoint_Get_DefTime Gets the period in which a MovingPoint is \n\ndefined. \n\nMovingPoint_atperiod ST_MovingPoint_Get_AtPeriod Gets a MovingPoint that is defined: during \n\na given period over a given MovingPoint. \n\nMovingPoint_atinstant ST_MovingPoint_Get_AtInstant Gets the MovingPoint object at an instant. \n\nTable 4.26 - MeshGIS and its binding SQL operations for SPTMesh MovingPoint objects. \n\nMeshGIS SQL Binding Operation Description \n\nMovingMesh_in a) MovingMesh_in g) Mandatory by the PostgreSQL \n\n\n\n \n\n \n\n \n\n \n\n59 \n\nb) ST_MovingMesh_FromSTWKT rules for user-defined types. \n\nh) Constructs a MovingMesh from \n\nits STWKT. \n\nMovingMesh_out MovingMesh_out Mandatory by the PostgreSQL \n\nrules for user-defined types. \n\nMovingMesh_create ST_MovingMesh_CreateEmpty Creates an empty MovingMesh. \n\nMovingMesh_add ST_Add_UnitMesh Adds a UnitMesh to a \n\nMovingMesh. \n\nMovingMesh_del ST_Del_UnitMesh Deletes a UnitMesh from a \n\nMovingMesh. \n\nMovingMesh_size ST_Get_Size Gets the number of units of a \n\nMovingMesh. \n\nMovingMesh_deftime ST_Get_DefTime Gets the period in which a \n\nMovingMesh is defined. \n\nMovingMesh_atperiod ST_Get_AtInstant Gets a MovingMesh that is \n\ndefined: during a given period over \n\na given MovingMesh. \n\nMovingMesh_atinstant ST_Get_AtInstant Gets the MovingMesh object at an \n\ninstant. \n\nMovingMesh_atinstant_octave ST_Get_AtInstant_ToOctave Used to see geometries in Octave. \n\nMovingMesh_area_atinstant ST_Get_Area Gets the MovingMesh object area \n\nat an instant. \n\nMovingMesh_area_atperiod ST_Get_Area_AtPeriod Gets the MovingMesh object area \n\nat a period. \n\nMovingMesh_intersects ST_Intersect Checks if 2 MovingMesh objects \n\nintersect at an instant. \n\nMovingMesh_intersection ST_Intersection Gets the intersection of 2 \n\nMovingMesh objects at an instant. \n\nMovingMesh_present ST_Present Checks if a MovingMesh object \n\nexists at an instant. \n\nMovingMesh_preent_atperiod ST_Get_Present_AtPeriod Checks if a MovingMesh object \n\nexists at a period. \n\nTable 4.27 - MeshGIS and its binding SQL operations for SPTMesh MovingMesh objects. \n\n4.4.3 Architecture \n\nFigure 4.13 shows the MeshGIS architecture. \n\n\n\n \n\n \n\n \n\n \n\n60 \n\n \n\nFigure 4.13 - MeshGIS high level architecture overview. \n\nThe MeshGIS architecture has as a reference the PostGIS architecture. Figure 4.14 shows a PostGIS high \n\nlevel architecture overview and Table 4.28 presents its external dependencies. \n\n \n\nFigure 4.14 - PostGIS high level architecture overview with its external dependencies. \n\nDependency Usage \n\nGEOS Geometry processing. \n\nProj.4 Coordinate re-projection functions. \n\nGDAL Raster processing and format support. \n\nSFCGAL Extended 3D support and additional geo-processing algorithms. \n\nLibXML2 XML parsing. \n\nJSON-C JSON parsing. \n\nTable 4.28 - PostGIS external dependencies. \n\n4.4.4 Usage and Installation \n\nTo use MeshGIS: \n\n\n\n \n\n \n\n \n\n \n\n61 \n\n? Install SPTMesh and its dependencies as described in section 4.3.9. \n\n? Copy meshgis.dll to the PostgreSQL installation lib directory. \n\n? Create the types and functions defined in the Definition.sql files that can be found in the sql \n\ndirectory, in the database that is to be used to store and work with moving objects. See also section \n\n4.5.1. \n\nImportant: \n\nMeshGIS is only guaranteed to work with the same PostgreSQL version with which it was compiled. To \n\nwork with a different PostgreSQL version users should change the project settings to point to the intended \n\nPostgreSQL installation, a normal PostgreSQL installation should be sufficient, and recompile MeshGIS. \n\nFigure 4.15 shows the MOVING types available in PostgreSQL after installing MeshGIS. \n\n \n\nFigure 4.15 - Moving types available in PostgreSQL after installing MeshGIS. \n\n4.5 A Framework for Future Work and Investigation \n\nWe do think that one of the most important contributions of this dissertation is the fact that the \n\nimplemented components can be used as a framework for future work and investigation in this area. \n\nAlthough there was not enough time to build a \u2018plug and play\u2019 kind of architecture it is possible to change the \n\ntriangulation and smoothing methods in a relatively simple and easy way however this possibility was not \n\ncompletely implemented for the interpolation method. \n\n4.5.1 Code Structure \n\nSPTMesh classes are organized into namespaces, see Table 4.29. \n\nNamespace Description \n\ncorrespondence Operations related to the correspondence between polygons. \n\ninterpolation Interpolation methods. \n\n\n\n \n\n \n\n \n\n \n\n62 \n\nio Input/output operations. \n\nprecision Precision model. \n\nrange Range types, interval and period types. \n\nsmoothing Smoothing methods. \n\nspatial Spatial types. \n\ntemporal Moving and unit types. \n\ntime Time types, e.g., instant. \n\ntriangulation Triangulation methods. \n\nutil Utility operations. \n\nTable 4.29 - SPTMesh namespaces. \n\nThere was a significant effort to document the classes and their functions in our source code and we \n\nprovide doxygen files to generate the documentation of both SPTMesh and MeshGIS. \n\nTable 4.30 presents the SPTMesh project structure. \n\nDirectory Description \n\nbuild Visual studio projects for SPTMesh. \n\nDirectory Description \n\nsptmesh C++ API visual studio project. \n\nsptmesh_c C API visual studio project. \n\ntests\\c++ C++ API tests visual studio project. \n\ntests\\capi C API tests visual studio project. \n\n  \n\ncapi C API source code. \n\ndoc Code documentation and doxygen file to generate the \n\ndocumentation. \n\ninclude Armadillo and SPTMesh header files. \n\nsrc SPTMesh source files. \n\ntests Tests source files. \n\nDirectory Description \n\nc++api C++ API tests source files. \n\ncapi C API tests source files. \n\n \n\nWe did not use a Tests Framework to perform the tests. \n\nTable 4.30 - SPTMesh project structure. \n\nNote: \n\n\n\n \n\n \n\n \n\n \n\n63 \n\n? The SPTMesh visual studio project is linking to the geos_c.lib distributed with the OSGeo4W\n24\n\n \n\ndistribution for windows. \n\nTable 4.31 presents the MeshGIS project structure. \n\nDirectory Description \n\nmeshgis Source and header files. \n\ndoc Code documentation and doxygen file to generate the \n\ndocumentation. \n\nsql Files with the definition of the SQL types and functions that bind \n\nto the MeshGIS types and functions. \n\nTable 4.31 - MeshGIS project structure. \n\nThe visual studio solution for MeshGIS can be found in the root directory. \n\n4.5.2 Extending the Framework \n\nTo add a new smoothing method to SPTMesh we need to follow the steps presented in Table 4.32. \n\nStep Example and Description \n\nCreate a new class that implements the \n\nSmoothing interface. \n\nE.g.: \n\nLinearSmoothing : public virtual Smoothing \n\nThis is the class that implements the new method. \n\nThe new class must have a member class that \n\nimplements the Parameters interface. \n\nE.g.: \n\nLinearSmoothingParameters : public virtual Parameters \n\nThis class is used to pass parameters to the method, i.e., \n\nevery method can have its own parameters. \n\nAdd a new entry to the SmoothingMethod \n\nenum defined in the Smoothing class for the \n\nnew method. \n\nEnum SmoothingMethod \n\n{ \n\n\u2026 \n\nLinearSmoothingMethod \n\n}; \n\nUpdate the SmoothingFactory createInstance \n\nfunction to be able to construct the new \n\nmethod. \n\nSmoothing* SmoothingFactory::createInstance(...) \n\n{ \n\n           switch (smoothingMethod)  \n\n     { \n\n          ... \n\n          case LinearSmoothingMethod: \n\n       return new LinearSmoothing(); \n\n               ... \n\n                                                           \n\n24\n We used OSGeo4W version 2.579 with GEOS version 3.5.0-1. \n\n\n\n \n\n \n\n \n\n \n\n64 \n\n     } \n\n} \n\nTable 4.32 - Adding a new smoothing method to SPTMesh. \n\nTo add a new triangulation method to SPTMesh we follow the same steps as above. See the \n\nimplementation of the smoothing and triangulation methods for more details. \n\n4.6 Summary \n\nWe implemented 2 components: SPTMesh and MeshGIS. SPTMesh is a framework for moving objects \n\nthat implements the discrete model presented and proposed in chapter 3. MeshGIS is a spatiotemporal \n\nextension for PostgreSQL that uses SPTMesh to manipulate and analyze moving objects. SPTMesh and \n\nMeshGIS can be used as a framework for future work and investigation. \n\nIn this chapter we presented and discussed: \n\n? Our main goals and implementation specific needs. \n\n? The technologies and the architectures that we considered and their advantages and limitations. \n\n? The technologies selected for our implementation. \n\n? The implementation details of SPTMesh and MeshGIS: its dependencies, data structures, operations, \n\narchitecture, usage and installation and implementation issues. \n\n? A Spatiotemporal Well-Known form for UNIT and MOVING types. \n\n? The structure of the source code of SPTMesh and MeshGIS and the extension of SPTMesh with \n\nnew triangulation and smoothing methods. \n\n? The use of SPTMesh and MeshGIS as a framework for future work and investigation. \n\n  \n\n\n\n \n\n \n\n \n\n \n\n65 \n\nCHAPTER 5 \n\n5.  Data Model Evaluation \n\nIn this chapter we present and discuss the tests that were performed to validate the components and the \n\nmethods that were implemented, and their results. \n\nWe used Octave and QGIS to visualize and analyze the tests\u2019 results. \n\n5.1 Datasets \n\nWe used 2 sets of data for testing: \n\n? Synthetic data, i.e., data created manually to test some more or less specific functionality. \n\n? A set of real data obtained from satellite images of 2 icebergs (\u201cRossSea Subsets,\u201d 2004) using \n\nthe methods implemented in (Mesquita, 2013). The icebergs\u2019 data corresponds to 9 consecutive \n\ntime intervals. \n\n5.2 Tests \n\nWe began by validating our implementation of the triangulation, smoothing and interpolation methods by \n\ncomparing their results with the results obtained by the original implementation in (Amaral, 2015). For this, \n\nwe used a specific example and compared the results numerically. \n\nThen, we performed tests with synthetic data, of which we show only a small subset with the more \n\nrepresentative and interesting examples, in particular: situations where there are rotations ? 2? (see Figure \n\n5.1) and the 180\u00ba rotation of an object (see Figure 5.2). \n\n \n\nFigure 5.1 - Coil interpolation test. \n\n \n\nFigure 5.2 - 180\u00ba rotation test. \n\n\n\n \n\n \n\n \n\n \n\n66 \n\nFinally, we performed tests with real data obtained from satellite images of 2 icebergs. See Figure 5.3. \n\nThe tests were performed using: \n\n? The SPTMesh C++ API directly in a C++ application. \n\n? MeshGIS through SQL in PostgreSQL. \n\n \n\nFigure 5.3 - The 2 icebergs used for testing in their initial positions after being processed using \n\nSPTMesh. \n\nFigure 5.4, Figure 5.5 and Figure 5.6 show some results, seen in Octave, of the interpolation method. \n\nNote that the icebergs are in motion. \n\n \n\nFigure 5.4 - Iceberg 1 interpolation test over an interval of time. \n\n \n\nFigure 5.5 - Iceberg 2 interpolation test over an interval of time. \n\n\n\n \n\n \n\n \n\n \n\n67 \n\n \n\nFigure 5.6 - The evolution of the 2 icebergs, seen together, over an interval of time. \n\nTo test MeshGIS we start by creating the icebergs table in PostgreSQL where we can store moving \n\nregions. For this we use the MovingMesh data type. \n\nCREATE TABLE db.icebergs \n\n( \n\nid  integer, \n\nname  varchar(50), \n\nmobj  movingmesh \n\n) \n\nWITH ( \n\nOIDS = FALSE \n\n); \n\nWe can insert data into the icebergs table using the functions: ST_MovingMesh_CreateEmpty and \n\nST_MovingMesh_FromSTWKT. \n\nINSERT INTO db. icebergs(id, name, mobj) VALUES(1, \u2018ice 2\u2019, ST_MovingMesh_CreateEmpty()); \n\n \n\nINSERT INTO db. icebergs(id, name, mobj) VALUES(2, \u2018ice 1\u2019 \n\nST_MovingMesh_FromSTWKT( \n\n' MOVINGMESH((1000 2000, (1052 987, ..., 1034 941), (1055 999, ..., 1001 875)))' \n\n) \n\n); \n\nIf we search the records in the icebergs table after the 2 previous commands are executed, we obtain the \n\nresults in Table 5.1. We can see \u2018ice 1\u2019 at instants 1000 and 2000 in Figure 5.7. \n\nSELECT * FROM db.icebergs; \n\n \n\nId Name Moving Object \n\n1 ice 1 MOVINGMESH((1000 2000, (1052 987, 1090 1037, \u2026, 1034 941), (1055 999, \u2026, 1001 \n\n875))) \n\n2 ice 2 MOVINGMESH EMPTY \n\nTable 5.1 - Results of the select command in the icebergs table. \n\n\n\n \n\n \n\n \n\n \n\n68 \n\n \n\nFigure 5.7 - Ice 1 at instants 1000 and 2000. \n\nWe can add data to a record in the icebergs table independently of the method used to create it. For \n\nexample, we can add a unit, i.e., a new evolution of the iceberg during an interval of time, to the record with \n\nid = 1. \n\nUPDATE db.icebergs SET mobj = ST_Add_UnitMesh((SELECT mobj FROM db.icebergs WHERE id = \n\n1), \n\n\u2018UNITMESH(2000 3000, (1001 875, 1055 999, 1064.0010000000475 1006.9977499999466, 1073 1015, \n\n1104 1074, 1101 1106, 1106 1127, 1119.5010000000475 1137.997545454487, 1133 1149, 1152 1195, \n\n1144 1218, 1162 1270, 1165.0010000000475 1296.4997735849001, 1168 1323, 1133 1347, 1121 1343, \n\n1096 1301, 1094 1282, 1078 1264, 1069 1266, 1049.5010000000475 1249.9975624999422, 1030 1234, \n\n996 1148, 966 1106, 944.0010000000475 1067.9988421052358, 922 1030, 875 919, 848 817, 903 787, \n\n924 796, 937 820, 979 848), (1030 942, 1078 1043, 1095 1054, 1118 1088, 1130 1114, 1128 1145, 1136 \n\n1170, 1146 1171, 1161 1184, 1184 1231, 1177 1254, 1198 1306, 1197 1327, 1207 1357, 1171 1384, 1161 \n\n1380, 1135 1348, 1125 1318, 1113 1306, 1102 1309, 1079 1297, 1058 1265, 1027 1194, 979 1138,  932 \n\n1052, 908 991, 892 971, 861 869, 919 837, 937 846, 951 869, 996 896))' \n\n, false) WHERE id = 1; \n\nAfter inserting the icebergs\u2019 data in the icebergs table we can ask what is: the number of units of the \n\nrecords in the icebergs table and the period in which they are defined. See Table 5.2 and Table 5.3. \n\nSELECT ST_get_Size(mobj) FROM db.icebergs; \n\nNumber of Units \n\n9 \n\n9 \n\nTable 5.2 - Result of the ST_get_Size function after the icebergs\u2019 data was stored in the \n\nicebergs table. \n\nSELECT ST_Get_DefTime(mobj) FROM db.icebergs; \n\nPeriod \n\nPERIOD(1000 2000, 2000 3000, 3000 4000, 4000 5000, 5000 6000, 6000 7000, 7000 8000, 8000 9000, \n\n9000 10000) \n\n\u2026 \n\nTable 5.3 - Period in which the records in the icebergs table are defined. \n\n\n\n \n\n \n\n \n\n \n\n69 \n\nIt is also possible to obtain information about the records in the icebergs table in a specific period or \n\ninstant. See Table 5.4 and Table 5.5, respectively. Figure 5.8 shows \u2018ice 2\u2019 at instants 1100, 2000, 3000, 4000 \n\nand 4500, respectively. Figure 5.9 shows \u2018ice 1\u2019 at instant 1500. \n\nSELECT ST_Get_AtPeriod(mobj, 'PERIOD(1100 4500)') FROM db.icebergs; \n\nMoving Object at a Period \n\nMOVINGMESH((1100 2000, (\u2026), (\u2026)), (2000 3000, (\u2026), (\u2026)), (3000 4000, (\u2026), (\u2026)), (4000 4500, \n\n(\u2026), (\u2026))) \n\n\u2026 \n\nTable 5.4 - Records in the icebergs table defined in a given period. \n\n \n\nFigure 5.8 - Ice 2 at instants 1100, 2000, 3000, 4000 and 4500. \n\nSELECT ST_Get_AtInstant(mobj, 1500) FROM db.icebergs; \n\nMoving Object at Instant 1500 \n\nPOLYGON((994.25 909.62, \u2026, 994.25 909.62)) \n\n\u2026 \n\nTable 5.5 - Records in the icebergs table defined at a given instant. \n\n \n\nFigure 5.9 - Ice 1 at instant 1500. \n\nFinally, we can search for information about the area, intersection and existence of objects at specific \n\ninstants or in some cases at specific periods.  \n\nUsing PostGIS and MeshGIS: \n\nSELECT ST_Area(ST_GeomFromText(ST_Get_AtInstant2(mobj, 3500))) FROM db.icebergs; \n\nUsing only MeshGIS: \n\n\n\n \n\n \n\n \n\n \n\n70 \n\nSELECT ST_Get_Area(mobj, 3500) FROM db.icebergs; \n\nWe can compare the results from the 2 previous commands in Table 5.6. \n\nUsing Area \n\nPostGIS + MeshGIS 66159.5400423294 \n\n31350.9223673383 \n\nMeshGIS 66159.5400423298 \n\n31350.9223673385 \n\nTable 5.6 - Area of the icebergs in a given instant. \n\nTable 5.7 and Figure 5.10 show the evolution of the area of \u2018ice 1\u2019 during a period of time. In Figure 5.10 \n\nthe red dots correspond to area observations during the specified period and we assume a linear evolution of \n\nthe area between the observations. In reality, in the general case, this evolution is some non-linear curve. \n\nSELECT ST_Get_Area_AtPeriod(mobj, 'PERIOD(1100 10000)') FROM db.icebergs; \n\nArea during the Period (1100 10000) \n\nMOVINGREAL((1100 2000 67732.8 67389 1), (2000 3000 67389 67907 1), (3000 4000 67720.3 67293 1), \n\n(4000 5000 66661.1 67923.5 1), (5000 6000 67252.1 67749.5 1), (6000 7000 67728 65815 1), (7000 8000 \n\n65685.1 65307 1), (8000 9000 65344.8 65276.5 1), (9000 10000 64589 64692.5 1)) \n\n... \n\nTable 5.7 - Evolution of the area of the icebergs in the table icebergs in a given period. \n\n \n\nFigure 5.10 - Ice 1 area during the PERIOD(1100 10000). \n\nIn the real data set the 2 icebergs do not intersect each other. To test the functions that test the intersection \n\nof moving regions, we created 2 moving meshes based on the real data set that intersect each other at some \n\npoint in a given time interval, Figure 5.11. \n\n\n\n \n\n \n\n \n\n \n\n71 \n\n \n\nFigure 5.11 - 2 Icebergs intersecting over an interval of time. \n\nNow we can test ST_Intersect and ST_Intersection, see Table 5.8, Table 5.9, Table 5.10 and Figure 5.12. \n\nThe values 1000 and 2000 correspond to the begin and end instants, respectively. \n\nSELECT ST_Intersect((SELECT mobj FROM db.icebergs WHERE id = 3), (SELECT mobj FROM \n\ndb.icebergs WHERE id = 4), 1000); \n\nSELECT ST_Intersect((SELECT mobj FROM db.icebergs WHERE id = 3), (SELECT mobj FROM \n\ndb.icebergs WHERE id = 4), 2000); \n\nInstant Intersect \n\n1000 true \n\n2000 false \n\nTable 5.8 - ST_Intersect results. \n\nSELECT ST_Intersection((SELECT mobj FROM db.icebergs WHERE id = 3), (SELECT mobj FROM \n\ndb.icebergs WHERE id = 4), 1000); \n\n \n\nFigure 5.12 - ST_Intersection result at instant 1000 in light blue, seen in QGIS. \n\nWe can use PostGIS to get the area of the intersection between the 2 moving objects at instant 1000. See \n\nTable 5.9. \n\nSELECT ST_Area(ST_GeomFromText(ST_Intersection((SELECT mobj FROM db.icebergs WHERE id \n\n= 3), (SELECT mobj FROM db.icebergs WHERE id = 4), 1000))); \n\nIntersection Area \n\n1815.203 \n\n\n\n \n\n \n\n \n\n \n\n72 \n\nTable 5.9 - Using PostGIS to get the area of the intersection of 2 moving objects at instant \n\n1000. \n\nSELECT ST_Intersection((SELECT mobj FROM db.icebergs WHERE id = 3), (SELECT mobj FROM \n\ndb.icebergs WHERE id = 4), 2000); \n\nIntersection \n\nGEOMETRYCOLLECTION EMPTY \n\nTable 5.10 - ST_ Intersection result when no intersection exists. \n\nWe can ask if a moving object exists: at an instant, see Table 5.11, and during a period, see Table 5.12. \n\nSELECT id, name, ST_Present(mobj, 2100) FROM db.icebergs ORDER BY id; \n\nId Name Present \n\n1 ice 1 true \n\n2 ice 2 true \n\n3 ice 3 false \n\n4 ice 4 false \n\nTable 5.11 - ST_Present result at instant 2100. Ice 3 and 4 are not defined at that instant. \n\nSELECT id, name, ST_Get_Present_AtPeriod(mobj, 'PERIOD(1100 2000, 2500 2750, 3000 4000, 10000 \n\n11000)') FROM db.icebergs ORDER BY id; \n\nId Name Present \n\n1 ice 1 MOVINGBOOL((1100 2000 1), (2500 2750 1), (3000 4000 1), (10000 11000 0)) \n\n2 ice 2 MOVINGBOOL((1100 2000 1), (2500 2750 1), (3000 4000 1), (10000 11000 0)) \n\n3 ice 3 MOVINGBOOL((1100 2000 1), (2500 2750 0), (3000 4000 0), (10000 11000 0)) \n\n4 ice 4 MOVINGBOOL((1100 2000 1), (2500 2750 0), (3000 4000 0), (10000 11000 0)) \n\nTable 5.12 - ST_Get_Present_AtPeriod result at a given period. (x y 0) means that the object is \n\nnot defined in the interval [x, y[. \n\n5.3 Summary \n\nIn this chapter we presented and discussed the tests that we performed and their results and the problems \n\nencountered during this phase. \n\nWe used 2 data sets for testing: \n\n? Synthetic data, i.e., data created to test more or less specific functionalities, e.g., a geometry \n\ncoiling. \n\n? A set of real data obtained from satellite images of the evolution of 2 icebergs over time. \n\nWe used Octave and QGIS to visualize and analyze the tests' results. \n\nThe tests show that our implementation can perform predicate operations, set operations, numeric \n\noperations and projection operations on moving objects. They also show that we can use functions from \n\nMeshGIS and PostGIS and compose them to provide further value. \n\n\n\n \n\n \n\n \n\n \n\n73 \n\nWe obtained interesting results but there are some problems that have not been solved yet and we discuss \n\nthem in the next chapter in more detail. \n\n  \n\n\n\n \n\n \n\n \n\n \n\n74 \n\n  \n\n\n\n \n\n \n\n \n\n \n\n75 \n\nCHAPTER 6 \n\n6.  Discussion \n\nOne of the main objectives of this chapter is to discuss the structure of some of the problems that we \n\nfound and to provide future work guidelines on these issues and some initial background on such a structure. \n\nWe present observations, opinions, possible solutions and explanations based on experimentation. \n\n6.1 Compatible Triangulation \n\nDuring the tests phase we realized that the triangulation and interpolation methods were unware of some \n\nof the characteristics of real data, in particular, the presence of cloned vertices, i.e., vertices that have exactly \n\nthe same x and y coordinates, and collinear vertices, i.e., more than 2 consecutive vertices lying on the same \n\nline. The presence of these vertices can make the compatible triangulation method fail. Figure 6.1 shows \n\nsome examples of cloned and collinear vertices. \n\n \n\nFigure 6.1 - Examples of cloned (left) and collinear (right) vertices. \n\nWe tried some quick fixes to solve this problem: \n\n? We allowed triangles to degenerate to a point and to a line. However we found counter-examples \n\nwhere this did not work. \n\n? We avoided cloned vertices by shifting them along the line connecting them to the next non-cloned \n\nvertex. This introduces more collinear vertices. Again, this did not work and having collinear \n\nvertices seems to increase the probability of failure. \n\n\n\n \n\n \n\n \n\n \n\n76 \n\n? We avoided cloned vertices as before and collinear vertices by shifting them in the perpendicular \n\nline to the line segment where they exist, that passes through them, in both directions, i.e., to the \n\ninside and the outside of the polygon. We had cases where we were able to triangulate a polygon by \n\nshifting the vertices in both directions, in some cases we had to shift the vertices in a specific \n\ndirection. This method has the bad property that we are changing the boundary, therefore, \n\nintroducing bias in the original data. We consider a constant value, say c, of 0.001 that was not \n\nstrictly established, although experiment suggests that smaller values will increase the probability of \n\nfailure of the triangulation method. But this is not necessarily true because the changes we make in \n\nthe correspondences have to be seen as a whole. These changes follow the idea that given 3 types of \n\nline segments with a cloned vertex on one of its extremities, Figure 6.2, we start by shifting that \n\nvertex along the line segment, Figure 6.3. Then we find the line passing through that vertex that is \n\nperpendicular to the line segment and use \u00b1 c to find the new position of the vertex to the left or to \n\nthe right of the line segment, Figure 6.4. This idea can be generalized for n cloned or n collinear \n\nvertices. As future work, this implementation should be verified and validated. \n\n \n\nFigure 6.2 - 3 line segments configurations. \n\n \n\nFigure 6.3 - Cloned vertex shifted along the line segments. \n\n \n\nFigure 6.4 - Possible new positions for the cloned vertex shifted along the perpendicular line. \n\n? Finally, we also allowed invalid geometries, i.e., geometries where one or more triangles overlap. \n\nWith a proper mixture of these fixes we can triangulate all the examples in our data set of real data. \n\nHowever, this has consequences: \n\n? Different fixes will generate geometries of different complexity, i.e., with more or less Steiner \n\npoints, and this has a direct impact on the performance of the triangulation and smoothing methods. \n\nSuch an impact can be noticeable even for relatively simple geometries. \n\n\n\n \n\n \n\n \n\n \n\n77 \n\n? Invalid geometries, see Figure 6.5, and degenerated triangles can generate problems during \n\ninterpolation and can cause unexpected rotations under certain conditions. \n\n? Degenerated triangles might cause the SVD of a matrix in the interpolation method to use numeric \n\nmethods to get approximated results and this has an impact on performance. \n\n \n\nFigure 6.5 - An invalid geometry. Source: smoothing_test_ice1_2_3_GEOS_Clones.m. \n\nThe fact that none of the fixes by itself solved the problem suggests that we do not know the structure of \n\nthe problem and this should be further analyzed: \n\n? How does the probability of failure changes with the number of collinear vertices? \n\n? Do we need to change the triangulation method? \n\n? Do we need to put restrictions on the input of the triangulation method? \n\n? What is the domain of the triangulation method that we are using? \n\n? What is the real structure of the set of geometries that we can have with n collinear vertices and \n\nwhat is the structure of the set of geometries that we can have when we shift the collinear vertices in \n\nthe perpendicular line to the line where they are defined? \n\n6.2 Interpolation \n\nIn this section we discuss the interpolation method problems. \n\n6.2.1 Degenerated Triangles and Invalid Geometries \n\nThe presence of degenerated triangles and invalid geometries, as discussed in section 6.1, seems to \n\ngenerate unexpected rotations under certain conditions. This is only a claim and it is also possible that this \n\nproblem may, instead, be related to the unwrap method problem discussed in section 6.2.2. \n\nFigure 6.6 shows the interpolation of a geometry with degenerated triangles and an invalid geometry. \n\nThis example can be found in the file: interpolation_test_ice1_2_3_GEOS_Clones.m. \n\n\n\n \n\n \n\n \n\n \n\n78 \n\n \n\nFigure 6.6 - From left to right: source geometry, interpolated geometry at an instant and the \n\ntarget geometry. \n\nThe next example seems to indicate that degenerated triangles can in fact generate unexpected rotations. \n\nIn this example the sequence of the rotation angles was carefully chosen in order to eliminate the unwrap \n\nmethod problem.  \n\nFigure 6.7 shows, in red, the evolution of a degenerated triangle (degenerated to a line), more specifically, \n\nthe evolution of the position of one of the collinear vertices of the degenerated triangle. This example can be \n\nfound in the file: interpolation_test_coil_Degenerated.m. As can be seen there is an unexpected rotation of \n\nthe degenerated triangle. \n\n \n\nFigure 6.7 - From left to right: source geometry with a degenerated triangle, the interpolated \n\ngeometry at 3 different instants and the target geometry. \n\nWhen we eliminate the collinear condition, above, by shifting the vertex in red 0.001 units to the left in \n\nthe perpendicular line to the line segment where it is defined, and using the same triangles and the same \n\nsequence of rotation angles as before, we eliminate the rotation problem.  \n\nIn Figure 6.8, in red, we can see the evolution of the, now, non-degenerated triangle. This example can be \n\nfound in the file: interpolation_test_coil_Degenerated_No_Collinear.m. This seems to support our claim. \n\n \n\nFigure 6.8 - From left to right: source geometry without the degenerated triangle, the \n\ninterpolated geometry at 3 different instants and the target geometry. \n\n\n\n \n\n \n\n \n\n \n\n79 \n\n6.2.2 Unwrap Method \n\nThe original method used to remove discontinuities from the rotation angles of 2 neighbour triangles, i.e., \n\nthe unwrap method, depends on the sequence of the angles. The method that computes the interpolation \n\ncomponents is unaware of such dependency and will generate unexpected triangle rotations. \n\nLet A be a list of angles, ?1, \u2026, ?N, |A| > 1. \n\nLet P be the set of all permutations of A and pi, pj the i-th and j-th permutations of P, respectively.  \n\nLet E = ?pi, pj : unwrap(pi) = unwrap(pj). \n\nThen, E is not a tautology. \n\nAn example follows. Given an interval I and a set A of triangles\u2019 rotation angles, then we can obtain the \n\nresults shown in Figure 6.9 and Figure 6.10. \n\n \n\nFigure 6.9 - From left to right: instants 1, 8 and 11. Coil interpolation test during an interval I \n\nwith a carefully chosen permutation of A. Source: interpolation_test_coil_tri_order_2.m. \n\n \n\nFigure 6.10 - From left to right: instants 1, 8 and 11. Coil interpolation test during an interval I \n\nwith a random permutation of A. Source: interpolation_test_coil_tri_order.m. \n\nThis problem requires further analysis and is not yet solved. Experiment suggests that: \n\n? The sequence of the rotation angles should follow the neighbourhood relationships between the \n\ntriangles in the geometry, but not every sequence is suitable. \n\n? The problem will occur on geometries with triangles with rotation angles bigger than a ?, where ? is \n\nprobably ? 2?. \n\n \n\nFigure 6.11 - A sequence of triangles with ids from 1, \u2026, 18. \n\nFor the geometry shown in Figure 6.11: \n\n\n\n \n\n \n\n \n\n \n\n80 \n\nPermutation pi = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}, where 1, \u2026, 18 indicates the \n\nid of the triangle for which each element of pi stores a rotation angle. \n\nPermutation pj = {18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, where 1, \u2026, 18 indicates the \n\nid of the triangle for which each element of pj stores a rotation angle. \n\nPermutation pk = {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1, 2, 3, 4, 5, 6, 7, 8}, where 1, \u2026, 18 indicates the \n\nid of the triangle for which each element of pk stores a rotation angle. \n\nPermutations pi and pj will generate the expected triangles rotations. However, pk will not. Finding the \n\n\u2018ideal\u2019 permutation does not seem to be the ideal solution. What is the correct permutation for more complex \n\ngeometries like the one in Figure 6.12? \n\n \n\nFigure 6.12 - Triangulated geometry of an iceberg. \n\nA possible solution would be to look for discontinuities between pairs of neighbour triangles instead of \n\ntrying to generate a suitable permutation for all of them? \n\n6.2.3 Smoothing Method Relevance \n\nUnder certain conditions the use of the smoothing method seems to have influence on the results obtained \n\nby the interpolation method. Below, Figure 6.13 and Figure 6.14, we can see the results obtained when we \n\ninterpolated an iceberg using and not using the smoothing method, respectively. Note that, the first and last \n\nmeshes have exactly the same boundary on both figures. \n\nIn Figure 6.13 we can notice a considerable effect in which there is an increase of the volume of the \n\ngeometry in the intermediate instants, followed by a decrease of that volume. This growing and shrinking \n\neffect is one of the effects that the triangulation and interpolation methods that we use should eliminate. \n\nIn Figure 6.14 we can see that there is a considerable deformation of the geometry. This result is both \n\nunexpected and undesirable. \n\n\n\n \n\n \n\n \n\n \n\n81 \n\n \n\nFigure 6.13 - Interpolation using the smoothing method. \n\n \n\nFigure 6.14 - Interpolation not using the smoothing method. \n\n6.3 Smoothing Method Performance \n\nThe smoothing method has performance issues even when applied to relatively simple meshes, see Figure \n\n6.15. Intuitively, this problem seems to grow with the number of Steiner points. However, it can also be \n\nrelated to the geometry itself. \n\n \n\nFigure 6.15 - A source and target relatively simple smoothed meshes. \n\nWe obtain the results in Table 6.1 when creating the meshes in Figure 6.15 using MeshGIS. \n\nMethods Used Search Radius Max Number of \n\nIterations \n\nSmoothing \n\nCriteria \n\nExecution \n\nTime (sec) \n\nTriangulation \n\nInterpolation \n\n4 6 Angle 1.1  \n\nTriangulation \n\nSmoothing \n\nInterpolation \n\n4 6 Angle 34.2  \n\n\n\n \n\n \n\n \n\n \n\n82 \n\nTriangulation \n\nInterpolation \n\n2 3 Angle 1.1  \n\nTriangulation \n\nSmoothing \n\nInterpolation \n\n2 3 Angle 27.3  \n\nTable 6.1 - Results from a performance test performed in PostgreSQL using and not using the \n\nsmoothing method. \n\nAs we can see in Table 6.1 this is a performance problem that should be considered for future work. The \n\nsmoothing method allows us to provide the search radius, the maximum number of iterations and the \n\nsmoothing criteria, i.e., angle or area, to be used. Changing these values can improve performance but we did \n\nnot test it thoroughly. \n\n6.4 Continuity \n\nIn this section we discuss continuity issues found during the tests phase. \n\n6.4.1 Mesh Objects \n\nThe notion of continuity for mesh objects is based, amongst other things, on their positions. The position \n\nof a mesh is actually the position of its centroid. While working with real data, we realized that the distance \n\nbetween 2 mesh objects, i.e., the distance between their positions, that are supposed to be continuous, \n\ncomputed using their respective centroids, is some value that can be small or relatively bigger. As a \n\nconsequence, it is hard to find a value to top up that distance. For this reason, this implementation is not \n\nusing the mesh position to establish continuity for mesh objects. \n\nTable 6.2 shows the centroid positions, in the 2D Cartesian plane, at the begin and end instants of 9 \n\ncontinuous unit mesh objects, obtained from real data, and their distances computed at the respective \n\ncontinuity instants. The values shown are truncated and they are represented using an abstract metric unit. \n\nThe centroid computation is only using the boundary points of the respective mesh. The first row represents \n\nthe distance between the 1\u00ba and 2\u00ba unit mesh objects, the second the distance between the 2\u00ba and the 3\u00ba and so \n\non and so forth. \n\nCentroid at the begin Instant Centroid at the end Instant Centroid Distance \n\n1009.17, 1042.75 1011.84, 1052.36 0.00027 \n\n1011.84, 1052.36 1036.94, 1097.33 0.25309 \n\n1036.70, 1097.24 1059.76, 1134.02 1.35299 \n\n1060.62, 1135.06 1063.83, 1151.01 1.31144 \n\n1064.70, 1151.99 1072.77, 1166.77 0.46039 \n\n1073.01, 1167.16 1106.79, 1194.41 0.62456 \n\n1106.43, 1193.91 1125.90, 1237.87 0.25436 \n\n\n\n \n\n \n\n \n\n \n\n83 \n\n1126.15, 1237.94 1126.43, 1248.15 2.19076 \n\n1127.99, 1249.69 1132.02, 1260.76  \n\nTable 6.2 - Centroid positions, in the 2D Cartesian plane, of 9 continuous unit mesh objects, \n\nobtained from real data, and their distances at the continuity instants. \n\n6.4.2 Unit Real Objects \n\nWhen working with real data we realized that it is hard to establish continuity for unit real objects. Unit \n\nreal objects can represent the evolution of different types of quantities, e.g., the area of a moving object, the \n\nperimeter of a moving object and the distance between 2 moving objects. We expect these quantities to be \n\ncontinuous for continuous objects, but the model is not enforcing that. Assuming they are, we need to define \n\na ? for each one of these different types of quantities because they have different natures. The problem \n\nbecomes even harder when we consider the difficulties of finding these ? values.  \n\nAn example follows. Table 6.3 shows the area differences between 9 continuous unit mesh objects, of a \n\nmoving object representing the evolution of an iceberg over a period of time, computed at the instant where \n\ncontinuity is verified, e.g., 0.027 is the difference between the area of the iceberg at the end and begin \n\ninstants of the first and second units, respectively. The results obtained seem to indicate that finding a ? to \n\nestablish continuity for the area of a moving object can be somewhat more difficult. \n\nArea Differences \n\n0.027 \n\n186.746 \n\n631.894 \n\n671.448 \n\n21.500 \n\n129.882 \n\n37.847 \n\n687.485 \n\nTable 6.3 - The area differences between 9 continuous unit mesh objects. \n\nThere is also the possibility that the nature of moving real objects does not impose a notion of continuity \n\non unit real objects. We decided to leave this issue open and in this implementation we do not establish a \n\nnotion of continuity for unit real objects. \n\n6.5 Other Issues \n\n? The use of the STWKT form implies loss of precision. This may have more or less serious \n\nconsequences. For example, to prevent the triangulation method from failing, we treat cases where \n\nthere are cloned or collinear vertices. This is done by changing their positions by a small amount. \n\nThe transformation of an object into the STWKT form can undo these changes due to loss of \n\n\n\n \n\n \n\n \n\n \n\n84 \n\nprecision. As a consequence, it may happen that the triangulation method fails when applied to an \n\nobject constructed from the new STWKT. And in this case, the process for finding and avoiding \n\ncollinear vertices becomes more complex.  To deal with this situation we use 17-digit precision for \n\nthe STWKT form, but it is not guaranteed that this will solve the problem for all cases. As future \n\nwork, we should use a Spatiotemporal Well-Known Binary (STWKB) form instead to avoid loss of \n\nprecision. \n\n? When adding a unit to a moving object using its STWKT form, the validity of the unit's interval \n\nshould be verified in the set of intervals of the moving object\u2019s units before building the unit. This is \n\nparticularly interesting and useful for moving mesh objects and that is because constructing a unit \n\nmesh object is an expensive process. \n\n? In MeshGIS, when we add or remove a unit to or from a moving object we think it makes sense that \n\nthe result of these operations clearly indicates its outcome. However, the implementation of this \n\nstrategy as is involves the transformation of the object resulting from these operations to the \n\nSTWKT form and then, back to a serialized object. This is unacceptable, in particular for moving \n\nmesh objects. When we move from the STWKT form to a serialized object we have to construct all \n\nthe units of that object, i.e., we have to apply the triangulation, smoothing and interpolation \n\nmethods. If we imagine a moving mesh object with dozens of units we can get an idea of the \n\nconsequences of this. The operation to add a unit to a moving mesh no longer uses this strategy. \n\n6.6 Summary \n\nWe discussed the major problems that were found when working with real data. These problems have not \n\nbeen solved and this discussion serves as a reference for future work and discussion. And although we \n\npresent observations, opinions, possible solutions and explanations, they are based on experimentation and \n\nthese problems should be studied and analysed more carefully. Working with real data can potentially help to \n\nunderstand and solve these issues. We also discussed other problems that should be further studied and \n\nanalysed.  \n\n\n\n \n\n \n\n \n\n \n\n85 \n\nCHAPTER 7 \n\n7.  Conclusions and Future Work \n\n7.1 Conclusions \n\nWe proposed a discrete data model for moving objects, in particular moving regions, based on the \n\nconcept of a mesh (a triangulated polygon) and compatible triangulation and rigid interpolation methods. \n\nThis data model has as its main foundations: the abstract data model presented in (R. H. G\u00fcting et al., 2000), \n\nthe discrete data model proposed in (Forlizzi et al., 2000) and the works in (Mesquita, 2013) and (Amaral, \n\n2015). By using this concept and methods we aim to be able to obtain a more realistic representation of the \n\nevolution of moving regions, i.e., a more realistic representation of the changes in position or shape and \n\nextent of moving regions over time. To the best of our knowledge this is the first data model for moving \n\nobjects that uses this concept and methods to represent moving regions. It is not a complete implementation \n\nof the abstract data model that it has as a reference. It only considers polygons without holes and a small sub-\n\nset of the operations on moving objects proposed in (Forlizzi et al., 2000). It does not provide a closed \n\nsystem of operations and it does not consider moving lines and moving collections.    \n\nWe implemented the proposed discrete data model in a C++ library called SPTMesh. It does not \n\nimplement all the operations defined in the model. \n\nWe also implemented a spatiotemporal database extension for PostgreSQL, as a C library, called \n\nMeshGIS that uses SPTMesh, as a proof of concept that SPTMesh works with real applications. \n\nSPTMesh is a framework for moving objects. Its main goals are to provide tools to manipulate and \n\nanalyze moving objects, in particular moving regions. Because SPTMesh is not application specific it can be \n\nused by other applications other than MeshGIS. \n\nMeshGIS makes it possible to store the moving objects provided by SPTMesh on PostgreSQL and to \n\nmanipulate and analyze them using SQL. That is, it makes it possible to take advantage of Database \n\nManagement Systems (DBMSs) to manage moving objects. \n\nSPTMesh follows the architecture of GEOS a well-known and well-established C++ library to manipulate \n\nand analyze spatial objects. \n\nMeshGIS follows the architecture of PostGIS a well-known spatial extension for PostgreSQL. \n\nSPTMesh architecture allows the extension of the library with new triangulation and smoothing methods \n\nin a simple way and provides: predicate operations, set operations, numeric operations and projection \n\n\n\n \n\n \n\n \n\n \n\n86 \n\noperations on moving objects. Furthermore, we can use functions from MeshGIS and PostGIS and compose \n\nthem to provide further value. \n\nSPTMesh and MeshGIS can be used as a framework for future work and investigation on this area. \n\nWe also presented a Spatiotemporal Well-known Text (STWKT) form for moving objects, i.e., a way of \n\nexpressing moving objects in a \u2018standard\u2019 way. \n\nWe tested SPTMesh and MeshGIS using the C++ SPTMesh API and the SQL types and functions that \n\nbind to the types and functions of MeshGIS. We tested, in particular, the triangulation, smoothing and \n\ninterpolation methods implemented in SPTMesh. We used 2 data sets for testing: a set of synthetic data and a \n\nset of real data describing the evolution of 2 icebergs over time. \n\nDuring the testing phase we encountered some unexpected problems, e.g., we realized that the \n\ntriangulation and interpolation methods were unaware of some of the characteristics of the data coming from \n\nthe method that we use to obtain the real data. We also encountered problems when establishing continuity \n\nfor the mesh and UNIT types. Some of these problems remain unsolved in the current implementation and \n\nthey are presented and discussed throughout this dissertation and in particular in chapter 6.  \n\nWe did not perform benchmarking tests but during the testing phase we realized that the smoothing \n\nmethod has performance problems and they are also discussed. \n\nWe encountered several implementation problems during this work. The implementation of SPTMesh \n\nand MeshGIS started from scratch with little information about the best way to implement them. We used the \n\nGEOS and the PostGIS projects as the main references for our implementation. Our main source of \n\ninformation about these projects was its source code. Despite being mature projects with a lot of built in \n\nfunctionality, their source code is not well documented and it was difficult to understand their architectures \n\nand structure, i.e., how they work and their main properties. Another problem was the fact that SPTMesh and \n\nMeshGIS are implemented using different programing languages, C++ and C. These programing languages \n\nhave significant differences and in order to implement these components we need knowledge about these 2 \n\nprograming languages and this is not necessarily a trivial task. \n\nThis implementation has limitations but the results obtained are interesting and seem to indicate that the \n\nuse of the concept of mesh with compatible triangulation and rigid interpolation methods makes some sense \n\nand produces promising results. \n\n7.2 Main Contributions \n\nWe do think that the main contributions of this dissertation are the following: \n\n? We proposed a data model for moving objects that uses concepts and methods that potentially can \n\nobtain a more realistic representation of the evolution of moving objects, in particular moving \n\nregions. We implemented this model in a framework for moving objects and we obtained results that \n\nseem to support this claim. \n\n\n\n \n\n \n\n \n\n \n\n87 \n\n? We implemented a spatiotemporal extension for PostgreSQL and proved that our framework for \n\nmoving objects works and it is not application-dependent. MeshGIS proves that: we can store our \n\nmoving objects in PostgreSQL and manipulate and analyze them using the Structured Query \n\nLanguage (SQL) and we can use functions from MeshGIS and PostGIS and composed them to \n\nobtain further value. \n\n? We implemented a framework that, we think, can be used for future work and investigation in this \n\narea. With this goal in mind we made an effort to document the classes and their functions with \n\nsome level of detail in the source code. \n\n? When working with real data we found some problems and we tried to understand their structure. \n\nWe have a better understanding of \u2018the whole\u2019 and of some of the limitations of the methods that we \n\nare using. \n\n7.3 Future Work \n\nWe don\u2019t present a full working framework for moving objects and there is a lot of work ahead. We think \n\nthat the following issues, not given in any specific order, are major points of interest for future work: \n\n? Solve the problems found for the triangulation and interpolations methods when working with real \n\ndata. Improve the performance of the smoothing method and establish a solid notion of continuity \n\nfor the mesh and UNIT types. \n\n? Decouple the interpolation method from the UnitMesh class. This is partially done and enables the \n\nextension of our framework with different interpolation methods in a simple way. This is interesting \n\nsince it is not proved that there is a single interpolation method that works for all possible scenarios \n\nand it makes it possible to test or integrate other interpolation methods in our framework. \n\n? Provide a Spatiotemporal Well-Known Binary (STWKB) form for MOVING and UNIT types and \n\nestablish a standard for the STWKT and STWKB forms. This avoids the problems of loss of \n\nprecision associated with the use of the STWKT form. \n\n? Provide a closed system of operations. We think that having the mobject and uobject types, i.e., a \n\ntype that can represent any MOVING type and a type that can represent any UNIT type, \n\nrespectively, can help to achieve this goal. \n\n? Associate a precision model with the MOVING types, when applicable. And possibly allow the user \n\nto define: which one should be used or custom precision models. This is interesting because we want \n\nto avoid the loss of precision and its consequences. \n\n? Allow the user to define its own interpolation functions for the mreal and mpoint types. This makes \n\nour framework more powerful and can provide more accurate results for the interpolated values of \n\nthese types. \n\n? Review the SPTMesh methods so that they provide thread safety or reentrancy properties when \n\nrelevant. \n\n\n\n \n\n \n\n \n\n \n\n88 \n\n? Work with dates, locales and time zones. The instant type should represent a specific date with a \n\nlocale and a time zone. We think that it is natural to work with dates independently of its internal \n\nrepresentation in SPTMesh. \n\n  \n\n\n\n \n\n \n\n \n\n \n\n89 \n\nCHAPTER 8 \n\n8.  Bibliography \n\nAlexa, M., Cohen-Or, D., &amp; Levin, D. (2000). As-rigid-as-possible shape interpolation. In Proceedings of the \n\n27th annual conference on Computer graphics and interactive techniques - SIGGRAPH \u201900 (pp. 157\u2013\n\n164). http://doi.org/10.1145/344779.344859 \n\nAmaral, A. (2015). Representation of spatio-temporal data using Compatible Triangulation and Morphing \n\ntechniques. Aveiro University. \n\nBaxter, W., Barla, P., &amp; Anjyo, K. (2008). Rigid shape interpolation using normal equations. In NPAR \u201908 \n\nProceedings of the 6th international symposium on Non-photorealistic animation and rendering (pp. \n\n59\u201364). http://doi.org/http://doi.acm.org/10.1145/1377980.1377993 \n\nBehr, T., Teixeira de Almeida, V., &amp; G\u00fcting, R. H. (2006). Representation of periodic moving objects in \n\ndatabases. Proceedings of the 14th Annual ACM International Symposium on Advances in Geographic \n\nInformation Systems - GIS \u201906, 43. http://doi.org/10.1145/1183471.1183480 \n\nBooth, J., Sistla, P., Wolfson, O., &amp; Cruz, I. F. (2009). A data model for trip planning in multimodal \n\ntransportation systems. Proceedings of the 12th International Conference on Extending Database \n\nTechnology Advances in Database Technology - EDBT \u201909, 994\u20131005. \n\nhttp://doi.org/10.1145/1516360.1516474 \n\nBreunig, M., Turker, C., Bohlen, M. H., Dieker, S., Guting, R. H., Jensen, C. S., \u2026 Scholl, M. (2003). \n\nArchitectures and Implementations of Spatio-temporal Database Management Systems. Spatio-\n\nTemporal Databases: The CHOROCHRONOS Approach, 263\u2013318. http://doi.org/10.1007/978-3-642-\n\n29066-4{_}11 \n\nCotelo Lema, J., Forlizzi, L., Guting, R. H., Nardelli, E., &amp; Schneider, M. (2003). Algorithms for Moving \n\nObjects Databases. The Computer Journal, 46(6), 680\u2013712. http://doi.org/10.1093/comjnl/46.6.680 \n\nDamiani, M. L., &amp; Guting, R. H. (2014). Semantic Trajectories and Beyond, 14\u201316. \n\nhttp://doi.org/10.1109/MDM.2014.57 \n\nDamiani, M. L., Valdes, F., &amp; Guting, R. (2015). Symbolic Trajectories. ACM Transactions on Spatial \n\nAlgorithms and Systems, 1(2), 52. http://doi.org/https://doi.org/10.1145/2786756 \n\nde Almeida, V. T., G\u00fcting, R. H., Behr, T., Ding, Z., Hoffmann, F., &amp; Spiekermann, M. (2004). SECONDO: \n\nAn Extensible DBMS Architecture and Prototype. Informatik-Report 313. Retrieved from \n\nhttp://dna.fernuni-hagen.de/papers/Secondo04.pdf \n\n\n\n \n\n \n\n \n\n \n\n90 \n\nDing, Z., Yang, B., G\u00fcting, R. H., &amp; Li, Y. (2015). Network-Matched Trajectory-Based Moving-Object \n\nDatabase?: Models and Applications. IEEE Transactions on Intelligent Transportation Systems, 16(4), \n\n1918\u20131928. \n\nErwig, M., &amp; Schneider, M. (1999). Developments in spatio-temporal query languages. Proceedings. Tenth \n\nInternational Workshop on Database and Expert Systems Applications. DEXA 99. \n\nhttp://doi.org/10.1109/DEXA.1999.795206 \n\nErwig, M., &amp; Schneider, M. (2002). Stql - A Spatio-Temporal Query Language. Kluwer International Series \n\nin Engineering and Computer Science, 105\u2013126. http://doi.org/citeulike-article-id:4207791 \n\nEtienne, L., Devogele, T., &amp; Bouju, A. (2010). Spatio-Temporal Trajectory Analysis of Mobile Objects \n\nFollowing the Same Itinerary. The International Archives of the Photogrammetry, Remote Sensing and \n\nSpatial Information Sciences, 38(II), 86\u201391. \n\nForlizzi, L., Giiting, R. H., Nardelli, E., &amp; Schneider, M. (2000). A Data Model and Data Structures for \n\nMoving Objects Databases. In Proceedings of the 2000 ACM SIGMOD International Conference on \n\nManagement of Data (pp. 319\u2013330). http://doi.org/http://doi.acm.org/10.1145/342009.335426 \n\nGong, C.-Q. (2011). A New Method for the Morph of Planar Polygons Based on Shape Feature. 2011 \n\nInternational Conference of Information Technology, Computer Engineering and Management \n\nSciences, 7\u201310. http://doi.org/10.1109/ICM.2011.44 \n\nGotsman, C., &amp; Surazhsky, V. (2001). Guaranteed intersection-free polygon morphing. Computers and \n\nGraphics (Pergamon), 25(1), 67\u201375. http://doi.org/10.1016/S0097-8493(00)00108-4 \n\nGotsman, C., &amp; Surazhsky, V. (2004). High quality compatible triangulations. Engineering with Computers \n\n(Vol. 20). http://doi.org/10.1007/s00366-004-0282-6 \n\nGrumbach, S., Rigaux, P., &amp; Segoufin, L. (2001). Spatio-Temporal Data Handling with Constraints, 95\u2013115. \n\nG\u00fcting, R. H., Almeida, V., Ansorge, D., Behr, T., Ding, Z., Hose, T., \u2026 Telle, U. (2005). SECONDO: An \n\nextensible DBMS platform for research prototyping and teaching. Proceedings - International \n\nConference on Data Engineering, 1115\u20131116. http://doi.org/10.1109/ICDE.2005.129 \n\nG\u00fcting, R. H., Behr, T., &amp; Christian, D. (2012). Trajectory Databases. Hagen: Fakult\u00e4t f\u00fcr Mathematik und \n\nInformatik. Retrieved from https://ub-deposit.fernuni-\n\nhagen.de/servlets/MCRFileNodeServlet/mir_derivate_00000801/G\u00fcting_Behr_D\u00fcntgen_Trajectory_D\n\natabases_2012.pdf \n\nG\u00fcting, R. H., Behr, T., &amp; D\u00fcntgen, C. (2010). SECONDO?: A Platform for Moving Objects Database \n\nResearch and for Publishing and Integrating Research Implementations. Bulletin of the IEEE Computer \n\nSociety Technical Committee on Data Engineering, 33(2), 56\u201363. \n\nGuting, R. H., Bohlen, M., Erwig, M., Jensen, C., Lorentzos, N., Nardelli, E., \u2026 Viqueira, J. (2003). Spatio -\n\ntemporal models and languages: An approach based on constraints. Spatio-Temporal Databases, 177\u2013\n\n201. http://doi.org/10.1007/978-3-540-45081-8_4 \n\n\n\n \n\n \n\n \n\n \n\n91 \n\nG\u00fcting, R. H., B\u00f6hlen, M. H., Erwig, M., Jensen, C. S., Lorentzos, N. A., Schneider, M., &amp; Vazirgiannis, M. \n\n(2000). A Foundation for Representing and Querying Moving Objects. ACM Trans. Database Systems, \n\n25(1), 1\u201342. http://doi.org/10.1145/352958.352963 \n\nG\u00fcting, R. H., De Almeida, V. T., &amp; Ding, Z. (2006). Modeling and querying moving objects in networks. \n\nVLDB Journal, 15(2), 165\u2013190. http://doi.org/10.1007/s00778-005-0152-x \n\nGuting, R., &amp; Lu, J. (2013). Parallel SECONDO Practical and Efficient Mobility Data Processing in the \n\nCloud. In IEEE International Conference on Big Data (pp. 17\u201325). \n\nG\u00fcting, R., &amp; Schneider, M. (2005). Moving Objects Databases. (J. Gray, Ed.). Morgan Kaufmann. \n\nHaesevoets, S., &amp; Kuijpers, B. (2004). Time-dependent affine triangulation of spatio-temporal data. \n\nProceedings of the 12th Annual ACM International Workshop on Geographic Information Systems - \n\nGIS \u201904, 57. http://doi.org/10.1145/1032222.1032233 \n\nHartmut, R., Zhiming, D., &amp; Almeida, V. T. (2006). Modeling and querying moving objects in networks, 15, \n\n165\u2013190. http://doi.org/10.1007/s00778-005-0152-x \n\nHeinz, F., &amp; G\u00fcting, R. H. (2016). Robust high-quality interpolation of regions to moving regions. \n\nGeoInformatica, 20(3), 385\u2013413. http://doi.org/10.1007/s10707-015-0240-z \n\nHurter, C., Andrienko, G., Andrienko, N., G, R. H., &amp; Sakr, M. (2013). Air Traffic Analysis. Mobility data: \n\nmodeling, management, and understanding. Cambridge University Press. \n\nJin, P., &amp; Sun, P. (2008). OSTM: A Spatiotemporal Extension to Oracle. Networked Computing and \n\nAdvanced Information Management, 2008. NCM \u201908. Fourth International Conference on. \n\nhttp://doi.org/10.1109/NCM.2008.31 \n\nJin, P., Yue, L., &amp; Gong, Y. (2005). Research on a Unified Spatiotemporal Data Model. Symposium on \n\nSpatial-temporal Modeling. Retrieved from \n\nhttp://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.184.1303&amp;rep=rep1&amp;type=pdf \n\nKim, D. H., Ryu, K. H., &amp; Kim, H. S. (2000). Spatiotemporal database model and query language. Journal of \n\nSystems and Software, 55(2), 129\u2013149. http://doi.org/10.1016/S0164-1212(00)00066-2 \n\nKim, D., Ryu, K., &amp; Park, C. (2002). Design and implementation of spatiotemporal database query \n\nprocessing system. Journal of Systems and Software, 60, 37\u201349. http://doi.org/10.1016/S0164-\n\n1212(01)00078-4 \n\nKim, K.-S., Ogawa, H., Nakamura, A., &amp; Kojima, I. (2014). Sophy: A Morphological Framework for \n\nStructuring Geo-referenced Social Media. Proceedings of the 7th ACM SIGSPATIAL International \n\nWorkshop on Location-Based Social Networks, 31\u201340. http://doi.org/10.1145/2755492.2755498 \n\nMatos, L., Moreira, J., &amp; Carvalho, A. (2012). A Spatiotemporal Extension for Dealing with Moving Objects \n\nwith Extent in Oracle 11G. SIGAPP Appl. Comput. Rev., 12(2), 7\u201317. \n\nhttp://doi.org/10.1145/2340416.2340417 \n\n\n\n \n\n \n\n \n\n \n\n92 \n\nMcKenney, M., Viswanadham, S. C., &amp; Littman, E. (2014). The cmr model of moving regions. Proceedings \n\nof the 5th ACM SIGSPATIAL International Workshop on GeoStreaming, 62\u201371. \n\nhttp://doi.org/10.1145/2676552.2676564 \n\nMckenney, M., &amp; Webb, J. (2010). Extracting Moving Regions from Spatial Data. In Proceedings of the 18th \n\nSIGSPATIAL International Conference on Advances in Geographic Information Systems (pp. 438\u2013\n\n441). San Jose, California. http://doi.org/10.1145/1869790.1869856 \n\nMckennney, M., &amp; Frye, R. (2015). Generating Moving Regions from Snapshots of Complex Regions. ACM \n\nTrans. Spatial Algorithms Systems, 1(1), 1\u201330. http://doi.org/10.1145/2774220 \n\nMesquita, P. (2013). Morphing Techniques For Representation of Geographical Moving Objects. \n\nUniversidade de Aveiro. \n\nNidzwetzki, J., &amp; G\u00fcting, R. (2016). DISTRIBUTED SECONDO: An extensible highly available and \n\nscalable database management system. INFORMATIK BERICHTE 371 \u2013 05/2016. \n\nNoh, S. (2004). Literature Review on Temporal, Spatial, and Spatiotemporal Data Models. Computer Science \n\nTechnical Reports. Paper 150, (April 2000), 1\u201339. Retrieved from \n\nhttp://archives.cs.iastate.edu/documents/disk0/00/00/03/50/00000350-00/literature_review(TR04-\n\n12).pdf \n\nOGC Moving Features. (2016). OGC Moving Features. Retrieved September 10, 2016, from \n\nhttp://www.opengeospatial.org/standards/movingfeatures \n\nOGC Simple Features. (2016). OGC Simple Feature Access - Part 1: Common Architecture. Retrieved \n\nSeptember 10, 2016, from http://www.opengeospatial.org/standards/sfa \n\nPaulo, L. M. (2012). Morphing techniques in spatiotemporal databases. Universidade de Aveiro. \n\nPelekis, N. (2002). STAU: A Spatio-Temporal Extension for the Oracle DBMS. UMIST. Retrieved from \n\nhttps://books.google.pt/books?id=tHgjcgAACAAJ \n\nPelekis, N., Frentzos, E., Giatrakos, N., &amp; Theodoridis, Y. (2008). HERMES: Aggregative LBS via a \n\nTrajectory DB Engine. In Proceedings of the 2008 ACM SIGMOD International Conference on \n\nManagement of Data (pp. 1255\u20131258). New York, NY, USA: ACM. \n\nhttp://doi.org/10.1145/1376616.1376748 \n\nPelekis, N., Frentzos, E., Giatrakos, N., &amp; Theodoridis, Y. (2010). Supporting Movement in ORDBMS \u2013 the \n\nHERMES MOD Engine. Hellas. \n\nPelekis, N., Frentzos, E., Giatrakos, N., &amp; Theodoridis, Y. (2015). H ERMES?: A Trajectory DB Engine for \n\nMobility-Centric Applications. International Journal of Knowledge-Based Organizations, 5(2), 19\u201341. \n\nhttp://doi.org/10.4018/ijkbo.2015040102 \n\nPelekis, N., &amp; Theodoridis, Y. (2006). Boosting location-based services with a moving object database \n\nengine. Proceedings of the 5th ACM International Workshop on Data Engineering for Wireless and \n\n\n\n \n\n \n\n \n\n \n\n93 \n\nMobile Access - MobiDE \u201906, 3. http://doi.org/10.1145/1140104.1140108 \n\nPelekis, N., &amp; Theodoridis, Y. (2007). An Oracle Data Cartridge for Moving Objects. UNIPI-ISL-TR-2010-\n\n01. Hellas. Retrieved from http://isl.cs.unipi.gr/publications.html \n\nPelekis, N., Theodoridis, Y., Vosinakis, S., &amp; Panayiotopoulos, T. (2006). Hermes - A Framework for \n\nLocation-Based Data Managment. In EDBT\u201906 Proceedings of the 10th international conference on \n\nAdvances in Database Technology (pp. 1130\u20131134). Munich, Germany. \n\nhttp://doi.org/10.1007/11687238_75 \n\nPelekis, N., Theodoulidis, B., Kopanakis, I., &amp; Theodoridis, Y. (2004). Literature review of spatio-temporal \n\ndatabase models. The Knowledge Engineering Review, 19(03), 1\u201334. \n\nhttp://doi.org/10.1017/S026988890400013X \n\nPopa, I. S., &amp; Zeitouni, K. (2012). Modeling and Querying Mobile Location Sensor Data. In Proceedings of \n\nthe 4th Int. Conference on Advanced Geographic Information Systems, Applications, and Services, \n\nIARIA (pp. 222\u2013231). \n\nPozzani, G., &amp; Combi, C. (2012). On the semantics of ST4SQL, a multidimensional spatio-temporal query \n\nlanguage. In Proceedings of the 16th International Database Engineering &amp; Applications Sysmposium \n\non - IDEAS \u201912 (pp. 222\u2013229). New York, New York, USA: ACM Press. \n\nhttp://doi.org/10.1145/2351476.2351504 \n\nPraing, R., &amp; Schneider, M. (2007). Modeling historical and future movements of spatio-temporal objects in \n\nmoving objects databases. Proceedings of the Sixteenth ACM Conference on Conference on \n\nInformation and Knowledge Management - CIKM \u201907, 183. http://doi.org/10.1145/1321440.1321469 \n\nPrasad Sistla, A., Wolfson, O., Chamberlain, S., &amp; Dao, S. (1997). Modeling and querying moving objects. \n\nIn Proceedings 13th International Conference on Data Engineering (pp. 422\u2013432). IEEE Comput. Soc. \n\nPress. http://doi.org/10.1109/ICDE.1997.581973 \n\nRossSea Subsets. (2004). Retrieved September 20, 2016, from \n\nhttp://rapidfire.sci.gsfc.nasa.gov/imagery/subsets/?project=antarctica&amp;subset=RossSea&amp;date=11/15/20 \n\nSanderson, C., &amp; Curtin, R. (2016). Armadillo?: a template-based C ++ library for linear algebra. The Journal \n\nof Open Source Software, 1. http://doi.org/10.1016/j.csda.2013.02.005.Intel. \n\nT\u00f8ssebro, E., &amp; G\u00fcting, R. (2001). Creating Representations for Continuously Moving Regions from \n\nObservations. In Proceedings of the 7th International Symposium on Advances in Spatial and \n\nTemporal Databases (pp. 321\u2013344). Springer-Verlag Berlin Heidelberg. Retrieved from \n\nhttp://159.226.100.157/sess_11293/http182dx.doi.org/10.1007/3-540-47724-1_17 \n\nT\u00f8ssebro, E., &amp; Nyg\u00e5rd, M. (2011). Representing topological relationships for spatiotemporal objects. \n\nGeoInformatica, 15(4), 633\u2013661. http://doi.org/10.1007/s10707-010-0120-5 \n\nViqueira, J. R. R., &amp; Lorentzos, N. A. (2007). SQL extension for spatio-temporal data. VLDB Journal, 16(2), \n\n179\u2013200. http://doi.org/10.1007/s00778-005-0161-9 \n\n\n\n \n\n \n\n \n\n \n\n94 \n\nWahid, M. T., Kamruzzaman, A. Z. M., &amp; Shariff, A. R. M. (2006). Spatio-Temporal Object Relational for \n\nBiodiversity System (STORe-Biodi). International Journal of Computer Science and Network Security, \n\n6(9A), 45\u201353. \n\nXinmin Chen, C., &amp; Zaniolo, C. (2000). SQLST?: A Spatio-Temporal Data Model and Query Language. \n\nConceptual Modeling \u2014 ER 2000, 1920, 111\u2013182. Retrieved from http://dx.doi.org/10.1007/3-540-\n\n45393-8_8 \n\nXu, J. (2012). Moving Objects with Multiple Transportation Modes. FernUniversit\u00e4t in Hagen. \n\nXu, J., &amp; G\u00fcting, R. H. (2012). Manage and query generic moving objects in SECONDO. Proceedings of the \n\nVLDB Endowment, 5(12), 2002\u20132005. http://doi.org/10.14778/2367502.2367558 \n\nZhao, L., Jin, P., Zhang, L., Wang, H., &amp; Lin, S. (2011). Developing an Oracle-Based Spatio-Temporal \n\nInformation Management System. In International Conference on Database Systems for Advanced \n\nApplications (pp. 168\u2013176). http://doi.org/https://doi.org/10.1007/978-3-642-20244-5_16 \n\nZheng, Y., Zhang, L., Ma, Z., Xie, X., &amp; Ma, W.-Y. (2011). Recommending friends and locations based on \n\nindividual location history. ACM Transactions on the Web, 5(1), 1\u201344. \n\nhttp://doi.org/10.1145/1921591.1921596"}]}}}