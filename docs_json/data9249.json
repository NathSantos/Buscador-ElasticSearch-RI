{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.12965"}, {"@name": "filename", "#text": "18778_arquivo6881_1.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Universidade Federal de Pernambuco\nCentro de Inform\u00e1tica\n\nP\u00f3s-gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o\n\nSystematic Development of Trustworthy\nComponent-based Systems\n\nRodrigo Teixeira Ramos\n\nTese de Doutorado\n\nRecife\nAgosto de 2011\n\n\n\nUniversidade Federal de Pernambuco\nCentro de Inform\u00e1tica\n\nRodrigo Teixeira Ramos\n\nSystematic Development of Trustworthy Component-based\nSystems\n\nTrabalho apresentado ao Programa de P\u00f3s-gradua\u00e7\u00e3o em\nCi\u00eancia da Computa\u00e7\u00e3o do Centro de Inform\u00e1tica da Uni-\nversidade Federal de Pernambuco como requisito parcial\npara obten\u00e7\u00e3o do grau de Doutor em Ci\u00eancia da Com-\nputa\u00e7\u00e3o.\n\nOrientador: Augusto Cezar Alves Sampaio\nCo-orientador: Alexandre Cabral Mota\n\nRecife\nAgosto de 2011\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n\n \n \n \n \n\n \n \n \n  \n  \n\n                       Cataloga\u00e7\u00e3o na fonte \n       Bibliotec\u00e1ria Jane Souto Maior, CRB4-571  \n  \n \nRamos, Rodrigo Teixeira                  \n       Systematic Development of Trustworthy \nComponent-based Systems / Rodrigo Teixeira Ramos - \nRecife: O Autor, 2011. \n       xi, 157  folhas : il., fig. \n \n       Orientador: Augusto Cezar Alves Sampaio. \n       Tese (doutorado) - Universidade Federal de \nPernambuco. CIn, Ci\u00eancia da Computa\u00e7\u00e3o, 2011. \n \n        Inclui bibliografia e ap\u00eandice. \n \n        1. Engenharia de software. 2. M\u00e9todos formais. 3. \nVerifica\u00e7\u00e3o de sistemas. 4. Verifica\u00e7\u00e3o por constru\u00e7\u00e3o. I. \nSampaio, Augusto Cezar Alves (orientador).  II. T\u00edtulo. \n         \n          005.1                     CDD (22. ed.)                   MEI2011 \u2013 \n133 \n \n \n \n \n\n\n\n\n\nI dedicate this work to my parents, who always offered me\ntheir love, care and support.\n\n\n\nAcknowledgements\n\nI would like to thank all those who supported me in my doctoral study and the work on my\nthesis.\n\nFirst and foremost, I am grateful to my parents and my wife, whose support, love and\npatience made this work possible. I am thankful to my mother for always motivating me to\nrealise my dreams. I thank my father for showing the importance of education. Both were\nconfronted with a difficult life since they were very young, and made a better life for our\nfamily through hard work and dedication. I am also very lucky to have found my great love,\nmy wife Renata, who has taught me the pleasure of life beyond the academia.\n\nI am deeply indebted to my advisors Augusto Sampaio and Alexandre Mota for the help and\ncounselling received all these years. They have introduced me to the life of research, ten yeas\nago. Since then, they have shared with me valuable advices, and more importantly friendship.\nThank you!\n\nThe Centro de Inform\u00e1tica at Universidade Federal de Pernambuco proved to be a very\npleasant environment where to work. I appreciate the office mates and friends I made there for\nall discussions and the pleasant time I spent with.\n\nFor their invaluable suggestions and timely advices, I am grateful to the professors Ana\nCristina Melo, David Deharbe, Juliano Iyoda, Marcio Cornelio and Paulo Borba, the members\nof my doctoral evaluation committee. I am also in gratitude to the professors Zhiming Liu,\nJean-Marc Jezequel and Olivier Barais for receiving me as an intern in their institutes during\nthe time of my studies. These experiences strongly influenced on the result of my work.\n\nFinally, my thanks go to the institute that provided financial support for my research work.\nThrough my doctoral study, my work was partially supported by CAPES \u2013 Coordena\u00e7\u00e3o de\nAperfei\u00e7oamento de Pessoal de N\u00edvel Superior.\n\niv\n\n\n\nResumo\n\nApesar de componentes serem tratados como unidades b\u00e1sicas de composi\u00e7\u00e3o no desenvolvi-\nmento baseado em componentes (CBD), para que eles obtenham um disseminado status de\nserem facilmente conectados como \u2018pe\u00e7as de lego\u2019 a integra\u00e7\u00e3o de componentes precisa ser\ncuidadosamente projetada, sistematizada e verificada; somente isto poder\u00e1 garantir arquiteturas\nconfi\u00e1veis. Al\u00e9m dos argumentos gerais sobre redu\u00e7\u00e3o de custo atrav\u00e9s de reuso, abordagens\nCBD precisam oferecer uma interessante, e frut\u00edfera, oportunidade para o desenvolvimento de\nsistemas cr\u00edticos de alta qualidade e vi\u00e1vel no contexto industrial.\n\nPara alcan\u00e7ar esta meta, propomos neste trabalho uma abordagem sistematizada para a\nconstru\u00e7\u00e3o de sistemas baseados em componentes (CBS) confi\u00e1veis. A abordagem foca na\nrealiza\u00e7\u00e3o de an\u00e1lises que consideram preocupa\u00e7\u00f5es de engenharia no CBD. Ela se baseia em\num modelo de componentes que caracteriza os blocos de constru\u00e7\u00e3o de nossa abordagem de\ndesenvolvimento, e que imp\u00f5e as restri\u00e7\u00f5es necess\u00e1rias para sua intera\u00e7\u00e3o segura. Al\u00e9m disto,\ndefinimos restri\u00e7\u00f5es de constru\u00e7\u00e3o para o nosso modelo de componentes, baseadas em regras\nde composi\u00e7\u00e3o para componentes. Estas permitem verificar quando dois componentes s\u00e3o\ncompat\u00edveis para trocarem informa\u00e7\u00f5es.\n\nAs regras de composi\u00e7\u00e3o compreendem um m\u00e9todo sistematizado para preservar, por cons-\ntru\u00e7\u00e3o, propriedades comportamentais em composi\u00e7\u00f5es de componentes; em particular, fo-\ncamos na preserva\u00e7\u00e3o de progresso local e da aus\u00eancia de deadlock nas composi\u00e7\u00f5es. Como\nconseq\u00fc\u00eancia, \u00e9 poss\u00edvel prever o comportamento de uma vasta gama de CBS, antes de sua im-\nplementa\u00e7\u00e3o, com base em propriedades conhecidas do sistema. Em nossa abordagem, tamb\u00e9m\npropomos alternativas de verifica\u00e7\u00e3o mais amenas: a) predi\u00e7\u00f5es de condi\u00e7\u00f5es de composi\u00e7\u00e3o\nbaseadas na an\u00e1lise de metadados de componentes; b) simplifica\u00e7\u00f5es em verifica\u00e7\u00f5es de com-\nponente associados a estilos arquiteturais espec\u00edficos.\n\nToda a abordagem \u00e9 apoiada pela \u00e1lgebra de processos CSP, que oferece modelos sem\u00e2n-\nticos que suportam uma vasta gama de verifica\u00e7\u00f5es e compara\u00e7\u00f5es de processos. Al\u00e9m disto,\nilustramos a aplica\u00e7\u00e3o desta abordagem atrav\u00e9s de dois estudos de caso, que focam em difer-\nentes aspectos da nossa abordagem, e verificamos mecanicamente a preserva\u00e7\u00e3o de proprieda-\ndes comportamentais de componentes na evolu\u00e7\u00e3o dessas aplica\u00e7\u00f5es.\n\nPalavras-chave: Componentes de software, corre\u00e7\u00e3o por constru\u00e7\u00e3o, previsibilidade na com-\nposi\u00e7\u00e3o, CSP.\n\nv\n\n\n\nAbstract\n\nIn component-based development (CBD), components are taken as units of composition. Nev-\nertheless, to achieve the widely disseminated status of components being plugged together as\nsimple \u2018Lego Pieces\u2019, the integration of components must be carefully designed, systematised\nand verified; only this can ensure reliable architectures. Beyond the general arguments about\nsavings by reuse, CBD approaches must offer an interesting, and fruitful, opportunity for high-\nquality critical systems development that is feasible in an industrial context.\n\nTo achieve this goal, in this work, we propose a systematic approach to build trustworthy\ncomponent-based systems. The approach focuses on performing analyses that are intended to\naddress engineering concerns on CBD. It relies on a component model which characterises\nthe building blocks of our systematic development approach, and imposes the necessary con-\nstraints for their safe interaction. Moreover, we define constructive constraints for development\nactivities in this component model. The constructive constraints for our component architec-\ntural model are based on composition rules for components. These notions allow checking, for\ninstance, whether two components are compatible for them to interoperate.\n\nThe composition rules comprise a systematic method to preserve behavioural properties by\nconstruction in component composition; in special, we focus on the preservation of deadlock-\nfreedom and local progress in compositions. As a consequence, it is possible to predict the\nbehaviour of a wide range of component-based systems prior to their implementation, based\non known properties of the system components. In addition, lightweight alternatives for heavy\nverifications are proposed in two ways on this approach: a) verifications of composition side\nconditions are improved by carrying out partial verification results on component metadata\nthroughout component compositions; b) in the second alternative, simplified alternative verifi-\ncations are proposed for components in specific architectural styles.\n\nThe entire approach is underpinned by the CSP process algebra, which offers rich semantic\nmodels that support a wide range of process verification, and comparisons. We illustrate the\napplication of our approach through two case studies, which focus on different aspects of our\napproach, and we mechanically verify the preservation of behavioural component properties in\nthe evolution of such applications.\n\nKeywords: Software components, correction by construction, composition predictability,\nCSP.\n\nvi\n\n\n\nContents\n\n1 Introduction 1\n1.1 Some research opportunities 2\n1.2 The approach and contributions 3\n1.3 Thesis outline 4\n\n2 Background on componentware 6\n2.1 Component-based development 7\n2.2 Software architecture 9\n\n2.2.1 Component models, technologies and frameworks 10\n2.2.2 Software component contracts 12\n\n2.3 Formal methods on components 13\n2.4 Desiderata for component-based critical systems 14\n\n3 Specification and refinement of concurrent systems 17\n3.1 Process algebra 17\n3.2 CSP syntax 18\n3.3 CSP semantic models 23\n\n3.3.1 Traces model 23\n3.3.2 Stable failure model 25\n3.3.3 Failure/divergence model 28\n\n4 I/O processes and communication protocols 31\n4.1 I/O processes 32\n4.2 Communication protocols 37\n\n4.2.1 Protocol compatibility 41\n4.2.1.1 Verifying compatibility via process refinement 43\n\n4.3 Buffering 47\n4.3.1 I/O buffers 48\n4.3.2 Buffer tolerance 49\n4.3.3 Buffering self-injection 53\n\n4.4 Safe hiding 57\n\n5 The BRIC component model 59\n5.1 A component-based system example 60\n5.2 BRIC component model 60\n\n5.2.1 Interfaces 60\n\nvii\n\n\n\nCONTENTS viii\n\n5.2.2 Regular components 62\n5.2.3 Connectors 66\n5.2.4 Composition 67\n5.2.5 Wrapping 71\n\n5.3 Architectural styles 72\n5.3.1 Interaction components 73\n5.3.2 Naive client-servers 75\n5.3.3 Protocol oriented components 75\n\n5.4 BRICK components 76\n\n6 A rigorous strategy for component compositions 80\n6.1 Local analysis 80\n\n6.1.1 Desirable quality attributes 81\n6.2 Composition rules 83\n\n6.2.1 General composition rules 83\n6.2.2 Trustworthy component systems 89\n6.2.3 Rule compositionality 90\n\n6.3 Verification improvements using architectural styles 93\n6.3.1 Wrapping interactions 93\n6.3.2 Improving composition support using component metadata 95\n\n7 Case studies 99\n7.1 The dining philosophers example 99\n7.2 A routing coordinator example 107\n\n8 Conclusions, related and future work 113\n8.1 Summary 114\n8.2 Related work 116\n\n8.2.1 Component models 116\n8.2.2 Reasoning model 118\n\n8.3 Future work 122\n\nA Relation between protocol compatibility and conflict freedom 125\n\nB Proofs of composition rules with metadata 129\n\nC Cases study in FDR 138\nC.1 FDR-CSP 138\nC.2 Auxiliary processes 139\nC.3 The dining philosopher\u2019s example 140\nC.4 Routing coordination 143\n\n\n\nList of Figures\n\n2.1 Bank Decomposition [ABB+01]. 8\n\n5.1 An example of a simple ATM System. 60\n5.2 The Client behaviour. 64\n5.3 Composition using a buffer 68\n\n6.1 Three composition rules proposed in this work. 83\n\n7.1 The Dining Philosophers Problem 100\n7.2 Interleave of Philosophers 103\n7.3 Communication between philosophers and their left forks 104\n7.4 Communication between philosophers and their right forks 105\n7.5 Communication of the last philosopher and his left fork 106\n7.6 Communication of between all philosophers and their forks 107\n7.7 Case Study: A more elaborate ATM System. 108\n7.8 The composition steps of basic connectors to form the network of connectors. 111\n\nix\n\n\n\nList of Definitions\n\n3.1 Definition (Traces refinement) 23\n3.2 Definition (Stable failure refinement) 26\n3.3 Definition (Deadlock-free process) 26\n3.4 Definition (Failures/divergences refinement) 29\n\n4.1 Definition (I/O channels) 32\n4.2 Definition (Process input and output events) 32\n4.3 Definition (Input determinism) 32\n4.4 Definition (Strong output decisiveness) 34\n4.5 Definition (I/O process) 37\n4.6 Definition (Communication protocol) 37\n4.7 Definition (Projection) 39\n4.8 Definition (Protocol implementation) 40\n4.9 Definition (Protocol satisfaction) 40\n4.10 Definition (Equivalent protocols) 40\n4.11 Definition (Conjugate protocols) 41\n4.12 Definition (Protocol compatibility) 41\n4.13 Definition (Strong protocol compatibility) 42\n4.14 Definition (Dual protocol) 43\n4.15 Definition (Dual protocol implementation) 43\n4.16 Definition (Communication context process) 45\n4.17 Definition (Communication context process implementation) 45\n4.18 Definition (I/O confluence) 50\n4.19 Definition (Finite output property) 52\n4.20 Definition (Buffering self-injection compatibility) 53\n4.21 Definition (Decoupled channels) 56\n4.22 Definition (Safe hiding) 57\n\n5.1 Definition (I/O type) 60\n5.2 Definition (Interface) 61\n5.3 Definition (Component contract) 62\n5.4 Definition (Component contract instantiation) 66\n5.5 Definition (Abstract connector) 66\n5.6 Definition (Connector instantiation) 67\n5.7 Definition (Asynchronous binary composition) 69\n5.8 Definition (Asynchronous unary composition) 70\n\nx\n\n\n\nLIST OF DEFINITIONS xi\n\n5.9 Definition (Wrapping) 72\n5.10 Definition (Interaction patterns) 73\n5.11 Definition (Interaction process) 74\n5.12 Definition (Interaction component) 74\n5.13 Definition (Default interaction component implementation) 74\n5.14 Definition (Naive client-server component) 75\n5.15 Definition (Protocol oriented component) 75\n5.16 Definition (Enriched component contract) 77\n5.17 Definition (Enrich Component Contract) 79\n\n6.1 Definition (Service conformance) 81\n6.2 Definition (Interleave composition) 84\n6.3 Definition (Communication composition) 85\n6.4 Definition (Feedback composition) 87\n6.5 Definition (Reflexive composition) 88\n6.6 Definition (Extended feedback composition) 90\n6.7 Definition (Extended communication composition) 91\n6.8 Definition (Interaction channels) 94\n6.9 Definition (Wrapping interaction) 94\n6.10 Definition (Enriched interleaving composition) 95\n6.11 Definition (Enriched communication composition) 96\n6.12 Definition (Enriched feedback composition) 97\n6.13 Definition (Enriched reflexive composition) 98\nA.1 Definition (Deadlock state) 126\nA.2 Definition (Strong conflict) 126\n\n\n\nCHAPTER 1\n\nIntroduction\n\nAlthough component-based system development (CBSD) has been around for a long time\n[Mah90], over the last decade it has re-emerged as a promising paradigm to deal with the\never increasing need for mastering complexity, evolution and reuse in the design of computer\nbased systems. The basic motivation for this paradigm is to replace conventional programming\nwith the composition and configuration of reusable and independent units, called components.\n\nNevertheless, in order to ensure the success of the component-based method, it is es-\nsential that we trust in the behaviour of the components and, furthermore, of the systems\nbased on them. Such trustworthiness is even more important in critical applications. For\ninstance, avionics systems must have high reliability and continue to operate upon a fail-\nure [MJG+10], autonomous agents in a manufacturing system must correctly obey their sched-\nule [Weh00, BGL+08]. Errors in these systems are caused not only by failures of individual\ncomponents, but by dysfunctional interactions between non-failed components.\n\nThe reason of dysfunctional interactions is that real industrial components do not always\nfit together like \u2018Lego Pieces\u2019, or just using a simple glue code. Integration solutions are often\ndeveloped in an ad hoc manner, in which incompatibilities are not discovered until their side\neffects emerge during implementation [HGK+06]. Critical issues for system construction are\nrelated to the design of the communication-based interaction mechanisms that permit compo-\nnents to work together [Spi04]. The correct design of these elements is critical; otherwise the\nsystem may malfunction in subtle ways or may not work at all. This concern is even more acute\nwhen a group of components are put together and coordinated to accomplish a collective set of\ntasks [PA98]. Therefore, it is crucial to verify whether Component Based Systems (CBS) sat-\nisfy some desired properties. In fact, most dysfunctional interactions are originated by classical\nproblems in concurrent systems, such as deadlock and livelock.\n\nSafety-related properties, including deadlock- and livelock-freedom, are emergent system\nattributes [Lev95]. In other words, these are properties that emerge from the interactions among\nmultiple system components, and their analysis might not reside in any component system\nin particular. For this reason, emergent properties cannot be tested directly in an efficient\nway. In [Min07, MCMM08], it was shown that deciding deadlock-freedom and liveness in\ninteraction systems is NP-hard. Therefore, it is desirable to establish (stronger) conditions that\nare easier to test and entail the desired properties [GGMC+06].\n\nTo help development, these conditions should be intrinsic to the design and implementation\nrules used by component developers and application integrators [Wal03, MH05]. In this way,\na system engineer, who is not an expert in analytic theory, can reason about properties of the\ndesign.\n\nProblems are inevitable after all. It is impossible to foresee every possible situation in\n\n1\n\n\n\n1.1 SOME RESEARCH OPPORTUNITIES 2\n\nwhich a given system might be used. Problems will surely arise when two or more systems that\nhave not interfaced together before are integrated. The sooner and easier these problems are\nidentified and resolved, the greater is the success of the component based method.\n\n1.1 Some research opportunities\n\nUnfortunately, it is at present difficult to verify important properties of component-based sys-\ntems in industry. Most well known industrial component models, which define components and\nhow they integrate, are widely based on simple, low-level granularity components (EJB [DK06]\nand COM/DCOM [Mic11]). These are represented by syntactical interfaces, which lack be-\nhavioural information and restrict component verifications [FG03].\n\nIronically, the idea of higher-level granularity component models, such as Wright [AG97,\nADG98], Fractal [BCL+06] and SOFA [BHP06], has been still waiting for full commercial\nexploitation [Pla05]. Higher-level granularity component models complement the syntactical\ninformation of a component with behaviour. The behaviour can be discriminated between\ndifferent kinds, usually associated to the component, port and assembly behaviour [HJK10].\nThe former, also called protocol, represents the whole observable behaviour of the component.\nThe behaviour associated to a port, also called port-protocol, is those observed from one point\nof interaction of the component. The latter is related to the established interaction of one\ncomponent with another.\n\nNevertheless, formal description methods are getting more and more attention in the devel-\nopment of critical systems because of their accuracy and the use of theorem proving mecha-\nnisms [Chi09]. Much effort is devoted to the correctness of component-based systems (CBS)\n[AG97, BCD02, HLL06b, Sif10, CZ07]. These works define a component model with a precise\nmeaning, or adopt a formal notation to specify the system. This makes it possible to analyse\nthe systems and to provide tool support in verifications.\n\nThe practice to date has been to verify and validate the system after it has been built\n[HLL06b, PV02, CCH+09] \u2013 the system is designed, implemented and then verified and vali-\ndated. The major issue is the high cost to fix a problem that is found in a late stage in develop-\nment, especially when the problem requires redesigning the system to meet reliability or some\nother quality attribute requirement.\n\nInstead of verifying the entire system, other more promising approaches focus on iteratively\nidentifing problems in compositions. However, in most approaches the cost of subsequent com-\npositions is not alleviated by the results of the previous ones [ADG98, BCD02, CK96]. Every\ncomposition is taken as a monolithic system for verification, and properties of its constituting\nparts are not considered. Verification methods do not take advantage of the hierarchical struc-\nture of component-based systems. In other words, these methods are not compositional, and\nhave scalability problems by not using local analysis when this is possible.\n\n\n\n1.2 THE APPROACH AND CONTRIBUTIONS 3\n\n1.2 The approach and contributions\n\nThis thesis describes a theoretical foundation for the development of correct component-based\nsystems (CBS). We propose a correct by construction strategy for ensuring the preservation\nof properties of a CBS from proved properties of its interaction model and of its components.\nWe consider the freedom of deadlock and livelock. Although we focus on these properties, the\nstrategy presented here can be applied to predict other safety and liveness properties. Moreover,\nthe ideas in this thesis can be transferred to other formal models, and support the implementa-\ntion of practical tools for component-based development.\n\nThis approach is intended to address engineering concerns, and make the expertise on cor-\nrectness available to engineers who are not experts in understanding the origin of dysfunctional\ninteractions between non-failed components in the system. Moreover, we claim that a construc-\ntive approach, in opposition to a posteriori verification, is more suitable to component based\nsystems. It preserves quality attributes of the system by construction, and identifies problems\nearly in the design phase. Moreover, we use local analysis, when this is possible, to scale the\nverifications in our approach.\n\nTo underpin this approach, we propose important design constraints. Satisfying these con-\nstraints at development, we can certainly trust on the resulting system. Part of these constraints\ncomprises our component model for components. It characterises which kinds of components,\nas well as interactions, are supported in this work. To allow further verifications, we focus\non behavioural rich components, in which not only syntactical information about component\noperations is presented, but also the behaviour with the possible valid sequences of operations\nthat the component can perform. The other constraints are the constructive constraints for\nthese components. They aimed to assist system evolution. In this work, we focus on notions\nthat predict quality attributes of components in compositions, which is one of the main activ-\nities in Component-Based Development [Szy02]. These notions allow checking whether the\nbehaviours of two components are compatible for them to interoperate. The entire approach\nis based on the CSP process algebra [Ros98], which allows us to formally address property\ncharacterisation and preservation.\n\nWe consider that there are four main contributions in this thesis. Each contribution is built\non top of the previous one. Moreover, altogether, they form our strategy for correct by con-\nstruction component-based systems.\n\nA study on the behavioural compatibility of protocols. We start by performing a study on\nprotocols in isolation, independent of being associated to components. This study shows\nwhether two protocol specifications are compatible to interoperate. The study consid-\ners both synchronous and asynchronous mediums, and presents test characterisations to\nverify such compatibility. In [RSM10], we have presented our initial results on the com-\npatibility of protocols, which have been evolved until the current state presented in this\nthesis.\n\nThe BRIC component model. In this thesis we define a generic component model, which\nimposes the necessary constraints that characterise the components we deal with, and\nhow they interact. It is aligned with the concepts of other practical component mod-\n\n\n\n1.3 THESIS OUTLINE 4\n\nels [BHP06, HLL06b, MB05] and covers a wide variety of applications. Each com-\nponent is represented by a contract, which describes the dynamic behaviour, interfaces\nand interaction points of the component. Connectors are presented in the model at two\ndifferent abstraction levels: one aimed for reuse, and the other representing their instan-\ntiation. Despite the former level represents connectors as a distinct first-class entity, the\nlatter allows to represent connector instances as components. The component model\nalso describes how components interact and how white-box can be packaged into black-\nbox components. The basic notions of this component model were originally presented\nin [RSM09, RSM10]; [RSM09] emphasises the benefits of certain architectural styles,\nalso presented in this thesis, to assist verifications.\n\nA correct by construction strategy for BRIC components. We present a strategy for com-\nposition that is based on a comprehensive set of basic composition rules for BRIC com-\nponents. The proposed rules can be regarded as safe steps to form a wide variety of\ntrustworthy component systems. The systematic use of these rules guarantees, by con-\nstruction, the absence of deadlock and livelock. Most of the side-conditions of these\nrules are based on the notion of port-protocols, which is the behaviour associated to each\npoint of interaction (port) of the component. The verification using port-protocols is\nmore efficient since the (whole) behaviour of a component is typically much broader (if\nwe compare the number of states and transitions) than its port-protocols. The proposed\nset of rules covers component systems with arbitrary topologies, including those with\ncycles. An application of these composition rules for tree-topology component-based\nsystem structures is presented in [RSM09]. The conformance notion, in where the rules\nare based on, was first presented in [RSM08].\n\nA strategy using enriched component contracts with metadata. To improve the practical\napplication of our rules, we propose an architectural style, called BRICK. In this style,\ncomponent contracts are enriched with metadata to carry additional information useful\nin composition verifications. Furthermore, we present a new set of composition rules\nthat take this metadata into consideration. The metadata of the composition is directly\nderived from the metadata of its constituting components. As a result, the complexity of\ncompositions is reduced, and the value of the component-based method is improved.\n\n1.3 Thesis outline\n\nWe have organised the presentation of this thesis in the following structure.\nChapters 2 and 3 are devoted to background. Chapter 2 presents some of the foundation\n\nconcepts on component-based development in which this thesis builds on. These are used\nthroughout the thesis to understand the context where and how components are used. It shows\ndifferent views on this field, and, in particular, the adoption of formal methods in such ap-\nproaches. Chapter 3 introduces the formalism that underlines our work, the CSP notation.\n\nIn Chapter 4, we present the basic notions that underline our approach, independent of the\nnotion of components. We characterise the desired behaviour of systems in this thesis; these\n\n\n\n1.3 THESIS OUTLINE 5\n\nare reactive, and characterised by the communication of input and output events. We also in-\ntroduce the notions of communication protocols (also called port-protocol) in this context, and\npresent our notions and test characterisations for protocol compatibility in both synchronous\nand asynchronous mediums.\n\nChapter 5 defines the BRIC component model. It presents the notion of component con-\ntracts and connectors. It also defines how components interact. At the end of this chapter, we\npresent some architectural styles, which specialise our architectural model to specific applica-\ntion domains. In particular, we present the BRICK component model, which allows component\ncontracts to have metadata (additional information used in composition); the components that\nsatisfy the BRICK component model are a subset of the components that satisfy the BRIC.\n\nIn Chapter 6, we present the constructive constraints of our component models, BRIC and\nBRICK. It presents our composition rules for components in these models. These rules pre-\nserve deadlock-freedom by construction, considering that the components involved in the as-\nsembly satisfy this property. Both sets of components, the ones for BRIC and BRICK, have\nthe same number of rules; each one has a corresponding rule in the other set. Within this con-\ntext, the set of composition rules for BRIC components is aimed at more general components.\nBy contrast, the set of rules for BRICK are intended for components with enriched contracts.\nThe latter set of rules performs simple calculations with the metadata in substitution to more\ngeneral verifications in the original rules for BRIC components. As a result, the complexity\nof verifications for BRICK is reduced, and the composition task is simplified. We also present\nimprovements on such composition rules when applied to other specific architectural styles pre-\nsented in Chapter 5. We present notions to preserve livelock-freedom after applying wrapping\noperators (operations that transform white-box into black-box components).\n\nChapter 7 evaluates our approach on two case studies. Each case study covers a different\npurpose. The first one is the seminal dining philosophers problem, and is aimed at comparing\nour approach to others in the literature. The second one shows the diversity of our approach in\nconstructing systems for coordinating other components.\n\nFinally, Chapter 8 presents our general conclusions, pointing out our main contributions.\nWe analyse the advantages and disadvantages of our approach comparing with related works,\nand we discuss some topics for future work.\n\n\n\nCHAPTER 2\n\nBackground on componentware\n\nBy definition, all systems comprise components. These components result from problem de-\ncomposition, a standard problem-solving technique in computer science: divide to conquer.\nEtymologically speaking, components are the parts that constitute the whole system1; in turn,\nthe whole comprises its parts. In the software area, for instance, different concepts about how\nsystems should be organised result in different kinds of components, which might have noth-\ning more in common than the name \u2018component\u2019. In fact, the term software component has a\ngenealogy at least as long as those of \u2018software engineering\u2019 and the \u2018software crisis\u2019 [McI68];\nall these ideas were originally reported in the famous NATO conference [NR69]. However,\nsince its origins, component notions and definitions developed in many (in some cases, contra-\ndictory) directions, influenced by different areas of computer science, such as object-oriented\nprogramming, reuse and software architecture. Today, the following definition [Szy02] is the\nmost frequently used.\n\n\u201cA component is a unit of composition with contractually specified interfaces and\nexplicit context dependencies only. A component can be deployed independently\nand is subject to composition by third parties.\u201d\n\nThis definition is still not fully accepted by the industry and academy [BDH+98]. The\nreason is that component concepts subtly differ in the way that they are observed during devel-\nopment. Despite it has been widely used, the definition above emphasises just one perspective\nin using components as the building blocks of a development approach. It emphasises, for in-\nstance, the composition and deployment of components. Other perspectives can consider, for\ninstance, the component at the design phase. Component-driven architectures [MT00] view\ncomponents as architectural entities and focus on the design of elegant architectures. Process\nmodels, like the one proposed by [ABB+01], mainly focus on efficient development methods\nfor software product families or reuse of third-party components; improving productivity via\nthe reuse of components or part of their behaviour (the one common to a product family). All\nthese perspectives for building systems from components are called more broadly component-\nware approaches.\n\nIn this chapter, we study several componentware approaches, and understand their com-\nmonalities. This is used as a basis to the rest of this thesis to understand the context where\ncomponents are used in practice. Based on the study of these approaches we draw desirable\n\n1Engineering large-scale systems is fundamentally different from programming in the small. A programming\nlanguage statement is inadequate as the unit of development. Instead, components must become the building\nblocks of a system.\n\n6\n\n\n\n2.1 COMPONENT-BASED DEVELOPMENT 7\n\nissues of an approach for the development of trustworthy component based development sys-\ntems. The desiderata for component-based critical systems is presented in Section 2.4\n\nIn each section that follows, we focus on a different perspective in componentware. All\nexisting approaches cited in this chapter are organised in these sections according to their main\ncharacteristics [BRSV99]: development process model, description techniques and formal sys-\ntem model. This does not propose a rigid classification schema for those approaches. In fact,\napproaches can present more than one of these characteristics. Section 2.1 discusses concepts\nand principles common in process oriented approaches. Section 2.2 discusses architecture-\ncentric approaches, including component models and frameworks. Finally, in Section 2.3 we\ndiscuss how formal methods are used to support the development of critical component-based\nsystems.\n\n2.1 Component-based development\n\nThe idea of constructing large systems from small pieces (components) can reduce the devel-\nopment time and improve the final product quality [Szy02], and then it is possibly the greatest\nmotivation for using this approach. In this scenario, it can be justified that the majority of\nresearch, as well as its results, are new CBD methods proposals in order to address a lot of\nweaknesses in this area [AAG+07].\n\nAs any other development process, developing components requires a systematic approach.\nHowever, there are somewhat differences from traditional (object-oriented) development pro-\ncess. The Component-based Software Engineering (CBSE) approach changes the nature of\nsoftware, so they need some original phases for the architecture of components.\n\nIn CBSE, considerably more time is devoted to business rules, business process modelling,\nanalysis, and design. Much less time is spent in development, while testing occurs throughout\nthe process. A detailed discussion of all tasks in component development would fill a complete\nbook [DW98, ABB+01, SDS01, CD01], therefore, for the sake of brevity, we detail only some\ncommon activities on the analysis and design phases in this section. These activities were\nselected because they generally take more time than traditional development ones take.\n\nIn summary, the building activities start top-down to introduce the building blocks of the\nsystem. As the activities continue towards lower granularity blocks, interfaces between the\nblocks are also defined. When the module is expected to correspond to a component, a tem-\nporary bottom-up approach can be taken; if desired capability can only be achieved by a set of\ncomponents, their integration into a super-component should be carried out.\n\nFigure 2.1 illustrates a regular component-based development. In this example, a banking\napplication is the software system that is to be built. The need for this software and definition\nof the problem is described in an early specification phase. After deciding to develop soft-\nware and determining its boundaries there is need to decompose the whole system (Bank) into\nreusable and cohesive sub-components (such as the Teller and Converter component contracts),\nsince these sub-components may be necessary in other software applications or systems. De-\ncomposition also provides flexibility for developers, such that a project manager can distribute\ncomponents to different developers so that cost will be minimised. After decomposition, each\nsub-component is considered independently and specified in detail. After specifying each com-\n\n\n\n2.1 COMPONENT-BASED DEVELOPMENT 8\n\nFigure 2.1 Bank Decomposition [ABB+01].\n\nponent, it is searched in possible repositories and domains. If there is an available component\nin the repository then it is integrated into the system without writing any new code (such as\nthe Converter component). Nevertheless, sometimes there is no such ready-made component\nthat complies with our requirements exactly. If there is a component that complies with re-\nquirements approximately then this component can be adapted to new requirements without\ncorrupting previous interactions within some other software systems. If there is no component\nthat complies with the requirements, then the only alternative is to create a new one using prin-\nciples of CBSE such as flexibility, reusability and maintainability (such as the Teller). Before\nthe integration phase, there is a need for testing each component separately. Finally at the in-\ntegration phase, with the help of interfaces of components, it is possible to glue components to\neach other in the light of requirements.\n\nAs presented above, much time is devoted to design in CBD. For this reason, CBD is\nusually used in combination with other methods. For instance, despite the differences of\nComponent-based Software Engineering (CBSE) and Reuse-oriented Software Engineering\n(or simply \u2018reuse\u2019) in both technical as well as organisational dimensions, both approaches\nare highly compatible, and one can benefit from using both approaches. Both paradigms have\nthe same business goals: increase productivity and quality. However, they subtly differ in their\napproaches towards achieving these goals. CBSE approaches focus on improving productivity\nby reduction of development time and by improving flexibility of systems. By contrast, reuse\nbased approaches emphasise cost reduction as a means of increasing productivity. To achieve\nthis, it avoids costs in projects through the use of artefacts resulting from previous projects, and\nemphasise the dissemination of knowledge for sharing the subject of reuse within an organisa-\ntion. As a result, despite the fact that it is possible to develop systems in a component-based\n\n\n\n2.2 SOFTWARE ARCHITECTURE 9\n\nstyle without doing reuse, components are independent units of composition and they are com-\nmonly considered a unit of reuse.\n\n2.2 Software architecture\n\nNot all componentware approaches [BDH+98] directly define software architecture concepts\nthat give concrete guidance to designers and architects. Approaches to software architecture\nand componentware are overlapping. Both consider the structure, the composition and the\nbehaviour of software systems. In fact, the software architecture approach is an integral part of\nan integrated componentware methodology [BHB+03].\n\nOne commonly used definition [BCK03] for software architecture is given below:\n\n\u201cThe software architecture of a program or computing system is the structure or\nstructures of the system, which comprise software elements, the externally visible\nproperties of those elements, and the relationships among them.\u201d\n\nIn this definition, the component notion is rather general and weak. A component can be\neverything from a database engine to a class written in an object oriented programming lan-\nguage. However, this definition gives some important implications. For instance, the definition\nimplies that every software system has an architecture, because every system can be shown to\nbe composed of elements and relations among them. In the most trivial, and uninteresting, case,\na system is itself a single element, and an architecture. More elaborate structures are desirable,\nsince recurring patterns on such structures might represent interesting quality attributes.\n\nThe architecture embodies information about how the elements relate to each other. Thus,\nan architecture is foremost an abstraction of a system that suppresses details of elements that do\nnot affect how they use, are used by, relate to, or interact with other elements. The \u2018externally\nvisible\u2019 properties refer to those assumptions that other elements can make of an element,\nsuch as its provided services, fault handling, shared resource usage, and so on. Architecture\nis concerned with the public details; private details of elements (details that have to do solely\nwith internal implementation) are not architectural. For instance, the behaviour of each element\nis part of the architecture since this behaviour can be observed or discerned from the point of\nview of another element. This does not mean that the \u2018exact behaviour\u2019 of every element must\nbe documented in all circumstances; but to the extent that an element\u2019s behaviour influences\nhow another element interacts with it and, furthermore, influences the system as a whole.\n\nIn the next sections, we discuss architectural characteristics of software components. In\nSection 2.2.1 we present an overview of existing approaches for component-driven architec-\ntures. It also discusses the benefits of separating computation (what a component does) and\ncoordination (how a component interacts with the external world) concerns in the architecture.\nIn Section 2.2.2, we show some general components aspects related to their interaction and,\nfurthermore, that are associated to component contracts (the \u2018externally visible\u2019 properties of a\ncomponent).\n\n\n\n2.2 SOFTWARE ARCHITECTURE 10\n\n2.2.1 Component models, technologies and frameworks\n\nIn commercial component technologies, such as Sun\u2019s Enterprise JavaBeansT M [DK06] and\nMicrosoft\u2019s COM+ [Mic11], a software component is taken as an implementation, ready to\nexecute, with well-defined interfaces that enable third-party composition (roughly, integration\nwith other components). The concept of component as implementation is a familiar one found\nin the marketplace, and it is most often used by practitioners to refer to commercial off-the-shelf\n(COTS) products.\n\nIn order to have an architectural constraint conscious design of software components, it is\nnecessary to merge such an implementation perspective with one that equates components as\ndesign abstractions; this union is denoted architectural components [BBB+00]. This can be\nachieved by bridging the gap between component technologies and software architecture.\n\nCOTS products may implement functionality and coordination in a way that is unique to\na product. On the opposite, architectures provide abstractions, which enable developers to\ncentre on the \u2018big picture\u2019 in developing a system, and provide means for analysing system\ndesigns with respect to quality attributes. In contrast to ordinary implementations, architectural\ncomponents are required to implement a contract that prescribes how components may interact\nor other architectural constraints. These contracts are constituent parts of a component model.\nIt is compliance with a component model that makes a component architectural.\n\nIn this context, component-based systems rely upon well-defined standards and conven-\ntions (component model) and a support infrastructure (component framework). The component\nmodel imposes design constraints on component developers, and the framework enforces these\nconstraints in addition to providing useful services, such as persistence and transactions.\n\nIn analogy to operating system, components are to frameworks what processes are to op-\nerating systems. The framework manages resources shared by components, and provides the\nunderlying mechanisms that enable communication (interaction) among components. Many\nexamples of component frameworks can be seen in practice. For instance, the Enterprise\nJavaBeansT M (EJB) [DK06] specification defines a framework of servers and containers to\nsupport the EJB component model, with servers responsible for providing persistence, transac-\ntion and security services while containers are responsible for managing component life cycle.\n\nBy imposing standards and conventions on component developers, component models can,\nfor instance, bring as a result a uniform composition method and appropriate quality attributes.\nThe former would result from imposing composition assumptions about what a component\nmust provide to or require from other in interaction, thereby reducing chances for accidental\nmismatches that inhibit composition of components. The latter results from standardising the\ntypes of component used in a system and their patterns of interaction, since it is consensual that\nthe quality attributes of a system will depend upon its software architecture. Closely related to\nquality attributes is quality of service, which can also be obtained by specifying that patterns\nof interaction are transactional, or encrypted, and so forth.\n\nSoftware architecture techniques are usually either descriptive or formal. Descriptive ap-\nproaches [Obj07, GMW00] provide diagram types for (graphically) representing static and\ndynamic aspects. Formal ones [ADG98, HLL06b] are based on a well defined mathemati-\ncal formalism, used to unambiguously express the basic building blocks and their relations\nas well as their properties: component, interface, connector and configuration. Other ap-\n\n\n\n2.2 SOFTWARE ARCHITECTURE 11\n\nproaches [BHP06, RSM05] merge these techniques with notations hiding the underlying for-\nmalism to the user.\n\nDescription techniques only cover a small part of a componentware technology. Specially\nUML [Obj07], in its newest 2.0 version, might just be observed as a vehicle to draw detailed\ndiagrams of software. This is also due to the fact that there is no formal model underlying the\nsemiformal UML notation.\n\nArchitecture Description Languages (ADLs) [MT00] are component-based techniques, in-\ntended to describe software architectures, which typically subsumes a formal semantic the-\nory [MT00]. They differ from regular component technologies by making a system\u2019s structure\nexplicit, distinguishing component computation from component interactions, and providing a\nhigh-level model that can be manipulated and analysed before any changes are affected. More-\nover, they impose design rules correlated to desirable quality attributes through component\ntypes, patterns of interaction, and other constraints. In addition, ADLs typically distinguish the\nfollowing specifications:\n\n\u2022 Component behavioural specification: ADLs are concerned with component functional-\nity. ADLs typically provide support for specifying both functional and non-functional\ncharacteristics of components. Non-functional requirements include those associated\nwith safety, security, reliability, and performance. Depending on the ADL, timing con-\nstraints, properties of component inputs and outputs, and data accuracy may all be spec-\nified.\n\n\u2022 Component protocol specification: Some ADLs [ADG98, PV02] support the specifica-\ntion of relatively complex component communication protocols. Other ADLs [Sha95]\nallow the type of a component to be specified (e.g., filter, process, etc.) which in turn\nrestricts the type of connector that can be used with it.\n\n\u2022 Connector specification: ADLs contain structures for specifying properties of connec-\ntors, where connectors are used to define interactions between components. In some\nADLs [BB04], connector specifications take the form of predicates, while in others\n[ADG98], connector specifications are expressed as a first entity class.\n\nHaving components and connectors as it is possible to distinguish concerns about compu-\ntation and coordination in system. In general (not limited to computer science), coordination is\ndefined as [MC94]:\n\nThe act of managing interdependencies between activities performed by entities in\norder to achieve some goals.\n\nThe separation of concerns raises an awareness of the importance of managing dependen-\ncies. For instance, the managers of a process often focus on how to manage activities. However,\nif a critical dependency of a process is not managed well, the process\u2019s efficiency and effective-\nness become low even if all activities in the process perform well [Lil03].\n\nCoordination problems arise in the organisation of interactions of a group of entities that\ncollaborate and cooperate to accomplish some task and to satisfy some goals. It is because\n\n\n\n2.2 SOFTWARE ARCHITECTURE 12\n\nentities cooperate that they can accomplish more elaborated actions, but it is also because of\ntheir multiplicity that they must coordinate their actions and resolve conflicts.\n\nBasically, there are two different ways to realise a purpose into a solution: endogenously\nor exogenously [PA98]. In the former, coordinating activities are spread over the many com-\nponents of the system. In the latter, the entire purpose is assigned to a specific entity, called in\ngeneral connector [MMP00, Spi04, AM02], which coordinates the components from \u2018outside\u2019.\nThe exogenous coordinators provide a better separation of concerns: they tend to coordinate\nentities, rather than activities or data. Moreover, connectors separate computation from the\ncoordination itself; this simplifies system specification, understanding, construction, evolution\nand validation of properties.\n\n2.2.2 Software component contracts\n\nAs we have previously discussed, component contracts are vital constituting parts of a compo-\nnent model. They represent the \u2018externally visible\u2019 properties of a component, which affects\nhow it uses, is used by, relates to, or interacts with other components.\n\nIn order to define which information belong to these contracts, we present in this section\nfour primary functional aspects of a software component [RM04]: (1) interface, (2) static be-\nhaviour, (3) dynamic behaviour, and (4) interaction protocol. Each of the four modelling as-\npects represents and helps to ensure different characteristics of a component. Moreover, the\nfour aspects have complementary strengths and weaknesses.\n\nInterface modelling is the most frequently performed activity associated to component con-\ntracts. It has become routine, spanning modern interface definition languages (IDLs) on\ncomponent technologies [Mic11, Obj08], ADLs [MT00], and general-purpose modelling\nnotations, such as UML [Obj07]. One primitive interface is composed of services that\nrepresent data operations performed by one component on behalf of another component.\nComposition at this level is performed matching interface names and services signatures\n(names and their respective input/output parameter types). However, software modelling\nsolely at this level does not guarantee many important properties, such as interoperability\nor substitutability of components: two components may associate vastly different mean-\nings with identical interfaces.\n\nStatic Behaviour modelling extends interface modelling on several approaches with static be-\nhavioural semantics [LW94, RG02, ZW97]. Such approaches describe the behavioural\nproperties of a system at specific snapshots in the system\u2019s execution. This is done pri-\nmarily extending interfaces with state variables, invariants on these states, and pre- and\npost-conditions associated with the interface operations. These techniques are successful\nat describing what the state of a component should be at specific points of time. However,\nthey are not expressive enough to represent how the component arrives at a given state.\n\nDynamic Behaviour modelling suppress deficiencies associated with static behaviour models.\nModelling dynamic component behaviour results in a more detailed view of the compo-\nnent and how it arrives at certain states during its execution. It describes the legal order-\ning of provided or required service calls of the component, considering all its interfaces.\n\n\n\n2.3 FORMAL METHODS ON COMPONENTS 13\n\nWhile this view of component modelling has not been practised as widely as interface or\nstatic behaviour modelling, there are several notable examples of it. For instance, UML\nhas adopted a StateChart-based technique [Har87] to model the dynamic behaviours of\nits conceptual components. Other variations of state-based techniques (e.g., FSM) have\nbeen used for similar purposes [FG03]. Finally, some ADLs [ADG98, HLL06b] have\nused process algebras to model dynamic behaviours of its components.\n\nInteraction Protocol modelling focuses on legal protocols of interaction among components.\nThis view of modelling describes the legal ordering of services calls of a component at\nits interaction point (using operation in the interface). Protocols can be observed as a\ncontinuous external view of a component execution. Several techniques [ADG98, FG03,\nPV02] for specifying interaction protocols have been developed. These techniques are\nbased on the same notations of dynamic behaviour techniques.\n\nThe four aspects complementary strengths and weaknesses, as well as their consistent treat-\nment in literature suggest the possibility of using the four modelling aspects in concert [RM04].\nThere is still much confusion about the difference of the above modelling views. In practice,\ninterfaces represent the operations of a component; static behaviour complements interfaces\nwith conditions about the execution of these operators; and, dynamic behaviour associates op-\nerators to transitions among internal states of the component. Finally, protocols are associated\nto the observable behaviour of the component.\n\nAs interfaces are the base of all other views, and are the most used one, interfaces are\nsometimes used as a synonym of component contracts. However, the degree of detail of the\ncomponent contract depends of the characterisation of components in the system (this is related\nto concept of component model in Section 2.2.1). This can have one of these elements, part\nor all of them. Other elements might also be necessary in the component contract to represent\nother needs. We use in this work the name interface to represent a set of operators (or events).\nProtocols are observable behaviours of the component. If the behaviour is restricted to the one\nobserved via one of the ports, it is called port-protocol.\n\n2.3 Formal methods on components\n\nThe formal method community has always been interested in issues of composition and modu-\nlarity and thus in component issues. The reason is obvious: when defining semantics or when\ntrying to prove properties of programs, modularity is a key issue. Hence a comprehensive body\nof knowledge has been developed in foundational research.\n\nThis body of knowledge cannot be directly applied by the research community, however.\nSpecific components issues have to be understood, before being semantically mapped into for-\nmal methods. This comprises questions of the description of components, in particular, of\ntheir formal specification, formal modelling as well as the question of composition. From a\nmethodological point of view the most interesting question is certainly how to describe com-\nponent interfaces in a way such that components can easily be composed and in particular that\nthe behaviour and the properties of a composed system can be derived exclusively from the\nspecifications of the interfaces.\n\n\n\n2.4 DESIDERATA FOR COMPONENT-BASED CRITICAL SYSTEMS 14\n\nReasoning on component-based system is directly associated with how components are\ncharacterised in their component models, and furthermore with their contracts (see Section\n2.2.2). As previously discussed, while practical component approaches mainly address inter-\noperability at the signature level, the way to describe and reason on the interactive behaviour\nof concurrent components requires that more elaborate functional aspects are present in the\ncomponents contracts.\n\nIn principle, there are quite different approaches to the modelling and contract specification\nof components. One is the idea to model the component in a state-based view (static behaviour).\nIn that case we describe the interface of the component in terms of the state changes in which\nthe component is involved. A more practical technique for doing that was developed in object\norientation [Mey92, Mey97] under the term design by contract. Most of the work is this area\nis more pragmatic and a careful comprehensive theoretic foundation of this approach is still\nmissing.\n\nAlso a number of other theoretical works in computer science implicitly addresses the no-\ntion of a component. A lot of the theoretical work in modelling distributed concurrent sys-\ntems implicitly has a concept of components. In particular, we select process algebras [Mil80,\nRos98], which focus on providing a high-level view on modelling of communication among\nparallel processes. They study concurrent systems in terms of observable actions of the par-\nticular parts of the system (processes). Then, a system is described by forms of composition\nbetween process and their algebraic properties. Some architecture description languages are\nbased on process algebras (such as Wright [AG97, ADG98] which is based on CSP [Ros98]).\n\n2.4 Desiderata for component-based critical systems\n\nThe high quality development of critical systems is difficult. Systems, whose correct func-\ntioning human life and substantial commercial assets depend on, need to be developed very\ncarefully. Systems that have to operate under the possibility of system failure need to be scru-\ntinised to exclude possible weaknesses.\n\nPart of the difficulty in developing critical systems is that correctness is often in conflict with\ncost. Where accurate design methods pose high cost through personnel training and complexity\nuse, they are all too often avoided. Beyond the general arguments about savings by reuse, the\ncomponentware approach offers an interesting, and fruitful, opportunity for high-quality critical\nsystems development that is feasible in an industrial context.\n\nThe componentware approach has the potential not only to reduce costs, but at the same\ntime to increase the quality of critical systems. This observation prompts some challenges,\npointed by [BHB+03], that one has to overcome to exploit this opportunity, which includes the\nfollowing:\n\n1. Adaptation of an appropriate notion of component to critical system application domains.\n\n2. Correct use of critical components in the system context and the application domain.\n\n3. Conflict between flexibility and level of criticality guarantees when defining components.\n\n\n\n2.4 DESIDERATA FOR COMPONENT-BASED CRITICAL SYSTEMS 15\n\nAnalysing the overview on componentware approaches presented in this chapter, we ob-\nserve some insights about how to solve the above challenges.\n\nComponent Model: An appropriate notion of component for critical systems can be achieved\nby defining a new component model. In this model, architecture should specifically omit\ncertain information about elements that are not related to their interaction, and reinforce\nthose that are. Furthermore, the full verification of interoperability issues and concur-\nrency problems, such as deadlock, requires more than the limited static information in\ninterfaces. The behaviour is what allows elements to interact with each other, and it is\nclearly an important part of the component model.\n\nThe complementary strengths and weaknesses of the aspects presented in Section 2.2.2,\nas well as their consistent treatment in literature suggest [RM04] the possibility of us-\ning the four modelling aspects in concert. Moreover, the variety of verification purposes\nsuggests that some of these modelling aspects can also be discriminated at different lev-\nels, when this is possible. For instance, protocols can represent the whole observable\nbehaviour of the component, or the behaviour associated to an interaction point (port) of\nthe component (with other components in the system); the latter is called port-protocol.\nPort-protocols are not directly distinguished by the interfaces of the ports. For instance,\ntwo ports might have behavioural equivalent port-protocols, but be associated to the same\ninterface.\n\nAlthough it is interesting to distinguish connectors from components at design time, there\nis no advantage in having such distinction at integration. The reason is that there are\nno observable differences in their implementation, and a uniform composition strategy\nis more suitable to systematic development approaches. For this reason, practical ap-\nproaches [MB05] to describe software architectures usually describe connectors as pat-\nterns of services with abstract and generic interfaces at the design phase, and then in-\nstantiate these abstract connectors into concrete components when they are assembled to\ncomponents. This improves the reuse of connectors to mediate a wide variety of compo-\nnents with different interfaces.\n\nConstructive Constraints: To safely employ critical components within the system, a suitable\nmethodology for component-based construction of critical system is necessary . The\nmethodology must introduce critical concerns into the development activities, such that\nquality attributes associated to one component (produced in-house or by a third party)\ncontributes to the quality of the entire system. This is an important issue, since com-\nponents are interesting reusable assets. Furthermore, the cost of exhaustive verifications\nand validations in one component make it worth considering their reuse in multiple sys-\ntems. To be consistent with this principle, quality attribute associated to a component\nmust be preserved, by construction, during the system evolution. Thus, in component-\nbased development, considerably more time is devoted to analysis and design activities.\nIn this context, two tasks draw more attention: component substitutions and composi-\ntions. If constructive constraints are associated to the design activities, and satisfied at\ndevelopment, components can be safely integrated and deployed.\n\n\n\n2.4 DESIDERATA FOR COMPONENT-BASED CRITICAL SYSTEMS 16\n\nFlexibility and Criticality: As problems are identified earlier, fewer costs are inflicted to the\ndevelopment budget. For this reason, predicting the resulting quality attributes of com-\npositions at design is more suitable than identify them at deployment, or after the system\nhas been built. A lightweight approach must focus on architectural abstractions, and\non properties amenable for compositional reasoning. Moreover, it must have a uniform\nmathematical treatment that enables reasoning technologies. To successfully achieve this\ngoal, it is essential that the component model be co-dependent of a major design strategy,\nwhich imposes rules to the target component technology, but which does not inhibit the\nindependent evolution of this technology. In fact, the approach would impose healthi-\nness conditions that a component must satisfy, and which can be implemented in most\ncomponent technologies.\n\n\n\nCHAPTER 3\n\nSpecification and refinement of concurrent systems\n\nThis chapter concerns with laying the mathematical foundations for the thesis. The moti-\nvation for such foundations is to unambiguously specify systems and analyse them with the\naim of anticipating possible omissions and errors introduced in the specification phase. More\nprecisely, the chapter introduces the process algebra CSP (Communicating Sequential Pro-\ncesses) [Ros98], which is one of the formalisms that dominates the modelling and verification\nof concurrent reactive systems.\n\nReactive systems typically consist of a number of agents which operate in parallel and\ncommunicate with each other by means of message passing. Each agent in a reactive system\nconstantly communicates and interacts with its environment (other agents): it reacts to stimuli\nfrom the environment (hence the adjective reactive). More broadly, CSP is used for describing\npatterns of communication by algebraic expressions. These may be manipulated and trans-\nformed according to various laws in order to establish important properties of the system being\ndescribed.\n\nThe chapter focuses on the features of CSP, as presented in [Ros98], necessary for under-\nstanding the specifications in this thesis. We start the chapter by giving an overview on the\nfield of process algebra, presenting the most important notations on this field and arguing the\nchoice of CSP as the formal notation of this work. The next sections introduce the key features,\nsyntax and the denotational semantic of CSP used throughout this thesis. While we introduce\nthe syntax, we describe how processes interact (sending and receiving messages) and present\nthe main operators (used in the thesis) for building large specifications. Related to the seman-\ntics, we elaborate on the traces, stable failures and the failures/divergence model. A model\nsupplies a precise mathematical meaning to CSP processes, come with refinement notions, and\nis consistent with the algebraic laws which govern them. We also discuss how each semantic\nmodel is deployed for the verification of some interesting properties of concurrent systems. To\ncomplement the syntax presented here, we list, in Appendix C, the syntax of CSP as used by\nthe model checker FDR, a tool that supports correctness analysis in CSP.\n\n3.1 Process algebra\n\nProcess algebra is the branch of Computer Science which studies mathematical models of pro-\ncesses, regarded as agents that act and interact continuously with other similar agents and with\ntheir common environment [Hoa06]. A process refers to the behaviour of a system [Bae05]. A\nsystem is anything showing behaviour, in particular the execution of a system, the actions of a\nmachine or even the actions of a human being.\n\n17\n\n\n\n3.2 CSP SYNTAX 18\n\nIn the last quarter century, several different process calculi have been constructed and ex-\nplored; many of them owe their inspiration to the seminal work on CCS [Mil80], and others\nhave been based more on CSP [Hoa85]. Both, CCS and CSP have succeeded admirably in their\noriginal aims to occupy the opposite extremes on almost any standard of comparison [Hoa06].\n\nCCS, as well as its variants, is defined in terms of its operational semantics, while the CSP\napproach [Hoa85, Ros98] has always been to regard behavioural models. Process Operational\nsemantic definitions of languages have the advantage that they are direct, understandable. On\nthe other hand, definitions, such in CSP, in abstract models, intended to capture the extensional\nmeaning of a program in some sense, have the advantage of \u2018cleanliness\u2019 and allow us to reason\nabout programs in the more abstract models.\n\nDespite CCS and CSP still occupy extreme positions in all variations of process calculi, the\nsimilarities across the whole range are far more significant than their differences [Hoa06]. And\nfor this reason, there are several efforts [HH10, Ros10] to unify the two modelling styles in\norder to enable practicing engineers to exploit a combination of their complementary advan-\ntages. Both works presented in [HH10, Ros10] aim that, in a different but equally valid sense,\nCCS is a subset of CSP; that is a conclusion which does not require us to make any judgement\nwhether the subset is superior to the full set, or vice-versa. We might say that, in general, the\noperators of CCS have elegant operational definitions, whereas the CSP operators have fairly\nelegant denotational definitions.\n\nHe and Hoare [HH10] show that there is a retraction which projects every process of CCS\nonto its closest approximation in the CSP subset. Using another strategy, [Ros10] defines what\nmeans a CSP-like operational semantics, based on basic CSP operators plus an additional one,\nneeded to complete the general simulation result. It shows that not only CCS is CSP-like, but\nalso its variant ? -calculus [SW03]. These efforts to unify these modelling styles demonstrated\nnot only the power of CSP, but also the great elegance of CCS and the ? -calculus.\n\nIn this work, we use CSP, as defined in [Ros98], as our formal notation. The reason for using\nCSP is that its denotational semantics has proved convenient for reasoning, and it provides the\nmain design concepts necessary for this work. The laws of CSP have been inspiring to prove\nrules for components, as illustrated in this work.\n\nMoreover, components are intrinsically black-box modules of the system. Thus any opera-\ntor used to express its behaviour must make sense over a model in which details of individual\nlinear runs of the behaviour (process) are recorded by an observer who cannot, of course, see\ninternal actions (as the ? action present in CCS). Despite mobility, present in ? -calculus, being\na recurring notion in several studies of component architectures, its use is immaterial to the\nscope of this work. Taken these reasons in consideration, CSP fits the necessary requirements\nto underline the concepts and the strategy presented in this work.\n\n3.2 CSP syntax\n\nThe basic idea of CSP concerns the communication between processes: communication takes\nplace over named channels and is synchronous. Communication is the only means of inter-\naction between processes. On their turn, processes are defined in terms of a set of events ?,\nwhich are the communication primitives. An event is a single, atomic, and instantaneously\n\n\n\n3.2 CSP SYNTAX 19\n\noccurring action that a process engages in. However, an event may still contain various pieces\nof information, and, therefore, have some structure. A structured event is given by a communi-\ncation channel which carries messages. In order to model values v being communicated along\na channel ch, each possible communication is described as a separate possible event ch.v in the\nprocess. The declaration of a channel assumes the form:\n\nchannel ch : T1....Tn\n\nIn the expression above, ch is a name, and T1....Tn are types. So that, an event ev = ch.v1 ...vn\nis consistent with this declaration if vi is of type Ti,1 ? i ? n; observe that n can also be zero.\nGiven some set of channels Ch, we write {|Ch|} to denote the set of events consistent with the\ndeclaration of channels ch ?Ch. This notation is taken from FDR.\n\nTo help identifying the channels used in a trace, we define chans(t) as a function that takes\na trace t and returns the channels used within it.\n\nchans(??) = /0\nchans(?c.x?^ t) ={c}?chans(t)\n\n. To illustrate our notions, we present the motivating example of a client-server interaction.\nThis is a version of the example presented in [RSM09]. However, for the sake of brevity, it is\nslightly modified to focus on the discussion of the CSP notation. The original version of the\nexample [RSM09] is presented when we start to cope with notions related to component-based\nsystems (Section 5).\n\nThis example is used as a running example in this chapter and in the next one. The following\ndatatypes and channels are used in the example.\n\ndatatype DAT ASV = wd.Int|reqBal|ackW d.Bool|resBal.Int\ndatatype DAT AU S = insertCard.Int|enterPin.Int|withdraw.Int|balance|\n\ntakeCard|takeCash|takeSlip\n\nchannel cus : DAT AU S\nchannel csv : DAT ASV\n\nAs we focus on the interaction between the client and the server, we explain only the events\nused in their communication: in the example, the events in DAT ASV are those used by the client\nto interact with the server, and vice-versa. It contains the events for withdrawing money (tagged\nwith wd) and for requiring and receiving an account balance (tagged with reqBal and resBal,\nrespectively). These events use the (assumed) built-in data types Bool and Int to represent\nboolean and integer values, respectively.\n\nBesides primitives for communication (sending and receiving messages over channels),\nrepresented by ?, two special actions are used to model executions of CSP processes: the\ninvisible action ? (modelling steps internal to a process) and the termination action X; these\nevents are, therefore, not observed by the environment. Altogether, they constitute the set of\nactions Act = ?X,? = ??{?,X}.\n\nFurthermore, a set of process names (or identifiers) PName is used for giving names to CSP\nprocesses, which are used for declaring processes and during their specification to refer other\n\n\n\n3.2 CSP SYNTAX 20\n\nprocesses. CSP processes are usually evaluated in the context of a set of process equations with\nthe form:\n\nName = P\n\nwhich associate processes with names; here, Name ? PName, and P is a process specification.\nMoreover, the CSP language contains a large number of operators for building specifi-\n\ncations (which are also processes) from already defined processes. The set LCSP of all CSP\nprocess terms is generated by the following rules:\n\nP ::= STOP %% Deadlock process\n\n| SKIP %% Terminating process\n\n| a ? P %% Prefix\n\n| P 2 Q %% External choice\n\n| P u Q %% Internal choice\n\n|ua : A \u2022 f (a) %% Indexed internal choice\n| 2a : A \u2022 f (a) %% Indexed external choice\n\n| P ; Q %% Sequential composition\n\n| P A?B Q %% Alphabetised parallel\n\n| P?\nA\n\nQ %% Generalised parallel\n\n| P ? Q %% Synchronous parallel\n\n| P ||| Q %% Interleaving\n\n| P \\ A %% Hiding\n\n| P[[R]] %% Renaming\n\n| bool&amp;P %% Boolean guard\n\n| Name %% Process naming\n\nHere, a ? ? is an event, A ? ? and B ? ? are set of events, R ? ?\u00d7? is a renaming relation upon\nevents, and bool is an boolean expression, and f ? ?\u00d7LCSP is a parametrised process that takes\nan event and returns a process. The process name Name ? PName is an identifier which stands\nfor the definition of a process. This also allows for the definition of recursive processes.\n\nParameters can be used to represent aspects of the process state, and can appear in guards:\nwe write bool&amp;P to denote the process that behaves as P if the boolean bool is true, and can per-\nform no events otherwise. The atomic processes SKIP and STOP both denote termination; SKIP\n\n\n\n3.2 CSP SYNTAX 21\n\ndenotes successful termination, whereas STOP denotes deadlock. SKIP does nothing except\nindicate it has reached the end of a pattern of communication by performing the termination\nevent X. STOP is not capable of executing any event, not even termination. The most basic\noperator is the prefix operator ; if P is a process and an event then a ? P denotes a process that\nis initially ready to engage in a. If this event occurs, then subsequent behaviour will be that of\nP.\n\nThere are two types of choice operators in CSP: one denoting internal choice and the other\ndenoting external choice. An internal (also called nondeterministic) choice is resolved between\nthe processes involved without reference to the environment (i.e. other processes running in\nparallel), whereas an external choice may be influenced by the environment and is resolved by\nthe first event to occur. These operators each come in two forms: the binary operator; and the\nchoice over an indexed set of processes.\n\nProcesses can be composed sequentially: the process P ; Q first behaves as P and then,\nif P successfully terminates (ends by a SKIP), behaves as Q. Alternatively processes can be\ncomposed in parallel. We write the alphabetised P A?B Q to denote the process in which P can\nperform only events in A, Q can perform only events in B, and they must simultaneously engage\nin events in the intersection of A and B. So, it is conventional for the interface A of process P\nto contain at least all of the events used in the definition of P. Similarly, B should contain all of\nthe events appearing in Q. Differently, the synchronised parallel P?\n\nA\nQ denote that P and Q can\n\nevolve independently, but must synchronise on every event in the set A; the difference with the\nalphabetized operator is that if both processes in P?\n\nA\nQ are allowed to communicate a particular\n\nevent a /? A, either P or Q can do a independently. In the generalised parallel P ? Q, P and Q\nmust synchronise in all events. In fact, it is an abbreviation for P A?B Q when A and B are the\nalphabets of P and Q, respectively. In an interleaving parallel combination no synchronisation\nis required; in the combination P ||| Q, the two processes evolve independently. In fact P ||| Q\nis an abbreviation for P?\n\n/0\nQ. In all parallel and interleaves combinations, the process P and\n\nQ must also agree on termination, even though the event does not appear explicitly in the\nsynchronisation sets A and B. This means that a parallel and an interleave combination does not\nterminate until all of its components are terminated.\n\nFinally, we introduce the hiding operator: P \\ A is a process that behaves as P, except that\nboth the requirement to synchronise upon and the ability to observe events from the set A has\nbeen removed. Regarding the renaming operator, P[[R]] is a process that behaves as P, except\nthat some events are replaced by others according to the renaming function R.\n\nIn our example, the client behaviour is formally written in CSP by the process CL as follows.\n\nCL =cus.insertCard?num ? cus.enterPin? pin ?\n(CLDRAW 2 CLBAL) ; cus!takeCard ?CL\n\nCLDRAW =cus.withdraw?val ? csv!wd.val ? csv.ackWd?a ? cus!takeCash ? SKIP\nCLBAL =cus.balance ? csv!reqBal ? csv.resBal?x ? cus!takeSlip ? SKIP\n\nTo help readability in our specification, we assume that a request event with an input parameter\ntakes the form ch.tag?x, where ch is the name of a channel and x acts as an input pattern, which\ncan be empty (as in the event balance) or with a variable (as in insertCard?num). The notation\n\n\n\n3.2 CSP SYNTAX 22\n\nch!v is used for response events, where v is an expression. The data processing starts by acquir-\ning the card number from the environment using the channel cus. Next, the prefix operator (?)\nstates that the event cus.enterPin? pin takes place, representing the validation of the user token\nand password. Then, CL offers two choices deterministically (2) : it engages either on the\nevents withdraw or balance, to withdraw money or to check the account balance, respectively.\nEach of the alternative operations is started by the occurrence of the csv!wd or the csv!reqBal\nevent, and can be completed by the csv.ackW d?a or the csv.resBal?x event, respectively. The\nevents cus!takeCash, cus!takeCard and cus!takeSlip inform the user about the operation result\nand finalisation.\n\nNow we present the server, which provides bank services to the client. Syntactically, the\ndynamic behaviour of the server is written in CSP as follows SV process.\n\nSV = csv.wd?x ? (ua : Bool \u2022 csv!ackW d.a)? SV\n2 csv.reqBal ? (uy : Int \u2022 csv!resBal.y)? SV\n\nThe process SV offers a deterministic choice (2) between a withdraw and a balance request,\nwhich is represented by the occurrence of the communications csv.wd?x and csv.reqBal. After\nreceiving a withdraw or balance request, it internally decides (nondeterministic choice u) the\nvalue of the withdraw acknowledgement (ackW d!a) and that of the balance response (resBal.y);\nthe nondeterministic choice is usually associated to abstract internal actions of the component,\nwhich decides the value that is output.\n\nThe ATM system can be represent by the parallel composition of the client (CL) and server\n(SV ), as illustrated below.\n\nATM = CL ?\ncsv\n\nSV\n\nIn this example, the client (CL) can communicate with the user (through channel us) indepen-\ndent of the server, but must synchronise with the server (SV ) on every event in the sv, which\nrepresents their communication medium.\n\nIn addition to operators among processes, the CSP language has also operators among\ntraces, which are sequence of events. So, when reasoning about possible sequences of in-\nteraction, we use these operators. In this work, will use filter (|? ) and hiding (\\) operators\non sequences. Given a sequence s and a set A, the sequence s |? A is the longest subsequence\nof s containing only elements from the set A. Conversely the sequence s \\ A is the longest\nsubsequence of s containing no elements from the set A. There are also other operators over\nsequences. The length #s of a sequence s is the number of elements it contains. The value of\n#(s |? A) gives the number of occurrences of events from A in s. This will be abbreviated s ? A.\nIn the case where A is a singleton set a, the set brackets will be elided and s ? a will abbreviate\ns ?{a}. Similarly, s |? a will abbreviate s |? {a}.\n\nThe account of the CSP language given here is incomplete. Only the core language has been\nconsidered with certain \u2018advanced\u2019 operators omitted. The language described corresponds\nto the modern version of CSP, as given in [Ros98], which differs slightly from the language\npresented in [Hoa85].\n\n\n\n3.3 CSP SEMANTIC MODELS 23\n\n3.3 CSP semantic models\n\nCSP offers a number of approaches to semantics. A process written in CSP may be understood\nin terms of operational semantics (where the process is transformed to a labelled transition sys-\ntem, with transitions representing communications); or in terms of algebraic semantics (where\nproperties of a process \u2013 such as equivalence to some other process \u2013 may be deduced by syn-\ntactic transformations on the process text following a set of algebraic laws); or in terms of\ndenotational semantics (where the process corresponds to a value in some mathematical model,\ntypically a complete partial order or a complete metric space). The latter is the dominant one,\nand of particular interest for our work.\n\nIn the next subsections we describe the three denotational models: traces, failures and\nfailures-divergences [Ros98].\n\n3.3.1 Traces model\n\nThe traces model denotes a CSP process according to its traces, which are the set of sequences\nof communications in which the process is willing to engage. Let A?X = ???{s ^?X?|s ? ??}\nbe the alphabet of communications. Formally in the traces model each process is identified by\na set T ?A?X that satisfies the following healthiness condition:\n\nT1. T is nonempty and prefix-closed. This means that it always contains the empty trace ??\nand if s ^t ? T then s ? T .\n\nGiven a CSP process P, the traces of P are denoted as traces(P). Table 3.1 reports the se-\nmantic clauses of the basic processes in the traces model. STOP never communicates anything:\nits set of traces consists only of the empty trace ??; the traces of an action prefix process are\nthe traces of the prefixed process P, each prefixed with the event a first communicated and the\nempty trace added. In the clause of the prefix choice ?x : X ? P, which is the only way to in-\ntroduce a variable x, every free occurrence of x in the process P is syntactically substituted by\na communication. Details about the other constructors are presented in [Ros98].\n\nAs an example, let us consider the processes CLBAL presented in the last section. The trace\nset of CLBAL is given by:\n\ntraces(CLBAL) ={??,?cus.balance?,?cus.balance,csv.reqBal?,\n?cus.balance,csv.reqBal,csv.resBal.true?,\n?cus.balance,csv.reqBal,csv.resBal. f alse?\n?cus.balance,csv.reqBal,csv.resBal.true,cus.takeSlip?,\n?cus.balance,csv.reqBal,csv.resBal. f alse,cus.takeSlip?}\n\nA process C is a trace refinement of A if, and only if, it contains all traces within A.\n\nDefinition 3.1 (Traces refinement). Let P, Q be CSP processes. P is a trace refinement of Q,\nwritten as Q vT P, if and only if: traces(P)? traces(Q).\n\n\n\n3.3 CSP SEMANTIC MODELS 24\n\ntraces(STOP) ={??}\ntraces(SKIP) ={??,?X?}\ntraces(div) ={??}\ntraces(a ? P) ={??}?{?a?^ s|s ? traces(P)}\ntraces(?x : X ? P) ={??}?{?a?^ s|s ? traces(P)? a ? X}\ntraces(P ; Q) =(traces(P)???)?{s ^ t |s ^?X?? traces(P)? t ? traces(Q)}\ntraces(P 2 Q) =traces(P)?traces(Q)\ntraces(P u Q) =traces(P)?traces(Q)\n\ntraces(P?\nX\n\nQ) =\n?\n{s?\n\nX\nt |s ? traces(P)? t ? traces(Q)}\n\ntraces(P X?Y Q) ={s ? (X ?Y )?X |s |? X ?{X}? traces(P)? s |? Y ?{X}? traces(Q)}\ntraces(P ? Q) =traces(P)?traces(Q)\n\ntraces(P ||| Q) =\n?\n{s ||| t |s ? traces(P)? t ? traces(Q)}\n\ntraces(P \\ X) ={s \\ X |s ? traces(P)}\ntraces(P[[R]]) ={t | ?s ? traces(P)\u2022 s R?t}\n\nTable 3.1 Semantic clauses for the traces model.\n\nTwo processes P and Q are traces-equivalent, P ?T Q, if P vT Q and Q vT P, i.e., traces(P) =\ntraces(Q). The process STOP is the most refined process in the traces model, i.e., P vT STOP for\nall processes P.\n\nThe refinement notion in CSP (independent of the semantic model) has many properties\nthat can be exploited, for example it is transitive:\n\nP v Q ? Q v S ? P v S\n\nand monotone: if C[.] is any process context, namely a process definition with a slot to put a\nprocess in, then\n\nP v Q ?C[P]vC[Q]\n\nThe traces model is the weakest of the three denotational models of CSP that we consider.\nIn fact, the traces of internal and external choice are indistinguishable. This indicates that\ntraces(P) does not give a complete description of P, since we would like to be able to distinguish\nbetween PuQ and P 2 Q. For example, the process a?SKIP guarantees that if the environment\nis prepared to engage in the event a and then terminate, then it can engage in the event a and\nterminate successfully. However, a?SKIPua?ST OP does not guarantee that it can engage in\nthe event a and terminate successfully if the environment is ready to engage in the event a and\nterminates. The traces model identifies both processes as they have the same traces. However,\none of them guarantees that it will terminate successfully, but the other does not guarantee.\n\n\n\n3.3 CSP SEMANTIC MODELS 25\n\nIn terms of verification, the traces model can be deployed for the verification of safety\nconditions. That is, a process Q which is a trace refinement of a process P, will perform\ntraces already defined in P and nothing more, i.e., traces(Q) ? traces(P). Safety conditions\nare concerned with the exclusion of traces only.\n\n3.3.2 Stable failure model\n\nThe stable failure model F gives a finer information about processes. For instance, it allows us\nto distinguish between internal and external choice (and much more). In particular, it allows\nus to detect deadlocked processes. A failure of a process is a pair (s,X), that describes a set\nof events X which a process can fail to accept after executing the trace s. The set X is called\nthe refusal set; the process cannot perform any event in the set X no matter for how long it is\noffered.\n\nThe \u2019stable\u2019 in the model name means that the sequences represented by s are those that\nreach a stable state where no transition is chosen nondeterministically. In other words, stable\nstates are those in which there are no choices between external and internal actions. As an\nexample, let us consider the following processes over the alphabet {a,b}:\n\nP =a ? ST OP 2 b ? ST OP\nQ =a ? STOP u b ? STOP\n\nThe stable failure set of P and Q, denoted by failures(P) and failures(Q), are given by:\n\nfailures(P) ={(??,{X}),(?a?,X),(?b?,X)|X ?{a,b,X}}\nfailures(Q) ={(??,Y ),(??,Z),(?a?,X),(?b?,X)|X ?{a,b,X},Y ?{a,X},Z ?{b,X}}\n\nHere, P and Q have different failures, i.e., the stable failure model F can distinguish between\ninternal and external choice. The failures of P records that initially (after the trace s = ??)\nthe process cannot refuse either a or b. The process Q has two initial invisible actions ? to\nchoose from. After performing them, it reaches stable states, where it can perform either a or\nb separately, and refuse b or a respectively. The failure of Q does not record any information\nabout the initial state, but only information about the stable states.\n\nObserve that it is by no means inevitable that every trace of a process has failure: it may\nnever stop performing ? actions. So, as not all traces of a process are present in its failures,\na process in the F model is represented not only by its stable failures, but also by its traces.\nFormally, in the stable failures model, each process P is modelled by a pair (T,F), denoting\nT = traces(P) and F = failures(P), where T ? ??X and F ? ??X\u00d7P(??X), satisfying the following\nhealthiness conditions (where s, t range over ?? and X ,Y over P(?X)):\n\nT1. T is non-empty and prefix closed.\n\nT2. (s,X)?F ?s?T . This asserts that all traces performed by the failures should be recorded\nin the traces component T . In other words it establishes consistency between the traces\ncomponent and the failures component.\n\nT3. s ^?X?? T ? (s ^?X?,X) ? F . If a trace terminates successfully by producing X, then it\nshould refuse all events in ?X at the stable state after s ^?X?.\n\n\n\n3.3 CSP SEMANTIC MODELS 26\n\nF2. (s,X)? F ?Y ? X ? (s,Y )? F . This asserts that in a stable state if a set X is refused, then\nany subset Y of X should also be refused.\n\nF3. (s,X)? F ? (?a : Y \u2022 s ^?a? /? T )? (s,X ?Y )? F . This asserts that if a process P can refuse\nthe set X of events in some stable state, then the same state must also refuse any set of\nevents Y that the process can never reach.\n\nF4. s ^?X?? T ? (s,?) ? F . This asserts that if we have any terminating trace s ^?X?, these\nshould refuse ? at the stable state after s.\n\nSimilar to the trace semantics, the clauses in Table 3.2 determine the failures of the various\nprocesses in the stable failure model F; the clauses in Table 3.1 are still valid for the traces of\nprocess in F model. Since the parallel operators can all be defined in terms of the interface par-\nallel operator ?\n\nX\n, we only have a formal need to give the definition for that one. The semantics\n\nfor the interleave and the synchronised parallel operator are shown, as an example are given\ndue to their importance to the work.\n\nA process C is a stable failures refinement of A if, and only if, it contains all traces within\nA and presents less stable failures; it refuses less communications.\n\nDefinition 3.2 (Stable failure refinement). Let P, Q be CSP processes. P is a stable failure re-\nfinement of Q, written as Q vF P, if, and only if: traces(P)? traces(Q)? failures(P)? failures(Q).\n\nIn other words, if every trace s of Q is possible for P and every refusal after this trace is\npossible for P, then Q can neither accept an event nor refuse unless P does. Two processes P\nand Q are stable failure-equivalent, P ?F Q, if P vF Q and Q vF Q, i.e., traces(P) = traces(Q) and\nfailures(P) = failures(Q). The bottom element in vF is (??X,??X\u00d7P(??X)), while its top element\nis (??, /0).\n\nAn important phenomenon captured by F is deadlock. Deadlock is a phenomenon pertain-\ning to networks of communicating processes which occur when two processes cannot agree\nto communicate with each other, thus the whole system becomes permanently frozen. This\nis potentially catastrophic in safety-critical computing applications. A network that can never\nexhibit deadlock is said to be deadlock-free.\n\nIn CSP deadlock is represented by the process STOP, which can perform only the empty\ntrace, and after the empty trace the process STOP refuses to engage in any event. In CSP, a\nprocess P is considered to be deadlock free, if the process P after performing a trace s never\nbecomes equivalent to the process STOP.\n\nDefinition 3.3 (Deadlock-free process). A process P is deadlock-free in CSP if, and only if:\n\n?s : ?? \u2022 (s,?X) /? failures(P)\n\nThis definition is justified, as in the model F the set of stable failures is required to be closed\nunder the subset-relation: (s,X) ? failures(P) ? Y ? X ? (s,Y ) ? failures(P). In other words:\nBefore termination, the process P can never refuse all events; there is always some event that P\ncan perform. Moreover, the stable failure refinement notion preserves the deadlock-freedom of\na process. That is, if P is deadlock free and P vF Q, then Q is deadlock free.\n\nFrom the definition of deadlock-free, an interesting lemma about deadlock-freedom in par-\nallel synchronizations is described below.\n\n\n\n3.3 CSP SEMANTIC MODELS 27\n\nfailures(STOP) ={(??,X)|X ? ?X}\nfailures(SKIP) ={(??,X)|X ? ?}?{(?X?,X)|X ? ?X}\nfailures(div) =/0\nfailures(a ? P) ={(??,X)|a /? X}?{(?a?^ s,X)|(s,X)? failures(P)}\nfailures(?x : A ? P) ={(??,X)|A?X = /0}?\n\n{(?a?^ s,X)| ? a ? A ? (s,X)? failures(P[a/x])}\nfailures(P ; Q) ={(s,X)|s ? ?? ? (s,X ?{X})? failures(P)}?\n\n{(s ^t,X)|s ^?X?? traces(P)? (t,X)? failures(Q)}\nfailures(P 2 Q) ={(??,X)|(??,X)? failures(P)?failures(Q)}?\n\n{(t,X)|(t,X)? failures(P)?failures(Q)? t 6= ??}?\n{(??,X)|X ? ? ??X?? traces(P)?traces(Q)}\n\nfailures(P u Q) =failures(P)?failures(Q)\n\nfailures(P?\nX\n\nQ) =\n?\n{(s?\n\nX\nt,Y ?Z)|Y 8(X ?{X}) = Z8(X ?{X})?\n\n(s,Y )? failures(P)? (t,Z)? failures(Q)}\n\nfailures(P ? Q) =\n?\n{(s?\n\nX\nt,Y ?Z)|(s,Y )? failures(P)? (t,Z)? failures(Q)}\n\nfailures(P ||| Q) =\n?\n{(s ||| t,Y ?Z)|Y 8{X}= Z8{X}?\n\n(s,Y )? failures(P)? (t,Z)? failures(Q)}\nfailures(P \\ X) ={(t \\ X,Y )|(t,Y ?X)? f ailures(P)}\nfailures(P[[R]]) ={(t,X)|(?t? |(t?,t)? R? ? (t?,R?1(X))? failures(P)}\n\nTable 3.2 Semantic clauses for the failures model.\n\nLemma 3.1. Let P and Q be divergence-free CSP processes. Then P ? Q deadlocks if, and only\nif:\n\n?(t,X) : failures(P) \u2022 (t,?8X)? failures(Q)\n\nProof. The proof of this lemma is mainly based on the semantics of the synchronised parallel\noperator.\n\nP ? Q is deadlock-free\n??s : ?? \u2022 (s,?X) /? failures(P ? Q)\n?[Semantics of the synchronised parallel operator]\n?s : ?? \u2022 (s,?X) /?{(t,X ?Y )|(t,X)? failures(P)? (t,Y )? failures(Q)}\n\n?[set theory, X ?Y = ?X ? ?X8X ?Y ]\n?(s,X) : failures(P)\u2022 (s,?X8X) /? failures(Q)\n\n\n\n3.3 CSP SEMANTIC MODELS 28\n\nFrom the lemma above, it is possible to formulate an important observation about how\nprocess should communicate in order to preserve deadlock-freedom: one process can never\nrefuses all events that the other can perform. For instance, consider that X is a maximum\nrefusal of P, then P can perform events within ?X8X . From the lemma above, in order to avoid\ndeadlock, Q cannot refuse such events.\n\n3.3.3 Failure/divergence model\n\nThe failures/divergence model gives us the most satisfactory representation for analysing live-\nness and safety properties of a CSP process; it allows us to detect not only deadlocked, but also\nlivelocked processes. Furthermore, it has long been taken as the \u2018standard\u2019 model for CSP.\n\nA process diverges, if it reaches a state from which it may forever compute internally\nthrough an infinite sequence of invisible actions. This is clearly a highly undesirable feature\nof the process, described by as \u2018even worse than deadlock\u2019 [Hoa85]. Livelock may invalidate\ncertain analysis methodologies, and is often caused by a bug in the modelling. However the\npossibility of writing down a divergent process arises from the presence of two crucial con-\nstructs: hiding and ill-formed recursive processes. For instance, consider the processes P = P\nand Q = (a ? Q) \\{a}. Q converts the external event a into an internal action ? . Therefore, Q\nindefinitely performs internal actions, which leads to a divergence. As a consequence, Q and P\nhave the same behaviour in the failures-divergences model. The CSP process div (the same of\nQ, in our example) represents the livelock phenomenon: immediately, it can refuse every event,\nand it diverges after any trace.\n\nIn the failures/divergence model, the processes are represented by two sets of behaviours:\nthe failures and the divergences. The divergences of a process are the finite traces on which the\nprocess can perform an infinite sequence of internal (invisible) actions. So, each process P is\nmodelled by the pair:\n\n(failures?(P),divergences(P))\n\nwhere:\n\n\u2022 failures?(P) is the set of all stable failures (s,X) (where s is a trace and X is a set of actions\nthat the process can refuse in some stable state \u2013 unable to perform ? or X \u2013 after s, or\nresults from state after s which can perform X and X ? ?), together with all the pairs of\nthe form (s,X) for s ? divergences(P).\n\n\u2022 divergences(P) is the (extension-closed) set of traces s on which a process can diverge.\n\nIn such model, if s is a trace that process P can perform then either P diverges after s or reaches\na stable state or one that can perform X.\n\nFormally the failures/divergences model is defined to be the pairs (F?,D) satisfying the\nfollowing healthiness condition, where s, t range over ??X X ,Y over P(?X):\n\nF.1. traces?(P) ={t |(t,X)? F} is non-empty and prefix closed.\n\nF.2. (s,X)? F ?Y ? X ? (s,Y )? F .\n\nF.3. (s,X)? F ? (?a ?Y \u2022 s ^?a? /? traces?(P))? (s,X ?Y )? F .\n\n\n\n3.3 CSP SEMANTIC MODELS 29\n\nF.4. s ^?X?? traces?(P)? (s,?)? F .\n\nD.1. s ? D??? ? t ? ??X ? s ^ t ? D.\n\nD.2. s ? D ? (s,X)? F . This adds all divergences-related failures of F.\n\nD.3. s ^?X? ? D ? s ? D. This ensures that we do not distinguish between how processes\nbehave after successful termination.\n\nSimilar to the previous models, the clauses in Table 3.3 determine the divergences of the various\nprocesses in the failure-divergence model. The clauses for the traces and failures in this model\nare similar to those presented in tables 3.1 and 3.2, but consider the divergences:\n\ntraces?(P) = traces(P)?divergences(P)\nfailures?(P) = failures(P)?{(s,X)|s ? divergences(P)}\n\nRefinement in the failures/divergence model is given by the following relation.\n\ndivergences(STOP) =/0\n\ndivergences(SKIP) =/0\n\ndivergences(div) =??X\n\ndivergences(a ? P) ={??}?{?a?^ s|s ? divergences(P)}\ndivergences(?x : X ? P) ={??}?{?a?^ s|s ? divergences(P)? a ? X}\ndivergences(P ; Q) =divergences(P)?\n\n{s ^ t |s ^?X?? traces?(P)? t ? divergences(Q)}\ndivergences(P 2 Q) =divergences(P)?divergences(Q)\ndivergences(P u Q) =divergences(P)?divergences(Q)\ndivergences(P?\n\nX\nQ) ={u ^ v| (?s : traces?(P),t : traces?(Q)|u ? (s?\n\nX\nt)??? ?\n\n(s ? divergences(P)? t ? divergences(Q))}\ndivergences(P \\ X) ={(s \\ X)^ t |s ? divergences(P)}\n\n?{(u \\ X)^t |u ? ?w ? (u \\ X)is finite ? (?s &lt;u|s ? traces?(P))}\ndivergences(P[[R]]) ={s?^t |(?s ? divergences(P)??? |sRs?)}\n\nTable 3.3 Semantic clauses for the failures-divergence model.\n\nDefinition 3.4 (Failures/divergences refinement). Let P, Q be CSP processes. P is a failures-\ndivergences refinement of Q, written as Q vFD P, if, and only if: failures?(P) ? failures?(Q) ?\ndivergences(P)? divergences(Q).\n\n\n\n3.3 CSP SEMANTIC MODELS 30\n\nTwo processes P and Q are failures-divergences equivalent, P?FD Q, if PvFD Q and QvFD P,\ni.e., failures?(P) = failures?(Q) and divergences(P) = divergences(Q). The process div is the least\nrefined process in the failures/divergence model. Then, a process is said to be free of divergence\n(or livelock free) if after carrying out a sequence of events, its denotation is different from div.\n\nAs said before, it is consensual that the failures-divergences model gives us the most satis-\nfactory representation for analysing liveness and safety properties of a CSP process. However,\nwhen we look into the mathematical theory of how divergences are calculated, it turns out that\nseeing accurately what a process can do after it has already been able to diverge is very difficult,\nand not really worth the effort [Ros98]. By combining traces with stable failures (which is in\nfact the failures part of the failures-divergences model), it is possible to see beyond any diver-\ngence by ignoring divergences altogether. Moreover, it is sometimes advantageous to analyse\na divergence-free process P by placing it in a context in which it may diverge as the result of\nhiding some set of actions; this only works when the traces and stable failures in this context\nare not influenced by these divergences.\n\nFor instance, the process P = (a ? P 2 b ? P) \\{b} diverges in its initial state. The hiding\noperation converts the external choice (2) into an internal choice (u). Therefore, the process\ninternally chooses between the external event a and an internal action resulted from hiding b. As\na consequence, P may indefinitely perform internal actions, which in the failures-divergences\nmodel leads to divergence.\n\nAs we will see in the next section, in our formalisation of some notions, it is not convenient\nthat certain hidden events result in divergence. For example, our intention is that the communi-\ncation protocols of divergence-free components are also divergence-free processes, even after\nhiding all events not in the protocol interface.\n\nTherefore, we assume in this work that basic components are divergence-free and deadlock-\nfree, and use the semantic models presented here in verifications to ensure that such problems\nare not introduced in the system formed by these components. The failures model is used in\nlocal analysis, in which the involved processes are divergent-free and the applied operators are\nknown for not introducing such a problem. The failures/divergence model is used in verifi-\ncations about the compositionality of strategy proposed in this work, checking theirs traces,\nfailures and divergences.\n\n\n\nCHAPTER 4\n\nI/O processes and communication protocols\n\nNaturally, specifications of a component behaviour at different abstraction levels are desirable,\ndepending on the circumstances. Taking the component in isolation, two kinds of behaviours\nare commonly found in literature: protocol and port-protocol. The former represents the whole\nbehaviour of the component. The latter is a more specific kind of specification that focuses\nsolely on the interaction of the component with others within the system, each one individu-\nally; such behaviour is called port-protocol, or communication protocol. It is observed as a\nprojection of the entire component behaviour over a specific interaction point of the component\nwith the rest of system.\n\nThe notion of protocols is intrinsically related to components, but deserves its own area\nof study. Due to its characteristics, protocols play an important role in the study of compo-\nnent communications. Furthermore, the study of protocols is performed in detail in this chap-\nter, and is used as a basis for the next chapters. In our rigorous strategy, both protocols and\nport-protocols are used, for instance, in local analysis of component interactions prior to their\ncomposition, in order to give reliability to the development.\n\nIn this chapter we present notions related to protocols. In particular, the first notion de-\nfined in this chapter is of I/O processes, which encompass the protocols and port-protocols;\nin particular, port-protocol is a specific kind of I/O process. I/O processes differ from regular\nprocesses by distinguishing input and output events, and establishing specific constraints about\nthese events (see Section 4.1).\n\nBesides the protocol definition, a central definition in this chapter is of protocol compati-\nbility, which states whether two port-protocols are ready to continuously communicate without\nbeing stuck. Moreover, we present means to verify such compatibility both on synchronous\nand asynchronous mediums. The notions related to protocols, including compatibility, are first\npresented with a synchronous semantics in Section 4.2. These are lift to asynchronous commu-\nnications in 4.3. In particular, we present notions related to buffer tolerance, which allow us to\nanalyse systems with asynchronous communications, but considering a synchronous semantics\nand the absence of the possible buffers in this communication.\n\nAlthough protocols and port-protocols are used to represent the behaviour of components,\nthis chapter studies these processes in isolation; the relation of these notions with other con-\nstituting parts of a component contract is presented in the next chapter. To emphasise this\nisolation, we assume protocols are regular I/O processes, and we call port-protocols of com-\nmunication protocols. The notion of component contracts, interfaces and ports are presented in\nthe next chapter.\n\n31\n\n\n\n4.1 I/O PROCESSES 32\n\n4.1 I/O processes\n\nIn the following definitions we present each of the notions that underlie our definition for I/O\nprocesses, presented in the end of this section.\n\nA first notion is related to the fact that any datum communicated by a process P through a\nchannel c is considered as either an input or an output of P. Considering this, we call c an I/O\nchannel if there is a clear distinction between inputs and outputs communicated on it.\n\nDefinition 4.1 (I/O channels). We say a channel c is an I/O channel if there exists two functions,\ninputs(c,P) and outputs(c,P), for every process P, such that\n\ninputs(c,P)?outputs(c,P)?{|c|} ? inputs(c,P)?outputs(c,P) = /0 (4.1)\n\nCommonly, inputs and outputs of a process partition the events of a channel c in two.\nHowever, the process is not obliged to perform all events of c. So, we state that inputs(c,P)?\noutputs(c,P)?{|c|}, instead of stating an equation. The functions input(c,P) and out put(c,P) are\ndefined declaratively, and must be given for each pair of process and channel. Such an implicit\ndefinition of these functions is later constrained by syntactical elements explicitly presented in\nthe component contracts (see the notion of interfaces in the next chapter).\n\nBased on the definition above, we are able to define input and output events of a process as:\n\nDefinition 4.2 (Process input and output events). Let P be a process that only uses I/O channels.\nThe inputs and outputs of P are determined by the following, equally named, functions inputs(P)\nand outputs(P):\n\ninputs(P) ={c.e|c.e ? inputs(c,P)} ? outputs(P) ={c.e|c.e ? outputs(c,P)} (4.2)\n\nNote that the directions of the events are not explicit in the channel definition, but implicit\nin the processes definitions. They must be given in order to state if a channel is an I/O channel.\n\nIn the client-server example presented in Section 3.2, the inputs and outputs of CL are\nrepresented by the functions:\n\ninputs(csv,CL) ={|csv.ackW d,csv.resBal|}\noutputs(csv,CL) ={|csv.wd,csv.reqBal|}\n\nThe decision to choose an input event from a set of events is performed by the environment,\nand to choose an output is performed internally; observe the pattern matching (represented\nby the marker \u2018?\u2019) before all input events in CL, it exposes to the environment a choice over\nmultiple events.\n\nThe second notion corresponds to the idea that when a process P offers any input commu-\nnication on c then it offers a choice to the environment.\n\nDefinition 4.3 (Input determinism). We say a process P is input deterministic if\n\n?s ^ ?c.a? : traces(P)| c.a ? inputs(c,P)\u2022 (s,{c.a}) /? failures(P) (4.3)\n\n\n\n4.1 I/O PROCESSES 33\n\nThe above statement defines that if P may perform a trace s ^?c.a?, whose last event is\nan input, then this input event is not refused by P, after performing s. Therefore, if a set of\ninput events are offered to the environment, none of them are refused; an (external) choice\namong the input events is offered to the environment. This property is based on the failures\nsemantics, which guarantees that if (s,{c.a}) /? failures(P) then there is no set (s,X)? failures(P)\nsuch that c.a ? X . In fact it is very similar to the definition of deterministic process [Ros98],\nexcept that it focuses solely on input events. Although Definition 4.3 does not explicitly refer\nto the behaviour related to outputs events, it allows choices among input and output events.\nAccording to the definition, whenever there is a choice among a specific input event and other\nevents (inputs or outputs) this will be an external choice.\n\nInput determinism is a property that is preserved under paralelism, as we show in the theo-\nrem below.\n\nTheorem 4.1 (Input determinism compositionality). Let P and Q be input determinist pro-\ncesses, and C a set of channels, such that ? P?? Q ?{|C|} and P ?\n\n{|C|}\nQ is deadlock-free. Then\n\nP ?\n{|C|}\n\nQ is input deterministic with respect to all inputs of P and Q, excepting those within C.\n\nProof. The proof of this theorem is performed by contradicting the statement that P ?\n{|C|}\n\nQ is\n\ninput deterministc. From Definition 4.3:\n\n?u ^ ?a? : traces(P ?\n{|C|}\n\nQ)| a ? inputs(c,P ?\n{|C|}\n\nQ)? a /?{|C|}\u2022 (u,{a})? failures(P ?\n{|C|}\n\nQ)\n\n?[Traces of P ?\n{|C|}\n\nQ]\n\n?s : traces(P),t : traces(Q),a : (inputs(P)?inputs(Q))8{|C|}|\n(s ^ ?a?? traces(P)? t ^ ?a?? traces(Q))? (s ?\n\n{|C|}\nt,{a})? failures(P ?\n\n{|C|}\nQ)\n\n?[a /? ? P?? Q, P and Q are input deterministic]\n?s : traces(P),t : traces(Q),a : (inputs(P)?inputs(Q))8{|C|}|\n((s,{a}) /? failures(P)? (t,{a}) /? failures(Q))? (s ?\n\n{|C|}\nt,{a})? failures(P ?\n\n{|C|}\nQ)\n\n?[Failures of P ?\n{|C|}\n\nQ]\n\n?(s,Y ) : failures(P),(t,Z) : failures(Q),a : (inputs(P)?inputs(Q))8{|C|}|\n((s,{a}) /? failures(P)? (t,{a}) /? failures(Q))?Y 8{|C|}= Z8{|C|}?{a}= Y ?Z\n\n?[({a}= Y ?Z)? (Y 8{|C|}= Z8{|C|})? a /?{|C|}?Y ={|a|}? Z ={|a|}]\n?s : traces(P),t : traces(Q),a : (inputs(P)?inputs(Q))8{|C|}|\n((s,{a}) /? failures(P)? (t,{a}) /? failures(Q))? (s,{a})? failures(P)? (t,{a})? failures(Q)\n\n?[Contradiction]\nfalse\n\n\n\n4.1 I/O PROCESSES 34\n\nIn the next definition, we state some constraints related to output events. It states that if a\nprocess can make an output on c, then it can offer no choice of values for the input process (or\nthe environment) to select from.\n\nDefinition 4.4 (Strong output decisiveness). We say a process P is strong output decisive if:\n\n?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P)\u2022 (s,outputs(c,P)) /? failures(P)?\n(s,outputs(c,P)8{c.b})? failures(P)\n\n(4.4)\n\nThe statement in the definition above says that the process does not provide an (external)\nchoice among its output events to the environment (or other processes it communicates with).\nAll choices among output events are internal. Besides, in the definition above, we state output\ndecisiveness based only on maximum failures (all outputs within c except c.b \u2013 represented\nby (s,out puts(c,P)8{c.b})), the other failures (whose refusals are subsets of these ones) are\nimplicit in the definition; according to the failures theory, ?X |X ? out puts(c,P)8{c.b}\u2022 (s,X)?\nfailures(P). The strong output decisiveness property presented here is equivalent to the equally\nnamed property presented in [Ros05b], if we consider that channels communicate exclusively\neither input or outputs.\n\nStrong output decisiveness is a property that is preserved under paralelism, as we show in\nthe theorem below.\n\nTheorem 4.2 (Output decisiveness compositionality). Let P and Q be output decisive pro-\ncesses, and C a set of channels, such that ? P?? Q ?{|C|} and P ?\n\n{|C|}\nQ is deadlock-free. Then\n\nP ?\n{|C|}\n\nQ is output decisive with respect to all outputs of P and Q, excepting those within C.\n\nProof. The proof of this theorem is performed by contradicting the statement that P ?\n{|C|}\n\nQ is\n\noutput decisive. From Definition 4.4, the proof can be divided in two parts:\n\n1. ?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P)\u2022 (s,outputs(c,P)) /? failures(P)\n\n2. ?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P)\u2022 (s,outputs(c,P)8{c.b})? failures(P)\n\nThe proof of the first part can be performed similarly to the proof of Theorem 4.1. Furthermore,\nwe focus on the proof of part 2, which starts by contradicting this statement for the process\nP ?\n{|C|}\n\nQ.\n\n\n\n4.1 I/O PROCESSES 35\n\n?u ^ ?c.b? : traces(P ?\n{|C|}\n\nQ)| c.b ? outputs(c,P ?\n{|C|}\n\nQ)? c /?C \u2022\n\n(u,outputs(c,P ?\n{|C|}\n\nQ)8{c.b}) /? failures(P ?\n{|C|}\n\nQ)\n\n?[Traces of P ?\n{|C|}\n\nQ]\n\n?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?\n(s ^ ?c.b?? traces(P)? t ^ ?c.b?? traces(Q))? (u,outputs(c,P ?\n\n{|C|}\nQ)8{c.b}) /? failures(P ?\n\n{|C|}\nQ)\n\n?[Failures of P ?\n{|C|}\n\nQ]\n\n?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?\n(s ^ ?c.b?? traces(P)? t ^ ?c.b?? traces(Q))?\n6?(s,Y ) : failures(P),(t,Z) : failures(Q)|Y 8{|C|}= Z8{|C|}?\n(outputs(c,P)?outputs(c,Q)8{c.b}) = Y ?Z\n\n?[c.b /? ? P?? Q, P and Q are output decisive]\n?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?\n(({|c|}? ? P ? (s,outputs(c,P)8{c.b})? failures(P)?\n6?(s,Y ) : failures(P),(t,Z) : failures(Q)|Y 8{|C|}= Z8{|C|}? (outputs(c,P)8{c.b}) = Y ?Z)?\n\n({|c|}? ? Q ? (t,outputs(c,Q)8{c.b})? failures(Q)?\n6?(s,Y ) : failures(P),(t,Z) : failures(Q)|Y 8{|C|}= Z8{|C|}? (outputs(c,Q)8{c.b}) = Y ?Z))\n\n?[(Y ?Z)?{|c|}? (Y 8{|C|}= Z8{|C|})? c /?C ?Y = Z]\n?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?\n(({|c|}? ? P ? (s,outputs(c,P)8{c.b})? failures(P)? (s,outputs(c,P)8{c.b}) /? failures(P))?\n({|c|}? ? Q ? (t,outputs(c,Q)8{c.b})? failures(Q)? (t,outputs(c,Q)8{c.b}) /? failures(Q)))\n\n?[Contradiction]\nfalse\n\nAltogether the input determinism and strong output decisiveness notions indicate how a\nprocess offer outputs and accept input events. They are not simple behaviour properties,\nhowever, it is relatively straightforward to formulate refinement checks for them in the style\nof [Ros05a, Ros05b].\n\nTheorem 4.3. A process P is input deterministic and output decisive with respect to all it\nchannels if, and only if:\n\n\u2022 P[[Ro]] is deterministic\n\n\u2022 ?c : chans(P)\u2022 P \\ (? P8outputs(c,P))?F ((P ?\noutputs(P)\n\nRU NFU NC({|c|}C R))\\ ? P)[[R?1]]\n\n\n\n4.1 I/O PROCESSES 36\n\nwhere Ro is a surjection that maps all outputs associated to a channel c of P into a distinct event\nnot used by P, R is a bijection from outputs of P into events not used in P, and RU NFU NC(R) =\n2a : dom R \u2022 a ? R(a)? RU NFU NC(R).\n\nProof. The proof of the theorem above is straightforward, since the statements were written to\nrepresent the input determinism and output decisiveness properties. We divide the proof in two\nparts.\n1) In the first part, we proof the equivalence between the first statement in the theorem above\nand that the process P is input deterministic and at least one output is offered, when there is a\nchoice among outputs.\n\n?s ^ ?c.a? : traces(P)| (c.a ? inputs(c,P)? (s,{c.a}) /? failures(P))?\n(c.a ? outputs(c,P)? (s,outputs(c,P)) /? failures(P))\n\n?[the outputs events of P are not distinguished in the statement]\n?s ^ ?c.a? : traces(P[[Ro]])| (c.a ? inputs(c,P)? (s,{c.a}) /? failures(Pc))?\n\n(c.a = oc ? (s,oc) /? failures(P[[Ro]]))\n?[the definition of deterministic processes in [Ros98]]\n\nP[[Ro]] is deterministic\n\n2) The alphabet of the processes in the two sides of the refinement relation are within outputs(P),\nsince we hide the inputs of P in the process on the left and the alphabet of the process on the\nright is the domain of the function R.\n\nIt is easy to see that for every communicated output c.o in P there is a subsequent commu-\nnicated event in RU NFU NC(R) that is represented by the function R(c.o). Furthermore, the traces\nof both processes in the refinement relation are equal.\n\ntraces(P \\ (? P8outputs(c,P))) = traces(((P ?\noutputs(P)\n\nRU NFU NC({|c|}C R))\\ ? P)[[R?1]])\n\nFurthermore, we focus on the failures equivalence between these processes. For the sake of\nbrevity, we consider S = P ?\n\noutputs(P)\nRU NFU NC({|c|}C R). From the behaviour of the process S, we\n\nobserve that:\n\n?s ^ ?c.b? : traces(S)|c.b ? ran R \u2022 (s,? P8{c.b})? failures(S)\n\nSo, hiding the alphabet of P, and applying the renaming R?1], we can state the following.\n\n?s ^ ?c.b? : traces((S \\ ? P)[[R?1]]) \u2022 (s,? P8{c.b})? failures((S \\ ? P)[[R?1]])\n?[P \\ (? P8outputs(c,P))?F (S \\ ? P)[[R?1]]]\n?s ^ ?c.b? : traces(P \\ (? P8outputs(c,P))) \u2022 (s,? P8{c.b})? failures(P \\ (? P8outputs(c,P)))\n\n?[semantics of hiding]\n?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P) \u2022 (s,outputs(c,P)8{c.b})? failures(P)\n\nBased on the proof above, we show that if a process satisfies the conditions of the Theorem 4.3,\nthen it is input deterministic and output decisive, and vice-versa.\n\n\n\n4.2 COMMUNICATION PROTOCOLS 37\n\nBased on the definitions above, we are able to define I/O processes.\n\nDefinition 4.5 (I/O process). We say P is an I/O process if:\n\n\u2022 whenever c.x ? ? P, then c is an I/O channel;\n\n\u2022 P has infinite traces;\n\n\u2022 P is divergent-free;\n\n\u2022 P is input deterministic;\n\n\u2022 P is strong output decisive.\n\nIn addition to the two properties already presented (input deterministic and output deci-\nsiveness), we assume that I/O processes are divergent-free and have infinite traces. Although\nthese processes have infinite traces, we consider, for practical purposes in model checking, that\nthese processes have finite state-spaces. Moreover, we require that the use of hiding, bijective\nrenaming and parallel operators on I/O processes that do not introduce divergence, automati-\ncally result in I/O processes (that is, they are conservative with respect to the I/O definition).\nThese assumptions are related to the focus of this work on presenting a systematic strategy for\ncomponent construction. Moreover, as we shown in Theorem 4.3, it is easy the check whether\nan arbitrary process is an I/O process in a model checker, such as FDR.\n\nThese processes represent a wide variety of computational systems. Only the process itself\ncan control its outputs; non-determinism exists only in the outputs of the process, which do not\noffer any choice to the environment. The process CL presented earlier is an example of an I/O\nprocess: all traces ended by input events are not refused, while decisions about which output is\nperformed are internal.\n\n4.2 Communication protocols\n\nCommunication protocols are commonly associated to specifications of component behaviours\nat a specific abstraction level, with an exclusive focus on a portion of the communicated events.\nDespite its relation with components, these protocols are also studied apart to analyse the com-\nmunications through a channel. For homogeneity, we consider communication protocols as\nregular I/O processes. However, we show the relationship between protocols and more com-\nplex I/O processes, which encompass such communication protocols.\n\nDefinition 4.6 (Communication protocol). We say a CSP process P is a communication proto-\ncol if :\n\n\u2022 ?c1,c2 \u2022 inputs(P)?{|c1|}? outputs(P)?{|c2|};\n\nThe definition above says that a communication protocol is an I/O process that inputs solely\nby a unique channel (c1, for instance) and outputs solely by a unique channel (c2, for instance).\nThese channels can be the same, or be distinct channels (one channel for each direction). Note\n\n\n\n4.2 COMMUNICATION PROTOCOLS 38\n\nthat any protocol that inputs and outputs via one channel has an isomorphic counterpart with\ntwo distinct channels, and vice-versa. We use protocols with one channel in the examples of\nthis work, since we consider they might be associated to more complex analysis.\n\nIn the client-server example, we can identify two protocols in the communication between\nthe client and the server: one from the point of view of the client, and, the other, from the point\nof view of the server. These are the processes ProtCL and ProtSV , respectively.\n\nProtCL = (uval : Int \u2022 csv!wd.val ? csv.ackW d?a ? ProtCL)\n2 (csv!reqBal ? csv.resBal?x ? ProtCL)\n\nProtSV = (csv.wd?x ?ua : Bool \u2022 csv!ackW d.a ? ProtSV )\n2 (csv.reqBal ?uy : Int \u2022 csv!resBal.y ? ProtSV )\n\nThe inputs and outputs of these processes are implicit in their specification. These are:\n\noutputs(ProtCL) = inputs(ProtSV ) ={|csv.wd,csv.reqBal|}\ninputs(ProtCL) = outputs(ProtSV ) ={|csv.ackW d,csv.resBal|}\n\nThese are the inputs and outputs that client and server use to interoperate. As observed above,\nthe outputs of one process is the same set of the inputs of the other. This syntactical requirement\nis not enough to ensure compatibility (two processes interoperate without deadlock). It might\nbe necessary to verify the behaviour of the processes in the interaction. Moreover, two pro-\ncesses can successfully interoperate with different sets of inputs and outputs (one can accepts\nmore input events then those output by the other). A detailed study on this topic is presented in\nthe next section.\n\nAs communication protocols are essentially used for the study of interactions within a sys-\ntem, we assume that they do not have any traditional errors, such as deadlocks. Additionally,\nas a communication protocol is an I/O process, it is also divergence free by definition. This,\nhowever, does not forbid the study of communication over unreliable mediums. In this context,\nfor instance, IP (the Internet Protocol) would be a protocol that is used in an unreliable medium\n(internet).\n\nNote that communication protocols can be defined solely by their traces and their sets of\ninputs and outputs. This means that there is only one communication protocol for a given set\nof traces, input and output events.\n\nFor the sake of brevity, we use in this section the notion: IsP and O\ns\nP for the inputs and\n\noutputs performed by a process P after a trace s, respectively.\n\nIsP ={a : inputs(P)|s ^?a?? traces(P)} (4.5)\nOsP ={a : outputs(P)|s ^?a?? traces(P)} (4.6)\n\nBelow, we present failures of a communication protocol, based on the input determinism and\noutput decisiveness properties. They say that all possible enabled inputs cannot be refused, at\nmost one output is enabled and, if it exists, is never refused.\n\n\n\n4.2 COMMUNICATION PROTOCOLS 39\n\nTheorem 4.4. Let P be a communication protocol. Then\n\nfailures(P) ={(s,X)|s ? traces(P)? X ? ?8IsP ? (O\ns\nP = /0 ? O\n\ns\nP * X)}\n\nProof. Based on Definition 4.6, there are, at most, two channels in a communication protocol\nc1 and c2: one for inputing, and another for outputting. Based on the input determinism and the\noutput decisiveness properties, (s,X)? failures(P) if, and only if, s ? traces(P) and:\n\n?s ^?c1.a? : traces(P)|c1.a ? inputs(c1,P)\u2022{c1.a}* X ?\n?s ^?c2.b? : traces(P)|c2.b ? outputs(c2,P)\u2022 outputs(c2,P) * X ? (outputs(c2,P)8{c2.b})? X\n\n?[based on the IsP and O\ns\nP definitions, and considering outputs(c2,P) = outputs(P)]\n\n?a : IsP \u2022 (s,{a}) /? X ??b : O\ns\nP \u2022 outputs(P) * X ? (out puts(P)8{b})? X\n\n?[no event within IsP belongs to X ]\nX ? ?8IsP ??b : O\n\ns\nP \u2022 outputs(P) * X ? (s,out puts(P)8{b})? X\n\n?[if OsP is nonempty, then X does not contains all events within O\ns\nP]\n\nX ? ?8IsP ? (O\ns\nP 6= /0 ? O\n\ns\nP * X)\n\n?[rewriting]\nX ? ?8IsP ? (O\n\ns\nP = /0 ? O\n\ns\nP * X)\n\nThe theorem above says that the behaviour of a communication protocol can be determined\nby its traces, or, more specifically by the inputs and output offered after each trace. Based on\nthis, we could say, relaxing the restrictions of the CSP language, and for the sake of under-\nstanding, that the behaviour of a communication protocol P after a trace s is always an external\nchoice of its inputs and one of its outputs, if it exists, after s, as represented by the process TP(s)\nbelow.\n\nP =TP(??)\n\nTP(s) =(2a : IsP ? TP(s ^?a?))\n\n2\n\n(ub : OsP ? TP(s ^?b?))\nNaturally, it is desirable to relate communication protocols and more complex I/O processes,\n\nwith more than just one channel for input or output. For this, we use the basic notion of\nprojection.\n\nDefinition 4.7 (Projection). Let P be a process, and C a set of communication channels. The\nprojection of P over C (denoted by P |? C) is defined as:\n\nP |? C = P \\ (?8{|C|})\n\n\n\n4.2 COMMUNICATION PROTOCOLS 40\n\nProjections restrict the behaviour of a process to a set of events. It behaves as the hiding of\nall events, except from those within C. For the sake of brevity, when C is singleton, we consider\nan overloaded version of the operator |? to accept a channel name instead of the singleton set\ncontaining such a channel name. This operator also overloads the filter operator |? for traces,\nwhich has a similar semantics, but expects a trace instead of a process.\n\nObviously, communication protocols are very similar to projections over the events of a\nunique channel (or two channels, considering that one performs solely inputs and the other\noutputs). However, in this case, we should ignore possible divergences introduced by the re-\nstriction.\n\nBased on the definition of communication protocols, we have two related and distinct con-\ncepts: implementing a protocol (Protocol Implementation) and satisfying a protocol (Protocol\nSatisfaction).\n\nDefinition 4.8 (Protocol implementation). Let P be an I/O process, and ch a communication\nchannel. The communication protocol, namely ProtIMP(P,ch), implemented by P over ch is a\nprotocol that satisfies the following property:\n\nProtIMP(P,ch)?F P |? ch\n\nThe protocol implemented by a component (represented solely by a process at this point)\nis given by the abstraction of its behaviour projection over a specific channel. Moreover, the\nprotocol has the same traces and failures as the projection, but it is divergent-free. We use the\nfailures semantics here, since we ignore the possible divergences introduced by the restriction.\n\nCommunication protocols focus on their own events, and ignore other events which do not\npertain to the communication. Protocol implementations are usually associated to the commu-\nnication of a single channel, and ignore events of other channels. Infinite sequences of internal\nactions are ignored because of the inability of communication protocols to distinguish them\nfrom events of other ports. Therefore, analyses of communication protocols are limited in this\nwork to divergent-free processes. The prevention of divergences is analysed in this work using\nother techniques, presented in the end of this chapter.\n\nGeneralising the definition above, we now define whether a process satisfies a protocol.\nSuch a protocol is a given behaviour that satisfies its communication over a channel.\n\nDefinition 4.9 (Protocol satisfaction). Let P be an I/O process, ch a communication channel,\nand Q a communication protocol. The communication of P over ch satisfies the protocol Q, if,\nand only, if:\n\nQ vF ProtIMP(P,ch)\n\nProtocol satisfaction is an important notion in some architectures, since they may have a\nrestriction about the communication protocols a process must satisfy in order to communicate\nwith others.\n\nFinally, we say two protocols are equivalent if they are isomorphic.\n\nDefinition 4.10 (Equivalent protocols). Let P and Q be protocols, and R a bijection of events in\nthe alphabet of P into events in the alphabet of Q. Then P is equivalent to Q if, and only if:\n\nP[[R]]?F Q\n\n\n\n4.2 COMMUNICATION PROTOCOLS 41\n\nProtocol equivalence is an important notion in systems verification, where expected transla-\ntions are performed by the medium. This happens for instance, marshalling and unmarshalling\ndata communications in a network.\n\n4.2.1 Protocol compatibility\n\nThe idea of protocol compatibility is about checking the relation of two connected processes\nin a network, verifying whether any communication problem (such as deadlock) is introduced\nafter their composition (considering, for instance, that they are deadlock-free). As the name\nmight suggest, the analysis is based on local verification, focusing solely on the communication\nprotocols. As communication protocols use a unique channel to communicate its inputs or\noutputs, the analysis of communication protocol synchronisations is simpler than the analysis\nof complex I/O processes. For this reason, the analysis of protocol compatibility is an effective\nway of ensuring that the communication between two I/O processes is deadlock-free, as we\nexploit in the next chapters.\n\nBefore presenting the compatibility notion for protocols, a relevant concept is required:\nconjugate protocols. It is a syntactic property that states the outputs of a process are understood\nas inputs of another. It is commonly used as a prior verification step in order to check if two\nprotocols are compatible.\n\nDefinition 4.11 (Conjugate protocols). Let P and Q be two communication protocols. P and Q\nare conjugate if, and only if:\n\noutputs(P)? inputs(Q) ? outputs(Q)? inputs(P)\noutputs(P)?outputs(Q) = /0 ? inputs(P)?inputs(Q) = /0\n\nThe term conjugate is used in modelling notations, like UML-RT [SR98], to assume that\ntwo interfaces have the same set of signal, but events with inverted directions (if an event is\ndefined as an input in an interface, it is an output in the other interface). Here, we generalise\nthis concept to a behavioural specification, protocols. Moreover, conjugate protocols may have\nsets of events with different cardinalities.\n\nBased on these concepts, we can define the important notion of compatible protocols: pro-\ntocols whose communication (resulting from their synchronisation) is deadlock-free, based on\nthe syntactic concept of conjugate protocols.\n\nDefinition 4.12 (Protocol compatibility). Let P and Q be two deadlock-free communication\nprotocols, such that P and Q are conjugate. The protocols P and Q are compatible (denoted\nP ? Q) if, and only if:\n\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\ns\nP ? I\n\ns\nQ)? (O\n\ns\nQ 6= /0 ? O\n\ns\nQ ? I\n\ns\nP)\n\nThe definition above relates the communication of the two communication protocols P and\nQ, in order to avoid possible deadlocks in their communication. Definition 4.12 focuses on the\npossible traces the two processes synchronise, saying that there must always be an output event\n\n\n\n4.2 COMMUNICATION PROTOCOLS 42\n\nto be performed, and at least one of the process must have all enabled outputs accepted by\nthe other process; the fact that protocols are conjugate just reinforce that they perform output\nevents within the vocabulary understood by the other process.\n\nBesides the wide application of the definition above, sometimes it is useful to have a\nstronger notion of compatibility that requires that the outputs of a process are always accepted\nby the process it communicates with. In fact, systems that consider this stronger notion are\nconsidered to have better designs. Using the stronger notion, no information generated (an\noutput) by a process is leaked; all of them are understood by its peer in the communication.\n\nDefinition 4.13 (Strong protocol compatibility). Let P and Q be two deadlock-free communi-\ncation protocols, such that P and Q are conjugate. The protocols P and Q are strong compatible\n(denoted P??Q) if, and only if:\n\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\ns\nQ 6= /0)? O\n\ns\nP ? I\n\ns\nQ ? O\n\ns\nQ ? I\n\ns\nP\n\nThe definition above is very similar to the one for protocol compatibility. However it subtly\nadditionally says that the outputs of each process must be accepted by the other, in all scenarios.\nThis stronger notion is more widely accepted, and demanded in practical systems.\n\nIn the example of the client-server communication, the protocols ProtCL and ProtSV are com-\npatible. In every state, after performing an event, the outputs of one protocol are accepted by\nthe other. This is requirement for that client and server interoperate without deadlock.\n\nThe theorem below shows the inherent relation between protocol compatibility and dead-\nlock-freedom in our component model.\n\nTheorem 4.5. Let P and Q be two deadlock-free conjugate protocols. Then P ? Q is deadlock-\nfree if, and only if, they are compatible.\n\nProof. This theorem is a direct consequence of Lemma A.1 and the Deadlock Rule 1, presented\nin [Ros98], which says that any tree topology system free of strong conflict is deadlock-free;\nstrong conflicts are states in which two components have no choice of communicating with rest\nof the system, and they cannot establish a communication between them.\n\nThe system structure P ? Q has a tree form; no cycle is presented. Moreover, according to\nthe Lemma A.1, compatible protocols are free of strong conflicts. As a result, according to\nDeadlock Rule 1, the pair of processes is deadlock-free.\n\nDetails about the relations of compatible protocols and the work of [Ros98] are presented\nin Appendix A.\n\nDespite the relationship between deadlock-freedom and protocol compatibility in our com-\nponent model, we need a test characterisation to perform simpler verifications on regular model\ncheckers, such as FDR; a candidate strategy for this test characterisation is through refinement\nchecking, which is supported by some model checkers, including FDR. Because of its prac-\ntical appeal, we focus the definition of the test characterisation of protocols that are strong\ncompatible.\n\n\n\n4.2 COMMUNICATION PROTOCOLS 43\n\n4.2.1.1 Verifying compatibility via process refinement\n\nA testing characterisation of this notion via refinement can be defined upon a special process,\ncalled dual protocol [VVR06]. We define the dual of a protocol Q as a process whose sets of\ninputs and outputs are equal to outputs(Q) and inputs(Q), respectively, and which has the same\nset of traces.\n\nDefinition 4.14 (Dual protocol). Let P be a deadlock-free communication protocol. The dual\nprotocol of P is defined as a deadlock-free communication protocol DP, such that:\n\ninputs(P) = outputs(DP)? outputs(P) = inputs(DP)? traces(DP) = traces(P)\n\nBased on this, we could say, relaxing the restrictions of the CSP language, and for the sake\nof understanding, that the behaviour of the dual protocol DP of P after a trace s is always an\nexternal choice of the outputs and one of the inputs of P, if it exists, after s, as represented by\nthe process T DP(s) below.\n\nQ =T DP(??)\n\nT DP(s) =(ua : IsP ? T DP(s ^?a?))\n2\n\n(2b : OsP ? T DP(s ^?b?))\n\nIn the client-server example, the dual protocol of ProtCL is represented by the process DProtCL\nbelow. Observe that it is equivalent to ProtSV , in the example.\n\nDProtCL = (2val : Int \u2022 csv.wd.val ? (ua : Bool \u2022 csv.ackW d?a ? DProtCL))\n2 (csv.reqBal ? (2x : Int \u2022 csv.resBal?x ? DProtCL))\n\nSimilarly to the definition of protocol implementation, we can define the dual protocol associ-\nated to a specific channel.\n\nDefinition 4.15 (Dual protocol implementation). Let P be a communication protocol. The dual\ncommunication protocol of P is named ProtDUAL(P).\n\nBased on the Definition 4.14, an interesting observation can be made. Communication pro-\ntocols are compatible to their dual protocols. Having the same traces of P, the dual protocol is\nthe compatible process with most similar structure. In fact, it can be used to guide implemen-\ntations that wish to communicate with P. Observing the definition above, a systematic way to\nobtain the dual protocol of a protocol P is by replacing internal choices by external choices, and\nvice-versa, within P. This strategy allows implementations that communicate with the protocol\nto decide how they provide these inputs.\n\nLemma 4.1. Let P be a deadlock-free communication protocol, and DP its dual protocol. Then\nP and DP are strong compatible.\n\n\n\n4.2 COMMUNICATION PROTOCOLS 44\n\nProof. This proof follows directly from definitions 4.14 and 4.13. We start the proof by a true\nstatement.\n\n?t : traces(P)\u2022 IsP ? I\ns\nP ? O\n\ns\nP ? O\n\ns\nP\n\n?[P is deadlock-free]\n?t : traces(P)\u2022 (OsP 6= /0 ? I\n\ns\nP 6= /0)? I\n\ns\nP ? I\n\ns\nP ? O\n\ns\nP ? O\n\ns\nP\n\n?[Definition 4.14, OsP = I\ns\nDP, I\n\ns\nP = O\n\ns\nDP]\n\n?t : traces(P)?traces(DP)\u2022 (OsP 6= /0 ? O\ns\nDP 6= /0)? O\n\ns\nDP ? I\n\ns\nP ? O\n\ns\nP ? I\n\ns\nDP\n\n?[Definition 4.13]\nP and DP are strong compatible\n\nFrom the notion of dual protocol, we are able to state that, for a given process P: any\nprocess Q more deterministic than the dual protocol of P is also compatible with P.\n\nLemma 4.2. Let P and Q be deadlock-free communication protocols, and DP the dual protocol\nof P, such that DP vF Q. Then P and Q are strong compatible.\n\nProof. The lemma above follows directly from Lemma 4.1, since if Q refines the dual protocol,\nthen Q can substitute it in all possible scenarios. Based on Lemma 4.1:\n\n?s : traces(P)?traces(DP)\u2022 (OsP 6= /0 ? O\ns\nDP 6= /0)? O\n\ns\nP ? I\n\ns\nDP ? O\n\ns\nDP ? I\n\ns\nP\n\n?[traces(Q)? traces(DP)]\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\n\ns\nDP 6= /0)? O\n\ns\nP ? I\n\ns\nDP ? O\n\ns\nDP ? I\n\ns\nP\n\n?[failures(Q)? failures(DP) and protocols are input deterministic, IsDP = IsQ ? OsP]\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\n\ns\nDP 6= /0)? O\n\ns\nP ? I\n\ns\nQ ? O\n\ns\nDP ? I\n\ns\nP\n\n?[failures(Q)? failures(DP) and protocols are output decisive,\nOsQ ? O\n\ns\nDP, O\n\ns\nDP 6= /0 ? O\n\ns\nQ 6= /0]\n\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\ns\nQ 6= /0)? O\n\ns\nP ? I\n\ns\nQ ? O\n\ns\nQ ? I\n\ns\nP\n\n?[Definition 4.13]\nP and Q are strong compatible\n\nAnalysing the lemma above, we observe that in any state, determined by trace s, Q must\naccept the same number of inputs and a number of outputs less or equal to the dual protocol of\nP. Any process that satisfies this property can substitute the dual protocol, which is the default\nimplementation compatible to P. This notion reminds the covariance of operation results in\nprogramming languages.\n\nAs previously mentioned, the protocols ProtCL and ProtSV are compatible. In this example,\nthey satisfy the refinement ProtSV v DProtCL.\n\nThis test characterisation, defined in terms of refinement, can be mechanically carried out by\nthe FDR model checker. However, the refinement checking captured by Theorem 4.1 cannot be\n\n\n\n4.2 COMMUNICATION PROTOCOLS 45\n\ndirectly applied to verify all possible compatible protocols. The reason is that some protocols\nmay accept more inputs than necessary in a communication, and despite being compatible\nwith a protocol P, they do not refine its dual protocol. In other words, we need a notion that\ncomprises both the contravariance of inputs and covariance of outputs. This can be done using\na mechanism that restricts the events communicated to the ones used by the communication\nprotocol, similar to what happens when the protocols communicate in practice.\n\nA useful process to help in verification would be a deadlock-free process that represents\nall possible communications between a protocol P and another process compatible with it. We\ncall this process communication context of P. To define this process we need to consider the\nprotocol P, and another that represents a protocol compatible with it. By Theorem 4.1 the\nnatural candidate is a dual protocol DP. As the input events of P are outputs of DPP, we need\nonly to specify the communication context process with respect to P.\n\nDefinition 4.16 (Communication context process). Let P be a deadlock-free communication\nprotocol. The communication context process of P (denoted by CTXP) is defined as a deadlock-\nfree deterministic process, such that traces(CTXP) = traces(P).\n\nSimilarly to the definition of protocol implementation, we can define the communication\ncontext process associated to a specific channel.\n\nDefinition 4.17 (Communication context process implementation). Let P be a communication\nprotocol. The communication context process of P is named CTX(P).\n\nA systematic way to define the communication context process of P is by using external\nchoice for all outgoing transitions in states of P. All events must be written in the form ch?data,\nwhere ch is the name of a channel in the interface and data is an identifier to hold possible data\nvalues associated with the interface.\n\nBased on this, we could say, relaxing the restrictions of the CSP language, and for the sake\nof understanding, that the behaviour of the context process CT XP of P after a trace s is always\nan external choice of the outputs and inputs of P after s, as represented by the process T CP(s)\nbelow.\n\nCT XP =T CP(??)\n\nT CP(s) =(2a : IsP ? T DP(s ^?a?))\n\n2\n\n(2b : OsP ? T DP(s ^?b?))\n\nThe definition of a communication context process allows us to restrict proofs concerning\ncommunication via a specific protocol. Based on it, we are able to state the following lemma.\nIts proof follows directly from the fact that the context process of a process P is a deterministic\nprocess with the same trace as P; as a consequence, no event performed by P is refused by its\ncontext process.\n\n\n\n4.2 COMMUNICATION PROTOCOLS 46\n\nLemma 4.3. Let P be deadlock-free a communication protocol, DPP its dual protocol, and CTXP\nthe context process of P. Then CTXP satisfies:\n\nP ?F P ? CTXP ?\nDPP ?F DPP ? CTXP\n\nProof. This lemma follows directly from the semantics of parallel operators, see Section 3.3.2.\nWe focus on the first equivalence; the proof of the second follows a similar strategy.\n\ntraces(P ? CTXP) = traces(P)?traces(CTXP)?\nfailures(P ? CTXP) ={(t,X ?Y )|(t,X)? failures(P)? (t,Y )? failures(CTXP)}\n?[traces(P) = traces(CTXP), failures(CTXP)? failures(P)]\n\ntraces(P ? CTXP) = traces(P)?traces(P)?\nfailures(P ? CTXP) ={(t,X ?Y )|(t,X)? failures(P)? (t,Y )? failures(P)}\n\n?[failures theory]\ntraces(P ? CTXP) = traces(P)?\nfailures(P ? CTXP) = failures(P)}\n\n?[equivalence in the failure model]\nP ?F P ? CTXP\n\nFrom Theorem 4.5, for protocol compatibility, and from Lemma 4.3, for communication\ncontext process, we are now able to construct a stronger test characterisation for protocol com-\npatibility based on refinement, which can be verified in the model checker FDR.\n\nTheorem 4.6. Let P and Q be two deadlock-free conjugate protocols. Then, P and Q are strong\ncompatible if, and only if:\n\nProtDUAL(P)vF Q ? CTX(P)\n\nProof. The proof has two parts, each corresponding to one implication direction in the theorem.\n1) We start by proving that ProtDUAL(P)vF Q ? CTX(P) implies in P??Q.\n\nThe first statement of the proof comes directly from the definition of dual protocols. For\nthe sake of brevity, consider in the proof DP = ProtDUAL(P).\n\n?s : traces(P)?traces(DP)\u2022 (OsP 6= /0 ? O\ns\nDP 6= /0)? O\n\ns\nP ? I\n\ns\nDP ? O\n\ns\nDP ? I\n\ns\nP\n\n?[traces(Q ? CTX(P))? traces(DP), traces(Q ? CTX(P)) = traces(Q)?traces(CTX(P)),\ntraces(CTX(P)) = traces(P)]\n\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\ns\nDP 6= /0)? O\n\ns\nP ? I\n\ns\nDP ? O\n\ns\nDP ? I\n\ns\nP\n\n?[failures(Q ? CTX(P))? failures(DP) and protocols are input deterministic, IsDP = I\ns\nQ ? O\n\ns\nP]\n\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\ns\nDP 6= /0)? O\n\ns\nP ? I\n\ns\nQ ? O\n\ns\nDP ? I\n\ns\nP\n\n?[failures(Q ? CTX(P))? failures(DP), OsQ ? O\ns\nDP, O\n\ns\nDP 6= /0 ? O\n\ns\nQ 6= /0]\n\n?s : traces(P)?traces(Q)\u2022 (OsP 6= /0 ? O\ns\nQ 6= /0)? O\n\ns\nP ? I\n\ns\nQ ? O\n\ns\nQ ? I\n\ns\nP\n\n?[Definition 4.13]\nP and Q are strong compatible\n\n\n\n4.3 BUFFERING 47\n\n2) The second part concerns the proof that P??Q implies that ProtDUAL(P)vF (Q ? CTX(P)).\n\n?(s,X) : failures(CTX(P)? Q)\u2022 true\n?[Failures semantics, P ? Q is deadlock-free ? CTX(P)? Q is deadlock-free]\n?(s,X) : failures(CTX(P)? Q)\u2022\n\ns ? traces(Q)?traces(CTX(P))? X ? ?8(IsQ ? O\ns\nP)? (O\n\ns\nQ 6= /0 ? O\n\ns\nQ * X)\n\n?[P??Q, OsP ? I\ns\nQ]\n\n?(s,X) : failures(CTX(P)? Q)\u2022\ns ? traces(Q)?traces(CTX(P))? X ? ?8OsP ? (I\n\ns\nQ 6= /0 ? I\n\ns\nQ * X)\n\n?[Definition 4.16]\n?(s,X) : failures(CTX(P)? Q)\u2022\n\ns ? traces(CTX(P))?traces(P)? X ? ?8OsP ? (I\ns\nQ 6= /0 ? I\n\ns\nQ * X)\n\n?[Lemma 4.4]\n?(s,X) : failures(CTX(P)? Q)\u2022 (s,X)? failures(ProtDUAL(P))\n\nConsidering the two results above, we conclude the proof of the theorem.\n\nThe theorem is informally explained by the observation of the two processes: ProtDUAL(P)\nand Q ? CTX(P). As ProtDUAL(P) is a protocol, it is deadlock-free and an I/O process. And so\nis the process Q ? CTX(P). From Lemma 4.4, in order to satisfy the refinement, Q ? CTX(P)\nmust have the same inputs and less or equal outputs than ProtDUAL(P). The role of CTX(P) in\nthe synchronism is to restrict the events performed by Q, as a consequence Q has more or the\nsame number of inputs than ProtDUAL(P). Moreover, Q must have less or equals outputs than\nthe dual protocol, in order to Q ? CTX(P) be output decisive. As a consequence, considering\nthe complementary directions of the events in P and in its dual protocol, the processes Q and P\nhave the requirements to the strong compatible.\n\nTheorem 4.6 presents an important test characterisation for protocol compatibility, which\nplays an important role in the verification of component compositions. All elements in the test\n(protocols, dual protocols and context processes) are usually provided at integration time, or\ncan be easily derived from the protocols, as previously shown.\n\nThis concludes our compatibility notions for individual communication protocols. A dis-\ncussion about networks of I/O is performed in the next sessions.\n\n4.3 Buffering\n\nIn this work we focus on the interoperation of asynchronous systems, which is an important\nissue on real concurrent systems. This brings a new concern in analysis of deadlock freedom:\nhow we can check if two processes can interoperate in asynchronous systems. Moreover, we\nare concerned how this can scale this verification, and if we bring our previous notions about\nprotocol compatibility in synchronous systems (which is the communication semantics of CSP\nprocesses) to this context.\n\n\n\n4.3 BUFFERING 48\n\nIn the next section, we present how asynchronous communication of I/O processes is spec-\nified via buffers. In Section 4.3.2, we study the analysis of systems with asynchronous com-\nmunications, as if their communication were synchronous. Moreover, we link our notion of\nprotocol compatibility with the idea of buffer tolerance, and we introduce a new notion of\nbuffering self-injection compatibility, which allows us to assembly two channels of a process\nvia a buffer, without introducing deadlocks.\n\n4.3.1 I/O buffers\n\nA classical definition of an (one place) buffer in CSP (as presented in [Ros98]) is of a process\nwith one input channel and one output channel (left and right, say) both of which have the same\ntype. The buffer copies information from its input channel to its output channel, preserving\norder and without loss, and such that it never refuses to output an item it contains and will not\nrefuse to input when empty.\n\nMore formally, any buffer satisfies the following specification [Ros98]:\n\n(i) All a buffer does is input on left and output on right. It correctly copies all its inputs to its output\nchannel, without loss or reordering.\n\n(ii) Whenever it is empty (i.e., it has output everything it has input) then it must accept any input.\n\n(iii) Whenever it is non-empty, then it cannot refuse to output.\n\nHere, we make a slightly change to generalise the notion of buffers, and ease the mapping\nof events in the two sides of the buffer. Instead of left and right channels, we assume they\nare distinct sets of events; more precisely, the domain and the range of a bijection called LR.\nFor instance, the simplest example of a buffer process, the process COPY , could be written as\nfollows:\n\nCOPY (LR) =?x : dom LR ? LR(x)? COPY(LR)\n\nwhere LR ={le f t.x 7? right.x|x ? T}\nThis can be easily translated into a specification in terms of failures and divergences. For\n\nany buffer B:\n\n1. divergences(B) = /0\n\n2. s ? traces(B)? s ? (dom LR?ran LR)? ? s ? ran LR ? s ? dom LR\n\n3. (s,X)? failures(B)? s ? ran LR = s ? dom LR ? X ?dom LR = /0 ? (s,ran LR)? failures(B)\n\n4. (s,X)? failures(B)? s ? ran LR &lt;s ? dom LR ? ran LR * X\n\nNote that the specification above translates the general specification of buffers presented\nearlier (items i, ii and iii) in terms of failures and divergences; it is also similar to the specifica-\ntion of buffers with left and right channels presented in [Ros98]. The operator s ? X returns the\ncardinality of events within X in the trace s, and it is used to specify states of the buffer (like\nempty and non-empty).\n\n\n\n4.3 BUFFERING 49\n\nAnother example is a buffer process which, unlike COPY , does not insist upon outputting\none thing before inputting the next. It represents an infinity buffer B?.\n\nB?(LR) = B???(LR) =?x : dom LR ? B\n?\n\n?x?\n\nB?\ns ^?y?(LR) = (?x : dom LR ? B\n\n?\n\n?x?^ s ^?y?(LR))\n\n2(LR(y)? B?s (LR))\n\nWe can also imagine a buffer of arbitrary Bn(LR) size as the pipeline of several one-place\nbuffers COPY (LR).\n\nBn(LR) = COPY (LR)?LR COPY (LR)?LR \u00b7\u00b7\u00b7?LR COPY (LR)\n\nThe operator ?LR is a new chain operator that instead of using left and right, takes LR into\nconsideration:\n\nP ?LR Q = (P[[RM]] ?\nmid\n\nQ[[LM]])\\ mid\n\nwhere LR, RM and LM are bijections and mid is a set of events, such that (? P?? Q)? (dom LR?\nran LR), (dom LR?ran LR) = /0, (dom LR?ran LR)?mid = /0, ran RM = mid, ran ML = mid, dom RM =\nran LR, and dom LM = dom LR.\n\nThe new chain operation is as simple as the original one [Ros98]; it renames events of both\nprocesses to an intermediary set of events (mid) and synchronise them on this set. For the sake\nof brevity, we consider that mid is an arbitrary set of events unused by the processes. LR is used\nas a reference to all other arbitrary bijections, used for the renames.\n\nIn all buffer specifications, events within left and right are associated to a definite direction:\ninput and output, respectively. However, it is possible to define similar constructions which\nconvey information in both directions. Instead of the traditional definition of buffer with left and\nright, we specify a bidirectional buffer parametrised by an ordinary buffer and two bijections.\n\nBUFFIO(BF,LR1,LR2) = (BF(LR1) ||| BF(LR2))\n\nFor the sake of brevity, we consider BUFF1IO and BUFF\n?\nIO as the following process:\n\nBUFF1IO(LR1,LR2) =BUFFIO(COPY,LR1,LR2)\n\nBUFFnIO(LR1,LR2) =BUFFIO(B\nn,LR1,LR2)\n\nBUFF?IO(LR1,LR2) =BUFFIO(B\n?\n\n??,LR1,LR2)\n\n4.3.2 Buffer tolerance\n\nAn important issue on real concurrent systems is the ability of verifying them without buffers.\nThe main reason is the reduction in state-space that this brings in the verification of asyn-\nchronous communications, usually modelled by buffers. Related to this is the term buffer tol-\nerance [Ros05b], which refers to systems into which buffers may be introduced onto their\nchannels without introducing any extra error. So, certain properties of buffer tolerant systems\n\n\n\n4.3 BUFFERING 50\n\ncan be analysed in the absence of buffers, considering a synchronous semantics. And, later on,\nthese properties are still valid in analogue systems (with buffers introduced onto their channels)\nwith asynchronous semantics.\n\nWe use in this work the notions of buffer tolerance as a strategy to analyse systems with\nasynchronous communications, as if their communication were synchronous (which is the com-\nmunication semantics of CSP processes). In addition to the work [Ros05b], we present here\ncompatibility notions for systems interoperate in mediums with asynchronous communication.\nFurthermore, we link our notion of protocol compatibility with the idea of buffer tolerance, and\nwe introduce a new notion of buffering self-injection compatibility, which allows us to assem-\nbly two channels of a process via a buffer, without introducing deadlocks. Other notions that\nsupport this strategy are also presented by demand.\n\nAs established in [Ros05b], the idea of confluent processes [Mil89, Ros06] is a useful tool in\nthe area of buffer tolerance. Using them, we are able to establish properties of buffered systems\nby checking their buffer-less analogues. A process or computation is said to be confluent if,\nwhenever a state has two alternative actions ? and ? , then performing either of them does not\npreclude the other and furthermore performing them in either order leads to equivalent states.\n\nFormally, a process P is confluent if P s=? Q1 and P\nt\n\n=? Q2 then there exists R with Q1\nt?s\n=? R\n\nand Q2\ns?t\n=? R where s?t is the trace consisting of s with the events of t deleted according to\n\nmultiplicity from the beginning. For example:\n\n?a,b,c,c,b,a???d,c,b,a,c?= ?b,a?\n\nConsider a bag BAG2 = {d 7? 1,c 7? 2,b 7? 1,a 7? 1} from the multiplicity of the events in\nthe sequence SEQ2 = ?d,c,b,a,c?. Delete events of SEQ1 = ?a,b,c,c,b,a? from events of SEQ2,\naccording to multiplicity from the beginning, is the same of, for each pair (ev 7? n) in BAG2,\ndelete the first n events ev of SEQ1, as shown in the statement above.\n\nMoreover, a set of traces is said to be confluent if it satisfies the following (apparently\nweaker) property [Ros05b]:\n\n\u2022 Consider T as the set of traces of a process P. P is confluent if whenever s ^?a?^ t and\ns ^?b? (with a 6= b) are both in T , so is s ^?b,a?^(t ??b?).\n\nTo help the use of the notion of confluence in a broader range of systems, we relax its\ndefinition a little, distinguishing only choices among input or output events. We call such a\nloose confluence an I/O confluence.\n\nDefinition 4.18 (I/O confluence). Let P be an I/O process. Then P is I/O confluent if and only\nif :\n\n?s ^?c1.a?^ t,s ^?c2.b? : traces(P)|c1.a 6= c2.b \u2022\n(c1.a ? inputs(P)??i : inputs(P,c1)|s ^?c2.b,i?^(t ??c2.b?)? traces(P))?\n(c1.a ? outputs(P)??o : outputs(P,c1)|s ^?c2.b,o?^(t ??c2.b?)? traces(P))?\n(c1 = c2 ? ({c1.a,c2.b}? outputs(P)?{c1.a,c2.b}? inputs(P)))\n\nThe notion above retains most of the useful properties of confluent process. However, it\nconsiders the specificities of I/O processes. It also does not consider if the event performed\n\n\n\n4.3 BUFFERING 51\n\nis an input or an output. In other words, a process is said to be I/O confluent if, whenever a\nstate has two alternative actions ? and ? , then performing either of them does not preclude\nthe other, unless it is a choice among inputs or outputs of the same channel. If ? is an input,\nthen performing ? does not preclude the process offering all inputs offered together with ? . If\n? is an output, then performing ? does not preclude the process offering at least one output\noffered together with ? . Outputs are treated differently because their decisions are internal to\nthe process, and, furthermore, performing an event may preclude outputs of happening in the\nfuture. As a result, instead of alternative actions leading to equivalent states in I/O confluent\nprocesses, they lead to \u2018less-deterministic states\u2019, where fewer outputs can be offered.\n\nIn the example of the client-server communication, the processes CL and SV are two exam-\nples of I/O confluent processes. They are categorised in the simplest case, in which there is no\nchoice among events of different channels, neither choices among inputs and outputs.\n\nObserve that I/O confluent processes are similar to channel-confluent processes [Ros05b],\nwhich are processes whose data component abstractions is also confluent; this result also ap-\nplies to the case where there are specific channels for inputs and outputs. This relates this loose\nnotion of confluence to the study performed by [Ros05b]. Moreover, I/O confluence states that\nthe communication of pending outputs is not interfered by input provisions, and vice-versa. In\nsuch aspect, they remind function agents [Ros05b]. This ensures, for instance, that when an\ninput and an output are simultaneously offered in a channel, whenever the decision is made,\nthese events are eventually performed by the process. In other words, pending outputs or a\nchoice among inputs are not denied; they are just postponed.\n\nTheorem 4.7. Let P be a process, {c1,...cn} the set of channels used in P, {ai1,ao1,...ain,aon}\na set of events, and R a bijection, such that R = { j, b| j ? 1...n ? b ? inputs(P,c j) \u2022 (b 7? ai j)}?\n{ j, b| j ? 1...n ? b ? outputs(P,c j)\u2022 (b 7? ao j)}. Then the process P is I/O confluent if the process\nP[[R]] is confluent.\n\nProof. The Lemma above is a direct consequence of the definition of confluent and of I/O\nconfluent processes..\n\n?s ^?c1.a?^t, s ^?c2.b? : traces(P)|c1.a 6= c2.b \u2022\nc1.a ? input(P)? c1.a ? outputs(P)\n\n? [P[[R]] is confluent]\n?s ^?c1.a?^ t, s ^?c2.b? : traces(P)|c1.a 6= c2.b \u2022\n\n(c1.a ? inputs(P)? ((?i : inputs(P,c1)|s ^?c2.b,i?^(t ??c2.b?)? traces(P))?\nc2.b ? inputs(P,c1)))?\n\n(c1.a ? outputs(P)? ((?o : outputs(P,c1)|s ^?c2.b,o?^(t ??c2.b?)? traces(P))?\nc2.b ? outputs(P,c1)))\n\n? [rewriting]\n?s ^?c1.a?^ t, s ^?c2.b? : traces(P)|c1.a 6= c2.b \u2022\n\n(c1.a ? inputs(P)??i : inputs(P,c1)|s ^?c2.b,i?^(t ??c2.b?)? traces(P))?\n(c1.a ? outputs(P)??o : outputs(P,c1)|s ^?c2.b,o?^(t ??c2.b?)? traces(P))?\n(c1 = c2 ? ({c1.a,c2.b}? outputs(P)?{c1.a,c2.b}? inputs(P)))\n\n\n\n4.3 BUFFERING 52\n\nThe work presented in [Ros05b, Ros06], presents a test characterisation of confluence,\nby checking if placing inwards buffers of size one from the environment to a process P, the\nresulting process is deterministic.\n\nTheorem 4.8. The process P is confluent if, and only if, the process C?[P], in which a one-place\ninwards-pointing buffer is placed on every individual event of P, is deterministic.\n\nProof. Details about the proof of this theorem can be obtained in [Ros05b].\n\nThis is a consequence of confluence processes being deterministic that , by combining them\nusing restrict constructors, result in confluent processes [Ros06]. The relation of confluent\nprocesses and their synchronisation with inwards buffers makes quite a subtle observation about\nthe nature of communication by confluent processes, and their relation with the buffer tolerant\nnotion.\n\nThe theorem above shows a test characterisation that is completely characterised by deter-\nminism under a particular sort of transformation; as a consequence, checking whether a process\nis confluent is feasible in FDR. Details about the C?[P] process are explained in [Ros05b].\n\nAnother important notion, required in communication through infinite buffers, is the finite\noutput property (FOP). It states that a process P cannot perform an infinite number of outputs\nwithout an input.\n\nDefinition 4.19 (Finite output property). Let P be an I/O process, and C the set of channels\nused in P. P satisfies the finite output property (FOP) if, and only if, for all c ? C the process\nP \\ outputs(P,c) is divergence-free.\n\nAs an I/O process is divergence-free, the absence of divergences after hiding the outputs\nof a certain channel guarantees that the process always communicate a finite number of out-\nputs. Based on this property, we are able to introduce buffers in a system without blocking the\ncommunication; processes that do not satisfy FOP may infinitely produce events to the buffers\nwithout being able to consume them.\n\nBelow, we show the relevance of such properties on the communication of protocols.\n\nTheorem 4.9. Let P and Q be two deadlock-free I/O confluent communication protocols with\ndistinct alphabets, BF a deterministic buffer, and LR1 and LR2 two bijections, such that:\n\n1. P and Q satisfy FOP;\n\n2. LR1 : outputs(P)? inputs(Q) and LR2 : outputs(Q)? inputs(P);\n\n3. P[[LR1]]??Q[[LR2]].\n\nThen the synchronization of P and Q via a buffer BF is deadlock-free.\n\nP ?\n? P\n\nBUFFIO(BF,LR1,LR2) ?\n? Q\n\nQ\n\n\n\n4.3 BUFFERING 53\n\nProof. The proof of this theorem is based on the theory of confluent processes, and their abil-\nity to be buffer tolerant [Ros05b]. Besides confluence, another weaker notion, called channel\nconfluence has this property. Channel confluent processes are processes whose pattern of com-\nmunication is independent of which data is sent, and abstracting such data this pattern obeys the\nconfluence property. Buffer tolerant systems have the property of preserving deadlock freedom\nafter buffers are introduced into its internal channels.\n\nSimilarly to channel confluent processes, I/O confluent processes are buffer tolerant. The\nreason is that any communication protocol P has an equivalent protocol P? with two channels,\none for communicating inputs and the other for outputs; this is obtained from a simple bijective\nrenaming. If P is I/O confluent, then P? is channel confluent. Similarly, the process Q has an\nanalogue protocol Q? that is channel confluent. A synchronisation of P? and Q? is buffer tolerant,\nand having an equivalent behaviour, so is the synchronisation of P and Q.\n\nGiven these considerations, we start our proof by the following statement, based on the\nTheorem 4.5. Consider, for a given process S, INS = inputs(S) and OU TS = outputs(S).\n\nP[[LR1]]? Q[[LR2]] is Deadlock-free\n?[P and Q are equivalent to channel confluent processes]\n(P ?\n\nOU TP\nBF(LR1)) ?\n\nINP?INQ\n(Q ?\n\nOU TQ\nBF(LR2)) is Deadlock-free\n\n?[? BF(LR1)?? BF(LR2) = /0]\nP ?\n\nINP?OU TP\n(BF(LR1)) ||| BF(LR2)) ?\n\nINQ?OU TQ\nQ is Deadlock-free\n\n?[according to definition of BUFFIO, P and Q are I/O processes ]\nP ?\n\n? P\nBUFFIO(BF,LR1,LR2) ?\n\n? Q\nQ is Deadlock-free\n\nThe theorem above shows that two confluent and compatible protocols that satisfy FOP can\ncommunicate in an asynchronous medium, represented by infinite buffers, without deadlock.\nMore important, all these properties can be verified without taking infinite buffer into account,\nand, furthermore, avoiding the state explosion on model checkers usually related to it.\n\nNote that this theorem can be applied to establish an asynchronous communication between\nthe client and the server, in our example. As previously mentioned the protocols CL and SV are\nstrong compatible. They also satisfy FOP and allow a bijection between their alphabets.\n\n4.3.3 Buffering self-injection\n\nThe protocol compatibility notion (Definition 4.12) is usually used to check the communica-\ntion between two distinct processes. However, sometimes, we have to understand the relation\namong distinct channels of the same component, probably one that contains other inner compo-\nnents. For this reason, we introduce another notion of compatibility, which is very similar to the\npreviously presented, except for the fact that we do not compare the communication between\ntwo simple processes (protocols) but the communication between events of the same process.\n\n\n\n4.3 BUFFERING 54\n\nDefinition 4.20 (Buffering self-injection compatibility). Let P be a deadlock-free I/O process,\nand c and z channels. Then P j = P |? {|c,z|} is buffering self-injection compatible if, and only if:\n\n1. ?(s,X) : failures(P j)|(s ? Oc = s ? Iz)? (s ? Oz = s ? Ic)\u2022 X ?(Oc ?Oz) = /0\n\n2. ?(s,X) : failures(P j)|s ? Oc > s ? Iz \u2022 (s |? z,X ?{|c|})? failures(P j |? z)\n\n3. ?(s,X) : failures(P j)|s ? Oz > s ? Ic \u2022 (s |? c,X ?{|z|})? failures(P j |? c)\n\nwhere Oc = outputs(P,c), Oz = outputs(P,z), Ic = inputs(P,c) and Iz = inputs(P,z)\n\nThe lemma below shows that a buffering self injection compatible process can establish a\ncommunication between its channels via a one-place buffer without deadlock.\n\nLemma 4.4. Let P be an deadlock-free I/O process, c and z communication channels, and LR1\nand LR2 bijections, such that:\n\n1. LR1 : outputs(P,c)? inputs(P,z) and LR2 : outputs(P,z)? inputs(P,c)\n\n2. ProtIMP(P,c)[[LR1]]??ProtIMP(Q,z)[[LR2]]\n\n3. ProtIMP(P,c) an ProtIMP(Q,z) satisfy FOP\n\nThen, P |? {|c,z|} is buffering self-injection compatible if, and only if, the following process is\ndeadlock-free:\n\nP |? {|c,z|} ?\n{|c,z|}\n\nBUFF1IO(LR1,LR2)\n\nProof. The proof of this lemma is carried by case analysis. We contradict the theorem above,\nshowing that for each possible case where the process deadlocks there is a possible communi-\ncation to perform.\n\nThe process deadlocks when P and the two buffers within BUFF1IO are stuck. Therefore, in\nthis proof, we analyse each case where BUFF1IO may deadlock. These are: when the buffers are\nempty, and no output of P comes out; and when at least one buffer is full.\n1) In the first case, every time both buffers are empty, the process P has communicated the\nsame number of events through c and z. In this case, the last event communicated by P cannot\nbe an output; if so, the buffer would not be empty. Therefore, since P is buffering self-inject\ncompatible, P may output something in this case. These processes do not deadlocks.\n\nBelow, we present the formal proof for this case, showing that if it deadlocks, then we have a\ncontradiction. Assume that Oc = outputs(P,c), Oz = outputs(P,z), Ic = inputs(P,c), Iz = inputs(P,z),\nPJ = P |? {|c,z|} and BF = BUFF1IO(LR1,LR2)\n\nP |? {|c,z|} ?\n{|c,z|}\n\nBF deadlocks\n\n?[Lemma 3.1]\n?(s,X) : failures(PJ)\u2022 (s,?8X)? failures(BF )\n\n\n\n4.3 BUFFERING 55\n\n?[buffers are empty]\n?(s,X) : failures(PJ)| (s ? Oc = s ? Iz)? (s ? Oz = s ? Ic)?\n\n(s,?8X)? failures(BF )? (?8X)?(Oc ?Oz) = /0\n?[P is buffering self-injection compatible, X ?outputs(PJ) = /0]\n?(s,X) : failures(PJ)| (s ? Oc = s ? Iz)? (s ? Oz = s ? Ic)?\n\n((?8X)?(Oc ?Oz) = /0)? (X ?(Oc ?Oz) = /0)\n?[contradiction]\n\nfalse\n\n2) In the second case, at least one buffer is full. Below, we present the formal proof for\nthis case, showing that if it deadlocks, then we have a contradiction. Here, we also assume\nthat Oc = outputs(P,c), Oz = outputs(P,z), Ic = inputs(P,c), Iz = inputs(P,z), PJ = P |? {|c,z|}, BF =\nBUFF1IO(LR1,LR2), Pc = ProtIMP(P,c) and Pz = ProtIMP(P,z). We start the proof by a consequence\nof the compatibility of the protocol implementation, and Lemma 3.1.\n\n?(s,X) : failures(BF )\u2022 (s,?8X) /? f ailures(Pc ||| Pz)\n?[Lemma 3.1, Proj ? BF deadlocks]\n?(s,X) : failures(BF )\u2022 (s,?8X) /? failures(Pc ||| Pz)?\n\n(s,?8X)? failures(Pro j)\n?[The failures semantics of the interleave operator, see Section 3.3.2]\n?(s,X) : failures(BF )\u2022 (s |? c,?8X) /? f ailures(Pc)? (s |? z,?8X) /? f ailures(Pz)?\n\n(s,?8X)? failures(Pro j)\n?[at least one buffer is full, P is buffering self-injection compatible]\n?(s,X) : failures(BF )\u2022 (s |? c,?8X) /? f ailures(Pc)? (s |? z,?8X) /? f ailures(Pz)?\n\n((s |? z,(?8X)?{|c|})? failures(Pro j |? z)?\n(s |? c,(?8X)?{|z|})? failures(Pro j |? c))\n\n?[Definition 4.8, failures(Pro j |? c) = failures(Pc)? failures(Pro j |? z) = failures(Pz)]\n?(s,X) : failures(BF )\u2022 (s |? c,?8X) /? f ailures(Pc)? (s |? z,?8X) /? f ailures(Pz)?\n\n((s |? z,?8X)? failures(Pz)? (s |? c,?8X)? failures(Pc))\n?[contradiction]\n\nfalse\n\nThis theorem could be used, for instance, in the development of the client-server example.\nSuppose that, due to a design decision, one achieves a process S = CL ||| SV , and then wishes to\ncommunicate the client and the server enclosed in S. This is a classical case that requires a self-\ninjection assembly. In this case, the client and the server fulfil the requirements of buffering\nself-injection.\n\nWe observe that this result can be easily expanded from communications with an one-place\nbuffer to an infinite buffer, if the process is also confluent.\n\n\n\n4.3 BUFFERING 56\n\nTheorem 4.10. Let P be an deadlock-free I/O confluent process, c and z communication chan-\nnels, BF a deterministic and infinite buffer and LR1 and LR2 bijections, such that:\n\n1. LR1 : outputs(P,c)? inputs(P,z) and LR2 : outputs(P,z)? inputs(P,c)\n\n2. ProtIMP(P,c)[[LR1]]??ProtIMP(Q,z)[[LR2]]\n\n3. P |? {|c,z|} is buffering self-injection compatible and satisfy the FOP\n\nThen, the following process is deadlock-free:\n\nP ?\n{|c,z|}\n\nBUFFIO(BF,LR1,LR2)\n\nProof. This theorem is a direct result of Lemma 4.4 and the fact of the process is I/O confluent.\nSince I/O confluent processes are channel confluent, then it is buffer tolerant, which means that\nan arbitrary number of buffers can be introduced without introduce new errors. A system that\nis deadlock-free will be also deadlock-free after introducing such buffers. So BF represents\na pipeline of an arbitrary number of one-place buffers. We start the proof from the result of\nLemma 4.4.\n\nP ?\n{|c,z|}\n\nBUFF1IO(LR1,LR2) is deadlock-free\n\n?[I/O buffer definition]\nP ?\n{|c,z|}\n\n(COPY (LR1) |||COPY (LR2)) is deadlock-free\n\n?[P and COPY are channel confluent]\n\nP ?\n{|c,z|}\n\n(\n(COPY (LR1)?LR1 \u00b7\u00b7\u00b7?LR1 COPY (LR1)) |||\n(COPY (LR2)?LR2 \u00b7\u00b7\u00b7?LR2 COPY (LR2))\n\n)\nis deadlock-free\n\n?[BF represents a buffer of arbitrary size]\nP ?\n{|c,z|}\n\n(BF(LR1) ||| BF(LR2)) is deadlock-free\n\n?[I/O buffer definition]\nP ?\n{|c,z|}\n\nBUFFIO(BF,LR1,LR2) is deadlock-free\n\nAn interesting subclass of I/O processes is the one with decoupled channels. In this class\nof processes, the communication through two channels of a same process behaves as commu-\nnications between channels of distinct processes.\n\nDefinition 4.21 (Decoupled channels). Let P be an I/O process and Ch a set of channels. Then,\nthe channels within Ch are decoupled in P (denoted by Ch DecoupledIn P) if, and only, if:\n\nP |? Ch ?F |||\nz?Ch\n\nProtIMP(P,z)\n\nBelow, we present the expected relation between the two notions of compatibility in pro-\ncesses with decoupled channels.\n\n\n\n4.4 SAFE HIDING 57\n\nTheorem 4.11. Let P be an deadlock-free I/O process, c and z communication channels, and\nLR1 and LR2 bijections, such that:\n\n1. LR1 : outputs(P,c)? inputs(P,z) and LR2 : outputs(P,z)? inputs(P,c)\n\n2. ProtIMP(P,c)[[LR1]]? ProtIMP(Q,z)[[LR2]]\n\n3. {c,z} DecoupledIn P\n\nThen, P |? {|c,z|} is buffering self-injection compatible.\n\nProof. The proof of this theorem is underpinned by the notion of protocol compatibility and by\nLemma 4.4. We start by the fact that the synchronisation of compatible protocols is deadlock-\nfree (Theorem 4.9).\n\n(ProtIMP(P,c) ||| ProtIMP(P,z)) ?\n{|c,z|}\n\nBUFF1IO(LR1,LR2) is deadlock-free\n\n?[Definition 4.5, ProtIMP(P,z)vF Pz?, ProtIMP(P,c)vF Pc? ]\n(Pc? ||| Pz?) ?\n\n{|c,z|}\nBUFF1IO(LR1,LR2) is deadlock-free\n\n?[{c,z}DecoupledIn P, P |? {c,z}?F Pz? ||| Pc?]\nP |? {|c,z|} ?\n\n{|c,z|}\nBUFF1IO(LR1,LR2) is deadlock-free\n\n?[Lemma 4.4]\nP |? {|c,z|} is self-injection compatible\n\n4.4 Safe hiding\n\nA notion related to projection is safe-hiding. Instead of focusing on the behaviour that remains\nafter hiding some events, this notion focuses on the preservation of a certain property after the\nhiding operation has been applied. More specifically, safe-hiding states that hiding does not\nintroduce divergences.\n\nDefinition 4.22 (Safe hiding). Lets P be a process, and C a set of channels. The process P\\{|C|}\nis safe-hide if, and only, if:\n\n?s ^ t ^ u : traces(P)|t is infinite \u2022 chans(t) * C\n\nLemma 4.5. Let P be a divergence-free process, and X a set of events. Then:\n\n?s : traces(P) | s is infinite ? s \\ X is finite\n\u2022?x,y,z|(x ^ y ^ z = s)? ((x ^ z)\\ X = s \\ X ? y is infinite)\n\n\n\n4.4 SAFE HIDING 58\n\nProof. As s is infinite, and after hiding events within X it becomes finite, then an infinite part\nof s is hidden. This is the fundamental fact that sustains the lemma above. y represents this\ninfinite hidden part. x and z are used to relate y to s.\n\nAs s \\ X is finite, and y is hidden, then the unhidden part is equals to (x ^ z) \\ X . Note that\nexcept from the fact that y is infinite, x and z can assume any size, even zero, depending on the\nlocation of y in the trace s.\n\nThe definition states that no infinite trace has an infinite part formed only of hidden events;\nthe part is identified as an infinite sequence of events that are communicated via the hidden\nset of channels. Basically, the definition states a condition to where hiding does not introduce\ndivergences. It focuses on the verification of the channels of the possible problematic infinite\ntraces. Despite its calculation is as hard as traditional calculations of divergences, its conclusion\ncan be useful to scenarios where traces obey specific patterns, and, furthermore, where the\nchannels used within these patterns can be easily figured out.\n\nNext, we show the theorem that proves the application of safe-hiding to the preservation of\ndivergence freedom.\n\nTheorem 4.12. Let P be a divergent-free process, and C a set of channels, such that P \\{|C|} is\na safe-hide. Then P \\{|C|} is divergent-free.\n\nProof. As there is no infinite trace hidden, no divergence is introduced. Furthermore, P \\{|C|}\nis divergence-free. Below, we calculate the divergences of the hidden process P \\{|C|}, based\non the denotational semantics of infinite traces, presented in Sec. 10.1 in [Ros98].\n\ndivergences(P \\{|C|})\n=[hiding semantics ]\n\n{(u \\{|C|}) ^ t |u ? infinites(P)? t ? ??X ? u \\{|C|} is finite}?\n{(s \\{|C|}) ^ t |s ? divergences(P)??? ? t ? ??X}\n\n=[P is divergence-free]\n\n{(u \\{|C|}) ^ t |u ? infinites(P)? t ? ??X ? u \\{|C|} is finite\n=[substituting y ^ x ^ z = u, Lemma 4.5]\n\n{((x ^ y ^ z)\\{|C|}) ^ t |x ^ y ^ z ? infinites(P)? t ? ??X ? (x ^ y ^ z)\\{|C|}= (x ^ z)\\{|C|}?\nx ^ z is finite ? y is infinite\n\n=[x ^ y ^ z \\ X = x ^ z \\ X ? y \\ X = ??]\n{((x ^ y ^ z)\\{|C|}) ^ t |x ^ y ^ z ? infinites(P)? t ? ??X ? (x ^ y ^ z)\\{|C|}= (x ^ z)\\{|C|}?\nx ^ z is finite ? y is infinite ? chans(y)?C\n\n=[P \\{|C|} is safe-hide]\n/0\n\nThis concludes our characterisation of the I/O processes, and related concepts. This is used\nas a basis for our component model and its constructive constraints.\n\n\n\nCHAPTER 5\n\nThe BRIC component model\n\nThe aim of this chapter is to define the component model used in this work. This model delim-\nits the broad outline of what constitutes a component in our approach, exposing its necessary\nrelated technical concepts and constraints. This component model, which we informally call\nBRIC, characterises not only components, but connectors as well as their interaction seman-\ntics. As a consequence, the BRIC component model defines the building blocks of our sys-\ntematic development approach, which is aligned with an overall engineering discipline based\non component, and considers important desirable issues on this area, previously pointed out in\nSection 2.4.\n\nThe BRIC component model characterises (re)active components in this work and how\nthey interact. The behaviour of these components are represented by I/O processes (pre-\nsented in Section 4.1). Moreover, they can interact either synchronously or asynchronously,\nas presented further in this chapter. These concepts are compatible with other component mod-\nels [HLL06b, ADG98, BCD02, BHP06]. In fact, other Architectural Description Languages\n(ADL) [MT00], or even the UML 2.0 [Obj07] might be used as a concrete syntax for the\nconcepts presented here; an example of similar mapping is presented in [RSM05]. The BRIC\ncomponent model presents connectors as first class design entities, which are aimed not only\nfor composition but also for reuse. The separation of concerns between components and con-\nnectors, as well the composition of the latter elements, allows the exogenous coordination of\ncomponents. Although coordination is allowed, it is not the focus of this thesis. We focus\nthe discussion on this chapter in the compositions of components, which is the basis for our\nsystematic strategy for components in the next chapter.\n\nThe rest of this chapter formalises several concepts in CBSE, such as interfaces, com-\nponents, port-protocols, component composition and connectors, as part of our architectural\ncomponent model. They are defined independently of any quality attribute, or without know-\ning further information about any target component technology. In the end of this chapter\n(Section 5.3), we introduce some architectural styles that do assume some constraints to fa-\ncilitate reasoning and analysis. In special, we present the BRICK component model, which\nenriches arbitrary BRIC components with metadata. As we show, such metadata store partial\ninformation used in verifications of compositions. Furthermore, they are rich tools to alleviate\nverifications. Constructive constraints for this architectural component model are presented in\nthe next chapters, embodied in a rigorous development process that provide assistance in wiring\ncomponents together, or updating them in a predictable way.\n\n59\n\n\n\n5.1 A COMPONENT-BASED SYSTEM EXAMPLE 60\n\n5.1 A component-based system example\n\nIn our approach, components and connectors are basically represented by black-box design ele-\nments, with defined interaction points (or ports) and a dynamic (external) behaviour, which are\nformally expressed by channels and a process in CSP, respectively. To illustrate the proposed\nnotions, we use an example: the communication between a CLIENT and a SERVER component\nin a simple ATM system (see Figure 5.1). When necessary, we assume the runtime environment\nas another, possibly a set of, components. However, in this example, no additional service is\nrequired from the environment, and, furthermore, its representation is immaterial.\n\nFigure 5.1 An example of a simple ATM System.\n\nThe architectural configuration of the system in Figure 5.1 shows all design entities and their\nrespective ports. Each component has an observational dynamic behaviour, which describes\nhow it reaches different states during its execution, based on external events. This is the same\nexample presented in Chapter 3, but we lift the definition of processes to components in this\nchapter.\n\nIn the example, the entire system is represented by a component, which is hierarchically\ncomposed of other components and connectors. After identification (through a card and pin),\nthe CLIENT component offers to the user a choice between withdrawing money and checking\nits account balance. Both withdraw and balance operations are expected to be performed by\nanother component. In our example, the SERVER component is responsible for these operations.\nThe connector CON helps to sort out communication issues between these components, such\nas heterogeneity. Further details are shown in the next sections.\n\n5.2 BRIC component model\n\n5.2.1 Interfaces\n\nComponent capabilities are usually described by means of interfaces, which define the provided\nand the required services of a component. In this work, we assume that interfaces simply consist\nof input and output events in CSP, which may express pairs of request-response or individual\nsynchronisation events of a service. At this level of abstraction, a pair with an input and an\noutput event might be understood as representing, for instance, the invocation of a method.\n\nBefore we define interfaces, we present the definition of I/O types that represent communi-\ncations with distinct events for input and output.\n\n\n\n5.2 BRIC COMPONENT MODEL 61\n\nDefinition 5.1 (I/O type). Let T and U be two disjoint sets of values. Then, we define an I/O\ntype as a set parameterised by these two sets, as follows:\n\nIOTT,U = in.T|out.U\n\nI/O types are associated at a fundamental level with the set of elements communicated by\na component. In fact, we observe them as sets of elements, whose values within T and U are\nassociated with the tags in and out. In a communication between a pair of components, typically\nT and U will be the sets of input and output values for one component and, conversely, the set\nof output and input values for the other component. Therefore, IOTT,U would be the I/O type of\none component and IOTU,T the I/O type of the other component.\n\nIn order to illustrate our notions, we revisit the example of the client-server communication\npresented in Section 3.2. We present here a new specification for the same problem. The run-\nning example is slightly modified to make explicit the direction of the events in communication.\nIn our example (see Figure 5.1), the interfaces IUS, ICL and ISV have the following I/O types.\n\nIUS = IOTUSIN ,USOU T\nICL = IOTCLIN ,CLOU T\nISV = IOTCLOU T ,CLIN\n\nwhere CLOU T , CLIN , USIN and USOU T are defined by the datatypes below.\n\nCLOU T = wd.Int|reqBal\nCLIN = ackW d.Bool|resBal.Int\nUSIN = insertCard.Int|enterPin.Int|withdraw.Int|balance\n\nUSOU T = takeCard|takeCash|takeSlip.Int\n\nNote that the I/O types of ICL and ISV are parametrised by the same set of values. In order to\nallow communication, the parameters of one I/O type have the reverse order of the other; this\nmeans that outputs of one are observed as inputs of another, and vice-versa. To ease readability,\nwe avoid such explicit parametrisation using the following abbreviations.\n\nDefinition 5.2 (Interface). Let TIN and TOU T be sets of values for input and output communica-\ntion of a given component. We call the types that represent the interface of such a component a\nregular interface and a conjugate interface (namely I and ?I, respectively), and define them as\nfollows:\n\nI = IOTTIN ,TOU T ?I = IOTTOU T ,TIN\n\nWe also define the projection functions inputs and out puts as follows:\n\ninputs(I) = ran(in)?I outputs(I) = ran(out)?I\n\nAs a result of Definition 5.2, a regular interface is a type whose input and output events are\ntagged by in and out, respectively, whereas a conjugated interface has input and output tagged\nby out and in, respectively. In our example, ICL =?ISV . The modifiers in and out also behave\nas functions that take an arbitrary value and yields the same value prefixed by those modifiers.\n\n\n\n5.2 BRIC COMPONENT MODEL 62\n\nAs a consequence of Definition 5.1, the ranges of in and out represent all inputs and outputs of\nthe system. For this reason, these modifiers are elegant candidates for defining the projection\nfunctions inputs and out puts; the intersection with the whole interface restricts the range of in\nand out (ran(in) and ran(out), respectively) to those values within the interface. For instance,\nfor TIN ={a,b} and TOU T ={w,z}, inputs(I) = outputs(?I) ={in.a,in.b} and outputs(I) = inputs(?\nI) ={out.w,out.z}. For the sake of brevity, we use ? as an operator that takes a regular interface\nand yields a conjugate interface, and vice-versa. So that ??I = I.\n\nDespite interfaces being an important concept to capture component interaction, it is not\nsufficient for ensuring the correct development of component based applications [RM04]. A-\npart from a static representation provided by interfaces, design entities are also expressed by\ntheir dynamic behaviour. Interfaces define the type of a component port. In other words, an\ninterface defines a set of possible events communicated by components via its ports. Thus, each\nport is associated to one interface. For instance, in our example, CLIENT uses the ports cl and\nus, and SERVER uses the port sv. In CSP, the association of a port with its type is syntactically\nexpressed in the channel definition, as follows.\n\nchannel cl : ICL\nchannel us : IUS\nchannel sv : ISV\n\n5.2.2 Regular components\n\nIn the definition below, we define a component contract in terms of its behaviour (represented\nas a CSP process), ports (represented as channels) and respective interfaces (types).\n\nDefinition 5.3 (Component contract). A component contract Ctr comprises an observational\nbehaviour B, a set of communication channels C, a set of interfaces I, and a total function\nR : C? I between channels and interfaces:\n\nCtr : ?B,R,I,C?\n\nsuch that\n\n\u2022 B is an I/O process\n\n\u2022 dom R = C ? ranR = I\n\n\u2022 Let c ?C, outputs(c,B) ={out.x : R(c)\u2022 c.out.x} and inputs(c,B) ={in.x : R(c)\u2022 c.in.x}\n\nA component is defined as an autonomous entity that deterministically offers its inputs, but\nnondeterministically decides which outputs it performs. These behaviours are represented by\nthe input deterministic and output decisive properties, satisfied by the component (see the Def-\ninition 4.5 of I/O process). Determinism is important to improve the reuse of the component:\ni) it always accepts to communicate the input services previously offered to the environment\n(other components); ii) the input events offered to the environment depends only on things it\n\n\n\n5.2 BRIC COMPONENT MODEL 63\n\nhas seen (i.e., the sequence of communications so far). The nondeterminism on outputs pro-\nvides the component with the ability to take internal decisions based on its inputs (autonomous\nentity).\n\nIn our component model, we do not distinguish between required and provided interfaces.\nThese, however, are immaterial in our strategy, since we concentrate our effort on composition.\nThe associated verification is not limited to syntactical checking, but also cope with verifica-\ntions in elaborated systems.\n\nObserving I/O processes, it is easy sometimes to classify an event as output or input, ac-\ncording to the process that enables it. However, this is not a reliable procedure. For this reason,\nwe rely on the interfaces to identify the type and the direction of the events. The syntactic\nelements of a component contract complement the behavioural ones. Among the four elements\nthat constitutes the contract definition, R is the only one that does not have an explicit counter-\npart in behavioural specification languages, like CSP; it represents the link between the channel\nnames and their types. The third statement in the definition above links the abstract functions\ninputs and out puts related to I/O channels (see Definion 4.1) to the in and out tags defined by\nthe interfaces; these functions are overloaded here in many scenarios, returning inputs and out-\nputs of interfaces, channels and components. This component contract definition observes the\ncomponent in isolation; other constructive constraints are defined in the next chapter to forbid\nundesirable synchronism with the environment.\n\nFor verification purposes (or further observations), we do not restrict the component dy-\nnamic behaviour B to communicate only events within {|C|}. Channels within C are those\nexternally observed, and used in direct compositions with other components (see next section).\nOther channels, which do not belong to C, represent communication among subparts (or con-\nstituting components) of the component. This distinction provides a certain kind of white-box\ncomponent that is especially useful in testing, verification or observation about the system and\nits constituting parts. Of course, we also provide means to hide such internal channels, in case\nsomeone wants to ship a black-box component (presented later in Section 5.2.5).\n\nThe notation {|ch|} is very useful; it allows us to turn any set of channels and partially\ndefined events into the corresponding events. For instance, if ch communicates values of the\nset {1,2}, {|ch|}={ch.1,ch.2}.\n\nEqually, the notation {|C|} =\n?\n\nc:C{|c|} represents the set of all events represented by chan-\nnels or partially defined events within C. As a consequence, the alphabet of events of a compo-\nnent Ctr externally observed by other components is given by {|CCtr|}. Similarly, the observed\ntraces of this component are defined within the transitive closure set of this alphabet ({|CCtr|}?).\n\nTo exemplify a component contract, we show it in CSP syntax. In our example, the CLIENT\ncomponent (see Section 5.1) has its contract defined by CtrCLIENT . It has two ports: us and cl,\nwhich are typed by IUS and ICL, respectively. The former port provides services to the user, and\nthe latter delegates these services to another component (SERVER).\n\nCtrCLIENT = ?CLIENT,{us 7? IUS,cl 7? ICL},{IUS,ICL},{us,cl}?\n\nThe component and its interfaces are illustrated in the CLIENT structure in Figure 5.1. Syntac-\ntically, channels and interfaces of this contract are written in CSP as previously presented. The\ndynamic behaviour is presented next.\n\n\n\n5.2 BRIC COMPONENT MODEL 64\n\nFigure 5.2 The Client behaviour.\n\nAs we focus on the interaction of CLIENT and SERVER, we explain only the events used in\ntheir communication. In the example, the events in ICL are those used by CLIENT to interact with\nSERVER. ICL contains the events for withdrawing money (tagged with wd) and for requiring and\nreceiving an account balance (tagged with reqBal and resBal, respectively). These events use the\n(assumed) built-in data types Bool and Int to represent boolean and integer values, respectively.\nThe CLIENT behaviour is illustrated by the statechart in Figure 5.2. Formally, its behaviour is\nwritten in CSP as follows.\n\nCLIENT =us.in.insertCard?num ? us.in.enterPin? pin ?\n(W DRAW 2 BAL) ; us.out!takeCard ? CLIENT\n\nW DRAW =us.in.withdraw?val ? cl.out!wd.val ? cl.in.ackW d?a ?\nus.out!takeCash ? SKIP\n\nBAL =us.in.balance ? cl.out!reqBal ? cl.in.resBal?x ?\nus.out!takeSlip.x ? SKIP\n\nThe process CLIENT is the specification of the component dynamic behaviour in CSP. All\ninput and output events are defined by the component interfaces. To help readability in our\nspecification, we assume that a request event with an input parameter takes the form ch.in.tag?x,\nwhere ch is the name of a channel and x acts as an input pattern, which can be empty (as\nin the event balance) or with a variable (as in insertCard?num). The notation ch.out!v is used\nfor response events, where v is an expression. The data processing starts by acquiring the card\nnumber from the environment using the channel us. Next, the prefix operator (?) states that the\nevent us.in.enterPin? pin takes place, representing the validation of the user token and password.\nThen, CLIENT offers two choices deterministically (2): it engages either on the events withdraw\nor balance, to withdraw money or to check the account balance, respectively. Each of the\nalternative operations is started by the occurrence of the cl.out!wd or the cl.out!reqBal event,\nand can be completed by the cl.in.ackW d?a or the cl.in.resBal?x event, respectively. The events\nus.out!takeCash, us.out!takeCard and us.out!takeSlip inform the user about the operation result\nand finalisation.\n\n\n\n5.2 BRIC COMPONENT MODEL 65\n\nNow we present the SERVER component contract, which provides bank services to the\nCLIENT component.\n\nCtrSERVER = ?SERVER,{sv 7? ISV},{ISV},{sv}?\n\nSyntactically, the dynamic behaviour of this contract is written in CSP as follows.\n\nSERVER = sv.in.wd?x ? (ua : Bool \u2022 sv.out!ackW d.a)? SERVER\n2 sv.in.reqBal ? (uy : Int \u2022 sv.out!resBal.y)? SERVER\n\nThe SERVER component has a provided interface ISV whose values for input and output com-\nmunication are defined in the opposite direction of those in ICL. We have defined ISV as a regular\ninterface in order to ease the understanding of the communication direction in the SERVER be-\nhaviour. The way the communication between CLIENT and SERVER is bridged is presented in\nSection 5.2.3.\n\nThe process SERVER offers a deterministic choice (2) between a withdraw and a balance re-\nquest, which is represented by the occurrence of the communications sv.in.wd?x and sv.in.reqBal.\nAfter receiving a withdraw or balance request, it internally decides (nondeterministic choice\nu) the value of the withdraw acknowledgement (ackW d!a) and that of the balance response\n(resBal.y); the nondeterministic choice is usually associated to abstract internal actions of the\ncomponent that decides the value that is output.\n\nObserve that a component contract does not define the port-protocol that it satisfies. It is\nusually an information given at deployment, used before component integration. In case a port-\nprotocol is not provided at the integration phase, we automatically derive it from the component\nbehaviour (see Definition 4.8), since a port-protocol is in fact a specification that a component\nrealises during the communication with other components. As presented in Definition 4.8,\nthe function ProtIMP(.,.) takes an I/O process (in our case the component behaviour) and a\nchannel, and returns the port-protocol associated to them. For the sake of brevity, we consider\nan overloaded version of the function to accept a component contract instead of an I/O process;\ni.e. it takes a component contract Ctr and a channel c. We call port-protocol, or communication\nprotocol, the protocol associated with the port of a component. For the sake of clarity, when\nthe context explicitly associates behaviour to a port, we might call the port-protocol as just\nprotocol.\n\nProtIMP(Ctr,c) = ProtIMP(BCtr,c)\n\nFor instance, in our example, the projection of CLIENT over the channel cl is expressed as\nfollows.\n\nProtIMP(CtrCLIENT,cl) = \u00b5 X \u2022 cl.out!wd.val ? cl.in.ackW d ? X\n2 cl.out!reqBal ? cl.in.resBal?x ? X\n\nObserve that the port-protocol is equivalent to the projection of the entire dynamic behaviour\nof CLIENT over the corresponding port (cl).\n\nUsually, a component is defined once and reused multiple times, and in multiple different\ncontexts. In this work, we represent these contexts as a set of channels, since channels represent\ninteraction points of the component, and each channel is used to communicate with a single\ncomponent in the environment. So, replacing the channels of a component contract by another\n\n\n\n5.2 BRIC COMPONENT MODEL 66\n\nset means that it supposedly interacts with another environment. In this work, this replacement\nis represented by a bijection of the set of channels of the component contract into a set with\nnew channels. To avoid performing indefinitely replacements, every time we want to reuse the\nspecification, this bijection assumes that the target interaction points have an index. So, reuse\nfrom now on is made by adopting a new identification for the component we wish to use.\n\nDefinition 5.4 (Component contract instantiation). Let Ctr be a component contract, and F a\nbijection between name prefixes, such that dom F = CCtr and F(c) has the form c..x...y, where\nx...y is a sequence of one or more integers combined by dots. Then the instance of Ctr according\nto F , denoted by CompINST (Ctr,F), is represented by the contract CtrF .\n\nCtrF = ?B[[F]],F?1 ; R,I,ran F?\n\nIn the definition above, all elements of the new component are derived from the bijection\nand from the older component contract. The behaviour of the new component contract (B[[F]])\nis equivalent to the older one, except that it uses a new set of interaction points (the range of\nthe bijection, ran F ). The interfaces are still the same, and mapping from interaction points into\ninterfaces are represented by a composition of the bijection (in inverse function F?1) with the\nrelation R. Note that all port-protocols of the new component are equivalent with the protocols\nof the older one, see Definition 4.10. The interaction point takes the form c.x...y, in which c is\na channel and x..y are identifiers of components; usually one of these identifiers is assigned to\nthe component itself and the other to components that it interacts with.\n\n5.2.3 Connectors\n\nConnectors establish coordination rules that govern component interaction and specify any aux-\niliary mechanisms required [SG96], such as mapping between heterogeneous communication\ninterfaces. They are regarded more broadly as exogenous coordinators [PA98, Arb06], intended\nto mean \u2018coordination from outside\u2019 the components.\n\nTo increase the range of components they integrate, connectors are abstractly defined at\nthe design level to serve the needs of unspecified components. They become components only\nlater in the life-cycle, on the assembly with the components, by relying on the component\ncontracts [MB05].\n\nWe represent the dynamic behaviour of abstract connectors as parametrised CSP processes,\nwhose parameters represent component ports and their respective roles in the composition\n(channels and port-protocols, respectively). When all parameters are instantiated, connectors\nare ready to be composed with other components, or to form more elaborate connectors. The\nfirst issue of connectors is that they allow reuse.\n\nDefinition 5.5 (Abstract connector). An abstract connector AC(SC,SI,SP) is described by a be-\nhaviour parameterised by a sequence of distinct channels SC, a sequence of arbitrary interfaces\nSI and a sequence of processes SP, such that #SC = #SP = #SI ? ?i : 1..#SI \u2022 ? SP(i) ={SI(i)}.\n\nA connector is formed by elements similar to a component, but its behaviour is parame-\nterised. Instead of sets of channels and interfaces, we use sequences, which are more suitable\nto parametrise the connector specification. We consider the sequence of processes as protocols\n\n\n\n5.2 BRIC COMPONENT MODEL 67\n\nover the channels that parametrise the connector. For consistency among these parameter se-\nquences, we establish that they have the same size, and that all processes only communicate\nvalues on their associated interfaces. When the connector parameters are instantiated, it be-\ncomes a component that behaves according to the connector behaviour. Sequences are used in\nthe definition of connector to help the parametrisation of the connectors.\n\nDefinition 5.6 (Connector instantiation). Let AC be an abstract connector, SC a sequence of\nchannels, SP a sequence of processes, and SI a sequence of interfaces, such that SC, SP and SI\nsatisfy the constraints to be parameters of AC. Then F(AC,SC,SI,SP) is a component contract\ndefined by:\n\nF(AC,SC,SI,SP) = ?AC(SC,SI,SP),{i : 1..#SC \u2022 (SC(i) 7? SI(i))},ran SI,ran SC?\n\nThe definition above bridges the gap between two abstraction levels: an abstract connector\nat design stage and its instantiation at component integration and deployment level. We say\nthat the function F has an instantiation role. It takes an abstract connector AC and its list of\nparameters (SC, SI and SP) and constructs a component, which is a concrete version of AC.\n\nOne of the simplest and most common abstract connectors is the one whose behaviour is\npresented below. It is parametrised by two channels, and its purpose is to copy any value\ncommunicated by one channel to the other. It does not perform any verification concerning\nprotocols, so the protocol parameters are not referenced in the definition.\n\nConcopy(?c1,c2?,?I1,?I1?,SEQP) = \u00b5 X \u2022\nc1?x : inputs(I1)? c2.reverse(x)? X\n2 c2?y : inputs(I2)? c1.reverse(y)? X\n\nwhere reverse(in.x) = out.x,reverse(out.x) = in.x\nObserve that input values of c1 and c2 are tagged by out, and outputs by in. The reason is\n\nthat this connector aims at mediating the communication between two components with regular\ninterfaces. So, an output of a component is transmitted to the other component, and vice-versa.\n\n5.2.4 Composition\n\nThe traditional composition idea about assembling two components is to perform parallel syn-\nchronisation among the channels they share in common, so that, an output is only transmitted\nwhen the other component is enabled to input it, and vice-versa.\n\nHowever, this brings a major barrier to our approach: sometimes, we wish to connect two\nchannels of a same component. This is especially important when we have a larger component\nformed of an interleaving of other inner components. In this case, the composition of the inner\ncomponents is postponed as a design decision.\n\nThe answer to this problem is to observe what happens with real applications, as hardware,\ndistributed and agent oriented systems, which are naturally asynchronous, or, at most, what is\ncalled, globally asynchronous locally synchronous (GALS) [Cha85]. Synchronism is achieved\nby direct (local) assemblies of components or by specific communication protocols or orches-\ntration in networks of components, which communicate asynchronously.\n\nTo represent asynchronous communication, we introduce buffers as intermediary elements\nof the composition. They copy information from one component channel to another, ignoring\n\n\n\n5.2 BRIC COMPONENT MODEL 68\n\nif the other component is enabled to input. Components may still be assembled directly using\nparallel operators in order to build more complex components, but certain compositions would\nbe allowed only through buffers, as shown in Fig. 5.3. Buffers could be considered as regular\nconnectors, but, due to their importance, we consider them as integral part of our strategy; other\nconnectors can be introduced later, if desired.\n\nThese buffers have the same structure as those presented in Section 4.3.1. However, compo-\nnent interfaces provide the syntactic support for the abstraction presented there. The mapping\nbetween outputs and inputs is translated as a renaming between the tags in and out (see I/O\ntypes). Considering this, we overload the function BUFFIO to receive a pair of channels, in-\nstead of bijections. The renaming used on this buffer is:\n\nR a?bIO ={a.out.x 7? b.in.x}\n\nthe elements a and b are placeholders for two channels. R a?bIO replaces outputs of a by inputs of\nb.\n\nFor the sake of brevity, we consider BUFF1IO, BUFF\nn\nIO and BUFF\n\n?\nIO as the following pro-\n\ncesses:\n\nBUFF1IO(c,z) =BUFFIO(COPY,R\nc?z\nIO ,R\n\nz?c\nIO )\n\nBUFFnIO(c,z) =BUFFIO(B\nn,R c?zIO ,R\n\nz?c\nIO )\n\nBUFF?IO(c,z) =BUFFIO(B\n?\n\n??,R\nc?z\nIO ,R\n\nz?c\nIO )\n\nFor instance, consider the communication between the processes P and Q below via the chan-\nnels c and z. Consider that P and Q has no channels in common, and that BUFF?IO(c,z) is an\ninfinite buffer that copies information from c to z, and vice-versa.\n\nP ?\n{|c|}\n\nBUFF?IO(c,z) ?\n{|z|}\n\nQ\n\nor, using the interleave operator.\n\n(P ||| Q) ?\n{|c,z|}\n\nBUFF?IO(c,z)\n\nObserving the form of the statement above, we are able to define a composition of an\narbitrary number of processes, assembling an arbitrary even number of channels.\n\nFigure 5.3 Composition using a buffer\n\n\n\n5.2 BRIC COMPONENT MODEL 69\n\nTo help us in this definition, we first specify an auxiliary function AsyncComp. The function\nAsyncComp takes a set of processes S and a bijective function F among distinct sets of channels\nused by processes within S and yields the assembly of the processes within S, connecting each\nchannel c to its respective channel represented by F(c).\n\nAsyncComp(S,F) =\n(\n|||\n\nP?S\nP\n)\n?dom F\n\n(\n|||\n\nc?dom F\nBUFF?IO(c,F(c))\n\n)\nor, considering PS = |||\n\nP?S\nP\n\nAsyncComp(S,F) = PS?dom F\n(\n|||\n\nc?dom F\nBUFF?IO(c,F(c))\n\n)\nObserve that the compositions can be constructed based on the function AsyncComp, indepen-\n\ndently of the form of PS or the number of channels mapped by F .\nFor the sake of brevity, we define component composition in two modes: a binary operation\n\non two components, and a unary operation over a component. Both are variations of the notions\nintroduced above. These variations are distinguished in order to explicit the common uses the\nfunction AsyncComp(.,.) and the properties related to each kind of use. First, we define the\ncomposition between two distinct components.\n\nDefinition 5.7 (Asynchronous binary composition). Let P and Q be two distinct component\ncontracts, and ?c1,..,cn? and ?z1,..,zn? sequences of distinct channels within CP and CQ, respec-\ntively, such that CP ?CQ = /0. Then, the asynchronous binary composition of P and Q (namely\nP?c1,..,cn? ??z1,..,zn? Q) is given by:\n\nP?c1,..,cn? ??z1,..,zn? Q = ?(AsyncComp({BP,BQ},{ci 7? zi|i ? 1..n}),RPQ,IPQ,CPQ?\n\nwhere CPQ = (CP ?CQ)8{c1,..,cn,z1,..,zn}, RPQ = CPQ C (RP ?RQ), and IPQ = ranRPQ\nIn this definition, we assume each component has a distinct set of interaction points (CP ?\n\nCQ = /0), and that their communication is asynchronous, mediated by buffers. The behaviour\nof the composition is defined by the synchronisation of the components (P or Q) with an in-\nfinite buffer in all interactions of the channels mapped by F (this is expressed by the process\nAsyncComp); we consider infinity buffer here, as they represent the worst case we can found.\nAny communication related to a channel mapped by F is not offered to the environment in fur-\nther compositions (CPQ). The operator C stands for domain restriction; it is used to restrict the\nmapping from channels into interfaces (RPQ) and, furthermore, to restrict the set of interfaces\nin the composition contract (IPQ). It is important to observe that the sequences ?c1,..,cn? and\n?z1,..,zn? have distinct channels, this helps to avoid that components share the same interaction\npoints (channels); the communication have to be intermediate via a buffer.\n\nThe binary composition behaves similarly to the piping (or chaining) CSP operator [Ros98].\nHowever, it does not oblige pipelines of assembled processes to have the same interface type;\nthe channels used in the composition are explicitly defined. Moreover, the buffer explicitly\nrepresents the bindings of different interface types, rather than the implicit renaming performed\nby such CSP operator.\n\nBelow we show how the composition can be used to construct well-formed component\ncontracts (elements that satisfy the conditions to be a component contract in our component\nmodel).\n\n\n\n5.2 BRIC COMPONENT MODEL 70\n\nTheorem 5.1 (Binary Composition Monotonicity). Let P and Q be component contracts, and\n?c1,..,cn? and ?z1,..,zn? sequences of distinct channels within CP and CQ, respectively, such that\nthe behaviour (B) in P?c1,..,cn? ??z1,..,zn? Q is deadlock-free. Then P?c1,..,cn? ??z1,..,zn? Q is a compo-\nnent contract.\n\nProof. In order to proof that the resulting tuple is a component contract, we have to show that\nits structure is compatible with Definition 5.3. This is provided by the use of the direct com-\nposition, P[|||]Q = P?? ? ??Q (see Definition 5.7). Moreover, the behaviour of the component is\nalso an I/O process, since the composition does not introduce divergences (no hiding operation\nor undesired renaming is performed), the infinite behaviours of the original components result\nin a new infinite process, and the resulting process is input deterministic and output decisive\nwith respect to the channels that remain in contract, C (see theorems 4.1 and 4.2).\n\nThe other composition mode concerns the assembling among channels of the same compo-\nnent.\n\nDefinition 5.8 (Asynchronous unary composition). Let P be a component contract, and ?c1,..,\ncn? and ?z1,..,zn? sequences of distinct channels within CP, such that {c1,..,cn}?{z1,..,zn} = /0.\nThen, the asynchronous unary composition of P (namely P ?|?c1,..,cn??z1,..,zn?) is given by:\n\nP ?\n???c1,..,cn?\n?z1,..,zn?\n\n= ?(AsyncComp({BP},{ci 7? zi|i ? 1..n}),RPQ,IPQ,CPQ?\n\nwhere CPQ = CP8{c1,..,cn,z1,..,zn}, RPQ = CPQ C RP, and IPQ = ranRPQ\n\nThe definition above is similar to the one for binary composition. It differs on the number\nof processes passed to AsyncComp. This allows us to assembly channels of a same component,\ninstead of two distinct components.\n\nBelow we show how the composition can be used to construct well-formed component\ncontracts (elements that satisfy the conditions to be a component contract in our component\nmodel).\n\nTheorem 5.2 (Unary Composition Monotonicity). Let P be a component contract, and ?c1,..,cn?\nand ?z1,..,zn? sequences of distinct channels within CP, such that the behaviour (B) in P?|\n\n?c1,..,cn?\n?z1,..,zn?\n\nis deadlock-free. Then P ?|?c1,..,cn??z1,..,zn? is a component contract.\n\nProof. In order to proof that the resulting tuple is a component contract, we have to show that\nits structure is compatible with Definition 5.3. This is provided by the use of the unary compo-\nsition, P[ic \u00af??oc] = P ?\n\n???ic?\n?oc? (see Definition 5.8). Moreover, the behaviour of the component is\n\nalso an I/O process, since the composition does not introduce divergences (no hiding operation\nor undesired renaming is performed), the infinite behaviours of the original components result\nin a new infinite process, and the resulting process is input deterministic and output decisive\nwith respect to the channels that remain in contract, C (see tTheorems 4.1 and 4.2).\n\nThe composition operators presented in both definitions follow some commutative, dis-\ntributive and identity properties.\n\n\n\n5.2 BRIC COMPONENT MODEL 71\n\nRule 5.1. Let P and Q be two component contracts, and cs1, zs1, cs2, zs2, cs3 and zs3 sequences\nof channels. Then:\n\nPcs1 ?zs1 Q = Qzs1 ?cs1 P (5.1)\n\nP = P ?|???? (5.2)\n\nP ?|cs1zs1 = P ?|\nzs1\ncs1 (5.3)\n\nP ?|cs1 ^ cs2\nzs1 ^ zs2\n\n=\n(\nP ?|cs1zs1\n\n)\n?|cs2?zs2 (5.4)(\n\nP ?|cs1zs1\n)\n\ncs2 ^ cs3 ?zs2 ^ zs3 Q = (Pcs2 ?zs2 Q)?|\ncs1 ^ cs3\nzs1 ^ zs3\n\n(5.5)\n\nProof. These set of rules are a direct consequence of commutative and associative properties\nof the parallel operator and the function BUFF?IO.\n\nBy definition, components are regarded as reusable units of composition. However, the\ndirect composition of components requires that the connected points of composition have the\nsame type (conjugated interfaces). This excludes a wide variety of components, which would\nbe eligible for composition and, furthermore, restricts their reuse. An alternative approach to\ndirect composition of components is to use connectors to mediate their interactions. In fact, we\nshow in Section 6.1 that this is explained by successive direct compositions.\n\nThe composition of two components using a connector can be performed through two direct\ncomposition steps. We first assemble a component (CLIENT or SERVER, in our example) to\nthe connector (CON). Then, the second step is to assemble the resulting composition to the\nother component (SERVER or CLIENT, respectively). Substituting CON by a concrete connector\nthat uses Concopy in our example, the resulting component is obtained from the (two-steps)\ncomposition of CLIENT and SERVER:\n\nAT Msystem = CLIENT ?cl? ? ?ccl? CON ?csv? ? ?sv? SERVER\n\nwhere\n\nchannel ccl : ICL\nchannel csv : ISV\n\nCON =F(Concopy,?ccl,csv?,?RCtrCLIENT (cl),RCtrSERVER(sv)?,\n\n?ProtIMP(CtrCLIENT,cl)[[ccl/cl]],ProtIMP(CtrSERVER,sv)[[csv/sv]]?)\n\nThe naive use of (a sequence of) direct composition of components (even through a connec-\ntor), without checking their compatibilities, can easily introduce deadlocks in the composition.\nIn order to safely compose components, some provisos must be checked. As a matter of fact,\nthis is the problem statement that originates the composition rules, proposed in Chapter 6.\n\n5.2.5 Wrapping\n\nThe composition operators presented in both definitions take components as parameters and\nreturn a compound component back, hiding the assembled channels from the resulting com-\nponent contract. These compositions construct a sort of grey-box components, in which some\n\n\n\n5.3 ARCHITECTURAL STYLES 72\n\nchannels used in B do not belong to C. These channels are not in the contract. For instance, the\nchannels mapped by F used in the synchronisation are restricted from the composition contract.\nThey can be observed, in this way, in tests and verifications about the constituting components\nof the composition. At any moment, it is possible to transform such grey-box into a black-box\ncomponent using the following hiding operator.\n\nDefinition 5.9 (Wrapping). Let P be a component contract, and CC a set of channels. Then, a\nwrapping of P with respect to CC is given by:\n\nP \\CC = ?(BP \\{|CC 8CP|},RP,IP,CP?\n\nDefinition 5.9 defines a new component contract from another that has the same provided\nand required services, but which hides some internal events used to process such services. This\nclearly does not restrict any further composition with the component P. In fact, it creates a\ncomponent version that is better aligned to the component-based philosophy, in which imple-\nmentation details are hidden to outside. For this reason, it is common to perform a direct\ncomposition, and a wrapping of its synchronised events afterwards. We call this operation of\nwrapped composition. For instance, the wrapping asynchronous binary composition of P and\nQ (namely P?c1,..,cn????z1,..,zn?Q) would be given by:\n\nP?c1,..,cn????z1,..,zn?Q = (P?c1,..,cn? ??z1,..,zn? Q)\\{|c1,..,cn,z1,..,zn|}\n\nAlthough compositions with wrapping play an important role at development of commer-\ncial off-the-shelf (COTS) components, sometimes developing in-house systems using grey-box\ncomponents are easier, since we can explicitly observe and analyse the communication of the\nconstituting parts of the system, before packing it in a black-box component using the wrap-\nping operator. This method does not invalidate COTS components, rather it just postpones such\nstatus to when the development is finished and it is delivered to third parties.\n\n5.3 Architectural styles\n\nIn the previous sections, we have formally defined a general architectural model concerned\nwith responsibilities assigned to components, and with initial assumptions about their interac-\ntion. However, additional constraints can be considered to capture more detailed integration\nconcerns. These concerns may determine whether pre-existing parts can be used together, or\naffect some quality attributes, or even enable a specific target technology (to construct or to\nreason about the system).\n\nDevelopers recognise a number of distinct architectural styles [SC97]. Many of these are\ndefined informally and idiosyncratically. Here, we formally present some styles found in com-\nmunicating processes: interaction, naive client-server, and protocol oriented components. Ob-\nviously, the small number of styles presented here is not intended to be complete, but they seem\nto represent the diversity found in practice.\n\nInteraction components, for instance, focus on components with a cyclic behaviour, which\nare found in several technologies such as, for instance, Session Enterprise JavaBeansT M and\n\n\n\n5.3 ARCHITECTURAL STYLES 73\n\ntransactional conversational Web Services. Moreover, it is aligned with a common partial-order\nreduction practice, transaction-based reduction, to alleviate state space explosion in the static\nanalysis of concurrent programs [BLL09]. The other architectural style, naive client-server1,\nfocuses on components with synchronous communication in which any communicated message\ncan be interpreted as either a requisition or an acknowledgement of a previous requisition.\nThis is similar to the style call-and-return [SC97], typically found in classical object-oriented\nsystems or applications with (remote) procedures calls, except from the fact that we include\nconcurrent processes in our style. Furthermore, the naive client-server style can be used to\ndesign synchronous communication protocols over asynchronous mediums. Another important\narchitecture style is called protocol oriented component. It defines components that preserve\ntheir communication protocol on all their channels, after composition. This is an important\nproperty in the development of component-based systems in where protocol plays a central\nrole, such as the strategy presented later in this work.\n\n5.3.1 Interaction components\n\nThis architectural style focuses on components that repeatedly present the same behaviour to\nthe environment. Such a recurring behaviour is called here an interaction process, which is\nitself defined in terms of interaction patterns [BBT01]. Each interaction pattern consists of a\nfinite sequence of events (representing component services) that, when performed, leads the\ncomponent (interaction process) back to its initial state. For instance, in our example, the\nCLIENT component presents such a recurring behaviour (see Figure 5.2). In this manner, the\ncomponent repeatedly offers these sequences of events, similar to possible transactions (includ-\ning compensating actions) performed against a database management system. These patterns\ncover a wide range of applications, like transactional stateful components found in several\ntechnologies such as, for instance, Session Enterprise JavaBeansT M and transactional conver-\nsational Web Services.\n\nTo present the interaction patterns of a process P, InteractionPatterns(P), we use the CSP\noperator P/s. If s ? traces(P) then P/s (pronounced \u2018P after s\u2019) represents the behaviour of P\nafter the trace s is performed. So, InteractionPatterns(P) is the set of traces that leads the process\nto its initial state.\n\nDefinition 5.10 (Interaction patterns). Let P be a CSP process.\n\nInteractionPatterns(P) ={s : traces(P)|P vF D (P/s)? s is finite}\n\nDefinition 5.10 is characterised in terms of the CSP failures/divergence semantic model.\nIt defines the set of traces after which the process presents the same failures and divergences;\nthese are precisely the interaction patterns of P. From Definition 5.10, we say that a process is\nan interaction process, if it can be defined in terms of interaction patterns. Its traces must be\na prefix (?) of an interaction pattern or a combination of them. Note that in either case they\nbelong to InteractionPatterns(P).\n\n1True client/server systems maintain a context that captures the current state of an ongoing series of actions.\n\u201cClient/server\u201d is sometimes used to describe systems that ignore this requirement and simply use components\nthat call/define procedures or send request/reply messages. We call the latter \u201cnaive client/server systems.\u201d\n\n\n\n5.3 ARCHITECTURAL STYLES 74\n\nDefinition 5.11 (Interaction process). A divergence-free CSP process P is an interaction pro-\ncess if, and only if:\n\n?s ? traces(P)\u2022?p : InteractionPatterns(P)\u2022 s ? p\n\nWe consider that an interaction process represents a complete pattern of services (including\ncompensating actions). After starting to communicate, the process always perform at least\none pattern completely, and eventually returns to a state where it can initiate other interaction\npatterns; only one interaction pattern can be performed at a time. These properties help us in\nfurther verifications in this work.\n\nBased on the above definition, we are able to define components that behave as interaction\nprocesses.\n\nDefinition 5.12 (Interaction component). Let C be a component with contract Ctr. Then C is\nan interaction component if, and only if, BCtr is an interaction process.\n\nThe definition of interaction components explicit how infinite traces can be represented by\nprocesses with a finite number of states, which is one of the requirements of an I/O process.\nAs said before, it also helps in the verification of process with infinite traces. Although there\nmay be other strategies for representing infinite traces with a finite number of states, we use\ninteraction components as our default strategy in the examples used in this work.\n\nOverall, in practice, we can specialise this architectural style in order to represent interac-\ntion processes solely in terms of the set of their interaction patterns. In order to achieve this,\nwe may assume that all choices between events of different channels are external. As a result,\nany interaction process P can be defined as a recursive process of the form P = Q ; P, where the\ntraces of the finite process Q represent interaction patterns of P. A default implementation for\na set of interaction patterns T of an interaction component is PDEF IMP(T), defined as follows.\n\nDefinition 5.13 (Default interaction component implementation). Let C be a set of channels,\nI a set of interfaces, R a mapping from C to I, and T a set of interaction patterns, such that\nT ?{|C|}?. Then the default implementation of T (namely PDEF IMP(T)) is an interaction process.\n\nPDEF IMP(T) = PINT (??,T) ; PDEF IMP(T)\n\nPINT (s,T ) =(2ai : enabled(s,in,T )\u2022 ai ? PINT (s_?ai?,T ))\n\n2\n\n(uao : enabled(s,out,T )\u2022 ao ? PINT (s_?ao?,T ))\n2 s ? (T ?{??})&amp; SKIP\n\nenabled(s,tag,T ) = {t,c,a|t ? T ? c ?C ? tag.a ?R(c) ? s_?c.tag.a?? t \u2022 c.tag.a}\n\nThe default implementation of an interaction component has a similar behaviour to one\ndefined for I/O processes in Chapter 4. It is defined as the external choice of its inputs and\n\n\n\n5.3 ARCHITECTURAL STYLES 75\n\nthe internal choice of its outputs, after a trace s. The set of inputs and outputs is given by\nenabled(s,in,T ) and enabled(s,out,T ), which returns the events with the tag in and out after the\ntrace s in the set of traces T respectively.\n\nThen Ctr = ?PDEF IMP(T),R,I,C? can be accepted as a contract for an interaction component,\nand easily transformed into a regular component contract (see Definition 5.3)\n\n5.3.2 Naive client-servers\n\nThe requirement for a component in a naive client-server style [SC97] is that it communicates\non each of its ports either as a client or as a server, according to a strict protocol. This protocol\nrequires that after a client sends a request, it must wait for a reply on that port before communi-\ncating again through it. Similarly, a server sends a response, after being requested. We define\na naive client-server component as a component that satisfies this requirement.\n\nBased on the requirement of this style, all protocols of this component satisfy strict con-\nditions: a) requests are followed by replies, and the former never comes before the latter; b)\na response is communicated on the opposite direction of its request; c) the component never\ncommunicates two consecutive requests, or replies, on a same port.\n\nDefinition 5.14 (Naive client-server component). Let Ctr be a component contract. Then Ctr\nis a naive client-server component if, and only if:\n\n?c,P|c ?CCtr ? P = ProtIMP(Ctr,c)\u2022 StrictProt(P,c,in,out)? StrictProt(P,c,out,in)\n\nwhere StrictProt(P,c,d1,d2) =?s : traces(P)\u2022 (s ?{|c.d1|}? s ?{|c.d2|}) ?\n(s ?{|c.d1|}? s ?{|c.d2|}+ 1)\n\nThe Definition 5.14 says that any protocol of a component satisfies the conditions of being\na server or a client. Their traces have the form: request, response, request, response...; the\nnumber of request is bigger than the number of responses (s ? {|c.d1|}? s ? {|c.d2|}), but their\ndifference is not bigger than one. The only difference is that a server request is an output, and\na client request is an input. Similarly, the responses have opposite directions. The property\nStrictProt represents the strict conditions for being a client or a server.\n\n5.3.3 Protocol oriented components\n\nThis style is related to the need of specifying components with respect to their port-protocol be-\nhaviours. In such a style, any composition preserves the port-protocol behaviour of the original\ncomponents in all channels that are still available after they are assembled. There are several\nways to achieve this; most of them restricted to specific applications. In this work, however,\nwe present this style in a generic form as follows.\n\nDefinition 5.15 (Protocol oriented component). We say that a component S is protocol oriented\nif, and only if, for any process R, channel c, and set of events Z, such that c ?CS, ? R?{|c|}= /0,\n?z? : Z \u2022 z? ?CS8{c} ? ProtIMP(R,z?)??ProtIMP(BS,z?), and BS ?\n\n{|Z|}\nR is deadlock-free, the following\n\nholds:\nBS |? {|c|}vF (BS ?\n\n{|Z|}\nR) |? {|c|}\n\n\n\n5.4 BRICK COMPONENTS 76\n\nThe proviso in the previous definition is hard to verify because we have to consider a wide\nrange of processes R for a same component S. This is intentionally defined in this way to\ncover several other more specific styles that naturally satisfy the conditions of protocol orient-\nedness. However, for specific styles, the verification of this proviso can be very easy using\nmore specific patterns of communication. For instance, classical styles whose components\nare also protocol oriented are components with cyclic processes or resource allocation proto-\ncols [MW97, Ros98]; classical examples of these are systolic arrays and the dining philoso-\nphers, respectively.\n\nAn example of a component that is not protocol oriented is one that behaves as follows.\nConsider that c and z are channels within the component contract.\n\nQ = c.in.a1 ? c.in.b ? Q\n2 c.in.a2 ? z.in.d ? Q\n\nIn the process above, the choice between the events c.in.a1 and c.in.a2 determines that the\nenvironment keeps communicating via the channel c or performs the event z.in.d. A valid com-\nposition might allow only the event c.in.a1 to be performed, precluding communications in z.\nFurthermore, compositions with this component may not preserve the protocol on z. This hap-\npens because I/O processes are output decisive, and a refinement of a given I/O processes might\nhave a more restricted set of outputs to choose from (see the notion of protocol compatibility\nin the last chapter). In most examples in this work, we use protocol oriented components. For\ninstance, the client and server components in our running example are protocol oriented.\n\n5.4 BRICK components\n\nIn addition to the contract elements presented in Definition 5.3, there might be other elements\nintended to ease and potentialise the use of a component during the development of a sys-\ntem. In this section, we define a component contract that specialises the notion of protocol\noriented component and enriches its contract with metadata. These components are called\nBRICK-components. The metadata elements record information that aims at alleviating several\nverifications in our rigorous strategy for component composition, which is presented in the next\nchapter.\n\nBy analysing the material about I/O processes in Chapter 4, it is worth observing that some\nproperties play an important role in the assembly of I/O processes. Moreover, some of these\nproperties can be predicted from properties of the original components in the composition.\n\nFurthermore, to ease the incremental development of component-based systems, we con-\nsider that the previous calculation of these properties is as relevant in a component contract as\nthe other elements presented in Definition 5.3. In fact, we include these properties in an en-\nriched definition of component contracts, so that compositions have to solely consider such en-\nriched component contracts. In particular, we focus on the properties related to port-protocols\nand decoupled channels (see Definitions 4.6 and 4.21), which are used to verify protocol com-\npatibilities and the safe introduction of buffers in a system. These are important properties, as\nshown in the next chapter, in the composition of components in systems with tree topologies\n(without cycles of dependencies between components). We propose a new component contract\n\n\n\n5.4 BRICK COMPONENTS 77\n\ndefinition, in which these properties are captured as relations that form a component metadata\n(representd by K in following definition).\n\nDefinition 5.16 (Enriched component contract). Let Ctr be a protocol oriented component\ncontract, and K a metadata derived from its elements. An enriched component contract that\nincludes Ctr is represented by:\n\n?BCtr,RCtr,ICtr,CCtr,K?\n\nwhere K comprises the following information:\n\nK : ?ProtK, CTXK, DProtK, DecK?\n\nsuch that:\n\n\u2022 dom ProtK ?CCtr ? ?c : dom ProtK \u2022 ProtK(c)vF ProtIMP(Ctr,c)\n\n\u2022 dom DProtK ?CCtr ? ?c : dom DProtK \u2022 DProtK(c) is the dual protocol of ProtK(c)\n\n\u2022 dom CTXK ?CCtr ? ?c : dom CTXK \u2022 CTXK(c) is the context process of ProtK(c)\n\n\u2022 dom DecK ?CCtr ? ran DecK ?CCtr ?\n?c1,c2 : CCtr \u2022 c1 DecK c2 ?{c1,c2}DecoupledInCtr ? c2 DecK c1\n\nThe element ProtK is a relation from channels to protocols, which represent the actual port-\nprotocol of the component on that channel. If a protocol within ProtK satisfies a property, then,\nby refinement, it also holds for the protocol of the component. Similarly, the elements DProtK\n\nand CTXK map channels into context processes and dual protocols, respectively. They are\nused to support the use of the protocols within ProtK; these are used, for instance, in protocol\ncompatibility verifications (see Theorem 4.6). Finally the element DecK is a relation among\ndecoupled channels of the component. Observe that Dec is a symmetric relation, since this\nproperty is inherited from the interleaving operator (see Definition 4.21). Altogether these\nelements help to alleviate the verifications of component compositions. Moreover, they can\nbe easily calculated for compositions using metadata of the original components present in the\nassembly.\n\nTo briefly illustrate the idea of metadata, let us define a protocol ProtSV 10 for a server, in a\nbank where basic accounts are limited to have more than 5 dollars and less than 1000 dollars.\nThe processes DProtSV 10 and PCTXSV 10 below are the dual protocol and the context process of\nProtSV 10, respectively.\n\nProtSV 10 = \u00b5 X \u2022 sv.in.wd?x ? (ua : Bool \u2022 sv.out!ackW d.a)? X\n2 sv.in.reqBal ? (uy : 5..1000 \u2022 sv.out!resBal.y)? X\n\nDProtSV 10 = \u00b5 X \u2022 (ux : Int \u2022 sv.in.wd!x ? sv.out.ackW d?a)? X\n2 sv.in.reqBal ? (2y : 5..1000 \u2022 sv.out.resBal.y)? X\n\n\n\n5.4 BRICK COMPONENTS 78\n\nPCTXSV 10 = \u00b5 X \u2022 sv.in.wd?x ? sv.out.ackW d?a ? X\n\n2 sv.in.reqBal ? (2y : 5..1000 \u2022 sv.out.resBal.y)? X\n\nLet us also suppose that we have a server that can communicate with two clients concur-\nrently. For the sake of brevity, we define this server as the interleave of two simple servers; one\ncommunicating on the channel sv and the other on sv? \u2013 both channels typed by the interface\nISV . The enriched component contract of this server is defined as CtrSERVER2.\n\nCtrSERVER2 = ?SERVER ||| SERVER[[sv\n?\n/sv]],{sv 7? ISV ,sv? 7? ISV},{ISV},{sv,sv?},KSERVER2?\n\nwhere\n\nKSERVER2 = ?{sv 7? ProtSV 10,sv? 7? ProtSV 10[[sv\n?\n/sv]]},{sv 7? PCTXSV 10,sv? 7? PCTXSV 10[[sv\n\n?\n/sv]]},\n\n{sv 7? DProtSV 10,sv? 7? DProtSV 10[[sv\n?\n/sv]]},{(sv,sv?)}?\n\nThe metadata is formed by protocols that limit the account balance, their dual protocols and\ncontext processes, as well as a relation that indicates that sv and sv? are not dependent on each\nother (they belong to two distinct processes in an interleave). We over restrict the protocols in\nthe metadata (they limit the account balance) to illustrate the ideas behind this notion.\n\nNote that CtrSERVER2 is a protocol oriented component, in which whenever a client is assem-\nbled to the channel sv?, the protocol implementation associated to sv is preserved, and vice versa;\ntherefore, the protocol ProtSV 10 within the metadata still refines ProtIMP(CtrSERVER2,sv) (the same\noccurs for ProtSV 10[[sv\n\n?\n/sv]] and the protocol implementation of sv?). These protocols are ready to\n\nbe used in protocols compatibility verifications of compositions. As they are preserved in com-\npositions, verifications in subsequent compositions do not have the onus of deriving protocols,\nand, furthermore, understanding the new behaviour defined by the composition.\n\nDecoupled channels are also useful to simplify assemblies of channels of the same compo-\nnent, identifying inner interleaves inside the component. This is a relation that can be easily\nobserved in white box components, but that requires additional verifications in gray or black-\nbox components; for this reason it was elected to be an element of the component contract\nmetadata. Due to the compositionality of interleaves, decoupled channels relations are not dif-\nficult to be predicted in compositions: if a client is assembled to the server via the channel sv,\nthe communication in the channels of the client are independent of communications in sv? (and\nvice versa), so, by induction, new decoupled channels relations are defined.\n\nObserve that the metadata elements (K) have a loose definition. They are intentionally\ndefined in this way to avoid including all protocols or relations between decoupled channels.\nWhen not provided by the developer of the component, such properties must be calculated\nby whom is interested on them (see definitions 4.8, 4.15, 4.17, and 4.21). In any case, these\nproperties can be derived from the other component contract elements (B, R, I, or C). When\n\n\n\n5.4 BRICK COMPONENTS 79\n\npresent, metadata ease the verification of important constraints in the development. As compo-\nnents are possibly reusable in many scenarios, the cost to define such metadata is proportionally\ndistributed by the degree of reuse employed.\n\nIn order to link the definition of enriched component contracts with the one for regular\ncomponents (Definition. 5.3), we define the function Enrich as follows.\n\nDefinition 5.17 (Enrich Component Contract). Let Ctr be a protocol oriented component con-\ntract, and K a metadata derived from its elements. Then:\n\nEnrich(Ctr,K) = ?BCtr,RCtr,ICtr,CCtr,K?\n\nThis is a very simple function used to construct enriched component contracts from regular\ncomponent contracts and already known metadata of these component contracts.\n\nIn the next chapters we explore relevant properties of the component model and architec-\ntural styles presented here.\n\n\n\nCHAPTER 6\n\nA rigorous strategy for component compositions\n\nThe constructive constraints for the BRIC component architectural model are based on compo-\nsition rules for components. These rules present a systematic strategy to build systems when-\never every two components are compatible to interoperate. They aim at guiding the developer\nin the composition of regular components in the BRIC component model, guaranteeing, by\nconstruction, preservation of some quality attributes amenable for verification by construction.\nTogether with the characterisation constraints in the component model, the rules impose side\nconditions to compositions in order to ensure they are correct.\n\nThe composition rules are defined on the top of the notion of service conformance. Service\nconformance can be understood as a design principle to be followed, when permitted: unused\nservices of a component should be still available after composition. The degree of satisfaction\nof this notion may vary from preserving all services (strong conformance) to at least one (weak\nconformance). The set of composition rules for the BRIC component model satisfy the weak\nservice conformance, and the set of composition rules for the BRICK component model satisfy\nthe strong service conformance.\n\nThe rest of this chapter is organised in three parts. The first one presents a prelude of our\nstrategy. It discusses the benefits and limitations of local analysis, and the quality attributes\nwe focus on this work. In special, we present our notions of service conformance, from which\nour compositions are lifted up. The second part sets out general rules for component based\nsystems. Based on them, we guarantee that properties about individual components (P(A) and\nP(B)) are preserved by their composition (P(A?B)). The third part considers basic assumptions\nabout the architectural styles presented in the previous chapter in order to understand scenarios\nthat are still amenable for compositional preservation of quality attributes. Based on these\nassumptions, we are able to construct some elaborate rules for these architectural styles that\nrequire less complex verifications and, furthermore, alleviate the verification of other quality\nattributes by construction.\n\n6.1 Local analysis\n\nA first (and widely used) attempt to prove behavioural properties in a composition would be\ndirectly checking such properties in the compound system, without any assumption about its\ncomponents. However, this significantly decreases the value of a component-based approach,\nsince to determine an attribute (or property) in a system after integration or deployment to a\ntarget system is often costly. In this section, we present composition rules that guarantee com-\n\n80\n\n\n\n6.1 LOCAL ANALYSIS 81\n\nposition properties of a system by construction, based on the same properties of its constituting\ncomponents, so that problems are anticipated before all parts are integrated.\n\nThese rules form a restricted model for component integration that shows whether a com-\nposition preserves a behavioural property or not. By not satisfying a property, it does not mean\nthat the composition is in fact problematic, but that this system does not attend to a pre-existing\n(or proposed) set of conditions that guarantee such a property.\n\nIt is true that some properties are global phenomenon over the whole system (emergent\nproperties) and sometimes arise, or fail to arise, for extremely subtle reasons. For most of\nthem, there is probably no complete method for deciding whether or not a property is satisfied\nother than brute-force state exploration. And yet all the rules described in this section rely\nentirely on local analyses. With such rules, one cannot hope to decide all cases, although they\ndo seem to work for a significant class of applications, as illustrated by our examples.\n\nGeneral rules based on local analyses are sometimes limited. For instance, a system might\nbe carefully designed to guarantee a certain property, but presents an elaborate design or in-\nteraction with other components that prevents any automatic verification using general rules.\nNevertheless, systems that are carefully designed also tend to follow specific rules, and these\nrules usually conform to an architectural style. As a consequence, new specific composition\nrules can be proposed for specific architectural styles, as we exemplify in this chapter.\n\n6.1.1 Desirable quality attributes\n\nBefore presenting composition rules that ensure the preservation of design properties by con-\nstruction, it is essential to discuss the kind of quality attributes we are concerned with. We are\ninterested in preserving behavioural properties. In particular, we support the argument that the\npreservation of basic properties helps in the preservation of more complex ones.\n\nFor instance, let\u2019s have a look on notions of service conformance (originally presented\nin [RSM10], but revisited here for introducing two levels of conformance). Satisfying this\nproperty means that the composition conforms to the services of the original components, or,\nin other words, that services not directly involved in the composition are preserved. The reason\nwe do not consider the services involved in the composition is because they are not available\nafterwards for new assemblies. With this in mind, we consider that these services assist in the\nimplementation of the other external visible services. We capture this notion with a refinement\nexpression which requires that the observed behaviour of the composed components refines the\nbehaviour of the original components, hiding all ports involved in the composition.\n\nThere are two levels of conformance agreement. In the strongest one, services provided in\nall external visible channels are preserved. In the weakest notion, services provided in part of\nthe channels are preserved. Below, we formally present them.\n\nDefinition 6.1 (Service conformance). Let {Ctr1,Ctr2,...,Ctrn} be a set of components, and\nCCtr be a component contract, such that CCtr = (Ctr1 s11 ? s12 Ctr2)s21 ? s22 ... sm1 ? sm2 Ctrn. Then\nthe composition CCtr\n\n\u2022 weakly conforms to the services of the components Ctr1...Ctrn if, and only if:\n\n?i,c|c ?CCCtr ?CCtri \u2022 (BCtri |? {|c|})vF (BCCtr |? {|c|})\n\n\n\n6.1 LOCAL ANALYSIS 82\n\n\u2022 strongly conforms to the services of the components Ctr1...Ctrn if, and only if:\n\n?i,c|c ?CCCtr ?CCtri \u2022 (BCtri |? {|c|})vF (BCCtr |? {|c|})\n\nAs in any composition the channels involved in the integration are removed from the set\nCCCtr. As a result, channels within CCCtr ?CCtri exactly represent the channels of Ctri that re-\nmains externally observable after the composition. The behaviour restricted to these channels\nconstitute the services we look for. The conformance is then expressed by the refinement of\nservices in the components (the original one and the composition).\n\nStrong conformance may not be always desired. It is easy to think in scenarios that part\nof the component is put aside in order to other components achieve a global goal as part of\na coordination strategy of the components of the system. So, strong conformance depends as\nmuch of the careful design of its components as of their correct composition. As its name says,\nthe weak conformance notion is more flexible to such condition.\n\nThe concern on design can be replaced by the use of architectural styles. Systems with\nprotocol oriented components (see Section 5.3.3) satisfy the conditions for weak conformance\nnotion. Observing Definition 5.15, it is easy to see how a style with stronger conditions could\nachieve strong conformance notion. The advantages of architectural styles to preserve proper-\nties are discussed later in this chapter.\n\nIt is interesting to observe that not all quality properties are independent. In fact, the service\nconformance notion depends on more basic properties. Analysing the refinement expression,\nwe observe that it is based on the semantics of hiding. Any event outside the alphabet used for\ncomparison is assumed to be always enabled. However, we know that this might not be true\nafter component integration. Problems might arise during integration, and stuck the communi-\ncation of those events.\n\nAccording to the CSP semantics, the reasons for a system to get stuck are the two classical\nquality attributes, commonly cited as emergent properties: deadlock- and livelock-freedom\n[Lev95]. They are cited as emergent properties because in order to verify them it is necessary to\ncheck the interaction of several components in the system. Deadlock arises when components\nin a composition might be waiting for each other to proceed, so that no external communication\nis visible. Livelock arises when components infinitely communicate on internal channels (those\nnot externally observable). Looking at sections 5.2.4 and 5.2.5, we note that deadlock and\nlivelock problems are introduced by different CSP operators. In this context, deadlocks might\narise from the synchronisation between components, while livelocks are possible introduced\nafter applying the hiding operator. For the sake of brevity, we say that a component contract\nCtr is livelock or deadlock-free, if its behaviour (BCtr) is.\n\nThe analyses of those quality attributes give us some insights about how to restrict the sce-\nnarios in which undesirable problems do not arise in the component integrations. Based on this\nanalysis we present the composition rules in the next sections, mainly focusing on deadlock and\nlivelock freedom. As observed for the service conformance notion, the preservation of these\nclassical properties is important in the analysis of general integration problems. Other confor-\nmance notions might be interesting for more specific coordination purposes. Some examples\nof conformance notions are presented in Chapter 7.\n\n\n\n6.2 COMPOSITION RULES 83\n\n6.2 Composition rules\n\nIn this section, we present four composition rules; each one focuses on a specific problem\nat development. They specialise the asynchronous compositions shown in Section 5.2.4, and\nfocus on the preservation of deadlock-freedom. The reason for not coping with livelocks is that\nthey are only introduced after wrappings.\n\nA way to guarantee livelock-freedom is to provide that wrappings perform safe hidings (see\nDefinition 4.22). So, to preserve both properties, one has just to lift our rules to comprise such\nproperty. In any case, the verification by construction of livelock-freedom is still costly, since\nit must be verified on the whole system (or composition). Means to alleviate the verification of\nsuch problem, in specific architectural styles, are presented in Section 6.3.2.\n\nThe next section presents our four composition rules, how they can be combined, and,\nfurthermore, how they preserve deadlock-freedom in the entire system by construction.\n\n6.2.1 General composition rules\n\nIn this work we propose a comprehensive set of compositions that ensure correct systems by\nconstruction. For instance, applying these rules, one can predict the absence of deadlocks in\nthe system, or even early identify this problem.\n\nIn order to cope with the complexity of deadlock analysis, each of our composition rules\nis related to a scenario at composition. Instead of focusing on assembling different compo-\nnents (as it traditionally conceived), our composition rules focus on synchronising two chan-\nnels of two components, or even the same component. Mainly, the pairwise verification of\nport-protocols on these channels guarantees deadlock-freedom in the entire system.\n\nThe four rules are presented in this section in an increasing order of complexity. They\nare named interleave, communication, feedback and reflexive compositions. Each of these\ncompositions constructs a new component, which includes the original ones. In other words,\neach composition results in a unique, and elaborate, component.\n\nThe structures of three of these composition rules are illustrated in Figure 6.1. The inter-\nleave and communication composition rules are binary compositions (they assemble channels\nof two distinct components). The feedback and reflexive composition rules are unary composi-\ntions (they assemble distinct channels of a component). These unary compositions rules have\nthe same structure; they are distinguished by the conditions they impose.\n\nThe interleave composition rule concerns the case where no channel is synchronised, or, in\nother words, no communication is established. The communication one represents the tradi-\n\nFigure 6.1 Three composition rules proposed in this work.\n\n\n\n6.2 COMPOSITION RULES 84\n\ntional case, when the composition involves two components. As these rules always take distinct\ncomponents, they always results in systems that follows a tree topology; systems that, when its\nstructure is flattened, results in a graph of communicating components with no cycle. The vi-\nsualisation of the topology, however, is sometimes hidden, since compositions generate new\ncomponents that enclose the original ones.\n\nIn addition to our binary compositions rules, we present unary composition rules that as-\nsemble two channels of the same component. Unary rules complement the binary rules by\nlinking component in an existing structure. In this way, we can connect unassembled channels\nin existing components of a tree topology system, or even create proper graphs of components\n(when we visualize a flattened structure of the system).\n\nThe third rule corresponds to the simpler unary composition case, where two channels of\nthe same component are assembled, but do not introduce a new cycle. The rule imposes that the\noriginal component presents a partition in its behaviour (there is a low cohesion). These first\ntree compositions are the rules used more often, and that luckily requires less complex verifica-\ntions. As this partition is not always explicitly visible in the system structure, this system can\nbe observed some times as a graph with cycles, however, behaviourally to an equivalent tree-\ntopology system. To avoid misunderstanding, we call these systems of pseudo cyclic systems.\n\nThe last composition rule, reflexive, deals with cycle-topologies. In particular, it is one\nthat intentionally introduces a cycle whenever this does not introduce problematic dependen-\ncies among the communication of events in the system. Similar to the feedback composition,\nit also assemblies two channels of the same component. In fact, it generalises the feedback\ncomposition rule, imposing more complex verifications\n\nThese are the composition rules that can be used in sequence to design a wide variety\nof systems, with different topologies. Elaborate rules for regular components can be derived\nfrom these basic ones, as we show in Section 6.2.3. As connectors have the same structure\nof components, these can be similarly used in our composition strategy. For instance, we can\nassemble two connectors, or a connector to a component, using a communication composition\nrule. In this way, we give a uniform treatment for both design elements.\n\nAs said before, the simplest form of composition is to aggregate two independent entities\nsuch that, after composition, these entities still do not communicate between themselves. They\ndirectly communicate with the environment as before, with no interference from each other. To\nperform this composition form, there is a proviso that they do not share any communication\nchannel.\n\nDefinition 6.2 (Interleave composition). Let P and Q be two component contracts, such that P\nand Q have disjoint channels, CP?CQ = /0. Then, the interleave composition of P and Q (namely\nP[|||]Q) is given by:\n\nP[|||]Q = P?? ? ??Q\n\nThe above composition form is, by definition, a particular kind of direct composition that\ninvolves no communication, resulting in a weakly cohesive entity, which performs all events\ndefined in the original entities without any interference from each other.\n\nTheorem 6.1. Deadlock-free Interleave Composition\nThe interleave composition of two deadlock-free component contracts is also a deadlock-free\ncomponent contract.\n\n\n\n6.2 COMPOSITION RULES 85\n\nProof. The statement that the resulting process is deadlock-free follows directly from the\ncondition that the components do not share any channel. Furthermore, as showed below,\nBP[|||]Q = BP |||BQ. As BP and BQ are deadlock-free, so is, from the semantics of the interleave\noperator, BP[|||]Q. We start by expanding the direct composition of P and Q (Definition 5.7).\n\nBP[|||]Q ?F (BP |||BQ) ?\n{}\n\n(\n|||\n\nc?{}\nBU F F ?IO(c,F(c))\n\n)\nno buffer is used, c ?{}\n\n?F (BP |||BQ) ?\n{}\n\nSKIP rewriting\n\n?F BP |||BQ\n\nThe proof that the composition rule is component contract results directly from Theo-\nrem 5.1.\n\nThe second form of composition states the most common way for assembling complemen-\ntary channels of two entities. It links a channel of one entity to a channel of the other entity, as\nin a direct composition (Definition 5.7).\n\nDefinition 6.3 (Communication composition). Let P and Q be two component contracts, and\nic and oc two communication channels, such that ic ? CP ? oc ? CQ, CP ? CQ = /0, and the port-\nprotocols ProtIMP(P,ic)[[R ic?ocIO ]] and ProtIMP(Q,oc)[[R\n\noc?ic\nIO ]] are I/O confluent strong compatible\n\nand satisfy the finite output property. Then, the communication composition of P and Q (namely\nP[ic ? oc]Q) via ic and oc is defined as follows:\n\nP[ic ? oc]Q = P?ic? ? ?oc?Q\n\nIn our composition rules, we assume each component has a distinct set of interaction points\n(CP ? CQ = /0), and that their communication is asynchronous, mediated by buffers. In the com-\nposition P[ic ? oc]Q, values of P are asynchronously forwarded to Q through an internal buffer,\nwhich is confined in the composition (see Definition 5.7). In order for the two components be\ncompatible in an asynchronous medium, we require that they satisfy the finite output property\n(FOP) and that their protocols are I/O confluent(see definitions 4.19 and 4.18). Observe that\ncomposition operator (? ) consider the existence of infinite buffers in the medium. In case, we\nknow the medium can be specified as a buffer of finite size, satisfying the finite output property\nis immaterial.\n\nTheorem 6.2. Deadlock-free Communication Composition\nThe communication composition of two deadlock-free component contracts is also a deadlock-\nfree component contract.\n\nProof. The communication composition of two components P and Q is formed, in fact, of\ntwo parallel synchronisations. The composition operator ? implicitly introduces a buffer that\nalways accepts any communication from P, and forwards to Q, and vice-versa. As these com-\nponents have strong compatible port-protocols, they always accept communications from each\nother. This theorem results direct from Theorem. 4.9.\n\n\n\n6.2 COMPOSITION RULES 86\n\nTo prove that a divergent-free component R is deadlock-free, we have to prove that BR \\ ?\ndiverges [Ros98]. In the statements below we rewrite the behaviour of a composition of two\ncomponent contracts P and Q using the channels ic and oc.\n\nBP[ic?oc]Q \\ ? =\n\n(\n(BP |||BQ) ?\n\n{|ic,oc|}\n\n(\n|||\n\nc?{ic}\nBU F F ?IO(c,F(c))\n\n))\n\\ ?\n\n=\n\n(\n(BP |||BQ) ?\n\n{|ic,oc|}\nBU F F ?IO(ic,oc)\n\n)\n\\ ?\n\n=\n\n(\nBP ?\n{|ic|}\n\nBU F F ?IO(ic,oc) ?\n{|oc|}\n\nBQ\n\n)\n\\ ?\n\n=\n\n(\nBP ?\n{|ic|}\n\nBU F F ?IO(ic,oc) ?\n{|oc|}\n\nBQ\n\n)\n\\ (?8{ic,oc})\\ ?\n\n=\n\n(\nBP |? {|ic,oc|} ?\n\n{|ic|}\nBU F F ?IO(ic,oc) |? {|ic,oc|} ?\n\n{|oc|}\nBQ |? {|ic,oc|}\n\n)\n\\ ?\n\n=\n\n(\nP |? ic ?\n\n{|ic|}\nBU F F ?IO(ic,oc) ?\n\n{|oc|}\nQ |? oc\n\n)\n\\ ?\n\nIf either P |? ic or Q |? oc diverges, them the synchronisation above diverges, proving that the\ncomposition is deadlock-free. So,in order to continue the proof, we assume that these projec-\ntions are divergence-free.\n\nBP[ic?oc]Q \\ ? =\n\n(\nP |? ic ?\n\n{|ic|}\nBU F F ?IO(ic,oc) ?\n\n{|oc|}\nQ |? oc\n\n)\n\\ ?\n\n=[P |? ic and Q |? oc are divergence-free](\nProtIMP(P,ic) ?\n\n{|ic|}\nBU F F ?IO(ic,oc) ?\n\n{|oc|}\nProtIMP(Q,oc)\n\n)\n\\ ?\n\n=[Theorem 4.9]\n\ndiv\n\nThe proof that the composition rule is component contract results directly from Theorem 5.1.\n\nThe next two composition rules show how we can build systems with cyclic topologies.\nIn particular, we focus on assembling two channels of the same component. Since we build\nsystems by composing components pairwisely, a set of assembled components can always be\ntaken as a single large grain entity. In doing so, composing outputs and inputs of this large\ngrain component allows introducing cycles in the flattened structure.\n\nDue to the existence of cycles, new conditions have to be taken into account to preserve\nbehavioural properties in the composition. This topic is closely related to the study of more\ngeneral approaches to ensure deadlock freedom [MW97, Ros98]. They identify that deadlocks\n\n\n\n6.2 COMPOSITION RULES 87\n\narise in complex (graph) topologies by the presence of undesirable cycles, called cycles of\nungranted requests [Ros98].\n\nThe third composition rule deals with pseudo cyclic topology, which are behavioural equiv-\nalent to systems with tree-topologies. It does have some cycles, but none of them introduces\ndeadlocks. However, it cannot express all possible topologies. For this reason, verification\non this topology is simpler than in arbitrary complex topologies. The feedback composition is\naligned with the incremental nature of our strategy, dealing with a one problem at a time. A\nrule for more complex topologies is presented in Definition 6.5.\n\nIn order to avoid undesirable cycles, we base our approach on the notion of decoupled\nchannels (see Definition 4.21 ). According to this notion, communication on one channel does\nnot interfere on communications through the other (their communications are interleaved). This\nis a simple way to avoid undesirable cycles. The intuition here is in accordance with the notion\nof independency between parallel I/O processes proposed in [MW97] to avoid deadlocks in\ncyclic networks in CSP.\n\nDefinition 6.4 (Feedback composition). Let P be a component contract, and ic and oc two com-\nmunication channels, such that ProtIMP(P,ic)[[R ic?ocIO ]] and the protocols ProtIMP(P,oc)[[R\n\noc?ic\nIO ]] are\n\nI/O confluent strong compatible and satisfy the finite output property, {ic,oc}? CP and decou-\npled in P. Then, the feedback composition P (namely P[oc ?? ic]) hooking oc to ic is defined as\nfollows:\n\nP[oc ?? ic] = P ?\n???ic?\n?oc?\n\nIn the resulting composition, P[oc ?? ic], values of P through oc are communicated to the\nfeedback channel ic. Both channels oc and ic are then confined in the composition (see Def-\ninition 5.8) and are not available to the environment. This composition rule imposes some\nconditions that are similar those in the communication composition rule (relative to protocol\ncompatibility and buffer tolerance), except that it additionally imposes that channels are de-\ncoupled. As mentioned before, this last condition imposes that the protocols associated to the\nassembled channels behave independently of each other, and furthermore, the new communi-\ncation does not introduce deadlocks.\n\nBefore presenting a theorem related to this kind of composition, we present the reflexive\ncomposition rule, which is more general. The proof of these two rules are related; in fact, as\nwe show later, the feedback composition is a subcase of the reflexive composition.\n\nThe composition rules presented so far deal with systems with a tree. In practice, there\nare more complex systems that indeed present cycles of dependencies in the topology of the\nsystem structure. In fact, not all cycles are undesirable. It has being pointed out [Ros98] that\nthe unique undesirable cycles are those that present a cycle of ungranted requests. These are\ncycles in which all components simultaneously realise a request that is prevented by the next\ncomponent, so all of them deadlock.\n\nTo deal with such cycles, we note that in order to avoid deadlock, we only need to know\nwhat kind of dependency exists between channels used in a cycle. In general it is difficult\nto classify all possible dependency kinds. So, in order to cover the general case, we use in\naddition projections with two channels, instead of solely port-protocols. Only the order among\ncommunication in these channels matters. They have to allow the injection of information from\n\n\n\n6.2 COMPOSITION RULES 88\n\none channel to the other via the implicit buffers of the composition. We call this rule reflexive\ncomposition.\n\nDefinition 6.5 (Reflexive composition). Let P be a component contract, and ic and oc two com-\nmunication channels, such that {ic,oc}? CP, and P |? {|c,z|} buffering self-injection compatible\nand satisfies the finite output property. Then, the reflexive composition P (namely P[oc \u00af??ic])\nhooking oc to ic is defined as follows:\n\nP[ic \u00af??oc] = P ?\n???ic?\n?oc?\n\nA reflexive composition is similar to the feedback composition. Both assemble channels\nof the same component contract. They differ in the relationship between these channels. The\nfeedback composition assembles independent channels, and the reflexive composition deals\nwith dependent ones, thanks to the buffering self-injection compatible property (see Defini-\ntion 4.20). Provided that the behaviour is buffering self-injection compatible, then it is possible\nto introduce a buffer to assembly the channels ic and oc without the composition deadlocks. In\nfact, the reflexive one is more general than the feedback one. However, it is also more costly.\nFor this reason, we have distinguished them. This cost is directly associated to the cost of de-\ntermining if the projection is self-injection compatible. We observe later that in several cases,\nin which components follow specific communication patterns (or architectural styles), it is eas-\nier to categorise all possible dependency relationships existing in a system, and performing\nverifications about them. We show one of these cases in Section 6.3.\n\nSimilar to our other composition rules, a reflexive composition preserves deadlock-freedom.\n\nTheorem 6.3. Deadlock-free Reflexive Composition\nThe reflexive composition of two deadlock-free component contracts is also a deadlock-free\ncomponent contract.\n\nProof. This proof is similar to the one for Theorem 6.2. Buffers are also implicitly introduced\nin the communication. As for communication composition, we provide a theorem that supports\nour proof, Theorem 4.10.\n\nTo prove a divergent-free component R is deadlock-free, we have to prove that BR \\ ? di-\nverges [Ros98]. In the statements below we rewrite the behaviour of a composition of a com-\nponents contracts P using the channels ic and oc.\n\nP[ic \u00af??oc]\\ ? =\n\n(\nBP ?\n{|ic,oc|}\n\n(\n|||\n\nc?{ic}\nBU F F ?IO(c,F(c))\n\n))\n\\ ?\n\n=\n\n(\nBP ?\n{|ic,oc|}\n\nBU F F ?IO(ic,oc)\n\n)\n\\ ?\n\n=\n\n(\nBP ?\n{|ic,oc|}\n\nBU F F ?IO(ic,oc)\n\n)\n\\ (?8{|ic,oc|})\\ ?\n\n=\n\n(\nBP |? {|ic,oc|} ?\n\n{|ic,oc|}\nBU F F ?IO(ic,oc)\n\n)\n\\ ?\n\n=\n\n(\nP |? {ic,oc} ?\n\n{|ic,oc|}\nBU F F ?IO(ic,oc)\n\n)\n\\ ?\n\n\n\n6.2 COMPOSITION RULES 89\n\nAccording to Theorem 4.10 the process in parentheses is deadlock-free, so hiding the whole\nalphabet results in divergence.\n\nP[ic \u00af??oc]\\ ? = div\n\nThe proof that the composition rule is component contract results directly from Theorem 5.2.\n\nA similar theorem is related to the feedback composition.\n\nTheorem 6.4. Deadlock-free Feedback Composition\nThe feedback composition of a deadlock-free component contract is also deadlock-free.\n\nProof. This theorem results direct from Theorem 4.11. The decoupled property in the feedback\ncomposition implies in self-injection compatibility. As a result, according to Theorem 6.3, the\nfeedback composition is also deadlock-free.\n\n6.2.2 Trustworthy component systems\n\nFrom our proposed building block constructors (composition rules), any system S can be struc-\ntured as follows.\n\nS ::=P\n\n| S [|||]S\n| S[c1 ? c2]S\n| S[c1 ?? c2]\n| S[c1 \u00af??c2]\n\nwhere P is a component contract whose behaviour is deadlock free. We say that any component\nsystem that follows this grammar is in normal form.\n\nTheorem 6.5. Deadlock-free Component Systems\nAny system S in normal form, built from deadlock-free components, is deadlock-free.\n\nProof. Direct from theorems 6.1, 6.2, 6.4, and 6.3.\n\nTheorem 6.5 is an important theorem in this work. It says that any system that follows\nour rules preserves the deadlock-free quality property, and emphasises the relevance of our\ncomposition rules in a rigorous strategy. Observe that livelock-free could easily be added in\nour theorem, since all operators used within our normal form does not introduce livelocks. As\nwe said before, livelocks are introduced by the wrapping operator and, unfortunately, demands\nheavy verification in the whole composition, after wrapping is performed. In Section 6.3,\nwe discuss how verification on compositions with arbitrary components can be alleviated by\nfollowing an architectural style. In Chapter 7 we present practical examples were these rules\nare applied in order to ensure that the final system is deadlock-free.\n\n\n\n6.2 COMPOSITION RULES 90\n\n6.2.3 Rule compositionality\n\nSound composition rules can also be elaborated based on the general composition rules pre-\nsented so far. Similar to them, elaborate rules should underlie common practices in develop-\nment. For instance, to assist developer activities, a desirable issue is to connect several ports\n(channels) in one step. To perform such a task, we would have to use the feedback or the com-\nmunication composition rules several times, assembling channels pairwise. In order to perform\nsuch compositions in one step, we have defined two new composition rules, which extend the\npreviously defined feedback and communication composition rules.\n\nDefinition 6.6 (Extended feedback composition). Let P be a component contract, and chseq1\nand chseq2 two nonempty sequences of distinct communication channels, such that:\n\n\u2022 (ran chseq1 ? ran chseq2)?CP ? (ran chseq1 ? ran chseq2) = /0;\n\n\u2022 (ran chseq1 ?ran chseq2) DecoupledIn P ? #chseq1 = #chseq2\n\n\u2022 ?i,z,c|c = chseq1(i) ? z = chseq2(i) \u2022 ProtIMP(P,c)[[R c?zIO ]] and ProtIMP(P,z)[[R\nz?c\nIO ]] are I/O\n\nconfluent strong compatible port-protocols and satisfy the finite output property;\n\nThen, the extended feedback composition of P (namely P[chseq1 ?? chseq2]) via the channels\nwithin chseqP and chseqQ is defined as follows:\n\nP[chseq1 ?? chseq2] = P ?\n??chseq1\nchseq2\n\nThe composition rule above is very similar to feedback composition, except for the fact that\nit assembles several channels at once. In fact, the result of this composition rule is equal to the\napplication of several consecutive feedback compositions. Instead of taking a pair of channels,\nthe extended composition rule takes two sequences of channels to assemble. The channels are\nassembled pairwisely according to their order; the first channel in one sequence is assembled\nto the first one the other sequence, and so on. Similarly to feedback composition rule, the\nextended feedback composition also guarantees deadlock-freedom.\n\nTheorem 6.6. Deadlock-free Extended Feedback Composition\nThe extended feedback composition of a deadlock-free component contract is also deadlock-\nfree.\n\nProof. The extended feedback composition has exactly the same conditions of a regular feed-\nback composition, except it is more restrictive; it has a bigger set of decoupled channels. Then,\nwe observe that, assuming c and z the head of chseq1 and chseq2, the composition P[c ?? z] is\nallowed. Such resulting process satisfies the provisos of Definition 6.6, similarly to P, except\nthat the new sequences are the tail of chseq1 and chseq2. Consider that the channels within the\ntail of chseq1 and chseq2 are represented by CT1 and CT2, respectively. The following statements\nshows that the channels within these sequences are decoupled in P[c ?? z].\n\n\n\n6.2 COMPOSITION RULES 91\n\nP[c ?? z] |? CT1 ?CT2\n?F [Definition 6.4]\n\nP ?\n{|c,z|}\n\nBU F F ?IO(c,z) |? CT1 ?CT2\n\n?F [Definition 4.7 ]\n(P ?\n{|c,z|}\n\nBU F F ?IO(c,z)) |? {|CT1 ?CT2|}\n\n?F [{|CT1 ?CT2|}?{|ran chseq1 ?ran chseq2|}]\n(P ?\n{|c,z|}\n\nBU F F ?IO(c,z)) |? {|ran chseq1 ?ran chseq2|} |? {|CT1 ?CT2|}\n\n?F [hide-?\nX\n\n-dist]\n\n(P |? ran chseq1 ?ran chseq2 ?\n{|c,z|}\n\nBU F F ?IO(c,z)) |? {|CT1 ?CT2|}\n\n?F [Definition 4.21, assuming Pi? is a process such that ProtIMP(P,i)v Pi?]\n\n(((|||\ni?CT1?CT2\n\nPi?) ||| (Pc? ||| Pz?)) ?\n{|c,z|}\n\nBU F F ?IO(c,z)) |? {|CT1 ?CT2|}\n\n?F [applying the restricting operator]\n\n|||\ni?CT1?CT2\n\nPi?\n\nUsing a similar strategy, but hiding a unique channel per time, it is easy to see that\n\n? j ?CT1 ?CT2 \u2022 ProtIMP(P, j)vF ProtIMP(P[c ?? z], j)\n\nThis concludes that the feedback compositions P[c ?? z] satisfies the provisos of Definition 6.6.\nBy induction, we prove that the Definition 6.6 can be represented by a consecutive application\nof feedback compositions. Moreover, P[chseq1 ?? chseq2] is deadlock-free.\n\nSimilarly, we also define a composition rule for distinct components using several channels.\n\nDefinition 6.7 (Extended communication composition). Let P and Q be two component con-\ntracts, and chseqP and chseqQ two nonempty sequences of distinct communication channels,\nsuch that:\n\n\u2022 CP ? CQ = /0 ? ran chseqP ?CP ? ran chseqQ ?CQ;\n\n\u2022 ran chseqP DecoupledIn P ? ran chseqQ DecoupledIn Q ? #chseqP = #chseqQ\n\n\u2022 ?i,z,c|c = chseqP(i) ? z = chseqQ(i) \u2022 ProtIMP(P,c)[[R c?zIO ]] and ProtIMP(Q,z)[[R\nz?c\nIO ]] are I/O\n\nconfluent strong compatible port-protocols and satisfy the finite output property;\n\n\n\n6.2 COMPOSITION RULES 92\n\nThen, the extended communication composition of P and Q (namely P[chseqP ? chseqQ]Q) via\nthe channels within chseqP and chseqQ is defined as follows:\n\nP[chseqP ? chseqQ]Q = PchseqP ? chseqQ Q\n\nThe composition rule above is very similar to a communication composition, except for the\nfact that it assembles several channels at once. The additional provisos state that each pair of\nassembled channels (chseqP(i) and chseqQ(i)) are independent of the other channels involved in\nthe composition. This proviso guarantees that no cycle of dependencies is introduced. A sim-\nilar composition could be obtained from the application of a communication composition and\nseveral subsequent feedback compositions. Similarly to these composition rules, the extended\ncommunication composition also guarantees deadlock-freedom.\n\nTheorem 6.7. Deadlock-free Extended Communication Composition\nThe extended communication composition of deadlock-free component contracts is also dead-\nlock-free.\n\nProof. This theorem results from Theorem 6.6, since definitions 6.7 and 6.6 carry several pro-\nvisos in common. To use our previous findings, we apply an interleave composition between\ntwo components P and Q. If P and Q satisfy the provisos of Definition 6.6, then P[|||]Q satis-\nfies the provisos of Def 6.6. First, based on the interleave of the components, we observe that\nfollowing relation between port-protocols of P and Q and of the composition.\n\nProtIMP(P[|||]Q, j) =\n\n{\nProtIMP(P, j) j ?CP\nProtIMP(Q, j) j ?CQ\n\nBased on this, and considering CT1 = ran chseqP ?CT2 = ran chseqQ, we observe that:\n\nP[|||]Q |? CT1 ?CT2\n\n?F [Definition 6.2 and hide-?-dist]\n\n(P |? CT1 ?CT2) ||| (Q |? CT1 ?CT2)\n\n?F [{|CT2|} /? ? P and {|CT1|} /? ? Q]\n\n(P |? CT1) ||| (Q |? CT2)\n\n?F [relation between port-protocols of P and Q and of the composition]\n\n|||\nj?CT1?CT2\n\nProtIMP(P[|||]Q, j)\n\nConsidering the above, we are allowed to perform the extended feedback composition on\nP[|||]Q assembling channels of chseqP with chseqQ. Based on Theorem 6.6, such composition is\ndeadlock-free.\n\n\n\n6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 93\n\n6.3 Verification improvements using architectural styles\n\nAs mentioned earlier, the use of architectural styles may help in the verification of component-\nbased systems, and, in special, in verifications related to their compositions. Particularly, we\nuse the styles: interaction, protocol oriented, and BRICK components. The first two styles help\nto guarantee livelock freedom and local progress, respectively. In addition, BRICK components\nhelp to scale our strategy to the development of large systems.\n\nProtocol oriented components deals with a set of concerns related to port-protocols, which\nplay a vital role in our strategy. In particular, we observe that sometimes a channel of a compo-\nnent does not have an associated port-protocol. The reason is that there are several conditions\nthat must be satisfied in order to have a well-formed port-protocol (see definitions 4.6 and 4.5),\nand these are not always achieved after we design the behaviour of a component in terms of\na specific channel. Another concern is that port-protocols associated to a specific channel are\npreserved after successive compositions. These concerns are accomplished by using protocol\noriented components, since it forces all channels to have an associated port-protocol and guar-\nantees that their projections are preserved after synchronisations with other components. As all\nport-protocols in a system are always preserved (even those not observed in a composition), we\nguarantee, by consequence, that all components in a system progress (see Section 5.3.3).\n\nIn the next section, we show how interaction components can be used to help in the treat-\nment of divergences. We show a variant of the wrapping operator, which can be easily used\ntogether with our composition rules to verify by construction the absent of deadlocks and live-\nlocks in a system.\n\nIn Section 6.3.2, we show a set of composition rules for the BRICK components. These\nrules are improved by the use of metadata, which help to alleviate verifications and, further-\nmore, scale in strategy to larger systems. As BRICK components are also protocol oriented\ncomponents, these rules guarantee by construction the local progress, in addition to the ab-\nsence of deadlocks.\n\n6.3.1 Wrapping interactions\n\nA desirable quality attribute not addressed by the general composition rules presented in Sec-\ntion 6.2 is livelock-freedom. The reason livelocks are only dealt with now is because diver-\ngences are only introduced in a composition by performing wrapping (see Definition 5.9).\nFurthermore to our knowledge, no compositional verification strategy detects divergence in ar-\nbitrary systems. In order to solve such a problem, we analyse some properties that explain how\nlivelocks are introduced in the interaction component style (see Section 5.3.1).\n\nLemma 6.1. Let Ctr be an interaction component contract with behaviour P, and C a set of\ncommunication channels. Then\n\nP is livelock-free ? (P \\C) diverges ??t ? InteractionPatterns(BCtr)\u2022 chans(t)?C\n\nProof. This lemma follows directly from the interaction component definition. In an interaction\ncomponent, an infinite trace is formed of the concatenation of several interaction patterns. If\nan interaction component only diverges after hiding certain events, then these events are those\n\n\n\n6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 94\n\nused by the infinite traces of the livelock.\n\nP is livelock-free ? (P \\C) diverges\n?[Definition 5.11]\n?t : InteractionPatterns(P)|chans(t)?C\n\nThe previous property says that if livelock-freedom is not preserved after wrapping an in-\nteraction component (or composition), then there is an interaction pattern that performs only\nevents on hidden channels. This property gives us some insights about how to guarantee this\nquality attribute. Since interaction patterns are usually known, we can keep all possible sets of\nchannels used by each interaction pattern of an interaction component, and predict possible sets\nused after the component being composed with others. We call these sets interaction channels.\n\nDefinition 6.8 (Interaction channels). Let Ctr be an interaction component contract. Then its\ninteraction channels are:\n\nIntChCtr ={chans(t)|t ? InteractionPatterns(BCtr)}\n\nObserving the evolution of interaction channels through compositions, we can predict\nwhether a system is livelock-free or not. So, similar to our composition rules, we propose\na safe version of wrapping, which does not introduce livelocks.\n\nDefinition 6.9 (Wrapping interaction). Let Ctr be an interaction component contract, and CC a\nset of communication channels, such that CC /? IntChCtr. Then the wrapping interaction version\nof Ctr (denoted by CtrddCC) is given by:\n\nCtrddCC = Ctr \\CC\n\nThe wrapping interaction behaves exactly the same way as wrapping, except for its proviso.\nIn order to apply wrapping interaction, we guarantee that no set of channels within interaction\nchannels are hidden. From Definition 6.9 and Lemma 6.1, we are able to state the following\ntheorem.\n\nTheorem 6.8. The wrapping interaction of a livelock-free interaction component contract is\nalso livelock-free.\n\nProof. This proof is straightforwardly obtained from Lemma 6.1 and Definition 6.9. The for-\nmer tells us which channels, after being hidden, would introduce livelocks. The latter prevents\nhiding such channels.\n\nThis theorem can help us to construct another normal form, specialised to our target archi-\ntectural style. The advantage is that if all constituting components are livelock and deadlock-\nfree, so is their composition. We do not explicitly define it here, but it is clear that this normal\nform would include all general rules, and those specific for the architectural style.\n\n\n\n6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 95\n\n6.3.2 Improving composition support using component metadata\n\nDuring development, it is sometimes desirable to keep additional information, called metadata,\nwith the component. Such metadata enrich component contracts with static information that\nassist the runtime environment with additional (validation) properties. In our approach, meta-\ndata comprise information that can (at any moment) be derived from other component contract\nelements (B, R, I, or C). In particular, we use metadata to optimise component composition\nverifications. The formal definition of components with metadata used in this work is presented\nin Section 5.4; other styles enriched with metadata can be defined in a similar way.\n\nSince these metadata comprise derived information, it can be ignored by a composition\nenvironment, and, furthermore, the component can still be used in environments unaware of\nthem. As a consequence, despite the use of metadata can be considered a powerful tool during\nthe integration phase, its use is optional.\n\nTo increase the value of our compositional approach, we derive composition metadata from\nthe metadata of the original components, without always building them from scratch. After\neach composition rule is applied, the metadata is updated using simple formulae that consider\nthe semantics of such composition rule.\n\nIn order to perform lightweight analysis, certain metadata might be informed once for a\nspecific component, and can be left out-of-date, or can be updated with an approximated value,\nafter composition. As a consequence, important composition scenarios are still represented in\nthe metadata, but not all of them. This introduces some approximation to our strategy, and\nrestricts the systems we can construct. However, this does not classify any deadlock system,\nas deadlock-free, neither states as \u2018true\u2019 a property that should be evaluated to \u2018false\u2019. We only\ntag more systems as problematic, requiring further analysis. At any moment, however, one can\nderive metadata from scratch, and give more precision to the approach.\n\nSimilarly to the composition rules presented before, we present four composition rules for\nenriched component contracts. The simpler composition of enriched component contracts is\nthe one formed by the interleaving of its components.\n\nDefinition 6.10 (Enriched interleaving composition). Let P and Q be two enriched component\ncontracts, such that P and Q have disjoint channels, CP?CQ = /0. Then, the enriched interleaving\ncomposition of P and Q (namely P[|||]Q) is given by:\n\nP[|||]Q = Enrich(?BP,RP,IP,CP??? ? ???BQ,RQ,IQ,CQ?,?ProtKPQ,CT X\nK\nPQ,DProt\n\nK\nPQ,Dec\n\nK\nPQ?)\n\nwhere\n\n(i) ProtKPQ = Prot\nK\nP ?Prot\n\nK\nQ\n\n(ii) CT X KPQ = CT X\nK\nP ?CT X\n\nK\nQ (c)\n\n(iii) DProtKPQ = DProt\nK\nP ?DProt\n\nK\nQ\n\n(iv) DecKPQ = Dec\nK\nP ?Dec\n\nK\nQ ?{(c1,c2)|(c1 ?CQ ? c2 ?CP)? (c1 ?CP ? c2 ?CQ)}\n\nThe result of this composition is similar to the one from Definition 6.2. In addition, we show\nhere the metadata associated to the interleaving. At this moment, no benefit is obtained from\n\n\n\n6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 96\n\nthe metadata; they are maintained for more complex compositions. However, the calculation\nof metadata is very simple. It basically includes all information of the metadata of P and Q,\nexcept that it also states that all channels of one component are decoupled from the other; this\nis a direct result of the interleaved behaviour of the composition.\n\nIntuitively, we note that the resulting tuple of an enriched interleaving composition is also\nan enriched component contract. However, unlike the interleaving composition, we have to\nprove that their metadata are well-formed, according to Definition 5.16.\n\nTheorem 6.9 (Enriched Interleaving Composition Compatibility). An enriched interleaving\ncomposition is an enriched component contract.\n\nProof. The proof of this theorem is presented in Appendix B.\n\nSimilarly, we define communication compositions of enriched component contracts in the\nfollowing way.\n\nDefinition 6.11 (Enriched communication composition). Let P and Q be two enriched com-\nponent contracts, and ic and oc two communication channels, such that ic ? CP ? oc ? CQ,\nCP ? CQ = /0, and ProtKP (ic)[[R\n\nic?oc\nIO ]] and the port-protocols Prot\n\nK\nQ (oc)[[R\n\noc?ic\nIO ]] are I/O confluent\n\nstrong compatible and satisfies the finite output property. Then, the communication composi-\ntion of P and Q (namely P[ic ? oc]Q) via ic and oc is defined as follows:\n\nP[ic ? oc]Q = Enrich(?BP,RP,IP,CP??ic? ? ?oc??BQ,RQ,IQ,CQ?,?ProtKPQ,CT X\nK\nPQ,Dec\n\nK\nPQ?)\n\nwhere\n\n(i) ProtKPQ ={(c 7? Prot\nK\nP (c))|c ? dom Prot\n\nK\nP 8{ic}}?{(c,Prot\n\nK\nQ (c)|c ? dom Prot\n\nK\nQ 8{oc}}\n\n(ii) DProtKPQ ={(c 7? DProt\nK\nP (c))|c ? dom DProt\n\nK\nP 8{ic}}?{(c,DProt\n\nK\nQ (c)|c ? dom DProt\n\nK\nQ 8{oc}}\n\n(iii) CT X KPQ ={(c 7?CT X\nK\nP (c))|c ? domCT X\n\nK\nP 8{ic}}?{(c,CT X\n\nK\nQ (c)|c ? domCT X\n\nK\nQ 8{oc}}\n\n(iv) DecKPQ ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? (\n((c1 Dec\n\nK\nP ic ? ic Dec\n\nK\nP c1)? (c2 ?CQ ? c1Dec\n\nK\nP c2))?\n\n((oc DecKQ c2 ? c2 Dec\nK\nQ oc)? (c1 ?CP ? c1Dec\n\nK\nQ c2)))}?\n\nThe result of this composition is similar to the one from Definition 6.3, except for: instead\nof checking compatibility among port-protocols of the original components, we check it on\nport-protocols within their metadata. Furthermore, the composition does not have to take into\naccount the complexity of its components, since no port-protocol has to be derived from the\ncomponent behaviours. In addition, we show here the metadata associated to the composition,\nwhich can be used in further compositions. Again, the calculation of metadata is very simple.\nThey include all information of the metadata of P and Q, excluding information about ic and oc,\nwhich does not belong to the new composition contract. There are also new relations identified\namong channels of one component and channels of the other, requiring that these channels\nare decoupled with the channels involved in the composition (ic and oc). This results from\nthe semantics of the parallel operator being used in the composition. Observe that DecK is a\nsymmetric relation, and, furthermore, this has to be handled in its calculation.\n\nAs for the interleaving composition, the communication composition of enriched compo-\nnents is also an enriched component.\n\n\n\n6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 97\n\nTheorem 6.10 (Enriched Communication Composition Compatibility). An enriched commu-\nnication composition is an enriched component contract.\n\nProof. The proof of this theorem is presented in Appendix B.\n\nNow we define the feedback composition of an enriched component contract.\n\nDefinition 6.12 (Enriched feedback composition). Let P be an enriched component contract,\nand ic and oc two communication channels, such that {ic,oc}? CP, ProtKP (ic)[[R\n\nic?oc\nIO ]] and the\n\nport-protocols ProtKP (oc)[[R\noc?ic\nIO ]] are I/O confluent strong compatible and satisfies the finite\n\noutput property, and ic DecKP oc. Then, the feedback composition P (namely P[oc ?? ic]) hooking\noc to ic is defined as follows:\n\nP[oc ?? ic] = Enrich(?BP,RP,IP,CP??\n???ic?\n?oc?,?Prot\n\nK\nS ,CT X\n\nK\nS ,DProt\n\nK\nS ,Dec\n\nK\nS ?)\n\nwhere\n\n(i) ProtKPQ ={(c 7? Prot\nK\nP (c))|c ? dom Prot\n\nK\nP 8{ic,oc}}\n\n(ii) DProtKPQ ={(c 7? DProt\nK\nP (c))|c ? dom DProt\n\nK\nP 8{ic,oc}}\n\n(iii) CT X KPQ ={(c 7?CT X\nK\nP (c))|c ? domCT X\n\nK\nP 8{ic,oc}}\n\n(iv) DecKS ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? c1Dec\nK\nP c2 ?\n\n((c1 Dec\nK\nP ic ? c1 Dec\n\nK\nP oc)? (ic Dec\n\nK\nP c2 ? oc Dec\n\nK\nP c2))}\n\nThe result of this composition is similar to the one from Definition 6.4, except that most\nprovisos use the metadata of its original components directly. Instead of having to check com-\npatibility among port-protocols of P, we check this on port-protocols within the metadata. In-\nstead of verifying that two channels are decoupled in P, we verify it directly on relations within\nthe metadata. In this way, we perform lightweight verifications. Moreover, the composition\ndoes not have to take into account the complexity of P. In addition, we show here the metadata\nassociated to the composition, which can be used in further compositions. Again, the calcu-\nlation of metadata is very simple. The new metadata include all information of the metadata\nof P, excluding information about ic and oc, which does not belong to the composition con-\ntract. Some other channels are also removed from the decoupled relation DecKS , since after the\ncomposition new communications are established. This composition of enriched components\nis also an enriched component.\n\nTheorem 6.11 (Enriched Feedback Composition Compatibility). An enriched feedback com-\nposition is an enriched component contract.\n\nProof. The proof of this theorem is presented in Appendix B.\n\nThe last rule is the reflexive composition of enriched compositions.\n\n\n\n6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 98\n\nDefinition 6.13 (Enriched reflexive composition). Let P be a component contract, and ic and\noc two communication channels, such that {ic,oc}?CP, and P |? {|c,z|} is buffering self-injection\ncompatible and satisfies the finite output property. Then, the reflexive composition P (namely\nP[oc \u00af??ic]) hooking oc to ic is defined as follows:\n\nP[ic \u00af??oc] = Enrich(?BP,RP,IP,CP??\n???ic?\n?oc?,?Prot\n\nK\nS ,CT X\n\nK\nS ,DProt\n\nK\nS ,Dec\n\nK\nS ?)\n\nwhere\n\n(i) ProtKPQ ={(c 7? Prot\nK\nP (c))|c ? dom Prot\n\nK\nP 8{ic,oc}}\n\n(ii) DProtKPQ ={(c 7? DProt\nK\nP (c))|c ? dom DProt\n\nK\nP 8{ic,oc}}\n\n(iii) CT X KPQ ={(c 7?CT X\nK\nP (c))|c ? domCT X\n\nK\nP 8{ic,oc}}\n\n(iv) DecKS ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? c1Dec\nK\nP c2 ?\n\n((c1 Dec\nK\nP ic ? c1 Dec\n\nK\nP oc)? (ic Dec\n\nK\nP c2 ? oc Dec\n\nK\nP c2))}\n\nThe result of this composition is similar to the one from Definition 6.5. It does not ben-\nefit from the metadata of its original components. This is because to check buffering self-\ninjection compatibility we cannot solely use port-protocols, but the entire component behav-\niour; it checks the behaviour concerning two communication channels. In addition, we show\nhere the metadata associated to the composition, which can be used in further compositions.\nThe structure of the metadata is identical to the one of a feedback composition of enriched com-\nponents, since both are unary compositions. So, similarly to Definition 6.12, this composition\nof enriched components is also an enriched component.\n\nTheorem 6.12. An enriched feedback composition is an enriched component contract.\n\nProof. The proof of this theorem is presented in Appendix B.\n\nDespite the reflexive composition of enriched components does not obtain further benefits\nfrom the use of metadata, we can construct more specific styles and define other metadata to\nalleviate this kind of composition.\n\nObserve that all rules presented here also guarantee deadlock-freedom because the behav-\niour of their compositions is equivalent to the behaviour of the general rules used to create them,\npresented in Section 6.2. Similarly, we could also define a normal form for them, specialised\nto our target architectural style, so that if all constituting components are deadlock-free, so is\nthe composition. As the focus of this section is the preservation of metadata, we did not define\nthis new normal form here.\n\n\n\nCHAPTER 7\n\nCase studies\n\nThis chapter aims to exemplify different scenarios in which our composition rules are appli-\ncable. They show the expressiveness of our rules to construct trustworthy systems. The case\nstudies in this chapter are: the dining philosophers example and a routing coordinator example\n\nEach case study has a different proposal. The first case study shows how our composition\nrules can be applied to construct the seminal dining philosophers example, which includes a\nrecurring problem on resource sharing. The proposal of this case study is to place our strategy\nin the context of others, including non component-based ones, concerning the guaranteeing\nof quality attributes. Contracts with metamodels are used here to improve the verifications of\ncompositions.\n\nWe show that by predicting the behaviour of compositions based on the constituting parts\n(components), we are able to identify the exact moment at development when errors may be\nintroduced. This is not the case when we use the traditional strategy to verify systems. In\nthe example of the dining philosophers, traditionally the verification is performed after the\nsystem is built, and then the developer starts to analyse why the system deadlocks. So, besides\npostponing the detection of the error, much more effort is made to identify its causes.\n\nThe second case study explores the application of our composition rules to construct a\ncoordination system. This study focuses on connectors and not on standard components; con-\nnectors are used to coordinate other components. Our proposal here is to show the diversity of\nthe design elements covered by our composition rules.\n\nAs we present in Appendix C, most necessary verifications in our strategy can be performed\nin the model checker FDR; these concern the verifications that a specification satisfies the\nconditions of our component model, and side conditions of the interleave, communication and\nfeedback composition rules.\n\n7.1 The dining philosophers example\n\nThis is perhaps the most famous example of a deadlock system. As shown in Figure 7.1, five\nphilosophers are seated at a round table with five forks; each fork placed between each pair\nof philosophers. In order to eat, a philosopher must pick up the forks on either side of him or\nher. A philosopher who cannot pick up one or the other fork has to wait. But, since there are a\nlimited number of forks, it is necessary to control the access to such resources. Otherwise, for\ninstance, all philosophers might get hungry simultaneously and pick up a fork, then deadlock\nand starve to death.\n\n99\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 100\n\nFigure 7.1 The Dining Philosophers Problem\n\nEven though this example is anthropomorphic, it actually captures one of the major causes\nof real deadlocks, namely competition for resources. We can model this story in various ways\nin CSP by choosing different \u2018episodes of philosophers lives\u2019 as events, but the essential things\nfrom the point of view of interaction are when they pick up or put down their forks.\n\nBefore presenting the actual components (forks and philosophers) that form the system,\nwe explain the behaviour of a fork and a philosopher as simple CSP processes. The dining\nphilosophers example here has a behaviour equivalent to the one presented in [Ros98], and\nits specification in CSP is a basis for its specification in our component model. As we show\nlater in this section, one of the benefits of using a component model is that we can store in\ncomponents contracts derived information about the system that is useful at verification and\nhelps the developer in his task of evolve the system.\n\nIFORK =IOTFKIN ,FKOUT\nFKIN =picksup|putsdown\nFKOU T =picksack|putsack\nchannel fk1,fk2 : IF ORK\nFORK =(COMPFK(fk1) 2 COMPFK(fk2)) ; FORK\n\nCOMPFK( f ) =PICKUPFK( f ) ; PUTDOWNFK( f )\n\nPICKUPFK( f ) = f .in.picksup ? f .out.picksack ? SKIP\nPUTDOWNFK( f ) = f .in.putdown ? f .out.putsack ? SKIP\n\nThe process FORK ensures that no two philosophers can hold a fork simultaneously. All\nevents associated to fork on the table are represented by the channels fk1 and fk2, each one\nspecific for the interactions with each philosopher. The processes PICKUPFK and PUTDOWNFK\nrepresent the elementary actions associated with a fork FORK. PICKUPFK represents picking\nup a fork, and PUTDOWNFK putting it down; picking up the fork always precedes putting it\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 101\n\ndown (the process COMPFK represents this restriction). The external choice means that the\nfirst philosopher to interact with the fork and pick it up, holds it until put it down. All events\nperformed by these processes are defined by the interface IFORK . To pick up a fork, we use two\nevents picksup and picksack. The former represents the intention to pick the fork, and the latter\nindicates that it has been performed. PUTDOWNFK similarly uses putsdown and putsack.\n\nThe events of a fork are a subset of those communicated by the philosopher, since the latter\nhas a more complex life cycle. Besides picking up or putting down a fork, the philosopher\ncan also think, eat, sit or get up on his chair. It is assumed that a philosopher thinks all the\ntime, except when he gets hungry. When he gets hungry, he sits on its chair and picks up the\nnecessary forks, eats, and then releases the forks, gets up and starts to think again. Of course,\ndifferent philosophers might have different preferences about which order they keep or release\nsuch forks. We assume that each philosopher picks up the left fork first, and puts it down last.\n\nILIF E =IOT/0,LFOU T\nLFOU T =thinks|sits|eats|getsup\nIPHFK =IOTFKOU T ,FKIN\nchannel pf 1,pf 2 :IPHFK\nchannel lf :ILIF E\nPHIL =PREEAT ; (lf .out.eats ? POSTEAT) ; PHIL\nPREEAT =lf .out.thinks ? lf .out.sits ? PICKFORKSUP\nPOSTEAT =PUTFORKSDOWN ; (lf .out.getsup ? SKIP)\nPICKFORKSUP =PICKUPPH(pf 1) ; PICKUPPH(pf 2)\n\nPUTFORKSDOWN =PUTDOWNPH(pf 2) ; PUTDOWNPH(pf 1)\n\nPICKUPPH(c) =c.out.picksup ? c.in.picksack ? SKIP\nPUTDOWNPH(c) =c.out.putsdown ? c.in.putsack ? SKIP\n\nThe process PHIL represents the life cycle of a philosopher. It uses the channels pf 1, pf 2 and\nli f e, which represent events associated to fork manipulations and other philosophers activi-\nties. The datatype of pf 1 and pf 2 are similar to fk1 and fk2, and are used to pick up and put\ndown forks. The central activity in the life cycle of a philosopher is eating. Before eat, the\nphilosopher thinks, sits and pick the forks up (the process PREEAT). After eating, the philoso-\npher puts the forks down and gets up (the process POSTEAT). Philosophers actions on his\nleft and right forks are represented by fk1 and fk2, respectively. The processes PICKFORKSUP\nand PUTFORKSDOWN represent the elementary actions associated to fork manipulations; the\nformer represents acquiring the two forks, and the latter represents releasing them.\n\nBased on these CSP processes, the contract of a fork and a philosopher are represented by\nCtrFORK and CtrPHIL, respectively.\n\nCtrFORK =?FORK,{fk1 7? IFORK,fk2 7? IFORK},{IFORK},{fk1, fk2}?\nCtrPHIL =?PHIL,{l f 7? ILIF E,pf 1 7? IPHFK,pf 2 7? IPHFK},{IPHFK,ILIF E},{l f ,pf 1,pf 2}?\n\nIn order to ensure no fork can be held by two philosophers at once, we represent each fork\nand philosopher on the table behaviour by a CSP process F ORKi or PHILi; where the identifier\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 102\n\ni ?{0..4}. The channels used by the component are:\n\nchannel fk : Int.Int.IFORK\nchannel pfk : Int.Int.IPHFK\nchannel life : Int.ILIF E\n\nIn order to distinguish actions from each philosopher on each fork, there are two integers on\nthe channel fk definition. fk contains two integers standing for the fork and for the philosopher\nidentifier. Similarly, pfk contains also two integers to identify the fork and the philosopher. The\nchannel li f e contains an integer representing the philosopher identifier.\n\nThe contract of the five forks and a philosophers on the table are:\n\nF ORK1 = CompINST (CtrFORK,{fk1 7? fk.1.1,fk2 7? fk.1.5})\nF ORK2 = CompINST (CtrFORK,{fk1 7? fk.2.2,fk2 7? fk.2.1})\nF ORK3 = CompINST (CtrFORK,{fk1 7? fk.3.3,fk2 7? fk.3.2})\nF ORK4 = CompINST (CtrFORK,{fk1 7? fk.4.4,fk2 7? fk.4.3})\nF ORK5 = CompINST (CtrFORK,{fk1 7? fk.5.5,fk2 7? fk.5.4})\nPHIL1 = CompINST (CtrPHIL,{pf 1 7? pfk.1.1,fk2 7? pfk.2.1})\nPHIL2 = CompINST (CtrPHIL,{pf 1 7? pfk.2.2,fk2 7? pfk.3.2})\nPHIL3 = CompINST (CtrPHIL,{pf 1 7? pfk.3.3,fk2 7? pfk.4.3})\nPHIL4 = CompINST (CtrPHIL,{pf 1 7? pfk.4.4,fk2 7? pfk.5.4})\nPHIL5 = CompINST (CtrPHIL,{pf 1 7? pfk.5.5,fk2 7? pfk.1.5})\n\nAlthough all forks are represented by a unique process with indexes on its channels, the\ndefinition of their component contracts are made separately. This helps to understand the inter-\naction of each of them with the environment. The same happens for the philosophers.\n\nTo easy the integration of these components, we use in this case study the metadata of the\ncomponent forks and philosophers. Their metadata is very simple, and only consider informa-\ntion about their protocols. There are no decoupled channels in these components.\n\nAll verifications about the protocols of the fork on the table can be performed on the same\nprotocol PROTFK , which is equivalent for all of them. Similarly, the behaviour (protocols) that\nphilosophers use to communicate with the forks can be represented by PROTPH .\n\nPROTFK = PICKUPFK(fk1) ; PUTDOWNFK(fk1) ; PROTFK\nPROTPH = PICKUPPH(pf 1) ; PUTDOWNPH(pf 1) ; PROTFK\n\nThese protocols are deterministic, and furthermore they have behavioural equivalent context\nprocesses and dual protocols. Observe that due to the fact that all forks and all philosophers\nhave a similar structure and behaviour, any pair of protocols, one of a fork and another of a\nphilosopher, that are equivalent to PROTFK and PROTPH satisfy the same properties of the pair\nPROTFK and PROTPH (see Definition 4.10). Furthermore, enriched versions of these components\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 103\n\nrepeat these protocols on the elements of protocols, context processes and dual protocols, as\npresented below.\n\nEF ORK1 = Enrich(F ORK1,MetaProt(PROTFK,fk1,fk.1.1,fk.1.5))\n\nEF ORK2 = Enrich(F ORK2,MetaProt(PROTFK,fk1,fk.2.2,fk.2.1))\n\nEF ORK3 = Enrich(F ORK3,MetaProt(PROTFK,fk1,fk.3.3,fk.3.2))\n\nEF ORK4 = Enrich(F ORK4,MetaProt(PROTFK,fk1,fk.4.4,fk.4.3))\n\nEF ORK5 = Enrich(F ORK5,MetaProt(PROTFK,fk1,fk.5.5,fk.5.4))\n\nEPHIL1 = Enrich(PHIL1,MetaProt(PROTPH,pf 1,pfk.1.1,pfk.2.1))\n\nEPHIL2 = Enrich(PHIL2,MetaProt(PROTPH,pf 1,pfk.2.2,pfk.3.2))\n\nEPHIL3 = Enrich(PHIL3,MetaProt(PROTPH,pf 1,pfk.3.3,pfk.4.3))\n\nEPHIL4 = Enrich(PHIL4,MetaProt(PROTPH,pf 1,pfk.4.4,pfk.5.4))\n\nEPHIL5 = Enrich(PHIL5,MetaProt(PROTPH,pf 1,pfk.5.5,pfk.1.5))\n\nwhere MetaProt(P,c,a,b) is a function that builds a metadata with protocols equivalent to P substituting\nthe channel c by the channels a and b, and with an empty set of decoupled channels. The function\nMetaProt(.,.,.,.) is defined as follows:\n\nMetaProt(P,c,a,b) =?MProts(P,c,a,b),MProts(P,c,a,b),MProts(P,c,a,b), /0?\nMProts(P,c,a,b) ={a 7? P[[c/a]],b 7? P[[c/b]]}\n\nThe complete system is then formed by putting all the components in parallel. We can build this system\nin several steps, using our composition rules. We can also apply the rules in different orders, and we still\nobtain the same system. For the sake of brevity, we present just one way, which we follow to show the\napplication of different composition rules.\n\nTo accomplish our goal, we first put all forks in interleave to form the composition FORKS, as\npresented below. We do the same with the philosophers to form PHILS, except for the fact that we do\nnot include the fifth philosopher.\n\nFORKS =EF ORK1[|||](EF ORK2[|||](EF ORK3[|||](EF ORK4[|||]EF ORK5)))\nPHILS =EPHIL1[|||](EPHIL2[|||](EPHIL3[|||]EPHIL4))\n\nFigure 7.2 shows the interleave of philosophers. The interleave of forks has a similar configuration.\nWe leave the last philosopher to the last step of this case study in order to analyse in details the dining\nphilosopher problem and its solution.\n\nFigure 7.2 Interleave of Philosophers\n\nFrom the Definition 6.10, the metadata of an interleave composition is defined from the metadata of\nthe original components. Protocols are preserved, while decoupled channels are defined as the possible\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 104\n\ncombination of the channels of the original components. FORKS and PHILS are the result of several in-\nterleave compositions. The set of decoupled channels is given the following set DecKFORKS and Dec\n\nK\nPHILS,\n\nrespectively. Consider\n\nDecKFORKS ={(c1,c2)| {c1,c2}?CEF ORK1 ?CEF ORK2 ?CEF ORK3 ?CEF ORK4 ?CEF ORK5 ?\n{c1,c2}* CEF ORK1 ?{c1,c2}* CEF ORK2 ?{c1,c2}* CEF ORK3 ?\n{c1,c2}* CEF ORK4 ?{c1,c2}* CEF ORK5}\n\nDecKPHILS ={(c1,c2)| {c1,c2}?CEPHIL1 ?CEPHIL2 ?CEPHIL3 ?CEPHIL4 ?{c1,c2}* CEPHIL1 ?\n{c1,c2}* CEPHIL2 ?{c1,c2}* CEPHIL3 ?{c1,c2}* CEPHIL4}\n\nAs a consequence of the interleave composition, a channel of one component is decoupled of all chan-\nnels of the other components. In other words, despite the components are placed together in a composi-\ntion (FORKS or PHILS) the behaviour observed in their channels is independent of the behaviour of the\nother components. Preservation of the protocols is important in all composition rules, except in the in-\nterleaved one, since we do not need the additional step to derive them from the compositions. Similarly,\ndecoupled channels are useful in feedback compositions. These can be used in the compositions, which\nare more elaborate than the interleave composition.\n\nWe use some derived composition rules, which can be explained in terms of more basic ones. In this\nstep, we assemble each philosopher within PHILS to his left fork in FORKS using the extended com-\nmunication composition which results in the PHIL?LFKS composition, presented below. Figure 7.3\nshows this composition.\n\nLEFTPHFKS = PHILS [?pfk.1.1,pfk.2.2,pfk.3.3,pfk.4.4???fk.1.1,fk.2.2,fk.3.3,fk.4.4?]FORKS\n\nThe extended communication composition compositions LEF TPHFKS can be observed as the application\nof a sequence of more basic compositions (see Section 6.2.3). It is the same as applying a communica-\ntion composition between PHILS and FORKS via pfk.1.1 and fk.1.1. Then apply successive feedback\ncompositions on the resulting component via pfk.2.2 and fk.2.2, then via pfk.3.3 and fk.3.3, and, finally,\nvia pfk.4.4 and fk.4.4. As a consequence, LEF TPHFKS preserves the same protocols of the metadata of\nall forks and philosophers within it, and its set of decoupled channels can be described as follows.\n\nDecKLEF TPHFKS ={(c1,c2)| {c1,c2}?CFORKS ?CPHILS ?{c1,c2}* CEF ORK5 ?\n{c1,c2}* CEF ORK1 ?CEPHIL1 ?{c1,c2}* CEF ORK2 ?CEPHIL2 ?\n{c1,c2}* CEF ORK3 ?CEPHIL3 ?{c1,c2}* CEF ORK4 ?CEPHIL4}\n\nFigure 7.3 Communication between philosophers and their left forks\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 105\n\nAfter linking one channel of one component to another, we restrict the set of decoupled chan-\nnels. For instance, channels of F ORK1 are not decoupled from the channels of PHIL1. The set\nabove explained by the communication and feedback compositions involve in the composition\nLEF TPHFKS (see Section 6.3.2).\n\nThen, in the next step, we use the extended feedback composition (see Definition 6.6) to\nassemble each philosopher within LEF TPHFKS to his right fork (see Figure 7.3), resulting in the\nPHILFKS composition. Figure 7.4 shows this composition.\n\nPHILFKS = LEFTPHFKS[?pfk.2.1,pfk.3.2,pfk.4.3,pfk.5.4? ?? ?fk.2.1,fk.3.2,fk.4.3,fk.5.4?]\n\nFigure 7.4 Communication between philosophers and their right forks\n\nIt is easy to observe that the composition PHILSFKS is deadlock-free. There are more forks\non the table than philosophers. The same is observed according to our rules, which preserve\ndeadlock-freedom. The problem arises when we decide to add the last philosopher CtrPHIL5.\nThe reason is that the way philosophers are defined, a system with a cycle of philosophers and\nforks might deadlocks. Below, we show the composition that assembles the last philosopher to\nhis left fork. Figure 7.5 shows this composition.\n\nLEFTLSTPH = PHILFKS[pfk.5.5 ? fk.5.5]CtrPHIL5\n\nThe composition LEF TLST PH is still deadlock-free, but the system development is unfinished.\nRoughly, at this moment, the last philosopher uses a fork on the table and another from outside.\nThe next step would be to assemble the philosopher to his right fork on the table. This is\nperformed in our strategy by assembling two channels of a same component, using the feedback\nor the reflection composition rules. However, none of our composition rules allows assembling\nthe channels pfk.1.5 and fk.1.5 in the component LEF TLST PH . The application of the former\nrule is prevented because these channels are dependent. The application of the latter is also\nforbidden because their dependence protocol is not reflexive compatible. The key reason, as we\nsaid before, is that by adding the last philosopher we might introduce deadlock scenarios to the\nsystem.\n\nTo solve the problem it is necessary to investigate its cause. The system fate is decided\nby the preferences of all philosophers in always picking up the left fork first. As a result, the\n\n\n\n7.1 THE DINING PHILOSOPHERS EXAMPLE 106\n\nFigure 7.5 Communication of the last philosopher and his left fork\n\nsystem might deadlock when all left forks are held. There are several solutions to the dining\nphilosophers problem. Most of them can be categorised in three ways. A set of solutions\ntries to understand the system globally, introducing a global controller that avoids the deadlock\nscenarios; for instance, allowing a butler to be in charge of the dining table [Ros98]. Another\ncategory follows a spontaneous symmetric breaking strategy, defining elaborate protocols to\na philosopher acquire and release a fork [CM84], or, roughly, making the philosophers more\npolite. The last and the easiest category of solutions follows an explicit symmetric breaking\nstrategy. They simply avoid critical scenarios by changing the preferences of some philosophers\non the table. For instance, we can replace PHIL5 by another philosopher PHIL5?, which always\npicks up the right fork first (pfk.1.5), and puts it down last. PHIL5? has the same contract as\nPHIL5, except by this subtle difference in its behaviour. The enriched version of its contract\nEPHIL5? is also very similar to EPHIL5.\n\nPHIL5? =CompINST (CtrPHIL,{pf 1 7? pfk.1.5,fk2 7? pfk.5.5})\nEPHIL5? =Enrich(PHIL5?,MetaProt(PROTPH,pf 1,pfk.5.5,pfk.1.5))\n\nBased on this new component contract, we can continue with the system development. The\ncomposition that assembles the new last philosopher (PHIL5?) to his left fork is represented by:\n\nALEFTLSTPH = PHILFKS[pfk.5.5 ? fk.5.5]EPHIL5?\n\nFinally, the whole system is represented by the following composition DINING.\n\nDINING = ALEFTLSTPH[pfk.1.5 \u00af??fk.1.5]\n\nThe final composition DINING is presented in Figure 7.6.\nThe DINING system is deadlock-free thanks to the symmetry breaking of the philosophers\n\npreferences. In this last step, we chose to use the reflection composition rule, since the involved\nchannels are dependent. Unlike the system with all symmetric philosophers, ALEF TLST PH al-\nlows the application of our rules. In this component, the involved protocols are reflexive com-\npatible. As a consequence, no cycle of ungranted requests is introduced in the system, and the\nsystem is deadlock-free.\n\n\n\n7.2 A ROUTING COORDINATOR EXAMPLE 107\n\nFigure 7.6 Communication of between all philosophers and their forks\n\nIt is interesting to note that all components in the dining philosopher belong to the cyclic\narchitectural style presented in Section 6.3. As a consequence, the cost of verifications is alle-\nviated. Since those are interaction components, verification about divergence-freedom by con-\nstruction is also simplified. For instance, one could be just interested in events about philoso-\nphers life in order to know when he is thinking, eating or seated. This can be obtained by\nwrapping the DINING component contract, hiding all communication about forks on the table.\nThe component PHILLIF E represents the wrapped component.\n\nPHILLIFE = DININGdd{pfk,fk}\n\nAccording to Lemma 6.1, since DINING is deadlock-free and there is no iteration pattern\n(cycle) formed only of events within the channels pfk and fk, then PHILLIF E is livelock-free.\n\nAppendix C presents the specification of the dinig philosophers example in CSPM , and ex-\nplains how this study case can be verified in the model checker FDR.\n\n7.2 A routing coordinator example\n\nIn order to illustrate the application of the composition rules proposed in Section 6.1 on com-\nponent coordinators, we refine the scenario of the ATM system initially presented in Section 5\n(see Figure 5.1). This more elaborate scenario consists mainly of two CLIENT and two SERVER\ninstances that run concurrently (see Figure 7.7.a). No component instance knows each other;\neach CLIENT (Client1 or Client2) interacts with an arbitrary SERVER (Server1 or Server2) to\nrequest services, without knowing the identity of each other. The consistent interaction of\nCLIENTs and SERVERs must be carefully coordinated by the system. In order to achieve that, we\ndesign an elaborate connector (called Connector Network in Figure 7.7.a) composed of other\nconnector instances (see its structure in Figure 7.7.b).\n\nThe Connector Network consists of instances of two kinds of connectors: LBC and CCM.\nTogether, they efficiently route all communications of a CLIENT to a SERVER, establishing a\nsafe communication path between both components until they finish their interaction. The LBC\nis a load balance connector, which verifies which SERVER is available at the moment. The CCM\nformalises a component communication manager, which identifies whether a SERVER is able\n\n\n\n7.2 A ROUTING COORDINATOR EXAMPLE 108\n\n(a) Black box view of the System (b) Structure of the Connector Network\n\nFigure 7.7 Case Study: A more elaborate ATM System.\n\nto interact with a new CLIENT or whether it is busy with an existing interaction. To coordinate\nthe information routing, these connectors communicate data and control events. The control\nevents are used to provide feedback on how the communication is performed.\n\nThe following CCM and LBC processes represent the equally named connectors.\n\nCCM(?co,c1,c2, f1, f2?,?P[co],P2,P3,P4,P5?,SEQI) = CCM\n?(c1,c2, f1, f2,co,P[co])\n\nLBC(?c1,c2,ci, f1, f2?,?P[c1],P[c2],P3,P4,P5?,SEQI) = LBC\n?(ci, f1, f2,c1,c2,P[c1],P[c2])\n\nAs observed in the expressions above, some protocol and interface information are immaterial\nin the definition of the connectors. The channels of both connectors are distinguished between\ncontrol and data information. In fact, to help understanding, we only show data channels in\nFigure. 7.7). Below, we provide the definitions of the auxiliary meta processes CCM? and LBC?.\nThese use some conditions that are not legal in CSP, but that abstractly specifies behaviors that\ncan be later specified in CSP, when the connector becomes concrete.\n\nchannel f ree\nCCM?(c1,c2, f1, f2,co,P[co]) = \u00b5 X. Copy(c1,co,??,P[co]) ; f ree ? X\n\n2 Copy(c2,co,??,P[co]) ; f ree ? X\n?{|c1,c2, f ree|} (Avail( f1,c2,idle) ||| Avail( f2,c1,idle))\n\nAvail( f ,c,status) = f .in?isbusy ? f .out!status ? Avail( f ,c,status)\n2 c ? Avail( f ,c,busy)\n2 f ree ? Avail( f ,c,idle)\n\nCopy(ci,co,s,P[co]) = ci.in?x ? co.out!x ?Copy\n?(ci,co,s\n\n_?x?,P[co])\n2 co.in?y ? ci.out!y ?Copy?(ci,co,s_?y?,P[co])\n\nCopy?(ci,co,s,P[co]) = SKIP<I f ailures(P[co]) = f ailures(P[co]/s)>I Copy(ci,co,s,P[co])\n\nIn the meta processes above, ci, c1, c2, and co are channels used for communicating data.\nThe channels c1 and c2 are used to communicate data between the connectors LBC and CCM,\nwhereas ci and co represent channels for communication with the environment. The channels\nf1 and f2 are used to communicate control data between the connectors. The channel f ree is\nused for internal synchronisation in the CCM. To ease the definitions of the connectors, we use\nprotocol P[c j], where c j stands for the channel associated to the protocol. In fact, these protocols\nrepresent the behaviour of the SERVER component over these channels when the connector is\ninstantiated.\n\n\n\n7.2 A ROUTING COORDINATOR EXAMPLE 109\n\nThe CCM repeatedly behaves as a connector that copies events from c1 to co or from c2\nto co. It chooses between the two behaviours depending on which channel (c1 or c2) has first\nenabled an event to be performed. It continuously transfers values between such channels\nuntil it concludes an interaction (a trace that leads the process to its initial state). In order to\ncheck if interaction has finished, we use the semantic condition failures(P[co]) = failures(P[co]/s\n(see Definition 5.10) At any time, the process CCM can receive an event f j.isbusy asking if\nthe connector is already engaged in an interaction. If so, it performs f j.busy; otherwise, it\ncommunicates f j.idle.\n\nLBC?(ci, f1, f2,c1,c2,P[c1],P[c2]) = \u00b5 X. f1.out!isbusy ? f2.out!isbusy ?\n( f1.in?idle ? f2.in?x ?Copy(ci,c1,??,P[c1]) ; X\n2 f1.in?busy ? ( f2.in?idle ?Copy(ci,c2,??,P[c2]) ; X\n\n2 f2.in?busy ? X))\n\nThe LBC starts by sending an event f j.isbusy to each connector assembled to c1 and c2. The\nfirst to answer f j.idle enables a communication. It continuously copies data from a channel ci\nto this connector until it finishes an interaction.\n\nBefore building the Connector Network, we have to instantiate the connectors LBC and CCM,\nwhich represent concrete connectors. The instance depends on the coordinated component\ncontracts. In our example, we assume they are used to mediate the communication between\nCLIENT and SERVER, previously described in Section 5.2.2. So, data channels have the same\ninterfaces as those of the components, and protocols are based on the SERVER protocol (P[c j] =\nProt(CtrSV ,sv)). Control channels do not depend on the communication data. Below, we present\nthe necessary interfaces, channels and auxiliary processes used to instantiate our connectors.\n\nIF D = IOTF DIN ,F DOU T\nIRC = IOTF DOU T ,F DIN\n\nF DIN : isBusy\n\nF DOU T : busy|idle\nPortRole : u|1|2\n\nConInstance : l1|l2|m1|m2\nchannel idataai : ConInstance.PortRole.ISV\nchannel odata : ConInstance.PortRole.ICL\nchannel i f eed : ConInstance.PortRole.IF D\nchannel o f eed : ConInstance.PortRole.IRC\n\nRN(c) =RUN({|c|})[x/c.x]\nPT (c) =ProtCtrSERVER(sv)\n\nThe channels idata and odata are data channels, and they are typed by the same interfaces\nused by CLIENT and SERVER. The channels i f eed and o f eed are control channels. They are\ntyped by the interfaces IF D and IRC, which are new. All channels defined in this example use\n\n\n\n7.2 A ROUTING COORDINATOR EXAMPLE 110\n\na common, and elaborate, strategy in CSP. They have indexes for different processes which\ncommunicate the same events typed by their respective interfaces. For instance, idata have\nan index (ConInstance) to distinguish connectors, and another (PortRole) to distinguish ports\nwithin each connector. The other channels have similar formats. We also define the auxiliary\nprocesses RN(c) and PT (c). The former is used when the communication order in the channel\nc is immaterial. The latter is used to perform verification of communication within c based on\nthe SERVER protocol.\n\nBased on these auxiliary channels, interfaces and processes, we define two instances of\neach connector LBC and CCM. The component contracts are called LBC1, LBC2, CCM1 and\nCCM2, respectively. Although we define a small number of channels in CSP, their indexes\nallow us to map a bigger number of ports in each component.\n\nLBC1 = F(LBC,?idata.l1.u,odata.l1.1,odata.l1.2,o f eed.l1.1,o f eed.l1.2?,?ICL,ISV ,ISV ,IRC,IRC?,\n?RN(idata.l1.u),PT (odata.l1.1),PT (odata.l1.2),RN(o f eed.l1.1),RN(o f eed.l1.2)?)\n\nLBC2 = F(LBC,?idata.l2.u,odata.l2.1,odata.l2.2,o f eed.l2.1,o f eed.l2.2?,?ICL,ISV ,ISV ,IRC,IRC?,\n?RN(idata.l2.u),PT (odata.l2.1),PT (odata.l2.2),RN(o f eed.l2.1),RN(o f eed.l2.2)?)\n\nCCM1 = F(CCM,?idata.m1.1,idata.m1.2,odata.m1.u,i f eed.m1.1,i f eed.m1.2?,?ICL,ICL,ISV ,IF D,IF D?,\n?RN(idata.m1.1),RN(idata.m1.2),PT (odata.m1.u),RN(i f eed.m1.1),RN(i f eed.m1.2)?)\n\nCCM2 = F(CCM,?idata.m2.1,idata.m2.2,odata.m2.u,i f eed.m2.1,i f eed.m2.2?,?ICL,ICL,ISV ,IF D,IF D?,\n?RN(idata.m2.1),RN(idata.m2.2),PT (odata.m2.u),RN(i f eed.m2.1),RN(i f eed.m2.2)?)\n\nBased on these component contracts, we are now able to construct the Connector Network.\nFigure 7.8 summarises our strategy to compose such components (concrete connectors). To\nbuild the coordinator, we first compose the two instances of LBC using an interleave com-\nposition (see Figure 7.8.a). Then, we perform a communication composition with each CCM\nconnector to the result of the previous composition (see Figure 7.8.b). Subsequently, we use a\nfeedback composition to connect channels of the resulted connector in order to assembly the in-\nner instances of the LBC to instances of the CCM (see Figure 7.8.c and 7.8.d). Control channels\nare composed using similar feedback compositions.\n\nThe following compositions are built throughout this strategy.\n\nConNet1 = LBC1 [|||]LBC2\nConNet2 = (ConNet1[odata.l1.1 ? idata.m1.1]CCM1)[odata.l2.2 ? idata.m2.2]CCM2\nConNet3 = (ConNet2[odata.l1.2 ?? idata.m2.1])[odata.l2.1 ?? idata.m1.2]\nConNet4 = (ConNet3[o f eed.l1.1 ?? i f eed.m1.1])[o f eed.l2.2 ?? i f eed.m2.2]\nConNet = (ConNet4[o f eed.l1.2 ?? i f eed.m2.1])[o f eed.l2.1 ?? i f eed.m1.2]\n\nThe compositions ConNet1 and ConNet2 represent the steps presented in figures 7.8.a, 7.8.b.\nOn these compositions the two LBC instances are interleaved. After the composition ConNet3,\nwhich represents the steps in the figures 7.8.c and 7.8.d, all data channels are assembled. Con-\ntrol channels are assembled on the compositions ConNet4 and ConNet. In fact the ConNet repre-\nsents the entire Connector Network.\n\n\n\n7.2 A ROUTING COORDINATOR EXAMPLE 111\n\na. b.\n\nc. d.\n\nFigure 7.8 The composition steps of basic connectors to form the network of connectors.\n\nUsing our composition rules, we guarantee by construction that ConnectorNetwork is dead-\nlock-free. A black-box version of this coordinator (see Figure 7.7) can also be built using the\nwrapping operation. Thanks to the fact that all concrete connectors are interaction components,\nthe verification of livelock-freedom is also amenable by construction. In fact, it is easy to\nsee that all interactions of the final coordination depend on communications with clients and\nservers, which guarantees livelock-freedom after internal channels are hidden.\n\nThe clients Client1 and Client2, and the servers Server1 and Server2 component contracts are\nspecified as follows.\n\nchannel icl : Int.ICL\nchannel isv : Int.ISV\n\nCtrClient1 = ?CLIENT[icl.1.x/cl.x],{icl.1 7? ICL},{ICL},{icl.1}?\nCtrClient2 = ?CLIENT[icl.2.x/cl.x],{icl.2 7? ICL},{ICL},{icl.2}?\nCtrServer1 = ?(SERVER \\{us})[isv.1.x/sv.x],{isv.1 7? ISV},{ISV},{isv.1}?\nCtrServer2 = ?(SERVER \\{us})[isv.2.x/sv.x],{isv.2 7? ISV},{ISV},{isv.2}?\n\nThe definitions of these contracts are based on the CLIENT and SERVER processes previ-\nously defined in Section 5.2.2. icl and isv are indexed channels, whose indexes represent which\nclient (Client1 or Client2) or server (Server1 or Server2) is communicating via the channel, re-\nspectively. The indexed channels are used in the component contracts definition to represent\nclients\u2019 and serves\u2019 interaction points. Based on these component contracts, the final system can\n\n\n\n7.2 A ROUTING COORDINATOR EXAMPLE 112\n\nbe represented by the composition of the interleave of clients (CLIENT s) and servers (SERVERs).\n\nchannel cl2 : ICL\nchannel sv2 : ISV\nCLIENT s =CtrClient1 [|||]CtrClient2\nSERVERs =CtrServer1 [|||]CtrServer2\n\nCLSV s =CLIENT S [|||]SERVERs\nAT MSY ST EM =CLSV s[?cl,cl2,sv,sv2???idata.l1.u,idata.l2.u,odata.m1.u,odata.m2.u?]ConNet\n\nAll clients and servers are independent of each other and, furthermore, are interleaved in\nCLSV s. Their communication composition with the coordinator ConNet is represented by the\ncomposition AT MSY ST EM , which according to our composition rules, is deadlock-free.\n\nAppendix C presents the specification of the study cases presented here in CSPM , and ex-\nplains how these study cases can be verified in the model checker FDR.\n\n\n\nCHAPTER 8\n\nConclusions, related and future work\n\nAlthough component-based development (CBD) provides mechanisms and tools for construct-\ning systems by plugging components together, the safe construction of these systems is still a\nresearch challenge. Trustworthiness is required during several development activities, such as\nsafe composition of third-party components or the correct adaptation of library components.\n\nIn this work, we have proposed a correct by construction approach for building trustworthy\ncomponent-based systems. The approach focuses on performing analyses that are intended to\naddress engineering concerns on CBD. In special, we focus on component integration. The\nentire approach is underpinned by the CSP process algebra, which offers rich semantic models\nthat support a wide range of process verifications, and comparisons. In fact, CSP has shown to\nbe very useful to support the rigorous development of component based systems, as a hidden\nformalism for modelling languages used in practise [RSM05, RSM06].\n\nThis work contributions fall into the following areas.\n\nA study of protocol compatibility. This study has been performed independently of the con-\ncept of components and considers both synchronous and asynchronous mediums. More-\nover, test characterisations via refinement checking are presented. The novelty in this\nstudy is not only presenting compatibility in asynchronous mediums, but also consider-\ning complex I/O communications, covering a wide variety of applications.\n\nThe BRIC component model. This component model is aligned to other models with behav-\niour descriptions. It focuses on (re)active components that are input deterministic and\noutput decisive. Reuse and compositions are allowed not only to components, but also to\nconnectors. Furthermore, it considers not only compositions between two distinct com-\nponents, but also the assembly between ports of the same component. This brings more\nflexibility to design decisions at development. An operation for hiding information to\npack components into black-boxes is also presented.\n\nA comprehensive set of composition rules. We present a set of composition rules that can be\nregarded as safe steps in the development. The application of the rules can be used to\nsystematically develop a wide variety of trustworthy component systems, and guarantees,\nby construction, the absence of deadlock and livelock. The approach covers not only\ntree-topologies but also topologies with cycles in a compositional method, without being\naware of needing to know the overall structure of the system. Port-protocols play an\nimportant role in the approach, and, in conjunction with other properties, help to alleviate\nverifications by supporting local analyses.\n\n113\n\n\n\n8.1 SUMMARY 114\n\nImprovement of verification using enriched component with metadata. We propose an in-\ntegrated correct by construction approach for component contracts using metadata, which\nextends our approach for arbitrary components with improved and lightweight side con-\nditions. Metadata are derived from component contract elements and are used in substi-\ntution to heavier verifications in the version without metadata. Additionally, metadata of\ncompositions can be easily derived from the metadata of its constituting components. As\na result, the order of complexity of the verifications is drastically reduced. Moreover, the\nimprovements in this approach ensure not only the absence of deadlock and livelock, but\nalso guarantee local progress of all components in the system.\n\nDespite these contributions, the proposed approach has some limitations:\n\n1. We require that component contracts have an associated behaviour. This is not always\nthe case in several component models in industry, however it is essential to support be-\nhavioural verifications;\n\n2. The benefits of using metadata are limited to the application of composition and feed-\nback composition rules. Although this corresponds to two of the four basic proposed\ncomposition rules, the application of the other composition rules is compatible with our\nstrategy with metadata. Moreover, one of these composition rules, the interleave one, is\nalready very simple, and does not need of further improvements.\n\n3. The strategy with metadata indicates that some compatible communications between\ncomponents, as incompatible (false-negatives). This is an intrinsic problem in local anal-\nysis methods, which is acceptable considering the advantages that it brings in scalability.\nIn these scenarios, the developer have to use traditional verification methods to com-\nplement our strategy. Furthermore, the strategy with metadata must be adopted as a\ntechnique that guides the attention of the integrator to the most crucial compositions, and\nnot as a \u2018silver bullet\u2019 method for the composition problem in general.\n\nA summary with some more details of our contributions is presented in the next section.\nIn Section 8.2, we relate our work with others in the literature. And, finally, we present in\nSection 8.3 future research directions for this work.\n\n8.1 Summary\n\nTo achieve the contributions previously mentioned, which have been also partially presented\nin [RSM10, RSM09], we have defined the BRIC and BRICK component models for compo-\nnents (see Chapter 5), whose contracts are described by their dynamic behaviour, interfaces,\ninteraction points (ports), and optionally some metadata (see definitions 5.3 and 5.16). These\nbasic elements of a component contract are called B, R, I, C, and K, respectively. The BRIC\nand BRICK models are distinguished by metadata. BRIC component contracts contains B, R,\nI and C elements. This component model imposes the necessary constraints that characterise\nwhich kind of components, as well as interactions, are supported by our approach. BRICK\n\n\n\n8.1 SUMMARY 115\n\ncomponents contracts add the existence of K elements. Since metadata can be derived from the\nother four elements of the contract, a BRIC component can be easily converted into an BRICK\ncomponent. Aligned with other practical approaches [MB05], connectors are introduced in\nour component model at two different abstraction levels. To increase the range of compo-\nnents they integrate, connectors are abstractly defined at the design level, in a parametrised\nform. When all parameters are fulfilled, a connector is instantiated as a component, which is\nready to be composed with other components, or to form more elaborate connectors. Based\non these basic notions, we define important constructive constraints that underline important\ncomponent-based development activities in Chapter 6.\n\nAll composition rules ensure the preservation of design properties by construction. In par-\nticular, we propose compositions that are defined on top of the notion of service conformance.\nService conformance can be understood as a design principle to be followed, when permit-\nted: unused services of a component should be still available after composition. The degree\nof satisfaction of this notion may vary from preserving all services to at least one, respectively\ncorresponding to the strong and the weak conformance notions. The set of composition rules\nfor the BRIC and BRICK component models satisfies the weak and the strong service confor-\nmance notion, respectively. Additional constraints in the BRICK component model ensure the\npreservation of such services. In this context, the set of composition rules for BRIC compo-\nnents is aimed at more general components. On the other hand, the set of rules for BRICK\ncomponents additionally considers enriched contracts. The latter set of rules performs simple\ncalculations with the metadata in substitution to more general verifications in the original rules\nfor BRIC components. As a result, the complexity of verifications for BRICK is reduced, and\nthe composition task is simplified.\n\nA distinguishing feature of our approach is that each of the proposed composition rules is\nintentionally simple to capture a particular communication pattern with the relevant side con-\nditions to preserve behavioural properties. The approach mainly relies on three basic rules for\ncomposing components: interleave, communication and feedback compositions. Altogether\nthese three composition rules allow the construction of a wide variety of useful complex com-\nponent based systems with tree topology structure configurations (see Section 6.2). An elabo-\nrate composition rule, called reflexive, is also provided for constructing systems with arbitrary\narchitectural configurations. Complex interactions can be progressively built from these very\nsimple rules, as illustrated in Section 6.2.\n\nEach composition results in a component, whose properties are directly derived from the\ncomponents involved in the composition. The rules guarantee both deadlock-freedom and\nlivelock-freedom in the compositions based on the assumption that the original components\nhold these properties. The verification of livelocks is straightforward, since this problem is\nnot introduced by any of our composition rules, but by performing wrapping operations after-\nwards (see Section 5.2.5). This operation hides the part of the component behaviour that is not\navailable for composition (the interaction between the sub-components of the composition).\nThe verification of livelock in general systems (BRIC components) is prohibitive, since it must\nbe verified in the whole system (rather than based on information of the inner components in\nthe system). Means to alleviate the verification of wrapping (see Section 5.2.5), in a specific\narchitectural style, is presented in Section 6.3.\n\n\n\n8.2 RELATED WORK 116\n\nTo guarantee deadlock-freedom in simpler topologies, the composition rules include side\nconditions that require the compatibility between communication protocols and the decoupled\nchannels. The former ensures compatibility between component communications, and the lat-\nter avoids undesirable architectural configurations. To simplify verifications of these side con-\nditions, one can optionally enrich component contracts using component metadata (see Sec-\ntion 6.3.2). Composition is improved by carrying out partial verification results on component\nmetadata throughout component compositions. To guarantee deadlock-freedom in structures\nwith cycles of communicating components, more elaborate conditions are considered. These\nensure that no cycles of ungranted requests [Ros98] are presented in the system.\n\nTo guarantee livelock-freedom, we analyse some interesting properties that explain how\nlivelocks are introduced in the interaction component style. Based on these properties we\ncan propose new composition rules that preserve livelock-freedom. Those composition rules\ninclude side conditions (see Section 6.3), which require that no interaction pattern (recurring\nbehaviour) of the original component be entirely hidden in the black-box composition. An\nintegrated approach with composition rules for the interaction components architectural style\nis presented in [RSM09].\n\nThe application of our approach has been illustrated in two case studies in Chapter 7: the\ndining philosophers example and a routing coordinator example. Each case study has a differ-\nent purpose. The objective of the dining philosophers case study is to place our strategy in the\ncontext of others, including non component-based ones, concerning the guaranteeing of quality\nattributes. The purpose of the routing coordinator case study is to show the diversity of the\ndesign elements covered by our composition rules, which are used in this case to construct an\nelaborate coordination system.\n\n8.2 Related work\n\nThe topic of this thesis expands over fields of architecture and reliability modelling. We have\nstudied a variety of approaches in each domain, and identified a few approaches that span both\ndomains. In this section, we first present a summary of related approaches to architectural\nmodelling. We then provide an overview on existing reliability models. The former focuses\non the characteristics of our component model, and the latter on the constructive constraints to\nensure properties on component-based systems. Since there is an extensive number of works\nin these fields, we focus on the works being most influential and related to our work.\n\n8.2.1 Component models\n\nThere are several different approaches to component models. As pointed out in [Wal03], each\ncomponent model is designed to achieve specific goals. Furthermore, each one has its benefits\nand deficiencies, depending on the context in which it is analysed. In this section, we consider\nrelated works and compare them according to the context of this thesis. For instance, there are\nmultiple (modelling) aspects for component [RM04].\n\nTo begin with, we do not relate our work with other component models that define low-level\ngranularity components, in which contracts/interfaces capture solely syntactical information\n\n\n\n8.2 RELATED WORK 117\n\n(like method signatures). Low-level granularity component models are associated to compo-\nnent technologies found in industry that are usually designed to support quick development or\nto permit the use of different programming languages in development. These are furthermore\nnot designed for reasoning. In order to get around this limitation concerning interface represen-\ntation, several authors [FLF01, LD00, LW94] propose the specification of the \u2018behaviour\u2019 part\nvia pre- and post conditions and invariants. According to [Pla05], one of the key obstacles in\napplying these approaches to components is that they require an explicit capturing of (object)\nstate - this may be both a very hard-to-achieve and, potentially, limiting decision at an early\nstage of a component design.\n\nWe focus on works that support behaviour description of entities. The idea of expressing\nbehaviour of an object as a regular process (via traces as sequences of method calls) has been\npublished in [Nie93]. It even considers the role of client calls (in a simple case) via parallel\ncomposition. The importance of capturing behaviour of components as sequences of events for\nCOTS components (commercial off the shelf) is emphasized also in [DR02] where a way of\nidentifying behaviour via monitoring experiments is described.\n\nThere have been a huge number of publications on behaviour description of components\nand connectors [ADG98, BCD02, HLL06b, BHP06, Arb04, Sif10, CZ07]. Our approach in-\ntegrates aspects from different but closely related domains. The target concrete syntax of our\nwork is CSP, but the elements within BRIC component contracts (see Definition 5.3) are not\ndirectly represented by this notation. CSP is used to give the underlying semantics of our com-\nponent model, and to help verifications. However, there are more suitable concrete syntaxes\nto represent our notions at development phase, such as Architectural Description Languages\n(ADLs) [MT00] or the modelling languages UML-RT [SR98] and UML2 [Obj07]. The con-\ncepts in these languages are highly compatible with our component model, and one can benefit\nfrom using both approaches, like modelling in one language and performing verifications in\nanother.\n\nOur component model is based on I/O transition systems, has explicit architectural struc-\nture, and presents connectors as first class design elements. These characteristics resemble\nseveral ADL approaches, such as Wright [AG97, ADG98], Darwin [MK96], PADL [BCD02],\nand ROOM [SGW94]. Our component model focuses on design elements, and does not take\ninto consideration the expressiveness of programming languages as architectural programming\nmodels, such as ArchJava [ACN02], SOFA [BHP06], Fractal [BCL+06], rCOS [HLL06a,\nCHLZ07] and BIP [Sif10]; the design concepts in these ADLS are, however, compatible\nwith concepts in our component model. Another related ADL is ROOM [SGW94], which later\nevolved to UML-RT [SR98], which in the meantime has been incorporated into UML2 [Obj07].\n\nDespite their similarities, the representation of components in these works differs in some\nextent. Some consider the internal behaviour of components, e.g. [BCL+06, HLL06a], other\nthe external behaviour, e.g. [ADG98]. Some component models represent components solely\nby their port-protocols, e.g. [CZ07], other neglects this kind of behaviour, e.g. [HLL06a]. In\nour work, we discriminate the external behaviour of components and their points of interactions\n(port-protocols). Component contracts have the whole external component behaviour, or are\nenriched with port-protocols (see component contracts and metadata in Chapter 5). Each kind\nof behaviour has its benefits in reasoning. Port-protocols alleviate verifications, whereas the\n\n\n\n8.2 RELATED WORK 118\n\nwhole behaviour of components is essential for structural analysis of larger systems. The com-\nparison with approaches to verify component-based systems is presented in the next section.\nOur component model also has operations to hide information in component contracts. The\nwrapping operation hides the part of the component behaviour that is not available for com-\nposition (the interaction between the sub-components of the composition). This is, however,\ndifferent from the concept of publication presented in rCOS [ZKL10] for creating \u2018black-box\ncomponents\u2019. In rCOS, a publication is an abstraction of a contract that removes behavioural\ninformation from the contract.\n\nAnother important issue is the representation of connectors. Some works have an explicit\nrepresentation for connectors, e.g. [ADG98], others connectors are not distinct from compo-\nnents, e.g. [HLL06a]. In some approaches both in components and connectors can be reused.\nOur approach is closest to that of [Spi04], in which, at the design level, connectors are repre-\nsented as parametrised CSP processes, called connector wrapper templates. At the integration\nphase, connectors have the same representation as components [ADG98, Spi04]. This provides\nmeans of enhancing existing connectors at different levels of abstraction, which is aligned with\npractical approaches of connector representation [MB05]. The more abstract one is used at\ndesign and it is meant for reuse. The more concrete one has the same structure of components,\nand it can, therefore, be used as units of compositions.\n\nThis issue is related to coordination languages. In these languages, connectors are used to\ncoordinate component interactions. Compared to ADL connectors, these connectors can repre-\nsent much more sophisticated coordination policies for sets of components. In the coordination\nlanguage Reo [Arb04], complex connectors are constructed from a composition of a compre-\nhensive set of basic connectors. The computational aspects of the connectors are therefore\nlimited to these basic connectors. In our work, we do not focus on coordination issues. Apart\nfrom that, one can build exogenous coordination on the top of our component model. Connec-\ntors can also be built from more basic ones, and, at any level, connectors can have complex\nbehaviours (see the routing coordinator example in Section 7.2.\n\nMost of these component models [AG97, BCD02, HLL06b, Sif10, CZ07] have an under-\nlying semantics, which allows verifications; most of these component models are classified as\nADL, and typically subsumes a formal semantic theory [MT00]. In the next section, we discuss\nthe relations between our approach and the verification methods in these works.\n\n8.2.2 Reasoning model\n\nThere are several efforts on the verification of Component-based Systems [BCD02, MCM08,\nHJK10, MW97, AG97]. The scalability issue in compositional verification has been actively\naddressed in this field; compositional verification is based on the idea that the correctness check\nof a complex system can be divided into smaller verification tasks for its components. In this\nsection, we compare our work, not only with approaches with an explicit component model,\nbut also with others that focus on the verification of behavioural elements (which may not be\nfully aligned with a component development method).\n\nThe work reported in [GGMC+07, MCMM07, MCM07] presents an extensive study of\nquality properties in CBS. It discusses liveness, local progress, deadlock, fairness and ro-\nbustness. We implicitly discuss these properties, except fairness and robustness. The dead-\n\n\n\n8.2 RELATED WORK 119\n\nlock property is locally addressed by our compatibility notion, which is an important condi-\ntion of our composition rules. Therefore, deadlock is preserved by our composition rules for\nBRIC components, and local progress is also preserved when composition rules are applied\nfor BRICK components (components with metadata). None of the composition rules introduce\nlivelock. In our approach, these may be introduced by wrapping operators. In this context,\nwe also present an approach to alleviate the compositional verifications of these properties on\nthese operations. Relating to fairness (of process schedules or of internal event choices), we\nbelieve that it must be performed by coordinators, which mediate component interactions. As\na consequence, fairness is a property associated to a coordination purpose and that requires a\nspecific verification, which is out of the scope of this work. Robustness is a desirable property\nwhich is not addressed by our work.\n\nEven though there are many approaches to formally model component based systems (CBS)\n[ADG98, AB03, IM08, HLL06b, PV02], to our knowledge the question of preserving, by\nconstruction, behavioural properties has not yet been fully systematised as we have done in\nthis work. Despite the fact that our black-box component contracts are compatible with most\ncomponent-based approaches, especially those based on CSP or CSP-like notations [Ros98,\nHLL06b], most approaches to date aim at verifying the entire component-based systems before\nimplementation, but not predicting behavioural properties by construction during design. We\ncan ensure deadlock- and livelock-freedom in a constructive way, as a result of applying com-\nposition rules, as opposed to performing model checking verification after the system has been\nbuilt. The compositional approach can be applied in heterogeneous systems (synchronous and\nasynchronous) with different topologies (tree or cyclic).\n\nApproaches to verifying a system tend to use abstraction techniques to reduce the state\nspace. They map a set of states of the actual system to an abstract, and a smaller set of\nstates in a way that preserve the behaviours of the system. [ZM10] adopts counterexample\nguided abstraction refinement scheme to alleviate the state explosion problem of deadlock de-\ntection. It extends the classical labelled transition system models by qualifying transitions as\ncertain and uncertain to make deadlock-freedom conservative. A similar approach is presented\nin [Kwi07]. It determines their sets of \u2018conflict-free\u2019 actions, called untangled actions. Un-\ntangled actions are compositional; synchronisation on untangled actions will not destroy their\n\u2018conflict-freedom\u2019. Following the same approach, [CCH+09] proposes a deadlock detection\nalgorithm based on navigating and marking transitions on a dynamic synchronization depen-\ndency graph.\n\nOther approaches tend to design components and interactions using strict component mod-\nels in order to avoid undesirable properties, such as deadlock. [DZZL10] builds up a service\ninteraction model and analyses the deadlock problem related with shared internet resources. It\nproposes some interaction solutions to effectively prevent deadlocks. In this context, our ap-\nproach can also be specialised for a specific architectural style. In [RSM09], we combine side\nconditions presented in this thesis to propose specific composition rules for interaction compo-\nnents. In this work, all verifications and notions support the analysis of partitions of the com-\nponent (and composition) behaviour in space (protocols) and time (interaction patterns). This\napproach combines the advantages of the approaches presented in [VVR06] and in [BBT01],\nwhere physical and temporal partitions are realised, respectively. Protocols are observed as a\n\n\n\n8.2 RELATED WORK 120\n\nparticular type in [VVR06], which permits the verification of compatibility. However, concerns\nabout the entire component behaviour are ignored in the definitions of [VVR06]. Interaction\npatterns are also defined in [BBT01], however without defining any conformance notion for\ncomponents or compositions. None of these works defines test characterisations that can me-\nchanically be performed in verification tools.\n\nThe study of deadlock-freedom is related to the analysis of component incompatibilities. In\nthis context, component compatibility is established by determining those components which,\nwhen connected, are free of deadlock. The study of behavioural compatibility helps to reduce\nthe cost of analysing deadlocks in compositions. The criterion exploits compositionality in the\nsense that a condition is locally checked on pairs of neighbouring components. If the condition\nis satisfied we can derive the property of deadlock-freedom. Thus, the state space construction\nrelated complexity is O(n) in the case of the architectural compatibility check, and O(? n) in the\ncase of the direct check.\n\nIn PADL [BCD02] and in [MCM08] compatibility is used to detect architectural mis-\nmatches and it is shown that pairwise compatibility is a sufficient criterion to derive deadlock-\nfreedom of an acyclic assembly from the deadlock-freedom of its local components. These\napproaches consider the whole behaviour of the constituting components in the composition.\nDifferently, our approach is centred on the use of port-protocols to alleviate compatibility veri-\nfications.\n\nCloser to our approach is the work presented in [LMC10, CZ07] that performs architec-\ntural compatibility verifications based on compatibility of port-protocols. The restriction in\n[LMC10] is that only deterministic protocols are considered. [CZ07] proposes a formal model\nof component interaction, in which component compatibility is verified using labelled Petri\nnets. In this work, the behaviour of components is represented solely by their port-protocols,\ncalled interface languages, which contains either possible sequences of required or provided\nservices. A request (rich) interface is compatible with a provider (rich) interface if and only if\nall sequences of services requested by the former can be provided by the latter. This condition\nreassembles our denotation definition of compatibility. However, as we deal with bidirectional\nI/O channels, these conditions are verified in each state of the protocol for both directions.\n\nA notion similar to behavioural compatibility is used by [HJK10] under the name of neutral-\nity. The verification of properties for the whole component then follows from the verification\nstep that uses only weakly deterministic port-protocols. Behavioural neutrality is defined in\nterms of observational equivalence between the behaviour of an assembly with two connected\ncomponents and the behaviour of an assembly with a single component and the binary connec-\ntor replaced by a unary one. This notion plays an important role in its reduction strategy. A\ncomponent neutral to another can be removed from the analysis of composition because they\ndo not contribute with any change in the external observable behaviour of the composition.\nThere are two restrictions in the approach: components must be weakly deterministic and in\norder to be neutral their input and output labels must mutually coincide. As verified in [CZ07],\nit is possible that one component does not use all services of another, and, therefore, that one\ncomponent might output fewer events than the other one may possibly input.\n\nAnother notion related to behavioural compatibility is used in [CK96] under the name of\ntransparency. In [CK96] automatically derived context constraints (restrictions imposed by the\n\n\n\n8.2 RELATED WORK 121\n\nenvironment on subsystem behaviour) are used to construct the LTS behaviour of composed\nsystems more efficiently. Context constraints take the form of interface processes, which cap-\nture the interplay of the environment of a single fixed component as part of the composition\nwith other components. If the composition of the interface process and the fixed process results\nin a smaller transition system, it is substituted in the overall analysis. The correctness of the ap-\nproach relies on a transparency property which requires a strong semantic equivalence between\nthe fixed process and its composition with its interface process. Compatibility is verified by\nchecking if the interface process is well-formed. In [AG97], the interface process associated to\na port is called a deterministic process of a process. Compatibility of two processes is checked\nby verifying the refinement relationship between a process and the synchronisation of another\nprocess and the deterministic process of the former. In our work, the interface process and\ndeterministic versions are called contextual process, and similarly to [AG97] is used solely in\ncompatibility checks, rather than in a more general analysis as in [CK96]. Similarly to [AG97],\nwe check compatibility of two protocols as the refinement of a protocol by its context process\nsynchronised with the dual protocol of the other. A dual protocol represents the most nonde-\nterministic process that is compatible with a protocol. We use this notion as we deal with I/O\nprocesses in this work.\n\nOur component model considers I/O processes that implicitly support bidirectional com-\nmunications. The possible existence of non-determinism in I/O processes and of bidirectional\ncommunication brings more complexity to our verifications than the works related to the no-\ntion of compatibility mentioned above [CK96, AG97, BCD02, MCM08, HJK10, LMC10]. For\ninstance, in [LMC10, BCD02] components must be deterministic. This prevents designer from\nconsidering situations where the components take internal decision (see output decisiveness,\nDefinition 4.4). Bidirectional communication may implicitly introduce small cycles (with two\ncomponents), and furthermore is not addressed by the works above, since they use compat-\nibility in component-based systems with tree-topology structures of unidirectional channels.\nHowever, bidirectional communication is implicit in our component model, and is furthermore\ndirectly support by our compatibility notion. Except for the work on PADL [BCD02, AB03],\nnone of the works cited above deal with cyclic topologies. Even this approach does not present\na solution to alleviate the verification of applications in such topologies. In [BCD02, AB03]\nto verify deadlock-freedom, deadlock freedom is locally considered in the relationship of each\ncomponent with the others in the whole cycle. Similarly to the seminal work on deadlock-\nfreedom [Ros98], the approach needs to know the internal structure of the entire system (which\nis also a component) a priori, which is in the opposite direction of a compositional method.\nIn our work, cyclic topologies are verified in compositional correct-by-construction approach,\nas soon as the cycle appears. A detailed comparisons between the basic concepts in [Ros98]\nand our study on protocol compatibility is presented in Appendix A. Means to alleviate the\nverification are presented by the notion of decoupled channels (see Section 6.2.1).\n\nA further important difference between checking compatibility of port-protocols (as done\nin our work) and checking the compatibility of entire component behaviours is that the use\nof explicit port behaviours makes the check for compatibility more efficient. Furthermore,\nas mentioned in [LMC10], this supports a gray box view of the components that is desired\nin CBD similar to the principle of information hiding. Despite the benefits of port-protocol\n\n\n\n8.3 FUTURE WORK 122\n\nrepresentation, representing the whole component is also necessary. For instance, the approach\nin [CZ07] abstracts the internal behaviour of components, and concentrates solely upon the\nbehaviour exhibited by port-protocols. Concentrating solely upon the behaviour exhibited by\nport-protocols, these works indirectly restrict the structure of their systems to tree-topologies,\nwithout cycles. For the same reason, it is forbidden to assembly multiple points of interaction\nbetween components, which implicitly introduce minor cycles. Similarly, the approach forbids\nthe verification of other emerging properties of the system, such as livelock, which emerges\nfrom the interaction of the components.\n\nSome approaches [IM08, MW97] do predict some system properties based on the proper-\nties of its constituting components. This is performed by categorising components and their\ncommunication patterns in order to prevent scenarios in which the interaction among compo-\nnents would introduce improper states. These works focus on different properties. The work\nreported in [IM08] does not focus on behavioural properties; rather, it presents some results on\nperformance. The approach presented in [MW97] proposes rules to guarantee the absence of\ndeadlocks by construction. However, it presents rules for specific protocol patterns, such as re-\nsource sharing and client-server, using simple data communication; for instance, a component\nmust always accept any input data value.\n\n8.3 Future work\n\nThe correct by construction approach proposed in this thesis can be extended in many ways.\nThere are several directions for building on the results of this work. Moreover, there are oppor-\ntunities for new interesting related research directions.\n\nSome extensions and improvements to the contributions of this work include:\n\nMore complex case studies. In order to better support the process of component-based de-\nvelopment, it is necessary to develop further case studies and carefully analyse what is\nthe support needed by the developers to apply the proposed rules in practice. A promis-\ning case study to start with is the CoCoME [RRMP08], which is a common component\nmodelling example that has been used to evaluate and compare the practical appliance of\nexisting component models;\n\nEvaluation of the time complexity of the approach. An important issue is to perform a com-\nparative study of the performance of our approach and other existing approaches in the\nliterature. This is essential to reinforce the benefits of our approach;\n\nIncreased breadth of architectural styles support, both in the number of styles and in the\nspecialised constructive constraints to support their development. This requires the study\nof the specialities of each style and how these would help to alleviate verifications in a\ncompositional approach;\n\nIncorporating and building on additional kinds of formalisms and analysis techniques, to\nprovide analyses of quality attributes for which our current component contracts are pos-\nsible awkward or inadequate. For instance, the combination of process and data-based\n\n\n\n8.3 FUTURE WORK 123\n\nspecifications, such as CSP-OZ [MORW04] and Circus [SWC02], can improve our strat-\negy to deal with component contracts with pre- and post conditions;\n\nAdopt a concrete syntax. It is essential to adopt a more convenient concrete syntax to the use\nof our notions. UML2 [Obj07] introduces notions of components, ports and structured\nclassifiers which are, not surprisingly, a perfect match with the syntactic requirements\nof our component model. Given that the UML2 shows a number of semantics variation\npoints, and also ambiguities, a mapping to our used semantics is needed. A start point\ncould be the similar mapping performed by the author from UML-RT into the Circus\nprocess algebra [RSM05].\n\nIncorporate new metadata to enrich component contracts that can improve our approach.\nFor instance, the notion of channel interactions (see Section 6.3.1) could be used to im-\nprove subsequent wrapping operations in a system. Other metadata can be identified and\nincorporated to our approach.\n\nBuilding tool support for the design of trustworthy component systems based on our ap-\nproach. This would include the environment for modelling and integrate components,\nas well as to perform rule compositions.\n\nThere are several other directions in which our work can be extended. These include:\n\nNew wrapping operators. Recently came to the author new ideas for performing wrapping\noperations. Instead of just hiding events of a channel to build back-box components,\none would require to ban the events. The reason is that hiding in CSP is an \u2018eager\u2019\nabstraction, since it reflects the idea that events abstracted are thought of as occurring at\nthe earliest opportunity. Change to the abstraction operator may bring big consequences\nto our approach. Applying wrappings would possibly introduce, for instance, deadlocks\nto the system.\n\nSubstitutability. Besides composition, substitution is another important aspect in the devel-\nopment of component-based systems. Most works on substitutability are based on the\nnotions of behavioural subtyping [LW94, Weh03], which is a strong form of relationship\nbetween two (component) types. It requires instances of a subtype and of a supertype to\nfulfil the principle of type substitutability [LW94]:\n\nAn instance of the subtype should be usable wherever an instance of the su-\npertype is expected, without a client being able to tell the difference.\n\nThis suggests the use of some form of refinement [Ros98] to formalise behavioural sub-\ntyping. Refinement guarantees substitutability in an even stronger form: a system can\nalways be replaced by its refinement without any noticeable difference. For subtyping,\nwe want only a replacement to be unnoticeable at places where a supertype is expected.\nThis is a weaker form of substitutability, but that nevertheless can be characterised in\nterms of refinement [Weh03]. Different substitutability relations can be defined if we are\naware of the context in which the component is. For instance, in [RSM10], we propose\n\n\n\n8.3 FUTURE WORK 124\n\nnew substitutability relations for components in which the environment can be partitioned\nin distinct parts that are intermediated by the component.\n\nIn contrast with composition, substitutability relate components that not currently pre-\nsented in the system (it relates a present configuration with a future one). As conse-\nquence, besides the definition of substitutability notions, it also is necessary to establish\nas a future work its relation with other constructive relations, as the composition rules\npresented here.\n\nCoordination An open issue in this work is the coordination of components. More research\nhas to be done in this direction. A desirable issue, for instance, is to easy the correct con-\nstruction of exogenous coordinators, aligned to the concepts of our component model. A\nfirst candidate to be the building blocks of this approach would be the connectors of our\ncomponent model. In our routing example, for instance, we compose connector to coor-\ndinate the load balance of servers (see Chapter 7). In [RSM10], we present coordinators\nin a systematic strategy to interoperate components. However, other entities could also\nbe defined as coordinators.\n\nAnother interesting related approach can be mentioned. We could incorporate and build\non techniques for the synthesis of coordinators to adapt or integrate components; this\nwill automatically generate the necessary glue code to reuse a component or integrate\nheterogeneous components. For instance, the works [AINT07, BCP06] provide formal\nmethodologies and tools to synthesise suitable coordinators for solving behavioural mis-\nmatches between heterogeneous.\n\nIncorporate other development tasks In this thesis we focus on correct compositions, but\nother tasks in development also deserve such an attention. So, in order to add more\nvalue to a development approach of trustworthy components, other development tasks\nhave to be incorporated. In [RSM06], for instance, we propose transformations laws\nfor components in UML-RT; these can be observed as refactorings for component-based\nsystems, and could be incorporated to our systematic approach. Due to the different\nsemantics used in both works, some effort is necessary.\n\n\n\nAPPENDIX A\n\nRelation between protocol compatibility and\nconflict freedom\n\nThe notion of protocol compatibility presented in Definition 4.12 is related to the seminal study\nof Roscoe on deadlock-free process [Ros98]. In fact, as we show is this chapter, compatible\nprotocols are also free of strong conflicts; being conflict freedom a cornerstone property in the\nstudy of deadlock. Two processes are in strong conflict if neither process can communicate\nwith other, or with the environment. Observe that this study consider some assumptions, and\nall of them are satisfied by our work. One important assumption is that all processes are triple-\ndisjoint, meaning that no event requires the synchronisation of more than two processes.\n\nThere are also other observations that must be taken into account. For instance, protocols\nare equivalent to projections of more complexes I/O process, and focus on specific channels of\nsuch process. Therefore, synchronisations between protocols are always considered to be total;\nthey synchronise on all events of their alphabet.\n\nThe assumptions made in [Ros98] are all present in this thesis:\n\na No I/O process can terminate. which does not preclude them from being constructed out\nof sub-process that can;\n\nb Synchronisation set are defined with the alphabet of the processes that are part of the\nsynchronisation;\n\nc networks of I/O processes (or components) are triple-disjoint, meaning that there is no\nevent that requires the synchronization of more than two processes. This is imposed by\nour composition rules, and by the way interactions are defined in our component model.\nAnalysis of protocol compatibilities are made in the context of synchronisations between\ntwo processes.\n\nd Compositions does not contains hidings.\n\ne Compositions rules and the analysis of protocols compatibility assume the network is\nbusy, defined to mean that each component process is deadlock-free.\n\nBefore we present the central theorem that relates the notions of protocol compatibility and\nstrong conflicts, we present the formalisation related to conflicts, presented in [Ros98].\n\nIn order to identify conflicts in a synchronisation of two processes P and Q, Roscoe analyses\nall possible states of such synchronisation. We translate the notion of state from [Ros98] as\nbelow. In order to reinforce that outputs of a protocol are considered as inputs of the other, we\nrequire that synchronised protocols are conjugate.\n\n125\n\n\n\nAPPENDIX A RELATION BETWEEN PROTOCOL COMPATIBILITY AND CONFLICT FREEDOM 126\n\nDefinition A.1 (Deadlock state). Let P and Q be conjugate protocols. A state of Q ? P is a pair\n(s,?XP,XQ?) where\n\n\u2022 (s,XP)? failures(P)? (s,XQ)? failures(Q)\n\n\u2022 XP ? ?8(IsP ? O\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\n\nThe definition of states above is slightly different from the one for regular processes, pre-\nsented in [Ros98]. The difference is that we translate the provisos in [Ros98] to our domain.\nHere, we synchronise protocols on their whole alphabets, and, furthermore, the trace s must\nexist in both processes Q and P. The initials of a protocol P after performing a trace s is repre-\nsented by all inputs ( IsP) and outputs ( O\n\ns\nP) it might perform.\n\nA strong conflict is defined as follows.\n\nDefinition A.2 (Strong conflict). Let P and Q be conjugate protocols. Then a strong conflict of\nQ ? P is a state (s,?XP,XQ?) which satisfies:\n\n\u2022 ?8XP ? XQ ? ?8XQ ? XP\n\nSince Q?P is a total synchronisation, the vocabulary is equals to the union of their alphabets\n(inputs(P)?outputs(Q)); this vocabulary is also used as the synchronisation set. Based on this,\nand on the fact that protocols are deadlock-free, the definition above is much simpler than\nin [Ros98]. For the sake of brevity, we define strong conflicts directly, without relating it to\nungranted requests or regular conflicts; these are conditions that underline the notion of strong\nconflicts in [Ros98].\n\nBased on the definitions above, we state the following theorem, which shows the equiva-\nlence of protocol compatibility and the absence of strong conflicts.\n\nLemma A.1. Let P and Q be two conjugate protocols. Then P ? Q is a pair of processes frees\nof strong conflicts if, and only if, P and Q are compatible.\n\nProof. Based on the Definition A.2, the absence of strong conflicts can defined as:\n\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\n\n\u2022 ?8XP * XQ ? ?8XQ * XP\n\nSo, we have to prove that if two protocols are compatible than the statement above is satisfied,\nand vice-versa. The first part of our proof focus on that protocol compatibility implies in the\nabsence of strong conflicts. We start by the central statement of Definition 4.12, saying that\nthe following is satisfied for all s ? traces(P)? traces(Q). For the sake of brevity, consider, for a\ngiven process S, INS = inputs(S) and OU TS = outputs(S).\n\n?s ? traces(P)?traces(Q)\u2022\n(OsP 6= /0 ? O\n\ns\nP ? I\n\ns\nQ)? (O\n\ns\nQ 6= /0 ? O\n\ns\nQ ? I\n\ns\nP)\n\n?[Definition 4.4]\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\n\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(OsP 6= /0 ? O\ns\nP ? I\n\ns\nQ ? I\n\ns\nQ ? ?8XQ ? O\n\ns\nP * XP)?\n\n(OsQ 6= /0 ? O\ns\nQ ? I\n\ns\nP ? I\n\ns\nP ? ?8XP ? O\n\ns\nQ * XQ)\n\n\n\nAPPENDIX A RELATION BETWEEN PROTOCOL COMPATIBILITY AND CONFLICT FREEDOM 127\n\n?[as a direct implication of the statement above]\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\n\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(OsP 6= /0 ? O\ns\nP ? I\n\ns\nQ ? I\n\ns\nQ ? ?8XQ ? O\n\ns\nP * XP ? ?8XQ * XP)?\n\n(OsQ 6= /0 ? O\ns\nQ ? I\n\ns\nP ? I\n\ns\nP ? ?8XP ? O\n\ns\nQ * XQ ? ?8XP * XQ)\n\n?[simplifying]\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\n\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(?8XQ * XP)? (?8XP * XQ)\n\nThe other part of this proof is concerned with proving that the absence of strong conflicts\nimplies that P and Q are compatible.\n\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(?8XQ * XP)? (?8XP * XQ)\n?[rewriting]\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\n\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(OsP 6= /0 ? ?8XQ * XP)? ((O\ns\nP = /0 ? ?8XQ * XP)?\n\n(OsQ 6= /0 ? ?8XP * XQ)? (O\ns\nQ = /0 ? ?8XP * XQ)\n\n?[Based on the Definition 4.4 we imply: ?a : OsP \u2022 I\ns\nP ?{a}? ?8XP.\n\nBy induction, we have that ?8XP * XQ ? OsP 6= /0 ? O\ns\nP * XQ; the same is valid for O\n\ns\nQ]\n\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(OsQ 6= /0 ? ?8XQ * XP ? O\ns\nQ * XP ? O\n\ns\nQ * XQ)?\n\n(OsP 6= /0 ? ?8XP * XQ ? O\ns\nP * XQ ? O\n\ns\nP * XP)?\n\n((OsQ = /0 ? ?8XQ * XP ? I\ns\nQ = ?8XQ)?\n\n(OsP = /0 ? ?8XP * XQ ? I\ns\nP = ?8XP)\n\n?[P and Q are conjugate, OU TP ? INQ ? OU TQ ? INP]\nBy induction, we have that ?8XP * XQ ? OsP 6= /0 ? O\n\ns\nP * XQ; the same is valid for O\n\ns\nQ]\n\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(OsQ 6= /0 ? ?8XQ * XP ? O\ns\nQ * XP ? O\n\ns\nQ * XQ ? O\n\ns\nQ ? I\n\ns\nP)?\n\n(OsP 6= /0 ? ?8XP * XQ ? O\ns\nP * XQ ? O\n\ns\nP * XP ? O\n\ns\nP ? I\n\ns\nQ)?\n\n((OsQ = /0 ? ?8XQ * XP ? I\ns\nQ = ?8XQ ? O\n\ns\nP 6= /0 ? O\n\ns\nP * XP)?\n\n(OsP = /0 ? ?8XP * XQ ? I\ns\nP = ?8XP ? O\n\ns\nQ 6= /0 ? O\n\ns\nQ * XQ)\n\n\n\nAPPENDIX A RELATION BETWEEN PROTOCOL COMPATIBILITY AND CONFLICT FREEDOM 128\n\n?[Based on the Definition 4.4, XP is a maximal refusal, we imply: ?b : OsP \u2022 XP = ?8(I\ns\nP ?{a});\n\nBy induction, considering that INP ? INQ = /0, IsQ * XP ? O\ns\nP ? I\n\ns\nQ; the same is valid for O\n\ns\nQ.]\n\n?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O\ns\nP)? XQ ? ?8(I\n\ns\nQ ? O\n\ns\nQ)\u2022\n\n(OsQ 6= /0 ? ?8XQ * XP ? O\ns\nQ * XP ? O\n\ns\nQ * XQ ? INP8I\n\ns\nP ? XP ? O\n\ns\nQ ? I\n\ns\nP)?\n\n(OsP 6= /0 ? ?8XP * XQ ? O\ns\nP * XQ ? O\n\ns\nP * XP ? INQ8I\n\ns\nQ ? XQ ? O\n\ns\nP ? I\n\ns\nQ)?\n\n((OsQ = /0 ? ?8XQ * XP ? I\ns\nQ = ?8XQ ? O\n\ns\nP 6= /0 ? O\n\ns\nP ? I\n\ns\nQ)?\n\n(OsP = /0 ? ?8XP * XQ ? I\ns\nP = ?8XP ? O\n\ns\nQ 6= /0 ? O\n\ns\nQ ? I\n\ns\nP)\n\n?[simplifying, considering that IsP, I\ns\nQ, O\n\ns\nP and O\n\ns\nQ depends solely of the traces of P and Q]\n\n?s ? traces(P)?traces(Q)\u2022\n(OsP 6= /0 ? O\n\ns\nP ? I\n\ns\nQ)? (O\n\ns\nQ 6= /0 ? O\n\ns\nQ ? I\n\ns\nP)\n\nBesides there is an equivalence between a pair of protocols being compatible and absent of\nstrong conflicts, the notion of protocol compatibility has the benefit of being defined solely in\nterms of the traces of the protocols, what easy further reasoning.\n\n\n\nAPPENDIX B\n\nProofs of composition rules with metadata\n\nThis appendix provides details about the proofs of the theorems stated in Section 6.3.2.\n\nTheorem 6.9 (Enriched Interleaving Composition Compatibility). An enriched interleaving\ncomposition is an enriched component contract.\n\nProof. Based on the definitions 5.16 and 6.10, in order to an enriched interleave composition\nP[|||]Q being an enriched component contract, we have to prove that:\n\n1. S = ?BP,RP,IP,CP??? ? ???BQ,RQ,IQ,CQ? is a protocol oriented component.\n\n2. dom ProtKPQ ?CS ??c : dom Prot\nK\nPQ \u2022 Prot\n\nK(c)vF ProtIMP(S,c)\n\n3. dom DecK ?CS ? ran DecK ?CS ?\n(?c1,c2 : CS \u2022 c1 DecK c2 ?{c1,c2}DecoupledIn S ? c2 DecKPQ c1)\n\nConsidering the items above, we split the proof in three parts; one corresponding to each\nitem. We do not show the proofs about preservation of context process and dual protocols.\nThese are similar to the proof for item 2.\nPart 1) Prove that the composition is a protocol oriented component (see Definition 5.15) is\nthe same as proving that for any process R, channel c, and set of events Z, such that c ? CS,\nZ ? ?BS ?? R, BS ?\n\n{|Z|}\nR is deadlock-free, the following holds:\n\nBS |? {|c|}vF (BS ?\n{|Z|}\n\nR) |? {|c|}\n\n?[Definition 6.2, CS = CP ?CQ, BS = BP |||BQ]\n(c ?CP ? ((BP |||BQ) |? {|c|}vF ((BP |||BQ) ?\n\n{|Z|}\nR) |? {|c|})?\n\n(c ?CQ ? ((BP |||BQ) |? {|c|}vF ((BP |||BQ) ?\n{|Z|}\n\nR) |? {|c|})\n\n?[rewriting, ?BP ??BQ = /0]\n(c ?CP ? (BP |? {|c|}vF BP ?\n\n{|Z|}\n(BQ ?\n\n{|Z|}\nR) |? {|c|})?\n\n(c ?CQ ? (BQ |? {|c|}vF BQ ?\n{|Z|}\n\n(BP ?\n{|Z|}\n\nR) |? {|c|})\n\n?[P and Q are protocol oriented components]\ntrue\n\n129\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 130\n\nPart 2) In this part, in order to prove that the composition is an enriched component contract,\nwe prove the following assertion:\n\ndom ProtKPQ ?CS ??c : dom Prot\nK\nPQ \u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n?[Definition 6.10, ProtKPQ = Prot\nK\nP ?Prot\n\nK\nQ ]\n\n(dom ProtKP ?dom Prot\nK\nQ )?CS ?\n\n?c : (dom ProtKP ?dom Prot\nK\nQ )\u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n?[Definition 6.2, CS = CP ?CQ, BS = BP |||BQ]\n(dom ProtKP ?dom Prot\n\nK\nQ )? (CP ?CQ)?\n\n?c : (dom ProtKP ?dom Prot\nK\nQ )\u2022 Prot\n\nK\nPQ(c)vF (BP |||BQ) |? {|c|}\n\n?[Definition 5.16, dom ProtKP ?CP ? dom Prot\nK\nQ ?CQ]\n\n?c : (dom ProtKP ?dom Prot\nK\nQ )\u2022 Prot\n\nK\nPQ(c)vF (BP |||BQ) |? {|c|}\n\n?[ ?BP ?{|CQ|}= /0 ? ?BQ ?{|CP|}= /0]\n(?c : dom ProtKP \u2022 Prot\n\nK\nPQ(c)vF BP |? {|c|})?\n\n(?c : dom ProtKQ \u2022 Prot\nK\nPQ(c)vF BQ |? {|c|})\n\n?[Definitions 6.10 and 4.8]\n(?c : dom ProtKP \u2022 Prot\n\nK\nP (c)vF ProtIMP(P,c))?\n\n(?c : dom ProtKQ \u2022 Prot\nK\nQ (c)vF ProtIMP(Q,c))\n\n?[Definition 5.16, P and Q are enriched component contracts]\ntrue\n\nPart 3) Finally, in this part, we prove the sentence in item 3. This is proved by contradiction,\nassuming that the statement is false.\n\ndom DecKPQ ?CS ? ran Dec\nK\nPQ ?CS ?\n\n(?c1,c2 : CS \u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S ?\u00acc2 Dec\nK\nPQ c1)\n\n?[Definition 6.2, CS = CP ?CQ]\ndom DecKPQ ?CP ?CQ ? ran Dec\n\nK\nPQ ?CP ?CQ ?\n\n(?c1,c2 : CP ?CQ \u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S ?\u00acc2 Dec\nK\nPQ c1)\n\n?[Definition 6.10, DecKPQ is symmetric]\nDecKPQ = Dec\n\nK\nP ?Dec\n\nK\nQ ?{(c1,c2)|(c1 ?CQ ? c2 ?CP)? (c1 ?CP ? c2 ?CQ)}?\n\n(?c1,c2 : CP ?CQ \u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S)\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 131\n\n?[rewriting the statement, splitting in the four possible subsets of DecKPQ]\n(?c1,c2 : CP |c1 DecKP c2 \u2022\u00ac{c1,c2}DecoupledIn S)?\n(?c1,c2 : CQ |c1 DecKQ c2 \u2022\u00ac{c1,c2}DecoupledIn S)?\n(?c1 : CP,c2 : CQ \u2022\u00ac{c1,c2}DecoupledIn S)?\n(?c1 : CQ,c2 : CP \u2022\u00ac{c1,c2}DecoupledIn S)\n?[Definition 4.21]\n(?c1,c2 : CP |c1 DecKP c2 \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c1) /?F S |? {c1,c2})?\n(?c1,c2 : CQ |c1 DecKQ c2 \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c1) /?F S |? {c1,c2})?\n(?c1 : CP,c2 : CQ \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F S |? {c1,c2})?\n(?c1 : CQ,c2 : CP \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F S |? {c1,c2})\n?[Definitions 4.7 and 6.2, BS = BP |||BQ ]\n\n(?c1,c2 : CP |c1 DecKP c2 \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F P |? {c1,c2})?\n(?c1,c2 : CQ |c1 DecKQ c2 \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F Q |? {c1,c2})?\n(?c1 : CP,c2 : CQ \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F P |? {c1} ||| Q |? {c2})?\n(?c1 : CQ,c2 : CP \u2022 ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F Q |? {c1} ||| P |? {c2})\n?[Definitions 4.8 and 6.2]\n(?c1,c2 : CP |c1 DecKP c2 \u2022 ProtIMP(P,c1) ||| ProtIMP(P,c2) /?F P |? {c1,c2})?\n(?c1,c2 : CQ |c1 DecKQ c2 \u2022 ProtIMP(Q,c1) ||| ProtIMP(Q,c2) /?F Q |? {c1,c2})\n?[Contradiction with Definition 4.21]\n\nfalse\n\nThe following lemma is stated to help the proof of Theorem 6.10.\n\nLemma B.1. Let S = P[ic ? oc]Q be a communication composition of two protocol oriented\ncomponents P and Q, and c1 and c2 two channels, such that {c1,ic} DecoupledIn P, c1 ?CP, and\nc2 ?CQ. Then {c1,c2}DecoupledIn S.\n\nProof.\n\nS |? {c1,c2}\n?F [Definition 6.3]\n\nBQ ?\n{|oc|}\n\n(BP ?\n{|ic|}\n\nBU F F ?IO(ic,oc)) |? {|c1,c2|}\n\n?F [rewriting]\nBQ ?\n{|oc|}\n\n(BP ?\n{|ic|}\n\nBU F F ?IO(ic,oc))\\{|CP8{ic,c1}|} |? {|c1,c2|}\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 132\n\n?F [applying the hiding operator]\nBQ ?\n{|oc|}\n\n(P |? {ic,c1} ?\n{|ic|}\n\nBU F F ?IO(ic,oc)) |? {|c1,c2|}\n\n?F [{c1,ic}DecoupledIn P]\nBQ ?\n{|oc|}\n\n((PIMP(P,c1) ||| PIMP(P,ic)) ?\n{|ic|}\n\nBU F F ?IO(ic,oc)) |? {|c1,c2|}\n\n?F [rewriting]\nPIMP(P,c1) ||| (BQ ?\n\n{|oc|}\n(PIMP(P,ic) ?\n\n{|ic|}\nBU F F ?IO(ic,oc))) |? {|c1,c2|}\n\n?F [Definition 4.8, and considering the above]\nPIMP(S,c1) ||| PIMP(S,c2)\n\nAdditionally, considering the proof above and that Q is a protocol oriented component, we\nconclude that:\n\nPIMP(S,c1)?F PIMP(P,c1)? PIMP(P,c2)vF PIMP(S,c2)\n\nLemma B.2. Let Ctr be a component contract, c1 a channel, and Z a set of channels, such that\n?z : Z \u2022{c1,z}DecoupledInCtr. Then:\n\nCtr |? {c1}?Z ?F Ctr |? {c1} |||Ctr |? Z\n\nProof. The idea of decoupled channels is close to the idea of non-interference of flows [RS01].\nWe translate it to our model as below, considering that P is a component contract, and A and B,\nsuch that A?B = /0, then:?\n\n??\nP |? A ?F (P ?\n\n{|B|}\nSKIP) |? A ?\n\nP |? B ?F (P ?\n{|A|}\n\nSKIP) |? B\n\n?\n??? P |? A?B ?F P |? A ||| P |? B\n\nComposing SKIP in parallel with P over the alphabet H has the effect of preventing all traces\nwith events within the synchronizing set (A or B). The notion above presents two ways to\nrepresent that the view of the behaviour of P over A is independent of events within B, and\nvice-versa. Based on the notion presented above, we prove the lemma.\n\nThe events within c1 are independent of events within Z, and vice-versa, ?z : Z \u2022 {c1,z}\nDecoupledInCtr. So:\n\nCtr |? {c1}?F (Ctr ?\n{|Z|}\n\nSKIP) |? {c1}?Ctr |? Z ?F (Ctr ?\n{|c1|}\n\nSKIP) |? Z\n\nas a consequence\nCtr |? {c1}?Z ?F Ctr |? {c1} |||Ctr |? Z\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 133\n\nLemma B.3. Let S = P[ic ? oc]Q be a communication composition of two protocol oriented\ncomponents P and Q, and c1 and c2 two channels, such that {c1,c2,ic}?CP, {c1,ic}DecoupledIn P,\n{c1,c2}DecoupledIn P. Then {c1,c2}DecoupledIn S.\n\nProof.\n\nS |? {c1,c2}\n?F [Definition 4.7]\n\nS |? {|c1,c2|}\n?F [rewriting]\n\nS |? {|c1,c2,ic|} |? {|c1,c2|}\n?F [ Lemma B.2 ]\n\n(S |? {c1} ||| S |? {c2,ic}) |? {|c1,c2|}\n?F [Definition 4.8, and considering the above]\n\n(ProtIMP(S,c1) ||| ProtIMP(S,c2)) |? {|c1,c2|}\n\nAdditionally, considering the proof above and that Q is a protocol oriented component, we\nconclude that:\n\nPIMP(S,c1)?F PIMP(P,c1)? PIMP(P,c2)vF PIMP(S,c2)\n\nTheorem 6.10 (Enriched Communication Composition Compatibility). An enriched commu-\nnication composition is an enriched component contract.\n\nProof. Despite a communication composition being more complex than an interleave one, this\nproof follows steps similar to the proof of Theorem 6.9.\n\nBased on the definitions 5.16 and 6.11, in order to an enriched interleave composition P[ic?\noc]Q being an enriched component contract, we have to prove that:\n\n1. S = ?BP,RP,IP,CP??ic? ? ?oc??BQ,RQ,IQ,CQ? is a protocol oriented component.\n\n2. dom ProtKPQ ?CS ??c : dom Prot\nK\nPQ \u2022 Prot\n\nK(c)vF ProtIMP(S,c)\n\n3. dom DecK ?CS ? ran DecK ?CS ?\n(?c1,c2 : CS \u2022 c1 DecK c2 ?{c1,c2}DecoupledIn S ? c2 DecKPQ c1)\n\nConsidering the items above, we split the proof in three parts; one corresponding to each\nitem. We do not show the proofs about preservation of context process and dual protocols.\nThese follow a proof similar to the one associated to item 2.\nPart 1) Prove that the composition is a protocol oriented component (see Definition 5.15) is the\nsame as proving the following is true for any process R, channel c, and set of events Z, such that\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 134\n\nc ?CS, Z ? ?BS ?? R, BS ?\n{|Z|}\n\nR is deadlock-free.\n\nBS |? {|c|}vF (BS ?\n{|Z|}\n\nR) |? {|c|}\n\n?[Definition 6.3, CS = (CP ?CQ)8{ic,oc}, BS = BP ?\n{|ic|}\n\n(BQ ?\n{|oc|}\n\nBU F F ?IO(ic,oc))]\n\n(c ?CP8ic ? (BS |? {|c|}vF (BP ?\n{|ic|}\n\n(BQ ?\n{|oc|}\n\nBU F F ?IO(ic,oc)) ?\n{|Z|}\n\nR |? {|c|})?\n\n(c ?CQ8oc ? (BS |? {|c|}vF (BP ?\n{|ic|}\n\n(BQ ?\n{|oc|}\n\nBU F F ?IO(ic,oc)) ?\n{|Z|}\n\nR |? {|c|})\n\n?[rewriting, Definition 5.15, ?BP ??BQ = /0]\n(c ?CP8ic ? (BP |? {|c|}vF BP ?\n\n{|Z?{ic}|}\n((BQ ?\n\n{|oc|}\nBU F F ?IO(ic,oc)) ?\n\n{|Z|}\nR) |? {|c|})?\n\n(c ?CQ8oc ? (BQ |? {|c|}vF BQ ?\n{|Z?{oc}|}\n\n((BP ?\n{|ic|}\n\nBU F F ?IO(ic,oc)) ?\n{|Z|}\n\nR) |? {|c|})\n\n?[Definition 5.15, P and Q are protocol oriented components]\ntrue\n\nPart 2) In this part, in order to prove that the composition is an enriched component contract,\nwe prove the following assertion:\n\ndom ProtKPQ ?CS ??c : dom Prot\nK\nPQ \u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n?[Definition 6.11]\n(dom ProtKP 8{ic}?dom Prot\n\nK\nQ 8{oc})?CS ?\n\n?c : (dom ProtKP ?dom Prot\nK\nQ )8{ic,oc}\u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n?[Definitions 5.16 and 6.3, CS = (CP ?CQ)8{ic,oc}]\n?c : (dom ProtKP ?dom Prot\n\nK\nQ )8{ic,oc}\u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n?[rewriting using Definition 6.3 ]\n(?c : dom ProtKP \u2022 c 6= ic ? Prot\n\nK\nPQ(c)vF BP ?\n\n{|ic|}\n(BQ ?\n\n{|oc|}\nBU F F ?IO(ic,oc)) |? {|c|})?\n\n(?c : dom ProtKQ \u2022 c 6= oc ? Prot\nK\nPQ(c)vF BQ ?\n\n{|oc|}\n(BP ?\n\n{|ic|}\nBU F F ?IO(ic,oc)) |? {|c|})\n\n?[ P and Q are protocol oriented components with disjoint alphabets]\n(?c : dom ProtKP \u2022 c 6= ic ? Prot\n\nK\nPQ(c)vF BP |? {|c|})?\n\n(?c : dom ProtKQ \u2022 c 6= oc ? Prot\nK\nPQ(c)vF BQ |? {|c|})\n\n?[ Definitions 4.8 and 6.11]\n(?c : dom ProtKP \u2022 c 6= ic ? Prot\n\nK\nP (c)vF ProtIMP(P,c))?\n\n(?c : dom ProtKQ \u2022 c 6= oc ? Prot\nK\nQ (c)vF ProtIMP(Q,c))\n\n?[Definition 5.16, P and Q are enriched component contracts]\ntrue\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 135\n\nPart 3) Finally, in this part, we prove the sentence in item 3. This is proved by contradiction,\nassuming that the statement is false.\n\ndom DecKPQ ?CS ? ran Dec\nK\nPQ ?CS ?\n\n(?c1,c2 : CS \u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S ?\u00acc2 Dec\nK\nPQ c1)\n\n?[Definition 6.3, CS = (CP ?CQ)8{ic,oc}]\ndom DecKPQ ? (CP ?CQ)8{ic,oc}? ran Dec\n\nK\nPQ ? (CP ?CQ)8{ic,oc}?\n\n(?c1,c2 : (CP ?CQ)8{ic,oc}\u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S ?\u00acc2 Dec\nK\nPQ c1)\n\n?[Definition 6.11, DecPQ is symmetric]\nDecKPQ ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? (\n\n((c1 Dec\nK\nP ic ? ic Dec\n\nK\nP c1)? (c2 ?CQ ? c1Dec\n\nK\nP c2))?\n\n((oc DecKQ c2 ? c2 Dec\nK\nQ oc)? (c1 ?CP ? c1Dec\n\nK\nQ c2)))}?\n\n(?c1,c2 : (CP ?CQ)8{ic,oc}\u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S)\n?[rewriting the statement, splitting in the four possible subsets of the symmetric relation DecKPQ ]\n(?c1,c2 : CP8{ic}|c1 DecKP c2 ? c1 Dec\n\nK\nP ic \u2022\u00ac{c1,c2}DecoupledIn S)?\n\n(?c1,c2 : CQ8{oc}|c1 DecKQ c2 ? c2 Dec\nK\nQ oc \u2022\u00ac{c1,c2}DecoupledIn S)?\n\n(?c1 : CP8{ic},c2 : CQ8{oc}|c1 DecKP ic \u2022\u00ac{c1,c2}DecoupledIn S)?\n(?c1 : CP8{ic},c2 : CQ8{oc}|c2 DecKQ oc \u2022\u00ac{c1,c2}DecoupledIn S)\n?[Lemma B.1]\n(?c1,c2 : CP8{ic}|c1 DecKP c2 ? c1 Dec\n\nK\nP ic \u2022\u00ac{c1,c2}DecoupledIn S)?\n\n(?c1,c2 : CQ8{oc}|c1 DecKQ c2 ? c2 Dec\nK\nQ oc \u2022\u00ac{c1,c2}DecoupledIn S)\n\n?[Contradiction with Lemma B.3]\nfalse\n\nThe following lemma is stated to help in the proof of Theorem 6.11.\n\nLemma B.4. Let S = P ?\n???ic?\n?oc? be a feedback composition, P a protocol oriented component,\n\nand c1 and c2 two channels, such that {c1,c2}DecoupledIn P, {c1,ic}DecoupledIn P, and {c1,oc}\nDecoupledIn P. Then {c1,c2}DecoupledIn S.\nProof. Assume P |? {ic,c1}?F (Pic? ||| Pc1?), ProtIMP(P,ic)vF Pic?, and ProtIMP(P,c1)vF Pc1?.\n\nS |? {c1,c2}\n?F [Definition 6.3]\n\n(BP ?\n{|ic,oc|}\n\nBU F F ?IO(ic,oc)) |? {|c1,c2|}\n\n?F [rewriting]\n(BP ?\n\n{|ic,oc|}\nBU F F ?IO(ic,oc)) |? {|c1,c2,ic,oc|} |? {|c1,c2|}\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 136\n\n?F [Lemma B.2]\n((P |? {c1} ||| P |? {c2,ic,oc}) ?\n\n{|ic,oc|}\nBU F F ?IO(ic,oc)) |? {|c1,c2|}\n\n?F [Definition 4.8, and considering the above]\nProtIMP(P,c1) ||| ProtIMP(P,c2)\n\nAdditionally, considering the proof above and that Q is a protocol oriented component, we\nconclude that:\n\nPIMP(S,c1)?F PIMP(P,c1)? PIMP(P,c2)vF PIMP(S,c2)\n\nTheorem 6.11 (Enriched Feedback Composition Compatibility). An enriched feedback com-\nposition is an enriched component contract.\n\nProof. Based on the definitions 5.16 and 6.12, in order to an enriched interleave composition\nP[|||]Q be an enriched component contract, we have to prove that:\n\n1. S = ?BP,RP,IP,CP??\n???ic?\n?oc? is a protocol oriented component.\n\n2. dom ProtKPQ ?CS ??c : dom Prot\nK\nPQ \u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n3. dom DecK ?CS ? ran DecK ?CS ?\n(?c1,c2 : CS \u2022 c1 DecK c2 ?{c1,c2}DecoupledIn S ? c2 DecKPQ c1)\n\nConsidering the items above, we split the proof in three parts; one corresponding to each\nitem. We do not show the proofs about preservation of context process and dual protocols.\nThese follow a proof similar to the one associated to item 2.\nPart 1) prove that S is a protocol oriented component is a direct consequence of the fact that P is\nalso a protocol oriented component. So, to prove that we have to prove the following statement\nfor any process R, channel c, and set of events Z, such that c ? CS, Z ? ?BS ?? R, BS ?\n\n{|Z|}\nR is\n\ndeadlock-free (see Definition 5.15).\n\nBS |? {|c|}vF (BS ?\n{|Z|}\n\nR) |? {|c|}\n\n?[Definition 6.4, CS = CP8{ic,oc}, BS = BP ?\n{|ic,oc|}\n\nBU F F ?IO(ic,oc)]\n\n(c ?CP8ic,oc ? ((BP ?\n{|ic,oc|}\n\nBU F F ?IO(ic,oc)) |? {|c|}vF BP ?\n{|Z?{ic,oc}|}\n\n(BU F F ?IO(ic,oc)) ||| R) |? {|c|})\n\n?[Definition 5.15, P are protocol oriented components]\nBP |? {|c|}vF BP ?\n\n{|Z?{ic,oc}|}\n(BU F F ?IO(ic,oc)) ||| R) |? {|c|})\n\n?[Definition 5.15, P are protocol oriented components]\ntrue\n\n\n\nAPPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 137\n\nPart 2) In this part, in order to prove that the composition is an enriched component contract,\nwe prove the following assertion:\n\ndom ProtKPQ ?CS ??c : dom Prot\nK\nPQ \u2022 Prot\n\nK\nPQ(c)vF ProtIMP(S,c)\n\n?[Definitions 6.12 and 6.4]\n(dom ProtKP 8{ic,oc})?CP8{ic,oc}?\n?c : dom ProtKP 8{ic,oc}\u2022 Prot\n\nK\nP (c)vF ProtIMP(S,c)\n\n?[Definitions 5.16]\n?c : dom ProtKP 8{ic,oc}\u2022 Prot\n\nK\nP (c)vF ProtIMP(S,c)\n\n?[Definition 6.4]\n?c : dom ProtKP 8{ic,oc}\u2022 Prot\n\nK\nP (c)vF BP ?\n\n{|ic,oc|}\nBU F F ?IO(ic,oc) |? {|c|})\n\n?[ P is a protocol oriented component]\n?c : dom ProtKP 8{ic,oc}\u2022 Prot\n\nK\nP (c)vF BP |? {|c|})\n\n?[Definition 5.16, P is an enriched component contracts]\ntrue\n\nPart 3) Finally, in this part, we prove the sentence in item 3. This is proved by contradiction,\nassuming that the statement is false.\n\ndom DecKPQ ?CS ? ran Dec\nK\nPQ ?CS ?\n\n(?c1,c2 : CS \u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S ?\u00acc2 Dec\nK\nPQ c1)\n\n?[Definition 6.3, CS = CP8{ic,oc}]\ndom DecKPQ ?CP8{ic,oc}? ran Dec\n\nK\nPQ ?CP8{ic,oc}?\n\n(?c1,c2 : (CP ?CQ)8{ic,oc}\u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S ?\u00acc2 Dec\nK\nPQ c1)\n\n?[Definition 6.11, DecKPQ is symmetric]\nDecKS ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? c1Dec\n\nK\nP c2 ?\n\n((c1 Dec\nK\nP ic ? c1 Dec\n\nK\nP oc)? (ic Dec\n\nK\nP c2 ? oc Dec\n\nK\nP c2))}\n\n(?c1,c2 : (CP ?CQ)8{ic,oc}\u2022 c1 DecKPQ c2 ?\u00ac{c1,c2}DecoupledIn S)\n?[rewriting the statement, considering that DecKPQ is a symmetric relation]\n\n(?c1,c2 : CP8{ic} |c1 DecKP c2 ? c1 Dec\nK\nP ic ? c1 Dec\n\nK\nP oc\n\n\u2022\u00ac{c1,c2}DecoupledIn S)\n?Contradiction with [Lemma B.4]\n\nfalse\n\n\n\nAPPENDIX C\n\nCases study in FDR\n\nThis Appendix complements Chapter 7, explaining how components of the study cases might\nbe verified in the model checker FDR (for Failure-Divergence-Refinement). The appendix is\nnot intended to detail the study cases or the strategy presented in this work, but to focus on the\naspects that ease their verification. In fact, we present simplifications of the study cases here.\nThe dining example presented here, has a reduced set of forks and philosophers. The routing\nexample presented here consider only instances of the abstract connectors in Chapter 7. This,\nhowever, does not invalidate our intention of showing that verifications can be performed in\nFDR, it only focuses on the essential steps of these case studies.\n\nElements of the component contracts in these cases are represented by datatypes, chan-\nnels and processes, as defined in Chapter 5. As the elements are sometimes distributed in the\nspecification, we mainly represent a component by its behaviour, which is mapped into a CSP\nprocess. All processes presented here are in the machine-readable CSP (CSPM ) notation with\nthe aim of being verified in FDR. In addition, some assertions are presented in appendix to\nillustrate verifications steps in the strategy presented in this work.\n\nThe next section are organised as follows. The first part concerns the notation used for\nthe CSP operators in CSPM , presenting only as far as it was used throughout this appendix;\nexplanations on related notions in FDR are also presented. Then, we present auxiliary processes\nused in the specification of all study cases. These auxiliary processes represent behaviours\nrelated to our component model and strategy. The next sections present the specification and\nassertions of the case: the dining philosophers and the routing coordinator examples.\n\nC.1 FDR-CSP\n\nThe description given in Table C.1 follows that in [For10]. This is not a complete list of\noperations; we have left out those not needed for understanding the CSP specifications of this\nwork.\n\n{|a|} stands for the set of all events which begin with a. For example, if we define a chan-\nnel foo to be of type {1..3}.Bool, then {| foo.3 |} denotes the set {foo.3.true,\nfoo.3.false}. The assert statement in FDR specifications is used to state properties which\nshould be checked on the specification. These may concern deadlock or divergence freedom\ntests as well as refinement tests. For instance assert P: [deadlock free] asserts that\nprocess P is deadlock free. Such assertions are used to initialise the list of checks for FDR.\n\n138\n\n\n\nC.2 AUXILIARY PROCESSES 139\n\nSTOP deadlock\nSKIP termination\nCHAOS(A) the chaotic process (on events in A)\nev -> P prefix: first event ev then P\nP; Q sequential composition: first P then Q\nP \\ A hiding: in P, hide all events in A\nP [[ev&lt;- ev\u2019]] renaming: in P, rename ev into ev\u2019\nP [] Q external choice between P and Q\nP |~| Q internal choice between P and Q\nb &amp; P boolean guard: execute P if b evaluates to true\nP ||| Q interleaving P with Q\nP [| A |[ Q parallel composition of P and Q with synchronisation on A\n[] x:A @ P(x) replicated external choice: choose over all P(x) such that x?A\n|~| x:A @ P(x) replicated internal choice\n\nTable C.1 Syntax of the CSPM language\n\nC.2 Auxiliary processes\n\nBefore present the study case in CSPM , we present some auxiliary parametrised processes that\nare used in verifications related to the strategy of construction. To tune verifications in FDR,\nwe use, when possible, local definitions to separate out those arguments which are passed in\nfor configuration purposes (sizes, channels and so on) from those which represent process state\nand may need to be modified on recursive calls.\n\nBUFFER(ci, co, n) =\nlet\n\nB(<>) = ci?x -> B(<x>)\nB(s) = (co!head(s) -> B(tail(s)))\n\n[] (#s<n &amp; ci?x -> B(s^<x>))\nwithin B(<>)\n\nBFIO(c1,c2) = BUFFER(c1.out,c2.in, 10)\n||| BUFFER(c2.out,c1.in, 10)\n\nThe process BUFFER(ci, co, n) is a buffer of size n that inputs events performed via a\nchannel ci to a channel co. And the process BFIO(c1,c2) is a I/O buffer for two channels\nc1 and c2. In order to tune the verification of these study cases, we use buffers of size 10,\nwhich does not change the behaviour of studies.\n\nBased on the specification of these buffers, we specify four parametrised processes to rep-\nresent our composition rules.\n\nINTER(P,Q) = P ||| Q\nCOMM(P,Q,c1,c2) = (P ||| Q) [| {| c1,c2 |} |] BFIO(c1,c2)\nFEED(P,c1,c2) = P[| {| c1,c2 |} |] BFIO(c1,c2)\nREF(P,c1,c2) = P[| {| c1,c2 |} |] BFIO(c1,c2)\n\n\n\nC.3 THE DINING PHILOSOPHER\u2019S EXAMPLE 140\n\nINTER(P,Q) represents an interleave composition of the two processes (component behav-\niours) P and Q. COMM(P,Q,c1,c2) represents a communication composition between P and\nQ, using the channels c1 and c2. Finally, FEED(P,c1,c2) and REF(P,c1,c2) represent\na feedback and a reflexive composition of P using the channels c1 and c2, respectively. These\nparametrised processes represent the structure of the composition, they do not represent all con-\ncepts of the compositions rules; provisos must still be satisfied to perform the compositions.\n\nOther processes are related to verifications of rule provisos. For instance, in order to check\nthat a process P is I/O confluent, we need to perform a data forgetful renaming on the process\n(P [[ c.in.x&lt;- i, c.out.y&lt;- o]], and then place an input one-place inwards-\npointing buffer on every individual event of the renamed process (C(i, C(o, P))). The\nprocess InBufferProt below represent these steps altogether.\n\nchannel o,i, mid\nCP(a,b) =\nlet\nCPBEHAV = a -> b -> CPBEHAV\nwithin CPBEHAV\nC(a, P) = (P[[ a&lt;- mid ]] [| {|mid|} |] CP(a,mid)) \\ {|mid|}\nCIO(P) = C(i, C(o, P))\n\nInBufferProt(P,c) = CIO(P [[ c.in.x&lt;- i, c.out.y&lt;- o,\nx&lt;-extensions(c.in), y&lt;-extensions(c.out)]])\n\nThese are some auxiliary processes used in verifications of the study case. Not all verifications\nsteps use an auxiliary process. Some provisos are directly represented by an assertion in the\nspecifications presented in the next sections.\n\nC.3 The dining philosopher\u2019s example\n\nTo easy the definition of I/O types, we define a datatype EVENTS with all possible events in the\nsystem, and another datatype IO that tags events within EVENTS with in or out. Based on this,\nall I/O types are defined as subtypes of IO; in fact, we could not define I/O types as datatypes,\nsince distinct datatype cannot share the same tags.\n\ndatatype EVENTS = picksup | putsdown | picksack | putsack |\nthinks | sits | eats | getsup\n\ndatatype IO = out.EVENTS | in.EVENTS\n\nAs said before, all interfaces are defined as subtypes of IO. The interface used by the fork\ncomponent is I_FORK, and the interfaces used by the philosopher are I_PHF and I_LIFE.\n\nsubtype FKIN = picksup | putsdown\nsubtype FKOUT = picksack | putsack\nsubtype I_FORK = out.FKOUT | in.FKIN\n\n\n\nC.3 THE DINING PHILOSOPHER\u2019S EXAMPLE 141\n\nsubtype LFOUT = thinks | sits | eats | getsup\nsubtype I_LIFE = out.LFOUT\nsubtype I_PHFK = in.FKOUT | out.FKIN\n\nThe channels typed by these interfaces are fk1, fk2, pf1, pf2 and lf.\n\nchannel fk1, fk2: I_FORK\nchannel pf1, pf2: I_PHFK\nchannel lf: I_LIFE\n\nBased on these types and channels, we define the behaviour of a fork and a philosopher as the\nprocesses FORK and PHIL.\n\nFORK = (COMPFK(fk1) [] COMPFK(fk2)); FORK\nCOMPFK(f) = PICKUP_FK(f); PUTDOWN_FK(f)\nPICKUP_FK(f) = f.in.picksup -> f.out.picksack -> SKIP\nPUTDOWN_FK(f) = f.in.putsdown -> f.out.putsack -> SKIP\n\nPHIL = PREEAT; (lf.out.eats -> POSTEAT); PHIL\nPREEAT = lf.out.thinks -> lf.out.sits -> PICKFORKSUP\nPOSTEAT = PUTFORKSDOWN; (lf.out.getsup -> SKIP)\nPICKFORKSUP = PICKUP_PH(pf1); PICKUP_PH(pf2)\nPUTFORKSDOWN = PUTDOWN_PH(pf1); PUTDOWN_PH(pf2)\nPICKUP_PH(c) = c.out.picksup -> c.in.picksack -> SKIP\nPUTDOWN_PH(c) = c.out.putsdown -> c.in.putsack -> SKIP\n\nThe contract of a fork and a philosopher component is defined by CtrF ORK and CtrPHIL, respec-\ntively.\n\nCtrF ORK = ?F ORK,{ f k1 7? IF ORK, f k2 7? IF ORK},{IF ORK},{ f k1, f k2}?\n\nCtrPHIL = ?PHIL,{l f 7? ILIF E, p f 1 7? IPHF K, p f 2 7? IPHF K},{IPHF K,ILIF E},{l f , p f 1, p f 2}?\n\nThese are component types corresponding to the fork and philosopher. The behaviour of\nthe corresponding instances of these types in the example are represented by the following\nprocesses. The contracts of these instances are presented in Chapter 7. For the sake of brevity,\nwe present the case study for only 3 philosophers.\n\nFORK0 = FORK [[ fk1&lt;- fk.0.0, fk2&lt;- fk.0.2 ]]\nFORK1 = FORK [[ fk1&lt;- fk.1.1, fk2&lt;- fk.1.0 ]]\nFORK2 = FORK [[ fk1&lt;- fk.2.2, fk2&lt;- fk.2.1 ]]\n\nPHIL0 = PHIL [[ pf1&lt;- pfk.0.0, pf2&lt;- pfk.1.0 ]]\nPHIL1 = PHIL [[ pf1&lt;- pfk.1.1, pf2&lt;- pfk.2.1 ]]\nPHIL2 = PHIL [[ pf1&lt;- pfk.2.2, pf2&lt;- pfk.0.2 ]]\nPHILA = PHIL [[ pf1&lt;- pfk.0.2, pf2&lt;- pfk.2.2 ]]\n\n\n\nC.3 THE DINING PHILOSOPHER\u2019S EXAMPLE 142\n\nThe behaviours of compositions among these instances are represented by the following\nprocesses.\n\nFORKS= INTER(INTER(FORK0, FORK1), FORK2)\nPHILS= INTER(PHIL0, PHIL1)\nLF_PHFKS=FEED(COMM(PHILS,FORKS,fk.0.0,pfk.0.0),fk.1.1,pfk.1.1)\nPHILFKS= FEED(FEED(LF_PHFKS,fk.1.0,pfk.1.0),fk.2.1,pfk.2.1)\n\nLF_LSTPH= COMM(PHILFKS, PHIL2, fk.2.2, pfk.2.2)\nDEAD_SYSTEM= REF(LF_LSTPH, fk.0.2, pfk.0.2)\n\nLEFT_PHA= COMM(PHILFKS, PHILA, fk.2.2, pfk.2.2)\nSYSTEM= REF(LEFT_PHA, fk.0.2, pfk.0.2)\n\nDEAD_SYSTEM corresponds to a possible final composition with deadlock, which contains\nphilosophers that obtain forks in a symmetric manner. SYSTEM corresponds to the final dead-\nlock-free composition that represents the systems; to avoid deadlock, one philosopher (PHILA)\nis acquires forks in order different of the others. The processes above represent only the be-\nhaviour of such compositions, and they do not consider the provisos related to the composition\nrules involved. In fact, we would never achieve a composition with the DEAD_SYSTEM be-\nhaviour, since it does not satisfies the provisos of a reflexive composition. To confirm which\ncompositions are deadlock-free, we can use the following verifications in FDR.\n\nassert PHILS :[deadlock free [F]]\nassert FORKS :[deadlock free [F]]\nassert LEFT_PHFKInS :[deadlock free [F]]\nassert PHILFKS :[deadlock free [F]]\nassert LEFT_LSTPH :[deadlock free [F]]\nassert not DEAD_SYSTEM :[deadlock free [F]]\nassert LEFT_PHA :[deadlock free [F]]\nassert SYSTEM :[deadlock free [F]]\n\nMost provisos of the compositions above (those related to protocols and decoupled channels)\ncan be verified in FDR. This cover the provisos related to interleave, communication and feed-\nback compositions rules. As the components in this study case satisfy the constraints to be\nBRIC components, the verifications of the composition rules are performed directly in the\nmetadata. Here, we only need to perform verifications on elements of the original compo-\nnents (forks and philosophers). The does not contain any decoupled channels (some decoupled\nchannels are identified latter during composition), therefore, we focus on verifications about\nprotocols.\n\nThe protocols of PHIL and F ORK are PROT_PH and PROT_FK, respectively. These are\nvery simple protocols, since they do not present the common non-determinism related to out-\nput events. For this reason, their dual protocols and context process have an equivalent behav-\niour, as we can observe on the dual protocol of DPROT_FK and context process CTX_FK of\nPROT_FK, presented below.\n\n\n\nC.4 ROUTING COORDINATION 143\n\nPROT_PH = PICKUP_PH(pf1); PUTDOWN_PH(pf1); PROT_PH\nPROT_FK = COMPFK(fk1); PROT_FK\nDPROT_FK = COMPFK(fk1); DPROT_FK\nCTX_FK = COMPFK(fk1); CTX_FK\n\nTo verify that these protocols are compatible, we verify the following assertion, which translates\nthe test characterisation for protocol compatibility presented in Section 4.1.\n\nPROTCTX_PH = (PROT_PH [[pf1.in&lt;-fk1.out,pf1.out&lt;-fk1.in]])\n[| {|fk1|} |] CTX_FK\n\nassert DPROT_FK [F= PROTCTX_PH\n\nTo verify that these protocols satisfy FOP, we just need to verify that hiding outputs does not\nintroduce divergences (infinity hidden traces). The follow assertion translates this verification.\n\nassert PROT_PH \\ {|pf1.out |}:[divergence free [FD]]\nassert PROT_FK \\ {|fk1.out |}:[divergence free [FD]]\n\nFinally, we present how to verify that these protocols are I/O confluent. In order to verify this,\nwe have to verify that the protocol with one-place inwards-pointing buffer on every individual\nevent, after applying a forgetful renaming on that protocol, is deterministic. This verification\nuses the process InBufferProt presented early.\n\nassert InBufferProt(Prot_FK) :[deterministic [F]]\nassert InBufferProt(Prot_PH) :[deterministic [F]]\n\nThis concludes the translation of this example into CSPM , and its verification in FDR.\n\nC.4 Routing coordination\n\nSimilar to the dining philosophers example, we define a datatype EVENTS with all possible\nevents in the system, and a root supertype IO for all I/O Types. IO is constructed by adding the\ntags in or out to all events within EVENTS. The nametype SubInt is used to tune verification\nin FDR, restricting the set of integers in consideration when performing verifications about the\nsystem.\n\nnametype SubInt = {1..2}\ndatatype EVENTS = wd.SubInt | resBal.SubInt | ackWd.Bool |\n\nreqBal | isbusy | busy | idle\ndatatype IO = in.EVENTS | out.EVENTS\n\nThe interfaces for communicating data are I_DTSV and I_DTCL. If a component transmits\ndata through the routing network, it has a port typed by one of these interfaces, and its receiver\nhas a port typed by the other interface. Observe that the interfaces of the routing network are\nspecific for the components intermediated by the connector in the example. In fact, these are the\nsame interfaces used by these components. Communications among connectors of the network\nuse ports typed by I_FDSV and I_FDCL.\n\n\n\nC.4 ROUTING COORDINATION 144\n\nsubtype CLOUT = wd.SubInt | reqBal\nsubtype CLIN = ackWd.Bool | resBal.SubInt\nsubtype I_DTSV = in.CLOUT | out.CLIN\nsubtype I_DTCL = in.CLIN | out.CLOUT\n\nsubtype FEEDASK = isbusy\nsubtype FEEDSTATUS = busy | idle\nsubtype I_FDSV = in.FEEDASK | out.FEEDSTATUS\nsubtype I_FDCL = out.FEEDASK | in.FEEDSTATUS\n\nAs said before, the ports used by the connector in the example are typed by the interfaces\nabove. The channels ifd, ofd, idt and odt are used by the connectors in the example. To\nillustrate the components in the extreme of the network, we define the channels sv and cl to\npresent in the specification of protocols of these systems.\n\nchannel ifd: I_FDSV\nchannel ofd: I_FDCL\n\nchannel idt, sv: I_DTSV\nchannel odt, cl: I_DTCL\n\nThe protocols of the components in the extreme of the connectors are important in the\nspecification of the network, since they parametrise the connectors abstract behaviour. Here,\nwe present these protocols to help the understanding of the system. Only concrete specifications\n(after parameters are resolved) are presented. Below the specification of the protocol of a server\n(PROT_SV), the protocol of a client (PROT_CL), its dual protocol (DPROT_CL) and its context\nprocess (CTX_CL).\n\nPROT_SV = (sv.in.wd?x ->\n(|~| a: Bool @ sv.out!ackWd.a -> PROT_SV))\n\n[] (sv.in.reqBal ->\n(|~| y: SubInt @ sv.out!resBal.y -> PROT_SV))\n\nPROT_CL = |~| val:SubInt @ cl.out!wd.val -> cl.in.ackWd?a ->\ncl.out!reqBal -> cl.in.resBal?x -> PROT_CL\n\nDPROT_CL = cl.out.wd?val -> |~| a:Bool @ cl.in.ackWd!a ->\ncl.out.reqBal ->\n|~| x: SubInt @ cl.in.resBal!x -> DPROT_CL\n\nCTX_CL = cl.out.wd?val -> cl.in.ackWd?a -> cl.out.reqBal ->\ncl.in.resBal?x -> CTX_CL\n\nAs presented below these are compatible protocols.\n\nPROTCTX_SV = (PROT_SV [[ sv.in&lt;- cl.out, sv.out&lt;- cl.in ]])\n[|{|cl|} |] CTX_CL\n\nassert InBufferProt(PROT_SV, sv) :[deterministic [F]]\n\n\n\nC.4 ROUTING COORDINATION 145\n\nThe behaviour of the two connectors in this example is given by the following processors\nCCM and LBC.\n\nCCM(c1,c2, f1, f2, co) = CHOICECOPY(c1,c2,co)\n[| {|c1,c2|} |] AVAIL(c1,c2,f1,f2)\n\nCHOICECOPY(c1,c2, co) =\nlet\n\nTWOCOPIES = (COPY(c1,co); TWOCOPIES)\n[] (COPY(c2,co); TWOCOPIES)\n\nwithin TWOCOPIES\n\nAVAIL(c1,c2,f1,f2) =\nlet\nAVST = (f1.in.isbusy -> f1.out!idle -> AVST)\n\n[] (f2.in.isbusy -> f2.out!idle -> AVST)\n[] (c1.in?x -> AVST1; AVST)\n[] (c2.in?x -> AVST2; AVST)\n\nAVST1 = (f1.in.isbusy -> f1.out!idle -> AVST1)\n[] (f2.in.isbusy -> f2.out!busy -> AVST1)\n[] (c1.out?x -> SKIP)\n\nAVST2 = (f1.in.isbusy -> f1.out!busy -> AVST2)\n[] (f2.in.isbusy -> f2.out!idle -> AVST2)\n[] (c2.out?x -> SKIP)\n\nwithin AVST\n\nCOPY(ci,co) = CPSTEP(ci,co); CPSTEP(co,ci)\nCPSTEP(ci,co) = ci.in?x -> co.out!x -> SKIP\n\nLBC(ci,f1,f2, c1,c2) =\nlet\nLBCBEHAV = f1.out!isbusy -> f2.out!isbusy ->\n\n( (f1.in.idle -> f2.in?x -> COPY(ci,c1); LBCBEHAV)\n[] (f1.in.busy -> ((f2.in.idle -> COPY(ci,c2); LBCBEHAV)\n\n[] (f2.in.busy -> LBCBEHAV))))\nwithin LBCBEHAV\n\nMost of the processes use local definitions to tune verifications in FDR. This is performed\nseparating out those arguments which are passed in for configuration purposes (sizes, channels\nand so on) from those which represent process state and may need to be modified on recursive\ncalls.\n\nInstances of the concrete protocols presented above are built by adding am identifier index\nin all channels used by these connectors, as presented below.\n\nchannel ifeed : {1..6}.I_FDSV\n\n\n\nC.4 ROUTING COORDINATION 146\n\nchannel ofeed : {1..6}.I_FDCL\n\nchannel idata : {1..8}.I_DTSV\nchannel odata : {1..8}.I_DTCL\n\nLBC1 = LBC(idata.1, ofeed.3, ofeed.5, odata.3, odata.5)\nLBC2 = LBC(idata.2, ofeed.4, ofeed.6, odata.4, odata.6)\n\nCCM1 = CCM(idata.3, idata.4, ifeed.3, ifeed.4, odata.1)\nCCM2 = CCM(idata.5, idata.6, ifeed.5, ifeed.6, odata.2)\n\nThe behaviour of compositions among these instances are represented by the following\nprocesses. The first four processes represent compositions between data channels, and the\nlast two compositions represent compositions between feedback channels (channels used to\nexchange control information in the routing).\n\nCONNET1 = COMM(LBC1, CCM1, idata.3, odata.3)\nCONNET2 = COMM(LBC2, CCM2, idata.4, odata.4)\nCONNET3 = COMM(CONNET1, CONNET2, idata.5, odata.5)\nCONNET4 = REF(CONNET3, idata.6, odata.6)\nCONNET5 = REF(REF(CONNET4,ifeed.3,ofeed.3),ifeed.4,ofeed.4)\nCONNET6 = REF(REF(CONNET5,ifeed.5,ofeed.5),ifeed.6,ofeed.6)\n\nThese are deadlock-free compositions, as assert below.\n\nassert CONNET1 :[deadlock free [F]]\nassert CONNET2 :[deadlock free [F]]\nassert CONNET3 :[deadlock free [F]]\nassert CONNET4 :[deadlock free [F]]\nassert CONNET5 :[deadlock free [F]]\nassert CONNET6 :[deadlock free [F]]\n\nVerifications about protocols of these components are performed to ensure the provisos\nof the compositions above. The following processes represent the protocols. PROT_CMMDT\nand PROT_CMMFD are the protocols for data and control communication of CCM, respectively.\nDPROT_CMMDT and DPROT_CMMFD are their dual protocols, respectively. PROT_LBCDT and\nPROT_LBCFD are the protocols for data and control communication of LBC.\n\nPROT_CMMFD = ifd.in.isbusy ->\n|~|y: FEEDSTATUS@ ifd.out.y -> PROT_CMMFD\n\nPROT_CMMDT = idt.in?y -> |~| x:CLIN @ odt.out?x -> PROT_CMMDT\nDPROT_CMMFD = ifd.in.isbusy -> ifd.out?x -> DPROT_CMMFD\nDPROT_CMMDT = |~|y:CLOUT@ idt.in.y -> idt.out?x -> DPROT_CMMDT\n\nPROT_LBCFD = ofd.out.isbusy -> ofd.in?x -> PROT_LBCFD\nPROT_LBCDT = |~|y:CLOUT@ odt.out.y -> odt.in?x -> PROT_LBCDT\n\n\n\nC.4 ROUTING COORDINATION 147\n\nTo assert that these protocols are compatible, the following verification is performed in FDR.\n\nPROT_LBCFDREN = PROT_LBCFD [[ofd.in&lt;- ifd.out,\nofd.out&lt;- ifd.in]]\n\nPROT_LBCDTREN = PROT_LBCDT [[odt.in&lt;- idt.out,\nodt.out&lt;- idt.in]]\n\nassert DPROT_CMMFD [F= PROT_LBCFDREN\nassert DPROT_CMMDT [F= PROT_LBCDTREN\n\nWe assert they are I/O confluent, using the following verification\n\nassert InBufferProt(PROT_SV, sv) :[deterministic [F]]\nassert InBufferProt(PROT_CL, cl) :[deterministic [F]]\nassert InBufferProt(PROT_CMMFD, ifd) :[deterministic [F]]\nassert InBufferProt(PROT_CMMDT, idt) :[deterministic [F]]\nassert InBufferProt(PROT_LBCFD, ofd) :[deterministic [F]]\nassert InBufferProt(PROT_LBCDT, odt) :[deterministic [F]]\n\nFinally, we assert they satisfy FOP by the assertions.\n\nassert PROT_CMMFD \\ {|ifd.out |} :[divergence free [FD]]\nassert PROT_CMMDT \\ {|idt.out |} :[divergence free [FD]]\nassert PROT_LBCFD \\ {|ofd.out |} :[divergence free [FD]]\nassert PROT_LBCDT \\ {|odt.out |} :[divergence free [FD]]\n\nThis concludes the translation of this example into CSPM , and its verification in FDR.\n\n\n\nBibliography\n\n[AAG+07] E. Almeida, A. Alvaro, V. Garcia, J. Mascena, V. Bur\u00e9gio, L. Nascimento, D. Lu-\ncr\u00e9dio, and S. Meira. C.R.U.I.S.E: Component Reuse in Sofware Engineering.\nC.E.S.A.R. e-books, 2007.\n\n[AB03] A. Aldini and M. Bernardo. A general approach to deadlock freedom verifica-\ntion for software architectures. In International Symposium of Formal Methods\nEurope, volume 2805 of Lecture Notes in Computer Science, pages 658\u2013677.\nSpringer, 2003.\n\n[ABB+01] C. Atkinson, J. Bayer, C. Bunse, E. Kamsties, O. Laitenberger, R. Laqua,\nD. Muthig, B. Paech, J. W\u00fcst, and J. Zettel. Component-Based Product Line\nEngineering With UML. Addison Wesley, 2001.\n\n[ACN02] J. Aldrich, C. Chambers, and D. Notkin. Archjava: connecting software architec-\nture to implementation. In International Conference on Software Engineering.\nACM Press, 2002.\n\n[ADG98] R. Allen, R. Douence, and D. Garlan. Specifying and analyzing dynamic soft-\nware architectures. In Conference on Fundamental Approaches to Software En-\ngineering (FASE), Lisbon, Portugal, March 1998.\n\n[AG97] R. Allen and D. Garlan. A formal basis for architectural connection. ACM\nTransactions on Software Engineering and Methodology, 6(3):213 \u2013 249, July\n1997.\n\n[AINT07] M. Autili, P. Inverardi, A. Navarra, and M. Tivoli. SYNTHESIS: a tool for\nautomatically assembling correct and distributed Component\u2013Based systems. In\n29th International Conference on Software Engineering, pages 784\u2013787. IEEE\nComputer Society, 2007.\n\n[AM02] F. Arbab and F. Mavaddat. Coordination through channel composition. In In-\nternational Conference on Coordination Models and Languages, pages 22\u201339.\nSpringer-Verlag, 2002.\n\n[Arb04] F. Arbab. Reo: a channel-based coordination model for component composition.\nMathematical. Structures in Computer Science, 14(3):329\u2013366, 2004.\n\n[Arb06] F. Arbab. Coordination for component composition. Electronic Notes in Theo-\nretical Computer Science, 160:15\u201340, 2006.\n\n148\n\n\n\nBIBLIOGRAPHY 149\n\n[Bae05] J.C.M. Baeten. A brief history of process algebra. Theoretical Computer Sci-\nence, 335(2-3):131\u2013146, 2005.\n\n[BB04] M. Barbosa and L. Barbosa. Specifying software connectors. In 1st International\nColloquim on Theoretical Aspects of Computing, pages 53\u201368. Springer, 2004.\n\n[BBB+00] F. Bachmann, L. Bass, C. Buhman, S. Comella-Dorda, F. Long, J. Robert,\nR. Seacord, and K. Wallnau. Volume ii: Technical concepts of component-based\nsoftware engineering, 2nd edition. Technical Report CMU/SEI-2000-TR-008,\nSoftware Engineering Institute, Carnegie Mellon University, 2000.\n\n[BBT01] A. Bracciali, A. Brogi, and F. Turini. Coordinating interaction patterns. In ACM\nSymposium on Applied Computing, pages 159\u2013165. ACM, 2001.\n\n[BCD02] M. Bernardo, P. Ciancarini, and L. Donatiello. Architecting families of software\nsystems with process algebras. ACM Transactions on Software Engineering and\nMethodology, 11(4):386\u2013426, 2002.\n\n[BCK03] L. Bass, P. Clements, and R. Kazman. Software Architecture in Practice.\nAddison-Wesley Longman, Reading, MA, 2nd edition, 2003.\n\n[BCL+06] E. Bruneton, T. Coupaye, M. Leclercq, V. Qu\u00e9ma, and J.B. Stefani. The FRAC-\nTAL component model and its support in Java. Software: Practice and Experi-\nence, 36(11-12):1257\u20131284, 2006.\n\n[BCP06] A. Brogi, C. Canal, and E. Pimentel. Component adaptation through flexible\nsubservicing. Science of Computer Programming, 63(1):39\u201356, 2006.\n\n[BDH+98] M. Broy, A. Deimel, J. Henn, K. Koskimies, F. Plasil, G. Pomberger, W. Pree,\nM. Stal, and C. Szyperski. What characterizes a (software) component. Software\nConcepts &amp; Tools, 19(1):49\u201356, 1998.\n\n[BGL+08] A. Basu, M. Gallien, C. Lesire, T.-H. Nguyen, S. Bensalem, F. Ingrand, and\nJ. Sifakis. Incremental component-based construction and verification of a\nrobotic system. In 18th European Conference on Artificial Intelligence, vol-\nume 178 of Frontiers in Artificial Intelligence and Applications, pages 631\u2013635.\nIOS Press, 2008.\n\n[BHB+03] G. Beneken, U. Hammerschall, M. Broy, M. Cengarle, J. Jurjens, B. Rumpe, and\nM. Schoenmakers. Componentware - state of the art. In Background Paper For\nthe Understanding Components Workshop of the CUE Initiative, 2003.\n\n[BHP06] T. Bures, P. Hnetynka, and F. Plasil. SOFA 2.0: Balancing Advanced Features\nin a Hierarchical Component Model. In 4th International Conference on Soft-\nware Engineering Research, Management and Applications, pages 40\u201348. IEEE,\n2006.\n\n\n\nBIBLIOGRAPHY 150\n\n[BLL09] D. Bosnacki, S. Leue, and A. Lluch-Lafuente. Partial-order reduction for general\nstate exploring algorithms. STTT, 11(1):39\u201351, 2009.\n\n[BRSV99] K. Bergner, A. Rausch, M. Sihling, and A. Vilbig. Componentware - method-\nology and process. In International Workshop on Component-Based Software\nEngineering. IEEE, 1999.\n\n[CCH+09] E. Cheung, X. Chen, H. Hsieh, A. Davare, A. Sangiovanni-Vincentelli, and\nY. Watanabe. Runtime deadlock analysis for system level design. Design Au-\ntomation for Embedded Systems, 13(4):287\u2013310, 2009.\n\n[CD01] J. Cheesman and J. Daniels. UML Components, A Simple Process for Specifying\nComponent-Based Systems. Addison-Wesley, 2001.\n\n[Cha85] D.M. Chapiro. Globally-asynchronous locally-synchronous systems (perfor-\nmance, reliability, digital). PhD thesis, Stanford University Stanford, CA, USA,\n1985.\n\n[Chi09] Z. Chi. Components Composition Compatibility Checking Based on Behavior\nDescription and Roles Division. In International Conference on Management of\ne-Commerce and e-Government, pages 262\u2013265. IEEE, 2009.\n\n[CHLZ07] X. Chen, J. He, Z. Liu, and N. Zhan. A model of Component-Based program-\nming. In International Symposium on Fundamentals of Software Engineering,\nvolume 4767 of Lecture Notes in Computer Science, pages 191\u2013206. Springer,\n2007.\n\n[CK96] S. Cheung and J. Kramer. Context constraints for compositional reachabil-\nity analysis. ACM Transactions on Software Engineering and Methodology,\n5(4):334\u2013377, 1996.\n\n[CM84] K. Chandy and J. Misra. The drinking philosophers problem. ACM Transactions\non Programming Languages and Systems, 6:632\u2013646, 1984.\n\n[CZ07] D.C. Craig and WM Zuberek. Compatibility of software components-modeling\nand verification. In International Conference on Dependability of Computer\nSystems, pages 11\u201318. IEEE, 2007.\n\n[DK06] L. DeMichiel and M. Keith. Enterprise javabeans specification, version 3.0.\nTechnical Report JSR 220, Sun Microsystems, 2006.\n\n[DR02] MS Dias and DJ Richardson. Identifying cause and effect relations between\nevents in concurrent event-based components. In 17th IEEE International Con-\nference on Automated Software Engineering, pages 245\u2013248. IEEE, 2002.\n\n[DW98] D. D\u2019Souza and A. Wills. Objects, Components and Frameworks With UML:\nThe Catalysis Approach. Addison-Wesley, 1998.\n\n\n\nBIBLIOGRAPHY 151\n\n[DZZL10] J. Ding, H. Zhu, H. Zhu, and Q. Li. Formal Modeling and Verifications of Dead-\nlock Prevention Solutions in Web Service Oriented System. In 2010 17th IEEE\nInternational Conference and Workshops on Engineering of Computer-Based\nSystems, pages 335\u2013343. IEEE, 2010.\n\n[FG03] A. Farias and Y. Gu\u00e9h\u00e9neuc. On the coherence of component protocols. Elec-\ntronic Notes Theoretical Computer Science, 82(5):42\u201353, 2003.\n\n[FLF01] R.B. Findler, M. Latendresse, and M. Felleisen. Behavioral contracts and behav-\nioral subtyping. ACM SIGSOFT Software Engineering Notes, 26(5):229\u2013236,\n2001.\n\n[For10] Formal-Systems. Failures-Divergence Refinement: FDR2 User Manual. Tech-\nnical report, Formal Systems (Europe) and Oxford University Computing Labo-\nratory, 2010.\n\n[GGMC+06] G. G\u00f6\u00dfler, S. Graf, M. Majster-Cederbaum, M. Martens, and J. Sifakis. Ensuring\nproperties of interaction systems. In Theory and Practice on Program Analysis\nand Compilation, volume 4444 of Lecture Notes in Computer Science, pages\n201\u2013224. Springer, 2006.\n\n[GGMC+07] G. G\u00f6\u00dfler, S. Graf, M. Majster-Cederbaum, M. Martens, and J. Sifakis. An\napproach to modelling and verification of component based systems. In Current\nTrends in Theory and Practice of Computer Science, volume 4362 of Lecture\nNotes in Computer Science, pages 295\u2013308. Springer, 2007.\n\n[GMW00] D. Garlan, R. Monroe, and D. Wile. ACME: Architecture Description of\nComposed-Based Systems. In Foundations of Component-Based Systems, pages\n47\u201368. Cambridge University Press, 2000.\n\n[Har87] D. Harel. Statecharts: A visual formalism for complex systems. Science of\nComputer Programming, 8:231\u2013274, 1987.\n\n[HGK+06] M. Hepner, R. Gamble, M. Kelkar, L. Davis, and D. Flagg. Patterns of conflict\namong software components. The Journal of Systems &amp; Software, 79(4):537\u2013\n551, 2006.\n\n[HH10] J. He. and C. Hoare. CSP is a retract of CCS. Theoretical Computer Science,\n411(11-13):1311\u20131337, 2010.\n\n[HJK10] R. Hennicker, S. Janisch, and A. Knapp. On the observable behaviour of com-\nposite components. Electronic Notes in Theoretical Computer Science, 260:125\u2013\n153, 2010.\n\n[HLL06a] J. He, X. Li, and Z. Liu. rCOS: a refinement calculus of object systems. Theo-\nretical Computer Science, 365(1-2):109\u2013142, 2006.\n\n\n\nBIBLIOGRAPHY 152\n\n[HLL06b] J. He, X. Li, and Z. Liu. A theory of reactive components. Electronic Notes in\nTheoretical Computer Science, 160:173\u2013195, 2006.\n\n[Hoa85] C. Hoare. Communicating Sequential Processes. Prentice-Hall, 1985.\n\n[Hoa06] C. Hoare. Why ever CSP? Electr. Notes Theor. Comput. Sci., 162:141\u2013146,\n2006.\n\n[IM08] J. Ivers and G. Moreno. PACC starter kit: developing software with predictable\nbehavior. In ICSE Companion, pages 949\u2013950. ACM, 2008.\n\n[Kwi07] X.W.M. Kwiatkowska. Compositional state space reduction using untangled\nactions. In 13th International Workshop on Expressiveness in Concurrency, vol-\nume 175 of Electronic Notes in Theoretical Computer Science, pages 27\u201346,\n2007.\n\n[LD00] Gary Leavens and Krishna Dhara. Concepts of behavioral subtyping and a sketch\nof their extension to Component-Based systems. In Foundations of Component-\nBased Systems, pages 113\u2013135. Cambridge University Press, 2000.\n\n[Lev95] N. Leveson. Safeware: System Safety and Computers. Addison-Wesley, 1995.\n\n[Lil03] J. Lillieskold. Coordinating dependencies in complex system development\nprojects. In Engineering Management Conference, pages 400\u2013404, 2003.\n\n[LMC10] C. Lambertz and M. Majster-Cederbaum. Port protocols for deadlock-freedom\nof component systems. In 3rd Interaction and Concurrency Experience: Guar-\nanteed Interaction, volume 38 of Electronic Proceedings in Theoretical Com-\nputer Science, pages 7\u201311, 2010.\n\n[LW94] B. Liskov and J. Wing. A behavioral notion of subtyping. ACM Transactions on\nProgramming Languages and Systems, 16(6):1811\u20131841, 1994.\n\n[Mah90] M. Mahoney. The roots of software engineering. CWI Quarterly, 3(4):325\u2013334,\n1990.\n\n[MB05] S. Matougui and A. Beugnard. How to Implement Software Connectors? A\nReusable, Abstract and Adaptable Connector. In IFIP WG 6.1 International\nConference in Distributed Applications and Interoperable Systems, volume 3543\nof Lecture Notes in Computer Science, pages 83\u201394. Springer, 2005.\n\n[MC94] T. Malone and K. Crowston. The interdisciplinary study of coordination. ACM\nComputing Surveys, 26:87\u2013120, 1994.\n\n[McI68] D. McIlroy. Mass-produced software components. In Software Engineering,\nNATO Science Committe report, pages 138\u2013155, 1968.\n\n\n\nBIBLIOGRAPHY 153\n\n[MCM07] M. Majster-Cederbaum and M. Martens. Robustness in interaction systems. In\n27th International Conference on Formal Methods for Networked and Distrib-\nuted Systems, volume 4574 of Lecture Notes of Computer Science, pages 325\u2013\n340. Springer, 2007.\n\n[MCM08] M Majster-Cederbaum and M. Martens. Compositional analysis of deadlock-\nfreedom for tree-like component architectures. In 8th ACM international con-\nference on Embedded software, pages 199\u2013206. ACM, 2008.\n\n[MCMM07] M. Majster-Cederbaum, M. Martens, and C. Minnameier. A polynomial-time\ncheckable sufficient condition for deadlock-freedom of component-based sys-\ntems. SOFSEM 2007: Theory and Practice of Computer Science, pages 888\u2013\n899, 2007.\n\n[MCMM08] M. Majster-Cederbaum, M. Martens, and C. Minnameier. Liveness in Interaction\nSystems. Electronic Notes in Theoretical Computer Science, 215:57\u201374, 2008.\n\n[Mey92] B. Meyer. Applying \u201cDesign By Contract\u201d. Computer, 25(10):40\u201351, 1992.\n\n[Mey97] B. Meyer. Object-Oriented Software Construction. Prentice-Hall International,\n2nd edition, 1997.\n\n[MH05] P. Merson and S. Hissam. Predictability by construction. In 20th Annual ACM\nSIGPLAN Conference on Object-Oriented Programming, Systems, Languages,\nand Applications, pages 134\u2013135. ACM, 2005.\n\n[Mic11] Microsoft Developer Network. Component object model technologies. Techni-\ncal report, http://www.microsoft.com/com, 2011.\n\n[Mil80] R. Milner. A Calculus of Communicating Systems, volume 92 of Lecture Notes\nin Computer Science. Springer, 1980.\n\n[Mil89] R. Milner. Communication and Concurrency. Prentice-Hall, 1989.\n\n[Min07] C. Minnameier. Local and global deadlock-detection in component-based sys-\ntems are NP-hard. Information Processing Letters, 103(3):105\u2013111, 2007.\n\n[MJG+10] A. Mota, J. Jesus, A. Gomes, F. Ferri, and E. Watanabe. Evolving a Safe System\nDesign Iteratively. In 29th International Conference Computer Safety, Relia-\nbility, and Security, volume 6351 of Lecture Notes in Computer Science, pages\n361\u2013374. Springer, 2010.\n\n[MK96] J. Magee and J. Kramer. Dynamic structures in software architecture. In 4th Sym-\nposium On the Foundations of Software Engineering, pages 3\u201314. ACM Press,\n1996.\n\n\n\nBIBLIOGRAPHY 154\n\n[MMP00] N. Mehta, N. Medvidovic, and S. Phadke. Towards a taxonomy of software\nconnectors. In International Conference on Software Engineering, pages 178\u2013\n187. ACM Press, 2000.\n\n[MORW04] M. M\u00f6ller, E.-R. Olderog, H. Rasch, and H. Wehrheim. Linking CSP-OZ With\nUML and Java: A Case Study. In Eerke A Boiten, John Derrick, and Graeme\nSmith, editors, 4th International Conference on Integrated Formal Methods, vol-\nume 2999 of LNCS, pages 267\u2013286. Springer, 2004.\n\n[MT00] N. Medvidovic and R. Taylor. A classification and comparison framework for\nsoftware architecture description languages. Transactions on Software Engineer-\ning, 26(1):70\u201393, 2000.\n\n[MW97] J.M.R. Martin and P.H. Welch. A design strategy for deadlock-free concurrent\nsystems. Transputer Communications, 3(4):215\u2013232, 1997.\n\n[Nie93] O. Nierstrasz. Regular types for active objects. ACM Sigplan Notices, 28(10):1\u2013\n15, 1993.\n\n[NR69] P. Naur and B. Randell, editors. Software Engineering Techniques: Report on\na Conference sponsored by the NATO Science Committee. Brussels: Scientific\nAffairs Division, Rome, Italy, 1969.\n\n[Obj07] Object Management Group. Unified Modeling Language, Superstructure,\nV2.1.2. Technical Report formal/2007-11-02, OMG, 2007. OMG Adopted Spec-\nification.\n\n[Obj08] Object Management Group. Common Object Request Broker Architecture\n(CORBA) Specification. Technical Report Version 3.1, OMG, 2008.\n\n[PA98] G. Papadopoulos and F. Arbab. Coordination models and languages. Advances\nin Computers - The Engineering of Large Systems, 46:330\u2013401, 1998.\n\n[Pla05] F. Plasil. Enhancing component specification by behavior description: the SOFA\nexperience. In 4th international symposium on Information and communication\ntechnologies, page 190. Trinity College Dublin, 2005.\n\n[PV02] F. Plasil and S. Visnovsky. Behavior protocols for software components. IEEE\nTransactions on Software Engineering, 28(11):1056\u20131076, 2002.\n\n[RG02] M. Richters and M. Gogolla. OCL: Syntax, semantics, and tools. In Object\nModeling With the OCL: The Rationale Behind the Object Constraint Language,\nvolume 2263 of LNCS, pages 42\u201368. Springer, 2002.\n\n[RM04] R. Roshandel and N. Medvidovic. Multi-View software component modeling for\ndependability. In Architecting Dependable Systems II, volume 3069 of Lecture\nNotes in Computer Science. Springer, 2004.\n\n\n\nBIBLIOGRAPHY 155\n\n[Ros98] A. W Roscoe. Theory and Practice of Concurrency. Prentice-Hall Series in\nComputer Science. Prentice-Hall, 1998.\n\n[Ros05a] A. Roscoe. On the expressiveness of CSP refinement. Formal Aspects of Com-\nputing, 17(2):93\u2013112, 2005.\n\n[Ros05b] A. W. Roscoe. The pursuit of buffer tolerance. Technical report, Oxford Univer-\nsity, May 2005.\n\n[Ros06] A. W. Roscoe. Confluence thanks to extensional determinism. Electronic Notes\nin Theoretical Computer Science, 162:305\u2013309, 2006.\n\n[Ros10] A. W. Roscoe. CSP is expressive enough for ? . Reflections on the Work of CAR\nHoare, pages 371\u2013404, 2010.\n\n[RRMP08] Andreas Rausch, Ralf Reussner, Raffaela Mirandola, and Frantisek Plasil, edi-\ntors. The Common Component Modeling Example: Comparing Software Com-\nponent Models, volume 5153 of Lecture Notes in Computer Science. Springer,\n2008.\n\n[RS01] P. Ryana and S. Schneider. Process algebra and non-interference. Journal of\nComputer Security, 9(1):75\u2013103, 2001.\n\n[RSM05] R. Ramos, A. Sampaio, and A. Mota. A semantics for UML-RT active classes via\nmapping into circus. In 7th IFIP International Conference on Formal Methods\nfor Open Object-based Distributed Systems, volume 3535 of Lecture Notes in\nComputer Science, pages 99\u2013114. Springer, 2005.\n\n[RSM06] R. Ramos, A. Sampaio, and A. Mota. Transformation laws for UML-RT. In\n8th IFIP International Conference on Formal Methods for Open Object-Based\nDistributed Systems, volume 4037 of Lecture Notes in Computer Science, pages\n123\u2013138. Springer, 2006.\n\n[RSM08] R. Ramos, A. Sampaio, and A. Mota. Framework composition conformance via\nrefinement checking. In ACM Symposium on Applied computing, pages 119\u2013\n125. ACM, 2008.\n\n[RSM09] R. Ramos, A. Sampaio, and A. Mota. Systematic development of trustworthy\ncomponent systems. In 2nd World Congress on Formal Methods, volume 5850\nof Lecture Notes in Computer Science, pages 140\u2013156. Springer, 2009.\n\n[RSM10] R. Ramos, A. Sampaio, and A. Mota. Conformance notions for the coordination\nof interaction components. Science of Computer Programming, 75(5):350\u2013373,\n2010.\n\n[SC97] M. Shaw and P. Clements. A field guide to boxology: Preliminary classification\nof architectural styles for software systems. In Internationall Computer Software\nand Applications Conference, pages 6\u201313, August 1997.\n\n\n\nBIBLIOGRAPHY 156\n\n[SDS01] Z. Stojanovic, A. Dahanayake, and H. Sol. An integrated component-oriented\nframework for effective and flexible enterprise distributed systems development.\nIn International Conference on Enterprise Information Systems, pages 667\u2013672,\n2001.\n\n[SG96] M. Shaw and D. Garlan. Software Architecture - Perspectives On an Emerging\nDiscipline. Prentice Hall, 1996.\n\n[SGW94] B. Selic, G. Gullekson, and P. Ward. Real-Time Object-Oriented Modeling. John\nWiley &amp; Sons, Inc., 1994.\n\n[Sha95] M. Shaw. Abstractions for software architecture and tools to support them. IEEE\nTransactions on Software Engineering, 21:314\u2013335, 1995.\n\n[Sif10] J. Sifakis. Component-Based Construction of Heterogeneous Real-Time Sys-\ntems in Bip. The Future of Software Engineering, page 150, 2010.\n\n[Spi04] B. Spitznagel. Compositional Transformation of Software Connectors. PhD\nthesis, Carnegie Mellon University, 2004. Number: CMU-CS-04-128.\n\n[SR98] B. Selic and J. Rumbaugh. Using UML for modeling complex RealTime sys-\ntems. Technical report, Rational Software Corporation, 1998.\n\n[SW03] D. Sangiorgi and D. Walker. The ? -calculus: A theory of mobile processes.\nCambridge University Press, 2003.\n\n[SWC02] A. Sampaio, J. Woodcock, and A. Cavalcanti. Refinement in Circus. In Inter-\nnational Symposium of Formal Methods Europe, volume 2391 of LNCS, pages\n451\u2013470. Springer, 2002.\n\n[Szy02] C. Szyperski. Component Software: Beyond Object\u2013Oriented Programming.\nAddisonn-Wesley, 2002.\n\n[VVR06] A. Vallecillo, V.T. Vasconcelos, and A. Ravara. Typing the behavior of soft-\nware components using session types. Fundamenta Informaticae, 73(4):583\u2013\n598, 2006.\n\n[Wal03] Kurt C. Wallnau. Volume III: a technology for predictable assembly from cer-\ntifiable components. Technical Report CMU/SEI-2003-TR-009, Software Engi-\nneering Institute, Carnegie Mellon University, 2003.\n\n[Weh00] H. Wehrheim. Specification of an automatic manufacturing system: A case study\nin using integrated formal methods. In 3rd Internationsl Conference Funda-\nmental Approaches to Software Engineering, volume 1783 of Lecture Notes in\nComputer Science, pages 334\u2013348. Springer, 2000.\n\n[Weh03] H. Wehrheim. Behavioral subtyping relations for active objects. Formal Methods\nin System Design, 23(2):143\u2013170, 2003.\n\n\n\nBIBLIOGRAPHY 157\n\n[ZKL10] N. Zhan, E. Kang, and Z. Liu. Component publications and compositions. Uni-\nfying Theories of Programming, pages 238\u2013257, 2010.\n\n[ZM10] H. Zeng and H. Miao. Deadlock Detection for Parallel Composition of Compo-\nnents. Computer and Information Science, pages 23\u201334, 2010.\n\n[ZW97] A. Zaremski and J. Wing. Specification matching of software components. ACM\nTransactions On Software Engineering and Methodology (TOSEM), 6(4):333\u2013\n369, October 1997."}]}}}