{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.15626"}, {"@name": "filename", "#text": "22093_Korbes_Andre_M.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Universidade Estadual de Campinas\n\nFaculdade de Engenharia El\u00e9trica e Computa\u00e7\u00e3o\n\nDepartamento de Engenharia da Computa\u00e7\u00e3o\ne Automa\u00e7\u00e3o Industrial\n\nAn\u00e1lise de Algoritmos da\nTransformada Watershed\n\nAutor: Andr\u00e9 K\u00f6rbes\n\nOrientador: Roberto de Alencar Lotufo\n\nDisserta\u00e7\u00e3o de Mestrado apresentada \u00e0 Faculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o como\nparte dos requisitos para obten\u00e7\u00e3o do t\u00edtulo de Mestre em Engenharia El\u00e9trica. \u00c1rea de\n\nconcentra\u00e7\u00e3o: Engenharia de Computa\u00e7\u00e3o.\n\nComiss\u00e3o Examinadora\nNina Sumiko Tomita Hirata\nRomis Ribeiro de Faissol Attux\n\nCampinas, 23/03/2010\n\n\n\nFICHA CATALOGR\u00c1FICA ELABORADA PELA\nBIBLIOTECA DA \u00c1REA DE ENGENHARIA - BAE - UNICAMP\n\nK\u00f6rbes, Andr\u00e9\nK841a An\u00e1lise de algoritmos da Transformada Watershed\n\n/ Andr\u00e9 K\u00f6rbes. \u2013 Campinas, SP: [s.n.], 2010.\n\nOrientador: Roberto de Alencar Lotufo.\nDisserta\u00e7\u00e3o de Mestrado - Universidade Estadual\n\nde Campinas, Faculdade de Engenharia El\u00e9trica e de\nComputa\u00e7\u00e3o.\n\n1. Algoritmos. 2. Morfologia matem\u00e1tica. 3.\nProcessamento de Imagens. I. Lotufo, Roberto de\nAlencar. II. Universidade Estadual de Campinas.\nFaculdade de Engenharia El\u00e9trica e de Computa\u00e7\u00e3o. III.\nT\u00edtulo\n\nT\u00edtulo em Ingl\u00eas: Analysis of algorithms of the Watershed Transform\nPalavras-chave em Ingl\u00eas: Algorithms, Mathematical morphology, Image processing\n\u00c1rea de concentra\u00e7\u00e3o: Engenharia de Computa\u00e7\u00e3o\nTitula\u00e7\u00e3o: Mestre em Engenharia El\u00e9trica\nBanca Examinadora: Nina Sumiko Tomita Hirata, Romis Ribeiro de Faissol Attux\nData da defesa: 23/03/2010\nPrograma de P\u00f3s Gradua\u00e7\u00e3o: Engenharia El\u00e9trica\n\nii\n\n\n\niii\n\n\n\nResumo\n\nA transformada watershed \u00e9 uma t\u00e9cnica morfol\u00f3gica de segmenta\u00e7\u00e3o de imagens inspirada na divi-\ns\u00e3o de superf\u00edcies em bacias hidrogr\u00e1ficas, tendo diversas formas de defini\u00e7\u00e3o e de algoritmos. Este\ntrabalho realiza uma an\u00e1lise sistem\u00e1tica da literatura de catorze destes algoritmos. Foram considera-\ndas as principais abordagens existentes desde a introdu\u00e7\u00e3o do primeiro algoritmo r\u00e1pido por Vincent\ne Soille em 1991, at\u00e9 os trabalhos de Cousty et al. em 2009. Para melhor compreens\u00e3o da \u00e1rea,\nas defini\u00e7\u00f5es de transformada watershed s\u00e3o revisitadas, provendo o conjunto de solu\u00e7\u00f5es formais\nposs\u00edveis e esperadas dos algoritmos.\n\nNa an\u00e1lise destes algoritmos \u00e9 fornecido pseudoc\u00f3digo com nota\u00e7\u00e3o uniformizada e uma imple-\nmenta\u00e7\u00e3o operacional Python permitindo abstrair detalhes de programa\u00e7\u00e3o. Al\u00e9m disto, tr\u00eas algorit-\nmos foram corrigidos para melhor ader\u00eancia a defini\u00e7\u00e3o e especifica\u00e7\u00e3o. Tamb\u00e9m s\u00e3o identificadas\npropriedades tais como o comportamento de varredura dos pixels, uso de estrat\u00e9gias em particular,\nuso de estruturas de dados, entre outras.\n\nA compila\u00e7\u00e3o das informa\u00e7\u00f5es sobre os algoritmos permitiu generaliz\u00e1-los e classific\u00e1-los base-\nado em paradigmas cl\u00e1ssicos da computa\u00e7\u00e3o, a saber a busca em largura e em profundidade. Ambos\ns\u00e3o embasados na ordem de visita\u00e7\u00e3o dos pixels utilizada, sendo a busca em largura semelhante a\nsimula\u00e7\u00e3o de inunda\u00e7\u00e3o enquanto a busca em profundidade simula gotas de \u00e1gua em uma superf\u00edcie.\n\nForam tamb\u00e9m realizados estudos comparativos entre as defini\u00e7\u00f5es implementadas pelos algorit-\nmos, entre as estrat\u00e9gias utilizadas para tratamento de problemas comuns, entre o desempenho obtido\npelos programas Python, e de paralelismo e abordagens utilizadas neste \u00faltimo caso. Desta forma,\nproduziu-se um panorama geral e atualizado dos algoritmos de transformada watershed.\n\nPalavras-chave: Transformada watershed, An\u00e1lise de Algoritmos.\n\nv\n\n\n\nAbstract\n\nThe watershed transform is a morphological image segmentation technique inspired on the division of\nsurfaces in catchment basins, with several forms of definition and algorithms. This work accomplishes\na survey of the literature on fourteen of these algorithms. The main approaches since the introduction\nof the first fast algorithm by Vincent and Soille in 1991, until the work of Cousty et al. in 2009\nhas been considered. For better understanding of the subject, the watershed definitions are revisited,\nproviding the set of formal solutions that are possible and expected from the algorithms.\n\nOn the analysis of the algorithms it is supplied pseudocode with a uniform notation and a Python\noperational implementation allowing to abstract programming details. Aside, three algorithms were\ncorrected for better adherence to definition and specification. Also some properties such as the scan-\nning behaviour, use of particular strategies, and use of data structures, among others were identified.\n\nThe compilation of information of the algorithms allowed to generalise and classify them based\non classic paradigms of computing, namely breadth-first and depth-first search. Both are based on the\nvisiting order of the pixels, with the breadth-first similar to a flooding simulation while the depth-first\nsimulates drops of water on a surface.\n\nComparative studies between the algorithms\u2019 implemented definitions, the strategies used for tre-\natment of common issues, the performance of the Python programs, of parallelism and its approaches\nare provided. In this way, a broad and updated viewpoint of the algorithms of the watershed trans-\nforms has been produced.\n\nKeywords: Watershed Transform, Algorithms Analysis.\n\nvii\n\n\n\nAgradecimentos\n\nAos meus pais Patr\u00edcio e Roswitha e ao meu irm\u00e3o Daniel, pelo suporte e amor constante, sem o qual\neste trabalho n\u00e3o seria poss\u00edvel.\n\n\u00c0 minha namorada Greice, companheira, parceira e amiga, pelo seu amor e paci\u00eancia.\n\nAo meu orientador, prof. Roberto Lotufo, pelos conhecimentos transmitidos.\n\nA todos amigos, novos e antigos, pelos momentos de descontra\u00e7\u00e3o proporcionados.\n\n\u00c0 CAPES, pelo apoio financeiro.\n\nix\n\n\n\nSum\u00e1rio\n\nLista de Figuras xiii\n\nLista de Tabelas xvii\n\n1 Introdu\u00e7\u00e3o 1\n1.1 Motiva\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 Organiza\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n\n2 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es 9\n2.1 Conven\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\n2.1.1 Imagens, dados e entradas . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.1.2 Estruturas de Dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.1.3 Nota\u00e7\u00e3o de La\u00e7os . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.1.4 Opera\u00e7\u00f5es de Arrowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n2.2 Defini\u00e7\u00f5es de Watershed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n2.2.1 Transformada Watershed . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n2.2.2 Imers\u00e3o (Flooding-WT) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.2.3 Dist\u00e2ncia Topogr\u00e1fica (TD-WT) . . . . . . . . . . . . . . . . . . . . . . . . 16\n2.2.4 Condi\u00e7\u00e3o Local (LC-WT) . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n2.2.5 Watershed por Transformada Imagem-Floresta (IFT-WT) . . . . . . . . . . . 22\n2.2.6 Watershed Cut (WC-WT) . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n2.2.7 Rela\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n3 Algoritmos de Watershed 31\n3.1 Algoritmo Vincent e Soille de Imers\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . 31\n\n3.1.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n3.2 Algoritmo Fila de Prioridade Beucher e Meyer . . . . . . . . . . . . . . . . . . . . 38\n\n3.2.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n3.3 Algoritmo Dijsktra-Moore de Caminhos M\u00ednimos de Meyer . . . . . . . . . . . . . 41\n\n3.3.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n3.4 Algoritmo Hill Climbing de Meyer . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n\n3.4.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n3.5 Algoritmo Berge de Caminhos M\u00ednimos de Meyer . . . . . . . . . . . . . . . . . . . 48\n\nxi\n\n\n\nxii SUM\u00c1RIO\n\n3.5.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n3.6 Algoritmo Componentes Conexos de Bieniek e Moga . . . . . . . . . . . . . . . . . 51\n\n3.6.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n3.7 Algoritmo Union-Find de Meijster e Roerdink . . . . . . . . . . . . . . . . . . . . . 56\n\n3.7.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.8 Algoritmo IFT de Lotufo e Falc\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n\n3.8.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.9 Algoritmo C\u00f3digo de Corrente de Sun, Yang e Ren . . . . . . . . . . . . . . . . . . 64\n\n3.9.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.10 Algoritmo Zona de Empate de Audigier, Lotufo e Couprie . . . . . . . . . . . . . . 69\n\n3.10.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71\n3.11 Algoritmo Tobog\u00e3 Invariante a Ordem de Lin et al. . . . . . . . . . . . . . . . . . . 72\n\n3.11.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n3.12 Algoritmo Imers\u00e3o Invariante a Ordem de Lin et al. . . . . . . . . . . . . . . . . . . 77\n\n3.12.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\n3.13 Algoritmo Caminhos M\u00ednimos de Osma-Ruiz et al. . . . . . . . . . . . . . . . . . . 82\n\n3.13.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86\n3.14 Algoritmo Watershed Cut de Cousty et al. . . . . . . . . . . . . . . . . . . . . . . . 88\n\n3.14.1 Implementa\u00e7\u00e3o Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n\n4 An\u00e1lise Cr\u00edtica dos Algoritmos 95\n4.1 An\u00e1lise Comparativa de Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . 95\n\n4.1.1 Resolu\u00e7\u00e3o de Zonas Planas . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\n4.1.2 Aplica\u00e7\u00f5es Pr\u00e1ticas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n\n4.2 An\u00e1lise Comparativa das Implementa\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . 116\n4.2.1 Explora\u00e7\u00e3o da Imagem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117\n4.2.2 Endere\u00e7amento de Caminhos . . . . . . . . . . . . . . . . . . . . . . . . . . 119\n4.2.3 Rotula\u00e7\u00e3o de Caminhos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\n4.2.4 Descoberta e Rotula\u00e7\u00e3o de M\u00ednimos Regionais . . . . . . . . . . . . . . . . 120\n4.2.5 Estruturas de Dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n4.2.6 Considera\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\n4.3 An\u00e1lise de Desempenho do Tempo de Execu\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . 123\n4.3.1 An\u00e1lise de Complexidade . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\n4.3.2 Considera\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\n\n4.4 An\u00e1lise de Paralelismo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n\n5 Considera\u00e7\u00f5es Finais 137\n5.1 Conclus\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n5.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n\nRefer\u00eancias bibliogr\u00e1ficas 141\n\nA Framework de Processamento de Imagens 145\n\n\n\nLista de Figuras\n\n1.1 Exemplo de aplica\u00e7\u00e3o da transformada watershed com marcadores atrav\u00e9s de recons-\ntru\u00e7\u00e3o morfol\u00f3gica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n1.2 Exemplo de aplica\u00e7\u00e3o de transformada watershed na identifica\u00e7\u00e3o de regi\u00f5es homo-\ng\u00eaneas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n\n1.3 Exemplos de resultados das defini\u00e7\u00f5es TZ-IFT-WT e WC-WT nas imagens beef e\ncsample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n\n1.4 Compara\u00e7\u00e3o de etapas obtidas em momentos equivalentes em dois tipos de algorit-\nmos. 1\u00aa Coluna: Largura (Imers\u00e3o). 2\u00aa Coluna: Profundidade (Caminhos M\u00ednimos). . 7\n\n2.1 Exemplo de opera\u00e7\u00f5es de inser\u00e7\u00e3o e remo\u00e7\u00e3o sobre uma estrutura de fila hier\u00e1rquica,\ncom 4 n\u00edveis e prioridade por ordem ascendente . . . . . . . . . . . . . . . . . . . . 12\n\n2.2 Exemplo de compress\u00e3o de caminhos sobre uma estrutura union-find. (a) Conjuntos\ncom ra\u00edzes em a e g ap\u00f3s opera\u00e7\u00f5es Link, (b) Conjuntos ap\u00f3s opera\u00e7\u00f5es de Find, com\ncaminhos comprimidos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\n2.3 Exemplo de padroniza\u00e7\u00e3o para as opera\u00e7\u00f5es de Arrowing indicando valores utilizados\nem dois casos. (a) Intervalo poss\u00edvel, definido para vizinhan\u00e7a-8, (b) Arrowing entre\npixels de exemplo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n2.4 Exemplo da intui\u00e7\u00e3o da simula\u00e7\u00e3o de inunda\u00e7\u00e3o no perfil de uma superf\u00edcie . . . . . 15\n2.5 Exemplo da intui\u00e7\u00e3o da simula\u00e7\u00e3o de chuva no perfil de uma superf\u00edcie . . . . . . . 16\n2.6 Aplica\u00e7\u00e3o da defini\u00e7\u00e3o Flooding-WT sobre uma imagem exemplo, representando o\n\nresultado em cada limiar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.7 Aplica\u00e7\u00e3o da defini\u00e7\u00e3o TD-WT sobre o grafo LCG de uma imagem exemplo, repre-\n\nsentando o resultado em cada passo verificando-se as arestas para cada pixel . . . . . 19\n2.8 Aplica\u00e7\u00e3o do lower completion sobre uma imagem exemplo com zonas planas. Re-\n\npresenta\u00e7\u00e3o dos n\u00edveis de cinza de acordo com os valores da imagem em escala [0,25]. 21\n2.9 Aplica\u00e7\u00e3o da defini\u00e7\u00e3o LC-WT sobre um corte do grafo LCG, feito aleatoriamente\n\npara remo\u00e7\u00e3o de solu\u00e7\u00f5es m\u00faltiplas, de uma imagem exemplo, representando o resul-\ntado em cada passo verificando-se as arestas para cada pixel, . . . . . . . . . . . . . 23\n\n2.10 Grafo exemplificando o empate de custos considerando-se W o m\u00e1ximo em um ca-\nminho terminado no pixel p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n2.11 Aplica\u00e7\u00e3o da defini\u00e7\u00e3o IFT-WT sobre o grafo MOG de uma imagem exemplo, re-\npresentando o resultado em cada passo pela propaga\u00e7\u00e3o do r\u00f3tulo para os vizinhos\nconectados pelo MOG de cada pixel j\u00e1 rotulado, resolvendo empates aleatoriamente . 25\n\nxiii\n\n\n\nxiv LISTA DE FIGURAS\n\n2.12 Aplica\u00e7\u00e3o da defini\u00e7\u00e3o IFT-WT sobre o grafo MOG de uma imagem exemplo, re-\npresentando o resultado em cada passo pela propaga\u00e7\u00e3o do r\u00f3tulo para os vizinhos\nconectados pelo MOG de cada pixel j\u00e1 rotulado, aplicando r\u00f3tulo TZ em caso de\nempate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\n2.13 Constru\u00e7\u00e3o do grafo do watershed cut a partir de uma imagem exemplo, aplicando os\nvalores m\u00ednimos dos pixels em quest\u00e3o de (a) nas arestas em (b) . . . . . . . . . . . 26\n\n2.14 Subgrafos m\u00ednimos em destaque, correspondentes aos m\u00ednimos regionais . . . . . . 27\n2.15 Grafo exemplificando a extens\u00e3o de componentes conexos . . . . . . . . . . . . . . 28\n2.16 Grafo de exemplo completo com subgrafos m\u00ednimos e alturas m\u00ednimas . . . . . . . . 28\n2.17 Aplica\u00e7\u00e3o do WC-WT sobre grafo constru\u00eddo a partir de imagem exemplo . . . . . . 29\n2.18 Gr\u00e1fico indicando os relacionamentos entre as defini\u00e7\u00f5es de transformada watershed\n\na respeito das bacias hidrogr\u00e1ficas . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\n3.1 Problema de ader\u00eancia a defini\u00e7\u00e3o Flooding-WT pelo algoritmo Imers\u00e3o. (a) Ima-\ngem, (b) resultado da defini\u00e7\u00e3o Flooding-WT, (c) resultado do algoritmo Imers\u00e3o (N8) 34\n\n3.2 Exemplo de inexist\u00eancia de linha divis\u00f3ria na imers\u00e3o de Vincent e Soille. (a) Ima-\ngem, (b) resultado da defini\u00e7\u00e3o Flooding-WT e algoritmo Imers\u00e3o (N4) . . . . . . . 35\n\n3.3 Diverg\u00eancia de solu\u00e7\u00f5es do algoritmo Imers\u00e3o. (a) Imagem, (b) varredura raster, (c)\nvarredura anti-raster (N4) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n\n3.4 An\u00e1lise de r\u00f3tulos no algoritmo Imers\u00e3o. (a) Ordem de visita\u00e7\u00e3o em varredura raster,\n(b) r\u00f3tulos para (a), (c) ordem de visita\u00e7\u00e3o em varredura anti-raster, (d) r\u00f3tulos para (c) 36\n\n3.5 Fila de Prioridade. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . . . . . 40\n3.6 Dijkstra-Moore de Caminhos M\u00ednimos. (a) Imagem, (b) Resultado (N4) . . . . . . . 43\n3.7 C\u00e1lculo do upstream para uma imagem de exemplo, com o downstream indicado por\n\nsetas a partir dos pixels de origem. . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n3.8 Hill Climbing (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . . . . . . . . 46\n3.9 Berge com custo TD-WT. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . 50\n3.10 Componentes Conexos. (a) Imagem, (b) Resultado em raster, (c) Resultado em anti-\n\nraster (N4) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n3.11 Constru\u00e7\u00e3o do DAG. (a) Imagem sem zonas planas, (b) DAG . . . . . . . . . . . . . 59\n3.12 Union-Find. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . . . . . . . . . 59\n3.13 IFT. (a) Imagem, (b) Resultado, (c) Floresta resultante com ra\u00edzes em cinza. (N4) . . 63\n3.14 C\u00f3digo de Corrente. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . . . . 67\n3.15 Zona de Empate da IFT. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . . 71\n3.16 Tobog\u00e3 Invariante a Ordem. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . 75\n3.17 Imers\u00e3o Invariante a Ordem. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . 80\n3.18 Caminhos M\u00ednimos. (a) Imagem, (b) Resultado (N4) . . . . . . . . . . . . . . . . . 86\n3.19 Watershed Cut. (a) Imagem, (b) Resultado, (c) Grafo correspondente (N4) . . . . . . 91\n\n4.1 Imagens utilizadas para experimento de resolu\u00e7\u00e3o de zonas planas. (a) Original - f,\n(b) ap\u00f3s remo\u00e7\u00e3o de zonas planas - lc. . . . . . . . . . . . . . . . . . . . . . . . . . 106\n\n4.2 Resultado dos algoritmos (a) IFT e (b) Berge-MaxLex aplicando custo combinado\nsobre imagem com zonas planas f . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n\n\n\nLISTA DE FIGURAS xv\n\n4.3 Resultados dos algoritmos (a) IFT-Rand e (b) Berge-Max aplicando custo m\u00e1ximo\nsobre imagem com zonas planas f . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n\n4.4 Resultado dos algoritmos (a) IFT-Rand e (b) Berge-Max aplicando custo m\u00e1ximo\nsobre imagem sem zonas planas lc . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\n\n4.5 Zonas de Empate com (a) custo m\u00e1ximo e lexicogr\u00e1fico sobre imagem com zonas\nplanas f, e com custo m\u00e1ximo sobre (b) a imagem com zonas planas f e (c) sem zonas\nplanas lc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n\n4.6 Zonas de empate de custo m\u00e1ximo sobre (a) imagem beef e (b) beef sem zonas planas.\n(c) Zona de empate de custo m\u00e1ximo e lexicogr\u00e1fico sobre imagem beef. (d) Subtra-\n\u00e7\u00e3o entre (a) e (b), indicando pontos resolvidos por lower completion. (e) Subtra\u00e7\u00e3o\nentre (b) e (c), indicando pontos onde apenas o custo lexicogr\u00e1fico resolve o empate . 111\n\n4.7 Zonas de empate de custo m\u00e1ximo sobre (a) imagem csample e (b) csample sem zonas\nplanas. (c) Zonas de empate de custo m\u00e1ximo e lexicogr\u00e1fico sobre imagem csample.\n(d) Subtra\u00e7\u00e3o entre (a) e (b). (e) Subtra\u00e7\u00e3o entre (b) e (c). . . . . . . . . . . . . . . . 112\n\n4.8 Etapas da aplica\u00e7\u00e3o beef para gera\u00e7\u00e3o da imagem para segmenta\u00e7\u00e3o por transformada\nwatershed utilizando marcadores indiretamente . . . . . . . . . . . . . . . . . . . . 113\n\n4.9 Compara\u00e7\u00e3o de resultados das defini\u00e7\u00f5es atrav\u00e9s de algoritmos aplicados na imagem\nbeef preparada por marcadores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n\n4.10 Etapas da aplica\u00e7\u00e3o concrete para segmenta\u00e7\u00e3o de regi\u00f5es homog\u00eaneas . . . . . . . 115\n4.11 Compara\u00e7\u00e3o de resultados das defini\u00e7\u00f5es de watershed atrav\u00e9s de algoritmos, na apli-\n\nca\u00e7\u00e3o de identifica\u00e7\u00e3o de regi\u00f5es homog\u00eaneas . . . . . . . . . . . . . . . . . . . . . 116\n4.12 Gr\u00e1fico comparativo do tempo de execu\u00e7\u00e3o m\u00e9dio dos algoritmos em segundos por\n\nn\u00famero de pixels, para imagens com zonas planas e sem filtragem . . . . . . . . . . 125\n4.13 Gr\u00e1fico comparativo do tempo de execu\u00e7\u00e3o m\u00e9dio dos algoritmos em segundos por\n\nn\u00famero de pixels, para imagens sem zonas planas e sem filtragem . . . . . . . . . . 127\n\nA.1 Exemplo de transforma\u00e7\u00e3o de (a) imagem em (b) vetor unidimensional . . . . . . . . 146\nA.2 Exemplo de tratamento das bordas na transforma\u00e7\u00e3o de (a) imagem com borda em\n\n(b) vetor com borda, onde estes pixels s\u00e3o intercalados . . . . . . . . . . . . . . . . 149\n\n\n\nLista de Tabelas\n\n4.1 Medi\u00e7\u00f5es sobre a aplica\u00e7\u00e3o de dete\u00e7\u00e3o de regi\u00f5es homog\u00eaneas . . . . . . . . . . . . 115\n4.2 Resumo das caracter\u00edsticas dos algoritmos estudados . . . . . . . . . . . . . . . . . 131\n4.3 M\u00ednimos regionais por imagens e por tamanhos . . . . . . . . . . . . . . . . . . . . 132\n4.4 M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algo-\n\nritmo, e desempenho relativo, para imagens com zonas planas n\u00e3o filtradas . . . . . . 132\n4.5 M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algo-\n\nritmo, e desempenho relativo, para imagens com zonas planas filtradas . . . . . . . . 132\n4.6 Perda de desempenho percentual para os algoritmos, por tamanho de imagem, entre\n\nas imagens com zonas planas filtradas e n\u00e3o filtradas . . . . . . . . . . . . . . . . . 133\n4.7 M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algo-\n\nritmo, e desempenho relativo, para imagens sem zonas planas n\u00e3o filtradas . . . . . . 133\n4.8 M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algo-\n\nritmo, e desempenho relativo, para imagens sem zonas planas e filtradas . . . . . . . 134\n4.9 Perda de desempenho percentual para os algoritmos, por tamanho de imagem, entre\n\nas imagens sem zonas planas filtradas e n\u00e3o filtradas . . . . . . . . . . . . . . . . . . 134\n4.10 Compara\u00e7\u00e3o de desempenho para os algoritmos por tamanho de imagem, entre as\n\nimagens sem filtragem com e sem zonas planas . . . . . . . . . . . . . . . . . . . . 135\n\nxvii\n\n\n\nTrabalhos Publicados Pelo Autor\n\n1. A. K\u00f6rbes, R. Lotufo. \u201cAnalysis of the watershed algorithms based on the Breadth-First and Depth-First\nexploring methods\u201d. In SIBGRAPI\u201909, pg. 133-140, Rio de Janeiro, Brazil, Oct. 2009. IEEE Computer\nSociety.\n\n2. A. K\u00f6rbes, G. B. Vitor, J. V. Ferreira, R. Lotufo. \u201cA proposal for a parallel watershed transform algo-\nrithm for real-time segmentation\u201d. In Proceedings of Workshop de Vis\u00e3o Computacional WVC\u20192009,\nSo Paulo, Brazil, Sep. 2009. D\u00edsponivel em http://iris.sel.eesc.usp.br/wvc2009/\nWVC2009_CD.rar.\n\n3. A. K\u00f6rbes, R. Lotufo. \u201cOn Watershed Transform: Plateau Treatment and Influence of the Different\nDefinitions in Real Applications\u201d. In IWSSIP\u20192010, accepted, Rio de Janeiro, Brazil, Jun. 2010.\n\n4. R. Lotufo, R. Machado, A. K\u00f6rbes, R. Ramos. \u201cAdessowiki on-line collaborative scientific program-\nming platform\u201d. In WikiSym \u201909: Proceedings of the 5th International Symposium on Wikis and Open\nCollaboration, pages 1-6, New York, NY, USA, 2009. ACM.\n\nxix\n\n\n\nCap\u00edtulo 1\n\nIntrodu\u00e7\u00e3o\n\nTarefas de segmenta\u00e7\u00e3o de imagens s\u00e3o recorrentes em sistemas de vis\u00e3o computacional, onde\ndeseja-se identificar regi\u00f5es de acordo com certas caracter\u00edsticas, constituindo geralmente uma etapa\nintermedi\u00e1ria de um sistema maior, onde os resultados da segmenta\u00e7\u00e3o ser\u00e3o utilizados para outros\nprocedimentos. Desta forma, deseja-se que este seja robusto, forne\u00e7a regi\u00f5es bem delimitadas e deta-\nlhado o suficiente para que sua interpreta\u00e7\u00e3o seja realizada corretamente. A segmenta\u00e7\u00e3o de imagens\nn\u00e3o \u00e9 um problema trivial, sendo amplamente investigado na literatura atrav\u00e9s de diversas aborda-\ngens e analisado em problemas espec\u00edficos para obten\u00e7\u00e3o dos resultados desejados. De forma geral,\nas t\u00e9cnicas existentes s\u00e3o classificadas em duas categorias: detec\u00e7\u00e3o de bordas ou descontinuidades e\ncrescimento de regi\u00f5es [1], sendo a transformada watershed classificada na segunda categoria.\n\nA transformada watershed prop\u00f5e uma abordagem morfol\u00f3gica para o problema de segmenta-\n\u00e7\u00e3o de imagens, interpretando estas como superf\u00edcies, onde cada pixel corresponde a uma posi\u00e7\u00e3o e\nos n\u00edveis de cinza determinam as altitudes. A partir desta no\u00e7\u00e3o, deseja-se ent\u00e3o identificar bacias\nhidrogr\u00e1ficas, definidas por m\u00ednimos regionais e suas regi\u00f5es de dom\u00ednio. Este conceito, estudado\nh\u00e1 muito tempo para defini\u00e7\u00f5es de linhas de divis\u00e3o da \u00e1gua [2], foi introduzido no estudo de ima-\ngens digitais por Digabel e Lantu\u00e9joul [3], e mais tarde, j\u00e1 denominada transformada watershed foi\nutilizada por Beucher e Lantu\u00e9joul [4] com o mesmo objetivo, identificar regi\u00f5es em uma superf\u00edcie,\ndetectando seus contornos. Estas propostas introdut\u00f3rias, juntamente com o trabalho em segmenta\u00e7\u00e3o\nmorfol\u00f3gica de Meyer e Beucher [5], estabeleceram o uso da transformada watershed.\n\nIntuitivamente, a transformada watershed trata de encontrar os pontos em uma superf\u00edcie onde\numa gota d\u2019\u00e1gua possa escorrer para dois m\u00ednimos regionais diferentes. Esta analogia pode ser tam-\nb\u00e9m criada inversamente, onde um n\u00edvel d\u2019\u00e1gua \u00e9 elevado atrav\u00e9s de uma superf\u00edcie, inundando a\npartir dos m\u00ednimos regionais, e, nos pontos onde \u00e1guas provenientes de m\u00ednimos diferentes se toca-\nrem ergue-se uma barreira, que constitui a linha de divis\u00e3o das bacias. Conceitualmente equivalentes,\nestas no\u00e7\u00f5es s\u00e3o formalizadas diversamente, onde as primeiras abordagens buscam imitar direta-\nmente o processo intuitivo [6, 7]. Entretanto, tais conceitos foram demonstrados serem equivalentes\na problemas cl\u00e1ssicos da computa\u00e7\u00e3o, e assim, defini\u00e7\u00f5es mais recentes optam por uma abordagem\nrelacionada a problemas de otimiza\u00e7\u00e3o de custos de caminhos em grafos [8, 9].\n\nEste trabalho trata de uma an\u00e1lise sistem\u00e1tica dos algoritmos da transformada watershed, que\nimplementam as diversas defini\u00e7\u00f5es existentes. Para tal efeito, considerou-se a literatura a partir da\nintrodu\u00e7\u00e3o da primeira transformada r\u00e1pida, em 1991, por Vincent e Soille [6], at\u00e9 os trabalhos re-\ncentes de Cousty et al. [9]. Na mesma linha, outros autores realizaram trabalhos similares, como\n\n1\n\n\n\n2 Introdu\u00e7\u00e3o\n\nHagyard, Razaz e Atkin [10] com a primeira an\u00e1lise de desempenho comparando os algoritmos de\nVincent e Soille [6] e Meyer [7], medindo seus tempos de execu\u00e7\u00e3o com implementa\u00e7\u00f5es eficientes,\nonde, apesar de j\u00e1 existente, o algoritmo de Beucher e Meyer [11] n\u00e3o foi inclu\u00eddo. Roerdink e Meijs-\nter revisitaram a \u00e1rea no ano 2000, realizando uma an\u00e1lise extensiva das tr\u00eas defini\u00e7\u00f5es existentes at\u00e9\no momento e dos seis algoritmos que as implementavam, verificando a corretude destes e seu modo\nde funcionamento [12]. Ap\u00f3s Roerdink e Meijster, mais recentemente, as defini\u00e7\u00f5es necessitaram de\numa revis\u00e3o, dada a inclus\u00e3o de novas t\u00e9cnicas, sendo poss\u00edvel ent\u00e3o relacion\u00e1-las com base em seus\nresultados te\u00f3ricos [13]. Neste trabalho os relacionamentos entre as defini\u00e7\u00f5es s\u00e3o estendidos aos\nalgoritmos, analisando a literatura sistematicamente, de modo a produzir um revis\u00e3o atualizada sobre\no assunto.\n\nAssim, este trabalho resume a literatura de algoritmos de transformada watershed buscando ser o\nmais amplo poss\u00edvel dentro do assunto. Desta forma, catorze algoritmos foram encontrados com a de-\nnomina\u00e7\u00e3o de watershed - cobrindo vastamente a \u00e1rea - e utilizando t\u00e9cnicas e conceitos embasados\nem defini\u00e7\u00f5es ou nas no\u00e7\u00f5es intuitivas de determina\u00e7\u00e3o de bacias hidrogr\u00e1ficas. Sabe-se da equiva-\nl\u00eancia dos algoritmos de watershed com segmenta\u00e7\u00e3o fuzzy conexa, entretanto, este m\u00e9todo n\u00e3o foi\ninclu\u00eddo [14]. De forma a uniformizar este conhecimento, optou-se por reproduzir em pseudoc\u00f3digo\nos algoritmos citados, e, atrav\u00e9s de uma nota\u00e7\u00e3o comum, buscar equival\u00eancia em funcionalidades,\naproximando pontos onde os algoritmos executam tarefas similares. Em paralelo, buscou-se tamb\u00e9m\nproduzir programas operacionais utilizando a linguagem Python [15] e que fossem o mais pr\u00f3ximas\no poss\u00edvel dos pseudoc\u00f3digos, utilizando para isto as abstra\u00e7\u00f5es necess\u00e1rias em termos de dimensio-\nnalidade e limita\u00e7\u00f5es de dom\u00ednio.\n\nEste trabalho foi desenvolvido utilizando o ambiente Adessowiki 1 como ferramenta de suporte\nao gerenciamento dos documentos e programas necess\u00e1rios. Neste ambiente, operado como uma\nwiki, s\u00e3o geradas p\u00e1ginas web contendo texto estruturado e c\u00f3digo Python execut\u00e1vel, capaz de gerar\nelementos como imagens para compor o resultado final desejado [16]. Al\u00e9m disso, o conte\u00fado do\ntexto pode ser continuamente mantido e atualizado de forma colaborativa, sendo uma fonte din\u00e2mica\nde informa\u00e7\u00f5es sobre a transformada watershed.\n\n1.1 Motiva\u00e7\u00e3o\n\nAplica\u00e7\u00f5es da transformada watershed s\u00e3o comuns na literatura em diversas \u00e1reas do proces-\nsamento de imagens. Seu uso \u00e9 em geral associado a algum gradiente, seja morfol\u00f3gico ou n\u00e3o,\nprovendo uma imagem pr\u00e9-processada adequada \u00e0 segmenta\u00e7\u00e3o de regi\u00f5es via transformada wa-\ntershed. Um problema comum em tais abordagens, conhecido na literatura e tratado de diversas\nformas, \u00e9 a supersegmenta\u00e7\u00e3o, gerando muito mais regi\u00f5es do que o esperado e/ou desejado para a\nimagem de entrada. De modo a reduzir estes problemas, as imagens de gradiente podem ser simplifi-\ncadas, seja utilizando filtros, como por exemplo o fechamento, ou marcadores em uma reconstru\u00e7\u00e3o\nmorfol\u00f3gica, diminuindo o n\u00famero de m\u00ednimos regionais, e por consequ\u00eancia o n\u00famero de regi\u00f5es\nidentificadas. Uma abordagem pr\u00f3pria da transformada watershed \u00e9 o uso de marcadores como en-\ntrada, provendo a classe de watershed por marcadores, mais eficiente por eliminar uma etapa usual\nde pr\u00e9-processamento.\n\n1http://www.adessowiki.org\n\n\n\n1.1 Motiva\u00e7\u00e3o 3\n\nA aplica\u00e7\u00e3o cl\u00e1ssica da transformada watershed \u00e9 na segmenta\u00e7\u00e3o de regi\u00f5es para p\u00f3s-proces-\nsamento destas, como medi\u00e7\u00e3o de \u00e1rea, per\u00edmetro, etc. A Fig. 1.1 apresenta uma aplica\u00e7\u00e3o onde\ndeseja-se medir a \u00e1rea interna (sem gordura) do bife, equivalente \u00e0 quantidade de carne neste. Para\nisto aplica-se sobre a imagem de entrada filtros morfol\u00f3gicos de fechamento e fechamento por \u00e1rea,\njunto com opera\u00e7\u00f5es de limiariza\u00e7\u00e3o, eros\u00e3o e dilata\u00e7\u00e3o, obtendo assim marcadores externos e inter-\nnos \u00e0 regi\u00e3o desejada [17]. Utilizando estes marcadores processa-se uma reconstru\u00e7\u00e3o morfol\u00f3gica\nna imagem inversa, for\u00e7ando a cria\u00e7\u00e3o de apenas dois m\u00ednimos regionais. Aplica-se ent\u00e3o a trans-\nformada watershed, detectando duas regi\u00f5es correspondentes aos marcadores. Pode-se ent\u00e3o calcular\na \u00e1rea da regi\u00e3o desejada e apresentar o contorno desta sobre a imagem original, como na Fig. 1.1.\nEste constitui um exemplo t\u00edpico de uso, onde a imagem \u00e9 filtrada e a transformada \u00e9 utilizada para\ndetec\u00e7\u00e3o da regi\u00e3o de interesse.\n\n(a) Imagem beef e marcadores (b) Imagem beef e contorno obtido atrav\u00e9s de\nwatershed\n\nFig. 1.1: Exemplo de aplica\u00e7\u00e3o da transformada watershed com marcadores atrav\u00e9s de reconstru\u00e7\u00e3o\nmorfol\u00f3gica\n\nApesar do problema de supersegmenta\u00e7\u00e3o recorrente \u00e0 transformada watershed, este pode ser\nusado de forma ben\u00e9fica em algumas aplica\u00e7\u00f5es. Um exemplo poss\u00edvel \u00e9 relacionado \u00e0 detec\u00e7\u00e3o de\nregi\u00f5es homog\u00eaneas, apresentado na Fig. 1.2 [17]. Nesta aplica\u00e7\u00e3o, deseja-se medir a \u00e1rea de tais\nregi\u00f5es, sendo aplicado para isto um algoritmo convencional de watershed sobre uma imagem de gra-\ndiente filtrada por contraste. Neste caso, ocorre severa supersegmenta\u00e7\u00e3o, devido ao grande n\u00famero\nde m\u00ednimos regionais. Entretanto, nas regi\u00f5es de textura homog\u00eanea, se formam componentes cone-\nxos de \u00e1rea maior que podem ser separados dos demais por um filtro de \u00e1rea. Para corre\u00e7\u00e3o de ru\u00eddos\ndentro destas regi\u00f5es, aplica-se um filtro de fechamento por \u00e1rea, que os elimina dentro do crit\u00e9rio da\naplica\u00e7\u00e3o. Pode-se dizer que neste caso a transformada watershed \u00e9 aplicada como um detector de\ntexturas. Na Fig. 1.2 s\u00e3o apresentados os contornos obtidos utilizando esta t\u00e9cnica.\n\nConforme mencionado anteriormente, a transformada watershed \u00e9 formalizada atrav\u00e9s de diversas\ndefini\u00e7\u00f5es com solu\u00e7\u00f5es produzidas por diversos algoritmos. Nas aplica\u00e7\u00f5es apresentadas nas Figs.\n1.1 e 1.2, intencionalmente, estas particularidades n\u00e3o foram especificadas. A raz\u00e3o para isto \u00e9 a\nno\u00e7\u00e3o geral de que os resultados das v\u00e1rias transformadas watershed s\u00e3o equivalentes, n\u00e3o sendo\ncomum na literatura a especifica\u00e7\u00e3o de qual algoritmo e defini\u00e7\u00e3o foram utilizados para obten\u00e7\u00e3o de\nresultados nas aplica\u00e7\u00f5es. Assim, as defini\u00e7\u00f5es Flooding-WT [6], TD-WT [7], LC-WT [18], IFT-\nWT [19], TZ-IFT-WT [20] e WC-WT [9] s\u00e3o revisitadas neste trabalho, de forma a determinar sua\n\n\n\n4 Introdu\u00e7\u00e3o\n\n(a) Imagem csample (b) Regi\u00f5es segmentadas da imagem csample\npor watershed\n\n(c) Contornos fechados das regi\u00f5es homog\u00ea-\nneas da imagem csample\n\nFig. 1.2: Exemplo de aplica\u00e7\u00e3o de transformada watershed na identifica\u00e7\u00e3o de regi\u00f5es homog\u00eaneas\n\ninflu\u00eancia no resultado dos algoritmos. Apesar de as diferen\u00e7as entre as defini\u00e7\u00f5es serem contidas\nna zona de empate [21], com exce\u00e7\u00e3o do WC-WT e Flooding-WT, nem sempre estas diferen\u00e7as\npodem ser dadas como equivalentes. A Fig. 1.3 apresenta os dois exemplos de aplica\u00e7\u00e3o anteriores\nutilizando-se transformadas diferentes. No caso das imagens (a) e (b), a diferen\u00e7a de \u00e1rea medida \u00e9\nde 1,1%, e na imagem (c) s\u00e3o detectadas 7 regi\u00f5es a menos do que em (d). Nesta compara\u00e7\u00e3o, as\nimagens em (a) e (c) correspondem \u00e0 defini\u00e7\u00e3o TZ-IFT-WT e as imagens (b) e (d) correspondem\n\u00e0 defini\u00e7\u00e3o WC-WT. Para muitas aplica\u00e7\u00f5es estas diferen\u00e7as podem ser descartadas, tratadas como\nru\u00eddo ou erro, e consideradas equivalentes. No entanto, casos especiais podem ser influenciados por\nestes resultados e deve-se ent\u00e3o tomar os devidos cuidados.\n\nA principal investiga\u00e7\u00e3o neste trabalho \u00e9 relativa \u00e0 diversidade de algoritmos e como estes se\nrelacionam com as defini\u00e7\u00f5es da transformada watershed. S\u00e3o estudados 14 algoritmos da literatura,\npor ordem de apari\u00e7\u00e3o: Imers\u00e3o [6], Fila de Prioridade [11], Dijkstra-Moore de Caminhos M\u00ednimos,\nHill-Climbing e Berge de Caminhos M\u00ednimos [7], Componentes Conexos [18], Union-Find [22], IFT\n[19], C\u00f3digo de Corrente [23], Zona de Empate [20], Tobog\u00e3 Invariante a Ordem e Imers\u00e3o Invariante\na Ordem [24], Caminhos M\u00ednimos [25] e Watershed Cut [9]. Al\u00e9m da rela\u00e7\u00e3o com as defini\u00e7\u00f5es, nem\nsempre explicitadas nas publica\u00e7\u00f5es dos algoritmos, o comportamento destes tamb\u00e9m motivou este\n\n\n\n1.2 Objetivos 5\n\n(a) TZ-IFT-WT (b) WC-WT\n\n(c) TZ-IFT-WT (d) WC-WT\n\nFig. 1.3: Exemplos de resultados das defini\u00e7\u00f5es TZ-IFT-WT e WC-WT nas imagens beef e csample\n\ntrabalho, implicando no estudo das t\u00e9cnicas de implementa\u00e7\u00e3o, formas de utiliza\u00e7\u00e3o de estruturas de\ndados, e a busca por uma classifica\u00e7\u00e3o mais refinada.\n\nA busca por tal classifica\u00e7\u00e3o destes algoritmos parte inicialmente dos princ\u00edpios intuitivos da imer-\ns\u00e3o e da gota d\u2019\u00e1gua. Estes, vistos sob a perspectiva de explora\u00e7\u00e3o de v\u00e9rtices em grafos, tornam-se\nsimilares \u00e0s buscas em largura e em profundidade, respectivamente. Entretanto, apesar de serem\nestrat\u00e9gias fundamentalmente diferentes, os resultados finais produzidos pelos algoritmos s\u00e3o pra-\nticamente iguais, com diferen\u00e7as sutis, conforme mencionado anteriormente e explorado em mais\nprofundidade no Cap. 4. A Fig. 1.4 apresenta os algoritmos de Imers\u00e3o de Vincent e Soille e de\nCaminhos M\u00ednimos de Osma-Ruiz, comparando seus resultados parciais de modo a ressaltar a clas-\nsifica\u00e7\u00e3o em busca em largura e profundidade.\n\n1.2 Objetivos\n\nO objetivo principal deste trabalho \u00e9 produzir uma revis\u00e3o sistem\u00e1tica atualizada da literatura\nsobre a transformada watershed, restrita ao m\u00e9todo cl\u00e1ssico, desconsiderando abordagens por marca-\ndores, hier\u00e1rquicas, estoc\u00e1sticas, etc., visto que estas s\u00e3o especializa\u00e7\u00f5es para determinados tipos de\nproblemas. Como parte integrante de tal revis\u00e3o, tem-se como objetivo a identifica\u00e7\u00e3o das caracte-\nr\u00edsticas principais de cada algoritmo, possibilitando a classifica\u00e7\u00e3o destes, bem como a generaliza\u00e7\u00e3o\n\n\n\n6 Introdu\u00e7\u00e3o\n\nem categorias. Deseja-se tamb\u00e9m associar cada algoritmo \u00e0 defini\u00e7\u00e3o correspondente, muitas vezes\nn\u00e3o reportada pelos autores originais, ou implementada parcialmente. Nestes \u00faltimos casos, os al-\ngoritmos s\u00e3o corrigidos em sua especifica\u00e7\u00e3o, quando n\u00e3o s\u00e3o mudan\u00e7as que influenciem na ordem\ndestes nem em sua arquitetura geral. Desta forma, deseja-se produzir uma cole\u00e7\u00e3o consistente de\nalgoritmos da transformada watershed, solidificando conhecimentos esparsos e confusos na literatura\ndo assunto.\n\nEntre as principais compara\u00e7\u00f5es realizadas neste estudo, est\u00e1 a classifica\u00e7\u00e3o de acordo com a\nvisita\u00e7\u00e3o e associa\u00e7\u00e3o com a busca em largura e em profundidade, consideradas t\u00e9cnicas cl\u00e1ssicas\nno estudo de algoritmos. Caracter\u00edsticas como as t\u00e9cnicas de uso de endere\u00e7os de pixels, rotula\u00e7\u00e3o\nde caminhos, descoberta de m\u00ednimos regionais, e os usos das diferentes estruturas de dados tamb\u00e9m\nmostram-se interessantes para auxiliar na compara\u00e7\u00e3o entre os algoritmos. An\u00e1lises de desempenho,\ncomplexidade e possibilidades de paralelismo tamb\u00e9m s\u00e3o necess\u00e1rias para se obter uma revis\u00e3o\ncompleta, indicando os algoritmos com tend\u00eancia a obter melhor desempenho.\n\n1.3 Organiza\u00e7\u00e3o\nEsta disserta\u00e7\u00e3o est\u00e1 organizada da seguinte forma: o Cap. 2 apresenta as conven\u00e7\u00f5es e nota\u00e7\u00f5es\n\nutilizadas, al\u00e9m das defini\u00e7\u00f5es da transformada watershed, apresentadas conforme apari\u00e7\u00e3o na litera-\ntura, utilizando exemplos com imagens num\u00e9ricas de modo a ressaltar as diferen\u00e7as. O Cap. 3 revisa\nos algoritmos da transformada watershed, em ordem cronol\u00f3gica, ressaltando as suas caracter\u00edsticas,\ncomportamento e padronizando o pseudoc\u00f3digo, bem como oferecendo uma implementa\u00e7\u00e3o Python\npara cada um deles. No Cap. 4, s\u00e3o feitas an\u00e1lises comparativas entre as caracter\u00edsticas dos algorit-\nmos, dos resultados e t\u00e9cnicas referentes \u00e0 resolu\u00e7\u00e3o de zonas planas, de desempenho do programa\nPython e de paralelismo, incluindo uma breve revis\u00e3o bibliogr\u00e1fica neste \u00faltimo t\u00f3pico. No Cap. 5\nas contribui\u00e7\u00f5es deste trabalho s\u00e3o discutidas, e trabalhos futuros s\u00e3o propostos para sua continui-\ndade. O Ap\u00eandice A apresenta o framework para processamento de imagens desenvolvido de modo\na abstrair problemas comuns na implementa\u00e7\u00e3o de algoritmos como a transformada watershed.\n\n\n\n1.3 Organiza\u00e7\u00e3o 7\n\n(a) (b)\n\n(c) (d)\n\n(e) (f)\n\n(g) (h)\n\n(i) (j)\n\nFig. 1.4: Compara\u00e7\u00e3o de etapas obtidas em momentos equivalentes em dois tipos de algoritmos. 1\u00aa\nColuna: Largura (Imers\u00e3o). 2\u00aa Coluna: Profundidade (Caminhos M\u00ednimos).\n\n\n\nCap\u00edtulo 2\n\nDefini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nNeste cap\u00edtulo, s\u00e3o apresentadas as defini\u00e7\u00f5es e conven\u00e7\u00f5es adotadas para compreens\u00e3o deste\ntrabalho. S\u00e3o expostas as formas de uso das imagens, al\u00e9m de padr\u00f5es utilizados nos algoritmos. Em\nseguida, a transformada watershed \u00e9 introduzida e as defini\u00e7\u00f5es e equa\u00e7\u00f5es existentes na literatura\ns\u00e3o detalhadas. Procura-se com este cap\u00edtulo solidificar fundamentos necess\u00e1rios para a compreens\u00e3o\ndos algoritmos e sua padroniza\u00e7\u00e3o, para posterior especifica\u00e7\u00e3o individual.\n\n2.1 Conven\u00e7\u00f5es\nNesta se\u00e7\u00e3o s\u00e3o apresentadas as nomenclaturas para as imagens dependendo de seu uso, opera\u00e7\u00f5es\n\ncomuns em estruturas de dados, procedimentos nos algoritmos, al\u00e9m dos tipos de la\u00e7o de repeti\u00e7\u00e3o\nfor utilizados na especifica\u00e7\u00e3o dos algoritmos. Os algoritmos de transformada watershed t\u00eam uma\ncaracter\u00edstica particular, que permite sua f\u00e1cil extens\u00e3o para qualquer dimens\u00e3o, necessitando apenas\nde uma rela\u00e7\u00e3o de ordem para os valores e uma rela\u00e7\u00e3o de vizinhan\u00e7a entre os pixels. Nesta se\u00e7\u00e3o\ndefine-se a forma como abstraem-se estes elementos das imagens.\n\n2.1.1 Imagens, dados e entradas\n\nToda imagem I \u00e9 considerada uma fun\u00e7\u00e3o I : D ? [hmin, hmax ], onde D ? NN \u00e9 o dom\u00ednio da\nimagem, [hmin, hmax ] ? R o intervalo de valores poss\u00edveis e N \u00e9 o n\u00famero de dimens\u00f5es da imagem.\nDenota-se por I(p) o valor de p ? D. Pixels pertencentes ao dom\u00ednio s\u00e3o representados com as\nletras p, q, u e v , conforme necessidade e nesta ordem. No entanto, deve-se tomar o cuidado para\nque a representa\u00e7\u00e3o multidimensional seja fact\u00edvel, normalmente vista como: 2D uma imagem em\nn\u00edvel de cinza; 3D um s\u00f3lido - geralmente obtido de imagens m\u00e9dicas - onde as regi\u00f5es segmentadas\nser\u00e3o volumes deste s\u00f3lido, ou uma sequ\u00eancia de imagens; 4D s\u00f3lidos ao longo do tempo - tamb\u00e9m\nadvindos de imagens m\u00e9dicas em geral - com as regi\u00f5es correspondendo a volumes no tempo.\n\nA entrada para todos os algoritmos \u00e9 uma imagem im e a sa\u00edda \u00e9 a imagem de r\u00f3tulos inteiros\npositivos lab. Em alguns casos, a imagem de entrada necessita ser pr\u00e9-processada para remo\u00e7\u00e3o\nde zonas planas, passando a ser mantida em lc, com mesmo dom\u00ednio. Nos algoritmos que ne-\ncessitam de m\u00ednimos regionais para realizar seu processamento, estes s\u00e3o fornecidos no conjunto\nM = {m1, m2, ... , mn}, onde mi s\u00e3o subconjuntos contendo os pixels de cada m\u00ednimo regional i .\n\n9\n\n\n\n10 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nA maioria dos algoritmos apresentados no Cap. 3 fazem uso de imagens de trabalho, intermedi\u00e1-\nrias, para c\u00e1lculo de dist\u00e2ncias geod\u00e9sicas, denotadas dist , ou de endere\u00e7os de outros pixels, neste\ncaso adr . A rela\u00e7\u00e3o de vizinhan\u00e7a de um pixel p \u00e9 dada por N(p), onde este \u00e9 um subconjunto de\nD, contendo os pixels conectados a p, de acordo com uma regra pr\u00e9-estabelecida, como por exemplo\nvizinhan\u00e7a-4 ou 8 em 2D e vizinhan\u00e7a-6 ou 26 em 3D. Nesta rela\u00e7\u00e3o ainda pode-se estabelecer duas\nrestri\u00e7\u00f5es, N +(p) e N?(p) que, dada uma ordem de visita\u00e7\u00e3o dos pixels em N(p), incluindo p (e.g.\nraster, anti-raster), indicam respectivamente os pixels a serem visitados depois e antes de p. Em\nrela\u00e7\u00e3o aos algoritmos baseados em grafos, utiliza-se para estes a nota\u00e7\u00e3o tradicional G = (V , E , F ),\nonde V \u00e9 o conjunto de v\u00e9rtices, correspondente a D, isto \u00e9, cada pixel da imagem \u00e9 um n\u00f3 do grafo,\nE \u00e9 o conjunto de arestas, constru\u00eddo a partir da rela\u00e7\u00e3o de vizinhan\u00e7a, e F \u00e9 a fun\u00e7\u00e3o de mapeamento\nde valores nas arestas. As conven\u00e7\u00f5es de nomes adotadas aqui s\u00e3o mantidas nas especifica\u00e7\u00f5es dos\nalgoritmos, procurando assim uniformiz\u00e1-los e facilitar sua compara\u00e7\u00e3o e entendimento.\n\n2.1.2 Estruturas de Dados\nAs estruturas de dados utilizadas nos algoritmos de transformada watershed t\u00eam um papel fun-\n\ndamental na sua efici\u00eancia e em seu comportamento no que diz respeito \u00e0 ordem de varredura dos\npixels. S\u00e3o quatro as estruturas utilizadas pelos algoritmos, a fila (FIFO), pilha (LIFO), fila de priori-\ndade com FIFO e conjuntos union-find. No caso da fila, pilha e fila de prioridade, para simplicidade,\nquando o algoritmo em quest\u00e3o utiliza apenas uma inst\u00e2ncia da estrutura, esta n\u00e3o \u00e9 inclu\u00edda nos\npar\u00e2metros da opera\u00e7\u00e3o a ser realizada. Nos outros casos, o \u00faltimo par\u00e2metro especifica sobre qual\ndas inst\u00e2ncias deve ser realizada a a\u00e7\u00e3o, sendo denotado como opcional por colchetes. Um resumo\ndas opera\u00e7\u00f5es \u00e9 apresentado abaixo.\n\na. Estrutura de Fila (FIFO)\n\n\u2022 QueuePush(p, [queue]): Insere na fila queue o elemento p.\n\u2022 QueuePop([queue]): Remove e devolve da fila queue o elemento na or-\n\ndem FIFO.\n\u2022 QueueEmpty([queue]): Devolve verdadeiro se a fila queue estiver vazia,\n\nfalso caso contr\u00e1rio.\n\u2022 QueueClear([queue]): Esvazia a fila.\n\nb. Estrutura de Pilha (LIFO)\n\n\u2022 StackPush(p, [stack]): Insere na pilha stack o elemento p.\n\u2022 StackPop([stack]): Remove e devolve da pilha stack o elemento na ordem\n\nLIFO.\n\u2022 StackEmpty([stack]): Devolve verdadeiro se a pilha stack estiver vazia,\n\nfalso caso contr\u00e1rio.\n\nc. Estrutura de Fila Hier\u00e1quica (fila de prioridade) (Heap Queue, Priority Queue)\n\n\u2022 HeapQueuePush(p, v, [heap]): Insere na fila heap o elemento p com pri-\noridade v.\n\n\n\n2.1 Conven\u00e7\u00f5es 11\n\n\u2022 HeapQueuePop([heap]): Remove e devolve da fila heap o elemento de\nmaior prioridade.\n\n\u2022 HeapQueueEmpty([heap]): Devolve verdadeiro se a fila heap estiver va-\nzia, falso caso contr\u00e1rio.\n\n\u2022 HeapQueueContains(p, [heap]): Devolve verdadeiro se o elemento p es-\ntiver contido na fila heap.\n\n\u2022 HeapQueueRemove(p, [heap]): Remove da fila heap o elemento p.\n\nd. Estrutura de conjunto Union-Find:\n\n\u2022 MakeSet(x): Cria um conjunto {x}\n\n\u2022 Link(x,y): Conecta o elemento y a x\n\n\u2022 Find(x): Percorre o conjunto a partir de x at\u00e9 encontrar o elemento repre-\nsentativo deste, comprimindo o caminho, e o devolve\n\n\u2022 Union(x,y): Cria um novo conjunto a partir da uni\u00e3o dos conjuntos cujas\nra\u00edzes s\u00e3o x e y, transformando x na raiz de ambos\n\nA implementa\u00e7\u00e3o eficiente destas estruturas de dados foge ao escopo deste trabalho, sendo alvo\nespec\u00edfico da literatura de algoritmos e teoria da computa\u00e7\u00e3o [26, 27]; no entanto sua compreens\u00e3o \u00e9\nimportante. As estruturas de fila e pilha s\u00e3o bastante conhecidas, sendo listas mantidas em mem\u00f3ria\ncom comportamento especial para inser\u00e7\u00e3o e retirada de elementos seguindo as pol\u00edticas FIFO e LIFO\nrespectivamente. A fila de prioridade (ou fila hier\u00e1rquica), introduzida na transformada watershed por\nBeucher e Meyer [11], possui duas caracter\u00edsticas importantes que determinam a ordem de remo\u00e7\u00e3o\nde elementos, sendo a prioridade individual e o desempate por FIFO. Uma fila de prioridade pode\nser vista tamb\u00e9m como uma cole\u00e7\u00e3o de filas FIFO, uma para cada valor poss\u00edvel, onde insere-se os\nelementos na fila com seu valor respectivo e a remo\u00e7\u00e3o \u00e9 feita a partir da fila que n\u00e3o estiver vazia\ncorrespondente ao menor valor poss\u00edvel entre todas. A Fig. 2.1 exemplifica esta estrutura com 4\nopera\u00e7\u00f5es de inser\u00e7\u00e3o de elementos p, q, u e v com valores 2, 3, 3 e 1 respectivamente, e 4 remo\u00e7\u00f5es,\napresentando as suas duas caracter\u00edsticas principais, atrav\u00e9s da no\u00e7\u00e3o de v\u00e1rias filas.\n\nA estrutura de dados union-find n\u00e3o \u00e9 utilizada em sua totalidade em nenhum dos algoritmos,\nno entanto a sua opera\u00e7\u00e3o Find tem extensa influ\u00eancia, assim como a t\u00e9cnica de compress\u00e3o de\ncaminhos, sendo importante sua compreens\u00e3o neste contexto. A estrutura union-find consiste em\nutilizar elementos representativos para identificar conjuntos desconexos, armazenados em um mesmo\nespa\u00e7o. Assim, conjuntos s\u00e3o expandidos utilizando-se o elemento representativo - a raiz do conjunto\n- como elo entre todos os elementos de um conjunto. A opera\u00e7\u00e3o de conex\u00e3o no entanto n\u00e3o requer\nque um dos elementos seja a raiz, e assim, ao conectar dois elementos que n\u00e3o s\u00e3o raizes de conjuntos,\nformam-se caminhos at\u00e9 esta, pois na conex\u00e3o o novo elemento passa a ser ligado ao j\u00e1 existente, e\nconsequentemente \u00e0 raiz do conjunto. O atravessamento destes caminhos, necess\u00e1rio na uni\u00e3o de\ndois conjuntos e para identificar a raiz de um elemento qualquer, realiza ent\u00e3o a compress\u00e3o destes,\ndiminuindo o n\u00famero de saltos necess\u00e1rios at\u00e9 a raiz em uma pr\u00f3xima visita. A Fig. 2.2 apresenta em\n(a) dois conjuntos, cujas ra\u00edzes s\u00e3o os elementos a e g, e em (b) o estado do conjunto ap\u00f3s a execu\u00e7\u00e3o\nde uma opera\u00e7\u00e3o Find sobre o elemento e.\n\n\n\n12 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nFig. 2.1: Exemplo de opera\u00e7\u00f5es de inser\u00e7\u00e3o e remo\u00e7\u00e3o sobre uma estrutura de fila hier\u00e1rquica, com 4\nn\u00edveis e prioridade por ordem ascendente\n\nFig. 2.2: Exemplo de compress\u00e3o de caminhos sobre uma estrutura union-find. (a) Conjuntos com\nra\u00edzes em a e g ap\u00f3s opera\u00e7\u00f5es Link, (b) Conjuntos ap\u00f3s opera\u00e7\u00f5es de Find, com caminhos compri-\nmidos\n\n2.1.3 Nota\u00e7\u00e3o de La\u00e7os\n\nNa especifica\u00e7\u00e3o dos algoritmos buscou-se atentar a detalhes de nota\u00e7\u00e3o para evitar ambiguidades\nEsta an\u00e1lise \u00e9 feita em especial nos la\u00e7os de repeti\u00e7\u00e3o for, que, quando paraleliz\u00e1veis, s\u00e3o substitu\u00ed-\ndos por um la\u00e7o for all. Busca-se com esta conven\u00e7\u00e3o tamb\u00e9m resolver ambiguidades comuns em\nalgoritmos onde o la\u00e7o for all \u00e9 aplicado para denotar o s\u00edmbolo ?, ou apenas um la\u00e7o for sobre todos\nelementos de um conjunto. A an\u00e1lise destes la\u00e7os leva em considera\u00e7\u00e3o duas condi\u00e7\u00f5es: ordem, que\nimplica na itera\u00e7\u00e3o de um conjunto onde os elementos devem ser analisados segundo alguma regra\n(e.g. dom\u00ednio em raster, ordem de n\u00edveis de cinza); e concorr\u00eancia, que implica processamento de\numa itera\u00e7\u00e3o afetar outras.\n\nDesta forma, la\u00e7os for denotam concorr\u00eancia, e podem ou n\u00e3o implicar em ordem espec\u00edfica, de-\npendendo do tipo de conjunto sendo varrido. Assim, um la\u00e7o for dever\u00e1 iterar sobre cada elemento\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 13\n\ndo conjunto de forma sequencial, pois os resultados de uma itera\u00e7\u00e3o interferem ou s\u00e3o utilizados nas\npr\u00f3ximas. A ordem de an\u00e1lise do conjunto depende da sua representa\u00e7\u00e3o. Conjuntos especificados\npor uma letra, como a itera\u00e7\u00e3o no dom\u00ednio da imagem D, n\u00e3o implicam ordem, sendo que os elemen-\ntos deste podem ser iterados de forma arbitr\u00e1ria. Intervalos, como [hmin, hmax ] devem ser iterados na\nordem do menor para o maior elemento.\n\nLa\u00e7os for all denotam que n\u00e3o h\u00e1 interfer\u00eancia entre as opera\u00e7\u00f5es e que o conjunto pode ser\niterado em qualquer ordem. Desta forma, as opera\u00e7\u00f5es efetuadas dentro do la\u00e7o s\u00e3o independentes\npara cada elemento do conjunto em quest\u00e3o, tamb\u00e9m denotado na literatura como parallel for ou\nparfor [28]. Um la\u00e7o for all tem o mesmo efeito do s\u00edmbolo ?, utilizado em pontos de inicializa\u00e7\u00e3o\nde alguns algoritmos, denotando a possibilidade de se efetuar a mesma opera\u00e7\u00e3o sobre todos os\nelementos do conjunto paralelamente. Para que isto seja poss\u00edvel, as opera\u00e7\u00f5es efetuadas n\u00e3o devem\ninfluenciar o processamento umas das outras. Nesta an\u00e1lise, considera-se que as opera\u00e7\u00f5es sobre\nestruturas de dados s\u00e3o at\u00f4micas.\n\n2.1.4 Opera\u00e7\u00f5es de Arrowing\nAs opera\u00e7\u00f5es de arrowing se repetem entre os algoritmos por serem estrat\u00e9gias comuns para cons-\n\ntru\u00e7\u00e3o de caminhos m\u00ednimos. No entanto, pequenas varia\u00e7\u00f5es, como valores de retorno e estrat\u00e9gias\nde uso ocorrem, e, por esse motivo o corpo destas opera\u00e7\u00f5es n\u00e3o \u00e9 explicitado, apenas funcionalidade\nb\u00e1sica, de forma a facilitar a compreens\u00e3o dos algoritmos, abstraindo sua especifica\u00e7\u00e3o nestes.\n\nA opera\u00e7\u00e3o Arrow (p, q) tem como objetivo indicar, atrav\u00e9s de um n\u00famero, a dire\u00e7\u00e3o relativa\nde p para q, construindo o caminho de m\u00e1xima inclina\u00e7\u00e3o. O valor devolvido por esta fun\u00e7\u00e3o \u00e9\npadronizado diferentemente dependendo do algoritmo, geralmente um n\u00famero de 1 a N, onde N \u00e9\no n\u00famero m\u00e1ximo de vizinhos de cada pixel, ocorrendo varia\u00e7\u00e3o entre os algoritmos no intervalo\nutilizado. A Fig. 2.3 apresenta uma poss\u00edvel padroniza\u00e7\u00e3o de dire\u00e7\u00f5es, exemplificando o uso da\nopera\u00e7\u00e3o Arrow .\n\nPara recupera\u00e7\u00e3o do endere\u00e7o de um pixel q a partir do endere\u00e7o de um pixel p vizinho e um\nn\u00famero n em um intervalo definido \u00e9 utilizada a fun\u00e7\u00e3o Pointed (p, n). Esta fun\u00e7\u00e3o permite recuperar\no endere\u00e7o do pr\u00f3ximo pixel em um caminho. Assim, dada uma padroniza\u00e7\u00e3o conforme exemplo da\nFig. 2.3, pode-se recuperar o vizinho deste indicado por n. Na Fig. 2.3 considera-se uma vizinhan\u00e7a-\n8, onde cada vizinho de p em (a) \u00e9 indicado por um n\u00famero inteiro no intervalo [1, 8], e em (b),\napresenta-se o posicionamento dos pixels p, q e u, e o direcionamento desejado\n\nTem-se ent\u00e3o que Arrow (p, q) = 2 e Arrow (u, q) = 1, de acordo com o representado pelas linhas\ntracejadas. A recupera\u00e7\u00e3o destes caminhos \u00e9 dada por Pointed (p, 2) = q e Pointed (u, 1) = q, onde\nq \u00e9 o endere\u00e7o do pixel vizinho do pixel endere\u00e7ado por p.\n\n2.2 Defini\u00e7\u00f5es de Watershed\nNesta se\u00e7\u00e3o \u00e9 realizada uma breve revis\u00e3o das defini\u00e7\u00f5es da transformada watershed nas quais\n\nos algoritmos estudados neste trabalho se baseiam para produ\u00e7\u00e3o de seus resultados. Estas defini-\n\u00e7\u00f5es s\u00e3o: imers\u00e3o (Flooding-WT) [6], dist\u00e2ncia topogr\u00e1fica (TD-WT) [7], condi\u00e7\u00e3o local (LC-WT)\n[29], transformada imagem-floresta com custo m\u00e1ximo de caminho (IFT-WT) [19], zona de empate\nda IFT-WT (TZ-IFT-WT) [20] e watershed cut (WC-WT) [9]. A abordagem escolhida neste assunto\n\n\n\n14 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nFig. 2.3: Exemplo de padroniza\u00e7\u00e3o para as opera\u00e7\u00f5es de Arrowing indicando valores utilizados em\ndois casos. (a) Intervalo poss\u00edvel, definido para vizinhan\u00e7a-8, (b) Arrowing entre pixels de exemplo\n\n\u00e9 suficiente para a compreens\u00e3o do funcionamento dos algoritmos, entretanto um estudo mais apro-\nfundado nas defini\u00e7\u00f5es e nos seus relacionamentos \u00e9 apresentado por Audigier [13] e por Roerdink\ne Meijster [12]. \u00c9 importante ressaltar o fato de que a exist\u00eancia de diversas defini\u00e7\u00f5es implica em\ndiferentes espa\u00e7os de solu\u00e7\u00f5es, que podem ser relacionados [21].\n\n2.2.1 Transformada Watershed\n\nA transformada watershed \u00e9 baseada na no\u00e7\u00e3o de divis\u00e3o de \u00e1guas de uma superf\u00edcie, tal como um\nterreno, onde deseja-se identificar as bacias de capta\u00e7\u00e3o dos m\u00ednimos regionais. A localiza\u00e7\u00e3o destas\nlinhas d\u2019\u00e1gua pode ser dada intuitivamente de duas formas: elevando um n\u00edvel d\u2019\u00e1gua uniformemente\nna superf\u00edcie e tra\u00e7ando as linhas nos pontos onde \u00e1guas provenientes de dois m\u00ednimos regionais\ndiferentes se tocam, ou localizando os pontos onde uma gota d\u2019\u00e1gua pode escorrer para m\u00ednimos\ndiferentes. A primeira no\u00e7\u00e3o pode ser visualizada na Fig. 2.4, onde apresenta-se uma superf\u00edcie e um\nn\u00edvel d\u2019\u00e1gua, que eleva-se, identificando os m\u00ednimos regionais por cores diferentes e tra\u00e7ando linhas\nonde as \u00e1guas se encontram.\n\nA segunda no\u00e7\u00e3o tem sua representa\u00e7\u00e3o na Fig. 2.5, onde, na mesma superf\u00edcie, s\u00e3o apresentadas\nsequencialmente gotas d\u2019\u00e1gua sobre esta, tra\u00e7ando linhas divis\u00f3rias nos pontos onde uma gota poderia\nescorrer para dois m\u00ednimos regionais diferentes. No entanto, em imagens, a localiza\u00e7\u00e3o destes pontos\npode n\u00e3o ser trivial, pois n\u00e3o s\u00e3o necessariamente m\u00e1ximos locais na superf\u00edcie - dois caminhos\ndistintos podem se unir e seguir para um mesmo m\u00ednimo regional - e torna-se complicada tamb\u00e9m a\nrepresenta\u00e7\u00e3o gr\u00e1fica.\n\nEstas no\u00e7\u00f5es intuitivas, chamadas princ\u00edpios de imers\u00e3o e de gota d\u2019\u00e1gua s\u00e3o fundamentais para a\ncompreens\u00e3o das defini\u00e7\u00f5es apresentadas a seguir. A aplica\u00e7\u00e3o destes sobre uma imagem \u00e9 feita\nde forma a considerar os n\u00edveis de cinza destas como os valores de altitude. Entretanto, para a\nobten\u00e7\u00e3o de contornos de objetos, em geral aplica-se um filtro derivativo sobre a imagem, para realce\ndas diferen\u00e7as onde estas atingem valores mais altos e sendo o local de posicionamento das linhas\ndo watershed. Uma estrat\u00e9gia bastante comum no \u00e2mbito da transformada watershed \u00e9 tamb\u00e9m a\nfiltragem de m\u00ednimos regionais para eliminar aqueles menos relevantes, e dessa forma obter regi\u00f5es\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 15\n\nFig. 2.4: Exemplo da intui\u00e7\u00e3o da simula\u00e7\u00e3o de inunda\u00e7\u00e3o no perfil de uma superf\u00edcie\n\nmais consistentes com o esperado.\n\n2.2.2 Imers\u00e3o (Flooding-WT)\n\nA defini\u00e7\u00e3o de imers\u00e3o [6], deste ponto em diante chamada Flooding-WT, busca simular o pro-\ncesso de submers\u00e3o de uma superf\u00edcie em \u00e1gua, baseando-se em um n\u00edvel de \u00e1gua ascendente e zonas\nde influ\u00eancia. Tomando uma imagem I, define-se uma recurs\u00e3o sobre os n\u00edveis de cinza no intervalo\n(hmin, hmax ], onde para cada n\u00edvel \u00e9 aplicado um limiar sobre a imagem e s\u00e3o calculadas as zonas de\ninflu\u00eancia do limiar atual em rela\u00e7\u00e3o as regi\u00f5es do limiar anterior. As zonas de influ\u00eancia, definidas\ncomo IZA(B), produzem como resultado regi\u00f5es onde a dist\u00e2ncia geod\u00e9sica de um pixel em A em\nrela\u00e7\u00e3o a um componente conexo de B \u00e9 estritamente menor que a qualquer outro componente co-\nnexo. A recurs\u00e3o \u00e9 inicializada com uma limiariza\u00e7\u00e3o em hmin. Ao final do processo, os pixels que\nn\u00e3o pertencerem a nenhuma zona de influ\u00eancia formam a linha de watershed [6]. Temos ent\u00e3o as\nregi\u00f5es para um n\u00edvel h definidas em Xh, e os limiares em Th. Considere minh os pixels pertencentes\na m\u00ednimos regionais no n\u00edvel h.\n\n\n\n16 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nFig. 2.5: Exemplo da intui\u00e7\u00e3o da simula\u00e7\u00e3o de chuva no perfil de uma superf\u00edcie\n\nXhmin = Thmin (2.1)\n\n?h ? (hmin, hmax ], Xh = minh ? IZTh (Xh?1) (2.2)\n\nW = DI?Xhmax (2.3)\n\nEsta defini\u00e7\u00e3o tamb\u00e9m \u00e9 vista como um esqueleto de zonas de influ\u00eancia (SKIZ) generalizado\npara uma imagem em n\u00edveis de cinza. A Fig. 2.6 apresenta um exemplo da defini\u00e7\u00e3o Flooding-WT.\nNo caso da aplica\u00e7\u00e3o real da defini\u00e7\u00e3o, deseja-se n\u00e3o somente identificar os pixels de watershed,\nmas tamb\u00e9m os r\u00f3tulos das regi\u00f5es, obtidas a partir das zonas de influ\u00eancia calculadas a partir dos\nm\u00ednimos regionais, rotulados estes unicamente na imagem. Nesta figura a defini\u00e7\u00e3o \u00e9 apresentada\npasso-a-passo, para todos os valores de h na imagem, calculando-se a zona de influ\u00eancia em rela\u00e7\u00e3o\naos n\u00edveis anteriores. Os pixels que n\u00e3o pertencerem a nenhuma zona de influ\u00eancia s\u00e3o denotados\ncom o r\u00f3tulo W. No entanto, deve-se ressaltar que esta rotula\u00e7\u00e3o n\u00e3o \u00e9 definitiva, sendo que a zona\nde influ\u00eancia \u00e9 recalculada e estes pixels podem passar a pertencer a outras bacias, como ocorre entre\nos n\u00edveis 3 e 4. O resultado para h = 9 \u00e9 o resultado final da defini\u00e7\u00e3o.\n\n2.2.3 Dist\u00e2ncia Topogr\u00e1fica (TD-WT)\nA defini\u00e7\u00e3o de dist\u00e2ncia topogr\u00e1fica, criada por Meyer [7], cria a no\u00e7\u00e3o de custo sobre uma su-\n\nperf\u00edcie digital considerando quaisquer dois pontos nesta, considerando-se as inclina\u00e7\u00f5es entre cada\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 17\n\nFig. 2.6: Aplica\u00e7\u00e3o da defini\u00e7\u00e3o Flooding-WT sobre uma imagem exemplo, representando o resultado\nem cada limiar\n\nponto e a dist\u00e2ncia geod\u00e9sica entre estes. De fato, o nome dist\u00e2ncia topogr\u00e1fica \u00e9 inapropriado por\nn\u00e3o se tratar de uma fun\u00e7\u00e3o do tipo dist\u00e2ncia, mas sim um custo de caminho. Desta forma, deseja-se\nidentificar os caminhos de custo \u00f3timo (m\u00ednimo) entre os pontos da imagem e os m\u00ednimos regionais, e\nassim, nos pontos amb\u00edguos, onde o custo \u00f3timo \u00e9 igual em rela\u00e7\u00e3o a dois m\u00ednimos diferentes, marca-\nse uma linha de watershed. A formaliza\u00e7\u00e3o desta defini\u00e7\u00e3o inicia-se pela no\u00e7\u00e3o de inclina\u00e7\u00e3o LS(p).\nPara simplifica\u00e7\u00e3o, consideramos que a dist\u00e2ncia geod\u00e9sica entre dois pixels adjacentes \u00e9 unit\u00e1ria.\n\nLS(p) = max\nq?N(p)?{p}\n\n(I(p) ? I(q)) (2.4)\n\nO custo para ir de um pixel p a um vizinho q \u00e9 definido em cost (p, q). Desta forma, temos que o\ncusto ser\u00e1 a rampa m\u00e1xima, ou caminho de m\u00e1xima inclina\u00e7\u00e3o, entre estes dois pixels.\n\n\n\n18 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\ncost (p, q) =\n\n???\n??\n\nLS(p) I(p) > I(q)\nLS(q) I(p) &lt;I(q)\n\nLS(p)+LS(q)\n2 I(p) = I(q)\n\n(2.5)\n\nA partir desta defini\u00e7\u00e3o, deduz-se a dist\u00e2ncia topogr\u00e1fica sobre um caminho ? = ?p0, ... , pn?\nqualquer como a soma dos custos entre os pixels adjacentes neste caminho. A dist\u00e2ncia topogr\u00e1fica,\nTI (p, q), entre dois pixels p = p0 e q = pn \u00e9 dada ent\u00e3o como a menor dist\u00e2ncia de todos os caminhos\nposs\u00edveis.\n\nTI (p, q) = min\n??[p q]\n\n(?\nn?1??\ni =0\n\ncost (pi , pi +1)\n\n)?\n(2.6)\n\nPode-se ent\u00e3o definir as bacias de capta\u00e7\u00e3o dos m\u00ednimos regionais da imagem, onde estes s\u00e3o\ndenotados por mi ? M sendo M o conjunto de todos os m\u00ednimos, como a minimiza\u00e7\u00e3o da fun\u00e7\u00e3o de\ndist\u00e2ncia topogr\u00e1fica entre qualquer p e os m\u00ednimos.\n\nCB(mi ) = {p ? D | ?mj ? M?{mi} : I(mi ) + TI (p, mi ) &lt;I(mj ) + TI (p, mj )} (2.7)\n\nAs linhas de watershed s\u00e3o obtidas pelo complemento das bacias, nos pixels onde a dist\u00e2ncia\ntopogr\u00e1fica n\u00e3o \u00e9 estritamente menor entre dois ou mais m\u00ednimos regionais diferentes.\n\nW (I) = I?\n??\n\nmi?M\n\nCB(mi ) (2.8)\n\nUma defini\u00e7\u00e3o derivada da dist\u00e2ncia topogr\u00e1fica, muito importante e \u00fatil na compreens\u00e3o dos\nalgoritmos de watershed e sua rela\u00e7\u00e3o com as defini\u00e7\u00f5es, \u00e9 o downstream. O downstream, represen-\ntado por ?, \u00e9 uma restri\u00e7\u00e3o sobre a rela\u00e7\u00e3o de vizinhan\u00e7a N(p), dada por um conjunto onde pertencem\napenas aqueles vizinhos com n\u00edvel de cinza menor que p e para os quais LS(p) \u00e9 m\u00e1ximo, ou seja,\naqueles com menor n\u00edvel de cinza.\n\n?(p) = {q ? N(p) | I(q) &lt;I(p) ? I(q) = min?u?N(p)I(u)} (2.9)\n\nA rela\u00e7\u00e3o ? cont\u00e9m os vizinhos de p para onde segue um caminho de m\u00e1xima inclina\u00e7\u00e3o, sendo\no fundamento de diversos algoritmos que realizam esta an\u00e1lise da vizinhan\u00e7a. O inverso desta, ??1,\nchamada de upstream define os vizinhos de p em que este est\u00e1 contido em ?. Seu c\u00e1lculo exige a\nverifica\u00e7\u00e3o das rela\u00e7\u00f5es ? de uma vizinhan\u00e7a expandida nos vizinhos dos vizinhos de p.\n\n??1(p) = {q ? N(p) | p ? ?(q)} (2.10)\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 19\n\nA Fig. 2.7 apresenta um exemplo da defini\u00e7\u00e3o TD-WT. Esta defini\u00e7\u00e3o possui solu\u00e7\u00e3o \u00fanica, e\npode ser obtida calculando-se os caminhos e dist\u00e2ncias topogr\u00e1ficas ou a partir da rela\u00e7\u00e3o ?, apli-\ncando r\u00f3tulo W quando os caminhos de m\u00e1xima inclina\u00e7\u00e3o indicados por esta levarem a dois ou mais\nm\u00ednimos regionais diferentes. Na Fig. 2.7 optou-se por apresentar os passos de an\u00e1lise dos caminhos\nda rela\u00e7\u00e3o ?, verificando para cada pixel os caminhos que partem deste e denotando-os com setas em\nvermelho e mantendo as setas j\u00e1 analisadas em verde. Ao analisar os caminhos, aplica-se o r\u00f3tulo\nobtido em todos os pixels deste. Nesta mesma figura, o segundo quadro apresentado corresponde ao\nLCG (Lower Complete Graph), que apresenta na forma de um grafo o downstream de todos os pixels\n[21].\n\nFig. 2.7: Aplica\u00e7\u00e3o da defini\u00e7\u00e3o TD-WT sobre o grafo LCG de uma imagem exemplo, representando\no resultado em cada passo verificando-se as arestas para cada pixel\n\nZonas Planas\n\nUm aspecto da defini\u00e7\u00e3o TD-WT se d\u00e1 em rela\u00e7\u00e3o \u00e0s zonas planas das imagens, onde o custo da\nfun\u00e7\u00e3o \u00e9 zerado. Este comportamento \u00e9 justificado, visto que o deslocamento nesta superf\u00edcie tem o\nmesmo custo em todas as dire\u00e7\u00f5es. A solu\u00e7\u00e3o apontada para este problema \u00e9 o uso de um algoritmo de\nremo\u00e7\u00e3o de zonas planas, onde todos os pixels que n\u00e3o pertencerem a um m\u00ednimo regional passam a\nter pelo menos um vizinho com n\u00edvel de cinza inferior. Este processo \u00e9 chamado de lower completion,\nsendo definido com rela\u00e7\u00e3o \u00e0s dist\u00e2ncias geod\u00e9sicas das bordas das zonas planas. A maior dist\u00e2ncia\nencontrada na imagem serve como par\u00e2metro para recalcular os valores dos pixels, em conjunto com\n\n\n\n20 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\ndist\u00e2ncias da borda e o n\u00edvel de cinza original. Desta forma, o Alg. 1 apresenta uma t\u00e9cnica simples\npara processamento do lower completion. Este algoritmo, baseado na proposta de Roerdink e Meijster\n[12], foi corrigido para tratamento correto de m\u00ednimos regionais.\n\nALGORITMO 1: Lower Completion\n\nEntrada: im: Imagem de n\u00edveis de cinza\nSaida: lc: Imagem lower-complete\n\n1: Initialise\n2: FICTITIOUS-PIXEL ?(-1,-1)\n3: cur_dist ? 0\n4: End\n\n5: for all p ? D do\n6: lc(p) ? 0\n7: if ?q ? N(p) | im(q) &lt;im(p) then\n8: QUEUEPUSH(p)\n9: lc(p) ?-1\n\n10: end if\n11: end for\n\n12: cur_dist ? 1\n13: QUEUEPUSH(FICTITIOUS-PIXEL)\n\n14: while QUEUEEMPTY() = false do\n15: p ?QUEUEPOP()\n16: if p = FICTITIOUS-PIXEL then\n17: if QUEUEEMPTY() = false then\n18: QUEUEPUSH(FICTITIOUS-PIXEL)\n19: cur_dist ? cur_dist + 1\n20: end if\n21: else\n22: lc(p) ?cur_dist\n23: for all q ? N(p) | im(q) = im(p) and lc(q) = 0 do\n24: QUEUEPUSH(q)\n25: lc(q) ?-1\n26: end for\n27: end if\n28: end while\n\n29: for all p ? D do\n30: if lc(p) = 0 then\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 21\n\n31: lc(p) ? cur_dist \u00d7 im(p)\n32: else\n33: lc(p) ? cur_dist \u00d7 im(p) + lc(p) ? 1\n34: end if\n35: end for\n\nDevido \u00e0 complexidade da defini\u00e7\u00e3o TD-WT em termos de c\u00e1lculo de custos, normalmente re-\nalizado como uma floresta de caminhos m\u00ednimos, a op\u00e7\u00e3o de implementa\u00e7\u00e3o mais comum desta \u00e9\natrav\u00e9s da rela\u00e7\u00e3o ? com procedimentos especiais para propaga\u00e7\u00e3o em zonas planas. Desta forma,\nn\u00e3o \u00e9 utilizado pr\u00e9-processamento, e em certa medida, a an\u00e1lise \u00e9 feita apenas nas regi\u00f5es onde \u00e9\nde fato necess\u00e1ria. A Fig. 2.8 apresenta em (a) um exemplo de imagem onde calcula-se o lower\ncompletion. Neste caso, a maior dist\u00e2ncia de borda tem valor 6, sendo o valor de refer\u00eancia utilizado\npara multiplicar pelos valores dos pixels e serem somados \u00e0s dist\u00e2ncias individuais das bordas. O\nresultado da remo\u00e7\u00e3o de zonas planas \u00e9 apresentado na Fig. 2.8 (b).\n\n(a) Imagem com zonas planas (b) Imagem ap\u00f3s\n\nFig. 2.8: Aplica\u00e7\u00e3o do lower completion sobre uma imagem exemplo com zonas planas. Representa-\n\u00e7\u00e3o dos n\u00edveis de cinza de acordo com os valores da imagem em escala [0,25].\n\n2.2.4 Condi\u00e7\u00e3o Local (LC-WT)\nDada a caracter\u00edstica da defini\u00e7\u00e3o TD-WT realizar uma otimiza\u00e7\u00e3o global dos caminhos poss\u00edveis\n\nna superf\u00edcie formada pela imagem, seu processamento em blocos paralelos requer diversos passos\nde sincroniza\u00e7\u00e3o. Buscando simplificar o projeto de um algoritmo paralelo [30], Bieniek e Moga\nremovem a condi\u00e7\u00e3o de unicidade da solu\u00e7\u00e3o da defini\u00e7\u00e3o TD-WT, degenerando-a na defini\u00e7\u00e3o de\ncondi\u00e7\u00e3o local, onde apenas informa\u00e7\u00f5es da vizinhan\u00e7a do pixel s\u00e3o utilizadas para determina\u00e7\u00e3o do\ncaminho de m\u00e1xima inclina\u00e7\u00e3o a que este pertence [18]. Assim, na defini\u00e7\u00e3o LC-WT, os pixels de\n\n\n\n22 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nwatershed, que garantiam a unicidade e resolu\u00e7\u00e3o de ambiguidades, passam a ser rotulados conforme\num dos m\u00ednimos em empate.\n\nNo entanto, esta altera\u00e7\u00e3o tem mais implica\u00e7\u00f5es na rela\u00e7\u00e3o ?(p), que passa a ser dada como um\ncaminho \u00fanico no LCG. A escolha de qual pixel vizinho determinar\u00e1 este r\u00f3tulo \u00e9 arbitr\u00e1ria dentro\ndo conjunto de op\u00e7\u00f5es v\u00e1lidas, sendo todas solu\u00e7\u00f5es poss\u00edveis. De forma simplificada, ? passa a\nconter o pixel vizinho com menor valor de cinza e menor que o pr\u00f3prio sendo analisado, ou em caso\nde empate, um destes, decidido arbitrariamente. As regi\u00f5es passam a ser definidas pela propaga\u00e7\u00e3o\ndos r\u00f3tulos dos m\u00ednimos regionais atrav\u00e9s dos seguintes princ\u00edpios, onde L corresponde ao r\u00f3tulo da\nregi\u00e3o:\n\n1. L(mi ) ?= L(mj ),?i ?= j , com mk sendo os m\u00ednimos regionais\n\n2. Para cada pixel p com ?(p) ?= ?,?q ? ?(p) com L(p) = L(q)\n\nA Fig. 2.9 apresenta um exemplo das poss\u00edveis solu\u00e7\u00f5es para a imagem utilizada. Dado que a\ndefini\u00e7\u00e3o LC-WT \u00e9 baseada na defini\u00e7\u00e3o TD-WT, modificam-se apenas os pixels de watershed, que\npassam a receber o r\u00f3tulo de um de seus vizinhos conectados no LCG. A defini\u00e7\u00e3o TD-WT tamb\u00e9m\npode ser vista como a transformada zona de empate da LC-WT, onde as m\u00faltiplas solu\u00e7\u00f5es s\u00e3o indi-\ncadas pelos pixels de watershed [21]. Assim, ao avaliar os caminhos a partir de cada pixel, quando\nestes levam a dois ou mais m\u00ednimos regionais diferentes, escolhe-se arbitrariamente um destes, geral-\nmente tomando como base a ordem de an\u00e1lise dos vizinhos, reduzindo ent\u00e3o o n\u00famero de arestas no\ngrafo direcionado (LCG), reduzindo tamb\u00e9m a complexidade do problema.\n\n2.2.5 Watershed por Transformada Imagem-Floresta (IFT-WT)\nDe forma similar a TD-WT, a defini\u00e7\u00e3o de transformada watershed pela transformada imagem-\n\nfloresta utiliza uma fun\u00e7\u00e3o de custo de caminho para obten\u00e7\u00e3o dos caminhos \u00f3timos em um grafo\nonde cada v\u00e9rtice corresponde a um pixel e o peso do arco \u00e9 obtido pela dire\u00e7\u00e3o em que se atravessa\neste, sendo utilizado o valor do pixel do v\u00e9rtice de fim. A fun\u00e7\u00e3o de custo do caminho utilizada pela\nIFT-WT, entretanto, \u00e9 composta de duas componentes, a primeira sendo o m\u00e1ximo do caminho, fmax ,\ne a segunda, utilizada em caso de empate na primeira, o custo lexicogr\u00e1fico, fd [19], [8].\n\nfmax (?v1, v2, ... , vn?) = max(I(v2), I(v3), ... , I(vn)) (2.11)\n\nfd (?v1, v2, ... , vn?) = max\nk?[0,n?1]\n\n(k : C[vn] = C[vn?k ]) (2.12)\n\nC[vn] = fmax (?v1, v2, ... , vn?) (2.13)\n\nA primeira componente, de maior import\u00e2ncia, simula a inunda\u00e7\u00e3o de uma superf\u00edcie, enquanto\na segunda faz com que a inunda\u00e7\u00e3o em superf\u00edcies planas ocorra a mesma velocidade a partir das\nbordas, vinda de m\u00ednimos diferentes. A componente fd representa a maior dist\u00e2ncia em um caminho\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 23\n\nFig. 2.9: Aplica\u00e7\u00e3o da defini\u00e7\u00e3o LC-WT sobre um corte do grafo LCG, feito aleatoriamente para\nremo\u00e7\u00e3o de solu\u00e7\u00f5es m\u00faltiplas, de uma imagem exemplo, representando o resultado em cada passo\nverificando-se as arestas para cada pixel,\n\nonde o valor de m\u00e1ximo se mant\u00e9m, ou seja, a dist\u00e2ncia at\u00e9 a borda da zona plana, onde ocorre o\nempate na primeira componente, ou seja, busca-se maximizar k que satisfa\u00e7a a condi\u00e7\u00e3o C[vn] =\nC[vn?k ]. Desta forma, definido o custo do caminho, aplica-se este na transformada imagem-floresta\n(IFT), utilizando como sementes - ra\u00edzes da floresta do grafo - os m\u00ednimos regionais ou marcadores\narbitr\u00e1rios. O resultado desta \u00e9 uma floresta de caminhos m\u00ednimos, onde o custo \u00e9 o m\u00e1ximo dos\narcos. Pode-se dizer ent\u00e3o que o resultado \u00e9 uma minimiza\u00e7\u00e3o de custos m\u00e1ximos.\n\nA defini\u00e7\u00e3o IFT-WT n\u00e3o apresenta solu\u00e7\u00e3o \u00fanica, nem utiliza r\u00f3tulos watershed para representa-\n\u00e7\u00e3o de pontos distantes igualmente de dois m\u00ednimos regionais. Esta \u00e9 uma consequ\u00eancia do uso do\ncusto m\u00e1ximo, conforme visto na Ref. [19], pois os m\u00e1ximos locais em um grafo podem ser atingidos\n- e por conseguinte rotulados - por qualquer um de seus vizinhos em empate tanto em custo m\u00e1ximo\nquanto lexicogr\u00e1fico. A Fig. 2.10 exemplifica este processo, assumindo que W > C(v ) e W > C(s).\nO custo final atribu\u00eddo a p ser\u00e1 W , independente de seu antecessor na floresta ser v ou s, sendo um\ncusto \u00f3timo, por\u00e9m possivelmente com r\u00f3tulos diferentes.\n\n\n\n24 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\n?\n\n????\n\n?\n\n????\n\n?\n\n? ?\n\n??\t?????\n?????\n???????\n\n(a)\n\nFig. 2.10: Grafo exemplificando o empate de custos considerando-se W o m\u00e1ximo em um caminho\nterminado no pixel p\n\nComo consequ\u00eancia, temos que as solu\u00e7\u00f5es da defini\u00e7\u00e3o IFT-WT formam um conjunto, denomi-\nnado ?. Inseridas neste conjunto, todas as solu\u00e7\u00f5es s\u00e3o v\u00e1lidas e \u00f3timas do ponto de vista da fun\u00e7\u00e3o\nde custo definida anteriormente. A Fig. 2.11 apresenta um exemplo de solu\u00e7\u00e3o para a imagem de-\nmonstrativa. Nesta solu\u00e7\u00e3o, parte-se do grafo que cont\u00e9m todas as solu\u00e7\u00f5es de ?, denominado MOG\n(Multipredecessor Optimal Graph), e, a partir das sementes iniciais, verifica-se seus vizinhos, deter-\nminando r\u00f3tulos para estes ou realizando cortes no grafo, para aplica\u00e7\u00e3o posterior do r\u00f3tulo. O MOG,\nassim como o LCG \u00e9 constru\u00eddo a partir de uma imagem sem zonas planas, sendo que no MOG,\ntodos os pixels vizinhos com n\u00edvel de cinza inferior pertencem ao conjunto de antecessores de um\nv\u00e9rtice, enquanto no LCG apenas os vizinhos com n\u00edvel de cinza m\u00ednimo e inferior na vizinhan\u00e7a s\u00e3o\nantecessores [21]. Procede-se desta forma, expandindo as regi\u00f5es j\u00e1 rotuladas at\u00e9 que todos os pixels\nsejam analisados, sendo o resultado final das setas em verde formadoras da floresta \u00f3tima.\n\nZona de Empate (TZ-IFT-WT)\n\nA zona de empate de uma defini\u00e7\u00e3o com solu\u00e7\u00f5es m\u00faltiplas qualquer pode ser dita como a solu\u00e7\u00e3o\nque unifica as outras, atribuindo um r\u00f3tulo especial onde h\u00e1 diferen\u00e7as entre as solu\u00e7\u00f5es poss\u00edveis\ncomo no caso da defini\u00e7\u00e3o TD-WT em rela\u00e7\u00e3o a LC-WT. Assim, no caso da IFT-WT, a zona de\nempate \u00e9 baseada no conjunto ?, que cont\u00e9m todas as solu\u00e7\u00f5es \u00f3timas. Para uma regi\u00e3o CBi , um\npixel v passa a pertencer a esta se e somente se pertencer a esta em todas as solu\u00e7\u00f5es poss\u00edveis.\nEm outras palavras, \u00e9 necess\u00e1rio que em todas as solu\u00e7\u00f5es exista um caminho entre o conjunto de\nsementes si e o pixel v em an\u00e1lise. Desta forma, os pixels que n\u00e3o pertencerem a nenhuma regi\u00e3o\nser\u00e3o contidos em T , formando a zona de empate [20].\n\nCBi = {v ? V , ?F ? ?, ??(si , v ) in F} (2.14)\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 25\n\nFig. 2.11: Aplica\u00e7\u00e3o da defini\u00e7\u00e3o IFT-WT sobre o grafo MOG de uma imagem exemplo, represen-\ntando o resultado em cada passo pela propaga\u00e7\u00e3o do r\u00f3tulo para os vizinhos conectados pelo MOG\nde cada pixel j\u00e1 rotulado, resolvendo empates aleatoriamente\n\nT = V?\n??\n\ni\n\nCBi (2.15)\n\nOs pixels contidos em T s\u00e3o representados na imagem resultante com um r\u00f3tulo especial TZ, cujo\nsignificado \u00e9 de permitir mais de uma solu\u00e7\u00e3o, n\u00e3o devendo ser visto como uma linha divis\u00f3ria entre\nas regi\u00f5es. A unifica\u00e7\u00e3o entre as solu\u00e7\u00f5es da IFT-WT permite diversas an\u00e1lises, como a robustez\nda segmenta\u00e7\u00e3o, afinamento das linhas, extens\u00e3o m\u00e1xima de objetos, al\u00e9m de estabelecer relaciona-\nmentos com as outras defini\u00e7\u00f5es [31], [21], [14]. A Fig. 2.12 apresenta a TZ-IFT-WT da imagem\ndemonstrativa. Assim como no exemplo da IFT-WT, inicia-se pelo MOG e pelos m\u00ednimos regionais,\npor\u00e9m neste caso, as setas vermelhas indicam os r\u00f3tulos vizinhos dos pixels que est\u00e3o sendo ana-\nlisados. Se estes forem consistentes - iguais - o pixel em quest\u00e3o o recebe, caso contr\u00e1rio, o pixel\npermite m\u00faltiplas solu\u00e7\u00f5es, e portanto pertence \u00e0 zona de empate, e ir\u00e1 propagar este r\u00f3tulo como\noutro qualquer.\n\n2.2.6 Watershed Cut (WC-WT)\n\nA defini\u00e7\u00e3o watershed cut \u00e9 baseada em opera\u00e7\u00f5es de corte de grafo sobre um grafo valorado nas\narestas. De modo a melhor compreender seu comportamento, inicia-se pela constru\u00e7\u00e3o do grafo a\npartir da imagem. Cada pixel da imagem corresponder\u00e1 a um v\u00e9rtice e ser\u00e1 adjacente aos v\u00e9rtices\ncorrespondentes aos pixels vizinhos. Os valores das arestas podem ser obtidos pelo m\u00e1ximo ou m\u00ed-\nnimo dos valores entre cada par de pixels correspondentes aos v\u00e9rtices, ou pode-se utilizar a diferen\u00e7a\nabsoluta entre estes, sendo a \u00faltima uma forma simples de c\u00e1lculo de gradiente [9]. A Fig. 2.13 apre-\nsenta em (a) a imagem demonstrativa e em (b) o grafo correspondente a esta, com os valores de aresta\nobtidos utilizando o m\u00ednimo entre os pixels.\n\n\n\n26 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nFig. 2.12: Aplica\u00e7\u00e3o da defini\u00e7\u00e3o IFT-WT sobre o grafo MOG de uma imagem exemplo, represen-\ntando o resultado em cada passo pela propaga\u00e7\u00e3o do r\u00f3tulo para os vizinhos conectados pelo MOG\nde cada pixel j\u00e1 rotulado, aplicando r\u00f3tulo TZ em caso de empate\n\n(a) Imagem\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n? ? ? ?\n\n(b) Grafo correspondente\n\nFig. 2.13: Constru\u00e7\u00e3o do grafo do watershed cut a partir de uma imagem exemplo, aplicando os\nvalores m\u00ednimos dos pixels em quest\u00e3o de (a) nas arestas em (b)\n\nA partir de um dado grafo, seguem duas defini\u00e7\u00f5es importantes para a compreens\u00e3o da defini\u00e7\u00e3o\nde watershed cut. A primeira delas define um subgrafo m\u00ednimo, que corresponde a um m\u00ednimo\nregional. Assim, dado um grafo G com fun\u00e7\u00e3o de valores F , um subgrafo X ser\u00e1 um m\u00ednimo de\nF com valor k se: (1) X \u00e9 conexo, (2) k \u00e9 o valor de qualquer aresta de X e (3) qualquer aresta\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 27\n\nadjancente a X tem valor estritamente maior que k [9]. O conjunto de subgrafos m\u00ednimos em F\n\u00e9 denotado por M(F ). Esta defini\u00e7\u00e3o \u00e9 extremamente importante no contexto da segmenta\u00e7\u00e3o por\ntransformada watershed, pois por consequ\u00eancia imp\u00f5e o n\u00famero de regi\u00f5es em que a imagem ser\u00e1\ndividida. Dada sua import\u00e2ncia, a Fig. 2.14 apresenta o grafo da Fig. 2.13 com seus subgrafos\nm\u00ednimos em destaque.\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n??\n\n?\n\n? ?\n\n?\n\n?\n\n??\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n(a)\n\nFig. 2.14: Subgrafos m\u00ednimos em destaque, correspondentes aos m\u00ednimos regionais\n\nVisto que s\u00e3o identificados tr\u00eas subgrafos m\u00ednimos na Fig. 2.14, logicamente ser\u00e3o obtidas tr\u00eas\nregi\u00f5es como resultado da aplica\u00e7\u00e3o da defini\u00e7\u00e3o de watershed cut. \u00c9 importante notar a defini\u00e7\u00e3o\ndiferente de m\u00ednimo regional para o watershed cut, que pode implicar na redu\u00e7\u00e3o do n\u00famero de\nregi\u00f5es segmentadas na imagem. Isto nos leva a segunda importante defini\u00e7\u00e3o, de extens\u00e3o, revisitada\na partir da proposta original de Bertrand [32, 9]. Sendo X e Y dois subgrafos de G, Y \u00e9 uma extens\u00e3o\nde X se X ? Y e cada componente conexo de Y cont\u00e9m exatamente um componente conexo de\nX . Intuitivamente, a extens\u00e3o implica em um subgrafo passar a ser adjacente de mais n\u00f3s vizinhos\nmantendo-se desconexo de outros componentes. A Fig. 2.15 apresenta um exemplo de extens\u00e3o,\nonde os componentes conexos s\u00e3o apresentados com cores diferentes, o subgrafo X \u00e9 ressaltado em\nnegrito, e arestas que pertencem a G mas n\u00e3o pertencem a Y s\u00e3o mostradas em pontilhado.\n\nPara completar as defini\u00e7\u00f5es necess\u00e1rias ao watershed cut, atribui-se tamb\u00e9m um valor a cada\nv\u00e9rtice do grafo, denominado altura m\u00ednima, denotado por F ?(x ), sendo o valor m\u00ednimo entre as\narestas conectadas ao v\u00e9rtice x [9]. Podendo ser calculado no momento da constru\u00e7\u00e3o do grafo, este\nvalor \u00e9 utilizado diversas vezes na obten\u00e7\u00e3o dos conjuntos de v\u00e9rtices no algoritmo. A Fig. 2.16\napresenta o grafo de exemplo completo com os valores de altura m\u00ednima.\n\nAssim, o watershed cut \u00e9 definido sobre um grafo valorado G = (V , E , F ), sendo S um sub-\nconjunto de E , e seu complemento S?. S satisfaz o princ\u00edpio da gota d\u2019\u00e1gua - e por consequ\u00eancia \u00e9\num watershed cut - se S? for uma extens\u00e3o de M(F ) e: [9]\n\n\n\n28 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\n? ?\n\n? ?\n\n? ?\n\n?\n\n?\n\n(a)\n\nFig. 2.15: Grafo exemplificando a extens\u00e3o de componentes conexos\n\n? ?\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n??\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n(a)\n\nFig. 2.16: Grafo de exemplo completo com subgrafos m\u00ednimos e alturas m\u00ednimas\n\n\u2022 Para qualquer aresta u = {x0, y0}? S h\u00e1 dois caminhos descendentes iniciando em\nx0 e y0 levando a m\u00ednimos diferentes e contidos em S?\n\n\u2022 F (u) ? F ({x0, x1}) (F (u) ? F ({y0, y1})), se os caminhos n\u00e3o forem triviais\n(n(?) > 1)\n\nDesta forma, S dever\u00e1 conter todas as arestas que dividem as regi\u00f5es do grafo em componentes\n(subgrafos) conexos. As linhas de divis\u00e3o entre as regi\u00f5es s\u00e3o definidas sobre arestas, e u \u00e9 uma aresta\nconectando quaisquer dois pontos de divisa entre regi\u00f5es. Ou seja, S \u00e9 um corte em G, contendo as\narestas que devem ser removidas de modo a se obter um watershed cut. No entanto, a defini\u00e7\u00e3o n\u00e3o\n\n\n\n2.2 Defini\u00e7\u00f5es de Watershed 29\n\nfornece uma solu\u00e7\u00e3o \u00fanica, sendo que podem existir v\u00e1rios conjuntos S que satisfa\u00e7am as condi\u00e7\u00f5es\nacima. A Fig. 2.17 mostra em (a) o grafo ap\u00f3s a opera\u00e7\u00e3o de corte e em (b) o resultado da rotula\u00e7\u00e3o\naplicada na imagem. As arestas pertencentes ao conjunto S s\u00e3o mostradas em pontilhado, e separam\nas regi\u00f5es da imagem, satisfazendo o princ\u00edpio da gota d\u2019\u00e1gua exposto acima. Na imagem (b) n\u00e3o\ns\u00e3o mostrados os m\u00ednimos regionais hachurados conforme os exemplos das defini\u00e7\u00f5es anteriores,\nvisto que seriam todos pixels vizinhos, contrariando a no\u00e7\u00e3o de divis\u00e3o em regi\u00f5es de acordo com os\ncomponentes conexos m\u00ednimos, comum \u00e0s outras defini\u00e7\u00f5es.\n\n? ?\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n??\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n(a) Grafo do WC-WT (b) R\u00f3tulos na imagem de\nsa\u00edda\n\nFig. 2.17: Aplica\u00e7\u00e3o do WC-WT sobre grafo constru\u00eddo a partir de imagem exemplo\n\n2.2.7 Rela\u00e7\u00f5es\nAs defini\u00e7\u00f5es da transformada watershed apresentadas acima podem ser relacionadas conforme\n\no trabalho de Audigier [13]. Para estabelecer estas rela\u00e7\u00f5es as imagens foram modeladas utilizando\ndois tipos de grafo em particular, o grafo MOG e LCG. Estes grafos permitem representar as solu\u00e7\u00f5es\nposs\u00edveis para a fun\u00e7\u00e3o de custo m\u00e1ximo e para a rela\u00e7\u00e3o ?. \u00c9 importante tamb\u00e9m compreender o\nsentido de uma transformada zona de empate: atrav\u00e9s desta se obt\u00e9m uma solu\u00e7\u00e3o \u00fanica para uma\ndefini\u00e7\u00e3o que fornece m\u00faltiplas solu\u00e7\u00f5es. A partir destes conceitos pode-se relacionar as defini\u00e7\u00f5es\nTD-WT, LC-WT, IFT-WT e TZ-IFT-WT. As principais rela\u00e7\u00f5es estabelecidas s\u00e3o [21]:\n\n1. Qualquer LC-WT \u00e9 tamb\u00e9m um IFT-WT.\n\n2. TD-WT \u00e9 a transformada zona de empate de LC-WT.\n\n3. As regi\u00f5es definidas por TZ-IFT-WT s\u00e3o um subconjunto das regi\u00f5es correspondentes de\nTD-WT.\n\n\n\n30 Defini\u00e7\u00f5es e Conven\u00e7\u00f5es\n\nPode-se a partir destes itens, considerando-se apenas as regi\u00f5es definidas pelas transformadas,\norganizar as informa\u00e7\u00f5es de relacionamentos em um gr\u00e1fico, apresentado na Fig. 2.18. A transfor-\nma\u00e7\u00e3o por zona de empate apresentada no gr\u00e1fico implica que pixels, que podem assumir diferentes\nr\u00f3tulos dada uma mesma defini\u00e7\u00e3o, passam a receber um r\u00f3tulo especial, como o r\u00f3tulo W e TZ\npara as defini\u00e7\u00f5es TD-WT e TZ-IFT-WT respectivamente. Neste gr\u00e1fico n\u00e3o s\u00e3o inclu\u00eddas as defi-\nni\u00e7\u00f5es Flooding-WT e WC-WT, pois, no caso da primeira, n\u00e3o h\u00e1 rela\u00e7\u00f5es estabelecidas, e no caso\nda segunda, esta \u00e9 definida como uma opera\u00e7\u00e3o de corte de grafo, possuindo rela\u00e7\u00f5es pr\u00f3prias, onde\nocorrem equival\u00eancias entre as defini\u00e7\u00f5es [33].\n\nFig. 2.18: Gr\u00e1fico indicando os relacionamentos entre as defini\u00e7\u00f5es de transformada watershed a\nrespeito das bacias hidrogr\u00e1ficas\n\nOs algoritmos apresentados no Cap. 3 s\u00e3o todos relacionados com uma das defini\u00e7\u00f5es da trans-\nformada watershed apresentadas aqui. Desta forma, pode-se estender o gr\u00e1fico dos relacionamentos\ndiretamente \u00e0 estes. No pr\u00f3ximo cap\u00edtulo s\u00e3o detalhados os algoritmos de transformada watershed\ndispon\u00edveis na literatura, apresentando-os no contexto das defini\u00e7\u00f5es formais, e ressaltando suas ca-\nracter\u00edsticas principais.\n\n\n\nCap\u00edtulo 3\n\nAlgoritmos de Watershed\n\nNeste cap\u00edtulo s\u00e3o avaliados 14 algoritmos de transformada watershed dispon\u00edveis na literatura.\nEsta revis\u00e3o busca uniformizar as informa\u00e7\u00f5es sobre estes, como sua motiva\u00e7\u00e3o para cria\u00e7\u00e3o, qual\ndefini\u00e7\u00e3o implementa, corretamente ou n\u00e3o, funcionamento geral, caracteriza\u00e7\u00e3o como busca em\nlargura ou profundidade, detalhes espec\u00edficos de implementa\u00e7\u00e3o, al\u00e9m da descri\u00e7\u00e3o dos algoritmos\nutilizando pseudoc\u00f3digo com nota\u00e7\u00e3o similar entre estes, facilitando a compreens\u00e3o. Os algoritmos\ns\u00e3o detalhados por ordem de apari\u00e7\u00e3o na literatura, a partir das primeiras transformadas r\u00e1pidas co-\nnhecidas. Com esta revis\u00e3o do estado da arte procura-se reunir as t\u00e9cnicas utilizadas de forma a\nfacilitar a compreens\u00e3o de suas implica\u00e7\u00f5es e usos.\n\n3.1 Algoritmo Vincent e Soille de Imers\u00e3o\nO algoritmo de imers\u00e3o, proposto por Vincent e Soille, \u00e9 a primeira transformada watershed r\u00e1-\n\npida conhecida na literatura, tendo seus princ\u00edpios estabelecidos pelo paradigma de busca em largura\ncom resultados determinados pela defini\u00e7\u00e3o Flooding-WT [6]. Sua implementa\u00e7\u00e3o \u00e9 baseada em um\nalgoritmo de quatro passos. O primeiro passo \u00e9 uma ordena\u00e7\u00e3o dos pixels pelo seu n\u00edvel de cinza.\nEste passo \u00e9 fundamental para determinar a velocidade de execu\u00e7\u00e3o do algoritmo, pois permite o\nacesso direto aos pixels no mesmo n\u00edvel, no entanto pode-se utilizar implementa\u00e7\u00f5es relativamente\nsimples que garantem esta mesma propriedade, como o uso de dicion\u00e1rios. Em seguida, itera-se pelos\npixels nos n\u00edveis de cinza na imagem, mascarando-os e inserindo em uma estrutura de dados aqueles\ncom vizinhos rotulados. A an\u00e1lise dos pixels na estrutura constitui o terceiro passo, onde os r\u00f3tulos\ns\u00e3o determinados e propagados nas zonas planas. Por \u00faltimo, pixels que n\u00e3o foram rotulados consti-\ntuem novos m\u00ednimos regionais, e assim seus componentes conexos recebem novos r\u00f3tulos. O Alg. 2\napresenta a imers\u00e3o de Vincent e Soille.\n\nALGORITMO 2: Imers\u00e3o\nEntrada: im: Imagem de n\u00edveis de cinza\nSaida: lab: Imagem de r\u00f3tulos\n\n1: Initialise\n\n31\n\n\n\n32 Algoritmos de Watershed\n\n2: MASK ? -2\n3: INIT ? -1\n4: WSHED ? 0\n5: FICTITIOUS-PIXEL ? -1\n6: ?p ? D, lab(p) ? INIT\n7: basins ? 0\n8: cur_dist ? 0 // Imagem de trabalho, para armazenar dist\u00e2ncias\n\ngeod\u00e9sicas\n\n9: ?p ? D, dist(p) ? 0\n10: End\n\n// 1\u00ba Passo\n\n11: Ordene os pixels por seu n\u00edvel de cinza, com m\u00ednimo hmin e m\u00e1ximo hmax\n\n// 2\u00ba Passo\n\n12: for h ? [hmin, hmax ] do // Imers\u00e3o em cada n\u00edvel de cinza\n13: for all p ? D | im(p) = h do\n14: lab(p) ? MASK // Rotula como n\u00e3o processado os pixels neste\n\nn\u00edvel\n\n15: if ?q ? N(p) | (lab(q) > 0 or lab(q) = WSHED) then\n16: dist(p) ? 1 // Inicializa a dist\u00e2ncia para o pixel ...\n17: QUEUEPUSH(p) // ... e usa a fila para process\u00e1-lo\n18: end if\n19: end for\n\n20: cur_dist ? 1\n21: QUEUEPUSH(FICTITIOUS-PIXEL)\n\n// 3\u00ba Passo\n\n22: while true do\n23: p ?QUEUEPOP()\n24: if p = FICTITIOUS-PIXEL then // Processou todos os pixels deste\n\nn\u00edvel de cinza a esta dist\u00e2ncia\n\n25: if QUEUEEMPTY() = true then // Verifica a condi\u00e7\u00e3o de parada\n26: break\n27: else\n28: QUEUEPUSH(FICTITIOUS-PIXEL) // Reinsere a condi\u00e7\u00e3o de\n\nparada\n\n29: cur_dist ? cur_dist + 1 // Ap\u00f3s processar todos os pixels\nvizinhos imediatos de regi\u00f5es j\u00e1 rotuladas (linha 17), aumenta a\n\ndist\u00e2ncia geod\u00e9sica\n\n30: p ? QUEUEPOP()\n\n\n\n3.1 Algoritmo Vincent e Soille de Imers\u00e3o 33\n\n31: end if\n32: end if\n33: for q ? N(p) do\n34: if dist(q) &lt;cur_dist and (lab(q) > 0 or lab(q) = WSHED) then //\n\nVerifica se o vizinho est\u00e1 rotulado e se a dist\u00e2ncia geod\u00e9sica \u00e9\n\nmenor que a atual (mais pr\u00f3ximo da descida do plateau, processado\n\npreviamente)\n\n35: if lab(q) > 0 then\n36: if lab(p) = MASK or lab(p) = WSHED then // Se o pixel\n\nainda n\u00e3o foi processado ou pertence a watershed, atribui o label\n\ndo m\u00ednimo, isto afina a linha de watershed\n\n37: lab(p) ? lab(q)\n38: else if lab(p) ?= lab(q) then // Se os r\u00f3tulos forem diferentes\n\n(dois m\u00ednimos atingiram um ponto) o pixel \u00e9 de watershed\n\n39: lab(p) ? WSHED\n40: end if\n41: else if lab(p) = MASK then\n42: lab(p) ? WSHED // Propaga\u00e7\u00e3o do r\u00f3tulo watershed\n43: end if\n44: else if lab(q) = MASK and dist(q) = 0 then // Propaga o processamento\n\ndentro de um plateau\n\n45: dist(q) ? cur_dist + 1\n46: QUEUEPUSH(q)\n47: end if\n48: end for\n49: end while\n\n// 4\u00ba Passo\n\n50: for p ? D | im(p) = h do // Novos m\u00ednimos n\u00e3o s\u00e3o enfileirados, s\u00e3o\nprocessados \u00e0 parte\n\n51: dist(p) ? 0\n52: if lab(p) = MASK then\n53: basins? basins+ 1\n54: QUEUEPUSH(p)\n55: lab(p) ? basins // Propaga o label para os pixels vizinhos n\u00e3o\n\nprocessados usando a fila\n\n56: while QUEUEEMPTY() = false do\n57: q ? QUEUEPOP()\n58: for all u ? N(q) | lab(u) = MASK do\n59: QUEUEPUSH(u)\n60: lab(u) ? basins\n61: end for\n\n\n\n34 Algoritmos de Watershed\n\n62: end while\n63: end if\n64: end for\n65: end for\n\nPara implementar estes passos, o algoritmo utiliza uma estrutura de dados FIFO, onde o primeiro\nelemento inserido ser\u00e1 o primeiro elemento a ser removido, correspondendo \u00e0s fun\u00e7\u00f5es de estrutura\nde fila apresentadas no Cap. 2. Al\u00e9m das imagens de entrada e sa\u00edda, tamb\u00e9m utiliza-se uma ima-\ngem de trabalho, onde s\u00e3o armazenadas as dist\u00e2ncias geod\u00e9sicas. O processo de an\u00e1lise dos pixels\nenfileirados se inicia por uma verifica\u00e7\u00e3o de condi\u00e7\u00e3o de parada, representada por um pixel fict\u00edcio,\ncujo significado \u00e9 indicar que todos pixels a uma determinada dist\u00e2ncia geod\u00e9sica a partir da borda\nda zona plana j\u00e1 foram processados. No caso de a fila estar vazia, o processamento desta deve ser\ninterrompido, caso contr\u00e1rio, os pixels seguintes devem ser processados ap\u00f3s incrementar a dist\u00e2ncia\natual. Ap\u00f3s esta verifica\u00e7\u00e3o, avalia-se a vizinhan\u00e7a do pixel e decide-se qual ser\u00e1 seu r\u00f3tulo, al\u00e9m de\ninserir na fila para serem processados os pixels vizinhos no mesmo n\u00edvel de cinza e que n\u00e3o estiverem\nnesta. Entretanto, os resultados desta implementa\u00e7\u00e3o podem n\u00e3o condizer com o esperado, de acordo\ncom a defini\u00e7\u00e3o. A Fig. 3.1 apresenta um contra-exemplo simples, onde em (a) \u00e9 apresentada uma\nimagem com dois m\u00ednimos regionais hachurados, sendo que em (c) a linha produzida pelo algoritmo\n\u00e9 afinada em rela\u00e7\u00e3o a linha da defini\u00e7\u00e3o vista em (b). Os resultados nestes exemplos foram obtidos\nutilizando vizinhan\u00e7a-8. Este problema \u00e9 conhecido na literatura, e pode ser visto tamb\u00e9m nas Refs.\n[12, 31].\n\n(a) (b) (c)\n\nFig. 3.1: Problema de ader\u00eancia a defini\u00e7\u00e3o Flooding-WT pelo algoritmo Imers\u00e3o. (a) Imagem, (b)\nresultado da defini\u00e7\u00e3o Flooding-WT, (c) resultado do algoritmo Imers\u00e3o (N8)\n\nAl\u00e9m desta quest\u00e3o, o algoritmo de Vincent e Soille nem sempre ir\u00e1 produzir linhas dividindo as\nregi\u00f5es segmentadas, sendo uma consequ\u00eancia da defini\u00e7\u00e3o adotada utilizando zonas de influ\u00eancia\ncomo crit\u00e9rio. Assim, pode-se exemplificar esta condi\u00e7\u00e3o com uma regi\u00e3o plana onde as dist\u00e2ncias\ndos pixels aos m\u00ednimos regionais correspondentes s\u00e3o estritamente menores umas das outras, ou seja,\nas zonas de influ\u00eancia conter\u00e3o todos os pixels desta regi\u00e3o e n\u00e3o haver\u00e1 linha divis\u00f3ria. A Fig. 3.2\napresenta um exemplo de acordo com o descrito.\n\nOutro ponto importante a ser considerado neste algoritmo \u00e9 referente \u00e0 unicidade das solu\u00e7\u00f5es\nproduzidas. A defini\u00e7\u00e3o Flooding-WT produz uma solu\u00e7\u00e3o \u00fanica, mas como visto na Fig. 3.1, a\nimplementa\u00e7\u00e3o do algoritmo n\u00e3o adere \u00e0 defini\u00e7\u00e3o. Desta forma, uma das consequ\u00eancias \u00e9 o fato de\n\n\n\n3.1 Algoritmo Vincent e Soille de Imers\u00e3o 35\n\n(a) (b)\n\nFig. 3.2: Exemplo de inexist\u00eancia de linha divis\u00f3ria na imers\u00e3o de Vincent e Soille. (a) Imagem, (b)\nresultado da defini\u00e7\u00e3o Flooding-WT e algoritmo Imers\u00e3o (N4)\n\no resultado do algoritmo ser dependente da ordem de visita\u00e7\u00e3o dos pixels, especialmente na rela\u00e7\u00e3o\nde vizinhan\u00e7a estabelecida. A Fig. 3.3 apresenta um exemplo onde a imagem foi lida em varredura\nraster e anti-raster - correspondente a uma rota\u00e7\u00e3o de 180o - e o algoritmo executado sobre elas.\nDesconsiderando-se diferen\u00e7as entre r\u00f3tulos, resultado da ordem de descoberta dos m\u00ednimos regionais\nestar invertida, a import\u00e2ncia deste exemplo est\u00e1 nos pixels que recebem dois r\u00f3tulos diferentes, em\nespecial o pixel de valor 7 e posi\u00e7\u00e3o (2,3).\n\n(a) (b) (c)\n\nFig. 3.3: Diverg\u00eancia de solu\u00e7\u00f5es do algoritmo Imers\u00e3o. (a) Imagem, (b) varredura raster, (c) varre-\ndura anti-raster (N4)\n\nEsta diferen\u00e7a de rotula\u00e7\u00e3o se deve \u00e0s regras adotadas para afinar a linha de watershed, que\npermite aos pixels rotulados como watershed serem rotulados novamente na avalia\u00e7\u00e3o de sua vi-\nzinhan\u00e7a. A Fig. 3.4 apresenta a forma de rotula\u00e7\u00e3o do pixel de valor 7 na imagem (a) da Fig. 3.3.\nConsiderando-se a sequ\u00eancia de leitura da vizinhan\u00e7a apresentada na Fig. 3.4 (a) e (c), o primeiro\ncaso visitaria os pixels na ordem W, B, B, A e o segundo caso na ordem A, B, W, A. Desta forma,\nno primeiro, conforme o algoritmo, o r\u00f3tulo atribu\u00eddo ser\u00e1 W, e no segundo o r\u00f3tulo ser\u00e1 A, pois o\nr\u00f3tulo W atribu\u00eddo inicialmente ser\u00e1 alterado na an\u00e1lise do \u00faltimo vizinho. Esta pol\u00edtica, que permite\na altera\u00e7\u00e3o de um r\u00f3tulo W - respons\u00e1vel por afinar as linhas - tem como consequ\u00eancia o problema\nde solu\u00e7\u00f5es m\u00faltiplas dependentes da ordem de an\u00e1lise dos vizinhos.\n\nA solu\u00e7\u00e3o dos problemas citados acima - ader\u00eancia a defini\u00e7\u00e3o, posicionamento da linha de di-\nvis\u00e3o e unicidade de resultado - n\u00e3o \u00e9 trivial. No entanto, pode-se modificar o algoritmo de modo\na solucionar o segundo problema e garantir a exist\u00eancia de linhas separando as bacias de capta\u00e7\u00e3o\nda imagem. Esta solu\u00e7\u00e3o, adotada por ferramentas de processamento de imagens como ImageJ [34]\ne SDC Morphology Toolbox [17], tem de forma geral, efeitos ben\u00e9ficos, pois garante a separa\u00e7\u00e3o\nn\u00e3o apenas por r\u00f3tulos mas tamb\u00e9m por contornos e, avaliando-se qualitativamente os resultados, \u00e9\npr\u00f3xima do original, mantendo a ess\u00eancia da segmenta\u00e7\u00e3o por imers\u00e3o. As modifica\u00e7\u00f5es efetuadas\nno Alg. 2 dizem respeito a avalia\u00e7\u00e3o da dist\u00e2ncia geod\u00e9sica, que deixa de ser estritamente menor\n\n\n\n36 Algoritmos de Watershed\n\n(a) (b)\n\n(c) (d)\n\nFig. 3.4: An\u00e1lise de r\u00f3tulos no algoritmo Imers\u00e3o. (a) Ordem de visita\u00e7\u00e3o em varredura raster, (b)\nr\u00f3tulos para (a), (c) ordem de visita\u00e7\u00e3o em varredura anti-raster, (d) r\u00f3tulos para (c)\n\npara menor ou igual (linha 34) e a propaga\u00e7\u00e3o do r\u00f3tulo WSHED (linha 36), condi\u00e7\u00e3o que \u00e9 retirada.\nDeve-se ressaltar que estas altera\u00e7\u00f5es n\u00e3o tornam o algoritmo aderente a defini\u00e7\u00e3o, e assim, seus\nresultados continuam a divergir do esperado e tamb\u00e9m n\u00e3o s\u00e3o \u00fanicos para uma mesma imagem.\n\n3.1.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nI N I T = ?1\nWSHED = 0\nFICTITIOUS \\ _PIXEL = ?1\n\nd e f i m m e r s i o n ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nl a b [ : ] = I N I T\nb a s i n s = 0\nc u r \\ _ d i s t = 0\n\nd i s t = ws . makeWorkCopy ( 0 )\n\n\n\n3.1 Algoritmo Vincent e Soille de Imers\u00e3o 37\n\nq u e u e = wsQueue ( )\n\n# \" s o r t i n g \"\nl e v e l s = d i c t ( )\nf o r p i n D :\n\ni f l e v e l s . h a s \\ _ k e y ( im [ p ] ) :\nl e v e l s [ im [ p ] ] . a p p e n d ( p )\n\ne l s e :\nl e v e l s [ im [ p ] ] = [ p ]\n\n# w a t e r s h e d\nH = s o r t e d ( l e v e l s . k e y s ( ) )\nf o r h i n H :\n\nf o r p i n l e v e l s [ h ] :\nl a b [ p ] = MASK\nf o r q i n N( p ) :\n\ni f l a b [ q ] > 0 o r l a b [ q ] == WSHED:\nd i s t [ p ] = 1\nq u e u e . p u s h ( p )\nb r e a k\n\nc u r \\ _ d i s t = 1\nq u e u e . p u s h ( FICTITIOUS \\ _PIXEL )\n\nw h i l e T r u e :\n\np = q u e u e . pop ( )\ni f p == FICTITIOUS \\ _PIXEL :\n\ni f q u e u e . e m p t y ( ) :\nb r e a k\n\ne l s e :\nq u e u e . p u s h ( FICTITIOUS \\ _PIXEL )\nc u r \\ _ d i s t += 1\np = q u e u e . pop ( )\n\nf o r q i n N( p ) :\n\ni f d i s t [ q ] &lt;c u r \\ _ d i s t and ( l a b [ q ] > 0 o r l a b [ q ] == WSHED) :\ni f l a b [ q ] > 0 :\n\ni f l a b [ p ] == MASK o r l a b [ p ] == WSHED:\nl a b [ p ] = l a b [ q ]\n\ne l i f l a b [ p ] ! = l a b [ q ] :\nl a b [ p ] = WSHED\n\ne l i f l a b [ p ] == MASK:\nl a b [ p ] = WSHED\n\ne l i f l a b [ q ] == MASK and d i s t [ q ] == 0 :\nd i s t [ q ] = c u r \\ _ d i s t + 1\nq u e u e . p u s h ( q )\n\n\n\n38 Algoritmos de Watershed\n\nf o r p i n l e v e l s [ h ] :\nd i s t [ p ] = 0\ni f l a b [ p ] == MASK:\n\nb a s i n s += 1\nq u e u e . p u s h ( p )\nl a b [ p ] = b a s i n s\nw h i l e n o t q u e u e . e m p t y ( ) :\n\nq = q u e u e . pop ( )\nf o r u i n N( q ) :\n\ni f l a b [ u ] ! = MASK:\nc o n t i n u e\n\nq u e u e . p u s h ( u )\nl a b [ u ] = b a s i n s\n\nr e t u r n ws . e n d ( )\n\n3.2 Algoritmo Fila de Prioridade Beucher e Meyer\nO algoritmo de fila de prioridade para a transformada watershed foi proposto por Beucher e Meyer\n\n[11] como um algoritmo simples de simula\u00e7\u00e3o de inunda\u00e7\u00e3o. Mais tarde, foi mostrado que o uso de\nfilas de prioridade produz uma segmenta\u00e7\u00e3o \u00f3tima considerando a fun\u00e7\u00e3o de m\u00e1ximo como custo\ndo caminho entre cada pixel e os m\u00ednimos regionais [19]. Al\u00e9m disso, o uso da pol\u00edtica FIFO de\ndesempate na fila de prioridade implementa implicitamente o custo lexicogr\u00e1fico, cujo resultado mais\nvis\u00edvel \u00e9 a divis\u00e3o de zonas planas de acordo com a dist\u00e2ncia da borda destas. Com estas propriedades,\no algoritmo de Beucher e Meyer produz o mesmo conjunto de resultados que qualquer algoritmo de\nfloresta de caminhos m\u00ednimos que utilize o custo do caminho com dois componentes, o m\u00e1ximo e o\ncusto lexicogr\u00e1fico. Desta forma, o conjunto de resultados pass\u00edveis de obten\u00e7\u00e3o atrav\u00e9s do algoritmo\nde fila de prioridade \u00e9 dado pela defini\u00e7\u00e3o IFT-WT.\n\nO procedimento proposto funciona em dois passos, sendo um de inicializa\u00e7\u00e3o da fila e outro de\ntrabalho. Entretanto, a inicializa\u00e7\u00e3o requer um conjunto de sementes - pixels selecionados e rotulados\nda imagem - que podem ser obtidos atrav\u00e9s de um algoritmo de detec\u00e7\u00e3o de m\u00ednimos regionais, ou\natrav\u00e9s de marcadores pr\u00e9-processados ou selecionados por usu\u00e1rios. A inicializa\u00e7\u00e3o consiste ent\u00e3o\nem enfileirar estas sementes com seu custo correspondendo ao seu n\u00edvel de cinza e rotul\u00e1-las de\nacordo com uma fun\u00e7\u00e3o de r\u00f3tulos ou pelos componentes conexos formados. O processamento trata\nde remover o pixel com maior prioridade da fila - aquele com o menor custo e inserido por primeiro\nentre aqueles com o mesmo custo - e ent\u00e3o analisar cada um de seus vizinhos ainda n\u00e3o rotulados,\ninserindo-os na fila com custo correspondente ao seu n\u00edvel de cinza, e propagar seu r\u00f3tulo. Itera-se\ndesta forma at\u00e9 que a fila esteja vazia, indicando que todos os pixels da imagem foram processados.\nO Alg. 3 apresenta a transformada watershed por fila de prioridade de Beucher e Meyer.\n\nALGORITMO 3: Fila de Prioridade\n\n\n\n3.2 Algoritmo Fila de Prioridade Beucher e Meyer 39\n\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D e conjunto de m\u00ednimos M\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D, lab(p) ? MASK\n3: End\n4: // Passo 1: Insere os m\u00ednimos regionais na fila\n5: for all p ? mi ? M do\n6: HEAPQUEUEPUSH(p, im(p))\n7: lab(p) ? i\n8: end for\n9: // Passo 2: Processa os pixels na ordem da fila\n\n10: while HEAPQUEUEEMPTY() = false do\n11: p ? HEAPQUEUEPOP()\n12: for all q ? N(p) | lab(q) = MASK do\n13: lab(q) ? lab(p)\n14: HEAPQUEUEPUSH(q, im(q))\n15: end for\n16: end while\n\nAnalisando-se o Algoritmo 3, nota-se que o controle da simula\u00e7\u00e3o de imers\u00e3o \u00e9 completamente\nrealizado pela fila de prioridade, dado que nenhuma rela\u00e7\u00e3o de ordem entre os n\u00edveis de cinza dos\npixels \u00e9 expl\u00edcita no algoritmo. A caracteriza\u00e7\u00e3o deste procedimento como uma transformada wa-\ntershed por busca em largura \u00e9 dada pela pol\u00edtica FIFO em cada n\u00edvel de cinza, sendo que a visita\u00e7\u00e3o\ndestes \u00e9 feita por uma fronteira que se expande, visitando todos na fronteira atual antes de visitar a\npr\u00f3xima. O uso dos m\u00ednimos regionais como sementes garante o comportamento de busca em largura\nde forma geral, no entanto o uso de marcadores arbitr\u00e1rios pode resultar na forma\u00e7\u00e3o de caminhos\ndiferentes, visto que a fronteira em expans\u00e3o pode encontrar pixels com custo menor que o atual,\nfazendo com que estes tenham maior prioridade do que o atual e interrompendo a an\u00e1lise deste n\u00edvel\nat\u00e9 que todos os custos inferiores sejam processados. Este comportamento de fato \u00e9 incorreto, e a\ncorre\u00e7\u00e3o deste \u00e9 feita armazenando-se o custo m\u00e1ximo do caminho e o utilizando na inser\u00e7\u00e3o na fila\nde prioridade.\n\nComo dito anteriormente, este algoritmo adere \u00e0 defini\u00e7\u00e3o IFT-WT , e portanto n\u00e3o tem solu\u00e7\u00e3o\n\u00fanica, sendo dependente de ordem de varredura e visita\u00e7\u00e3o. A programa\u00e7\u00e3o deste algoritmo tem seu\ndesempenho extremamente ligado \u00e0 efici\u00eancia da fila de prioridade. Um estudo mais aprofundado\ndesta foge ao escopo deste trabalho, sendo alvo de diversos outros, todavia \u00e9 importante ressaltar a\nnecessidade da pol\u00edtica FIFO como regra de desempate, n\u00e3o considerada em diversas implementa\u00e7\u00f5es\n(e.g. priority_queue da biblioteca STL para C++ e heapq para Python), sendo necess\u00e1rio utilizar\nfun\u00e7\u00f5es de compara\u00e7\u00e3o personalizadas que levam em conta um valor referente a ordem de inser\u00e7\u00e3o,\narmazenado junto ao custo. Ainda em rela\u00e7\u00e3o a seu desempenho, este algoritmo apresenta uma\nsolu\u00e7\u00e3o elegante, separando problemas como a detec\u00e7\u00e3o dos m\u00ednimos regionais e avalia\u00e7\u00e3o de custos\nem algoritmos distintos. A Fig. 3.5 apresenta um exemplo de resultado obtido utilizando o algoritmo\nde fila de prioridade.\n\n\n\n40 Algoritmos de Watershed\n\n(a) (b)\n\nFig. 3.5: Fila de Prioridade. (a) Imagem, (b) Resultado (N4)\n\nUma vers\u00e3o deste algoritmo, tamb\u00e9m mencionada por Beucher e Meyer, degenera a otimalidade\nda defini\u00e7\u00e3o IFT-WT e produz pixels de linha entre as regi\u00f5es da imagem. Este algoritmo foi descrito\npor Meyer, incluindo uma condi\u00e7\u00e3o na extra\u00e7\u00e3o dos elementos da fila, se dois ou mais vizinhos\ntiverem r\u00f3tulos diferentes, o pixel ser\u00e1 rotulado como watershed [35]. Esta implementa\u00e7\u00e3o, apesar\nde n\u00e3o aderir a nenhuma defini\u00e7\u00e3o estabelecida, \u00e9 encontrada no pacote OpenCV [36] e na biblioteca\nMilena [37], como parte da ferramenta Olena [38].\n\n3.2.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\n\nd e f h i e r a r c h i c a l Q u e u e ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nl a b [ : ] = MASK\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\nq u e u e = wsHeapQueue ( )\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nq u e u e . p u s h ( p , im [ p ] )\nl a b [ p ] = m+1\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\n\n\n\n3.3 Algoritmo Dijsktra-Moore de Caminhos M\u00ednimos de Meyer 41\n\nf o r q i n N( p ) :\ni f l a b [ q ] ! = MASK:\n\nc o n t i n u e\n\nl a b [ q ] = l a b [ p ]\nq u e u e . p u s h ( q , im [ q ] )\n\nr e t u r n ws . e n d ( )\n\n3.3 Algoritmo Dijsktra-Moore de Caminhos M\u00ednimos de Meyer\nNo mesmo trabalho em que Meyer apresenta a defini\u00e7\u00e3o TD-WT, s\u00e3o propostos tr\u00eas algoritmos\n\npara implementa\u00e7\u00e3o desta [7]. O primeiro destes, tratado nesta se\u00e7\u00e3o, \u00e9 baseado nos trabalhos de\nDijsktra [39] e Moore [40] para constru\u00e7\u00e3o de florestas de caminhos m\u00ednimos. Ao usar estes al-\ngoritmos, Meyer modifica sua fun\u00e7\u00e3o de custo, que deixa de ser apenas uma soma, para indicar a\ninclina\u00e7\u00e3o de um caminho, e assim construir os caminhos de m\u00e1xima inclina\u00e7\u00e3o e menor custo a\npartir dos m\u00ednimos regionais de uma imagem. Sua defini\u00e7\u00e3o produz resultados \u00fanicos, possibilita-\ndos pela marca\u00e7\u00e3o de pixels de divis\u00e3o. Entretanto, estes n\u00e3o s\u00e3o previstos no algoritmo proposto, e\ndesta forma, Roerdink e Meijster [12] prop\u00f5e uma modifica\u00e7\u00e3o, reproduzida no Alg. 4, de forma a\nimplementar a defini\u00e7\u00e3o TD-WT completamente.\n\nALGORITMO 4: Dijkstra-Moore\n\nEntrada: im: Imagem de n\u00edveis de cinza sem zonas planas, com dom\u00ednio D e m\u00ednimos regionais\nmi ? M\n\nSaida: lab: Imagem rotulada\n1: Initialise\n2: WSHED ? 0\n3: ?p ? D, lab(p) ? 0, dist(p) ??\n4: End\n\n5: for all p ? mi ? M do\n6: lab(p) ? i\n7: dist(p) ? im(p)\n8: end for\n\n9: while D ?= ? do\n10: p ? u : u ? D and dist(u) = min?v?D dist(v)\n\n11: D ? D?{p}\n12: for all q ? N(p) do\n13: if dist(p) + COST(p, q) &lt;dist(q) then\n\n\n\n42 Algoritmos de Watershed\n\n14: dist(q) ? dist(p) + COST(p,q)\n15: lab(q) ? lab(p)\n16: else if dist(p) + COST(p, q) = dist(q) and lab(q) ?= lab(p) then\n17: lab(q) ? WSHED\n18: end if\n19: end for\n20: end while\n\n21: Procedure COST(p, q : q ? N(p))\n22: LS(p) ? max?u?N(p) | im(u)<im(p)(im(p) ? im(u))\n23: LS(q) ? max?u?N(q) | im(u)<im(q)(im(q) ? im(u))\n\n24: if im(p) > im(q) then\n25: return LS(p)\n26: else if im(q) > im(p) then\n27: return LS(q)\n28: else if im(p) = im(q) then\n29: return LS(p)+LS(q)2\n30: end if\n31: End\n\nOs algoritmos de Dijkstra e Moore s\u00e3o cl\u00e1ssicos na literatura de teoria de grafos na abordagem\ndo problema de florestas de caminhos m\u00ednimos [41], portanto seu funcionamento geral \u00e9 bastante\nconhecido, sendo aplicado sobre o grafo inerente \u00e0 imagem. Todavia o c\u00e1lculo da fun\u00e7\u00e3o de custo e a\npol\u00edtica de rotula\u00e7\u00e3o dos pixels necessitam de mais explica\u00e7\u00f5es. Assim, o algoritmo inicia rotulando\nos m\u00ednimos regionais, previamente detectados por outro procedimento e inicializando os valores da\nmatriz dist com os n\u00edveis de cinza de cada pixel pertencente a um m\u00ednimo regional, de onde s\u00e3o\nselecionados os pixels e armazenadas as dist\u00e2ncias topogr\u00e1ficas at\u00e9 os m\u00ednimos. A matriz dist \u00e9\nutilizada para realizar a fun\u00e7\u00e3o de uma fila hier\u00e1rquica, onde primeiro s\u00e3o processados os elementos\ncom menor custo. Desta forma, a cada itera\u00e7\u00e3o processa-se e retira-se do conjunto contendo todos os\npixels da imagem aquele com o menor valor na matriz dist (linhas 10 e 11). Em seguida, avalia-se a\nvizinhan\u00e7a do pixel selecionado, verificando se o custo oferecido \u00e9 menor que o custo atual destes, e\nent\u00e3o propagando o novo custo e r\u00f3tulo. Nesta opera\u00e7\u00e3o, o algoritmo tem funcionamento id\u00eantico ao\nalgoritmo de Dijkstra. No entanto, se o custo oferecido for igual ao custo atual do pixel vizinho e estes\npossu\u00edrem r\u00f3tulos diferentes, caracteriza-se uma ambiguidade de caminhos de m\u00e1xima inclina\u00e7\u00e3o, e\nassim este pixel \u00e9 rotulado como watershed (linhas 16 e 17).\n\nO algoritmo de Dijkstra reconhecidamente mant\u00e9m similaridades com o algoritmo de busca em\nlargura cl\u00e1ssico [26]. Sua adapta\u00e7\u00e3o para a transformada watershed, utilizando uma fun\u00e7\u00e3o de custo\ncrescente e positiva que garanta as mesmas propriedades do algoritmo original, ser\u00e1 caracterizada\ncomo uma transformada watershed por busca em largura. Esta similaridade \u00e9 dada na forma que\na fronteira de expans\u00e3o cresce de forma pr\u00f3xima \u00e0 uniforme, dependendo dos custos dos vizinhos\ndestas. Pode-se dizer que em compara\u00e7\u00e3o com a defini\u00e7\u00e3o cl\u00e1ssica - avalia\u00e7\u00e3o de todos v\u00e9rtices a\n\n\n\n3.3 Algoritmo Dijsktra-Moore de Caminhos M\u00ednimos de Meyer 43\n\ndist\u00e2ncia k antes dos v\u00e9rtices a dist\u00e2ncia k + 1 - esta \u00e9 mantida, no entanto k passa a ter o valor da\nfun\u00e7\u00e3o de custo.\n\nA programa\u00e7\u00e3o deste algoritmo depende de outros dois, para remo\u00e7\u00e3o de zonas planas, discutido\nna Sec. 2.2.3 e detec\u00e7\u00e3o de m\u00ednimos regionais. \u00c9 necess\u00e1rio tamb\u00e9m decidir a forma de aplica-\n\u00e7\u00e3o da opera\u00e7\u00e3o de extra\u00e7\u00e3o do menor elemento, feita avaliando-se a matriz dist a cada itera\u00e7\u00e3o ou\nutilizando-se uma fila de prioridade, sendo a segunda forma mais recomendada por reduzir o n\u00famero\nde opera\u00e7\u00f5es e mantendo em uma estrutura apenas os dados necess\u00e1rios, e proposta originalmente\npara este fim por Dial [42]. A Fig. 3.6 apresenta um exemplo de resultado obtido utilizando o algo-\nritmo Dijkstra-Moore de transformada watershed.\n\n(a) (b)\n\nFig. 3.6: Dijkstra-Moore de Caminhos M\u00ednimos. (a) Imagem, (b) Resultado (N4)\n\n3.3.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nWSHED = 0\n\nd e f d i j k s t r a M o o r e ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nl c = l o w e r C o m p l e t e ( im , o f f s e t s )\nws = wsImage ( l c )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\nd e f c o s t ( p , q ) :\nLSp = im [ p ] ? min ( im [N( p ) ] )\nLSq = im [ q ] ? min ( im [N( q ) ] )\ni f im [ p ] > im [ q ] :\n\n\n\n44 Algoritmos de Watershed\n\nr e t u r n LSp\ne l i f im [ q ] > im [ p ] :\n\nr e t u r n LSq\ne l s e :\n\nr e t u r n ( LSp + LSq ) / 2 . 0\n\nl a b [ : ] = MASK\nd i s t = ws . makeWorkCopy ( i n f )\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nl a b [ p ] = m+1\nd i s t [ p ] = im [ p ]\n\n# make t h e d o m a i n o b j e c t a s e t\nD = l i s t (D)\n\nw h i l e l e n (D) > 0 :\np = d i s t . a r g m i n ( )\n\nD . r e m o v e ( p )\nf o r q i n N( p ) :\n\nc = c o s t ( p , q )\ni f d i s t [ p ] + c &lt;d i s t [ q ] and l a b [ q ] == MASK:\n\nd i s t [ q ] = d i s t [ p ] + c\nl a b [ q ] = l a b [ p ]\n\ne l i f d i s t [ p ] + c == d i s t [ q ] and l a b [ q ] ! = l a b [ p ] :\nl a b [ q ] = WSHED\n\nd i s t [ p ] = i n f\n\nr e t u r n ws . e n d ( )\n\n3.4 Algoritmo Hill Climbing de Meyer\nAssim como o algoritmo Dijkstra-Moore, Meyer prop\u00f4s em conjunto \u00e0 defini\u00e7\u00e3o TD-WT o algo-\n\nritmo Hill Climbing, utilizando os conceitos de downstream e upstream [7]. Estes conjuntos proces-\nsam intrinsecamente a dist\u00e2ncia topogr\u00e1fica, e portanto neste algoritmo esta n\u00e3o \u00e9 calculada explicita-\nmente. Da mesma forma que o algoritmo Dijkstra-Moore, este n\u00e3o foi proposto prevendo a unicidade\ndas solu\u00e7\u00f5es, e tamb\u00e9m foi revisto por Roerdink e Meijster [12], sendo reproduzido aqui detalhando\na forma de constru\u00e7\u00e3o do conjunto upstream, e implementando completamente a defini\u00e7\u00e3o TD-WT.\nO Alg. 5 apresenta o pseudoc\u00f3digo da transformada watershed por Hill Climbing.\n\nALGORITMO 5: Hill Climbing\n\n\n\n3.4 Algoritmo Hill Climbing de Meyer 45\n\nEntrada: im: Imagem de n\u00edveis de cinza sem zonas planas, com dom\u00ednio D e m\u00ednimos regionais\nmi ? M\n\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: WSHED ? 0\n3: MASK ? -1\n4: ?p ? mi ? M, lab(p) ? i\n5: ?p ? D?M, lab(p) ? MASK\n6: S ?{p ? D : ?q ? N(p), im(p) ?= im(q)}\n7: End\n\n8: while S ?= ? do\n9: p ? u : u ? S and im(u) = min?v?S im(v)\n\n10: S ? S?{p}\n\n11: ??1(p) ? {q | q ? N(p) and im(p) = min?u?N(q)im(u)}\n\n12: for all q ? ??1(p) ? S do\n13: if lab(q) = MASK then\n14: lab(q) ? lab(p)\n15: else if lab(q) ?= lab(p) then\n16: lab(q) ? WSHED\n17: end if\n18: end for\n19: end while\n\nO algoritmo opera calculando para cada pixel o seu upstream e propagando seu r\u00f3tulo para este.\nQuando dois r\u00f3tulos diferentes se encontram, o pixel \u00e9 marcado como watershed. Este processamento\n\u00e9 iniciado a partir das bordas dos m\u00ednimos regionais e ordenado pelo n\u00edvel de cinza dos pixels, pro-\ncessando todos a um n\u00edvel antes de processar o pr\u00f3ximo. Uma vez que o pixel foi processado, ele\nn\u00e3o \u00e9 mais visitado. H\u00e1 duas etapas importantes neste algoritmo, que s\u00e3o a sele\u00e7\u00e3o do pixel a ser\nprocessado e o c\u00e1lculo do upstream.\n\nA primeira etapa consiste na sele\u00e7\u00e3o entre todos os pixels que ainda n\u00e3o foram processados aquele\ncom o menor n\u00edvel de cinza. Esta opera\u00e7\u00e3o \u00e9 equivalente a inserir inicialmente todos os pixels em uma\nfila de prioridade e executar uma remo\u00e7\u00e3o da frente desta a cada itera\u00e7\u00e3o. No Alg. 5 a forma escolhida\nde representa\u00e7\u00e3o desta opera\u00e7\u00e3o foi atrav\u00e9s de um subconjunto da imagem original e buscando o\nelemento de menor n\u00edvel de cinza, e ent\u00e3o removendo-o do subconjunto.\n\nA segunda etapa, de c\u00e1lculo do upstream, envolve a an\u00e1lise dos vizinhos do pixel selecionado e dos\nvizinhos destes. Isto \u00e9 necess\u00e1rio pois o upstream \u00e9 o inverso do downstream. Desta forma, o c\u00e1lculo\ndo upstream s\u00f3 \u00e9 poss\u00edvel determinando-se o downstream de cada vizinho, que, por consequ\u00eancia,\nnecessita da an\u00e1lise dos vizinhos destes. A Fig. 3.7 apresenta um exemplo de c\u00e1lculo do upstream\n\n\n\n46 Algoritmos de Watershed\n\npara o pixel de coordenadas (3,3). Em (a) \u00e9 mostrada a imagem com o pixel em an\u00e1lise hachurado.\nEm (b) o downstream \u00e9 apresentado com setas e os pixels de destino destas s\u00e3o hachurados. Em\n(c) s\u00e3o hachurados os pixels que pertencem ao upstream do pixel em an\u00e1lise, ou seja, aqueles cujo\ndownstream cont\u00e9m o pixel (3,3), com as setas em destaque em (b).\n\n(a) Imagem (b) Downstream (c) Upstream\n\nFig. 3.7: C\u00e1lculo do upstream para uma imagem de exemplo, com o downstream indicado por setas a\npartir dos pixels de origem.\n\nPara o algoritmo Hill Climbing tamb\u00e9m verifica-se a caracteriza\u00e7\u00e3o da busca em largura, com base\nno mesmo princ\u00edpio para isto no algoritmo Dijkstra-Moore. Sendo todos os pixels a um determinado\nn\u00edvel de cinza processados antes do pr\u00f3ximo: o custo destes ser\u00e1 definitivo e novamente a dist\u00e2ncia\nk pode ser vista como o custo m\u00ednimo a partir de um m\u00ednimo regional, e todos os pixels a um deter-\nminado custo ser\u00e3o processados antes dos pixels a custo k + 1. A programa\u00e7\u00e3o deste algoritmo deve\nlevar em considera\u00e7\u00e3o a necessidade de um algoritmo de remo\u00e7\u00e3o de zonas planas e de detec\u00e7\u00e3o de\nm\u00ednimos regionais, assim como uma t\u00e9cnica eficiente para armazenamento e identifica\u00e7\u00e3o do pixel\nde menor valor dado um subconjunto da imagem. Assim como no caso do algoritmo Dijkstra-Moore,\nonde deseja-se o menor valor dentre um conjunto de dist\u00e2ncias topogr\u00e1ficas, uma fila de prioridade \u00e9\nrecomendada para implementa\u00e7\u00e3o deste. A Fig. 3.8 apresenta um exemplo de resultado do algoritmo\nHill Climbing.\n\n(a) (b)\n\nFig. 3.8: Hill Climbing (a) Imagem, (b) Resultado (N4)\n\n\n\n3.4 Algoritmo Hill Climbing de Meyer 47\n\n3.4.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nWSHED = 0\nMASK = ?2\n\nd e f h i l l C l i m b i n g ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nl c = l o w e r C o m p l e t e ( im , o f f s e t s )\nws = wsImage ( l c )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nl a b [ : ] = MASK\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\n# e x p a n d s x r a n g e i n t o a l i s t\nS = l i s t (D)\n\n# l a b e l m i n i m a\nf o r m i n x r a n g e ( l e n (M) ) :\n\nf o r p i n M[m ] :\nl a b [ p ] = m+1\n# r e m o v e s i n n e r p i x e l s f r o m S\nhmax = max ( im [N( p ) ] )\ni f hmax == im [ p ] :\n\nS . r e m o v e ( p )\n\nSc = d i c t ( )\nw h i l e l e n ( S ) > 0 :\n\np = S [ ( im [ S ] ) . a r g m i n ( ) ]\nS . r e m o v e ( p )\nSc [ p ] = T r u e\n\nu p s t r e a m = l i s t ( )\nf o r q i n N( p ) :\n\ni f im [ p ] == min ( im [N( q ) ] ) :\nu p s t r e a m . a p p e n d ( q )\n\nf o r q i n u p s t r e a m :\ni f Sc . h a s \\ _ k e y ( q ) :\n\nc o n t i n u e\n\ni f l a b [ q ] == MASK:\nl a b [ q ] = l a b [ p ]\n\ne l i f l a b [ q ] ! = l a b [ p ] :\nl a b [ q ] = WSHED\n\n\n\n48 Algoritmos de Watershed\n\nr e t u r n ws . e n d ( )\n\n3.5 Algoritmo Berge de Caminhos M\u00ednimos de Meyer\nO terceiro algoritmo proposto por Meyer [7] \u00e9 baseado no algoritmo de constru\u00e7\u00e3o de florestas\n\nde caminhos m\u00ednimos de C. Berge [43]. Dado que o algoritmo de Dijsktra-Moore constr\u00f3i uma\nSPF (Shortest Path Forest), qualquer algoritmo com esta capacidade, utilizando a fun\u00e7\u00e3o de custo de\ndist\u00e2ncia topogr\u00e1fica, tamb\u00e9m ir\u00e1 produzir como resultado uma transformada watershed. Todavia,\nassim como nos algoritmos Dijkstra-Moore e Hill-Climbing, o original de Meyer n\u00e3o prev\u00ea o uso\nde pixels de watershed para garantir a implementa\u00e7\u00e3o correta da defini\u00e7\u00e3o TD-WT e unicidade da\nsolu\u00e7\u00e3o. Desta forma, Roerdink e Meijster [12] revisam-no e este \u00e9 reproduzido no Alg. 6.\n\nALGORITMO 6: Berge\n\nEntrada: im: Imagem de n\u00edveis de cinza sem zonas planas, com dom\u00ednio D e m\u00ednimos regionais\nmi ? M\n\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D, lab(p) ? 0, dist(p) ??\n3: ?p ? mi ? M, lab(p) ? i , dist(p) ? im(p)\n4: stable ? true\n5: WSHED ? 0\n6: End\n7: repeat\n8: stable ? true\n9: for p ? D+ do\n\n10: PROPAGATE(p,N +(p))\n11: end for\n12: for p ? D? do\n13: PROPAGATE(p,N +(p))\n14: end for\n15: until stable = true\n\n16: Procedure PROPAGATE(p, Q)\n17: for all q ? Q do\n18: if dist(p) + COST(p, q) &lt;dist(q) then\n19: dist(q) ? dist(p) + COST(p, q)\n20: lab(q) ? lab(p)\n21: stable ? false\n\n\n\n3.5 Algoritmo Berge de Caminhos M\u00ednimos de Meyer 49\n\n22: else if dist(p) + COST(p, q) = dist(q) and lab(q) ?= lab(p) and lab(q) ?= WSHED\nthen\n\n23: lab(q) ? WSHED\n24: stable ? false\n25: end if\n26: end for\n27: End\n\n28: Procedure COST(p, q : q ? N(p))\n29: LS(p) ? max?u?N(p) | im(u)<im(p)(im(p) ? im(u))\n30: LS(q) ? max?u?N(q) | im(u)<im(q)(im(q) ? im(u))\n\n31: if im(p) > im(q) then\n32: return LS(p)\n33: else if im(q) > im(p) then\n34: return LS(q)\n35: else if im(p) = im(q) then\n36: return LS(p)+LS(q)2\n37: end if\n38: End\n\nO algoritmo de Berge para transformada watershed \u00e9 um caso em particular na classifica\u00e7\u00e3o uti-\nlizada neste trabalho, pois n\u00e3o possui comportamento de calcular os resultados guiado por largura\nou profundidade. Sua varredura pode ser feita de forma aleat\u00f3ria, at\u00e9 a estabiliza\u00e7\u00e3o dos resultados,\ndeterminado pela vari\u00e1vel stable no Alg. 6. Entretanto, de modo a obter resultados est\u00e1veis mais rapi-\ndamente (menos varreduras), Roerdink e Meijster sugerem o uso de varreduras sequenciais em raster\ne anti-raster representadas no algoritmo por D+ e D?. Para cada pixel, propaga-se seu resultado atual\npara seus vizinhos ainda n\u00e3o visitados - N + - relativos \u00e0 ordem de varredura atual. A estabiliza\u00e7\u00e3o\ndo algoritmo se d\u00e1 quando nenhum pixel tiver seu r\u00f3tulo modificado, sendo que, a cada nova itera\u00e7\u00e3o\nnecess\u00e1ria, todos os pixels devem ser reprocessados.\n\nEm uma implementa\u00e7\u00e3o em software, este comportamento pode ser indesejado, por repetir di-\nversas vezes as opera\u00e7\u00f5es, mas, em dispositivos com mem\u00f3ria de leitura sequencial r\u00e1pida, onde o\nacesso a esta se torna muito eficiente dado um sentido, o algoritmo pode apresentar resultados su-\nperiores a outros ou mesmo ser a \u00fanica op\u00e7\u00e3o. Em particular, este algoritmo tamb\u00e9m \u00e9 interessante\njustamente por sua varredura aleat\u00f3ria, que remove condi\u00e7\u00f5es intr\u00ednsecas de outros, como o custo\nlexicogr\u00e1fico intr\u00ednseco \u00e0s estruturas de filas, passando a depender \u00fanica e exclusivamente da fun\u00e7\u00e3o\nde custo utilizada na propaga\u00e7\u00e3o. A Fig. 3.9 apresenta um exemplo de resultado do algoritmo Berge.\n\n\n\n50 Algoritmos de Watershed\n\n(a) (b)\n\nFig. 3.9: Berge com custo TD-WT. (a) Imagem, (b) Resultado (N4)\n\n3.5.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nWSHED = 0\n\nd e f b e r g e ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nl c = l o w e r C o m p l e t e ( im , o f f s e t s )\nws = wsImage ( l c )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\nd e f c o s t ( p , q ) :\nLSp = im [ p ] ? min ( im [N( p ) ] )\nLSq = im [ q ] ? min ( im [N( q ) ] )\ni f im [ p ] > im [ q ] :\n\nr e t u r n LSp\ne l i f im [ q ] > im [ p ] :\n\nr e t u r n LSq\ne l s e :\n\nr e t u r n ( LSp + LSq ) / 2 . 0\n\nd e f p r o p a g a t e ( p , Q , cmp ) :\ns = T r u e\nf o r q i n Q :\n\ni f n o t cmp ( q , p ) :\nc o n t i n u e\n\nc = c o s t ( p , q )\ni f d i s t [ p ] + c &lt;d i s t [ q ] :\n\n\n\n3.6 Algoritmo Componentes Conexos de Bieniek e Moga 51\n\nd i s t [ q ] = d i s t [ p ] + c\nl a b [ q ] = l a b [ p ]\ns = F a l s e\n\ne l i f d i s t [ p ] + c == d i s t [ q ] and l a b [ q ] ! = l a b [ p ] and l a b [ q ] ! =\nWSHED:\n\nl a b [ q ] = WSHED\ns = F a l s e\n\nr e t u r n s\n\nl a b [ : ] = MASK\nd i s t = ws . makeWorkCopy ( i n f )\ns t a b l e = F a l s e\n\nD = l i s t (D)\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nl a b [ p ] = m+1\nd i s t [ p ] = im [ p ]\n\nw h i l e n o t s t a b l e :\ns t a b l e = T r u e\nf o r p i n D :\n\ns t a b l e = s t a b l e and p r o p a g a t e ( p , N( p ) , lambda u , v : u > v )\n\nf o r p i n r e v e r s e d (D) :\ns t a b l e = s t a b l e and p r o p a g a t e ( p , N( p ) , lambda u , v : u &lt;v )\n\nr e t u r n ws . e n d ( )\n\n3.6 Algoritmo Componentes Conexos de Bieniek e Moga\nO algoritmo de componentes conexos de Bieniek e Moga se origina de estudos sobre a paraleliza-\n\n\u00e7\u00e3o da transformada watershed, iniciados por Moga et al. [44] com a arquitetura para implementa\u00e7\u00e3o\ndistribu\u00edda e continuados por Bieniek et al. com a defini\u00e7\u00e3o LC-WT e a proposta de um algoritmo\nparalelo [30]. No entanto, a formaliza\u00e7\u00e3o do algoritmo de componentes conexos viria somente com\na uni\u00e3o destes trabalhos [18, 29]. Desta forma, apresenta-se consistentemente a defini\u00e7\u00e3o LC-WT,\nderivada da defini\u00e7\u00e3o TD-WT, e um algoritmo capaz de implement\u00e1-la, com possibilidade de parale-\nliza\u00e7\u00e3o. O Alg. 7 apresenta a proposta de Bieniek e Moga.\n\nALGORITMO 7: Componentes Conexos\n\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D\nSaida: lab: Imagem rotulada\n\n\n\n52 Algoritmos de Watershed\n\n1: Initialise\n2: PLATEAU ??\n3: ?p ? D, lab(p) ? MASK\n4: End\n\n5: // Passo 1\n6: for all p ? D do\n7: q ? p\n8: for u ? N(p) and im(u) &lt;im(p) do\n9: if im(u) &lt;im(q) then\n\n10: q ? u\n11: end if\n12: end for\n13: if q ?= p then\n14: adr(p) ? q\n15: else\n16: adr(p) ? PLATEAU\n17: end if\n18: end for\n\n19: // Passo 2\n20: for all p ? D | adr(p) = PLATEAU do\n21: if ?q ? N(p) | adr(q) ?= PLATEAU and im(p) = im(q) then\n22: QUEUEPUSH(q)\n23: end if\n24: end for\n25: while QUEUEEMPTY() = false do\n26: p ? QUEUEPOP()\n27: for all q ? N(p) | adr(q) = PLATEAU and im(p) = im(q) do\n28: adr(q) ? adr(p)\n29: QUEUEPUSH(q)\n30: end for\n31: end while\n\n32: // Passo 3\n33: for p ? D | adr(p) = PLATEAU do\n34: adr(p) ? p\n35: for q ? N?(p) | im(p) = im(q) do\n36: u ? FIND(p)\n37: v ? FIND(q)\n38: adr(u) ? adr(v) ? min(u,v)\n39: end for\n\n\n\n3.6 Algoritmo Componentes Conexos de Bieniek e Moga 53\n\n40: end for\n\n41: // Passo 4\n42: basins? 1\n43: for p ? D do\n44: r ? FIND(p)\n45: adr(p) ? r\n46: if lab(r) = MASK then\n47: lab(r) ? basins\n48: basins ? basins + 1\n49: end if\n50: lab(p) ? lab(r)\n51: end for\n\n52: Procedure FIND(p)\n53: q ? p\n54: while adr(q) ?= q do\n55: q ? adr(q)\n56: end while\n57: u ? p\n58: while adr(u) ?= q do\n59: v ? adr(u)\n60: adr(u) ? q\n61: u ? v\n62: end while\n63: return q\n64: End\n\nA defini\u00e7\u00e3o LC-WT tem, por sua natureza, m\u00faltiplas solu\u00e7\u00f5es, e, desta forma, a resposta do\nalgoritmo - que n\u00e3o tem componentes estoc\u00e1sticos - depende da forma de varredura da imagem e da\nvizinhan\u00e7a. Todavia, todas as respostas s\u00e3o v\u00e1lidas de acordo com a LC-WT. O Alg. 7 opera em\nquatro passos b\u00e1sicos, utilizando adr como matriz auxiliar, armazenando endere\u00e7os de pixels. No\nprimeiro passo, cada pixel armazena em adr o endere\u00e7o de seu vizinho m\u00ednimo, ou uma constante em\ncaso deste n\u00e3o existir, indicando uma zona plana. O segundo passo consiste em resolver o endere\u00e7o\ndos pixels de zona plana que n\u00e3o s\u00e3o m\u00ednimos regionais. Isto \u00e9 feito propagando o endere\u00e7o a partir\nda borda destas zonas, uniformemente, atrav\u00e9s de uma fila. O terceiro passo trata da resolu\u00e7\u00e3o dos\nm\u00ednimos regionais, que tamb\u00e9m s\u00e3o zonas planas, passam a ser representados por um pixel, aquele\ncom o menor endere\u00e7o entre todos do componente conexo, sendo armazenado em adr para os outros.\nNo \u00faltimo passo, os caminhos gerados na matriz adr s\u00e3o percorridos, rotulando-se o pixel avaliado\nde acordo com o final do caminho, correspondente a um m\u00ednimo regional. Na visita\u00e7\u00e3o \u00e9 utilizada a\nt\u00e9cnica de compress\u00e3o de caminhos, de modo que cada pixel neste passa a apontar diretamente para\no final do caminho, otimizando a busca por seu r\u00f3tulo no momento da sua avalia\u00e7\u00e3o.\n\n\n\n54 Algoritmos de Watershed\n\nAnalisando-se o comportamento deste algoritmo, os tr\u00eas passos iniciais apenas constr\u00f3em os ca-\nminhos entre qualquer pixel e seu m\u00ednimo regional correspondente. O \u00faltimo passo, respons\u00e1vel pela\nrotula\u00e7\u00e3o, atravessa esses caminhos at\u00e9 encontrar o fim deles, caracterizando uma busca em profun-\ndidade. A Fig. 3.10 apresenta um exemplo de resultados do algoritmo componentes conexos, com as\nduas possibilidades de solu\u00e7\u00f5es, geradas por varredura em raster e anti-raster. A diferen\u00e7a entre as\nduas solu\u00e7\u00f5es corresponde ao pixel que na defini\u00e7\u00e3o TD-WT \u00e9 rotulado como watershed, como pode\nser visto entre outras na Fig. 3.6.\n\n(a) (b) (c)\n\nFig. 3.10: Componentes Conexos. (a) Imagem, (b) Resultado em raster, (c) Resultado em anti-raster\n(N4)\n\n3.6.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nPLATEAU = ?1\n\nd e f c o n n e c t e d C o m p o n e n t s ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nl a b [ : ] = MASK\na d r = ws . makeWorkCopy ( 0 )\n\nq u e u e = wsQueue ( )\n\nd e f f i n d ( p ) :\nq = p\nw h i l e a d r [ q ] ! = q :\n\nq = a d r [ q ]\nu = p\n\n\n\n3.6 Algoritmo Componentes Conexos de Bieniek e Moga 55\n\nw h i l e a d r [ u ] ! = q :\nv = a d r [ u ]\na d r [ u ] = q\nu = v\n\nr e t u r n q\n\n# s t e p 1\nf o r p i n D :\n\nq = p\nf o r u i n N( p ) :\n\ni f im [ u ] &lt;im [ q ] :\nq = u\n\ni f q ! = p :\na d r [ p ] = q\n\ne l s e :\na d r [ p ] = PLATEAU\n\n# s t e p 2\nf o r p i n D :\n\ni f a d r [ p ] ! = PLATEAU :\nc o n t i n u e\n\nf o r q i n N( p ) :\ni f a d r [ q ] == PLATEAU o r im [ q ] ! = im [ p ] :\n\nc o n t i n u e\n\nq u e u e . p u s h ( q )\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\nf o r q i n N( p ) :\n\ni f a d r [ q ] ! = PLATEAU o r im [ q ] ! = im [ p ] :\nc o n t i n u e\n\na d r [ q ] = p\nq u e u e . p u s h ( q )\n\n# s t e p 3\nf o r p i n D :\n\ni f a d r [ p ] ! = PLATEAU :\nc o n t i n u e\n\na d r [ p ] = p\n\nf o r q i n N( p ) :\ni f q > p o r im [ q ] ! = im [ p ] :\n\nc o n t i n u e\n\n\n\n56 Algoritmos de Watershed\n\nu = f i n d ( p )\nv = f i n d ( q )\na d r [ u ] = a d r [ v ] = min ( u , v )\n\n# s t e p 4\nb a s i n s = 1\nf o r p i n D :\n\nr = f i n d ( p )\na d r [ p ] = r\ni f l a b [ r ] == MASK:\n\nl a b [ r ] = b a s i n s\nb a s i n s += 1\n\nl a b [ p ] = l a b [ r ]\n\nr e t u r n ws . e n d ( )\n\n3.7 Algoritmo Union-Find de Meijster e Roerdink\nAp\u00f3s a proposta da defini\u00e7\u00e3o TD-WT por Meyer [7], com algoritmos fracamente definidos e\n\ninadequados para obter os resultados de acordo com a defini\u00e7\u00e3o [12], Meijster e Roerdink prop\u00f5em\num algoritmo baseado na defini\u00e7\u00e3o de downstream e que implementa corretamente tal defini\u00e7\u00e3o [22].\nO algoritmo Union-Find utiliza opera\u00e7\u00f5es de compress\u00e3o de caminho e verifica\u00e7\u00e3o de unicidade de\nr\u00f3tulos sobre um d\u00edgrafo ac\u00edclico (DAG - directed acyclic graph), constru\u00eddo sobre uma imagem\nsem zonas planas. Desta forma, s\u00e3o utilizados de fato tr\u00eas algoritmos em separado, com suas sa\u00eddas\nconcatenadas: remo\u00e7\u00e3o de zonas planas, constru\u00e7\u00e3o do DAG e resolu\u00e7\u00e3o de r\u00f3tulos. Assim, o Alg. 8\nconstr\u00f3i o d\u00edgrafo ac\u00edclico da imagem sem zonas planas e o Alg. 9 efetua a resolu\u00e7\u00e3o de r\u00f3tulos por\nunion-find.\n\nALGORITMO 8: DAG\nEntrada: im: Imagem de n\u00edveis de cinza\nSaida: sln: D\u00edgrafo representado sob forma de matriz indexado pelo pixel\n\n1: for p ? D do\n2: if ?(p) = ? then\n3: ?(p) ? {q ? N(p) | im(q) = min?u?N(p)im(u), im(q) &lt;im(p)}\n4: if ?(p) = ? then\n5: ?(p) ? p\n6: if ?q ? N(p) | im(q) = im(p) then\n7: QUEUEPUSH(p)\n8: while QUEUEEMPTY() = false do\n9: q = QUEUEPOP()\n\n10: for u ? N(q) | im(u) = im(p) do\n\n\n\n3.7 Algoritmo Union-Find de Meijster e Roerdink 57\n\n11: if ?(u) = ? then\n12: ?(u) = p\n13: QUEUEPUSH(u)\n14: end if\n15: end for\n16: end while\n17: end if\n18: end if\n19: end if\n20: i ? 0\n21: for all q ? ?(p) do\n22: sln[p,i] ? q\n23: i ? i + 1\n24: end for\n25: end for\n\nALGORITMO 9: Union-Find\nEntrada: sln: D\u00edgrafo representado sob forma de matriz indexado pelo pixel\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: W ? -1\n3: N ? 4\n4: ?p ? D, lab(p) ? MASK\n5: basins ? 1\n6: End\n\n7: for p ? D do\n8: r ?FIND(p)\n9: if r ?= W then\n\n10: if lab(r) = MASK then\n11: lab(r) ? basins\n12: basins ? basins + 1\n13: end if\n14: lab(p) ? lab(r)\n15: else\n16: lab(p) ? WSHED\n17: end if\n18: end for\n\n\n\n58 Algoritmos de Watershed\n\n1: Procedure FIND(p)\n2: rep ? 0\n3: i ? 1\n4: while i ? N and rep ?= W do\n5: if sln[p,i] ?= p and sln[p,i] ?= W then\n6: sln[p,i] ? FIND(sln[p,i])\n7: end if\n8: if i = 1 then\n9: rep ? sln[p,1]\n\n10: else if sln[p,i] ?= rep then\n11: rep ? W\n12: for all j ? [1, N] do\n13: sln[p,j] ? W\n14: end for\n15: end if\n16: i ? i + 1\n17: end while\n18: return rep\n19: End\n\nA constru\u00e7\u00e3o do DAG \u00e9 feita definindo um v\u00e9rtice para cada pixel e conectando estes de acordo\ncom seu downstream. Esta regra, calculada na linha 3, \u00e9 v\u00e1lida para todos os pixels da imagem,\npois esta n\u00e3o cont\u00e9m zonas planas, exceto aqueles de m\u00ednimo regional, onde ?(p) ser\u00e1 vazio para\ntodo o componente conexo, que recebe ent\u00e3o tratamento especial. Nestas regi\u00f5es, o primeiro pixel\ndescoberto como pertencente a ela (?(p) = ?) passa a ser o seu representante, e propaga-se seu\nendere\u00e7o para seus vizinhos de componente, modificando seus valores de ? antes de serem visitados,\no que exige a condi\u00e7\u00e3o de teste na linha 2. As linhas 20 a 24 tratam de transformar o downstream na\nforma de armazenamento de grafo na matriz sln adotada. A Fig. 3.11 apresenta em (a) a imagem de\nexemplo sem zonas planas utilizada ao longo deste cap\u00edtulo. Sobre esta \u00e9 calculado o DAG mostrado\nem (b) de acordo com o Alg. 8.\n\nA etapa de resolu\u00e7\u00e3o dos r\u00f3tulos a partir do DAG, apresentada no Alg. 9, busca, a partir de\ncada v\u00e9rtice, seguir os caminhos formados por suas arestas direcionadas at\u00e9 um v\u00e9rtice sem arestas\nde sa\u00edda, indicando ser o representante de um m\u00ednimo regional. Esta opera\u00e7\u00e3o, chamada de Find,\nadv\u00e9m do algoritmo de gerenciamento de conjuntos desconexos de Tarjan [27], chamado de Union-\nFind, cujo nome foi trazido para o contexto da transformada watershed, dada sua import\u00e2ncia. Ao\nencontrar dois r\u00f3tulos diferentes ating\u00edveis a partir do mesmo v\u00e9rtice, este passa a ser identificado\ncomo um pixel de watershed (linhas 10 e 11 na opera\u00e7\u00e3o Find). \u00c9 importante tamb\u00e9m notar o car\u00e1ter\nrecursivo desta opera\u00e7\u00e3o, com a compress\u00e3o dos caminhos, evitando a repeti\u00e7\u00e3o de percursos.\n\nDa mesma forma que o Alg. Componentes Conexos (Alg. 7), este tamb\u00e9m pode ser caracterizado\ncomo uma busca em profundidade, justamente pelo comportamento da opera\u00e7\u00e3o Find na resolu\u00e7\u00e3o\ndos r\u00f3tulos. Em particular, pode-se dizer que o Alg. 7 \u00e9 um caso particular deste, onde cada v\u00e9rtice\npode possuir apenas uma aresta de sa\u00edda [12]. O resultado final da resolu\u00e7\u00e3o de r\u00f3tulos sobre o DAG\n\n\n\n3.7 Algoritmo Union-Find de Meijster e Roerdink 59\n\n(a)\n\n??\n\n?\n\n??\n\n?\n\n?\n\n??\n\n??\n\n?\n\n??\n\n??\n\n? ?\n\n? ? ?? ??\n\n(b)\n\nFig. 3.11: Constru\u00e7\u00e3o do DAG. (a) Imagem sem zonas planas, (b) DAG\n\nda Fig. 3.11 (b) \u00e9 apresentado na Fig. 3.12, igualando-se aos outros algoritmos que implementam a\ndefini\u00e7\u00e3o TD-WT. \u00c9 importante ressaltar que o resultado do DAG deve ser id\u00eantico ao LCG, exceto\nnos m\u00ednimos regionais, onde os v\u00e9rtices no LCG n\u00e3o t\u00eam arestas, e no DAG as arestas levam a um\nrepresentante do componente.\n\n(a) (b)\n\nFig. 3.12: Union-Find. (a) Imagem, (b) Resultado (N4)\n\n3.7.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nWSHED = 0\nW = ?1\n\n\n\n60 Algoritmos de Watershed\n\nMASK = ?2\n\nd e f u n i o n F i n d ( im , o f f s e t s ) :\n\nl c = l o w e r C o m p l e t e ( im , o f f s e t s )\ns l n = d i g r a p h ( l c , o f f s e t s )\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( l c )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nl a b [ : ] = MASK\nb a s i n s = 1\n\nd e f f i n d ( p ) :\nr e p = 0\ni = 0\ngamma = s l n [ p ]\nw h i l e i &lt;l e n ( gamma ) and r e p ! = W:\n\ni f gamma [ i ] ! = p and gamma [ i ] ! = W:\ngamma [ i ] = f i n d ( gamma [ i ] )\n\ni f i == 0 :\nr e p = gamma [ 0 ]\n\ne l i f gamma [ i ] ! = r e p :\nr e p = W\nf o r j i n r a n g e ( l e n ( gamma ) ) :\n\ngamma [ j ] = W\ni += 1\n\nr e t u r n r e p\n\nf o r p i n D :\n\nr = f i n d ( p )\ni f r ! = W:\n\ni f l a b [ r ] == MASK:\nl a b [ r ] = b a s i n s\nb a s i n s += 1\n\nl a b [ p ] = l a b [ r ]\ne l s e :\n\nl a b [ p ] = WSHED\n\nr e t u r n ws . e n d ( )\n\nd e f d i g r a p h ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\n\n\n\n3.8 Algoritmo IFT de Lotufo e Falc\u00e3o 61\n\nws = wsImage ( im )\nN , im , l c , D = ws . b e g i n ( o f f s e t s )\n\ns l n = d i c t ( )\n\n# s c a n t h e i m a g e\nf o r p i n D :\n\ni f s l n . h a s \\ _ k e y ( p ) :\nc o n t i n u e # i s p a r t o f t h e m i n i m a l p l a t e a u\n\ngamma = l i s t ( )\nm i n v a l u e = min ( im [N( p ) ] )\np l a t e a u = F a l s e\nf o r q i n N( p ) :\n\ni f im [ q ] == m i n v a l u e and im [ q ] &lt;im [ p ] :\ngamma . a p p e n d ( q )\n\ni f im [ q ] == im [ p ] :\np l a t e a u = T r u e\n\ni f l e n ( gamma ) == 0 :\ni f p l a t e a u :\n\n# m i n i m a l p l a t e a u\nq u e u e = wsQueue ( )\nq u e u e . p u s h ( p )\ngamma . a p p e n d ( p ) # make t h e f i r s t o n e t h e r e p r e s e n t a t i v e\nw h i l e n o t q u e u e . e m p t y ( ) :\n\nq = q u e u e . pop ( )\nf o r u i n N( q ) :\n\ni f im [ u ] == im [ p ] :\ni f n o t s l n . h a s \\ _ k e y ( u ) :\n\ns l n [ u ] = [ p ]\nq u e u e . p u s h ( u )\n\ne l s e :\ngamma . a p p e n d ( p ) # one?p i x e l minimum\n\ns l n [ p ] = gamma\n\nr e t u r n s l n\n\n3.8 Algoritmo IFT de Lotufo e Falc\u00e3o\nA transformada imagem-floresta (IFT - Image Foresting Transform) \u00e9 em sua ess\u00eancia uma ge-\n\nneraliza\u00e7\u00e3o dos algoritmos de Dijkstra [39] e Moore [40] com a implementa\u00e7\u00e3o baseada em filas de\nprioridade proposta por Dial [42] para fins de c\u00e1lculo de uma floresta de caminhos m\u00ednimos [19].\nDiversas aplica\u00e7\u00f5es para este algoritmo s\u00e3o poss\u00edveis variando-se seus par\u00e2metros [8], mas, no con-\n\n\n\n62 Algoritmos de Watershed\n\ntexto da transformada watershed, utiliza-se a fun\u00e7\u00e3o de custo de m\u00e1ximo [19]. No entanto, o uso\nda fila hier\u00e1rquica com pol\u00edtica FIFO implica no uso indireto do custo lexicogr\u00e1fico, tornando assim\no custo a ser minimizado para cada pixel baseado em duas componentes. Assim, de acordo com o\nformalizado na se\u00e7\u00e3o 2.2.5, o Alg. 10 implementa a defini\u00e7\u00e3o IFT-WT.\n\nALGORITMO 10: IFT\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D, S: marcadores\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D, done(p) ? false\n3: ?p ?? S, C1(p) ? ?, lab(p) ? MASK, parent(p) ? MASK\n4: ?p ? S, C1(p) ? im(p), lab(p) ? ?(p), parent(p) ? p, HEAPQUEUEPUSH(p,\n\nim(p))\n5: End\n\n6: while HEAPQUEUEEMPTY() = false do\n7: p ? HEAPQUEUEPOP()\n8: done(p) ? true\n9: for all q ? N(p) | done(q) = false do\n\n10: c ? max (C1(p), im(q))\n11: if c &lt;C1(q) then\n12: if HEAPQUEUECONTAINS(q) then\n13: HEAPQUEUEREMOVE(q)\n14: end if\n15: C1(q) ? c\n16: lab(q) ? lab(p)\n17: parent(q) ? p\n18: HEAPQUEUEPUSH(q, C1(q))\n19: end if\n20: end for\n21: end while\n\nO Alg. 10, como mencionado anteriormente, \u00e9 uma generaliza\u00e7\u00e3o, e, portanto, assemelha-se\nmuito \u00e0 abordagem de Dijkstra e aos Algs. Dijkstra-Moore de Caminhos M\u00ednimos (Alg. 4) e Fila\nde Prioridade (Alg. 3). Sua principal diferen\u00e7a est\u00e1 na utiliza\u00e7\u00e3o expl\u00edcita de uma fun\u00e7\u00e3o de custo,\napresentada como o m\u00e1ximo do caminho para obter os resultados da defini\u00e7\u00e3o IFT-WT, mas que\npoderia ser substitu\u00edda pela dist\u00e2ncia topogr\u00e1fica para produzir solu\u00e7\u00f5es de acordo com a defini\u00e7\u00e3o\nTD-WT. Por ser um algoritmo de prop\u00f3sito mais geral, este tamb\u00e9m necessita gerenciar a remo\u00e7\u00e3o e\nreinser\u00e7\u00e3o na fila de prioridade, dependendo do custo encontrado (linhas 12 e 13). No entanto, como\nvisto na Fig. 2 da ref. [19], para a fun\u00e7\u00e3o de custo m\u00e1ximo, esta remo\u00e7\u00e3o n\u00e3o \u00e9 necess\u00e1ria, e, assim,\no algoritmo pode ser degenerado no Alg. Fila de Prioridade (Alg. 3, Se\u00e7\u00e3o 3.2).\n\n\n\n3.8 Algoritmo IFT de Lotufo e Falc\u00e3o 63\n\nDe fato, estes passam a apresentar o mesmo comportamento, efetuando uma busca em largura\ncom crit\u00e9rio dependente do custo do caminho. Ainda em rela\u00e7\u00e3o ao Alg. 10, este faz uso da fun\u00e7\u00e3o\n?, que representa alguma rotula\u00e7\u00e3o utilizada para os pixels, gerada pelos componentes conexos ou\narbitrariamente por um usu\u00e1rio, por exemplo. Como resultado, al\u00e9m da segmenta\u00e7\u00e3o da imagem,\n\u00e9 produzida a floresta, onde cada pixel tem apenas um antecessor, denotado por parent (p), e cada\nregi\u00e3o \u00e9 uma \u00e1rvore.\n\nA implementa\u00e7\u00e3o do algoritmo IFT depende de um algoritmo de detec\u00e7\u00e3o de m\u00ednimos regionais\ne de uma fila de prioridade com pol\u00edtica FIFO. No entanto, seu uso mais comum \u00e9 com marcadores\nescolhidos e rotulados pelo usu\u00e1rio: sendo assim, seu desempenho grandemente dependente da fila. O\nalgoritmo IFT implementa a corre\u00e7\u00e3o comentada no Alg. 3 para tratar o uso de marcadores arbitr\u00e1rios\nna transformada watershed. A Fig. 3.13 apresenta um dos poss\u00edveis resultados e a floresta gerada para\neste.\n\n(a) (b)\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n? ?\n\n? ? ? ?\n\n(c)\n\nFig. 3.13: IFT. (a) Imagem, (b) Resultado, (c) Floresta resultante com ra\u00edzes em cinza. (N4)\n\n3.8.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\n\nd e f i f t ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n\n\n64 Algoritmos de Watershed\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\n# c r e a t e t h e w o r k i n g i m a g e s\nd o n e = ws . makeWorkCopy ( F a l s e )\nc 1 = ws . makeWorkCopy ( i n f )\np a r = ws . makeWorkCopy (MASK)\n\nl a b [ : ] = MASK\n\nq u e u e = wsHeapQueue ( )\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nc 1 [ p ] = im [ p ]\nl a b [ p ] = m+1\np a r [ p ] = p\nq u e u e . p u s h ( p , im [ p ] )\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\nd o n e [ p ] = T r u e\nf o r q i n N( p ) :\n\ni f d o n e [ q ] :\nc o n t i n u e\n\nc = max ( c 1 [ p ] , im [ q ] )\ni f c &lt;c 1 [ q ] :\n\ni f c 1 [ q ] &lt;i n f :\ni f q u e u e . c o n t a i n s ( q , c 1 [ q ] ) :\n\nq u e u e . r e m o v e ( q , c 1 [ q ] )\nc 1 [ q ] = c\nl a b [ q ] = l a b [ p ]\np a r [ q ] = p\nq u e u e . p u s h ( q , c 1 [ q ] )\n\nr e t u r n ws . e n d ( )\n\n3.9 Algoritmo C\u00f3digo de Corrente de Sun, Yang e Ren\n\nO algoritmo de c\u00f3digo de corrente para transformada watershed, proposto por Sun, Yang e Ren\n[23], estende a no\u00e7\u00e3o comum desta t\u00e9cnica de detec\u00e7\u00e3o de contornos para uso na indica\u00e7\u00e3o dos\ncaminhos de m\u00e1xima inclina\u00e7\u00e3o. De fato, o algoritmo \u00e9 baseado na proposta de Bieniek e Moga\n[29], executando passos muito semelhantes em objetivo, e, como este, produz resultados condizentes\ncom a defini\u00e7\u00e3o LC-WT. Todavia, apesar da semelhan\u00e7a, o Alg. 11, apresentado abaixo, pode ser\nmodificado para produzir outras informa\u00e7\u00f5es \u00fateis mais facilmente, como por exemplo a \u00e1rea [23].\n\n\n\n3.9 Algoritmo C\u00f3digo de Corrente de Sun, Yang e Ren 65\n\nALGORITMO 11: C\u00f3digo de Corrente\n\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D : out(p) ? MASK, in(p) ? 0\n3: basins ? 1\n4: End\n\n5: // Passo 1\n6: for p ? D do\n7: q ? u ? N(p) : im(u) = min?v?N(p)im(v) and im(u) &lt;im(p)\n8: if q ?= ? then\n9: out(p) ? ARROW(p,q)\n\n10: in(q) ? in(q) ? POINTIN(p,q)\n11: end if\n12: end for\n\n13: // Passo 2\n14: for all p ? D | out(p) ?= MASK do\n15: if ?q | q ? N(p), out(q) = MASK and im(p) = im(q) then\n16: QUEUEPUSH(p)\n17: end if\n18: end for\n19: while QUEUEEMPTY() = false do\n20: p ? QUEUEPOP()\n21: for q ? N(p) | im(p) = im(q) and out(q) = MASK do\n22: out(q) ? ARROW(q,p)\n23: in(p) ? in(p) ? POINTIN(q,p)\n24: QUEUEPUSH(q)\n25: end for\n26: end while\n\n27: // Passo 3\n28: for p ? D | out(p) = MASK do\n29: for q ? N(p) | im(p) = im(q) do\n30: out(q) ? ARROW(q,p)\n31: in(p) ? in(p) ? POINTIN(q,p)\n32: STACKPUSH(q)\n33: end for\n34: while STACKEMPTY() = false do\n35: u ? STACKPOP()\n\n\n\n66 Algoritmos de Watershed\n\n36: for v ? N(u) | im(u) = im(v) do\n37: if out(v) = MASK and v ?= p then\n38: out(v) ? ARROW(v,u)\n39: in(u) ? in(u) ? POINTIN(v,u)\n40: STACKPUSH(v)\n41: end if\n42: end for\n43: end while\n44: end for\n\n45: // Passo 4\n46: for p ? D | out(p) = MASK do\n47: STACKPUSH(p)\n48: while STACKEMPTY() = false do\n49: u ? STACKPOP()\n50: lab(u) ? basins\n51: for all v ? N(u) | POINTIN(v , u) ? in(u) do\n52: lab(v) ? basins\n53: STACKPUSH(v)\n54: end for\n55: end while\n56: basins ? basins + 1\n57: end for\n\n58: Procedure POINTIN(p,q)\n59: return ARROW(q,p)\n60: End\n\nO principal ponto na compreens\u00e3o do Alg. 11 \u00e9 o uso das matrizes out e in, que armazenam a di-\nre\u00e7\u00e3o do vizinho m\u00ednimo e dos vizinhos para os quais o pixel em quest\u00e3o \u00e9 m\u00ednimo, respectivamente.\nEstas matrizes correspondem aos conceitos de downstream e upstream. Assim, os tr\u00eas primeiros pas-\nsos efetuam o c\u00e1lculo destes valores para todos os pixels da imagem, escolhendo um representante\npara cada componente conexo de m\u00ednimo regional e direcionando os outros para este. Desta forma,\nconstr\u00f3i-se implicitamente um grafo direcionado e formam-se caminhos de todos os pixels para um\nm\u00ednimo regional. No \u00faltimo passo s\u00e3o gerados os r\u00f3tulos para os representantes e propaga-se este\nr\u00f3tulo seguindo o caminho a partir do upstream. Esta \u00faltima etapa, onde o algoritmo torna-se similar\nao Alg. Hill Climbing (Alg. 5), caracteriza-o como uma busca em profundidade, pois utiliza uma\nestrutura de pilha para visita\u00e7\u00e3o dos pixels de upstream, assim percorrendo o caminho o m\u00e1ximo\nposs\u00edvel antes de iniciar outro.\n\n\u00c9 importante tamb\u00e9m ressaltar as fun\u00e7\u00f5es Arrow e PointIn utilizadas no Alg. 11. A primeira,\ndescrita na se\u00e7\u00e3o 2.1.4 \u00e9 convencionada com valores de retorno em [0, N). A segunda faz uso da\nprimeira para indicar a dire\u00e7\u00e3o contr\u00e1ria do caminho, invertendo-se os par\u00e2metros de entrada. Desta\n\n\n\n3.9 Algoritmo C\u00f3digo de Corrente de Sun, Yang e Ren 67\n\nforma o endere\u00e7o da dire\u00e7\u00e3o tamb\u00e9m \u00e9 invertido, gerando o n\u00famero corretamente. O Alg. 11 utiliza\nestes valores em in indicando-os como um conjunto, por\u00e9m a programa\u00e7\u00e3o desta forma seria muito\ndispendiosa em termos de uso de mem\u00f3ria. Assim, Sun, Yang e Ren [23] utilizam os endere\u00e7os\ndos vizinhos como flags bin\u00e1rias na mem\u00f3ria, e ent\u00e3o torna-se poss\u00edvel, por exemplo, com um byte,\nindicar que um pixel pertence ao downstream de at\u00e9 oito vizinhos seus e utilizando opera\u00e7\u00f5es r\u00e1pidas\npara isto. A Fig. 3.14 apresenta um exemplo do uso do algoritmo c\u00f3digo de corrente.\n\n(a) (b)\n\nFig. 3.14: C\u00f3digo de Corrente. (a) Imagem, (b) Resultado (N4)\n\n3.9.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\n\nd e f c h a i n C o d e ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nw o u t = ws . makeWorkCopy (MASK)\nwin = ws . makeWorkCopy ( 0 )\nb a s i n s = 1\nq u e u e = wsQueue ( )\ns t a c k = w s S t a c k ( )\n\nd e f p o i n t O u t ( p , q ) :\n# f i n d s t h e o f f s e t\nc = q ? p\n# q u e r y t h e n e i g h b o u r h o o d f o r t h e o f f s e t\ni d x = ws . n e i g h b o u r . q u e r y ( c )\ni f i d x == ?1:\n\nr a i s e E x c e p t i o n ( \" N e i g h b o u r n o t f o u n d \" )\n\n\n\n68 Algoritmos de Watershed\n\nr e t u r n i d x\n\nd e f p o i n t I n ( p , q ) :\ni d x = p o i n t O u t ( q , p )\nr e t u r n 1&lt;&lt;i d x\n\n# s t e p 1\nf o r p i n D :\n\nm i n v a l u e = min ( im [N( p ) ] )\nminpx = None\n\nf o r q i n N( p ) :\n\ni f im [ q ] &lt;im [ p ] and im [ q ] == m i n v a l u e :\nminpx = q\n\ni f n o t minpx i s None :\nw o u t [ p ] = p o i n t O u t ( p , minpx )\nwin [ minpx ] | = p o i n t I n ( p , minpx )\n\n# s t e p 2\nf o r p i n D :\n\ni f w o u t [ p ] == MASK:\nc o n t i n u e\n\nf o r q i n N( p ) :\n\ni f w o u t [ q ] == MASK and im [ q ] == im [ p ] :\nq u e u e . p u s h ( p )\nb r e a k\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\nf o r q i n N( p ) :\n\ni f im [ p ] == im [ q ] and w o u t [ q ] == MASK:\nw o u t [ q ] = p o i n t O u t ( q , p )\nwin [ p ] | = p o i n t I n ( q , p )\nq u e u e . p u s h ( q )\n\n# s t e p 3\nf o r p i n D :\n\ni f w o u t [ p ] ! = MASK:\nc o n t i n u e\n\nf o r q i n N( p ) :\ni f im [ q ] ! = im [ p ] :\n\nc o n t i n u e\n\nw o u t [ q ] = p o i n t O u t ( q , p )\n\n\n\n3.10 Algoritmo Zona de Empate de Audigier, Lotufo e Couprie 69\n\nwin [ p ] | = p o i n t I n ( q , p )\ns t a c k . p u s h ( q )\n\nw h i l e n o t s t a c k . e m p t y ( ) :\nu = s t a c k . pop ( )\nf o r v i n N( u ) :\n\ni f im [ u ] == im [ v ] and w o u t [ v ] == MASK and v ! = p :\nw o u t [ v ] = p o i n t O u t ( v , u )\nwin [ u ] | = p o i n t I n ( v , u )\ns t a c k . p u s h ( v )\n\n# s t e p 4\nf o r p i n D :\n\ni f w o u t [ p ] ! = MASK:\nc o n t i n u e\n\ns t a c k . p u s h ( p )\nw h i l e n o t s t a c k . e m p t y ( ) :\n\nu = s t a c k . pop ( )\nl a b [ u ] = b a s i n s\nf o r v i n N( u ) :\n\n# c h e c k s i f v i s i n i n? l i s t o f u\ni f p o i n t I n ( v , u ) &amp; win [ u ] > 0 :\n\nl a b [ v ] = b a s i n s\ns t a c k . p u s h ( v )\n\nb a s i n s += 1\n\nr e t u r n ws . e n d ( )\n\n3.10 Algoritmo Zona de Empate de Audigier, Lotufo e Couprie\nO algoritmo de zona de empate, proposto por Audigier, Lotufo e Couprie [20], baseia-se na trans-\n\nformada watershed por IFT, vista na se\u00e7\u00e3o 3.8, de forma a unificar suas solu\u00e7\u00f5es, provendo um algo-\nritmo de transformada watershed com fun\u00e7\u00e3o de custo de caminho m\u00e1ximo e solu\u00e7\u00e3o \u00fanica, coerente\ncom a defini\u00e7\u00e3o TZ-IFT-WT, apresentada na Sec. 2.2.5. Para realizar corretamente o c\u00e1lculo dos\npixels de zona de empate, o Alg. IFT (Alg. 10) \u00e9 modificado, de modo a explicitamente armazenar os\ncustos lexicogr\u00e1ficos, necess\u00e1rios para determinar as situa\u00e7\u00f5es em que o pixel receber\u00e1 o r\u00f3tulo TZ.\nO Alg. 12 apresenta as modifica\u00e7\u00f5es comentadas.\n\nALGORITMO 12: Zona de Empate\n\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D, S: marcadores\nSaida: lab: Imagem rotulada\n\n\n\n70 Algoritmos de Watershed\n\n1: Initialise\n2: ?p ? D, C2(p) ? 0 done(p) ? false\n3: ?p ?? S, C1(p) ? ?, lab(p) ? MASK, parent(p) ? MASK\n4: ?p ? S, C1(p) ? im(p), lab(p) ? ?(p), parent(p) ? p, HEAPQUEUEPUSH(p,\n\nim(p))\n5: End\n\n6: while HEAPQUEUEEMPTY() = false do\n7: p ? HEAPQUEUEPOP()\n8: done(p) ? true\n9: for all q ? N(p) | done(q) = false do\n\n10: c ? max (C1(p), im(q))\n11: if c &lt;C1(q) then\n12: if HEAPQUEUECONTAINS(q) then\n13: HEAPQUEUEREMOVE(q)\n14: end if\n15: C1(q) ? c\n16: lab(q) ? lab(p)\n17: parent(q) ? p\n18: HEAPQUEUEPUSH(q, C1(q))\n19: if c = C1(p) then\n20: C2(q) ? C2(p) + 1\n21: end if\n22: else if c = C1(q) and lab(q) ?= lab(p) then\n23: if c = C1(p) then\n24: if C2(q) = C2(p) + 1 then\n25: lab(q) ? TIE-ZONE\n26: end if\n27: else\n28: lab(q) ? TIE-ZONE\n29: end if\n30: end if\n31: end for\n32: end while\n\nAs modifica\u00e7\u00f5es em rela\u00e7\u00e3o ao Alg. 10 s\u00e3o efetuadas nas linhas 19 a 29, onde a imagem C2\narmazena o custo lexicogr\u00e1fico e este \u00e9 avaliado quando o custo m\u00e1ximo n\u00e3o satisfizer a condi\u00e7\u00e3o de\nunicidade. A condi\u00e7\u00e3o testada na linha 22 verifica se dois caminhos atingiram um pixel com mesmo\ncusto m\u00e1ximo e que estes t\u00eam r\u00f3tulos diferentes, indicando poss\u00edveis solu\u00e7\u00f5es diferentes. Em seguida,\nverifica-se na linha 23 se esta condi\u00e7\u00e3o foi atingida dentro de uma zona plana, que caso contr\u00e1rio,\nindica automaticamente um empate. Se, dentro desta zona plana, os custos lexicogr\u00e1ficos forem\niguais (linha 24) ent\u00e3o constitui-se uma outra forma de empate, baseada na segunda componente do\n\n\n\n3.10 Algoritmo Zona de Empate de Audigier, Lotufo e Couprie 71\n\ncusto do caminho. Resumidamente, a zona de empate ocorre quando custo m\u00e1ximo e lexicogr\u00e1fico\ns\u00e3o iguais para um pixel, estando este em zona plana (C2 > 0) ou n\u00e3o (C2 = 0).\n\nApesar das modifica\u00e7\u00f5es efetuadas, o comportamento do algoritmo n\u00e3o \u00e9 modificado, dado que\neste \u00e9 regido pela fila de prioridade, mantendo assim sua caracter\u00edstica de busca em largura, herdada\ndo Alg. 10. O r\u00f3tulo TZ, correspondente \u00e0s zonas de empate e respons\u00e1vel pela unicidade da solu\u00e7\u00e3o\ndo algoritmo, n\u00e3o deve ser interpretado como uma linha de watershed, mas como um identificador de\nambiguidade, onde mais de uma solu\u00e7\u00e3o \u00e9 poss\u00edvel mas todas s\u00e3o v\u00e1lidas [21]. A Fig. 3.15 apresenta\num exemplo de resultado produzido pelo algoritmo de zona de empate. Deve-se ressaltar que a zona\nde empate n\u00e3o garante a separa\u00e7\u00e3o entre regi\u00f5es. Este caso pode ser visto em uma zona plana onde\nno encontro de regi\u00f5es n\u00e3o h\u00e1 pixel onde o custo lexicogr\u00e1fico entre em empate.\n\n(a) (b)\n\nFig. 3.15: Zona de Empate da IFT. (a) Imagem, (b) Resultado (N4)\n\n3.10.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nTIE \\ _ZONE = 0\n\nd e f t i e Z o n e ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\n# c r e a t e t h e w o r k i n g i m a g e s\nd o n e = ws . makeWorkCopy ( F a l s e )\nc 1 = ws . makeWorkCopy ( i n f )\nc 2 = ws . makeWorkCopy ( 0 )\n\n\n\n72 Algoritmos de Watershed\n\np a r = ws . makeWorkCopy (MASK)\nl a b [ : ] = MASK\n\nq u e u e = wsHeapQueue ( )\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nc 1 [ p ] = im [ p ]\nl a b [ p ] = m+1\np a r [ p ] = p\nq u e u e . p u s h ( p , im [ p ] )\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\nd o n e [ p ] = T r u e\nf o r q i n N( p ) :\n\ni f d o n e [ q ] :\nc o n t i n u e\n\nc = max ( c 1 [ p ] , im [ q ] )\ni f c &lt;c 1 [ q ] :\n\ni f c 1 [ q ] &lt;i n f :\ni f q u e u e . c o n t a i n s ( q , c 1 [ q ] ) :\n\nq u e u e . r e m o v e ( q , c 1 [ q ] )\nc 1 [ q ] = c\nl a b [ q ] = l a b [ p ]\np a r [ q ] = p\nq u e u e . p u s h ( q , c 1 [ q ] )\ni f c == c 1 [ p ] :\n\nc 2 [ q ] = c 2 [ p ] + 1\ne l i f c == c 1 [ q ] and l a b [ q ] ! = l a b [ p ] :\n\ni f c == c 1 [ p ] :\ni f c 2 [ q ] == c 2 [ p ] + 1 :\n\nl a b [ q ] = TIE \\ _ZONE\ne l s e :\n\nl a b [ q ] = TIE \\ _ZONE\n\nr e t u r n ws . e n d ( )\n\n3.11 Algoritmo Tobog\u00e3 Invariante a Ordem de Lin et al.\n\nO algoritmo de tobog\u00e3 invariante a ordem, de Lin et al., prop\u00f5e um m\u00e9todo de resolu\u00e7\u00e3o de am-\nbiguidades referentes a ordem de processamento dos pixels de uma imagem [24]. Para isso, o r\u00f3tulo\nRIDGE \u00e9 utilizado quando dois caminhos de inclina\u00e7\u00e3o m\u00e1xima a partir de um mesmo pixel levam\na dois r\u00f3tulos diferentes. Esta proposta remete \u00e0 defini\u00e7\u00e3o TD-WT [7] e ao algoritmo Union-Find\npara watershed de Meijster e Roerdink [22]. No entanto, a equival\u00eancia direta entre estas propostas\ns\u00f3 ocorre quando a imagem tem suas zonas planas removidas. Isto se deve \u00e0 natureza da defini\u00e7\u00e3o\nTD-WT, sabidamente problem\u00e1tica nestas zonas, por ter custo zero no caminho [12]. Todavia, o al-\n\n\n\n3.11 Algoritmo Tobog\u00e3 Invariante a Ordem de Lin et al. 73\n\ngoritmo de Lin et al. n\u00e3o tem como requisito o processo de remo\u00e7\u00e3o de zonas planas, tratando este\nproblema implicitamente atrav\u00e9s do c\u00e1lculo das dist\u00e2ncias geod\u00e9sicas at\u00e9 as bordas. Entretanto, o\nprocesso de rotula\u00e7\u00e3o n\u00e3o utiliza esta informa\u00e7\u00e3o na avalia\u00e7\u00e3o dos r\u00f3tulos, causando portanto a dife-\nren\u00e7a. A corre\u00e7\u00e3o deste problema \u00e9 simples, bastando restringir o conjunto de pixels em que o r\u00f3tulo\nser\u00e1 avaliado, aderindo ent\u00e3o \u00e0 defini\u00e7\u00e3o TD-WT. O Alg. 13 apresenta o pseudoc\u00f3digo corrigido\nrestringindo a avali\u00e7\u00e3o de r\u00f3tulos no conjunto Smin, contendo os elementos de S onde a dist\u00e2ncia \u00e9\nm\u00ednima dentro deste.\n\nALGORITMO 13: Tobog\u00e3 Invariante a Ordem\n\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D : lab(p) ? MASK\n3: End\n\n// Passo 1: Para cada pixel com vizinho menor, cria a lista de\n\nrampas m\u00e1ximas\n\n4: for all p ? D do\n5: h ? im(p)\n6: min ? min?q?N(p)im(q)\n7: if h > min then\n8: sliding(p) ? {q ? N(p) | im(q) = min}\n9: QUEUEPUSH(p)\n\n10: dist(p) ? 0\n11: end if\n12: end for\n\n// Passo 2: Propaga\u00e7\u00e3o das bordas para dentro de plateaus\n\n13: while QUEUEEMPTY() = false do\n14: p ? QUEUEPOP()\n15: d ? dist(p) + 1\n16: h ? im(p)\n17: for all q ? N(p) | im(q) = h do\n18: if sliding(q) = ? then\n19: sliding(q) ? {p}\n20: dist(q) ? d\n21: QUEUEPUSH(q)\n22: else if dist(q) = d then\n23: sliding(q) ? sliding(q) ?{p}\n24: end if\n25: end for\n26: end while\n\n// Passo 3: Rotula\u00e7\u00e3o dos m\u00ednimos\n\n27: basins? 1\n\n\n\n74 Algoritmos de Watershed\n\n28: for p ? D | sliding(p) = ? and lab(p) = MASK do\n29: lab(p) ? basins\n30: basins? basins+ 1\n31: QUEUEPUSH(p)\n32: h = im(p)\n33: while QUEUEEMPTY() = false do\n34: q ? QUEUEPOP()\n35: for all u ? N(q) | im(u) = h do\n36: if lab(u) = MASK then\n37: lab(u) ? lab(p)\n38: QUEUEPUSH(u)\n39: end if\n40: end for\n41: end while\n42: end for\n\n// Passo 4: Rotula\u00e7\u00e3o dos pixels por busca em profundidade\n\n43: for p ? D do\n44: RESOLVE(p)\n45: end for\n\n// Desce o caminho da gota recursivamente, at\u00e9 resolver todos os\n\nvizinhos\n\n1: Procedure RESOLVE(p)\n2: if lab(p) = MASK then\n3: S ? sliding(p)\n4: for q ? S do\n5: RESOLVE(q)\n6: end for\n7: dmin ? min?q?S dist(q)\n8: Smin ?{q ? S : dist(q) = dmin}\n9: if ?q ? Smin, lab(q) = ? then\n\n10: lab(p) ? ?\n11: else\n12: lab(p) ? WSHED\n13: end if\n14: end if\n15: End\n\nO Alg. 13 consiste de quatro passos b\u00e1sicos: cria\u00e7\u00e3o da lista de rampas m\u00e1ximas para cada\npixel com ao menos um vizinho em n\u00edvel de cinza menor, propaga\u00e7\u00e3o uniforme das rampas nas\nzonas planas, rotula\u00e7\u00e3o dos m\u00ednimos regionais, resolu\u00e7\u00e3o dos r\u00f3tulos dos pixels com base nas rampas\nm\u00e1ximas. A caracteriza\u00e7\u00e3o deste algoritmo como busca em profundidade se d\u00e1 na \u00faltima etapa,\nde resolu\u00e7\u00e3o dos r\u00f3tulos, onde os caminhos das rampas m\u00e1ximas s\u00e3o percorridos at\u00e9 a localiza\u00e7\u00e3o\n\n\n\n3.11 Algoritmo Tobog\u00e3 Invariante a Ordem de Lin et al. 75\n\nde um pixel j\u00e1 rotulado. Um dos complicadores para programa\u00e7\u00e3o deste algoritmo \u00e9 justamente\na lista de rampas m\u00e1ximas, necess\u00e1ria para cada pixel. Entretanto, algumas estrat\u00e9gias podem ser\nadotadas, como o uso de bits como sinalizadores de quais vizinhos do pixel pertencem \u00e0 lista, como\nproposto por Sun, Yang e Ren [23] para o armazenamento do upstream. De forma a processar zonas\nplanas uniformemente, uma fila \u00e9 utilizada para ordenamento dos pr\u00f3ximos pixels que devem ser\nprocessados.\n\nDe forma geral, o funcionamento do Alg. 13 corresponde \u00e0 constru\u00e7\u00e3o de um grafo direcionado\nac\u00edclico, formando caminhos de m\u00e1xima inclina\u00e7\u00e3o at\u00e9 m\u00ednimos regionais, e ent\u00e3o determinando se\ntodos os caminhos partindo de um v\u00e9rtice terminam em um mesmo m\u00ednimo regional, ou seja, se o\nr\u00f3tulo de seus caminhos \u00e9 \u00fanico. A partir desta avalia\u00e7\u00e3o \u00e9 definido se o pixel ser\u00e1 rotulado conforme\num m\u00ednimo ou como linha de watershed. Este processo une em apenas um algoritmo o m\u00e9todo\nUnion-Find [22, 12] que depende de tr\u00eas algoritmos, otimizando o acesso aos pixels. Aplicando o\nAlgoritmo 13, modificado da vers\u00e3o original, obt\u00e9m-se resultados \u00fanicos por imagem, independentes\nde ordem de varredura, aderentes \u00e0 defini\u00e7\u00e3o TD-WT e respeitando suas propriedades. A Fig. 3.16\napresenta um exemplo de resultado obtido usando o algoritmo de tobog\u00e3 invariante a ordem.\n\n(a) (b)\n\nFig. 3.16: Tobog\u00e3 Invariante a Ordem. (a) Imagem, (b) Resultado (N4)\n\n3.11.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nRIDGE = 0\n\nd e f o r d e r I n v a r i a n t T o b o g g a n ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nl a b [ : ] = MASK\n\n\n\n76 Algoritmos de Watershed\n\nq u e u e = wsQueue ( )\nd i s t = ws . makeWorkCopy ( 0 )\ns l i d i n g = d i c t ( )\n\nd e f r e s o l v e ( p ) :\ni f l a b [ p ] == MASK:\n\nS = s l i d i n g [ p ]\n\nf o r q i n S :\nr e s o l v e ( q )\n\ns i n g l e \\ _ l a b e l = T r u e\na l f a = None\n\ndmin = min ( d i s t [ S ] )\n\n# i d e n t i f i e s u n i q u e l a b e l on S\nf o r u i n S :\n\ni f d i s t [ u ] ! = dmin :\nc o n t i n u e\n\ni f a l f a i s None :\na l f a = l a b [ u ]\n\ne l s e :\ni f a l f a ! = l a b [ u ] :\n\ns i n g l e \\ _ l a b e l = F a l s e\n\ni f s i n g l e \\ _ l a b e l :\nl a b [ p ] = a l f a\n\ne l s e :\nl a b [ p ] = RIDGE\n\n# s t e p 1\nf o r p i n D :\n\nh = im [ p ]\nhmin = min ( im [N( p ) ] )\n\ni f h > hmin :\nS = l i s t ( )\nf o r q i n N( p ) :\n\ni f im [ q ] ! = hmin :\nc o n t i n u e\n\nS . a p p e n d ( q )\ns l i d i n g [ p ] = S\nq u e u e . p u s h ( p )\nd i s t [ p ] = 0\n\n\n\n3.12 Algoritmo Imers\u00e3o Invariante a Ordem de Lin et al. 77\n\n# s t e p 2\nw h i l e n o t q u e u e . e m p t y ( ) :\n\np = q u e u e . pop ( )\nd = d i s t [ p ] + 1\nh = im [ p ]\n\nf o r q i n N( p ) :\ni f im [ q ] ! = h :\n\nc o n t i n u e\n\ni f n o t s l i d i n g . h a s \\ _ k e y ( q ) :\ns l i d i n g [ q ] = [ p ]\nd i s t [ q ] = d\nq u e u e . p u s h ( q )\n\ne l i f d i s t [ q ] == d :\ns l i d i n g [ q ] . a p p e n d ( p )\n\n# s t e p 3\nb a s i n s = 1\nf o r p i n D :\n\ni f s l i d i n g . h a s \\ _ k e y ( p ) o r l a b [ p ] ! = MASK:\nc o n t i n u e\n\nl a b [ p ] = b a s i n s\nb a s i n s += 1\n\nq u e u e . p u s h ( p )\nh = im [ p ]\n\nw h i l e n o t q u e u e . e m p t y ( ) :\nq = q u e u e . pop ( )\nf o r u i n N( q ) :\n\ni f im [ u ] ! = h :\nc o n t i n u e\n\ni f l a b [ u ] == MASK:\nl a b [ u ] = l a b [ p ]\nq u e u e . p u s h ( u )\n\n# s t e p 4\nf o r p i n D :\n\nr e s o l v e ( p )\n\nr e t u r n ws . e n d ( )\n\n3.12 Algoritmo Imers\u00e3o Invariante a Ordem de Lin et al.\n\nEm paralelo ao algoritmo de tobog\u00e3, Lin et al. prop\u00f5e um algoritmo de imers\u00e3o invariante a\nordem utilizando os mesmos conceitos de resolu\u00e7\u00e3o de ambiguidades com o r\u00f3tulo RIDGE [24]. A\n\n\n\n78 Algoritmos de Watershed\n\ndiferen\u00e7a entre as propostas se d\u00e1 na ordem de processamento, onde, neste algoritmo, os pixels s\u00e3o\nvisitados de acordo com seu n\u00edvel em ordem ascendente, levando \u00e0 no\u00e7\u00e3o de imers\u00e3o. De modo a\nuniformizar a divis\u00e3o das zonas planas, estas s\u00e3o visitadas a partir das bordas calculando sua dist\u00e2ncia\ngeod\u00e9sica utilizando uma fila, caracterizando um algoritmo de busca em largura a partir dos m\u00ednimos\nregionais. O algoritmo de imers\u00e3o foi projetado para obter os mesmo resultados do tobog\u00e3 [24], e,\nassim, apesar de remeter \u00e0 defini\u00e7\u00e3o TD-WT, n\u00e3o a implementa completamente, ignorando a dist\u00e2ncia\ngeod\u00e9sica na resolu\u00e7\u00e3o dos r\u00f3tulos. Similarmente ao algoritmo tobog\u00e3, a corre\u00e7\u00e3o deste problema \u00e9\nfeita restringindo o conjunto S no conjunto Smin, onde os elementos de Smin s\u00e3o os elementos S com\nvalor de dist\u00e2ncia m\u00ednimo no conjunto, aderindo ent\u00e3o \u00e0 defini\u00e7\u00e3o TD-WT. O Algoritmo 14 apresenta\na implementa\u00e7\u00e3o do procedimento de imers\u00e3o invariante a ordem em pseudoc\u00f3digo.\n\nALGORITMO 14: Imers\u00e3o Invariante a Ordem\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D : lab(p) ? MASK\n3: End\n\n4: Ordene os pixels por seu valor de n\u00edvel de cinza, com m\u00ednimo hmin e m\u00e1ximo hmax\n\n5: basins ? 1\n6: for h ? [hmin, hmax ] do\n7: // Passo 1: Simula\u00e7\u00e3o de inunda\u00e7\u00e3o\n8: for all p ? D | im(p) = h do\n9: min ? min?q?N(p)im(q)\n\n10: if h > min then\n11: // Verifica todos os vizinhos que est\u00e3o no n\u00edvel m\u00ednimo\n\nencontrado\n\n12: S ?{q | q ? N(p) and im(q) = min}\n13: dmin ? min?q?S dist(q)\n14: Smin ?{q ? S : dist(q) = dmin}\n15: if ?q ? Smin, lab(q) = ? then\n16: lab(p) ? ? // Se o r\u00f3tulo for \u00fanico na menor dist\u00e2ncia,\n\natribui para o pixel\n\n17: else\n18: lab(p) ? WSHED // Se o r\u00f3tulo n\u00e3o for \u00fanico, cria uma\n\nbarreira\n\n19: end if\n20: QUEUEPUSH(p)\n21: dist(p) ? 0\n22: end if\n23: end for\n\n\n\n3.12 Algoritmo Imers\u00e3o Invariante a Ordem de Lin et al. 79\n\n24: // Passo 2: Crescimento de regi\u00f5es com base na dist\u00e2ncia\ngeod\u00e9sica dentro de zona plana\n\n25: while QUEUEEMPTY() = false do\n26: p ? QUEUEPOP()\n27: d ? dist(p) + 1\n28: for all q ? N(p) | im(q) = h do\n29: if lab(q) = MASK then\n30: lab(q) ? lab(p)\n31: dist(q) ? d\n32: QUEUEPUSH(q)\n33: else if lab(p) ?= lab(q) and dist(q) = d then\n34: lab(q) ? WSHED\n35: end if\n36: end for\n37: end while\n\n38: // Passo 3: Rotula\u00e7\u00e3o dos m\u00ednimos\n39: for p ? D | im(p) = h and lab(p) = MASK do\n40: lab(p) ? basins\n41: basins ? basins+ 1\n42: QUEUEPUSH(p)\n43: while QUEUEEMPTY() = false do\n44: q ? QUEUEPOP()\n45: for all u ? N(q) | im(u) = h and lab(u) = MASK do\n46: lab(u) ? lab(p)\n47: QUEUEPUSH(u)\n48: end for\n49: end while\n50: end for\n51: end for\n\nO Alg. 14 consiste de tr\u00eas passos b\u00e1sicos dependentes da ordena\u00e7\u00e3o dos pixels: simula\u00e7\u00e3o da\ninunda\u00e7\u00e3o, verificando os pixels no n\u00edvel de cinza em processamento, e rotulando-os de acordo com\nsua vizinhan\u00e7a; propaga\u00e7\u00e3o das regi\u00f5es nas zonas planas com base na dist\u00e2ncia geod\u00e9sica at\u00e9 a borda;\nrotula\u00e7\u00e3o dos novos m\u00ednimos regionais. O primeiro passo \u00e9 tratado como uma simula\u00e7\u00e3o de inunda-\n\u00e7\u00e3o, pois \u00e9 nesta etapa em que os r\u00f3tulos dos pixels de n\u00edveis de cinza menores passam para o n\u00edvel\nsendo processado no momento, dando a no\u00e7\u00e3o do n\u00edvel de \u00e1gua sendo elevado. O segundo passo trata\nda no\u00e7\u00e3o da imers\u00e3o em zonas planas, onde a \u00e1gua \u00e9 propagada uniformemente das bordas para o\ninterior destas regi\u00f5es, em um mesmo n\u00edvel. Por \u00faltimo, os r\u00f3tulos s\u00e3o gerados avaliando os n\u00edveis de\ncinza iterativamente, e descobrindo aquelas regi\u00f5es em que nenhum pixel tem n\u00edvel de cinza superior\na um de seus vizinhos, ou seja, s\u00e3o novos m\u00ednimos regionais.\n\nAssim como o algoritmo de tobog\u00e3 ordenado, a imers\u00e3o ordenada constr\u00f3i implicitamente um\n\n\n\n80 Algoritmos de Watershed\n\ngrafo direcionado ac\u00edclico, por\u00e9m partindo dos m\u00ednimos regionais, ou seja, do fim dos caminhos\nde m\u00e1xima inclina\u00e7\u00e3o. A avalia\u00e7\u00e3o dos r\u00f3tulos \u00e9 feita da mesma forma, analisando os poss\u00edveis\ncaminhos a partir de um pixel, por\u00e9m esta pode ser feita no momento da inunda\u00e7\u00e3o, pois estes j\u00e1 s\u00e3o\nconhecidos, n\u00e3o sendo necess\u00e1rio manter listas de vizinhos. Por, de fato, constru\u00edrem representa\u00e7\u00f5es\nequivalentes para os caminhos, os Algs. 14 e 13 obt\u00e9m os mesmos resultados, e, por sua vez, coerentes\ncom a defini\u00e7\u00e3o TD-WT. Assim, a Fig. 3.17 apresenta o mesmo resultado da Fig. 3.16, por\u00e9m\nutilizando o algoritmo de imers\u00e3o invariante a ordem e tamb\u00e9m coerente com os outros algoritmos de\nTD-WT, dada a unicidade de solu\u00e7\u00e3o da defini\u00e7\u00e3o.\n\n(a) (b)\n\nFig. 3.17: Imers\u00e3o Invariante a Ordem. (a) Imagem, (b) Resultado (N4)\n\nEm rela\u00e7\u00e3o ao desempenho comparativo entre os algoritmos de imers\u00e3o e tobog\u00e3 ordenados, a\nimers\u00e3o depende da ordena\u00e7\u00e3o dos pixels por seu n\u00edvel de cinza, processo que tamb\u00e9m necessita de\numa estrutura de dados especial para armazenamento dos pixels em cada n\u00edvel. A ordena\u00e7\u00e3o, assim\ncomo no Alg. Imers\u00e3o (Alg. 2), causa o maior problema de desempenho, sendo que o processamento\nrestante \u00e9 dependente desta, e por sua vez, de sua efici\u00eancia.\n\n3.12.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nRIDGE = 0\n\nd e f o r d e r I n v a r i a n t I m m e r s i o n ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nd i s t = ws . makeWorkCopy ( 0 )\n\nl a b [ : ] = MASK\nb a s i n s = 1\n\n\n\n3.12 Algoritmo Imers\u00e3o Invariante a Ordem de Lin et al. 81\n\nq u e u e = wsQueue ( )\n\n# \" s o r t i n g \"\nl e v e l s = d i c t ( )\nf o r p i n D :\n\ni f l e v e l s . h a s \\ _ k e y ( im [ p ] ) :\nl e v e l s [ im [ p ] ] . a p p e n d ( p )\n\ne l s e :\nl e v e l s [ im [ p ] ] = [ p ]\n\n# w a t e r s h e d\nH = s o r t e d ( l e v e l s . k e y s ( ) )\nf o r h i n H :\n\n# s t e p 1\nf o r p i n l e v e l s [ h ] :\n\nhmin = min ( im [N( p ) ] )\ni f h > hmin :\n\nS = l i s t ( )\ns i n g l e \\ _ l a b e l = T r u e\na l f a = None\nf o r q i n N( p ) :\n\ni f im [ q ] ! = hmin :\nc o n t i n u e\n\nS . a p p e n d ( q )\n\ndmin = min ( d i s t [ S ] )\nf o r q i n S :\n\ni f d i s t [ q ] ! = dmin :\nc o n t i n u e\n\ni f a l f a i s None :\na l f a = l a b [ q ]\n\ne l s e :\ni f a l f a ! = l a b [ q ] :\n\ns i n g l e \\ _ l a b e l = F a l s e\n\ni f s i n g l e \\ _ l a b e l :\nl a b [ p ] = a l f a\n\ne l s e :\nl a b [ p ] = RIDGE\n\nq u e u e . p u s h ( p )\nd i s t [ p ] = 0\n\n# s t e p 2\nw h i l e n o t q u e u e . e m p t y ( ) :\n\np = q u e u e . pop ( )\n\n\n\n82 Algoritmos de Watershed\n\nd = d i s t [ p ] + 1\nf o r q i n N( p ) :\n\ni f im [ q ] ! = h :\nc o n t i n u e\n\ni f l a b [ q ] == MASK:\nl a b [ q ] = l a b [ p ]\nd i s t [ q ] = d\nq u e u e . p u s h ( q )\n\ne l i f l a b [ p ] ! = l a b [ q ] and d i s t [ q ] == d :\nl a b [ q ] = RIDGE\n\n# s t e p 3\nf o r p i n l e v e l s [ h ] :\n\ni f l a b [ p ] ! = MASK:\nc o n t i n u e\n\nl a b [ p ] = b a s i n s\nb a s i n s += 1\nq u e u e . p u s h ( p )\nw h i l e n o t q u e u e . e m p t y ( ) :\n\nq = q u e u e . pop ( )\nf o r u i n N( q ) :\n\ni f im [ u ] ! = h o r l a b [ u ] ! = MASK:\nc o n t i n u e\n\nl a b [ u ] = l a b [ p ]\nq u e u e . p u s h ( u )\n\nr e t u r n ws . e n d ( )\n\n3.13 Algoritmo Caminhos M\u00ednimos de Osma-Ruiz et al.\nOsma-Ruiz et al. prop\u00f5e um algoritmo para computa\u00e7\u00e3o mais eficiente de caminhos m\u00ednimos,\n\nbuscando encontrar os caminhos de inclina\u00e7\u00e3o m\u00e1xima em cada pixel, implementando implicita-\nmente a defini\u00e7\u00e3o LC-WT [25]. Seu incremento em efici\u00eancia \u00e9 analisado em rela\u00e7\u00e3o ao algoritmo\nde c\u00f3digo de corrente de Sun, Yang e Ren [23], pois s\u00e3o propostas similares em rela\u00e7\u00e3o ao funciona-\nmento e produzem os mesmo resultados em rela\u00e7\u00e3o \u00e0 defini\u00e7\u00e3o. A implementa\u00e7\u00e3o de Osma-Ruiz et\nal. procura ser o mais eficiente poss\u00edvel em rela\u00e7\u00e3o \u00e0 visita\u00e7\u00e3o de pixels, formando caminhos at\u00e9 os\nm\u00ednimos regionais na primeiza vez que o pixel \u00e9 visitado. Para isso s\u00e3o utilizadas filas, que armaze-\nnam os pixels que devem ser visitados em cada momento, e o que deve ser feitos com estes. O Alg.\n15 apresenta o pseudoc\u00f3digo para a proposta de Osma-Ruiz et al.\n\nALGORITMO 15: Caminhos M\u00ednimos\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D\n\n\n\n3.13 Algoritmo Caminhos M\u00ednimos de Osma-Ruiz et al. 83\n\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: UNVISITED ? -8\n3: PENDING ? -9\n4: ?p ? D, lab(p) ? UNVISITED\n5: basins ? 1\n6: qPending, qEdge, qInner, qDescending: filas\n7: End\n\n8: for p ? D | lab(p) = UNVISITED do\n9: // Passo 1: Verifica\u00e7\u00e3o de m\u00ednimos na vizinhan\u00e7a\n\n10: for q ? N(p) do\n11: if im(q) = im(p) then\n12: if QUEUEEMPTY(qPending) = true then\n13: lab(p) ? PENDING\n14: QUEUEPUSH(p, qPending)\n15: end if\n16: lab(q) ? PENDING\n17: QUEUEPUSH(q, qPending)\n18: else if im(q) = min?u?N(p)im(u) and im(q) &lt;im(p) then\n19: min ? q\n20: end if\n21: end for\n\n22: if QUEUEEMPTY(qPending) = false then\n23: // Passo 2.1: Detec\u00e7\u00e3o de zona plana\n24: while QUEUEEMPTY(qPending) = false do\n25: q ? QUEUEPOP(qPending)\n26: if q ?= p then\n27: min ?\n28: for all u ? N(q) do\n29: if im(u) = im(p) then\n30: if lab(u) = UNVISITED then\n31: lab(u) ? PENDING\n32: QUEUEPUSH(u, qPending)\n33: end if\n34: else if im(u) = min?v?N(q)im(v) and im(u) &lt;im(q) then\n35: min ? u\n36: end if\n37: end for\n38: end if\n\n\n\n84 Algoritmos de Watershed\n\n39: if ?min then\n40: lab(q) ? ARROW(q, min)\n41: QUEUEPUSH(q, qEdge)\n42: else\n43: QUEUEPUSH(q, qInner)\n44: end if\n45: end while\n\n46: if QUEUEEMPTY(qEdge) = false then\n47: // Passo 3.1: Propaga\u00e7\u00e3o das bordas para dentro da zona\n\nplana\n\n48: if QUEUEEMPTY(qInner) = false then\n49: // Propaga o caminho descendente da borda para dentro da\n\nzona plana\n\n50: while QUEUEEMPTY(qEdge) = false do\n51: q ? QUEUEPOP(qEdge)\n52: for all u ? N(q) do\n53: if im(u) = im(q) and lab(u) = PENDING then\n54: lab(u) ? ARROW(u, q)\n55: QUEUEPUSH(u, qEdge)\n56: end if\n57: end for\n58: end while\n59: else\n60: QUEUECLEAR(qEdge)\n61: end if\n62: QUEUECLEAR(qInner)\n63: else\n64: // Passo 3.2: Rotula\u00e7\u00e3o de zona plana m\u00ednima\n65: while QUEUEEMPTY(qInner) = false do\n66: q ? QUEUEPOP(qInner)\n67: lab(q) ? basins\n68: end while\n69: basins ? basins+ 1\n70: end if\n71: else\n72: // Passo 2.1: Rotula\u00e7\u00e3o de pixel que n\u00e3o forma zona plana\n73: if @min then\n74: lab(p) ? basins\n75: basins ? basins+ 1\n76: else\n77: lab(p) ? ARROW(p, min)\n\n\n\n3.13 Algoritmo Caminhos M\u00ednimos de Osma-Ruiz et al. 85\n\n78: end if\n79: end if\n80: end for\n\n81: // Passo 4: Rotula\u00e7\u00e3o dos caminhos em profundidade\n82: for all p ? D do\n83: q ? p\n84: while lab(q) ? 0 do\n85: QUEUEPUSH(q, qDescending)\n86: q ? POINTED(q, lab(q))\n87: end while\n88: while QUEUEEMPTY(qDescending) = false do\n89: u ? QUEUEPOP(qDescending)\n90: lab(u) ? lab(q)\n91: end while\n92: end for\n\nAnalisando-se o Alg. 15, este est\u00e1 dividido em 4 passos principais, interdependentes nos dados\ngerados, estando os 3 primeiros no contexto de uma varredura da imagem. Nesta varredura s\u00e3o trata-\ndos apenas os pixels n\u00e3o visitados anteriormente. O primeiro passo trata da verifica\u00e7\u00e3o da vizinhan\u00e7a\ndo pixel em an\u00e1lise, onde detecta-se se este faz parte de uma zona plana e se algum de seus vizinhos\nforma um caminho de m\u00e1xima inclina\u00e7\u00e3o. A partir desta verifica\u00e7\u00e3o, o passo 2 \u00e9 dividido dependendo\nse o pixel forma ou n\u00e3o uma zona plana. No caso mais simples, onde o pixel n\u00e3o forma uma zona\nplana - n\u00e3o tem nenhum vizinho com mesmo n\u00edvel de cinza - determina-se se este \u00e9 um m\u00ednimo re-\ngional e rotula-se este ou ent\u00e3o utiliza-se a opera\u00e7\u00e3o Arrow para determinar qual o caminho que este\ndeve seguir. Neste algoritmo a opera\u00e7\u00e3o Arrow \u00e9 convencionada no intervalo (?N, 0]. Caso o pixel\nperten\u00e7a a uma zona plana - verificado atrav\u00e9s da quantidade de elementos em uma fila - processa-se\na zona plana, identificando pixels internos e de borda, armazenando-os em filas distintas e usando a\nopera\u00e7\u00e3o Arrow nas bordas. A partir desta distin\u00e7\u00e3o, o terceiro passo depende da exist\u00eancia ou n\u00e3o\nde pixels de borda na zona plana, que determina se a zona plana \u00e9 um m\u00ednimo regional ou n\u00e3o. Se\npixels de borda tiverem sido detectados, o algoritmo propaga esta borda para os pixels internos at\u00e9 a\nexaust\u00e3o destes. O quarto passo, que caracteriza o algoritmo como uma busca em profundidade, trata\nda resolu\u00e7\u00e3o dos r\u00f3tulos dos pixels que n\u00e3o pertencem a um m\u00ednimo regional. Isto \u00e9 feito percor-\nrendo o caminho gerado atrav\u00e9s da opera\u00e7\u00e3o Pointed, e atualizando os r\u00f3tulos do caminho conforme\no m\u00ednimo regional onde este termina.\n\nA proposta deste algoritmo mostra uma forma de integrar procedimentos realizados separada-\nmente em outros algoritmos, como o c\u00f3digo de corrente de Sun, Yang e Ren [23], onde os passos de\ndescoberta de vizinhos m\u00ednimos, resolu\u00e7\u00e3o de zonas planas, rotula\u00e7\u00e3o de m\u00ednimos regionais e rotula-\n\u00e7\u00e3o dos outros pixels s\u00e3o feitos em varreduras independentes. No entanto, a proposta de Osma-Ruiz\net al. [25] necessita de filas otimizadas, pois s\u00e3o um ponto chave que afeta gravemente seu desempe-\nnho. Ainda em rela\u00e7\u00e3o a estas, o algoritmo necessitou de duas corre\u00e7\u00f5es, para incluir opera\u00e7\u00f5es de\nlimpeza das filas qEdge e qInner nas linhas 59 e 61. A Fig. 3.18 apresenta um exemplo do resul-\n\n\n\n86 Algoritmos de Watershed\n\ntado do algoritmo de Osma-Ruiz et al. de caminhos m\u00ednimos, de acordo com as poss\u00edveis solu\u00e7\u00f5es\napresentadas pela defini\u00e7\u00e3o LC-WT, sendo que outras solu\u00e7\u00f5es podem ser encontradas alterando-se a\nordem de visita\u00e7\u00e3o de vizinhos e de varredura da imagem.\n\n(a) (b)\n\nFig. 3.18: Caminhos M\u00ednimos. (a) Imagem, (b) Resultado (N4)\n\n3.13.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nUNVISITED = ?32767\nPENDING = ?32766\n\nd e f s h o r t e s t P a t h s ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\nl a b [ : ] = UNVISITED\nb a s i n s = 1\n\nq P e n d i n g = wsQueue ( )\nqEdge = wsQueue ( )\nq I n n e r = wsQueue ( )\nq D e s c e n d i n g = wsQueue ( )\n\nd e f a r r o w ( p , q ) :\n# f i n d s t h e o f f s e t\nc = q ? p\n# q u e r y t h e n e i g h b o u r h o o d f o r t h e o f f s e t\ni d x = ws . n e i g h b o u r . q u e r y ( c )\ni f i d x == ?1:\n\nr a i s e E x c e p t i o n ( \" N e i g h b o u r n o t f o u n d \" )\nr e t u r n ? i d x # i n v e r t e d s i g n a l\n\n\n\n3.13 Algoritmo Caminhos M\u00ednimos de Osma-Ruiz et al. 87\n\nd e f p o i n t e d ( p , d i r e c t i o n ) :\n# add t h e o f f s e t o f t h e p r e v i o u s l y d e t e c t e d d i r e c t i o n\nd i r e c t i o n = i n t ( d i r e c t i o n )\nq = ws . n e i g h b o u r . a d d O f f s e t ( p , ?d i r e c t i o n ) # i n v e r t e d s i g n a l\ni f n o t q :\n\nr a i s e E x c e p t i o n ( \" I n v a l i d d i r e c t i o n \" )\nr e t u r n q\n\n# s t a r t l o o p i n g\nf o r p i n D :\n\ni f l a b [ p ] ! = UNVISITED :\nc o n t i n u e\n\nm i n v a l u e = min ( im [N( p ) ] )\nminpx = None\n\nf o r q i n N( p ) :\n\ni f im [ q ] == im [ p ] :\ni f q P e n d i n g . e m p t y ( ) :\n\nl a b [ p ] = PENDING\nq P e n d i n g . p u s h ( p )\n\nl a b [ q ] = PENDING\nq P e n d i n g . p u s h ( q )\n\ne l i f im [ q ] &lt;im [ p ] and im [ q ] == m i n v a l u e :\nminpx = q\n\ni f n o t q P e n d i n g . e m p t y ( ) :\nw h i l e n o t q P e n d i n g . e m p t y ( ) :\n\nq = q P e n d i n g . pop ( )\ni f q ! = p :\n\nm i n v a l u e = min ( im [N( q ) ] )\nminpx = None\n\nf o r u i n N( q ) :\n\ni f im [ u ] == im [ p ] :\ni f l a b [ u ] == UNVISITED :\n\nl a b [ u ] = PENDING\nq P e n d i n g . p u s h ( u )\n\ne l i f im [ u ] &lt;im [ q ] and im [ u ] == m i n v a l u e :\nminpx = u\n\ni f n o t minpx i s None :\nl a b [ q ] = a r r o w ( q , minpx )\nqEdge . p u s h ( q )\n\ne l s e :\nq I n n e r . p u s h ( q )\n\n\n\n88 Algoritmos de Watershed\n\ni f n o t qEdge . e m p t y ( ) :\ni f n o t q I n n e r . e m p t y ( ) :\n\nw h i l e n o t qEdge . e m p t y ( ) :\nq = qEdge . pop ( )\nf o r u i n N( q ) :\n\ni f im [ u ] == im [ q ] and l a b [ u ] == PENDING :\nl a b [ u ] = a r r o w ( u , q )\nqEdge . p u s h ( u )\n\ne l s e :\nqEdge . c l e a r ( )\n\nq I n n e r . c l e a r ( )\ne l s e :\n\nw h i l e n o t q I n n e r . e m p t y ( ) :\nq = q I n n e r . pop ( )\nl a b [ q ] = b a s i n s\n\nb a s i n s += 1\ne l s e :\n\ni f minpx i s None :\nl a b [ p ] = b a s i n s\nb a s i n s += 1\n\ne l s e :\nl a b [ p ] = a r r o w ( p , minpx )\n\nf o r p i n D :\n\nq = p\nw h i l e l a b [ q ]&lt;= 0 :\n\nq D e s c e n d i n g . p u s h ( q )\nq = p o i n t e d ( q , l a b [ q ] )\n\nw h i l e n o t q D e s c e n d i n g . e m p t y ( ) :\nu = q D e s c e n d i n g . pop ( )\nl a b [ u ] = l a b [ q ]\n\n# c r o p and r e t u r n\nr e t u r n ws . e n d ( )\n\n3.14 Algoritmo Watershed Cut de Cousty et al.\n\nO algoritmo watershed cut foi introduzido por Cousty et al. [9], sendo definido como uma ope-\nra\u00e7\u00e3o de corte de grafo sobre um grafo valorado nas arestas, obtido da imagem. De fato, o algoritmo\nproduz um corte que gera uma MSF relativa aos m\u00ednimos regionais, isto implica que cada MST con-\nt\u00e9m um e apenas um m\u00ednimo regional, tamb\u00e9m definidos sobre o grafo, e que cada m\u00ednimo tamb\u00e9m\npertence a apenas uma MST. A interpreta\u00e7\u00e3o de uma MSF relativa aos m\u00ednimos regionais pode ser\nvista como se cada conjunto de v\u00e9rtices que comp\u00f5e um m\u00ednimo fosse visto como apenas um v\u00e9rtice,\n\n\n\n3.14 Algoritmo Watershed Cut de Cousty et al. 89\n\ne assim retornando \u00e0 defini\u00e7\u00e3o tradicional da MSF.\nO algoritmo criado por Cousty et. al. calcula uma MSF relativa, conforme explicado anteri-\n\normente, e esta restri\u00e7\u00e3o permite-lhe aperfei\u00e7oar outros algoritmos de MSF e atingir complexidade\nlinear [9]. Iterativamente, s\u00e3o calculados caminhos de m\u00e1xima inclina\u00e7\u00e3o - chamados de stream -\nonde busca-se, a partir do m\u00ednimo (bottom) do caminho, a aresta m\u00ednima deste, intuitivamente, para\nonde uma gota d\u2019\u00e1gua escorreria. No entanto, permite-se que mais de um pixel no caminho tenha\naltitude m\u00ednima, caso que ocorre quando uma zona plana \u00e9 explorada, ou seja, mais de um pixel pode\nter o mesmo valor m\u00ednimo explorado at\u00e9 o momento, at\u00e9 que se encontre um valor de altitude menor\nque o atual. Desta forma, a explora\u00e7\u00e3o do stream \u00e9 alternada entre busca em profundidade e busca\nem largura. Todavia, esta abordagem n\u00e3o trata o problema de divis\u00e3o de zonas planas de modo a\nseparar as regi\u00f5es de forma mais igualit\u00e1ria poss\u00edvel. Este \u00e9 um dos pontos, por\u00e9m n\u00e3o o \u00fanico, onde\npode-se obter m\u00faltiplas solu\u00e7\u00f5es do watershed cut. Assim sendo, para se obter equival\u00eancia com\noutros m\u00e9todos, \u00e9 necess\u00e1rio realizar a remo\u00e7\u00e3o de zonas planas da imagem antes da constru\u00e7\u00e3o do\ngrafo. O Alg. 16 apresenta o watershed cut proposto por Cousty et al. [9].\n\nALGORITMO 16: Watershed Cut\nEntrada: (D, E , F ): Grafo valorado\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D : lab(p) ? MASK\n3: basins ? 0\n4: End\n5: for p ? D | lab(p) = MASK do\n6: [L, label] ? STREAM(p) // Busca o stream do pixel\n7: if label = ?1 then\n8: // L \u00e9 um stream m\u00ednimo (inf-stream)\n9: basins ? basins+ 1\n\n10: label ? basins\n11: end if\n12: for all q ? L do\n13: lab(q) ? basins\n14: end for\n15: end for\n\n1: Procedure STREAM(p)\n2: L ? {p}\n3: L? ? {p} // M\u00ednimos bottoms n\u00e3o explorados de L\n4: while ?u ? L? do\n5: L? ? L? ?{u} // M\u00ednimo explorado \u00e9 removido\n6: BREADTH-FIRST ? true\n7: while BREADTH-FIRST = true and (?{u, v} ? E | v ?? L and F ({u, v}) =\n\nF ?(u)) do\n\n\n\n90 Algoritmos de Watershed\n\n8: // Verifica na vizinhan\u00e7a do pixel aqueles cuja aresta\nforma o caminho de m\u00e1xima inclina\u00e7\u00e3o (steepest descent)\n\n9: if lab(v) ?= MASK then\n10: // O pixel do caminho j\u00e1 est\u00e1 rotulado, portanto retorna\n\neste r\u00f3tulo\n\n11: return [L, lab(v)]\n12: else if F ?(v ) &lt;F ?(u) then\n13: // Encontrou um caminho de descida com um novo m\u00ednimo\n14: L ? L ?{v}\n15: L? ? {v}\n16: // Volta a buscar a partir dos m\u00ednimos\n17: BREADTH-FIRST ? false\n18: else\n19: // F?(v ) = F?(u), portanto v tamb\u00e9m \u00e9 um m\u00ednimo de L\n20: L ? L ?{v}\n21: L? ? L? ?{v}\n22: // Continua procurando por caminhos de descida na\n\nvizinhan\u00e7a\n\n23: end if\n24: end while\n25: end while\n26: // Nenhum r\u00f3tulo encontrado\n27: return [L,?1]\n28: End\n\nA implementa\u00e7\u00e3o deste algoritmo n\u00e3o requer estruturas de dados complexas, como listas ou filas.\nEntretanto, \u00e9 necess\u00e1ria alguma metodologia para armazenamento do grafo que \u00e9 processado, bem\ncomo formas r\u00e1pidas de acesso \u00e0s arestas e valores de altura m\u00ednima. Seu funcionamento \u00e9 bastante\nintuitivo: para cada pixel, busca-se um caminho de m\u00e1xima inclina\u00e7\u00e3o, procurando em profundidade,\ne alternando para busca em largura em zonas planas. Em rela\u00e7\u00e3o \u00e0 rotula\u00e7\u00e3o, ao encontrar um v\u00e9rtice\nj\u00e1 rotulado no caminho de m\u00e1xima inclina\u00e7\u00e3o, este r\u00f3tulo ser\u00e1 utilizado; caso contr\u00e1rio, a busca em\nlargura permite que o caminho detecte as zonas planas que de fato s\u00e3o m\u00ednimos regionais, de modo\na rotul\u00e1-las unicamente. No Alg. 16, o conjunto L representa o caminho de m\u00e1xima inclina\u00e7\u00e3o, en-\nquanto L? representa o conjunto de v\u00e9rtices que est\u00e3o na fronteira de expans\u00e3o. A Fig. 3.19 apresenta\nem (b) um dos resultados poss\u00edveis do watershed cut para a imagem (a) com seu grafo correspondente\nem (c), ressaltando os cortes feitos com arestas tracejadas. Nesta figura tamb\u00e9m \u00e9 mostrada a \u00e1rvore\nde predecessores gerada pela propaga\u00e7\u00e3o dos r\u00f3tulos.\n\n\u00c9 importante ressaltar que, devido \u00e0 diferen\u00e7a causada pela defini\u00e7\u00e3o de m\u00ednimos regionais nas\narestas de um grafo valorado, pode-se ter diferen\u00e7as no n\u00famero de regi\u00f5es identificadas em compara-\n\u00e7\u00e3o com os outros algoritmos apresentados neste cap\u00edtulo. No entanto, analisando-se as condi\u00e7\u00f5es em\nque o problema de fus\u00e3o de m\u00ednimos ocorre, este est\u00e1 restrito a m\u00ednimos regionais separados por uma\nzona plana, onde o valor dos pixels nesta zona plana \u00e9 o valor m\u00ednimo entre os vizinhos do m\u00ednimo\n\n\n\n3.14 Algoritmo Watershed Cut de Cousty et al. 91\n\n(a) (b)\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n?\n\n?\n?\n\n?\n?\n\n? ?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n?\n\n?\n\n? ?\n\n?\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n?\n\n(c)\n\nFig. 3.19: Watershed Cut. (a) Imagem, (b) Resultado, (c) Grafo correspondente (N4)\n\nregional. Esta an\u00e1lise \u00e9 v\u00e1lida quando usada a fun\u00e7\u00e3o de m\u00e1ximo para valora\u00e7\u00e3o das arestas. No caso\nda fun\u00e7\u00e3o de m\u00ednimo, o problema \u00e9 ainda mais restrito, pois a zona plana deve ter apenas um pixel\npara que ocorra a fus\u00e3o dos m\u00ednimos regionais.\n\nA programa\u00e7\u00e3o do algoritmo permite tomar medidas de modo a se evitar repetidas varreduras\ndo conjunto L para verificar se um v\u00e9rtice est\u00e1 contido neste. Isto \u00e9 efetuado utilizando um r\u00f3tulo\ndistinto na imagem de sa\u00edda, representando que o pixel pertence ao conjunto L. Ap\u00f3s concluir o\nc\u00e1lculo do stream, este \u00e9 sobrescrito pelo r\u00f3tulo definitivo do pixel. Em rela\u00e7\u00e3o \u00e0 estrutura de dados\npara armazenamento do grafo, duas alternativas podem ser consideradas cl\u00e1ssicas: uso de matriz de\nadjac\u00eancias ou listas de v\u00e9rtices. A primeira op\u00e7\u00e3o, apesar de r\u00e1pida, \u00e9 invi\u00e1vel por sua necessidade\nde mem\u00f3ria (e.g. para uma imagem de 256x256 pixels, seria necess\u00e1ria uma matriz quadrada de lado\n65.536, correspondendo a aproximadamente 4 bilh\u00f5es de elementos). Desta forma, devido ao n\u00famero\nlimitado de arestas adjacentes a cada v\u00e9rtice, opta-se pelo uso de listas, ou dicion\u00e1rios, para indexa\u00e7\u00e3o\ndos v\u00e9rtices, assim como nos algoritmos Union-Find e Tobog\u00e3 Invariante a Ordem.\n\n3.14.1 Implementa\u00e7\u00e3o Python\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nIN \\ _SET = ?1\n\nd e f w a t e r s h e d C u t ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\n\n\n\n92 Algoritmos de Watershed\n\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\nb a s i n s = 0\n\nmax \\ _ v a l u e = max ( im ) + 1\n\n# b u i l d t h e g r a p h\ng r a p h = d i c t ( ) # u s e a d i c t\nf o r p i n D :\n\nl a b [ p ] = MASK # \" mask \" t h e i m a g e\nf m i n u s = max \\ _ v a l u e\ne d g e s = [ ] # c r e a t e t h e e d g e s\nf o r q i n N( p ) :\n\nm = max ( im [ p ] , im [ q ] )\ne d g e s . a p p e n d ( { \u2019w \u2019 : m, \u2019 i n d e x \u2019 : q } )\ni f m &lt;f m i n u s : # m i n i m i z e t h e f m i n u s v a l u e o f t h e v e r t e x\n\nf m i n u s = m\n\ng r a p h [ p ] = { \u2019 f m i n u s \u2019 : f m i n u s , \u2019 e d g e s \u2019 : e d g e s } # a p p e n d t h e e d g e s and\nf m i n u s d i c t t o t h e g r a p h\n\n# i t e r a t e on t h e g r a p h / l a b e l i m a g e\nf o r p i n D :\n\ni f l a b [ p ] == MASK:\n# make a s t r e a m on t h e p i x e l\nL , l a b e l = s t r e a m ( p , g r a p h , l a b )\n# g e n e r a t e a new l a b e l i f n e c e s s a r y\ni f l a b e l == ?1:\n\nb a s i n s += 1\nl a b e l = b a s i n s\n\n# s e t t h e f o u n d / g e n e r a t e d l a b e l on t h e s e t\nf o r q i n L :\n\nl a b [ q ] = l a b e l\n\n# c r o p and r e t u r n t h e l a b e l e d i m a g e\nr e t u r n ws . e n d ( )\n\n# d e f i n e t h e s t r e a m f u n c t i o n\nd e f s t r e a m ( p , g r a p h , l a b ) :\n\nL = [ p ]\nL i = [ p ]\nl a b [ p ] = IN \\ _SET # mark f o r s i g n a l i z i n g t h e p i x e l i s i n t h e s e t\n\nw h i l e l e n ( L i ) > 0 :\nu = L i . pop ( )\nb r e a d t h \\ _ f i r s t = T r u e\nf m i n u s = g r a p h [ u ] [ \u2019 f m i n u s \u2019 ]\n\n\n\n3.14 Algoritmo Watershed Cut de Cousty et al. 93\n\ne d g e s = g r a p h [ u ] [ \u2019 e d g e s \u2019 ]\n\nw h i l e b r e a d t h \\ _ f i r s t :\ne d g e \\ _ f o u n d = F a l s e\nf o r e i n e d g e s :\n\nv = e [ \u2019 i n d e x \u2019 ]\nw = e [ \u2019w \u2019 ]\ni f l a b [ v ] ! = IN \\ _SET and w == f m i n u s :\n\ne d g e \\ _ f o u n d = T r u e\nb r e a k\n\ni f n o t e d g e \\ _ f o u n d :\nb r e a k\n\ni f l a b [ v ] ! = MASK:\nr e t u r n ( L , l a b [ v ] )\n\ne l i f g r a p h [ v ] [ \u2019 f m i n u s \u2019 ] &lt;f m i n u s :\nL . a p p e n d ( v )\nl a b [ v ] = IN \\ _SET\nL i = [ v ]\nb r e a d t h \\ _ f i r s t = F a l s e\n\ne l s e :\nL . a p p e n d ( v )\nl a b [ v ] = IN \\ _SET\nL i . a p p e n d ( v )\n\nr e t u r n ( L ,?1 )\n\n\n\nCap\u00edtulo 4\n\nAn\u00e1lise Cr\u00edtica dos Algoritmos\n\nNeste cap\u00edtulo s\u00e3o realizadas diversas an\u00e1lises dos algoritmos de transformada watershed explo-\nrados anteriormente. Inicia-se por algumas considera\u00e7\u00f5es a respeito dos resultados dos algoritmos em\nzonas planas, formas de resolu\u00e7\u00e3o destas quando isto \u00e9 executado, e suas rela\u00e7\u00f5es com as defini\u00e7\u00f5es.\nTamb\u00e9m \u00e9 realizado um estudo sobre o impacto das diferen\u00e7as entre as defini\u00e7\u00f5es em aplica\u00e7\u00f5es pr\u00e1-\nticas. Em seguida, faz-se uma an\u00e1lise comparativa, verificando caracter\u00edsticas comuns, como a forma\nde visita\u00e7\u00e3o dos pixels, t\u00e9cnicas utilizadas para endere\u00e7amento na matriz, para construir e percorrer\ncaminhos. Por \u00faltimo, uma an\u00e1lise de desempenho \u00e9 feita, comparando-se relativamente os tempos\nmedidos para execu\u00e7\u00e3o em um grupo de imagens. Nesta an\u00e1lise busca-se apontar poss\u00edveis gargalos\nnos algoritmos e t\u00e9cnicas que poderiam ser combinadas para atingir mais velocidade. Entre estas\nt\u00e9cnicas, reservou-se uma se\u00e7\u00e3o especial para discuss\u00e3o do paralelismo.\n\n4.1 An\u00e1lise Comparativa de Resultados\n\n4.1.1 Resolu\u00e7\u00e3o de Zonas Planas\nO tratamento das zonas planas comp\u00f5e uma parte importante do c\u00e1lculo da transformada wa-\n\ntershed, por serem regi\u00f5es das imagens onde os custos dos caminhos tornam-se iguais e requerem\nalguma a\u00e7\u00e3o dos algoritmos. Pode-se classificar estas a\u00e7\u00f5es em: lower completion; propaga\u00e7\u00e3o FIFO\nde r\u00f3tulos a partir das bordas; c\u00e1lculo de custo lexicogr\u00e1fico; propaga\u00e7\u00e3o aleat\u00f3ria. Nesta se\u00e7\u00e3o,\nanalisa-se a influ\u00eancia destas alternativas no resultado da transformada watershed. A opera\u00e7\u00e3o de\nlower completion \u00e9 utilizada no pr\u00e9-processamento da imagem com o intuito de poder-se ignorar a\nexist\u00eancia de zonas planas, garantindo que para cada pixel exista um vizinho com n\u00edvel de cinza me-\nnor, exceto nos m\u00ednimos regionais, e assim simplificar o algoritmo final. Quando este processo n\u00e3o\n\u00e9 realizado, a t\u00e9cnica mais utilizada pelos algoritmos \u00e9 o uso de filas, propagando-se r\u00f3tulos a partir\ndas bordas, realizando uma divis\u00e3o uniforme destas, abdicando do custo da defini\u00e7\u00e3o que se imple-\nmenta. No entanto, implicitamente calcula-se o custo lexicogr\u00e1fico, que \u00e9 tomado como segunda\ncomponente de custo, de desempate \u00e0 primeira, simulando a velocidade constante de propaga\u00e7\u00e3o de\n\u00e1guas em superf\u00edcies planas [19]. Na literatura, ocorre uma confus\u00e3o em rela\u00e7\u00e3o ao uso destes con-\nceitos para divis\u00e3o correta de zonas planas, sendo tratados como equivalentes, quando n\u00e3o o s\u00e3o. Em\nparalelo a isto, a fila hier\u00e1rquica \u00e9 vista de forma geral como uma estrutura que implicitamente em-\nbute apenas o custo m\u00e1ximo, sendo a pol\u00edtica FIFO respons\u00e1vel pelo custo lexicogr\u00e1fico. No entanto,\n\n95\n\n\n\n96 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nesta estrutura, utilizada como fundamento de diversos algoritmos, mesmo descartando-se a pol\u00edtica\nFIFO, implementa, na teoria, um custo com mais componentes do que apenas o m\u00e1ximo, de dif\u00edcil\nformula\u00e7\u00e3o.\n\nAo utilizar a defini\u00e7\u00e3o de dist\u00e2ncia topogr\u00e1fica (TD-WT), onde o custo do caminho de um pixel at\u00e9\num m\u00ednimo regional \u00e9 dado por uma soma, equivalente a se encontrar os menores vizinhos para cada\npixel no c\u00e1lculo do downstream, o uso ou de lower completion ou de custo lexicogr\u00e1fico equipara-se\nem resultado, como visto em diversos algoritmos que implementam as defini\u00e7\u00f5es LC-WT e TD-WT.\nEspecialmente comparando-se as abordagens de Meijster e Roerdink com o algoritmo Union-Find,\nonde a remo\u00e7\u00e3o de zonas planas via lower completion constitui a primeira etapa, e de Lin et al.\ncom o algoritmo Tobog\u00e3 Ordenado, onde as zonas planas s\u00e3o resolvidas utilizando uma fila para\nprocessamento a partir das bordas destas - implicitamente um custo lexicogr\u00e1fico. Dado que estes\nalgoritmos implementam a mesma defini\u00e7\u00e3o, produzindo os mesmos resultados, ambas formas podem\nser ditas como equivalentes.\n\nEntretanto, estas n\u00e3o s\u00e3o equivalentes quando utiliza-se como fun\u00e7\u00e3o de custo o m\u00e1ximo no cami-\nnho, base da defini\u00e7\u00e3o IFT-WT, sendo que apenas o uso do custo lexicogr\u00e1fico conjunto ao m\u00e1ximo\nproduz os resultados esperados. Para demonstrar esta hip\u00f3tese \u00e9 necess\u00e1ria a modifica\u00e7\u00e3o dos al-\ngoritmos de Berge - para c\u00e1lculo expl\u00edcito dos custos -, IFT - para demonstra\u00e7\u00e3o do papel da fila\nhier\u00e1rquica - e Zona de Empate - para verifica\u00e7\u00e3o de coer\u00eancia das solu\u00e7\u00f5es.\n\nAlg. Berge-Max\n\nO algoritmo Berge-Max baseia-se no algoritmo de florestas de caminhos m\u00ednimos proposto por\nBerge [43] com implementa\u00e7\u00f5es por Meyer [7] e Roerdink e Meijster [12] (Alg. 6). No entanto, estas\npropostas utilizam a fun\u00e7\u00e3o de custo do caminho como a soma dos custos dos arcos neste, indepen-\ndente da forma de c\u00e1lculo do custo dos arcos. No entanto, esta n\u00e3o \u00e9 uma restri\u00e7\u00e3o do algoritmo,\nque depende apenas da converg\u00eancia das fun\u00e7\u00f5es para produzir o resultado correto. Assim sendo,\nprop\u00f5e-se no Alg. 17 o uso da fun\u00e7\u00e3o de custo m\u00e1ximo, para c\u00e1lculo da SPF.\n\nALGORITMO 17: Berge-Max\n\nEntrada: im: Imagem de n\u00edveis de cinza, com dom\u00ednio D e m\u00ednimos regionais mi ? M\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D, lab(p) ? MASK, C1(p) ??\n3: ?p ? mi ? M, lab(p) ? i , C1(p) ? im(p)\n4: stable ? true\n5: End\n6: repeat\n7: stable ? true\n8: for p ? D+ do\n9: PROPAGATE(p,N +(p))\n\n10: end for\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 97\n\n11: for p ? D? do\n12: PROPAGATE(p,N +(p))\n13: end for\n14: for p ? D do\n15: if lab(parent(p)) ?= lab(p) then\n16: lab(p) ?lab(parent(p))\n17: stable ? false\n18: end if\n19: end for\n20: until stable = true\n\n21: Procedure PROPAGATE(p, Q)\n22: for all q ? Q do\n23: c ? max (C1(p), im(q))\n24: if c &lt;C1(q) then\n25: C1(q) ? c\n26: parent(q) ? p\n27: stable ? false\n28: end if\n29: end for\n30: End\n\nPodem-se identificar duas diferen\u00e7as do Alg. 17 em rela\u00e7\u00e3o ao Alg. 6: (1) calcula-se o custo\ndiretamente pelo m\u00e1ximo entre o custo atual e o valor do pr\u00f3ximo pixel no caminho, formando assim\no caminho de custo m\u00e1ximo; (2) faz-se necess\u00e1ria a utiliza\u00e7\u00e3o expl\u00edcita da rela\u00e7\u00e3o de antecessor, para\nuso na rotula\u00e7\u00e3o, atrav\u00e9s da matriz de endere\u00e7os par. Esta matriz \u00e9 necess\u00e1ria, pois a atualiza\u00e7\u00e3o dos\nantecessores ocorre a cada varredura realizada, minimizando os custos, sendo que em determinados\npontos o antecessor de um pixel sofre altera\u00e7\u00e3o de r\u00f3tulo sem que o pixel em quest\u00e3o seja alterado,\npois seu custo j\u00e1 \u00e9 m\u00ednimo. Desta forma, os r\u00f3tulos necessitam ser determinados pela matriz par,\npara que sejam corretamente atualizados, de acordo com a SPF calculada.\n\nO fato de n\u00e3o utilizar nenhum tipo de estrutura de dados exceto a matriz C1 para armazenamento\ndo custo m\u00ednimo obtido em cada pixel garante que este algoritmo implementa apenas a fun\u00e7\u00e3o de\nm\u00e1ximo como custo do caminho, n\u00e3o tendo sua visita\u00e7\u00e3o guiada por nenhum tipo de prioridade que\npossa guiar os resultados. Esta caracter\u00edstica tamb\u00e9m permite que o algoritmo produza solu\u00e7\u00f5es dife-\nrenciadas, todavia corretas. Ainda em rela\u00e7\u00e3o \u00e0s solu\u00e7\u00f5es poss\u00edveis, o Alg. 17 n\u00e3o adere diretamente\na nenhuma defini\u00e7\u00e3o, n\u00e3o produzindo pixels de watershed, apenas bacias de capta\u00e7\u00e3o rotuladas condi-\nzendo com uma SPF onde o custo do caminho \u00e9 o m\u00e1ximo dos arcos neste e as ra\u00edzes s\u00e3o os m\u00ednimos\nregionais.\n\n\n\n98 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\n\nd e f b e r g e \\ _max ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\nd e f p r o p a g a t e ( p , Q , cmp ) :\ns = T r u e\nf o r q i n Q :\n\ni f n o t cmp ( q , p ) :\nc o n t i n u e\n\nc = max ( c 1 [ p ] , im [ q ] )\ni f c &lt;c 1 [ q ] :\n\nc 1 [ q ] = c\np a r [ q ] = p\ns = F a l s e\n\nr e t u r n s\n\nl a b [ : ] = MASK\nc 1 = ws . makeWorkCopy ( i n f )\np a r = ws . makeWorkCopy (?1 )\ns t a b l e = F a l s e\n\nD = l i s t (D)\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nl a b [ p ] = m+1\nc 1 [ p ] = im [ p ]\n\nw h i l e n o t s t a b l e :\ns t a b l e = T r u e\nf o r p i n D :\n\ns t a b l e = p r o p a g a t e ( p , N( p ) , lambda u , v : u > v ) and s t a b l e\n\ni f p a r [ p ] ! = ?1 and l a b [ p ] ! = l a b [ p a r [ p ] ] :\nl a b [ p ] = l a b [ p a r [ p ] ]\ns t a b l e = F a l s e\n\nf o r p i n r e v e r s e d (D) :\ns t a b l e = p r o p a g a t e ( p , N( p ) , lambda u , v : u &lt;v ) and s t a b l e\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 99\n\ni f p a r [ p ] ! = ?1 and l a b [ p ] ! = l a b [ p a r [ p ] ] :\nl a b [ p ] = l a b [ p a r [ p ] ]\ns t a b l e = F a l s e\n\nr e t u r n ws . e n d ( )\n\nImplementa\u00e7\u00e3o Python\n\nAlg. Berge-MaxLex\n\nAssim como o algoritmo Berge-Max (Alg. 17), o algoritmo Berge-MaxLex \u00e9 baseado no m\u00e9todo\nde constru\u00e7\u00e3o de SPF de Berge [43]. De fato, o segundo \u00e9 constru\u00eddo com base no primeiro, incluindo-\nse a componente de custo lexicogr\u00e1fico quando h\u00e1 empate da componente de m\u00e1ximo. Como a\nvarredura do algoritmo Berge pode ser realizada aleatoriamente, o custo lexicogr\u00e1fico \u00e9 calculado\nat\u00e9 sua converg\u00eancia, sendo armazenado na matriz C2. Tomam-se como regras para c\u00e1lculo deste:\n(1) qualquer pixel para o qual existir um pixel de valor menor na vizinhan\u00e7a ter\u00e1 custo lexicogr\u00e1fico\nzero, (2) em caso de empate no custo m\u00e1ximo, o custo lexicogr\u00e1fico do pixel vizinho ser\u00e1 o custo\nlexicogr\u00e1fico do pixel atual mais um, caso este seja menor que o custo lexicogr\u00e1fico atual do pixel\nvizinho. A partir destas, escreve-se o Alg. 18.\n\nALGORITMO 18: Berge-MaxLex\n\nEntrada: im: Imagem de n\u00edveis de cinza, com dom\u00ednio D e m\u00ednimos regionais mi ? M\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ? D, lab(p) ? MASK, C1(p) ??, C2(p) ? 0\n3: ?p ? mi ? M, lab(p) ? i , C1(p) ? im(p)\n4: stable ? true\n5: End\n6: repeat\n7: stable ? true\n8: for p ? D+ do\n9: PROPAGATE(p,N +(p))\n\n10: end for\n11: for p ? D? do\n12: PROPAGATE(p,N +(p))\n13: end for\n14: for p ? D do\n15: if lab(parent(p)) ?= lab(p) then\n16: lab(p) ?lab(parent(p))\n\n\n\n100 An\u00e1lise Cr\u00edtica dos Algoritmos\n\n17: stable ? false\n18: end if\n19: end for\n20: until stable = true\n\n21: Procedure PROPAGATE(p, Q)\n22: for all q ? Q do\n23: c ? max (C1(p), im(q))\n24: if c &lt;C1(q) then\n25: C1(q) ? c\n26: parent(q) ? p\n27: stable ? false\n28: if c = C1(p) then\n29: C2(q) ? C2(p) + 1\n30: else\n31: C2(q) ? 0\n32: end if\n33: else if c = C1(q) then\n34: if c = C1(p) then\n35: if C2(p) + 1 &lt;C2(q) then\n36: C2(q) ? C2(p) + 1\n37: parent(q) ? p\n38: stable ? false\n39: end if\n40: else if parent(q) ?= p and C2(q) ?= 0 then\n41: C2(q) ? 0\n42: parent(q) ?p\n43: stable ? false\n44: end if\n45: end if\n46: end for\n47: End\n\nNota-se que o Algoritmo 18 expande o Alg. 17, incluindo o c\u00e1lculo expl\u00edcito do custo lexicogr\u00e1-\nfico ap\u00f3s a avalia\u00e7\u00e3o do custo m\u00e1ximo. Desta forma, implementa-se a defini\u00e7\u00e3o IFT-WT utilizando\nvarredura aleat\u00f3ria na imagem. Da mesma maneira que o Alg. 17, a rotula\u00e7\u00e3o dos pixels \u00e9 feita atra-\nv\u00e9s de seus antecessores, pelos mesmos motivos apresentados anteriormente, que n\u00e3o s\u00e3o removidos\ncom a introdu\u00e7\u00e3o da segunda componente de custo. \u00c9 importante ressaltar a necessidade da regra (1)\nexposta anteriormente, implementada no algoritmo na sua inicializa\u00e7\u00e3o e nas linhas 31 e 41. A reini-\ncializa\u00e7\u00e3o do valor garante que este custo ser\u00e1 calculado corretamente, pois n\u00e3o se pode antecipar o\ncomportamento da varredura, e, por consequ\u00eancia, a dire\u00e7\u00e3o de crescimento do custo lexicogr\u00e1fico.\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 101\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\n\nd e f b e r g e \\ _max \\ _ l e x ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\nd e f p r o p a g a t e ( p , Q , cmp ) :\ns = T r u e\nf o r q i n Q :\n\ni f n o t cmp ( q , p ) :\nc o n t i n u e\n\nc = max ( c 1 [ p ] , im [ q ] )\n\ni f c &lt;c 1 [ q ] :\nc 1 [ q ] = c\np a r [ q ] = p\ns = F a l s e\ni f c == c 1 [ p ] :\n\nc 2 [ q ] = c 2 [ p ] + 1\ne l s e :\n\nc 2 [ q ] = 0\ne l i f c == c 1 [ q ] :\n\ni f c == c 1 [ p ] :\ni f c 2 [ p ] + 1 &lt;c 2 [ q ] :\n\nc 2 [ q ] = c 2 [ p ] + 1\np a r [ q ] = p\ns = F a l s e\n\ne l i f p a r [ q ] ! = p and c 2 [ q ] ! = 0 :\nc 2 [ q ] = 0\np a r [ q ] = p\ns = F a l s e\n\nr e t u r n s\n\nl a b [ : ] = MASK\nc 1 = ws . makeWorkCopy ( i n f )\nc 2 = ws . makeWorkCopy ( 0 )\np a r = ws . makeWorkCopy (?1 )\ns t a b l e = F a l s e\n\nD = l i s t (D)\n\n\n\n102 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nl a b [ p ] = m+1\nc 1 [ p ] = im [ p ]\n\nw h i l e n o t s t a b l e :\ns t a b l e = T r u e\nf o r p i n D :\n\ns t a b l e = p r o p a g a t e ( p , N( p ) , lambda u , v : u > v ) and s t a b l e\n\ni f p a r [ p ] ! = ?1 and l a b [ p ] ! = l a b [ p a r [ p ] ] :\nl a b [ p ] = l a b [ p a r [ p ] ]\ns t a b l e = F a l s e\n\nf o r p i n r e v e r s e d (D) :\ns t a b l e = p r o p a g a t e ( p , N( p ) , lambda u , v : u &lt;v ) and s t a b l e\n\ni f p a r [ p ] ! = ?1 and l a b [ p ] ! = l a b [ p a r [ p ] ] :\nl a b [ p ] = l a b [ p a r [ p ] ]\ns t a b l e = F a l s e\n\nr e t u r n ws . e n d ( )\n\nImplementa\u00e7\u00e3o Python\n\nAlgoritmo IFT-Rand\n\nAssim como o algoritmo Berge-Max, o algoritmo IFT-Rand busca - por\u00e9m n\u00e3o atinge, por mo-\ntivos explicados a seguir - uma implementa\u00e7\u00e3o de transformada watershed aplicando unicamente o\ncusto m\u00e1ximo no caminho, sendo baseado no algoritmo IFT [8]. No algoritmo IFT com custo lexico-\ngr\u00e1fico, este n\u00e3o \u00e9 calculado explicitamente, sendo inerente ao uso da fila de prioridade com pol\u00edtica\nFIFO [19]. Desta forma, a estrat\u00e9gia adotada neste algoritmo foi remover a ordena\u00e7\u00e3o FIFO, permi-\ntindo que a remo\u00e7\u00e3o de elementos em um mesmo n\u00edvel de prioridade torne-se independente da ordem\nde inser\u00e7\u00e3o. Outra estrat\u00e9gia poss\u00edvel \u00e9 tornar a fila de prioridade com pol\u00edtica LIFO. No entanto,\nimplementa\u00e7\u00f5es de filas de prioridade com quebra de desempate arbitr\u00e1rio s\u00e3o mais comumente in-\nclu\u00eddas em bibliotecas de linguagens de programa\u00e7\u00e3o (e.g. heapq em Python, priority_queue na STL\nem C++, PriorityQueue em Java).\n\nDesta forma, alterando apenas o tipo de estrutura de dados do Alg. IFT (Alg. 10) pode-se\ndegener\u00e1-lo para o algoritmo IFT-Rand. Entretanto, o uso da prioridade como ordena\u00e7\u00e3o dos pi-\nxels a serem processados - que garante a otimalidade dos caminhos - implica em uma equa\u00e7\u00e3o mais\ncomplexa que apenas o custo m\u00e1ximo do caminho. Este efeito ocorre pois os caminhos de custo k\nser\u00e3o todos avaliados antes dos caminhos de custo k + 1. Isto implica que pixels de custo k + 1 com\nvizinhos de custo k , nunca ser\u00e3o atingidos por outros pixels com custo k + 1, mesmo estes sendo\ntamb\u00e9m caminhos \u00f3timos, do ponto de vista do custo m\u00e1ximo.\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 103\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\n\nd e f i f t \\ _ r a n d ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\n# c r e a t e t h e w o r k i n g i m a g e s\nd o n e = ws . makeWorkCopy ( F a l s e )\nc 1 = ws . makeWorkCopy ( i n f )\np a r = ws . makeWorkCopy (MASK)\n\nl a b [ : ] = MASK\n\nq u e u e = wsRandHeapQueue ( )\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nc 1 [ p ] = im [ p ]\nl a b [ p ] = m+1\np a r [ p ] = p\nq u e u e . p u s h ( p , im [ p ] )\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\nd o n e [ p ] = T r u e\nf o r q i n N( p ) :\n\ni f d o n e [ q ] :\nc o n t i n u e\n\nc = max ( c 1 [ p ] , im [ q ] )\ni f c &lt;c 1 [ q ] :\n\ni f c 1 [ q ] &lt;i n f :\ni f q u e u e . c o n t a i n s ( q , c 1 [ q ] ) :\n\nq u e u e . r e m o v e ( q , c 1 [ q ] )\nc 1 [ q ] = c\nl a b [ q ] = l a b [ p ]\np a r [ q ] = p\nq u e u e . p u s h ( q , c 1 [ q ] )\n\nr e t u r n ws . e n d ( )\n\nImplementa\u00e7\u00e3o Python\n\n\n\n104 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nAlgoritmo Zona de Empate Max\n\nTendo por base o algoritmo Zona de Empate sobre a defini\u00e7\u00e3o IFT-WT [13], pode-se remover\no custo lexicogr\u00e1fico e calcular tamb\u00e9m a zona de empate considerando-se apenas o custo m\u00e1ximo\ndos caminhos. No entanto, esta abordagem pode n\u00e3o ser considerada a mais apropriada, pois o\nfundamento do algoritmo Zona de Empate ou IFT \u00e9 o algoritmo de Dijsktra [39] com a implementa\u00e7\u00e3o\nde Dial [42], cujas propriedades garantem que os pixels removidos da fila de prioridade j\u00e1 est\u00e3o com\nsua solu\u00e7\u00e3o definitiva. Por\u00e9m, para o c\u00e1lculo da zona de empate com custo m\u00e1ximo, \u00e9 necess\u00e1rio\nreinserir pixels com solu\u00e7\u00e3o definitiva novamente na fila, de modo a propagar a zona de empate onde\no custo for \u00f3timo para os caminhos alternativos encontrados. Desta forma, a propriedade supracitada\nn\u00e3o \u00e9 mais v\u00e1lida. Esta solu\u00e7\u00e3o \u00e9 apresentada no Alg. 19.\n\nALGORITMO 19: Zona de Empate Max\n\nEntrada: im: Imagem de n\u00edveis de cinza com dom\u00ednio D, S: marcadores\nSaida: lab: Imagem rotulada\n\n1: Initialise\n2: ?p ?? S, C1(p) ? ?, lab(p) ? MASK, parent(p) ? MASK\n3: ?p ? S, C1(p) ? im(p), lab(p) ? ?(p), parent(p) ? p, HEAPQUEUEPUSH(p,\n\nim(p))\n4: End\n\n5: while HEAPQUEUEEMPTY() = false do\n6: p ? HEAPQUEUEPOP()\n7: for all q ? N(p) do\n8: c ? max (C1(p), im(q))\n9: if c &lt;C1(q) then\n\n10: if HEAPQUEUECONTAINS(q) then\n11: HEAPQUEUEREMOVE(q)\n12: end if\n13: C1(q) ? c\n14: lab(q) ? lab(p)\n15: parent(q) ? p\n16: HEAPQUEUEPUSH(q, C1(q))\n17: else if c = C1(q) and lab(q) ?= lab(p) then\n18: lab(q) ? TIE-ZONE\n19: HEAPQUEUEPUSH(q, C1(q))\n20: end if\n21: end for\n22: end while\n\nPode-se ver no Alg. 19 que foram removidos o c\u00e1lculo expl\u00edcito da segunda componente do custo\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 105\n\ndo caminho, correspondente ao custo lexicogr\u00e1fico, e o uso da vari\u00e1vel done, que indicava pixels\ncuja solu\u00e7\u00e3o j\u00e1 era definitiva e n\u00e3o deveriam ser reprocessados. A reinser\u00e7\u00e3o dos pixels que recebem\nr\u00f3tulo TZ na fila \u00e9 executada na linha 19, permitindo assim que se descubra todos os caminhos de\ncusto m\u00e1ximo na imagem.\n\nfrom common i m p o r t *\n\n# c o n s t a n t s\nMASK = ?2\nTIE \\ _ZONE = 0\n\nd e f t i e Z o n e \\ _max ( im , o f f s e t s ) :\n\n# i n i t i a l i s e v a r i a b l e s\nws = wsImage ( im )\nN , im , l a b , D = ws . b e g i n ( o f f s e t s )\n\n# f i n d m i n i m a\nM = f i n d M i n i m a ( im , N , D)\n\n# c r e a t e t h e w o r k i n g i m a g e s\nd o n e = ws . makeWorkCopy ( F a l s e )\nc 1 = ws . makeWorkCopy ( i n f )\np a r = ws . makeWorkCopy (MASK)\nl a b [ : ] = MASK\n\nq u e u e = wsHeapQueue ( )\n\nf o r m i n x r a n g e ( l e n (M) ) :\nf o r p i n M[m ] :\n\nc 1 [ p ] = im [ p ]\nl a b [ p ] = m+1\np a r [ p ] = p\nq u e u e . p u s h ( p , im [ p ] )\n\nw h i l e n o t q u e u e . e m p t y ( ) :\np = q u e u e . pop ( )\nf o r q i n N( p ) :\n\nc = max ( c 1 [ p ] , im [ q ] )\ni f c &lt;c 1 [ q ] :\n\ni f c 1 [ q ] &lt;i n f :\ni f q u e u e . c o n t a i n s ( q , c 1 [ q ] ) :\n\nq u e u e . r e m o v e ( q , c 1 [ q ] )\nc 1 [ q ] = c\nl a b [ q ] = l a b [ p ]\np a r [ q ] = p\nq u e u e . p u s h ( q , c 1 [ q ] )\n\ne l i f c == c 1 [ q ] and l a b [ q ] ! = l a b [ p ] :\n\n\n\n106 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nl a b [ q ] = TIE \\ _ZONE\nq u e u e . p u s h ( q , c 1 [ q ] )\n\nr e t u r n ws . e n d ( )\n\nImplementa\u00e7\u00e3o Python\n\nExperimento\n\nNeste experimento \u00e9 utilizada uma imagem de tamanho 10x10 pixels, constante em valor 1, com\nquatro m\u00ednimos regionais de valor 0, posicionados nas coordenadas (2,2), (2,9), (9,2), (9,9). O c\u00e1lculo\nda opera\u00e7\u00e3o de remo\u00e7\u00e3o de zonas planas \u00e9 feito utilizando-se o Alg. 1. A Fig. 4.1 apresenta em (a) a\nimagem original - f - e em (b) a imagem sem zonas planas - lc, utilizando vizinhan\u00e7a-4.\n\n(a) (b)\n\nFig. 4.1: Imagens utilizadas para experimento de resolu\u00e7\u00e3o de zonas planas. (a) Original - f, (b) ap\u00f3s\nremo\u00e7\u00e3o de zonas planas - lc.\n\nInicia-se apresentando as solu\u00e7\u00f5es que consideram a fun\u00e7\u00e3o de custo do caminho com dois com-\nponentes. O algoritmo IFT n\u00e3o realiza o c\u00e1lculo expl\u00edcito do custo lexicogr\u00e1fico, pois a pol\u00edtica FIFO\ngarante o comportamente adequado. Todavia, o algoritmo Berge-MaxLex necessita realizar o c\u00e1lculo\nexpl\u00edcito, e, devido a sua varredura aleat\u00f3ria, processar estas dist\u00e2ncias at\u00e9 a estabiliza\u00e7\u00e3o com custo\nm\u00ednimo. Desta forma, com as duas componentes expl\u00edcitas, o algoritmo Berge-MaxLex produz os\nmesmos resultados do algoritmo IFT. A Fig. 4.2 apresenta os resultados considerando custo m\u00e1ximo\ne lexicogr\u00e1fico para os algoritmos (a) IFT e (b) Berge-MaxLex, aplicados sobre a imagem f.\n\nAplicando estes mesmos algoritmos sobre a imagem lc, obt\u00e9m-se os mesmos resultados, indi-\ncando que este processo n\u00e3o influencia no resultado quando as duas componentes s\u00e3o utilizadas. No\nentanto, removendo a componente lexicogr\u00e1fica e aplicando os algoritmos apenas com custo m\u00e1ximo\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 107\n\n(a) (b)\n\nFig. 4.2: Resultado dos algoritmos (a) IFT e (b) Berge-MaxLex aplicando custo combinado sobre\nimagem com zonas planas f\n\nsobre a imagem f, os resultados destes ser\u00e3o fortemente dependentes das estrat\u00e9gias de visita\u00e7\u00e3o uti-\nlizadas. Assim, ao remover a pol\u00edtica FIFO e o c\u00e1lculo expl\u00edcito do custo lexicogr\u00e1fico do algoritmo\nBerge-MaxLex, degenerando-os nos algoritmos IFT-Rand e Berge-Max respectivamente, obtemos os\nresultados da Fig. 4.3.\n\n(a) (b)\n\nFig. 4.3: Resultados dos algoritmos (a) IFT-Rand e (b) Berge-Max aplicando custo m\u00e1ximo sobre\nimagem com zonas planas f\n\nNa Fig. 4.3 s\u00e3o geradas duas solu\u00e7\u00f5es distintas, por\u00e9m v\u00e1lidas, considerando-se apenas o custo\n\n\n\n108 An\u00e1lise Cr\u00edtica dos Algoritmos\n\ndo caminho como o m\u00e1ximo deste. A solu\u00e7\u00e3o em (a) depende da forma de organiza\u00e7\u00e3o utilizada\nna implementa\u00e7\u00e3o de uma fila de prioridade, n\u00e3o sendo poss\u00edvel prever qual o pr\u00f3ximo pixel a ser\nanalisado dentro de um mesmo n\u00edvel de prioridade, dado que esta ordem \u00e9 dependente da inser\u00e7\u00e3o\ne organiza\u00e7\u00e3o na mem\u00f3ria. J\u00e1 a solu\u00e7\u00e3o em (b) \u00e9 claramente direcionada da origem em (0,0) para\no canto inferior direito. Isto ocorre pois o algoritmo Berge-Max utiliza a mesma matriz para pro-\ncessamento e armazenamento, e assim o r\u00f3tulo do primeiro m\u00ednimo regional encontrado em (2,2) \u00e9\npropagado a quase todos os pixels da imagem, pois o custo m\u00e1ximo \u00e9 constante nestes, formando uma\nsolu\u00e7\u00e3o v\u00e1lida. Alternando-se a ordem de varredura da imagem e da vizinhan\u00e7a, diferentes resultados\npodem ser encontrados, todos v\u00e1lidos.\n\nEntretanto, ao aplicar estes algoritmos na imagem lc, obt\u00e9m-se o efeito desejado para comprova-\n\u00e7\u00e3o da hip\u00f3tese inicial. Para obter a equival\u00eancia entre lower completion e custo lexicogr\u00e1fico usando\ncusto m\u00e1ximo, seria necess\u00e1rio que o resultado do algoritmo Berge-Max na imagem lc fosse igual ao\nresultado do algoritmo Berge-MaxLex sobre a imagem f. No entanto, esta igualdade n\u00e3o \u00e9 encontrada.\nA Fig. 4.4 apresenta os resultados dos algoritmos (a) IFT-Rand e (b) Berge-Max aplicados sobre a\nimagem lc. \u00c9 interessante notar que o algoritmo IFT-Rand produz resultado igual ao algoritmo IFT,\ntodavia isto se deve ao fato da depend\u00eancia da fila de prioridade, que, na verdade, implica em uma\nequa\u00e7\u00e3o mais complexa do que apenas o custo m\u00e1ximo.\n\n(a) (b)\n\nFig. 4.4: Resultado dos algoritmos (a) IFT-Rand e (b) Berge-Max aplicando custo m\u00e1ximo sobre\nimagem sem zonas planas lc\n\nCom estes exemplos demonstra-se que, para o uso do custo m\u00e1ximo, n\u00e3o h\u00e1 equival\u00eancia de\nresultados entre lower completion e custo lexicogr\u00e1fico. Ocorre de fato uma redu\u00e7\u00e3o na zona de\nempate, mas n\u00e3o a elimina\u00e7\u00e3o desta, como seria o desej\u00e1vel para a imagem f. A Fig. 4.5 apresenta as\nzonas de empate calculadas (a) na imagem f considerando custo combinado, e apenas custo m\u00e1ximo\n(b) na imagem f e (c) na imagem lc. Ao aplicar o custo combinado na imagem lc o resultado \u00e9 o\nmesmo de (a).\n\nDe fato, o c\u00e1lculo das zonas de empates nestes tr\u00eas casos refor\u00e7a os exemplos anteriores, e de-\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 109\n\n(a) (b)\n\n(c)\n\nFig. 4.5: Zonas de Empate com (a) custo m\u00e1ximo e lexicogr\u00e1fico sobre imagem com zonas planas f,\ne com custo m\u00e1ximo sobre (b) a imagem com zonas planas f e (c) sem zonas planas lc\n\nmonstra de forma independente o mesmo fato. A simples redu\u00e7\u00e3o da zona de empate entre as imagens\n(b) e (c) e o fato de (c) n\u00e3o ser igual a (a), prova que a remo\u00e7\u00e3o de zonas planas atrav\u00e9s do processo\nde lower completion n\u00e3o equivale ao uso do custo lexicogr\u00e1fico como segunda componente de custo\ndo caminho, onde a primeira \u00e9 o m\u00e1ximo.\n\nA partir destas conclus\u00f5es pode-se verificar a ocorr\u00eancia destas regi\u00f5es problem\u00e1ticas em ima-\ngens de aplica\u00e7\u00f5es reais. Para este efeito, utilizam-se as mesmas aplica\u00e7\u00f5es das Figs. 1.1 e 1.2,\napresentadas na introdu\u00e7\u00e3o deste trabalho. Deseja-se com estes exemplos ressaltar que o problema\nda resolu\u00e7\u00e3o de zonas planas n\u00e3o \u00e9 meramente te\u00f3rico, e tem influ\u00eancia nos resultados obtidos da\ntransformada watershed. A Fig. 4.6 apresenta o c\u00e1lculo da zona de empate considerando apenas o\n\n\n\n110 An\u00e1lise Cr\u00edtica dos Algoritmos\n\ncusto m\u00e1ximo sobre a imagem beef em (a), sobre esta ap\u00f3s lower completion em (b) e a zona de\nempate considerando custo m\u00e1ximo e lexicogr\u00e1fico em (c). Calcula-se ent\u00e3o a subtra\u00e7\u00e3o entre (a) e\n(b) e temos as regi\u00f5es da imagem onde o lower completion resolve a ambiguidade de solu\u00e7\u00f5es em (d).\nNo entanto, para identificar a influ\u00eancia das zonas onde o lower completion n\u00e3o resolve a ambigui-\ndade e permite solu\u00e7\u00f5es m\u00faltiplas enquanto o custo lexicogr\u00e1fico \u00e9 \u00fanico, subtrai-se da imagem (b)\nas zonas de empate calculadas com custo m\u00e1ximo e lexicogr\u00e1fico, conforme Alg. 12, apresentada em\n(c). Desta forma, os pontos de empate insol\u00faveis por natureza s\u00e3o eliminados (e.g. picos de m\u00e1ximo\nseparando regi\u00f5es), restando as regi\u00f5es em que apenas o custo lexicogr\u00e1fico \u00e9 capaz de eliminar o\nempate, sendo apresentada em (e).\n\nNota-se na Fig. 4.6 (e) diversos pontos onde h\u00e1 diferen\u00e7a entre o resultado da aplica\u00e7\u00e3o de lower\ncompletion e custo lexicogr\u00e1fico. A mesma metodologia pode ser aplicada na imagem csample, de\nmodo a identificar estas regi\u00f5es problem\u00e1ticas. Assim, na Fig. 4.7 s\u00e3o apresentadas as zonas de\nempate de custo m\u00e1ximo para a imagem csample em (a), e para esta sem zonas planas em (b). Em\n(c) \u00e9 apresentada a zona de empate considerando custos m\u00e1ximo e lexicogr\u00e1fico. Em (d) \u00e9 calculada\na subtra\u00e7\u00e3o entre (a) e (b), apresentando as regi\u00f5es onde o lower completion foi eficiente, e em (e) as\nregi\u00f5es onde este n\u00e3o \u00e9 suficiente.\n\nPara avaliar o impacto das regi\u00f5es onde o lower completion \u00e9 ineficiente na resolu\u00e7\u00e3o de zonas\nplanas, pode-se comparar a \u00e1rea destas com a \u00e1rea total da zona de empate, onde qualquer solu\u00e7\u00e3o \u00e9\nv\u00e1lida. Na imagem beef, 25,7% dos pixels em empate estariam incorretos, n\u00e3o constituindo um em-\npate real, assim como 13,1% dos pixels na imagem csample. Esta porcentagem reitera as conclus\u00f5es\nanteriores, de que \u00e9 necess\u00e1rio o uso de custo lexicogr\u00e1fico para divis\u00e3o de zonas planas quando \u00e9 uti-\nlizado o custo m\u00e1ximo, sendo um problema n\u00e3o apenas de defini\u00e7\u00e3o, mas impactante nos resultados\nem imagens reais.\n\nConsidera\u00e7\u00f5es\n\n\u00c9 importante ressaltar como principal resultado deste experimento que a equival\u00eancia entre o pro-\ncesso de remo\u00e7\u00e3o de zonas planas e a aplica\u00e7\u00e3o do custo lexicogr\u00e1fico depende da fun\u00e7\u00e3o de custo\naplicada ao caminho, e que se deseja minimizar. O projeto de um algoritmo deve considerar este re-\nsultado na t\u00e9cnica utilizada para resolu\u00e7\u00e3o de zonas planas, de modo a produzir solu\u00e7\u00f5es consistentes.\nA escolha do m\u00e9todo depende, de forma geral, da defini\u00e7\u00e3o a ser implementada e da forma do algo-\nritmo, recaindo em 4 possibilidades: (1) propaga\u00e7\u00e3o da borda atrav\u00e9s de fila, (2) lower completion\ne uso de fila de prioridade ou sele\u00e7\u00e3o do menor vizinho, (3) uso de fila de prioridade com pol\u00edtica\nFIFO, e (4) c\u00e1lculo expl\u00edcito do custo lexicogr\u00e1fico.\n\nCada m\u00e9todo tem suas implica\u00e7\u00f5es. A implementa\u00e7\u00e3o de uma fila n\u00e3o \u00e9 uma tarefa trivial e\nsua efici\u00eancia depende da forma como esta \u00e9 realizada e do objetivo que se deseja cumprir. No en-\ntanto, o processo de lower completion tamb\u00e9m depende de filas para calcular explicitamente o custo\nlexicogr\u00e1fico e recalcular os valores dos pixels. O c\u00e1lculo expl\u00edcito, realizado como no algoritmo\nBerge-MaxLex, n\u00e3o depende de estruturas de dados, por\u00e9m, s\u00e3o feitas diversas varreduras at\u00e9 estabi-\nliza\u00e7\u00e3o destes valores. Desta forma, um balan\u00e7o entre as alternativas deve ser feito, de modo que o\nm\u00e9todo escolhido seja o mais apropriado para as caracter\u00edsticas do algoritmo, entretanto considera-\nse que o tratamente de zonas planas \u00e9 essencial para garantir a consist\u00eancia entre a defini\u00e7\u00e3o e a\nimplementa\u00e7\u00e3o dos algoritmos de transformada watershed.\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 111\n\n(a) (b)\n\n(c) (d)\n\n(e)\n\nFig. 4.6: Zonas de empate de custo m\u00e1ximo sobre (a) imagem beef e (b) beef sem zonas planas. (c)\nZona de empate de custo m\u00e1ximo e lexicogr\u00e1fico sobre imagem beef. (d) Subtra\u00e7\u00e3o entre (a) e (b),\nindicando pontos resolvidos por lower completion. (e) Subtra\u00e7\u00e3o entre (b) e (c), indicando pontos\nonde apenas o custo lexicogr\u00e1fico resolve o empate\n\n4.1.2 Aplica\u00e7\u00f5es Pr\u00e1ticas\n\nNesta se\u00e7\u00e3o comparam-se os algoritmos de watershed por seus resultados em aplica\u00e7\u00f5es pr\u00e1ticas.\nPara tal efeito, utilizam-se os mesmos exemplos apresentados na introdu\u00e7\u00e3o deste trabalho, nas Figs.\n1.1 e 1.2, apresentando os resultados para os diferentes algoritmos. Desta forma, busca-se ressaltar\n\n\n\n112 An\u00e1lise Cr\u00edtica dos Algoritmos\n\n(a) (b)\n\n(c) (d)\n\nFig. 4.7: Zonas de empate de custo m\u00e1ximo sobre (a) imagem csample e (b) csample sem zonas\nplanas. (c) Zonas de empate de custo m\u00e1ximo e lexicogr\u00e1fico sobre imagem csample. (d) Subtra\u00e7\u00e3o\nentre (a) e (b). (e) Subtra\u00e7\u00e3o entre (b) e (c).\n\na sutileza nas diferen\u00e7as entre os resultados, que em aplica\u00e7\u00f5es pr\u00e1ticas podem ou n\u00e3o causar perdas\nde qualidade. Considerando-se que cada um dos algoritmos est\u00e1 associado a uma defini\u00e7\u00e3o da trans-\nformada, ser\u00e3o apresentados apenas os resultados para cada uma das diferentes possibilidades. Um\ncuidado deve ser tomado em rela\u00e7\u00e3o \u00e0 defini\u00e7\u00e3o Flooding-WT, que por n\u00e3o ter nenhum algoritmo que\na implemente corretamente, \u00e9 representada neste experimento pelo algoritmo de Imers\u00e3o.\n\nAssim, inicia-se com a primeira aplica\u00e7\u00e3o, da imagem beef, onde deseja-se segmentar uma regi\u00e3o\ninterior utilizando uma filtragem por marcadores e processamento do watershed. A Fig. 4.8 apresenta\nas etapas aplicadas \u00e0 imagem original. Em (a) \u00e9 mostrada a imagem beef ; (b) calcula-se um filtro de\nfechamento com disco de raio 2 para elimina\u00e7\u00e3o de ru\u00eddos; (c) limiariza-se a imagem em n\u00edvel 10\npara separar o bife do fundo; (d) aplica-se filtro de fechamento por \u00e1rea para eliminar ru\u00eddos internos;\n(e) calcula-se o gradiente para gerar o marcador externo; (f) faz-se a eros\u00e3o para gerar o marcador\ninterno; (g) executa a uni\u00e3o dos marcadores; (h) calcula-se gradiente da imagem (b) com marcadores\ncomo m\u00ednimos regionais; (i) filtra-se os m\u00ednimos regionais da imagem atrav\u00e9s da sua reconstru\u00e7\u00e3o\nmorfol\u00f3gica pelos marcadores em (g).\n\nCom base na imagem (i) da Fig. 4.8 calcula-se o watershed, normaliza-se seus r\u00f3tulos e se obt\u00e9m\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 113\n\n(a) Entrada (b) Fechamento de (a) (c) Limiariza\u00e7\u00e3o de (b)\n\n(d) Fechamento por \u00e1rea de\n(c)\n\n(e) Gradiente de (d) (f) Eros\u00e3o de (e)\n\n(g) Uni\u00e3o de (e) e (f) (h) Gradiente de (b) com mar-\ncadores zerados\n\n(i) Reconstru\u00e7\u00e3o morfol\u00f3gica\nde (h) por (g)\n\nFig. 4.8: Etapas da aplica\u00e7\u00e3o beef para gera\u00e7\u00e3o da imagem para segmenta\u00e7\u00e3o por transformada wa-\ntershed utilizando marcadores indiretamente\n\no contorno interno da regi\u00e3o de interesse. A Fig. 4.9 apresenta em (a) a imagem e marcadores e as\ndiferentes defini\u00e7\u00f5es em (b) - (g), uma imagem de diferen\u00e7a sim\u00e9trica entre todas elas em (h), e uma\nimagem da uni\u00e3o de todos os contornos rotulados em (i). \u00c9 importante ressaltar que os contornos\napresentados em (b) - (g) foram dilatados para melhor visualiza\u00e7\u00e3o.\n\nAvaliando-se os resultados das imagens (b) - (g) da Fig. 4.9 pode-se dizer que s\u00e3o todos aceit\u00e1veis\ne equivalentes para esta aplica\u00e7\u00e3o, onde deseja-se calcular a \u00e1rea interna do bife, obtendo m\u00e9dia de\n35313,5 pixels com varia\u00e7\u00e3o m\u00e1xima de 0,3% para mais e 0,9% para menos. A an\u00e1lise da imagem (h)\nrevela que as diferen\u00e7as entre estes contornos s\u00e3o m\u00ednimas refor\u00e7ando a varia\u00e7\u00e3o obtida, exceto em\nregi\u00f5es cr\u00edticas, sendo este resultado embasado por uma an\u00e1lise da imagem (i), onde a sobreposi\u00e7\u00e3o\ndos contornos \u00e9 evidente, restando apenas alguns elementos em desacordo. Entretanto, dependendo\nda aplica\u00e7\u00e3o e da margem de erro utilizada, tais diferen\u00e7as devem ser consideradas, optando-se ent\u00e3o\npor abordagens mais ou menos restritivas a respeito do tamanho de regi\u00f5es e formas de obten\u00e7\u00e3o de\ncontorno de uma regi\u00e3o definida.\n\nA segunda aplica\u00e7\u00e3o mostrada na introdu\u00e7\u00e3o utiliza o watershed como um detector de texturas,\nbaseando-se no tamanho das regi\u00f5es identificadas. Desta forma, o experimento \u00e9 repetido, aplicando-\n\n\n\n114 An\u00e1lise Cr\u00edtica dos Algoritmos\n\n(a) Imagem (b) Algoritmo Imers\u00e3o\n(Flooding-WT)\n\n(c) Algoritmo Imers\u00e3o Invari-\nante a Ordem (TD-WT)\n\n(d) Algoritmo Componentes\nConexos (LC-WT)\n\n(e) Algoritmo Fila de Priori-\ndade (IFT-WT)\n\n(f) Algoritmo Zona de Em-\npate (TZ-IFT-WT)\n\n(g) Algoritmo (h) Uni\u00e3o das diferen\u00e7as si-\nm\u00e9tricas par a par entre as\nimagens (b) - (g)\n\n(i) Uni\u00e3o dos contornos obti-\ndos nas imagens (b) - (g)\n\nFig. 4.9: Compara\u00e7\u00e3o de resultados das defini\u00e7\u00f5es atrav\u00e9s de algoritmos aplicados na imagem beef\npreparada por marcadores\n\nse os mesmos algoritmos, e comparando os resultados atrav\u00e9s do resultado esperado da aplica\u00e7\u00e3o, a\nmedida de \u00e1rea total, e das diferen\u00e7as e uni\u00f5es entre os contornos das regi\u00f5es identificadas. A Fig.\n4.10 apresenta as etapas para extra\u00e7\u00e3o das regi\u00f5es de interesse: (a) imagem csample; (b) gradiente\nmorfol\u00f3gico filtrado por din\u00e2mica em n\u00edvel 10; (c) transformada watershed rotulada; (d) filtragem das\nregi\u00f5es por \u00e1rea maior ou igual a 300; (e) fechamento por \u00e1rea para elimina\u00e7\u00e3o de ru\u00eddos internos; (f)\ncontornos internos das regi\u00f5es obtidas.\n\nA Fig. 4.11 apresenta as imagens produzidas pelos algoritmos, variando-se o algoritmo de trans-\nformada watershed utilizado na etapa (b) da Fig. 4.10, e mantendo as outras opera\u00e7\u00f5es intactas.\nEm (a) \u00e9 apresentada a imagem e as regi\u00f5es de interesse numeradasde 1 a 5; (b) - (g) apresenta as\ndiferentes defini\u00e7\u00f5es; (h) diferen\u00e7a sim\u00e9trica entre todas as defini\u00e7\u00f5es; (i) uni\u00e3o dos contornos.\n\nNesta aplica\u00e7\u00e3o deseja-se medir um tipo espec\u00edfico de regi\u00e3o homog\u00eanea, de caracter\u00edstica mais\nescura, e que forma blocos maiores. Como medida de compara\u00e7\u00e3o entre os resultados, pode-se usar\no n\u00famero total de regi\u00f5es encontradas, visto que em todos os resultados as 5 regi\u00f5es de interesse\n\n\n\n4.1 An\u00e1lise Comparativa de Resultados 115\n\n(a) Entrada (b) Gradiente morfol\u00f3gico de\n(a) filtrado por din\u00e2mica\n\n(c) Transformada\n\n(d) Filtragem por \u00e1rea de (c) (e) Fechamento por \u00e1rea de\n(d)\n\n(f) Contornos internos de (e)\n\nFig. 4.10: Etapas da aplica\u00e7\u00e3o concrete para segmenta\u00e7\u00e3o de regi\u00f5es homog\u00eaneas\n\nforam identificadas, e a \u00e1rea destas 5 regi\u00f5es. Desta forma, respectivamente os algoritmos (b) - (g)\nencontraram 26, 27, 28, 28, 23 e 30 regi\u00f5es. Em rela\u00e7\u00e3o \u00e0s regi\u00f5es foram medidas \u00e1reas m\u00e9dias\ne a varia\u00e7\u00e3o percentual m\u00e1xima para mais e para menos, obtendo os valores apresentados na Tab.\n4.1. Da mesma forma que o exemplo da aplica\u00e7\u00e3o anterior, as imagens de diferen\u00e7as sim\u00e9tricas\nem (h) e uni\u00e3o dos contornos em (i) apresentam resultados muito pr\u00f3ximos entre as defini\u00e7\u00f5es. De\n\nRegi\u00e3o \u00c1rea m\u00e9dia Var. Positiva Var. Negativa\n1 12749,66 2,3% 3,5%\n2 11343,5 1,9% 2,8%\n3 11030,16 1,8% 2,9%\n4 11041,83 6,2% 4,0%\n5 22776 0,3% 1,0%\n\nTab. 4.1: Medi\u00e7\u00f5es sobre a aplica\u00e7\u00e3o de dete\u00e7\u00e3o de regi\u00f5es homog\u00eaneas\n\nforma geral, a an\u00e1lise dos resultados aponta para consist\u00eancia entre as solu\u00e7\u00f5es, sendo algumas mais\nrestritivas em rela\u00e7\u00e3o \u00e0 dimens\u00e3o das regi\u00f5es produzidas, como a defini\u00e7\u00e3o TZ-IFT-WT que produz\nregi\u00f5es menores devido \u00e0 zona de empate, e outras mais amplas, produzindo regi\u00f5es maiores, como a\ndefini\u00e7\u00e3o WC-WT. Tais considera\u00e7\u00f5es devem ser levadas em conta quando a transformada watershed\nfor utilizada em situa\u00e7\u00f5es com margens de erro baixas. Em outros problemas, pode ser necess\u00e1ria\numa avalia\u00e7\u00e3o mais criteriosa, considerando qual abordagem \u00e9 mais apropriada, especialmente em\nrela\u00e7\u00e3o ao comportamento das defini\u00e7\u00f5es, visto que os algoritmos s\u00e3o fortemente relacionados a estas\n\n\n\n116 An\u00e1lise Cr\u00edtica dos Algoritmos\n\n(a) Imagem csample e regi\u00f5es\nde interesse\n\n(b) Algoritmo Imers\u00e3o\n(Flooding-WT)\n\n(c) Algoritmo Imers\u00e3o Invari-\nante a Ordem (TD-WT)\n\n(d) Algoritmo Componentes\nConexos (LC-WT)\n\n(e) Algoritmo Fila de Priori-\ndade (IFT-WT)\n\n(f) Algoritmo Zona de Em-\npate (TZ-IFT-WT)\n\n(g) Algoritmo Watershed Cut\n(WC-WT)\n\n(h) Uni\u00e3o das diferen\u00e7as si-\nm\u00e9tricas par a par entre as\nimagens (b) - (g)\n\n(i) Uni\u00e3o dos contornos obti-\ndos nas imagens (b) - (g)\n\nFig. 4.11: Compara\u00e7\u00e3o de resultados das defini\u00e7\u00f5es de watershed atrav\u00e9s de algoritmos, na aplica\u00e7\u00e3o\nde identifica\u00e7\u00e3o de regi\u00f5es homog\u00eaneas\n\nnas solu\u00e7\u00f5es que oferecem. Entretanto, em casos onde ocorre um pr\u00e9-processamento mais intenso,\nespecialmente com a filtragem de m\u00ednimos regionais, estas diferen\u00e7as tendem a ser grandemente\ndiminu\u00eddas, como no primeiro exemplo apresentado, onde a varia\u00e7\u00e3o de \u00e1rea medida foi inferior a\n1%, representando um caso de uso mais comum da transformada.\n\n4.2 An\u00e1lise Comparativa das Implementa\u00e7\u00f5es\nNesta se\u00e7\u00e3o os algoritmos apresentados no Cap. 3 s\u00e3o comparados nas t\u00e9cnicas empregadas para\n\nrealizar algumas tarefas comuns. S\u00e3o discutidos os m\u00e9todos de explora\u00e7\u00e3o da imagem, endere\u00e7a-\nmento dos caminhos de gota d\u2019\u00e1gua, rotula\u00e7\u00e3o dos caminhos, descoberta e rotula\u00e7\u00e3o de m\u00ednimos\nregionais, e a influ\u00eancia do uso de caminhos m\u00faltiplos para cada pixel em contraste com caminhos\n\n\n\n4.2 An\u00e1lise Comparativa das Implementa\u00e7\u00f5es 117\n\n\u00fanicos.\n\n4.2.1 Explora\u00e7\u00e3o da Imagem\nA an\u00e1lise de explora\u00e7\u00e3o da imagem realizada neste trabalho busca caracterizar os algoritmos de\n\nacordo com a estrat\u00e9gia utilizada para a rotula\u00e7\u00e3o dos pixels. Ao expor esta an\u00e1lise pretende-se criar\nguias para a compreens\u00e3o dos algoritmos. Entre as formas de explora\u00e7\u00e3o da imagem identificadas, h\u00e1\nduas vertentes representativas e ainda outra alternativa pouco utilizada. Adotamos aqui a nomencla-\ntura utilizada por Cormen et al. [26] e cl\u00e1ssica na avalia\u00e7\u00e3o de algoritmos de busca em grafos: busca\nem largura e busca em profundidade. A terceira linha constitui-se da varredura aleat\u00f3ria, onde n\u00e3o \u00e9\nimposta nenhuma ordem no acesso aos pixels, representada unicamente no \u00e2mbito da transformada\nwatershed pelo algoritmo de Berge de constru\u00e7\u00e3o de florestas de caminhos m\u00ednimos. Esta represen-\nta\u00e7\u00e3o \u00fanica n\u00e3o implica baixo n\u00edvel de import\u00e2ncia, pois devido a este fato o algoritmo \u00e9 livre de\nimplica\u00e7\u00f5es inerentes ao uso de estruturas de dados para controlar a forma de varredura. Entretanto,\npor ser \u00fanico e j\u00e1 explorado em v\u00e1rios aspectos neste trabalho, ser\u00e3o consideradas apenas as aborda-\ngens em largura e profundidade nesta compara\u00e7\u00e3o. \u00c9 importante ressaltar que esta caracteriza\u00e7\u00e3o n\u00e3o\nimplica em qual defini\u00e7\u00e3o o algoritmo implementa.\n\nBusca em Largura\n\nM\u00e9todos de busca em largura s\u00e3o bem conhecidos na literatura de computa\u00e7\u00e3o, sendo os funda-\nmentos de diversos procedimentos, como os algoritmos de busca em grafos de Dijsktra para cons-\ntru\u00e7\u00e3o de SPFs e de Prim para constru\u00e7\u00e3o de MSFs [26]. A principal caracter\u00edstica deste tipo de\nalgoritmo \u00e9 dada por sua natureza de expans\u00e3o, sempre da \u00faltima borda e uniformemente em sua\nlargura. A respeito do custo do caminho a partir da semente original, todos os v\u00e9rtices de custo k s\u00e3o\nvisitados antes de visitar qualquer v\u00e9rtice de custo k + 1 [26].\n\nNo campo dos algoritmos de transformada watershed, pode ser vista uma similaridade entre a\nbusca em largura e a simula\u00e7\u00e3o do watershed por inunda\u00e7\u00e3o, onde um conjunto de sementes \u00e9 expan-\ndido para se encontrar a parti\u00e7\u00e3o \u00f3tima formada por estas. Neste sentido, diversos algoritmos tamb\u00e9m\npodem ser reconhecidos como buscas em largura, conforme foi caracterizado em suas respectivas se-\n\u00e7\u00f5es, considerando-se como sementes os m\u00ednimos regionais. Estas propostas se diferenciam em uma\ns\u00e9rie de caracter\u00edsticas e implementam defini\u00e7\u00f5es distintas, mas preservam a varredura em largura,\nonde a dist\u00e2ncia k passa a ser o custo do caminho, dependente da defini\u00e7\u00e3o adotada.\n\nDesta forma, pode-se generalizar os algoritmos que aplicam esta estrat\u00e9gia em 3 passos, onde\npermite-se variar a forma de expans\u00e3o e rotula\u00e7\u00e3o de acordo com a defini\u00e7\u00e3o adotada, com a varia\u00e7\u00e3o\nfundamental sendo as conex\u00f5es iterativas no passo 2:\n\n1. Defina as sementes/marcadores\na. Por entrada; ou\nb. Por c\u00e1lculo dos m\u00ednimos regionais\n\n2. Calcule as conex\u00f5es dos pixels da itera\u00e7\u00e3o atual com a anterior\n\n3. Rotule os pixels de acordo com as conex\u00f5es calculadas. V\u00e1 para o passo 2 e expanda as\nregi\u00f5es da itera\u00e7\u00e3o atual, at\u00e9 visitar todos os pixels\n\n\n\n118 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nDe maneira geral, algoritmos de transformada watershed com varredura em largura tem como\ndesvantagem a detec\u00e7\u00e3o inicial dos m\u00ednimos regionais, seja por um procedimento independente, ou\npor ordena\u00e7\u00e3o dos pixels por seus valores, para detec\u00e7\u00e3o dos componentes conexos m\u00ednimos. Este\npr\u00e9-processamento pode se tornar uma opera\u00e7\u00e3o custosa, e em alguns casos ter seu desempenho\nreduzido comparado ao equivalente baseado em busca em profundidade [24].\n\nBusca em Profundidade\n\nAssim como os algoritmos de busca em largura, a busca em profundidade tamb\u00e9m \u00e9 muito comum\nna literatura, especialmente em grafos, representada comumente por algoritmos gulosos. A estrat\u00e9gia\nadotada aqui \u00e9 continuar a busca sempre a partir do v\u00e9rtice visitado mais recentemente, enquanto\nposs\u00edvel, e ent\u00e3o retornar para analisar v\u00e9rtices pendentes. De fato, em contraste com a busca em\nlargura, a busca em profundidade prioriza v\u00e9rtices de custo k + 1 assim que s\u00e3o descobertos, antes de\nvisitar todos de custo k [26].\n\nPode-se facilmente ver a semelhan\u00e7a entre este procedimento descrito e uma gota d\u2019\u00e1gua descendo\nsobre uma superf\u00edcie, onde esta segue um caminho \u00fanico. Em rela\u00e7\u00e3o a transformada watershed,\nsegue-se o mesmo racioc\u00ednio, representado pela t\u00e9cnica de arrowing, onde identifica-se para cada\npixel o vizinho com menor valor. Diversos algoritmos recentes utilizam esta abordagem, seguindo um\ncaminho at\u00e9 que este seja esgotado em um m\u00ednimo regional, e assim rotulando-o. Outras propostas\ns\u00e3o baseadas em construir os caminhos em etapas anteriores, identificar os m\u00ednimos, e por \u00faltimo\nexecutar a rotula\u00e7\u00e3o percorrendo o caminho, caracterizando-os como buscas em profundidade. Assim\ncomo gotas d\u2019\u00e1gua que terminam em uma mesma bacia de capta\u00e7\u00e3o, os caminhos identificados que\nlevam a um mesmo m\u00ednimo regional s\u00e3o rotulados igualmente.\n\nAssim como o algoritmo de transformada watershed por busca em largura, pode-se generalizar a\nbusca em profundidade em 3 passos, conforme a caracteriza\u00e7\u00e3o mencionada anteriormente:\n\n1. Conecte cada pixel ao(s) seu(s) vizinho(s) de acordo com o custo desejado\n\n2. Rotule os m\u00ednimos regionais\n\n3. Percorra para cada pixel o caminho at\u00e9 o m\u00ednimo regional e utilize o r\u00f3tulo deste\n\nDiversas varia\u00e7\u00f5es existem para cada passo, vistas nos algoritmos apresentados no Cap. 3. Estes\npassos s\u00e3o geralmente distingu\u00edveis nos algoritmos, no entanto podem ser unidos, na tentativa de atin-\ngir melhor desempenho. Em especial deve-se comentar sobre o passo 1, que depende da composi\u00e7\u00e3o\nda imagem na resolu\u00e7\u00e3o das zonas planas. Estas zonas n\u00e3o podem, de maneira geral, ser conectadas\nutilizando um algoritmo de busca em profundidade, optando-se por utilizar varia\u00e7\u00f5es de algoritmos\nem largura para propaga\u00e7\u00e3o e divis\u00e3o correta, aplicando-se uma segunda componente de custo para\nresolu\u00e7\u00e3o destes empates. Entretanto, mesmo nestes casos, o passo 3 \u00e9 caracter\u00edstico de algoritmos\nde busca em profundidade, percorrendo o caminho at\u00e9 encontrar um pixel j\u00e1 rotulado ou um m\u00ednimo\nregional.\n\nConsidera\u00e7\u00f5es\n\nA classifica\u00e7\u00e3o dos algoritmos de transformada watershed em largura ou profundidade busca\nauxiliar na compreens\u00e3o destes, de modo a identificar dificuldades inerentes ao m\u00e9todo adotado, ou\n\n\n\n4.2 An\u00e1lise Comparativa das Implementa\u00e7\u00f5es 119\n\na determinadas t\u00e9cnicas. Deve-se ressaltar que esta classifica\u00e7\u00e3o n\u00e3o tem rela\u00e7\u00e3o com a defini\u00e7\u00e3o do\nalgoritmo, sendo poss\u00edvel implementar qualquer defini\u00e7\u00e3o existente em ambos os paradigmas, com\ndiversos exemplos j\u00e1 existentes e vistos no Cap. 3. No entanto, nota-se uma prefer\u00eancia na literatura\npor projetar algoritmos onde n\u00e3o \u00e9 necess\u00e1rio identificar marcadores iniciais, como no caso da busca\nem largura. Pode-se dizer que os algoritmos com marcadores s\u00e3o preferidos em aplica\u00e7\u00f5es onde o\nusu\u00e1rio os seleciona ou s\u00e3o pr\u00e9-calculados de alguma forma, sendo que nestes casos, os algoritmos\nexistentes s\u00e3o baseados em propostas cl\u00e1ssicas, como os algoritmos de Dijsktra ou Prim. Entretanto,\nnota-se que para o caso da transformada watershed por marcadores, n\u00e3o h\u00e1 t\u00e9cnicas existentes que\nutilizem varreduras em profundidade, apenas algoritmos em largura, que expandem os marcadores\niterativamente, por vezes baseados em algoritmos de grafos, como \u00e1rvores geradoras m\u00ednimas [45].\n\n4.2.2 Endere\u00e7amento de Caminhos\nA maioria dos algoritmos apresentados no Cap. 3, constr\u00f3i, de alguma forma, caminhos entre os\n\nm\u00ednimos regionais e todos os pixels da imagem. Em alguns destes, os caminhos n\u00e3o s\u00e3o armazena-\ndos, por n\u00e3o serem necess\u00e1rios na etapa de rotula\u00e7\u00e3o, como no caso do algoritmo de imers\u00e3o e filas\nde prioridade ou servem apenas como refer\u00eancia, como no algoritmo IFT. Um caso especial \u00e9 o algo-\nritmo watershed cut, que, apesar de construir um caminho a partir de cada pixel, o armazena em um\nconjunto, n\u00e3o impondo nenhuma rela\u00e7\u00e3o de conexidade entre os elementos. Todavia, a maioria dos\nalgoritmos faz uso intenso de duas t\u00e9cnicas de endere\u00e7amento para constru\u00e7\u00e3o e armazenamento dos\ncaminhos: via endere\u00e7o relativo ou endere\u00e7o absoluto. Ambas as t\u00e9cnicas s\u00e3o consideradas arrowing,\npois indicam atrav\u00e9s de um n\u00famero o pr\u00f3ximo pixel no caminho. Apesar da equival\u00eancia conceitual,\na escolha de uma ou outra abordagem afeta outras decis\u00f5es no projeto de um algoritmo de watershed.\n\nO endere\u00e7o relativo \u00e9 uma abordagem onde a gama de valores poss\u00edveis para cada pixel \u00e9 limitada\nao tamanho da vizinhan\u00e7a definida. Assim, para cada pixel, utiliza-se um n\u00famero para indicar qual a\ndire\u00e7\u00e3o para onde o caminho segue, sendo que cada vizinho corresponde a uma dire\u00e7\u00e3o. Esta t\u00e9cnica\nn\u00e3o permite indicar caminhos para pixels fora da vizinhan\u00e7a, por exemplo quando \u00e9 necess\u00e1rio fazer\na compress\u00e3o de caminhos. Por\u00e9m a limita\u00e7\u00e3o da amplitude de valores poss\u00edveis habilita o uso de\nt\u00e9cnicas como no algoritmo c\u00f3digo de corrente de Sun, Yang e Ren [23], onde os c\u00f3digos de entrada\ns\u00e3o armazenados em apenas um byte, onde cada bit corresponde a uma dire\u00e7\u00e3o poss\u00edvel de entrada.\n\nO endere\u00e7o absoluto n\u00e3o possui a limita\u00e7\u00e3o de gama de valores poss\u00edveis ao tamanho da vizi-\nnhan\u00e7a, pois neste caso utiliza-se diretamente a posi\u00e7\u00e3o do pixel na matriz, ou seja, seu \u00edndice no\nvetor. De modo a facilitar o armazenamento destes valores, implementa\u00e7\u00f5es em software geralmente\nutilizam um endere\u00e7o unidimensional para as matrizes de imagens. Com esta t\u00e9cnica n\u00e3o h\u00e1 neces-\nsidade de avaliar o referencial e qual o deslocamento que deve ser feito, utilizando diretamente o\nendere\u00e7o armazenado para seguir o caminho. Desta forma, os pixels n\u00e3o precisam ser diretamente\nconectados, permitindo o uso de t\u00e9cnicas como a compress\u00e3o de caminhos, al\u00e9m do atravessamento\nmais eficiente dos caminhos por n\u00e3o haver necessidade de avalia\u00e7\u00e3o de vizinhan\u00e7a para identifica\u00e7\u00e3o\ndo pr\u00f3ximo ponto.\n\n4.2.3 Rotula\u00e7\u00e3o de Caminhos\nComo mencionando na se\u00e7\u00e3o anterior, diversos algoritmos constr\u00f3em caminhos que posterior-\n\nmente s\u00e3o percorridos para determina\u00e7\u00e3o dos r\u00f3tulos dos pixels que pertencem a estes. No entanto,\n\n\n\n120 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nesta opera\u00e7\u00e3o pode ser realizada de duas formas diferentes, que s\u00e3o atreladas \u00e0 forma de endere\u00e7a-\nmento escolhida.\n\nA primeira t\u00e9cnica, mais simples, consiste em percorrer o caminho a partir do pixel em avalia\u00e7\u00e3o\nat\u00e9 o ponto em que um r\u00f3tulo \u00e9 encontrado, seja em um m\u00ednimo regional ou na fus\u00e3o com outro\ncaminho, e ent\u00e3o, com este r\u00f3tulo em mem\u00f3ria, percorrer novamente o caminho aplicando o r\u00f3tulo\nencontrado. Este processo tamb\u00e9m pode ser aplicado no sentido inverso, a partir dos m\u00ednimos regio-\nnais propagar o r\u00f3tulo para os pixels cujos caminhos terminam nestes. Em ambos os sentidos pode-se\nutilizar uma estrutura de dados como uma pilha ou fila para armazenar os pixels pertencentes ao ca-\nminho. Esta t\u00e9cnica n\u00e3o modifica os endere\u00e7os no caminho, e portanto pode ser utilizada tanto com\nposi\u00e7\u00f5es absolutas quanto relativas, sendo mais comum em conjunto com a \u00faltima.\n\nA compress\u00e3o de caminhos, op\u00e7\u00e3o \u00e0 rotula\u00e7\u00e3o direta, \u00e9 advinda do Union-Find, estrutura de dados\nintroduzida por Tarjan para gerenciamento de conjuntos [27]. Todavia esta opera\u00e7\u00e3o requer que cada\nelemento possa ser endere\u00e7ado para qualquer outro elemento em posi\u00e7\u00e3o arbitr\u00e1ria, ou seja, o ende-\nre\u00e7amento absoluto \u00e9 um requisito. A t\u00e9cnica consiste em percorrer o caminho at\u00e9 encontrar o seu\nfinal, considerado como o elemento representativo daquele conjunto, e ent\u00e3o modificar os elementos\npercorridos para apontar diretamente para o representante. Desta forma, n\u00e3o \u00e9 necess\u00e1rio percorrer\nnovamente o caminho inteiro at\u00e9 o m\u00ednimo regional quando um pixel que j\u00e1 foi atravessado for ava-\nliado novamente para determina\u00e7\u00e3o de seu r\u00f3tulo. De fato, a efici\u00eancia desta opera\u00e7\u00e3o \u00e9 mais vis\u00edvel\nquando s\u00e3o utilizados caminhos m\u00faltiplos, j\u00e1 que para caminhos \u00fanicos o n\u00famero de visitas realizada\npara cada pixel pode ser at\u00e9 maior do que utilizando a primeira t\u00e9cnica apresentada. No entanto, o\nrequisito de se utilizar o endere\u00e7o absoluto resulta em mais agilidade no atravessamento do caminho.\n\nEm paralelo \u00e0 estas duas t\u00e9cnicas, pode-se aplicar na implementa\u00e7\u00e3o destes algoritmos uma tabela\nde equival\u00eancia de r\u00f3tulos. Ao utilizar esta tabela, os caminhos s\u00e3o percorridos apenas uma vez, onde\npara cada caminho novo - encontrado a partir de um pixel que n\u00e3o foi rotulado - atribui-se um novo r\u00f3-\ntulo. Ao atingir um outro r\u00f3tulo - seja de outro caminho ou de um m\u00ednimo regional - adiciona-se uma\nentrada na tabela de equival\u00eancia. Ap\u00f3s percorrer todos os caminhos, a imagem \u00e9 novamente varrida,\ndesta vez corrigindo os r\u00f3tulos pr\u00e9-determinados pelos seus equivalentes definitivos. A efici\u00eancia\ndesta alternativa est\u00e1 estritamente ligada ao desempenho da tabela de equival\u00eancia e da varredura da\nimagem na mem\u00f3ria. Apesar de ser uma possibilidade, nenhum dos algoritmos analisados utiliza esta\nt\u00e9cnica.\n\n4.2.4 Descoberta e Rotula\u00e7\u00e3o de M\u00ednimos Regionais\nEm rela\u00e7\u00e3o aos m\u00ednimos regionais, os algoritmos dividem-se em detectar por ordenamento dos\n\npixels, na constru\u00e7\u00e3o de caminhos de m\u00e1xima inclina\u00e7\u00e3o, ou aplicar um algoritmo espec\u00edfico para\nisto. O \u00faltimo caso foge ao escopo deste trabalho, dada a variedade de algoritmos poss\u00edveis para\nrotula\u00e7\u00e3o de componentes conexos e detec\u00e7\u00e3o de m\u00ednimos regionais. No primeiro caso, a ordena\u00e7\u00e3o\ndos pixels \u00e9 utilizada nas simula\u00e7\u00f5es de imers\u00e3o, onde componentes conexos novos recebem seus\nr\u00f3tulos definitivos assim que s\u00e3o descobertos, e estes s\u00e3o propagados a partir das bordas.\n\nTodavia, ao construir caminhos entre os pixels e m\u00ednimos regionais, surgem, de forma geral,\nduas possibilidades, comumente associadas \u00e0 forma de endere\u00e7amento e de rotula\u00e7\u00e3o dos caminhos\nutilizada. Em ambos os casos, parte-se do princ\u00edpio de que sabe-se quais s\u00e3o os m\u00ednimos regionais,\nonde estes foram descobertos por serem componentes conexos sem pixels vizinhos de menor valor,\nou seja, nenhum caminho \u00e9 constru\u00eddo partindo destes. Assim, procede-se ent\u00e3o atribuindo um r\u00f3tulo\n\n\n\n4.2 An\u00e1lise Comparativa das Implementa\u00e7\u00f5es 121\n\nnovo e propagando-o aos pixels vizinhos no componente conexo, ou selecionando-se um pixel como\nrepresentante do m\u00ednimo regional, para onde os caminhos dos outros pixels passam a ser direcionados.\nAo percorrer o caminho e encontrar este representante, seu r\u00f3tulo ser\u00e1 propagado ao caminho, que\ninclui os elementos restantes do m\u00ednimo.\n\nDe forma geral, pode-se dizer que a op\u00e7\u00e3o por rotular o m\u00ednimo regional em uma primeira etapa\nimplica em mais efici\u00eancia computacional, pois o atravessamento dos caminhos at\u00e9 um r\u00f3tulo n\u00e3o\nincluir\u00e1 pixels j\u00e1 identificados como partes de m\u00ednimos regionais. Entretanto, dependendo do projeto\ndo algoritmo, sendo baseado estritamente em grafos por exemplo, esta op\u00e7\u00e3o n\u00e3o \u00e9 poss\u00edvel na etapa\nde constru\u00e7\u00e3o destes, sendo necess\u00e1rio utilizar o representante como indicador do r\u00f3tulo dos demais.\n\n4.2.5 Estruturas de Dados\nUma parte importante das implementa\u00e7\u00f5es de algoritmos de transformada watershed reside nas\n\nestruturas de dados utilizadas para controle de visita\u00e7\u00e3o dos pixels, rotula\u00e7\u00e3o e ordena\u00e7\u00e3o. Pode-\nse identificar quatro tipos de estruturas utilizadas: pilha (LIFO), fila (FIFO), fila de prioridade com\ndesempate FIFO e conjuntos/listas. Foge do escopo deste trabalho um aprofundamento nas caracte-\nr\u00edsticas de cada estrutura, no entanto, deve-se considerar que o desempenho das suas opera\u00e7\u00f5es de\ninser\u00e7\u00e3o e remo\u00e7\u00e3o \u00e9 determinante para o desempenho geral do algoritmo que as utilizar.\n\nA estrutura mais comum entre os algoritmos \u00e9 a fila, utilizada majoritariamente para realizar a\npropaga\u00e7\u00e3o das bordas para os pixels internos das zonas planas. Seu uso neste caso est\u00e1 associado \u00e0\nnecessidade de propaga\u00e7\u00e3o uniforme das bordas, garantido pela pol\u00edtica FIFO, uma vez que inseridos\ntodos os pixels de borda conhecidos, estes ser\u00e3o processados antes de qualquer pixel interno, inserido\npor algum pixel removido da fila. Intrinsecamente, o uso da fila \u00e9 equivalente ao c\u00e1lculo do custo\nlexicogr\u00e1fico.\n\nO uso da fila de prioridade est\u00e1 ligado \u00e0s t\u00e9cnicas de simula\u00e7\u00e3o de imers\u00e3o, onde avalia-se os\npixels por ordem de n\u00edvel de cinza, propagando seu r\u00f3tulo para a vizinhan\u00e7a. A pol\u00edtica FIFO garante\nque no desempate ocorra o mesmo comportamento da fila comentado acima, onde ocorre o c\u00e1lculo\nintr\u00ednseco do custo lexicogr\u00e1fico, e a divis\u00e3o das zonas planas de acordo com este. Uma forma simples\nde se visualizar a fila de prioridades FIFO \u00e9 dada por Beucher e Meyer [11], onde se tem uma estrutura\ncom N filas independentes, onde N \u00e9 o n\u00famero de n\u00edveis de cinza da imagem a ser analisada, com\na inser\u00e7\u00e3o realizada na fila correspondente ao n\u00edvel do pixel, e a remo\u00e7\u00e3o sempre realizada a partir\ndo menor n\u00edvel dispon\u00edvel. Outras implementa\u00e7\u00f5es baseiam-se no conceito de \u00e1rvores para organizar\nos elementos e otimizar seu desempenho. Estas, no entanto, necessitam de elementos adicionais na\ncompara\u00e7\u00e3o para calcular o desempate com pol\u00edtica FIFO.\n\nO uso da estrutura de pilha \u00e9 restrito a apenas um algoritmo, no entanto poderia ser expandido,\nsubstituindo o uso de filas onde estas servem apenas como estruturas de armazenamento. No entanto,\nno algoritmo de c\u00f3digo de corrente, o uso da pilha caracteriza sua rotula\u00e7\u00e3o como uma busca em\nprofundidade. Ao substituir, neste caso, a pilha por uma fila, o efeito do algoritmo seria de uma\nrotula\u00e7\u00e3o em largura, descaracterizando-o.\n\nAssim como a pilha, o uso de conjuntos simples \u00e9 restrito apenas ao algoritmo watershed cut,\ntodavia poderia substituir filas no mesmo caso das pilhas citado acima. Conjuntos n\u00e3o implicam em\nordem na inser\u00e7\u00e3o ou remo\u00e7\u00e3o de elementos, mas devem permitir acesso aleat\u00f3rio a seus elementos.\nNo entanto, no algoritmo watershed cut esta propriedade - que pode acarretar em perda de desem-\npenho por requerir opera\u00e7\u00f5es de busca aleat\u00f3ria na mem\u00f3ria - n\u00e3o \u00e9 utilizada, e assim, o conjunto\n\n\n\n122 An\u00e1lise Cr\u00edtica dos Algoritmos\n\npoderia ser substitu\u00eddo por outra estrutura mais simples, como uma pilha, onde o elemento a ser\nremovido sempre tem sua posi\u00e7\u00e3o em mem\u00f3ria conhecida.\n\nAl\u00e9m das estruturas citadas aqui, o armazenamento de grafos \u00e9 recorrente nos algoritmos, optando-\nse geralmente por estruturas din\u00e2micas para estes, visto que matrizes de adjac\u00eancia tornam-se in-\nvi\u00e1veis devido \u00e0s dimens\u00f5es. Ocasionalmente tamb\u00e9m s\u00e3o utilizadas estruturas especiais, como na\nopera\u00e7\u00e3o de ordena\u00e7\u00e3o por frequ\u00eancia sugerida para o algoritmo de imers\u00e3o de Vincent e Soille [6].\n\nUma considera\u00e7\u00e3o v\u00e1lida a todas estruturas \u00e9 referente ao gerenciamento de mem\u00f3ria, dado o\nvolume de dados trabalhados. Considerando-se que s\u00e3o geralmente armazenados nas estruturas os\nendere\u00e7os dos pixels, e que uma imagem relativamente pequena pode fazer dezenas de milhares de\nopera\u00e7\u00f5es de inser\u00e7\u00e3o e remo\u00e7\u00e3o, aloca\u00e7\u00f5es e libera\u00e7\u00f5es de mem\u00f3ria em estruturas totalmente din\u00e2-\nmicas tornam-se muito custosas, dada a natureza destas opera\u00e7\u00f5es. Entretanto, por n\u00e3o se conhecer\npreviamente o tamanho m\u00e1ximo que as estruturas atingir\u00e3o, n\u00e3o se pode utilizar abordagens completa-\nmente est\u00e1ticas. Desta forma, abordagens h\u00edbridas s\u00e3o mais adequadas, por permitirem o crescimento\ndas estruturas e por realizarem opera\u00e7\u00f5es de aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria para blocos maiores.\n\n4.2.6 Considera\u00e7\u00f5es\nNesta se\u00e7\u00e3o, buscou-se realizar uma an\u00e1lise comparativa dos algoritmos apresentados no Cap. 3\n\ntendo em vista seus aspectos t\u00e9cnicos. Assim, vislumbra-se auxiliar no projeto de algoritmos mais\neficientes, combinando solu\u00e7\u00f5es j\u00e1 consolidadas para problemas comuns entre todos os algoritmos.\nPode-se resumir estes problemas e as solu\u00e7\u00f5es apontadas na seguinte lista:\n\n1. Explora\u00e7\u00e3o da imagem\n\n1. Largura\n2. Profundidade\n3. Aleat\u00f3rio\n\n2. Endere\u00e7amento de caminhos \u00f3timos\n\n1. Endere\u00e7o absoluto\n2. Endere\u00e7o relativo\n3. Conjuntos (impl\u00edcito)\n\n3. Rotula\u00e7\u00e3o de caminhos\n\n1. Compress\u00e3o\n2. Atravessamento e rotula\u00e7\u00e3o\n3. Tabela de equival\u00eancia\n\n4. Localiza\u00e7\u00e3o/Rotula\u00e7\u00e3o de m\u00ednimos regionais\n\n1. Uso de algoritmo espec\u00edfico (Par\u00e2metro de entrada)\n2. Ordena\u00e7\u00e3o dos pixels e detec\u00e7\u00e3o de componentes conexos\n3. Detec\u00e7\u00e3o de componentes m\u00ednimos por arrowing da imagem\n\n\n\n4.3 An\u00e1lise de Desempenho do Tempo de Execu\u00e7\u00e3o 123\n\n5. Estruturas de dados\n\n1. Fila (FIFO)\n2. Pilha (LIFO)\n3. Fila de Prioridade com pol\u00edtica FIFO de desempate\n4. Grafo\n5. Ordena\u00e7\u00e3o\n6. Conjunto\n\nAl\u00e9m destas solu\u00e7\u00f5es apontadas, diversas delas implicam no uso de estruturas de dados, desde\nalgumas reconhecidamente simples como pilhas (LIFO), at\u00e9 filas de prioridade com pol\u00edtica FIFO. A\nefici\u00eancia de muitos algoritmos est\u00e1 severamente ligada \u00e0 efici\u00eancia das opera\u00e7\u00f5es nestas estruturas,\nbem como seu gerenciamento de mem\u00f3ria. Uma discuss\u00e3o mais aprofundada destas foge do escopo\ndeste trabalho, sendo encontrada na literatura, por exemplo, na Ref. [26].\n\nUtilizando as informa\u00e7\u00f5es obtidas a partir das an\u00e1lises realizadas nesta se\u00e7\u00e3o, pode-se resumir\neste conte\u00fado na Tab. 4.2. Nesta tabela s\u00e3o apresentados, por ordem cronol\u00f3gica, os algoritmos apre-\nsentados no Cap. 3, listando a defini\u00e7\u00e3o implementada, a forma de expans\u00e3o utilizada na visita\u00e7\u00e3o\ndos pixels, a forma como endere\u00e7os s\u00e3o armazenados e processados na etapa de rotula\u00e7\u00e3o. Por \u00faltimo,\na informa\u00e7\u00e3o das estruturas de dados necess\u00e1rias \u00e0 implementa\u00e7\u00e3o destes \u00e9 listada, por ser extrema-\nmente relevante ao desempenho final obtido. As informa\u00e7\u00f5es das caracter\u00edsticas s\u00e3o referentes aos\nitens listados acima. H\u00e1 tr\u00eas anota\u00e7\u00f5es nesta tabela que devem ser consideradas: (1) O algoritmo de\nImers\u00e3o de Vincent e Soille \u00e9 baseado na defini\u00e7\u00e3o Flooding-WT mas a implementa incorretamente;\n(2) Consideram-se as vers\u00f5es revistas por Roerdink e Meijster [12]; (3) Consideram-se as vers\u00f5es\ncorrigidas e propostas nos Algs. 13 e 14.\n\n4.3 An\u00e1lise de Desempenho do Tempo de Execu\u00e7\u00e3o\nNesta se\u00e7\u00e3o \u00e9 apresentado o experimento realizado para avalia\u00e7\u00e3o do desempenho relativo ao\n\ntempo de execu\u00e7\u00e3o dos algoritmos apresentados no Cap. 3. A implementa\u00e7\u00e3o destes foi realizada,\npara efeito de compara\u00e7\u00e3o relativa, na linguagem Python [15], utilizando uma abordagem que re-\nflita a especifica\u00e7\u00e3o do algoritmo de forma mais pr\u00f3xima poss\u00edvel na implementa\u00e7\u00e3o. Desta forma,\nprocurou-se evitar a introdu\u00e7\u00e3o precoce de elementos que pudessem otimizar apenas alguns algo-\nritmos, mantendo assim uma base comum a todos, e avaliando apenas o algoritmo em si. Deve-se\nressaltar que o uso de implementa\u00e7\u00f5es C/C++, possuindo caracter\u00edsticas diferentes de execu\u00e7\u00e3o, ge-\nraria resultados diferentes, com poss\u00edveis altera\u00e7\u00f5es na classifica\u00e7\u00e3o por velocidade.\n\nPara esta avalia\u00e7\u00e3o, foram utilizadas quatro imagens conhecidas na literatura como: baboon,\ncamera, lena e peppers. Estas imagens, obtidas no tamanho 512x512, foram redimensionadas pro-\nporcionalmente aos tamanhos com largura 64, 128 e 256. Foi obtido ent\u00e3o o gradiente morfol\u00f3gico\nde cada uma delas e tamb\u00e9m calculado um filtro de din\u00e2mica (remo\u00e7\u00e3o de m\u00ednimos por contraste),\nconstituindo assim um conjunto de 32 (4x4x2) imagens. A Tab. 4.3 resume as imagens utilizadas e\no n\u00famero de m\u00ednimos regionais para cada tamanho, sendo para cada imagem mostrada na primeira\nlinha os valores correspondentes \u00e0 original redimensionada e na segunda \u00e0 imagem redimensionada e\nfiltrada. Em rela\u00e7\u00e3o aos algoritmos, foram utilizados os seguintes: imers\u00e3o (Alg. 2), fila de priorida-\n\n\n\n124 An\u00e1lise Cr\u00edtica dos Algoritmos\n\ndes (Alg. 3), componentes conexos (Alg. 7), union-find (Alg. 9), IFT (Alg. 10), c\u00f3digo de corrente\n(Alg. 11), zona de empate (Alg. 12), tobog\u00e3 (Alg. 13) e imers\u00e3o (Alg. 14) invariantes a ordem, cami-\nnhos m\u00ednimos (Alg. 15) e watershed cut (Alg. 16). De modo a obter resultados equivalentes, foram\nefetuadas duas compara\u00e7\u00f5es, uma utilizando apenas algoritmos que n\u00e3o necessitam de tratamento de\nzonas planas e outra onde para todos os algoritmos foi realizado este pr\u00e9-processamento. Assim, no\nprimeiro teste foram exclu\u00eddos os algoritmos watershed cut e union-find. Desta forma, o custo asso-\nciado ao algoritmo de remo\u00e7\u00e3o de zonas planas \u00e9 isolado do teste de desempenho. Dos algoritmos\napresentados no Cap. 3, foram exclu\u00eddos os algoritmos Dijkstra-Moore de caminhos m\u00ednimos, hill\nclimbing e Berge, pois seu desempenho - implementados conforme especifica\u00e7\u00e3o - inviabilizaria o\nexperimento. A t\u00e9cnica utilizada para otimizar os dois primeiros algoritmos seria o uso de uma fila\nde prioridade, tornando-os pr\u00f3ximos aos algoritmos de fila de prioridade e IFT em comportamento\ne desempenho. Quanto ao algoritmo Berge, a melhoria de seu desempenho depende de hardware\notimizado em rela\u00e7\u00e3o \u00e0 leitura de mem\u00f3ria utilizada. Cada algoritmo foi executado 10 vezes em\nsequ\u00eancia - alternando-se entre estes - para cada imagem, em um computador com processador Ath-\nlon 64 3000+ (1.8Ghz), com 1Gb de mem\u00f3ria RAM. Os tempos foram mensurados em milissegundos,\ndescartando-se a menor e maior medida para cada tamanho e classe (filtrada ou n\u00e3o) de imagem.\n\nDesta forma, obt\u00e9m-se os tempos m\u00e9dios de execu\u00e7\u00e3o para as imagens originais e filtradas, nos\ntamanhos citados acima, sem pr\u00e9-processamento. A an\u00e1lise dos dados obtidos para cada tipo de\nimagem revela pouca varia\u00e7\u00e3o entre o desempenho dos algoritmos nas diferentes imagens de um\nmesmo tamanho, sendo mais influenciado pelo n\u00famero total de pixels. Ordenando-se os algoritmos\npor seu desempenho, temos que, na implementa\u00e7\u00e3o Python, o algoritmo Componentes Conexos \u00e9 o\nmais r\u00e1pido, e o algoritmo C\u00f3digo de Corrente \u00e9 o mais lento. Esta diferen\u00e7a \u00e9 inesperada em rela\u00e7\u00e3o\nao projeto do algoritmo, ambos com abordagens muito pr\u00f3ximas. No entanto, na avalia\u00e7\u00e3o de Osma-\nRuiz et al. [25], foram tamb\u00e9m necess\u00e1rias modifica\u00e7\u00f5es na implementa\u00e7\u00e3o, sem as quais o algoritmo\ntem perdas de at\u00e9 200% de desempenho. Estas modifica\u00e7\u00f5es n\u00e3o foram inclu\u00eddas na implementa\u00e7\u00e3o\ntestada aqui, seguindo apenas o projeto e recomenda\u00e7\u00f5es originais.\n\nCalculando-se a m\u00e9dia para cada grupo de imagens de mesmo tamanho, pode-se calcular o de-\nsempenho relativo entre os algoritmos, verificando o aumento de tempo em rela\u00e7\u00e3o ao algoritmo mais\nr\u00e1pido, para cada tamanho. Estes resultados s\u00e3o apresentados nas tabelas 4.4 e 4.5, onde as 4 primei-\nras colunas correspondem \u00e0s m\u00e9dias, e as 4 \u00faltimas aos desempenhos relativos. A interpreta\u00e7\u00e3o do\ndesempenho relativo deve ser realizada conforme exemplo: tomando o algoritmo Imers\u00e3o para o ta-\nmanho 64 na Tab. 4.4, este consome 1.43 vezes o tempo do algoritmo Componentes Conexos para\ncompletar seu processo. Pode-se ent\u00e3o construir um gr\u00e1fico sobre as m\u00e9dias dos tempos de execu\u00e7\u00e3o\ndos algoritmos, apresentado na Fig. 4.12, utilizando os dados das imagens n\u00e3o filtradas, com a escala\nno eixo Y correspondendo ao tempo em segundos, e o eixo X o n\u00famero total de pixels na imagem.\nPode-se dizer tamb\u00e9m que os algoritmos s\u00e3o bem comportados a respeito de sua classifica\u00e7\u00e3o relativa\ngeral, sendo est\u00e1veis em rela\u00e7\u00e3o ao crescimento de pixels na imagem, indicando caracter\u00edsticas de\ncomplexidade parecidas.\n\nEm rela\u00e7\u00e3o ainda aos dados das Tabs. 4.4 e 4.5, calcula-se a influ\u00eancia do n\u00famero de m\u00ednimos\nregionais no desempenho geral do algoritmo, com a raz\u00e3o percentual de tempo entre a execu\u00e7\u00e3o nas\nimagens filtradas e as originais apresentada na Tab. 4.6. Analisando-se esta tabela, percebe-se que\no algoritmo Componentes Conexos apresenta a maior perda de desempenho, de aproximadamente\n20%, e que alguns algoritmos, como Fila de Prioridade, IFT e C\u00f3digo de Corrente praticamente n\u00e3o\napresentam variabilidade em rela\u00e7\u00e3o ao n\u00famero de m\u00ednimos. Para os algoritmos Tobog\u00e3 e Imers\u00e3o\n\n\n\n4.3 An\u00e1lise de Desempenho do Tempo de Execu\u00e7\u00e3o 125\n\nFig. 4.12: Gr\u00e1fico comparativo do tempo de execu\u00e7\u00e3o m\u00e9dio dos algoritmos em segundos por n\u00famero\nde pixels, para imagens com zonas planas e sem filtragem\n\nInvariantes, a redu\u00e7\u00e3o de m\u00ednimos regionais causa a redu\u00e7\u00e3o no tempo de execu\u00e7\u00e3o. De forma geral,\nos resultados dos algoritmos Componentes Conexos, Tobog\u00e3 e Imers\u00e3o Invariantes se devem \u00e0 forma\ncomo os pixels s\u00e3o rotulados, percorrendo caminhos maiores ou n\u00e3o. Em rela\u00e7\u00e3o aos algoritmos Fila\nde Prioridade e IFT, a detec\u00e7\u00e3o de m\u00ednimos regionais varre a imagem inteira apenas uma vez, inde-\npendente do n\u00famero destes detectados, e o algoritmo em si tem seu tempo de desempenho atrelado\n\u00e0 fila de prioridade, independente da estrutura da imagem. Da mesma forma, o algoritmo C\u00f3digo\nde Corrente efetua a rotula\u00e7\u00e3o de forma independente da estrutura da imagem, sendo que as outras\netapas n\u00e3o s\u00e3o influenciadas pela filtragem realizada. Os dados na Tab. 4.6 devem ser interpretados\ncomo uma acelera\u00e7\u00e3o no desempenho resultante da redu\u00e7\u00e3o de m\u00ednimos regionais. Valores negativos\nindicam melhora (tempos de execu\u00e7\u00e3o menores), enquanto valores positivos indicam piora. A se-\ngunda parte da an\u00e1lise de desempenho \u00e9 realizada tendo como entrada as imagens originais e filtradas\npr\u00e9-processadas para remo\u00e7\u00e3o de zonas planas. Desta forma, incluem-se os algoritmos union-find e\nwatershed cut, que necessitam desta etapa para produzir resultados equivalentes aos outros. No en-\n\n\n\n126 An\u00e1lise Cr\u00edtica dos Algoritmos\n\ntanto, a remo\u00e7\u00e3o de zonas planas tamb\u00e9m altera o desempenho da maioria dos algoritmos, pois estes\nn\u00e3o realizam mais o tratamento interno destas, quando expl\u00edcito. O procedimento utilizado para os\ntestes foi o mesmo do anterior, sendo que o pr\u00e9-processamento da imagem n\u00e3o foi mensurado, pois\neste n\u00e3o faz parte do foco deste estudo. Assim como nas imagens sem pr\u00e9-processamento, os tempos\nmedidos revelam o algoritmo Componentes Conexos como a implementa\u00e7\u00e3o Python mais eficiente,\ne o algoritmo C\u00f3digo de Corrente com o pior desempenho, para todos os tamanhos de imagem testa-\ndos. O pr\u00e9-processamento para remo\u00e7\u00e3o de zonas planas n\u00e3o influenciou na variabilidade nos tempos\nde execu\u00e7\u00e3o entre imagens do mesmo tamanho. Desta forma, procede-se com o c\u00e1lculo das m\u00e9dias\npor tamanho da imagem, apresentadas nas tabelas 4.7 e 4.8, assim como o desempenho relativo ao\nalgoritmo Componentes Conexos. Realizando o mesmo comparativo do teste anterior, verifica-se na\ntabela 4.9 a perda de desempenho quando realizada a filtragem na imagem. Analisando-se esta tabela,\nnota-se que a varia\u00e7\u00e3o que ocorre em imagens sem pr\u00e9-processamento, especialmente em rela\u00e7\u00e3o ao\nalgoritmo Componentes Conexos, \u00e9 eliminada, tornando o desempenho deste, e tamb\u00e9m dos outros\nalgoritmos, praticamente est\u00e1vel em rela\u00e7\u00e3o a estrutura da imagem, dado que o pr\u00e9-processamento\na modifica de forma a otimizar a classe de algoritmos que opera por busca em profundidade. Para\nconcluir este teste, o gr\u00e1fico apresentado na Fig. 4.13 apresenta o desempenho m\u00e9dio dos algoritmos\nsobre imagens pr\u00e9-processadas sem filtragem. Nota-se que n\u00e3o h\u00e1 diferen\u00e7as grandes de desem-\npenho, no entanto o pr\u00e9-processamento permitiu ao algoritmo Componentes Conexos aumentar seu\ndesempenho em rela\u00e7\u00e3o aos outros.\n\nA influ\u00eancia real do pr\u00e9-processamento sobre o comportamento dos algoritmos \u00e9 analisada na\nTab. 4.10, onde calcula-se a diferen\u00e7a percentual entre o desempenho dos algoritmos sem e com a\nremo\u00e7\u00e3o de zonas planas, para as imagens sem filtragem. Nota-se a pequena influ\u00eancia disto sobre\nos algoritmos por busca em largura, dado que poss\u00edveis redu\u00e7\u00f5es s\u00e3o ocasionadas por menos uso de\nmem\u00f3ria por filas, e aumentos no tempo (valores negativos) s\u00e3o resultados de mais n\u00edveis de cinza\nnas filas de prioridade, causando uma tabela de espalhamento maior, utilizada para armazenar cada\nn\u00edvel, ocupando mais mem\u00f3ria.\n\nEm rela\u00e7\u00e3o aos algoritmos por busca em profundidade, a diferen\u00e7a de desempenho est\u00e1 relaci-\nonada a estrat\u00e9gia utilizada para percorrer os caminhos calculados, se isto \u00e9 feito recursivamente\n(Tobog\u00e3 Invariante), ou atrav\u00e9s de uma pilha (C\u00f3digo de Corrente) ou fila (Componentes Conexos,\nCaminhos M\u00ednimos). Claramente, o uso de uma fila traz melhores resultados, visto que os caminhos\ns\u00e3o percorridos uma vez para identifica\u00e7\u00e3o do r\u00f3tulo e utiliza-se a fila ent\u00e3o para aplicar estes r\u00f3-\ntulos nos pixels do caminho. Na Tab. 4.10 interpreta-se os valores como o ganho de desempenho\nrelacionado \u00e0 remo\u00e7\u00e3o de zonas planas.\n\n4.3.1 An\u00e1lise de Complexidade\nPara possibilitar uma avalia\u00e7\u00e3o adequada dos algoritmos e das medidas de desempenho apresen-\n\ntadas nesta se\u00e7\u00e3o, deve-se ter como par\u00e2metro tamb\u00e9m a complexidade \u00e0 qual as implementa\u00e7\u00f5es dos\nalgoritmos est\u00e3o submetidas. No entanto, esta an\u00e1lise n\u00e3o \u00e9 trivial, pois a maioria dos algoritmos\npossui diversas etapas com complexidades distintas. Assim, consideram-se como fatores o n\u00famero\ntotal de pixels n, o n\u00famero de pixels em zonas planas n2 e o n\u00famero de pixels em m\u00ednimos regionais\nn3. O tamanho da vizinhan\u00e7a, por ser significativamente menor que o n\u00famero de pixels \u00e9 descartado\nda an\u00e1lise de complexidade. A respeito dos algoritmos em que o n\u00famero de arestas de um grafo \u00e9\nrelevante, este \u00e9 representado por e.\n\n\n\n4.3 An\u00e1lise de Desempenho do Tempo de Execu\u00e7\u00e3o 127\n\nFig. 4.13: Gr\u00e1fico comparativo do tempo de execu\u00e7\u00e3o m\u00e9dio dos algoritmos em segundos por n\u00famero\nde pixels, para imagens sem zonas planas e sem filtragem\n\nO algoritmo de imers\u00e3o \u00e9 considerado linear, utilizando-se uma estrutura de dados especial para\nordena\u00e7\u00e3o e acesso aos elementos ordenados em cada n\u00edvel de cinza, s\u00e3o realizadas em m\u00e9dia 5 aces-\nsos a cada pixel [6]. O algoritmo fila de prioridade tem como maior caracter\u00edstica o uso da estrutura\nde fila de prioridade com remo\u00e7\u00e3o m\u00ednima. Implementada utilizando uma heap, esta estrutura obt\u00e9m\ncomplexidade O(log n) nas opera\u00e7\u00f5es de inser\u00e7\u00e3o e remo\u00e7\u00e3o. Assim, dado que cada pixel \u00e9 inserido\ne removido uma vez da fila, e \u00e9 necess\u00e1ria uma varredura adicional para detec\u00e7\u00e3o dos m\u00ednimos regi-\nonais, este algoritmo tem complexidade O(2n log n). O algoritmo componentes conexos \u00e9 avaliado\nem cada uma de suas etapas individualmente, com complexidade O(4n + n2 + n3 log n3) [29]. A\nrespeito do algoritmo Union-Find, sua complexidade n\u00e3o \u00e9 avaliada como um todo na literatura, no\nentanto, este requer duas varreduras para execu\u00e7\u00e3o do lower completion, uma varredura para cons-\n\n\n\n128 An\u00e1lise Cr\u00edtica dos Algoritmos\n\ntru\u00e7\u00e3o do grafo ac\u00edclico direcionado, e o processamento de uma opera\u00e7\u00e3o FIND em cada pixel, que\npode ser desdobrada em m\u00faltiplas chamadas, devido a natureza do algoritmo. O algoritmo IFT pode\nser visto como uma implementa\u00e7\u00e3o do algoritmo de Dijkstra com custo m\u00e1ximo, que tem comple-\nxidade O((n + e) log n) [26]. Entretanto, sua implementa\u00e7\u00e3o \u00e9 degenerada no algoritmo de fila de\nprioridade, onde o n\u00famero de arestas efetivamente visitadas \u00e9 igual ao n\u00famero de pixels na imagem.\nNeste algoritmo tamb\u00e9m \u00e9 realizada uma varredura adicional para detec\u00e7\u00e3o dos m\u00ednimos. A inclus\u00e3o\nde condi\u00e7\u00f5es adicionais verificadas para cada pixel, estendendo-o no c\u00e1lculo da zona de empate n\u00e3o\naltera sua complexidade. No algoritmo c\u00f3digo de corrente, a remo\u00e7\u00e3o da opera\u00e7\u00e3o FIND, faz com\nque, baseado no algoritmo componentes conexos, sua complexidade seja reduzida para O(4n + n2)\n[23]. O algoritmo caminhos m\u00ednimos por sua vez ao reduzir o n\u00famero total de varreduras da imagem,\naltera a sua complexidade para O(2n + n2 ? n3) [25]. Por \u00faltimo, o algoritmo watershed cut varre a\nimagem duas vezes apenas, atingindo ent\u00e3o complexidade linear [9].\n\nTomando estas informa\u00e7\u00f5es como base para an\u00e1lise dos gr\u00e1ficos das Figs. 4.12 e 4.13, verifica-se\nque as implementa\u00e7\u00f5es e imagens utilizadas mascararam estes resultados, criando um comportamento\nquase linear para todos os algoritmos testados. Esta caracter\u00edstica pode ser atribu\u00edda \u00e0 linguagem\nPython, cujo desempenho \u00e9 limitado pela capacidade de seu intepretador de refletir o real comporta-\nmento esperado de algoritmos fortemente iterativos e tamb\u00e9m aos tamanhos das imagens utilizadas e\nsuas caracter\u00edsticas. Ou seja, devido \u00e0 escolha da linguagem Python para implementa\u00e7\u00e3o dos algorit-\nmos em um n\u00edvel alto de abstra\u00e7\u00e3o, incorreu-se na perda de desempenho geral, e descaracteriza\u00e7\u00e3o da\nfun\u00e7\u00e3o limitante destes. Al\u00e9m disso, o overhead das estruturas de dados faz com que os algoritmos\nque menos dependam destas para realizar suas itera\u00e7\u00f5es se tornem mais r\u00e1pidos, como por exemplo\no algoritmos componentes conexos se beneficiando desta caracter\u00edstica e c\u00f3digo de corrente sendo\nprejudicado.\n\n4.3.2 Considera\u00e7\u00f5es\n\nNesta se\u00e7\u00e3o foram apresentados resultados de um teste de desempenho do tempo de execu\u00e7\u00e3o\ndos algoritmos de transformada watershed considerando a execu\u00e7\u00e3o sobre imagens com e sem pr\u00e9-\nprocessamento para remo\u00e7\u00e3o de zonas planas. Deve-se ressaltar que os resultados obtidos aqui s\u00e3o\ninfluenciados pela implementa\u00e7\u00e3o em linguagem Python, que n\u00e3o favorece algoritmos com intensa\nrepeti\u00e7\u00e3o de dados. Tamb\u00e9m deve-se considerar a carga causada pelo uso de estruturas de dados,\nas quais otimizadas podem causar sens\u00edveis diferen\u00e7as de desempenho. No entanto, o uso desta\navalia\u00e7\u00e3o pode guiar projetos de algoritmos e implementa\u00e7\u00f5es a utilizar combina\u00e7\u00f5es de t\u00e9cnicas\npara melhorar o tempo de execu\u00e7\u00e3o.\n\nFoi mostrado tamb\u00e9m que nos resultados para a linguagem Python a opera\u00e7\u00e3o de pr\u00e9-processamento\nn\u00e3o traz aumento significativo do desempenho, considerando o seu custo. No entanto, alguns algo-\nritmos dependem desta para produzir resultados consistentes. Entretanto, \u00e9 claro que os resultados\nobtidos aqui podem ser diferentes dos obtidos ao utilizar outras linguagens, por exemplo C/C++, de-\nvido a natureza das linguagens interpretadas, como Python, de apresentar perda de velocidade em\nitera\u00e7\u00f5es sobre grandes conjuntos de dados, e descaracterizar a fun\u00e7\u00e3o limitante.\n\n\n\n4.4 An\u00e1lise de Paralelismo 129\n\n4.4 An\u00e1lise de Paralelismo\n\nO c\u00e1lculo da transformada watershed \u00e9 muito utilizado em tarefas de segmenta\u00e7\u00e3o de imagens em\nprocessos de vis\u00e3o computacional. Tais processos t\u00eam - de maneira geral - requisitos de velocidade\nlimitantes, onde deseja-se sempre diminuir os tempos de execu\u00e7\u00e3o para obter resultados mais rapi-\ndamente ou adicionar etapas mais complexas ao processamento. Desta forma, desde a introdu\u00e7\u00e3o da\ntransformada watershed estudam-se t\u00e9cnicas de paraleliza\u00e7\u00e3o de modo a obter ganhos em velocidade.\nO foco inicial destes trabalhos estava em sistema de processamento de imagem t\u00edpicos, onde a seg-\nmenta\u00e7\u00e3o representaria uma etapa demorada [46, 30, 44], e algoritmos paralelos poderiam melhorar\no desempenho destes sistemas. Neste t\u00f3pico, Roerdink e Meijster produziram uma extensa revis\u00e3o\nbibliogr\u00e1fica [12]. Mais recentemente, devido a evolu\u00e7\u00e3o dos processadores e a redu\u00e7\u00e3o significativa\ndo tempo de processamento dos algoritmos sequenciais, o foco dos algoritmos paralelos - apesar de\nainda ser a acelera\u00e7\u00e3o - passou a ser em sistemas com requisitos de processamento mais restritos,\ntais como de navega\u00e7\u00e3o aut\u00f4noma, onde deseja-se atingir taxas de processamento de at\u00e9 30 quadros\npor segundo. Neste sentido, algoritmos sequenciais ainda n\u00e3o s\u00e3o suficientemente r\u00e1pidos, e outras\nestrat\u00e9gias s\u00e3o procuradas [47, 48].\n\nOs primeiros trabalhos de Moga et al. [44] e Meijster e Roerdink [46] buscam definir o problema\ne abordagens para este, baseando-se em algoritmos j\u00e1 existentes. Desta forma, cria-se de fato uma\narquitetura e t\u00e9cnicas para gerenciar r\u00f3tulos e divis\u00f5es de blocos, necess\u00e1rias ao paralelismo. Estas\nabordagens dependem de um algoritmo sequencial, executado em cada bloco, e posteriormente uma\netapa de fus\u00e3o das regi\u00f5es e unifica\u00e7\u00e3o de r\u00f3tulos. Bieniek et al. [30] segue esta mesma linha,\npor\u00e9m introduz um novo algoritmo sequencial, mais adequado \u00e0 divis\u00e3o da imagem em blocos. Uma\ncaracter\u00edstica comum \u00e0s arquiteturas paralelas propostas \u00e9 a necessidade de detec\u00e7\u00e3o e rotula\u00e7\u00e3o dos\nm\u00ednimos regionais previamente ao watershed em si, feito isto para unifica\u00e7\u00e3o dos r\u00f3tulos.\n\nGalil\u00e9e et al. [48] introduz um algoritmo especificamente para arquiteturas paralelas, sem a ne-\ncessidade da detec\u00e7\u00e3o de m\u00ednimos regionais, e utilizando comunica\u00e7\u00e3o por mensagens para otimizar\no processamento entre os v\u00e1rios n\u00facleos. Dessa forma, o algoritmo paralelo de fato realiza o gerenci-\namento de mensagens e estados, propagando r\u00f3tulos e dist\u00e2ncias, especialmente em zonas planas, que\naguardam a chegada dos dados de vizinhos at\u00e9 a rotula\u00e7\u00e3o de toda a imagem. A abordagem de Trieu e\nMaruyama [47] baseia-se no algoritmo C\u00f3digo de Corrente, de Sun, Yang e Ren [23], modificando-o\npara arquiteturas FPGA, sem o uso de estruturas de dados como filas e pilhas, realizando a sincro-\nniza\u00e7\u00e3o dos dados at\u00e9 estabiliza\u00e7\u00e3o destes, varrendo a imagem em sentido raster e anti-raster at\u00e9 a\nconverg\u00eancia do processo.\n\nEm conjunto com o trabalho desta disserta\u00e7\u00e3o, prop\u00f4s-se um algoritmo de transformada wa-\ntershed apropriado ao uso em processadores gr\u00e1ficos many-core de prop\u00f3sito gen\u00e9rico, chamados\nde GPUs [49]. Estes processadores operam em arquitetura SIMD (Single Instruction Multiple Data),\nrequerindo algoritmos especializados e projetados para tal fim. Entretanto, a aplica\u00e7\u00e3o da trans-\nformada watershed inteiramente paralela, como projetado inicialmente, n\u00e3o se mostrou a melhor\nop\u00e7\u00e3o comparando-se os tempos de execu\u00e7\u00e3o para os passos individuais necess\u00e1rios. Desta forma,\naproveitando-se de uma caracter\u00edstica do modelo CUDA de programa\u00e7\u00e3o para GPUs que permite al-\nternar o processamento entre GPU e CPU, desenvolveu-se um algoritmo h\u00edbrido, utilizando as etapas\nmais r\u00e1pidas em cada caso [50].\n\nA diverg\u00eancia de abordagens paralelas para a transformada watershed ressalta que este n\u00e3o \u00e9 um\nproblema trivial. A evolu\u00e7\u00e3o de novas m\u00e1quinas paralelas e arquiteturas diferenciadas torna esta ta-\n\n\n\n130 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nrefa mais complicada, requerendo novos algoritmos. Entretanto, verifica-se que entre as abordagens\nexistentes para paraleliza\u00e7\u00e3o da transformada watershed, todas s\u00e3o baseadas em algoritmos sequen-\nciais, carregando problemas de sincroniza\u00e7\u00e3o destes. Assim, identifica-se a necessidade de novas\nabordagens para algoritmos paralelos de transformada watershed, utilizando conceitos e t\u00e9cnicas di-\nferentes das utilizadas em algoritmos sequenciais.\n\n\n\n4.4 An\u00e1lise de Paralelismo 131\n\nA\nno\n\nA\nlg\n\nor\nit\n\nm\no\n\nD\nefi\n\nni\n\u00e7\u00e3\n\no\nE\n\nxp\nan\n\ns\u00e3\no\n\nE\nnd\n\ner\ne\u00e7\n\na-\nm\n\nen\nto\n\nR\not\n\nul\na\u00e7\n\n\u00e3o\nM\n\n\u00edn\nim\n\nos\nE\n\nst\nru\n\ntu\nra\n\ns\nde\n\nD\nad\n\nos\n19\n\n91\nIm\n\ner\ns\u00e3\n\no\nV\n\nin\nce\n\nnt\ne\n\nS\noi\n\nll\ne\n\nF\nlo\n\nod\nin\n\ng-\nW\n\nT\n(1\n\n)\nL\n\nar\ngu\n\nra\n--\n\n--\nO\n\nrd\nen\n\na\u00e7\n\u00e3o\n\nF\nil\n\na\n/O\n\nrd\nen\n\na\u00e7\n\u00e3o\n\n19\n93\n\nF\nil\n\na\nde\n\nP\nri\n\nor\nid\n\nad\ne\n\nB\neu\n\nch\ner\n\ne\nM\n\ney\ner\n\nIF\nT-\n\nW\nT\n\nL\nar\n\ngu\nra\n\n--\n--\n\nE\nnt\n\nra\nda\n\nF\nil\n\na\nH\n\nie\nr\u00e1\n\nrq\nui\n\nca\n\n19\n94\n\nD\nij\n\nsk\ntr\n\na-\nM\n\noo\nre\n\nde\nC\n\nam\nin\n\nho\ns\n\nM\n\u00ed-\n\nni\nm\n\nos\nde\n\nM\ney\n\ner\n(2\n\n)\nT\n\nD\n-W\n\nT\nL\n\nar\ngu\n\nra\n--\n\n--\nE\n\nnt\nra\n\nda\n--\n\n19\n94\n\nH\nil\n\nl-\nC\n\nli\nm\n\nbi\nng\n\nde\nM\n\ney\ner\n\n(2\n)\n\nT\nD\n\n-W\nT\n\nL\nar\n\ngu\nra\n\n--\n--\n\nE\nnt\n\nra\nda\n\n--\n19\n\n94\nB\n\ner\nge\n\nde\nC\n\nam\nin\n\nho\ns\n\nM\n\u00edn\n\nim\nos\n\nde\nM\n\ney\ner\n\n(2\n)\n\nT\nD\n\n-W\nT\n\nA\nle\n\nat\n\u00f3r\n\nio\n--\n\n--\nE\n\nnt\nra\n\nda\n--\n\n19\n98\n\nC\nom\n\npo\nne\n\nnt\nes\n\nC\non\n\nex\nos\n\nde\nB\n\nie\nni\n\nek\ne\n\nM\nog\n\na\nL\n\nC\n-W\n\nT\nP\n\nro\nfu\n\nnd\nid\n\nad\ne\n\nA\nbs\n\nol\nut\n\no\nC\n\nom\npr\n\nes\ns\u00e3\n\no\nA\n\nrr\now\n\nin\ng\n\nF\nil\n\na\n\n19\n98\n\nU\nni\n\non\n-F\n\nin\nd\n\nde\nM\n\nei\njs\n\nte\nr\n\ne\nR\n\noe\nrd\n\nin\nk\n\nT\nD\n\n-W\nT\n\nP\nro\n\nfu\nnd\n\nid\nad\n\ne\nA\n\nbs\nol\n\nut\no\n\nC\nom\n\npr\nes\n\ns\u00e3\no\n\nA\nrr\n\now\nin\n\ng\nF\n\nil\na\n\n/G\nra\n\nfo\n20\n\n00\nIF\n\nT\nde\n\nL\not\n\nuf\no\n\ne\nFa\n\nlc\n\u00e3o\n\nIF\nT-\n\nW\nT\n\nL\nar\n\ngu\nra\n\n--\n--\n\nE\nnt\n\nra\nda\n\nF\nil\n\na\nH\n\nie\nr\u00e1\n\nrq\nui\n\nca\n20\n\n05\nC\n\n\u00f3d\nig\n\no\nde\n\nC\nor\n\nre\nnt\n\ne\nde\n\nS\nun\n\n,Y\nan\n\ng\ne\n\nR\nen\n\nL\nC\n\n-W\nT\n\nP\nro\n\nfu\nnd\n\nid\nad\n\ne\nR\n\nel\nat\n\niv\no\n\nR\not\n\nul\na\u00e7\n\n\u00e3o\nA\n\nrr\now\n\nin\ng\n\nF\nil\n\na\n/P\n\nil\nha\n\n20\n05\n\nZ\non\n\na\nde\n\nE\nm\n\npa\nte\n\nde\nA\n\nud\nig\n\nie\nr,\n\nL\no-\n\ntu\nfo\n\ne\nC\n\nou\npr\n\nie\nT\n\nZ\n-I\n\nF\nT-\n\nW\nT\n\nL\nar\n\ngu\nra\n\n--\n--\n\nE\nnt\n\nra\nda\n\nF\nil\n\na\nH\n\nie\nr\u00e1\n\nrq\nui\n\nca\n\n20\n05\n\nTo\nbo\n\ng\u00e3\nIn\n\nva\nri\n\nan\nte\n\na\nO\n\nrd\nem\n\nde\nL\n\nin\net\n\nal\n.\n\n(3\n)\n\nT\nD\n\n-W\nT\n\nP\nro\n\nfu\nnd\n\nid\nad\n\ne\nA\n\nbs\nol\n\nut\no\n\nR\not\n\nul\na\u00e7\n\n\u00e3o\nA\n\nrr\now\n\nin\ng\n\nF\nil\n\na\n/G\n\nra\nfo\n\n20\n05\n\nIm\ner\n\ns\u00e3\no\n\nIn\nva\n\nri\nan\n\nte\na\n\nO\nrd\n\nem\nde\n\nL\nin\n\net\nal\n\n.\n(3\n\n)\nT\n\nD\n-W\n\nT\nL\n\nar\ngu\n\nra\n--\n\n--\nO\n\nrd\nen\n\na\u00e7\n\u00e3o\n\nF\nil\n\na\n/O\n\nrd\nen\n\na\u00e7\n\u00e3o\n\n20\n06\n\nC\nam\n\nin\nho\n\ns\nM\n\n\u00edn\nim\n\nos\nde\n\nO\nsm\n\na-\nR\n\nui\nz\n\net\nal\n\n.\nL\n\nC\n-W\n\nT\nP\n\nro\nfu\n\nnd\nid\n\nad\ne\n\nR\nel\n\nat\niv\n\no\nR\n\not\nul\n\na\u00e7\n\u00e3o\n\nA\nrr\n\now\nin\n\ng\nF\n\nil\na\n\n20\n08\n\nW\nat\n\ner\nsh\n\ned\n-C\n\nut\nde\n\nC\nou\n\nst\ny\n\net\nal\n\n.\nW\n\nC\n-W\n\nT\nP\n\nro\nfu\n\nnd\nid\n\nad\ne\n\nC\non\n\nju\nnt\n\no\nR\n\not\nul\n\na\u00e7\n\u00e3o\n\nA\nrr\n\now\nin\n\ng\nC\n\non\nju\n\nnt\no\n\n/G\nra\n\nfo\n\nTa\nb.\n\n4.\n2:\n\nR\nes\n\num\no\n\nda\ns\n\nca\nra\n\nct\ner\n\n\u00eds\nti\n\nca\ns\n\ndo\ns\n\nal\ngo\n\nri\ntm\n\nos\nes\n\ntu\nda\n\ndo\ns\n\n\n\n132 An\u00e1lise Cr\u00edtica dos Algoritmos\n\n64 128 256 512\nlena 432 1855 7844 36628\nlena filtrado 273 1051 3654 16923\nbaboon 600 2654 10798 37372\nbaboon filtrado 488 2133 8978 30674\ncamera 454 1914 8594 24709\ncamera filtrado 208 845 3640 6804\npeppers 442 1661 7337 33000\npeppers filtrado 320 1039 3257 22222\n\nTab. 4.3: M\u00ednimos regionais por imagens e por tamanhos\n\nAlgoritmos/Tamanhos 64 128 256 512 64 128 256 512\nImers\u00e3o 0.55 2.21 8.80 35.41 1.43 1.40 1.38 1.33\nFila de Prioridade 0.50 2.05 8.32 35.03 1.30 1.29 1.30 1.32\nComponentes Conexos 0.39 1.58 6.37 26.60\nIFT 0.54 2.14 8.64 36.30 1.39 1.35 1.36 1.36\nC\u00f3digo de Corrente 0.98 3.92 15.56 62.87 2.55 2.48 2.44 2.36\nTobog\u00e3 Invariante 0.68 2.71 10.69 43.11 1.77 1.72 1.68 1.62\nImers\u00e3o Invariante 0.62 2.44 9.58 38.01 1.60 1.54 1.50 1.43\nCaminhos M\u00ednimos 0.59 2.35 9.40 39.14 1.52 1.48 1.48 1.47\n\nTab. 4.4: M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algoritmo, e\ndesempenho relativo, para imagens com zonas planas n\u00e3o filtradas\n\nAlgoritmos/Tamanhos 64 128 256 512 64 128 256 512\nImers\u00e3o 0.56 2.29 9.17 36.85 1.25 1.20 1.16 1.15\nFila de Prioridade 0.51 2.05 8.37 34.55 1.13 1.07 1.06 1.08\nComponentes Conexos 0.45 1.91 7.91 31.96\nIFT 0.53 2.15 8.71 35.91 1.18 1.12 1.10 1.12\nC\u00f3digo de Corrente 0.98 3.94 15.63 62.89 2.18 2.06 1.98 1.97\nTobog\u00e3 Invariante 0.66 2.60 10.24 41.98 1.46 1.36 1.29 1.31\nImers\u00e3o Invariante 0.59 2.30 8.95 35.60 1.30 1.20 1.13 1.11\nCaminhos M\u00ednimos 0.62 2.53 10.40 42.43 1.37 1.32 1.32 1.33\n\nTab. 4.5: M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algoritmo, e\ndesempenho relativo, para imagens com zonas planas filtradas\n\n\n\n4.4 An\u00e1lise de Paralelismo 133\n\nAlgoritmos/Tamanhos 64 128 256 512\nImers\u00e3o 2% 4% 4% 4%\nFila de Prioridade 1% 0% 1% -1%\nComponentes Conexos 17% 21% 24% 20%\nIFT -1% 1% 1% -1%\nC\u00f3digo de Corrente 0% 0% 0% 0%\nTobog\u00e3 Invariante -4% -4% -4% -3%\nImers\u00e3o Invariante -5% -6% -7% -6%\nCaminhos M\u00ednimos 5% 8% 11% 8%\n\nTab. 4.6: Perda de desempenho percentual para os algoritmos, por tamanho de imagem, entre as\nimagens com zonas planas filtradas e n\u00e3o filtradas\n\nAlgoritmos/Tamanhos 64 128 256 512 64 128 256 512\nImers\u00e3o 0.55 2.18 8.76 35.03 1.51 1.50 1.50 1.49\nFila de Prioridade 0.50 2.05 8.40 35.21 1.38 1.41 1.43 1.50\nComponentes Conexos 0.36 1.46 5.85 23.54\nUnion-Find 0.89 3.53 14.11 57.30 2.44 2.43 2.41 2.43\nIFT 0.53 2.14 8.76 36.58 1.44 1.47 1.50 1.55\nC\u00f3digo de Corrente 0.98 3.90 15.58 62.46 2.68 2.68 2.66 2.65\nTobog\u00e3 Invariante 0.70 2.79 11.12 44.77 1.91 1.92 1.90 1.90\nImers\u00e3o Invariante 0.63 2.49 9.88 39.52 1.71 1.71 1.69 1.68\nCaminhos M\u00ednimos 0.56 2.28 9.12 36.49 1.54 1.57 1.56 1.55\nWatershed Cut 0.44 1.85 7.85 38.15 1.21 1.27 1.34 1.62\n\nTab. 4.7: M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algoritmo, e\ndesempenho relativo, para imagens sem zonas planas n\u00e3o filtradas\n\n\n\n134 An\u00e1lise Cr\u00edtica dos Algoritmos\n\nAlgoritmos/Tamanhos 64 128 256 512 64 128 256 512\nImers\u00e3o 0.55 2.20 8.80 35.35 1.51 1.51 1.53 1.54\nFila de Prioridade 0.50 2.03 8.37 34.28 1.37 1.40 1.46 1.49\nComponentes Conexos 0.36 1.45 5.74 22.99\nUnion-Find 0.89 3.56 14.25 58.04 2.43 2.45 2.48 2.52\nIFT 0.53 2.13 8.75 35.75 1.44 1.47 1.52 1.56\nC\u00f3digo de Corrente 0.97 3.92 15.67 62.44 2.67 2.70 2.73 2.72\nTobog\u00e3 Invariante 0.70 2.84 11.50 46.48 1.92 1.96 2.00 2.02\nImers\u00e3o Invariante 0.63 2.51 10.05 40.00 1.72 1.73 1.75 1.74\nCaminhos M\u00ednimos 0.57 2.28 9.15 36.58 1.56 1.57 1.59 1.59\nWatershed Cut 0.45 1.84 7.77 40.84 1.22 1.27 1.35 1.78\n\nTab. 4.8: M\u00e9dia geral dos tempos de execu\u00e7\u00e3o em segundos por tamanho de imagem e algoritmo, e\ndesempenho relativo, para imagens sem zonas planas e filtradas\n\nAlgoritmos/Tamanhos 64 128 256 512\nImers\u00e3o 0% 1% 0% 1%\nFila de Prioridade -1% -1% 0% -3%\nComponentes Conexos 0% 0% -2% -2%\nUnion-Find 0% 1% 1% 1%\nIFT 0% 0% 0% -2%\nC\u00f3digo de Corrente 0% 0% 1% 0%\nTobog\u00e3 Invariante 1% 2% 3% 4%\nImers\u00e3o Invariante 0% 1% 2% 1%\nCaminhos M\u00ednimos 1% 0% 0% 0%\nWatershed Cut 1% 0% -1% 7%\n\nTab. 4.9: Perda de desempenho percentual para os algoritmos, por tamanho de imagem, entre as\nimagens sem zonas planas filtradas e n\u00e3o filtradas\n\n\n\n4.4 An\u00e1lise de Paralelismo 135\n\nAlgoritmos/Tamanhos 64 128 256 512\nImers\u00e3o 1% 1% 1% 1%\nFila de Prioridade 0% 0% -1% -1%\nComponentes Conexos 6% 9% 9% 13%\nIFT 2% 0% -1% -1%\nC\u00f3digo de Corrente 1% 0% 0% 1%\nTobog\u00e3 Invariante -2% -3% -4% -4%\nImers\u00e3o Invariante -1% -2% -3% -4%\nCaminhos M\u00ednimos 4% 3% 3% 7%\n\nTab. 4.10: Compara\u00e7\u00e3o de desempenho para os algoritmos por tamanho de imagem, entre as imagens\nsem filtragem com e sem zonas planas\n\n\n\nCap\u00edtulo 5\n\nConsidera\u00e7\u00f5es Finais\n\n5.1 Conclus\u00f5es\n\nA transformada watershed, desde sua introdu\u00e7\u00e3o no processamento morfol\u00f3gico de imagens at\u00e9\no presente momento, tem sido alvo constante de estudos, buscando atingir algoritmos mais r\u00e1pidos\ne formaliza\u00e7\u00f5es que os representem consistentemente, al\u00e9m de fornecer uma ferramenta de segmen-\nta\u00e7\u00e3o \u00fatil e robusta para aplica\u00e7\u00f5es diversas. No entanto, apesar de prover uma interface simples, a\ntransformada watershed pode ser definida por ao menos seis formas, e implementada por 14 algorit-\nmos. Tamanha diversidade inspirou este trabalho, buscando investigar as raz\u00f5es para tal e a evolu\u00e7\u00e3o\nexistente no per\u00edodo. Para isto foram necess\u00e1rias ferramentas b\u00e1sicas de nota\u00e7\u00e3o de algoritmos e da\ncompreens\u00e3o das defini\u00e7\u00f5es existentes, seu comportamento, resultados e rela\u00e7\u00f5es, baseado no traba-\nlho anterior de Romaric focado nas rela\u00e7\u00f5es entre as diferentes defini\u00e7\u00f5es [13].\n\nEste trabalho buscou criar um panorama geral da transformada watershed, avaliando 14 algo-\nritmos existentes na literatura: Imers\u00e3o [6], Fila de Prioridade [11], Dijkstra-Moore de Caminhos\nM\u00ednimos, Hill-Climbing e Berge de Caminhos M\u00ednimos [7], Componentes Conexos [18], Union-\nFind [22], IFT [19], C\u00f3digo de Corrente [23], Zona de Empate [20], Tobog\u00e3 e Imers\u00e3o Invariante\na Ordem [24], Caminhos M\u00ednimos [25] e Watershed Cut [9]. Tal estudo permitiu validar os resul-\ntados em rela\u00e7\u00e3o \u00e0s defini\u00e7\u00f5es existentes, corrigindo-os quando necess\u00e1rio, provendo pseudoc\u00f3digo\ncom nota\u00e7\u00e3o uniformizada, facilitando a compara\u00e7\u00e3o, compreens\u00e3o e implementa\u00e7\u00e3o destes. Cada\nalgoritmo foi avaliado buscando:\n\n\u2022 Defini\u00e7\u00e3o base;\n\n\u2022 Comportamento de varredura na imagem;\n\n\u2022 Caracter\u00edsticas de projeto;\n\n\u2022 Descri\u00e7\u00e3o do funcionamento;\n\n\u2022 Uso de estruturas de dados; e\n\n\u2022 Detalhes de implementa\u00e7\u00e3o.\n\n137\n\n\n\n138 Considera\u00e7\u00f5es Finais\n\nAssim se obteve uma cole\u00e7\u00e3o de algoritmos e informa\u00e7\u00f5es padronizadas, fornecendo meios para\nclassificar e generalizar as abordagens analisadas. A compara\u00e7\u00e3o entre os algoritmos se seguiu divi-\ndida em an\u00e1lise de resultados, comparativa, de desempenho e de paralelismo. A an\u00e1lise de resultados\navaliou os m\u00e9todos utilizados para tratamento de zonas planas e que influenciam na transformada e a\ninflu\u00eancia das seis defini\u00e7\u00f5es em aplica\u00e7\u00f5es pr\u00e1ticas onde o watershed \u00e9 parte do processo. A an\u00e1lise\ncomparativa agrupou, classificou e comparou os algoritmos atrav\u00e9s das caracter\u00edsticas de projeto e\ncomportamento obtidos na avalia\u00e7\u00e3o individual. A an\u00e1lise de desempenho utilizou implementa\u00e7\u00f5es\nprototipadas para obter medidas de tempo de execu\u00e7\u00e3o dos algoritmos em linguagem Python, ideal\npara representa\u00e7\u00e3o de pseudoc\u00f3digo por permitir abstra\u00e7\u00f5es de programa\u00e7\u00e3o e assim se aproximar do\nprimeiro, sem perdas de funcionalidade. Por \u00faltimo, a an\u00e1lise de paralelismo buscou identificar os al-\ngoritmos com capacidades para tal e revisar tamb\u00e9m os trabalhos existentes na literatura, destacando\nas dificuldades encontradas neste tipo de abordagem.\n\nCom este estudo, se obteve uma cole\u00e7\u00e3o de algoritmos compondo uma revis\u00e3o bibliogr\u00e1fica atu-\nalizada na \u00e1rea, compreendendo 14 algoritmos, utilizando pseudoc\u00f3digo com nota\u00e7\u00e3o uniforme e\nprovendo implementa\u00e7\u00f5es operacionais na mesma linha, aproximando as abordagens para represen-\nta\u00e7\u00e3o de algoritmos. Entre os algoritmos analisados, foram efetuadas corre\u00e7\u00f5es em 3 destes: Tobog\u00e3\ne Imers\u00e3o Invariantes a Ordem de Lin et al. [24] e Caminhos M\u00ednimos de Osma-Ruiz et al. [25]. Nos\ndois primeiros casos, a corre\u00e7\u00e3o teve o intuito de tornar os algoritmos aderentes \u00e0 defini\u00e7\u00e3o TD-WT,\ncom poucas modifica\u00e7\u00f5es para isto. No terceiro caso, a corre\u00e7\u00e3o implica apenas em corretude de\nespecifica\u00e7\u00e3o para elimina\u00e7\u00e3o de comportamentos incorretos. A identifica\u00e7\u00e3o de propriedades dos\nalgoritmos permitiu classific\u00e1-los de acordo com o comportamento de sua varredura e compar\u00e1-los\ncom abordagens cl\u00e1ssicas em computa\u00e7\u00e3o, a saber: busca em largura e busca em profundidade. Esta\nclassifica\u00e7\u00e3o tamb\u00e9m permitiu generalizar os algoritmos e descrever - utilizando mais a no\u00e7\u00e3o de\ncustos de caminhos e conectividade em detrimento das no\u00e7\u00f5es intuitivas - a transformada watershed.\nEntre as outras propriedades de interesse, pode-se, por inspe\u00e7\u00e3o dos algoritmos em alguns casos,\nidentificar qual a defini\u00e7\u00e3o implementada por cada um destes, representando claramente as op\u00e7\u00f5es e\nrequerimentos de cada um.\n\nAo se vislumbrar a cole\u00e7\u00e3o obtida, algumas conclus\u00f5es s\u00e3o imediatas: tem-se maior compreen-\ns\u00e3o da literatura do assunto ao agrupar as abordagens e identificar caracter\u00edsticas nestas, auxiliando\nna escolha de um algoritmo para um sistema ou mesmo para projetos de novos algoritmos e imple-\nmenta\u00e7\u00f5es; a diversidade de algoritmos permite supor que n\u00e3o h\u00e1 limita\u00e7\u00e3o na arquitetura destes em\nrela\u00e7\u00e3o a qual defini\u00e7\u00e3o implementam, com exemplos amparando tal suposi\u00e7\u00e3o, como por exemplo\nabordagens em largura e profundidade para a defini\u00e7\u00e3o TD-WT. Desta \u00faltima conclus\u00e3o, pode-se\nconstatar tamb\u00e9m a independ\u00eancia dos algoritmos em rela\u00e7\u00e3o \u00e0s defini\u00e7\u00f5es, podendo-se supor que\nqualquer abordagem pode implementar qualquer defini\u00e7\u00e3o, assumindo-se assim que pode existir, por\nexemplo um algoritmo em profundidade que implementa a defini\u00e7\u00e3o IFT-WT.\n\nConforme mencionado na introdu\u00e7\u00e3o, este trabalho est\u00e1 disponibilizado no ambiente Adessowiki,\nprovendo c\u00f3digo-fonte e pseudoc\u00f3digo de refer\u00eancia para a implementa\u00e7\u00e3o dos algoritmos estudados\naqui. Deseja-se que este torne-se uma fonte de consulta din\u00e2mica, provendo programas eficientes para\ncada um dos algoritmos, conjugando c\u00f3digo-fonte em diversas linguagens e estilos com a especifica-\n\u00e7\u00e3o dos algoritmos e sua documenta\u00e7\u00e3o. De forma a avan\u00e7ar neste sentido, o trabalho \u00e9 colocado no\nambiente de forma a permitir a colabora\u00e7\u00e3o de outros autores e assim ser constantemente atualizado\nem rela\u00e7\u00e3o \u00e0 transformada watershed.\n\n\n\n5.2 Trabalhos Futuros 139\n\n5.2 Trabalhos Futuros\nA continua\u00e7\u00e3o deste trabalho \u00e9 prevista em quatro linhas, interligadas por\u00e9m distintas. Planeja-se\n\nestudar mais profundamente as abordagens de paralelismo, especialmente mas n\u00e3o limitado, em algo-\nritmos morfol\u00f3gicos, como a transformada watershed, tomando proveito das tecnologias recentes que\npermitem se obter novamente ganhos de desempenho significativos, como os processadores gr\u00e1ficos\nmany-core (GPU) e as CPUs multi-core, e com isso desenvolver novas estrat\u00e9gias, tanto para projeto,\nquanto para an\u00e1lise, teste e implementa\u00e7\u00e3o de tais algoritmos.\n\nEntre os pontos pouco focados neste trabalho, um deles \u00e9 a an\u00e1lise de desempenho dos algorit-\nmos, onde foi utilizada a linguagem Python por motivos est\u00e9ticos mas que impactou em uma an\u00e1lise\nn\u00e3o muito aprofundada. Neste sentido, planeja-se produzir implementa\u00e7\u00f5es eficientes em linguagem\nC/C++ dos algoritmos mais promissores em termos de velocidade entre os estudados e analisar no-\nvamente o desempenho destes, provendo \u00e0 comunidade cient\u00edfica amparo na escolha tamb\u00e9m neste\nponto, al\u00e9m de implementa\u00e7\u00f5es p\u00fablicas com c\u00f3digo-fonte. Uma consequ\u00eancia quase direta de tal\nan\u00e1lise tamb\u00e9m \u00e9 aprofundar os impactos dos diferentes algoritmos e defini\u00e7\u00f5es nas aplica\u00e7\u00f5es pr\u00e1ti-\ncas, permitindo realizar comparativos com aplica\u00e7\u00f5es de grande porte e com quantidades maiores de\nimagens, invi\u00e1veis utilizando as implementa\u00e7\u00f5es Python.\n\nEm paralelo, neste trabalho apenas os algoritmos de transformada watershed cl\u00e1ssicos foram es-\ntudados, sendo poss\u00edvel tamb\u00e9m estender a an\u00e1lise para outros tipos, como o watershed hier\u00e1rquico,\nestoc\u00e1stico, entre outros. No entanto, tais classes s\u00e3o representadas por poucos algoritmos, n\u00e3o apre-\nsentando os mesmos desafios encontrados na abordagem original.\n\n\n\nRefer\u00eancias Bibliogr\u00e1ficas\n\n[1] Rafael C. Gonz\u00e1lez and Richard E. Woods. Digital Image Processing. Prentice Hall, 2 edition,\n2002.\n\n[2] J. Clerk Maxwell. On hills and dales. Philosophical Magazine, II:233\u2013240, December 1870.\n\n[3] H. Digabel and C. Lantu\u00e9joul. Iterative algorithms. In J.-L. Chermant, editor, Proc. Second\nEuropean Symp. Quantitative Analysis of Microstructures in Material Science, Biology and Me-\ndicine, pages 85\u201399, Stuttgart, Germany, 1978. Riederer Verlag.\n\n[4] S. Beucher and C. Lantu\u00e9joul. Use of watersheds in contour detection. In International\nWorkshop on Image Processing: Real-time Edge and Motion Detection/Estimation, Rennes,\nFrance, September 1979.\n\n[5] F. Meyer and S. Beucher. Morphological segmentation. Journal of Visual Communication and\nImage Representation, 1(1):21\u201346, September 1990.\n\n[6] L. Vincent and P. Soille. Watersheds in digital spaces: An efficient algorithm based on immer-\nsion simulations. IEEE Transactions on Pattern Analysis and Machine Intelligence, 13(6):583\u2013\n598, 1991.\n\n[7] F. Meyer. Topographic distance and watershed lines. Signal Processing, 38(1):113\u2013125, 1994.\n\n[8] A. X. Falc\u00e3o, J. Stolfi, and R. A. Lotufo. The image foresting transform: theory, algorithms, and\napplications. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 26(1):19\u201329,\n2004.\n\n[9] J. Cousty, G. Bertrand, L. Najman, and M. Couprie. Watershed cuts: Minimum spanning fo-\nrests and the drop of water principle. IEEE Transactions on Pattern Analysis and Machine\nIntelligence, 31(8):1362\u20131374, 2009.\n\n[10] D. Hagyard, M. Razaz, and P. Atkin. Analysis of watershed algorithms for greyscale images. In\nProceedings of International Conference on Image Processing (1996), volume 3, pages 41\u201344,\n1996.\n\n[11] S. Beucher and F. Meyer. Mathematical morphology in image processing, chapter The Morpho-\nlogical Approach to Segmentation: The Watershed Transformation. Optical Engineering. M.\nDekker, New York, 1993.\n\n141\n\n\n\n142 REFER\u00caNCIAS BIBLIOGR\u00c1FICAS\n\n[12] J. B. T. M. Roerdink and A. Meijster. The watershed transform: definitions, algorithms and\nparallelization strategies. Fundam. Inf., 41(1-2):187\u2013228, 2000.\n\n[13] R. Audigier. Zona de empate: o elo entre defini\u00e7\u00f5es da transformada de watershed e entre elas\ne a segmenta\u00e7\u00e3o via conexidade nebulosa. PhD thesis, FEEC/Unicamp, Campinas, SP, July\n2007.\n\n[14] Romaric Audigier and Roberto de A. Lotufo. Duality between the watershed by image foresting\ntransform and the fuzzy connectedness segmentation approaches. In Computer Graphics and\nImage Processing, Brazilian Symposium on, pages 53\u201360, Los Alamitos, CA, USA, 2006. IEEE\nComputer Society.\n\n[15] Guido van Rossum and Fred Drake L. Python Reference Manual. Python Software Foundation,\n2009. http://docs.python.org/ref/ref.html.\n\n[16] Roberto A. Lotufo, Rubens C. Machado, Andr\u00e9 K\u00f6rbes, and Rafael G. Ramos. Adessowiki\non-line collaborative scientific programming platform. In WikiSym \u201909: Proceedings of the 5th\nInternational Symposium on Wikis and Open Collaboration, pages 1\u20136, New York, NY, USA,\n2009. ACM.\n\n[17] SDC Information Systems. SDC Morphology Toolbox for Python Documentation. SDC Infor-\nmation Systems, Naperville, IL, USA, 2009. http://www.mmorph.com/pymorphpro/\nmorph/index.html.\n\n[18] A. Bieniek and A. Moga. A connected component approach to the watershed segmentation. In\nISMM \u201998: Proceedings of the fourth international symposium on Mathematical morphology\nand its applications to image and signal processing, pages 215\u2013222, Norwell, MA, USA, 1998.\nKluwer Academic Publishers.\n\n[19] R. Lotufo and A. Falc\u00e3o. The ordered queue and the optimality of the watershed approaches. In\nProceedings of the 5th International Symposium on Mathematical Morphology and its Applica-\ntions to Image and Signal Processing, volume 18, pages 341\u2013350. Kluwer Academic Publishers,\nJune 2000.\n\n[20] R. Audigier, R. Lotufo, and M. Couprie. The tie-zone watershed: Definition, algorithm and\napplications. In Proceedings of IEEE International Conference on Image Processing (ICIP\u201905),\nvolume 2, pages 654\u2013657, 2005.\n\n[21] R. Audigier and R. A. Lotufo. Watershed by image foresting transform, tie-zone, and theoretical\nrelationships with other watershed definitions. In ISMM\u20192007 Proceedings, volume 1, S\u00e3o Jos\u00e9\ndos Campos, October 2007. Universidade de S\u00e3o Paulo (USP), Instituto Nacional de Pesquisas\nEspaciais (INPE).\n\n[22] A. Meijster and J. B. T. M. Roerdink. A disjoint set algorithm for the watershed transform. In\nProc. IX European Signal Processing Conf EUSIPCO \u201998, pages 1665\u20131668, 1998.\n\n[23] Han Sun, Jingyu Yang, and Mingwu Ren. A fast watershed algorithm based on chain code and\nits application in image segmentation. Pattern Recognition Letters, 26(9):1266\u20131274, 2005.\n\n\n\nREFER\u00caNCIAS BIBLIOGR\u00c1FICAS 143\n\n[24] Y. Lin, Y. Tsai, Y. Hung, and Z. Shih. Comparison between immersion-based and toboggan-\nbased watershed image segmentation. IEEE Transactions on Image Processing, 15(3):632\u2013640,\n2006.\n\n[25] V. Osma-Ruiz, J. I. Godino-Llorente, N. S\u00e1enz-Lech\u00f3n, and P. G\u00f3mez-Vilda. An improved\nwatershed algorithm based on efficient computation of shortest paths. Pattern Recognition,\n40(3):1078\u20131090, 2007.\n\n[26] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algorithms. The MIT\nPress, Cambridge , Massachusetts, 2 edition, 2001.\n\n[27] Robert Endre Tarjan. Data structures and network algorithms. Society for Industrial and Ap-\nplied Mathematics, Philadelphia, PA, USA, 1983.\n\n[28] Barry Wilkinson and Michael Allen. Parallel Programming: Techniques and Applications Using\nNetworked Workstations and Parallel Computers. Prentice Hall, 1 edition, 1999.\n\n[29] A. Bieniek and A. Moga. An efficient watershed algorithm based on connected components.\nPattern Recognition, 33(6):907\u2013916, 2000.\n\n[30] A. Bieniek, H. Burkhardt, H. Marschner, M. N\u00f6lle, and G. Schreiber. A parallel watershed\nalgorithm. In Proceedings of 10th Scandinavian Conference on Image Analysis (SCIA97), pages\n237\u2013244, 1997.\n\n[31] Romaric Audigier and Roberto Lotufo. Uniquely-determined thinning of the tie-zone watershed\nbased on label frequency. J. Math. Imaging Vis., 27(2):157\u2013173, 2007.\n\n[32] Gilles Bertrand. On topological watersheds. J. Math. Imaging Vis., 22(2-3):217\u2013230, 2005.\n\n[33] Jean Cousty, Gilles Bertrand, Laurent Najman, and Michel Couprie. Watershed cuts: Thinnings,\nshortest-path forests and topological watersheds. IEEE Transactions on Pattern Analysis and\nMachine Intelligence, 2009, to appear.\n\n[34] W.S. Rasband. Imagej. Technical report, U. S. National Institutes of Health, Bethesda, Mary-\nland, USA, 1997\u20132009. http://rsb.info.nih.gov/ij/.\n\n[35] F. Meyer. Color image segmentation. In Image Processing and its Applications, 1992, pages\n303\u2013306. IEEE Computer Society, 1992.\n\n[36] Open computer vision library, 2009. http://sourceforge.net/projects/\nopencvlibrary/.\n\n[37] Roland Levillain, Thierry G\u00e9raud, and Laurent Najman. Milena: Write generic morphologi-\ncal algorithms once, run on many kinds of images. In Proceedings of the 9th International\nSymposium on Mathematical Morphology (ISMM), Groningen, The Netherlands, Aug. 2009.\nhttp://www.lrde.epita.fr/cgi-bin/twiki/view/Olena/.\n\n[38] Epita Research and Development Laboratory. Olena project, 2009. http://olena.lrde.\nepita.fr.\n\n\n\n144 REFER\u00caNCIAS BIBLIOGR\u00c1FICAS\n\n[39] E.W. Dijkstra. A note on two problems in connexion with graphs. Numerische Mathematik,\n1(1):269\u2013271, December 1959.\n\n[40] Edward F. Moore. The shortest path through a maze. In Proceedings of the International\nSymposium on the Theory of Switching, pages 285\u2013292. Harvard University Press, 1959.\n\n[41] J. A. Bondy and U. S. R. Murty. Graph Theory With Applications. 1976.\n\n[42] Robert B. Dial. Algorithm 360: shortest-path forest with topological ordering [h]. Communica-\ntions of the ACM, 12(11):632\u2013633, 1969.\n\n[43] C. Berge. The Theory of graphs and its applications. John Wiley &amp; Sons, Inc., New York, 1\nedition, 1962.\n\n[44] Alina Moga, Timo Viero, Bogdan Dobrin, and Moncef Gabbouj. Implementation of a distri-\nbuted watershed algorithm. In J. Serra and P. Soille, editors, Mathematical morphology and\nits applications to image processing, volume 2, pages 281\u2013288. Kluwer Academic Publishers,\n1994.\n\n[45] F. Meyer. Minimum spanning forests for morphological segmentation. In J. Serra and P. Soille,\neditors, Mathematical morphology and its applications to image processing, volume 2, pages\n77\u201387. Kluwer Academic Publishers, 1994.\n\n[46] A. Meijster and J. B. T. M. Roerdink. A Proposal for the Implementation of a Parallel Watershed\nAlgorithm - CAIP\u201995, volume 970 of Lecture Notes in Computer Science, pages 790\u2013795. Sprin-\nger Berlin / Heidelberg, 1995.\n\n[47] Dang Ba Khac Trieu and Tsutomu Maruyama. Real-time image segmentation based on a parallel\nand pipelined watershed algorithm. Journal of Real-Time Image Processing, 2(4):319\u2013329,\nDecember 2007.\n\n[48] Bruno Galil\u00e9e, Franck Mamalet, Marc Renaudin, and Pierre-Yves Coulon. Parallel asynchro-\nnous watershed algorithm-architecture. IEEE Transactions on Parallel and Distributed Systems,\n18(1):44\u201356, 2007.\n\n[49] Andr\u00e9 K\u00f6rbes, Giovani Bernardes Vitor, Janito Vaqueiro Ferreira, and Roberto de Alencar Lo-\ntufo. A proposal for a parallel watershed transform algorithm for real-time segmentation. In\nProceedings of Workshop de Vis\u00e3o Computacional WVC\u20192009, S\u00e3o Paulo, Brazil, Sep. 2009.\nAvailable on http://iris.sel.eesc.usp.br/wvc2009/WVC2009_CD.rar.\n\n[50] Giovani Bernardes Vitor, Janito Vaqueiro Ferreira, and Andr\u00e9 K\u00f6rbes. Fast image segmentation\nby watershed transform on graphical hardware. In Proceedings of the 30\u00baCILAMCE, Arma\u00e7\u00e3o\ndos B\u00fazios, Brazil, Nov. 2009.\n\n\n\nAp\u00eandice A\n\nFramework de Processamento de Imagens\n\nEm algoritmos de processamento de imagens, a busca por efici\u00eancia geralmente leva a programas\ndesenvolvidos utilizando o n\u00edvel de abstra\u00e7\u00e3o mais baixo poss\u00edvel, de modo a se obter instru\u00e7\u00f5es mais\neficientes e programas mais otimizados. No entanto, uma consequ\u00eancia direta desta abordagem \u00e9 a\nobten\u00e7\u00e3o de c\u00f3digos-fonte de dif\u00edcil compreens\u00e3o e manuten\u00e7\u00e3o. Entretanto neste trabalho buscou-se\nprezar pela legibilidade de c\u00f3digo e ao mesmo tempo se obter implementa\u00e7\u00f5es funcionais pr\u00f3ximas\ndas especifica\u00e7\u00f5es dos algoritmos em pseudoc\u00f3digo. Assim, optou-se por desenvolver um framework\nde base, contemplando os problemas mais comuns e abstraindo-os do c\u00f3digo que efetivamente produz\nos resultados dos algoritmos estudados.\n\nConsiderou-se para efeito de projeto deste framework que algumas funcionalidades deveriam ser\nencapsuladas, entre elas o tratamento de dimensionalidade para processamento de imagens de qual-\nquer formato e tamanho; o tratamento da borda, considerando a necessidade de uso de vizinhan\u00e7as,\nonde pixels externos \u00e0 imagem original n\u00e3o devem ser visitados, sendo comportamento padr\u00e3o na\nmorfologia matem\u00e1tica; e o tratamento de vizinhan\u00e7a, encapsulando o c\u00e1lculo de deslocamentos no\ndom\u00ednio da imagem. Algumas restri\u00e7\u00f5es adotadas para este desenvolvimento devem ser comentadas:\n(1) exige-se que uma rela\u00e7\u00e3o de vizinhan\u00e7a seja sim\u00e9trica, de forma que o c\u00e1lculo da borda da ima-\ngem tamb\u00e9m o seja; (2) as rela\u00e7\u00f5es de vizinhan\u00e7a s\u00e3o dadas como uma lista de deslocamentos em\ncada dimens\u00e3o da imagem; (3) as bordas t\u00eam valor constante determinado pelo infinito positivo da\nlinguagem Python. Assim, tem-se o primeiro bloco de c\u00f3digo criando as constantes de vizinhan\u00e7as 4\ne 8, e definindo a constante de borda e uma fun\u00e7\u00e3o que verifica o valor de um pixel e identifica se este\n\u00e9 uma borda ou n\u00e3o. Esta fun\u00e7\u00e3o \u00e9 necess\u00e1ria apenas por quest\u00f5es de compatibilidade e legibilidade.\n\n# c o n s t a n t s\n# n e i g h b o u r h o o d\nN4 = a r r a y ( [ [ ?1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , ?1 ] ] )\nN8 = a r r a y ( [ [ ?1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , ?1 ] , [ ?1 , ?1 ] , [ ?1 , 1 ] , [ 1 , 1 ] , [ 1 , ?1 ] ] )\n\n# v a l u e s\ni n f = 1 e 4 0 0\nBORDER = i n f\n\nd e f i s B o r d e r ( v ) :\n\n145\n\n\n\n146 Framework de Processamento de Imagens\n\n\" \" \" T e s t s i f t h e v a l u e i s a b o r d e r v a l u e \" \" \"\nr e t u r n v == BORDER\n\nUma restri\u00e7\u00e3o importante diz respeito \u00e0 forma de varredura da imagem, de modo a converter\nesta em um vetor unidimensional. Este processo deve ser padronizado, ordenado, variando-se da\n\u00faltima dimens\u00e3o para a primeira, ou seja, em uma imagem 2D, isso implica que para cada linha ser\u00e3o\nvarridas suas colunas. A Fig. A.1 exemplifica este processo, realizando a varredura de uma imagem\ncom 3 linhas e duas colunas, e transformando-a em um vetor de 6 posi\u00e7\u00f5es. Padronizando a forma de\nvarredura, pode-se ent\u00e3o prever as posi\u00e7\u00f5es em que os pixels estar\u00e3o a partir do tamanho da imagem\noriginal.\n\n(a) (b)\n\nFig. A.1: Exemplo de transforma\u00e7\u00e3o de (a) imagem em (b) vetor unidimensional\n\nUtilizando esta transforma\u00e7\u00e3o de uma imagem com dimens\u00f5es arbitr\u00e1rias para apenas uma di-\nmens\u00e3o, pode-se abstrair o problema da dimensionalidade. No entanto, o tratamento da imagem\nem rela\u00e7\u00e3o \u00e0s bordas deve ser cuidadoso, de forma a criar estas \u00e1reas e impedir que o processamento\nescape do dom\u00ednio da imagem. Em resumo, tais cuidados s\u00e3o tomados por uma opera\u00e7\u00e3o de redimen-\nsionamento da imagem (padding) onde cria-se a borda com o valor constante definido anteriormente,\npela opera\u00e7\u00e3o de transforma\u00e7\u00e3o em vetor unidimensional, e pela opera\u00e7\u00e3o de recorte da imagem\n(crop) onde a partir do vetor de trabalho, restaura-se a imagem para suas dimens\u00f5es originais, elimi-\nnando a borda. Al\u00e9m de funcionar como principal ponto de entrada do framework, a classe wsImage\napresentada abaixo tem nestas opera\u00e7\u00f5es suas funcionalidades fundamentais.\n\n# common c l a s s e s f o r t h e a l g o r i t h m s\nc l a s s wsImage ( ) :\n\n\" \" \" C l a s s f o r s t o r i n g t h e i m a g e s and c o n t r o l l i n g e n t r y an d e x i t p o i n t s\n\" \" \"\n\nd e f \\ _ \\ _ i n i t \\ _ \\ _ ( s e l f , a r r a y ) :\n\" \" \" C o n s t r u c t o r f o r s t o r i n g t h e N?D i n p u t i m a g e \" \" \"\ns e l f . i n p u t = a r r a y\ns e l f . work = None\ns e l f . l a b e l = None\ns e l f . o u t p u t = None\n\n\n\n147\n\nd e f b e g i n ( s e l f , o f f s e t s ) :\n\" \" \" P r e p a r e t h e i m a g e f o r p r o c e s s i n g \" \" \"\nfrom numpy i m p o r t z e r o s , r a v e l\n\ni f l e n ( s e l f . i n p u t . s h a p e ) ! = o f f s e t s . s h a p e [ 1 ] :\nr a i s e E x c e p t i o n ( \" I m a g e s h a p e d o e s n o t f i t o f f s e t s d i m e n s i o n s \" )\n\n# i n i t i a l i s e t h e n e i g h b o u r\ns e l f . n e i g h b o u r = w s N e i g h b o u r ( o f f s e t s )\n# pad t h e i n p u t i m a g e\ns e l f . work = s e l f . \\ _ p a d ( )\n# s t o r e t h e p a d d e d s h a p e\ns e l f . w o r k s h a p e = s e l f . work . s h a p e\n# r a v e l t h e p a d d e d i m a g e ( make 1?D)\ns e l f . work = r a v e l ( s e l f . work )\n# make a z e r o e d c o p y o f i t\ns e l f . l a b e l = z e r o s ( s e l f . work . s h a p e )\n# i n i t i a l i s e t h e o u t p u t\ns e l f . o u t p u t = None\n# i n i t i a l i s e t h e s h a p e o f t h e i m a g e\ns e l f . n e i g h b o u r . s e t I m a g e S h a p e ( s e l f . w o r k s h a p e )\ns e l f . n e i g h b o u r . s e t I m a g e ( s e l f . work )\n# i n i t i a l i s e t h e d o m a i n o b j e c t\nD = wsDomain ( s e l f . work . s i z e )\nD . s e t I m a g e ( s e l f . work )\n\n# r e t u r n s t h e n e i g h b o u r h o o d r e l a t i o n , t h e w o r k i n g i m a g e , t h e l a b e l\ni m a g e and t h e d o m a i n o f t h e i m a g e\n\nr e t u r n s e l f . n e i g h b o u r . N , s e l f . work , s e l f . l a b e l , D\n\nd e f \\ _ p a d ( s e l f ) :\n\" \" \" P a d s t h e N?D i m a g e w i t h t h e BORDER c o n s t a n t a s n e c e s s a r y f o r\n\nc o n t a i n i n g a l l t h e o f f s e t s f r o m t h e l i s t \" \" \"\nfrom numpy i m p o r t z e r o s\n# g e n e r a t e t h e n e w s h a p e b y i t e r a t i n g t h r o u g h t h e o r i g i n a l and a d d i n g\n\nt h e e x t r a s p a c e n e e d e d a t e a c h d i m e n s i o n\nn e w s h a p e = t u p l e ( map ( lambda o r i g , d : o r i g + ( d?1) , s e l f . i n p u t . s h a p e ,\n\ns e l f . n e i g h b o u r . s h a p e ) )\n# g e n e r a t e t h e s l i c i n g l i s t\ns l i c i n g = map ( lambda o r i g , d : s l i c e ( ( d?1) / 2 , ( d?1) / 2 + o r i g ) ,\n\ns e l f . i n p u t . s h a p e , s e l f . n e i g h b o u r . s h a p e )\n# c r e a t e t h e p a d d e d i m a g e\nw o r k i m a g e = z e r o s ( n e w s h a p e )\nw o r k i m a g e [ : ] = BORDER\nw o r k i m a g e [ s l i c i n g ] = s e l f . i n p u t\nr e t u r n w o r k i m a g e\n\nd e f \\ _ c r o p ( s e l f ) :\n\" \" \" R e s h a p e and c r o p t h e l a b e l i m a g e \" \" \"\nr e t u r n s e l f . c r o p ( s e l f . l a b e l )\n\n\n\n148 Framework de Processamento de Imagens\n\nd e f c r o p ( s e l f , x ) :\n\" \" \" R e s h a p e and c r o p s a N?D i m a g e t o t h e o r i g i n a l s i z e ( same a s\n\ns e l f . i n p u t ) \" \" \"\nfrom numpy i m p o r t r e s h a p e\n# g e n e r a t e t h e s l i c i n g l i s t\ns l i c i n g = map ( lambda o r i g , d : s l i c e ( ( d?1) / 2 , ( d?1) / 2 + o r i g ) ,\n\ns e l f . i n p u t . s h a p e , s e l f . n e i g h b o u r . s h a p e )\n# r e s h a p e t h e l a b e l i m a g e t o t h e o r i g i n a l s h a p e\nt e m p = r e s h a p e ( x , s e l f . w o r k s h a p e )\n# c r o p t h e t e m p i m a g e\nr e t u r n t e m p [ s l i c i n g ]\n\nd e f e n d ( s e l f ) :\nr e t u r n s e l f . \\ _ c r o p ( ) . a s t y p e ( \u2019 i n t 3 2 \u2019 )\n\nd e f makeWorkCopy ( s e l f , d e f a u l t = 0 ) :\n\" \" \" Make a c o p y o f t h e w o r k i m a g e f i l l e d w i t h t h e v a l u e and t y p e o f\n\np a r a m e t e r d e f a u l t \" \" \"\nc o p i e d = s e l f . work . c o p y ( )\nc o p i e d = c o p i e d . a s t y p e ( t y p e ( d e f a u l t ) )\nc o p i e d . f i l l ( d e f a u l t )\nr e t u r n c o p i e d\n\nAtrav\u00e9s da classe wsImage apresentada, a qual encapsula o problema da dimensionalidade prio-\nritariamente, tem-se acesso ao controle de dom\u00ednio da imagem, encapsulado pela classe wsDomain.\nUm problema recorrente em algoritmos de processamento de imagens, especialmente em morfologia\nonde trata-se de conjuntos limitados, \u00e9 o tratamento de borda. No caso dos algoritmos morfol\u00f3gicos,\na vizinhan\u00e7a fora da imagem \u00e9 recortada, ou seja, o dom\u00ednio de processamento \u00e9 limitado apenas ao\ndom\u00ednio da imagem, n\u00e3o sendo utilizadas estrat\u00e9gias como valores constantes ou repeti\u00e7\u00e3o c\u00edclica,\ntal como no processamento da transformada de Fourier. Desta forma, deseja-se abstrair este c\u00e1lculo,\nde forma que na programa\u00e7\u00e3o de um algoritmo n\u00e3o seja necess\u00e1rio verificar se os endere\u00e7os sendo\nvisitados extrapolam o dom\u00ednio da imagem. A programa\u00e7\u00e3o desta classe foi realizada atrav\u00e9s de ob-\njetos iter\u00e1veis, onde a cada nova itera\u00e7\u00e3o verifica-se qual o pr\u00f3ximo endere\u00e7o v\u00e1lido a ser visitado,\nconsiderando-se um espa\u00e7o pr\u00e9-definido de endere\u00e7os poss\u00edveis. Um endere\u00e7o \u00e9 dito v\u00e1lido se na\nimagem tomada para c\u00e1lculo de dom\u00ednio este n\u00e3o representar uma borda produzida pela opera\u00e7\u00e3o de\npadding. A Fig. A.2 apresenta a imagem com padding de bordas para uma vizinhan\u00e7a 4 ou 8, e sua\nvetoriza\u00e7\u00e3o, onde os pixels em branco indicam a borda e ser\u00e3o descartados na visita\u00e7\u00e3o do dom\u00ednio.\n\n\u00c9 importante ressaltar na Fig. A.2 os pixels de borda intermedi\u00e1rios, os quais s\u00e3o transparen-\ntemente descartados pela classe wsDomain, n\u00e3o permitindo que o programa os processe e incorra\nem erros. Esse tratamento interno aumenta significativamente a legibilidade e usabilidade deste fra-\nmework, permitindo que varreduras pela imagem sejam realizadas apenas iterando-se sobre um con-\njunto de endere\u00e7os.\n\n\n\n149\n\n(a) (b)\n\nFig. A.2: Exemplo de tratamento das bordas na transforma\u00e7\u00e3o de (a) imagem com borda em (b) vetor\ncom borda, onde estes pixels s\u00e3o intercalados\n\nc l a s s wsDomain :\nd e f \\ _ \\ _ i n i t \\ _ \\ _ ( s e l f , l e n g t h ) :\n\ns e l f . i n n e r = x r a n g e ( l e n g t h )\ns e l f . c o u n t = 0\n\nd e f n e x t ( s e l f ) :\ni f s e l f . c o u n t >= l e n ( s e l f . i n n e r ) :\n\ns e l f . c o u n t = 0\nr a i s e S t o p I t e r a t i o n\n\nw h i l e i s B o r d e r ( s e l f . im [ s e l f . i n n e r [ s e l f . c o u n t ] ] ) :\ns e l f . c o u n t += 1\ni f s e l f . c o u n t >= l e n ( s e l f . i n n e r ) :\n\ns e l f . c o u n t = 0\nr a i s e S t o p I t e r a t i o n\n\nc = s e l f . c o u n t\ns e l f . c o u n t = c + 1\nr e t u r n s e l f . i n n e r [ c ]\n\nd e f \\ _ \\ _ g e t i t e m \\ _ \\ _ ( s e l f , i t e m ) :\nr e t u r n s e l f . i n n e r [ i t e m ]\n\nd e f \\ _ \\ _ i t e r \\ _ \\ _ ( s e l f ) :\nr e t u r n s e l f\n\nd e f \\ _ \\ _ l e n \\ _ \\ _ ( s e l f ) :\nr e t u r n l e n ( s e l f . i n n e r )\n\nd e f s e t I m a g e ( s e l f , im ) :\ns e l f . im = im\n\nA classe wsDomain fornece funcionalidade essencial aos algoritmos, permitindo acesso transpa-\n\n\n\n150 Framework de Processamento de Imagens\n\nrente aos pixels que comp\u00f5e exclusivamente o dom\u00ednio da imagem, sem tratamentos especiais para\nbordas. De mesma import\u00e2ncia \u00e9 o acesso \u00e0 vizinhan\u00e7a, comumente denotado em pseudoc\u00f3digo como\nN(p). Com o desenvolvimento da classe wsNeighbour e em especial o m\u00e9todo N busca-se obter um\nc\u00f3digo-fonte que remeta diretamente \u00e0 nota\u00e7\u00e3o de pseudoc\u00f3digo. Em particular, esta classe deve lidar\ncom 2 restri\u00e7\u00f5es: (1) realizar o c\u00e1lculo dos deslocamentos fornecidos em qualquer dimens\u00e3o para o\nvetor unidimensional; e (2) impedir que a vizinhan\u00e7a avance sobre a borda da imagem. A primeira\nrestri\u00e7\u00e3o \u00e9 resolvida pela programa\u00e7\u00e3o da Eq. A.1, dada de acordo com a padroniza\u00e7\u00e3o da varre-\ndura explicada anteriormente e exemplificada na Fig. A.1. Dado um deslocamento N-dimensional\n?dN , dN?1, ... , d2, d1?, a transforma\u00e7\u00e3o para um deslocamento unidimensional r em uma imagem\ncom tamanhos ?sN , sN?1, ... , s2, s1? \u00e9 dada por:\n\nr =\nN??\n\ni =1\n\n(di\ni?1??\nj =1\n\nsj ) (A.1)\n\nPara uma dada vizinhan\u00e7a, e.g. vizinhan\u00e7a-4, s\u00e3o dadas 4 listas de deslocamento, e calcula-se 4\nvalores de r , correspondendo aos deslocamentos que devem ser calculados sobre um ponto qualquer\nno dom\u00ednio da imagem. Este c\u00e1lculo s\u00f3 \u00e9 realizado uma vez, pois n\u00e3o depende do pixel, sendo ent\u00e3o\napenas somado a coordenada deste para localiza\u00e7\u00e3o dos vizinhos. Para uma imagem de tamanho (3,\n10, 15) por exemplo, e um deslocamento (-1, 1, 2), a Eq. A.1 se expande da seguinte forma:\n\nr = (2) + (1 \u00b7 15) + (?1 \u00b7 10 \u00b7 15) = ?133 (A.2)\n\nAo calcular a posi\u00e7\u00e3o do vizinho (-1, 1, 2) do pixel de endere\u00e7o unidimensional 260 ser\u00e1 apenas\nsomado o deslocamento ?133 a este, resultando na posi\u00e7\u00e3o 127. Este endere\u00e7o ser\u00e1 ent\u00e3o verificado\nse corresponde a uma borda da imagem, e, caso contr\u00e1rio, ser\u00e1 inclu\u00eddo na lista de vizinhos poss\u00edveis\ndo pixel 260. A classe wsNeighbour encapsula este comportamento, permitindo ao m\u00e9todo N operar\nde forma r\u00e1pida e transparente em rela\u00e7\u00e3o a dimensionalidade e bordas.\n\nc l a s s w s N e i g h b o u r ( ) :\n\" \" \" C l a s s f o r n e i g h b o u r h o o d p r o c e s s i n g \" \" \"\n\nd e f \\ _ \\ _ i n i t \\ _ \\ _ ( s e l f , o f f s e t s ) :\n\" \" \" C o n s t r u c t o r f o r t h e l i s t o f o f f s e t s i n N?D ( n e i g h b o u r s )\n\no f f s e t s m u s t b e a m x N m a t r i x , w h e r e m i s t h e n u m b e r o f\no f f s e t s ( n e i g h b o u r s ) and N i s t h e d i m e n s i o n s o f t h e i m a g e \" \" \"\n\ns e l f . o f f s e t s = a r r a y ( o f f s e t s )\ns e l f . \\ _ s h a p e ( )\ns e l f . s = None\n\nd e f \\ _ s h a p e ( s e l f ) :\n\" \" \" C a l c u l a t e s t h e s h a p e o f t h e o f f s e t s \" \" \"\nN = s e l f . o f f s e t s . s h a p e [ 1 ]\ns e l f . s h a p e = [ ]\n\n\n\n151\n\nf o r i i n r a n g e (N) :\ndmax = max ( s e l f . o f f s e t s [ : , i ] )\ndmin = min ( s e l f . o f f s e t s [ : , i ] )\ni f a b s ( dmax ) ! = a b s ( dmin ) :\n\nr a i s e E x c e p t i o n ( \" O f f s e t s m u s t b e s y m m e t r i c a l \" )\nd = dmax ? dmin + 1\n# make t h e d i m e n s i o n a l w a y s odd\ni f d % 2 == 0 :\n\nd += 1\ns e l f . s h a p e . a p p e n d ( d )\n\ns e l f . s h a p e = t u p l e ( s e l f . s h a p e )\n\nd e f s e t I m a g e S h a p e ( s e l f , i m s h a p e ) :\n\" \" \" S e t t h e i m a g e s h a p e and c a l c u l a t e s t h e o f f s e t s i n 1?D \" \" \"\ns e l f . s = i m s h a p e\ni f l e n ( s e l f . s ) ! = s e l f . o f f s e t s . s h a p e [ 1 ] :\n\nr a i s e E x c e p t i o n ( \" I m a g e s h a p e d o e s n o t f i t o f f s e t s d i m e n s i o n s \" )\n\n# c a l c u l a t e t h e o f f s e t s i n 1?D\n# t h e p r o c e s s o c c u r s l i k e t h i s :\n# e a c h o f f s e t i s m u l t i p l i e d b y t h e m u l t i p l i c a t i o n o f t h e v a l u e s o f\n\nt h e n e x t c o m p o n e n t s o f t h e s h a p e o f t h e i m a g e and summed :\n# e x a m p l e :\n# s h a p e : ( 3 , 1 0 , 1 5 )\n# o f f s e t : [ 1 , 1 , 2 ]\n# o f f s e t i n 1?D: ( 1 * 10 * 1 5 ) + ( 1 * 1 5 ) + ( 2 )\n#\n# o f c o u r s e , t h e o f f s e t s m u s t f o l l o w t h e o r d e r o f t h e s h a p e ( Nth?D ,\n\n. . . , 3 r d?D , 2 nd?D , 1 s t?D) , t h a t i s u s u a l l y\n# ( t i m e , c h a n n e l , row , c o l u m n ) o r i n g r a y s c a l e i m a g e s ( t i m e , row ,\n\nc o l u m n ) o r s i m p l e 2?D i m a g e s ( row , c o l u m n )\n\n# LONG VERSION\n# s e l f . r o f f s e t s = [ ]\n# f o r o f f s e t i n s e l f . o f f s e t s :\n\n# r o f f s e t = 0\n# f o r i i n r a n g e ( l e n ( o f f s e t ) ) :\n\n# n = o f f s e t [ i ]\n# r o f f s e t += n * r e d u c e ( l a m b d a x , y : x * y , s e l f . s [ ( i +1) : ] , 1 )\n\n# s e l f . r o f f s e t s . a p p e n d ( r o f f s e t )\n\n# SHORT VERSION ( u s i n g map and r e d u c e )\ns e l f . r o f f s e t s = map (\n\nlambda o f f s e t : sum (\nmap ( lambda n , i :\n\nn * r e d u c e ( lambda x , y : x * y , s e l f . s [ ( i + 1 ) : ] , 1 ) ,\no f f s e t , r a n g e ( l e n ( o f f s e t ) )\n)\n\n) ,\ns e l f . o f f s e t s )\n\n\n\n152 Framework de Processamento de Imagens\n\nd e f s e t I m a g e ( s e l f , im ) :\n\" \" \" S e t t h e w o r k i n g i m a g e t o q u e r y f o r b o r d e r v a l u e s on\n\nn e i g h b o u r h o o d c a l c u l a t i o n \" \" \"\ns e l f . im = im\n\nd e f N( s e l f , p i x e l ) :\n\" \" \" R e t u r n s t h e l i s t o f i n d e x e s o f n e i g h b o u r s o f p i x e l i n 1?D \" \" \"\ni f n o t s e l f . s :\n\nr a i s e E x c e p t i o n ( \" S e t t h e i m a g e s h a p e f i r s t ! \" )\n\n# c a l c u l a t e t h e c o o r d i n a t e s o f t h e n e i g h b o u r s b a s e d on t h e o f f s e t s\ni n 1?D\n\nn = map ( lambda c : c + p i x e l , s e l f . r o f f s e t s )\nr = l i s t ( )\n\nf o r i i n n :\ni f i s B o r d e r ( s e l f . im [ i ] ) :\n\nc o n t i n u e\n\nr . a p p e n d ( i )\n\nr e t u r n r\n\nd e f q u e r y ( s e l f , c ) :\n\" \" \" L o o k u p on t h e r o f f s e t s f o r t h e i n d e x o f t h e o f f s e t c \" \" \"\nf o r i i n r a n g e ( l e n ( s e l f . r o f f s e t s ) ) :\n\ni f s e l f . r o f f s e t s [ i ] == c :\nr e t u r n i\n\nr e t u r n ?1\n\nd e f a d d O f f s e t ( s e l f , p , i n d e x ) :\n\" \" \" A d d s t h e o f f s e t o f t h e d e s i r e d i n d e x t o t h e v a l u e p \" \" \"\ni f i n d e x &lt;0 o r i n d e x >= l e n ( s e l f . r o f f s e t s ) :\n\nr e t u r n None\ne l s e :\n\nc = s e l f . r o f f s e t s [ i n d e x ]\nr e t u r n p + c\n\nAl\u00e9m das tr\u00eas classes apresentadas aqui, foram desenvolvidas interfaces para estruturas de dados\ncomuns em algoritmos, como filas, pilhas e filas de prioridade. Estas interfaces foram constru\u00eddas de\nmodo a manter transparente a implementa\u00e7\u00e3o interna, que, neste caso, foi realizada utilizando listas\ne dicion\u00e1rios embarcados na linguagem Python."}]}}}