{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.13003"}, {"@name": "filename", "#text": "18812_arquivo7289_1.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancia da Computa\u00e7\u00e3o \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\u201cDESENVOLVIMENTO RIGOROSO COM  \nUML-RT\u201d \n\n \nPor \n\n \n\nRodrigo Teixeira Ramos  \n \n\nDisserta\u00e7\u00e3o de Mestrado \n \n\n \n \n \n\n \n \n\nUniversidade Federal de Pernambuco \nposgraduacao@cin.ufpe.br \n\nwww.cin.ufpe.br/~posgraduacao \n \n \n\nRECIFE, ABRIL/2005 \n\n\n\nUniversidade Federal de Pernambuco\nCentro de Informa?tica\n\nRodrigo Teixeira Ramos\n\nDESENVOLVIMENTO RIGOROSO COM UML-RT\n\nTrabalho apresentado ao Programa de Po?s-graduac?a?o em\n\nCie?ncia da Computac?a?o do Centro de Informa?tica da Uni-\n\nversidade Federal de Pernambuco como requisito parcial\n\npara obtenc?a?o do grau de Mestre em Cie?ncia da Com-\n\nputac?a?o.\n\nOrientador: Augusto Cesar Alves Sampaio\n\nCo-orientador: Alexandre Cabral Mota\n\nRecife\nAbril/2005\n\n\n\n\n\nAos meus pais pelo exemplo de cara?ter, fortaleza e bon-\n\ndade.\n\n\n\nAGRADECIMENTOS\n\n... eu poderia suportar, embora na?o sem dor, que tivessem morrido todos\n\nos meus amores, mas enlouqueceria se morressem todos os meus amigos!\n\nAte? mesmo aqueles que na?o percebem o quanto sa?o meus amigos e o\n\nquanto minha vida depende de suas existe?ncias ... A alguns deles na?o\n\nprocuro, basta-me saber que eles existem. Esta mera condic?a?o me\n\nencoraja a seguir em frente pela vida ... mas e? delicioso que eu saiba e\n\nsinta que os adoro, embora na?o declare e na?o os procure ...\n\n\u2014VIN?ICIUS DE MORAES (Para voce?, com carinho)\n\nTerminada mais esta etapa da grande jornada da vida, sinto-me grato a? diversas pes-\nsoas que contribu??ram direta ou indiretamente para o meu aprendizado e fortalecimento\ndurante estes dois anos de mestrado. A estas, manifesto, agora, meus profundos e sinceros\nagradecimentos.\n\nSou grato a Deus por estar sempre presente em minha vida e por ter me honrado com\no afeto e o companheirismo de tantos amigos. Dentre eles, ressalto: os meus grandes\namigos Leonardo Cole e Danielly Cruz, que tanto me ajudaram em todas as horas com\nsua amizade fraterna e sincera; Ma?rcio Dahia, que com seu bom grande humor me ajudou\na enfrentar alguns tediosos dias no Cin; e Fernando Trinta e Thiago Santos, que sempre\ntomei como exemplos de disciplina e obstinac?a?o na busca de meus ideais. Agradec?o\ntambe?m aos amigos Ma?rcio Corne?lio, Rafael Borges, Rohit Gheyi, Thiago Massoni pelas\nenriquecedoras discusso?es.\n\nExpresso meus agradecimentos aos professores Augusto Sampaio e Alexandre Mota\npela inu?meras ajudas e sugesto?es durante o meu mestrado. Mais do que orientadores, eles\nforam bons e pre?stimos amigos durante todo este per??odo. Principalmente, sou grato a?\nAugusto pela preocupac?a?o com a minha formac?a?o e pelos duradouros ensinamentos, que\nlevarei pelo restante da minha vida.\n\nPor fim, e sobretudo, gostaria de manifestar minha especial gratida?o aos meus pais,\na quem devo na?o apenas esta conquista mas tudo o que sou, meus irma?os, e a? Sabrina,\nminha namorada e amiga, pelo amor e pela confianc?a inabala?veis.\n\niv\n\n\n\nRESUMO\n\nComo outros me?todos visuais orientados a objetos, UML tem influenciado tremendamente\na pra?tica de modelagem na engenharia de software com ricos mecanismos de estruturac?a?o.\nPore?m, apesar de suas vantagens e adoc?a?o em larga escala, na pra?tica, a falta de uma\nsema?ntica formal tem dificultado o desenvolvimento rigoroso baseado em modelos de\naplicac?o?es na?o triviais (aplicac?o?es que por sua natureza necessitam de e?nfase na especi-\nficac?a?o e na verificac?a?o de seus componentes). A raza?o para isto e? que transformac?o?es\nde modelos podem na?o preservar a sema?ntica e, como consequ?e?ncia, o comportamento\ndo modelo. Este problema e? ainda mais se?rio em transformac?o?es que envolvem diferentes\nviso?es do modelo.\n\nLimitac?o?es similares podem ser encontradas durante o desenvolvimento com UML-\nRT. Esta linguagem e? uma extensa?o conservativa de UML que prove? a noc?a?o de objetos\nativos (objetos com um comportamento pro?prio, independente do fluxo de execuc?a?o do\nrestante do sistema) para descrever aplicac?o?es concorrentes e distribu??das. Neste tipo de\ndesenvolvimento, transformac?o?es devem lidar simultaneamente com as diferentes viso?es\nesta?ticas e dina?micas do modelo, representadas por seus diagramas e propriedades.\n\nPor estes motivos, este trabalho propo?e uma sema?ntica para UML-RT, mapeando\nsuas construc?o?es em OhCircus, uma linguagem formal, orientada a objetos, que combina\nCSP e Z, e que suporta o ca?lculo de refinamentos de Morgan. A partir desta sema?ntica,\nbem como das noc?o?es e leis de refinamentos de OhCircus, e? poss??vel propor leis de trans-\nformac?a?o de modelos pass??veis de demonstrac?a?o e que preservam o comportamento do\nsistema.\n\nEstas leis de transformac?a?o sa?o propostas em duas categorias: a primeira delas e? um\nconjunto abrangente de leis ba?sicas que expressam pequenas mudanc?as nas principais\nviso?es do modelo, como a declarac?a?o ou remoc?a?o de elementos do modelo; ja? a segunda\nrepresenta leis de transformac?a?o de maior granularidade, derivadas a partir da composic?a?o\nde leis ba?sicas, como a decomposic?a?o de uma ca?psulas em ca?psulas operando em para-\nlelo. Tais transformac?o?es derivadas podem ser vistas como refatoramentos (refactorings)\ncorretos sobre o modelo, facilmente aplica?veis durante um processo de desenvolvimento\nrigoroso, sem que o desenvolvedor tenha conhecimento do formalismo que o suporta.\n\nFinalmente, a abrange?ncia deste conjunto de leis e? discutida particularmente atrave?s\ndos principais passos de uma estrate?gia de reduc?a?o de modelos UML-RT a um modelo\nUML estendido com um u?nico objeto ativo, responsa?vel por todas as interac?o?es com o\nambiente e por conservar o comportamento dina?mico do sistema modelado. Este modelo\nUML estendido pode ser visto como uma forma normal, e, portanto, nossa estrate?gia\npode ser vista como uma contribuic?a?o para uma estrate?gia mais global de completude\ncapturada por reduc?a?o a esta forma normal.\n\nv\n\n\n\nresumo vi\n\nPalavras-chave: UML-RT, transformac?a?o de modelos, OhCircus, integrac?a?o de me?todos\nformais\n\n\n\nABSTRACT\n\nAs other object-oriented visual methods, UML has tremendously influenced the software\nengineering modeling practice with rich structuring mechanisms. Despite its strengths,\nthe rigorous development of non-trivial applications (those applications that, due their\ncomplexity, need to emphasise the specification and verification of their components)\ndo not seem feasible without a formal semantics. The reason is that well-known model\ntransformations might not preserve behaviour. This problem is even more serious in\na model driven development, where transformations are as important as models, and\ninvolve different model views.\n\nSimilar limitations can be found during the development with UML-RT. This language\nis a conservative UML profile that includes active objects (objects with an execution flow\nindependent of the rest of the system) to describe concurrent and distributed applications.\nIn this kind of development, transformations have to simultaneously handle both static\nand dynamic model views, represented by the diagrams and properties of the model.\n\nFor these reasons, this work proposes a semantics for UML-RT via mapping into\nOhCircus, a formal object oriented language that combines CSP, Z and specification\nstatements, and also support Morgan\u2019s refinement calculus. From this semantics and\nthe laws of OhCircus, we are able to propose and prove model transformation laws that\npreserve the system behaviour.\n\nTwo groups of laws are proposed: the first one embodies a comprehensive set of laws\nthat govern small changes in the main model views, like introducing or removing a modelo\nelement; the second group presents more elaborated laws derived from the composition\nof these basic laws, like decomposing a capsule into parallel component capsules. The\nderived laws can be taken as precise model refactorings that are easily applied in a\nrigourous development, without the developer directly dealing with the formalism that\nsupports them.\n\nFinally, the comprehensiveness of the set of laws is particularly discussed through the\nmain steps of a reduction strategy of UML-RT models into a UML model extended with\na single capsule responsible for all the interactions with the environment; This capsule\nis also responsible for maintaining the active behaviour of the modeled system. This\nextended UML model can be regarded as a normal form, and, therefore, our strategy\ncan be regarded as a contribution to a completeness strategy captured by normal form\nreduction.\n\nKeywords: UML-RT, model transformations, OhCircus, formal method integration\n\nvii\n\n\n\nSUMA?RIO\n\nCap??tulo 1\u2014Introduc?a?o 1\n\nCap??tulo 2\u2014Linguagens de Modelagem 7\n\n2.1 UML 1.x . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.2 ADLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\n2.2.1 ROOM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.2.2 Wright . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.2.3 ACME . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.2.4 SDL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.2.5 ADLs e UML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n\n2.3 UML-RT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.4 UML 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.5 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\nCap??tulo 3\u2014Formalizac?a?o de UML-RT 19\n\n3.1 OhCircus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n3.1.1 Sintaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n3.1.2 Sema?ntica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n3.1.2.1 Expresso?es de Processos . . . . . . . . . . . . . . . . . . 25\n3.1.3 Noc?o?es de Refinamento e Equivale?ncia . . . . . . . . . . . . . . . 26\n3.1.4 Leis para refinamento de Processos . . . . . . . . . . . . . . . . . 27\n\n3.2 Mapeamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n3.2.1 Mapeamento estrutural . . . . . . . . . . . . . . . . . . . . . . . . 30\n3.2.2 Mapeamento comportamental . . . . . . . . . . . . . . . . . . . . 34\n\n3.3 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\nCap??tulo 4\u2014Leis de Transformac?a?o para UML-RT 39\n\n4.1 Leis Ba?sicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n4.2 Leis Derivadas e Refatoramentos . . . . . . . . . . . . . . . . . . . . . . 53\n4.3 Formalizac?a?o das Leis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n\n4.3.1 Prova da Lei 4.20 . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n4.3.2 Prova da Lei 4.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\n4.4 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n\nviii\n\n\n\nsuma?rio ix\n\nCap??tulo 5\u2014Normalizac?a?o e Aplicac?a?o das Leis 63\n\n5.1 Estrate?gia de Normalizac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . 63\n5.2 Estudo de Caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n5.3 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n\nCap??tulo 6\u2014Concluso?es 74\n\n6.1 Trabalhos relacionados . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n6.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\n\nApe?ndice A\u2014Sintaxe Completa de Ohcircus 81\n\nApe?ndice B\u2014Leis de CSP 83\n\nApe?ndice C\u2014Leis de Transformac?a?o para UML-RT Adicionais 85\n\n\n\nLISTA DE FIGURAS\n\n2.1 Caso de Uso do Sistema de Automac?a?o Industrial . . . . . . . . . . . . . 14\n2.2 Modelo do Sistema de Automac?a?o Industrial . . . . . . . . . . . . . . . . 15\n\n3.1 Especificac?a?o da ca?psula Storage . . . . . . . . . . . . . . . . . . . . . . . 20\n3.2 Especificac?a?o da classe Piece . . . . . . . . . . . . . . . . . . . . . . . . . 24\n3.3 Exemplo de uma pra?tica correta (a esquerda) e uma errada (a direita) da\n\nconexa?o de subca?psulas . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n\n5.1 Os dois sentidos de aplicac?a?o das leis . . . . . . . . . . . . . . . . . . . . 64\n5.2 Passo ii da normalizac?a?o do Estudo de Caso . . . . . . . . . . . . . . . . 65\n5.3 Passo iii da normalizac?a?o do Estudo de Caso . . . . . . . . . . . . . . . . 66\n5.4 Primeiro modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de\n\nCaso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n5.5 Segundo modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de\n\nCaso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n5.6 Modelo final da composic?a?o de ca?psulas no passo iv da normalizac?a?o do\n\nEstudo de Caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n5.7 Arquitetura candidata do Estudo de Caso . . . . . . . . . . . . . . . . . 71\n5.8 Identificac?a?o de ProcessorA e ProcessorB no Estudo de Caso . . . . . . . . 72\n5.9 Identificac?a?o de Holon no Estudo de Caso . . . . . . . . . . . . . . . . . . 73\n\nx\n\n\n\nCAPI?TULO 1\n\nINTRODUC?A?O\n\nA noc?a?o de Engenharia de Software como a conhecemos, originou-se durante a de?cada de\n60, quando a comunidade da cie?ncia da computac?a?o comec?ou a despertar interesse [13]\nna necessidade pela produc?a?o de software baseado em fundamentos teo?ricos e disciplinas\npra?ticas, como as encontradas em ramos tradicionais e estabilizados da engenharia [62].\nPreocupados com a rece?m instalada crise do software [11, 39], desejava-se um aumento\nda qualidade de software, atrave?s de processos mais produtivos durante o seu desenvol-\nvimento.\n\nHoje, esta produc?a?o de software tem caminhado para uma abordagem de desenvolvi-\nmento dirigido a modelos (MDE - Model Driven Engineering) [87, 51], onde os artefatos\nprincipais durante o desenvolvimento sa?o modelos, ao inve?s do co?digo em uma linguagem\nde programac?a?o. Diferentemente da abordagem tradicional de que modelos sa?o utiliza-\ndos somente para fins de documentac?a?o de aspectos interessantes durante a construc?a?o\nde programas, implantadas indiretamente por diversos processos da engenharia de soft-\nware, o objetivo principal no desenvolvimento dirigido a modelos e? que o processo de\ndesenvolvimento e? dirigido pelas atividades de modelagem de software.\n\nDurante o ciclo de vida deste processo, e? poss??vel aplicar diversos tipos de trans-\nformac?a?o para se especializar ou reestruturar o modelo. Neste contexto, transformac?o?es\nsa?o artefatos ta?o importantes quanto os pro?prios modelos, e te?m finalidades semelhantes\na transformac?o?es tradicionais de co?digo, como refactorings [33, 77] e refinamentos [67].\nDe fato, estes tipos de transformac?a?o tambe?m sa?o aplicados para resolver problemas rela-\ncionados a? evoluc?a?o e manutenc?a?o [57] existentes em sistemas baseados em modelos [51].\nEnquanto refactorings reestruturam o sistema para adicionar aspectos de qualidade (por\nexemplo, atrave?s da aplicac?a?o de padro?es de projeto), preservando o seu comportamento,\nrefinamentos sa?o utilizados para concretizar o modelo (por exemplo, especializando-o para\numa plataforma espec??fica).\n\nEm esforc?os recentes, a OMG (Object Management Group) [71] tem atestado o va-\nlor de abordagens baseadas em modelos para o desenvolvimento de software, atrave?s da\npadronizac?a?o de notac?o?es e interoperabilidade de ferramentas. Uma evide?ncia e? a espe-\ncificac?a?o de MDA (Model-Driven Architecture) [65] e UML [81]. Enquanto UML tem\nse tornado uma notac?a?o padra?o para a modelagem de sistemas, MDA te?m contribu??do,\nentre outros benef??cios, com padro?es de interoperabilidade e portabilidade ao suporte\nmetodolo?gico do desenvolvimento dirigido a modelos, atrave?s de uma arquitetura de mo-\ndelos. MDA define uma arquitetura que separa a especificac?a?o das funcionalidades do\nsistema da especificac?a?o de como elas sa?o implementadas. A especificac?a?o inicial e? estru-\nturada como um modelo de plataforma independente (PIM), que pode ser refinado em\num ou mais modelos espec??ficos de plataforma (PSM).\n\nApesar de na?o possuir uma definic?a?o precisa, a noc?a?o geral de arquitetura na en-\n\n1\n\n\n\nintroduc?a?o 2\n\ngenharia de software e? um pouco diferente da encontrada em MDA. Um consenso em\nengenharia de software parece ser que uma arquitetura descreve um sistema em partes\ncom um alto n??vel de abstrac?a?o e atrave?s do relacionamentos entre estas partes. Em\nMDA, a arquitetura do sistema e? vista como um conjunto de modelos durante o desen-\nvolvimento do sistema, que descrevem n??veis de abstrac?a?o distintos da modelagem, e o\nrelacionamento destes modelos e? realizado atrave?s de transformac?o?es. Atribuiremos neste\ntrabalho o conceito de arquitetura a um u?nico n??vel de abstrac?a?o do software, que pode\nser vista em termos da decomposic?a?o do sistema em componentes, suas propriedades, e\nsuas relac?o?es [6, 20], enquanto transformac?o?es sa?o utilizadas para relacionar o modelo dos\ndiferentes n??veis abstrac?o?es desta arquitetura; desta maneira, modelos e transformac?o?es\npodem ainda assim representar os papeis sugeridos em MDA.\n\nNeste sentido, arquiteturas podem ser representadas por modelos, e evoluir durante\num processo de desenvolvimento baseado em modelos, atrave?s da transformac?o?es. Pore?m,\na criac?a?o e utilizac?a?o de artefatos de software (modelos e transformac?o?es) na?o devem ser\nbaseadas no empirismo [45] para a produc?a?o de software de qualidade. Modelos sem\numa sema?ntica formal podem ser amb??guos e, consequ?entemente, na?o expressarem cor-\nretamente suas propriedades. Por outro lado, transformac?o?es sem bases so?lidas podem\nna?o garantir a preservac?a?o destas propriedades [26]. Isto se torna mais se?rio no desen-\nvolvimento de aplicac?o?es na?o triviais (por exemplo, concorrentes ou distribu??das), onde\na verificac?a?o e especificac?a?o destas propriedades se torna ainda mais dif??cil.\n\nNormalmente, modelos sa?o expressos atrave?s de notac?o?es semi-formais como UML\ne suas extenso?es, u?teis para especificar aspectos de um dom??nio especifico, ainda que\nindependentes de plataforma. Em particular, enfatizamos o uso de UML-RT [90] (UML\npara tempo real), uma extensa?o conservativa de UML que prove? a noc?a?o de objetos\nativos [56] (objetos com um comportamento pro?prio, independente do fluxo de execuc?a?o\ndo restante do sistema) para descrever aplicac?o?es concorrentes e distribu??das.\n\nNa literatura, diversos esforc?os [30, 12, 69] atacam este problema atrave?s da integrac?a?o\nde notac?o?es informais (ou semi-formais), utilizadas para descrever estes modelos, com\nlinguagens formais, esperando que conceitos tradicionais da teoria da programac?a?o con-\nduzam a um desenvolvimento de sistemas consistente, sem que, durante a sua evoluc?a?o,\npropriedades, anteriormente definidas e verificadas, na?o sejam preservadas.\n\nEstes trabalhos atribuem uma sema?ntica, definida pela linguagem formal, a? notac?a?o\ninformal. Assim, modelos podem ser mapeados para a linguagem formal sempre que se\ndeseje verificar sua consiste?ncia. Um inco?modo, pore?m, e? que, a cada nova transformac?a?o\ndo modelo, este mapeamento deve ser realizado e propriedades devem ser provadas para\nse assegurar a consiste?ncia do modelo.\n\nUma pra?tica que pode assistir na soluc?a?o deste problema e? a criac?a?o de leis de trans-\nformac?a?o de modelos, seguindo as mesmas diretrizes das leis da programac?a?o [46]. As leis\nda programac?a?o sa?o leis que governam as propriedades ba?sicas da programac?a?o, e que\npor este motivo sua aplicac?a?o pode ser utilizada para garantir a preservac?a?o de trans-\nformac?o?es de programa; como as leis que governam a aritme?tica descrevem as operac?o?es\nsobre nu?meros, leis de programac?a?o descrevem as propriedades dos construtores de pro-\ngramas. Uma lei da aritme?tica, por exemplo, e?: 0 + x = x , que denota que o nu?mero 0\ne? o elemento neutro (ou a identidade) para a operac?a?o de soma. Atrave?s da composic?a?o\n\n\n\nintroduc?a?o 3\n\nde leis ba?sicas, e? poss??vel demonstrar propriedades mais complexas. Por exemplo, na\naritme?tica, a lei 2a?a = a, pode ser reescrita, passo-a-passo, atrave?s de leis ba?sicas para\nse provar sua corretude; em particular, ela pode ser derivada das ba?sicas leis da a?lgebra\natrave?s dos seguintes passos: (a + a) ? a = a; a + (a ? a) = a; a + 0 = a; e a = a . Na\nrealidade, leis da programac?a?o podem tambe?m definir uma sema?ntica axioma?tica [98],\ndefinindo propriedades sobre os construtores da linguagem atrave?s de axiomas e regras\nde infere?ncia, da lo?gica simbo?lica, sendo tambe?m u?teis para provar propriedades de pro-\ngramas [67].\n\nDiversos paradigmas podem ser beneficiados atrave?s das leis de programac?a?o. Por\nexemplo leis para programas que utilizam linguagens orientadas a objeto [9], imperati-\nvas [46] e concorrente [80] podem ser u?teis para estabelecer uma base formal para pra?ticas\ninformais de desenvolvimento de software ja? existentes, como refactorings. Desta maneira,\ndesenvolvedores podem realizar suas tarefas sem explicitamente lidarem com formalismos,\nmas baseados neles. Transformac?o?es complexas de co?digo podem ser explicadas atrave?s\nda composic?a?o de leis ba?sicas de programac?a?o, utilizando uma interface ja? conhecida pelo\nprogramador e livre de formalismos.\n\nApesar desta ser uma a?rea ainda incipiente, leis de modelagem podem trazer benef??cios\nsimilares aos das leis da programac?a?o como, por exemplo, derivando-se refactorings para\nmodelos a partir de leis mais ba?sicas [37]. Este e? um dos objetivos fundamentais deste\ntrabalho: propor um desenvolvimento rigoroso baseado em modelos UML-RT. Este de-\nsenvolvimento e? rigoroso por garantir a consiste?ncia e preservac?a?o de propriedades do\nsistema durante a fase de modelagem. Para garantir esta preservac?a?o de propriedades,\ncontribu??mos neste trabalho para o desenvolvimento rigoroso em UML da seguinte ma-\nneira:\n\n\u2022 Atribuic?a?o de uma sema?ntica formal a UML-RT, atrave?s do seu mapeamento sinta?tico\npara a linguagem formal OhCircus [16];\n\n\u2022 Proposic?a?o de um conjunto abrangente de leis ba?sicas de transformac?a?o para UML-\nRT para auxiliar a criac?a?o de tarefas de modelagem consistentes, que preservam o\ncomportamento do modelo;\n\n\u2022 Derivac?a?o de leis de projeto para UML-RT a partir das leis ba?sicas, com a finalidade\nde aumentar sua aplicabilidade;\n\n\u2022 Demonstrac?a?o da abrange?ncia das leis propostas atrave?s dos principais passos de\numa estrate?gia de normalizac?a?o;\n\n\u2022 Aplicac?a?o destas leis durante o projeto de um estudo de caso para demonstrar sua\nintegrac?a?o com um processo de desenvolvimento pra?tico;\n\nPropomos uma sema?ntica para os elementos de UML-RT atrave?s de seu mapeamento\npara a linguagem formal OhCircus [16], uma linguagem orientada a objetos que combina\nCSP [79], Z [95] e o ca?lculo de refinamentos de Morgan [67]; este mapeamento e? baseado\nem resultados previamente obtidos [74]. Tanto em [74] como neste trabalho, focamos\nno mapeamento dos novos elementos (classes ativas e outros construtores relacionados)\n\n\n\nintroduc?a?o 4\n\nque UML-RT adiciona a UML. Consideramos conjuntamente as viso?es comportamentais\ne estruturais de um modelo UML-RT.\n\nUma raza?o para a escolha de OhCircus e? que sua sema?ntica e? definida com base\nna Unified Theory of Programming (UTP) [47], cujo modelo relacional tem se mostrado\nconveniente para formalizar diversos paradigmas da programac?a?o. Outra vantagem e?\nque OhCircus inclui os principais conceitos encontrados em UML-RT. Ao inve?s de, por\nexemplo, CSP-OZ [31], OhCircus desacopla a ocorre?ncia de eventos de operac?o?es sobre o\nestado, e e? projetada para suportar um ca?lculo de refinamento [67]. Leis de OhCircus te?m\ninspirado a aplicac?a?o de diversas leis para UML-RT [83], e a prova de leis de transformac?a?o\npara UML-RT atrave?s de nosso mapeamento sema?ntico [74]. Diferentemente de outros\ntrabalhos relacionados a? formalizac?a?o de UML [12, 69] e UML-RT [32, 25], este trabalho\nconsidera conjuntamente as viso?es estrutural e comportamental do modelo.\n\nUtilizando como base a sema?ntica atribu??da aos elementos de UML-RT, atrave?s de\nseu mapeamento para OhCircus, propomos leis de transformac?a?o que preservam o com-\nportamento do sistema. Focamos na proposic?a?o de leis ba?sicas, porque estas sa?o mais\nfacilmente provadas e permitem um desenvolvimento sistema?tico, onde leis ba?sicas podem\nser utilizadas para justificar leis mais complexas.\n\nAs leis propostas capturam pequenos passos consistentes que preservam tanto aspectos\nesta?ticos quanto dina?micos do modelo (levando em conta conjuntamente propriedades\nestruturais e comportamentais). Atrave?s da combinac?a?o de leis ba?sicas introduzimos\nnovas leis mais elaboradas. Tais leis sa?o capazes de capturar e formalizar algumas das\npra?ticas utilizadas em atividades de projeto, como no Processo Unificado da Rational\n(RUP) [52], sendo esta uma outra contribuic?a?o importante deste trabalho. Atrave?s de\num estudo de caso, mostramos como um modelo concreto de projeto pode ser gerado a\npartir de um modelo inicial e abstrato de ana?lise.\n\nComo exemplo de lei ba?sica de transformac?a?o podemos citar a inserc?a?o, remoc?a?o ou\nalterac?a?o de um elemento do modelo. Usualmente, estas leis alteram apenas uma das\nviso?es do modelo, pore?m impondo condic?o?es para a sua aplicac?a?o com base com seu\nrelacionamento com as viso?es. Por lidarmos com leis que preservam o comportamento do\nmodelo, criamos leis de equivale?ncia entre modelos, que podem ser aplicadas em qualquer\ndirec?a?o (da esquerda para a direita, ou da direita para a esquerda); na realidade cada lei\npode ser vista como a definic?a?o conjunta de duas regras de transformac?a?o de modelo.\n\nAs leis propostas aqui esta?o baseadas nas ide?ias inicialmente reportadas em [83], que\napresenta algumas poucas leis de transformac?a?o de grande granularidade para UML-RT,\nrefletindo a importa?ncia de transformac?o?es na pra?tica de desenvolvimento.\n\nComo na?o definimos leis para os elementos de UML, nosso trabalho pode ser conside-\nrado suplementar a outros trabalhos que focam especificamente nestes elementos [41, 30,\n38], ou a trabalhos que descrevem sucintamente leis para UML-RT [26, 85], sem expres-\nsar os padro?es e as condic?o?es necessa?rios para sua aplicac?a?o. Transformac?o?es consistentes\nentre classes no diagrama sa?o livremente permitidas, desde que estas na?o interfiram com\na interface esperada por ca?psulas que invoquem me?todos destas classes. Isto acontece\nporque a comunicac?a?o entre objetos ativos em UML-RT e classes e? atrave?s da chamada\nde me?todos e porque ca?psulas na?o compartilham classes entre si. Assim do ponto de vista\ndestas classes, ca?psulas sa?o simplesmente elementos externos que invocam seus servic?os.\n\n\n\nintroduc?a?o 5\n\nAle?m da avaliac?a?o das leis sob o ponto de vista de sua corretude e aplicabilidade, a\nabrange?ncia do conjunto de leis proposto e? discutida particularmente atrave?s dos princi-\npais passos de uma estrate?gia de reduc?a?o de modelos em UML-RT a um modelo UML es-\ntendido com um u?nico objeto ativo (Cap??tulo 5), responsa?vel por todas as interac?o?es com\no ambiente e por conservar o comportamento dina?mico do sistema modelado. Este mo-\ndelo UML estendido pode ser visto como uma forma normal, e, portanto, nossa estrate?gia\npode ser vista como uma contribuic?a?o para uma estrate?gia de completude capturada por\numa reduc?a?o a esta forma normal, semelhante a? estrate?gia apresentada em [9] para uma\nlinguagem de programac?a?o orientada a objetos. Nosso foco e? em um conjunto de leis para\ndiagramas de classe e estrutura de modelos; uma estrate?gia completa de normalizac?a?o\nnecessita de um grande nu?mero de leis para capturar transformac?o?es nos diagramas de\nestados, que esta? fora do escopo deste trabalho.\n\nApesar de lidarmos, neste trabalho, com um subconjunto da linguagem UML-RT e\ndesta linguagem na?o ter sido criada por organizac?o?es de padronizac?a?o (como a OMG),\nsendo mantida pelas empresas que suportam suas ferramentas [19], va?rios conceitos desta\nlinguagem esta?o diretamente presentes em outras linguagens para a descric?a?o de arquite-\nturas ou de componentes. Assim, todas as contribuic?o?es que possam ser incorporadas ao\ndesenvolvimento usando UML-RT podem, a principio, ser adaptadas para o desenvolvi-\nmento nessas linguagens.\n\nEsta dissertac?a?o esta dividida em cinco cap??tulos, ale?m deste, e tre?s ape?ndices. O\nconteu?do de cada um e? descrito a seguir:\n\n\u2022 Cap??tulo 2: Neste cap??tulo, introduzimos os conceitos presentes na linguagem\nUML-RT; ale?m disto contextualizamos esta linguagem em relac?a?o a algumas outras\nlinguagens de modelagem, indicando suas vantagens e desvantagens. Um exemplo\nsobre como esta linguagem sera? utilizada na modelagem de um sistema rigoroso\ntambe?m sera? apresentadao neste cap??tulo.\n\n\u2022 Cap??tulo 3: Neste cap??tulo, introduzimos a linguagem formal OhCircus e apre-\nsentamos os mapeamentos sema?nticos de um subconjunto expressivo das viso?es\nestruturais e comportamentais de UML para esta linguagem formal.\n\n\u2022 Cap??tulo 4: Neste cap??tulo, apresentamos, de uma maneira incremental, um con-\njunto abrangente de leis ba?sicas de transformac?a?o para UML-RT e algumas leis\nderivadas a partir deste conjunto. Ale?m disto, provamos algumas destas leis utili-\nzando a sema?ntica proposta no Cap??tulo 3.\n\n\u2022 Cap??tulo 5: Neste cap??tulo, aplicamos leis de transformac?a?o de modelos em UML-\nRT a um estudo de caso: um sistema de automac?a?o industrial. As aplicac?o?es das leis\nsa?o utilizadas em uma estrate?gia de normalizac?a?o de um ponto intermedia?rio do de-\nsenvolvimento deste estudo de caso, e no desenvolvimento deste ponto intermedia?rio\nate? um modelo de concreto, pro?ximo a? implementac?a?o. Durante este desenvolvi-\nmento, as leis sa?o contextualizadas segundo as atividades de projeto, utilizando no\nRUP.\n\n\n\nintroduc?a?o 6\n\n\u2022 Cap??tulo 6: Neste cap??tulo, discutimos alguns trabalhos relacionados e futuros, e\napresentamos nossas considerac?o?es finais\n\n\u2022 Ape?ndice A: Neste ape?ndice, mostramos a grama?tica completa da linguagem\nOhCircus.\n\n\u2022 Ape?ndice B: Neste ape?ndice, mostramos algumas leis de CSP utilizadas para a\nprova das leis de UML-RT.\n\n\u2022 Ape?ndice C: Neste ape?ndice, mostramos algumas leis restantes de transformac?a?o\npara UML-RT na?o apresentadas no Cap??tulo 4.\n\n\n\nCAPI?TULO 2\n\nLINGUAGENS DE MODELAGEM\n\nNeste cap??tulo, introduziremos alguns conceitos gerais de UML [81], e indicaremos os\nmotivos pelos quais ela e? inapropriada para o desenvolvimentos de componentes reativos\npara sistemas software, cuja arquiteturas incluem aspectos concorrentes e distribu??dos.\nApesar da proposta para uma versa?o mais nova de UML (UML 2.0) possuir va?rias das\ncaracter??sticas deseja?veis para a modelagem destas arquiteturas, escolhemos a linguagem\nUML-RT neste trabalho, por a considerarmos uma linguagem mais consolidada e que\nconta (no momento) com um suporte mais amplo de ferramentas comerciais.\n\nO projeto de arquitetura de tais sistemas distribu??dos e reativos tem como elemento\ncentral a interac?a?o de seus componentes durante a execuc?a?o de algumas tarefas [54].\nComo veremos a seguir, a versa?o atual da UML na?o possui va?rias caracter??sticas deseja?veis\npara a especificac?a?o de componente de software [48], tampouco define explicitamente a\ninterac?a?o entre as interfaces destes componente.\n\nPara se obter um contexto amplo de onde UML-RT esta inserida, explicaremos neste\ncap??tulo varias linguagens de modelagens relacionadas, como descrito a seguir, a UML-\nRT. Apesar de discutimos elas superficialmente, conseguimos trac?ar que influe?ncias elas\ndespertam umas nas outras. Na Sec?a?o 2.1 exibiremos alguns problemas relacionados\na? versa?o de UML 1.5. Na Sec?a?o 2.2 mostraremos algumas linguagens idealizadas para\na descric?a?o de arquiteturas utilizando componentes. Na Sec?a?o 2.3, introduziremos a\nsintaxe da linguagem UML-RT, e como ela foi inspirada em UML e em tais linguagens\npara descric?a?o de arquiteturas. Por fim, na Sec?a?o 2.4, discutiremos sobre a nova versa?o\nde UML, reformulada com base em va?rias caracter??sticas encontradas em UML-RT.\n\n2.1 UML 1.X\n\nDesde a padronizac?a?o da Linguagem de Modelagem Unificada (UML) pelo OMG\n(Object Management Group) em 1997, ela tem se tornado para a comunidade um padra?o\nde facto para a especificac?a?o e modelagem de software.\n\nUML prove? uma diversividade de te?cnicas para descrever aspectos estruturais e com-\nportamentais de um sistema modelado. Diagramas de classe, objeto, componente e im-\nplantac?a?o focam principalmente na estrutura do sistema, enquanto diagramas de estados\nenfatizam no comportamento, tipicamente de componentes individuais. Diagramas de\natividades, sequ?e?ncia, colaborac?a?o e casos de uso tambe?m focam no comportamento,\npore?m adicionalmente referenciam elementos estruturais.\n\nDiagramas de sequ?e?ncia e colaborac?a?o sa?o utilizados para descrever interac?o?es en-\ntre componentes, expressando a ordem de ocorre?ncia de mensagens trocadas entre eles.\nDevido a? sua expressividade limitada (por exemplo, eles na?o conseguem expressar alter-\nnativas ou repetic?o?es), eles sa?o utilizados normalmente apenas para mostrar cena?rios de\nutilizac?a?o do sistema.\n\n7\n\n\n\n2.1 uml 1.x 8\n\nDevido a popularidade de UML, me?todos e pra?ticas de modelagem tem se desenvol-\nvido enormemente. Diversas necessidades te?m requerido mudanc?as e extenso?es da atual\nversa?o de UML, versa?o 1.5. Tais extenso?es te?m gerado novos profiles, ou culminado na\nreestruturac?a?o da linguagem, UML versa?o 2.0. Podemos destacar alguns problemas na\natual versa?o de UML que tem gerado tais mudanc?as.\n\n\u2022 Falta de uma sema?ntica formal\n\n\u2022 Tamanho excessivo e multiplicidade de modelos.\n\n\u2022 Suporte inadequado para o desenvolvimento baseado com componentes.\n\nSema?ntica Formal: UML e? conhecida como uma linguagem semi-formal, cuja ne-\ncessidade de noc?o?es mais formais e? reconhecida em diversos trabalhos [30, 4, 58]. A\nsema?ntica de seus elementos sinta?ticos e? imprecisa, o que gera problemas de comunicac?a?o\nentre os membros do projeto de software. Ale?m disto, sem uma sema?ntica formal pre-\ncisa na?o e? poss??vel automatizar ana?lises rigorosas de um modelo, tampouco executa?-lo\ndiretamente para testar seu comportamento; a u?nica maneira de se testar um sistema\nmodelado e? o codificando.\n\nAtrave?s da atribuic?a?o de uma noc?a?o formal a seus elementos, pode-se prover suporte\na? verificac?a?o de propriedades do modelo, atribuir noc?o?es de equivale?ncia entre modelos,\ne, consequ?entemente, realizar transformac?o?es seguras de seus elementos; reestruturando\no modelo sem alterar suas propriedades.\n\nTamanho Excessivo a Multiplicidade de Modelos: A versa?o atual de UML tem\nsido vista por muitos como muito grande e complexa [22, 44, 7]. Seu tamanho excessivo\ntransforma seu aprendizado, aplicac?a?o e implementac?a?o dif??cil. Ale?m disto, a multiplici-\ndade de seus modelos resulta numa quantidade excessiva de diagramas e s??mbolos para\nexpressar os aspectos estruturais e comportamentais do modelo. Tais diagramas na?o con-\nseguem expressar isoladamente estes aspectos, resultando em problemas de produtividade\ne consiste?ncia durante sua elaborac?a?o [22].\n\nSuporte ao desenvolvimento baseado em componentes: Apesar de suas inu?me-\nras vantagens, UML tem diversas desvantagens quando comparado com linguagens para\ndescric?a?o de componentes [91]. Isto se deve ao fato de que diagramas de componentes em\nUML na?o tem por finalidade representar a decomposic?a?o lo?gica de um sistema, durante\nseu projeto, em subsistemas composicionais e reusa?veis. Em UML, um componente e? uma\nunidade f??sica da implementac?a?o [81], sendo utilizado somente na fase de implantac?a?o.\nAle?m disto, UML na?o oferece o conceito de conexo?es como objetos de primeira ordem,\nvisto com um h??brido entre associac?a?o (associac?a?o entre classes) e uma depende?ncia entre\numa classe e a interface de outra classe. Tais interfaces na?o podem ser diretamente\nutilizadas para descrever, em um n??vel de detalhes suficiente, as mu?ltiplas interac?o?es\nentre componentes de software [20].\n\nVa?rias abordagens utilizam UML no Desenvolvimento Baseado em Componentes\n(CBD), pore?m esta linguagem na?o e? especializada para este tipo de desenvolvimento,\ne certas extenso?es ao seu padra?o sa?o necessa?rias [20, 48]. Devidos aos problemas ja? des-\ncritos, abordagens naturais utilizando classes, interfaces, e subsistemas na?o contemplam\n\n\n\n2.2 adls 9\n\nadequadamente a especificac?a?o do comportamento de um componente [48]. Tais proble-\nmas estimularam a criac?a?o de extenso?es de UML, a sua unificac?a?o com Linguagens de\nDescric?a?o de arquitetura (ADLs) (Sec?a?o 2.2.5), ou mesmo a reformulac?a?o da linguagem\n(Sec?a?o 2.4)\n\n2.2 ADLS\n\nComponentes prove?m um n??vel de abstrac?a?o mais alto que objetos. Usualmente,\neles podem ser vistos como caixas pretas que fornecem ou requerem um conjunto de\nservic?os (representados por interface). Componentes que interagem podem assim ser\ncompostos para formar um componente com um maior n??vel de abstrac?a?o. A estrutura\ndestas composic?o?es sa?o o foco da arquitetura de software, que e? definida em [91], como:\n\u201cA arquitetura de um sistema de software define o sistema em termos de componentes\ncomputacionais e de suas interac?o?es\u201d.\n\nPara a especificac?a?o de arquitetura de software, um grande nu?mero de Linguagens de\nDescric?a?o de Arquitetura (ADLs) te?m sido propostas [64]. Esta especificac?a?o e? utilizada\npara descrever a interac?a?o entre componentes, atrave?s de seu comportamento individual,\ninterfaces de comunicac?a?o internas e externas, ale?m da influe?ncia mu?tua entre estas in-\nterfaces.\n\nEm [64], ADLs te?m como caracter??sticas essenciais a definic?a?o expl??cita de componen-\ntes, conexo?es e configurac?o?es de arquitetura e a possibilidade de modelagem de interfaces\nde componentes; definidos com uma sema?ntica clara. Aspectos adicionais, relacionados a\nestas noc?o?es podem ser deseja?veis, pore?m na?o essenciais. Seus benef??cios sera?o reconhe-\ncidos, e demonstrados, em contextos de problema espec??fico (por exemplo, aspectos na?o\nfuncionais de tempo ou desempenho), pore?m sua ause?ncia na?o significa que a linguagem\nna?o representa uma ADL.\n\nVa?rias linguagens possuem uma sema?ntica formal para descrever o comportamento\nde seus componentes e conexo?es, por exemplo, atrave?s de algebra de processos [3] ou\nma?quinas de estados finitas. Este tipo de sema?ntica reforc?a o uso da declarac?a?o de\npropriedades arquiteturais, e assegura o mapeamento de arquiteturas de um n??vel de\nabstrac?a?o para outro. Adicionalmente, e? deseja?vel que ADLs possibilitem refinamentos\nconsistentes e corretos de arquiteturas de sistemas abstratas em outras exequ???veis. Outros\naspectos deseja?veis sa?o a possibilidade de evoluc?a?o e de dinamismo da configurac?a?o de\narquiteturas de software. Enquanto o primeiro esta? relacionado a? adic?a?o e manutenc?a?o de\nfuncionalidade na arquitetura, o segundo aspecto se refere a? modificac?a?o da configurac?a?o\ndo sistema durante a sua execuc?a?o.\n\nVa?rios ADLs sa?o considerados em respeitos a diferentes aspectos do desenvolvimento\nbaseado em componentes e arquitetura de software. A seguir ilustramos alguns ADLs que\ntem uma suporte formal de sua descric?a?o ou influenciaram de alguma maneira mudanc?as\nna versa?o de UML 2.0.\n\n\n\n2.2 adls 10\n\n2.2.1 ROOM\n\nA Linguagem de Modelagem de Tempo Real Orientada a Objetos (ROOM) [89] utiliza\num variante do conceito de \u201dcomponente-porta-conector\u201dpara a arquitetura de compo-\nnentes, descrita em [91, 23]. Tais conceitos de componentes, portas e conectores, sa?o\nsemelhantes a outros ADLs, e sa?o descritos como:\n\n\u2022 Componentes: Um componente (ou atores): e? qualquer elemento que realiza al-\ngum tipo de computac?a?o. A declarac?a?o deste descreve sua interface externa, seu\ncomportamento, e uma estrutura interna, utilizada para a composic?a?o de novos\ncomponentes.\n\n\u2022 Portas: um conjunto de portas definem as interfaces externas de um ator. Portas\nsa?o os u?nicos locais por onde um ator oferece ou requisita servic?os; sendo portanto\nbidirecional.\n\n\u2022 Protocolos: Um protocolo define o conjunto de sinais permitidos na transmissa?o ou\nrecepc?a?o de mensagem entre componentes conectados. Qualquer porta associada a\num protocolo deve enviar os sinais de sa??da e receber os de entrada deste protocolo.\n\n\u2022 Portas Conjugadas: Portas podem ser conjugadas com relac?a?o ao seu protocolo\nassociado, recebe os sinais de sa??da de seu protocolo e envia seus sinais de entrada.\n\n\u2022 Conectores: Um conector estabelece uma conexa?o entre duas portas. Ele liga uma\nporta de um componente a uma porta conjugada de outro componente com um\nprotocolo associado compat??vel (na maioria das vezes, o mesmo).\n\nROOM descreve principalmente dois tipos de diagramas. Diagramas de atores em\nROOM descrevem a decomposic?a?o hiera?rquica de um sistema de software em seus com-\nponentes, como tambe?m as conexo?es entre estes componentes; estes diagramas sa?o uti-\nlizados para descrever a estrutura interna de componentes. ROOM Charts, por outro\nlado, sa?o utilizados para descrever o comportamento de componentes e protocolos, sendo\nderivados de StateCharts [43].\n\n2.2.2 Wright\n\nWright [3] e? um ADL com suporte a? descric?a?o de componentes, conexo?es e composic?a?o\nde componentes. Ela foca na especificac?a?o comportamental de componentes e conexo?es\natrave?s de uma notac?a?o formal baseada em CSP. As interfaces de eventos de cada compo-\nnente misturam os eventos transmitidos e recebidos pelo componente, na?o distinguindo\nservic?os fornecidos e requeridos.\n\nComponentes podem ser descritos individualmente atrave?s de uma especificac?a?o expl??cita,\nou atrave?s da composic?a?o de outros componentes utilizando operadores de CSP, de uma\nmaneira bottom-up; caracterizando descric?a?o comportamental caixa branca. Atrave?s\ndeste formalismo, e? poss??vel realizar verificac?o?es de consiste?ncia e integridade da especi-\nficac?a?o; verificando, por exemplo, se esta? livre de deadlocks.\n\n\n\n2.2 adls 11\n\n2.2.3 ACME\n\nO propo?sito de ACME [36] e? prover um formato para a troca de informac?a?o entre\nferramentas e ambientes de diferentes ADLs. Ele e? baseado em abstrac?o?es comuns exis-\ntentes em ADLs, suportando diretamente componentes, conexo?es e sistemas (arquitetu-\nras). Para suportar qualquer ADL, ACME inclui uma sintaxe aberta para caracter??stica\nbaseada em propriedades definidas pelo usua?rio, com uma sema?ntica fora do escopo de\nACME. Atrave?s de extenso?es da linguagem, ACME e? capaz de descrever comunicac?a?o de\ncomponentes atrave?s de eventos, podendo descrever sequ?e?ncias de eventos (traces), e uti-\nlizar a notac?a?o de XML para descrever arquiteturas, focando apenas aspectos estruturais\ndo sistema.\n\n2.2.4 SDL\n\nA Linguagem de Especificac?a?o e Descric?a?o (SDL) [40] e? um padra?o da ITU-T, e aceito\npela ISO. SDL e? uma linguagem formal e orientada a objetos, com suporte a descric?a?o de\ncomponentes ativos (processos) e passivos (dados), eventos de comunicac?a?o e composic?a?o\nde componentes, ale?m de outras caracter??sticas inerentes a ADLs. Por ter uma base\nformal utilizando ma?quinas de estados abstratas (ASM) [40], ela prove? uma especificac?a?o\nna?o amb??gua de sistemas.\n\nApesar de, em SDL, canais de comunicac?a?o serem definidos explicitamente, interco-\nnexo?es entre componentes sa?o especificados implicitamente no comportamento dos com-\nponentes (atrave?s do uso de canais comuns). Por esta raza?o, linguagens como esta sa?o\nchamadas em [64] como linguagems de configurac?a?o in-line e estariam mais pro?ximas\nde serem classificadas como linguagens de interconexa?o de mo?dulos (MIL) [73] do que\npropriamente como ADLs.\n\n2.2.5 ADLs e UML\n\nEm [35], e? argumentado que UML na?o e? adequado para modelar a estrutura de\nsistemas tipicamente utilizados em linguagens de descric?a?o de arquiteturas. O maior pro-\nblema e? que nem todos os elementos encontrados em ADLs possuem um mapeamento\ndireto para os conceitos de modelagem encontrados em UML. Apesar disto, diversos\ntrabalhos [18, 82, 76] mapeiam os conceitos arquiteturais de ADLs em UML, geralmente\nalterando o significados dos elementos de UML atrave?s de estereo?tipos; o \u201ccomo\u201d este ele-\nmentos sa?o modificados na?o e? especificado, utilizando geralmente a sema?ntica associadas\na estes em seus contra-elementos em ADL. Estes trabalhos contribuem para a melhoria de\num aspecto deseja?vel de compreensa?o da arquitetura, atrave?s do mapeamento de ADLs\nem linguagens mais populares e disseminadas na comunidade.\n\nEm [18], os conceitos de ACME sa?o mapeados em UML atrave?s de estereo?tipos.\nDevido a algumas especifidades da linguagem, nem todos os conceitos de ACME puderam\nser representados em UML. De forma similar, em [76], estes mecanismos de extensa?o\n(estereo?tipos) sa?o utilizados para mapear os ADLs: Wright, Darwin [61], and Rapide [59].\n\nEm [82, 18], o conceitos arquiteturais de ROOM sa?o mapeados em UML, atrave?s do\nuso de estereo?tipos. Em [82] o papel de cada porta e? definido explicitamente por uma\n\n\n\n2.3 uml-rt 12\n\nclasse, que implementa o comportamento associado ao seu protocolo em ROOM e rea-\nliza uma interface com os servic?os associados a este este protocolo; portas conjugadas\nrealizam interfaces de protocolos conjugados. Este modelo facilita o uso de portas como\nelementos de primeira classe, pore?m dificultam a heranc?a de comportamento dos proto-\ncolos e restrigem os servic?os dos protocolos a? simples chamadas de me?todos. Em [18] um\nmapeamento menos detalhado e? realizado, indicando somente quais os conceitos arqui-\nteturais de ROOM poderiam ser representados em UML, da mesma forma que em [82]\nsinais de protocolos sa?o restringidos a me?todos de classes em UML.\n\nEm [90], a integrac?a?o entre UML e ROOM e? realizada adicionando-se a UML elemen-\ntos com uma nova sema?nticas. Sendo o resultado desta integrac?a?o uma linguagem mais\naceita pela comunidade, popularmente chamada de UML-RT. Tal linguagem cria novos\nelementos (ca?psulas) para representar componententes de software em UML, reservando\ncomponentes passivos para serem representados como classes ordina?rias. Os diagrams\nde atores sa?o representados em extensa?o do diagrama de colaborac?a?o, enquanto ROOM\nCharts sa?o representados por diagramas de estados espec??ficos para ca?psulas e protoco-\nlos. Apesar de conter em sua definic?a?o elementos para representar os papeis realizados\npelas portas (ordina?rias ou conjugadas), ela sugere uma notac?a?o mais compacta para a\nrepresentac?a?o destes papeis atrave?s de associac?o?es e sufixos no nome destas portas, como\na que e? empregada em suas ferramentas [19] e assumida por no?s na Sec?a?o 2.3.\n\nComo vimos a integrac?a?o de ADLs e UML podem gerar novas extenso?es da UML\n(profile de UML-RT), ou mesmo contribuem para a? reformulac?a?o de novas verso?es de\nUML. Em [88], e? indicado que va?rias das caracter??sticas de modelagem arquitetural de\nUML 2.0 sa?o derivadas de tre?s linguagem de de descric?a?o arquitetural, UML-RT [90] [61],\nACME [36] e SDL [40].\n\n2.3 UML-RT\n\nA especificac?a?o e projeto de sistemas distribu??dos e? uma tarefa complexa que envolve\na especificac?a?o de dados, comportamento, comunicac?a?o e de aspectos arquiteturais do\nsistema. Com a finalidade de atender estes requisitos, UML e ROOM foram combinadas\nna linguagem UML for Real-Time (UML-RT) [90]. Apesar de seu nome, UML-RT na?o\npossui um suporte adequado para qualquer aplicac?a?o que envolva tempo real, na realidade\nela e? focada na modelagem de sistemas baseados em componentes e sistemas embarcados\nqualificados como soft-real time (onde o tempo apesar de fazer parte da modelagem, na?o\ne? um fator cr??tico). Sendo o enfoque deste trabalho a modelagem de componentes ativos,\nsem lidar aspectos de tempo.\n\nUML-RT e? considerada um extensa?o conservativa de UML, introduzindo apenas novos\nelementos e diagramas (baseados nos conceitos de ROOM) que se inter-relacionam com os\nelementos ja? existentes em UML. Quatro novos construtores sa?o introduzidos: ca?psulas,\nprotocolos, portas e conectores.\n\nCa?psulas descrevem componentes ativos, potencialmente concorrentes, do sistema,\nque possuem uma estrutura interna e uma comportamento associado. Diferentes de atores\nem ROOM, ca?psulas sa?o utilizadas primordialmente para descrever elementos ativos, com\num fluxo de dados independente do restante do sistema. Enquanto elementos passivos\n\n\n\n2.3 uml-rt 13\n\nsa?o descritos por classes em UML.\nAssim, uma ca?psula tem ale?m de seu comportamento passivo definidos em seus\n\nme?todos, o seu comportamento ativo definido por uma ma?quina de estados. Na rea-\nlidade o comportamento das ca?psulas sa?o reativas, e dependem de est??mulos externos\npara que alguma ac?a?o associada seja executada. Tais est??mulos sa?o originados pelo am-\nbiente, e so? podem ser transmitidos ou recebidos a uma ca?psula atrave?s de suas portas,\nobjetos definem um ponto de interac?a?o com a ca?psula. Portas realizam protocolos, que\ndefinem o conjunto de sinais de entrada e sa??da de uma ca?psulas, que representam os\nservic?os fornecidos e requeridos pela ca?psula. Um protocolo tambe?m define um fluxo\nva?lido destes sinais atrave?s das portas. Conectores agem como canais de comunicac?a?o\nf??sicos entre portas.\n\nUm modelo em UML-RT e? formado por um conjunto de diagrama e propriedades, tal\nqual em UML. Para que os elementos de ROOM fossem incorporados em UML-RT, alguns\ndiagramas foram estendidos: diagramas de classe, estado e estrutura (extensa?o de dia-\ngramas de colaborac?a?o). Este conjunto de diagramas consegue representar inteiramente\nas seguintes viso?es arquiteturais: dados, comportamento, configurac?a?o da arquitetura. A\nfim de simplificar a especificac?a?o do modelo, iremos focar nosso trabalho somente nesta\nviso?es; outros diagramas que indicam somente cena?rios de aplicac?a?o do sistema, como\ndiagramas de sequ?e?ncia na?o sera?o considerados. Expressaremos propriedades do sistema\ndiretamente na linguagem Circus 3; Eles poderiam ser alternativamente expressados em\nOCL, pore?m um mapeamento entre OCL e Circus e? fora de nosso escopo. Neste traba-\nlho, na?o consideraremos heranc?a, devido a sema?ntica de heranc?a de ca?psulas em UML-RT\nainda na?o ser bem-definida.\n\nOs diagramas de classes de UML definem adicionalmente a declarac?a?o de ca?psulas\ne protocolos. Ca?psulas podem ter associac?a?o para classes, ca?psulas, ou protocolos do\nmodelo. Uma associac?a?o com uma classe permite que a ca?psula possa utilizar me?todos e\natributos da classe; gerando como consequ?e?ncia um atributo do tipo da classe na ca?psula.\nEnquanto uma associac?a?o entre ca?psulas e? utilizada para permitir que parte do compor-\ntamento de uma ca?psula seja explicado a partir da composic?a?o de insta?ncias de outras\nca?psulas. Por fim, uma associac?a?o a um protocolo gera, como consequ?e?ncia, uma porta na\nca?psula. Estes relacionamentos sa?o vistos como agregac?o?es, onde o elemento de destino\nda associac?a?o e? parte da ca?psula, e e? criado apenas apo?s a criac?a?o da ca?psula; refere?ncias\nc??clicas entre ca?psulas na?o sa?o permitidas. Associac?o?es para ca?psulas, oriundas de classes\ne protocolos tambe?m na?o sa?o permitidas.\n\nApesar de serem associadas como tipos da linguagem, ca?psulas na?o sa?o elementos de\nprimeira classe e por definic?a?o na?o podem ser atribu??das a nenhuma varia?vel de ambiente.\nSendo suas insta?ncias localizadas unicamente nos diagramas de estrutura que as conte?m; a\nvisa?o hiera?rquica representada por este diagrama descreve a visa?o extensional das ca?psulas\ndo sistema. Por o foco deste trabalho ser a modelagem de ca?psulas, e por na?o haver sentido\no compartilhamento de insta?ncias de ca?psulas em diferentes estrutura, assumiremos uma\nsema?ntica de co?pia na passagem de para?metros de uma mensagem; classes na?o podem\nser compartilhadas entre ca?psulas. Como a principal aplicac?o?es deste trabalho e? no\ndesenvolvimento de sistemas distribu??dos, onde ca?psulas representam elementos pass??veis\nde distribuic?a?o, consideramos que o compartilhamento de recursos entre ca?psulas deve ser\n\n\n\n2.3 uml-rt 14\n\nfeitos explicitamente atrave?s da troca de mensagem entre elas utilizando uma sema?ntica\nde co?pia. Esta e? uma abordagem comum em tecnologias para sistemas distribu??dos, como\nRMI ou CORBA.\n\nPara ilustrarmos a notac?a?o de UML-RT atrave?s de um exemplo, um estudo de caso,\nutilizado tambe?m nos cap??tulos seguintes deste trabalho, de um sistema de automac?a?o\nindustrial e? utilizado. Este sistema e? utilizado para o processamento de pec?as industriais.\nTais pec?as sa?o inseridas no sistema por um operador e apo?s algum tempo sa?o recuperadas\ndo sistema por ele. Como pode ser visto na Figura 2.1, no diagrama de casos de uso do\nsistema. Neste cap??tulo uma versa?o inicial do sistema e? apresentada (Figura 2.2), este\npor sua vez sera? o ponto de partida da modelagem do sistema durante um processo de\ndesenvolvimento no Cap??tulo 5.2.\n\nFigura 2.1. Caso de Uso do Sistema de Automac?a?o Industrial\n\nNa Figura 2.2 e? apresentado (a esquerda) o diagrama de classes do sistema, neste\ndiagrama encontramos a declarac?a?o das ca?psulas Storage e ProdSys. A ca?psula Storage e?\num elemento de fronteira utilizado para armazenar pec?as industriais (representadas pela\nclasse Pieces). A ca?psula ProdSys tem como responsabilidade processar pec?as industriais.\nAle?m disto ProdSys representa todo o sistema, e, consequ?entemente, possui uma asso-\nciac?a?o com as outras ca?psulas do modelo. Na realidade as ca?psulas Storage e ProdSys\nna?o foram identificadas ao acaso, elas representam elementos de ana?lise extra??dos a partir\ndos casos de uso do sistema. Graficamente, a declarac?a?o destas ca?psulas e? representada\npor uma caixa com um estereo?tipo Capsula e um s??mbolo em cima a? esquerda. Eles sa?o\nformados por tre?s compartimentos, o primeiro indica a declarac?a?o de atributos, o segundo\no de me?todos e o terceiro o de portas, respectivamente de cima para baixo. Por exemplo,\na ca?psula ProdSys possui um atributo p para representar a pec?a que esta processando\nno momento, um me?todo process para processar pec?as, e duas portas pi e po para inte-\nragir com as outras ca?psulas do sistema. Note que neste diagrama na?o e? indicado qual\ninsta?ncias de ca?psulas interagem entre si, isto e? descrito no diagrama de estrutura.\n\nEstas ca?psulas tambe?m tem relacionamentos com protocolos, que sa?o utilizados para\ndirigir a comunicac?a?o entre eles. Graficamente a declarac?a?o destes protocolos e? repre-\nsentada por uma caixa com um estereo?tipo Protocol e um s??mbolo em cima a? esquerda.\nEles possuem dois compartimentos, o primeiro para descrever os sinais de entrada e o\nsegundo para os sinais de sa??da do protocolos, respectivamente de cima para baixo. O\nprotocolo STI governa inserc?a?o de pec?as em uma ca?psula (representado u?nicamente pelo\nsinal input), enquanto STO a recuperac?a?o de pec?as (o sinal req e? utilizado para requerer\npec?as, enquanto o sinal output para enviar tais pec?as). Quando sinais sa?o utilizados para\n\n\n\n2.3 uml-rt 15\n\nFigura 2.2. Modelo do Sistema de Automac?a?o Industrial\n\nenviar mensagens de dados eles possuem uma classe associada ao tipo do dado, quando\nna?o o tipo associado e? void.\n\nPor sua pro?pria natureza, ca?psulas prove?m um alto n??vel de information hiding. Como\nseu mecanismo de comunicac?a?o e? realizado atrave?s da passagem de mensagens por suas\nportas, todos os atributos e me?todos das ca?psulas sa?o vis??veis somente dentro do escopo\nda ca?psulas; somente portas sa?o vis??veis externamente para serem conectadas a? portas\nde outras ca?psulas. Este desacoplamento faz com que ca?psulas sejam altamente reuti-\nliza?veis, em adic?a?o ca?psulas podem ser definidas hierarquicamente a partir da composic?a?o\nde outras ca?psulas dentro de sua estrutura interna (representadas no diagrama de estru-\ntura); cada uma delas com uma ma?quina de estados associada e um poss??vel estrutura\nhiera?rquica compostas de outras ca?psulas. Chamaremos aqui, as insta?ncias de ca?psulas\ndentro da estrutura outra como sub-ca?psulas ou ca?psulas componentes.\n\nAssumimos que a comunicac?a?o entre duas ca?psulas conectadas e? s??ncrona (como o\nmodelo para UML-RT descrito em [8]), indicando que a ca?psula de destino de um sinal\nsempre estara? pronto para recebe-lo. Condic?o?es de mapeamento de um modelo s??ncrono\npara um ass??ncrono em UML-RT podem ser vistas em [8].\n\nUm diagrama de estrutura estende o diagrama colaborac?a?o para indicar a interac?a?o en-\ntre ca?psulas. Mostrando na?o somente depende?ncias entre objetos, como em um diagrama\nde colaborac?a?o, mas indicando a configurac?a?o da arquitetura atrave?s da composic?a?o\nhiera?rquica de ca?psulas, das conexo?es entre os pontos de interac?a?o de cada insta?ncia\nde ca?psula da estrutura, dos protocolos associados a cada um destas conexo?es. Defi-\nnindo assim a composic?a?o estrutural do modelo. A decomposic?a?o estrutural de ProdSys\ne? mostrado na figura 2.2 (acima a? direita). Ele e? composto das insta?ncias sin, pro e son,\nrespectivamente das ca?psulas Storage, Processo e Storage. A ca?psula sin e? responsa?vel\npor armazenar pec?as na?o processadas, son por armazenar pec?as processadas, e sys por\n\n\n\n2.3 uml-rt 16\n\nrecuperar as pec?as oriundas de sin, processa-las e deposita?-las em son. Sendo estas as\nrepresentac?o?es gra?ficas para ca?psulas em um diagrama de estrutura. Pequenos quadrados\nnas insta?ncias representam suas portas, onde os brancos indicam portas conjugadas (as\ndirec?o?es dos sinais sa?o invertidos em relac?a?o a definic?a?o do protocolo). Portas normais\ndevem ser conectadas a? portas conjugadas para que o sinais de sa??da de uma seja visto\ncomo o sinal de entrada da outra. As portas mi e mo sa?o portas relay e servem unicamente\npara interligar as portas si e so ao mundo externo; por esta raza?o elas na?o precisam ser\nconjugadas. Enquanto as restantes sa?o portas finais e sa?o utilizadas para interligar os\ndiagramas de estados das ca?psulas ao ambiente externo. Para facilitar a visualizac?a?o da\narquitetura, a estrutura de todas as ca?psulas sa?o vis??veis, pore?m normalmente na?o se e?\nposs??vel visualizar a partir do diagrama de estrutura de ProdSys o conteu?do e o tipo das\nportas contidos no diagrama de estrutura de sub-ca?psulas.\n\nO comportamento das ca?psulas e do protocolos do modelo e? descrito em termos de um\ndiagrama de estados em UML-RT, que especializa diagramas de estado de UML [70] para\nadequa?-los aos conceitos de ROOM Charts [86]. Estritamente, por serem usados para\ndescrever objetos ativos, estes diagramas na?o possuem estados finais, tampouco suas\ntransic?o?es sa?o disparadas por eventos impl??citos; todos os eventos devem ser associados a\nsinais externos. Assim como em UML, um diagrama de estados e? composto por transic?o?es\ne estados; em geral, uma transic?a?o possui a formato p.e[g]/a, onde e e? um sinal de\nentrada (ou um conjunto de sinais de entrada), p indica a porta de origem pelo qual o\nsinal foi recebido, g e? uma guarda e a e? uma ac?a?o. O recebimento de um sinais de entrada\nem um estado ativo e a avaliac?a?o da guarda correspondente como verdadeira disparam\numa transic?a?o. Como resultado, a ac?a?o correspondente e? executada e um novo estado e?\nativado.\n\nEm UML, estados podem ser classificados como iniciais, escolha, compostos ou sim-\nples. Um estado inicial e? um estado transiente que indica o ponto de in??cio de uma\nma?quina de estados. Um estado composto agrupo outros estados, enquanto um estado\nsimples na?o possui nenhum outro dentro dele. Um estado de escolha corresponde aos\nestados que envolvem uma decisa?o de qual caminho (estado) deve ser seguido (ativado)\nem func?a?o de uma guarda associada ao estado; existem apenas duas transic?o?es de sa??da\ndo estado: uma e? disparada quando a guarda e? verdadeira, e outra quando a guarda e?\nfalsa. Estados compostos sa?o divididos em dois tipos: Or-States e And-States. Or-State\ndefinem uma composic?a?o seque?ncial de estados, onde somente um deles e? ativado por vez,\nenquanto And-States conte?m regio?es (separados por uma linha pontilhada) que executam\nsequ?encias de estados em paralelo, e permitem que cada regia?o possua um estado ativo\npor vez. And-States sa?o considerados como deciso?es de projetos; de fato eles podem ser\nrepresentados pela composic?a?o de duas ca?psulas que possui cada uma das regio?es como\nma?quina de estado. (ver Cap??tulo 4).\n\nPara cada ma?quina de estados em UML-RT, assumimos que existe uma estado com-\nposto que possui todos os outros; ele e? chamado de estado topo (ou S0 e seu estado inicial\ne? implicitamente disparado quando a insta?ncia da ca?psula ( ou porta) e? criada. Em cada\nestado composto transic?o?es sa?o associados diretamente a um ponto de junc?a?o (exibido\ngraficamente por um circulo preto) na borda do estado. Se na?o e? uma transic?a?o do ponto\nde junc?a?o com destino em um sub-estado, o estado inicial sera? ativado; caso tenha destino\n\n\n\n2.4 uml 2.0 17\n\na um sub-estado, este sera? ativado. Transic?o?es de sa??da de um estado composto podem\nemanar de um sub-estado ou diretamente da borda do estado. O u?ltimo caso interrompe\no estado e seus sub-estados em qualquer situac?a?o; ac?o?es de entrada e sa??da (ac?o?es execu-\ntadas antes do estado ser tornar ativo e inativo, respectivamente) sa?o sempre executadas\nnormalmente.\n\nA Figura 2.2 (abaixo) apresenta o diagramas de estados das ca?psulas Storage, ProdSys\ne dos protocolos STO e STI , eles sa?o denominados graficamente como os estados S0\ndos respectivas ca?psulas. Nos dois primeiros casos o comportamento das ca?psulas sa?o\ndescritas por um estado composto do tipo Or-State, que executa sequ?encialmente seus\nestados. Nenhum comportamento em ProdSys esta associado a? sua ma?quina de estados,\npodendo ser explicado unicamente pela composic?a?o das sub-ca?psulas que compo?e. Na\nca?psula Storage, por exemplo, apo?s a sua criac?a?o, o estado inicial se torna ativo e ac?a?o\ncontendo o me?todo Storage() e? executada, isto e? equivalente a? execuc?a?o de um construtor\nda ca?psula. Apo?s isto o estado Sa se torna ativo e espera pelos sinais req e input, quando\nsinais chegarem e suas respectivas guardam forem avaliadas como verdadeiras as ac?o?es\nassociadas a estes estados sa?o executadas, retornando assim ao estado Sa; uma descric?a?o\nmais detalhada sobre o comportamento da ma?quina de estado de Storage sera? descrita\nno Cap??tulo 3.\n\nNo?s assumimos que eventos, guardas e ac?o?es sa?o expressas utilizando a notac?a?o de\nOhCircus. Por exemplo, no diagrama de estados de ProdSys, a ac?a?o da transic?a?o inicial e?\nrepresentada pelo envio de um sinal req atrave?s da porta pi (pi.req), e o evento que dispara\na u?nica transic?a?o de sa??da de Sp e? expresso por pi?output.x, indicando que o recebimento\ndo sinal output atrave?s da porta pi, cujo valor e? atribu??do a uma varia?vel local x. A ac?a?o\ndesta transic?a?o executa um me?todo process() que modifica o valor de uma varia?vel p e\napo?s isto envia o evento po!input.p, que comunica o valor p pelo sinal input atrave?s da\nporta po. Note o envio de sinais sempre esta? contido nas ac?o?es do diagrama de estado, e\nque os prefixos ? e ! sempre esta?o relacionados a eventos que comunicam dados de entrada\ne sa??da, respectivamente.\n\n2.4 UML 2.0\n\nA versa?o 2.0 de UML introduz novos conceitos a? versa?o 1.5 e altera outros ja? exis-\ntentes1. Nesta sec?a?o, falamos dos conceitos da versa?o 2.0 referenciando minimamente o\nmetamodelo de UML (o nu?cleo da definic?a?o sema?ntica da linguagem). Apesar disto, para\napresentar os relacionamentos entre esses conceitos, precisamos descrever certos aspectos\ndo metamodelo, como em particular, o conceito de classificadores, um tipo que pode ter\ninsta?ncias; por exemplo, classes sa?o classificadores cujas as insta?ncias sa?o objetos. Este\nconceito e? importante porque dois dos elementos de UML que vamos discutir, classes e\ncomponentes, sa?o classificadores. Assim, quando descrevemos que um conceitos pode ser\naplicado a classificadores, estamos, consequ?entemente, descrevendo como eles podem ser\naplicados a? classes e componentes.\n\nEsta versa?o combina va?rias caracter??sticas encontradas em alguns ADLs para espe-\n\n01 Ate? a data de entrega desta dissertac?a?o a vera?o 2.0 de UML ainda na?o havia sido publicada como\numa versa?o oficial da OMG.\n\n\n\n2.5 concluso?es 18\n\ncificac?a?o de componente a? UML [88], como por exemplo decomposic?a?o hiera?rquica de\ncomponentes. Todas estas caracter??sticas sa?o importantes para formar um novo conceito\nde componentes, tratados agora como componentes de software ao inve?s de meros frag-\nmentos f??sicos do software para propo?sitos de implantac?a?o. Isto indica que componentes\nsa?o pedac?os modularizados, reutiliza?veis, e implanta?veis do software dispon??veis durante\no desenvolvimento, e durante a execuc?a?o do sistema.\n\nCada classificador (classes e componentes) podem ser compostos por outros elementos\ncontidos dentro da estrutura interna do classificador. Esta estrutura interna descreve\ncomo os elementos podem ser compostos por outros elementos, chamados de partes ou\nelementos conecta?veis. Estes na?o sa?o nunca classificadores, pore?m insta?ncias ou conjunto\nde insta?ncias de classificadores. O relacionamento entre estes elementos e os de sua\nestrutura interna e? a de agregac?a?o, no sentido que os as partes na?o podem existir sem os\nelementos que as conte?m.\n\nAdicionalmente esta estrutura indica como o componente interage com o ambiente\natrave?s de suas interfaces, ou portas. Interfaces e portas sa?o utilizadas para desacoplar\nas insta?ncias do ambiente; onde, sob o ponto de vista a insta?ncia e? vista como uma caixa\npreta com va?rios pontos de interac?a?o (interfaces ou portas). Interface se diferenciam\nde portas, por oferecerem seus servic?os como me?todos. Enquanto portas oferecem seus\nservic?os atrave?s de conjunto de sinais.\n\nMa?quinas de estados foram subdivididas em ma?quinas de estados comportamentais\ne de protocolo. A primeira e? utilizada para o mesmo propo?sito que antes, descrever o\ncomportamento interno de uma classificadores, enquanto a segunda e? usada para definir\no comportamento abstrato associado a interfaces e portas.\n\n2.5 CONCLUSO?ES\n\nApesar de UML-RT na?o ter sido criado por organizac?o?es de padronizac?a?o (como a\nOMG), sendo mantida pelas empresas que suportam suas ferramentas, va?rios conceitos\ndesta linguagem esta?o diretamente presentes em outras linguagens para a descric?a?o de\narquiteturas (ADLS) ou de componentes (UML 2.0). Unido-os em uma u?nica lingua-\ngem, que tem como vantagens, uma separac?a?o clara entre elementos ativos e passivos,\nos quais possuem uma sema?ntica diferente para a passagem de mensagens, decomposic?a?o\nhiera?rquica de seus componentes, e a definic?a?o expl??cita de inter-conexo?es e interfaces de\nseus componentes.\n\nAle?m disto, possui um pequeno conjunto de diagrams, capazes de descrever os aspec-\ntos estruturais e dina?micos do modelo. Desta forma, UML-RT e? uma linguagem enxuta\ne? descritiva para a modelagem de componentes ativos. Apesar disto, possui como des-\nvantagem, na?o poder descrever explicitamente conexo?es com diferentes comportamentos;\nisto pode ser representado implicitamente atrave?s de componentes que funcionam como\nadaptadores desta conexa?o. Apesar disto, esta linguagem na?o ser, neste aspectos, me-\nnos representativa que outras linguagens para a descric?a?o de arquiteturas, e todas as\ncontribuic?o?es que possam ser incorporadas ao desenvolvimento em UML-RT podem ser,\nconsequ?entemente, futuramente aplicadas a UML 2.0, linguagem ainda na?o oficial sob\nfase de elaborac?a?o pela OMG, .\n\n\n\nCAPI?TULO 3\n\nFORMALIZAC?A?O DE UML-RT\n\nNeste cap??tulo, mostraremos a formalizac?a?o de UML-RT atrave?s de seu mapeamento\nsinta?tico na linguagem de especificac?a?o OhCircus [16]. Com esta formalizac?a?o damos\nsignificado aos elementos de UML-RT, em termos da sema?ntica de um subconjunto (Cir-\ncus) de OhCircus.\n\nA motivac?a?o para uso desta linguagem formal e? que ela oferece um ca?lculo de re-\nfinamentos que auxilia na prova de transformac?o?es de modelos em UML-RT usando o\nmapeamento em OhCircus. Ale?m disto, objetos ativos e suas conexo?es podem ser facil-\nmente representados atrave?s de processos e canais de comunicac?a?o de OhCircus.\n\nApresentamos, na Sec?a?o 3.1, uma breve introduc?a?o a? linguagem OhCircus, incluindo\nnoc?o?es de sua sintaxe, sema?ntica e ca?lculo de refinamentos. Como mostramos na Sec?a?o\n3.1.2, a sema?ntica e o ca?lculo de refinamentos e? restrito ao subconjunto Circus, mas\nisso e? suficiente para lidarmos com as construc?o?es que UML-RT adiciona a UML. Um\nmapeamento de UML em OhCircus e? proposto em [10]. Na Sec?a?o 3.2, apresentamos o\nmapeamento dos principais elementos de UML-RT em OhCircus.\n\n3.1 OHCIRCUS\n\nOhCircus e? uma linguagem orientada a objetos projetada para lidar com a especi-\nficac?a?o e o refinamento de sistemas concorrentes. OhCircus combina a a?lgebra de pro-\ncessos CSP [79] com a linguagem baseada em modelos Z [95] com o intuito de capturar\naspectos relacionados ao estado e a? comunicac?a?o do sistema em uma mesma especificac?a?o,\ncomo em [94].\n\nPara expressar a comunicac?a?o de sistemas concorrentes, OhCircus inclui a noc?a?o de\nprocesso, cujo estado e? definido por um esquema em Z e o comportamento por uma ac?a?o\nna notac?a?o de CSP. A interac?a?o entre processos e? realizada somente atrave?s de canais,\nutilizados para comunicar valores ou somente para a sincronizac?a?o.\n\nAle?m de sua utilizac?a?o para especificac?a?o de sistemas concorrentes e reativos, OhCir-\ncus foi projetada para suportar uma teoria de refinamentos. O objetivo desta teoria e? dar\numa base so?lida ao desenvolvimento de sistemas concorrentes e distribu??dos, utilizando\num ca?lculo de refinamentos semelhante ao encontrado em [67].\n\n3.1.1 Sintaxe\n\nDa mesma maneira que especificac?o?es em Z, programas em OhCircus sa?o formados\npor uma sequ?e?ncia de para?grafos:\n\nProgram ::= OhCircusParagraph?\n\nOnde, OhCircusParagraph? denota um lista com zero ou mais elementos da categoria\n\n19\n\n\n\n3.1 ohcircus 20\n\nsinta?tica OhCircusParagraph. Cada um destes para?grafos pode ser um para?grafo de Z (de-\nnotados aqui pela categoria sinta?tica Paragraph, conforme definido em [95]), ou a definic?a?o\nde canais, grupo de canais, processos ou classes (denotados, respectivamente, pelas catego-\nrias sinta?ticas ChannelDefinition, ChanSetDefinition OhProcessDefinition, ClassDefinition).\n\nOhCircusParagraph ::= Paragraph\n| ChannelDefinition | ChanSetDefinition\n| OhProcessDefinition | ClassDefinition\n\nOs principais construtores de OhCircus sa?o ilustrados atrave?s de uma parte da espe-\ncificac?a?o do sistema de automac?a?o industrial (previamente introduzido na Sec?a?o 2.3); a\ngrama?tica completa de OhCircus pode ser encontrada no Ape?ndice A. Na Figura 3.1,\napresentamos a especificac?a?o da ca?psula Storage, utilizada para armazenar objetos da\nclasse Piece, atrave?s de um processo ChartStorage em OhCircus. Utilizaremos o mesmo\nfonte da Figura 2.2 para identificadores (por exemplo, nomes de atributos, classes e\nca?psulas) encontrados diretamente no modelo em UML-RT.\n\nO tamanho ma?ximo de armazenamento e? representado atrave?s de uma constante\npositiva N , declarada no primeiro para?grafo da Figura 3.1.\n\n| N : N\nTSTI ::= input ? Piece ?\nchannel si : TSTI\nTSTO ::= req | output ? Piece ?\nchannel so : TSTO\nprocess ChartStorage =? begin\n\nstate StorageState =? [buff : seq Piece; size : 0..N | size = #buff ? N ]\nStorageInit =? [StorageState? | buff? = ?? ? size? = 0]\ninsert =? [?StorageState; x ? : Piece | size &lt;N ?\n\nbuff? = buff a ?x ?? ? size? = size + 1]\nremove =? [?StorageState; x ! : Piece | size > 0 ? x ! = head buff ?\n\nbuff? = tail buff ? size? = size ? 1]\nSa =? (size &lt;N &amp; si?input.x ? insert(x); Sa)\n\n2 (size > 0 &amp; so.req ? (var x : Piece \u2022 x = remove(); so!output.x); Sa)\n\u2022 StorageInit; Sa\nend\n\nFigura 3.1. Especificac?a?o da ca?psula Storage\n\nTodos os canais utilizados por um processo devem ser declarados. As categorias\nsinta?ticas Expression e Schema?Exp sa?o utilizadas para designar expresso?es em Z e ex-\npresso?es de esquema definidas em [95]. A categoria sinta?tica N e? utilizada para identifi-\ncadores va?lidos em Z.\n\n\n\n3.1 ohcircus 21\n\nChannelDefinition ::= channel CDeclaration\nCDeclaration ::= SimpleCDeclaration | SimpleCDeclaration; CDeclaration\nSimpleCDeclaration ::= N+ | N+ : Expression | Schema?Exp\n\nA declarac?a?o de uma canal e? composta por um nome e o valor comunicado pelo canal.\nCaso o canal seja utilizado apenas para a sincronizac?a?o de processos, sem comunicac?a?o\nde valor, a declarac?a?o contera? apenas o nome do canal, sem um tipo associado.\n\nUma mesma declarac?a?o pode introduzir mais de um canal, desde que tenham o mesmo\ntipo. Neste caso, ao inve?s de um u?nico nome, temos uma lista de nomes de canais\nseparados por v??rgula.\n\nEm nosso exemplo, o processo armazena e fornece objetos atrave?s dos canais si e\nso, respectivamente. Os tipos TSTI e TSTO indicam que valores podem ser comunicados\npor estes canais; neste exemplo, esses tipos sa?o declarados como tipos enumerados. Em\nTSTO, req e? um construtor (de tipo) utilizado no exemplo para representar a requisic?a?o\nde objetos do processo, e output um construtor utilizado para representar o fornecimento\ndos objetos requisitados. E input, em TSTI, e? utilizado para representar o armazenamento\nde objetos do tipo Piece.\n\nA declarac?a?o de um processo e? composta por seu nome e sua especificac?a?o. Apesar de\nOhCircus possibilitar a heranc?a de processos, (utilizando-se a palavra-chave extends),\nesta caracter??stica na?o e? abordada neste trabalho.\n\nOhProcessDefinition ::= process N =? [extends N] Process\n\nUm processo pode ser explicitamente definido, ou pode ser definido em termos de\noutros processos. Uma definic?a?o expl??cita de um processo e? delimitada pelas palavras-\nchaves begin e end; ela e? formada por uma sequ?e?ncia de para?grafos do processo e uma\nac?a?o principal (no final da definic?a?o, apo?s o s??mbolo \u2022), que define o comportamento do\nprocesso. Um destes para?grafos e? utilizado para descrever o estado do processo atrave?s\nda notac?a?o Z, apo?s a palavra-chave state.\n\nProcess ::= begin PParagraph?\n\n[state Schema?Exp]\nPParagraph?\n\n[\u2022 Action]\nend\n\n| CompProcess\n\nEm nosso exemplo, o processo ChartStorage encapsula dois componentes de estado no\nesquema StorageState: uma lista de objetos e o tamanho desta lista.\n\nNa definic?a?o expl??cita de um processo, ale?m da definic?a?o de seu estado e ac?a?o principal,\no seu corpo e? formado por para?grafos em Z e ac?o?es. Estes para?grafos sa?o utilizados para\nestruturar a especificac?a?o e sa?o referenciados pela ac?a?o principal.\n\nPParagraph ::= Paragraph | N =? ParAction | nameset N == NSExp\n\nUma ac?a?o pode ser um esquema, um comando guardado, uma invocac?a?o para uma\nac?a?o previamente definida, ou uma combinac?a?o de outras ac?o?es utilizando operadores de\n\n\n\n3.1 ohcircus 22\n\nCSP.\n\nAction ::= Schema?Exp | CSPActionExp | Command | N\n\nO corpo de para?grafos do processo ChartStorage e? formado por tre?s esquemas em Z\nque modificam o estado: StorageInit, insert e remove. O esquema StorageInit especifica\na operac?a?o de inicializac?a?o do processo, definindo a sua lista de objetos como vazia. A\noperac?a?o insert adiciona um objeto a? lista e atualiza o atributo size com seu novo tamanho,\nenquanto a operac?a?o remove modifica o estado, removendo o primeiro elemento da lista\ne decrementando o valor de size (ver Figura 3.1).\n\nAssim como em Z, interrogac?o?es (?), exclamac?o?es (!) e apostrofos (?) sa?o utilizados\npara decorar varia?veis de entrada, de sa??da ou com estado final (valor apo?s a operac?a?o),\nrespectivamente.\n\nTre?s ac?o?es primitivas de CSP esta?o dispon??veis em OhCircus: Skip, Stop e Chaos. A\nac?a?o Skip na?o comunica qualquer valor, tampouco alterar o estado: ela termina imedi-\natamente. A ac?a?o Stop representa deadlock, e a ac?a?o Chaos representa diverge?ncia. A\nu?nica garantia em ambos os casos e? que o invariante do estado e? mantido.\n\nCSPActionExp ::= Skip | Stop | Chaos\n| Communication ? Action | Predicate &amp; Action\n| Action; Action | Action 2 Action | Action u Action\n| Action |[ NSExp | CSExpression | NSExp ]| Action\n| Action ||[NSExp | NSExp]|| Action\n| Action \\ CSExpression | \u00b5 N \u2022 Action | ...\n\nCommunication ::= N CParameter?\n\nCParameter ::= ?N |?N : Predicate |!Expression | .Expression\n\nComunicac?o?es (representadas pela categoria sinta?tica Communication) em OhCircus\nobedecem ao mesmo padra?o de CSP, pore?m guardas podem ser associadas a elas; a\ncategoria sinta?tica Predicate, utilizada para predicados em Z, e? definida em [95]. Por\nexemplo, dado um predicado p em Z, se a condic?a?o p for verdade, a ac?a?o p &amp; (c?x ? A)\nrecebe um valor atrave?s do canal c e o atribui a? varia?vel x no mesmo escopo, executando,\napo?s isto, a ac?a?o A. No entanto, se a condic?a?o p for falsa, esta ac?a?o e? bloqueada (refutada).\nIsto possibilita que condic?o?es, como a guarda p, possam ser associadas a qualquer ac?a?o.\n\nTodas as varia?veis livres precisam estar no mesmo escopo que uma ac?a?o. Todos\nos componentes do estado esta?o em um escopo global para qualquer ac?a?o do processo.\nValores de entrada de canais introduzem novas varia?veis no escopo, e atribuem este valor a\nelas; estas varia?veis na?o podem receber novas atribuic?o?es. Os operadores de composic?a?o\nde CSP para ac?o?es de sequ?e?ncia (; ), escolha interna (u) e externa (2), paralelismo\n(|[NSExp |CSExpression |NSExp]|), interleaving (||[NSExp | NSExp]||), e hiding (\\) podem\nser utilizados para compor ac?o?es. Operadores de CSP para a definic?a?o de comunicac?a?o\ne de recursividade (\u00b5) tambe?m sa?o permitidos no n??vel de ac?o?es. Outros operadores de\ncomposic?a?o de CSP podem ser encontrados na grama?tica de OhCircus (ver Ape?ndice A).\n\nEm nosso exemplo, a ac?a?o principal inicializa o processo ChartStorage e oferece conti-\nnuamente a escolha para o ambiente dos eventos si?input.x e so.req. Esta escolha pelo\n\n\n\n3.1 ohcircus 23\n\nambiente e? definida atrave?s do operador de escolha externa (2). Tal escolha e? continua-\nmente oferecida atrave?s do uso do operador de recursividade (\u00b5).\n\nSa =? (size &lt;N &amp; si?input.x ? insert(x); Sa)\n2 (size > 0 &amp; so.req ? (var x : Piece \u2022 x = remove(); so!output.x); Sa)\n\n\u2022 StorageInit; Sa\n\nO processo somente aceita input se existir espac?o para armazenar o novo objeto; o\nsinal e? guardado por size &lt;N . Caso a guarda seja satisfeita, o objeto e? adicionado a? lista\natrave?s da operac?a?o insert, que tambe?m incrementa a varia?vel size. A ac?a?o si?input.x ?\ninsert(x) e? escrita no estilo de CSP. Nesta ac?a?o, a varia?vel x e? declarada dinamicamente\ncom o tipo dado pelo canal si e com o valor correspondente ao comunicado atrave?s do\nmesmo. O evento so.req somente e? habilitado caso o processo contenha algum objeto em\nsua lista; caso esta condic?a?o seja verdadeira, o retorno de uma ac?a?o remove() (o objeto\ninicial da lista buff) e? atribu??do a uma varia?vel x, seguido do envio do valor de x atrave?s\ndo evento so!output.x.\n\nNo n??vel de ac?o?es, os operadores de paralelismo e interleaving sa?o levemente diferentes\ndaqueles de CSP. Com a intenc?a?o de evitar conflitos no acesso a?s varia?veis em escopo, estes\noperadores de ac?o?es precisam declarar dois conjunto que particionam todas as varia?veis em\nescopo: componentes de estado, varia?veis locais e de entrada. O operador de paralelismo\nde OhCircus segue uma abordagem alfabetizada, adotada em [79]. Quando processos\nsa?o postos em paralelo, o conjunto de eventos em que eles sincronizam necessitam ser\nexplicitamente especificado; eventos que na?o sa?o listados ocorrem independentemente.\nPor exemplo, no paralelismo A1 |[ ns1 | cs | ns2 ]| A2, as ac?o?es A1 e A2 sincronizam nos\ncanais do conjunto cs. A ac?a?o A1 pode modificar somente os valores das varia?veis em\nns1; similarmente, a ac?a?o A2 pode modificar valores das varia?veis em ns2. As ac?o?es\ncompostas pelo operador de interleaving se comportam de maneira similar ao operador\nde paralelismo em relac?a?o a?s suas partic?o?es.\n\nApo?s definidos explicitamente, os processos podem ser combinados utilizando-se ope-\nradores de CSP para formar novos processos.\n\nCompProcess ::= N | Proc; Process | Process \\ CSExpression\n| Process 2 Process | Process u Process |\n| Process ||| Process | Process |[ CSExpression ]| Process |...\n\nDois Processos P1 e P2 podem ser combinados, por exemplo, em sequ?e?ncia (P1; P2),\nonde o processo P2 executa apo?s o te?rmino com sucesso da execuc?a?o de P1, ou em paralelo\nP1|[cs]|P1, sincronizando sobre eventos de cs; seguindo uma abordagem alfabetizada como\na adotada em [79].\n\nNo nosso exemplo do sistema de automac?a?o (Sec?a?o 2.3), o processo que representa\na ca?psula MAIN e? definido pela composic?a?o paralela de todos os processos do sistema\n(ca?psulas), sincronizando em seus canais de comunicac?a?o, como apresentado na Sec?a?o 3.2.\nPor exemplo, de maneira simplificada, os processos relativos a?s insta?ncias das ca?psulas\nStorage e Processo sa?o compostos utilizando o operador de paralelismo Storage[so := c2]|[{|\nc2 |}]|Processo[pi := c2]. Neste caso, para que os dois processos sincronizem em um canal\nde comunicac?a?o comum c2, os canais so e pi devem ser renomeados para c2.\n\n\n\n3.1 ohcircus 24\n\nA sintaxe para a definic?a?o de classe e? expressa por seu nome, sua super classe atrave?s\nda cla?usulas extends, e seus atributos e me?todos delimitados pelas cla?usula begin e\nend. Por na?o abordarmos heranc?a neste trabalho, toda classe devera? omitir a cla?usula\nextends. Assim como em processos, a definic?a?o de atributos e me?todos de uma classe\nconsiste em uma sequ?e?ncia de para?grafos, onde o para?grafo com a cla?usula state iden-\ntifica o esquema de estado da classe com seus componentes de estado (atributos). O\nesquema de estado de uma classe e? definido em Z assim como os estados de um processo,\npore?m inclui qualificadores (public, protected, private e logical) na declarac?a?o de\nseus componentes. Caso um atributo na?o seja qualificado, este e? assumido como privado.\n\nClassDefinition ::= class N =? [extends N]begin CParagraph?\n\n[state StateSchema] CParagraph?\n\n[initial Schema?Exp] CParagraph?\nend\n\nCParagraph ::= Paragraph | Qualifier N =? ParametrisedCommand\nQualifier ::= public | protected | private | logical\n\nA cla?usula initial introduz o construtor da classe. Este na?o e? introduzido para ser\num me?todo, apenas para definir a criac?a?o da classe, na?o devendo ter em sua especi-\nficac?a?o varia?veis de sa??da. Me?todos (categoria sinta?tica CParagraph) sa?o declarados como\npara?grafos em Z, diferenciando-se pore?m pela possibilidade de utilizarem qualificadores\nde acesso, indicando em que escopo podem ser chamados.\n\nNa Figura 3.2, a especificac?a?o de Piece e? descrita atrave?s de um para?grafo com o\nestado da classe e tre?s para?grafos com operac?o?es. O esquema de estado e? composto de\num u?nico componente data, representado por uma sequ?e?ncia de naturais de tamanho\n100. O para?grafo PieceInit representa o construtor da classe Piece, inicializando todos os\nvalores de data com 0. Os me?todos setData e getData sa?o utilizados somente para alterar\ne recuperar o valor do componente data.\n\nclass Piece =? begin\nstate PieceState =? [data : seq N | #data = 100]\ninitial PieceInit =? [PieceState? | ran data? = {0}]\npublic setData =? [?StorageState; d? : seq N | data? = d?]\npublic getData =? [?StorageState; r ! : seq N \u2022 r ! = data]\n\nend\n\nFigura 3.2. Especificac?a?o da classe Piece\n\n3.1.2 Sema?ntica\n\nApesar de utilizamos OhCircus para o mapeamento de um subconjunto compreens??vel\nde UML-RT (Sec?a?o 3.2), classes do sistema sa?o semanticamente vistas, aqui, apenas como\nregistros na?o compartilhados de dados, representados em Z. Na?o sendo necessa?rio assim\n\n\n\n3.1 ohcircus 25\n\nabordar todas as caracter??sticas de orientac?a?o a objetos de UML. A sema?ntica de classes\npara UML em Z (e portanto para UML-RT) e? considerada em diversos trabalhos [30, 12,\n69]. Como este trabalho foca apenas na definic?a?o sema?ntica dos elementos que UML-RT\nadiciona a? UML, a utilizac?a?o de um subconjunto de OhCircus (Circus) que na?o utiliza\norientac?a?o a objetos e? satisfato?ria para a finalidade deste trabalho..\n\nO modelo sema?ntico de Circus e? baseado na Teoria Unificada da Programac?a?o (UTP)\n[47]. A UTP e? um framework no qual a teoria de relac?o?es sa?o utilizadas como uma base\nunificada para a cie?ncia da programac?a?o, atrave?s de seus diferentes paradigmas: proce-\ndural e declarativo, sequ?encial e paralelo, acoplado e distribu??do, e hardware e software.\n\nProgramas, projetos, e especificac?o?es sa?o interpretados como relac?o?es entre uma ob-\nservac?a?o inicial e subsequ?ente, que pode ser uma observac?a?o intermedia?ria ou final, do\ncomportamento da execuc?a?o de um programa. Leis do ca?lculo relacional podem ser uti-\nlizadas como ferramental de prova.\n\nDesta maneira, ide?ias, como composic?a?o sequ?encial, condicional, na?o-determinismo,\ne paralelismo sa?o compartilhadas por diferentes teorias. Em cada teoria, varia?veis de\nobservac?a?o sa?o identificadas para descrever seus aspectos mais importantes, e sub-teorias\nsa?o criadas a partir de restric?o?es do relacionamento entre estas varia?veis de observac?a?o.\nUm exemplo e? a pro?pria linguagem Circus, que estende a teoria de CSP para processos\nreativos. Em Circus a definic?a?o de um processo, por exemplo, possui ambientes para ar-\nmazenar informac?o?es de canais e varia?veis em escopo, componentes de estado, para?grafos\ne processos que compo?e.\n\nNeste trabalho, na?o entramos no detalhe da sema?ntica de processos ou canais em\nCircus; a sema?ntica completa de Circus pode ser encontrada em [100]. Entretanto,\nmostramos como os operadores de composic?a?o de processos, podem ser representados\natrave?s de processos simples, cuja sema?ntica e? apresentada em [100].\n\n3.1.2.1 Expresso?es de Processos Expresso?es de processos utilizam operadores de\nCSP para combinar processos existentes. A sema?ntica de uma expressa?o R op Q, onde op\ne? uma operac?a?o bina?ria qualquer em CSP, exceto paralelismo e interleaving, e? definida\nda seguinte forma.\n\nR op Q = begin\nstate State =? R.st ? Q.st\nR.pps ? Q.st\nQ.pps ? R.st\n\u2022 R.act op Q.act\n\nend\n\nO estado dos processos R e Q sa?o denotados por R.st e Q.st, respectivamente. De uma\nmaneira similar, a notac?a?o R.pps e Q.pps sa?o utilizadas para se referir aos para?grafos\nna definic?a?o dos processos R e Q. Suas ac?o?es principais sa?o denotadas com R.act e\nQ.act. As operac?o?es do processo composto sa?o formadas pelos esquemas de R.pps ? Q.st\ne Q.pps ? Q.st. O termo R.pps ? Q.st indica que as operac?o?es em R.pps na?o podem\nalterar os componentes do estado em Q.st; para garantir isto, e? adicionado a? operac?a?o a\nexpressa?o ?Q. Similarmente, Q.pps na?o altera os componentes em R.st.\n\n\n\n3.1 ohcircus 26\n\nComo discutido na Section 3.1.1, os operadores de paralelismo e interleaving para\nac?o?es sa?o levemente diferentes daqueles utilizados para processos; no n??vel de ac?o?es,\npartic?o?es com todas as varia?veis no escopo precisam ser declaradas. Por esta raza?o,\num novo operador R.pps ?PAR Q.st e? utilizado na definic?a?o de paralelismo e interleaving.\nEste operador libera as operac?o?es em R.pps para alterar todas as varia?veis de ambiente,\nutilizando ?Q ao inve?s da expressa?o ?Q. Apesar disto, esta permissa?o e? ignorada, ja? que\nos componentes de estado de Q.st esta?o declarados na mesma partic?a?o utilizada pelas\nac?o?es de Q.act; de forma similar, R.st pertencem a? partic?a?o utilizada pelas ac?o?es de\nR.act. Assim a sema?ntica do operador de paralelismo e? definida como segue.\n\nR |[ cs ]| Q = begin\nstate State =? R.st ? Q.st\nR.pps ?PAR Q.st\nQ.pps ?PAR R.st\n\u2022 R.act |[ ns1 | cs | ns2 ]| Q.act\n\nend\n\nNa definic?a?o do operador de paralelismo, R.st esta? contido em ns1, e Q.st em ns2. O\noperador de interleaving e? definido de forma similar.\n\nA sema?ntica do operador de hiding e? mais simples: os para?grafos do processo sa?o\ninclu??dos sem alterac?o?es, somente a ac?a?o principal e? modificada para esconder os canais\nusados como argumento do hiding.\n\nR \\ cs = begin\nstate R.st\nR.pps\n\u2022 R.act \\ cs\n\nend\n\nA sema?ntica de outros operadores pode ser encontrada em [99]\n\n3.1.3 Noc?o?es de Refinamento e Equivale?ncia\n\nUma das noc?o?es centrais na UTP e? a de refinamento, que e? definida em termos de\nimplicac?a?o: uma implementac?a?o P satisfaz uma especificac?a?o S se, e somente se, [P ? S ],\nonde os colchetes denotam o quantificador universal sobre o alfabeto utilizado por P e S ,\ncomo em [21]; o alfabeto deve ser o mesmo para a implementac?a?o e para especificac?a?o.\nA noc?a?o de equivale?ncia, e? igual a? demonstrac?a?o do refinamento em ambas as direc?o?es;\nna UTP, [P = S ] se e somente se [P ? S ] e [S ? P ].\n\nEm Circus (e, portanto, em OhCircus), a noc?a?o ba?sica de refinamento para ac?o?es e\ndada pela Definic?a?o 3.1 [15].\n\nDefinic?a?o 3.1 (Refinamento de Ac?o?es) Para ac?o?es A1 e A2 no mesmo espac?o de es-\ntados, A1 vA A2 se e somente se [A1 ? A2]. 2\n\nProcessos, que possuem seus estados privados, possuem uma definic?a?o levemente di-\nferente. A ac?a?o principal de um processo define seu comportamento. Por esta raza?o,\n\n\n\n3.1 ohcircus 27\n\nrefinamento de processos e? definido em termos de refinamento de ac?o?es de blocos lo-\ncais. A seguir, P1.st e P1.act denotam o estado local e a ac?a?o principal do processo P1;\nsimilarmente para o processo P2.\n\nDefinic?a?o 3.2 (Refinamento de Processos) P1 vP P2 se e somente se (?P1.st; P1.st?\n\u2022 P1.act) vA (?P2.st; P2.st? \u2022 P2.act) 2\n\nAs ac?o?es P1.act e P2.act podem agir em diferentes espac?os de estado. As ac?o?es destes\nprocessos sa?o comparadas ignorando-se seus componentes de estado; o espac?o de estado\nconte?m somente as varia?veis observadas na UTP.\n\nComo dito anteriormente, o estado de um processo e? privado, permitindo que seus\ncomponentes sejam modificados durante um refinamento, atrave?s de refinamento de da-\ndos [68]. Em [17], a te?cnica de simulac?a?o aplicada em Z foi adotada para lidar com\nprocessos e ac?o?es. Uma simulac?a?o e? uma relac?a?o entre os estados de dois processos que\nsatisfazem um conjunto de propriedades.\n\nDefinic?a?o 3.3 (Forwards Simulation) Uma forwards simulation entre as ac?o?es A1 e\nA2 de processos P1 e P2, com um estado local L, e? uma relac?a?o R entre P1.st, P2.st, e L,\nsatisfazendo.\n\n\u2022 (Aplicabilidade) ?P2.st; L \u2022 (?P1.st \u2022 R)\n\n\u2022 (Corretude) ?P1.st; P2.st; P2.st?; L \u2022 R ? A2 ? (?P1.st?; L? \u2022 R? ? A1) 2\n\nNeste caso, no?s escrevemos A1 ?P1,P2,R,L A2. Uma forwards simulation entre P1 e P2\ne? uma forwards simulation entre suas ac?o?es principais.\n\nComo destacado em [17], diferentemente da definic?a?o usual de forwards simulation,\nna Definic?a?o 3.3 na?o existe um requisito de aplicabilidade em relac?a?o a?s pre?-condic?o?es.\nIsto se deve ao fato de que ac?o?es sa?o totais. Se uma ac?a?o e? executada fora de sua pre?-\ncondic?a?o, ela diverge; pore?m, seu comportamento na?o e? arbitra?rio, ja? que o invariante de\nestado e? implicitamente mantido, e novas sincronizac?o?es arbitra?rias podem ser observadas,\nmas observac?o?es passadas na?o sa?o afetadas. Ale?m disto, nenhuma condic?a?o especifica e?\nimposta em sua inicializac?a?o: qualquer inicializac?a?o de estado precisa ser explicitamente\ninclu??da na ac?a?o principal.\n\nUm teorema em [17] indica que se existe uma relac?a?o de forwards simulation existe\ntambe?m uma relac?a?o de refinamento. Uma estrate?gia de refinamento para Circus foi\ndefinida em [17]. Esta estrate?gia, pode envolver va?rias iterac?o?es com tre?s passos: refi-\nnamento de dados, refinamento de ac?o?es, e refinamento de processos. Os dois primeiros\npassos sa?o utilizados para reorganizar a estrutura de um processo, alterando-se seus com-\nponentes de estados e suas ac?o?es. O terceiro passo e? utilizado para refinar (tipicamente,\ndecompor) processos, preservando o comportamento.\n\n3.1.4 Leis para refinamento de Processos\n\nLeis para o refinamento de processos lidam simultaneamente com estado e comporta-\nmento. Nesta sec?a?o, apresentaremos duas leis para o refinamento de processos; mais leis\npodem ser encontradas em [17].\n\n\n\n3.1 ohcircus 28\n\nA primeira lei indica que podemos introduzir novos processos em uma especificac?a?o,\nassumindo que eles na?o sejam utilizados. Como na introduc?a?o de novas varia?veis em uma\nlinguagem imperativa, o fato de o processo na?o ser utilizado e? suficiente para garantir\nque sua introduc?a?o na?o afeta os demais processos.\n\nLei 3.1 Introduc?a?o de declarac?a?o de processo\n\ncp = pd cp\n\ndesde que: o processo declarado em pd na?o seja referenciado nem declarado na\nsequ?e?ncia de para?grafos do programa em Circus cp. 2\n\nApesar desta lei expressar uma propriedade simples, sua importa?ncia se torna evidente\nem sua composic?a?o com outras leis.\n\nA lei a seguir e? aplicada para particionar um processo cujos componentes de estado\npodem ser divididos em dois conjuntos, de uma maneira tal que cada um deles possui seu\npro?prio conjunto de para?grafos, que na?o interfere no outro. A forma geral e? apresentada\npelo P abaixo.\n\nprocess P =? begin\nstate State =? Q.st ? R.st\nQ.pps ? R.st\nR.pps ? Q.st\n\u2022 F (Q.act, R.act)\n\nend\n\nComo na definic?a?o da expressa?o de processos (Sec?a?o 3.1.2.1), o estado do processo P\ne? definido pela conjunc?a?o de outros dois esquemas Q.st e R.st. Ale?m disto, os para?grafos\nde P sa?o tambe?m particionados de maneira que os para?grafos em Q.pps na?o alteram os\ncomponentes de R.st; de uma maneira similar, os para?grafos em R.pps na?o alteram os\ncomponentes em Q.st. Quando dois conjuntos de para?grafos satisfazem estas condic?o?es,\ndizemos que eles sa?o disjuntos com respeito a R.st e Q.st. Finalmente, a ac?a?o principal\nde P e? definida como uma composic?a?o F das ac?o?es Q.act e R.act, onde F e? um contexto\n(func?a?o sobre processos) envolvendo operadores de CSP que podem ser utilizados na\ncomposic?a?o de processos.\n\nA Lei 3.2, apresentada abaixo, transforma um processo particionado P (como definido\nacima) em tre?s processos, onde os dois primeiros incluem as partic?o?es dos estados e dos\npara?grafos de P , e o terceiro processo e? definido em termos dos dois primeiros, utilizando\na mesma func?a?o F que define a ac?a?o principal de P .\n\nLei 3.2 (Decomposic?a?o de processo) Seja qd e rd declarac?o?es dos processos Q e R,\ndeterminados por Q.st, Q.pps, e Q.act, e R.st, R.pps, e R.act, respectivamente, e pd a\ndeclarac?a?o do processo P . Enta?o:\n\npd = (qd rd process P =? F (Q, R))\n\ndesde que: Q.pps e R.pps sejam disjuntos com respeito a R.st e Q.st, respectivamente.\n2\n\n\n\n3.2 mapeamento 29\n\n3.2 MAPEAMENTO\n\nNesta sec?a?o, atribu??mos significado sema?ntico aos elementos de UML-RT atrave?s de\nseu mapeamento sinta?tico para OhCircus. Esta traduc?a?o prove? um mapeamento tanto\nda visa?o estrutural quanto comportamental dos elementos de UML-RT para OhCircus.\n\nEm nossa estrate?gia de mapeamento, o destino da traduc?a?o e? uma especificac?a?o em\nCircus que possui o significado do modelo original. Classificadores de UML-RT com um\ncomportamento associado (ca?psulas e protocolos) sa?o mapeados em processos, e portas\nem canais.\n\nComo mencionado anteriormente, o mapeamento de classes ja? foi considerado por\ndiversos autores [12, 29, 10], e esta? fora do escopo deste trabalho. Assumimos que classes\nem UML podem ser mapeadas diretamente em classes de OhCircus, como exposto em [10].\nAle?m disto, assumimos um modelo em UML-RT mais concreto, onde associac?o?es sa?o\ndiretamente interpretadas como atributos de classe, e invariantes devem ser locais ao\nescopo da classe. Apesar destas considerac?o?es serem decididas somente durante o projeto\ndo modelo, a antecipac?a?o dessas deciso?es sa?o comumente realizadas na concretizac?a?o do\nmodelo e sa?o justificadas atrave?s de refinamentos de modelo UML, como apresentado\nem [10].\n\nAqui somente associac?o?es unidirecionais sa?o utilizadas, indicando um atributo da\nclasse, e na?o relacionamentos entre todas as insta?ncias da classe. Assim, restric?o?es sobre\nestas associac?o?es sa?o confinadas dentro dos invariantes de classe (ou ca?psula). Ale?m\ndisto, invariantes podem incluir somente refere?ncias para varia?veis no escopo da classe\n(ou ca?psula), descrita por atributos da classe (ou ca?psula) ou por atributos de classes\nacessados via navegac?a?o.\n\nConsideramos tanto uma visa?o intensional quanto extensional do modelo. A visa?o\nintencional e? mapeada diretamente nos elementos sinta?ticos de UML-RT. A visa?o exten-\nsional e? implicitamente definida pelo diagrama de estrutura de suas ca?psulas; eles conte?m\no conjunto de todas as insta?ncias de ca?psulas. Para lidar com a sua estrutura hiera?rquica\nem Circus, assumimos que todas as insta?ncias de ca?psulas, portas e conectores te?m um\nu?nico nome no modelo.\n\nIniciamos o mapeamento a partir dos protocolos do modelo, e , em seguida, a ca?psula\nque representa todo o sistema; incrementalmente, cada componente de ca?psula e? mapeado\npara Circus, seguindo uma apresentac?a?o top-down. No exemplo de automac?a?o industrial\n(Figura 2.2), a ca?psula mais externa e? ProdSys.\n\nQuando mapeamos elementos declarados em uma lista (como os sinais de um pro-\ntocolo, e atributos e me?todos de uma ca?psula), por convenc?a?o destacamos um de seus\nelementos, apresentamos seu mapeamento, e invocamos uma meta-func?a?o (TL()) para\ntraduzir os outros elementos da lista. Por simplicidade, assumimos que TL() e? sobrecar-\nregada (overloaded ), para cada tipo de lista (atributos, me?todos, sinais, portas, insta?ncias\nde ca?psula). Na pra?tica, obviamente, cada lista de elementos pode ser vazia, pore?m evi-\ntamos este caso trivial, assumindo que ela possui pelo menos um elemento.\n\n\n\n3.2 mapeamento 30\n\n3.2.1 Mapeamento estrutural\n\nUma declarac?a?o de um protocolo em UML-RT encapsula definic?o?es de elementos de\ncomunicac?a?o (sinais) e um comportamento de controle (diagrama de estados). Em Oh-\nCircus, isto gera dois elementos: um processo sem estado que captura o comportamento\ndo protocolo e um canal para representar os elementos de comunicac?a?o. Em relac?a?o aos\nsinais, um poss??vel mapeamento poderia ser feito introduzindo-se um canal para cada um\ndos sinais do protocolo. Ao inve?s disto, no?s utilizamos um u?nico canal para comunicar\ntodos os sinais de um protocolo. Este canal comunica valores de um tipo enumerado,\nonde cada um de seus construtores representa um sinal. Utilizar um u?nico canal facilita\no mapeamento de ca?psulas apresentado a seguir. Por exemplo, quando nos referimos\naos sinais envolvidos em uma sincronizac?a?o ou mudanc?a de nome (renaming), e? mais\nconveniente utilizar um u?nico canal.\n\nTP ::= i ?T (I) ?| o | TL(incomes) | TL(outgoings)\nchannel chanP : TP\nprocess P =? begin \u2022H(SP) end\n\nO protocolo P e? mapeado no processo de mesmo nome e no canal chanP. Em nomes\ncom ??ndice subscrito, como chanP acima, no?s assumimos que P e? um nome que devera?\nser substitu??do pelo nome do protocolo sendo mapeado. Desta forma, o mapeamento do\nprotocolo STO no estudo de caso (Figura 2.2) gera um canal correspondente chanSTO.\nO canal chanP comunica valores de tipo enumerado TP; cada valor representa um sinal.\nSinais sem para?metros, como o sinal de sa??da o acima, sa?o traduzidos em constantes;\nsinais parametrizados sa?o mapeados em construtores de tipos de dados (como i). O tipo\ndo para?metro e? traduzido em seu tipo correspondente em OhCircus pela func?a?o T (). Os\nsinais restantes (incomes e outgoings) sa?o mapeados pela func?a?o TL(), como previamente\nexplicado.\n\nO comportamento do protocolo P e? representado por H(SP), onde SP representa o\nestado que encapsula todos os outros estados do diagrama de estados de P. Note que,\napesar do diagrama de estados de um protocolo poder ser sempre representado por um\nestado S0, preferimos destacar todo o comportamento de P em um subestado SP, onde\no comportamento de H(S0) e? equivalente ao de H(SP). A func?a?o H(), que traduz um\ndiagrama de estados em ac?o?es de OhCircus, e? definida na Sec?a?o 3.2.2.\n\nEm nosso exemplo da Figura 2.2, o mapeamento do protocolo STO possui o formato\na seguir. O comportamento do protocolo e? definido pelo processo homo?nimo P e seus\nelementos de comunicac?a?o (sinais) sa?o definidos pelo canal chanSTO que comunica valores\ndo tipo enumerado TSTO, explicado anteriormente na Sec?a?o 3.1.1. A ac?a?o principal de\nSTO e? expressa pela aplicac?a?o da func?a?o H ao seu estado mais externo S0.\n\nTSTO ::= req | output ?T (Piece) ?\nchannel chanSTO : TSTO\nprocess STO =? begin \u2022H(S0) end\n\n\n\n3.2 mapeamento 31\n\nCa?psulas sa?o definidas tambe?m como processos, com me?todos definidos em esquemas\nde operac?o?es e atributos mapeados em esquemas de estado em Z (o estado do processo).\nCada porta gera um canal com o mesmo tipo de dados do canal correspondente ao seu\nprotocolo, e tem seu comportamento descrito pelo processo obtido do mapeamento de\nseu protocolo sincronizado com o obtido do diagrama de estados da ca?psula. Observe\nque, em UML-RT, o tipo de uma porta e? o pro?prio protocolo. Em OhCircus, o tipo de\num canal originado por uma porta e? um tipo enumerado que representa seus sinais (como\nexplicado no mapeamento de protocolos).\n\nchannel p : TP; TL(ports); TL(ports?)\nprocess ChartC =? begin\n\nstate Cstate =? [a : T (A); TL(atts) | InvC]\nm =? [?Cstate ; x : T (X);\n\nTL(params) | Prem ? Postm]\nTL(meths)\n\u2022H(Sc)\n\nend\n\nNo mapeamento acima, o processo ChartC lida com as viso?es representadas pelos\ndiagramas de classe e estado, encapsulando todas as ac?o?es que manipulam os atributos\nprivados da ca?psula C. Na ca?psula C acima, os compartimentos correspondem a? listas\nde atributos, me?todos e portas. Enta?o, a, m e p sa?o aqueles que destacamos. O atributo\na e? mapeado para um atributo do estado de ChartC com seu tipo correspondente em\nOhCircus, dado por T (A); os outros atributos atts sa?o mapeados pela func?a?o TL(), como\nexplicado previamente. O invariante InvC se origina da nota em UML-RT no contexto\na? esquerda, e assume-se que este ja? esteja descrito em OhCircus. O me?todo m() e?\nmapeado para uma operac?a?o que pode modificar qualquer componente do estado, e cujos\npara?metros sa?o mapeados em atributos do esquema. Como o invariante InvC, assume-se\nque a pre?- e a po?s-condic?a?o Prem e Postm sejam escritas em OhCircus(ver Sec?a?o 2.3).\nSimilarmente a func?a?o TL() mapeia os outros me?todos meths. A porta p e? mapeada\npara um canal com o mesmo tipo TP do canal ChanP utilizado pelo protocolo P. A ac?a?o\nprincipal de ChartC e? expressa por H(SC), que representa o mapeamento dos diagramas\nde estado da ca?psula C, definido na Sec?a?o 3.2.2\n\nEm nosso exemplo da Figura 2.2, o mapeamento da ca?psula SysProd e? representado\npelo processo ChartSysProd. Definido por um estado com um u?nico componente p, uma\noperac?a?o process que realiza um processamento qualquer em p e uma ac?a?o principal, que\n\n\n\n3.2 mapeamento 32\n\nsera? exibida na Sec?a?o 3.2.2.\n\nchannel pi, mo : TSTO\nchannel po, mi : TSTI\nprocess ChartSysProd =? begin\n\nstate SysProdstate =? [p : Piece]\nprocess =? [?SysProdstate | ? i ? ran p?.data | i 6= 0 \u2022 p.data(i) = fat(i)]\n...\n\u2022H(S0)\n\nend\n\nDe fato, a declarac?a?o dos atributos e me?todos de SysProd sa?o bastantes simples,\na complexidade maior desta ca?psula se encontra em seu diagrama de estrutura. Um\nmapeamento mais elaborado da declarac?a?o dos me?todos e atributos da ca?psula Storage\npodem ser encontrados na Sec?a?o 3.1.1.\n\nPara a formalizac?a?o de ca?psulas, precisamos considerar tambe?m diagramas de estru-\ntura. O mapeamento que lida com a visa?o correspondente a este diagrama, representa\no comportamento observado por C considerando as restric?o?es impostas pelo comporta-\nmento de suas portas aos seus respectivos canais de comunicac?a?o. E? necessa?rio considerar\ntambe?m, em paralelo, o comportamento de todas as ca?psulas conectadas a sua estrutura.\n\nchannel k : TP; TL(cons)\nchanset cc =? {| k |}?{|cons|}\nchanset hchan =? cc ?{|ports? |}?{|portsB |}?{|portsCap |}\nprocess StructC =? ((ChartC |[ cc ]| (P[chanP := k] |[ cc]|\n\n(TL(ports) |[ cc ]| TL(ports?)))) |[ cc]|\n((StructCin[q, portsCin := k, cons]) |[ cc]|\nTL(cal )))[k, cons := p, ports] \\ hchan\n\nNo processo (StructC), o comportamento de ChartC e? sincronizado com o comporta-\nmento de todas as portas da ca?psula C; destacamos aqui a porta p, cujo comportamento\ne? representado pelo processo P. O canal chanP utilizado por P necessita ser renomeado\ncom o nome do conector (k) que liga a porta p a outras portas no sistema. As outras\nportas sa?o similarmente mapeadas atrave?s da func?a?o TL(). No?s destacamos o compo-\nnente de ca?psula b (do tipo B) da lista dos outros componentes Cal, que tem o nome de\ntodas as suas portas pu?blicas (q e portsB) alterados para o das conexo?es associadas a eles\n(k e cons); portsB representa a lista de portas pu?blicas de B. Apo?s paralelizar todos os\ncomponentes no diagrama de estrutura C, uma func?a?o injetiva e? necessa?ria para alterar o\nnome de conexo?es a?s portas pu?blicas associadas a elas ([m, cons := p, ports]). Ale?m disto\ne? necessa?rio esconder os canais associados a conexo?es, portas protegidas de C, e portas\npu?blicas de B e de Cal, vis??veis somente no diagrama de estrutura de C.\n\nEm nosso exemplo da Figura 2.2, o mapeamento do diagrama de estrutura da ca?psula\nSysProd e? representado por um processo StructSysProd.\n\n\n\n3.2 mapeamento 33\n\nchannel k, m : TSTI\nchannel l, n : TSTO\nchanset cc =? {| k, m, l, n |}\nchanset hchan =? cc ?{| pi, po|}\nprocess StructSysProd =? (ChartSysProd[pi, po := l, m] |[ cc ]| STI[chanSTI := k] |[ cc]|\n\nSTI[chanSTI := n] |[ cc ]| STO[chanSTO := l] |[ cc]|\nSTO[chanSTO := m] |[ cc ]| StructStorage[si, so := k, l] |[ cc]|\nStructStorage[si, so := m, n])[k, n := mi, mo] \\ hchan\n\nO processo StructSysProd e? composto pelo paralelismo de ChartSysProd, dos processos que\nrepresentam suas portas e daqueles que representam suas subca?psulas, sincronizados nos\ncanais associados a?s conexo?es internas de SysProd (k, m, l, n ). No processo ChartSysProd, as\nportas pi e po sa?o renomeadas nas conexo?es l e m, respectivamente. As portas pi, po, mi\ne mo de SysProd sa?o representadas pelos processos STI[chanSTI := k], STI[chanSTI := n],\nSTO[chanSTO := l] e STO[chanSTO := m], respectivamente; cada um deles formados pelo\nrespectivo processo do protocolo relativo a? porta e renomeados pelas conexo?es associadas\na ela. As subca?psulas sin e son sa?o representadas pelos processos StructStorage[si, so := k, l]\ne StructStorage[si, so := m, n] respectivamente; estes sa?o formados pelo processo associado\na ca?psula Storage (da qual sa?o insta?ncias), renomeada pelos respectivos canais de suas\nconexo?es no diagrama SysProd.\n\nDevido a representarmos conexo?es entre portas atrave?s da sincronizac?o?es entre pro-\ncessos, necessitamos assumir que portas devem estar conectadas entre si no menor n??vel\nde estrutura que as contenha. Na realidade, esta suposic?a?o e? uma boa pra?tica de projeto\npois evita indirec?o?es e reduz a complexidade do modelo. Na Figura 3.3, as insta?ncias de\nca?psulas b e c devem ser conectadas no menor n??vel de estrutura em StrM que os conte?m,\nneste caso o diagrama de estrutura de A.\n\nFigura 3.3. Exemplo de uma pra?tica correta (a esquerda) e uma errada (a direita) da conexa?o\nde subca?psulas\n\nNa Figura 3.3, o mapeamento das subca?psulas B e C do contexto a? esquerda teria o\nformato (StructB[q := k]) |[ k ]| (StructC[p := k]), enquanto o contexto do lado direito teria\numa formato semelhante ao (StructB[q := q\n\n?] |[ k ]| StructC[p := p?])[q, q? := k, k]. Como\na func?a?o [q, q? := k, k] na?o e? injetiva (as duas portas sa?o renomeadas em uma mesma\nporta), ela na?o distribui pelo operador de paralelismo (Ver Lei B.1, no Ape?ndice B) e\ndifere o comportamento do mapeamento dos dois contextos (apesar de em UML-RT eles\npossu??rem um mesmo comportamento).\n\nDiferentemente de ca?psulas e protocolos, classes sa?o mapeadas em classes em OhCir-\ncus. Estas classes tem o mapeamentos de seus elementos semelhante ao mapeamentos\nde atributos e me?todos de uma ca?psula, definidos como para?grafos em Z.\n\n\n\n3.2 mapeamento 34\n\nclass A =? begin\nstate Astate =? [b : T (B); TL(aatts) | InvA]\nm =? [?Astate ; x : T (X);\n\nTL(params) | Prem ? Postm]\nTL(ameths)\n\nend\n\nComo assumimos que classes na?o possui um comportamento expl??cito associado, ne-\ncessitamos apenas mapear a visa?o de uma classe em diagrama de classes em OhCircus.\nNa classe A acima, os compartimentos correspondem a? listas de atributos e me?todos.\nEnta?o, b, m sa?o aqueles que destacamos. O atributo b e? mapeado para um atributo do\nestado de A com seu tipo correspondente em OhCircus, dado pela classe B; os outros\natributos aatts sa?o mapeados pela func?a?o TL(), como explicado previamente. O invari-\nante InvA se origina da nota em UML-RT no contexto a? esquerda, e assume-se que este\nja? esteja descrito em OhCircus. O me?todo m() e? mapeado para uma operac?a?o que pode\nmodificar qualquer componente do estado, e cujos para?metros sa?o mapeados em atributos\ndo esquema. Como o invariante Y, assume-se que a pre?- e a po?s-condic?a?o Prem e Postm\nsejam escritas em OhCircus. Similarmente a func?a?o TL() mapeia os outros me?todos\nameths.\n\n3.2.2 Mapeamento comportamental\n\nNosso mapeamento dos diagramas de estado de ca?psulas e protocolos em OhCircus\ne? baseado no trabalho reportado em [69], que apresenta a formalizac?a?o de diagramas de\nestado em CSP. No entanto, e? necessa?rio estende?-lo para considerar ac?o?es de OhCircus,\nlidar com paralelismo (And-States) e estados compostos com mu?ltiplos pontos iniciais.\n\nSeja M uma ma?quina de estados e SM o conjunto de estados de M . O conjunto de\neventos de M e? denotado por EM , e suas ac?o?es e guardas booleanas por AM e GM , res-\npectivamente. Ale?m disto, SIM denotara? o conjunto de estados inicias, SChM o conjunto\nde estados de escolha, SSM o conjunto de estados simples e SCoM o conjunto de estados\ncompostos de SM .\n\nComo um diagrama de estados pode ser identificado como um estado composto que\nconte?m todos os outros, seu mapeamento de estados pode ser visto como o de um u?nico\nestado. Assim, podemos indicar este mapeamento por uma func?a?o H que leva um estado\na sua representac?a?o em OhCircus.\n\nH : SM ? CSPAction\n\nNo?s assumimos que uma ac?a?o em AM e? expressa por uma chamada de me?todos,\ne, portanto, na?o precisa ser traduzida. Como outros predicados, guardas em AM sa?o\nescritas utilizando a sintaxe de OhCircus. Como portas possuem um canal associado em\nOhCircus com o seu nome, e sinais sa?o expressos pelos valores do tipo destes canais, um\nsinal e de uma porta p pode ser diretamente escrito pelo casamento de padra?o de eventos\nem OhCircus identificado, correspondente ao sinal e.\n\n\n\n3.2 mapeamento 35\n\nCada padra?o aplicado a? func?a?o de mapeamento de estados H(\u00b7) gera um equac?a?o\ndistinta. No lado esquerdo de cada equac?a?o, ilustramos o padra?o de aplicac?a?o como um\ntemplate para um tipo de estado espec??fico.\n\nNossa primeira traduc?a?o corresponde ao estado inicial. Este possui somente uma\ntransic?a?o de sa??da, e nenhuma ac?a?o de entrada ou sa??da. Da??, seja Ai um estado inicial,\ncom Ai ? SIM , act() a ac?a?o de sua transic?a?o de sa??da, e A1 o destino desta transic?a?o,\nenta?o:\n\nH(Ai) = act(); H(A1)\n\nPara um estado de escolha, a traduc?a?o e? como segue. Seja Ac um estado de escolha,\ncom Ac ? SChM , que tem somente duas transic?o?es e uma guarda g (estas transic?o?es na?o\npossuem evento e sa?o disparadas de acordo com a avaliac?a?o de g), enta?o:\n\nH(Ac) = (g &amp; act1(); H(A1)) u (\u00ac g &amp; act2(); H(A2))\n\nEm relac?a?o a um estado simples, sua traduc?a?o corresponde a? ac?a?o de processo abaixo.\nSeja As um estado simples, com As ? SSM , AC o estado composto que o conte?m, com\nAC ? SCOM , tls sua lista de transic?o?es de sa??da e p.e[g]/act() uma das transic?a?o destacada\ndesta lista, enta?o:\n\nH(As) = entryAs(); ((g &amp; p.e ? exitAs(); act(); H(A1))\n2 ((noteventAC ? exitAs(); exiteventAC ? SKIP )\n2 TL(tls)))\n\nQuando o estado As e? ativado, ele executa a ac?a?o de entrada entryAs() e espera por\num novo sinal oriundo do ambiente (a escolha externa captura esta decisa?o). Destacamos\naqui a transic?a?o disparada pelo sinal e da porta p, dentre a lista de transic?o?es tls. O\nevento p.e e? executado somente quando sua guarda g for satisfeita. Caso isto ocorra, a\nac?a?o de sa??da exitAs() e a ac?a?o act() associada a? transic?a?o disparada, sa?o executadas, e\no estado A1 torna-se ativo. Ale?m de esperar por sinais que disparem suas transic?o?es de\nsa??da, um estado simples pode ficar inativo pelo disparo de uma transic?a?o de sa??da (de\ngrupo) do estado composto que o conte?m; neste caso, um evento de notificac?a?o noteventAC,\nonde AC representa o estado composto, e? disparado para garantir que a ac?a?o de sa??da de\nAs seja executada antes da ac?a?o de sa??da de AC. Apo?s a execuc?a?o da ac?a?o de sa??da de\nAs, um evento exiteventAC e? enviado, permitindo que a ac?a?o de sa??da do estado AC seja\nexecutada.\n\nPara mapear estados compostos, e? necessa?rio apenas a apresentac?a?o da traduc?a?o\nde um estado composto do tipo And-State. Como suas regio?es concorrentes sa?o dadas\npela composic?a?o sequ?encial de estados (tal qual um Or-State), a traduc?a?o de um estado\ncomposto do tipo Or-State pode ser visto por um And-State com uma u?nica regia?o. Seja\n\n\n\n3.2 mapeamento 36\n\nAC e EAC estados compostos pertencentes a? SCOM , onde EAC e? o estado composta que\nconte?m AC e AC um And-State com as seguintes regio?es r1 e r2, Ai1 e Ai2 ? SIM os estados\niniciais das regio?es de AC, A1 e A2 ? SM estados contido em EAC, e [R] uma func?a?o\nde renomeac?a?o que substitui um canal associado a uma porta a? um canal associado a\nconexa?o que esta porta esta? conectada, enta?o:\n\nH(AC) = entryAC(); (H(Ai1)[R] |[ Cstate1 | cc | Cstate2]|\nH(Ai2)[R] |[ Cstate1 ? Cstate2 | cc | Cstate3]|\n\n2 (g1 &amp; p1.e1 ? noteventAC ? exiteventAC ? exitAC();\nact1(); H(A1))\n\n2 (TL(tls))\n2 (g2 &amp; p2.e2 ? exiteventAC ? exitAC(); act2(); H(A2))\n2 (noteventEAC ? noteventAC ? exiteventAC ? exitAC();\n\nexiteventEAC ? SKIP ))\n\nQuando o And-State AC e? ativado, ele executa a ac?a?o de entrada entryAC(), e depois\no estado inicial de cada uma de suas regio?es. Para que as regio?es r1 e r2 sincronizem\nadequadamente suas ac?o?es, e? necessa?rio renomear os canais associados a?s portas conec-\ntadas em StrM pelos canais em cc correspondentes a suas conexo?es, atrave?s da func?a?o\nR. Assim sinais de sa??da de uma regia?o podem ser sincronizados a? sinais de sa??da de\noutra. Assumimos que as ac?o?es dos estados r1 e r2 podem modificar somente valores de\nvaria?veis em Cstate1 e Cstate2, respectivamente, enquanto a ac?a?o de sa??da e as associadas a?s\ntransic?o?es de sa??da de state2 modificam somente valores de varia?veis em state3. O estado\nda ca?psula conte?m a unia?o de Cstate1, Cstate2 e Cstate3. E a qualquer momento, o estado\nAC pode receber um evento externo e interromper os subestados de r11 e r2, deixando-os\ninativos.\n\nUm estado composto pode ficar inativo de tre?s formas: atrave?s de uma transic?a?o de\nsa??da com origem no pro?prio (transic?o?es de grupo), com origem em um de seus subestados,\nou com origem em um de seus superestados. Nos dois primeiros casos, o comportamento\nassociado a? transic?a?o e? descrito em AC, enquanto no u?ltimo este comportamento e? descrito\nem EAC. E em todos eles, eventos de notificac?a?o sa?o criados para garantir que a ordem\nde execuc?a?o das ac?o?es de sa??da dos estados seja realizada do estado mais interno ao mais\nexterno, que conte?m os demais. A lista de transic?o?es localizadas no dois primeiros casos\ne? representada aqui por tls, onde foram destacadas aquelas disparadas pelos sinais p1.e1\ne p1.e1, respectivamente, para o primeiro e o segundo caso.\n\nQuando o estado AC recebe o evento p1.e1 e avalia a guarda g como verdadeira, um\nevento noteventAC e? enviado para solicitar que todos os subestado ativos executem suas\nac?o?es de sa??da. Quando uma notificac?a?o exiteventAC chega, a ac?a?o de sa??da de AC e?\nfinalmente executada, seguida pela ac?a?o act1 da transic?a?o. Apo?s este conjunto de ac?o?es,\no estado A1 torna-se enta?o ativo. Transic?o?es que emanam de um subestado, atrave?s\nde um ponto de junc?a?o de AC se comportam de forma similar. Este tipo de junc?a?o\ne? mapeado como um subestado transiente final de AC, e, portanto, na?o possui qualquer\nac?a?o associada. Assim, AC na?o necessita esperar pela execuc?a?o de qualquer ac?a?o de sa??da,\ne na?o precisa lidar com o evento noteventAC. No entanto o evento exiteventAC e? necessa?rio\n\n\n\n3.2 mapeamento 37\n\npara sincronizar com este pseudo-estado de sa??da de AC. Para um ponto de junc?a?o F ,\nsua traduc?a?o corresponde a H(F ) = exiteventAC ? SKIP . As outras transic?o?es de sa??da\nde AC em tls podem ser similarmente traduzidas pela func?a?o TL(tls), que mapeia a lista\ntls de transic?o?es da mesma similar a? transic?o?es disparadas pelos eventos p1.e1 e p1.e1, que\ndestacamos aqui.\n\nAssim como estados simples, estados compostos podem estar inclusos dentro de outros\nestados compostos; no contexto anterior, AC e? um subestado de EAC. Nesta situac?a?o, AC\npode a qualquer momento receber uma notificac?a?o noteventEAC indicando a ocorre?ncia\nde uma transic?a?o de sa??da em EAC. Quando este evento e? recebido, AC precisa enviar o\nevento noteventAC para seus subestados ativos a fim de que eles executem suas ac?o?es de\nsa??da antes de sua pro?pria ac?a?o (exitAC). Quando AC receber exiteventAC, a ac?a?o exitAC\ne? executada, e enta?o exiteventEAC e? enviado para que EAC execute sua pro?pria ac?a?o de\nsa??da.\n\nEm nosso exemplo da Figura 2.2, o mapeamento do comportamento do protocolo STO\nsera? definido por um processo homo?nimo, cuja ac?a?o principal e? dada pelo mapeamento\ndo estado S0, que conte?m todos os outros.\n\nprocess STO =? begin\nSb =? chanSTO.req ? Sc\nSc =? chanSTO.output ? Sa\n\u2022 Sb\n\nend\n\nNa ma?quina de estados de um protocolo, na?o encontramos ac?o?es ou guardas, sendo\nrepresentado apenas pela ordem dos eventos no canal associados a ele, que em STO e?\nrepresentado por chanSTO. Como podemos notar, a? excec?a?o do estado inicial, cada um\ndos estados de STO e? representado por uma para?grafo no corpo do processo (Sb e Sc). A\nac?a?o principal de STO (\u2022 Sb) e? igual ao comportamento correspondente ao mapeamento\ndo estado inicial STO, cuja transic?a?o tem como destino o estado Sb.\n\nDiferentemente de protocolos, as ma?quinas de estados de ca?psulas possuem ac?o?es e\nguardas, como e? visto no mapeamento associado a? ac?a?o principal de ChartSysProd (abaixo)\ne ChartStorage (ver Sec?a?o 3.1.1) .\n\n...\nSp =? pi?output.x ? p = x; process(); po!input.x; Sp\n\u2022 pi.req ? Sp\n\nNa ac?a?o principal de ChartSysProd, pi.req correspondente a? ac?a?o da transic?a?o inicial\nde SysProd, que possui como destino o estado Sp. Este estado e? representado por um\npara?grafo de mesmo nome e oferece um u?nico evento pi?output.x, o qual dispara a u?nica\ntransic?a?o de Sp em SysProd. A ac?a?o executada apo?s este evento e? a mesma descrita na\nFigura 2.2, que utiliza uma notac?a?o semelhante para a chamada de me?todos e o envio de\nsinais.\n\nComo desejamos neste trabalho um mapeamento puramente sinta?tico, na?o lidamos\ncom histo?ria em estados. Ja? que para isto dever??amos atribuir varia?veis a todos estados\n\n\n\n3.3 concluso?es 38\n\ncompostos do modelo, criando uma representac?a?o sema?ntica de cada um deles. Esta\nvaria?vel seria utilizada para guardar a u?ltima configurac?a?o de subestados ativos antes\nque uma transic?a?o de sa??da fosse disparada. Assim, quando um estado composto se\ntornasse ativo novamente, essa configurac?a?o seria restaurada.\n\n3.3 CONCLUSO?ES\n\nAtrave?s do mapeamento de UML-RT para OhCircus, possibilitamos a atribuic?a?o de\numa sema?ntica a UML-RT atrave?s de sua integrac?a?o com uma notac?a?o formal. Como con-\nsequ?e?ncia, podemos provar propriedades de um modelo em UML-RT atrave?s de demons-\ntrac?o?es de sua especificac?a?o em OhCircus, e, portanto, a preservac?a?o de comportamento\nde um modelo durante a aplicac?a?o de leis transformac?a?o em UML-RT.\n\n\n\nCAPI?TULO 4\n\nLEIS DE TRANSFORMAC?A?O PARA UML-RT\n\nNeste cap??tulo, focamos em leis de transformac?a?o que expressam pequenas reestruturac?o?es\nde um modelo em UML-RT, sem que haja alterac?a?o do comportamento do sistema mo-\ndelado. Particularmente, concentramo-nos nos elementos adicionais que UML-RT adici-\nona a UML (ca?psulas, protocolos e portas) e em seus relacionamentos, complementando\nassim outros trabalhos que lidam somente com elementos de UML (como classes e inter-\nfaces) [41, 30, 38]. Observe que como ca?psulas na?o compartilham classes, e que como a\ncomunicac?a?o entre ca?psulas e classes e? atrave?s da chamada de me?todos, transformac?o?es\nnum modelo de classes, sem mudar suas interfaces com as ca?psulas a que dependem, sa?o\nlivremente permitidas.\n\nFocamos, principalmente, em leis que envolvem as viso?es relacionadas a? declarac?a?o\nde elementos do modelo e a? configurac?a?o de sua arquitetura, representados pelos dia-\ngramas de classe e estrutura. Ale?m disto, algumas leis relacionadas a? declarac?a?o do\ncomportamento de elementos (leis para diagramas de estado) sa?o exibidas, pore?m em\numa quantidade necessa?ria para descrevermos a abrange?ncia de nossas leis quanto as\nduas viso?es citadas; esta abrange?ncia sera? discutida no Cap??tulo 5.\n\nAlgumas transformac?o?es ba?sicas (criac?a?o, remoc?a?o ou alterac?a?o de elementos) sa?o re-\nalizadas, usualmente, em elementos isolados do modelo. Outras transformac?o?es sa?o uti-\nlizadas para substituir elementos. Assim, noc?o?es de equivale?ncia, extra??das da sema?ntica\nde OhCircus, permitem que as leis lidem simultaneamente com os aspectos esta?ticos e\ndina?micos do modelo, preservando o comportamento observado, atrave?s de mudanc?as em\nseus diagramas de classe, estado e estrutura.\n\nA raza?o para lidarmos com diagramas de estrutura e? porque eles representam in-\nterac?o?es entre ca?psulas que na?o sa?o expressas por outros diagramas; por isto, eles devem\nser considerados para que o comportamento global do sistema gerado seja preservado.\n\nInicialmente, apresentamos algumas leis ba?sicas (Sec?a?o 4.1) que sa?o usadas em se-\nguida para justificar leis mais elaboradas (Sec?a?o 4.2). A partir da composic?a?o destas leis\nba?sicas, e? poss??vel criar transformac?o?es utilizadas usualmente durante a ana?lise e projeto\ndo sistema, como refactorings. Apesar de nosso propo?sito maior ser a sistematizac?a?o do\ndesenvolvimento em UML-RT, utilizando transformac?o?es de modelo, a partir do mape-\namento de modelos em UML-RT para OhCircus (Cap??tulo 3) obtemos o benef??cio de\nutilizar uma sema?ntica formal, bem como leis de refinamento de OhCircus, para provar a\ncorretude de algumas das leis de transformac?a?o apresentadas neste cap??tulo (Sec?a?o 4.3).\n\n4.1 LEIS BA?SICAS\n\nCada lei e? definida por uma equac?a?o, onde os termos descrevem o contexto dos ele-\nmentos do modelo antes e apo?s a aplicac?a?o da lei. A aplicac?a?o de uma lei pode ser feita\n\n39\n\n\n\n4.1 leis ba?sicas 40\n\nem qualquer um dos sentidos (partindo-se do termo da esquerda ou da direita), pore?m\nobedecendo-se as condic?o?es impostas para aplicac?a?o da lei no sentido desejado.\n\nA relac?a?o entre os dois termos e? representada na lei por uma relac?a?o de equivale?ncia\nde modelos (uma seta bidirecional) com um subscrito M, que representa o contexto do\nrestante do modelo. A noc?a?o de equivale?ncia utilizada e? baseada na sema?ntica de OhCir-\ncus, que e? definida na Unifying Theories od Programming [47]. Na realidade, apenas um\nsubconjunto de OhCircus (Circus) tem uma sema?ntica completamente definida. Apesar\ndas leis propostas na?o modificarem M, algumas das leis impo?em condic?o?es sobre algu-\nmas viso?es deste modelo, que por esta raza?o sa?o explicitamente apresentadas durante a\nlei: ClsM representa as declarac?o?es de ca?psulas, protocolos e classes em M, composto por\nseu conjunto de diagramas de classe; StrM simboliza a estrutura (ou a configurac?a?o da\narquitetura) de M, expresso pelos diagramas de estrutura de suas ca?psulas. Um terceira\nvisa?o do modelo, StaM, representa a declarac?a?o do comportamento, isolado, de todas\nas ca?psulas e protocolos do sistema, expresso por suas respectivas ma?quinas de estado.\nApesar de, dinamicamente, estas ma?quinas de estados se comunicarem, de acordo com as\nconexo?es expressas em StrM, elas sa?o independentes entre si. Por esta raza?o, usualmente,\no diagrama de estados de cada um destes elementos sera? explicitamente mostrado nos\ntermos da leis, ao inve?s de recorrermos a StaM; para um elemento A, indicaremos seu\ndiagrama de estados como S0 de A.\n\nDiagramas e anotac?o?es descrevendo propriedades (invariantes, pre?- e po?s-condic?o?es)\ndo modelo sa?o apresentadas nas leis quando necessa?rio. Em alguns casos, existe o interesse\nque somente uma parte (auto-contida) destes diagramas seja mostrada; neste caso, uma\nlinha pontilhada na borda dos diagrama e? utilizada. Adicionalmente, relacionamentos\nentre os elementos apresentados no diagrama podem existir, mesmo que na?o explicitados.\n\nLeis relacionadas a? declarac?a?o de elementos, usualmente, sa?o responsa?veis por criar\nnovos elementos em um modelo UML-RT. Em geral, elas possuem como condic?a?o para\na introduc?a?o de um elemento (aplicac?a?o da esquerda para a direita da lei) que este na?o\npossua o mesmo nome de outro elemento ja? utilizado no modelo, e para a remoc?a?o de\num elemento (aplicac?a?o da direita para esquerda) que o elemento na?o seja utilizado pelo\nrestante do modelo.\n\nA primeira lei estabelece quando e? poss??vel introduzir uma nova ca?psula ao modelo.\nObserve que apesar do contexto no lado esquerdo da lei estar vazio, o M subscrito fixa o\ncontexto para aplicac?a?o da lei.\n\nLei 4.1 Declarar Ca?psula\n\nCondic?o?es:\n\n(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado A.\n\n\n\n4.1 leis ba?sicas 41\n\n(?) Nenhuma ca?psula em M tem uma relac?a?o com a ca?psula A em qualquer diagrama.\n\nUsamos o s??mbolo (?) antes de uma condic?a?o para indicar que ela e? requerida somente\npara aplicac?o?es da lei da esquerda para a direita. Similarmente, utilizamos (?) para\nindicar que a condic?a?o e? necessa?ria somente para aplicac?o?es da lei da direita para a\nesquerda, e usamos (?) para indica que a condic?a?o e? necessa?ria em ambas as direc?o?es.\n\nA condic?a?o para remover a ca?psula A (aplicac?a?o da lei da direita para esquerda) e?\nque nenhuma outra estende, tem uma associac?a?o em ClsM ou e? conectada com ela em\nStrM. Em relac?a?o a? aplicac?a?o da lei da esquerda para a direita, ja? que em UML (e, por\nsua vez, em UML-RT) na?o e? permitido que dois elementos possuam o mesmo nome em\num mesmo pacote (contexto local), existe uma condic?a?o expressando que a declarac?a?o de\nnova ca?psula em StrM deve possuir sempre um novo nome no modelo. Assumimos que\natts, meths e ports representam, respectivamente, os conjuntos de atributos, me?todos e\nportas da ca?psula.\n\nNas duas direc?o?es de aplicac?a?o da lei, a ca?psula A na?o esta? associada a nenhuma outra\nno modelo, portanto, a apresentac?a?o do diagrama de estrutura e o de estados e? irrelevante.\nNa realidade, estes diagramas podem possuir qualquer conteu?do, que obedec?a a?s condic?o?es\nda lei.\n\nApesar de sua simplicidade, esta lei e? bastante importante, ja? que uma ca?psula so?\npode fazer parte da arquitetura do sistema modelado, caso ela tenha sido declarada pre-\nviamente. Semelhante a? Lei 4.1, as leis C.1 e C.2 apresentadas no Ape?ndice C capturam\na introduc?a?o de protocolos e classes em ClsM.\n\nA pro?xima lei estabelece quando podemos adicionar ou remover uma associac?a?o entre\nca?psulas. Assumimos que, quando uma ca?psula A e? criada, e? criado tambe?m seu diagrama\nde estrutura; este diagrama conte?m as insta?ncias de todas as ca?psulas com as quais A\npossui uma associac?a?o.\n\nLei 4.2 Introduzir Associac?a?o Ca?psula-Ca?psula\n\nCondic?o?es:\n\n(?) Na?o existe outra insta?ncia de ca?psula chamada b no diagrama de estrutura de A.\n(?) A insta?ncia b da ca?psula B na?o esta? conectada a nenhuma outra na estrutura de A,\n\ninclusive a? insta?ncia a que a conte?m.\n\n\n\n4.1 leis ba?sicas 42\n\nNa Lei 4.2, a aplicac?a?o da esquerda para a direita gera como resultado uma associac?a?o\nentre as ca?psulas A e B. Como consequ?e?ncia, uma nova insta?ncia de B e? criada no\ndiagrama de estrutura de A, em qualquer contexto de StrM onde uma insta?ncia a de A\naparec?a. Nesta lei, o conjunto de portas aports e bports sa?o representados por portas\nmu?ltiplas em StrM; na realidade, estes conjuntos podem possuir uma ou mais portas\ndistintas com diferentes cardinalidades e tipos. Pode ainda haver conexo?es envolvendo as\nportas de A e B, na?o explicitado na lei.\n\nRelativo a? sema?ntica de um ca?psula isolada em StrM, esta e? vista como processo em\nOhCircus que na?o comunica com nenhum outro na especificac?a?o e que possivelmente\nestara? sempre bloqueada. Como o comportamento de ca?psulas e? descrito por ma?quinas\nde estado que na?o possuem um estado final, um sistema em UML-RT e? representado\nem OhCircus por um processo que nunca termina, e que, por esta raza?o, na?o tera? seu\ncomportamento alterado pela inserc?a?o de uma nova ca?psula isolada do restante do modelo.\n\nA pro?xima lei estabelece quando e? permitido adicionar ou remover me?todos em uma\nca?psula.\n\nLei 4.3 Introduzir Me?todo\n\nCondic?o?es:\n\n(?) Na?o existe um me?todo chamado m em A.\n(?) O me?todo m na?o e? utilizado por outro me?todo em meths, nem tampouco no diagrama de\n\nestados de A, ou em um predicado de A.\n\nA Lei 4.3 e? similar ao refatoramento para adicionar me?todos em classe [33], possuindo\nrestric?o?es quanto ao nome do me?todo e quanto ao seu uso. Da direita para a esquerda,\no me?todo m na?o pode ser utilizado por outro me?todo, ac?a?o do diagrama de estados ou\npredicado (invariante, pre?- ou po?s-condic?a?o) de A. Ale?m disto, o padra?o da lei possui\ncomo condic?o?es impl??citas que os tipos de dados D e R ja? existam em M. Note que eliminar\num me?todo de uma ca?psula e? bem mais simples do que de uma classe, pois me?todos em\numa ca?psula sa?o inerentemente privados.\n\nA seguir, e? apresentado um caso espec??fico de uma lei que introduz um atributo em\numa ca?psula, como consequ?e?ncia da criac?a?o de uma associac?a?o da ca?psula com uma\nclasse.\n\nComo outras leis que introduzem novos elementos, a Lei 4.4 possui em suas condic?o?es\nde aplicac?a?o restric?o?es quanto ao nome e ao uso do elemento introduzido (neste caso a\nassociac?a?o b). Assumimos que a introduc?a?o de uma associac?a?o b entre uma ca?psula A e\numa classe B introduz implicitamente um atributo b em A, por esta raza?o a existe?ncia\nde uma condic?a?o que indica que na?o pode haver outro atributo chamados b em A.\n\n\n\n4.1 leis ba?sicas 43\n\nLei 4.4 Introduzir Associac?a?o Ca?psula-Classe\n\nCondic?o?es:\n\n(?) Na?o ha? um atributo chamado b em A.\n(?) O atributo b na?o e? utilizado por nenhum me?todo, diagrama de estados ou predicado de\n\nA.\n\nApesar da Lei 4.4 ser espec??fica para classes, uma lei ana?loga para a introduc?a?o de\natributos (possivelmente de tipos primitivos) pode ser facilmente deduzida a partir dela.\n\nA pro?xima lei estabelece quando podemos adicionar ou remover uma associac?a?o entre\num protocolo e uma ca?psula. Como consequ?e?ncia da introduc?a?o desta associac?a?o, e? criada\numa insta?ncia deste protocolo (porta) na ca?psula.\n\nLei 4.5 Introduzir Associac?a?o Ca?psula-Protocolo\n\nCondic?o?es:\n\n(?) Na?o existe outra porta chamada p na ca?psula A.\n(?) A porta p na?o e? utilizada no diagrama de estados de A; na?o existe conexa?o ligada a p em\n\nStrM.\n\nEm uma visa?o geral, a Lei 4.5 e? similar ao refactoring \u201cAdicionar Atributo\u201d [33];\nportas, apesar de sua declarac?a?o em um compartimento diferente, podem ser vistas como\natributos de uma ca?psula. Por esta raza?o, a lei possui como condic?a?o que na?o pode haver\nduas ou mais portas com um mesmo nome em uma ca?psula. Para se remover uma porta\ne? necessa?rio que esta na?o seja usada no diagrama de estados (assumimos que ac?o?es para\no envio de sinais na?o podem estar localizados em me?todos da ca?psula); nem tampouco\na porta pode ser usada na conexa?o com outras ca?psulas em StrM. Note que portas sa?o\ncriadas como consequ?e?ncia da associac?a?o entre ca?psulas e protocolos, sendo visualmente\nvista tanto no diagrama de classes quanto no diagrama de estrutura; por simplicidade, o\nconjunto de portas ports e? mostrado no diagrama de estrutura como uma porta mu?ltipla.\n\n\n\n4.1 leis ba?sicas 44\n\nDevido a condic?a?o da lei de que a porta p nunca e? utilizada no diagrama de estados de\nA, enta?o a apresentac?a?o deste diagrama e? desnecessa?ria.\n\nA pro?xima lei estabelece quando e? permitido adicionar ou remover sinais de sa??da em\num protocolo.\n\nLei 4.6 Introduzir Sinal de Sa??da\n\nCondic?o?es:\n\n(?) Na?o existe sinal chamado s no protocolo X.\n(?) Nenhum diagrama de estados em StaM usa o sinal s.\n\nSemelhante a? Lei 4.5, a Lei 4.6 possui uma restric?a?o quanto ao uso do nome do novo\nelemento (sinal) em seu contexto local (protocolo) e quanto ao uso deste elemento nos\ndiagramas de estado do modelo. A primeira condic?a?o indica que na?o existe previamente\nnenhum sinal s de entrada ou sa??da em X no modelo do lado esquerdo. A segunda condic?a?o\nindica que o sinal s na?o e? utilizado nos diagramas de estado do protocolo X ou de nenhuma\nca?psula com uma porta de tipo X. Note que apesar de s possuir um para?metro do tipo\nde dado D, este pode ser inclusive void. Em geral, ha? uma condic?a?o impl??cita de que D\ndeve ser um tipo va?lido em ClsM.\n\nApesar do sinal s estar localizado no mesmo compartimento de sinais de sa??da de X,\numa lei ana?loga para um sinal de entrada possui as mesmas condic?o?es que a Lei 4.6. A\nu?nica diferenc?a entre estas leis e? o compartimento de localizac?a?o do sinal, o qual indica o\nseu sentido. A lei para introduzir um sinal de entrada esta? no Ape?ndice C (na Lei C.4).\n\nA pro?xima lei captura o incremento da multiplicidade da associac?a?o entre um proto-\ncolo e uma ca?psula e, consequ?entemente, o respectivo incremento da multiplicidade da\nporta que representa esta relac?a?o.\n\nLei 4.7 Incrementar Multiplicidade da Associac?a?o Ca?psula-Protocolo\n\nCondic?o?es:\n\n(?) O nu?mero de conexo?es em StrM envolvendo a porta p e? inferior a? sua multiplicidade.\n\n\n\n4.1 leis ba?sicas 45\n\nA condic?a?o relativa a? quantidade de conexo?es envolvendo uma porta e? uma restric?a?o\nda pro?pria linguagem UML-RT. A Lei 4.7, apesar de sua simplicidade, e? muito importante\npara sincronizac?a?o de ca?psulas em diagramas de estrutura (Lei 4.8).\n\nA pro?xima lei estabelece quando e? permitido se conectar duas ca?psulas. Apesar de\nsuas similaridades com outras leis, esta lei afeta (exclusivamente) o diagrama de estrutura\ndo modelo.\n\nLei 4.8 Introduzir Conexa?o\n\nCondic?o?es:\n\n(?) A sequ?e?ncia de sinais aceitos por b e c e? inalterada; r e s devem ser insta?ncias de mesmo\num protocolo.\n\n(?) A quantidade de conexo?es ligadas a? r e s e? inferior a multiplicidade destas porta.\n\nA Lei 4.8 indica que duas ca?psulas somente podem ser conectadas se o seu compor-\ntamento for inalterado: a sequ?e?ncia de sinais aceitos por ambas as ca?psulas (sinais que\ndisparam suas transic?o?es), atrave?s das portas r e s, na?o deve ser mudada. A linha ponti-\nlhada em StrM indica que nada e? dito quanto a?s conexo?es das portas r e s com o restante\ndo modelo, ambas podendo, portanto, possuir conexo?es com outras ca?psulas em StrM.\nNote a condic?a?o quanto a? sequ?encia de sinais atrave?s de b e c e? uma condic?a?o dina?mica,\ne que na?o pode ser verificada sintaticamente. Para a insta?ncia de ca?psula a, temos que\nverifica se todos os sinais provenientes da porta s de b, que sejam aceitos por a, sejam\nsincronizados com outra ca?psula c? no modelo, de forma que o paralelismo de c? com b\nsincronizada em r e? equivalente a c?; o mesmo acontece para insta?ncia de ca?psula b e os\nsinais provenientes de r.\n\nEm um caso mais simples desta lei, na?o existem outras portas conectadas a r ou\ns. Neste caso, para que o comportamento de A ou B na?o seja alterado, a ma?quina de\nestados destas ca?psulas na?o devem possuir transic?o?es disparadas pelos novos sinais prove-\nnientes desta conexa?o. Uma condic?a?o menos restritiva, que ainda conserva as condic?o?es\nde aplicac?a?o da Lei 4.8, e? que pelo menos uma das portas r ou s na?o e? utilizada em sua\nca?psula; isto e?, na?o e? utilizada pelo diagrama de estado de sua respectiva ca?psula.\n\nNo caso mais complexo, estas portas esta?o conectadas a porta de outras ca?psulas do\nmodelo; o que acarretaria um condic?a?o impl??cita, no lado esquerdo, de que a multipli-\ncidade desta portas comportassem a nova conexa?o c. Neste caso, para que a sequ?e?ncia\nde sinais recebidos fosse inalterada, todos novos sinais que trafeguem por c devem esta\nsincronizados a outros sinais enviados ou recebidos nessas outras ca?psulas do modelo.\nDesta maneiras, apo?s a aplicac?a?o da esquerda para a direita, as ca?psulas continuam a\naceitar e enviar os mesmos sinais que outrora, incluindo o valor de seus dados, sem que\nisto gere uma mudanc?a na comunicac?a?o ou deadlock.\n\nA pro?xima lei indica quando uma ca?psula pode substituir outra na arquitetura do\nsistema, afetando, exclusivamente, o diagrama de estrutura do modelo.\n\n\n\n4.1 leis ba?sicas 46\n\nLei 4.9 Substituic?a?o de ca?psula\n\nCondic?o?es:\n(?) B e C possuem as assinaturas dos conjuntos de portas b1, .., bN e c1, .., cN e o seus com-\n\nportamentos, quando visto em relac?a?o este conjunto de portas, equivalentes.\n\nA Lei 4.9 possui como condic?a?o de aplicac?a?o que as ca?psulas B e C possuam compa-\ntibilidade de assinatura e comportamento. A compatibilidade de assinatura indica que\nexiste uma relac?a?o de bijec?a?o entre o conjunto de portas de cada uma das ca?psulas, isto\ne?, cada porta de B possui uma porta correspondente, distinta e do mesmo protocolo em\nC, e vice e versa. A compatibilidade de comportamento indica que insta?ncias de B e C\npossuem o mesmo comportamento observado e que a substituic?a?o de uma pelo outra no\nsistema na?o podera? ser notada. A verificac?a?o desta compatibilidade e? claramente uma\ncondic?a?o dina?mica, mas pode ser simplificada, verificando-se uma regia?o da ma?quina de\nestados de C que seja equivalente a uma regia?o da ma?quina de estado de B. A equivale?ncia\ndas ma?quinas de estados e? comprovada pela conservac?a?o da sequ?e?ncia dos sinais aceitos e\nenviados por cada um das portas de uma ca?psula e sua correspondente na outra ca?psula;\num trabalho que lida com a equivale?ncia de ma?quinas de estado pode ser encontrado\nem [34].\n\nApesar desta lei ser bastante semelhante a? Lei 4.8, ela na?o pode ser justificada a\npartir de diversas aplicac?o?es da Lei 4.8 sem que na?o introduzamos deadlock ao modelo.\nA Lei 4.9 so? poderia ser derivada a partir da Lei 4.8, caso cada um das portas da ca?psula\nque sera? substitu??da estivesse associada a uma regia?o da ma?quina de estados da ca?psula\nque na?o utilizasse as outras portas da ca?psula. Um exemplo desta configurac?a?o pode ser\nencontro na Lei 4.20.\n\nNa lei a seguir, e? poss??vel verificar sob que condic?o?es uma relay port pode ser criado.\nEste tipo de porta serve apenas como uma ponte para conexo?es de fora da estrutura de\numa ca?psula com portas protegidas dentro desta estrutura.\n\nLei 4.10 Criar Relay Port\n\nCondic?o?es:\n(?) O protocolo associado a? porta p possui uma ma?quina de estados determin??stica.\n\nPara que a inserc?a?o da nova porta na comunicac?a?o de a na?o altere o comportamento\ndo sistema, devemos garantir que o diagrama de estados do protocolo associado a? porta\ninserida e? determin??stica.\n\nA pro?xima lei expressa como uma insta?ncia de uma ca?psula pode ser inserida para\nintermediar a comunicac?a?o de outras duas ca?psulas.\n\n\n\n4.1 leis ba?sicas 47\n\nLei 4.11 Inserir Ca?psula para Intermediar Comunicac?a?o\n\nCondic?o?es:\n\n(?) A sequ?e?ncia de sinais transmitidos pela conexa?o k e? a mesma que a transmitida\npelas conexo?es k1 e k1.\n\nNo lado direito da Lei 4.11, a ca?psula C aceita e envia os mesmo sinais que poderiam\nser transmitidos atrave?s de k. Esta e? uma condic?a?o dina?mica, e indica que a ma?quina de\nestado de XC na?o pode ser mais restritiva que a ma?quina de estados de X. Em sua forma\nmais geral, todos os sinais de entrada do protocolo X sa?o aceitos por r e reenviados a\npartir de s; similarmente, os sinais de sa??da de X sa?o aceitos por s e reenviados a partir de\nr. Destacamos aqui, somente os sinais i e o de X, enquanto outras transic?o?es internas de\nSxz sa?o responsa?veis pelos demais sinas do protocolo para que a condic?a?o seja satisfeita.\n\nA condic?a?o de aplicac?a?o desta e? uma condic?a?o dina?mica, e na?o pode ser verificada sin-\ntaticamente. Para demonstrarmos a condic?a?o precisamos provar que todo sinal recebido\npor r deve ser enviado atrave?s de s, e vice-versa. Apesar de leis responsa?veis por alterar\nsomente o diagrama de estados do modelo na?o serem o foco deste trabalho, apresentare-\nmos a seguir algumas leis relacionadas a esta visa?o. Algumas outras transformac?o?es em\ndigramas de estados podem ser encontradas em [34, 96]\n\nA pro?xima lei expressa como a associac?a?o entre duas ca?psulas pode ser movida para\noutra ca?psula.\n\n\n\n4.1 leis ba?sicas 48\n\nLei 4.12 Encapsular Ca?psula\n\nCondic?o?es:\n\n(?) Nenhum nome de porta em cps? coincide com um nome em csp; em todo contexto em StrM\nonde existir uma insta?ncia de C, a porta t? estara? conectada a? porta t de uma insta?ncia\nde B.\n\n(?) Na?o existe uma porta chamada t? em C.\n(?) O protocolo T e todos protocolos associados a?s portas em bps e aps? possuem uma ma?quina\n\nde estados determin??stica.\n\nNo lado direito da Lei 4.12, como consequ?e?ncia da mudanc?a da associac?a?o b de A para\nC, a insta?ncia b e? transferida para o diagrama de estrutura de C. Assim, a insta?ncia b\npassa a se comunicar diretamente com as outras insta?ncias na estrutura de c e necessita\nde um conjunto de portas cps? em c para ter acesso ao mundo externo; todas as conexo?es\nque existiam em bps passam a se conectar a? cps?. A porta t? deixa de ter utilidade no\nmodelo.\n\nA aplicac?a?o da direita para a esquerda desta lei mostra como a hierarquia de um\ndiagrama de estrutura pode ser dissolvida passo-a-passo, atrave?s da mudanc?a das asso-\nciac?o?es entre ca?psulas. Note que apesar da hierarquia de ca?psulas indicar uma ordem na\ncriac?a?o destas ca?psulas (ca?psulas mais externas seriam criadas antes das mais internas),\nna?o ha? garantia quanto a? ordem de execuc?a?o de suas ac?o?es iniciais. Desta forma, uma\nestrutura plana de ca?psulas, sem prioridades quanto a? criac?a?o, teria o mesmo compor-\ntamento que uma estrutura hiera?rquica. De fato, esta hierarquia e? usada somente para\nagrupar conceitos ou computabilidade em processos de execuc?a?o.\n\nDevido a lei incorporar novas portas no modelo, ela possui uma condic?a?o de aplicac?a?o\nde que o comportamento destas portas e, consequ?entemente, seus protocolos, sa?o de-\ntermin??sticos. Desta maneira a conexa?o de uma nova porta em StrM na?o ira alterar\n\n\n\n4.1 leis ba?sicas 49\n\no comportamento do modelo. Apesar desta ser uma condic?a?o dina?mica, na pra?tica, e?\nfacilmente verificada por que, normalmente, protocolos na?o te?m ma?quinas de estados\nassociadas.\n\nSemelhante a? Lei 4.12, as leis C.5 e C.6 apresentadas no Ape?ndice C capturam dois\noutros poss??veis padro?es para a mudanc?a de uma associac?a?o entre ca?psulas.\n\nA lei a seguir indica que um conjunto de portas utilizadas na comunicac?a?o entre duas\nca?psulas podem ser combinadas em apenas duas portas, cujos tipos compreendem os\nsinais e o comportamento do conjunto original.\n\nLei 4.13 Compor Protocolos\n\nCondic?o?es:\n\n(?) X e Y na?o possuem sinais com nomes em comum.\n(?) Sx utiliza somente os sinais em xincomes e xoutgoings; Sy utiliza somente os sinais em\n\nyincomes e youtgoings.\n\n(?) Sa e Sb sa?o isomo?rficos a Saz e Sbz, respectivamente, exceto que todas as ocorre?ncias de\np e q em Sa sa?o trocadas por pq em Saz; similarmente, r e s sa?o trocadas por rs em Sbz.\n\nNo lado esquerdo Lei 4.13, utilizac?o?es redundantes dos protocolos X e Y sa?o sim-\nplificadas para utilizarem um u?nico protocolo XY, como consequ?e?ncia a quantidade de\nassociac?o?es e portas no modelos sa?o reduzidas. As ma?quinas de estados das ca?psulas\nque utilizam tais protocolos continuam a descrever o mesmo comportamento, pore?m uti-\nlizando novas portas, associadas a? protocolo XY. Em sentido contra?rio, a lei pode ser\nutilizada para aumentar a reusabilidade do protocolo XY, dividindo-o em dois novos pro-\ntocolos X e Y. Note que a visa?o StaM e? representada nesta lei atrave?s dos diagramas de\nestado de das ca?psulas e protocolos envolvidas na lei. Esta Lei possui como condic?a?o de\naplicac?a?o que todos estados dos diagramas de estado de A, C, X, e Y estejam encapsulados\n\n\n\n4.1 leis ba?sicas 50\n\ndentro de um estado composto que representa toda a ma?quina de estados; Sa, Sc, Sx, e\nSy, respectivamente. Este formato pode ser alcanc?ado atrave?s da aplicac?a?o da Lei 4.15.\n\nA pro?xima lei estabelece sob que condic?o?es podemos mover o comportamento de um\nprotocolo para as ca?psulas que possuem uma associac?a?o com este protocolo.\n\nLei 4.14 Mover Comportamento Protocolo-Ca?psulas\n\nCondic?o?es:\n\n(?) As ma?quinas de estados em Sx e Sxz sa?o isomo?rficas, exceto que toda transic?a?o a[]\\\ndisparadas por um sinal de entrada na maquina de estados de X e? representada por uma\ntransic?a?o r?a.x[]\\s!a.x; similarmente toda transic?a?o b[]\\ disparadas por um sinal de sa??da\nX e? representada por uma transic?a?o s?b.y[]\\r!b.y.\n\nNo lado esquerdo da Lei 4.14, toda comunicac?a?o com a ma?quina de estados de A1 pela\nporta q1 e? filtrada pela ma?quina de estados de X, que governa o fluxo de comunicac?a?o\npor esta porta; o mesmo acontece nas outras ca?psulas do sistema que utilizam portas do\ntipo X. No lado direito da Lei 4.14, toda comunicac?a?o com a ma?quina de estados de A1\npor uma porta q1 e? sincronizada com as portas r e s, restringindo seu comportamento da\nmesma maneira que X o fazia no lado esquerdo da lei; similarmente, o mesmo acontece\npara outras ca?psulas AN que utilizem X. Atrave?s desta lei, e? poss??vel retirar todas as\nregras do modelo situadas nos protocolos e move?-las paras as ma?quinas de estado das\nca?psulas.\n\nA pro?xima Lei mostra que um conjunto de estados sempre pode ser visto como um\nu?nico estado que, por sua vez, engloba todos os outros.\n\n\n\n4.1 leis ba?sicas 51\n\nLei 4.15 Encapsular estados\n\nNo lado direito da Lei 4.15 toda a subma?quina de estados de Sa, do lado esquerdo,\nesta contida em Sc; Sa, do lado esquerdo, e? isomo?rfica a Sc. Esta lei server apenas para\nreestruturar o diagrama de estados de A, sem alterar seu comportamento. Assumimos\nque li e lo representam respectivamente as transic?o?es de sa??da e entrada de Sa, e que tanto\nSa quanto Sb podem ser compostos de outros estados.\n\nA pro?xima lei mostra como a substituic?a?o de ac?o?es em um diagrama de estados de\numa ca?psula pode na?o alterar o comportamento observado desta ca?psula. Apesar desta\nlei ser relativa apenas a ac?o?es de transic?o?es, podemos assumir que ac?o?es de sa??da ou\nentrada de estados podem sempre ser reescritas como ac?o?es em transic?o?es de sa??da ou\nentrada destes estados.\n\nLei 4.16 Reescrever Ac?a?o de Transic?a?o\n\nCondic?o?es:\n\n(?) act1 ? act2; g1 ? g2\n\nNa Lei 4.16, apenas uma parte dos diagramas de estado de A e? apresentado, expressado\npela linha pontilhada no diagrama. A equivale?ncia entre ac?o?es (act1 ? act2) indica que\natributos ou para?metros utilizados por outras ac?o?es no diagrama de estados na?o tera?o seus\nvalores alterados apo?s a reescrita das ac?o?es, nem tampouco o comportamento observado\nda ca?psula sera? alterado. Como, no contexto deste trabalho, ac?o?es sa?o escritas na notac?a?o\nde Circus, a equivale?ncia de ac?o?es pode ser determinada utilizando-se a noc?a?o de leis\nreportada em [15]. Esta condic?a?o e?, claramente, sema?ntica. Ja? que diagramas de estados\nde protocolos na?o possuem ac?o?es, esta? impl??cito nesta lei que o diagrama apresentado e?\nde uma ca?psula A de M.\n\nDevido a esta lei na?o interferir em nenhuma declarac?a?o de ClsM, nem tampouco alterar\nsuas conexo?es em StrM, a apresentac?a?o dos diagramas de classe e estrutura e? desnecessa?ria.\n\nA pro?xima lei estabelece quando e? poss??vel criar uma nova regia?o um AND-State de\numa ma?quina de estados. Uma condic?a?o para a aplicac?a?o da lei e? que a ca?psula seja\nformada por partic?o?es. Uma partic?a?o de uma ca?psula e? composto por uma tupla com\nfragmentos de cada um dos conjuntos de elementos declarados em uma ca?psula (atributos,\nme?todos, predicados, portas e ma?quina de estado), estes fragmentos podem referenciar\n\n\n\n4.1 leis ba?sicas 52\n\nsomente outros elementos da tupla, e na?o podem ser referenciados por nenhum outro\nelemento declarado na ca?psula. Assim, uma ca?psula particionada e? fracamente coesa,\ncujas partic?o?es na?o compartilham elementos entre si.\n\nLei 4.17 Criar Regia?o\n\nCondic?o?es:\n\n(?) A ca?psula A e? formada por duas partic?o?es: ?aatts, ainv, ameths, Sa, aports? e ?batts, binv,\nbmeths, Sb, bports?; as portas em bports na?o devem estar conectadas a nenhuma outra\nca?psula em StrM.\n\n(?) As portas em bports na?o esta?o conectadas a outras portas em StrsfM .\n\nA Lei 4.17 indica que uma nova regia?o pode ser adicionada a uma ca?psula caso ela na?o\ninterfira no comportamento das regio?es restantes da ca?psula. No lado direito da Lei 4.17\na ma?quina de estados de A e? formado por um AND-State composto por duas regio?es (que\nconte?m os estados Sa e Sb), que interagem entre si ou com o ambiente. Ale?m disto, nas\nac?o?es em Sa, somente atributos aatts e os me?todos ameths (que podem referenciar somente\natributos em aatts) sa?o usados; analogamente, ac?o?es de Sb utilizam somente atributos\nbatts e me?todos bmeths (que referenciam somente atributos de batts). O invariante de A\ne? a conjunc?a?o ainv ? binv, onde ainv inclui somente varia?veis livres en aatts, e binv somente\nem batts. Finalmente, as portas em aports so? podem ser referenciadas em Sa e bports\nem Sb. Quando uma ca?psula obedece estas condic?o?es, no?s dizemos que ela esta? semi\nparticionada. Neste caso, existem duas semi partic?o?es: ?aatts, ainv, ameths, Sa, aports? e\n?batts, binv, bmeths, Sb, bports?.\n\nA pro?xima lei estabelece como uma ac?a?o do diagrama de estados de uma ca?psula pode\nser isolado em uma nova partic?a?o da ca?psula.\n\n\n\n4.2 leis derivadas e refatoramentos 53\n\nLei 4.18 Isolar Ac?a?o\n\nCondic?o?es:\n(?) A ca?psula A na?o possui a declarac?a?o de nenhuma porta, chamada p ou q; a u?nica varia?vel\n\nlocal utilizada pela ac?a?o F e? a varia?vel d do tipo D.\n\n(?) O estado Sw na?o possui subestados;\n(?) A ac?a?o F na?o utiliza atributos em aatts que sejam utilizados por outras ac?o?es na ma?quina\n\nde estados de A\n\nNa lado direito da Lei 4.18, o acesso a? ac?a?o F passa a ser realizado atrave?s de um\nsinal reqf de requisic?a?o a? porta p, ao inve?s de executa-lo diretamente. Esta requisic?a?o e?\ncapturada por uma outra partic?a?o na ca?psula, que processa a ac?a?o F e envia o retorno\ndeste processamento atrave?s do sinal resf. Um caso mais simples desta lei e? quando F e?\nigual a um me?todo m em ameths, onde m deve possuir um para?metro de tipo D e retorno\nde tipo R\n\n4.2 LEIS DERIVADAS E REFATORAMENTOS\n\nDiferentemente das leis apresentadas na sec?a?o anterior, nesta sec?a?o consideramos leis\nde maior granularidade, usualmente aplicadas durante a ana?lise e projeto de sistemas\nde software. Transformac?o?es de modelo como estas podem ser justificadas a partir da\ncomposic?a?o sequ?encial de leis ba?sicas, aplicadas passo-a-passo. As condic?o?es de aplicac?a?o\ndestas leis sa?o criadas a partir da composic?a?o das condic?o?es de aplicac?a?o das leis ba?sicas\nque as formam.\n\nAs transformac?o?es apresentadas aqui podem ser consideradas refatoramentos de mo-\ndelos (refactorigs) [96], por serem usadas para reestruturar o modelo e por manterem o\ncomportamento do sistema modelado inalterado apo?s sua aplicac?a?o. Mostramos, nesta\nsec?a?o, somente um pequeno conjunto destas leis, focando naquelas que sa?o mais impor-\ntantes para a descric?a?o dos principais passos da estrate?gia de normalizac?a?o de um modelo\nem UML-RT (Sec?a?o 4.2). Apo?s a apresentac?a?o de cada lei, sera?o realizadas justificativas\ninformais sobre a derivac?a?o destas transformac?o?es a partir das mais ba?sicas; algumas\nprovas formais sera?o apresentadas na Sec?a?o 4.3.\n\n\n\n4.2 leis derivadas e refatoramentos 54\n\nEm um processo de desenvolvimento, e? comum identificar uma classe (ou ca?psula)\ndurante a ana?lise que depois, durante o projeto, ira? ser representada por mais do que uma\nu?nica abstrac?a?o. Enta?o, e? importante uma transformac?a?o para promover esta abstrac?a?o\nescondida em uma classe ou ca?psula do modelo.\n\nLeis para extrac?a?o de dados de uma classe ou de uma ca?psula sa?o bem semelhantes.\nMostramos apenas a lei para extrac?a?o de dados a partir de uma ca?psula. Este tipo de lei,\npor exemplo, facilita que sistemas sejam modelados como componentes e, apo?s um certo\nesta?gio do desenvolvimento, classes sejam extra??das destes componentes (ou ca?psulas).\n\nLei 4.19 Extrair Classe\n\nCondic?o?es:\n\n(?) bmeths, binv, bpre e bpost acessam somente me?todos em bmeths ou atributos em batts.\n(?) Nenhuma ca?psula, exceto A, utiliza B.\n(?) A estrutura interna de Sa e? isomo?rfica a Sax e os me?todos em amths? possuem a mesma\n\nassinatura e o corpo dos me?todos em ameths, exceto que me?todos em bmeths e atributos\nem batts sa?o acessados a partir de b.\n\nNo lado esquerdo da Lei 4.19, a ca?psula A e? representada pelo conjuntos de atributos\naatts e batts, de me?todos ameths e bmeths e de portas ports. A ma?quina de estados de\nA e? representada por um estado Sa que engloba todos os outros estados da ma?quina de\nestado, e tem acesso a qualquer elemento descrito anteriormente. O invariante de A e? a\nconjunc?a?o ainv ? binv, e a pre?- e po?s-condic?o?es dos me?todos de A sa?o expressos por apre,\nbpre, apost e bpost. Os elementos batts, bmeths, bpre e bpost sa?o fortemente coesos, e na?o\nfazem refere?ncia a nenhum outro elemento de A; estes sa?o os elementos que podem ser\nextra??dos para uma nova classe. Na lado direito da Lei 4.19, toda ac?a?o em Sax, me?todo\nde ameths? ou predicado (ainv?, apre? ou apost?) que anteriormente acessava um atributo i\nde batts ou me?todo m de bmeths devera? ser reescrita para acessa?-los como b.i ou b.j.\n\nNote que como B e? uma nova abstrac?a?o no modelo, pode-se desejar que esta esteja\nlivre de certas regras impostas ao contrato de A. Desta forma, pode-se atribuir qualquer\ninvariante binv a B, tal que ainv ? binv seja aceita?vel pelo contrato de A. Da mesma forma\npre?- e po?s-condic?o?es indeseja?veis em B devem ser colocadas em me?todos em ameths que\ndeleguem todas as suas ac?o?es a me?todos em bmeths.\n\nA justificativa da Lei 4.19 a partir de leis mais ba?sicas e? feita aplicando-se a Lei 4.4\npara se introduzir o atributo b em A, do tipo de uma classe B (criada a partir da Lei C.2)\n\n\n\n4.2 leis derivadas e refatoramentos 55\n\ncomo descrita na Lei 4.19, e aplicando-se a Lei 4.16 para se reescrever as ac?o?es da ma?quina\nde estados de A em ac?o?es equivalentes que utilizam b. Por fim, atributos e me?todos na?o\nutilizados mais em A podem ser removidos aplicando-se as Leis 4.3 e 4.4. Um exemplo\nde uma lei de transformac?a?o para a extrac?a?o de classes a partir de uma ca?psula pode ser\nvisto em [83]; esta lei mostra a extrac?a?o de um atributo, representando um conjunto de\nclasses, para uma classe que mediara? o acesso a este conjunto.\n\nA lei a seguir decompo?e uma ca?psula A no paralelismo de insta?ncias de ca?psulas (B\ne C) com o propo?sito de diminuir sua complexidade e de, potencialmente, aumentar seu\nreuso.\n\nLei 4.20 Decomposic?a?o Paralela de uma Ca?psula\n\nCondic?o?es:\n\n(?) ?batts, binv, bmeths, (b1, b2), Sb? e ?catts, cinv, cmeths, (c1, c2, Sc? particionam A;\n(?) As ma?quinas de estado Sb e Sc sa?o isomo?rficas a? Sb? e Sc?, respectivamente, exceto que\n\ntodas as ocorre?ncias de b1 e c2 em sa?o substitu??das respectivamente, por b\n?\n1 e c\n\n?\n2; os\n\nprotocolo X e Z possuem uma ma?quina de estados determin??stica.\n\nAnalogamente a? Lei4.17, a Lei 4.20 requer que a ca?psula A seja particionada, onde\ncada partic?a?o deve ser auto-contida e fazer uso somente dos atributos e me?todos da\npartic?a?o. Ale?m disto, as u?nicas portas utilizadas em uma partic?a?o sa?o aquelas que ela\nconte?m.\n\nNo lado esquerdo da Lei 4.20, a ma?quina de estado de A e? formada por um AND-\nState, composto de duas regio?es. Cada uma destas regio?es possui um estado que engloba\ntodos os outros (Sb e Sc), que interagem entre si (comunicac?a?o interna) atrave?s das\nportas conjugadas b2 e c1 (como capturado pelo diagrama de estrutura). As outras\nduas portas (b1 e c2) sa?o utilizadas para comunicac?o?es externas dos estados Sb e Sc,\nrespectivamente. As portas b1 e b2 sa?o utilizadas somente pelo estado Sb, enquanto Sc\nfaz uso somente das portas c1 e c2. Como dito, anteriormente, as ac?o?es de Sb utilizam\nsomente atributos e me?todos de batts e bmeths; analogamente Sc faz uso somente de\ncatts e cmeths. Finalmente, o invariante de A e? a conjunc?a?o binv ? cinv, onde binv inclui\nsomente batts como varia?veis livres, e cinv inclui somente catts.\n\n\n\n4.2 leis derivadas e refatoramentos 56\n\nO efeito da decomposic?a?o e? criar duas novas ca?psulas componentes, b e c, uma para\ncada partic?a?o, e redimensionar a ca?psula original A para agir como um mediador. Em\ngeral, o novo comportamento de A ira? depender da forma particular da decomposic?a?o. A\nLei 4.20 captura uma decomposic?a?o paralela. No lado direito da lei, A na?o possui uma\nma?quina de estados, delegando completamente seu comportamento original para B e C\natrave?s de conexo?es com componentes destes tipos no diagrama de estrutura.\n\nEm relac?a?o ao diagrama de estrutura no lado direito da lei, ele mostra como A en-\ncapsula b e c. Quando a e? criada, ele automaticamente cria insta?ncias de b e c, que\nexecutam concorrentemente. As portas pu?blicas b1 e c2 sa?o preservadas em A, e, assim,\nsua interface com o ambiente externo. A ca?psula B tem como porta pu?blica uma imagem\nde b1, chamada b\n\n?\n1. Apesar desta porta ser pu?blica em B, ela somente e? vista dentro\n\ndo diagrama de estrutura de A. O papel desta porta e? possibilitar que B receba sinais\nexternos recebidos por A atrave?s de b1, como e? capturado pela conexa?o entre b\n\n?\n1 e b1\n\nno diagrama de estrutura de A. Analogamente, c2 e b\n?\n2 te?m o mesmo relacionamento,\n\nrelativo a?s ca?psulas A e C. As portas internas b2 e c1 foram movidas para as ca?psulas B\ne C, respectivamente, e realizam os mesmo pape?is que antes.\n\nA justificativa da Lei 4.20 a partir das leis ba?sicas pode ser feita movendo-se, no lado\ndireito da lei, passo-a-passo o comportamento de B e C para A. Inicialmente movemos\no comportamento de B para uma outra ca?psula A?, que futuramente ira? substituir A. O\nprimeiro passo e? desencapsular o componente de ca?psula b (Lei 4.12) da estrutura de\nA. Criar outra ca?psula A? (Lei 4.1) com os atributos (batts), invariante (binv), me?todos\n(bmeths) e portas (b1 e b2) de B, e enta?o, inserir uma insta?ncia a\n\n? de A? em todo contexto\nde StrM em que uma insta?ncia de A aparece (Lei 4.2). Em seguida, b e? substitu??do por a\n\n?\n\natrave?s da aplicac?a?o da Lei 4.9, ja? que as ma?quinas de estados de B e A? sa?o isomo?rficas.\nFinalmente, b e? removida de StrM (Lei 4.2).\n\nPara se mover o comportamento de C para A?, os atributos catts, os me?todos cmeths\ne as portas c1 e c2 sa?o adicionados a? A\n\n? (Leis 4.3 e 4.5). Enta?o, uma regia?o e? adicionada\nao digrama de estados de A? com o estado Sc (Lei 4.17). Ja? que Sc na?o compartilha\nnenhum elemento (atributo, me?todo ou porta) com Sb, o comportamento de A continua\ninalterado. No passo seguinte, o componente de ca?psula c e? desencapsulado (Lei 4.12) do\ndiagrama de estrutura de A, substitu??da por a? (Lei 4.9), e removida de StrM (Lei 4.2),\nseguindo um processo semelhante ao que aplicado a? insta?ncia de c.\n\nNo final, A na?o e? mais utilizada no sistema, podendo ser retirada do modelo (Lei 4.1),\ne assim A? pode ter seu nome renomeado para A (Lei C.3), obtendo assim o mesmo\ncontexto apresentado no lado esquerdo da Lei 4.20.\n\nMotivado por pra?ticas ja? existentes de desenvolvimento, precisamos de uma lei que\ntransforma classes, possivelmente encontradas durante a ana?lise, em ca?psulas, durante o\nprojeto.\n\n\n\n4.3 formalizac?a?o das leis 57\n\nLei 4.21 Transformar Classe em Ca?psula\n\nCondic?o?es:\n\n(?) Todos os atributos batts sa?o privados.\n(?) Nenhuma outra ca?psula, ale?m de A, possui uma relac?a?o com B.\n\nA Lei 4.21 transforma uma classe B (lado esquerdo), que na?o tem nenhum compor-\ntamento associado (diagrama de estados), em uma ca?psula (lado direito), que inclui um\ndiagrama de estados que lida com as requisic?o?es para a chamada de seus me?todos.\n\nO comportamento das chamadas de me?todos em B e? preservado por um diagrama de\nestados que simula uma comunicac?a?o sincronizadas com o protocolo cliente. Enta?o, todos\nos servic?os (me?todos pu?blicos) da classe sa?o acess??veis a partir de um novo protocolo XB.\nNote que o construtor da classe B transforma-se na ac?a?o da transic?a?o inicial de diagrama\nde estados da nova ca?psula B.\n\nA justificativa desta lei em func?a?o de leis ba?sicas pode ser feita, no lado esquerdo da\nLei 4.21, aplicando-se a Lei 4.19 para incluir a classe B na ca?psula A, em seguida aplica-se\nas leis 4.17 e 4.18 para criar uma nova partic?a?o em A com os atributos em batts, me?todos\nbmeths, m() e B().\n\nApo?s particionar A, a Lei 4.20 pode ser aplicada para decompor a ca?psula A em duas\nca?psulas, onde uma destas e? a ca?psula B. Enta?o, o componente b do tipo B sera? desen-\ncapsulado da estrutura de A (Lei 4.12) para que obtenhamos StrM como e? apresentado\nno lado esquerdo da Lei 4.21. Finalmente uma regia?o vazia sera? criada em A(Lei 4.17),\ne, atrave?s da aplicac?a?o da Lei 4.20, a ca?psula A podera? ter a mesma declarac?a?o que no\nlado esquerdo da Lei 4.21.\n\n4.3 FORMALIZAC?A?O DAS LEIS\n\nBaseado no mapeamento sema?ntico apresentado na Sec?a?o 3.2, podemos transformar\nos modelos em UML-RT presentes nos dois lados de uma lei de transformac?a?o para a\nnotac?a?o OhCircus. A partir da sema?ntica de Circus e de seu ca?lculo de refinamentos, e?\nposs??vel verificar a validade das leis de transformac?a?o para UML-RT. Ao inve?s de recorrer\n\n\n\n4.3 formalizac?a?o das leis 58\n\ndiretamente a? sema?ntica de Circus podemos utilizar leis de refinamento [84] para realizar\nsua prova; na realidade, va?rias das leis para UML-RT foram inspiradas por leis em Circus.\n\n4.3.1 Prova da Lei 4.20\n\nPara provar esta lei, lidamos inicialmente com as viso?es descritas pelos diagramas\nde classe e estado. O mapeamento destas viso?es da ca?psula A, do lado esquerdo da lei,\ncomo um processo em Circus e? obtido utilizando-se a segunda regra de mapeamento\napresentada na Sec?a?o 3.2.1 e a u?ltimo regra da Sec?a?o 3.2.2. Escrevemos as duas partic?o?es\nusando o operador ?, como na Lei 3.2. De fato, a Lei 4.20 foi inspirada pela Lei 3.2\nde Circus. Assim, as viso?es representadas pelo processo ChartA sa?o equivalentes a? sim-\nples composic?a?o paralela de ChartB e de ChartC. Estritamente, os atributos e me?todos\nbatts, catts, bmeths e cmeths precisam ser mapeados utilizando a func?a?o TL; aqui no?s\nomitiremos sua aplicac?a?o para manter a legibilidade.\n\nprocess ChartA =? begin\nstate State =? [batts ? catts | InvB ? InvC]\nbmeths ? catts\ncmeths ? batts\n\u2022H(SB)[b2 := k] |[ batts | {| k, b1, c2 |} | catts]|)H(SC)[c1 := k]\n\nend\n\nAplicando as func?o?es identidade [b1 := b\n?\n1][b\n\n?\n1 := b1] e [c2 := c\n\n?\n2][c\n\n?\n2 := c2] a? ac?a?o principal de\n\nChartA, obtemos:\n\n\u2022H(SB)[b1 := b?1][b?1,b2 := b1,k] |[ batts|{|k,b1,c2 |}|catts]|)H(SC)[c2 := c?2][c?2,c1 := c2,k]\n\nA partir da Lei 3.2, obtemos a igualdade:\n\nChartA = ChartB[b\n?\n1,b2 := b1,k] |[{| k, b1, c2 |} ]| ChartC[c?2,c1 := c2,k]\n\nonde ChartB e ChartB sa?o declarados como:\n\nprocess ChartB =? begin state State =? [batts | InvB] bmeths \u2022H(SB)[b1 := b?1] end\nprocess ChartC =? begin state State =? [catts | InvC] cmeths \u2022H(SC)[c2 := c?2] end\n\nAgora, considerando a parte estrutural da ca?psula A, obtemos o processo StructA em\nCircus, como e? apresentado abaixo.\n\nStructA =? (ChartA[b2, c1 := k, k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]|\nY[chanY := k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]| Z[chanZ := c2])\\{|k|}\n\nO diagrama de estrutura de B, C e A, no lado direito da lei, sa?o mapeados de maneira\nsimilar. Para se evitar confuso?es entre as duas ocorre?ncias de A na lei, iremos nos referir\na? ocorre?ncia no lado esquerdo simplesmente como A, e a? do lado direito como A?.\n\n\n\n4.3 formalizac?a?o das leis 59\n\nStruct?A =? ((StructB[b\n?\n1, b2 := m, k ] |[{| k |} ]| StructC[c?2, c1 := n, k ]) |[{| k |}]|\n\n(X[chanX := m] |[{| k |} ]| Z[chanZ := n]))[m, n := b1, c2] \\ {| k |}\nStructsB =? ChartB |[{|b2,b?1 |}]|X[chanX := b?1] |[{|b2,b?1 |}]|Y[chanY := b2]\nStructC =? ChartC |[{|c1,c?2 |}]|Y[chanY := c1] |[{|c1,c?2 |}]|Z[chanZ := c?2]\n\nEnta?o, queremos provar que StructA tem o mesmo comportamento de StructA? , onde\no u?ltimo inclui em sua estrutura StructB e StructC.\n\nStructA\n= [1. Pela definic?a?o de StructA]\n\n(ChartA[b2, c1 := k, k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |} ]| Y[chanY := k]\n|[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]| Z[chanZ := c2])\\{|k|}\n\n= [2. Expandindo ChartA ]\n(ChartB[b\n\n?\n1,b2 := b1,k] |[{|k,b1,c2 |}]|ChartC[c?2,c1 := c2,k] |[{|k,b1,c2 |}]| X[chanX := b1]\n\n|[{|k,b1,c2 |} ]| Y[chanY := k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]| Z[chanZ := c2]) \\ {| k |}\n= [3. Aplicando a Lei B.6 para X[chanX := b1] e Z[chanZ := c2]]\n\n(ChartB[b\n?\n1,b2 := b1,k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]|\n\nY[chanY := k] |[{|k,b1,c2 |} ]| ChartC[c?2,c1 := c2,k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]|\nZ[chanZ := c2] |[{|k,b1,c2 |}]| Z[chanZ := c2]) \\ {| k |}\n\n= [4. Reorganizando os processos utilizando as leis B.4 e B.4]\n(ChartB[b\n\n?\n1,b2 := b1,k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]|\n\nChartC[c\n?\n2,c1 := c2,k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |} ]| Z[chanZ := c2] |[{|k,b1,c2 |}]|\n\nX[chanX := b1] |[{|k,b1,c2 |}]| Z[chanZ := c2]) \\ {| k |}\n= [5. Aplicando as func?o?es de substituic?a?o indentidade [k := b2][b2 := k], [k := c1][c1 := k],\n\ne distribuindo [k := b2] e [k := c1] atrave?s da Lei B.1 ]\n(((ChartB[b\n\n?\n1 := b1] |[{|b2,b1,c2 |}]| X[chanX := b1] |[{|b2,b1,c2 |}]| Y[chanY := b2])[b2 := k]\n\n|[{|k,b1,c2 |}]| ((ChartC[c?2 := c2] |[{|c1,b1,c2 |}]| Y[chanY := c1] |[{|c1,b1,c2 |}]| Z[chanZ := c?2])\n[c1 := k] |[{|k,b1,c2 |}]| X[chanX := b1]) |[{|k,b1,c2 |} ]| Z[chanZ := c2])) \\ {| k |}\n\n= [6. Aplicando a func?a?o de substituic?a?o indentidade [c2,b1 := c\n?\n2,b\n\n?\n1][c\n\n?\n2,b\n\n?\n1 := n,m]\n\n[n,m := c2,b1], e distribuindo [c2,b1 := c\n?\n2,b\n\n?\n1][c\n\n?\n2,b\n\n?\n1 := n,m] atrave?s da Lei B.1 ]\n\n(((ChartB |[{|b2,b?1,n|}]|X[chanX := b?1] |[{|b2,b?1,n|}]|Y[chanY := b2])[b?1,b2 := m,k]\n|[{|k,m,n|}]| ((ChartC |[{|c1,m,c?2 |}]| Y[chanY := c1] |[{|c1,m,c?2 |}]| Z[chanZ := c?2])\n[c?2,c1 := n,k] |[{|k,m,n|} ]| X[chanX := m]) |[{|k,m,n|} ]| Z[chanZ := n])[m,n := b1,c2]) \\ {| k |}\n\n= [7. Utilizando a Lei B.7 para restringir as sincronizac?o?es sobre os canais n e m]\n(((ChartB |[{|b2,b?1 |}]|X[chanX := b?1] |[{|b2,b?1 |}]|Y[chanY := b2])[b?1,b2 := m,k] |[{|k,m,n|}]|\n((ChartC |[{|c1,c?2 |}]|Y[chanY := c1] |[{|c1,c?2 |}]|Z[chanZ := c?2])[c?2,c1 := n,k] |[{|k,m,n|}]|\nX[chanX := m]) |[{|k,m,n|}]| Z[chanZ := n])[m,n := b1,c2]) \\ {| k |}\n\n= [8. Utilizando a definic?a?o de StructB e StructC ]\n((StructB[b\n\n?\n1,b2 := m,k] |[{|k,m,n|}]| (StructC[c?2,c1 := n,k] |[{|k,m,n|}]|\n\nX[chanX := m]) |[{|k,m,n|} ]| Z[chanZ := n])[m,n := b1,c2]) \\ {| k |}\n= StructA?\n\nDurante a prova, tre?s leis condicionais sa?o utilizadas. A condic?a?o da Lei B.6 (Passo\n3) e? claramente satisfeita porque os processos X e Z sa?o obtidos de dos protocolos X e Z,\nque, na Lei 4.20, assume-se que sa?o determin??sticos. A condic?a?o da Lei B.7 (Passo 7) e?\nsatisfeita ja? que que os processos ChartB, X[chanX := b\n\n?\n1] e Y[chanY := b2] na?o utilizam o\n\n\n\n4.3 formalizac?a?o das leis 60\n\ncanal n; similarmente, os processos ChartC, Y[chanY := c1] e Z[chanZ := c\n?\n2] na?o utilizam\n\nm. A condic?a?o da Lei B.1 (passos 5 e 6) e? satisfeita ja? que as seguintes func?o?es de\nrenomeac?a?o utilizadas na distribuic?a?o sa?o injetivas: [k := b2], [k := c1] e [c2,b1 := n,m].\n\n4.3.2 Prova da Lei 4.12\n\nNo lado esquerdo da Lei 4.12, em toda ocorre?ncia de uma insta?ncia da ca?psula C, existe\nsempre uma insta?ncia b da ca?psula B conectada a uma de suas subca?psulas d da ca?psula\nd : D. A ca?psula A representa o contexto onde esta configurac?a?o existe. A lei indica que\napo?s sua aplicac?a?o, em seu lado direito, o comportamento de C e de qualquer contexto\nem que aparec?a (A) sera? inalterado, caso b passe a ser um componente do diagrama de\nestrutura de C.\n\nPara provar esta lei, precisamos lidar apenas com a visa?o estrutural do modelos (StrM),\nja? que as u?nicas reestruturac?o?es da lei que podem afetar o comportamento do sistema\nsa?o mudanc?as realizadas nas conexo?es do diagrama de estrutura de C e A. De fato a\nvisa?o intencional das insta?ncias de ca?psulas em Circus desconsidera as associac?o?es no\ndiagrama de classes do modelo, mapeando unicamente a ocorre?ncias destas insta?ncias em\nStrM. Apesar da remoc?a?o da porta t\n\n?, no lado esquerdo da lei, e da adic?a?o do conjunto de\nportas p?, no lado direito da lei, estas portas sa?o somente utilizadas na visa?o estrutural\npara interconectar portas de componentes de ca?psula em diferentes estruturas, e nenhuma\nnecessidade de prova quando a? sua declarac?a?o e? necessa?ria.\n\nDevido a? condic?a?o de que a u?nica insta?ncia de C e? o componente c em A, nossa de-\nmonstrac?a?o precisa mostrar apenas a igualdade do comportamento de A no lado esquerdo\ne direito da lei. Para se evitar confuso?es entre as duas ocorre?ncias de A e C na lei, ire-\nmos nos referir a?s ocorre?ncia no lado esquerdo simplesmente como A e C, e a?s do lado\ndireito como A? C?; note que B e D continuam inalterados em ambos os lados da lei.\nAssim, o comportamento da ca?psula A seria dado por StructA, atrave?s da terceira regra\nde mapeamento da Sec?a?o 3.2.1.\n\nStructA =? (TL(aps) |[{|x,w,y |}]| TL(aps?) |[{|x,w,y |}]| StructB[bps,t := x,w] |[{|x,w,y |}]|\nStructC[cps,t\n\n? := y,w]) [x,y := aps?,aps] \\ {| w |}\n\nSimilarmente, o mapeamento de B, C, C? e A? sa?o dados por:\n\nStructB =? ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |} ]| T[chanT := t]\nStructC =? (T[chanT := k] |[{| k,z |} ]| TL(cps) |[{| k,z |} ]| StructD[dps, s := z, k])\n\n[z, k := csp, t?]\nStructC? =? (StructB[bps,t := x\n\n?,w] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]|\nStructD[dps,s := z,w]) [z,x\n\n? := csp,cps?] \\ {| w |}\nStructA? =? (TL(aps) |[ x , y ]| TL(aps?) |[ x , y ]| StructC? [cps, cps? := y, x])\n\n[x, y := aps?, aps]\n\nComo veremos na prova abaixo, o comportamento do processo StructA sera? igual ao\ndo StructA? , de fato a u?nica mudanc?a entre sera? na ordem da composic?a?o paralela de\nStructB e StructC, e na renomec?a?o de seus canais.\n\nStructA\n\n\n\n4.3 formalizac?a?o das leis 61\n\n= [1. Expandindo StructA]\n(TL(aps) |[{|x,w,y |}]| TL(aps?) |[{|x,w,y |}]| StructB[bps,t := x,w] |[{|x,w,y |}]|\nStructC[cps,t\n\n? := y,w]) [x,y := aps?,aps] \\ {| w |}\n= [2. Expandindo StructC]\n\n(TL(aps) |[{|x,w,y |}]| TL(aps?) |[{|x,w,y |}]| StructB[bps,t := x,w] |[{|x,w,y |}]|\n((T[chanT := k] |[{| k,z |} ]| TL(cps) |[{| k,z |}]| StructD[dps, s := z, k]) [z, k := csp, t?])\n[cps,t? := y,w]) [x,y := aps?,aps] \\ {| w |}\n\n= [3. Restrigindo w aos processos que o usam, aplicando as leis B.7 e B.2]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (StructB[bps,t := x,w] |[{| x,w,y |}]|\n((T[chanT := k] |[{| k,z |}]| TL(cps) |[ k,z ]| StructD[dps,s := z,k]) [z, k := csp, t?])\n[cps, t? := y, w]) \\ {| w |}) [x, y := aps?, aps]\n\n= [4. Aplicando os renamings [t? := k] e [k := w]]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (StructB[bps,t := x,w] |[{| x,w,y |}]|\n((T[chanT := w] |[{| w,z |}]| TL(cps) |[{| w,z |}]| StructD[dps,s := z,w]) [z := csp])\n[cps := y]) \\ {| w |}) [x,y := aps?,aps]\n\n= [5. Inserindo a func?a?o indentidade [x := x?][x? := cps?][cps? := x] ]\n((TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (StructB[bps,t := x,w] |[{| x,w,y |}]|\n((T [chanT := w ] |[{| w,z |}]| TL(cps) |[{| w,z |}]| StructD[dps,s := z,w]) [z := csp])\n[cps := y]) \\ {| w |}) [x := x?][x? := cps?][cps? := x]) [x,y := aps?,aps]\n\n= [6. Aplicando os renamings [x := x?], [x? := cps?]e[cps? := x]]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,y |}]|\n(T[chanT := w ] |[{| w,z |}]| TL(cps) |[{| w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?])\n[cps, cps? := y,x]) \\ {| w |}) [x,y := aps?,aps]\n\n= [7. Aplicando B.7 para espandir o canal x ]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,y |}]|\nT[chanT := w ] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?])\n[cps, cps? := y,x] \\ {| w |}) [x,y := aps?,aps])\n\n= [8. Restringindo w atrave?s da Lei B.7]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (((StructB[bps,t := x?,w] |[{| x?,y |} ]| T[chanT := w ])\n|[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?])\n[cps, cps? := y,x] \\ {| w |}) [x,y := aps?,aps]\n\n= [9. Expandindo StructB ]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((((ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |}]|\nT[chanT := t])[bps,t := x\n\n?,w] |[{| x?,y |} ]| T[chanT := w ]) |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]|\nStructD[dps,s := z,w]) [z,x\n\n? := csp,cps?]) [cps, cps? := y,x] \\ {| w |}) [x,y := aps?,aps]\n= [10. Usando a Lei B.1 para distribuir o renaming [bps,t := x,w]]\n\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((((ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |}]|\nT[chanT := t] |[{| bps,t |} ]| T[chanT := t]))[bps,t := x?,w] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]|\nStructD[dps,s := z,w]) [z,x\n\n? := csp,cps?]) [cps, cps? := y,x] \\ {| w |}) [x,y := aps?,aps]\n= [11. Usando a Lei B.6 para T[chanT := t] ]\n\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((((ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |}]|\nT[chanT := t]))[bps,t := x\n\n?,w] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]| StructD[dps,s := z,w])\n[z,x? := csp,cps?]) [cps, cps? := y,x] \\ {| w |}) [x,y := aps?,aps]\n\n= [12. Pela definic?a?o de StructB ]\n\n\n\n4.4 concluso?es 62\n\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,z |}]| TL(cps)\n|[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?]) [cps, cps? := y,x] \\ {| w |})\n[x,y := aps?,aps]\n\n= [13. aplicando a Lei B.3 para mover \\ {| w |} ]\n(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,z |}]| TL(cps)\n|[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?] \\ {| w |}) [cps, cps? := y,x])\n[x,y := aps?,aps]\n\n= [14. Aplicac?a?o da definic?a?o de StructC? ]\n(TL(aps) |[ x , y ]| TL(aps?) |[ x , y ]| StructC? [cps, cps? := y, x]) [x, y := aps?, aps]\n\n= [15. Segundo a definic?a?o de StructA? ]\nStructA?\nDurante a prova, tre?s leis condicionais sa?o utilizadas. A condic?a?o da Lei B.6 (Passo\n\n11) e? claramente satisfeita porque o processo T e? obtido do protocolo T, que, na Lei 4.12,\nassume-se que e? determin??stico. A condic?a?o da Lei B.7 (passo 3,7,8) e? satisfeita ja? que\nque nos passos onde e? aplicada os processos na?o utilizam os canais x, w e y. A condic?a?o\nda Lei B.1 (Passos 10) e? satisfeita ja? que a func?o?es de renomeac?a?o [bps,t := x,w] utilizadas\nna distribuic?a?o e? injetiva.\n\n4.4 CONCLUSO?ES\n\nNeste cap??tulo, apresentamos um conjunto de leis ba?sicas em UML-RT e como elas\npodem ser utilizadas para justificar outras leis de transformac?o?es mais elaboradas, usu-\nalmente utilizadas na pra?tica.\n\nA partir da sema?ntica OhCircus, foi poss??vel tambe?m demonstrar a corretude destas\nleis. Esta corretude permite a inclusa?o das leis em um processo de desenvolvimento ri-\ngoroso, onde o desenvolvedor pode realizar suas tarefas de modelagem com uma maior\ngarantia sobre seus resultados. Adicionalmente, a aplicac?a?o de leis com estas carac-\nter??sticas pode diminuir o esforc?o desprendido durante o desenvolvimento em testes de\nverificac?a?o do modelo.\n\n\n\nCAPI?TULO 5\n\nNORMALIZAC?A?O E APLICAC?A?O DAS LEIS\n\nCom o objetivo de analisar o poder de expressa?o do conjunto de leis proposto, neste\ncap??tulo mostraremos a abrange?ncia dessas leis atrave?s de sua aplicac?a?o nos principais\npassos de uma estrate?gia de normalizac?a?o de um modelo UML-RT em um modelo UML\nestendido com um u?nico objeto ativo, responsa?vel por todas as interac?o?es com o ambiente\ne por conservar o comportamento dina?mico do sistema modelado.\n\nEste modelo UML estendido pode ser visto como uma forma normal, e, portanto,\nnossa estrate?gia pode ser vista como uma contribuic?a?o para uma estrate?gia de completude\ncapturada por uma reduc?a?o a esta forma normal, semelhante a? estrate?gia apresentada\nem [9] para uma linguagem de programac?a?o orientada a objetos; a completude de conjun-\ntos de leis para uma linguagem imperativa simples e para a linguagem concorrente Occam\ne? apresentada em [46, 80], respectivamente. Nosso foco e? em um conjunto de leis para\ndiagramas de classe e estrutura do modelos; uma estrate?gia completa de normalizac?a?o\nnecessita de um grande nu?mero de leis para capturar transformac?o?es nos diagramas de\nestados, que esta? fora do escopo deste trabalho.\n\nNo processo de normalizac?a?o as leis sa?o aplicadas, usualmente, em um sentido inverso\nao que sa?o aplicadas durante um processo de desenvolvimento. Durante o processo de\ndesenvolvimento, elas sa?o aplicadas para quebrar abstrac?o?es, promover reuso e modula-\nrizac?a?o, enquanto que em uma estrate?gia de reduc?a?o a uma forma normal, as leis sa?o\naplicadas para gerar um sistema monol??tico, cujo u?nico objetivo e? atestar o poder de\nexpressa?o das leis.\n\nNas sec?o?es a seguir mostramos a aplicac?a?o das leis em seus dois sentidos (ver Fi-\ngura 5.1). Na Sec?a?o 5.1, a medida que os passos de nossa estrate?gia de normalizac?a?o\nsa?o apresentados, mostramos a aplicac?a?o de algumas leis de transformac?a?o utilizadas na\nreduc?a?o do modelo de sistema simplificado de automac?a?o industrial, apresentado anteri-\normente na Sec?a?o 2.3, em uma u?nica ca?psula. Enquanto na Sec?a?o 5.2, apresentamos a\naplicac?a?o das leis durante o desenvolvimento do estudo de caso, partindo-se de um mo-\ndelo abstrato de ana?lise, extraido dos casos de uso do sistema, ate? um modelo concreto e\nmais elaborado de projeto em UML-RT , pro?ximo a? fase de implementac?a?o. Como tanto\na estrate?gia de reduc?a?o quanto o desenvolvimento do estudo de caso utilizam o mesmo\nmodelo como ponto de partida, a combinac?a?o de ambos e? capaz de ilustrar o conjunto de\npassos necessa?rios para desenvolver um modelo monol??tico representado por u?nica ca?psula\nem um modelo mais concreto e modularizado de projeto.\n\n5.1 ESTRATE?GIA DE NORMALIZAC?A?O\n\nAtrave?s do uso conjunto das leis propostas mostramos que todo o modelo pode ser\nrepresentado por uma u?nica ca?psula MAIN, cujas portas pu?blicas sa?o utilizadas pelo\n\n63\n\n\n\n5.1 estrate?gia de normalizac?a?o 64\n\nFigura 5.1. Os dois sentidos de aplicac?a?o das leis\n\nsistema na comunicac?a?o com o ambiente externo. Inicialmente, assumimos que todas\nas demais ca?psulas do modelo estar contidas no diagrama de estrutura de MAIN. Desta\nmaneira, StrM e? expresso pelo diagrama hiera?rquico de estrutura de MAIN, e toda ca?psula\nque reagir a um estimulo externo, interage direta ou indiretamente com alguma porta\nde MAIN. Apo?s isto toda a hierarquia de StrM e? destru??da e redunda?ncias no modelo\nsa?o removidas, assegurando que todo o comportamento do modelo esta contido em suas\nca?psulas. Em seguida o objetivo e? compor as ca?psulas duas-a-duas, em uma u?nica ca?psula,\nate? que reste uma u?nica ca?psula no modelo (MAIN).\n\nEsta estrate?gia e? efetuada atrave?s da sequ?e?ncia de passos abaixo. As leis referenciadas\nem cada passo sa?o exaustivamente aplicadas no modelo. Esta sequ?encia de passos e?\nexecutada ciclicamente, ate? que as leis na?o possam ser mais aplicadas.\n\ni) Combinar portas de ca?psulas. As ca?psulas devem ter uma u?nica conexa?o bina?ria\nentre si, utilizando, cada uma delas, uma u?nica porta (aplicac?a?o da Lei 4.13, da\nesquerda para a direita);\n\nEste passo e? utilizado principalmente para adequar a comunicac?a?o entre as ca?psulas\nao padra?o de aplicac?a?o das leis dos pro?ximos passos. Ale?m disto, e? u?til tambe?m\npara diminuir portas redundantes no modelo. Em nosso estudo de caso (Figura 2.2),\ntodas as insta?ncias de ca?psulas comunicam-se entre si atrave?s de uma u?nica conexa?o\nbina?ria, e por isto a aplicac?a?o desta lei e? desnecessa?ria.\n\nii) Eliminar hierarquia no diagrama de estrutura das ca?psulas. Componentes de ca?psulas\n(insta?ncias) situadas na estrutura de outra ca?psula devem ser movidas para o n??vel\nde estrutura superior, que conte?m esta outra ca?psula (aplicac?a?o das leis C.6, C.5\ne 4.12, da direita para a esquerda).\n\nEm nosso estudo de caso, explicitamos a ca?psula Main no modelo. Isto pode ser feito\natrave?s da sua criac?a?o (aplicac?a?o da Lei 4.1 da esquerda para a direita) e inserc?a?o\nde uma insta?ncia man do tipo Main em StrM; a ca?psula ProdSys pode ser movida\npara dentro do diagrama de estrutura de Main a partir da aplicac?a?o da Lei C.6 (da\ndireita para a esquerda).\n\nEnta?o, devemos eliminar as insta?ncias de ca?psulas sin e son da hierarquia de ProdSys,\nresultando em arquitetura plana, sem a existe?ncia de subca?psulas, como e? mostrado\nna Figura 5.2. Nesta figura, a Lei C.5 foi aplicada duas vezes para que a ca?psula\nsin e son fossem retiradas da estrutura de sys.\n\niii) Mover comportamento para ca?psulas. Todo o comportamento do modelo deve estar\n\n\n\n5.1 estrate?gia de normalizac?a?o 65\n\nFigura 5.2. Passo ii da normalizac?a?o do Estudo de Caso\n\nsituado dentro de suas ca?psulas; protocolos na?o devem conter qualquer comporta-\nmento associado (aplicac?a?o da Lei 4.14, da esquerda para a direita);\n\nNo sistema de automac?a?o industrial, o u?nico protocolo que possui um comporta-\nmento associado e? STO. Este esta? associado a?s portas so e pi nas ca?psulas Storage e\nProdSys. Para que possamos aplicar a lei que move o comportamento do protocolo\npara uma ca?psula, precisamos proteger as portas so e pi e criar relay ports que\ninterliguem elas ao ambiente externo, atrave?s da Lei 4.10.\n\nEm seguida, podemos mover o comportamento do protocolo STO para uma ca?psula\nSTOC no modelo, atrave?s da Lei 4.14. Toda as ca?psulas que possu??rem uma asso-\nciac?a?o com STO, passaram a possuir uma nova subca?psula de tipo STOC em seu\ndiagrama de estrutura que controla o fluxo de informac?o?es da conexa?o a?s portas\ndo tipo STO, tal qual a porta o fazia. Observamos que o diagrama de estrutura\ne? bastante complexo e que pode ser reduzido a uma forma mais amiga?vel atrave?s\nda aplicac?a?o da Lei C.5 para desencapsular as insta?ncias do tipo STOC de dentro\nda estrutura de Storage e ProdSys, e removermos uma das insta?ncias redundantes\nque intermediam a comunicac?a?o entre sin e sys, atrave?s da aplicac?a?o da Lei 4.11,\nresultando no modelo da Figura 5.3.\n\nApesar do resultado obtido possibilitar a aplicac?a?o do pro?ximo passo de norma-\nlizac?a?o, notamos que as insta?ncias da ca?psula STOC? na?o restringem nenhuma co-\nmunicac?a?o na conexa?o; na realidade, as ca?psulas Storage e ProdSys ja? obedecem a\nesta restric?a?o, sempre enviando ou recebendo um sinal req antes de sincronizarem\ncom o sinal output. Por isso, podemos remover as insta?ncias das subca?psula c e c?\n\nque intermediam as conexo?es entre as insta?ncias sin, sys e son em StrM, atrave?s da\naplicac?a?o da Lei 4.11. O resultado e? um modelo ide?ntico ao da Figura 5.2, exceto\n\n\n\n5.1 estrate?gia de normalizac?a?o 66\n\nFigura 5.3. Passo iii da normalizac?a?o do Estudo de Caso\n\nque STO na?o possui uma ma?quina de estados associada.\n\niv) Compor ca?psulas. Cada duas ca?psulas que se comuniquem, devem ser encapsuladas\nno diagrama de estrutura de uma nova ca?psula e compostas dentro deste diagrama.\nPara tanto, uma nova ca?psula e? criada a partir da aplicac?a?o da Lei 4.1, e uma\ninsta?ncia de seu tipo e? inserida no mesmo diagrama de estrutura das outras duas\nca?psulas que sera?o compostas (Lei 4.2). A duas ca?psulas devem ser encapsulas\ndentro do diagrama de estrutura desta nova ca?psula (leis C.6 e 4.12), e finalmente\ncompostas dentro da nova ca?psula (aplicac?a?o da Lei 4.20, da direita para a es-\nquerda), reduzindo-se assim a quantidade de ca?psulas do sistemas;\n\nEm nosso estudo de caso, para que possamos compor as ca?psulas sys e son devemos\nencapsula?-las em uma nova ca?psula Controller (criada a partir da Lei 4.1), que\nmediara? qualquer comunicac?a?o externa a sys ou a son. Para tanto, devemos aplicar a\nLei C.6 para encapsular son dentro de con e depois aplicar a Lei 4.12 para encapsular\nsys em con, obtendo como resultado final o modelo exibido na Figura 5.4.\n\nApo?s encapsularmos as duas ca?psulas sys e son podemos compo?-las em uma u?nica\nca?psula atrave?s da aplicac?a?o da Lei 4.20. Cada regia?o das ma?quinas destas ca?psulas\nsera? associada a uma nova regia?o na ma?quina de estados de Controller, descrevendo\no comportamento ativo destas ca?psulas atrave?s do paralelismo destas regio?es. A\nConexa?o entre as portas po e si continuara a ser descrita atrave?s de uma conexa?o\ninterna ao diagrama de estrutura de Controller em StrM, como pode ser visto na\nFigura 5.5.\n\nApo?s a primeira aplicac?a?o da Lei 4.20, notamos que o modelo (visto na Figura 5.5)\nse encontra em um formato que possibilita uma segunda composic?a?o de ca?psulas,\n\n\n\n5.1 estrate?gia de normalizac?a?o 67\n\nFigura 5.4. Primeiro modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de Caso\n\ndesta vez sin e con. Notamos desta maneira que, nas ca?psulas compostas, seus con-\ntroladores sa?o vistos como ca?psulas normais do modelos, e que podem ser compostas\nnovamente. Nesta u?ltima composic?a?o, a ca?psula que conte?m sin e con e? a propria\nca?psula Main que representa todo o sistema, resultando no fim de nosso processo\nde aplicac?a?o. O resultado desta segunda composic?a?o pode ser visto na Figura 5.6.\n\nv) Remover declarac?o?es na?o utilizadas no modelo. Todas os elementos (ca?psulas, pro-\ntocolos, portas, me?todos e atributos) na?o referenciados por outros elementos do\nmodelo devem ser removidos (aplicac?a?o das Leis 4.1, C.1, 4.2, 4.5, 4.6, 4.3, C.2, 4.8\nda direita para a esquerda);\n\nEm nosso estudo de caso, durante a aplicac?a?o das leis, diversas ca?psulas deixaram\nde ter utilidade, como Storage, ProdSys, Controller e STOC. Apesar de na?o serem\nmostradas mais no modelo, nenhuma lei foi utilizada para remover explicitamente\nsuas declarac?o?es. A remoc?a?o da declarac?a?o destes elementos do modelo pode ser\nfeita atrave?s da aplicac?a?o da Lei 4.1 (da direita para a esquerda).\n\nEsta estrate?gia visa unificar as ca?psulas do modelo em uma u?nica ca?psula com todo o\ncomportamento do modelo, como pode ser observado na reduc?a?o de nosso estudo de caso\nna Figura 5.6. Desta forma o modelo resultante e? formado por uma u?nica ca?psula que\nconte?m o comportamento e os dados de todo o modelo, mantendo as mesmas portas de\ncomunicac?a?o, existentes anteriormente, com o ambiente externo. As classes do modelo\nna?o sa?o afetadas.\n\nA simplificac?a?o da ma?quina de estados da ca?psula resultante, reduzindo a quantidade\nde regio?es de S0, na?o e? foco deste trabalho. Isto ser feito atrave?s de leis que envolvem\n\n\n\n5.2 estudo de caso 68\n\nFigura 5.5. Segundo modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de Caso\n\ncondic?o?es de prova na equivale?ncia de diagrama de estados [34].\nEste modelo poderia ser reduzido a uma u?nica ca?psula, sem a existe?ncia de classes\n\nno modelo. Neste caso, passos adicionais devem ser aplicados, como em [9], para reduzir\ntodas as classes do modelo, e incluir as classes na capsula que possui uma associac?a?o\npara elas (aplicac?a?o da Lei 4.19, da direita para a esquerda). Note que, caso a ca?psula\nresultante tenha um comportamento puramente passivo, ela pode ser transformada em\numa classe, atrave?s da Lei 4.21. A classe final desempenharia, enta?o, papel semelhante\nao resultado da estrate?gia de reduc?a?o em [9], que reduz um sistema orientado a objeto\narbitra?rio na linguagem ROOL a uma u?nica classe que representa todo o modelo.\n\nAlgumas leis na?o foram explicitamente referenciadas no processo de normalizac?a?o.\nPor exemplo, as leis 4.15 e 4.17. Entretanto, estas leis sa?o necessa?rias para, por exemplo,\nparticionar uma ca?psula e permitem a aplicac?a?o da Lei 4.20. Similarmente, outras leis\nsa?o usadas na justificativa de leis derivadas, utilizadas no processo de normalizac?a?o ou\npara preparar o modelo em um formato que possibilite a aplicac?a?o de outras leis, como\nas leis 4.10 e 4.15.\n\n5.2 ESTUDO DE CASO\n\nCom a finalidade de ilustrar a aplicac?a?o das leis propostas no Cap??tulo 4, apresentare-\nmos, nesta sec?a?o, a modelagem sistematizada de um sistema simplificado de automac?a?o\nindustrial (ver Sec?a?o 2.3). O sistema utilizado como estudo de caso ja? foi explorado\nem [53], onde a sua modelagem em UML-RT e? apresentada, pore?m sem que nenhuma lei\nde transformac?a?o tenha sido proposta. Aqui, refinamos um modelo abstrato de ana?lise,\nextra??do dos casos de uso do sistema, em um modelo concreto e mais elaborado de projeto,\npro?ximo a uma implementac?a?o. Esta estrate?gia mostra que o conjunto de leis proposto\n\n\n\n5.2 estudo de caso 69\n\nFigura 5.6. Modelo final da composic?a?o de ca?psulas no passo iv da normalizac?a?o do Estudo\nde Caso\n\npode justificar pra?ticas informais de projeto. Em particular, desenvolvemos este estudo\nde caso seguindo algumas das pra?ticas encontradas no Processo Unificado (RUP) [52],\nque sa?o explicadas no decorrer do texto.\n\nNo sistema de automac?a?o industrial [53], toda a aplicac?a?o e? responsa?vel por processar\num nu?mero de pec?as. O sistema consiste dos seguintes dispositivos: um reposito?rio de\nentrada com pec?as na?o processadas, um reposito?rio de sa??da com pec?as ja? processadas,\nalgumas ma?quinas que processam as pec?as e alguns agentes de transporte. Cada pec?a\nna?o processada deve ser retirada do reposito?rio de entrada, passar por todas as ma?quinas\nem um trajeto pre?-definido e ser armazenada no reposito?rio de sa??da. As ma?quinas e\nreposito?rios encontram-se distantes fisicamente, e necessitam requerer pec?as de trabalho\na um elemento de transporte, chamado holon (um agente auto?nomo de transporte).\n\nPor simplicidade, na Sec?a?o 2.3 na?o lidamos com todas as restric?o?es da especificac?a?o,\nrepresentando apenas o comportamento global do sistema, que servira? como ponto de\npartida para o desenvolvimento do estudo de caso. O objetivo, aqui, e? detalhar esta\nmodelagem, mostrando os passos necessa?rios ate? que ele possua duas ma?quinas e um\nagente de transporte. Passos adicionais para se obter o projeto apresentado em [53] sa?o\ndiscutidos no final da sec?a?o.\n\nNo RUP, modelos de ana?lise e projeto sa?o constru??dos a partir da visa?o de casos de\nuso do sistema. Para o propo?sito deste trabalho, as funcionalidades do sistema foram\nreduzidas a tre?s casos de uso: inserir pec?as, recuperar pec?as e processar pec?as (veja\nFigura 2.1, na Sec?a?o 2.3). Inicialmente, o sistema se encontra inativo e sem nenhuma\npec?a; a? medida que o operador do sistema as insere, o sistema processa as pec?as e as\ndisponibiliza para que o operador possa recupera?-las.\n\nEm relac?a?o ao mapeamento de casos de uso no modelo de ana?lise, baseamos nos no\ntrabalho reportado em [101] para extrair um objeto ativo de cada caso de uso do sistema.\nNesta abordagem, apo?s a descric?a?o dos casos de uso, o comportamento dos casos de uso\n\n\n\n5.2 estudo de caso 70\n\nsa?o mapeados em objetos ativos (ca?psulas) que podem utilizar outros objetos passivos\n(classes), sintetizados a partir da descric?a?o dos casos de uso. A especificac?a?o conjunta\ndestas duas categorias de objetos forma o modelo de ana?lise. O modelo que representa\na visa?o de ana?lise de nosso estudo de caso pode ser visto na Figura 5.2, onde a ca?psula\nMain representa todo o sistema, a insta?ncia sin da ca?psula Storage representa o caso de\nuso inserir pec?a, a insta?ncia son da ca?psula Storage representa o caso de uso recuperar\npec?a e a insta?ncia sys da ca?psula ProdSys representa o caso de uso processar pec?a. A\nclasse Piece e? sintetizado a partir da descric?a?o da troca de mensagens entre estas ca?psulas.\nNa estrutura de Main, e? descrita a interac?a?o entre estas ca?psulas e, consequ?entemente,\nentre os casos de uso do sistema: uma u?nica insta?ncia sys recupera pec?as de trabalho\ndiretamente da insta?ncia sin, as processa, e as envia a? ca?psula son.\n\nDiferente desta abordagem, no RUP, o modelo de ana?lise e? derivado a partir de casos\nde uso, ignorando o uso de objetos ativos. Cada caso de uso da? origem a uma classe de\ncontrole com todas as regras de nego?cio do caso de uso, classes de fronteira para cada\ninterac?a?o do sistema com um ator (pessoa ou sistema) do mundo externo e classes de\nentidade com os dados utilizados pelas classes restantes associadas ao caso de uso. Atrave?s\ndesta te?cnica, e? poss??vel separar dados das operac?o?es associadas a?s regras de nego?cio dos\ncasos de uso, bem como das regras de comunicac?a?o do sistema com o ambiente externo.\n\nApesar das diferenc?as, a abordagem utilizada por no?s pode alcanc?ar, atrave?s do uso de\nnossas leis, resultados semelhantes a? te?cnica utilizada no RUP. A ca?psula que representa\ntodo o caso de uso pode ser decomposta em va?rias outras ca?psulas que representem os\npapeis das elementos de controle e fronteira sugeridos no RUP, enquanto entidades, por\nserem naturalmente passivas, continuariam a ser representados atrave?s de classes. Por\nfim, caso cada uma desta ca?psulas (de controle e de fronteira) possuam um comporta-\nmento passivo, elas podem ser transformadas em classes, resultando em um modelo de\nana?lise semelhante ao proposto pelo RUP.\n\nEm nosso estudo de caso, as ca?psulas Storage e Prodsys possuem um comportamento\nativo e representam o papel de controladores de seus respectivos casos de uso, enquanto\nMain serve de fronteira com o mundo externo, neste caso nenhuma regra de comunicac?a?o\ne? atribu??da a Main, que na?o possui por este motivo uma ma?quina de estados associada.\n\nApo?s a criac?a?o de um modelo de ana?lise, o pro?ximo passo e? encontrar uma arquitetura\ncandidata[52]. Nesta atividade do RUP, identificamos os elementos que sa?o abstrac?o?es\nchaves para interac?a?o entre os casos de uso e verificamos a possibilidade de reuso. Ado-\ntamos uma arquitetura de camadas simples onde a manipulac?a?o de dados e? isolada das\nregras de nego?cio. Por esta raza?o inserimos uma colec?a?o de dados para representar a\ncolec?a?o de Pieces em Storage. Esta colec?a?o e? extra??da da ca?psula Storage, atrave?s da\nLei 4.19, em uma nova classe PieceCollection, como e? mostrado na Figura 5.7.\n\nA arquitetura candidata e? incrementalmente aperfeic?oada atrave?s da identificac?a?o de\nnovos elementos de projeto. Como desejamos que nosso modelo possua uma segunda\nma?quina de processamento, decompomos a ca?psula ProdSys em duas outras ca?psulas.\nPara isto, inicialmente necessitamos criar uma nova partic?a?o em ProdSys como parte da\nresponsabilidade do processamento de pec?as de trabalho. Dois novos me?todos processA()\ne processB() sa?o criados em ProdSys (Lei 4.3), de forma que execuc?a?o sequ?encial des-\ntes me?todos seja equivalente a process(). Enta?o, a ac?a?o p = process(x) e? reescrita na\n\n\n\n5.2 estudo de caso 71\n\nFigura 5.7. Arquitetura candidata do Estudo de Caso\n\nac?a?o equivalente var y = processA(x); p = processB(y) (Lei 4.16), e a execuc?a?o da ac?a?o\nprocessB(y); po!input.p e? isolada em uma nova partic?a?o (Lei 4.18). Finalmente, apo?s pos-\nsuirmos duas partic?o?es na ca?psula ProdSys, esta pode ser decomposta em duas novas\nca?psulas (ProcessorA e ProcessorB) atrave?s da Lei 4.20, como e? mostrado na Figura 5.8;\npor questa?o de clareza, algumas relac?o?es entre ca?psulas e protocolos sa?o omitidas no\nmodelo.\n\nOutro elemento crucial da especificac?a?o que falta ser identificado e? o agente de trans-\nporte. Este elemento itermedia a comunicac?a?o entre insta?ncias das ca?psulas Storage,\nProcessorA e ProcessorB, que representam dispositivos fisicamente separados. Para dar\norigem a este elemento de transporte, criamos uma nova insta?ncia de ca?psula em StrM in-\ntermediando a comunicac?a?o entre as insta?ncias das ca?psulas citadas, atrave?s da Lei 4.11.\nEm seguida, combinamos as insta?ncias duas a duas ate? formar uma especificac?a?o inicial\nda ca?psula que representara? o agente de transporte, chamada de Holon. Utilizaremos para\ncombinar estas ca?psulas a Lei C.7, uma versa?o simplificada da Lei 4.20 que na?o requer\nque as partic?o?es se comuniquem. O modelo resultante da aplicac?a?o destas leis pode ser\nvisto na Figura 5.9\n\nOutras mudanc?as podem ser realizadas no modelo como, por exemplo, a unia?o das\nportas pi e pd, e pb e po nas ca?psulas ProcessorA e ProcessorB, respectivamente, atrave?s\nda Lei 4.13. Na?o realizamos estas transformac?o?es, pois na?o diminuiria o potencial de\nreuso do sistema e na?o propiciaria melhoria significativa do modelo.\n\nOutros passos de modelagem que podem ser realizado e? a criac?a?o de um novo agente de\ntransporte (insta?ncia de Holon) em sincronia com hts, atrave?s da aplicac?a?o incremental da\nLei 4.8 a todas as portas de hts, e o refinamentos das ma?quinas de estados de ProcessorA,\nProcessorB e Holon para que apenas um agente efetue o transporte de pec?as a cada\n\n\n\n5.3 concluso?es 72\n\nFigura 5.8. Identificac?a?o de ProcessorA e ProcessorB no Estudo de Caso\n\nrequisic?a?o de uma ma?quina (ProcessorA e ProcessorB), tal qual o modelo existente em [53].\nDesta maneira, as ma?quinas de processamento negociariam o agente de transporte que\npossu??ssem menor custo (de tempo e dista?ncia) para transporte das pec?as entre outras\nma?quinas do sistema ou reposito?rios.\n\nAle?m disto, podemos alterar a ma?quina de estados de Holon para que ela possua\numa partic?a?o encarregada do percurso (entre as ma?quinas e reposito?rios) que as pec?as\ndevem seguir no sistema e outra partic?a?o encarregada pelo transporte propriamente dito.\nAtrave?s da Lei 4.20, a partic?a?o com o roteiro daria origem a uma nova ca?psula Driver\nque pertenceria a? camada de nego?cio da arquitetura do sistema, enquanto a partic?a?o\nresponsa?vel pelo transporte daria origem a uma ca?psula Transporter pertencente a? camada\nde comunicac?a?o da arquitetura do sistema. Na?o nos atemos a estes passos da modelagem\npor eles estarem essencialmente relacionados a mudanc?as nos diagramas de estados do\nmodelos, cujas leis na?o sa?o o enfoque deste trabalho.\n\n5.3 CONCLUSO?ES\n\nNeste cap??tulo, ilustramos a aplicabilidade das leis propostas em um estudo de caso\nreal e discutimos, brevemente, como elas podem ser inseridas em um processo de desen-\nvolvimento. Notamos que, devido a nem todos os processos de desenvolvimento inclu??rem\na noc?a?o de objetos ativos, algumas atividades do processo devem ser adaptadas, sem que\nisto altere o fluxo do processo.\n\n\n\n5.3 concluso?es 73\n\nFigura 5.9. Identificac?a?o de Holon no Estudo de Caso\n\nOutro ponto observado e? que, devido ao nosso enfoque em leis estruturais do modelo,\ncertos passos de modelagem na?o sa?o completamente cobertos, principalmente quando\nestes requerem leis que alterem o diagrama de estados de modelo. Apesar disto, a com-\npletude de nossas leis quando a? visa?o estrutural do modelo na?o e? comprometida, como\nfoi mostrado no estudo de caso.\n\nAle?m disso, demonstramos a abrange?ncia deste conjunto de leis atrave?s dos principais\npassos de uma estrate?gia de normalizac?a?o. Esta estrate?gia foi ilustrada pela norma-\nlizac?a?o do modelo de ana?lise do sistema de automac?a?o industrial ate? uma forma normal,\nrepresentada por um modelo UML estendido com uma u?nica ca?psula.\n\nComo tanto a estrate?gia de reduc?a?o quanto o desenvolvimento do estudo de caso utili-\nzam o mesmo modelo como ponto de partida, a combinac?a?o de ambos e? capaz de ilustrar\no conjunto de passos necessa?rios para desenvolver um modelo monol??tico representado\npor u?nica ca?psula em um modelo mais concreto e modularizado de projeto.\n\n\n\nCAPI?TULO 6\n\nCONCLUSO?ES\n\nNeste trabalho, mostramos a possibilidade de um desenvolvimento rigoroso em UML-\nRT atrave?s do uso de leis de transformac?a?o de modelos. Estas leis sa?o apresentadas de\numa maneira incremental, onde um conjunto de leis ba?sicas e? utilizado para justificar\nleis mais elaboradas e usualmente utilizadas na pra?ticas. Em contraste com a definic?a?o\nusual de regras de transformac?a?o, estas leis sa?o definidas segundo uma sema?ntica formal\ne garantem a preservac?a?o do comportamento do sistema modelado.\n\nPara provarmos a corretude destas leis, necessitamos atribuir uma sema?ntica formal\na UML-RT, atrave?s de seu mapeamento para a linguagem formal OhCircus, enfocando\nos elementos que UML-RT adiciona a UML (ca?psulas, protocolos, portas e conexo?es) e\nconsiderando uma visa?o integrada do modelo envolvendo digramas de classes, estado e\nestrutura. Baseado neste mapeamento sema?ntico, e na sema?ntica das leis de OhCircus,\nno?s mostramos que e? poss??vel (e relativamente simples) provar tais leis de transformac?a?o\nde modelos, a? medida que contribu??mos de uma forma original a? formalizara?o de trans-\nformac?o?es em modelos UML-RT.\n\nApesar de o destino de nossa traduc?a?o ser uma linguagem de especificac?a?o (ao inve?s\nde um modelo matema?tico mais padronizado), a notac?a?o de OhCircus inclui as notac?o?es\nde CSP e Z, ambas formalismos bem conhecidos e maduros. Ale?m disto, a combinac?a?o\ndestas notac?o?es em OhCircus e? formalmente caracterizada com base na Unifying Theories\nof Programming.\n\nNossas leis sa?o apresentadas de uma forma incremental; iniciamos com leis ba?sicas que\ncapturam isoladamente propriedades fundamentais dos elementos de UML-RT. A partir\ndestas, no?s propomos leis mais elaboradas, que formalizam transformac?o?es utilizadas na\npra?tica. As leis lidam com diversos diagramas do modelo (classe, estado e estrutura)\ne sua apresentac?a?o deixa expl??cito os efeitos de sua aplicac?a?o sobre estes diagramas,\ndiferentemente de outras leis que consideram estes diagramas isoladamente.\n\nConsiderando os elementos que UML-RT adiciona a UML, o conjunto de leis proposto\ne? abrangente, e pode ser observado como parte de uma sema?ntica axioma?tica destes ele-\nmentos. A noc?a?o de abrange?ncia destas leis e? baseada na demonstrac?a?o de que um mo-\ndelo arbitra?rio UML-RT pode ser reduzido a um modelo UML estendido com uma u?nica\nca?psula responsa?vel por todas as interac?o?es com o ambiente. Este modelo UML esten-\ndido pode ser visto como uma forma normal, e, portanto, nossa estrate?gia pode ser vista\ncomo uma contribuic?a?o para uma estrate?gia de completude capturada por uma reduc?a?o\na esta forma normal, semelhante a? estrate?gia apresentada em [9] para uma linguagem\nde programac?a?o orientada a objetos. Apesar de na?o termos apresentado uma estrate?gia\nde reduc?a?o em todos os detalhes, mostramos que as leis propostas sa?o abrangentes o\nsuficiente para cobrir transformac?o?es que incluem ca?psulas e protocolos em diagramas de\nclasse e de estrutura.\n\n74\n\n\n\n6.1 trabalhos relacionados 75\n\nOutro ponto importante e? a relac?a?o entre classes e ca?psulas, como capturado pela\nLei 4.21 que transforma, sob determinadas condic?o?es, um elemento no outro. Mostra-\nmos, tambe?m, a aplicac?a?o das leis durante a execuc?a?o de atividades de modelagem de\nana?lise e projeto do RUP atrave?s de um estudo de caso. Como explicado no Cap??tulo 4,\ntransformac?o?es consistentes entre classes no diagrama sa?o livremente permitidas, desde\nque estas na?o interfiram com a interface esperada por ca?psulas que invoquem me?todos\ndestas classes. Isto acontece porque a comunicac?a?o entre ca?psulas e classes e? atrave?s da\nchamada de me?todos e porque ca?psulas na?o compartilham classes entre si. Assim do\nponto de vista destas classes, ca?psulas sa?o simplesmente elementos externos que invocam\nseus servic?os.\n\nApesar de lidarmos, neste trabalho, com um subconjunto da linguagem UML-RT e o\nfato desta linguagem na?o ter sido criada por organizac?o?es de padronizac?a?o (como a OMG),\nsendo mantida pelas empresas que suportam suas ferramentas [19], va?rios conceitos desta\nlinguagem esta?o diretamente presentes em outras linguagens para a descric?a?o de arqui-\nteturas ou de componentes, como ADLs ou UML 2.0 (versa?o ainda na?o finalizada pela\nOMG). Assim, todas as contribuic?o?es que possam ser incorporadas ao desenvolvimento\nusando UML-RT podem, em princ??pio, ser adaptadas para estas linguagens.\n\n6.1 TRABALHOS RELACIONADOS\n\nRelacionado a? formalizac?a?o de modelos visuais orientados a objetos, duas abordagens\nprincipais podem ser identificadas [30]: suplementar e integrac?a?o de me?todos. A primeira\nsubstitui linguagens naturais de documentac?a?o por expresso?es mais formais. A pro?pria\nOCL [70] e? um exemplo desta abordagem, ela e? utilizada em conjunto com UML com o\npropo?sito de anotar o modelo. Na u?ltima abordagem, te?cnicas de modelagem orientadas\na objetos sa?o tornadas mais precisas e receptivas a ana?lises rigorosas atrave?s de sua\nintegrac?a?o com notac?o?es de especificac?a?o formal, mapeando o modelo informal em um\ndom??nio formal e bem definido. Utilizamos a u?ltima abordagem por ela ter, em princ??pio,\num maior apelo pra?tico, ja? que o desenvolvedor pode realizar suas tarefas de modelagem\nna notac?a?o que possuir maior familiaridade sem explicitamente lidar com formalismos,\npore?m baseados em uma notac?a?o u?nica que possibilita a prova de va?rios aspectos do\nmodelo. Um exemplo bem sucedido da integrac?a?o de me?todos formais com linguagens\nvisuais e? a linguagem Alloy [50] que descreve a declarac?a?o de classes, seus relacionamentos\ne propriedades em um diagrama similar ao diagrama de classes em UML. Contudo, apesar\nde Alloy possuir uma sema?ntica bem definida, apenas um subconjunto das viso?es do\nmodelo e? expresso nesta linguagem.\n\nNa literatura, diversos esforc?os te?m se referido aos problemas de integrac?a?o de modelos\nUML com linguagens formais; existem diversas abordagens de especificac?a?o [12, 28, 29,\n78, 69], como a combinac?a?o de UML com Z [95] ou com CSP[79]; tipicamente, cada uma\ndestas contribuic?o?es tende a se concentrar em uma u?nica visa?o do modelo (como diagrama\nde estados [69] ou diagrama de classes [12, 28, 78]). Embora alguns trabalhos como, por\nexemplo, [58, 66] utilizem uma notac?a?o uniforme para descrever um mapeamento que\nconsidere a estrutura e o comportamento do modelo, a apresentac?a?o e? informal e baseada\nem exemplos.\n\n\n\n6.1 trabalhos relacionados 76\n\nA formalizac?a?o de diagramas de classes utilizando a notac?a?o Z e? apresentada em\n[12, 28, 29]; nestas abordagens, classes, associac?o?es e o pro?prio modelo sa?o mapeados em\nesquemas em Z. O esquema que representa o modelo possui a visa?o extensional de suas\nclasses, com o conjunto de todos os objetos do modelo, e as associac?o?es do diagrama de\nclasses. Desta maneira, quaisquer propriedades sobre as classes ou associac?o?es podem\nser incorporadas como predicados deste esquema. Comparac?o?es detalhadas desta abor-\ndagem e de outras que envolvem extenso?es de Z com orientac?a?o a objetos (Object-Z) [93]\nsa?o discutidas em [4]. Estas abordagens para Object-Z usam, em geral, conceitos seme-\nlhantes a? abordagem utilizada em Z, pore?m atrave?s de uma representac?a?o mais sucinta\ndo diagrama de classes, por representarem diretamente algumas das caracter??sticas de\norientac?a?o a objetos de UML.\n\nO mapeamento de classes assumido para OhCircus (uma simplificac?a?o do encontrado\nem [10]) e? semelhante ao encontrado em [78] para Object-Z, onde classes sa?o mapeadas\ndiretamente em construtores da linguagens, associac?o?es sa?o representadas pela instan-\nciac?a?o de atributos adicionais nas classes envolvidas na relac?a?o (localizados de acordo\ncom a navegac?a?o da associac?a?o) e todas as restric?o?es do modelo devem ser expressos\ncomo invariantes destas classes. O trabalho reportado em [78] tambe?m mostra o poder\nde expressividade de Z em relac?a?o a propriedades do modelo descritas OCL, corroborando\ncom outros trabalhos que comparam Z e OCL [49].\n\nCom respeito a? sema?ntica formal de diagramas de estados, o mapeamento destes dia-\ngramas em processos em CSP e? apresentado em [69, 75]. Em [69], ma?quinas de estados sa?o\nmapeadas em processos CSP. Apesar de expressar a hierarquia de ma?quinas de estados,\neste trabalho na?o lida com paralelismo ou estados com histo?ria. Ale?m disto, por utilizar\nsomente CSP, esta abordagem ignora ac?o?es que envolvam operac?o?es sobre os componentes\nde estados ou me?todos de um elemento declarado no modelo.\n\nEm [75], ma?quinas de estados sa?o mapeadas em processos CSP e esquemas em Z, uti-\nlizando a notac?a?o unificada CSP-OZ. Cada estado possui uma representac?a?o sema?ntica\natrave?s de um esquema em Z, enquanto os eventos de comunicac?a?o e a composic?a?o des-\ntes estados sa?o realizados atrave?s de processos em CSP. Desta maneira, os principais\nconceitos de ma?quina de estados, como hierarquia, concorre?ncia e estados com historia\nsa?o mapeados em uma notac?a?o u?nica que permite uma integrac?a?o com mapeamentos de\ndiagrama de classes. Apesar de lidar com hierarquia de estados, transic?o?es complexas\n(por exemplo, transic?o?es entre diferentes n??veis da hierarquia que atravessam a borda de\nestados compostos) na?o sa?o cobertos neste trabalho; as u?nicas transic?o?es expressas em\nestados compostos sa?o transic?o?es de grupo. Apesar destes tipos de transic?o?es comple-\nxas permitirem a violac?a?o do encapsulamento de estados compostos, elas sa?o necessa?rias\npara indicar diferentes estados de aceitac?a?o ou falha da subma?quina de estados de um\nestado composto [92]; sendo, esta propriedade crucial em nossas leis para simplificar a\nrepresentac?a?o de subma?quina de estados em um u?nico estado.\n\nPor esta raza?o, optamos por estender o trabalho [69] utilizando a notac?a?o de OhCir-\ncus. Adaptac?o?es foram necessa?rias para permitir ac?o?es sobre atributos e me?todos das\nca?psulas, e a inserc?a?o de paralelismo atrave?s de And-States. Neste sentido, o mapea-\nmento de estados compostos foi completamente alterado para permitir os diversos tipos\nde transic?o?es sobre And-States, utilizando uma abordagem similar a? encontrada em [75]\n\n\n\n6.1 trabalhos relacionados 77\n\nna utilizac?a?o de eventos de comunicac?a?o para notificar a sa??da destes estados compos-\ntos para os seus sub-estados (ver Sec?a?o 3.2.2); estados historia na?o foram abordados\nneste trabalho por na?o serem necessa?rios em nossas leis, ja? que na?o focamos em leis para\ndiagramas de estados.\n\nRelacionado a? formalizac?a?o de UML-RT, limitac?o?es similares a?s encontradas na in-\ntegrac?a?o de me?todos formais e UML podem ser encontrada em trabalhos [32, 27, 24]\nque formalizam UML-RT utilizando CSP. Eles focam na traduc?a?o da visa?o estrutural de\nUML-RT em CSP [32], e consideram a representac?a?o comportamental das ca?psulas [27, 24]\nsomente parcialmente. Por lidarem isoladamente com as viso?es de um modelo UML-RT,\nestes trabalhos apresentam deficie?ncias quando analisamos as diversas viso?es do modelo\nem conjunto, como discutido adiante.\n\nEm [32] a visa?o estrutural (contido no diagrama de estrutura) das portas, ca?psulas e\nconectores sa?o representados por classes e processos em CSP-OZ, e a renomeac?a?o de ca-\nnais de comunicac?a?o para o mesmo nome destas portas e? utilizado para a composic?a?o de\nca?psulas, sendo esta a estrate?gia utilizada por no?s na composic?a?o (conexa?o) de ca?psula\nem um diagrama de estrutura. Nenhuma refere?ncia a outros elementos declarados no\ndiagrama de estado ou classes e? feita neste trabalho. Apesar de em [66] os trabalhos\nreportados em [32] e em [75] serem referenciados conjuntamente em uma estrate?gia para\na traduc?a?o dos diagramas de estrutura, estados e classes de UML-RT para CSP-OZ, o\nmapeamento e? feito de maneira informal e atrave?s de exemplos, sem nenhuma refere?ncia\npara: como o comportamento dos protocolos associados a?s portas de uma conexa?o e? incor-\nporado na comunicac?a?o entre as ca?psulas; como regio?es de AND-State em um diagrama\nde estados de uma ca?psula devem ser sincronizadas entre si ou com outras ma?quinas de\nestados do modelo; ou quais condic?o?es sa?o necessa?rias para a composic?a?o de uma ca?psula\na outra.\n\nO trabalho reportado em [27, 24] apresenta brevemente algumas noc?o?es que podem ser\nutilizadas como base para o mapeamento de UML-RT em CSP, pore?m baseado somente\nnestas noc?o?es parece ser dif??cil o mapeamento de sistemas complexos em todos os seus\naspectos. Estes trabalhos citam brevemente ma?quinas de estados simples de ca?psulas [27]\ne protocolos [24] e contribuem com o mapeamento do diagrama de estruturas atrave?s do\nmapeamento de conectores como processos CSP [27], apresentando ainda assim os mesmos\nproblemas atribu??dos aos trabalhos [66, 32, 75], ale?m disto, na?o lidam com a hierarquia\nde diagramas de estrutura e estado.\n\nRelacionado a leis para UML, existem diversos trabalhos [41, 28, 29, 38, 55, 96] que\nconsideram transformac?o?es para classes e diagramas de estados que consideramos com-\nplementares ao nosso trabalho. Diferentemente das leis apresentadas no Cap??tulo 4, as\nleis apresentadas nestes trabalhos lidam com um modelo mais abstrato, na?o considerando\nassociac?o?es como atributos de classes no diagrama de classes ou ac?o?es no diagrama de\nestados. Ale?m disto, as leis propostas nestes trabalhos consideram restric?o?es globais ao\nmodelo, como aquelas que envolvem o nu?mero de insta?ncias de classes em todo o sistema;\nem nosso trabalho, propriedades sa?o restritas aos invariantes das classes e ca?psulas.\n\nEm [28, 29, 37] leis sobre diagramas de classe sa?o consideradas incluindo uma sema?ntica\nformal para UML, utilizando Alloy [37] e Z [28, 29], bem como a prova da validade destas\nleis; no trabalho reportado em [41], regras de transformac?a?o sa?o apresentadas baseadas\n\n\n\n6.1 trabalhos relacionados 78\n\nna linguagem semi-formal OCL. Destacamos o trabalho reportado em [37] por apresentar\num conjunto abrangente de leis ba?sicas para Alloy, e que podem ser facilmente aplicadas a\ndiagramas de classe. Semelhante ao nosso trabalho, em [37] leis mais elaboradas e usual-\nmente aplicadas na pra?tica sa?o derivadas da composic?a?o de leis mais ba?sicas. Como dito\nanteriormente, estes trabalhos interpretam o modelo em um n??vel mais abstrato, onde as-\nsociac?o?es na?o sa?o necessariamente direcionais nem tampouco geram atributos nas classes\nque relacionam. Por esta raza?o, estas leis sa?o mais gerais que as nossas e permitem des-\ncrever uma quantidade maior de propriedades sobre as classes do modelo. Contudo, leis\npara classes na?o sa?o o foco de nosso trabalho e somente sa?o utilizadas para complementar\nas leis que propomos para os elementos que UML-RT adiciona a UML.\n\nAs transformac?o?es de modelos UML apresentadas em [55, 96] contemplam diagra-\nmas de estado, em adic?a?o a? diagramas classe, pore?m os efeitos em cada diagrama sa?o\nconsiderados isoladamente, e portanto qualquer interfere?ncia entre aspectos esta?ticos e\ndina?micos sa?o ignorados, diferentemente da nossa abordagem que considera estes efei-\ntos simultaneamente. Em particular, [55] apresenta uma sema?ntica formal para UML,\nOCL e statecharts em termos de Real-time Action Logic (RAL), e apresenta e prova\nalgumas transformac?o?es. Em [96], uma relac?a?o entre os conceitos de refactoring para\nco?digo e transformac?o?es de modelos sa?o apresentadas de maneira informal, mostrando a\npreservac?a?o de comportamento em algumas transformac?o?es para diagramas de estado e\nde classe.\n\nRelativo a leis de transformac?a?o para UML-RT, poucos trabalhos [85, 25, 63] foram\nencontrados; em sua maioria, apenas a utilidade destas leis sa?o mencionadas em um pro-\ncesso de desenvolvimento passo-a-passo [85] ou na verificac?a?o de consiste?ncia do modelo\ndurante sua evoluc?a?o [25], utilizando UML-RT.\n\nEm [85], e? proposto um processo de desenvolvimento incorporando noc?o?es de refina-\nmento, baseadas em princ??pios particulares de refinamento comportamental de interfaces\ndo componentes (ca?psulas) da aplicac?a?o e incorporac?a?o de tempo. O primeiro tipo de\ntransformac?a?o permite que as interfaces de uma ca?psula sejam alteradas levando-se em\nconsiderac?a?o sua ma?quina de estados, enquanto o segundo tipo sugere que sincronismo\ne aspectos temporais sejam ignorados nos esta?gios iniciais do desenvolvimento, e que\no modelo, inicialmente ass??ncrono, seja refinando para adiciona-los durante o desenvol-\nvimento. Na?o consideramos em nosso trabalho aspectos temporais, assincronismo, ou\nmesmo refinamentos. Apesar disto, o refinamento comportamental de interfaces propo?e\nque o comportamento observado do componente na?o deve ser alterado, sendo semelhante\na algumas de nossas leis que lidam com a visa?o estrutural do modelo, sem alterar seu\ncomportamento, como leis para a conexa?o (Lei 4.8), substituic?a?o (Lei 4.9) e decomposic?a?o\n(Lei 4.20) de ca?psulas (ver Cap??tulo 4).\n\nEm [25], o principio da localidade e? explorado, formalizando a evoluc?a?o de modelos\natrave?s de leis ba?sicas de transformac?a?o; este trabalho tambe?m analisa o efeito destas\ntransformac?o?es na consiste?ncia de algumas propriedades do modelo, como deadlock e\ncompatibilidade de interface. Nenhum destes trabalhos, todavia, apresenta a aplicac?a?o\ndas leis de uma maneira sistema?tica, com fizemos aqui. Apesar de algumas leis serem\nintroduzidas (como, por exemplo, a introduc?a?o de uma ca?psula, porta ou conexa?o), ne-\nnhum padra?o para os termos a? esquerda e a? direita da lei, nem tampouco as condic?o?es\n\n\n\n6.2 trabalhos futuros 79\n\nexpl??citas para suas aplicac?o?es, sa?o apresentados. Em [63], uma u?nica lei para a delegac?a?o\nde responsabilidades de uma ca?psula a subca?psulas e? apresentada, tal qual a Lei 4.20. A\ndiferenc?a existente entre as duas e? que a lei proposta em [63] considera a possibilidade\nde uma das partic?o?es da ca?psula na?o ser movida para uma nova subca?psula, sendo este\napenas um dos passos da derivac?a?o da Lei 4.20 (ver Sec?a?o 4.2).\n\nSob um determinado ponto de vista, propomos leis alge?bricas que descrevem propri-\nedades ba?sicas sobre os elementos que UML-RT adiciona a UML, de forma semelhante\na outras leis alge?bricas para alguns paradigmas da programac?a?o, como, por exemplo, o\norientado a objetos [9], o imperativa [46] e o concorrente [80], ou a linguagens de modela-\ngem como Alloy [37]. Apesar de UML-RT possuir algumas caracter??sticas encontradas em\nalguns deste paradigmas, nossa noc?a?o de equivale?ncia na?o pode ser baseada diretamente\nem nenhum deles, e por esta raza?o utilizamos em nossas leis uma noc?a?o de equivale?ncia\nbaseada na sema?ntica de OhCircus, que por sua vez e? baseada na UTP. Nossa estrate?gia\nde reduc?a?o a uma forma normal tambe?m e? similar a alguns destes trabalhos [9].\n\nNo contexto do desenvolvimento utilizando Model Driven Architecture (MDA) [65],\nnossas leis sa?o classificadas como leis horizontais, por na?o alterarem o n??vel de abstrac?a?o\ndo modelo quanto a sua plataforma. Ale?m disto, os modelos utilizados por no?s encontram-\nse em um n??vel intermedia?rio de abstrac?a?o da plataforma, por incorporarem uma visa?o\npro?xima da implementac?a?o; nossos modelos utilizam uma linguagem para a descric?a?o de\nac?o?es no diagrama de estados e lidam com associac?o?es como atributos. Apesar disto, o\nmodelo possui ainda assim um grande n??vel de abstrac?a?o e pode ser mapeado para diversas\nplataformas espec??ficas, que descrevam, por exemplo, a tecnologia de comunicac?a?o das\nca?psulas e a representac?a?o destas na linguagem destino. Ale?m disso, nosso mapeamento\npara OhCircus pode ser visto como uma transformac?a?o para um modelo transversal\ncom o intuito de verificar e validar propriedades do modelo. Nossas leis ainda podem\nser aplicadas em um processo de desenvolvimento tradicional, como o RUP, que utilize\nUML-RT [5, 42, 1].\n\n6.2 TRABALHOS FUTUROS\n\nApesar de termos proposto um conjunto abrangente de leis ba?sicas, e discutido sua\nabrange?ncia atrave?s de uma estrate?gia de reduc?a?o a uma forma normal, a completude\ndeste conjunto na?o foi provada formalmente. As leis cobrem os principais passos da\nestrate?gia, mas leis adicionais (principalmente referente a transformac?o?es de diagrama de\nestados) sa?o necessa?rias.\n\nAle?m disto, derivac?o?es de novas leis de maior granularidade podem ser necessa?rias\npara facilitar as tarefas realizadas pelo desenvolvedor durante a modelagem de sistemas.\nTais leis devem ser encontradas a partir da ana?lise de um conjunto amplo de estudos de\ncaso e padro?es de projeto para UML-RT. Ale?m disto, estudos sobre a incorporac?a?o de\nmodelos e transformac?o?es de modelos em processos de desenvolvimento [60, 51, 2] ainda\nse encontram em um estado bastante incipiente. Maiores estudos nesta a?rea podera?o\nrevelar novas aplicac?o?es de transformac?a?o de modelos, e , consequ?entemente, a definic?a?o\nde novas leis derivadas a partir das leis ba?sicas de transformac?a?o.\n\nOutro trabalho futuro e? expandir o escopo de nossas leis para lidar com caracter??sticas\n\n\n\n6.2 trabalhos futuros 80\n\nencontradas comumente em linguagens orientadas a objetos, como a heranc?a de classes\ne ca?psulas, e introduzir sema?ntica de refere?ncia para classes. Para isto, ale?m de neces-\nsitarmos atribuir uma sema?ntica para heranc?a comportamental de ca?psulas, ainda na?o\nbem definida, precisar??amos formalizar tais caracter??sticas de orientac?a?o a objetos na\nsema?ntica para OhCircus, que ainda esta? em processo de definic?a?o. Outro campo de\nestudo que merece especial interesse e? o desenvolvimento orientado a? agentes, onde se\nverifica uma grande semelhanc?a entre o conceito de ca?psulas e agentes. Um exemplo de\numa metodologia que utiliza UML-RT para modelar agentes e? encontrado em [14].\n\nObservamos, tambe?m, a necessidade de verificar a relac?a?o entre nossas leis de mo-\ndelagem e leis de programac?a?o, especialmente em linguagens de programac?a?o que lidam\ncom objetos ativos, como JCSP [97]. Isto possibilita o desenvolvimento rigoroso em\nUML-RT lidar com tre?s n??veis distintos de abstrac?a?o do sistema, utilizando modelos em\nUML-RT, especificac?o?es em OhCircus e implementac?o?es em JCSP, baseado em trabalhos\nque mostram o mapeamento entre estas linguagens [72, 74]. Este desenvolvimento seria\nsemelhante a? abordagem em [66], que mapeia UML-RT em Java e CSP-OZ, pore?m intro-\nduzindo leis de transformac?a?o como parte essencial de seu processo. Adicionalmente, a\nmecanizac?a?o destas leis de transformac?a?o facilitariam sua utilizac?a?o pra?tica e automac?a?o\nde tarefas de modelagem.\n\nPor fim, acreditamos que as contribuic?o?es deste trabalho podem ser incorporadas no\ndesenvolvimento baseado em componentes ativos em UML 2.0, que traz va?rios dos con-\nceitos de UML-RT em sua definic?a?o, contribuindo, assim, para a integrac?a?o de me?todos\nformais com uma linguagem de modelagem padronizada e amplamente utilizada pela\ncomunidade.\n\nDesta maneira, uma prova?vel lista de trabalhos futuros inclui:\n\n\u2022 Prova formal de todo o conjunto de leis ba?sicas;\n\n\u2022 Formalizac?a?o da estrate?gia de reduc?a?o do conjunto de leis ba?sicas;\n\n\u2022 Emprego de novos estudos de casos, e a derivac?a?o de padro?es de projeto para UML-\nRT;\n\n\u2022 Estudo do relacionamento de leis de transformac?a?o de modelos em UML-RT e leis\npara linguagens de programac?a?o;\n\n\u2022 Estudo da integrac?a?o de leis de transformac?a?o em processos de desenvolvimento\nrigorosos, que incorporem linguagens formais, de modelagem e de implementac?a?o;\n\n\u2022 Mecanizac?a?o das leis de transformac?a?o de modelos;\n\n\u2022 Incorporac?a?o das contribuic?o?es deste trabalho a com outras linguagens de modela-\ngem, como UML 2.0 e Linguagens de Descric?a?o de Arquitetura.\n\n\n\nAPE?NDICE A\n\nSINTAXE COMPLETA DE OHCIRCUS\n\nProgram ::= OhCircusParagraph?\n\nOhCircusParagraph ::= Paragraph\n| ChannelDefinition | ChanSetDefinition\n| OhProcessDefinition | ClassDefinition\n\nChannelDefinition ::= channel CDeclaration\nCDeclaration ::= SimpleCDeclaration | SimpleCDeclaration; CDeclaration\nSimpleCDeclaration ::= N+ | N+ : Expression | Schema?Exp\nChanSetDefinition ::= chanset N == CSExpression\nCSExpression ::= {||} | {| N+ |} | N\n\n| CSExpression ? CSExpression | CSExpression ? CSExpression\n| CSExpression \\ CSExpression\n\nOhProcessDefinition ::= process N =? [extends N] Process\nProcess ::= begin PParagraph?\n\n[stateSchema?Exp]\nPParagraph?\n\n[\u2022 Action]\nend\n\n| CompProcess\nCompProcess ::= N | Proc; Process | Process \\ CSExpression\n\n| Process 2 Process | Process u Process | Process ||| Process\n| Process |[ CSExpression ]| Process | Process[N+ := N+]\n| Declaration ? Process | ; Declaration ? Process\n| 2 Declaration ? Process |u Declaration ? Process\n| ||| Declaration ? Process | Declaration ? ProcessbExp+c\n| ? Declaration |[ CSExpression ]|?Process\n| Declaration \u2022 Process | ; Declaration \u2022 Process\n| 2 Declaration \u2022 Process |u Declaration \u2022 Process\n| ||| Declaration \u2022 Process | Declaration \u2022 Process(Exp+)\n| ? Declaration |[ CSExpression]| \u2022 Process\n\nPParagraph ::= Paragraph | N =? ParAction | nameset N == NSExp\nNSExp ::= {} | N+ | N | NSExp ? NSExp | NSExp ? NSExp\n\n| NSExp \\ NSExp\nParAction ::= Declaration \u2022 Action | Action\nAction ::= Schema?Exp | CSPActionExp | Command | N\n\n81\n\n\n\nsintaxe completa de ohcircus 82\n\nCSPActionExp ::= Skip | Stop | Chaos\n| Communication ? Action | Predicate &amp; Action\n| Action; Action | Action 2 Action | Action u Action\n| Action |[ NSExp | CSExpression | NSExp ]| Action\n| Action ||[NSExp | NSExp]|| Action | ; Declaration \u2022 Action |\n| Action \\ CSExpression | \u00b5 N \u2022 Action | ParAction(Exp+)\n| 2 Declaration \u2022 Action |u Declaration \u2022 Action\n| ? Declaration |[ NSExp | CSExpression | NSExp]| \u2022 Action\n| ||| Declaration ||[NSExp | NSExp]||\u2022 Action\n\nCommunication ::= NCParameter?\n\nCParameter ::= ?N |?N : Predicate |!Expression | .Expression\nClassDefinition ::= class N =? [extends N]begin CParagraph?\n\n[state StateSchema] CParagraph?\n\n[initial Schema?Exp] CParagraph?\nend\n\nCParagraph ::= Paragraph | Qualifier N =? ParametrisedCommand\nQualifier ::= public | protected | private | logical\nParametrisedCommand ::= Schema?Exp | Command\n\n| ParameterDeclaration \u2022 Command\nParameterDeclaration ::= ParameterQualifier Declaration\n\n| ParameterQualifier Declaration; ParameterDeclaration\nParameterQualifier ::= val | res\nCommand ::= N+ : [Pred, Pred] | N+ := Expression+ | \u00b5 N \u2022 Command\n\n| var Declaration \u2022 Command | super.N(OhExpression?)\n| OhExpression.N(OhExpression?)\n| Command; Command | if GuardedCommands fi\n\nGuardedCommands ::= Predicate ? Command\n| Predicate ? Command 2 GuardedCommands\n\nOhExpression ::= Expression\n| this | null | new N[(OhExpression+)]\n| OhExpression.N | OhExpression : N(OhExpression?)\n| super.N | super.N(OhExpression?)\n| OhExpression instanceof N | (N)OhExpression\n\n\n\nAPE?NDICE B\n\nLEIS DE CSP\n\nDevido a Circusutilizar a mesma sema?ntica de va?rios operadores de CSP [79], leis ba?sicas\nde CSP sobre estes operadores sa?o tambe?m leis de Circus.\n\nUma destas leis e? a distribuic?a?o de renaming atrave?s da composic?a?o paralela (Lei B.1).\nReferenciada tambe?m como f [.]?|[X ]|?dist.\n\nLei B.1 (Distribuic?a?o paralela de renaming)\n\nf [P |[ X ]| Q] = (f [P ] |[ f [X ]|]f [Q])\n\nSomente se: f e? uma func?a?o injetiva. 2\n\nA lei a seguir mostra a distribuic?a?o de hiding atrave?s da composic?a?o paralela (Lei B.2).\nReferenciada tambe?m como hide |[ X ]|?dist.\n\nLei B.2 (Distribuic?a?o paralela de hiding)\n\n(P |[ X ]| Q) \\ Z = (P \\ Z ) |[ (X ]| (Q \\ Z )\n\nSomente se: X ? Z = {} 2\n\nA pro?xima lei mostra a simetria de renaming sobre o operador de hiding (Lei B.3).\nReferenciada tambe?m como f [.]?hide?sym.\n\nLei B.3 (Simetria de renaming sobre hiding)\n\nf [P \\ X ] = f [P ] \\ f [Z ]\n\nSomente se: X ? Z = {} , e f e? uma func?a?o injetiva. 2\n\nOutras duas leis expressa?o a associatividade (Lei B.4) e simetria (Lei B.5) da com-\nposic?a?o paralela. Referenciada tambe?m como |[X ]|?assoc e |[X ]|?sym.\n\nLei B.4 (Associatividade do paralelismo)\n\nP |[ X ]| (Q |[ X ]| R) = (P |[ X ]| Q) |[ X ]| R\n\nLei B.5 (Simetria do paralelismo)\n\nP |[ X ]| Q = Q |[ X ]| P\n\nUtilizaremos os fato que o operador de paralelismo somente e? idepotente sob deter-\nminadas condic?o?es. Referenciada este fato como a Lei |[X ]|?idem.\n\n83\n\n\n\nleis de csp 84\n\nLei B.6 (Indepote?ncia do operador de paralelismo)\n\nP = P |[ ?P ]| P\n\nSomente se: P e? um processo determin??stico. 2\n\nTambe?m utilizaremos o fato que canais na?o utilizados no sincronismo de um operador\nde paralelismo sa?o redundantes. |[cs ]|?null .\n\nLei B.7 (Restric?a?o de canais)\n\nP |[ ?P ? ?Q ? cs ]| Q = P |[ ?P ? ?Q ]| Q\n\n\n\nAPE?NDICE C\n\nLEIS DE TRANSFORMAC?A?O PARA UML-RT\nADICIONAIS\n\nSemelhante a? Lei 4.1, a pro?xima lei estabelece quando e? poss??vel introduzir um novo\nprotocolo ao modelo.\n\nLei C.1 Declarar Protocolo\n\nCondic?o?es:\n\n(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado X.\n(?) Nenhuma elemento em ClsM tem uma relac?a?o com o protocolo X.\n\nSimilarmente a? Lei 4.1, para se remover um protocolo X e? necessa?rio que nenhum outro\nelemento o utilize, seja em associac?o?es, que criam como consequ?e?ncia portas de tipo X,\nou em generalizac?o?es. Assim, uma porta com tipo X na?o pode ser usada em um diagrama\nde estado ou estrutura e, portanto, a apresentac?a?o destes diagramas e? irrelevante (pela\nmesma raza?o que a Lei 4.1).\n\nAssumimos que incomes e outgoings representam, respectivamente, os conjuntos de\nsinais de entrada e de sa??da do protocolo.\n\nSemelhante a outros trabalhos que lidam com leis para classes em UML [38], A\npro?xima lei estabelece quando e? poss??vel introduzir uma nova classe ao modelo.\n\nLei C.2 Declarar Classe\n\nCondic?o?es:\n\n(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado A.\n(?) Nenhuma elemento em ClsM tem uma relac?a?o com a classe A.\n\n85\n\n\n\nleis de transformac?a?o para uml-rt adicionais 86\n\nSimilarmente a? Lei 4.1, para se remover uma classe A e? necessa?rio que nenhum outro\nelemento a utilize, atrave?s de associac?o?es ou em generalizac?o?es em ClsM. A adic?a?o de uma\nclasse implica ClsM que esta podera? ser utilizada por outras classes ou ca?psulas do modelo,\nque devem estar obrigatoriamente declaradas em ClsM, como a lei impo?e condic?o?es que a\nclasse A na?o e? utilizada por outros elementos do modelo, a apresentac?a?o de outras viso?es\nM sa?o irrelevante.\n\nA pro?xima lei estabelece quando e? permitido renomear uma ca?psula.\n\nLei C.3 Renomear Ca?psula\n\nCondic?o?es:\n(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado B.\n(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado A.\n\nComo consequ?e?ncia da renomeac?a?o de uma ca?psula A para B, na Lei C.3, todas as\ninsta?ncias de A em StrM passariam a ter o tipo B; analogamente, na aplicac?a?o da direita\npara a esquerda, todas as insta?ncias de B passariam a ter o tipo A. Apesar de sua\nsimplicidade, esta lei e? importante quando desejamos substituir uma ca?psula no sistema\npor outra de mesmo nome; ate? que a ca?psula original seja removida do modelo, as duas\nca?psulas sa?o declaradas no modelo com nomes distintos. Apo?s a substituic?a?o e remoc?a?o\nda ca?psula original, a nova ca?psula e? renomeada.\n\nA pro?xima lei estabelece quando e? permitido adicionar ou remover sinais de entrada\nem um protocolo.\n\nLei C.4 Introduzir Sinal de Entrada\n\nCondic?o?es:\n(?) Na?o existe nenhum sinal chamado s no protocolo X.\n(?) Nenhum diagrama de estados em StaM usa o sinal s.\n\nA Lei C.4 e? ana?loga a? Lei 4.6, diferenciando-se apenas em relac?a?o a? direc?a?o do sinal\ninserido. Semelhante a? Lei 4.6, a Lei C.4 possui uma restric?a?o quanto ao uso do nome do\nnovo elemento (sinal) em seu contexto local (protocolo) e quanto ao uso deste elemento\nnos diagramas de estado do modelo.\n\nA pro?xima lei expressa como a associac?a?o entre duas ca?psulas pode ser movida para\noutra ca?psula que na?o possui subca?psulas.\n\n\n\nleis de transformac?a?o para uml-rt adicionais 87\n\nLei C.5 Encapsular Ca?psula 2\n\nCondic?o?es:\n\n(?) Nenhum nome de porta em cps? coincide com um nome em csp; Em todo contexto em StrM\nonde existir uma insta?ncia de C, a porta t? estara? conectada a? porta t de uma insta?ncia\nde B.\n\n(?) O protocolo T e todos protocolos associados a?s portas em bps e aps? possuem uma ma?quina\nde estados determin??stica.\n\nEsta lei e? ana?loga a? Lei 4.12, diferenciando-se apenas a? estrutura encontrada na\nca?psula C. No lado direito da Lei 4.12, como consequ?e?ncia da mudanc?a da associac?a?o b\nde A para C, a insta?ncia b e? transferida para o diagrama de estrutura de C. Assim, a\ninsta?ncia b passa a fazer parte da estrutura interna de C e a necessitar de um conjunto\nde portas cps? em c para ter acesso ao mundo externo; todas as conexo?es que existiam\nem bps passam a se conectar a? cps?.\n\nA pro?xima lei expressa como a associac?a?o entre duas ca?psulas pode ser movida para\noutra ca?psula que na?o possui portas.\n\n\n\nleis de transformac?a?o para uml-rt adicionais 88\n\nLei C.6 Encapsular Ca?psula 3\n\nCondic?o?es:\n\n(?) Todos protocolos associados as portas em bps e aps? possuem uma ma?quina de estados\ndetermin??stica.\n\nEsta lei e? ana?loga a? Lei C.5, diferenciando-se apenas por C na?o possuir nenhuma porta\nassociada. No lado direito da Lei 4.12, como consequ?e?ncia da mudanc?a da associac?a?o b\nde A para C, a insta?ncia b e? transferida para o diagrama de estrutura de C. Assim, a\ninsta?ncia b passa a fazer parte da estrutura interna de C e a necessitar de um conjunto\nde portas cps? em c para ter acesso ao mundo externo; todas as conexo?es que existiam\nem bps passam a se conectar a? cps?.\n\nA lei a seguir decompo?e uma ca?psula A no paralelismo de insta?ncias de ca?psulas (B e\nC) que na?o se comunicam entre si.\n\n\n\nleis de transformac?a?o para uml-rt adicionais 89\n\nLei C.7 Decomposic?a?o Paralela Simples de uma Ca?psula\n\nCondic?o?es:\n\n(?) ?batts, binv, bmeths, bps, Sb? e ?catts, cinv, cmeths, cps, Sc? particionam A; os protocolo as-\nsociados a?s portas em bps e cps possuem uma ma?quina de estados determin??stica.\n\nAnalogamente a? 4.20, a Lei C.7 requer que a ca?psula A seja particionada, onde cada\npartic?a?o deve ser auto-contida e fazer uso somente acesso aos atributos e aos me?todos da\npartic?a?o. Ale?m disto, as u?nicas portas utilizadas em uma partic?a?o sa?o aquelas que ela\nconte?m.\n\nSemelhante a? Lei 4.20, esta lei possui o propo?sito de diminuir sua complexidade da\nca?psula A (lado esquerdo da lei), pore?m na?o possui como condic?a?o que as partes decom-\npostas (que da?o origem a?s ca?psulas B e C, no lado direito da lei) comuniquem-se entre\nsi.\n\nO efeito da decomposic?a?o e? criar duas novas ca?psulas componentes, b e c, uma para\ncada partic?a?o, e redimensionar a ca?psula original A para agir como um mediador. Em\ngeral, o novo comportamento de A ira? depender da forma particular da decomposic?a?o. A\nLei C.7 captura uma decomposic?a?o paralela. No lado direito da lei, A na?o tem nenhuma\nma?quina de estados. Ele delega completamente seu comportamento original para B e C\natrave?s de conexo?es com componentes destes tipos no diagrama de estrutura.\n\nA justificativa da Lei 4.20 a partir das leis ba?sicas pode ser feita a partir de uma\nsimplificac?a?o da demonstrac?a?o da Lei 4.20, mudando-se apenas a aplicac?a?o das leis ne-\ncessa?rias para desencapsular as insta?ncias de ca?psulas b e c do diagrama de estrutura de\nA (no lado esquerdo da lei, utilizando-se para este fato apenas a Lei C.6 que indica que\nas insta?ncias desencapsuladas na?o se comunicam com nenhuma outra subca?psula de A.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS\n\n[1] Designing for Concurrency. Technical Report 084-0698, ObjecTime Limited. Ob-\njecTime, 1998.\n\n[2] M. Alanen, J. Lilius, I. Porres, and D. Truscan. Realizing a model driven engineering\nprocess. Technical Report 565, TUCS, Nov 2003.\n\n[3] R. Allen. A Formal Approach to Software Architecture. PhD thesis, School of\nComputer Science, Carnegie Mellon University, Pittsburgh, USA, May 1997. Issued\nas CMU Technical Report CMU-CS-97-144.\n\n[4] N. Amalio and F. Polack. Comparison of formalisation approaches of UML class\nconstructs in Z and Object-Z. In Third International Conference of B and Z, volume\n2651 of LNCS, pages 339\u2013358, June 2003.\n\n[5] M. Antonsson and P. Hansson. Modeling of Real-Time Systems in UML with\nRational Rose and Rose Real-Time based on RUP. Master\u2019s thesis, Chalmers\nUniversity of Technology, Gothenburg, Sweden, April 2001. Honorary mention in\nthe 2001 SNART Best Master\u2019s Thesis Award.\n\n[6] L. Bass, P. Clements, and R. Kazman. Software Architecture in Practice. Addison-\nWesley Longman, Reading, MA, 1998.\n\n[7] K. Berkenko?tter. Using UML 2.0 in Real-Time Development. A Critical Review.\nIn International Workshop on Specification and Validation of UML models for Real\nTime and Embedded Systems (SVERTS), 2003. Workshop hold in conjunction with\nUML 2003.\n\n[8] V. D. Bianco, L. Lavazza, M. Mauri, and G. Occorso. Towards uml-based formal\nspecifications of component-based real-time software. In M. Pezze?, editor, 6th Inter-\nnational Conference on Fundamental Approaches to Software Engineering, Lecture\nNotes in Computer Science, pages 118\u2013134, Warsaw, Poland, April 2003. Springer.\n\n[9] P. Borba, A. Sampaio, A. Cavalcanti, and M. Corne?lio. Algebraic reasoning for\nobject-oriented programming. Science of Computer Programming, 52:53\u2013100, 2004.\n\n[10] R. Borges, A. Mota, and A. Sampaio. Integrando uml e me?todos formais. Technical\nreport, Universidade Federal de Pernambuco, Recife, Brasil, 2004.\n\n[11] F. P. Brooks, Jr. The Mythical Man-Month. Addison Wesley, anniversary edition,\n1995.\n\n90\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 91\n\n[12] J.-M. Bruel, R. France, and M. Larrondo-Petrie. An integrated object-oriented and\nformal modeling environment. Journal of Object-Oriented Programming, 10(7):25\u2013\n34, 1997.\n\n[13] J. Buxton and B. Randell, editors. Software Engineering Techniques: Report on a\nConference sponsored by the NATO Science Committee, Rome, Italy, October 1969.\nBrussels: NATO Scientific Affairs Division, April 1970.\n\n[14] J. M. C. Silva, J. Castro. Detailing architectural design in the tropos methodology.\nIn Second International SofTware Requirements to Architectures Workshop, pages\n85\u201393, 2003.\n\n[15] A. Cavalcanti, A. Sampaio, and J. Woodcock. Refinement of Actions in Circus. In\nProceedings of REFINE\u20192002, Electronic Notes in Theoretical Computer Science,\n2002. Invited Paper.\n\n[16] A. Cavalcanti, A. Sampaio, and J. Woodcock. A unified language of classes and\nprocesses. In St Eve: State-Oriented vs. Event-Oriented Thinking in Requirements\nAnalysis, Formal Specification and Software Engineering, Satellite Workshop at\nFM\u201903, 2003.\n\n[17] A. Cavalcanti, A. Sampaio, and J. Woodcock. A refinement strategy for circus.\nFormal Asp. Comput., 15(2-3):146\u2013181, 2003.\n\n[18] S. Cheng and D. Garlan. Mapping Architectural Concepts to UML-RT. In Pro-\nceedings of the International Conference on Parallel and Distributed Processing\nTechniques and Application (PDPTA\u20192001), Las Vegas, Nevada, USA, 2001.\n\n[19] I. Corporation. Rational rose technical developer, 2004. Available at: http://www-\n306.ibm.com/software/awdtools/developer/technical. Includes IBM Rational Rose\nRealTime.\n\n[20] I. Crnkovic. Component-based software engineering - new challenges in software\ndevelopment. Software Focus, 2(4):127\u2013133, 2001.\n\n[21] E. W. Dijkstra and C. S. Scholten. Predicate calculus and program semantics.\nSpringer-Verlag New York, Inc., 1990.\n\n[22] D. Dori. Why significant uml change is unlikely. Communications of the ACM,\n45(11):82\u201385, 2002.\n\n[23] D. D\u2019Souza and A. Wills. Objects, components, and frameworks with UML: the\ncatalysis approach. Addison-Wesley Longman Publishing Co., Inc., 1999.\n\n[24] G. Engels, R. Heckel, and J. Ku?ster. Rule-based specification of behavioral con-\nsistency based on the uml meta-model. In 4th International Conference on The\nUnified Modeling Language, Modeling Languages, Concepts, and Tools, pages 272\u2013\n286, London, UK, 2001. Springer-Verlag.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 92\n\n[25] G. Engels, R. Heckel, J. Ku?ster, and L. Groenewegen. Consistency-Preserving\nModel Evolution through Transformations. In 5th International Conference on the\nUnified Modeling Language, volume 2460 of LNCS, pages 212\u2013226. Springer, 2002.\n\n[26] G. Engels, R. Heckel, J. M. Ku?ster, and L. Groenewegen. Consistency-Preserving\nModel Evolution through Transformations. In J.-M. Je?ze?quel, H. Hussmann, and\nS. Cook, editors, UML 2002 - The Unified Modeling Language. 5th International\nConference, volume 2460 of LNCS, pages 212\u2013226, Dresden, Germany, October\n2002. Springer.\n\n[27] G. Engels, J. M. Ku?ster, R. Heckel, and L. Groenewegen. A methodology for\nspecifying and analyzing consistency of object-oriented behavioral models. In 8th\nEuropean Software Engineering Conference, pages 186\u2013195. ACM Press, 2001.\n\n[28] A. Evans. Reasoning with UML Class Diagrams. In 2nd IEEE Workshop on\nIndustrial Strength Formal Specification Techniques. IEEE Computer Society, 1998.\n\n[29] A. Evans, R. France, and E. Grant. Towards formal reasoning with uml models. In\nOOPSLA\u201999 Workshop on Behavioral Semantics, 1999.\n\n[30] A. Evans, R. France, K. Lano, and B. Rumpe. The UML as a Formal Modeling No-\ntation. In First International Workshop on the Unified Modeling Language, LNCS.\nSpringer, 1999.\n\n[31] C. Fischer. Combination and Implementation of Processes and Data: from CSP-OZ\nto Java. PhD thesis, Fachbereich Informatik Universita?t Oldenburg, 2000.\n\n[32] C. Fischer, E.-R. Olderog, and H. Wehrheim. A CSP View on UML-RT Structure\nDiagrams. In Proceedings of the 4th International Conference on Fundamental\nApproaches to Software Engineering, pages 91\u2013108. Springer, 2001.\n\n[33] M. Fowler. Refactoring-Improving the design of existing code. Addison Wesley,\n1999.\n\n[34] H. Frank and J. Eder. Equivalence transformations on statecharts. In 12th Interna-\ntional Conference on Software Engineering and Knowledge Engineering, Chicago,\nJuly 2000. Knowledge System Institute.\n\n[35] D. Garlan, S.-W. Cheng, and A. J. Kompanek. Reconciling the needs of architectu-\nral description with object-modeling notations. Science of Computer Programming,\n44(1):23\u201349, 2002.\n\n[36] D. Garlan, R. Monroe, and D. Wile. ACME: Architecture Description of Composed-\nBased Systems. In G. T. Leavens and M. Sitaraman, editors, Foundations of\nComponent-Based Systems, pages 47\u201368. Cambridge University Press, 2000.\n\n[37] R. Gheyi. Basic laws of object modeling. Master\u2019s thesis, Informatics Center,\nFederal Universisty of Pernambuco, Recife, Brazil, February 2004.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 93\n\n[38] R. Gheyi and P. Borba. Refactoring Alloy Specifications. In 6t h Brazilian Workshop\non Formal Methods, volume 95 of ENTCS, pages 227\u2013243. Elsevier Science, May\n2004.\n\n[39] W. Gibbs. Software\u2019s Chronic Crisis. Scientific American, 271(3):86\u201395, September\n1994.\n\n[40] U. Gla?sser, R. Gotzhein, and A. Prinz. The formal semantics of SDL-2000: status\nand perspectives. Computer Networks: The International Journal of Computer and\nTelecommunications Networking, 42(3):343\u2013358, 2003.\n\n[41] M. Gogolla and M. Richters. Transformation Rules for UML Class Diagrams. In\nFirst International Workshop on the Unified Modeling Language (UML)\u201998, LNCS,\npages 92\u2013106. Springer, 1999.\n\n[42] G. Gullekson. Designing for Concurrency and Distribution with Rational Rose\nRealTime. Technical Report TP-1864/00, Rational Software Corporation, 2000.\nRational Software White Paper.\n\n[43] D. Harel. Statecharts: A Visual Formalism for Complex Systems. Science of\nComputer Programming, 8:231\u2013274, 1987.\n\n[44] D. Harel and B. Rumpe. Modeling languages: Syntax, semantics and all that stuff,\npart i: The basic stuff. Technical Report MSC00-16, 2000.\n\n[45] C. A. R. Hoare. Programming: Sorcery or science? IEEE Software, 1(2):5\u201316,\n1984.\n\n[46] C. A. R. Hoare, I. J. Hayes, H. Jifeng, C. C. Morgan, A. W. Roscoe, J. W. Sanders,\nI. H. Sorensen, J. M. Spivey, and B. A. Sufrin. Laws of programming. Communi-\ncations of the ACM, 30(8):672\u2013686, 1987.\n\n[47] C. A. R. Hoare and H. Jifeng. Unifying Theories of Programming. Prentice-Hall,\n1998.\n\n[48] J. Ivers, P. Clements, D. Garlan, R. Nord, B. Schmerl, and J. Silva. Documenting\nComponent and Connector Views with UML 2.0. Technical Report CMU/SEI-\n2004-TR-008, Carnegie Mellon, Software Engineering Institute, 2004.\n\n[49] D. Jackson. A Comparison of Object Modelling Notations: Alloy, UML and Z.\nTechnical report, MIT. Lab for Computer Science, August 1999.\n\n[50] D. Jackson. Micromodels of Software: Lightweight Modelling and Analysis with\nAlloy. Technical report, Software Design Group. MIT Lab for Computer Science,\n2002.\n\n[51] S. Kent. Model Driven Engineering. In Proceedings of IFM\u201902, volume 2335 of\nLNCS, pages 286\u2013298. Springer-Verlag, 2002.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 94\n\n[52] P. Kruchten. The Rational Unified Process: An Introduction. Addison-Wesley, 2\nedition, 2000.\n\n[53] I. Kru?ger, W. Prenninger, and R. Sandner. Development of an Autonomous Trans-\nport System using UML-RT. Technical Report TUM-I0215, Technische Universita?t,\nMu?nchen, 2002.\n\n[54] I. H. Kru?ger. Towards Precise Service Specification with UML and UML-RT. In\nJ. Ju?rjens, M. V. Cengarle, E. B. Fernandez, B. Rumpe, and R. Sandner, editors,\nCritical Systems Development with UML \u2013 Proceedings of the UML\u201902 workshop,\npages 19\u201334. Technische Universita?t Mu?nchen, Institut fu?r Informatik, 2002.\n\n[55] K. Lano and J. Bicarregui. Semantics and Transformations for UML Models. In\nFirst International Workshop on the Unified Modeling Language, volume 1618 of\nLNCS, pages 107\u2013119. Springer, June 1999.\n\n[56] R. G. Lavender and D. C. Schmidt. Active object: an object behavioral pattern\nfor concurrent programming. pages 483\u2013499, 1996.\n\n[57] M. M. Lehman. Laws of software evolution revisited. In C. Montangero, editor, 5th\nEuropean Workshop on Software Process Technology, volume 1149 of LNCS, pages\n108\u2013124, Nancy, France, October 1996. Springer.\n\n[58] J. Liu, J. S. Dong, B. Mohany, and K. Shi. Linking uml with integrated formal tech-\nniques. In Unified Modeling Language: Systems Analysis, Design, and Development\nIssues. IDEA GROUP Publishing, 2000.\n\n[59] D. C. Luckham and J. Vera. An event-based architecture definition language. IEEE\nTransactions on Software Engineering, 21(9):717\u2013734, 1995.\n\n[60] J. Ludewig. Models in software engineering. Software and System Modeling, 2(1):5\u2013\n14, 2003.\n\n[61] J. Magee and J. Kramer. Dynamic structures in software architecture. In Fourth\nSymposium on the Foundations of Software Engineering, pages 3\u201314, New York,\nNY, USA, 1996. ACM Press.\n\n[62] M. S. Mahoney. The roots of software engineering. CWI Quarterly, 3(4):325\u2013334,\nFebruary 1990.\n\n[63] T. McClean, F. Bordelau, and J.-P. Corriveau. Scenario-Driven Refactoring in\nUML-RT. In 2nd International Workshop on Scenarios and State Machines: Mo-\ndels, Algorithms, and Tools, Portland, Oregon, USA, May 2003. Held at the Inter-\nnational Conference on Software Engineering 2003 - ICSE\u201903.\n\n[64] N. Medvidovic and R. N. Taylor. A classification and comparison framework for\nsoftware architecture description languages. IEEE Trans. Softw. Eng., 26(1):70\u201393,\n2000.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 95\n\n[65] J. Miller and J. Mukerji. MDA Guide Version 1.0.1. Object Management Group,\n2003. OMG document omg/03-06-01.\n\n[66] M. Mo?ller, E.-R. Olderog, H. Rasch, and H. Wehrheim. Linking csp-oz with uml\nand java: A case study. In E. A. Boiten, J. Derrick, and G. Smith, editors, 4th\nInternational Conference on Integrated Formal Methods, volume 2999 of LNCS,\npages 267\u2013286. Springer, 2004.\n\n[67] C. Morgan. Programming from Specifications. Prentice Hall, second edition, 1994.\n\n[68] C. Morgan and P. H. B. Gardiner. Data refinement by calculation. Acta Inf.,\n27(6):481\u2013503, 1989.\n\n[69] M. Y. Ng and M. J. Butler. Towards formalizing uml state diagrams in csp. In\n1st International Conference on Software Engineering and Formal Methods, pages\n138\u2013147. IEEE Computer Society, September 2003.\n\n[70] Object Management Group. OMG Unified Modeling Language Specification, 2003.\nOMG document formal/03-03-01.\n\n[71] Object Management Group, Inc. The OMG\u2019s Home page, 2005. Avaliable at:\nhttp://www.omg.org/.\n\n[72] M. Oliveira and A. Cavalcanti. From Circus to JCSP. In 6th International Con-\nference on Formal Engineering Methods, volume 3308 of LNCS, pages 320\u2013340.\nSpringer, 2004.\n\n[73] R. Prieto-Diaz and J. M. Neighbors. Module interconnection languages. Journal\nof Systems and Software, 6(4):307\u2013334, 1986.\n\n[74] R. Ramos, A. Sampaio, and A. Mota. A semantics for uml-rt active classes via\nmapping into circus. In To Apear in 7th IFIP international Conference on Formal\nMethods for Open Object-Based Distributed Systems, LNCS, Athens, Greece, June\n2005. University of Athens, Springer.\n\n[75] H. Rasch. Translating a subset of uml state machines into csp. Technical report,\nUniversita?t Freiburg, May 2002. Mobi-J Meeting.\n\n[76] J. E. Robbins, N. Medvidovic, D. F. Redmiles, and D. S. Rosenblum. Integrating\narchitecture description languages with a standard design method. In Proceedings\nof the 20th international conference on Software engineering, pages 209\u2013218. IEEE\nComputer Society, 1998.\n\n[77] D. B. Roberts. Practical Analysis for Refactoring. PhD thesis, University of Illinois\nat Urbana Champaign, 1999.\n\n[78] D. Roe, K. Broda, and A. Russo. Mapping uml models incorporating ocl constraints\ninto object-z. Technical Report 2003/9, Imperial College London, 2003.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 96\n\n[79] A. W. Roscoe. The Theory and Practice of Concurrency. Prentice-Hall, 1998.\n\n[80] A. W. Roscoe and C. A. R. Hoare. The laws of occam programming. Theor.\nComput. Sci., 60(2):177\u2013229, 1988.\n\n[81] J. Rumbaugh, I. Jacobson, and G. Booch. The Unified Modeling Language Reference\nManual. Addison-Wesley, Reading, Mass., 1999.\n\n[82] B. Rumpe, M. Schoenmakers, A. Radermacher, and A. Schrr. UML + ROOM as a\nStandard ADL? In F. Titsworth, editor, Proceedings of the 5th International Con-\nference on Engineering of Complex Computer Systems, page 43. IEEE Computer\nSociety, 1999.\n\n[83] A. Sampaio, A. Mota, and R. Ramos. Class and Capsule Refinement in UML for\nReal Time. In Proceedings of the Brazilian Workshop on Formal Methods, volume 95\nof ENTCS, pages 23\u201351, 2004.\n\n[84] A. Sampaio, J. Woodcock, and A. Cavalcanti. Refinement in Circus. In Internati-\nonal Symposium of Formal Methods Europe, volume 2391 of LNCS, pages 451\u2013470.\nSpringer, 2002.\n\n[85] R. Sandner. Developing Distributed Systems Step by Step with UML-RT. In\nWorkshop Visuelle Verhaltensmodellierung verteilter und nebenla?ufiger Software-\nSysteme. Universita?t Mu?nster, 2000.\n\n[86] B. Selic. An Efficient Object-Oriented Variation of the Statecharts Formalism for\nDistributed Real-Time Systems. In 11th IFIP WG10.2 International Conference on\nComputer Hardware Description Languages and their Applications, volume A-32 of\nIFIP Transactions, pages 335\u2013344, 1993.\n\n[87] B. Selic. The Pragmatics of Model-Driven Development. IEEE Software, 20(5):19\u2013\n25, 2003.\n\n[88] B. Selic. Tutorial: An overview of uml 2.0. In 6th International Conference on Soft-\nware Engineering, pages 741\u2013742, Edinburgh, United Kingdom, May 2004. IEEE\nComputer Society.\n\n[89] B. Selic, G. Gullekson, and P. T. Ward. Real-time object-oriented modeling. John\nWiley &amp; Sons, Inc., 1994.\n\n[90] B. Selic and J. Rumbaugh. Using UML for Modeling Complex RealTime Systems.\nRational Software Corporation, 1998. available at http://www. rational.com.\n\n[91] M. Shaw and D. Garlan. Software Architecture - Perspectives on an Emerging\nDiscipline. Softwaretechnik-Trends, 20(2), 2000.\n\n[92] A. J. H. Simons. On the compositional properties of uml statechart diagrams. In\nRigorous Object-Oriented Methods, Workshops in Computing, York, UK, January\n2000. BCS.\n\n\n\nREFERE?NCIAS BIBLIOGRA?FICAS 97\n\n[93] G. Smith. The Object-Z specification language. Kluwer Academic Publishers,\nNorwell, MA, USA, 2000.\n\n[94] G. Smith and J. Derrick. Specification, refinement and verification of concurrent\nsystems - an integration of Object-Z and CSP. Formal Methods in Systems Design,\n18:249\u2013284, May 2001.\n\n[95] M. Spivey. The Z Notation: A Reference Manual. Prentice Hall, second edition,\n1992.\n\n[96] G. Sunye?, D. Pollet, Y. L. Traon, and J.-M. Je?ze?quel. Refactoring UML Models. In\n4th International Conference on the The Unified Modeling Language, volume 2185\nof LNCS, pages 134\u2013148. Springer, October 2001.\n\n[97] P. Welch and J. Martin. A CSP Model for Java Multithreading. In P. Nixon and\nI. Ritchie, editors, Software Engineering for Parallel and Distributed Systems, pages\n114\u2013122. ICSE 2000, IEEE Computer Society Press, June 2000.\n\n[98] G. Winskel. The formal semantics of programming languages: an introduction.\nMIT Press, 1993.\n\n[99] J. Woodcock and A. Cavalcanti. Circus: a concurrent refinement language. Te-\nchnical Report Oxford OX1 3QD UK, Oxford University Computing Laboratory,\nWolfson Building, Parks Road, July 2001.\n\n[100] J. Woodcock and A. Cavalcanti. The Semantics of Circus. In ZB 2002: Formal\nSpecification and Development in Z and B, volume 2272 of LNCS, pages 184\u2013203.\nSpringer, 2002.\n\n[101] L. Zhang, D. Xie, and W. Zou. Viewing use cases as active objects. ACM SIGSOFT\nSoftware Engineering Notes, 26(2):44\u201348, 2001.\n\n\n\n\n\tAcr11E.tmp\n\tAcr11E.tmp\n\tDisserta\u00e7\u00e3o Mestrado_Desenv Rigoroso com UML-RT.pdf\n\tDisserta\u00e7\u00e3o Mestrado_Desenv Rigoroso com UML-RT.pdf\n\tDisserta\u00e7\u00e3o Mestrado_Rodrigo.pdf\n\tCap\u00edtulo 1---Introdu\u00e7\u00e3o\n\tCap\u00edtulo 2---Linguagens de Modelagem\n\tUML 1.x\n\tADLs\n\tROOM\n\tWright\n\tACME\n\tSDL\n\tADLs e UML\n\n\tUML-RT\n\tUML 2.0\n\tConclus\u00f5es\n\n\tCap\u00edtulo 3---Formaliza\u00e7\u00e3o de UML-RT\n\tOhCircus\n\tSintaxe\n\tSem\u00e2ntica\n\tExpress\u00f5es de Processos\n\n\tNo\u00e7\u00f5es de Refinamento e Equival\u00eancia\n\tLeis para refinamento de Processos\n\n\tMapeamento\n\tMapeamento estrutural\n\tMapeamento comportamental\n\n\tConclus\u00f5es\n\n\tCap\u00edtulo 4---Leis de Transforma\u00e7\u00e3o para UML-RT\n\tLeis B\u00e1sicas\n\tLeis Derivadas e Refatoramentos\n\tFormaliza\u00e7\u00e3o das Leis\n\tProva da Lei ??\n\tProva da Lei ??\n\n\tConclus\u00f5es\n\n\tCap\u00edtulo 5---Normaliza\u00e7\u00e3o e Aplica\u00e7\u00e3o das Leis\n\tEstrat\u00e9gia de Normaliza\u00e7\u00e3o\n\tEstudo de Caso\n\tConclus\u00f5es\n\n\tCap\u00edtulo 6---Conclus\u00f5es\n\tTrabalhos relacionados\n\tTrabalhos Futuros\n\n\tAp\u00eandice A---Sintaxe Completa de Ohcircus\n\tAp\u00eandice B---Leis de CSP\n\tAp\u00eandice C---Leis de Transforma\u00e7\u00e3o para UML-RT Adicionais"}]}}}