{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.14655"}, {"@name": "filename", "#text": "21017_TCC_CleitonJanke.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "UNIVERSIDADE FEDERAL DE SANTA CATARINA \n\n \n\n \n\n \n\n \n\n \n\nDESENVOLVIMENTO DE APLICA\u00c7\u00c3O PARA A ETAPA \n\nDE ESPECIFICA\u00c7\u00c3O DA METODOLOGIA DE \n\nDESENVOLVIMENTO DE ONTOLOGIAS EM REDE NEON. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nCleiton Edgar Janke Duarte \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nFlorian\u00f3polis \u2013 SC \n\n2009/1 \n\n\n\n  \n\nUNIVERSIDADE FEDERAL DE SANTA CATARINA \n\nDEPARTAMENTO DE INFORM\u00c1TICA E ESTAT\u00cdSTICA \n\nCURSO DE SISTEMAS DE INFORMA\u00c7\u00c3O \n\n \n\n \n\nDESENVOLVIMENTO DE APLICA\u00c7\u00c3O PARA A ETAPA DE \n\nESPECIFICA\u00c7\u00c3O DA METODOLOGIA DE \n\nDESENVOLVIMENTO DE ONTOLOGIAS EM REDE NEON. \n\n \n\n \n\n \n\nCleiton Edgar Janke Duarte \n\n \n\n \n\n \n\nTrabalho de conclus\u00e3o de curso \n\napresentado como parte dos \n\nrequisitos para obten\u00e7\u00e3o do grau \n\nde Bacharel em Sistemas de Informa\u00e7\u00e3o. \n\n \n\n \n\n \n\n \n\n \n\nFlorian\u00f3polis \u2013 SC \n\n2009/1 \n\n\n\n  \n\nCleiton Edgar Janke Duarte \n\n \n\nDESENVOLVIMENTO DE APLICA\u00c7\u00c3O PARA A ETAPA DE \n\nESPECIFICA\u00c7\u00c3O DA METODOLOGIA DE DESENVOLVIMENTO DE \n\nONTOLOGIAS EM REDE NEON. \n\n \n\n \n\n \n\nTrabalho de conclus\u00e3o de curso \n\napresentado como parte dos \n\nrequisitos para obten\u00e7\u00e3o do grau \n\nde Bacharel em Sistemas de Informa\u00e7\u00e3o. \n\n \n\n \n\n \n\nBanca Examinadora: \n\n \n\n \n\n__________________________________ \n\nProf. Dr. Jos\u00e9 Leomar Todesco \n\nUniversidade Federal de Santa Catarina  \n\nOrientador \n\n \n\n__________________________________ \n\nProf. Dr. Fernando Alvaro Ostuni Gauthier \n\nUniversidade Federal de Santa Catarina  \n\nCo-orientador \n\n \n\n__________________________________ \n\nProf. Dr. Rog\u00e9rio Cid Bastos  \n\nUniversidade Federal de Santa Catarina \n\n\n\n  \n\nSUM\u00c1RIO \n\nLISTA DE FIGURAS ................................................................................................6 \n\nRESUMO ....................................................................................................................7 \n\n1) INTRODU\u00c7\u00c3O ......................................................................................................8 \n\n1.1) OBJETIVO GERAL ..............................................................................................8 \n\n1.2) OBJETIVO ESPEC\u00cdFICO .......................................................................................8 \n\n2) ENGENHARIA DE ONTOLOGIAS ...................................................................9 \n\n2.1) ONTOLOGIA.......................................................................................................9 \n\n2.1.1) Classifica\u00e7\u00e3o de Ontologias ...................................................................11 \n\n2.1.2) Uso de Ontologias ..................................................................................13 \n\n2.1.3) A Engenharia de Ontologias e suas Atividades......................................15 \n\n2.2) METODOLOGIAS PARA CONSTRU\u00c7\u00c3O DE ONTOLOGIAS ...................................17 \n\n2.2.1) Metodologia On-to-Knowledge ..............................................................18 \n\n2.2.2) Metodologia METHONTOLOGY ...........................................................19 \n\n2.2.3) Metodologia NeOn .................................................................................20 \n\n2.3) FERRAMENTAS ................................................................................................23 \n\n2.3.1) Prot\u00e9g\u00e9 ...................................................................................................24 \n\n2.3.2) OntoKEM................................................................................................25 \n\n2.3.3) NeOn Toolkit ..........................................................................................26 \n\n3) A FASE DE ESPECIFICA\u00c7\u00c3O DE ONTOLOGIAS ......................................27 \n\n3.1) COMO \u00c9 VISTO NO NEON.................................................................................27 \n\n3.2) COMO FOI VISTO NO ONTOKEM ......................................................................30 \n\n3.3) CONSIDERA\u00c7\u00d5ES .............................................................................................33 \n\n4) APLICA\u00c7\u00c3O PARA A FASE DE ESPECIFICA\u00c7\u00c3O ....................................34 \n\n4.1) UM POUCO SOBRE O MVP ...............................................................................35 \n\n4.2) ESPECIFICA\u00c7\u00c3O DA APLICA\u00c7\u00c3O ......................................................................37 \n\n4.3) O XML PARA PERSIST\u00caNCIA ...........................................................................42 \n\n4.4) DETALHAMENTO DA ESTRUTURA DA APLICA\u00c7\u00c3O...........................................46 \n\n4.4.1) O Pacote \u201cData\u201d....................................................................................48 \n\n4.4.2) O Pacote \u201cBeans\u201d ..................................................................................50 \n\n4.4.3) A classe \u201cExtractController\u201d e a extra\u00e7\u00e3o de termos............................52 \n\n4.4.4) O Pacote \u201cView\u201d....................................................................................53 \n\n4.5) RESULTADOS APRESENTADOS .........................................................................55 \n\n\n\n  \n\n5) CONCLUS\u00c3O ......................................................................................................63 \n\n5.1) CONSIDERA\u00c7\u00d5ES FINAIS..................................................................................63 \n\n5.2) TRABALHOS FUTUROS.....................................................................................64 \n\n6) REFER\u00caNCIAS BIBLIOGR\u00c1FICAS ...............................................................65 \n\nANEXO A \u2013 C\u00d3DIGO-FONTE DA APLICA\u00c7\u00c3O. .............................................69 \n\nANEXO B \u2014 ARTIGO..........................................................................................197 \n\n \n\n\n\n  \n\nLISTA DE FIGURAS \n\nFIGURA 1 \u2013 N\u00cdVEIS DE ABSTRA\u00c7\u00c3O PARA ONTOLOGIAS ............................................................11 \n\nFIGURA 2 \u2013 CLASSIFICA\u00c7\u00c3O DE ONTOLOGIA POR HIERARQUIA..................................................12 \n\nFIGURA 3 \u2013 PROCESSO DE DESENVOLVIMENTO DA METODOLOGIA ON-TO-KNOWLEDGE ..........18 \n\nFIGURA 4 \u2013 PROCESSO DE DESENVOLVIMENTO E CICLO DE VIDA DA METODOLOGIA \n\nMETHONTOLOGY .......................................................................................................20 \n\nFIGURA 5 \u2013 ETAPAS E CEN\u00c1RIOS PARA CONSTRU\u00c7\u00c3O DE ONTOLOGIAS EM REDE PRESENTES NA \n\nMETODOLOGIA NEON ......................................................................................................23 \n\nFIGURA 6 \u2013 TELA DE EXEMPLO DA FERRAMENTA PROT\u00c9G\u00c9, USANDO A ONTOLOGIA DE EXEMPLO \n\nWINES...............................................................................................................................24 \n\nFIGURA 7 \u2013 TELA DE EXEMPLO DA FERRAMENTA ONTOKEM, M\u00d3DULO \u201cVOCABUL\u00c1RIO\u201d ........26 \n\nFIGURA 8 \u2013 TELA DE EXEMPLO DA FERRAMENTA NEON-TOOLKIT............................................26 \n\nFIGURA 9 \u2013 MODELO DO DOCUMENTO OSRD, DA METODOLOGIA NEON..................................30 \n\nFIGURA 10 \u2013 TELA DE EXEMPLO DO M\u00d3DULO DE \u201cPROJETO\u201d DO ONTOKEM ............................32 \n\nFIGURA 11 \u2013 TELA DE EXEMPLO DO M\u00d3DULO DE \u201cPERGUNTAS DE COMPET\u00caNCIA\u201d DO \n\nONTOKEM.......................................................................................................................32 \n\nFIGURA 12 \u2013 REPRESENTA\u00c7\u00c3O DO PADR\u00c3O DE PROJETO MVP NA ESTRUTURA PASSIVE VIEW...36 \n\nFIGURA 13 \u2013 DIAGRAMA DE CASOS DE USO DA APLICA\u00c7\u00c3O ......................................................37 \n\nFIGURA 14 \u2013 ESTRUTURA DE CLASSES DA APLICA\u00c7\u00c3O COM O PADR\u00c3O MVP ............................40 \n\nFIGURA 15 \u2013 SUBESTRUTURA DA APLICA\u00c7\u00c3O SOBRE A PARTE DE MODELAGEM DAS REGRAS DE \n\nNEG\u00d3CIO DA ETAPA DE ESPECIFICA\u00c7\u00c3O. ..........................................................................42 \n\nFIGURA 16 \u2013 ESTRUTURA DO ARQUIVO XML DE PERSIST\u00caNCIA................................................43 \n\nFIGURA 17 \u2014 PACOTE \u201cBEANS\u201d E SUAS CLASSES PARA COMUNICA\u00c7\u00c3O ENTRE AS CAMADAS. .51 \n\nFIGURA 18 \u2014 O PACOTE \u201cVIEW\u201d E AS CLASSES DE REPRESENTA\u00c7\u00c3O E MANIPULA\u00c7\u00c3O DOS \n\nM\u00d3DULOS DA APLICA\u00c7\u00c3O. ...............................................................................................54 \n\nFIGURA 19 \u2014 TELA INICIAL DA APLICA\u00c7\u00c3O..............................................................................58 \n\nFIGURA 20 \u2014 MENU \u201cFILE\u201d E AS OP\u00c7\u00d5ES DE IN\u00cdCIO DE USO DE UM PROJETO. ...........................58 \n\nFIGURA 21 \u2014 ABA DO M\u00d3DULO \u201cPROJECT\u201d, NO ESTADO DE EXIBI\u00c7\u00c3O (ACIMA) E NO ESTADO DE \n\nEDI\u00c7\u00c3O (ABAIXO). ...........................................................................................................60 \n\nFIGURA 22 \u2014 M\u00d3DULO \u201cCOMPETENCE QUESTIONS\u201d. ..............................................................61 \n\nFIGURA 23 \u2014 M\u00d3DULO \u201cTERMS\u201d. ............................................................................................62 \n\n \n\n\n\n  \n\nRESUMO \n\n \n\nO prop\u00f3sito das p\u00e1ginas que seguem \u00e9 o de apresentar o \n\ntrabalho de conclus\u00e3o de curso sobre \u201cDesenvolvimento de aplica\u00e7\u00e3o \n\npara a etapa de especifica\u00e7\u00e3o da metodologia de desenvolvimento de \n\nontologias em rede NeOn\u201d. Nesse trabalho os objetivos foram \n\nconhecer e apresentar a metodologia NeOn, com foco na sua etapa de \n\nespecifica\u00e7\u00e3o, passando na seq\u00fcencia \u00e0 elabora\u00e7\u00e3o de um sistema \n\nque desse suporte a esta atividade. Estruturalmente o trabalho \n\ndescreve os conceitos mais importantes do escopo de trabalho \n\n(ontologias, engenharia de ontologias, etc.) nos quais est\u00e1 a \n\nmetodologia NeOn, fazendo em seguida uma an\u00e1lise da etapa de \n\nespecifica\u00e7\u00e3o desta metodologia. \u00c9 tamb\u00e9m apresentada a \n\nmodelagem dos requisitos da aplica\u00e7\u00e3o, feita com base na an\u00e1lise \n\nanterior, descrevendo detalhadamente em seguida o processo de \n\ndesenvolvimento da aplica\u00e7\u00e3o e sua estrutura. Para finalizar, \n\nconclus\u00f5es sobre a referida aplica\u00e7\u00e3o bem como sobre a etapa a qual \n\nela se prop\u00f5e a dar suporte. \n\n \n\nPalavras-chaves: ontologia, ontologia em rede, metodologia \n\nNeOn, etapa de especifica\u00e7\u00e3o. \n\n\n\n  \n\n \n\n1) INTRODU\u00c7\u00c3O \n\nO aumento gradativo do uso das ontologias tem exigido cada \n\nvez mais ferramentas que automatizem o processo de constru\u00e7\u00e3o \n\ndestas. Nesse sentido, surgiu na Europa o projeto NeOn. Este projeto \n\nprop\u00f4s uma metodologia que prev\u00ea o desenvolvimento de ontologias \n\nem rede, visando o reuso e a reengenharia de ontologias j\u00e1 existentes \n\npara elabora\u00e7\u00e3o de novas. Para suportar esta metodologia, foi \n\nconcebido o NeOn Toolkit, um plataforma que integra v\u00e1rias \n\nferramentas espec\u00edficas para atender a diferentes atividades \n\nrelacionadas a metodologia NeOn. \n\nObservando a falta de uma ferramenta que suportasse a etapa \n\nde especifica\u00e7\u00e3o dessa metodologia este trabalho prop\u00f5e o \n\n\u201cDesenvolvimento de uma aplica\u00e7\u00e3o para a etapa de especifica\u00e7\u00e3o da \n\nmetodologia de desenvolvimento de ontologias em rede NeOn\u201d. \n\n \n\n1.1) Objetivo Geral \n\nDesenvolvimento de uma aplica\u00e7\u00e3o que suporte a etapa de \n\nespecifica\u00e7\u00e3o da metodologia de desenvolvimento de ontologias em \n\nrede NeOn. \n\n \n\n1.2) Objetivo Espec\u00edfico \n\n\u2022 Conhecer o projeto NeOn, seus objetivos e estrutura. \n\n\u2022 Conhecer a metodologia de desenvolvimento de ontologias em \n\nrede do NeOn. \n\n\u2022 Elaborar uma estrutura de classes que realize o suporte \u00e0 etapa \n\nde especifica\u00e7\u00e3o de ontologias da metodologia NeOn. \n\n\n\n  \n\n\u2022 Desenvolver uma aplica\u00e7\u00e3o com base na estrutura de classes \n\nelaborada. \n\n \n\n2) ENGENHARIA DE ONTOLOGIAS \n\nEste cap\u00edtulo aborda alguns conceitos e processos envolvidos \n\nna Engenharia de Ontologias. Mais exatamente, discorrer\u00e1 a respeito \n\nde ontologia \u2014 seu conceito, classifica\u00e7\u00f5es poss\u00edveis e formas de \n\nutiliza\u00e7\u00e3o \u2014, sobre a pr\u00f3pria Engenharia de Ontologias \u2014 \n\ndescrevendo os est\u00e1gios envolvidos no processo de desenvolvimento \n\nde uma ontologia \u2014, tamb\u00e9m sobre algumas metodologias existentes \n\npara desenvolvimento de ontologias e, por fim, sobre algumas \n\nferramentas computacionais existentes nesse escopo. \n\n \n\n2.1) Ontologia \n\nO conceito de ontologia variou de defini\u00e7\u00e3o desde seu \n\nsurgimento na Filosofia at\u00e9 as sua aplica\u00e7\u00e3o atual no \u00e2mbito da \n\nCi\u00eancia da Computa\u00e7\u00e3o e Engenharia do Conhecimento (KIRYAKOV, \n\n2006). Em sua origem o conceito era de uma disciplina dedicada ao \n\nestudo da natureza e da exist\u00eancia dos elementos. J\u00e1 na Ci\u00eancia da \n\nComputa\u00e7\u00e3o, trata da representa\u00e7\u00e3o do conhecimento, a organiza\u00e7\u00e3o \n\ne estrutura\u00e7\u00e3o dos conhecimentos sobre um determinado dom\u00ednio. \n\nA defini\u00e7\u00e3o inicialmente utilizada na Ci\u00eancia da Computa\u00e7\u00e3o \n\nveio, segundo Kiryakov (2006), por Gruber (1993) que define o \n\nconceito de ontologia como \u201cuma especifica\u00e7\u00e3o expl\u00edcita de uma \n\nconceitualiza\u00e7\u00e3o\u201d. Um outro autor, Borst (1997) atribuiu mais detalhes \n\na defini\u00e7\u00e3o, sendo que para ele \u201contologia \u00e9 uma especifica\u00e7\u00e3o formal \n\ne expl\u00edcita de uma conceitualiza\u00e7\u00e3o compartilhada\u201d. \n\n\n\n  \n\nDevedzic (2002) interpreta ontologia como um sistema de \n\nconceitos e das rela\u00e7\u00f5es existentes entre esses conceitos, sendo os \n\nconceitos definidos e interpretados declarativamente. O sistema \n\nmodelaria um determinado dom\u00ednio definindo o vocabul\u00e1rio de termos \n\ndo mesmo e as restri\u00e7\u00f5es das combina\u00e7\u00f5es poss\u00edveis entre esses \n\ntermos. \n\nSegundo Hepp et al. (2007) ontologias poderiam ser definidas \n\ncomo representa\u00e7\u00f5es formais de dom\u00ednios, como um entendimento \n\ncompartilhado sobre um dom\u00ednio. Sua constru\u00e7\u00e3o se daria por um \n\nprocesso social entre os especialistas do dom\u00ednio e os engenheiros do \n\nconhecimento definindo assim esse entendimento comum, como um \n\ncontrato. A constru\u00e7\u00e3o da ontologia se d\u00e1, segundo o autor, de forma \n\ndin\u00e2mica, havendo, por parte dos participantes do processo, inclus\u00f5es, \n\nmodifica\u00e7\u00f5es e descartes de elementos da ontologia. \n\nKiryakov (2006) expressa formalmente ontologia como um \n\nrelacionamento de quatro elementos representando isso pela \n\nqu\u00e1drupla: \n\nO = {C, R, I, A} \n\nSendo \u201cO\u201d a ontologia, os demais elementos s\u00e3o: \n\n\u2022 C: conjunto de classes que representam os conceitos de um \n\ndeterminado dom\u00ednio; \n\n\u2022 R: conjunto das rela\u00e7\u00f5es ou associa\u00e7\u00f5es existentes entre os \n\nconceitos; \n\n\u2022 I: conjunto das inst\u00e2ncias advindas das classes \n\n\u2022 A: conjunto de axiomas do dom\u00ednio, que definem as restri\u00e7\u00f5es e \n\nregras que atuam sobre as inst\u00e2ncias. \n\nDaconta et al. (2003) mencionam que ontologias inserem \n\ndefini\u00e7\u00f5es comput\u00e1veis (pass\u00edveis de processamento e interpreta\u00e7\u00e3o \n\npor computadores) para conceitos de um dado dom\u00ednio e para os \n\n\n\n  \n\nrelacionamentos entre esses conceitos. Eles acrescentam ainda que \n\npara ser comput\u00e1vel, tr\u00eas n\u00edveis de abstra\u00e7\u00e3o s\u00e3o importantes ao \n\ndesenvolvimento da ontologia, como pode ser visto na Figura 1. No \n\nn\u00edvel mais alto est\u00e3o os elementos da ontologia (classes, rela\u00e7\u00f5es \n\nentre as classes, propriedades das classes, inst\u00e2ncias e os axiomas), \n\nsendo este o n\u00edvel da linguagem de representa\u00e7\u00e3o do conhecimento. \n\nAbaixo, no n\u00edvel de conceitos da ontologia, est\u00e3o os conceitos do \n\ndom\u00ednio de interesse na linguagem de representa\u00e7\u00e3o do \n\nconhecimento. J\u00e1 no \u00faltimo n\u00edvel, de inst\u00e2ncias da ontologia, est\u00e3o \n\nrepresentados os objetos do dom\u00ednio, com os respectivos valores para \n\nas propriedades. \n\n \nFigura 1 \u2013 N\u00edveis de abstra\u00e7\u00e3o para ontologias \n\nFonte: Adaptado e traduzido de Daconta et al. (2003). \n\n \n\n2.1.1) Classifica\u00e7\u00e3o de Ontologias \n\nOntologias podem ser classificadas de diferentes formas, \n\ntomando por base sua hierarquia ou ent\u00e3o a expressividade da \n\nmesma. \n\nEm termos de hierarquia h\u00e1 tr\u00eas n\u00edveis de classifica\u00e7\u00e3o \n\naplic\u00e1veis (GUARINO, 1998): \n\n? Ontologias de alto n\u00edvel: nesse grupo est\u00e3o as ontologias \n\nque descrevem conceitos de aplica\u00e7\u00e3o geral, que s\u00e3o independentes \n\nde um problema ou dom\u00ednio espec\u00edfico, por exemplo, conceitos de \n\nespa\u00e7o, tempo, objetos, etc. Tem boa aplica\u00e7\u00e3o para reuso na \n\n\n\n  \n\nconstru\u00e7\u00e3o de outras ontologias, mais espec\u00edficas, que envolvam \n\nesses conceitos mais gerais. \n\n? Ontologias de dom\u00ednio e de tarefa: as de dom\u00ednio \n\ndescrevem conceitos gen\u00e9ricos de um dom\u00ednio em particular (como no \n\nexemplo citado em RAUTEMBERG (2009), o termo \u201cdoen\u00e7a\u201d no \n\ndom\u00ednio de \u201cMedicina\u201d). As ontologias de tarefa descrevem o conjunto \n\nde a\u00e7\u00f5es ou tarefas realizadas em um determinado dom\u00ednio (exemplo, \n\na a\u00e7\u00e3o de \u201cdiagnosticar\u201d tamb\u00e9m no dom\u00ednio de \u201cMedicina\u201d \n\n(RAUTEMBERG, 2009)). \n\n? Ontologias de aplica\u00e7\u00e3o: As desse n\u00edvel descrevem \n\nconceitos que integram os das ontologias do n\u00edvel anterior (de dom\u00ednio \n\ne de tarefas), sendo uma especializa\u00e7\u00e3o dessas normalmente. \n\nNa Figura 2 \u00e9 poss\u00edvel ter uma representa\u00e7\u00e3o visual da \n\nclassifica\u00e7\u00e3o acima descrita. \n\n \nFigura 2 \u2013 Classifica\u00e7\u00e3o de ontologia por hierarquia \n\nFonte: Adaptado e traduzido de Guarino (1998). \n\n \n\nNa classifica\u00e7\u00e3o por expressividade (GOM\u00c9Z-P\u00c9REZ; \n\nCORCHO, 2002) tem-se dois grupos poss\u00edveis, determinados pelo tipo \n\n\n\n  \n\nde linguagem de representa\u00e7\u00e3o aplicada e pelos elementos \n\nconstituintes da ontologia, sendo esses grupos: \n\n? Ontologias de menor expressividade: as que modelam \n\ninforma\u00e7\u00e3o sobre um dom\u00ednio (conceitos e taxonomia), n\u00e3o vinculando \n\nos axiomas e restri\u00e7\u00f5es. Por justamente n\u00e3o apresentar uma \n\nexpressividade t\u00e3o alta em rela\u00e7\u00e3o ao dom\u00ednio abordado (pela n\u00e3o \n\nnecessidade dos axiomas e restri\u00e7\u00f5es) \u00e9 que a infer\u00eancia \n\ncomputacional sobre a mesma \u00e9 dificultada. \n\n? Ontologias de maior expressividade: essas incorporam os \n\naxiomas e restri\u00e7\u00f5es do dom\u00ednio, o que requer maior expressividade, \n\ntornando tamb\u00e9m o racioc\u00ednio, por parte dos computadores, mais f\u00e1cil. \n\n \n\n2.1.2) Uso de Ontologias \n\nOntologias est\u00e3o geralmente associadas \u00e0 informa\u00e7\u00e3o e \n\nconhecimento sobre dom\u00ednios sendo utilizadas para a representa\u00e7\u00e3o \n\ndesse conhecimento em aplica\u00e7\u00f5es computacionais. Como exemplos \n\nde uso podem ser mencionados a integra\u00e7\u00e3o e recupera\u00e7\u00e3o de \n\ninforma\u00e7\u00f5es na web e a gest\u00e3o de conhecimento sobre um dom\u00ednio \n\n(STUDER et al., 1998). Outros autores (GRUNINGER; LEE, 2002) \n\napresentam ainda outras aplica\u00e7\u00f5es para ontologias: \n\n? Comunica\u00e7\u00e3o: entre sistemas computacionais, seres \n\nhumanos, ou ainda entre ambos. \n\n? Infer\u00eancia computacional: usadas internamente na \n\nrepresenta\u00e7\u00e3o e manipula\u00e7\u00e3o de informa\u00e7\u00f5es, al\u00e9m de tamb\u00e9m serem \n\nusadas para an\u00e1lise de estruturas, algoritmos e, entradas e sa\u00eddas de \n\nsistemas. \n\n? Reuso e utiliza\u00e7\u00e3o do conhecimento: possibilitam definir \n\nbibliotecas ou reposit\u00f3rios de informa\u00e7\u00f5es. \n\n\n\n  \n\nAinda no contexto do conhecimento, focando na engenharia \n\nsobre a mesma, ontologias podem ser empregadas para (MIKA; \n\nAKKERMANS, 2005): \n\n? Comunica\u00e7\u00e3o do conhecimento: processo no qual est\u00e3o as \n\ntarefas ligadas \u00e0 compreens\u00e3o dos conceitos. \n\n? Integra\u00e7\u00e3o do conhecimento: processo onde est\u00e3o as \n\natividades que definem o relacionamento entre os conceitos. \n\n? Racioc\u00ednio com conhecimento: processo com tarefas \n\nrelacionadas \u00e0 produ\u00e7\u00e3o de novos conhecimentos. \n\nQuando se altera o foco no conhecimento para a gest\u00e3o do \n\nmesmo, ainda destacam-se mais aplica\u00e7\u00f5es para as ontologias \n\n(GSEVIC et al., 2006): \n\n? Colabora\u00e7\u00e3o: ontologias podem servir como um \u201cesqueleto \n\nunificado do conhecimento\u201d para projetos onde a equipe envolvida \u00e9 \n\ninterdisciplinar, possibilitando assim uma melhor comunica\u00e7\u00e3o e \n\nentendimento entre os membros sobre os conceitos relacionados ao \n\ndom\u00ednio. \n\n? Interoperabilidade: uma ontologia pode facilitar a integra\u00e7\u00e3o \n\nde diferentes fontes de dados para busca de informa\u00e7\u00f5es, por \n\nexemplo, desde que essas distintas fontes reconhe\u00e7am a mesma \n\nontologia, facilitando assim a convers\u00e3o de dados quando necess\u00e1rio, \n\npor exemplo. \n\n? Educa\u00e7\u00e3o: ontologias podem servir como fonte de refer\u00eancia \n\npara estudos pesquisas e propaga\u00e7\u00e3o do conhecimento de um \n\ndeterminado dom\u00ednio, isso quando a ontologia representa um \n\nconsenso comum dos conceitos desse dom\u00ednio. \n\n? Modelagem: ontologias podem, no contexto de Sistemas \n\nBaseados em Conhecimento, servir como um \u201cbloco de constru\u00e7\u00e3o \n\nreutiliz\u00e1vel\u201d (RAUTEMBERG, 2009) podendo este ser utilizado em \n\n\n\n  \n\naplica\u00e7\u00f5es distintas. Exemplo: uma ontologia sobre carros pode servir \n\na um sistema web para venda de autom\u00f3veis, onde pode trazer \n\nsugest\u00f5es de carros para compras como tamb\u00e9m informa\u00e7\u00f5es e \n\nconhecimentos pertinentes sobre os carros vendidos. \n\n \n\n2.1.3) A Engenharia de Ontologias e suas \n\nAtividades \n\nA Engenharia de Ontologias \u00e9 a disciplina respons\u00e1vel por \n\nadministrar e se preocupar com as atividades, processos, ciclos de \n\nvida, m\u00e9todos e metodologias envolvidos no desenvolvimento de \n\nontologias, bem como nas ferramentas e linguagens envolvidos na \n\nconstru\u00e7\u00e3o dessas ontologias (G\u00d3MEZ-P\u00c9REZ et al., 2004). \n\nA terminologia envolvida na Engenharia de Ontologias foi \n\nbaseada na Engenharia de Software, advindo da\u00ed a semelhan\u00e7a nas \n\natividades envolvidas no desenvolvimento de ontologias com as de \n\ndesenvolvimento de software (PINTO; MARTINS, 2004 e YE et al., \n\n2007). \n\nA seguir, as atividades presentes no desenvolvimento de \n\nontologias: \n\n? Especifica\u00e7\u00e3o: etapa onde s\u00e3o identificados prop\u00f3sito e \n\nescopo da ontologia a ser desenvolvida. Podem ser aplicadas as \n\nperguntas \u201cPor que a ontologia \u00e9 constru\u00edda?\u201d e \u201cQuais s\u00e3o as \n\ninten\u00e7\u00f5es de uso e usu\u00e1rios da ontologia?\u201d, pois as respostas destas \n\nser\u00e3o as defini\u00e7\u00f5es, respectivamente, do prop\u00f3sito e do escopo. \n\n? Conceitualiza\u00e7\u00e3o: \u00e9 onde se define um modelo conceitual da \n\nontologia, que represente os conceitos do dom\u00ednio abordado e as \n\nrela\u00e7\u00f5es entre estes. A defini\u00e7\u00e3o se baseia nas informa\u00e7\u00f5es colhidas \n\nna atividade anterior (especifica\u00e7\u00e3o). \n\n\n\n  \n\n? Formaliza\u00e7\u00e3o: nesta atividade o modelo conceitual \n\nanteriormente definido \u00e9 formalizado, aplicando-se restri\u00e7\u00f5es e \n\naxiomas aos conceitos j\u00e1 estabelecidos. Dessa forma \u00e9 feita a \n\nrestri\u00e7\u00e3o das interpreta\u00e7\u00f5es desses termos e feita a organiza\u00e7\u00e3o \n\nhier\u00e1rquica dos mesmos (atrav\u00e9s de rela\u00e7\u00f5es estruturais como \u201c\u00e9-um\u201d \n\nou \u201cparte-de\u201d).? Implementa\u00e7\u00e3o: a ontologia \u00e9 implementada atrav\u00e9s \n\nde uma linguagem de representa\u00e7\u00e3o do conhecimento, que deve ser \n\nescolhida adequadamente para cada caso. \n\n? Manuten\u00e7\u00e3o: como no desenvolvimento de softwares, \u00e9 onde \n\ns\u00e3o feitas corre\u00e7\u00f5es e atualiza\u00e7\u00f5es na ontologia, algumas vezes \n\nprovocados por novos requisitos que surgem, ou s\u00e3o visualizados, \n\ndurante o desenvolvimento. \n\nAl\u00e9m dessas etapas pr\u00e9-definidas h\u00e1 outras que tamb\u00e9m s\u00e3o \n\nimportantes, n\u00e3o apenas em um dado momento do desenvolvimento, \n\nmas durante todo o ciclo de vida da ontologia (PINTO; MARTINS, \n\n2004): \n\n? Aquisi\u00e7\u00e3o do conhecimento: como o nome indica seria \n\nadquirir conhecimento a respeito do dom\u00ednio da ontologia, fazendo \n\nisso atrav\u00e9s de especialistas nesse dom\u00ednio ou ent\u00e3o de bibliografia \n\nsobre o mesmo. Algumas t\u00e9cnicas poss\u00edveis para aquisi\u00e7\u00e3o de tal \n\nseriam brainstorming, entrevistas, an\u00e1lises de textos, etc. \n\n? Avalia\u00e7\u00e3o: julgamento t\u00e9cnico da qualidade da ontologia, que \n\npode ser: \n\n? Avalia\u00e7\u00e3o t\u00e9cnica: \u00e9 utilizado um framework de refer\u00eancia \n\npara o julgamento, sendo que essa avalia\u00e7\u00e3o envolve as atividades \n\nde: \n\n? verifica\u00e7\u00e3o, que garante a corre\u00e7\u00e3o segundo fontes de \n\nconhecimento especializadas; \n\n\n\n  \n\n? valida\u00e7\u00e3o, que garante o alinhamento \u00e0 finalidade \n\nestabelecida para a ontologia, de acordo com os resultados da etapa \n\nde especifica\u00e7\u00e3o. \n\n? Avalia\u00e7\u00e3o de usu\u00e1rios: \u00e9 feito o julgamento de usabilidade e \n\nutilidade da ontologia, do ponto de vista do usu\u00e1rio. \n\n? Documenta\u00e7\u00e3o: registro de toda a ontologia e de todo o \n\nprocesso de desenvolvimento, etapa por etapa (o que, como e por que \n\nfoi feito), incluindo os documentos finais de cada etapa, a fim de gerar \n\num material completo para o entendimento, uso e reuso, e \n\nmanuten\u00e7\u00e3o da ontologia. \n\nEssas atividades s\u00e3o as mais comuns no que diz respeito a \n\ndesenvolvimento de ontologias, sendo que existem outras atividades \n\nligadas a metodologias mais espec\u00edficas da Engenharia de Ontologias. \n\nNesse trabalh\u00e3o o foco estar\u00e1 concentrado na primeira etapa \n\napresentada: Especifica\u00e7\u00e3o. \n\n \n\n2.2) Metodologias para Constru\u00e7\u00e3o de Ontologias \n\nAinda n\u00e3o h\u00e1 uma metodologia que tenha se definido como \n\npadr\u00e3o para desenvolvimento de ontologias (PINTO; MARTINS, 2004). \n\nUm dos argumentos lan\u00e7ados para isso \u00e9 que as metodologias \n\npossuem atividades que n\u00e3o est\u00e3o compreendidas entre si, \n\nnecessitando-se assim a combina\u00e7\u00e3o de metodologias para abrangir \n\nas atividades necess\u00e1rias ao desenvolvimento de uma ontologia \n\n(FERNADEZ-L\u00d3PEZ; G\u00d3MEZ-P\u00c9REZ, 2002). \n\nNessa sess\u00e3o ser\u00e3o apresentadas, brevemente, algumas \n\nmetodologias comuns no desenvolvimento de ontologias \u2014 a On-to-\n\nKnowledge e a METHONTOLOGY \u2014 e a metodologia NeOn, sobre a \n\nqual se dar\u00e1 o desenvolvimento do trabalho. \n\n\n\n  \n\n \n\n2.2.1) Metodologia On-to-Knowledge \n\nTendo sido desenvolvida em uma coopera\u00e7\u00e3o entre v\u00e1rias \n\nentidades europ\u00e9ias (FENSEL; HERMELEN, 2008) a metodologia On-\n\nto-Knowledge teve como foco de concep\u00e7\u00e3o a utiliza\u00e7\u00e3o em Sistemas \n\nde Gest\u00e3o do Conhecimento. Essa metodologia \u00e9 dividida em cinco \n\nfases, como pode ser visto na Figura 3, descritas a seguir (SURE; \n\nSTUDER, 2003): \n\n \nFigura 3 \u2013 Processo de desenvolvimento da metodologia On-to-Knowledge \n\nFonte: Adaptado e traduzido de Sure e Studer (2003). \n\n \n\n? Estudo de viabilidade: \u00e9 uma fase pr\u00e9-desenvolvimento, \n\nanterior ao real in\u00edcio da metodologia. O estudo realizado nessa fase \n\nvisa mapear todo o contexto envolvido no desenvolvimento, \n\nidentificando, por exemplo, os problemas ou oportunidades que a \n\norganiza\u00e7\u00e3o envolvida no projeto tem e verificando se existe a \n\nnecessidade real de uma ontologia para a mesma. O estudo \u00e9 \n\nrealizado utilizando CommonKADS como metodologia (SCHREIBER \n\net al., 2002). \n\n? In\u00edcio da ontologia: aqui realmente inicia a metodologia. \n\nTrata-se da fase de especifica\u00e7\u00e3o descrita anteriormente na sess\u00e3o \n\n2.1.3, onde s\u00e3o definidos os requisitos para desenvolvimento, o \n\ndom\u00ednio abrangido, as fontes de conhecimento, os atores e cen\u00e1rios, \n\n\n\n  \n\nas quest\u00f5es de compet\u00eancia \u2014 que ir\u00e3o definir os termos envolvidos \n\nno dom\u00ednio, que passar\u00e3o depois a ser os conceitos e rela\u00e7\u00f5es de tal \n\n\u2014 al\u00e9m de outros itens. \n\n? Refinamento: \u00e9 onde \u00e9 feito o desenvolvimento da ontologia, \n\nmuitas vezes juntamente com os especialistas no dom\u00ednio, onde s\u00e3o \n\nfeitas an\u00e1lises sobre a ontologia a fim de evoluir e estend\u00ea-la, de \n\nacordo com o que foi anteriormente definido. O produto final desta fase \n\n\u00e9 uma vers\u00e3o est\u00e1vel da ontologia. \n\n? Avalia\u00e7\u00e3o: aqui \u00e9 feita a verifica\u00e7\u00e3o da ontologia mediante os \n\nrequisitos estabelecidos na fase inicial do desenvolvimento. Por muitas \n\nvezes s\u00e3o utilizadas as perguntas de compet\u00eancia como base para \n\nanalisar se a ontologia responde satisfatoriamente essas quest\u00f5es, \n\nrepresentando assim bem o dom\u00ednio. \n\n? Manuten\u00e7\u00e3o e Evolu\u00e7\u00e3o: \u00e9 uma fase p\u00f3s-desenvolvimento \n\nque visa aumentar a representatividade da ontologia ou adapt\u00e1-la a \n\num novo requisito, por exemplo, cabendo a responsabilidade dessa \n\nfase \u00e0 organiza\u00e7\u00e3o detentora da ontologia. \n\n \n\n2.2.2) Metodologia METHONTOLOGY \n\nEsta metodologia nasceu em um grupo de pesquisa em \n\nEngenharia de Ontologias da Universidade Polit\u00e9cnica de Madri, e tem \n\nforte embasamento nas metodologias de Engenharia de Software e \n\nEngenharia do Conhecimento (GOM\u00c9Z-P\u00c9REZ et al., 2004). Nessa \n\nmetodologia, o ciclo de vida de uma ontologia \u00e9 baseado em prot\u00f3tipos \n\n\u2014 a cada etapa do processo de desenvolvimento (especifica\u00e7\u00e3o, \n\nconceitualiza\u00e7\u00e3o e demais, veja sess\u00e3o 2.1.3) \u00e9 gerado um prot\u00f3tipo \n\nda ontologia at\u00e9 aquele ponto. As atividades dessa metodologia t\u00eam \n\nfoco na ger\u00eancia, desenvolvimento e suporte ao ciclo de vida, como \n\n\n\n  \n\nvisto na Figura 4, tendo esta caracter\u00edstica forte liga\u00e7\u00e3o com a \n\nEngenharia de Software. \n\n \nFigura 4 \u2013 Processo de desenvolvimento e ciclo de vida da metodologia \n\nMETHONTOLOGY \nFonte: Adaptado e traduzido de G\u00f3mez-Per\u00e9z et al. (2004). \n\n \n\nAs etapas do processo s\u00e3o as descritas anteriormente na \n\nsess\u00e3o 2.1.3, como pode ser confirmado no bloco \u201cAtividades de \n\nDesenvolvimento\u201d, na Figura 4. A sua principal caracter\u00edstica em \n\nrela\u00e7\u00e3o a outras metodologias \u00e9 a gera\u00e7\u00e3o de artefatos de \n\ndocumenta\u00e7\u00e3o ao final de cada etapa do processo de \n\ndesenvolvimento, gerando uma documenta\u00e7\u00e3o bastante rica. \n\n \n\n2.2.3) Metodologia NeOn \n\nO projeto NeOn \u2014 acr\u00f4nimo para Networked Ontologies \u2014 foi \n\ncriado a partir de um cons\u00f3rcio de institui\u00e7\u00f5es europ\u00e9ias. O projeto \n\ntrabalha com a id\u00e9ia de desenvolvimento colaborativo de ontologias, \n\npermitindo o reuso de ontologias para constru\u00e7\u00e3o de novas, \n\npromovendo isso atrav\u00e9s de ontologias distribu\u00eddas em rede, em \n\n\n\n  \n\ndiferentes locais e compartilhadas via web (SU\u00c1REZ-FIGUEROA et \n\nal., 2007). Assim n\u00e3o seria mais necess\u00e1rio construir uma ontologia \n\ntotalmente do zero, ou ent\u00e3o replicar elementos de uma ontologia j\u00e1 \n\nexistente para criar uma nova, bastaria compartilhar a j\u00e1 existente e \n\nestend\u00ea-la para gerar a nova cria\u00e7\u00e3o. \n\nPara esse novo conceito de desenvolvimento o projeto prop\u00f4s \n\numa metodologia para tal (SU\u00c1REZ-FIGUEROA et al., 2008). A \n\nmetodologia aplicada, por\u00e9m, varia de acordo com o cen\u00e1rio de \n\nconstru\u00e7\u00e3o de uma ontologia em rede que se apresenta para o caso. \n\nS\u00e3o nove os cen\u00e1rios encontrados durante as pesquisas do projeto, \n\nsendo eles (SU\u00c1REZ-FIGUEROA et al., 2008): \n\n? Cen\u00e1rio 1: Constru\u00e7\u00e3o total \u2014 a partir do zero, reuso de \n\nontologias j\u00e1 existentes \u2014 sem o reuso de recursos de conhecimento. \n\n? Cen\u00e1rio 2: Constru\u00e7\u00e3o de ontologia em rede a partir do reuso \n\ne reengenharia de recursos de conhecimento. \n\n? Cen\u00e1rio 3: Constru\u00e7\u00e3o de ontologia em rede a partir do reuso \n\nde recursos ontol\u00f3gicos. \n\n? Cen\u00e1rio 4: Constru\u00e7\u00e3o de ontologia em rede a partir de reuso \n\ne reengenharia de recursos ontol\u00f3gicos. \n\n? Cen\u00e1rio 5: Constru\u00e7\u00e3o de ontologia em rede a partir do reuso \n\ne integra\u00e7\u00e3o de recursos ontol\u00f3gicos. \n\n? Cen\u00e1rio 6: Constru\u00e7\u00e3o de ontologia em rede a partir do reuso, \n\nintegra\u00e7\u00e3o e reengenharia de recursos ontol\u00f3gicos. \n\n? Cen\u00e1rio 7: Constru\u00e7\u00e3o de ontologia em rede a partir do reuso \n\nde padr\u00f5es de design de ontologias. \n\n? Cen\u00e1rio 8: Constru\u00e7\u00e3o de ontologia em rede a partir da \n\nreestrutura\u00e7\u00e3o de recursos ontol\u00f3gicos. \n\n\n\n  \n\n? Cen\u00e1rio 9: Constru\u00e7\u00e3o de ontologia em rede a partir da \n\nlocaliza\u00e7\u00e3o de recursos ontol\u00f3gicos. \n\nA partir da leitura de Su\u00e1rez-Figueroa (2008) entende-se por \n\nrecursos de conhecimento (ou recursos n\u00e3o-ontol\u00f3gicos) estruturas \n\nque representam informa\u00e7\u00f5es de conhecimento sobre um dom\u00ednio e \n\nque n\u00e3o foram formalizadas atrav\u00e9s de ontologias (ex.: thesauri, \n\ndicion\u00e1rios gloss\u00e1rios, etc.). J\u00e1 recursos ontol\u00f3gicos seriam sele\u00e7\u00f5es \n\nde elementos extra\u00eddos de ontologias para resolu\u00e7\u00e3o de um dado \n\nproblema, sendo que esses recursos podem ser: ontologias \n\ncompletas, m\u00f3dulos de ontologias, padr\u00f5es de design de ontologias ou \n\ndeclara\u00e7\u00f5es de ontologias. \n\nOs cen\u00e1rios propostos no estudo em Su\u00e1rez-Figueroa (2008) \n\npodem ser combinados em grupos. A divis\u00e3o mais considerada na \n\nmetodologia NeOn \u00e9 de separar os cen\u00e1rios onde h\u00e1 reuso de \n\nrecursos ontol\u00f3gicos daqueles onde h\u00e1 reuso e reengenharia de \n\nrecurso n\u00e3o-ontol\u00f3gicos (recursos de conhecimento), havendo ainda o \n\ncaso especial do cen\u00e1rio 7, onde h\u00e1 o reuso de padr\u00f5es de design de \n\nontologias. \n\nNa Figura 5 \u00e9 poss\u00edvel visualizar todos os processos e \n\natividades envolvidos no desenvolvimento com a metodologia NeOn \u2014 \n\nos n\u00fameros indicam as partes envolvidas em cada cen\u00e1rio de \n\nconstru\u00e7\u00e3o de ontologias em rede, citados anteriormente. Pode-se \n\nobservar na Figura 5 tamb\u00e9m as etapas b\u00e1sicas presentes na \n\nmetodologia: especifica\u00e7\u00e3o, conceitualiza\u00e7\u00e3o, formaliza\u00e7\u00e3o e \n\nimplementa\u00e7\u00e3o (vis\u00edveis na figura como \u201cO. Specification, O. \n\nConceptualization, O. Formalization, O. Implementation\u201d). Essas \n\netapas s\u00e3o como as descritas anteriormente na sess\u00e3o 2.1.3 desse \n\ntrabalho. O que muda \u00e9 que, dependendo do cen\u00e1rio, h\u00e1 o acr\u00e9scimo \n\nde uma etapa, al\u00e9m de atividades e processos distintos entre as \n\netapas de j\u00e1 existentes, em especial conceitualiza\u00e7\u00e3o e formaliza\u00e7\u00e3o. \n\n\n\n  \n\nAs etapas acrescidas s\u00e3o: Localiza\u00e7\u00e3o (na figura, \u201cO. localization\u201d), \n\npresente no cen\u00e1rio 9 e, Reestrutura\u00e7\u00e3o da Ontologia (na figura, \n\n\u201cOntology Restructuring\u201d), presente no cen\u00e1rio 8, onde s\u00e3o aplicadas \n\natividades de extens\u00e3o, especializa\u00e7\u00e3o, modulariza\u00e7\u00e3o, etc. sobre os \n\nrecursos ontol\u00f3gicos usados na constru\u00e7\u00e3o. \n\n \nFigura 5 \u2013 Etapas e cen\u00e1rios para constru\u00e7\u00e3o de ontologias em rede presentes na \n\nmetodologia NeOn \nFonte: Su\u00e1rez-Figueroa (2008). \n\n \n\n2.3) Ferramentas \n\nNo desenvolvimento de ontologias \u00e9 importante o uso de \n\nferramentas computacionais que suportam a manipula\u00e7\u00e3o dos \n\nelementos da ontologia, para que esta n\u00e3o seja t\u00e3o complexa e mais \n\nconsistente (GRAU et al., 2008). \n\nNesse trabalho ser\u00e3o apresentadas algumas dessas \n\nferramentas, que s\u00e3o: Prot\u00e9g\u00e9, OntoKEM e NeOn Toolkit. \n\n\n\n  \n\n \n\n2.3.1) Prot\u00e9g\u00e9 \n\nDentre as mais conhecidas ferramentas para manipula\u00e7\u00e3o e \n\ndesenvolvimento de ontologias est\u00e1 o Prot\u00e9g\u00e9. Trata-se de uma \n\nplataforma \u2014 um conjunto de ferramentas espec\u00edficas de \n\nmanipula\u00e7\u00e3o, cria\u00e7\u00e3o e visualiza\u00e7\u00e3o \u2014 baseada na pol\u00edtica open-\n\nsource \u2014 pol\u00edtica de c\u00f3digo aberto que possibilita o acesso ao c\u00f3digo \n\nda aplica\u00e7\u00e3o para possibilitar altera\u00e7\u00f5es evolu\u00e7\u00f5es e \n\ndesenvolvimentos de novas funcionalidades \u2014 que tem por objetivo a \n\nconstru\u00e7\u00e3o de modelos de dom\u00ednios e aplica\u00e7\u00f5es baseadas em \n\nconhecimento com ontologias (PROT\u00c9G\u00c9, 2009). Na Figura 6 \u00e9 \n\nposs\u00edvel visualizar a interface gr\u00e1fica da ferramenta. \n\n \nFigura 6 \u2013 Tela de exemplo da ferramenta Prot\u00e9g\u00e9, usando a ontologia de exemplo \n\nwines \nFonte: RAUTEMBERG (2009). \n\n \n\n\n\n  \n\n2.3.2) OntoKEM \n\nO ontoKEM \u2014 que significa ontology for Knowledge Engineering \n\nand Management \u2014 \u00e9 uma ferramenta web, desenvolvida em meio \n\nacad\u00eamico, que suporta a constru\u00e7\u00e3o e documenta\u00e7\u00e3o de ontologias \n\n(RAUTEMBERG et al., 2008). Nessa ferramenta o desenvolvimento \u00e9 \n\nbaseado em artefatos de documenta\u00e7\u00e3o fundamentados nas \n\nmetodologias On-to-Knowledge e METHONTOLOGY (j\u00e1 vistas \n\nanteriormente, nas se\u00e7\u00f5es 2.2.1 e 2.2.2 respectivamente) e tamb\u00e9m \n\nno processo de desenvolvimento apresentado pelo guia intitulado \n\nOntology Development 101 (refer\u00eancia sobre o guia em NOY \n\nGUINESS, 2008). Esta ferramenta ser\u00e1 usada no pr\u00f3ximo cap\u00edtulo \n\ncomo exemplo de compara\u00e7\u00e3o entre as formas de especifica\u00e7\u00e3o das \n\nmetodologias On-to-Knowledge e METHONTOLOGY (aplicadas no \n\nontoKEM) e da metodologia NeOn (aplicada nesse trabalho). Na \n\nFigura 7 segue uma visualiza\u00e7\u00e3o do ontoKEM na sua atual vers\u00e3o, \n\npara fins ilustrativos. \n\n \n\n\n\n  \n\nFigura 7 \u2013 Tela de exemplo da ferramenta ontoKEM, m\u00f3dulo \u201cVocabul\u00e1rio\u201d \n\n \n\n2.3.3) NeOn Toolkit \n\nTrata-se da ferramenta computacional que suporta o projeto \n\nNeOn, j\u00e1 descrito anteriormente na sess\u00e3o 2.2.3. O NeOn Toolkit \u00e9 \n\numa plataforma dotada de um conjunto de ferramentas espec\u00edficas \n\npara constru\u00e7\u00e3o de ontologias em rede, como \u00e9 a proposta da \n\nmetodologia NeOn (NEON, 2008). A ferramenta foi elaborada \n\nutilizando-se da estrutura da interface de desenvolvimento e \n\nprograma\u00e7\u00e3o Eclipse SDK e \u00e9 expans\u00edvel atrav\u00e9s de plugins que \n\nexecutam fun\u00e7\u00f5es espec\u00edficas das etapas de desenvolvimento da \n\nmetodologia. A plataforma ainda n\u00e3o est\u00e1 completa, pois o pr\u00f3prio \n\nprojeto NeOn ainda est\u00e1 em desenvolvimento. Na Figura 8 segue uma \n\nvisualiza\u00e7\u00e3o da interface gr\u00e1fica do NeOn Toolkit. \n\n \nFigura 8 \u2013 Tela de exemplo da ferramenta NeOn-Toolkit \n\nFonte: NeOn (2008). \n\n \n\n\n\n  \n\n3) A FASE DE ESPECIFICA\u00c7\u00c3O DE ONTOLOGIAS \n\nO objetivo deste breve cap\u00edtulo \u00e9 o de apresentar \n\nespecificadamente a etapa de especifica\u00e7\u00e3o segundo a metodologia \n\nNeOn. \u00c9 essa etapa da metodologia que a aplica\u00e7\u00e3o proposta nesse \n\ntrabalho visa dar suporte. De um modo geral, a especifica\u00e7\u00e3o na \n\nEngenharia de Ontologia j\u00e1 foi descrita na sess\u00e3o 2.1.3, sendo que \n\nnesse cap\u00edtulo a primeira sess\u00e3o trar\u00e1 os detalhes da etapa propostos \n\nno projeto NeOn. Na segunda sess\u00e3o ser\u00e1 apresentado como foi \n\nimplementada a etapa mencionada na ferramenta de desenvolvimento \n\nde ontologias ontoKEM (que usa as metodologias On-to-Knowledge e \n\nMETHONTOLOGY, como j\u00e1 descrito na sess\u00e3o 2.3.2 desse trabalho), \n\nafim de destacar as diferen\u00e7as e similaridades entre as metodologias \n\nj\u00e1 conhecidas e o NeOn. \n\n \n\n3.1) Como \u00e9 visto no NeOn \n\nComo j\u00e1 mencionado anteriormente, na Engenharia de \n\nOntologias a etapa de especifica\u00e7\u00e3o visa identificar o prop\u00f3sito e \n\nescopo da ontologia a ser desenvolvida, respondendo respectivamente \n\nas perguntas \u201cPor que a ontologia \u00e9 constru\u00edda?\u201d e \u201cQuais s\u00e3o as \n\ninten\u00e7\u00f5es de uso e usu\u00e1rios da ontologia?\u201d (PINTO; MARTINS, 2004 e \n\nYE et al., 2007) e tamb\u00e9m definir quais tipos de usu\u00e1rios, cen\u00e1rios de \n\nusos e n\u00edvel de formaliza\u00e7\u00e3o que a ontologia ir\u00e1 suportar e os \n\nrequisitos que a mesma deve atender (SU\u00c1REZ-FIGUEROA, 2008). \n\nPara a metodologia NeOn foi proposta a t\u00e9cnica de perguntas de \n\ncompet\u00eancia (GR\u00dcNINGER; FOX, 1995) para o levantamento dos \n\nrequisitos da ontologia. Atrav\u00e9s das perguntas de compet\u00eancia \u00e9 que \n\nse levantar\u00e1 \u201co que\u201d a ontologia deve responder \u2014 ao final ser\u00e3o \n\nessas perguntas que a mesma dever\u00e1 responder. Os termos extra\u00eddos \n\n\n\n  \n\ndessas perguntas \u00e9 que passar\u00e3o, na etapa seguinte da metodologia, \n\na formar os conceitos e rela\u00e7\u00f5es entre conceitos da ontologia. \n\nComo documento de resultado da etapa de especifica\u00e7\u00e3o a \n\nmetodologia NeOn prop\u00f5e o OSRD (\u201cOntology Requirements \n\nSpecification Document\u201d ou \u201cDocumento de Especifica\u00e7\u00e3o de \n\nRequisitos da Ontologia\u201d), um modelo padr\u00e3o que apresenta os \n\nrequisitos da ontologia, sendo eles (SU\u00c1REZ-FIGUEROA, 2008): \n\n? Prop\u00f3sito (\u201cOntology purpose\u201d): aqui \u00e9 onde s\u00e3o \n\ndetalhados os objetivos, as finalidades ao qual a ontologia se prop\u00f5e. \n\n? Escopo (\u201cOntology scope\u201d): identifica qual ser\u00e1 a \n\nabrang\u00eancia e a granularidade da ontologia, at\u00e9 que profundidade a \n\nontologia abordar\u00e1 o dom\u00ednio representado. \n\n? N\u00edvel de Formalismo (\u201cLevel of Formality\u201d): indica qual o \n\ngrau de formaliza\u00e7\u00e3o que se pretende adotar na implementa\u00e7\u00e3o da \n\nontologia. Um exemplo de descri\u00e7\u00e3o de N\u00edvel de Formalismo seria: \u201cA \n\nontologia ser\u00e1 implementada na linguagem OWL\u201d. \n\n? Usu\u00e1rios desejados (\u201cIntended Users\u201d): o objetivo neste \n\nitem \u00e9 criar as descri\u00e7\u00f5es dos perfis de usu\u00e1rios desejados para essa \n\nontologia. Atrav\u00e9s dessas descri\u00e7\u00f5es \u00e9 poss\u00edvel, ap\u00f3s a elabora\u00e7\u00e3o da \n\nontologia, desenvolver aplica\u00e7\u00f5es melhor focadas nos perfis mais \n\ndesejados, por exemplo. \n\n? Usos (Cen\u00e1rios) desejados (\u201cIntended Uses\u201d): este item \n\ndetalhar os cen\u00e1rios de uso que a ontologia dever\u00e1 prover suporte ao \n\nestar conclu\u00edda. Estes cen\u00e1rios podem ser descritos atrav\u00e9s de \n\nlinguagem natural ou at\u00e9 mesmo atrav\u00e9s de diagramas UML, como \n\ndiagramas casos de uso. Tamb\u00e9m facilita o desenvolvimento de \n\naplica\u00e7\u00f5es mais focadas. \n\n? Grupos de Perguntas de Compet\u00eancia (\u201cGroups of \n\nCompetence Questions\u201d): \u00e9 onde s\u00e3o inseridas as perguntas de \n\n\n\n  \n\ncompet\u00eancias elaboradas, bem como as suas respectivas respostas. \n\nAs perguntas devem ser categorizadas conforme a necessidade e \n\ntamb\u00e9m deve ser atribu\u00edda a prioridade de cada uma. \n\nA partir desses grupos, e de suas perguntas de compet\u00eancia, \u00e9 \n\nque ser\u00e3o extra\u00eddos os termos e objetos para a ontologia. No projeto \n\nNeOn a proposta \u00e9 que essa extra\u00e7\u00e3o seja autom\u00e1tica: \u00e9 feita uma \n\nbusca nas perguntas e extra\u00eddos os termos, que ent\u00e3o s\u00e3o exibidos ao \n\nusu\u00e1rio desenvolvedor que, por sua vez, pode selecionar quais s\u00e3o \n\nrelevantes. \n\n? Termos (\u201cTerms\u201d): representam os termos extra\u00eddos das \n\nperguntas, sendo estes normalmente conceitos ou rela\u00e7\u00f5es entre \n\nconceitos da ontologia. Sempre apresentam a freq\u00fc\u00eancia com a qual \n\naparecem na listagem total de perguntas de compet\u00eancia e podem \n\ntamb\u00e9m receber ordena\u00e7\u00e3o de prioridade. \n\n? Objetos (\u201cObjects\u201d): representam os objetos extra\u00eddos das \n\nperguntas, sendo estes objetos normalmente inst\u00e2ncias da ontologia. \n\nPossuem as mesmas caracter\u00edsticas de freq\u00fc\u00eancia e prioridade dos \n\ntermos. \n\nNa Figura 9 \u00e9 poss\u00edvel visualizar o modelo de documento OSRD \n\nproposto no NeOn. \n\n\n\n  \n\n \nFigura 9 \u2013 Modelo do documento OSRD, da metodologia NeOn \n\nFonte: Su\u00e1rez-Figueroa (2008). \n\n \n\n3.2) Como foi visto no ontoKEM \n\nNa ferramenta ontoKEM, desenvolvida sob as metodologias On-\n\nto-Knowledge e METHONTOLOGY, pode-se notar algumas distin\u00e7\u00f5es \n\nem rela\u00e7\u00e3o a proposta da metodologia NeOn, mas que possuem uma \n\ncerta semelhan\u00e7a de objetivo. No ontoKEM (RAUTEMBERG et al., \n\n2008) a etapa de especifica\u00e7\u00e3o \u00e9 dividida em dois m\u00f3dulos: o de \n\n\u201cProjeto\u201d e o de \u201cPerguntas de Compet\u00eancia\u201d. \n\nNo de \u201cProjeto\u201d \u00e9 especificado, al\u00e9m do nome da ontologia, a \n\ndescri\u00e7\u00e3o da mesma \u2014 al\u00e9m da descri\u00e7\u00e3o da vers\u00e3o na qual se \n\nencontra a mesma. Em rela\u00e7\u00e3o ao NeOn esse campo de \u201cdescri\u00e7\u00e3o\u201d \n\n\n\n  \n\nseria um equivalente aos campos descritivos de \u201cprop\u00f3sito\u201d e \u201cescopo\u201d \n\nunificados. Na mesma \u201cdescri\u00e7\u00e3o\u201d poderiam ser inclu\u00eddos os campos \n\n\u201cn\u00edvel de formalismo\u201d e at\u00e9 \u201cusu\u00e1rios desejados\u201d e \u201cusos (cen\u00e1rios) \n\ndesejados\u201d do NeOn, que n\u00e3o possuem correspondentes diretos no \n\nontoKEM. O problema seria o de que todas essas informa\u00e7\u00f5es seriam \n\nrepassadas juntas e na forma de texto livre. \n\nTanto no ontoKEM quanto no NeOn \u00e9 proposta a t\u00e9cnica de \n\nperguntas de compet\u00eancia para o levantamento de requisitos, cabendo \n\na ger\u00eancia disto ao m\u00f3dulo de \u201cPerguntas de compet\u00eancia\u201d. Ali, al\u00e9m \n\ndos cadastrados da perguntas, \u00e9 feito o cadastro dos termos para \n\ncada uma das perguntas. A extra\u00e7\u00e3o destes, por\u00e9m, \u00e9 feita \n\nmanualmente pelo usu\u00e1rio desenvolvedor da ontologia \u2014 ao contr\u00e1rio \n\nda proposta de extra\u00e7\u00e3o autom\u00e1tica do NeOn. Ap\u00f3s o t\u00e9rmino do \n\ncadastro das perguntas e termos \u00e9 poss\u00edvel fazer uma visualiza\u00e7\u00e3o e \n\nsele\u00e7\u00e3o dos termos, permitindo assim exportar os relevantes para a \n\npr\u00f3xima etapa do desenvolvimento da ontologia. \n\nNa Figura 10 \u00e9 poss\u00edvel visualizar o m\u00f3dulo de \u201cProjeto\u201d do \n\nontoKEM, e Figura 11 o de \u201cPerguntas de compet\u00eancia\u201d. \n\n\n\n  \n\n \nFigura 10 \u2013 Tela de exemplo do m\u00f3dulo de \u201cProjeto\u201d do ontoKEM \n\n \nFigura 11 \u2013 Tela de exemplo do m\u00f3dulo de \u201cPerguntas de Compet\u00eancia\u201d do ontoKEM \n\n \n\n\n\n  \n\n3.3) Considera\u00e7\u00f5es \n\nEm rela\u00e7\u00e3o aos procedimentos da etapa de especifica\u00e7\u00e3o \n\nadotados nas duas solu\u00e7\u00f5es, podemos fazer algumas compara\u00e7\u00f5es. \n\nA divis\u00e3o proposta pelo NeOn para os requisitos mais \n\ndescritivos da ontologia \u2014 prop\u00f3sitos, escopo, n\u00edvel de formalismo \u2014 \n\npermite uma defini\u00e7\u00e3o mais clara de cada um por parte de quem \n\nespecifica a ontologia. Apenas um campo descritivo pode permitir uma \n\nmaior liberdade, mas com isso o desenvolvedor pode acabar \n\nesquecendo alguma dessas informa\u00e7\u00f5es, deixando a especifica\u00e7\u00e3o \n\nmais pobre. \n\nA listagem de usu\u00e1rios desejados e dos cen\u00e1rios de uso da \n\nontologia, propostas estas do NeOn, permitem uma defini\u00e7\u00e3o mais \n\nclara dos objetivos e aplica\u00e7\u00f5es da ontologia, facilitando at\u00e9 o \n\ndesenvolvimento posterior de aplica\u00e7\u00f5es sobre a ontologia \u2014 podendo \n\nestas serem focadas sobre determinados usu\u00e1rios ou cen\u00e1rios de \n\nusos. \n\nO uso de perguntas de compet\u00eancia \u00e9 bem semelhante em \n\nambos, sendo que no NeOn tamb\u00e9m s\u00e3o requeridas as respostas \n\nrespectivas a cada quest\u00e3o. A extra\u00e7\u00e3o dos termos \u00e9 que faz a grande \n\ndiferen\u00e7a nesta parte \u2014 manual no ontoKEM e autom\u00e1tica atrav\u00e9s de \n\nt\u00e9cnicas de extra\u00e7\u00e3o terminol\u00f3gicas (SU\u00c1REZ-FIGUEROA, 2008) no \n\nNeOn. A extra\u00e7\u00e3o autom\u00e1tica, com possibilidade de posterior sele\u00e7\u00e3o \n\ndos mais relevantes, facilita bastante o levantamento dos termos da \n\nontologia, n\u00e3o havendo a necessidade de um usu\u00e1rio ficar analisando \n\ncada pergunta e/ou resposta de compet\u00eancia para verificar quais os \n\ntermos que podem existir. \n\nO modelo proposto pela metodologia NeOn parece interessante \n\ne eficaz como modelo de especifica\u00e7\u00e3o de ontologias. Observado isso, \n\no documento OSRD e seus itens servir\u00e3o de base para o \n\n\n\n  \n\ndesenvolvimento de uma aplica\u00e7\u00e3o para suporte da etapa de \n\nespecifica\u00e7\u00e3o da metodologia NeOn, que \u00e9 a proposta desse trabalho. \n\n \n\n4) APLICA\u00c7\u00c3O PARA A FASE DE ESPECIFICA\u00c7\u00c3O \n\nEm Su\u00e1rez-Figueroa (2008), ao final das explica\u00e7\u00f5es a respeito \n\nda etapa de especifica\u00e7\u00e3o da metodologia NeOn, h\u00e1 uma sugest\u00e3o de \n\nimplementa\u00e7\u00e3o. Sugere-se o desenvolvimento de uma aplica\u00e7\u00e3o \n\nacopl\u00e1vel \u2014 um plugin \u2014 para a plataforma de desenvolvimento de \n\nontologias em rede NeOn Toolkit, sendo que esta aplica\u00e7\u00e3o deve \n\nseguir os processos e atividades propostas na etapa de especifica\u00e7\u00e3o \n\nda metodologia NeOn. \n\nNesse trabalho o foco n\u00e3o foi no desenvolvimento somente de \n\num plugin para o NeOn Toolkit, mas sim em uma aplica\u00e7\u00e3o para \n\nespecifica\u00e7\u00e3o de ontologias baseada na metodologia NeOn e que \n\npermitisse liberdade de acoplamento, tanto na parte visual quando na \n\nparte de sa\u00eddas resultantes \u2014 documentos que podem ser gerados ou \n\nformas de persist\u00eancia dos dados. Para isso houve a aplica\u00e7\u00e3o \n\nadaptada do padr\u00e3o de projeto conhecido por MVP, tanto na camada \n\nde visualiza\u00e7\u00e3o quanto na de externaliza\u00e7\u00e3o e persist\u00eancia de dados. \n\nNeste cap\u00edtulo ser\u00e3o apresentados os conceitos e \n\nprocedimentos adotados no desenvolvimento da aplica\u00e7\u00e3o proposta no \n\ntrabalho. Inicialmente ser\u00e1 brevemente apresentado o MVP, para \n\nmelhor entendimento da estrutura e especifica\u00e7\u00e3o da aplica\u00e7\u00e3o que \n\nser\u00e1 o item seguinte. Como terceiro item vir\u00e1 a descri\u00e7\u00e3o do XML para \n\npersist\u00eancia dos dados, seguido de um detalhamento dos m\u00f3dulos e \n\nclasses usados, em \u201cDetalhamento da Estrutura da Aplica\u00e7\u00e3o\u201d. Como \n\n\u00faltima sess\u00e3o comenta-se os resultados apresentados, numa forma de \n\nconsidera\u00e7\u00f5es finais sobre o desenvolvimento. \n\n \n\n\n\n  \n\n4.1) Um pouco sobre o MVP \n\nO MVP \u2014 acr\u00f4nimo para \u201cModel-View-Presenter\u201d ou \u201cModelo-\n\nVisualiza\u00e7\u00e3o-Apresentar\u201d, em tradu\u00e7\u00e3o livre \u2014 \u00e9 um padr\u00e3o de projeto \n\n(FOWLER, 2009) que visa separar o desenvolvimento de uma \n\naplica\u00e7\u00e3o em tr\u00eas camadas principais: \n\n? Model: \u00e9 onde ficam as regras de neg\u00f3cio da aplica\u00e7\u00e3o, onde, \n\npor exemplo, \u00e9 feita toda a manipula\u00e7\u00e3o dos dados conforme o \n\nobjetivo da aplica\u00e7\u00e3o. \n\n? View: \u00e9 onde est\u00e1 toda a parte de interfaces de comunica\u00e7\u00e3o \n\n(gr\u00e1ficas ou n\u00e3o) da aplica\u00e7\u00e3o, que realizam a intera\u00e7\u00e3o com os \n\nusu\u00e1rios da mesma (sejam estes pessoas, m\u00e1quinas ou outros \n\nsistemas). \n\n? Presenter: seria a camada respons\u00e1vel por intermediar as \n\na\u00e7\u00f5es e informa\u00e7\u00f5es repassadas entre o as duas camadas anteriores, \n\nexecutando, por exemplo, tratamento dos dados para possibilitar a \n\nvisualiza\u00e7\u00e3o (alterando o tipo do dado, sem alterar a informa\u00e7\u00e3o \n\nvinculada nele) e vice-versa. \n\nFowler (2009) prop\u00f4s a divis\u00e3o do padr\u00e3o em duas arquiteturas \n\nposs\u00edveis: \u201cSupervising Controller\u201d (\u201cControle Supervisionado\u201d, em \n\ntradu\u00e7\u00e3o livre) e \u201cPassive View\u201d (\u201cVis\u00e3o Passiva\u201d, em tradu\u00e7\u00e3o livre). \n\nNesse trabalho foi adotada a estrutura \u201cPassive View\u201d, explicada a \n\nseguir. \n\nNessa estrutura a camada \u201cView\u201d possui apenas o \n\ncomportamento inerente aos seus componentes, n\u00e3o possuindo \n\nnenhum comportamento referente \u00e0s regras de neg\u00f3cio da aplica\u00e7\u00e3o. \n\nExemplificando: no caso de uma interface gr\u00e1fica, o View apresentar\u00e1 \n\napenas os componentes e campos para visualiza\u00e7\u00e3o e os tratamentos \n\ne comportamentos inerentes a estes (como monitores para eventos de \n\nbot\u00f5es e outros campos, por exemplo). A proposta do Passive View \n\n\n\n  \n\ncom isso \u00e9 separar bem os comportamentos permitindo que os testes \n\ndas regras de neg\u00f3cio possam ser feitos independentes da camada \n\nvisual (eliminando assim a possibilidade um erro proveniente de um \n\ncomponente visual ser refletido em um teste das regras de neg\u00f3cio). \n\nOutra vantagem apresentada nessa estrutura \u00e9 separar \n\ntecnologicamente as camadas de visualiza\u00e7\u00e3o e neg\u00f3cio, permitindo \n\numa troca da camada de vis\u00e3o sem grandes altera\u00e7\u00f5es (ou at\u00e9 \n\nnenhuma) na camada de neg\u00f3cios. \n\nNo Passive View todo o comportamento que antes ficaria no \n\nelemento (ou classe) de visualiza\u00e7\u00e3o \u2014 como recuperar um dado \n\nespec\u00edfico de uma base de dados e atribu\u00ed-lo a um campo visual, por \n\nexemplo \u2014 passa a um novo elemento chamado \u201cController\u201d (ou \n\n\u201cPresenter\u201d). O Controller \u00e9 que se torna respons\u00e1vel por recuperar os \n\ndados necess\u00e1rios e repass\u00e1-los \u00e0 camada visual, bem como \n\nrecuperar os dados da camada visual e trat\u00e1-los conforme o \n\nnecess\u00e1rio. Para manter o desacoplamento do View o Controller \n\nacessa o mesmo atrav\u00e9s de interfaces, que o View por sua vez deve \n\nimplementar. J\u00e1 o View possui acesso direto ao Controller, afim de n\u00e3o \n\ncomplicar muito a implementa\u00e7\u00e3o atrav\u00e9s da estrutura. Na Figura 12 \n\nsegue uma visualiza\u00e7\u00e3o do padr\u00e3o MVP e da estrutura Passive View. \n\n \nFigura 12 \u2013 Representa\u00e7\u00e3o do padr\u00e3o de projeto MVP na estrutura Passive View \n\nFonte: Fowler (2009). \n\n \n\n\n\n  \n\nNesse trabalho, al\u00e9m da camada visual, a camada de \n\npersist\u00eancia dos dados tamb\u00e9m foi abstra\u00edda sobre o conceito do \n\n\u201cMVP \u2013 Passive View\u201d, sendo que a comunica\u00e7\u00e3o entre a aplica\u00e7\u00e3o e \n\nos m\u00f3dulos de persist\u00eancia \u00e9 feita atrav\u00e9s de interfaces, como poder\u00e1 \n\nser visto na sess\u00e3o seguinte. \n\n \n\n4.2) Especifica\u00e7\u00e3o da Aplica\u00e7\u00e3o \n\nA partir da elabora\u00e7\u00e3o de um diagrama de casos de uso (Figura \n\n13) foi poss\u00edvel levantar os requisitos necess\u00e1rios para o \n\ndesenvolvimento da aplica\u00e7\u00e3o. O diagrama teve como ponto de partida \n\no processo descrito na etapa de especifica\u00e7\u00e3o da metodologia NeOn \n\n(ver sess\u00e3o 2.2.3). \n\n \nFigura 13 \u2013 Diagrama de casos de uso da aplica\u00e7\u00e3o \n\n \n\nApenas um tipo usu\u00e1rio foi identificado para uso da aplica\u00e7\u00e3o, \n\nsendo este usu\u00e1rio denominado no diagrama como \u201cusu\u00e1rio \n\n\n\n  \n\ndesenvolvedor\u201d. A etapa de especifica\u00e7\u00e3o de uma ontologia conta \n\nnormalmente com a intera\u00e7\u00e3o de v\u00e1rias pessoas, geralmente \n\nespecialistas do dom\u00ednio abordado, e desenvolvedores de ontologias, \n\nmas para desenvolvimento da aplica\u00e7\u00e3o aqui proposta basta a \n\nabstra\u00e7\u00e3o de um usu\u00e1rio, podendo este ser qualquer membro da \n\nequipe de especifica\u00e7\u00e3o. \n\nA partir da defini\u00e7\u00e3o do usu\u00e1rio e pr\u00f3ximo passo foi definir \n\nmacro processo envolvidos. Tr\u00eas foram observados: \n\n? Criar o Projeto: nesse processo s\u00e3o informados os requisitos \n\ngerais da especifica\u00e7\u00e3o \u2014 o nome do projeto de especifica\u00e7\u00e3o (nome \n\nda ontologia), autores, prop\u00f3sito da ontologia, escopo, n\u00edvel de \n\nformalismo, usu\u00e1rios desejados e cen\u00e1rios de uso da ontologia. Ao \n\nabstrair esse processo tamb\u00e9m foi definida a forma de persist\u00eancia \n\ndos dados armazenados, que seria feita em um arquivo XML, melhor \n\ndetalhado posteriormente na sess\u00e3o 4.3. Ao criar o projeto j\u00e1 \u00e9 gerada \n\numa vers\u00e3o inicial do arquivo XML, guardando os requisitos gerais \n\ncadastrados. \n\n? Cria\u00e7\u00e3o de categorias e perguntas de compet\u00eancia: \u00e9 o \n\nprocesso onde s\u00e3o criadas as perguntas de compet\u00eancia e as \n\ncategorias que as armazenam. Por padr\u00e3o, ao criar o projeto j\u00e1 \u00e9 \n\ncriada uma categoria intitulada \u201cdefault\u201d (o nome pode ser alterado) \n\npara receber as perguntas. Mais categorias podem ser criadas \n\nconforme a necessidade. As perguntas podem ter uma senten\u00e7a \n\n(sendo esta apenas a pergunta em si) ou ent\u00e3o duas senten\u00e7as (a \n\npergunta e a sua resposta). Cada pergunta pode ser classificada a \n\napenas uma categoria, podendo haver mudan\u00e7a posterior \u00e0 \n\nclassifica\u00e7\u00e3o inicial. \n\n? Identifica\u00e7\u00e3o dos termos das perguntas de compet\u00eancia: \n\neste processo \u00e9 mais automatizado pela pr\u00f3pria aplica\u00e7\u00e3o. Nele \u00e9 \n\nrealizada a extra\u00e7\u00e3o autom\u00e1tica dos termos das perguntas de \n\n\n\n  \n\ncompet\u00eancia (tanto das perguntas em si quanto das respostas quando \n\nestas existirem). A extra\u00e7\u00e3o \u00e9 feita a partir de todo o conjunto de \n\nperguntas ou do conjunto de perguntas de uma categoria espec\u00edfica. O \n\nconjunto dos termos encontrados s\u00e3o exibidos ao usu\u00e1rio \n\ndesenvolvedor para que este possa selecionar quais termos s\u00e3o \n\nrelevantes para o projeto. H\u00e1 a possibilidade tamb\u00e9m de realizar a \n\ncombina\u00e7\u00e3o entre termos durante a sele\u00e7\u00e3o, a fim de criar um termo \n\ncomposto que a extra\u00e7\u00e3o autom\u00e1tica n\u00e3o capturou nas senten\u00e7as. \n\n \n\nCom o t\u00e9rmino da elabora\u00e7\u00e3o do diagrama de casos de uso o \n\npr\u00f3ximo passo foi a elabora\u00e7\u00e3o das classes da aplica\u00e7\u00e3o. \n\nEstruturalmente a aplica\u00e7\u00e3o segue o padr\u00e3o de projeto MVP, descrito \n\nanteriormente, permitindo distinguir claramente as classes \n\nrespons\u00e1veis pela parte de visualiza\u00e7\u00e3o (View), apresenta\u00e7\u00e3o \n\n(Presenter) e modelagem do neg\u00f3cio (Model). Na Figura 14 est\u00e1 \n\nrepresentada, sem detalhamento das classes, essa divis\u00e3o. \n\n\n\n  \n\n \nFigura 14 \u2013 Estrutura de classes da aplica\u00e7\u00e3o com o padr\u00e3o MVP \n\n \n\n\n\n  \n\nNa parte de modelagem do neg\u00f3cio houve mais uma divis\u00e3o \n\nestrutural, tamb\u00e9m seguindo a linha de desenvolvimento do MVP. Esta \n\nsubestrutura \u00e9 composta por: \n\n? Classe \u201cAmbiente\u201d (Environment): controla a inicializa\u00e7\u00e3o \n\nda aplica\u00e7\u00e3o e cria\u00e7\u00e3o dos seus objetos de controle. \n\n? Pacote de classes de dados (Data Package): respons\u00e1vel \n\npela manipula\u00e7\u00e3o, em tempo de desenvolvimento, dos dados \n\nenvolvidos no processo de especifica\u00e7\u00e3o (dados de prop\u00f3sito, escopo, \n\ndados das perguntas de compet\u00eancia, dos termos, etc.). \n\n? Classe de controle de sa\u00edda (OutputController): \u00e9 a \n\nrespons\u00e1vel direta pela comunica\u00e7\u00e3o com as classes respons\u00e1veis por \n\ngerarem o documento OSRD e pela persist\u00eancia do XML. \n\n? Classe de controle da extra\u00e7\u00e3o dos termos \n\n(ExtractController): realiza a extra\u00e7\u00e3o dos termos a partir das \n\nperguntas de compet\u00eancia selecionadas (todas ou de uma categoria \n\nespec\u00edfica). \n\nNa Figura 15 \u00e9 poss\u00edvel visualizar a subestrutura ainda a pouco \n\ndescrita. Na sess\u00e3o 4.4 haver\u00e1 um maior detalhamento dessas \n\nclasses mencionadas. \n\n\n\n  \n\n \nFigura 15 \u2013 Subestrutura da aplica\u00e7\u00e3o sobre a parte de modelagem das regras de \n\nneg\u00f3cio da etapa de especifica\u00e7\u00e3o. \n\n \n\n4.3) O XML para persist\u00eancia \n\nPara a persist\u00eancia dos dados levantados pela aplica\u00e7\u00e3o, no \n\nprocesso de especifica\u00e7\u00e3o de ontologia, optou-se pelo uso do XML. \n\nPoderia ter sido utilizado a persist\u00eancia em um banco de dados ou em \n\n\n\n  \n\noutro tipo de reposit\u00f3rio de dados, mas o uso do XML permite \u00e0 \n\naplica\u00e7\u00e3o uma maior comunica\u00e7\u00e3o com outros tipos de sistemas, \n\nferramentas ou aplica\u00e7\u00f5es. \n\nPara uma aplica\u00e7\u00e3o externa interpretar o XML de persist\u00eancia \n\nbasta que ela conhe\u00e7a a estrutura do mesmo e possa fazer leitura de \n\narquivos do tipo XML. Esse procedimento \u00e9 bem mais simples do que \n\nexigir que uma aplica\u00e7\u00e3o externa conhe\u00e7a, por exemplo, o mesmo \n\nbanco de dados que a aplica\u00e7\u00e3o de especifica\u00e7\u00e3o. \n\nA estrutura do XML segue uma abstra\u00e7\u00e3o dos itens presentes \n\nno documento OSRD proposto na etapa de especifica\u00e7\u00e3o do NeOn. \n\nNa Figura 16 est\u00e1 representado essa estrutura do arquivo XML. \n\n \nFigura 16 \u2013 Estrutura do arquivo XML de persist\u00eancia \n\n\n\n  \n\n \n\nAnalisando a Figura 16 podemos descrever a estrutura \u2014 \n\nimportante observar a sess\u00e3o 3.1 para melhor entendimento \u2014 sendo \n\nela composta pelos seguintes elementos: \n\n?&lt;project>: \u00e9 o elemento raiz do XML. Representa o conceito \n\nde especifica\u00e7\u00e3o de ontologia (ou projeto) como um todo. O XML \n\npoderia, dessa forma, conter v\u00e1rias especifica\u00e7\u00f5es de ontologias \n\n(v\u00e1rios projetos), cada um com seus elementos espec\u00edficos. \n\n?&lt;name>: representa o nome do projeto, sendo tamb\u00e9m o \n\nidentificador \u00fanico do mesmo. O nome tamb\u00e9m \u00e9 usado para \n\nidentificar o arquivo XML em si. \n\n?&lt;autor>: representa o(s) nome(s) do(s) autor(es) do projeto \n\nde ontologia. \n\n?&lt;createDate>: indica a data em que foi criado o projeto de \n\nontologia. \n\n?&lt;purpose>: representa o item \u201cprop\u00f3sito\u201d do documento \n\nOSRD do NeOn. \n\n?&lt;scope>: representa o item \u201cescopo\u201d do documento OSRD do \n\nNeOn. \n\n?&lt;formalityLevel>: representa o item \u201cn\u00edvel de formalismo\u201d do \n\ndocumento OSRD do NeOn. \n\n?&lt;users>: indica o subn\u00edvel que descreve os \u201cusu\u00e1rios \n\ndesejados\u201d, como no documento OSRD. Este subn\u00edvel pode possuir \n\num ou mais elementos como o descrito a seguir: \n\n?&lt;userDescription>: indica a descri\u00e7\u00e3o de um usu\u00e1rio em \n\nespec\u00edfico. \n\n?&lt;usesScenarios>: trata-se de mais um subn\u00edvel, este \n\nindicando o item \u201cusos (cen\u00e1rios) desejados\u201d do documento OSRD. \n\n\n\n  \n\nTamb\u00e9m pode possuir um ou mais elementos internos como o descrito \n\na seguir: \n\n?&lt;scenario>: indica a descri\u00e7\u00e3o de um cen\u00e1rio de uso em \n\nespec\u00edfico. \n\n?&lt;category>: subn\u00edvel que indica uma categoria de perguntas \n\nde compet\u00eancia. Por default h\u00e1 no m\u00ednimo uma categoria para \n\nenglobar as perguntas de compet\u00eancia. O elemento possui como \n\natributo o nome da categoria. \n\nO elemento \u201ccategory\u201d possui a seguinte hierarquia de \n\nelementos: \n\n?&lt;competenceQuestion>: indica a pergunta de compet\u00eancia \n\ncomo um todo. Como atributo possui um c\u00f3digo identificador \u2014 sendo \n\neste incremental para todo o projeto \u2014 que ser\u00e1 usado para \n\nreferenciar os termos mais adiante. Possui duas divis\u00f5es internas, \n\nsendo elas: \n\n?&lt;question>: este elemento \u00e9 obrigat\u00f3rio na pergunta de \n\ncompet\u00eancia, indica a pergunta que deve ser respondida ao fim do \n\ndesenvolvimento da ontologia. \n\n?&lt;answer>: \u00e9 a resposta que deve ser data \u00e0 pergunta de \n\ncompet\u00eancia, sendo este elemento n\u00e3o obrigat\u00f3rio. \n\nAp\u00f3s os subn\u00edveis \u201ccategory\u201d encontra-se o \u00faltimo subn\u00edvel do \n\nXML: \n\n?&lt;selectedTerms>: neste subn\u00edvel est\u00e3o indicados todos os \n\ntermos selecionados a partir das perguntas de compet\u00eancia. A \n\nestrutura deste subn\u00edvel \u00e9: \n\n?&lt;term>: trata-se de um termo selecionado em espec\u00edfico. \n\nPossui como conte\u00fado o nome (ou descri\u00e7\u00e3o) do termo. Seus atributos \n\nindicam as perguntas de compet\u00eancia onde o termo aparece (al\u00e9m de \n\n\n\n  \n\nindicarem de qual elemento dessa pergunta ele veio: \u201cquestion\u201d ou \n\n\u201canswer\u201d). A quantidade de perguntas de origem vai indicar a \n\nfreq\u00fc\u00eancia de ocorr\u00eancia do termo. A ordem com a qual os termos \n\naparecem pode ser definida pela freq\u00fc\u00eancia, ou ent\u00e3o atrav\u00e9s de uma \n\nordem pr\u00e9-estabelecida \u00e0 cria\u00e7\u00e3o do XML. \n\nPara gravar o arquivo a aplica\u00e7\u00e3o utilizar\u00e1 o processo de \n\nserializa\u00e7\u00e3o de objetos existente na pr\u00f3pria linguagem de \n\nprograma\u00e7\u00e3o. Ser\u00e1 constru\u00eddo um objeto, com uma estrutura interna \n\ncomo a descrita para o XML nessa sess\u00e3o, e que ser\u00e1 preenchido com \n\nas informa\u00e7\u00f5es pertinentes, para ent\u00e3o ser gravado em um local \n\ndefinido pelo usu\u00e1rio da aplica\u00e7\u00e3o. \n\n \n\n4.4) Detalhamento da Estrutura da Aplica\u00e7\u00e3o \n\nAp\u00f3s a defini\u00e7\u00e3o dos casos de uso da aplica\u00e7\u00e3o, da estrutura de \n\nclasses da mesma e da estrutura do XML de persist\u00eancia dos dados \n\nfoi dado in\u00edcio \u00e0 parte de codifica\u00e7\u00e3o. \n\nComo linguagem de programa\u00e7\u00e3o foi escolhida a linguagem \n\nJava, n\u00e3o apenas por ser uma das linguagens orientadas a objeto \n\nmais usadas atualmente, mas tamb\u00e9m com o foco em trabalhos \n\nfuturos, devido \u00e0 portabilidade do Java, e da exist\u00eancia de outras \n\nferramentas de desenvolvimento de ontologias tamb\u00e9m elaboradas \n\ncom esta linguagem, possibilitando assim uma integra\u00e7\u00e3o mais \n\nsimples. Como op\u00e7\u00e3o de ferramenta de programa\u00e7\u00e3o veio o Eclipse \n\nSDK, pela j\u00e1 maior familiaridade de uso. \n\nTodas as partes \u2014 de visualiza\u00e7\u00e3o (interfaces gr\u00e1ficas), de \n\npersist\u00eancia e sa\u00edda de dados (persist\u00eancia do XML e gera\u00e7\u00e3o do \n\ndocumento OSRD), de extra\u00e7\u00e3o dos termos e, da parte principal, de \n\nmodelagem de regras de neg\u00f3cio da etapa de especifica\u00e7\u00e3o (em \n\nresumo, a estrutura de classes vista na Figura 14) \u2014 foram tratadas \n\n\n\n  \n\ncomo projetos separados. Como a parte principal realiza sua \n\ncomunica\u00e7\u00e3o atrav\u00e9s de interfaces, esta n\u00e3o necessita conhecer \n\ndiretamente as outras partes, podendo as mesmas ser desenvolvidas \n\nsob outra tecnologia (em uma linguagem diferente, por exemplo, \n\nbastando que esta \u00faltima possa implementar as interfaces definidas). \n\nPara facilitar o desenvolvimento, todas as outras partes \n\nvinculadas \u00e0 principal tamb\u00e9m foram desenvolvidas na linguagem \n\nJava, inclusive a parte visual, onde foi usado o pacote de classes \n\nvisual \u201cswing\u201d do Java, que j\u00e1 tr\u00e1s componentes visuais prontos, \n\nhavendo apenas a necessidade de montar a tela e realizar a intera\u00e7\u00e3o \n\nentre sistema e componentes. \n\nComo a parte de persist\u00eancia dos dados j\u00e1 mencionada ao final \n\nda sess\u00e3o 4.3, ap\u00f3s o detalhamento do XML de persist\u00eancia, \n\npassamos ent\u00e3o ao detalhamento da parte principal, de modelagem de \n\nregras de neg\u00f3cio da etapa de especifica\u00e7\u00e3o. \n\nCinco classes formam o grupo principal de controle da \n\naplica\u00e7\u00e3o: \n\n? Environment: \u00c9 a classe que gerencia os outros controllers \n\nda aplica\u00e7\u00e3o e \u00e9 por esta classe que se d\u00e1 o in\u00edcio do funcionamento \n\nda parte principal da aplica\u00e7\u00e3o. \u00c9 ela que instancia os outros \n\ncontroladores e que permite a comunica\u00e7\u00e3o entre os mesmos. \n\n? DataController: na aplica\u00e7\u00e3o a um pacote denominado \u201cData\u201d \n\n(que ser\u00e1 descrito posteriormente, na sess\u00e3o 4.4.1) o DataController \u00e9 \n\na sua classe de ger\u00eancia. Esta classe realiza todas as transa\u00e7\u00f5es e \n\ncomunica\u00e7\u00f5es entre as classes do pacote Data e o resto do sistema. \n\n? ViewController: Como o pr\u00f3prio nome j\u00e1 sugere \u00e9 a classe \n\nque gerencia os presenters das telas do sistema. Ela realiza os \n\ntratamentos necess\u00e1rios para visualiza\u00e7\u00e3o dos dados advindos do \n\n\n\n  \n\npacote Data, os direcionando tamb\u00e9m para os respectivos presenters, \n\ne vice-versa.  \n\n? OutputController: \u00c9 o controlador de sa\u00edda do sistema. \n\nComunica-se com as classes respons\u00e1veis pela persist\u00eancia do XML \n\nde dados e pela gera\u00e7\u00e3o do documento OSRD. Ao contr\u00e1rio do \n\nDataController e do ViewController, que possuem a mesmo ciclo de \n\nvida do Environment, este s\u00f3 \u00e9 instanciado quando h\u00e1 a necessidade \n\nde persist\u00eancia ou gera\u00e7\u00e3o do documento. \n\n? ExtractController: \u00c9 um controlador que possui um ciclo de \n\nvida bem reduzido, existindo apenas quando \u00e9 solicitada a extra\u00e7\u00e3o \n\nautom\u00e1tica dos termos, ficando ele respons\u00e1vel pela extra\u00e7\u00e3o dos \n\ntermos nas perguntas de compet\u00eancia requeridas. \n\n \n\n4.4.1) O Pacote \u201cData\u201d \n\nPara a aplica\u00e7\u00e3o havia a necessidade de fazer uma abstra\u00e7\u00e3o \n\ndos requisitos observados no documento OSRD do NeOn, algo que \n\npudesse permanecer \u201cem mem\u00f3ria\u201d, evitando assim constantes \n\nleituras de arquivos em disco, atividade esta bastante lenta. Assim foi \n\nconcebido o pacote de classes \u201cData\u201d (nome advindo de \u201cDados\u201d, em \n\ningl\u00eas). \n\nEste pacote \u00e9 formado pelo controlador j\u00e1 descrito \n\nDataController e por mais quatro classes, destinadas ao \n\narmazenamento de dados. As classes de dados nada mais s\u00e3o do que \n\nrepresenta\u00e7\u00f5es em c\u00f3digo dos elementos do XML de persist\u00eancia. A \n\nseguir uma descri\u00e7\u00e3o dessas classes de dados: \n\n? Project: Esta classe de dados, ao contr\u00e1rio das demais, \n\nrepresenta o n\u00f3 raiz da estrutura do XML de persist\u00eancia e, portanto, \n\nengloba todo o conjunto de elementos hierarquicamente inferiores a \n\neste n\u00f3 raiz (ou seja, todos os outros elementos descritos no XML). \n\n\n\n  \n\nCaso a aplica\u00e7\u00e3o suportasse mais de um projeto por manipula\u00e7\u00e3o, \n\nexistiriam duas inst\u00e2ncias ativas da classe Project no sistema por vez. \n\nDos elementos que s\u00e3o subn\u00edveis no XML (users, usesScenarios, \n\ncategory, e selectedTerms) apenas users e usesScenarios est\u00e3o \n\ntotalmente inseridos na classe (na forma de listagens de literais ou \n\n\u201cstrings\u201d), nos outros apenas as refer\u00eancias aos objetos s\u00e3o \n\narmazenadas, pois a classes espec\u00edficas para esses elementos. \n\n? Category: Esta classe representa cada subn\u00edvel de categoria \n\nde perguntas de compet\u00eancia que existir na especifica\u00e7\u00e3o. Possui, \n\nal\u00e9m do seu nome, os c\u00f3digos identificadores das perguntas de \n\ncompet\u00eancia (no caso, os c\u00f3digos dos objetos da classe \n\nCompetenceQuestion), que lhe pertencem. \n\n? CompetenceQuestion: Representa as perguntas de \n\ncompet\u00eancia. A refer\u00eancia a seus objetos quem armazena \u00e9 a \n\ninst\u00e2ncia de Project, pois as perguntas est\u00e3o ligadas diretamente ao \n\nprojeto, sendo as categorias apenas para classifica\u00e7\u00e3o. Possui um \n\nc\u00f3digo identificador, \u00fanico no projeto, e duas classes internas, \n\nQuestion e Answer: \n\n? Question: classe interna de CompetenceQuestion que \n\nrepresenta a senten\u00e7a correspondente \u00e0 pergunta. \u00c9 obrigat\u00f3ria sua \n\nexist\u00eancia nas perguntas de compet\u00eancia. Possui tamb\u00e9m uma \n\nlistagem dos c\u00f3digos dos termos extra\u00eddos de sua senten\u00e7a. \n\n? Answer: classe interna de CompetenceQuestion que \n\nrepresenta a senten\u00e7a correspondente \u00e0 resposta da pergunta. N\u00e3o h\u00e1 \n\nobrigatoriedade de sua exist\u00eancia nas perguntas de compet\u00eancia. \n\nPossui, igualmente a Question, uma listagem dos c\u00f3digos dos termos \n\nextra\u00eddos de sua senten\u00e7a. \n\n? Terms: Esta classe representa os termos que foram \n\nselecionados na extra\u00e7\u00e3o autom\u00e1tica. Possui como atributos o nome \n\n\n\n  \n\n(ou descri\u00e7\u00e3o) do termo, os c\u00f3digos das \u201cQuestion\u2019s\u201d de origem, bem \n\ncomo das \u201cAnswer\u2019s\u201d, a freq\u00fc\u00eancia de ocorr\u00eancia no projeto (que \u00e9 \n\ncalculado de acordo com a quantidade de senten\u00e7as de origem \n\nexistentes na pr\u00f3pria classe) e um indicar de ordem, pois o \u201cusu\u00e1rio \n\ndesenvolvedor\u201d pode escolher uma ordem distinta \u00e0 ordem padr\u00e3o, \n\nque \u00e9 pela freq\u00fc\u00eancia. \n\nEsse pacote Data pode ser visualizado na Figura 15, \n\nanteriormente apresentada na sess\u00e3o 4.2. \n\n \n\n4.4.2) O Pacote \u201cBeans\u201d \n\nCom a separa\u00e7\u00e3o das camadas de visualiza\u00e7\u00e3o e de \n\narmazenamento e tratamento dos dados, houve a necessidade de \n\numa forma de transportar as informa\u00e7\u00f5es necess\u00e1rias entre as duas \n\ncamadas que atendesse a todas as necessidades de dados e que \n\nfosse simples; assim foi implementado o pacote \u201cBeans\u201d. \n\nNesse pacote est\u00e3o contidas classes que representam os dados \n\nrequeridos por cada m\u00f3dulo de visualiza\u00e7\u00e3o de informa\u00e7\u00f5es da \n\naplica\u00e7\u00e3o: Projeto (\u201cProjectBean\u201d), Perguntas de Compet\u00eancia \n\n(\u201cCompetenceQuestionsBean\u201d), que tamb\u00e9m engloba as categorias de \n\nperguntas de compet\u00eancia, e Termos (\u201cTermsBean\u201d). Na Figura 17 \u00e9 \n\nposs\u00edvel visualizar o pacote e suas classes. \n\n\n\n  \n\n \nFigura 17 \u2014 Pacote \u201cBeans\u201d e suas classes para comunica\u00e7\u00e3o entre as camadas. \n\n \n\nOs bean possuem atributos que representam os dados que \n\nser\u00e3o necess\u00e1rios aos presenters de cada m\u00f3dulo para exibir as \n\ninforma\u00e7\u00f5es solicitadas. Estes beans \u201ctrafegam\u201d \u2014 s\u00e3o repassados de \n\nm\u00e9todo em m\u00e9todo entre as camadas \u2014 sempre que uma grande \n\nquantidade de informa\u00e7\u00f5es \u00e9 solicitada. Como exemplo, pode ser \n\ncitado a solicita\u00e7\u00e3o da listagem de perguntas de uma determinada \n\ncategoria de perguntas de compet\u00eancia. \n\nTratamento de opera\u00e7\u00f5es mais simples, como a adi\u00e7\u00e3o de uma \n\npergunta de categoria, por exemplo, s\u00e3o tratadas aparte dos beans, \n\nsendo a informa\u00e7\u00e3o repassada diretamente atrav\u00e9s de m\u00e9todo entre \n\nas camadas. \n\nOs beans normalmente s\u00e3o instanciados no DataController, \n\nonde recebem a carga inicial de dados, mas podem ser gerados em \n\nqualquer parte dos sistema, pois sempre recebem solicita\u00e7\u00f5es e nunca \n\ninvocam informa\u00e7\u00f5es a outras classes externas, servindo assim como \n\nestruturas auxiliares independentes. Em analogia, seriam como \n\nve\u00edculos de transporte que carregam materiais de um local a outro. \n\n\n\n  \n\nEstas classes n\u00e3o possuem m\u00e9todos de tratamento das regras \n\nde neg\u00f3cio, apenas tratamentos relacionados aos dados que lhes \n\npertencem, como por exemplo, o fornecimento dos termos ordenados \n\nde acordo com um padr\u00e3o (alfab\u00e9tico, freq\u00fc\u00eancia, etc.) no caso do \n\nTermsBean. \n\n \n\n4.4.3) A classe \u201cExtractController\u201d e a extra\u00e7\u00e3o de \n\ntermos \n\nComo j\u00e1 mencionado anteriormente, dentre as quatro classes \n\ncontroladoras do sistema duas possuem um tempo de vida reduzido, \n\npois realizam atividades espec\u00edficas e isoladas; a classe \n\nExtractController \u00e9 uma delas. \n\nEsta classe \u00e9 a respons\u00e1vel por receber as senten\u00e7as das \n\nperguntas de compet\u00eancia (tanto as perguntas em si quanto as \n\nrespostas das mesmas) e realizar a extra\u00e7\u00e3o autom\u00e1tica dos termos.  \n\nSua instancia\u00e7\u00e3o e sempre executada pela classe Environment \n\n(bem como os demais controladores) sendo esta instancia\u00e7\u00e3o \n\nrequerida pelo DataController que repassa o conjunto de perguntas de \n\ncompet\u00eancia da categoria solicitada pelo m\u00f3dulo de Termos. Ap\u00f3s \n\nreceber as senten\u00e7as o ExtractController trabalha executando a \n\nseguinte seq\u00fc\u00eancia de atividades sobre cada uma: \n\n? Inicialmente \u00e9 feita a \u201climpeza\u201d da senten\u00e7a: s\u00e3o removidos os \n\nsinais de pontua\u00e7\u00e3o e caracteres especiais existentes. Para isto \u00e9 \n\nempregado uma express\u00e3o regular, atrav\u00e9s da pr\u00f3pria classe String da \n\nlinguagem Java, que identifica os caracteres de pontua\u00e7\u00e3o e os \n\nremove; \n\n? Com a \u201csenten\u00e7a limpa\u201d \u00e9 feita a \u201ctokeniza\u00e7\u00e3o\u201d da mesma. \n\nNessa atividade atrav\u00e9s da classe StringTokenizer, tamb\u00e9m nativa da \n\nlinguagem Java, a senten\u00e7a \u00e9 separada em tokens (s\u00edmbolos) que \n\n\n\n  \n\nnesse caso seriam os termos presentes na senten\u00e7a. A separa\u00e7\u00e3o \u00e9 \n\nfeita tomando por refer\u00eancia os espa\u00e7os em branco da senten\u00e7a, por \n\nisso a import\u00e2ncia de permitir a combina\u00e7\u00e3o de termos extra\u00eddos, para \n\ngerar termos compostos; \n\n? Atrav\u00e9s do StringTokenizer \u00e9 poss\u00edvel realizar a itera\u00e7\u00e3o \n\nsobre os termos separados da senten\u00e7a, sendo assim poss\u00edvel a \n\nan\u00e1lise em separado de cada token. Para cada uma \u00e9 feita a \n\nverifica\u00e7\u00e3o se n\u00e3o se trata de uma stop word \u2014 palavras que isoladas \n\nn\u00e3o trazem nenhuma informa\u00e7\u00e3o importante, sendo normalmente \n\npreposi\u00e7\u00f5es e artigos, como \u201co\u201d, \u201ca\u201d, \u201cpara\u201d, \u201cde\u201d, \u201cem\u201d, etc. Se for uma \n\nstop word o termo \u00e9 descartado. \n\n? Por \u00faltimo, se o termo n\u00e3o foi descartado, este recebe a \n\nrefer\u00eancia de qual pergunta de compet\u00eancia (distinguindo entre \n\npergunta ou resposta) o mesmo foi extra\u00eddo, para posterior \n\npersist\u00eancia do termo caso este venha a ser escolhido como relevante \n\npara a especifica\u00e7\u00e3o, isto j\u00e1 no m\u00f3dulo de Termos. \n\nAtrav\u00e9s do TermsBean os termos extra\u00eddos s\u00e3o repassados de \n\nvolta ao DataController que os retorna ao m\u00f3dulo de Termos para \n\nutiliza\u00e7\u00e3o do usu\u00e1rio da aplica\u00e7\u00e3o. \n\n \n\n4.4.4) O Pacote \u201cView\u201d \n\nAs classes que efetivamente implementam as interfaces \n\ngr\u00e1ficas n\u00e3o fazem parte da aplica\u00e7\u00e3o proposta, pois a mesma, como \n\nj\u00e1 explicado anteriormente, prop\u00f5em-se a ser independente de \n\ncamada de visualiza\u00e7\u00e3o \u2014 permitindo a implementa\u00e7\u00e3o de interfaces \n\ngr\u00e1ficas distintas tecnologias que utilizam todas a mesma aplica\u00e7\u00e3o \n\ncomo base.  \n\nMas para permitir essa independ\u00eancia visual \u00e9 necess\u00e1rio um \n\nconjunto de classes que realiza a comunica\u00e7\u00e3o entre o projeto visual e \n\n\n\n  \n\na aplica\u00e7\u00e3o em si, um conjunto de classes que represente os m\u00f3dulos \n\nque se requisita encontrar no projeto visual; \u00e9 neste ponto que entra o \n\npacote \u201cView\u201d. Na Figura 18 \u00e9 poss\u00edvel visualizar a estrutura do \n\npacote. \n\n \nFigura 18 \u2014 O pacote \u201cView\u201d e as classes de representa\u00e7\u00e3o e manipula\u00e7\u00e3o dos \n\nm\u00f3dulos da aplica\u00e7\u00e3o. \n\n \n\nObservando a Figura 18 vamos \u00e0 descri\u00e7\u00e3o da estrutura do \n\npacote. Os m\u00f3dulos da aplica\u00e7\u00e3o sempre trabalham em uma dupla de \n\nelementos: a interface que descreve o servi\u00e7o oferecido pelo m\u00f3dulo \n\n\u2014 trata-se dos elementos do diagrama que possuem o estere\u00f3tipo \n\n\u201c\u00abinterface\u00bb\u201d e o identificador \u201cForm\u201d ao final do nome \u2014 e as classes \n\nque s\u00e3o respons\u00e1veis por receber as informa\u00e7\u00f5es e requisi\u00e7\u00f5es da \n\ntela e repassarem ao sistema (e vice-versa), os chamados \n\n\u201cpresenters\u201d da estrutura MVP \u2014 est\u00e3o identificados no diagrama pelo \n\nsufixo \u201cPresenter\u201d no nome. O m\u00f3dulo Main consiste, na pr\u00e1tica, no \n\nambiente visual da aplica\u00e7\u00e3o, onde est\u00e3o inseridos os demais \n\nm\u00f3dulos, sendo a altera\u00e7\u00e3o entre um m\u00f3dulo e outro realizada atrav\u00e9s \n\ndele. \n\nA classe ViewController \u00e9 o controlador principal da camada \n\nvisual. \u00c9 atrav\u00e9s dele efetivamente que a camada visual se comunica \n\n\n\n  \n\ncom o resto do sistema fazendo, por exemplo, a requisi\u00e7\u00e3o de \n\ninforma\u00e7\u00f5es das classes de dados da aplica\u00e7\u00e3o. Quando h\u00e1 a \n\nnecessidade de comunica\u00e7\u00e3o entre os m\u00f3dulos a mesma tamb\u00e9m \u00e9 \n\nfeita pelo ViewController, sendo ele assim um coordenador dos \n\nm\u00f3dulos. \n\nAs classes presenters s\u00e3o respons\u00e1veis por realizar os \n\ntratamentos pertinentes \u00e0 execu\u00e7\u00e3o e resposta de a\u00e7\u00f5es vindas da \n\ncamada visual. Um exemplo seria a adi\u00e7\u00e3o de uma nova pergunta de \n\ncompet\u00eancia: cabe ao presenter validar as informa\u00e7\u00f5es recebidas da \n\ncamada visual e informar caso algum item esteja incorreto \u2014 a falta de \n\num item obrigat\u00f3rio, por exemplo. Tratamentos de formas de \n\nvisualiza\u00e7\u00e3o de dados s\u00e3o pertinentes \u00e0 camada visual e n\u00e3o aos \n\npresenters \u2014 por exemplo, o tratamento de passar um valor num\u00e9rico \n\npara um literal, pois o componente da interface gr\u00e1fica apenas trabalha \n\ncom valores literais. \n\nAs interfaces Form possuem a descri\u00e7\u00e3o dos m\u00e9todos m\u00ednimos \n\na serem implementados na camada visual, para cada m\u00f3dulo, para \n\nque os presenters possam realizar a intera\u00e7\u00e3o com esta camada. \n\nTamb\u00e9m possuem atributos que necessitam ser de conhecimento \n\ntanto da camada visual quanto dos presenters, como constantes de \n\ntipos de erros de valida\u00e7\u00e3o, por exemplo. \n\n \n\n4.5) Resultados apresentados \n\nNa sess\u00e3o 4.4 anteriormente apresentada foi apresentada a \n\nestrutura interna da aplica\u00e7\u00e3o e como a mesma se prop\u00f5e a funcionar. \n\nContudo, para entendimento completo da aplica\u00e7\u00e3o e das atividades \n\npara a qual a mesma foi proposta, havia a necessidade de que fosse \n\ndesenvolvida uma camada visual para interagir com o sistema e \n\ndemonstrar seus resultados. \n\n\n\n  \n\nPortanto esse cap\u00edtulo apresenta a aplica\u00e7\u00e3o pela \u00f3tica do \n\nusu\u00e1rio, demonstrando a camada visual desenvolvida para a aplica\u00e7\u00e3o \n\ne as respostas das funcionalidades descritas desta \u00faltima. \n\n\u00c9 importante salientar que a camada visual foi desenvolvida \n\ncom o objetivo \u00fanico de apresentar as funcionalidades da aplica\u00e7\u00e3o \n\nproposta. Sendo assim, pontos como usabilidade e configura\u00e7\u00e3o \n\n(internacionaliza\u00e7\u00e3o e localiza\u00e7\u00e3o, por exemplo) n\u00e3o foram tomados \n\ncomo prioridade, podendo estar um pouco limitados ou com \n\npossibilidade de melhorias. \n\nTecnologicamente a camada visual foi desenvolvida na \n\nlinguagem de programa\u00e7\u00e3o Java, utilizando as classes e componetes \n\nvisuais da pr\u00f3pria linguagem, em especial do pacote \u201cjavax.swing\u201d. \n\nComo interface de desenvolvimento foi utilizada a ferramenta Eclipse \n\nSDK \u2014 j\u00e1 empregada no desenvolvimento da aplica\u00e7\u00e3o em si \u2014 \n\nmunida de um plugin pr\u00f3prio da ferramenta para desenvolvimento de \n\ninterfaces gr\u00e1ficas, o Visual Editor. \n\nPara facilitar a explica\u00e7\u00e3o, a apresenta\u00e7\u00e3o se dar\u00e1 como um \n\n\u201ctour\u201d atrav\u00e9s do aplicativo, como se o leitor fosse um usu\u00e1rio. \n\nNa Figura 19 est\u00e1 a visualiza\u00e7\u00e3o inicial da aplica\u00e7\u00e3o. Os \n\ncampos e componentes da mesma n\u00e3o possuem funcionalidade, pois \n\nnenhum projeto de especifica\u00e7\u00e3o est\u00e1 em uso no momento \u2014 fato \n\nindicado ao usu\u00e1rio pela mensagem \u201c<no open project>\u201d exibida na \n\nbarra de t\u00edtulo da aplica\u00e7\u00e3o. \n\nEstruturalmente a interface gr\u00e1fica da aplica\u00e7\u00e3o est\u00e1 dividida \n\nem um menu superior, intitulado \u201cFile\u201d (\u201cArquivo\u201d, em tradu\u00e7\u00e3o livre) e \n\num conjunto de tr\u00eas abas que representam os m\u00f3dulos de trabalho da \n\naplica\u00e7\u00e3o: \u201cProject\u201d, \u201cCompetence Questions\u201d e \u201cTerms\u201d. \n\n\n\n  \n\nDe in\u00edcio apenas o menu \u201cFile\u201d e suas op\u00e7\u00f5es est\u00e3o ativas \n\nnesse momento. Nesse menu h\u00e1 duas op\u00e7\u00f5es para in\u00edcio de uso de \n\num projeto de especifica\u00e7\u00e3o, como pode ser visto na Figura 20: \n\n? \u201cNew...\u201d: permite o in\u00edcio de um novo projeto de \n\nespecifica\u00e7\u00e3o. Ao clicar na fun\u00e7\u00e3o solicitado ao usu\u00e1rio indicar onde o \n\nprojeto ser\u00e1 salvo e qual o nome dado ao mesmo. A partir disso a \n\naplica\u00e7\u00e3o j\u00e1 atribui o nome dado ao projeto e cria um arquivo de \n\npersist\u00eancia XML, afim de j\u00e1 possibilitar posteriores persist\u00eancias dos \n\ndados. \n\n? \u201cOpen...\u201d: Essa op\u00e7\u00e3o permite abrir um arquivo XML \n\nposteriormente salvo atrav\u00e9s da aplica\u00e7\u00e3o. Ao abrir o arquivo os dados \n\nneles contidos s\u00e3o automaticamente carregados na estrutura de dados \n\nda aplica\u00e7\u00e3o, passando assim a estarem dispon\u00edveis para altera\u00e7\u00f5es. \n\nO \u00faltimo item do menu, \u201cPersist project...\u201d realiza a \n\npersist\u00eancia dos dados presentes na estrutura de classes do pacote \n\n\u201cData\u201d para o arquivo XML de persist\u00eancia definido para o projeto. \n\n \n\n\n\n  \n\nFigura 19 \u2014 Tela inicial da aplica\u00e7\u00e3o. \n\n \nFigura 20 \u2014 Menu \u201cFile\u201d e as op\u00e7\u00f5es de in\u00edcio de uso de um projeto. \n\n \n\nCom um projeto aberto j\u00e1 h\u00e1 a possibilidade de navegar entre \n\nas abas dos m\u00f3dulos. \n\nO primeiro m\u00f3dulo, Figura 21, chama-se \u201cProject\u201d e \u00e9 composto \n\ndas informa\u00e7\u00f5es diretamente relacionadas \u00e0 identifica\u00e7\u00e3o do projeto \n\nde especifica\u00e7\u00e3o. Nele \u00e9 poss\u00edvel alterar dados como: nome do \n\nprojeto, autor, proposta do projeto, escopo do mesmo, n\u00edvel de \n\nformalidade, e tamb\u00e9m listar as descri\u00e7\u00f5es para os usu\u00e1rios e cen\u00e1rios \n\nde uso desejados \u2014 estes itens j\u00e1 foram descritos anteriormente na \n\nsess\u00e3o 3.1. \n\nPara alterar as informa\u00e7\u00f5es existentes no m\u00f3dulo \u00e9 necess\u00e1rio \n\nexecutar o solicitar explicitamente tal fun\u00e7\u00e3o atrav\u00e9s do bot\u00e3o \u201cEdit\u201d na \n\nparte inferior do m\u00f3dulo. Isso faz com que os campos tornem-se \n\nedit\u00e1veis e a troca entre abas e a abertura do menu \u201cFile\u201d, garantindo \n\n\n\n  \n\nassim que nenhuma informa\u00e7\u00e3o seja perdida durante o processo de \n\naltera\u00e7\u00e3o dos dados de identifica\u00e7\u00e3o por conta da execu\u00e7\u00e3o de uma \n\noutra fun\u00e7\u00e3o n\u00e3o pertinente \u00e0 tarefa. \n\n \n\n\n\n  \n\n \nFigura 21 \u2014 Aba do m\u00f3dulo \u201cProject\u201d, no estado de exibi\u00e7\u00e3o (acima) e no estado de \n\nedi\u00e7\u00e3o (abaixo). \n\n \n\n\n\n  \n\nNa aba seguinte \u2014 veja Figura 22 \u2014 est\u00e1 o m\u00f3dulo \n\n\u201cCompetence Questions\u201d. \u00c9 ele o respons\u00e1vel pela ger\u00eancia das \n\nperguntas de compet\u00eancia do projeto e de suas categorias. As \n\nfuncionalidades de \u201cadicionar\u201d, \u201ceditar\u201d e \u201cremover\u201d s\u00e3o comuns tanto \n\n\u00e0s perguntas quanto \u00e0s categorias, possuindo as perguntas ainda a \n\nop\u00e7\u00e3o de serem movidas de uma categoria a outra. A \u00fanica exce\u00e7\u00e3o \n\nde altera\u00e7\u00e3o desse m\u00f3dulo \u00e9 em rela\u00e7\u00e3o a uma categoria padr\u00e3o que \n\n\u00e9 criada automaticamente com o in\u00edcio projeto, sempre atribu\u00edda ao \n\nidentificar 1 de categorias \u2014 na Figura 22, aparece com o nome \n\n\u201cDefault\u201d \u2014 esta n\u00e3o pode ser removida, apenas pode ter o nome \n\nalterado. \n\n \nFigura 22 \u2014 M\u00f3dulo \u201cCompetence Questions\u201d. \n\n \n\nNa listagem de perguntas, as perguntas em si s\u00e3o identificadas \n\npelo prefixo \u201c<???>\u201d enquanto que suas respostas s\u00e3o identificadas \n\npelo prefixo \u201c<ANS>\u201d (de \u201canswer\u201d, \u201cresposta\u201d em ingl\u00eas). Isto se deve \n\n\n\n  \n\na uma limita\u00e7\u00e3o na formata\u00e7\u00e3o de exibi\u00e7\u00e3o do componente, o que \n\ngeraria um esfor\u00e7o extra na resolu\u00e7\u00e3o da quest\u00e3o e fugiria da proposta \n\nde desenvolvimento da camada visual: apresentar as funcionalidades \n\nda aplica\u00e7\u00e3o. \n\nO \u00faltimo m\u00f3dulo trata-se do \u201cTerms\u201d, o m\u00f3dulo respons\u00e1vel por \n\ngerenciar os termos vinculados ao projeto, que foram extra\u00eddos das \n\nperguntas de compet\u00eancia. Na Figura 23 \u00e9 poss\u00edvel visualizar este \n\nm\u00f3dulo. \n\n \nFigura 23 \u2014 M\u00f3dulo \u201cTerms\u201d. \n\n \n\nOs termos s\u00e3o exibidos em listas, sempre no formato de caixa \n\nalta e seguidos de informa\u00e7\u00f5es a respeito de sua origem (n\u00fameros \n\nidentificadores das perguntas e respostas de onde os mesmos se \n\noriginam) e de atributos pertinentes, como ordem e identificador. \n\nNa lista da esquerda est\u00e3o os termos extra\u00eddos das perguntas \n\nda categoria que foi selecionada ao executar a a\u00e7\u00e3o de extra\u00e7\u00e3o de \n\n\n\n  \n\ntermos, atrav\u00e9s do bot\u00e3o \u201cExtract...\u201d existente acima dessa lista. \u00c9 \n\nposs\u00edvel a extra\u00e7\u00e3o tanto de uma categoria espec\u00edfica quanto de todas \n\nas categorias, extraindo assim de todas as perguntas existentes. \n\nNa lista da direita ficam os termos que efetivamente foram \n\nescolhidos como relevantes. Logo acima est\u00e3o bot\u00f5es que possibilitam \n\nas funcionalidades de remo\u00e7\u00e3o de termos (Remove), de ordena\u00e7\u00e3o \n\n(Order...) e de persist\u00eancia dos escolhidos (Persist), esta n\u00e3o em \n\narquivo XML, mas na estrutura de classes de dados da aplica\u00e7\u00e3o. \n\nAo centro est\u00e3o as funcionalidades de adicionar termos extra\u00eddo \n\naos escolhidos e tamb\u00e9m de combinar termos extra\u00eddos, afim de gerar \n\num termo composto que ent\u00e3o ser\u00e1 adicionado aos escolhidos \n\n(exemplo: termo composto \u201cUNIVERSIDADE FEDERAL DE SANTA \n\nCATARINA\u201d, composi\u00e7\u00e3o dos termos \u201cUNIVERSIDADE\u201d, \u201cFEDERAL\u201d, \n\n\u201cSANTA\u201d e \u201cCATARINA\u201d). O importante para essa \u00faltima \n\nfuncionalidade \u00e9 que os termos devem ter todos, ao menos, uma \n\npergunta ou resposta de origem em comum, pois o termo composto \n\nser\u00e1 atribu\u00eddo como origin\u00e1rio desta pergunta ou resposta. \n\n \n\n5) CONCLUS\u00c3O \n\n \n\n5.1) Considera\u00e7\u00f5es Finais \n\nEm rela\u00e7\u00e3o \u00e0 metodologia NeOn, mais exatamente sobre a \n\netapa de especifica\u00e7\u00e3o de ontologias, o ponto que mais se destaca \u00e9 a \n\ntentativa de aproximar o processo de desenvolvimento de ontologias \u00e0 \n\nmaturidade hoje observada na Engenharia de Software, como \n\ninclusive \u00e9 citado em Su\u00e1rez-Figueroa (2008). \n\nO documento OSRD proposto na etapa de especifica\u00e7\u00e3o da \n\nmetodologia traz um padr\u00e3o exato das informa\u00e7\u00f5es relevantes \u00e0 etapa \n\n\n\n  \n\ndurante o desenvolvimento da ontologia, organizando as informa\u00e7\u00f5es \n\npara que estas sirvam de subs\u00eddio para as etapas seguintes do \n\nprocesso de desenvolvimento. \n\nCom a aplica\u00e7\u00e3o h\u00e1 a possibilidade de automatizar o \n\ndesenvolvimento desse documento al\u00e9m de permitir uma comunica\u00e7\u00e3o \n\nfacilitada com outras aplica\u00e7\u00f5es durante o processo, respons\u00e1veis por \n\noutras etapas do mesmo, sendo isto poss\u00edvel a partir de um arquivo \n\nXML cuja estrutura seja de conhecimento comum, possibilitando a \n\nimplementa\u00e7\u00e3o da correta forma de leitura e interpreta\u00e7\u00e3o do mesmo. \n\n \n\n5.2) Trabalhos Futuros \n\nAlinhamento da aplica\u00e7\u00e3o proposta \u00e0 plataforma NeOn Toolkit \n\ndo projeto NeOn, desenvolvendo nova parte visual para adequa\u00e7\u00e3o \u00e0 \n\nconcep\u00e7\u00e3o de plugin. \n\nDesenvolvimento de nova camada visual que vise melhor \n\nusabilidade e melhor configura\u00e7\u00e3o, observando j\u00e1 crit\u00e9rios de \n\ninternacionaliza\u00e7\u00e3o e localiza\u00e7\u00e3o de software. \n\n \n\n\n\n  \n\n6) REFER\u00caNCIAS BIBLIOGR\u00c1FICAS \n\n \n\nBORST, W. N. Construction of Engineering Ontologies. Tese, \nUniversity of Tweenty \u2013 Centre for Telematica and Information \nTechnology, Enschede, Nederland, 1997. \n\n \n\nDACONTA, M. C.; et al. The Semantic Web: A Guide to the Future \nof XML, Web Services, and Knowledge Management. Wiley \nPublishing, 2003. \n\n \n\nDEVEDZIC, V. Understanding Ontological Engineering. \nCommunications of the ACM, v. 45, n. 4, p. 136-144, 2002. \n\n \n\nFENSEL, D.; HERMELEN, F. van. On-To-Knowledge: Content-\nDriven Knowledge Management Tools through Evolving \nOntologies. Dispon\u00edvel em: \n<http://www.ontoknowledge.org/downl/del33.pdf>. Acesso em: 02 abril \n2008 17:00. \n\n \n\nFERN\u00c1NDEZ-L\u00d3PEZ, M.; G\u00d3MEZ-P\u00c9REZ, A. Overview and analysis \nof methodologies for building ontologies. The Knowledge \nEngineering Review, v. 17, n. 2, p. 129-156, 2002. \n\n \n\nFOWLER, M. Retirement note for Model View Presenter Pattern. \nDispon\u00edvel em: &lt;\nhttp://martinfowler.com/eaaDev/ModelViewPresenter.html>. Acesso \nem: 11 mai. 2009. 19:00. \n\n \n\nG\u00d3MEZ-P\u00c9REZ, A.; CORCHO, O. Ontology Languages for the \nSemantic Web. IEEE Inteligent Systems, v. 17, n. 1, p. 54-60, 2002. \n\n \n\nG\u00d3MEZ-P\u00c9REZ, A; et al. Ontologic Engineering: with examples \nfrom the areas of knowledge management, e-commerce and the \nsemantic web. Springer-Verlag, 2004. \n\n \n\n\n\n  \n\nGRAU, B. C.; et al. Modular Reuse of Ontologies: Theory and Practice. \nJournal of Artificial Intelligence Research, v. 31, n. 1, p. 273-318, \n2008. \n\n \n\nGRUBER, T. A translation approach  to portable ontology specification. \nKnowledge Acquisition, v. 5, n. 2, p. 199-220, 1993.  \n\n \n\nGRUNINGER, M.; FOX, M. S. Methodology for the design and \nevaluation of ontologies. In Skuce D (ed) IJCAI95 Workshop on \nBasic Ontological Issues in Knowledge Sharing, pp 6.1\u20136.10.,1995. \n\n \n\nGRUNINGER, M.; LEE, J. Ontology Applications and Design. \nCommunications of the ACM, v. 45, n. 2, p. 39\u201341, 2002.  \n\n \n\nGSEVIC, D.; et al. Model Driven Architecture and Ontology \nDevelopment. Springer, 2006.  \n\n \n\nGUARINO, N. Formal Ontology in Information Systems. In: GUARINO, \nN. (ed). Formal Ontology in Information Systems. Amsterdam: IOS \nPress, 1998. \n\n \n\nHEPP, M.; et al. Harvesting Wiki Consensus Using Wikipedia Entries \nas Vocabulary for Knowledge Management. Internet Computing, v. \n11, n. 5, p. 54-65, 2007. \n\n \n\nKIRYAKOV, A. Ontologies for Knowledge Management. In: DAVIES, \nJ.; et al. (eds). Semantic Web Technologies: trends and research in \nontology-based systems, p. 115-138, 2006. \n\n \n\nMIKA, P.; AKKERMANS, H.  Towards a new synthesis of ontology \ntechnology and knowledge management. The Knowledge \nEngineering Review, v. 19, n. 4, p. 317-345, 2005. \n\n \n\nNEON. NeOn Toolkit Portal. Dispon\u00edvel em: &lt;http://www.neon-\ntoolkit.org/>. Acesso em: 10 mai. 2009. 17:00. \n\n \n\n\n\n  \n\nNOY, N. F.; MCGUINNESS, D. L. Ontology Development 101: A \nGuide to Creating Your First Ontology. Dispon\u00edvel em: \n<http://wwwksl.stanford.edu/people/dlm/papers/ontology-tutorial-noy-\nmcguinness.pdf>. \n\n \n\nPINTO, H. S.; MARTINS, J. P. Ontologies: how can they be built? \nKnowledge and Information Systems, v. 6, n. 4, p. 441-464, 2004. \n\n \n\nPROT\u00c9G\u00c9. What is Prot\u00e9g\u00e9? Dispon\u00edvel em: \n<http://protege.stanford.edu/overview>. Acesso em: 09 mai. 2009. \n14:00. \n\n \n\nRAUTENBERG, S.; et al. ontoKEM: uma ferramenta para \nconstru\u00e7\u00e3o e documenta\u00e7\u00e3o de ontologias. In: Semin\u00e1rio de \nPesquisa  em Ontologia no Brasil, Niter\u00f3i, Brasil, Agosto, 2008. Anais \ndo 1\u00ba Semin\u00e1rio de Pesquisa em Ontologia no Brasil, 2008. \n\n \n\nRAUTENBERG, S. Modelo de Conhecimento para Mapeamento de \nInstrumentos da Gest\u00e3o do Conhecimento e de Agentes \nComputacionais da Engenharia do Conhecimento Baseado em \nOntologias. Exame de Qualifica\u00e7\u00e3o, Universidade Federal de Santa \nCatarina \u2013 Programa de P\u00f3s-Gradua\u00e7\u00e3o em Engenharia e Gest\u00e3o do \nConhecimento, Florian\u00f3polis, Santa Catarina, Brasil, mar. 2009. \n\n \n\nSCHREIBER, G.; et al. Knowledge engineering and management: \nthe commonKADS methodology. MIT Press, 2002. \n\n \n\nSTUDER, R.; et al. Knowledge Engineering: Principles and methods. \nData &amp; Knowledge Engineering, v. 25, n. 1, p. 161-197, 1998. \n\n \n\nSU\u00c1REZ-FIGUEROA, M. C.; et al., D5.3.1 NeOn Development \nProcess and Ontology Life Cycle. NeOn: Lifecycle Support for \nNetworked Ontologies, Integrated Project (IST-2005-027595), NeOn-\nProject.org, 2007. \n\n \n\nSU\u00c1REZ-FIGUEROA, M.; et al., C. D5.4.1. NeOn Methodology for \nBuilding Contextualized Ontology Networks. NeOn: Lifecycle \nSupport for Networked Ontologies, Integrated Project (IST-2005-\n027595), NeOn-Project.org, 2008. \n\n\n\n  \n\n \n\nSURE, Y.; STUDER, R. A Methodology for Ontology-based \nKnowledge Management. In: DAVIES, John; et al (eds). Towards The \nSemantic Web: Ontology-Driven Knowledge Management. John Wiley \n&amp; Sons, p. 33-46, 2003. \n\n \n\n\n\n  \n\n \n\nANEXO A \u2013 C\u00d3DIGO-FONTE DA APLICA\u00c7\u00c3O. \n\n \n\n? Projeto \u201cCQPlugin\u201d \u2014 projeto da aplica\u00e7\u00e3o proposta. \n \n\n? Pacote \u201cBeans\u201d: \n\n? Classe CompetenceQuestionsBean.java: \npackage beans; \n \nimport java.util.Collection; \nimport java.util.LinkedHashMap; \nimport java.util.Map; \nimport java.util.Set; \n \nimport data.CQ; \nimport data.Category; \n \npublic class CompetenceQuestionsBean { \n  \n private Map<Integer, Category> categoriesMap = null; \n private Map<Integer, CQ> competenceQuestionsMap = null; \n  \n private OneCategory oneCategory = null; \n private OneCompetenceQuestion oneCompetenceQuestion = null; \n  \n public CompetenceQuestionsBean() {} \n  \n /** \n  * @return the categoriesMap \n  */ \n public Map<Integer, Category> getCategoriesMap() { \n  return this.categoriesMap; \n } \n  \n /** \n  * @param categoriesMap the categoriesMap to set \n  */ \n public void setCategoriesMap(Map<Integer, Category> categoriesMap) { \n  final int length = (categoriesMap != null ? categoriesMap.size() \n: 0); \n  this.categoriesMap = new LinkedHashMap<Integer, \nCategory>(length); \n  if (length > 0) { \n   this.categoriesMap.putAll(categoriesMap); \n  } \n } \n  \n /** \n  * @return the competenceQuestionsMap \n  */ \n public Map<Integer, CQ> getCompetenceQuestionsMap() { \n  return this.competenceQuestionsMap; \n } \n  \n /** \n  * @param competenceQuestionsMap the competenceQuestionsMap to set \n  */ \n public void setCompetenceQuestionsMap(Map<Integer, CQ> \ncompetenceQuestionsMap) { \n  final int length = (competenceQuestionsMap != null ? \ncompetenceQuestionsMap.size() : 0); \n  this.competenceQuestionsMap = new LinkedHashMap<Integer, \nCQ>(length); \n  if (length > 0) { \n\n\n\n  \n\n  \n this.competenceQuestionsMap.putAll(competenceQuestionsMap); \n  } \n } \n  \n /** \n  * @return the oneCategory \n  */ \n public OneCategory getOneCategory() { \n  return oneCategory; \n } \n \n /** \n  * @param oneCategory the oneCategory to set \n  */ \n public void setOneCategory(OneCategory oneCategory) { \n  this.oneCategory = oneCategory; \n } \n  \n /** \n  * @return the oneCompetenceQuestion \n  */ \n public OneCompetenceQuestion getOneCompetenceQuestion() { \n  return oneCompetenceQuestion; \n } \n \n /** \n  * @param oneCompetenceQuestion the oneCompetenceQuestion to set \n  */ \n public void setOneCompetenceQuestion(OneCompetenceQuestion \noneCompetenceQuestion) { \n  this.oneCompetenceQuestion = oneCompetenceQuestion; \n } \n  \n public static class OneCategory { \n  private final Integer idCode; \n  private final String name; \n  private final String description; \n   \n  public OneCategory(final Integer idCode, final String name, \nfinal String description) { \n   this.idCode = idCode; \n   this.name = name; \n   this.description = description; \n  } \n \n  public Integer getIdCode() { \n   return idCode; \n  } \n \n  public String getName() { \n   return name; \n  } \n \n  public String getDescription() { \n   return description; \n  } \n } \n  \n public static class OneCompetenceQuestion { \n  private final Integer idCode; \n  private final String question; \n  private final String answer; \n  private final int quantQuestionTerms; \n  private final int quantAnswerTerms; \n   \n  public OneCompetenceQuestion(final Integer idCode, \n    final String question, final String answer, \n    final int quantQuestionTerms, final int \nquantAnswerTerms) { \n   this.idCode = idCode; \n   this.question = question; \n   this.answer = answer; \n   this.quantQuestionTerms = quantQuestionTerms; \n   this.quantAnswerTerms = quantAnswerTerms; \n  } \n \n  public Integer getIdCode() { \n   return idCode; \n  } \n\n\n\n  \n\n \n  public String getQuestion() { \n   return question; \n  } \n \n  public String getAnswer() { \n   return answer; \n  } \n \n  public int getQuantQuestionTerms() { \n   return quantQuestionTerms; \n  } \n \n  public int getQuantAnswerTerms() { \n   return quantAnswerTerms; \n  } \n } \n  \n /*-------------------- \n  * Validation Methods: \n  --------------------*/ \n  \n public boolean existCategoryName(final Integer idCode, final String \nname) { \n  if (this.categoriesMap != null &amp;&amp; categoriesMap.size() > 0) { \n   Collection<Category> categories = \nthis.categoriesMap.values(); \n   for (Category category : categories) { \n    if \n(category.getName().trim().equalsIgnoreCase(name.trim()) &amp;&amp; \n      category.getIdCode() != idCode) { \n     return true; \n    } \n   } \n  } \n  return false; \n } \n  \n /*--------------- \n  * Other Methods: \n  ---------------*/ \n \n public Map<String, Integer> getAvailableCategoriesToMove(final Integer \nsourceCategoryID) { \n  final Map<String, Integer> destinationOptionsMap = new \nLinkedHashMap<String, Integer>(0); \n   \n  final Set<Integer> categoryIDs = this.categoriesMap.keySet(); \n  for (Integer idCode : categoryIDs) { \n   if (sourceCategoryID != idCode) { \n    final Category category = \nthis.categoriesMap.get(idCode); \n    destinationOptionsMap.put(category.getName(), \nidCode); \n   } \n  } \n   \n  return destinationOptionsMap; \n } \n} \n \n \n\n? Classe IOBean.java: \npackage beans; \n \nimport java.text.DateFormat; \nimport java.text.ParseException; \nimport java.util.ArrayList; \nimport java.util.Date; \nimport java.util.LinkedHashSet; \nimport java.util.List; \nimport java.util.Set; \nimport java.util.StringTokenizer; \n \nimport system.utils.UtilClass; \n \npublic class IOBean { \n  \n\n\n\n  \n\n //*Endere\u00e7o do arquivo \n private final String fileAddress; \n  \n //*Atributos de dados: \n private String projectName; \n private String autor; \n private Date createDate; \n private String purpose; \n private String scope; \n private String formalityLevel; \n  \n private List<String> usersDescriptions = new ArrayList<String>(0); \n private List<String> usesScenarios = new ArrayList<String>(0); \n  \n private List<CategoryIO> categories = new ArrayList<CategoryIO>(0); \n  \n private List<TermIO> terms = new ArrayList<TermIO>(0); \n  \n /*----------- \n  * Construtor \n  -----------*/ \n public IOBean(final String fileAddress) { \n  this.fileAddress = fileAddress; \n } \n  \n public void addCategoryIO(final CategoryIO categoryIO) { \n  if (categories == null) { \n   categories = new ArrayList<CategoryIO>(0); \n  } \n  if (categoryIO != null) { \n   this.categories.add(categoryIO); \n  } \n } \n  \n public void addTermIO(final TermIO termIO) { \n  if (terms == null){ \n   terms = new ArrayList<TermIO>(0); \n  } \n  if (termIO != null) { \n   this.terms.add(termIO); \n  } \n } \n  \n public static class CategoryIO { \n  private String name; \n  private List<CQsIO> cqs = new ArrayList<CQsIO>(0); \n   \n  public void addCQsIO(CQsIO cqIO) { \n   if (cqs == null) { \n    cqs = new ArrayList<CQsIO>(0); \n   } \n   if (cqIO != null) { \n    this.cqs.add(cqIO); \n   } \n  } \n   \n  public static class CQsIO { \n   private int id; \n   private String question; \n   private String answer; \n    \n   public int getId() { \n    return id; \n   } \n   public String getQuestion() { \n    return question; \n   } \n   public String getAnswer() { \n    return answer; \n   } \n   public void setId(int id) { \n    this.id = id; \n   } \n   public void setQuestion(String question) { \n    this.question = UtilClass.removeAccent(question); \n   } \n   public void setAnswer(String answer) { \n    this.answer = UtilClass.removeAccent(answer); \n   } \n  } \n\n\n\n  \n\n \n  public String getName() { \n   return name; \n  } \n  public List<CQsIO> getCqs() { \n   if (cqs != null) { \n    return cqs; \n   } \n   return new ArrayList<CQsIO>(0); \n  } \n  public void setName(String name) { \n   this.name = UtilClass.removeAccent(name); \n  } \n  public void setCqs(List<CQsIO> cqs) { \n   this.cqs = cqs; \n  } \n } \n  \n public static class TermIO { \n  private int[] originQuestion; \n  private int[] originAnswers; \n  private String term; \n  private Integer orderPosition; \n   \n  public int[] getOriginQuestion() { \n   if (originQuestion != null) { \n    return originQuestion;     \n   } \n   return new int[]{}; \n  } \n  public String getStringOfOriginQuestions() { \n   return \nthis.getStringOfIntArray(this.getOriginQuestion()); \n  } \n  public int[] getOriginAnswers() { \n   if (originAnswers != null) { \n    return originAnswers;     \n   } \n   return new int[]{}; \n  } \n  public String getStringOfOriginAnswers() { \n   return \nthis.getStringOfIntArray(this.getOriginAnswers()); \n  } \n  private String getStringOfIntArray(final int[] intArray) { \n   StringBuilder strBuilder = new StringBuilder(); \n   final int length = (intArray != null ? intArray.length : \n0); \n   for (int i=0; i &lt;length; i++) { \n    if (strBuilder.length() > 0) { \n     strBuilder.append(\",\"); \n    } \n    strBuilder.append(intArray[i]); \n   } \n   String returnStr = strBuilder.toString(); \n   return (returnStr != null ? returnStr : new String()); \n  } \n  public String getTerm() { \n   return term; \n  } \n  public Integer getOrderPosition() { \n   return orderPosition; \n  } \n  public void setOriginQuestion(int[] originQuestion) { \n   this.originQuestion = originQuestion; \n  } \n  public void setOriginQuestion(String originQuestion) { \n   this.originQuestion = \nthis.getOriginsArrayFromString(originQuestion); \n  } \n  public void setOriginAnswers(int[] originAnswers) { \n   this.originAnswers = originAnswers; \n  } \n  public void setOriginAnswers(String originAnswers) { \n   this.originAnswers = \nthis.getOriginsArrayFromString(originAnswers); \n  } \n  private int[] getOriginsArrayFromString(final String strOrigins) \n{ \n\n\n\n  \n\n   final Set<Integer> originsSet = new \nLinkedHashSet<Integer>(0); \n   if (strOrigins != null &amp;&amp; !strOrigins.trim().isEmpty()) \n{ \n    String cleanString = \nUtilClass.removePuncts(strOrigins, \" \"); \n    StringTokenizer tokenizer = new \nStringTokenizer(cleanString); \n    while (tokenizer.hasMoreTokens()) { \n     String token = \ntokenizer.nextToken().trim(); \n     final int idOrigin = \nInteger.parseInt(token); \n     originsSet.add(idOrigin); \n    } \n   } \n   return \nUtilClass.convertArrayIntegerToArrayInt(originsSet.toArray(new Integer[]{})); \n  } \n  public void setTerm(String term) { \n   this.term = UtilClass.removeAccent(term); \n  } \n  public void setOrderPosition(Integer orderPosition) { \n   this.orderPosition = orderPosition; \n  } \n  public void setOrderPosition(String orderPosition) { \n   if (orderPosition != null &amp;&amp; \n!orderPosition.trim().isEmpty()) { \n    try { \n     this.orderPosition = \nInteger.parseInt(orderPosition.trim()); \n    } catch (NumberFormatException e) { \n     this.orderPosition = null; \n    } \n   } else { \n    this.orderPosition = null; \n   } \n  } \n } \n  \n /*--------- \n  * GETTERS: \n  ---------*/ \n \n public String getFileAddress() { \n  return fileAddress; \n } \n \n public String getProjectName() { \n  return projectName; \n } \n \n public String getAutor() { \n  return autor; \n } \n \n public Date getCreateDate() { \n  return createDate; \n } \n public String getStringOfCreateDate() { \n  if (createDate != null) { \n   return createDate.toString(); \n  } \n  return null; \n } \n \n public String getPurpose() { \n  return purpose; \n } \n \n public String getScope() { \n  return scope; \n } \n \n public String getFormalityLevel() { \n  return formalityLevel; \n } \n \n public List<String> getUsersDescriptions() { \n  return usersDescriptions; \n\n\n\n  \n\n } \n \n public List<String> getUsesScenarios() { \n  return usesScenarios; \n } \n \n public List<CategoryIO> getCategories() { \n  if (categories != null) { \n   return categories; \n  } \n  return new ArrayList<CategoryIO>(0); \n } \n \n public List<TermIO> getTerms() { \n  if (terms != null) { \n   return terms; \n  } \n  return new ArrayList<TermIO>(0); \n } \n \n /*--------- \n  * SETTERS: \n  ---------*/ \n  \n public void setProjectName(String projectName) { \n  this.projectName = UtilClass.removeAccent(projectName); \n } \n \n public void setAutor(String autor) { \n  this.autor = UtilClass.removeAccent(autor); \n } \n \n public void setCreateDate(Date createDate) { \n  this.createDate = createDate; \n } \n public void setCreateDate(String createDate) { \n  try { \n   this.createDate = \n(DateFormat.getInstance()).parse(createDate); \n  } catch (ParseException e) { \n   this.createDate = new Date(); \n  } \n } \n \n public void setPurpose(String purpose) { \n  this.purpose = UtilClass.removeAccent(purpose); \n } \n \n public void setScope(String scope) { \n  this.scope = UtilClass.removeAccent(scope); \n } \n \n public void setFormalityLevel(String formalityLevel) { \n  this.formalityLevel = UtilClass.removeAccent(formalityLevel); \n } \n \n public void setUsersDescriptions(List<String> usersDescriptions) { \n  this.usersDescriptions = \nUtilClass.removeAccentFromStringList(usersDescriptions); \n } \n \n public void setUsesScenarios(List<String> usesScenarios) { \n  this.usesScenarios = \nUtilClass.removeAccentFromStringList(usesScenarios); \n } \n \n public void setCategories(List<CategoryIO> categories) { \n  this.categories = categories; \n } \n \n public void setTerms(List<TermIO> terms) { \n  this.terms = terms; \n } \n} \n \n \n\n? Classe ProjectBean.java: \npackage beans; \n\n\n\n  \n\n \nimport java.util.Date; \nimport java.util.List; \n \n \npublic class ProjectBean { \n  \n public static class Params { \n   \n  private String name; \n  private String autor; \n  private String purpose; \n  private String scope; \n  private String formalityLevel; \n  private List<String> usersDescriptionsList; \n  private List<String> usesScenariosList; \n \n  public String getName() { \n   return name; \n  } \n \n  public String getAutor() { \n   return autor; \n  } \n \n  public String getPurpose() { \n   return purpose; \n  } \n \n  public String getScope() { \n   return scope; \n  } \n \n  public String getFormalityLevel() { \n   return formalityLevel; \n  } \n \n  public List<String> getUsersDescriptionsList() { \n   return usersDescriptionsList; \n  } \n \n  public List<String> getUsesScenariosList() { \n   return usesScenariosList; \n  } \n \n  public void setName(final String name) { \n   this.name = name; \n  } \n \n  public void setAutor(final String autor) { \n   this.autor = autor; \n  } \n \n  public void setPurpose(final String purpose) { \n   this.purpose = purpose; \n  } \n \n  public void setScope(final String scope) { \n   this.scope = scope; \n  } \n \n  public void setFormalityLevel(final String formalityLevel) { \n   this.formalityLevel = formalityLevel; \n  } \n \n  public void setUsersDescriptionsList(final List<String> \nusersDescriptionsList) { \n   this.usersDescriptionsList = usersDescriptionsList; \n  } \n \n  public void setUsesScenariosList(final List<String> \nusesScenariosList) { \n   this.usesScenariosList = usesScenariosList; \n  }  \n } \n  \n private Date createDate; \n  \n private final Params initParams; \n private Params changedParams; \n\n\n\n  \n\n  \n public ProjectBean(final ProjectBean.Params initParams, final Date \nprojectCreateDate) { \n  if (initParams != null) { \n   this.initParams = initParams; \n  } else { \n   this.initParams = new Params(); \n  } \n  this.createDate = projectCreateDate; \n } \n  \n private Params getChangedParams() { \n  if (this.changedParams == null) { \n   this.changedParams = new Params(); \n  } \n  return this.changedParams; \n } \n  \n public void setName(final String name) { \n  this.getChangedParams().setName(name); \n } \n public void setAutor(final String autor) { \n  this.getChangedParams().setAutor(autor); \n } \n public void setPurpose(final String purpose) { \n  this.getChangedParams().setPurpose(purpose); \n } \n public void setScope(final String scope) { \n  this.getChangedParams().setScope(scope); \n } \n public void setFormalityLevel(final String formalityLevel) { \n  this.getChangedParams().setFormalityLevel(formalityLevel); \n } \n public void setUsersDescriptionList(final List<String> \nusersDescriptionsList) { \n \n this.getChangedParams().setUsersDescriptionsList(usersDescriptionsList)\n; \n } \n public void setUsesScenariosList(final List<String> usesScenariosList) \n{ \n  this.getChangedParams().setUsesScenariosList(usesScenariosList); \n } \n  \n public boolean hasNewName() { \n  if (this.changedParams != null) { \n   return this.isDiferent(this.initParams.getName(), \nthis.changedParams.getName()); \n  } \n  return false; \n } \n  \n public String getName() { \n  if (this.changedParams != null) { \n   return this.changedParams.getName(); \n  } else { \n   return this.initParams.getName(); \n  } \n } \n public String getAutor() { \n  if (this.changedParams != null) { \n   return this.changedParams.getAutor(); \n  } else { \n   return this.initParams.getAutor(); \n  } \n } \n public String getPurpose() { \n  if (this.changedParams != null) { \n   return this.changedParams.getPurpose(); \n  } else { \n   return this.initParams.getPurpose(); \n  } \n } \n public String getScope() { \n  if (this.changedParams != null) { \n   return this.changedParams.getScope(); \n  } else { \n   return this.initParams.getScope(); \n  } \n } \n\n\n\n  \n\n public String getFormalityLevel() { \n  if (this.changedParams != null) { \n   return this.changedParams.getFormalityLevel(); \n  } else { \n   return this.initParams.getFormalityLevel(); \n  } \n } \n public List<String> getUsersDescriptionsList() { \n  if (this.changedParams != null) { \n   return this.changedParams.getUsersDescriptionsList(); \n  } else { \n   return this.initParams.getUsersDescriptionsList(); \n  } \n } \n public List<String> getUsesScenariosList() { \n  if (this.changedParams != null) { \n   return this.changedParams.getUsesScenariosList(); \n  } else { \n   return this.initParams.getUsesScenariosList(); \n  } \n } \n  \n public Date getCreateDate() { \n  return this.createDate; \n } \n  \n private boolean isDiferent(final String init, final String changed) { \n  return (init == null ? changed != null : \n!init.equalsIgnoreCase(changed)); \n } \n private boolean isListDiferent(final List<String> init, final \nList<String> changed) { \n  return (init == null ? changed != null : !init.equals(changed)); \n } \n \n public boolean hasChanges() { \n  if (this.changedParams != null) { \n   if ( this.isDiferent(this.initParams.getName(), \nthis.changedParams.getName()) ) { \n    return true; \n   } else if ( this.isDiferent(this.initParams.getAutor(), \nthis.changedParams.getAutor()) ) { \n    return true; \n   } else if ( \nthis.isDiferent(this.initParams.getPurpose(), this.changedParams.getPurpose()) \n) { \n    return true; \n   } else if ( this.isDiferent(this.initParams.getScope(), \nthis.changedParams.getScope()) ) { \n    return true; \n   } else if ( \nthis.isDiferent(this.initParams.getFormalityLevel(), \nthis.changedParams.getFormalityLevel()) ) { \n    return true; \n   } else if ( \nthis.isListDiferent(this.initParams.getUsersDescriptionsList(), \nthis.changedParams.getUsersDescriptionsList()) ) { \n    return true; \n   } else if ( \nthis.isListDiferent(this.initParams.getUsesScenariosList(), \nthis.changedParams.getUsesScenariosList()) ) { \n    return true; \n   } \n  } \n  return false; \n } \n  \n public void clearChanges() { \n  this.changedParams = null; \n } \n} \n \n \n\n? Classe TermsBean,java: \npackage beans; \n \nimport java.util.ArrayList; \nimport java.util.Collection; \n\n\n\n  \n\nimport java.util.Collections; \nimport java.util.LinkedHashMap; \nimport java.util.LinkedHashSet; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \n \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.ValidationErrors; \nimport view.terms.TermsForm.OrderByOptions; \n \nimport data.Term; \n \npublic class TermsBean { \n  \n private Map<String, MappedTerm> initTermsMap; \n  \n private Map<String, MappedTerm> chosenTermsMap; \n  \n private Map<String, MappedTerm> extractedTermsMap; \n  \n private Map<String, Integer> availableCategoriesToExtract; \n  \n public TermsBean() { \n  this.extractedTermsMap = new LinkedHashMap<String, \nMappedTerm>(0); \n     \n  this.initTermsMap = new LinkedHashMap<String, MappedTerm>(0); \n  this.chosenTermsMap = new LinkedHashMap<String, MappedTerm>(0); \n } \n  \n public void loadInitData(final Map<Integer, Term> allTermsMap) { \n  final int length = (allTermsMap != null ? allTermsMap.size() : \n0); \n  if (length > 0) { \n   this.loadMapToMap(allTermsMap, this.initTermsMap); \n   this.loadMapToMap(allTermsMap, this.chosenTermsMap); \n  } \n } \n \n private void loadMapToMap(final Map<Integer, Term> allTermsMap, \n   final Map<String, MappedTerm> targetTermsMap) { \n  targetTermsMap.clear(); \n  final Set<Integer> keySet = allTermsMap.keySet(); \n  for (Integer id : keySet) { \n   final Term term = allTermsMap.get(id); \n   MappedTerm mappedTerm = new MappedTerm(); \n    \n   mappedTerm.setIdCode(term.getIdCode()); \n   mappedTerm.setOrderPosition(term.getOrderPosition()); \n   mappedTerm.setTerm(term.getDescription()); \n  \n mappedTerm.setOriginQuestions(term.getOriginQuestions()); \n   mappedTerm.setOriginAnswers(term.getOriginAnswers()); \n    \n   targetTermsMap.put( \n    \n UtilClass.formatTermsMapKey(mappedTerm.term), mappedTerm); \n  } \n } \n  \n public void reloadInitTermsMap(final Map<Integer, Term> allTermsMap) { \n  if (this.initTermsMap != null) { \n   this.loadMapToMap(allTermsMap, this.initTermsMap); \n  } \n } \n  \n public void clearExtractedTermsMap() { \n  this.extractedTermsMap.clear(); \n } \n  \n public void addAllExtractedTermsFromQuestion(final Set<String> \nextractedTerms, final int questionID) { \n  this.addAllExtractedTerms(extractedTerms, questionID, null); \n } \n  \n public void addAllExtractedTermsFromAnswer(final Set<String> \nextractedTerms, final int answerID) { \n  this.addAllExtractedTerms(extractedTerms, null, answerID); \n } \n\n\n\n  \n\n  \n private void addAllExtractedTerms(final Set<String> extractedTerms, \n   final Integer questionID, final Integer answerID) { \n  if (extractedTerms != null) { \n   for (String term : extractedTerms) { \n    MappedTerm mappedTerm = \n    \n this.extractedTermsMap.get(UtilClass.formatTermsMapKey(term)); \n    if (mappedTerm == null) { \n     mappedTerm = new MappedTerm(); \n     mappedTerm.term = term; \n     this.extractedTermsMap.put( \n      \n UtilClass.formatTermsMapKey(mappedTerm.term), mappedTerm); \n    } \n    if (questionID != null) { \n    \n mappedTerm.originQuestions.add(questionID); \n    } \n    if (answerID != null) { \n     mappedTerm.originAnswers.add(answerID); \n    } \n   } \n  } \n } \n  \n public int getFrequency(final String term) { \n  MappedTerm mappedTerm = this.chosenTermsMap.get(term); \n  if (mappedTerm != null) { \n   return mappedTerm.getFrequency(); \n  } \n  return 0; \n } \n  \n public Collection<MappedTerm> valuesOfExtractedTermsMap(final \nOrderByOptions orderOption) { \n  Map<String, MappedTerm> returnMap = \nthis.compareExtractedWithChosenMap(); \n  if (orderOption != null) { \n   return this.valuesOfTermsMap(returnMap, orderOption); \n  } \n  return returnMap.values(); \n } \n  \n public Collection<MappedTerm> valuesOfChosenTermsMap(final \nOrderByOptions orderOption) { \n  if (orderOption != null) { \n   return this.valuesOfTermsMap(this.chosenTermsMap, \norderOption); \n  } \n  return this.chosenTermsMap.values(); \n } \n  \n private Collection<MappedTerm> valuesOfTermsMap(final Map<String, \nMappedTerm> termsMap, \n   final OrderByOptions orderOption) { \n  switch (orderOption) { \n   case POSITION: { \n    return this.getValuesOrderByPosition(termsMap); \n   } \n   case FREQUENCY: { \n    return this.getValuesOrderByFrequency(termsMap); \n   } \n   default: { \n    return this.getValuesOrderByAlphabet(termsMap); \n   } \n  } \n } \n  \n private Collection<MappedTerm> getValuesOrderByAlphabet( \n   final Map<String, MappedTerm> termsMap) { \n  final int length = (termsMap != null ? termsMap.size() : 0); \n  Collection<MappedTerm> returnValues = new \nArrayList<MappedTerm>(length); \n  if (length > 0) { \n   final List<String> keyList = new \nArrayList<String>(termsMap.keySet()); \n   Collections.sort(keyList); \n   for (String key : keyList) { \n\n\n\n  \n\n    final String term = \nUtilClass.formatTermsMapKey(key); \n    returnValues.add(termsMap.get(term)); \n   } \n  } \n  return returnValues; \n } \n \n private Collection<MappedTerm> getValuesOrderByFrequency( \n   final Map<String, MappedTerm> termsMap) { \n  final int length = (termsMap != null ? termsMap.size() : 0); \n  Collection<MappedTerm> returnValues = new \nArrayList<MappedTerm>(length); \n  if (length > 0) { \n   Map<Integer, List<MappedTerm>> orderedMap = new \nLinkedHashMap<Integer, List<MappedTerm>>(0); \n   Collection<MappedTerm> values = termsMap.values(); \n   for (MappedTerm mappedTerm : values) { \n    final int frequency = mappedTerm.getFrequency(); \n    final List<MappedTerm> list = \n(orderedMap.containsKey(frequency) ? \n       orderedMap.get(frequency) : \nnew ArrayList<MappedTerm>(0)); \n    list.add(mappedTerm); \n    orderedMap.put(frequency, list); \n   } \n   List<Integer> keyList = new \nArrayList<Integer>(orderedMap.keySet()); \n   Collections.sort(keyList, Collections.reverseOrder()); \n   for (Integer key : keyList) { \n    returnValues.addAll(orderedMap.get(key)); \n   } \n  } \n  return returnValues; \n } \n \n private Collection<MappedTerm> getValuesOrderByPosition( \n   final Map<String, MappedTerm> termsMap) { \n  final int length = (termsMap != null ? termsMap.size() : 0); \n  Collection<MappedTerm> returnValues = new \nArrayList<MappedTerm>(length); \n  if (length > 0) { \n   Map<Integer, MappedTerm> positionMap = new \nLinkedHashMap<Integer, MappedTerm>(0); \n   Map<Integer, List<MappedTerm>> frequencyMap = new \nLinkedHashMap<Integer, List<MappedTerm>>(0); \n   Collection<MappedTerm> values = termsMap.values(); \n   for (MappedTerm mappedTerm : values) { \n    final Integer orderPosition = \nmappedTerm.getOrderPosition(); \n    if (orderPosition != null) { \n     positionMap.put(orderPosition, \nmappedTerm); \n    } else { \n     final int frequency = \nmappedTerm.getFrequency(); \n     final List<MappedTerm> list = \n(frequencyMap.containsKey(frequency) ? \n       frequencyMap.get(frequency) \n: new ArrayList<MappedTerm>(0)); \n     list.add(mappedTerm); \n     frequencyMap.put(frequency, list); \n    } \n   } \n   List<Integer> positionList = new \nArrayList<Integer>(positionMap.keySet()); \n   Collections.sort(positionList); \n   for (Integer position : positionList) { \n    returnValues.add(positionMap.get(position)); \n   } \n   List<Integer> frequencyList = new \nArrayList<Integer>(frequencyMap.keySet()); \n   Collections.sort(frequencyList, \nCollections.reverseOrder()); \n   for (Integer frequency : frequencyList) { \n    returnValues.addAll(frequencyMap.get(frequency)); \n   } \n  } \n  return returnValues; \n } \n\n\n\n  \n\n \n public boolean isChosenEqualsInitMap() { \n  boolean equals = true; \n   \n  final int lengthChosen = this.chosenTermsMap.size(); \n  final int lengthInit = this.initTermsMap.size(); \n  if (lengthChosen != lengthInit) { \n   equals = false; \n  } else { \n   for (String key : this.chosenTermsMap.keySet()) { \n    final String term = \nUtilClass.formatTermsMapKey(key); \n    if (!this.compareMappedTerms( \n      this.chosenTermsMap.get(term), \nthis.initTermsMap.get(term))) { \n     equals = false; \n     break; \n    } \n   } \n  } \n   \n  return equals; \n } \n  \n private boolean compareMappedTerms(final MappedTerm chosenTerm, \n   final MappedTerm initTerm) { \n  boolean equals = true; \n   \n  final Object[] detailsChosenTerm = new Object[]{ \n    chosenTerm.idCode, chosenTerm.term, \nchosenTerm.orderPosition  \n  }; \n  final Object[] detailsInitTerm = new Object[]{ \n    initTerm.idCode, initTerm.term, \ninitTerm.orderPosition \n  }; \n  for (int i=0; i &lt;3; i++) { \n   if (detailsChosenTerm[i] != null) { \n    if \n(!detailsChosenTerm[i].equals(detailsInitTerm[i])) { \n     equals = false; \n     break; \n    } \n   } else if (detailsInitTerm[i] != null) { \n    equals = false; \n    break; \n   } \n  } \n   \n  if (equals) { \n   for (Integer question : chosenTerm.originQuestions) { \n    if (!initTerm.originQuestions.contains(question)) \n{ \n     equals = false; \n     break; \n    } \n   } \n   if (equals) { \n    for (Integer answer : chosenTerm.originAnswers) { \n     if \n(!initTerm.originAnswers.contains(answer)) { \n      equals = false; \n      break; \n     } \n    } \n   } \n  } \n   \n  return equals; \n } \n \n public Map<String, Integer> getAvailableCategoriesToExtract() { \n  return availableCategoriesToExtract; \n } \n \n public void setAvailableCategoriesToExtract( \n   Map<String, Integer> availableCategoriesToExtract) { \n  this.availableCategoriesToExtract = \navailableCategoriesToExtract; \n } \n\n\n\n  \n\n  \n public Map<String, MappedTerm> compareExtractedWithChosenMap() { \n  Map<String, MappedTerm> returnMap = new LinkedHashMap<String, \nMappedTerm>(0); \n  returnMap.putAll(this.extractedTermsMap); \n   \n  for (String key : this.extractedTermsMap.keySet()) { \n   final String term = UtilClass.formatTermsMapKey(key); \n   boolean termMustRemoved = true; \n   if (this.chosenTermsMap.containsKey(term)) { \n    final MappedTerm extractedTerm = \nthis.extractedTermsMap.get(term); \n    final MappedTerm chosenTerm = \nthis.chosenTermsMap.get(term); \n     \n    for (Integer question : \nextractedTerm.originQuestions) { \n     if \n(!chosenTerm.originQuestions.contains(question)) { \n      termMustRemoved = false; \n      break; \n     } \n    } \n     \n    if (termMustRemoved) { \n     for (Integer answer : \nextractedTerm.originAnswers) { \n      if \n(!chosenTerm.originAnswers.contains(answer)) { \n       termMustRemoved = false; \n       break; \n      } \n     } \n    } \n   } else { \n    termMustRemoved = false; \n   } \n    \n   if (termMustRemoved) { \n    returnMap.remove(term); \n   } \n  } \n   \n  return returnMap; \n } \n  \n public void moveTermsToChosenMap(final List<String> extractedTermsList) \n{ \n  for (String key : extractedTermsList) { \n   final String term = UtilClass.formatTermsMapKey(key); \n   final MappedTerm extractedTerm = \nthis.extractedTermsMap.get(term); \n   if (this.chosenTermsMap.containsKey(term)) { \n    final MappedTerm chosenTerm = \nthis.chosenTermsMap.get(term); \n     \n    for (Integer question : \nextractedTerm.originQuestions) { \n     if \n(!chosenTerm.originQuestions.contains(question)) { \n     \n chosenTerm.originQuestions.add(question); \n     } \n    } \n     \n    for (Integer answer : \nextractedTerm.originAnswers) { \n     if \n(!chosenTerm.originAnswers.contains(answer)) { \n     \n chosenTerm.originAnswers.add(answer); \n     } \n    } \n   } else { \n    this.chosenTermsMap.put(term, extractedTerm); \n   } \n  } \n } \n  \n\n\n\n  \n\n public void addCombinedTermsToChosenMap(final List<String> \ncombinedTermsList, \n   final Set<Integer> commonQuestions, final Set<Integer> \ncommonAnswers) throws Exception { \n  if (combinedTermsList != null &amp;&amp; combinedTermsList.size() > 0) { \n   final StringBuilder strBuilder = new StringBuilder(); \n   for (String partialTerm : combinedTermsList) { \n    if (strBuilder.length() > 0) { \n     strBuilder.append(\" \"); \n    } \n    strBuilder.append(partialTerm); \n   } \n   final String term = \nUtilClass.formatTermsMapKey(strBuilder.toString()); \n   if (!this.chosenTermsMap.containsKey(term)) { \n    final MappedTerm mappedTerm = new MappedTerm(); \n    mappedTerm.setTerm(term); \n    mappedTerm.setOriginQuestions(commonQuestions); \n    mappedTerm.setOriginAnswers(commonAnswers); \n    this.chosenTermsMap.put(term, mappedTerm); \n   } else { \n    throw new \nException(ValidationErrors.EXISTED_VALUE.toString()); \n   } \n  } \n } \n  \n public List<Integer> removeNotPersistedChosenTerms(final List<String> \ntermsList) { \n  final List<Integer> persistedTermIDs = new \nArrayList<Integer>(0); \n  for (String key : termsList) { \n   final String term = UtilClass.formatTermsMapKey(key); \n   final MappedTerm chosenTerm = \nthis.chosenTermsMap.remove(term); \n   if (chosenTerm != null) { \n    if (chosenTerm.idCode != null) { \n     persistedTermIDs.add(chosenTerm.idCode); \n    } \n   } \n  } \n  return persistedTermIDs; \n } \n  \n public static class MappedTerm { \n   \n  private Integer idCode = null; \n  private String term; \n  private Set<Integer> originQuestions = new \nLinkedHashSet<Integer>(0); \n  private Set<Integer> originAnswers = new \nLinkedHashSet<Integer>(0); \n  private Integer orderPosition = null; \n \n  public Integer getIdCode() { \n   return idCode; \n  } \n \n  public String getTerm() { \n   return term; \n  } \n \n  public Set<Integer> getOriginQuestions() { \n   return originQuestions; \n  } \n \n  public Set<Integer> getOriginAnswers() { \n   return originAnswers; \n  } \n \n  public Integer getOrderPosition() { \n   return orderPosition; \n  } \n \n  public void setIdCode(Integer idCode) { \n   this.idCode = idCode; \n  } \n \n  public void setTerm(String term) { \n   this.term = term; \n\n\n\n  \n\n  } \n \n  public void setOriginQuestions(Set<Integer> originQuestions) { \n   this.originQuestions = this.getListing(originQuestions); \n  } \n \n  public void setOriginAnswers(Set<Integer> originAnswers) { \n   this.originAnswers = this.getListing(originAnswers); \n  } \n \n  public void setOrderPosition(Integer orderPosition) { \n   this.orderPosition = orderPosition; \n  } \n   \n  private Set<Integer> getListing(final Set<Integer> originIDs) { \n   final int length = (originIDs != null ? originIDs.size() \n: 0); \n   final Set<Integer> listing = new \nLinkedHashSet<Integer>(length); \n   if (length > 0) { \n    listing.addAll(originIDs); \n   } \n   return listing; \n  } \n   \n  public int getFrequency() { \n   return (originQuestions.size() + originAnswers.size()); \n  } \n } \n \n public Map<String, MappedTerm> getInitTermsMap() { \n  return initTermsMap; \n } \n \n public Map<String, MappedTerm> getChosenTermsMap() { \n  return chosenTermsMap; \n } \n \n public Map<String, MappedTerm> getExtractedTermsMap() { \n  return extractedTermsMap; \n }  \n} \n \n \n\n? Pacote \u201cData\u201d: \n\n? Classe DataController,java: \npackage data; \n \nimport java.util.ArrayList; \nimport java.util.Collection; \nimport java.util.Date; \nimport java.util.LinkedHashMap; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \n \nimport system.Environment; \nimport system.ExtractController; \nimport system.OutputController; \nimport system.utils.UtilClass; \nimport beans.CompetenceQuestionsBean; \nimport beans.IOBean; \nimport beans.ProjectBean; \nimport beans.TermsBean; \nimport beans.CompetenceQuestionsBean.OneCategory; \nimport beans.CompetenceQuestionsBean.OneCompetenceQuestion; \nimport beans.IOBean.CategoryIO; \nimport beans.IOBean.TermIO; \nimport beans.IOBean.CategoryIO.CQsIO; \nimport beans.TermsBean.MappedTerm; \n \npublic class DataController { \n  \n private Environment environment; \n  \n\n\n\n  \n\n private Project project = null; \n  \n private String openProjectAddress = null; \n private Project initLoadedProject = null; \n \n public DataController(Environment environment) { \n  this.environment = environment; \n } \n  \n public void setProject(final Project projectInstance) { \n  this.project = projectInstance; \n } \n  \n public void setInitLoadedProject(final Project projectInstance) { \n  this.initLoadedProject = new Project(projectInstance.getName()); \n  this.initLoadedProject.setAutor(projectInstance.getAutor()); \n  this.initLoadedProject.setPurpose(projectInstance.getPurpose()); \n  this.initLoadedProject.setScope(projectInstance.getScope()); \n \n this.initLoadedProject.setFormalityLevel(projectInstance.getFormalityLe\nvel()); \n \n this.initLoadedProject.setUsersDescriptionsList(projectInstance.getUser\nsDescriptionsList()); \n \n this.initLoadedProject.setUsesScenariosList(projectInstance.getUsesScen\nariosList()); \n \n this.initLoadedProject.setCreateDate(projectInstance.getCreateDate()); \n \n this.initLoadedProject.setAllCategories(projectInstance.getAllCategorie\ns()); \n  this.initLoadedProject.setAllCQs(projectInstance.getAllCQs()); \n \n this.initLoadedProject.setAllTerms(projectInstance.getAllTerms()); \n } \n \n public boolean hasProjectInstance() { \n  return (this.project != null); \n } \n  \n public String getProjectTitle() { \n  if (this.hasProjectInstance()) { \n   return this.project.getName(); \n  } \n  return null; \n } \n  \n public boolean persistProject() { \n  final IOBean bean = new IOBean(this.openProjectAddress); \n   \n  bean.setProjectName(this.project.getCurrentDefinedName()); \n  bean.setAutor(this.project.getAutor()); \n  bean.setCreateDate(this.project.getCreateDate()); \n  bean.setPurpose(this.project.getPurpose()); \n  bean.setScope(this.project.getScope()); \n  bean.setFormalityLevel(this.project.getFormalityLevel()); \n \n bean.setUsersDescriptions(this.project.getUsersDescriptionsList()); \n  bean.setUsesScenarios(this.project.getUsesScenariosList()); \n  this.loadCategoriesForOutput(bean); \n  this.loadTermsForOutput(bean); \n   \n  OutputController oc = this.environment.getOutputController(); \n  return oc.outputToXML(bean); \n } \n \n private void loadCategoriesForOutput(final IOBean bean) { \n  Collection<Category> categories = \nthis.project.getAllCategories().values(); \n  for (Category category : categories) { \n   CategoryIO categIO = new CategoryIO(); \n   categIO.setName(category.getName()); \n   this.loadCQsForOutput(categIO, category.getListOfCQs()); \n   bean.addCategoryIO(categIO); \n  } \n } \n \n private void loadCQsForOutput(final CategoryIO categIO, final \nList<Integer> cqsList) { \n\n\n\n  \n\n  if (cqsList != null &amp;&amp; cqsList.size() > 0) { \n   for (Integer cqID : cqsList) { \n    CQ cq = this.project.getCQ(cqID); \n    if (cq != null) { \n     CQsIO ioCQ = new CQsIO(); \n     ioCQ.setId(cq.getIdCode()); \n    \n ioCQ.setQuestion(cq.getQuestion().getSentence()); \n    \n ioCQ.setAnswer(cq.getAnswer().getSentence()); \n      \n     categIO.addCQsIO(ioCQ); \n    } \n   } \n  } \n } \n \n private void loadTermsForOutput(final IOBean bean) { \n  Collection<Term> terms = this.project.getAllTerms().values(); \n  for (Term term : terms) { \n   TermIO termIO = new TermIO(); \n   termIO.setTerm(term.getDescription()); \n   termIO.setOrderPosition(term.getOrderPosition()); \n   final Integer[] questonsArray = \nterm.getOriginQuestions().toArray(new Integer[]{}); \n  \n termIO.setOriginQuestion(UtilClass.convertArrayIntegerToArrayInt(questo\nnsArray)); \n   final Integer[] answersArray = \nterm.getOriginAnswers().toArray(new Integer[]{}); \n  \n termIO.setOriginAnswers(UtilClass.convertArrayIntegerToArrayInt(answers\nArray)); \n    \n   bean.addTermIO(termIO); \n  } \n } \n \n public ProjectBean getProjectBean() { \n  if (this.hasProjectInstance()) { \n   ProjectBean.Params initParams = new \nProjectBean.Params(); \n  \n initParams.setName(this.project.getCurrentDefinedName()); \n   initParams.setAutor(this.project.getAutor()); \n   initParams.setPurpose(this.project.getPurpose()); \n   initParams.setScope(this.project.getScope()); \n  \n initParams.setFormalityLevel(this.project.getFormalityLevel()); \n  \n initParams.setUsersDescriptionsList(this.project.getUsersDescriptionsLi\nst()); \n  \n initParams.setUsesScenariosList(this.project.getUsesScenariosList()); \n   return new ProjectBean(initParams, \nthis.project.getCreateDate()); \n  } \n  return null; \n } \n  \n public CompetenceQuestionsBean getCompetenceQuestionsBean() { \n  if (this.hasProjectInstance()) { \n   CompetenceQuestionsBean bean = new \nCompetenceQuestionsBean(); \n   bean.setCategoriesMap(this.project.getAllCategories()); \n   return bean; \n  } \n  return null; \n } \n  \n public TermsBean getTermsBean() { \n  if (this.hasProjectInstance()) { \n   final TermsBean bean = new TermsBean(); \n   bean.loadInitData(this.project.getAllTerms()); \n   this.loadAvailableCategoriesToExtract(bean); \n   return bean; \n  } \n  return null; \n } \n  \n\n\n\n  \n\n private void loadAvailableCategoriesToExtract(final TermsBean bean) { \n  final Collection<Category> allCategories = \nthis.project.getAllCategories().values(); \n  final int length = (allCategories != null ? allCategories.size() \n: 0); \n  final Map<String, Integer> availableCategories = new \nLinkedHashMap<String, Integer>(length); \n  if (length > 0) { \n   availableCategories.put(UtilClass.ALL_CATEGORIES_LABEL, \nUtilClass.ALL_CATEGORIES_ID); \n   for (Category category : allCategories) { \n    if (category.getListOfCQs().size() > 0) { \n    \n availableCategories.put(category.getName(), category.getIdCode()); \n    } \n   } \n  } \n  bean.setAvailableCategoriesToExtract(availableCategories); \n } \n \n public void loadAllCQs(CompetenceQuestionsBean bean) { \n  Map<Integer, CQ> cqMap = new LinkedHashMap<Integer, CQ>(0); \n  cqMap.putAll(this.project.getAllCQs()); \n  bean.setCompetenceQuestionsMap(cqMap); \n } \n  \n public void loadCQsByCategory( \n   final CompetenceQuestionsBean bean, Integer categoryID) \n{ \n  final Category category = this.project.getCategory(categoryID); \n  final List<Integer> listOfCQs = category.getListOfCQs(); \n   \n  Map<Integer, CQ> cqMap = this.getCQMap(listOfCQs); \n   \n  bean.setCompetenceQuestionsMap(cqMap); \n } \n  \n private Map<Integer, CQ> getCQMap(final List<Integer> listOfCQs) { \n  Map<Integer, CQ> cqMap = null; \n  if (listOfCQs != null) { \n   cqMap = new LinkedHashMap<Integer, \nCQ>(listOfCQs.size()); \n   for (Integer id : listOfCQs) { \n    cqMap.put(id, this.project.getCQ(id)); \n   } \n  } \n  return cqMap; \n } \n \n public void loadOneCategory(final CompetenceQuestionsBean bean, \n   final Integer categoryID) { \n  final Category category = this.project.getCategory(categoryID); \n  final OneCategory oneCategory; \n  if (category != null) { \n   oneCategory = new OneCategory( \n     category.getIdCode(), category.getName(), \ncategory.getDescription()); \n  } else { \n   oneCategory = null; \n  } \n  bean.setOneCategory(oneCategory); \n } \n  \n public void loadOneCQ(final CompetenceQuestionsBean bean, \n   final Integer cqID) { \n  final CQ cq = this.project.getCQ(cqID); \n  final OneCompetenceQuestion oneCQ; \n  if (cq != null) { \n   oneCQ = new OneCompetenceQuestion(cq.getIdCode(), \n     cq.getQuestion().getSentence(), \ncq.getAnswer().getSentence(), \n     cq.getQuestion().getTerms().size(), \ncq.getAnswer().getTerms().size()); \n  } else { \n   oneCQ = null; \n  } \n  bean.setOneCompetenceQuestion(oneCQ); \n } \n  \n public void startNewFile(String fileName, String fileAddress) { \n\n\n\n  \n\n  this.openProjectAddress = fileAddress; \n  Project newProject = this.getNewProjectInstance( \n    UtilClass.removeExtensionFromFileName(fileName), \nnew Date()); \n  this.createDefaultCategory(newProject); \n   \n  // Opera\u00e7\u00f5es iniciais de carga do projeto: \n  this.setProject(newProject); \n  this.setInitLoadedProject(newProject); \n   \n  // Solicitando persist\u00eancia inicial do arquivo \n  this.persistProject(); \n } \n  \n public Project getNewProjectInstance(final String projectName, final \nDate projectCreateDate) { \n  final Project projectInstance = new Project(projectName); \n  projectInstance.setCreateDate(projectCreateDate); \n  return projectInstance; \n } \n  \n private void createDefaultCategory(final Project projectInstance) { \n  Category defaultCategory = \nprojectInstance.getCategory(UtilClass.DEFAULT_CATEGORY_ID); \n  if (defaultCategory == null) { \n   defaultCategory = new \nCategory(UtilClass.DEFAULT_CATEGORY_ID); \n  \n defaultCategory.setName(Category.DEFAULT_CATEGORY_INIT_NAME); \n  \n defaultCategory.setDescription(Category.DEFAULT_CATEGORY_INIT_DESCRIPTI\nON); \n   projectInstance.inputCategory(defaultCategory); \n  } \n } \n  \n public void openFile(final String fileName, final String fileAddress) \nthrows Exception { \n  this.openProjectAddress = fileAddress; \n  final IOBean bean = new IOBean(this.openProjectAddress); \n  OutputController oc = this.environment.getOutputController(); \n  oc.inputFromXML(bean); \n   \n  final Project newProject = \n   this.getNewProjectInstance(bean.getProjectName(), \nbean.getCreateDate()); \n   \n  newProject.setAutor(bean.getAutor()); \n  newProject.setPurpose(bean.getPurpose()); \n  newProject.setScope(bean.getScope()); \n  newProject.setFormalityLevel(bean.getFormalityLevel()); \n \n newProject.setUsersDescriptionsList(bean.getUsersDescriptions()); \n  newProject.setUsesScenariosList(bean.getUsesScenarios()); \n  this.loadCategoriesToProject(newProject, bean); \n  this.loadTermsToProject(newProject, bean); \n   \n  // Opera\u00e7\u00f5es iniciais de carga do projeto: \n  this.setProject(newProject); \n  this.setInitLoadedProject(newProject); \n } \n \n private void loadCategoriesToProject(final Project newProject, final \nIOBean bean) { \n  final List<CategoryIO> categIOList = bean.getCategories(); \n  if (categIOList != null) { \n   for (CategoryIO categIO : categIOList) { \n    Category category = newProject.getNewCategory(); \n    category.setName(categIO.getName()); \n    this.loadCQsToProject(newProject, category, \ncategIO); \n     \n    newProject.inputCategory(category); \n   } \n  } \n } \n  \n private void loadCQsToProject(final Project newProject, final Category \ncategory, \n   final CategoryIO categIO) { \n\n\n\n  \n\n  final List<CQsIO> ioCQList = categIO.getCqs(); \n  if (ioCQList != null) { \n   for (CQsIO ioCQ : ioCQList) { \n    final CQ cq = new CQ(ioCQ.getId()); \n    cq.setParentCategory(category.getIdCode()); \n    cq.getQuestion().setSentence(ioCQ.getQuestion()); \n    cq.getAnswer().setSentence(ioCQ.getAnswer()); \n     \n    category.addCQ(cq.getIdCode()); \n    newProject.inputCQ(cq); \n   } \n  } \n } \n \n private void loadTermsToProject(final Project newProject, final IOBean \nbean) { \n  final List<TermIO> termIOList = bean.getTerms(); \n  if (termIOList != null) { \n   for (TermIO termIO : termIOList) { \n    final Term term = newProject.getNewTerm(); \n    term.setDescription(termIO.getTerm()); \n    term.setOrderPosition(termIO.getOrderPosition()); \n    term.setOriginQuestions( \n     \n UtilClass.convertArrayIntToSetInteger(termIO.getOriginQuestion())); \n    term.setOriginAnswers( \n     \n UtilClass.convertArrayIntToSetInteger(termIO.getOriginAnswers())); \n     \n    newProject.inputTerm(term); \n   } \n  } \n } \n \n public void saveProjectBean(final ProjectBean bean) { \n  if (bean.hasChanges()) { \n   if (bean.hasNewName()) { \n    this.project.updateName(bean.getName()); \n   } \n   this.project.setAutor(bean.getAutor()); \n   this.project.setPurpose(bean.getPurpose()); \n   this.project.setScope(bean.getScope()); \n  \n this.project.setFormalityLevel(bean.getFormalityLevel()); \n  \n this.project.setUsersDescriptionsList(bean.getUsersDescriptionsList()); \n  \n this.project.setUsesScenariosList(bean.getUsesScenariosList()); \n  } \n } \n  \n public void addCategory(final CompetenceQuestionsBean bean, \n   final String name, final String description) { \n  final Category newCategory = this.project.getNewCategory(); \n  newCategory.setName(name); \n  newCategory.setDescription(description); \n  this.project.inputCategory(newCategory); \n  bean.setCategoriesMap(this.project.getAllCategories()); \n } \n  \n public void editCategory(final int idCode, \n   final String name, final String description) { \n  final Category category = this.project.getCategory(idCode); \n  category.setName(name); \n  category.setDescription(description); \n } \n  \n public boolean hasCQs(final List<Integer> categoryIDsList) { \n  for (Integer categoryID : categoryIDsList) { \n   if (this.project.hasCQs(categoryID)) { \n    return true; \n   } \n  } \n  return false; \n } \n  \n public void removeCategories(final CompetenceQuestionsBean bean, final \nList<Integer> categoryIDsList) { \n  final Category defaultCategory = \nthis.project.getCategory(UtilClass.DEFAULT_CATEGORY_ID); \n\n\n\n  \n\n  for (Integer idCode : categoryIDsList) { \n   final Category category = \nthis.project.removeCategory(idCode); \n   this.addListOfCQsToCategory(defaultCategory, \ncategory.getListOfCQs()); \n  } \n  bean.setCategoriesMap(this.project.getAllCategories()); \n } \n  \n private void addListOfCQsToCategory(final Category category, \n   final List<Integer> cqIDsList) { \n  if (category != null &amp;&amp; \n    cqIDsList != null &amp;&amp; !cqIDsList.isEmpty()) { \n   final Integer parentCategory = category.getIdCode(); \n   for (Integer CQidCode : cqIDsList) { \n    category.addCQ(CQidCode); \n   \n this.project.getCQ(CQidCode).setParentCategory(parentCategory); \n   } \n  } \n } \n  \n public void addCompetenceQuestion(final CompetenceQuestionsBean bean, \n   final Integer categoryID, final String question, final \nString answer) { \n  final CQ newCQ = this.project.getNewCQ(); \n  newCQ.setParentCategory(categoryID); \n  newCQ.getQuestion().setSentence(question); \n  newCQ.getAnswer().setSentence(answer); \n  this.project.inputCQ(categoryID, newCQ); \n  this.loadCQsByCategory(bean, categoryID); \n } \n  \n public void editCompetenceQuestion(final Integer cqID, \n   final String question, final String answer) { \n  final CQ cq = this.project.getCQ(cqID); \n  cq.getQuestion().setSentence(question); \n  cq.getAnswer().setSentence(answer); \n } \n  \n public void removeCompetenceQuestions(final CompetenceQuestionsBean \nbean, \n   final Integer categoryID, final List<Integer> cqIDsList) \n{ \n  final boolean isAllCategories = (UtilClass.ALL_CATEGORIES_ID == \ncategoryID); \n  if (isAllCategories) { \n   for (Integer cqID : cqIDsList) { \n    final CQ cq = this.project.removeCQ(cqID); \n    final Category parent = \nthis.project.getCategory(cq.getParentCategory()); \n    if (parent != null) { \n     parent.removeCQ(cqID); \n    } \n   } \n   this.loadAllCQs(bean); \n  } else { \n   final Category category = \nthis.project.getCategory(categoryID); \n   for (Integer cqID : cqIDsList) { \n    this.project.removeCQ(cqID); \n    category.removeCQ(cqID); \n   } \n   this.loadCQsByCategory(bean, categoryID); \n  } \n } \n  \n public void moveCompetenceQuestions(final CompetenceQuestionsBean bean, \n   final Integer sourceCategoryID, final Integer \ntargetCategoryID, \n   final List<Integer> cqIDsList) { \n  final Category source = \nthis.project.getCategory(sourceCategoryID); \n  final Category target = \nthis.project.getCategory(targetCategoryID); \n  for (Integer cqID : cqIDsList) { \n   source.removeCQ(cqID); \n   target.addCQ(cqID); \n  \n this.project.getCQ(cqID).setParentCategory(targetCategoryID); \n\n\n\n  \n\n  } \n  this.loadCQsByCategory(bean, sourceCategoryID); \n } \n  \n public void extractTerms(final TermsBean bean, final Integer \ncategoryID) throws Exception { \n  final Collection<CQ> cqCollection = new ArrayList<CQ>(0); \n  final ExtractController ec = \nthis.environment.getExtractController(); \n  if (categoryID == UtilClass.ALL_CATEGORIES_ID) { \n   cqCollection.addAll(this.project.getAllCQs().values()); \n  } else { \n   final Category category = \nthis.project.getCategory(categoryID); \n   if (category != null &amp;&amp; category.getListOfCQs().size() > \n0) { \n    cqCollection.addAll( \n     \n this.getCQMap(category.getListOfCQs()).values()); \n   } \n  } \n  ec.extractTerms(bean, cqCollection); \n } \n  \n public void removePersistedTerms(final TermsBean bean, \n   final List<Integer> persistedTermIDs) { \n  for (Integer termID : persistedTermIDs) { \n   final Term term = this.project.removeTerm(termID); \n   this.removeTermIDFromCQs(termID, \nterm.getOriginQuestions(), term.getOriginAnswers()); \n  } \n  bean.reloadInitTermsMap(this.project.getAllTerms()); \n } \n  \n private void removeTermIDFromCQs(final Integer termID, \n   final Set<Integer> originQuestions, final Set<Integer> \noriginAnswers) { \n  for (Integer question : originQuestions) { \n   final CQ cq = this.project.getCQ(question); \n   cq.getQuestion().getTerms().remove(termID); \n  } \n  for (Integer answer : originAnswers) { \n   final CQ cq = this.project.getCQ(answer); \n   cq.getAnswer().getTerms().remove(termID); \n  } \n } \n  \n public void persistTerms(final TermsBean bean) { \n  final Collection<MappedTerm> chosenTermCollection = \n   bean.getChosenTermsMap().values(); \n  for (MappedTerm chosenTerm : chosenTermCollection) { \n   final Term term; \n   final Integer idCode = chosenTerm.getIdCode(); \n   if (idCode == null) { \n    term = this.project.getNewTerm(); \n    this.project.inputTerm(term); \n   } else { \n    term = this.project.getTerm(idCode); \n   } \n   term.setDescription(chosenTerm.getTerm()); \n   term.setOrderPosition(chosenTerm.getOrderPosition()); \n   this.compareCQidCodesOnTerm(term, \n     chosenTerm.getOriginQuestions(), \nchosenTerm.getOriginAnswers()); \n  } \n  bean.loadInitData(this.project.getAllTerms()); \n } \n \n private void compareCQidCodesOnTerm(final Term term, \n   final Set<Integer> originQuestions, final Set<Integer> \noriginAnswers) { \n  for (Integer question : originQuestions) { \n   final Set<Integer> termOriginQuestions = \nterm.getOriginQuestions(); \n   if (!termOriginQuestions.contains(question)) { \n    termOriginQuestions.add(question); \n    final CQ cq = this.project.getCQ(question); \n   \n cq.getQuestion().getTerms().add(term.getIdCode()); \n   } \n\n\n\n  \n\n  } \n  for (Integer answer : originAnswers) { \n   final Set<Integer> termOriginAnswers = \nterm.getOriginAnswers(); \n   if (!termOriginAnswers.contains(answer)) { \n    termOriginAnswers.add(answer); \n    final CQ cq = this.project.getCQ(answer); \n    cq.getAnswer().getTerms().add(term.getIdCode()); \n   } \n  } \n } \n} \n \n\n? Classe CQ.java: \npackage data; \n \nimport java.util.ArrayList; \nimport java.util.List; \n \npublic class CQ { \n  \n private final Integer idCode; \n private Integer parentCategory; \n private final Question question; \n private final Answer answer; \n  \n public CQ(final Integer idCode) { \n  this.idCode = idCode; \n  this.question = new Question(); \n  this.answer = new Answer(); \n } \n  \n public class Question { \n   \n  private String sentence; \n  private List<Integer> terms; \n   \n  public Question() { \n   this.terms = new ArrayList<Integer>(0); \n  } \n \n  public String getSentence() { \n   return sentence; \n  } \n \n  public void setSentence(String sentence) { \n   this.sentence = sentence; \n  } \n \n  public List<Integer> getTerms() { \n   return terms; \n  } \n \n  public void setTerms(List<Integer> terms) { \n   this.terms = terms; \n  } \n   \n } \n  \n public class Answer { \n   \n  private String sentence; \n  private List<Integer> terms; \n   \n  public Answer() { \n   this.terms = new ArrayList<Integer>(0); \n  } \n \n  public String getSentence() { \n   return sentence; \n  } \n \n  public void setSentence(String sentence) { \n   this.sentence = sentence; \n  } \n \n  public List<Integer> getTerms() { \n   return terms; \n\n\n\n  \n\n  } \n \n  public void setTerms(List<Integer> terms) { \n   this.terms = terms; \n  } \n   \n } \n \n public Integer getParentCategory() { \n  return parentCategory; \n } \n \n public void setParentCategory(Integer parentCategory) { \n  this.parentCategory = parentCategory; \n } \n \n public Integer getIdCode() { \n  return idCode; \n } \n \n public Question getQuestion() { \n  return question; \n } \n \n public Answer getAnswer() { \n  return answer; \n } \n  \n} \n \n\n? Classe Category.java: \npackage data; \n \nimport java.util.ArrayList; \nimport java.util.List; \n \npublic class Category { \n  \n protected static final String DEFAULT_CATEGORY_INIT_NAME = \"Default\"; \n protected static final String DEFAULT_CATEGORY_INIT_DESCRIPTION = \n\"Default category of the Project\"; \n  \n private final Integer idCode; \n private String name; \n private String description; \n private List<Integer> listOfCQs; \n  \n public Category(final Integer idCode) { \n  this.idCode = idCode; \n  this.listOfCQs = new ArrayList<Integer>(0); \n } \n \n public String getName() { \n  return name; \n } \n \n public void setName(String name) { \n  this.name = name; \n } \n \n public String getDescription() { \n  return description; \n } \n \n public void setDescription(String description) { \n  this.description = description; \n } \n \n public List<Integer> getListOfCQs() { \n  return listOfCQs; \n } \n \n public void setListOfCQs(List<Integer> listOfCQs) { \n  this.listOfCQs = listOfCQs; \n } \n \n public Integer getIdCode() { \n  return idCode; \n\n\n\n  \n\n } \n  \n public void addCQ(final Integer CQidCode) { \n  if ( ! this.listOfCQs.contains(CQidCode)) { \n   this.listOfCQs.add(CQidCode); \n  } \n } \n  \n public boolean removeCQ(final Integer CQidCode) { \n  if (this.listOfCQs.contains(CQidCode)) { \n   return this.listOfCQs.remove(CQidCode); \n  } \n  return false; \n } \n} \n \n\n? Classe Project.java: \npackage data; \n \nimport java.util.Collections; \nimport java.util.Date; \nimport java.util.LinkedHashMap; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \n \npublic class Project { \n  \n private final String name; \n private String newName = null; \n private String autor; \n private Date createDate; \n private String purpose; \n private String scope; \n private String formalityLevel; \n private List<String> usersDescriptionsList; \n private List<String> usesScenariosList; \n  \n private Map<Integer, Category> allCategories; \n private Map<Integer, CQ> allCQs; \n private Map<Integer, Term> allTerms; \n  \n public Project(final String name) { \n  this.name = name; \n  this.allCategories = new LinkedHashMap<Integer, Category>(); \n  this.allCQs = new LinkedHashMap<Integer, CQ>(); \n  this.allTerms = new LinkedHashMap<Integer, Term>(); \n } \n  \n public void updateName(final String newName) { \n  this.newName = newName; \n } \n  \n /*------------------------------------------- \n  * M\u00e9todos para obter novos objetos de dados. \n  -------------------------------------------*/ \n  \n /** \n  * M\u00e9todo que fornece uma nova inst\u00e2ncia do tipo 'categoria'. \n  * @return Category: objeto do tipo Category \n  */ \n public Category getNewCategory() { \n  final Integer newCode = \nthis.getNewCode(this.allCategories.keySet()); \n  return new Category(newCode); \n } \n  \n /** \n  * M\u00e9todo que fornece uma nova inst\u00e2ncia do tipo 'quest\u00e3o de \ncompet\u00eancia'. \n  * @return CQ: objeto do tipo CQ \n  */ \n public CQ getNewCQ() { \n  final Integer newCode = this.getNewCode(this.allCQs.keySet()); \n  return new CQ(newCode); \n } \n  \n /** \n\n\n\n  \n\n  * M\u00e9todo que fornece uma nova inst\u00e2ncia do tipo 'termo'. \n  * @return Term: objeto do tipo Term \n  */ \n public Term getNewTerm() { \n  final Integer newCode = this.getNewCode(this.allTerms.keySet()); \n  return new Term(newCode); \n } \n  \n /*------------------------------------------- \n  * M\u00e9todos para inser\u00e7\u00e3o/atualiza\u00e7\u00e3o de objetos de dados. \n  -------------------------------------------*/ \n  \n /** \n  * M\u00e9todo que insere um determinado objeto do tipo 'categoria'. \n  * @param category Category: objeto a ser inserido. \n  */ \n public void inputCategory(Category category) { \n  this.allCategories.put(category.getIdCode(), category); \n } \n  \n /** \n  * M\u00e9todo que insere um determinado objeto do tipo 'quest\u00e3o de \ncompet\u00eancia'. \n  * @param competenceQuestion CQ: objeto a ser inserido. \n  */ \n public void inputCQ(final CQ competenceQuestion) { \n  this.allCQs.put(competenceQuestion.getIdCode(), \ncompetenceQuestion); \n } \n  \n /** \n  * M\u00e9todo que insere um determinado objeto do tipo 'quest\u00e3o de \ncompet\u00eancia'. \n  * @param competenceQuestion CQ: categoria na qual o objeto ser\u00e1 \ninserido. \n  * @param competenceQuestion CQ: objeto a ser inserido. \n  */ \n public void inputCQ(final Integer categoryID, final CQ \ncompetenceQuestion) { \n  final Integer CQidCode = competenceQuestion.getIdCode(); \n  this.allCQs.put(CQidCode, competenceQuestion); \n  this.getCategory(categoryID).addCQ(CQidCode); \n } \n  \n /** \n  * M\u00e9todo que insere um determinado objeto do tipo 'termo'. \n  * @param term Term: objeto a ser inserido. \n  */ \n public void inputTerm(Term term) { \n  this.allTerms.put(term.getIdCode(), term); \n } \n  \n /*------------------------------------------- \n  * M\u00e9todos que fornecem os objetos de dados. \n  -------------------------------------------*/ \n  \n /** \n  * M\u00e9todo que fornece um determinado objeto do tipo 'categoria'. \n  * @param idCode Integer: c\u00f3digo identificador do objeto \n  * @return Category: inst\u00e2ncia do objeto Category requerida pelo idCode \n  */ \n public Category getCategory(Integer idCode) { \n  if (idCode != null &amp;&amp; idCode > 0) { \n   return this.allCategories.get(idCode); \n  } \n  return null; \n } \n  \n /** \n  * M\u00e9todo que fornece um determinado objeto do tipo 'quest\u00e3o de \ncompet\u00eancia'. \n  * @param idCode Integer: c\u00f3digo identificador do objeto \n  * @return CQ: inst\u00e2ncia do objeto CQ requerida pelo idCode \n  */ \n public CQ getCQ(Integer idCode) { \n  if (idCode != null &amp;&amp; idCode > 0) { \n   return this.allCQs.get(idCode); \n  } \n  return null; \n } \n\n\n\n  \n\n  \n /** \n  * M\u00e9todo que fornece um determinado objeto do tipo 'termo'. \n  * @param idCode Integer: c\u00f3digo identificador do objeto \n  * @return Term: inst\u00e2ncia do objeto Term requerida pelo idCode \n  */ \n public Term getTerm(Integer idCode) { \n  if (idCode != null &amp;&amp; idCode > 0) { \n   return this.allTerms.get(idCode); \n  } \n  return null; \n } \n  \n /*------------------------------------------- \n  * M\u00e9todo auxiliares. \n  -------------------------------------------*/ \n  \n /** \n  * M\u00e9todo que fornece um novo c\u00f3digo para cria\u00e7\u00e3o de um novo objeto de \ndado (Category, CQ ou Term). \n  * @param keySet Set<Integer>: cole\u00e7\u00e3o com os c\u00f3digos existentes para \naquele objeto de dado. \n  * @return Integer: retorna um c\u00f3digo acima do \u00faltimo encontrado \n('\u00faltimo c\u00f3digo' + 1). \n  */ \n private Integer getNewCode(Set<Integer> keySet) { \n  if (keySet != null &amp;&amp; keySet.size() > 0) { \n   final Integer lastCode = Collections.max(keySet); \n   if (lastCode != null &amp;&amp; lastCode != 0) { \n    return (lastCode + 1); \n   } \n  } \n  return 1; \n } \n  \n /*------------------------------------------- \n  * M\u00e9todos GET e SET. \n  -------------------------------------------*/ \n \n public String getAutor() { \n  return autor; \n } \n \n public void setAutor(String autor) { \n  this.autor = autor; \n } \n \n public Date getCreateDate() { \n  return createDate; \n } \n \n public void setCreateDate(Date createDate) { \n  this.createDate = createDate; \n } \n \n public String getPurpose() { \n  return purpose; \n } \n \n public void setPurpose(String purpose) { \n  this.purpose = purpose; \n } \n \n public String getScope() { \n  return scope; \n } \n \n public void setScope(String scope) { \n  this.scope = scope; \n } \n \n public String getFormalityLevel() { \n  return formalityLevel; \n } \n \n public void setFormalityLevel(String formalityLevel) { \n  this.formalityLevel = formalityLevel; \n } \n  \n public List<String> getUsersDescriptionsList() { \n\n\n\n  \n\n  return usersDescriptionsList; \n } \n \n public void setUsersDescriptionsList(List<String> \nusersDescriptionsList) { \n  this.usersDescriptionsList = usersDescriptionsList; \n } \n \n public List<String> getUsesScenariosList() { \n  return usesScenariosList; \n } \n \n public void setUsesScenariosList(List<String> usesScenariosList) { \n  this.usesScenariosList = usesScenariosList; \n } \n  \n public Map<Integer, Category> getAllCategories() { \n  return allCategories; \n } \n \n public void setAllCategories(Map<Integer, Category> allCategories) { \n  this.allCategories = allCategories; \n } \n \n public Map<Integer, CQ> getAllCQs() { \n  return allCQs; \n } \n \n public void setAllCQs(Map<Integer, CQ> allCQs) { \n  this.allCQs = allCQs; \n } \n \n public Map<Integer, Term> getAllTerms() { \n  return allTerms; \n } \n \n public void setAllTerms(Map<Integer, Term> allTerms) { \n  this.allTerms = allTerms; \n } \n \n public String getName() { \n  return name; \n } \n \n public String getNewName() { \n  return newName; \n } \n  \n public String getCurrentDefinedName() { \n  if (this.newName != null &amp;&amp; !this.newName.isEmpty()) { \n   return this.newName; \n  } \n  return this.name; \n } \n \n public boolean hasCQs(final Integer categoryID) { \n  final Category category = this.getCategory(categoryID); \n  if (category != null &amp;&amp; \n    category.getListOfCQs().size() > 0) { \n   return true; \n  } \n  return false; \n } \n \n public Category removeCategory(final Integer categoryID) { \n  return this.allCategories.remove(categoryID); \n } \n  \n public CQ removeCQ(final Integer CQidCode) { \n  return this.allCQs.remove(CQidCode); \n } \n \n public Term removeTerm(final Integer termID) { \n  return this.allTerms.remove(termID); \n } \n} \n \n\n? Classe Term.java: \n\n\n\n  \n\npackage data; \n \nimport java.util.LinkedHashSet; \nimport java.util.Set; \n \npublic class Term { \n  \n private final Integer idCode; \n private String description; \n private Set<Integer> originQuestions; \n private Set<Integer> originAnswers; \n private Integer orderPosition = null; \n \n public Term(final Integer idCode) { \n  this.idCode = idCode; \n  this.originQuestions = new LinkedHashSet<Integer>(0); \n  this.originAnswers = new LinkedHashSet<Integer>(0); \n } \n \n public String getDescription() { \n  return description; \n } \n \n public void setDescription(String description) { \n  this.description = description; \n } \n \n public Set<Integer> getOriginQuestions() { \n  return originQuestions; \n } \n \n public void setOriginQuestions(Set<Integer> originQuestions) { \n  this.originQuestions = originQuestions; \n } \n \n public Set<Integer> getOriginAnswers() { \n  return originAnswers; \n } \n \n public void setOriginAnswers(Set<Integer> originAnswers) { \n  this.originAnswers = originAnswers; \n } \n \n public Integer getOrderPosition() { \n  return orderPosition; \n } \n \n public void setOrderPosition(Integer orderPosition) { \n  this.orderPosition = orderPosition; \n } \n \n public Integer getIdCode() { \n  return idCode; \n } \n} \n \n\n? Pacote \u201cSystem\u201d: \n\n? Classe Environment.java: \npackage system; \n \nimport view.ViewController; \nimport view.ViewParams; \nimport view.main.MainForm; \nimport view.project.ProjectForm; \nimport view.questions.CompetenceQuestionsForm; \nimport view.terms.TermsForm; \nimport data.DataController; \n \npublic class Environment { \n \n private DataController dataController; \n private ViewController viewController; \n  \n public Environment(MainForm mainForm, ProjectForm projectForm, \n   CompetenceQuestionsForm cqForm, TermsForm termsForm) { \n\n\n\n  \n\n  this.dataController = new DataController(this); \n   \n  ViewParams viewParams = new ViewParams(mainForm, projectForm, \ncqForm, termsForm); \n  this.viewController = new ViewController(this, viewParams); \n } \n  \n public DataController getDataController() { \n  return this.dataController; \n } \n  \n public ViewController getViewController() { \n  return this.viewController; \n } \n  \n public ExtractController getExtractController() { \n  return new ExtractController(); \n } \n  \n public OutputController getOutputController() { \n  return new OutputController(); \n } \n  \n public static void start(MainForm mainForm, ProjectForm projectForm, \n   CompetenceQuestionsForm cqForm, TermsForm termsForm) { \n  new Environment(mainForm, projectForm, cqForm, termsForm); \n } \n} \n \n\n? Classe ExtractController.java: \npackage system; \n \nimport java.util.ArrayList; \nimport java.util.Collection; \nimport java.util.LinkedHashSet; \nimport java.util.List; \nimport java.util.Set; \nimport java.util.StringTokenizer; \n \nimport system.utils.UtilClass; \nimport beans.TermsBean; \nimport data.CQ; \n \npublic class ExtractController { \n  \n public void extractTerms(final TermsBean bean, final Collection<CQ> \ncqCollection) throws Exception { \n  bean.clearExtractedTermsMap(); \n  final int length = (cqCollection != null ? cqCollection.size() : \n0); \n  if (length > 0) { \n   for (CQ cq : cqCollection) { \n    //* Extra\u00e7\u00e3o de 'question': \n    bean.addAllExtractedTermsFromQuestion( \n     \n this.extractFromSentence(cq.getQuestion().getSentence()), \n      cq.getIdCode()); \n    //* Extra\u00e7\u00e3o de 'answer': \n    bean.addAllExtractedTermsFromAnswer( \n     \n this.extractFromSentence(cq.getAnswer().getSentence()), \n      cq.getIdCode()); \n   } \n  } \n } \n  \n private Set<String> extractFromSentence(final String sentence) throws \nException { \n  final Set<String> termsList = new LinkedHashSet<String>(0); \n  if (sentence != null &amp;&amp; !sentence.isEmpty()) { \n   String cleanSentence = UtilClass.removePuncts(sentence); \n    \n   StringTokenizer tokenizer = new \nStringTokenizer(cleanSentence); \n   while (tokenizer.hasMoreTokens()) { \n    String token = tokenizer.nextToken(); \n    if (!UtilClass.isStopWord(token)) { \n     termsList.add( \n\n\n\n  \n\n      \n UtilClass.formatTermsMapKey(token)); \n    } \n   } \n  } \n  return termsList; \n } \n} \n \n\n? Classe OutputController.java: \npackage system; \n \nimport java.io.File; \nimport java.io.FileInputStream; \nimport java.io.FileWriter; \nimport java.io.IOException; \nimport java.util.ArrayList; \nimport java.util.List; \n \nimport javax.xml.parsers.DocumentBuilderFactory; \nimport javax.xml.stream.XMLOutputFactory; \nimport javax.xml.stream.XMLStreamException; \nimport javax.xml.stream.XMLStreamWriter; \n \nimport org.w3c.dom.Document; \nimport org.w3c.dom.Element; \nimport org.w3c.dom.NodeList; \n \nimport system.utils.Tags; \nimport beans.IOBean; \nimport beans.IOBean.CategoryIO; \nimport beans.IOBean.TermIO; \nimport beans.IOBean.CategoryIO.CQsIO; \n \npublic class OutputController { \n  \n public OutputController() {} \n  \n public boolean outputToXML(final IOBean bean) { \n  boolean outputOK = false; \n  if (bean != null &amp;&amp; \n    bean.getFileAddress() != null &amp;&amp; \n    !bean.getFileAddress().isEmpty()) { \n    \n   XMLOutputFactory factory = \nXMLOutputFactory.newInstance(); \n   XMLStreamWriter wr = null; \n    \n   try { \n    wr = factory.createXMLStreamWriter(new \nFileWriter(bean.getFileAddress())); \n     \n    wr.writeStartDocument(); \n    wr.writeStartElement(Tags.PROJECT); \n    // \n    wr.writeStartElement(Tags.NAME); \n    wr.writeCharacters(bean.getProjectName()); \n    wr.writeEndElement(); \n     \n    wr.writeStartElement(Tags.AUTOR); \n    wr.writeCharacters(bean.getAutor()); \n    wr.writeEndElement(); \n     \n    wr.writeStartElement(Tags.CREATE_DATE); \n    wr.writeCharacters(bean.getStringOfCreateDate()); \n    wr.writeEndElement(); \n     \n    wr.writeStartElement(Tags.PURPOSE); \n    wr.writeCharacters(bean.getPurpose()); \n    wr.writeEndElement(); \n     \n    wr.writeStartElement(Tags.SCOPE); \n    wr.writeCharacters(bean.getScope()); \n    wr.writeEndElement(); \n     \n    wr.writeStartElement(Tags.FORMALITY_LEVEL); \n    wr.writeCharacters(bean.getFormalityLevel()); \n    wr.writeEndElement(); \n\n\n\n  \n\n     \n    wr.writeStartElement(Tags.USERS); \n    final List<String> usersDescriptions = \nbean.getUsersDescriptions(); \n    if (usersDescriptions != null &amp;&amp; \nusersDescriptions.size() > 0) { \n     for (String user : usersDescriptions) { \n     \n wr.writeStartElement(Tags.USER_DESCRIPTION); \n      wr.writeCharacters(user); \n      wr.writeEndElement(); \n     } \n    } \n    wr.writeEndElement(); \n     \n    wr.writeStartElement(Tags.USES_SCENARIOS); \n    final List<String> usesScenarios = \nbean.getUsesScenarios(); \n    if (usesScenarios != null &amp;&amp; usesScenarios.size() \n> 0) { \n     for (String scenario : usesScenarios) { \n     \n wr.writeStartElement(Tags.SCENARIO); \n      wr.writeCharacters(scenario); \n      wr.writeEndElement(); \n     } \n    } \n    wr.writeEndElement(); \n     \n    final List<CategoryIO> categories = \nbean.getCategories(); \n    for (CategoryIO categoryIO : categories) { \n     wr.writeStartElement(Tags.CATEGORY); \n     wr.writeAttribute(Tags.Attrib.NAME, \ncategoryIO.getName()); \n     final List<CQsIO> cqs = \ncategoryIO.getCqs(); \n     for (CQsIO cqIO : cqs) { \n      wr.writeStartElement(Tags.CQ); \n      wr.writeAttribute(Tags.Attrib.ID, \nString.valueOf(cqIO.getId())); \n     \n wr.writeStartElement(Tags.QUESTION); \n     \n wr.writeCharacters(cqIO.getQuestion()); \n      wr.writeEndElement(); \n      final String answer = \ncqIO.getAnswer(); \n      if (answer != null &amp;&amp; \n!answer.isEmpty()) { \n      \n wr.writeStartElement(Tags.ANSWER); \n       wr.writeCharacters(answer); \n       wr.writeEndElement(); \n      } \n      wr.writeEndElement(); \n     } \n     wr.writeEndElement(); \n    } \n     \n    wr.writeStartElement(Tags.SELECTED_TERMS); \n    final List<TermIO> terms = bean.getTerms(); \n    for (TermIO termIO : terms) { \n     wr.writeStartElement(Tags.TERM); \n    \n wr.writeAttribute(Tags.Attrib.ORIGIN_QUESTIONS, \ntermIO.getStringOfOriginQuestions()); \n    \n wr.writeAttribute(Tags.Attrib.ORIGIN_ANSWERS, \ntermIO.getStringOfOriginAnswers()); \n     final Integer orderPosition = \ntermIO.getOrderPosition(); \n     if (orderPosition != null) { \n     \n wr.writeAttribute(Tags.Attrib.ORDER_POSITION, \nInteger.toString(orderPosition)); \n     } \n     wr.writeCharacters(termIO.getTerm()); \n     wr.writeEndElement(); \n    } \n\n\n\n  \n\n    wr.writeEndElement(); \n    // \n    wr.writeEndElement(); \n    wr.writeEndDocument(); \n     \n    wr.flush(); \n    wr.close(); \n     \n    outputOK = true; \n     \n   } catch (XMLStreamException e) { \n    e.printStackTrace(); \n   } catch (IOException e) { \n    e.printStackTrace(); \n   } finally { \n    if (wr != null) { \n     wr = null; \n    } \n   } \n  } \n  return outputOK; \n } \n  \n public boolean inputFromXML(final IOBean bean) throws Exception { \n  boolean inputOK = false; \n  if (bean != null &amp;&amp; \n    bean.getFileAddress() != null &amp;&amp; \n    !bean.getFileAddress().isEmpty()) { \n   try { \n    Document xmlDoc = \n    \n DocumentBuilderFactory.newInstance().newDocumentBuilder().parse( \n      new FileInputStream(new \nFile(bean.getFileAddress()))); \n     \n    //* Recuperando elemento ra\u00edz Project: \n    Element elemProject = (Element) \nxmlDoc.getElementsByTagName(Tags.PROJECT).item(0); \n     \n    //* Recuperando elemento Name: \n   \n bean.setProjectName(this.getValueFromOneElementNodeList(elemProject, \nTags.NAME)); \n    //* Recuperando elemento Autor: \n   \n bean.setAutor(this.getValueFromOneElementNodeList(elemProject, \nTags.AUTOR)); \n    //* Recuperando elemento Create Date: \n   \n bean.setCreateDate(this.getValueFromOneElementNodeList(elemProject, \nTags.CREATE_DATE)); \n    //* Recuperando elemento Purpose: \n   \n bean.setPurpose(this.getValueFromOneElementNodeList(elemProject, \nTags.PURPOSE)); \n    //* Recuperando elemento Scope: \n   \n bean.setScope(this.getValueFromOneElementNodeList(elemProject, \nTags.SCOPE)); \n    //* Recuperando elemento Formality Level: \n   \n bean.setFormalityLevel(this.getValueFromOneElementNodeList(elemProject, \nTags.FORMALITY_LEVEL)); \n     \n    //* Recuperando elementos Users Descriptions: \n    { \n     Element elemUsers = (Element) \nelemProject.getElementsByTagName(Tags.USERS).item(0); \n     NodeList listOfUserDescr = \nelemUsers.getElementsByTagName(Tags.USER_DESCRIPTION); \n     final int length = \nlistOfUserDescr.getLength(); \n     final List<String> usersDescriptionsList \n= new ArrayList<String>(length); \n     for (int i=0; i &lt;length; i++) { \n      Element elemUserDescr = (Element) \nlistOfUserDescr.item(i); \n     \n usersDescriptionsList.add(elemUserDescr.getTextContent()); \n     } \n\n\n\n  \n\n    \n bean.setUsersDescriptions(usersDescriptionsList); \n    } \n    //* Recuperando elementos Uses Scenarios: \n    { \n     Element elemUsesScenarios = (Element) \nelemProject.getElementsByTagName(Tags.USES_SCENARIOS).item(0); \n     NodeList listOfScenario = \nelemUsesScenarios.getElementsByTagName(Tags.SCENARIO); \n     final int length = \nlistOfScenario.getLength(); \n     final List<String> usesScenariosList = \nnew ArrayList<String>(length); \n     for (int i=0; i &lt;length; i++) { \n      Element elemScenario = (Element) \nlistOfScenario.item(i); \n     \n usesScenariosList.add(elemScenario.getTextContent()); \n     } \n     bean.setUsesScenarios(usesScenariosList); \n    } \n     \n    //* Recuperando elementos Categories: \n    { \n     NodeList listOfCategory = \nelemProject.getElementsByTagName(Tags.CATEGORY); \n     final int length = \nlistOfCategory.getLength(); \n     for (int i=0; i &lt;length; i++) { \n      Element elemCategory = (Element) \nlistOfCategory.item(i); \n       \n      final CategoryIO categoryIO = new \nCategoryIO(); \n     \n categoryIO.setName(elemCategory.getAttribute(Tags.Attrib.NAME)); \n     \n categoryIO.setCqs(this.getCQsIOList(elemCategory)); \n       \n      bean.addCategoryIO(categoryIO); \n     } \n    } \n     \n    //* Recuperando elementos Terms: \n    { \n     NodeList listOfSelectedTerms = \nelemProject.getElementsByTagName(Tags.SELECTED_TERMS); \n     if (listOfSelectedTerms.getLength() == 1) \n{ \n      NodeList listOfTerm = ((Element) \nlistOfSelectedTerms.item(0)).getElementsByTagName(Tags.TERM); \n      final int length = \nlistOfTerm.getLength(); \n      for (int i=0; i &lt;length; i++) { \n       Element elemTerm = \n(Element) listOfTerm.item(i); \n        \n       final TermIO termIO = new \nTermIO(); \n      \n termIO.setTerm(elemTerm.getTextContent()); \n      \n termIO.setOrderPosition(elemTerm.getAttribute(Tags.Attrib.ORDER_POSITIO\nN)); \n      \n termIO.setOriginQuestion(elemTerm.getAttribute(Tags.Attrib.ORIGIN_QUEST\nIONS)); \n      \n termIO.setOriginAnswers(elemTerm.getAttribute(Tags.Attrib.ORIGIN_ANSWER\nS)); \n        \n       bean.addTermIO(termIO); \n      } \n     } \n    } \n     \n    inputOK = true; \n     \n   } catch (Exception e) { \n    e.printStackTrace(); \n\n\n\n  \n\n    throw e; \n   } \n  } \n  return inputOK; \n } \n  \n private List<CQsIO> getCQsIOList(final Element elemCategory) throws \nException { \n  if (elemCategory != null) { \n   NodeList listOfCQ = \nelemCategory.getElementsByTagName(Tags.CQ); \n   final int length = listOfCQ.getLength(); \n   final List<CQsIO> auxList = new \nArrayList<CQsIO>(length); \n   for (int i=0; i &lt;length; i++) { \n    Element elemCQ = (Element) listOfCQ.item(i); \n     \n    final CQsIO ioCQ = new CQsIO(); \n    final String id = \nelemCQ.getAttribute(Tags.Attrib.ID); \n    ioCQ.setId(Integer.parseInt(id)); \n   \n ioCQ.setQuestion(this.getValueFromOneElementNodeList(elemCQ, \nTags.QUESTION)); \n    ioCQ.setAnswer(this.getAnswerFromCQ(elemCQ)); \n     \n    auxList.add(ioCQ); \n   } \n   return auxList; \n  } \n  return null; \n } \n \n private String getAnswerFromCQ(final Element elemCQ) throws Exception { \n  if (elemCQ != null) { \n   NodeList listOfAnswer = \nelemCQ.getElementsByTagName(Tags.ANSWER); \n   if (listOfAnswer.getLength() == 1) { \n    Element elemAnswer = (Element) \nlistOfAnswer.item(0); \n    return elemAnswer.getTextContent(); \n   } \n  } \n  return null; \n } \n \n private String getValueFromOneElementNodeList( \n   final Element elemSuper, final String tag) throws \nException { \n  Element elemChild = (Element) \nelemSuper.getElementsByTagName(tag).item(0); \n  return elemChild.getTextContent(); \n } \n} \n \n\n? Sub-pacote \u201cmvp\u201d: \n\n? Interface PassiveView.java: \npackage system.mvp; \n \npublic interface PassiveView { \n  \n&lt;T extends Presenter> void registerPresenter(T presenter); \n  \n} \n \n\n? Classe Presenter.java: \npackage system.mvp; \n \npublic abstract class Presenter { \n \n protected abstract void registerItselfInForm(); \n  \n public abstract void fillIn(); \n\n\n\n  \n\n  \n public abstract void fillOut(); \n  \n} \n \n\n? Sub-pacote \u201cutils\u201d: \n\n? Classe Tags.java: \npackage system.utils; \n \npublic final class Tags { \n  \n public static final String PROJECT = \"project\";  \n  \n public static final String NAME = \"name\"; \n public static final String AUTOR = \"autor\"; \n public static final String CREATE_DATE = \"createDate\"; \n public static final String PURPOSE = \"purpose\"; \n public static final String SCOPE = \"scope\"; \n public static final String FORMALITY_LEVEL = \"formalityLevel\"; \n  \n public static final String USERS = \"users\"; \n public static final String USER_DESCRIPTION = \"userDescription\"; \n  \n public static final String USES_SCENARIOS = \"usesScenarios\"; \n public static final String SCENARIO = \"scenario\"; \n  \n public static final String CATEGORY = \"category\"; \n public static final String CQ = \"competenceQuestion\"; \n public static final String QUESTION = \"question\"; \n public static final String ANSWER = \"answer\"; \n  \n public static final String SELECTED_TERMS = \"selectedTerms\"; \n public static final String TERM = \"term\"; \n  \n  \n public static final class Attrib { \n   \n  /** \n   * Attribute of CATEGORY tag. \n   */ \n  public static final String NAME = \"name\"; \n   \n  /** \n   * Attribute of CQ tag. \n   */ \n  public static final String ID = \"id\"; \n   \n  /** \n   * Attribute of TERM tag. \n   */ \n  public static final String ORDER_POSITION = \"orderPosition\"; \n   \n  /** \n   * Attribute of TERM tag. \n   */ \n  public static final String ORIGIN_QUESTIONS = \"originQuestions\"; \n  /** \n   * Attribute of TERM tag. \n   */ \n  public static final String ORIGIN_ANSWERS = \"originAnswers\"; \n   \n } \n} \n \n\n? Classe UtilClass.java: \npackage system.utils; \n \nimport java.util.ArrayList; \nimport java.util.HashSet; \nimport java.util.LinkedHashSet; \nimport java.util.List; \nimport java.util.Set; \nimport java.util.StringTokenizer; \n\n\n\n  \n\n \n \npublic final class UtilClass { \n  \n public enum ValidationErrors { \n  NULL_FIELD, \n  EXISTED_VALUE \n } \n  \n public enum MESSAGES { \n  EXTRACT_TERMS_EXCEPTION, \n  COMBINE_TERMS_EXCEPTION, \n  NO_COMMON_ORIGINS, \n  TERM_ALLREADY_EXIST, \n  NO_PROJECT_TO_PERSIST, \n  FAIL_ON_PROJECT_PERSISTENCE, \n  PROJECT_PERSISTED, \n  FAIL_ON_OPEN_PROJECT \n } \n  \n public static List<ValidationErrors> getOneItemList( \n   final ValidationErrors error) { \n  List<ValidationErrors> errorList = new \nArrayList<ValidationErrors>(1); \n  errorList.add(error); \n  return errorList; \n } \n  \n public static String formatTermsMapKey(final String term) { \n  if (term != null &amp;&amp; !term.isEmpty()) { \n   return term.toUpperCase(); \n  } \n  return \"\"; \n } \n  \n public static final String APP_FILE_EXT = \"xml\"; \n  \n public static final int APP_WIDTH = 800; \n public static final int APP_HEIGTH = 600; \n  \n public static final String APP_NO_OPEN_PROJECT_TITLE = \"<no open \nproject> - CQPlugin\"; \n public static final String APP_OPEN_PROJECT_TAG = \"Open Project: [{0}] \n- CQPlugin {1}\"; \n public static final String APP_TITLE_SIGNAL_NEED_PERSISTENCE = \" - \n!PROJECT NEED PERSISTENCE!\"; \n  \n public static final String NO_CREATE_DATE_LABEL = \"<no create date>\"; \n  \n public static final int NO_SELECTED_CATEGORY = -1; \n  \n public static final int ALL_CATEGORIES_ID = 0; \n public static final String ALL_CATEGORIES_LABEL = \"<All Categories>\"; \n  \n public static final int DEFAULT_CATEGORY_ID = 1; \n  \n public static final String CATEGORY_PREFIX = \") \"; \n  \n public static final String QUESTION_PREFIX = \" -&lt;???> - \"; \n public static final String ANSWER_PREFIX = \" -&lt;ANS> - \"; \n  \n public static final String TERMS_INIT_DETAILS_TAG = \" --|--\"; \n public static final String TERMS_IDCODE_TAG = \"&lt;ID: {0}>\"; \n public static final String TERMS_ORIGIN_QUESTIONS_TAG = \"&lt;questions: \n{0}>\"; \n public static final String TERMS_ORIGIN_ANSWERS_TAG = \"&lt;answers: \n{0}>\"; \n public static final String TERMS_ORDER_TAG = \"&lt;order: {0}>\"; \n  \n \n private UtilClass() {} \n  \n public static boolean isNullOrEmpty(final String value) { \n  if (value == null || value.isEmpty()) { \n   return true; \n  } \n  return false; \n } \n  \n /** \n\n\n\n  \n\n  * The &amp;quot;o&amp;quot; character. \n  */ \n public static final String O_CHARACTER = \"o\"; \n  \n /** \n  * The space character. \n  */ \n public static final String BLANK_SPACE = \" \"; \n \n private static final Set<String> STOP_WORDS = loadStopWords(); \n  \n /** \n  * Loads the list of stop words. \n  * \n  * @return the stop list. \n  */ \n public static Set<String> loadStopWords() { \n  final Set<String> stopWord = new HashSet<String>(); \n  stopWord.add(\"a\"); \n  stopWord.add(\"abaixo\"); \n  stopWord.add(\"about\"); \n  stopWord.add(\"above\"); \n  stopWord.add(\"abroad\"); \n  stopWord.add(\"acaso\"); \n  stopWord.add(\"acerca\"); \n  stopWord.add(\"acima\"); \n  stopWord.add(\"acha\"); \n  stopWord.add(\"acho\"); \n  stopWord.add(\"acola\"); \n  stopWord.add(\"across\"); \n  stopWord.add(\"ademais\"); \n  stopWord.add(\"adentro\"); \n  stopWord.add(\"adiante\"); \n  stopWord.add(\"afim\"); \n  stopWord.add(\"afin\"); \n  stopWord.add(\"afins\"); \n  stopWord.add(\"afora\"); \n  stopWord.add(\"after\"); \n  stopWord.add(\"against\"); \n  stopWord.add(\"agora\"); \n  stopWord.add(\"ahead\"); \n  stopWord.add(\"ai\"); \n  stopWord.add(\"ailleurs\"); \n  stopWord.add(\"ainda\"); \n  stopWord.add(\"aiansi\"); \n  stopWord.add(\"alem\"); \n  stopWord.add(\"algo\"); \n  stopWord.add(\"alguem\"); \n  stopWord.add(\"algum\"); \n  stopWord.add(\"alguma\"); \n  stopWord.add(\"algumas\"); \n  stopWord.add(\"algunas\"); \n  stopWord.add(\"algunos\"); \n  stopWord.add(\"alguns\"); \n  stopWord.add(\"ali\"); \n  stopWord.add(\"alias\"); \n  stopWord.add(\"all\"); \n  stopWord.add(\"alli\"); \n  stopWord.add(\"alo\"); \n  stopWord.add(\"alone\"); \n  stopWord.add(\"along\"); \n  stopWord.add(\"alors\"); \n  stopWord.add(\"also\"); \n  stopWord.add(\"although\"); \n  stopWord.add(\"always\"); \n  stopWord.add(\"ambas\"); \n  stopWord.add(\"ambito\"); \n  stopWord.add(\"ambos\"); \n  stopWord.add(\"among\"); \n  stopWord.add(\"amongst\"); \n  stopWord.add(\"amplo\"); \n  stopWord.add(\"an\"); \n  stopWord.add(\"and\"); \n  stopWord.add(\"anex\"); \n  stopWord.add(\"another\"); \n  stopWord.add(\"ante\"); \n  stopWord.add(\"antes\"); \n  stopWord.add(\"anti\"); \n  stopWord.add(\"any\"); \n  stopWord.add(\"ao\"); \n\n\n\n  \n\n  stopWord.add(\"aonde\"); \n  stopWord.add(\"aos\"); \n  stopWord.add(\"apenas\"); \n  stopWord.add(\"apesar\"); \n  stopWord.add(\"apos\"); \n  stopWord.add(\"apres\"); \n  stopWord.add(\"aquela\"); \n  stopWord.add(\"aquelas\"); \n  stopWord.add(\"aquele\"); \n  stopWord.add(\"aqueles\"); \n  stopWord.add(\"aqui\"); \n  stopWord.add(\"aquilo\"); \n  stopWord.add(\"are\"); \n  stopWord.add(\"as\"); \n  stopWord.add(\"assim\"); \n  stopWord.add(\"at\"); \n  stopWord.add(\"ate\"); \n  stopWord.add(\"ati\"); \n  stopWord.add(\"atras\"); \n  stopWord.add(\"atraves\"); \n  stopWord.add(\"attendant\"); \n  stopWord.add(\"atual\"); \n  stopWord.add(\"aucun\"); \n  stopWord.add(\"aucune\"); \n  stopWord.add(\"auquel\"); \n  stopWord.add(\"aussi\"); \n  stopWord.add(\"aussitot\"); \n  stopWord.add(\"autant\"); \n  stopWord.add(\"autour\"); \n  stopWord.add(\"auxquelles\"); \n  stopWord.add(\"auxquels\"); \n  stopWord.add(\"avante\"); \n  stopWord.add(\"avec\"); \n  stopWord.add(\"b\"); \n  stopWord.add(\"back\"); \n  stopWord.add(\"baixissima\"); \n  stopWord.add(\"baixissimas\"); \n  stopWord.add(\"baixissimo\"); \n  stopWord.add(\"baixissimos\"); \n  stopWord.add(\"balela\"); \n  stopWord.add(\"barato\"); \n  stopWord.add(\"baseada\"); \n  stopWord.add(\"basicamente\"); \n  stopWord.add(\"basta\"); \n  stopWord.add(\"bastante\"); \n  stopWord.add(\"be\"); \n  stopWord.add(\"beaucoup\"); \n  stopWord.add(\"because\"); \n  stopWord.add(\"been\"); \n  stopWord.add(\"before\"); \n  stopWord.add(\"bem\"); \n  stopWord.add(\"best\"); \n  stopWord.add(\"better\"); \n  stopWord.add(\"between\"); \n  stopWord.add(\"beyond\"); \n  stopWord.add(\"big\"); \n  stopWord.add(\"both\"); \n  stopWord.add(\"but\"); \n  stopWord.add(\"by\"); \n  stopWord.add(\"c\"); \n  stopWord.add(\"ca\"); \n  stopWord.add(\"cada\"); \n  stopWord.add(\"capaz\"); \n  stopWord.add(\"capazes\"); \n  stopWord.add(\"caro\"); \n  stopWord.add(\"caros\"); \n  stopWord.add(\"caso\"); \n  stopWord.add(\"casos\"); \n  stopWord.add(\"cela\"); \n  stopWord.add(\"celle\"); \n  stopWord.add(\"celles\"); \n  stopWord.add(\"celui\"); \n  stopWord.add(\"cependant\"); \n  stopWord.add(\"cerca\"); \n  stopWord.add(\"certa\"); \n  stopWord.add(\"certain\"); \n  stopWord.add(\"certaine\"); \n  stopWord.add(\"certaines\"); \n  stopWord.add(\"certains\"); \n  stopWord.add(\"certas\"); \n\n\n\n  \n\n  stopWord.add(\"certo\"); \n  stopWord.add(\"certos\"); \n  stopWord.add(\"ces\"); \n  stopWord.add(\"cet\"); \n  stopWord.add(\"cette\"); \n  stopWord.add(\"ceux\"); \n  stopWord.add(\"chacun\"); \n  stopWord.add(\"chacune\"); \n  stopWord.add(\"chaque\"); \n  stopWord.add(\"chez\"); \n  stopWord.add(\"chose\"); \n  stopWord.add(\"cima\"); \n  stopWord.add(\"coisa\"); \n  stopWord.add(\"com\"); \n  stopWord.add(\"combien\"); \n  stopWord.add(\"comigo\"); \n  stopWord.add(\"comme\"); \n  stopWord.add(\"comment\"); \n  stopWord.add(\"como\"); \n  stopWord.add(\"comuns\"); \n  stopWord.add(\"concernant\"); \n  stopWord.add(\"conforme\"); \n  stopWord.add(\"conformidade\"); \n  stopWord.add(\"conosco\"); \n  stopWord.add(\"conseguinte\"); \n  stopWord.add(\"consequentemente\"); \n  stopWord.add(\"consigo\"); \n  stopWord.add(\"contida\"); \n  stopWord.add(\"contidas\"); \n  stopWord.add(\"contido\"); \n  stopWord.add(\"contidos\"); \n  stopWord.add(\"contigo\"); \n  stopWord.add(\"contra\"); \n  stopWord.add(\"contre\"); \n  stopWord.add(\"contudo\"); \n  stopWord.add(\"convosco\"); \n  stopWord.add(\"corp\"); \n  stopWord.add(\"could\"); \n  stopWord.add(\"cuando\"); \n  stopWord.add(\"cuja\"); \n  stopWord.add(\"cujas\"); \n  stopWord.add(\"cujo\"); \n  stopWord.add(\"cujos\"); \n  stopWord.add(\"d\"); \n  stopWord.add(\"da\"); \n  stopWord.add(\"dans\"); \n  stopWord.add(\"daquela\"); \n  stopWord.add(\"daquelas\"); \n  stopWord.add(\"daquele\"); \n  stopWord.add(\"daqueles\"); \n  stopWord.add(\"daqui\"); \n  stopWord.add(\"daquilodas\"); \n  stopWord.add(\"das\"); \n  stopWord.add(\"de\"); \n  stopWord.add(\"debaixo\"); \n  stopWord.add(\"dedans\"); \n  stopWord.add(\"defronte\"); \n  stopWord.add(\"dehors\"); \n  stopWord.add(\"deja\"); \n  stopWord.add(\"del\"); \n  stopWord.add(\"dela\"); \n  stopWord.add(\"delas\"); \n  stopWord.add(\"dele\"); \n  stopWord.add(\"deles\"); \n  stopWord.add(\"della\"); \n  stopWord.add(\"delle\"); \n  stopWord.add(\"demais\"); \n  stopWord.add(\"dentre\"); \n  stopWord.add(\"depois\"); \n  stopWord.add(\"depressa\"); \n  stopWord.add(\"depuis\"); \n  stopWord.add(\"des\"); \n  stopWord.add(\"desde\"); \n  stopWord.add(\"desquelles\"); \n  stopWord.add(\"desquels\"); \n  stopWord.add(\"dessa\"); \n  stopWord.add(\"dessas\"); \n  stopWord.add(\"desse\"); \n  stopWord.add(\"desses\"); \n  stopWord.add(\"dessus\"); \n\n\n\n  \n\n  stopWord.add(\"desta\"); \n  stopWord.add(\"destas\"); \n  stopWord.add(\"deste\"); \n  stopWord.add(\"destes\"); \n  stopWord.add(\"detras\"); \n  stopWord.add(\"diante\"); \n  stopWord.add(\"disso\"); \n  stopWord.add(\"disto\"); \n  stopWord.add(\"do\"); \n  stopWord.add(\"donc\"); \n  stopWord.add(\"donde\"); \n  stopWord.add(\"donne\"); \n  stopWord.add(\"dont\"); \n  stopWord.add(\"doutra\"); \n  stopWord.add(\"doutras\"); \n  stopWord.add(\"doutro\"); \n  stopWord.add(\"doutros\"); \n  stopWord.add(\"dos\"); \n  stopWord.add(\"du\"); \n  stopWord.add(\"dum\"); \n  stopWord.add(\"duma\"); \n  stopWord.add(\"duns\"); \n  stopWord.add(\"duquel\"); \n  stopWord.add(\"duramente\"); \n  stopWord.add(\"durant\"); \n  stopWord.add(\"durante\"); \n  stopWord.add(\"during\"); \n  stopWord.add(\"e\"); \n  stopWord.add(\"each\"); \n  stopWord.add(\"easy\"); \n  stopWord.add(\"either\"); \n  stopWord.add(\"el\"); \n  stopWord.add(\"ela\"); \n  stopWord.add(\"elas\"); \n  stopWord.add(\"ele\"); \n  stopWord.add(\"eles\"); \n  stopWord.add(\"ell\"); \n  stopWord.add(\"ella\"); \n  stopWord.add(\"elle\"); \n  stopWord.add(\"elles\"); \n  stopWord.add(\"ello\"); \n  stopWord.add(\"em\"); \n  stopWord.add(\"embaixo\"); \n  stopWord.add(\"embora\"); \n  stopWord.add(\"en\"); \n  stopWord.add(\"encore\"); \n  stopWord.add(\"enough\"); \n  stopWord.add(\"enquanto\"); \n  stopWord.add(\"entanto\"); \n  stopWord.add(\"entao\"); \n  stopWord.add(\"entre\"); \n  stopWord.add(\"entretanto\"); \n  stopWord.add(\"essa\"); \n  stopWord.add(\"essas\"); \n  stopWord.add(\"esse\"); \n  stopWord.add(\"esses\"); \n  stopWord.add(\"esta\"); \n  stopWord.add(\"estas\"); \n  stopWord.add(\"este\"); \n  stopWord.add(\"estes\"); \n  stopWord.add(\"et\"); \n  stopWord.add(\"etaient\"); \n  stopWord.add(\"etait\"); \n  stopWord.add(\"etant\"); \n  stopWord.add(\"etc\"); \n  stopWord.add(\"eu\"); \n  stopWord.add(\"eux\"); \n  stopWord.add(\"ever\"); \n  stopWord.add(\"every\"); \n  stopWord.add(\"everybody\"); \n  stopWord.add(\"everyone\"); \n  stopWord.add(\"everything\"); \n  stopWord.add(\"everywhere\"); \n  stopWord.add(\"f\"); \n  stopWord.add(\"facil\"); \n  stopWord.add(\"favor\"); \n  stopWord.add(\"few\"); \n  stopWord.add(\"fim\"); \n  stopWord.add(\"fin\"); \n  stopWord.add(\"finali\"); \n\n\n\n  \n\n  stopWord.add(\"fins\"); \n  stopWord.add(\"for\"); \n  stopWord.add(\"fora\"); \n  stopWord.add(\"forward\"); \n  stopWord.add(\"from\"); \n  stopWord.add(\"fulano\"); \n  stopWord.add(\"furent\"); \n  stopWord.add(\"g\"); \n  stopWord.add(\"grace\"); \n  stopWord.add(\"grandemente\"); \n  stopWord.add(\"h\"); \n  stopWord.add(\"had\"); \n  stopWord.add(\"has\"); \n  stopWord.add(\"have\"); \n  stopWord.add(\"he\"); \n  stopWord.add(\"hem\"); \n  stopWord.add(\"her\"); \n  stopWord.add(\"here\"); \n  stopWord.add(\"hers\"); \n  stopWord.add(\"herself\"); \n  stopWord.add(\"him\"); \n  stopWord.add(\"himself\"); \n  stopWord.add(\"his\"); \n  stopWord.add(\"hoje\"); \n  stopWord.add(\"hormis\"); \n  stopWord.add(\"hors\"); \n  stopWord.add(\"how\"); \n  stopWord.add(\"however\"); \n  stopWord.add(\"hoy\"); \n  stopWord.add(\"hum\"); \n  stopWord.add(\"i\"); \n  stopWord.add(\"ici\"); \n  stopWord.add(\"if\"); \n  stopWord.add(\"igual\"); \n  stopWord.add(\"igualmente\"); \n  stopWord.add(\"il\"); \n  stopWord.add(\"ils\"); \n  stopWord.add(\"in\"); \n  stopWord.add(\"inc\"); \n  stopWord.add(\"inter\"); \n  stopWord.add(\"into\"); \n  stopWord.add(\"is\"); \n  stopWord.add(\"isso\"); \n  stopWord.add(\"isto\"); \n  stopWord.add(\"it\"); \n  stopWord.add(\"item\"); \n  stopWord.add(\"its\"); \n  stopWord.add(\"itself\"); \n  stopWord.add(\"iusque\"); \n  stopWord.add(\"j\"); \n  stopWord.add(\"ja\"); \n  stopWord.add(\"jadis\"); \n  stopWord.add(\"jamais\"); \n  stopWord.add(\"je\"); \n  stopWord.add(\"jeito\"); \n  stopWord.add(\"juntamente\"); \n  stopWord.add(\"junto\"); \n  stopWord.add(\"juntos\"); \n  stopWord.add(\"jusqu\"); \n  stopWord.add(\"jusque\"); \n  stopWord.add(\"just\"); \n  stopWord.add(\"justa\"); \n  stopWord.add(\"justo\"); \n  stopWord.add(\"k\"); \n  stopWord.add(\"l\"); \n  stopWord.add(\"la\"); \n  stopWord.add(\"lado\"); \n  stopWord.add(\"lados\"); \n  stopWord.add(\"laquelle\"); \n  stopWord.add(\"las\"); \n  stopWord.add(\"last\"); \n  stopWord.add(\"le\"); \n  stopWord.add(\"lequel\"); \n  stopWord.add(\"les\"); \n  stopWord.add(\"lesquelles\"); \n  stopWord.add(\"lesquels\"); \n  stopWord.add(\"less\"); \n  stopWord.add(\"leur\"); \n  stopWord.add(\"leurs\"); \n  stopWord.add(\"lha\"); \n\n\n\n  \n\n  stopWord.add(\"lhas\"); \n  stopWord.add(\"lhe\"); \n  stopWord.add(\"lhes\"); \n  stopWord.add(\"lho\"); \n  stopWord.add(\"lhos\"); \n  stopWord.add(\"lo\"); \n  stopWord.add(\"lors\"); \n  stopWord.add(\"lorsque\"); \n  stopWord.add(\"los\"); \n  stopWord.add(\"ltda\"); \n  stopWord.add(\"lui\"); \n  stopWord.add(\"m\"); \n  stopWord.add(\"mais\"); \n  stopWord.add(\"malgre\"); \n  stopWord.add(\"maneira\"); \n  stopWord.add(\"maneiras\"); \n  stopWord.add(\"many\"); \n  stopWord.add(\"mas\"); \n  stopWord.add(\"me\"); \n  stopWord.add(\"mediante\"); \n  stopWord.add(\"meme\"); \n  stopWord.add(\"memes\"); \n  stopWord.add(\"menos\"); \n  stopWord.add(\"mera\"); \n  stopWord.add(\"meramente\"); \n  stopWord.add(\"meras\"); \n  stopWord.add(\"mero\"); \n  stopWord.add(\"meros\"); \n  stopWord.add(\"mes\"); \n  stopWord.add(\"mesma\"); \n  stopWord.add(\"mesmas\"); \n  stopWord.add(\"mesmo\"); \n  stopWord.add(\"mesmos\"); \n  stopWord.add(\"meu\"); \n  stopWord.add(\"meus\"); \n  stopWord.add(\"mien\"); \n  stopWord.add(\"mienne\"); \n  stopWord.add(\"miennes\"); \n  stopWord.add(\"miens\"); \n  stopWord.add(\"mim\"); \n  stopWord.add(\"minha\"); \n  stopWord.add(\"minhas\"); \n  stopWord.add(\"moins\"); \n  stopWord.add(\"moment\"); \n  stopWord.add(\"mon\"); \n  stopWord.add(\"more\"); \n  stopWord.add(\"most\"); \n  stopWord.add(\"moyennant\"); \n  stopWord.add(\"mr\"); \n  stopWord.add(\"mrs\"); \n  stopWord.add(\"my\"); \n  stopWord.add(\"myself\"); \n  stopWord.add(\"mz\"); \n  stopWord.add(\"muita\"); \n  stopWord.add(\"muitas\"); \n  stopWord.add(\"muito\"); \n  stopWord.add(\"muitos\"); \n  stopWord.add(\"n\"); \n  stopWord.add(\"na\"); \n  stopWord.add(\"nada\"); \n  stopWord.add(\"nao\"); \n  stopWord.add(\"naquela\"); \n  stopWord.add(\"naquelas\"); \n  stopWord.add(\"naquele\"); \n  stopWord.add(\"naqueles\"); \n  stopWord.add(\"naquilo\"); \n  stopWord.add(\"nas\"); \n  stopWord.add(\"ne\"); \n  stopWord.add(\"near\"); \n  stopWord.add(\"neither\"); \n  stopWord.add(\"nela\"); \n  stopWord.add(\"nelas\"); \n  stopWord.add(\"nele\"); \n  stopWord.add(\"neles\"); \n  stopWord.add(\"nenhum\"); \n  stopWord.add(\"nenhuma\"); \n  stopWord.add(\"nenhumas\"); \n  stopWord.add(\"nenhuns\"); \n  stopWord.add(\"nesse\"); \n  stopWord.add(\"nesses\"); \n\n\n\n  \n\n  stopWord.add(\"nesta\"); \n  stopWord.add(\"nestas\"); \n  stopWord.add(\"neste\"); \n  stopWord.add(\"nestes\"); \n  stopWord.add(\"never\"); \n  stopWord.add(\"ni\"); \n  stopWord.add(\"ninguem\"); \n  stopWord.add(\"nisso\"); \n  stopWord.add(\"no\"); \n  stopWord.add(\"non\"); \n  stopWord.add(\"none\"); \n  stopWord.add(\"nos\"); \n  stopWord.add(\"nossa\"); \n  stopWord.add(\"nossas\"); \n  stopWord.add(\"nosso\"); \n  stopWord.add(\"nossos\"); \n  stopWord.add(\"not\"); \n  stopWord.add(\"notamment\"); \n  stopWord.add(\"notres\"); \n  stopWord.add(\"nous\"); \n  stopWord.add(\"now\"); \n  stopWord.add(\"nulle\"); \n  stopWord.add(\"nulles\"); \n  stopWord.add(\"num\"); \n  stopWord.add(\"numa\"); \n  stopWord.add(\"numas\"); \n  stopWord.add(\"nunca\"); \n  stopWord.add(\"nuns\"); \n  stopWord.add(O_CHARACTER); \n  stopWord.add(\"of\"); \n  stopWord.add(\"often\"); \n  stopWord.add(\"oi\"); \n  stopWord.add(\"ola\"); \n  stopWord.add(\"on\"); \n  stopWord.add(\"onde\"); \n  stopWord.add(\"one\"); \n  stopWord.add(\"only\"); \n  stopWord.add(\"or\"); \n  stopWord.add(\"os\"); \n  stopWord.add(\"other\"); \n  stopWord.add(\"ou\"); \n  stopWord.add(\"our\"); \n  stopWord.add(\"ourselves\"); \n  stopWord.add(\"out\"); \n  stopWord.add(\"outra\"); \n  stopWord.add(\"outras\"); \n  stopWord.add(\"outrem\"); \n  stopWord.add(\"outro\"); \n  stopWord.add(\"outros\"); \n  stopWord.add(\"over\"); \n  stopWord.add(\"p\"); \n  stopWord.add(\"par\"); \n  stopWord.add(\"para\"); \n  stopWord.add(\"parce\"); \n  stopWord.add(\"parmi\"); \n  stopWord.add(\"pela\"); \n  stopWord.add(\"pelas\"); \n  stopWord.add(\"per\"); \n  stopWord.add(\"perante\"); \n  stopWord.add(\"perto\"); \n  stopWord.add(\"plus\"); \n  stopWord.add(\"plusieurs\"); \n  stopWord.add(\"pode\"); \n  stopWord.add(\"pois\"); \n  stopWord.add(\"por\"); \n  stopWord.add(\"poucos\"); \n  stopWord.add(\"pour\"); \n  stopWord.add(\"pourquoi\"); \n  stopWord.add(\"pres\"); \n  stopWord.add(\"proxima\"); \n  stopWord.add(\"proximamente\"); \n  stopWord.add(\"proximas\"); \n  stopWord.add(\"proximos\"); \n  stopWord.add(\"psiu\"); \n  stopWord.add(\"puis\"); \n  stopWord.add(\"puisque\"); \n  stopWord.add(\"q\"); \n  stopWord.add(\"quais\"); \n  stopWord.add(\"quaisquer\"); \n  stopWord.add(\"qual\"); \n\n\n\n  \n\n  stopWord.add(\"qualquer\"); \n  stopWord.add(\"quand\"); \n  stopWord.add(\"quando\"); \n  stopWord.add(\"quant\"); \n  stopWord.add(\"quanta\"); \n  stopWord.add(\"quantas\"); \n  stopWord.add(\"quanto\"); \n  stopWord.add(\"quantos\"); \n  stopWord.add(\"quase\"); \n  stopWord.add(\"que\"); \n  stopWord.add(\"quel\"); \n  stopWord.add(\"quelle\"); \n  stopWord.add(\"quelqu''un\"); \n  stopWord.add(\"quelqu''une\"); \n  stopWord.add(\"quelque\"); \n  stopWord.add(\"quelques-unes\"); \n  stopWord.add(\"quelques-uns\"); \n  stopWord.add(\"quels\"); \n  stopWord.add(\"quem\"); \n  stopWord.add(\"quiconque\"); \n  stopWord.add(\"quoi\"); \n  stopWord.add(\"quoique\"); \n  stopWord.add(\"r\"); \n  stopWord.add(\"rather\"); \n  stopWord.add(\"s\"); \n  stopWord.add(\"sa\"); \n  stopWord.add(\"sans\"); \n  stopWord.add(\"sauf\"); \n  stopWord.add(\"says\"); \n  stopWord.add(\"se\"); \n  stopWord.add(\"seguinte\"); \n  stopWord.add(\"selon\"); \n  stopWord.add(\"sem\"); \n  stopWord.add(\"sempre\"); \n  stopWord.add(\"senao\"); \n  stopWord.add(\"sendo\"); \n  stopWord.add(\"ses\"); \n  stopWord.add(\"seu\"); \n  stopWord.add(\"seus\"); \n  stopWord.add(\"shall\"); \n  stopWord.add(\"she\"); \n  stopWord.add(\"should\"); \n  stopWord.add(\"si\"); \n  stopWord.add(\"sien\"); \n  stopWord.add(\"sienne\"); \n  stopWord.add(\"siennes\"); \n  stopWord.add(\"siens\"); \n  stopWord.add(\"sim\"); \n  stopWord.add(\"simplesmente\"); \n  stopWord.add(\"since\"); \n  stopWord.add(\"sob\"); \n  stopWord.add(\"sobre\"); \n  stopWord.add(\"small\"); \n  stopWord.add(\"soi\"); \n  stopWord.add(\"soi-meme\"); \n  stopWord.add(\"soit\"); \n  stopWord.add(\"some\"); \n  stopWord.add(\"somente\"); \n  stopWord.add(\"sont\"); \n  stopWord.add(\"soon\"); \n  stopWord.add(\"sous\"); \n  stopWord.add(\"still\"); \n  stopWord.add(\"sua\"); \n  stopWord.add(\"suas\"); \n  stopWord.add(\"such\"); \n  stopWord.add(\"suis\"); \n  stopWord.add(\"t\"); \n  stopWord.add(\"ta\"); \n  stopWord.add(\"tal\"); \n  stopWord.add(\"talvez\"); \n  stopWord.add(\"tambem\"); \n  stopWord.add(\"tampouco\"); \n  stopWord.add(\"tandis\"); \n  stopWord.add(\"tant\"); \n  stopWord.add(\"tanta\"); \n  stopWord.add(\"tantas\"); \n  stopWord.add(\"tanto\"); \n  stopWord.add(\"tantos\"); \n  stopWord.add(\"te\"); \n  stopWord.add(\"telle\"); \n\n\n\n  \n\n  stopWord.add(\"telles\"); \n  stopWord.add(\"tem\"); \n  stopWord.add(\"teremos\"); \n  stopWord.add(\"tes\"); \n  stopWord.add(\"teus\"); \n  stopWord.add(\"than\"); \n  stopWord.add(\"that\"); \n  stopWord.add(\"the\"); \n  stopWord.add(\"their\"); \n  stopWord.add(\"themselves\"); \n  stopWord.add(\"then\"); \n  stopWord.add(\"there\"); \n  stopWord.add(\"these\"); \n  stopWord.add(\"they\"); \n  stopWord.add(\"thing\"); \n  stopWord.add(\"this\"); \n  stopWord.add(\"those\"); \n  stopWord.add(\"though\"); \n  stopWord.add(\"through\"); \n  stopWord.add(\"tienne\"); \n  stopWord.add(\"tiennes\"); \n  stopWord.add(\"tiens\"); \n  stopWord.add(\"toda\"); \n  stopWord.add(\"todas\"); \n  stopWord.add(\"todavia\"); \n  stopWord.add(\"today\"); \n  stopWord.add(\"todo\"); \n  stopWord.add(\"todos\"); \n  stopWord.add(\"toi\"); \n  stopWord.add(\"tomara\"); \n  stopWord.add(\"ton\"); \n  stopWord.add(\"to\"); \n  stopWord.add(\"too\"); \n  stopWord.add(\"toujours\"); \n  stopWord.add(\"tous\"); \n  stopWord.add(\"toute\"); \n  stopWord.add(\"toutes\"); \n  stopWord.add(\"tranquila\"); \n  stopWord.add(\"tranquilamente\"); \n  stopWord.add(\"tranquilas\"); \n  stopWord.add(\"tranquilo\"); \n  stopWord.add(\"tranquilos\"); \n  stopWord.add(\"tras\"); \n  stopWord.add(\"tres\"); \n  stopWord.add(\"trop\"); \n  stopWord.add(\"tu\"); \n  stopWord.add(\"tua\"); \n  stopWord.add(\"tuas\"); \n  stopWord.add(\"tudo\"); \n  stopWord.add(\"u\"); \n  stopWord.add(\"ulterior\"); \n  stopWord.add(\"um\"); \n  stopWord.add(\"uma\"); \n  stopWord.add(\"umas\"); \n  stopWord.add(\"un\"); \n  stopWord.add(\"una\"); \n  stopWord.add(\"under\"); \n  stopWord.add(\"uno\"); \n  stopWord.add(\"uns\"); \n  stopWord.add(\"until\"); \n  stopWord.add(\"up\"); \n  stopWord.add(\"upon\"); \n  stopWord.add(\"upres\"); \n  stopWord.add(\"v\"); \n  stopWord.add(\"vai\"); \n  stopWord.add(\"varia\"); \n  stopWord.add(\"varias\"); \n  stopWord.add(\"vario\"); \n  stopWord.add(\"varios\"); \n  stopWord.add(\"vem\"); \n  stopWord.add(\"very\"); \n  stopWord.add(\"vez\"); \n  stopWord.add(\"vezes\"); \n  stopWord.add(\"voce\"); \n  stopWord.add(\"voces\"); \n  stopWord.add(\"vos\"); \n  stopWord.add(\"vossa\"); \n  stopWord.add(\"vossas\"); \n  stopWord.add(\"vosso\"); \n  stopWord.add(\"vossos\"); \n\n\n\n  \n\n  stopWord.add(\"votre\"); \n  stopWord.add(\"votres\"); \n  stopWord.add(\"vous\"); \n  stopWord.add(\"vu\"); \n  stopWord.add(\"vide\"); \n  stopWord.add(\"w\"); \n  stopWord.add(\"was\"); \n  stopWord.add(\"we\"); \n  stopWord.add(\"were\"); \n  stopWord.add(\"what\"); \n  stopWord.add(\"when\"); \n  stopWord.add(\"where\"); \n  stopWord.add(\"which\"); \n  stopWord.add(\"while\"); \n  stopWord.add(\"who\"); \n  stopWord.add(\"whom\"); \n  stopWord.add(\"whose\"); \n  stopWord.add(\"will\"); \n  stopWord.add(\"with\"); \n  stopWord.add(\"within\"); \n  stopWord.add(\"without\"); \n  stopWord.add(\"would\"); \n  stopWord.add(\"www\"); \n  stopWord.add(\"x\"); \n  stopWord.add(\"y\"); \n  stopWord.add(\"yet\"); \n  stopWord.add(\"you\"); \n  stopWord.add(\"your\"); \n  stopWord.add(\"yours\"); \n  stopWord.add(\"yourself\"); \n  stopWord.add(\"yourselves\"); \n  stopWord.add(\"z\"); \n  stopWord.add(\"us\"); \n  stopWord.add(\"ours\"); \n  stopWord.add(\"them\"); \n  stopWord.add(\"theirs\"); \n  stopWord.add(\"am\"); \n  stopWord.add(\"being\"); \n  stopWord.add(\"having\"); \n  stopWord.add(\"does\"); \n  stopWord.add(\"did\"); \n  stopWord.add(\"doing\"); \n  stopWord.add(\"can\"); \n  stopWord.add(\"may\"); \n  stopWord.add(\"might\"); \n  stopWord.add(\"must\"); \n  stopWord.add(\"ought\"); \n  stopWord.add(\"below\"); \n  stopWord.add(\"down\"); \n  stopWord.add(\"off\"); \n  stopWord.add(\"again\"); \n  stopWord.add(\"further\"); \n  stopWord.add(\"once\"); \n  stopWord.add(\"why\"); \n  stopWord.add(\"nor\"); \n  stopWord.add(\"own\"); \n  stopWord.add(\"same\"); \n  stopWord.add(\"so\"); \n  stopWord.add(\"least\"); \n  stopWord.add(\"say\"); \n  stopWord.add(\"said\"); \n  stopWord.add(\"get\"); \n  stopWord.add(\"go\"); \n  stopWord.add(\"goes\"); \n  stopWord.add(\"made\"); \n  stopWord.add(\"make\"); \n  stopWord.add(\"put\"); \n  stopWord.add(\"see\"); \n  stopWord.add(\"seen\"); \n  stopWord.add(\"whether\"); \n  stopWord.add(\"like\"); \n  stopWord.add(\"well\"); \n  stopWord.add(\"even\"); \n  stopWord.add(\"way\"); \n  stopWord.add(\"take\"); \n  stopWord.add(\"two\"); \n  stopWord.add(\"three\"); \n  stopWord.add(\"four\"); \n  stopWord.add(\"five\"); \n  stopWord.add(\"first\"); \n\n\n\n  \n\n  stopWord.add(\"second\"); \n  stopWord.add(\"new\"); \n  stopWord.add(\"old\"); \n  stopWord.add(\"high\"); \n  stopWord.add(\"long\"); \n  return stopWord; \n } \n  \n /** \n  * Checks whether the informed content is a stop word. \n  * \n  * @param word \n  *            the content to be checked. \n  * @return whether the parameter is or not a stop word. \n  * @throws Exception \n  *             unexpected error. \n  */ \n public static boolean isStopWord(final String word) throws Exception { \n  return \nSTOP_WORDS.contains(removeAccent(word.trim().toLowerCase())); \n } \n  \n /** \n  * Clears the string content modifying accented character. \n  * http://www.columbia.edu/kermit/utf8-t1.html \n  * \n  * @param content \n  *            content to be changed. \n  * @return the string without accent. \n  */ \n public static String removeAccent(final String content) { \n  if (content == null || content.trim().isEmpty()) { \n   return content; \n  } \n  final char[] aryLAcento = \n\"\\u00E1\\u00C1\\u00E3\\u00C3\\u00E2\\u00C2\\u00E0\\u00C0\\u00E4\\u00C4\\u00E9\\u00C9\\u00E\nA\\u00CA\\u00E8\\u00C8\\u00EB\\u00CB\\u00ED\\u00CD\\u00EF\\u00CF\\u00EC\\u00CC\\u00EE\\u00C\nE\\u00F3\\u00D3\\u00F5\\u00D5\\u00F4\\u00D4\\u00F2\\u00D2\\u00F6\\u00D6\\u00FA\\u00DA\\u00F\nB\\u00DB\\u00F9\\u00D9\\u00FC\\u00DC\\u00E7\\u00C7\\u00FF\\u0178\\u00FD\\u00DD\\u00F1\\u00D\n1\" \n   .toCharArray(); \n  final char[] aryLSAcento = \n\"aAaAaAaAaAeEeEeEeEiIiIiIiIoOoOoOoOoOuUuUuUuUcCyYyYnN\" \n   .toCharArray(); \n  final char[] aryLConteudo = content.toCharArray(); \n  final StringBuffer stbLRetorno = new StringBuffer(); \n  char chrLCarc; \n  for (int intLIdx = 0; intLIdx &lt;aryLConteudo.length; intLIdx++) \n{ \n   chrLCarc = aryLConteudo[intLIdx]; \n   for (int intLAcento = 0; intLAcento &lt;aryLAcento.length; \nintLAcento++) { \n    if (chrLCarc == aryLAcento[intLAcento]) { \n     chrLCarc = aryLSAcento[intLAcento]; \n     break; \n    } \n   } \n   stbLRetorno.append(chrLCarc); \n  } \n  return stbLRetorno.toString(); \n } \n  \n public static List<String> removeAccentFromStringList(final \nList<String> listOfString) { \n  final int length = (listOfString != null ? listOfString.size() : \n0); \n  List<String> auxList = new ArrayList<String>(0);  \n  if (length > 0) { \n   for (String content : listOfString) { \n    auxList.add(UtilClass.removeAccent(content)); \n   } \n  } \n  return auxList; \n } \n  \n /** \n  * If exists consecutive blank characters replace them for one blank. \n  * \n  * @param content \n  *            content to be changed. \n\n\n\n  \n\n  * @return a string without consecutive blank characters. \n  */ \n public static String removeBlanks(final String content) { \n  return content.replaceAll(\"\\\\s+\", BLANK_SPACE).trim(); \n } \n  \n public static boolean validateFileName(final String fileName) { \n  if (fileName != null &amp;&amp; !fileName.isEmpty()) { \n   String cleanedName = UtilClass.cleanFileName(fileName); \n   if (!fileName.equalsIgnoreCase(cleanedName)) { \n    StringTokenizer tokenizer = new \nStringTokenizer(cleanedName); \n    final int lastElement = tokenizer.countTokens(); \n    int count = 0; \n    while (tokenizer.hasMoreElements()) { \n     String token = tokenizer.nextToken(); \n     count++; \n     if (count == lastElement) { \n      if \n(APP_FILE_EXT.equalsIgnoreCase(token)) { \n       return true; \n      } \n     } \n    } \n   } \n  } \n  return false; \n } \n  \n public static String cleanFileName(final String fileName) { \n  return removePuncts(fileName, \" \"); \n } \n /** \n  * Replacement is \"\"(empty). \n  * @param content \n  * @return \n  */ \n public static String removePuncts(final String content) { \n  return removePuncts(content, \"\"); \n } \n public static String removePuncts(final String content, final String \nreplacement) { \n  return content.replaceAll(\"\\\\p{Punct}\", replacement).trim(); \n } \n  \n public static String removeExtensionFromFileName(final String fileName) \n{ \n  StringBuilder returnName = new StringBuilder(); \n  String cleanedName = cleanFileName(fileName); \n  StringTokenizer tokenizer = new StringTokenizer(cleanedName); \n  final int lastElement = tokenizer.countTokens(); \n  int count = 0; \n  while (tokenizer.hasMoreElements()) { \n   String token = tokenizer.nextToken(); \n   count++; \n   if (count != lastElement) { \n    if (returnName.length() > 0) { \n     returnName.append(\" \"); \n    } \n    returnName.append(token); \n   } \n  } \n  return returnName.toString(); \n } \n \n public static int[] convertArrayIntegerToArrayInt(Integer[] \nintegerArray) { \n  final int length = (integerArray != null ? integerArray.length : \n0); \n  int[] intArray = new int[length]; \n  for (int i=0; i &lt;length; i++) { \n   intArray[i] = integerArray[i].intValue(); \n  } \n  return intArray; \n } \n  \n public static Set<Integer> convertArrayIntToSetInteger(final int[] \nintArray) { \n  final int length = (intArray != null ? intArray.length : 0); \n  final Set<Integer> auxSet = new LinkedHashSet<Integer>(length); \n\n\n\n  \n\n  for (int i=0; i &lt;length; i++) { \n   auxSet.add(intArray[i]); \n  } \n  return auxSet; \n } \n} \n \n\n? Pacote \u201cview\u201d: \n\n? Classe ViewController.java: \npackage view; \n \nimport java.text.MessageFormat; \nimport java.util.List; \n \nimport system.Environment; \nimport system.utils.UtilClass; \nimport view.main.MainPresenter; \nimport view.project.ProjectPresenter; \nimport view.questions.CompetenceQuestionsPresenter; \nimport view.terms.TermsPresenter; \nimport beans.CompetenceQuestionsBean; \nimport beans.ProjectBean; \nimport beans.TermsBean; \nimport data.DataController; \n \npublic class ViewController { \n  \n private Environment environment; \n  \n private MainPresenter mainPresenter; \n private ProjectPresenter projectPresenter; \n private CompetenceQuestionsPresenter cqPresenter; \n private TermsPresenter termsPresenter; \n \n public ViewController(final Environment environment, final ViewParams \nviewParams) { \n  this.environment = environment; \n  this.initPresenters(viewParams); \n } \n \n private void initPresenters(final ViewParams viewParams) { \n  this.mainPresenter = new MainPresenter(this, \nviewParams.getMainForm()); \n  this.projectPresenter = new ProjectPresenter(this, \nviewParams.getProjectForm()); \n  this.cqPresenter = new CompetenceQuestionsPresenter(this, \nviewParams.getCqForm()); \n  this.termsPresenter = new TermsPresenter(this, \nviewParams.getTermsForm()); \n  this.doFirstLoad(); \n } \n  \n private void doFirstLoad() { \n  this.loadProjectView(); \n  final DataController dc = this.environment.getDataController(); \n  if (dc.hasProjectInstance()) { \n   final String projectTitle = dc.getProjectTitle();  \n   this.mainPresenter.setAppTitle( \n    \n MessageFormat.format(UtilClass.APP_OPEN_PROJECT_TAG, projectTitle, \n\"\")); \n  } else { \n   this.setNoOpenProjectMode(); \n  } \n } \n  \n private void loadProjectView() { \n  this.mainPresenter.selectProjectView(); \n  final DataController dc = this.environment.getDataController(); \n  this.projectPresenter.loadBean(dc.getProjectBean()); \n } \n \n public CompetenceQuestionsBean getCompetenceQuestionsBean() { \n  final DataController dc = this.environment.getDataController(); \n  return dc.getCompetenceQuestionsBean(); \n\n\n\n  \n\n } \n  \n public TermsBean getTermsBean() { \n  final DataController dc = this.environment.getDataController(); \n  return dc.getTermsBean(); \n } \n  \n public void loadAllCQs(final CompetenceQuestionsBean bean) { \n  final DataController dc = this.environment.getDataController(); \n  dc.loadAllCQs(bean); \n } \n  \n public void loadCQsByCategory(final CompetenceQuestionsBean bean, \n   final Integer categoryID) { \n  final DataController dc = this.environment.getDataController(); \n  dc.loadCQsByCategory(bean, categoryID); \n } \n  \n public void setMainFormEnabled(final boolean enabled) { \n  this.mainPresenter.setFormEnabled(enabled); \n } \n  \n public void loadOneCategory(final CompetenceQuestionsBean bean, \n   final Integer categoryID) { \n  final DataController dc = this.environment.getDataController(); \n  dc.loadOneCategory(bean, categoryID); \n } \n  \n public void loadOneCQ(final CompetenceQuestionsBean bean, \n   final Integer competenceQuestionID) { \n  final DataController dc = this.environment.getDataController(); \n  dc.loadOneCQ(bean, competenceQuestionID); \n } \n  \n private void setNoOpenProjectMode() { \n  this.mainPresenter.allowViewChanges(false); \n \n this.mainPresenter.setAppTitle(UtilClass.APP_NO_OPEN_PROJECT_TITLE); \n } \n \n public void startNewFile(String fileName, String fileAddress) { \n  final DataController dc = this.environment.getDataController(); \n  dc.startNewFile(fileName, fileAddress); \n  this.doFirstLoad(); \n } \n  \n public void openFile(final String fileName, final String fileAddress) \nthrows Exception { \n  final DataController dc = this.environment.getDataController(); \n  dc.openFile(fileName, fileAddress); \n  this.doFirstLoad(); \n } \n \n public void saveProjectBean(ProjectBean bean) { \n  final DataController dc = this.environment.getDataController(); \n  dc.saveProjectBean(bean); \n  this.loadProjectView(); \n } \n \n public void addCategory(final CompetenceQuestionsBean bean, \n   final String name, final String description) { \n  final DataController dc = this.environment.getDataController(); \n  dc.addCategory(bean, name, description); \n } \n \n public void editCategory(final int idCode, \n   final String name, final String description) { \n  final DataController dc = this.environment.getDataController(); \n  dc.editCategory(idCode, name, description); \n } \n \n public boolean hasCQs(final List<Integer> categoryIDsList) { \n  final DataController dc = this.environment.getDataController(); \n  return dc.hasCQs(categoryIDsList); \n } \n \n public void removeCategories(final CompetenceQuestionsBean bean, final \nList<Integer> categoryIDsList) { \n  final DataController dc = this.environment.getDataController(); \n  dc.removeCategories(bean, categoryIDsList); \n\n\n\n  \n\n } \n \n public void addCompetenceQuestion(final CompetenceQuestionsBean bean, \n   final Integer categoryID, final String question, final \nString answer) { \n  final DataController dc = this.environment.getDataController(); \n  dc.addCompetenceQuestion(bean, categoryID, question, answer); \n } \n \n public void editCompetenceQuestion(final Integer cqID, \n   final String question, final String answer) { \n  final DataController dc = this.environment.getDataController(); \n  dc.editCompetenceQuestion(cqID, question, answer); \n } \n \n public void removeCompetenceQuestions(final CompetenceQuestionsBean \nbean, \n   final Integer categoryID, final List<Integer> cqIDsList) \n{ \n  final DataController dc = this.environment.getDataController(); \n  dc.removeCompetenceQuestions(bean, categoryID, cqIDsList); \n } \n \n public void moveCompetenceQuestions(final CompetenceQuestionsBean bean, \n   final Integer sourceCategoryID, final Integer \ntargetCategoryID, \n   final List<Integer> cqIDsList) { \n  final DataController dc = this.environment.getDataController(); \n  dc.moveCompetenceQuestions(bean, sourceCategoryID, \ntargetCategoryID, cqIDsList); \n } \n \n public void extractTerms(final TermsBean bean, final Integer \ncategoryID) throws Exception { \n  final DataController dc = this.environment.getDataController(); \n  dc.extractTerms(bean, categoryID); \n } \n \n public void removePersistedTerms(final TermsBean bean, \n   final List<Integer> persistedTermIDs) { \n  final DataController dc = this.environment.getDataController(); \n  dc.removePersistedTerms(bean, persistedTermIDs); \n } \n \n public void persistTerms(final TermsBean bean) { \n  final DataController dc = this.environment.getDataController(); \n  dc.persistTerms(bean); \n } \n \n public Boolean persistProject() { \n  final DataController dc = this.environment.getDataController(); \n  if (dc.hasProjectInstance()) { \n   return dc.persistProject(); \n  } else { \n   return null; \n  } \n } \n} \n \n\n? Classe ViewParams.java: \npackage view; \n \nimport view.main.MainForm; \nimport view.project.ProjectForm; \nimport view.questions.CompetenceQuestionsForm; \nimport view.terms.TermsForm; \n \npublic class ViewParams { \n  \n private final MainForm mainForm; \n private final ProjectForm projectForm; \n private final CompetenceQuestionsForm cqForm; \n private final TermsForm termsForm; \n  \n public ViewParams(MainForm mainForm, ProjectForm projectForm, \n   CompetenceQuestionsForm cqForm, TermsForm termsForm) { \n  this.mainForm = mainForm; \n  this.projectForm = projectForm; \n\n\n\n  \n\n  this.cqForm = cqForm; \n  this.termsForm = termsForm; \n } \n \n public MainForm getMainForm() { \n  return mainForm; \n } \n \n public ProjectForm getProjectForm() { \n  return projectForm; \n } \n \n public CompetenceQuestionsForm getCqForm() { \n  return cqForm; \n } \n \n public TermsForm getTermsForm() { \n  return termsForm; \n } \n} \n \n\n? Sub-pacote \u201cmain\u201d: \n\n? Interface MainForm.java: \npackage view.main; \n \nimport system.mvp.PassiveView; \nimport system.utils.UtilClass.MESSAGES; \n \npublic interface MainForm extends PassiveView { \n  \n void close(); \n  \n void setAppTitle(String appTitle); \n  \n void setMainFormEnabled(boolean enabled); \n \n void allowViewChanges(boolean allowed); \n \n void selectProjectView(); \n \n void selectCompetenceQuestionsView(); \n \n void selectTermsView(); \n \n void showMessage(MESSAGES message); \n \n} \n \n\n? Classe MainFormImpl.java: \npackage view.main; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.MESSAGES; \nimport view.ViewController; \n \npublic class MainPresenter extends Presenter { \n \n private ViewController viewController; \n private MainForm form; \n \n public MainPresenter(ViewController viewController, MainForm form) { \n  this.viewController = viewController; \n  this.form = form; \n  this.registerItselfInForm(); \n } \n \n @Override \n protected void registerItselfInForm() { \n  this.form.registerPresenter(this); \n } \n \n @Override \n\n\n\n  \n\n public void fillIn() {} \n \n @Override \n public void fillOut() {} \n \n public void setFormEnabled(boolean enabled) { \n  this.form.setMainFormEnabled(enabled); \n } \n \n public void selectProjectView() { \n  this.form.selectProjectView(); \n } \n public void selectCompetenceQuestionsView() { \n  this.form.selectCompetenceQuestionsView(); \n } \n public void selectTermsView() { \n  this.form.selectTermsView(); \n } \n \n public void allowViewChanges(boolean allowed) { \n  this.form.allowViewChanges(allowed); \n } \n  \n public void setAppTitle(final String appTitle) { \n  this.form.setAppTitle(appTitle); \n } \n \n public void startNewFile(final String fileName, final String \nfileAddress) { \n  this.viewController.startNewFile(fileName, fileAddress); \n } \n \n public void openFile(final String fileName, final String fileAddress) { \n  try { \n   this.viewController.openFile(fileName, fileAddress); \n  } catch (Exception e) { \n   this.form.showMessage(MESSAGES.FAIL_ON_OPEN_PROJECT); \n  } \n } \n \n public void persistProject() { \n  final Boolean retorno = this.viewController.persistProject(); \n  if (retorno == null) { \n  \n this.form.showMessage(UtilClass.MESSAGES.NO_PROJECT_TO_PERSIST); \n  } else if (retorno) { \n  \n this.form.showMessage(UtilClass.MESSAGES.PROJECT_PERSISTED); \n  } else { \n  \n this.form.showMessage(UtilClass.MESSAGES.FAIL_ON_PROJECT_PERSISTENCE); \n  } \n } \n} \n \n\n? Sub-pacote \u201cproject\u201d: \n\n? Interface ProjectForm.java: \npackage view.project; \n \nimport java.util.Date; \nimport java.util.List; \n \nimport system.mvp.PassiveView; \n \npublic interface ProjectForm extends PassiveView { \n  \n String getProjectName(); \n  \n String getProjectAutor(); \n  \n String getProjectPurpose(); \n  \n String getProjectScope(); \n  \n String getProjectFormalityLevel(); \n\n\n\n  \n\n  \n List<String> getProjectUsersDescriptionsList(); \n  \n List<String> getProjectUsesScenariosList(); \n  \n void setProjectName(String value); \n  \n void setProjectCreateDate(Date value); \n  \n void setProjectAutor(String value); \n  \n void setProjectPurpose(String value); \n  \n void setProjectScope(String value); \n  \n void setProjectFormalityLevel(String value); \n  \n void setProjectUsersDescriptionsList(List<String> value); \n  \n void setProjectUsesScenariosList(List<String> value); \n  \n void setEmptyMode(); \n  \n void setViewMode(); \n  \n void setEditMode(); \n  \n} \n \n\n? Classe ProjectFormImpl.java: \npackage view.project; \n \nimport system.mvp.Presenter; \nimport view.ViewController; \nimport beans.ProjectBean; \n \npublic class ProjectPresenter extends Presenter { \n \n private ViewController viewController; \n private ProjectForm form; \n  \n private ProjectBean bean; \n \n public ProjectPresenter(final ViewController viewController, final \nProjectForm form) { \n  this.viewController = viewController; \n  this.form = form; \n  this.registerItselfInForm(); \n } \n \n @Override \n protected void registerItselfInForm() { \n  this.form.registerPresenter(this); \n } \n  \n public void loadBean(ProjectBean bean) { \n  this.bean = bean; \n  this.loadValues(); \n } \n  \n public void loadValues() { \n  if (this.bean != null) { \n   this.bean.clearChanges(); \n   this.fillIn(); \n   this.setFormViewMode(); \n  } else { \n   this.fillEmpty(); \n  } \n } \n  \n public boolean hasChanges() { \n  this.fillOut(); \n  return this.bean.hasChanges(); \n } \n  \n private void fillEmpty() { \n  this.form.setProjectName(null); \n  this.form.setProjectCreateDate(null); \n\n\n\n  \n\n  this.form.setProjectAutor(null); \n  this.form.setProjectPurpose(null); \n  this.form.setProjectScope(null); \n  this.form.setProjectFormalityLevel(null); \n  this.setFormEmptyMode(); \n } \n \n @Override \n public void fillIn() { \n  this.form.setProjectName(this.bean.getName()); \n  this.form.setProjectCreateDate(this.bean.getCreateDate()); \n  this.form.setProjectAutor(this.bean.getAutor()); \n  this.form.setProjectPurpose(this.bean.getPurpose()); \n  this.form.setProjectScope(this.bean.getScope()); \n \n this.form.setProjectFormalityLevel(this.bean.getFormalityLevel()); \n  this.fillInUsersDescriptionsList(); \n  this.fillInUsesScenariosList(); \n } \n \n @Override \n public void fillOut() { \n  this.bean.setName(this.form.getProjectName()); \n  this.bean.setAutor(this.form.getProjectAutor()); \n  this.bean.setPurpose(this.form.getProjectPurpose()); \n  this.bean.setScope(this.form.getProjectScope()); \n \n this.bean.setFormalityLevel(this.form.getProjectFormalityLevel()); \n  this.fillOutUsersDescriptionsList(); \n  this.fillOutUsesScenariosList(); \n } \n  \n private void fillInUsersDescriptionsList() { \n \n this.form.setProjectUsersDescriptionsList(this.bean.getUsersDescription\nsList()); \n } \n private void fillOutUsersDescriptionsList() { \n \n this.bean.setUsersDescriptionList(this.form.getProjectUsersDescriptions\nList()); \n } \n  \n private void fillInUsesScenariosList() { \n \n this.form.setProjectUsesScenariosList(this.bean.getUsesScenariosList())\n; \n } \n private void fillOutUsesScenariosList() { \n \n this.bean.setUsesScenariosList(this.form.getProjectUsesScenariosList())\n; \n } \n  \n public void doEditAction() { \n  this.setFormEditMode(); \n } \n  \n public void doSaveAction() { \n  if (this.hasChanges()) { \n   this.viewController.saveProjectBean(this.bean); \n  } else { \n   this.setFormViewMode(); \n  } \n } \n \n public void doCancelAction() { \n  this.loadValues(); \n } \n  \n private void setFormEmptyMode() { \n  this.form.setEmptyMode(); \n  this.viewController.setMainFormEnabled(true); \n } \n private void setFormViewMode() { \n  this.form.setViewMode(); \n  this.viewController.setMainFormEnabled(true); \n } \n private void setFormEditMode() { \n  this.form.setEditMode(); \n\n\n\n  \n\n  this.viewController.setMainFormEnabled(false); \n } \n} \n \n\n? Sub-pacote \u201cquestions\u201d: \n\n? Interface CompetenceQuestionsForm.java: \npackage view.questions; \n \nimport java.util.List; \nimport java.util.Map; \n \nimport system.mvp.PassiveView; \n \npublic interface CompetenceQuestionsForm extends PassiveView { \n  \n public enum FORM_FIELDS { \n  // LISTING FIELDS: \n  CATEGORY_LIST, \n  CQ_LIST, \n  // CATEGORY DETAILS FIELDS: \n  CATEGORY_NAME, \n  CATEGORY_DESCRIPTION, \n  //CQ DETAILS FIELDS: \n  CQ_QUESTION, \n  CQ_ANSWER \n } \n  \n void setCategoriesList(Map<Integer, String> categories); \n  \n void setCompetenceQuestionsList( \n   Map<Integer, String> questionsMap, \n   Map<Integer, String> answersMap); \n  \n void setModalMode(boolean modalEnabled); \n  \n void showDetailToAddCategory(); \n void showDetailToEditCategory(Integer idCode, String name, String \ndescription); \n void showDetailToRemoveCategory(List<Integer> selectedCategories, \nboolean categoriesHaveCQs); \n  \n void showDetailToAddCompetenceQuestion(); \n void showDetailToEditCompetenceQuestion( \n   Integer idCode, String question, String answer); \n void showDetailToRemoveCompetenceQuestion(List<Integer> \ncompetenceQuestionIDsList); \n void showDetailToMoveCompetenceQuestions(Integer sourceCategoryID, \nList<Integer> selectedIDs, \n   Map<String, Integer> destinationOptionsMap); \n} \n \n\n? Classe CompetenceQuestionsFormImpl.java: \npackage view.questions; \n \nimport java.util.ArrayList; \nimport java.util.LinkedHashMap; \nimport java.util.List; \nimport java.util.Map; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.ValidationErrors; \nimport view.ViewController; \nimport view.questions.CompetenceQuestionsForm.FORM_FIELDS; \nimport beans.CompetenceQuestionsBean; \nimport beans.CompetenceQuestionsBean.OneCategory; \nimport beans.CompetenceQuestionsBean.OneCompetenceQuestion; \nimport data.CQ; \nimport data.Category; \n \npublic class CompetenceQuestionsPresenter extends Presenter { \n \n private ViewController viewController; \n\n\n\n  \n\n private CompetenceQuestionsForm form; \n  \n private CompetenceQuestionsBean bean; \n \n public CompetenceQuestionsPresenter(final ViewController \nviewController, final CompetenceQuestionsForm form) { \n  this.viewController = viewController; \n  this.form = form; \n  this.registerItselfInForm(); \n } \n \n @Override \n protected void registerItselfInForm() { \n  this.form.registerPresenter(this); \n } \n  \n @Override \n public void fillIn() { \n  if (bean == null) { \n   this.bean = \nthis.viewController.getCompetenceQuestionsBean(); \n  } \n  this.loadCategories(); \n  this.loadSelectedCategoryItems(UtilClass.NO_SELECTED_CATEGORY); \n } \n \n @Override \n public void fillOut() { \n  this.bean = null; \n  this.loadCategories(); \n  this.loadSelectedCategoryItems(UtilClass.NO_SELECTED_CATEGORY); \n } \n  \n /*------------------------------------- \n  * M\u00e9todo envolvidos com as Categorias: \n  -------------------------------------*/ \n private void loadCategories() { \n  Map<Integer, String> categoriesMap = new LinkedHashMap<Integer, \nString>(0); \n  if (this.bean != null) { \n   categoriesMap = \nthis.prepareCategoriesMap(this.bean.getCategoriesMap()); \n  } \n  this.form.setCategoriesList(categoriesMap); \n } \n  \n public void doAddCategory() { \n  this.form.showDetailToAddCategory(); \n } \n public void doEditCategory(final Integer categoryID) { \n  if (categoryID != null &amp;&amp; categoryID > 0) { \n   this.viewController.loadOneCategory(this.bean, \ncategoryID); \n   final OneCategory oneCategory = \nthis.bean.getOneCategory(); \n   if (oneCategory != null) { \n   \n this.form.showDetailToEditCategory(oneCategory.getIdCode(), \n      oneCategory.getName(), \noneCategory.getDescription()); \n   } \n  } \n } \n public void doRemoveCategory(final List<Integer> categoryIDsList) { \n  final boolean categoriesHaveCQs = \nthis.viewController.hasCQs(categoryIDsList); \n  this.form.showDetailToRemoveCategory(categoryIDsList, \ncategoriesHaveCQs); \n } \n  \n public void addCategory(final String categoryName, String \ncategoryDescription) { \n  this.viewController.addCategory(this.bean, categoryName, \ncategoryDescription); \n  this.fillIn(); \n } \n  \n public void editCategory(final int categoryID, \n   final String categoryName, final String \ncategoryDescription) { \n\n\n\n  \n\n  this.viewController.editCategory(categoryID, categoryName, \ncategoryDescription); \n  this.fillIn(); \n } \n  \n public void removeCategories(final List<Integer> categoryIDsList) { \n  this.viewController.removeCategories(this.bean, \ncategoryIDsList); \n  this.fillIn(); \n } \n  \n /*---------------------------------------------------- \n  * M\u00e9todos envolvidos com as Perguntas de Compet\u00eancia: \n  ----------------------------------------------------*/ \n public void doAddCQ() { \n  this.form.showDetailToAddCompetenceQuestion(); \n } \n public void doEditCQ(final Integer competenceQuestionID) { \n  if (competenceQuestionID != null &amp;&amp; competenceQuestionID > 0) { \n   this.viewController.loadOneCQ(this.bean, \ncompetenceQuestionID); \n   final OneCompetenceQuestion oneCQ = \nthis.bean.getOneCompetenceQuestion(); \n   if (oneCQ != null) { \n    this.form.showDetailToEditCompetenceQuestion( \n      oneCQ.getIdCode(), \noneCQ.getQuestion(), oneCQ.getAnswer()); \n   } \n  } \n } \n public void doRemoveCQ(final List<Integer> competenceQuestionIDsList) { \n \n this.form.showDetailToRemoveCompetenceQuestion(competenceQuestionIDsLis\nt); \n } \n  \n public void doMoveCQ(Integer sourceCategoryID, List<Integer> \nselectedIDs) { \n  this.form.showDetailToMoveCompetenceQuestions(sourceCategoryID, \nselectedIDs, \n   \n this.bean.getAvailableCategoriesToMove(sourceCategoryID));   \n } \n  \n public void addCompetenceQuestion(final Integer categoryID, \n   final String question, final String answer) { \n  this.viewController.addCompetenceQuestion(this.bean, categoryID, \nquestion, answer); \n \n this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); \n } \n  \n public void editCompetenceQuestion(final Integer competenceQuestionID, \n   final String question, final String answer) { \n  this.viewController.editCompetenceQuestion(competenceQuestionID, \nquestion, answer); \n \n this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); \n } \n  \n public void removeCompetenceQuestions(final Integer categoryID, \n   final List<Integer> competenceQuestionIDsList) { \n  this.viewController.removeCompetenceQuestions(this.bean, \ncategoryID, competenceQuestionIDsList); \n \n this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); \n } \n  \n public void moveCompetenceQuestions(final Integer sourceCategoryID, \n   final Integer targetCategoryID, final List<Integer> \ncqIDsList) { \n  this.viewController.moveCompetenceQuestions(this.bean, \nsourceCategoryID, targetCategoryID, cqIDsList); \n \n this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); \n } \n  \n /*---------------------------------------------------------------------\n-------- \n\n\n\n  \n\n  * M\u00e9todos envolvidos tanto com Categorias quanto com Perguntas de \nCompet\u00eancia: \n  ----------------------------------------------------------------------\n-------*/ \n public void loadSelectedCategoryItems(final int categoryID) { \n  final Map<Integer, CQ> mapOfCQ; \n  switch (categoryID) { \n  case UtilClass.NO_SELECTED_CATEGORY: \n   mapOfCQ = null; \n   break; \n  case UtilClass.ALL_CATEGORIES_ID: \n   this.viewController.loadAllCQs(this.bean); \n   mapOfCQ = this.bean.getCompetenceQuestionsMap(); \n   break; \n  default: \n   this.viewController.loadCQsByCategory(this.bean, \ncategoryID); \n   mapOfCQ = this.bean.getCompetenceQuestionsMap(); \n   break; \n  } \n  this.loadCompetenceQuestions(mapOfCQ); \n } \n  \n private void loadCompetenceQuestions(final Map<Integer, CQ> mapOfCQ) { \n  CQsViewObject cqsViewObject = null; \n  if (mapOfCQ != null) { \n   cqsViewObject = this.prepareCQsMaps(mapOfCQ); \n  } \n  Map<Integer, String> questionsMap = null; \n  Map<Integer, String> answersMap = null; \n  if (cqsViewObject != null) { \n   questionsMap = cqsViewObject.getMapOfQuestionString(); \n   answersMap = cqsViewObject.getMapOfAnswerString(); \n  } \n  this.form.setCompetenceQuestionsList(questionsMap, answersMap); \n } \n  \n /*----------------------- \n  * M\u00e9todos preparat\u00f3rios: \n  -----------------------*/ \n private Map<Integer, String> prepareCategoriesMap(final Map<Integer, \nCategory> mapOfCategory) { \n  final int length = (mapOfCategory != null ? mapOfCategory.size() \n: 0); \n  Map<Integer, String> mapOfString = new LinkedHashMap<Integer, \nString>(length); \n  if (length > 0) { \n   mapOfString.put(UtilClass.ALL_CATEGORIES_ID, \nUtilClass.ALL_CATEGORIES_LABEL); \n   final List<Category> categories = new \nArrayList<Category>(mapOfCategory.values()); \n   for (Category category : categories) { \n    mapOfString.put(category.getIdCode(), \ncategory.getName()); \n   } \n  } \n  return mapOfString; \n } \n  \n private CQsViewObject prepareCQsMaps(final Map<Integer, CQ> mapOfCQ) { \n  final int length = (mapOfCQ != null ? mapOfCQ.size() : 0); \n  Map<Integer, String> mapOfQuestionString = new \nLinkedHashMap<Integer, String>(length); \n  Map<Integer, String> mapOfAnswerString = new \nLinkedHashMap<Integer, String>(0); \n   \n  if (length > 0) { \n   final List<CQ> cqList = new \nArrayList<CQ>(mapOfCQ.values()); \n   for (CQ cq : cqList) { \n    final Integer key = cq.getIdCode(); \n    mapOfQuestionString.put(key, \ncq.getQuestion().getSentence()); \n    final String answer = \ncq.getAnswer().getSentence(); \n    if (!UtilClass.isNullOrEmpty(answer)) { \n     mapOfAnswerString.put(key, answer); \n    } \n   } \n  } \n\n\n\n  \n\n  return new CQsViewObject(mapOfQuestionString, \nmapOfAnswerString); \n } \n  \n /** \n  * Objeto interno para retorno, a partir do m\u00e9todo preparat\u00f3rio \n  * dos mapeamentos das perguntas e respostas ao m\u00e9todo de envio ao \nform. \n  */ \n private class CQsViewObject { \n   \n  private final Map<Integer, String> mapOfQuestionString; \n  private final Map<Integer, String> mapOfAnswerString; \n   \n  public CQsViewObject(final Map<Integer, String> \nmapOfQuestionString, \n    final Map<Integer, String> mapOfAnswerString) { \n   this.mapOfQuestionString = mapOfQuestionString; \n   this.mapOfAnswerString = mapOfAnswerString; \n  } \n \n  public Map<Integer, String> getMapOfQuestionString() { \n   return mapOfQuestionString; \n  } \n \n  public Map<Integer, String> getMapOfAnswerString() { \n   return mapOfAnswerString; \n  } \n   \n } \n  \n public void setModalMode(boolean modalEnabled) { \n  this.viewController.setMainFormEnabled(!modalEnabled); \n  this.form.setModalMode(modalEnabled); \n } \n \n public Map<FORM_FIELDS, List<ValidationErrors>> validateCategoryDetail( \n   final Integer idCode, final String name, final String \ndescription) { \n  Map<FORM_FIELDS, List<ValidationErrors>> errors = \n   new LinkedHashMap<FORM_FIELDS, \nList<ValidationErrors>>(0); \n   \n  if (name == null || name.trim().isEmpty()) { \n   errors.put(FORM_FIELDS.CATEGORY_NAME, \n    \n UtilClass.getOneItemList(ValidationErrors.NULL_FIELD)); \n  } else if (this.bean.existCategoryName(idCode, name)) { \n   errors.put(FORM_FIELDS.CATEGORY_NAME, \n    \n UtilClass.getOneItemList(ValidationErrors.EXISTED_VALUE)); \n  } \n  return errors; \n } \n \n public Map<FORM_FIELDS, List<ValidationErrors>> validateCQDetail( \n   final Integer idCode, final String question, final \nString answer) { \n  Map<FORM_FIELDS, List<ValidationErrors>> errors = \n   new LinkedHashMap<FORM_FIELDS, \nList<ValidationErrors>>(0); \n   \n  if (question == null || question.trim().isEmpty()) { \n   errors.put(FORM_FIELDS.CQ_QUESTION, \n    \n UtilClass.getOneItemList(ValidationErrors.NULL_FIELD)); \n  } \n  return errors; \n } \n} \n \n\n? Sub-pacote \u201cterms\u201d: \n\n? Interface TermsForm.java: \npackage view.terms; \n \n\n\n\n  \n\nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \n \nimport system.mvp.PassiveView; \nimport system.utils.UtilClass.MESSAGES; \n \npublic interface TermsForm extends PassiveView { \n  \n public enum OrderByOptions { \n  ALPHABET(\"Alphabet\"), \n  FREQUENCY(\"Frequency\"), \n  POSITION(\"Position\"); \n   \n  private final String label; \n   \n  private OrderByOptions(final String label) { \n   this.label = label; \n  } \n \n  public String getLabel() { \n   return label; \n  } \n   \n  public static OrderByOptions getOptionByOrdinal(final int \nordinal) { \n   if (ALPHABET.ordinal() == ordinal) { \n    return ALPHABET; \n   } else if (FREQUENCY.ordinal() == ordinal) { \n    return FREQUENCY; \n   } else { \n    return POSITION; \n   } \n  } \n } \n  \n OrderByOptions getOrderByOption(); \n \n List<String> getNotOrderedTerms(); \n  \n List<String> getOrderedTerms(); \n  \n void setModalMode(boolean modalEnabled); \n \n void setExtractedTermsList(Map<String, String> extractedTermsMap); \n \n void setChosenTermsList(Map<String, String> chosenTermsMap); \n \n void setTermsPersistenceNeed(boolean needed); \n \n void showDetailToExtractTerms(Map<String, Integer> \navailableCategoriesToExtract); \n \n void showDetailToRemoveTerms(List<String> termsList); \n  \n void showDetailToOrderTerms(List<String> orderedTerms, List<String> \nnotOrderedTerms); \n  \n void showException(MESSAGES exceptionEnum); \n \n void finishOrderTerms(); \n  \n void showDetailToCombineTerms(List<String> termsList, \n   Set<Integer> commonQuestions, Set<Integer> \ncommonAnswers); \n \n void finishCombineTerms(MESSAGES message); \n \n} \n \n\n? Classe TermsFormImpl.java: \npackage view.terms; \n \nimport java.text.MessageFormat; \nimport java.util.ArrayList; \nimport java.util.Collection; \nimport java.util.LinkedHashMap; \nimport java.util.LinkedHashSet; \n\n\n\n  \n\nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.MESSAGES; \nimport system.utils.UtilClass.ValidationErrors; \nimport view.ViewController; \nimport view.terms.TermsForm.OrderByOptions; \nimport beans.TermsBean; \nimport beans.TermsBean.MappedTerm; \n \npublic class TermsPresenter extends Presenter { \n \n private ViewController viewController; \n private TermsForm form; \n  \n private TermsBean bean; \n \n public TermsPresenter(final ViewController viewController, final \nTermsForm form) { \n  this.viewController = viewController; \n  this.form = form; \n  this.registerItselfInForm(); \n } \n \n @Override \n protected void registerItselfInForm() { \n  this.form.registerPresenter(this); \n } \n \n @Override \n public void fillIn() { \n  if (this.bean == null) { \n   this.bean = this.viewController.getTermsBean(); \n  } \n  this.loadChosenTerms(); \n  this.loadExtractedTerms(); \n  this.defineTermsPersistenceNeed(); \n } \n \n @Override \n public void fillOut() { \n  this.bean = null; \n  this.loadChosenTerms(); \n  this.loadExtractedTerms(); \n } \n  \n private void loadExtractedTerms() { \n  Map<String, String> extractedTermsMap = new \nLinkedHashMap<String, String>(0); \n  if (this.bean != null) { \n   extractedTermsMap = this.prepareTermsMap( \n    \n this.bean.valuesOfExtractedTermsMap(this.form.getOrderByOption())); \n  } \n  this.form.setExtractedTermsList(extractedTermsMap); \n } \n \n private void loadChosenTerms() { \n  Map<String, String> chosenTermsMap = new LinkedHashMap<String, \nString>(0); \n  if (this.bean != null) { \n   chosenTermsMap = this.prepareTermsMap( \n    \n this.bean.valuesOfChosenTermsMap(this.form.getOrderByOption())); \n  } \n  this.form.setChosenTermsList(chosenTermsMap); \n } \n  \n private Map<String, String> prepareTermsMap(final \nCollection<MappedTerm> valuesOfMap) { \n  final int length = (valuesOfMap != null ? valuesOfMap.size() : \n0); \n  Map<String, String> mapStringToString = new \nLinkedHashMap<String, String>(length); \n  if (length > 0) { \n   for (MappedTerm mappedTerm : valuesOfMap) { \n\n\n\n  \n\n    final StringBuilder strBuilder = new \nStringBuilder( \n      mappedTerm.getTerm() + \nUtilClass.TERMS_INIT_DETAILS_TAG); \n    final Integer idCode = mappedTerm.getIdCode(); \n    if (idCode != null) { \n     strBuilder.append( \n      \n MessageFormat.format(UtilClass.TERMS_IDCODE_TAG, idCode)); \n    } \n    if (mappedTerm.getOriginQuestions().size() > 0) { \n     strBuilder.append( \n      \n MessageFormat.format(UtilClass.TERMS_ORIGIN_QUESTIONS_TAG,  \n      \n mappedTerm.getOriginQuestions().toString())); \n    } \n    if (mappedTerm.getOriginAnswers().size() > 0) { \n     strBuilder.append( \n      \n MessageFormat.format(UtilClass.TERMS_ORIGIN_ANSWERS_TAG, \n      \n mappedTerm.getOriginAnswers().toString())); \n    } \n    final Integer order = \nmappedTerm.getOrderPosition(); \n    if (order != null) { \n     strBuilder.append( \n      \n MessageFormat.format(UtilClass.TERMS_ORDER_TAG, order)); \n    } \n    mapStringToString.put(mappedTerm.getTerm(), \nstrBuilder.toString()); \n   } \n  } \n  return mapStringToString; \n } \n  \n private TermsOrderListsObject prepareTermsMapToOrder() { \n  final Collection<MappedTerm> valuesOfMap = \nthis.bean.valuesOfChosenTermsMap(OrderByOptions.POSITION); \n  final int length = (valuesOfMap != null ? valuesOfMap.size() : \n0); \n  List<String> orderedTerms = null; \n  List<String> notOrderedTerms = null; \n  if (length > 0) { \n   orderedTerms = new ArrayList<String>(0); \n   notOrderedTerms = new ArrayList<String>(0); \n   for (MappedTerm mappedTerm : valuesOfMap) { \n    final Integer position = \nmappedTerm.getOrderPosition(); \n    final String term = \nUtilClass.formatTermsMapKey(mappedTerm.getTerm()); \n    if (position != null) { \n     orderedTerms.add(term); \n    } else { \n     notOrderedTerms.add(term); \n    } \n   } \n  } \n  return new TermsOrderListsObject(orderedTerms, notOrderedTerms); \n } \n \n private void defineTermsPersistenceNeed() { \n  final boolean needed; \n  if (this.bean != null) { \n   needed = !this.bean.isChosenEqualsInitMap(); \n  } else { \n   needed = false; \n  } \n  this.form.setTermsPersistenceNeed(needed); \n } \n  \n private class TermsOrderListsObject { \n  private final List<String> orderedTerms; \n  private final List<String> notOrderedTerms; \n   \n  public TermsOrderListsObject(final List<String> orderedTerms, \n    final List<String> notOrderedTerms) { \n   this.orderedTerms = orderedTerms; \n\n\n\n  \n\n   this.notOrderedTerms = notOrderedTerms; \n  } \n \n  public List<String> getOrderedTerms() { \n   return orderedTerms; \n  } \n \n  public List<String> getNotOrderedTerms() { \n   return notOrderedTerms; \n  } \n } \n  \n /*--------------------------- \n  * Buttons Incomming Methods: \n  ---------------------------*/ \n public void doExtractTerms() { \n \n this.form.showDetailToExtractTerms(this.bean.getAvailableCategoriesToEx\ntract()); \n } \n  \n public void doRemoveTerm(final List<String> termsList) { \n  this.form.showDetailToRemoveTerms(termsList); \n } \n  \n public void doOrderTerms() { \n  List<String> orderedTerms = null; \n  List<String> notOrderedTerms = null; \n  if (this.bean != null) { \n   final TermsOrderListsObject tolo = \n    this.prepareTermsMapToOrder(); \n   orderedTerms = tolo.getOrderedTerms(); \n   notOrderedTerms = tolo.getNotOrderedTerms(); \n  } \n  this.form.showDetailToOrderTerms(orderedTerms, notOrderedTerms); \n } \n  \n public void doConfirmOrderedTerms() { \n  final Map<String, MappedTerm> chosenTermsMap = \nthis.bean.getChosenTermsMap(); \n   \n  final List<String> notOrderedTermsList = \nthis.form.getNotOrderedTerms(); \n  if (notOrderedTermsList != null &amp;&amp; notOrderedTermsList.size() > \n0) { \n   for (int i=0; i &lt;notOrderedTermsList.size(); i++) { \n    final String term = \nUtilClass.formatTermsMapKey(notOrderedTermsList.get(i)); \n    chosenTermsMap.get(term).setOrderPosition(null); \n   } \n  } \n \n  final List<String> orderedTermsList = \nthis.form.getOrderedTerms(); \n  if (orderedTermsList != null &amp;&amp; orderedTermsList.size() > 0) { \n   for (int i=0; i &lt;orderedTermsList.size(); i++) { \n    final String term = \nUtilClass.formatTermsMapKey(orderedTermsList.get(i)); \n    chosenTermsMap.get(term).setOrderPosition(i+1); \n   } \n  } \n   \n  this.loadChosenTerms(); \n  this.form.finishOrderTerms(); \n } \n  \n public void doCombineTerms(final List<String> termsList) { \n  if (termsList != null &amp;&amp; termsList.size() > 0) { \n   final Map<String, MappedTerm> extractedTermsMap = \nthis.bean.getExtractedTermsMap(); \n   final Map<Integer, Integer> mapQuestions = new \nLinkedHashMap<Integer, Integer>(0); \n   final Map<Integer, Integer> mapAnswers = new \nLinkedHashMap<Integer, Integer>(0); \n    \n   for (String strTerm : termsList) { \n    final String term = \nUtilClass.formatTermsMapKey(strTerm); \n    final MappedTerm mappedTerm = \nextractedTermsMap.get(term); \n\n\n\n  \n\n    this.appendOrigins(mapQuestions, \nmappedTerm.getOriginQuestions()); \n    this.appendOrigins(mapAnswers, \nmappedTerm.getOriginAnswers()); \n   } \n    \n   final int commonNeededQuant = termsList.size(); \n   final Set<Integer> commonQuestions = \nthis.compareOrigins(mapQuestions, commonNeededQuant); \n   final Set<Integer> commonAnswers = \nthis.compareOrigins(mapAnswers, commonNeededQuant); \n    \n   if (commonQuestions.size() > 0 || commonAnswers.size() > \n0) { \n    this.form.showDetailToCombineTerms(termsList, \ncommonQuestions, commonAnswers); \n   } else { \n   \n this.form.showException(MESSAGES.NO_COMMON_ORIGINS); \n   } \n  } \n } \n \n private void appendOrigins(final Map<Integer, Integer> mapOrigins, \n   final Set<Integer> originSet) { \n  if (mapOrigins != null &amp;&amp; originSet != null) { \n   for (Integer origin : originSet) { \n    if (mapOrigins.containsKey(origin)) { \n     int quant = mapOrigins.get(origin); \n     mapOrigins.put(origin, ++quant); \n    } else { \n     mapOrigins.put(origin, 1); \n    } \n   } \n  } \n } \n  \n private Set<Integer> compareOrigins(final Map<Integer, Integer> \nmapOrigins, \n   final int commonNeededQuant) { \n  final Set<Integer> commonOrigins = new \nLinkedHashSet<Integer>(0); \n  for (Integer origin : mapOrigins.keySet()) { \n   if (commonNeededQuant == mapOrigins.get(origin)) { \n    commonOrigins.add(origin); \n   } \n  } \n  return commonOrigins; \n } \n  \n public void setModalMode(boolean modalEnabled) { \n  this.viewController.setMainFormEnabled(!modalEnabled); \n  this.form.setModalMode(modalEnabled); \n  if (!modalEnabled) { \n   this.defineTermsPersistenceNeed(); \n  } \n } \n  \n public void changeListsOrdenation() { \n  this.loadExtractedTerms(); \n  this.loadChosenTerms(); \n } \n  \n public void extractTerms(final Integer categoryID) { \n  try { \n   this.viewController.extractTerms(this.bean, categoryID); \n   this.loadExtractedTerms(); \n  } catch (Exception e) { \n  \n this.form.showException(UtilClass.MESSAGES.EXTRACT_TERMS_EXCEPTION); \n   e.printStackTrace();  \n  } \n } \n \n public void addExtractedTerms(final List<String> termsList) { \n  this.bean.moveTermsToChosenMap(termsList); \n  this.loadExtractedTerms(); \n  this.loadChosenTerms(); \n  this.defineTermsPersistenceNeed(); \n } \n\n\n\n  \n\n  \n public void addCombinedTerms(final List<String> combinedTermsList, \n   final Set<Integer> commonQuestions, final Set<Integer> \ncommonAnswers) { \n  MESSAGES message = null; \n  try { \n   this.bean.addCombinedTermsToChosenMap( \n     combinedTermsList, commonQuestions, \ncommonAnswers); \n   this.loadChosenTerms(); \n   this.defineTermsPersistenceNeed(); \n  } catch (Exception ex) { \n   if \n(ValidationErrors.EXISTED_VALUE.toString().equals(ex.getMessage())) { \n    message = MESSAGES.TERM_ALLREADY_EXIST; \n   } else { \n    message = MESSAGES.COMBINE_TERMS_EXCEPTION; \n   } \n  } finally { \n   this.form.finishCombineTerms(message); \n  } \n } \n \n public void removeChosenTerms(final List<String> termsList) { \n  final List<Integer> persistedTermIDs = \n   this.bean.removeNotPersistedChosenTerms(termsList); \n  if (persistedTermIDs.size() > 0) { \n   this.viewController.removePersistedTerms(this.bean, \npersistedTermIDs); \n  } \n  this.loadExtractedTerms(); \n  this.loadChosenTerms(); \n  this.defineTermsPersistenceNeed(); \n } \n \n public void persistTerms() { \n  this.viewController.persistTerms(this.bean); \n  this.loadChosenTerms(); \n  this.defineTermsPersistenceNeed(); \n } \n} \n \n\n? Projeto \u201cView-CQPlugin\u201d \u2014 projeto de camada visual \n\npara a aplica\u00e7\u00e3o proposta. \n \n\n? Pacote \u201cgui\u201d: \n\n? Classe CompetenceQuestionsFormImpl.java: \npackage gui; \n \nimport java.awt.Dimension; \nimport java.awt.FlowLayout; \nimport java.awt.GridBagConstraints; \nimport java.awt.GridBagLayout; \nimport java.awt.Insets; \nimport java.util.ArrayList; \nimport java.util.LinkedHashMap; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Vector; \n \nimport javax.swing.JButton; \nimport javax.swing.JDesktopPane; \nimport javax.swing.JInternalFrame; \nimport javax.swing.JLabel; \nimport javax.swing.JList; \nimport javax.swing.JOptionPane; \nimport javax.swing.JPanel; \nimport javax.swing.JScrollPane; \nimport javax.swing.JSplitPane; \nimport javax.swing.JTextArea; \nimport javax.swing.JTextField; \n\n\n\n  \n\nimport javax.swing.WindowConstants; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.ValidationErrors; \nimport view.questions.CompetenceQuestionsForm; \nimport view.questions.CompetenceQuestionsPresenter; \n \npublic class CompetenceQuestionsFormImpl extends JDesktopPane implements \n  CompetenceQuestionsForm { \n \n private static final long serialVersionUID = 1L; \n  \n private static final String NEW_CATEGORY_TITLE = \"New Category\"; \n private static final String EDIT_CATEGORY_TITLE = \"Edit Category\"; \n  \n private static final String NEW_CQ_TITLE = \"New Competence Question\"; \n private static final String EDIT_CQ_TITLE = \"Edit Competence Question\"; \n  \n private static final String REMOVE_CATEGORY_MAIN_TEXT = \n  \"You really want to remove the selected category(ies)?\"; \n private static final String REMOVE_CATEGORY_PROCEDURE_TEXT_LINE_1 = \n  \"If there are competence questions in this(ese) category(ies),\"; \n private static final String REMOVE_CATEGORY_PROCEDURE_TEXT_LINE_2 = \n  \"they will be moved to the default category.\"; \n  \n private CategoryParams filledInCategoryParams = null; \n private List<Integer> selectedCategoriesToRemove = null; \n private CQParams filledInCQParams = null; \n  \n private CompetenceQuestionsPresenter presenter; \n private JSplitPane jSplitPane = null; \n private JPanel panelCategories = null; \n private JPanel panelCQs = null; \n private JLabel captionCategoriesPanel = null; \n private JButton buttonAddCategory = null; \n private JButton buttonEditCategory = null; \n private JButton buttonRemoveCategory = null; \n private JScrollPane scrollPaneCategories = null; \n private JLabel captionCQsPanel = null; \n private JButton buttonAddCQ = null; \n private JButton buttonEditCQ = null; \n private JButton buttonRemoveCQ = null; \n private JScrollPane scrollPaneCQs = null; \n private JListCategories jListCategories = null; \n private JListCQs jListCQs = null; \n private JInternalFrame jInternalFrameCategoryDetail = null; \n private JPanel jContentPaneCategoryDetail = null; \n private JLabel captionCategDetailName = null; \n private JTextField fieldCategDetailName = null; \n private JLabel captionCategDetailDescription = null; \n private JScrollPane scrollPaneCategDetailDescription = null; \n private JTextArea fieldCategDetailDescription = null; \n private JPanel bottomBarCategDetail = null; \n private JButton buttonCategDetailConfirm = null; \n private JButton buttonCategDetailCancel = null; \n private JLabel infoRequiredCategDetail = null; \n private JInternalFrame jInternalFrameRemoveCategory = null; \n private JPanel jContentPaneRemoveCategory = null; \n private JPanel bottomBarRemoveCateg = null; \n private JButton buttonRemoveCategConfirm = null; \n private JButton buttonRemoveCategCancel = null; \n private JLabel labelRemoveCategProcedureLine1 = null; \n private JLabel labelRemoveCategMainLine = null; \n private JLabel labelRemoveCategProcedureLine2 = null; \n private JInternalFrame jInternalFrameCQDetail = null; \n private JPanel jContentPaneCQDetail = null; \n private JLabel captionCQDetailQuestion = null; \n private JTextField fieldCQDetailQuestion = null; \n private JLabel captionCQDetailAnswer = null; \n private JTextField fieldCQDetailAnswer = null; \n private JPanel bottomBarCQDetail = null; \n private JButton buttonCQDetailConfirm = null; \n private JButton buttonCQDetailCancel = null; \n private JLabel infoRequiredCQDetail = null; \n private JButton buttonMoveCQ = null; \n \n public CompetenceQuestionsFormImpl() { \n  super(); \n  initialize(); \n\n\n\n  \n\n } \n \n private void initialize() { \n  GridBagConstraints gridBagConstraints = new \nGridBagConstraints(); \n  gridBagConstraints.fill = GridBagConstraints.BOTH; \n  gridBagConstraints.gridy = 0; \n  gridBagConstraints.weightx = 1.0; \n  gridBagConstraints.weighty = 1.0; \n  gridBagConstraints.gridx = 0; \n  this.setSize(500, 300); \n  this.setLayout(new GridBagLayout()); \n  this.add(getJSplitPane(), gridBagConstraints); \n } \n  \n private void showInfoMessage(final String message) { \n  JOptionPane.showMessageDialog(this, message); \n } \n  \n /*------------------- \n  * Overrided Methods: \n  -------------------*/ \n @Override \n public void setVisible(final boolean flag) { \n  super.setVisible(flag); \n  if (this.presenter != null) { \n   if (flag) { \n    this.presenter.fillIn(); \n   } else { \n    this.presenter.fillOut(); \n   } \n  } \n } \n  \n /*------------------- \n  * Interface Methods: \n  -------------------*/ \n @Override \n public&lt;T extends Presenter> void registerPresenter(T presenter) { \n  this.presenter = (CompetenceQuestionsPresenter)presenter; \n } \n \n @Override \n public void setCategoriesList(Map<Integer, String> categories) { \n  this.jListCategories.setData(categories); \n } \n \n @Override \n public void setCompetenceQuestionsList( \n   Map<Integer, String> questionsMap, \n   Map<Integer, String> answersMap) { \n  this.jListCQs.setData(questionsMap, answersMap); \n } \n  \n @Override \n public void setModalMode(boolean modalEnabled) { \n  final boolean enabled = !modalEnabled; \n   \n  this.jSplitPane.setEnabled(enabled); \n   \n  this.jListCategories.setEnabled(enabled); \n  this.buttonAddCategory.setEnabled(enabled); \n  this.buttonEditCategory.setEnabled(enabled); \n  this.buttonRemoveCategory.setEnabled(enabled); \n   \n  this.jListCQs.setEnabled(enabled); \n  this.buttonAddCQ.setEnabled(enabled); \n  this.buttonEditCQ.setEnabled(enabled); \n  this.buttonRemoveCQ.setEnabled(enabled); \n } \n  \n @Override \n public void showDetailToAddCategory() { \n  this.showCategoryDetail(true, null); \n } \n  \n @Override \n public void showDetailToEditCategory(final Integer idCode, \n   final String name, final String description) { \n\n\n\n  \n\n  this.showCategoryDetail(false, new CategoryParams(idCode, name, \ndescription)); \n } \n  \n @Override \n public void showDetailToRemoveCategory(final List<Integer> \nselectedCategories, \n   final boolean categoriesHaveCQs) { \n  this.selectedCategoriesToRemove = selectedCategories; \n  this.showRemoveCategory(categoriesHaveCQs); \n } \n  \n @Override \n public void showDetailToAddCompetenceQuestion() { \n  this.showCQDetail(true, null); \n } \n \n @Override \n public void showDetailToEditCompetenceQuestion(final Integer idCode, \n   final String question, final String answer) { \n  this.showCQDetail(false, new CQParams(idCode, question, \nanswer)); \n } \n  \n @Override \n public void showDetailToRemoveCompetenceQuestion(final List<Integer> \ncompetenceQuestionIDsList) { \n  final String title = \"Removing competence question...\"; \n  final String message = \n   \"Are you sure you want to remove the selected \nquestions?\\n\" + \n    \"If there are answers to them, these will be \nremoved too.\"; \n  final int choice = JOptionPane.showConfirmDialog( \n    CompetenceQuestionsFormImpl.this, \n    message, title, JOptionPane.OK_CANCEL_OPTION); \n  if (choice == JOptionPane.OK_OPTION) { \n   final Integer categoryID = \njListCategories.getSelectedDataID(); \n   this.presenter.removeCompetenceQuestions(categoryID, \ncompetenceQuestionIDsList); \n  } \n } \n  \n @Override \n public void showDetailToMoveCompetenceQuestions(final Integer \nsourceCategoryID, final List<Integer> selectedIDs, \n   final Map<String, Integer> destinationOptionsMap) { \n  if (destinationOptionsMap != null &amp;&amp; \ndestinationOptionsMap.size() > 0) { \n   String[] destinations = \ndestinationOptionsMap.keySet().toArray(new String[]{}); \n   final String choice = \nthis.showMoveCQsDialog(destinations); \n   if (choice != null &amp;&amp; !choice.isEmpty()) { \n    final Integer targetCategoryID = \ndestinationOptionsMap.get(choice); \n   \n presenter.moveCompetenceQuestions(sourceCategoryID, targetCategoryID, \nselectedIDs); \n   } \n  } else { \n   this.showInfoMessage( \n     \"There aren't categories available to \nmove\\n\" + \n     \"the selected competence questions.\"); \n  } \n } \n  \n /*--------------------------------- \n  * Components manipulation methods: \n  ---------------------------------*/ \n private void showCategoryDetail(final boolean newCategory, final \nCategoryParams params) { \n  if (this.jInternalFrameCategoryDetail == null) { \n   this.add(this.getJInternalFrameCategoryDetail(), null); \n  } \n  this.jInternalFrameCategoryDetail.setTitle( \n    newCategory ? NEW_CATEGORY_TITLE : \nEDIT_CATEGORY_TITLE); \n\n\n\n  \n\n  this.fillInCategoryDetail(params); \n  this.jInternalFrameCategoryDetail.show(); \n } \n  \n private void fillInCategoryDetail(final CategoryParams params) { \n  if (this.jInternalFrameCategoryDetail != null) { \n   String name = null; \n   String description = null; \n   if (params != null) { \n    name = params.getName(); \n    description = params.getDescription(); \n   } \n   this.fieldCategDetailName.setText(name); \n   this.fieldCategDetailDescription.setText(description); \n    \n   this.filledInCategoryParams = params; \n  } \n } \n  \n private CategoryParams fillOutCategoryDetail() { \n  if (this.jInternalFrameCategoryDetail != null) { \n   final String name = this.fieldCategDetailName.getText(); \n   final String description = \nthis.fieldCategDetailDescription.getText(); \n   final Integer idCode = (this.filledInCategoryParams != \nnull ? \n     this.filledInCategoryParams.getIdCode() : \nnull); \n   return new CategoryParams(idCode, name, description); \n  } \n  return null; \n } \n  \n private void showRemoveCategory(final boolean categoriesHaveCQs) { \n  if (this.jInternalFrameRemoveCategory == null) { \n   this.add(this.getJInternalFrameRemoveCategory(), null); \n  } \n  final String mainLabel = REMOVE_CATEGORY_MAIN_TEXT; \n  final String procedureLine1 = \nREMOVE_CATEGORY_PROCEDURE_TEXT_LINE_1; \n  final String procedureLine2 = \nREMOVE_CATEGORY_PROCEDURE_TEXT_LINE_2; \n  this.labelRemoveCategMainLine.setText(mainLabel); \n  this.labelRemoveCategProcedureLine1.setText(procedureLine1); \n  this.labelRemoveCategProcedureLine2.setText(procedureLine2); \n  this.jInternalFrameRemoveCategory.show(); \n } \n  \n private void showCQDetail(final boolean newCQ, final CQParams params) { \n  if (this.jInternalFrameCQDetail == null) { \n   this.add(this.getJInternalFrameCQDetail(), null); \n  } \n  this.jInternalFrameCQDetail.setTitle( \n    newCQ ? NEW_CQ_TITLE : EDIT_CQ_TITLE); \n  this.fillInCQDetail(params); \n  this.jInternalFrameCQDetail.show(); \n } \n  \n private void fillInCQDetail(final CQParams params) { \n  if (this.jInternalFrameCQDetail != null) { \n   String question = null; \n   String answer = null; \n   if (params != null) { \n    question = params.getQuestion(); \n    answer = params.getAnswer(); \n   } \n   this.fieldCQDetailQuestion.setText(question); \n   this.fieldCQDetailAnswer.setText(answer); \n    \n   this.filledInCQParams = params; \n  } \n } \n  \n private CQParams fillOutCQDetail() { \n  if (this.jInternalFrameCQDetail != null) { \n   final String question = \nthis.fieldCQDetailQuestion.getText(); \n   final String answer = \nthis.fieldCQDetailAnswer.getText(); \n   final Integer idCode = (this.filledInCQParams != null ? \n\n\n\n  \n\n     this.filledInCQParams.getIdCode() : \nnull); \n   return new CQParams(idCode, question, answer); \n  } \n  return null; \n } \n  \n private String showMoveCQsDialog(final String[] destinations) { \n  final String title = \"Moving competence questions...\"; \n  final String message = \n   \"Select the category in which to move\\n\" + \n    \"the selected competence questions.\"; \n  final String choice = \n   (String)JOptionPane.showInputDialog(this, message, \ntitle, \n     JOptionPane.OK_CANCEL_OPTION, null, \ndestinations, destinations[0]); \n  return choice; \n } \n \n /*--------------------------- \n  * Data Manipulation Methods: \n  ---------------------------*/ \n private void applyCategoryDetailErrorsMap( \n   Map<FORM_FIELDS, List<ValidationErrors>> \nfieldsErrorsMap, \n   List<String> messageList) { \n  if (fieldsErrorsMap.containsKey(FORM_FIELDS.CATEGORY_NAME)) { \n   List<ValidationErrors> errorList = \nfieldsErrorsMap.get(FORM_FIELDS.CATEGORY_NAME); \n   for (ValidationErrors error : errorList) { \n    switch (error) { \n    case NULL_FIELD: \n     messageList.add(\"Inform the name of the \ncategory.\"); \n     break; \n    case EXISTED_VALUE: \n     messageList.add(\"The given name already \nexists.\"); \n     break; \n    } \n   } \n  } \n } \n  \n private void applyCQDetailErrorsMap( \n   Map<FORM_FIELDS, List<ValidationErrors>> \nfieldsErrorsMap, \n   List<String> messageList) { \n  if (fieldsErrorsMap.containsKey(FORM_FIELDS.CQ_QUESTION)) { \n   List<ValidationErrors> errorList = \nfieldsErrorsMap.get(FORM_FIELDS.CQ_QUESTION); \n   for (ValidationErrors error : errorList) { \n    switch (error) { \n    case NULL_FIELD: \n     messageList.add(\"You must inform the \nquestion sentence of the competence question.\"); \n     break; \n    } \n   } \n  } \n } \n  \n /** \n  * Cerifica se h\u00e1 apenas uma categoria selecionada \n  * e se esta \u00e9 valida (n\u00e3o pode ser o item \"<All Categories>\") \n  * @return {@linkplain boolean} Retorna&lt;code>true</code> \n  *     se apenas uma categoria v\u00e1lida estiver \nselecionada. \n  */ \n private boolean hasSelectedOneValidCategory() { \n  if (this.jListCategories != null &amp;&amp; \nthis.jListCategories.isEnabled()) { \n   final List<Integer> selectedIDs = \nthis.jListCategories.getSelectedDataIDsList(); \n   final int quantSelectedIDs = selectedIDs.size(); \n   if (quantSelectedIDs == 1) { \n    if (UtilClass.ALL_CATEGORIES_ID != \nselectedIDs.get(0)) { \n     return true; \n\n\n\n  \n\n    } \n   } \n  } \n  return false; \n } \n  \n private JSplitPane getJSplitPane() { \n  if (jSplitPane == null) { \n   jSplitPane = new JSplitPane(); \n   jSplitPane.setLeftComponent(getPanelCategories()); \n   jSplitPane.setRightComponent(getPanelCQs()); \n  } \n  return jSplitPane; \n } \n \n private JPanel getPanelCategories() { \n  if (panelCategories == null) { \n   GridBagConstraints gridBagConstraints5 = new \nGridBagConstraints(); \n   gridBagConstraints5.fill = GridBagConstraints.BOTH; \n   gridBagConstraints5.gridy = 2; \n   gridBagConstraints5.weightx = 1.0; \n   gridBagConstraints5.weighty = 1.0; \n   gridBagConstraints5.gridwidth = 3; \n   gridBagConstraints5.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints5.gridx = 0; \n   GridBagConstraints gridBagConstraints4 = new \nGridBagConstraints(); \n   gridBagConstraints4.gridx = 2; \n   gridBagConstraints4.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints4.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints4.gridy = 1; \n   GridBagConstraints gridBagConstraints3 = new \nGridBagConstraints(); \n   gridBagConstraints3.gridx = 1; \n   gridBagConstraints3.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints3.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints3.gridy = 1; \n   GridBagConstraints gridBagConstraints2 = new \nGridBagConstraints(); \n   gridBagConstraints2.gridx = 0; \n   gridBagConstraints2.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints2.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints2.gridy = 1; \n   GridBagConstraints gridBagConstraints1 = new \nGridBagConstraints(); \n   gridBagConstraints1.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints1.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints1.gridwidth = 3; \n   gridBagConstraints1.fill = \nGridBagConstraints.HORIZONTAL; \n   captionCategoriesPanel = new JLabel(); \n   captionCategoriesPanel.setText(\"Categories:\"); \n   panelCategories = new JPanel(); \n   panelCategories.setLayout(new GridBagLayout()); \n   panelCategories.add(captionCategoriesPanel, \ngridBagConstraints1); \n   panelCategories.add(getButtonAddCategory(), \ngridBagConstraints2); \n   panelCategories.add(getButtonEditCategory(), \ngridBagConstraints3); \n   panelCategories.add(getButtonRemoveCategory(), \ngridBagConstraints4); \n   panelCategories.add(getScrollPaneCategories(), \ngridBagConstraints5); \n  } \n  return panelCategories; \n } \n \n private JPanel getPanelCQs() { \n  if (panelCQs == null) { \n   GridBagConstraints gridBagConstraints27 = new \nGridBagConstraints(); \n   gridBagConstraints27.gridx = 3; \n   gridBagConstraints27.anchor = \nGridBagConstraints.NORTHWEST; \n\n\n\n  \n\n   gridBagConstraints27.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints27.gridy = 1; \n   GridBagConstraints gridBagConstraints10 = new \nGridBagConstraints(); \n   gridBagConstraints10.fill = GridBagConstraints.BOTH; \n   gridBagConstraints10.gridy = 2; \n   gridBagConstraints10.weightx = 1.0; \n   gridBagConstraints10.weighty = 1.0; \n   gridBagConstraints10.gridwidth = 4; \n   gridBagConstraints10.anchor = GridBagConstraints.CENTER; \n   gridBagConstraints10.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints10.gridx = 0; \n   GridBagConstraints gridBagConstraints9 = new \nGridBagConstraints(); \n   gridBagConstraints9.gridx = 2; \n   gridBagConstraints9.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints9.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints9.gridy = 1; \n   GridBagConstraints gridBagConstraints8 = new \nGridBagConstraints(); \n   gridBagConstraints8.gridx = 1; \n   gridBagConstraints8.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints8.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints8.gridy = 1; \n   GridBagConstraints gridBagConstraints7 = new \nGridBagConstraints(); \n   gridBagConstraints7.gridx = 0; \n   gridBagConstraints7.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints7.insets = new Insets(1, 1, 1, 1); \n   gridBagConstraints7.gridy = 1; \n   GridBagConstraints gridBagConstraints6 = new \nGridBagConstraints(); \n   gridBagConstraints6.gridx = 0; \n   gridBagConstraints6.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints6.gridwidth = 4; \n   gridBagConstraints6.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints6.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints6.gridy = 0; \n   captionCQsPanel = new JLabel(); \n   captionCQsPanel.setText(\"Competence Questions:\"); \n   panelCQs = new JPanel(); \n   panelCQs.setLayout(new GridBagLayout()); \n   panelCQs.add(captionCQsPanel, gridBagConstraints6); \n   panelCQs.add(getButtonAddCQ(), gridBagConstraints7); \n   panelCQs.add(getButtonEditCQ(), gridBagConstraints8); \n   panelCQs.add(getButtonRemoveCQ(), gridBagConstraints9); \n   panelCQs.add(getButtonMoveCQ(), gridBagConstraints27); \n   panelCQs.add(getScrollPaneCQs(), gridBagConstraints10); \n  } \n  return panelCQs; \n } \n \n private JButton getButtonAddCategory() { \n  if (buttonAddCategory == null) { \n   buttonAddCategory = new JButton(); \n   buttonAddCategory.setText(\"Add\"); \n   buttonAddCategory.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      presenter.doAddCategory(); \n     } \n    } \n   }); \n  } \n  return buttonAddCategory; \n } \n \n private JButton getButtonEditCategory() { \n  if (buttonEditCategory == null) { \n   buttonEditCategory = new JButton(); \n   buttonEditCategory.setText(\"Edit\"); \n   buttonEditCategory.addActionListener(new \njava.awt.event.ActionListener() { \n\n\n\n  \n\n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final Integer categoryID = \njListCategories.getSelectedDataID(); \n      if (categoryID != null &amp;&amp; \ncategoryID > 0) { \n      \n presenter.doEditCategory(categoryID); \n      } else { \n       final String message = \n        \"Select a category \nto edit.\\n\" + \n        \"The item&lt;all \ncategories> is not a category, \\n\" + \n        \"is a compilation \nfrom all one, can't be edited.\"; \n       showInfoMessage(message); \n      } \n     } \n    } \n   }); \n  } \n  return buttonEditCategory; \n } \n \n private JButton getButtonRemoveCategory() { \n  if (buttonRemoveCategory == null) { \n   buttonRemoveCategory = new JButton(); \n   buttonRemoveCategory.setText(\"Remove\"); \n   buttonRemoveCategory.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final List<Integer> \ncategoryIDsList = jListCategories.getSelectedDataIDsList(); \n       \n      final List<String> messageList = \nnew ArrayList<String>(0); \n      for (Integer categoryID : \ncategoryIDsList) { \n       if (categoryID == \nUtilClass.DEFAULT_CATEGORY_ID) { \n        messageList.add( \n          \"The \ndefault category (the one with ID: \" + \n         \n UtilClass.DEFAULT_CATEGORY_ID + \n          \") \nwas selected, but it can't be removed.\\n\"); \n       \n categoryIDsList.remove(categoryID); \n        break; \n       } \n      } \n      if (categoryIDsList != null &amp;&amp; \ncategoryIDsList.size() > 0) { \n      \n presenter.doRemoveCategory(categoryIDsList); \n      } else { \n       messageList.add(\"Select a \ncategory \" + \n         \"(except the \ndefault (with ID: \" + \n        \n UtilClass.DEFAULT_CATEGORY_ID + \n         \") to be \nremoved.\"); \n      } \n      if (messageList.size() > 0) { \n       final StringBuilder \nmsgBuilder = new StringBuilder(); \n       for (String message : \nmessageList) { \n        if \n(msgBuilder.length() > 0) { \n        \n msgBuilder.append(\"\\n\"); \n        } \n\n\n\n  \n\n       \n msgBuilder.append(message); \n       } \n      \n showInfoMessage(msgBuilder.toString()); \n      } \n     } \n    } \n   }); \n  } \n  return buttonRemoveCategory; \n } \n \n private JScrollPane getScrollPaneCategories() { \n  if (scrollPaneCategories == null) { \n   scrollPaneCategories = new JScrollPane(); \n  \n scrollPaneCategories.setViewportView(getJListCategories()); \n  } \n  return scrollPaneCategories; \n } \n \n private JButton getButtonAddCQ() { \n  if (buttonAddCQ == null) { \n   buttonAddCQ = new JButton(); \n   buttonAddCQ.setText(\"Add\"); \n   buttonAddCQ.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      if (hasSelectedOneValidCategory()) \n{ \n       presenter.doAddCQ(); \n      } else { \n       final String message = \n        \"You must select a \ncategory to add a competence question.\\n\" + \n        \"(Attention: The \nitem \\\"\"+ UtilClass.ALL_CATEGORIES_LABEL +\"\\\" isn't a category)\"; \n       showInfoMessage(message); \n      } \n     } \n    } \n   }); \n  } \n  return buttonAddCQ; \n } \n \n private JButton getButtonEditCQ() { \n  if (buttonEditCQ == null) { \n   buttonEditCQ = new JButton(); \n   buttonEditCQ.setText(\"Edit\"); \n   buttonEditCQ.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final List<Integer> selectedIDs = \njListCQs.getSelectedDataIDsList(); \n      final int length = \nselectedIDs.size(); \n      if (length == 0) { \n       showInfoMessage(\"Select one \ncompetence question to edit.\"); \n      } else if (length > 1) { \n       showInfoMessage(\"Only one \ncompetence question can be edited at time.\"); \n      } else { \n      \n presenter.doEditCQ(selectedIDs.get(0)); \n      } \n     } \n    } \n   }); \n  } \n  return buttonEditCQ; \n } \n \n private JButton getButtonRemoveCQ() { \n\n\n\n  \n\n  if (buttonRemoveCQ == null) { \n   buttonRemoveCQ = new JButton(); \n   buttonRemoveCQ.setText(\"Remove\"); \n   buttonRemoveCQ.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final List<Integer> selectedIDs = \njListCQs.getSelectedDataIDsList(); \n      if (selectedIDs.size() == 0) { \n       showInfoMessage(\"Select at \nleast one Competence Question to remove.\"); \n      } else { \n      \n presenter.doRemoveCQ(selectedIDs); \n      } \n     } \n    } \n   }); \n  } \n  return buttonRemoveCQ; \n } \n \n private JScrollPane getScrollPaneCQs() { \n  if (scrollPaneCQs == null) { \n   scrollPaneCQs = new JScrollPane(); \n   scrollPaneCQs.setViewportView(getJListCQs()); \n  } \n  return scrollPaneCQs; \n } \n \n private JListCategories getJListCategories() { \n  if (jListCategories == null) { \n   jListCategories = new JListCategories(); \n   jListCategories.addMouseListener(new \njava.awt.event.MouseAdapter() { \n    public void \nmouseClicked(java.awt.event.MouseEvent e) { \n     if (jListCategories.isEnabled()) { \n      final List<Integer> selectedIDs = \njListCategories.getSelectedDataIDsList(); \n      if (selectedIDs.size() == 1) { \n      \n presenter.loadSelectedCategoryItems(selectedIDs.get(0)); \n      } else { \n      \n presenter.loadSelectedCategoryItems(UtilClass.NO_SELECTED_CATEGORY); \n      } \n     } \n    } \n   }); \n  } \n  return jListCategories; \n } \n \n private JListCQs getJListCQs() { \n  if (jListCQs == null) { \n   jListCQs = new JListCQs(); \n  } \n  return jListCQs; \n } \n  \n /** \n  * Especializa\u00e7\u00e3o do componente JList para a exibi\u00e7\u00e3o das categorias. \n  * Recebe e trabalha com um mapeamento de dados. \n  */ \n private class JListCategories extends JList { \n   \n  private static final long serialVersionUID = 1L; \n   \n  private Map<Integer, ?> mapIndexToDataID; \n   \n  public JListCategories() { \n   super(); \n  } \n   \n  /** \n   * @deprecated usar setData(Map<K, V> categoriesMap) \n   */ \n\n\n\n  \n\n  @Override \n  public void setListData(Object[] listData) { \n   super.setListData(listData); \n  } \n   \n  /** \n   * @deprecated usar setData(Map<K, V> categoriesMap) \n   */ \n  @Override \n  public void setListData(Vector<?> listData) { \n   super.setListData(listData); \n  } \n   \n  @SuppressWarnings(\"unchecked\") \n  public&lt;K extends Object, V extends Object> void setData(Map<K, \nV> categoriesMap) { \n   final int length = ( categoriesMap != null ? \ncategoriesMap.size() : 0 ); \n   Map<Integer, K> mapIndexToDataID = new \nLinkedHashMap<Integer, K>(length); \n   final Vector<String> listData = new \nVector<String>(length); \n    \n   if (length > 0) { \n    final K[] keys = \n(K[])categoriesMap.keySet().toArray(); \n    for (int i=0; i &lt;length; i++) { \n     final K dataID = keys[i];  \n     listData.add( dataID + \nUtilClass.CATEGORY_PREFIX + \n       categoriesMap.get(dataID) \n); \n     mapIndexToDataID.put(listData.size()-1, \ndataID); \n    } \n    this.mapIndexToDataID = mapIndexToDataID; \n   } \n    \n   super.setListData(listData); \n  } \n   \n  @SuppressWarnings(\"unchecked\") \n  public&lt;K extends Object> K getSelectedDataID() { \n   if (this.mapIndexToDataID != null &amp;&amp; \nthis.mapIndexToDataID.size() > 0) { \n    final int selectedIndex = \nsuper.getSelectedIndex(); \n    if (selectedIndex >= 0) { \n     return \n(K)this.mapIndexToDataID.get(selectedIndex); \n    } \n   } \n   return null; \n  } \n   \n  @SuppressWarnings(\"unchecked\") \n  public&lt;K extends Object> List<K> getSelectedDataIDsList() { \n   final int[] indices = super.getSelectedIndices(); \n   final int length = indices.length; \n   final List<K> dataIDsList = new ArrayList<K>(length); \n   for (int i=0; i &lt;length; i++) { \n   \n dataIDsList.add((K)this.mapIndexToDataID.get(indices[i])); \n   } \n   return dataIDsList; \n  } \n } \n  \n /** \n  * Especializa\u00e7\u00e3o do componente JList para a exibi\u00e7\u00e3o \n  * das perguntas de compet\u00eancia e suas respostas. \n  * Recebe e trabalha com um duplo mapeamento de dados. \n  */ \n private class JListCQs extends JList { \n   \n  private static final long serialVersionUID = 1L; \n   \n  private Map<Integer, ?> mapIndexToQuestionID; \n  private Map<Integer, ?> mapIndexToAnswerID; \n   \n\n\n\n  \n\n  public JListCQs() { \n   super(); \n  } \n   \n  /** \n   * @deprecated usar setData(Map<K, V> questionsMap, Map<K, V> \nanswersMap) \n   */ \n  @Override \n  public void setListData(Object[] listData) { \n   super.setListData(listData); \n  } \n   \n  /** \n   * @deprecated usar setData(Map<K, V> questionsMap, Map<K, V> \nanswersMap) \n   */ \n  @Override \n  public void setListData(Vector<?> listData) { \n   super.setListData(listData); \n  } \n   \n  @SuppressWarnings(\"unchecked\") \n  public&lt;K extends Object, V extends Object> void setData( \n    Map<K, V> questionsMap, Map<K, V> answersMap) { \n   final int lengthQuestions = (questionsMap != null ? \nquestionsMap.size() : 0); \n   final int lengthAnswers = (answersMap != null ? \nanswersMap.size() : 0); \n    \n   Map<Integer, K> mapIndexToQuestionID = new \nLinkedHashMap<Integer, K>(lengthQuestions); \n   Map<Integer, K> mapIndexToAnswerID = new \nLinkedHashMap<Integer, K>(lengthAnswers); \n   final Vector<String> listData = new \nVector<String>(lengthQuestions); \n    \n   if (lengthQuestions > 0) { \n    final boolean hasAnswers = (lengthAnswers > 0); \n    final K[] keys = \n(K[])questionsMap.keySet().toArray(); \n    for (int i=0; i &lt;lengthQuestions; i++) { \n     final K dataID = keys[i]; \n      \n     listData.add( dataID + \nUtilClass.QUESTION_PREFIX + \n       questionsMap.get(dataID) ); \n     mapIndexToQuestionID.put(listData.size()-\n1, dataID); \n      \n     if (hasAnswers &amp;&amp; \nanswersMap.containsKey(dataID)) { \n      listData.add( dataID + \nUtilClass.ANSWER_PREFIX + \n       \n answersMap.get(dataID) ); \n     \n mapIndexToAnswerID.put(listData.size()-1, dataID); \n     } \n    } \n    this.mapIndexToQuestionID = mapIndexToQuestionID; \n    this.mapIndexToAnswerID = mapIndexToAnswerID; \n   } \n    \n   super.setListData(listData); \n  } \n   \n  @SuppressWarnings(\"unchecked\") \n  public&lt;K extends Object> K getSelectedDataID() { \n   final int selectedIndex = super.getSelectedIndex(); \n   K selectedDataID = null; \n    \n   if (selectedIndex >= 0) { \n    if (this.mapIndexToQuestionID != null &amp;&amp; \n     \n this.mapIndexToQuestionID.containsKey(selectedIndex)) { \n     selectedDataID = \n(K)this.mapIndexToQuestionID.get(selectedIndex); \n    } \n    if (selectedDataID == null &amp;&amp; \n\n\n\n  \n\n      this.mapIndexToAnswerID != null &amp;&amp; \n     \n this.mapIndexToAnswerID.containsKey(selectedIndex)) { \n     selectedDataID = \n(K)this.mapIndexToAnswerID.get(selectedIndex); \n    } \n   } \n    \n   return selectedDataID; \n  } \n   \n  @SuppressWarnings(\"unchecked\") \n  public&lt;K extends Object> List<K> getSelectedDataIDsList() { \n   final int[] indices = super.getSelectedIndices(); \n   final int length = indices.length; \n   final List<K> dataIDsList = new ArrayList<K>(length); \n   for (int i=0; i &lt;length; i++) { \n    final K questionID = \n(K)this.mapIndexToQuestionID.get(indices[i]); \n    if (questionID != null) { \n     this.setInOneList(dataIDsList, \nquestionID); \n    } else { \n     final K answerID = \n(K)this.mapIndexToAnswerID.get(indices[i]); \n     if (answerID != null) { \n      this.setInOneList(dataIDsList, \nanswerID); \n     } \n    } \n   } \n   return dataIDsList; \n  } \n   \n  private&lt;K extends Object> void setInOneList( \n    final List<K> listToSet, final K element) { \n   if (listToSet != null &amp;&amp; element != null) { \n    if ( ! listToSet.contains(element)) { \n     listToSet.add(element); \n    } \n   } \n  } \n } \n  \n private static class CategoryParams { \n  private final Integer idCode; \n  private final String name; \n  private final String description; \n   \n  public CategoryParams(final Integer idCode, final String name, \nfinal String description) { \n   this.idCode = idCode; \n   this.name = name; \n   this.description = description; \n  } \n \n  public Integer getIdCode() { \n   return idCode; \n  } \n \n  public String getName() { \n   return name; \n  } \n \n  public String getDescription() { \n   return description; \n  } \n } \n  \n private static class CQParams { \n  private final Integer idCode; \n  private final String question; \n  private final String answer; \n   \n  public CQParams(final Integer idCode, final String question, \nfinal String answer) { \n   this.idCode = idCode; \n   this.question = question; \n   this.answer = answer; \n  } \n\n\n\n  \n\n \n  public Integer getIdCode() { \n   return idCode; \n  } \n \n  public String getQuestion() { \n   return question; \n  } \n \n  public String getAnswer() { \n   return answer; \n  } \n } \n \n private JInternalFrame getJInternalFrameCategoryDetail() { \n  if (jInternalFrameCategoryDetail == null) { \n   jInternalFrameCategoryDetail = new JInternalFrame(); \n   jInternalFrameCategoryDetail.setTitle(\"Category \nDetail\"); \n  \n jInternalFrameCategoryDetail.setDefaultCloseOperation(WindowConstants.H\nIDE_ON_CLOSE); \n   jInternalFrameCategoryDetail.setClosable(false); \n  \n jInternalFrameCategoryDetail.setContentPane(getJContentPaneCategoryDeta\nil()); \n   final Dimension size = new Dimension(300, 200); \n   this.jInternalFrameCategoryDetail.setMinimumSize(size); \n   this.jInternalFrameCategoryDetail.setSize(size); \n   jInternalFrameCategoryDetail \n     .addComponentListener(new \njava.awt.event.ComponentAdapter() {    \n    public void \ncomponentShown(java.awt.event.ComponentEvent e) {     \n     if (presenter != null) { \n      presenter.setModalMode(true); \n     } \n    } \n    public void \ncomponentHidden(java.awt.event.ComponentEvent e) { \n     if (presenter != null) { \n      presenter.setModalMode(false); \n     } \n    } \n     }); \n  } \n  return jInternalFrameCategoryDetail; \n } \n \n private JPanel getJContentPaneCategoryDetail() { \n  if (jContentPaneCategoryDetail == null) { \n   GridBagConstraints gridBagConstraints17 = new \nGridBagConstraints(); \n   gridBagConstraints17.gridx = 0; \n   gridBagConstraints17.anchor = \nGridBagConstraints.SOUTHWEST; \n   gridBagConstraints17.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints17.insets = new Insets(0, 4, 2, 4); \n   gridBagConstraints17.gridy = 5; \n   infoRequiredCategDetail = new JLabel(); \n   infoRequiredCategDetail.setText(\"Fields with (*) are \nrequired.\"); \n   GridBagConstraints gridBagConstraints15 = new \nGridBagConstraints(); \n   gridBagConstraints15.gridx = 0; \n   gridBagConstraints15.anchor = \nGridBagConstraints.SOUTHWEST; \n   gridBagConstraints15.insets = new Insets(2, 4, 0, 4); \n   gridBagConstraints15.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints15.gridwidth = 1; \n   gridBagConstraints15.gridy = 4; \n   GridBagConstraints gridBagConstraints14 = new \nGridBagConstraints(); \n   gridBagConstraints14.fill = GridBagConstraints.BOTH; \n   gridBagConstraints14.gridy = 3; \n   gridBagConstraints14.weightx = 1.0; \n   gridBagConstraints14.weighty = 1.0; \n\n\n\n  \n\n   gridBagConstraints14.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints14.insets = new Insets(0, 4, 2, 4); \n   gridBagConstraints14.gridwidth = 1; \n   gridBagConstraints14.gridx = 0; \n   GridBagConstraints gridBagConstraints13 = new \nGridBagConstraints(); \n   gridBagConstraints13.gridx = 0; \n   gridBagConstraints13.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints13.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints13.insets = new Insets(2, 4, 0, 4); \n   gridBagConstraints13.gridwidth = 1; \n   gridBagConstraints13.gridy = 2; \n   captionCategDetailDescription = new JLabel(); \n   captionCategDetailDescription.setText(\"Description:\"); \n   GridBagConstraints gridBagConstraints12 = new \nGridBagConstraints(); \n   gridBagConstraints12.fill = GridBagConstraints.BOTH; \n   gridBagConstraints12.gridy = 1; \n   gridBagConstraints12.weightx = 1.0; \n   gridBagConstraints12.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints12.insets = new Insets(0, 4, 2, 4); \n   gridBagConstraints12.gridwidth = 1; \n   gridBagConstraints12.gridx = 0; \n   GridBagConstraints gridBagConstraints11 = new \nGridBagConstraints(); \n   gridBagConstraints11.gridx = 0; \n   gridBagConstraints11.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints11.insets = new Insets(4, 4, 0, 4); \n   gridBagConstraints11.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints11.gridy = 0; \n   captionCategDetailName = new JLabel(); \n   captionCategDetailName.setText(\"Name: (*)\"); \n   jContentPaneCategoryDetail = new JPanel(); \n   jContentPaneCategoryDetail.setLayout(new \nGridBagLayout()); \n   jContentPaneCategoryDetail.setPreferredSize(new \nDimension(300, 200)); \n   jContentPaneCategoryDetail.add(captionCategDetailName, \ngridBagConstraints11); \n  \n jContentPaneCategoryDetail.add(getFieldCategDetailName(), \ngridBagConstraints12); \n  \n jContentPaneCategoryDetail.add(captionCategDetailDescription, \ngridBagConstraints13); \n  \n jContentPaneCategoryDetail.add(getScrollPaneCategDetailDescription(), \ngridBagConstraints14); \n  \n jContentPaneCategoryDetail.add(getBottomBarCategDetail(), \ngridBagConstraints15); \n   jContentPaneCategoryDetail.add(infoRequiredCategDetail, \ngridBagConstraints17); \n    \n  } \n  return jContentPaneCategoryDetail; \n } \n \n private JTextField getFieldCategDetailName() { \n  if (fieldCategDetailName == null) { \n   fieldCategDetailName = new JTextField(); \n   fieldCategDetailName.setText(\"Name\"); \n  } \n  return fieldCategDetailName; \n } \n \n private JScrollPane getScrollPaneCategDetailDescription() { \n  if (scrollPaneCategDetailDescription == null) { \n   scrollPaneCategDetailDescription = new JScrollPane(); \n  \n scrollPaneCategDetailDescription.setViewportView(getFieldCategDetailDes\ncription()); \n  } \n  return scrollPaneCategDetailDescription; \n\n\n\n  \n\n } \n \n private JTextArea getFieldCategDetailDescription() { \n  if (fieldCategDetailDescription == null) { \n   fieldCategDetailDescription = new JTextArea(); \n   fieldCategDetailDescription.setText(\"Description\"); \n  } \n  return fieldCategDetailDescription; \n } \n \n private JPanel getBottomBarCategDetail() { \n  if (bottomBarCategDetail == null) { \n   bottomBarCategDetail = new JPanel(); \n   bottomBarCategDetail.setLayout(new FlowLayout()); \n   bottomBarCategDetail.add(getButtonCategDetailConfirm(), \nnull); \n   bottomBarCategDetail.add(getButtonCategDetailCancel(), \nnull); \n  } \n  return bottomBarCategDetail; \n } \n \n private JButton getButtonCategDetailConfirm() { \n  if (buttonCategDetailConfirm == null) { \n   buttonCategDetailConfirm = new JButton(); \n   buttonCategDetailConfirm.setText(\"Confirm\"); \n   buttonCategDetailConfirm.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final CategoryParams filledOutParams = \nfillOutCategoryDetail(); \n     if (filledOutParams != null) { \n      Map<FORM_FIELDS, \nList<ValidationErrors>> errors = presenter.validateCategoryDetail( \n       \n filledOutParams.getIdCode(), filledOutParams.getName(), \n       \n filledOutParams.getDescription()); \n      if (errors.isEmpty()) { \n       if \n(filledOutParams.getIdCode() == null) { \n       \n presenter.addCategory( \n         \n filledOutParams.getName(), filledOutParams.getDescription()); \n       } else { \n       \n presenter.editCategory(filledOutParams.getIdCode(), \n         \n filledOutParams.getName(), filledOutParams.getDescription()); \n       } \n      \n jInternalFrameCategoryDetail.doDefaultCloseAction(); \n      } else { \n       List<String> messageList = \nnew ArrayList<String>(0); \n      \n applyCategoryDetailErrorsMap(errors, messageList); \n       final StringBuilder \nmsgBuilder = new StringBuilder(); \n       for (String message : \nmessageList) { \n        if \n(msgBuilder.length() > 0) { \n        \n msgBuilder.append(\"\\n\"); \n        } \n       \n msgBuilder.append(message); \n       } \n      \n JOptionPane.showMessageDialog(jInternalFrameCategoryDetail, \n        \n msgBuilder.toString(), \n         \"Validation \nErrors\", \n        \n JOptionPane.INFORMATION_MESSAGE); \n      } \n\n\n\n  \n\n     } \n    } \n   }); \n  } \n  return buttonCategDetailConfirm; \n } \n \n private JButton getButtonCategDetailCancel() { \n  if (buttonCategDetailCancel == null) { \n   buttonCategDetailCancel = new JButton(); \n   buttonCategDetailCancel.setText(\"Cancel\"); \n   buttonCategDetailCancel.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n    \n jInternalFrameCategoryDetail.doDefaultCloseAction(); \n    } \n   }); \n  } \n  return buttonCategDetailCancel; \n } \n \n private JInternalFrame getJInternalFrameRemoveCategory() { \n  if (jInternalFrameRemoveCategory == null) { \n   jInternalFrameRemoveCategory = new JInternalFrame(); \n  \n jInternalFrameRemoveCategory.setDefaultCloseOperation(WindowConstants.H\nIDE_ON_CLOSE); \n   jInternalFrameRemoveCategory.setTitle(\"Remove \nCategory\"); \n   final Dimension size = new Dimension(360, 150); \n   this.jInternalFrameRemoveCategory.setMinimumSize(size); \n   this.jInternalFrameRemoveCategory.setSize(size); \n  \n jInternalFrameRemoveCategory.setContentPane(getJContentPaneRemoveCatego\nry()); \n   jInternalFrameRemoveCategory \n     .addComponentListener(new \njava.awt.event.ComponentAdapter() {    \n    public void \ncomponentShown(java.awt.event.ComponentEvent e) {     \n     if (presenter != null) { \n      presenter.setModalMode(true); \n     } \n    } \n    public void \ncomponentHidden(java.awt.event.ComponentEvent e) { \n     if (presenter != null) { \n      presenter.setModalMode(false); \n     } \n    } \n     }); \n  } \n  return jInternalFrameRemoveCategory; \n } \n \n private JPanel getJContentPaneRemoveCategory() { \n  if (jContentPaneRemoveCategory == null) { \n   GridBagConstraints gridBagConstraints20 = new \nGridBagConstraints(); \n   gridBagConstraints20.gridx = 0; \n   gridBagConstraints20.insets = new Insets(2, 4, 4, 4); \n   gridBagConstraints20.anchor = GridBagConstraints.NORTH; \n   gridBagConstraints20.gridy = 2; \n   labelRemoveCategProcedureLine2 = new JLabel(); \n   labelRemoveCategProcedureLine2.setText(\"Procedure Line \n2\"); \n   GridBagConstraints gridBagConstraints19 = new \nGridBagConstraints(); \n   gridBagConstraints19.insets = new Insets(4, 4, 2, 3); \n   gridBagConstraints19.anchor = GridBagConstraints.NORTH; \n   labelRemoveCategMainLine = new JLabel(); \n   labelRemoveCategMainLine.setText(\"Main Line\"); \n   GridBagConstraints gridBagConstraints16 = new \nGridBagConstraints(); \n   gridBagConstraints16.gridx = 0; \n   gridBagConstraints16.anchor = GridBagConstraints.NORTH; \n   gridBagConstraints16.insets = new Insets(2, 4, 2, 4); \n   gridBagConstraints16.fill = GridBagConstraints.NONE; \n\n\n\n  \n\n   gridBagConstraints16.gridy = 1; \n   labelRemoveCategProcedureLine1 = new JLabel(); \n   labelRemoveCategProcedureLine1.setText(\"Procedure Line \n1\"); \n   GridBagConstraints gridBagConstraints18 = new \nGridBagConstraints(); \n   gridBagConstraints18.gridy = 3; \n   gridBagConstraints18.insets = new Insets(8, 4, 4, 4); \n   gridBagConstraints18.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints18.anchor = GridBagConstraints.SOUTH; \n   jContentPaneRemoveCategory = new JPanel(); \n   jContentPaneRemoveCategory.setLayout(new \nGridBagLayout()); \n   jContentPaneRemoveCategory.add(labelRemoveCategMainLine, \ngridBagConstraints19); \n  \n jContentPaneRemoveCategory.add(labelRemoveCategProcedureLine1, \ngridBagConstraints16); \n  \n jContentPaneRemoveCategory.add(labelRemoveCategProcedureLine2, \ngridBagConstraints20); \n  \n jContentPaneRemoveCategory.add(getBottomBarRemoveCateg(), \ngridBagConstraints18); \n  } \n  return jContentPaneRemoveCategory; \n } \n \n private JPanel getBottomBarRemoveCateg() { \n  if (bottomBarRemoveCateg == null) { \n   bottomBarRemoveCateg = new JPanel(); \n   bottomBarRemoveCateg.setLayout(new FlowLayout()); \n   bottomBarRemoveCateg.add(getButtonRemoveCategConfirm(), \nnull); \n   bottomBarRemoveCateg.add(getButtonRemoveCategCancel(), \nnull); \n  } \n  return bottomBarRemoveCateg; \n } \n \n private JButton getButtonRemoveCategConfirm() { \n  if (buttonRemoveCategConfirm == null) { \n   buttonRemoveCategConfirm = new JButton(); \n   buttonRemoveCategConfirm.setText(\"Remove\"); \n   buttonRemoveCategConfirm.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n     \n presenter.removeCategories(selectedCategoriesToRemove); \n     } \n    \n jInternalFrameRemoveCategory.doDefaultCloseAction(); \n    } \n   }); \n  } \n  return buttonRemoveCategConfirm; \n } \n \n private JButton getButtonRemoveCategCancel() { \n  if (buttonRemoveCategCancel == null) { \n   buttonRemoveCategCancel = new JButton(); \n   buttonRemoveCategCancel.setText(\"Cancel\"); \n   buttonRemoveCategCancel.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n    \n jInternalFrameRemoveCategory.doDefaultCloseAction(); \n    } \n   }); \n  } \n  return buttonRemoveCategCancel; \n } \n \n private JInternalFrame getJInternalFrameCQDetail() { \n  if (jInternalFrameCQDetail == null) { \n   jInternalFrameCQDetail = new JInternalFrame(); \n\n\n\n  \n\n   final Dimension size = new Dimension(400, 180); \n   jInternalFrameCQDetail.setMinimumSize(size); \n   jInternalFrameCQDetail.setSize(size); \n   jInternalFrameCQDetail.setPreferredSize(size); \n   jInternalFrameCQDetail.setTitle(\"CQ Detail\"); \n  \n jInternalFrameCQDetail.setDefaultCloseOperation(WindowConstants.HIDE_ON\n_CLOSE); \n  \n jInternalFrameCQDetail.setContentPane(getJContentPaneCQDetail()); \n   jInternalFrameCQDetail \n     .addComponentListener(new \njava.awt.event.ComponentAdapter() {    \n    public void \ncomponentShown(java.awt.event.ComponentEvent e) {     \n     if (presenter != null) { \n      presenter.setModalMode(true); \n     } \n    } \n    public void \ncomponentHidden(java.awt.event.ComponentEvent e) { \n     if (presenter != null) { \n      presenter.setModalMode(false); \n     } \n    } \n     }); \n  } \n  return jInternalFrameCQDetail; \n } \n \n private JPanel getJContentPaneCQDetail() { \n  if (jContentPaneCQDetail == null) { \n   GridBagConstraints gridBagConstraints26 = new \nGridBagConstraints(); \n   gridBagConstraints26.gridx = 0; \n   gridBagConstraints26.anchor = \nGridBagConstraints.SOUTHWEST; \n   gridBagConstraints26.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints26.insets = new Insets(0, 4, 2, 4); \n   gridBagConstraints26.gridy = 5; \n   infoRequiredCQDetail = new JLabel(); \n   infoRequiredCQDetail.setText(\"Fields with (*) are \nrequired.\"); \n   GridBagConstraints gridBagConstraints25 = new \nGridBagConstraints(); \n   gridBagConstraints25.gridx = 0; \n   gridBagConstraints25.anchor = \nGridBagConstraints.SOUTHWEST; \n   gridBagConstraints25.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints25.insets = new Insets(2, 4, 0, 4); \n   gridBagConstraints25.gridy = 4; \n   GridBagConstraints gridBagConstraints24 = new \nGridBagConstraints(); \n   gridBagConstraints24.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints24.gridy = 3; \n   gridBagConstraints24.weightx = 1.0; \n   gridBagConstraints24.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints24.insets = new Insets(0, 4, 2, 4); \n   gridBagConstraints24.gridx = 0; \n   GridBagConstraints gridBagConstraints23 = new \nGridBagConstraints(); \n   gridBagConstraints23.gridx = 0; \n   gridBagConstraints23.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints23.insets = new Insets(2, 4, 0, 4); \n   gridBagConstraints23.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints23.gridy = 2; \n   captionCQDetailAnswer = new JLabel(); \n   captionCQDetailAnswer.setText(\"Answer sentence:\"); \n   GridBagConstraints gridBagConstraints22 = new \nGridBagConstraints(); \n   gridBagConstraints22.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints22.gridy = 1; \n   gridBagConstraints22.weightx = 1.0; \n\n\n\n  \n\n   gridBagConstraints22.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints22.insets = new Insets(0, 4, 2, 4); \n   gridBagConstraints22.gridx = 0; \n   GridBagConstraints gridBagConstraints21 = new \nGridBagConstraints(); \n   gridBagConstraints21.gridx = 0; \n   gridBagConstraints21.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints21.insets = new Insets(4, 4, 0, 4); \n   gridBagConstraints21.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints21.gridy = 0; \n   captionCQDetailQuestion = new JLabel(); \n   captionCQDetailQuestion.setText(\"Question sentence: \n(*)\"); \n   jContentPaneCQDetail = new JPanel(); \n   jContentPaneCQDetail.setLayout(new GridBagLayout()); \n   jContentPaneCQDetail.add(captionCQDetailQuestion, \ngridBagConstraints21); \n   jContentPaneCQDetail.add(getFieldCQDetailQuestion(), \ngridBagConstraints22); \n   jContentPaneCQDetail.add(captionCQDetailAnswer, \ngridBagConstraints23); \n   jContentPaneCQDetail.add(getFieldCQDetailAnswer(), \ngridBagConstraints24); \n   jContentPaneCQDetail.add(getBottomBarCQDetail(), \ngridBagConstraints25); \n   jContentPaneCQDetail.add(infoRequiredCQDetail, \ngridBagConstraints26); \n  } \n  return jContentPaneCQDetail; \n } \n \n private JTextField getFieldCQDetailQuestion() { \n  if (fieldCQDetailQuestion == null) { \n   fieldCQDetailQuestion = new JTextField(); \n   fieldCQDetailQuestion.setText(\"Question\"); \n  } \n  return fieldCQDetailQuestion; \n } \n \n private JTextField getFieldCQDetailAnswer() { \n  if (fieldCQDetailAnswer == null) { \n   fieldCQDetailAnswer = new JTextField(); \n   fieldCQDetailAnswer.setText(\"Answer\"); \n  } \n  return fieldCQDetailAnswer; \n } \n \n private JPanel getBottomBarCQDetail() { \n  if (bottomBarCQDetail == null) { \n   bottomBarCQDetail = new JPanel(); \n   bottomBarCQDetail.setLayout(new FlowLayout()); \n   bottomBarCQDetail.add(getButtonCQDetailConfirm(), null); \n   bottomBarCQDetail.add(getButtonCQDetailCancel(), null); \n  } \n  return bottomBarCQDetail; \n } \n \n private JButton getButtonCQDetailConfirm() { \n  if (buttonCQDetailConfirm == null) { \n   buttonCQDetailConfirm = new JButton(); \n   buttonCQDetailConfirm.setText(\"Confirm\"); \n   buttonCQDetailConfirm.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final CQParams filledOutParams = \nfillOutCQDetail(); \n     if (filledOutParams != null) { \n      Map<FORM_FIELDS, \nList<ValidationErrors>> errors = presenter.validateCQDetail( \n       \n filledOutParams.getIdCode(), filledOutParams.getQuestion(), \n       \n filledOutParams.getAnswer()); \n      if (errors.isEmpty()) { \n       if \n(filledOutParams.getIdCode() == null) { \n\n\n\n  \n\n        final Integer \ncategoryID = jListCategories.getSelectedDataID(); \n       \n presenter.addCompetenceQuestion(categoryID, \n         \n filledOutParams.getQuestion(), filledOutParams.getAnswer()); \n       } else { \n       \n presenter.editCompetenceQuestion(filledOutParams.getIdCode(), \n         \n filledOutParams.getQuestion(), filledOutParams.getAnswer()); \n       } \n      \n jInternalFrameCQDetail.doDefaultCloseAction(); \n      } else { \n       List<String> messageList = \nnew ArrayList<String>(0); \n      \n applyCQDetailErrorsMap(errors, messageList); \n       final StringBuilder \nmsgBuilder = new StringBuilder(); \n       for (String message : \nmessageList) { \n        if \n(msgBuilder.length() > 0) { \n        \n msgBuilder.append(\"\\n\"); \n        } \n       \n msgBuilder.append(message); \n       } \n      \n JOptionPane.showMessageDialog(jInternalFrameCategoryDetail, \n        \n msgBuilder.toString(), \n         \"Validation \nErrors\", \n        \n JOptionPane.INFORMATION_MESSAGE); \n      } \n     } \n    } \n   }); \n  } \n  return buttonCQDetailConfirm; \n } \n \n private JButton getButtonCQDetailCancel() { \n  if (buttonCQDetailCancel == null) { \n   buttonCQDetailCancel = new JButton(); \n   buttonCQDetailCancel.setText(\"Cancel\"); \n   buttonCQDetailCancel.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n    \n jInternalFrameCQDetail.doDefaultCloseAction(); \n    } \n   }); \n  } \n  return buttonCQDetailCancel; \n } \n \n private JButton getButtonMoveCQ() { \n  if (buttonMoveCQ == null) { \n   buttonMoveCQ = new JButton(); \n   buttonMoveCQ.setText(\"Move...\"); \n   buttonMoveCQ.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      if (hasSelectedOneValidCategory()) \n{ \n       final List<Integer> \nselectedIDs = jListCQs.getSelectedDataIDsList(); \n       if (selectedIDs.size() == \n0) { \n       \n showInfoMessage(\"Select at least one competence question to move.\"); \n\n\n\n  \n\n       } else { \n        final Integer \ncategoryID = jListCategories.getSelectedDataID(); \n       \n presenter.doMoveCQ(categoryID, selectedIDs); \n       } \n      } else { \n       final String message = \n        \"You must select a \ncategory to move competence questions.\\n\" + \n        \"(Attention: The \nitem \\\"\"+ UtilClass.ALL_CATEGORIES_LABEL +\"\\\" isn't a category)\"; \n       showInfoMessage(message); \n      } \n     } \n    } \n   }); \n  } \n  return buttonMoveCQ; \n } \n} \n \n\n? Classe MainFormImpl.java: \npackage gui; \n \nimport java.awt.CardLayout; \nimport java.awt.Toolkit; \nimport java.io.File; \n \nimport javax.swing.JFileChooser; \nimport javax.swing.JFrame; \nimport javax.swing.JMenu; \nimport javax.swing.JMenuBar; \nimport javax.swing.JMenuItem; \nimport javax.swing.JOptionPane; \nimport javax.swing.JPanel; \nimport javax.swing.JTabbedPane; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.MESSAGES; \nimport view.main.MainForm; \nimport view.main.MainPresenter; \n \npublic class MainFormImpl extends JFrame implements MainForm { \n  \n private static final long serialVersionUID = 1L; \n  \n private static final String NEW_PROJECT_DIALOG_TITLE = \"New\"; \n  \n private enum Modules { \n  PROJECT_FORM(ProjectFormImpl.class.getName(), \"Project\"), \n \n COMPETENCE_QUESTIONS_FORM(CompetenceQuestionsFormImpl.class.getName(), \n    \"Competence questions\"), \n  TERMS_FORM(TermsFormImpl.class.getName(), \"Terms\"); \n   \n  private final String moduleName; \n  private final String tabTitle; \n   \n  private Modules(final String moduleName, final String tabTitle) \n{ \n   this.moduleName = moduleName; \n   this.tabTitle = tabTitle; \n  } \n   \n  public String getModuleName() { \n   return moduleName; \n  } \n   \n  public String getTabTitle() { \n   return tabTitle; \n  } \n } \n  \n private MainPresenter presenter; \n  \n private ProjectFormImpl projectFormImpl; \n\n\n\n  \n\n private CompetenceQuestionsFormImpl cqFormImpl; \n private TermsFormImpl termsFormImpl; \n  \n private JFileChooser fileDialog; \n  \n private JPanel jContentPane = null; \n private JTabbedPane tabBar = null; \n \n private JMenuBar appMenuBar = null; \n \n private JMenu menuFile = null; \n \n private JMenuItem menuItemNew = null; \n \n private JMenuItem menuItemOpen = null; \n \n private JMenuItem menuItemPersist = null; \n \n public MainFormImpl() { \n  super(); \n  this.projectFormImpl = new ProjectFormImpl(); \n  this.cqFormImpl = new CompetenceQuestionsFormImpl(); \n  this.termsFormImpl = new TermsFormImpl(); \n  initialize(); \n } \n \n private void initialize() { \n  JFrame.setDefaultLookAndFeelDecorated(true); \n  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n  this.setJMenuBar(getAppMenuBar()); \n  this.setContentPane(getJContentPane()); \n  this.setVisible(true); \n  final int width = UtilClass.APP_WIDTH; \n  final int heigth = UtilClass.APP_HEIGTH; \n  this.setSize(width, heigth); \n  { \n   Toolkit toolkit = Toolkit.getDefaultToolkit(); \n   final int sysWidth  = toolkit.getScreenSize().width; \n   final int sysHeight = toolkit.getScreenSize().height; \n   final int locWidth = (sysWidth/2 - width/2); \n   final int locHeigth = (sysHeight/2 - heigth/2); \n   this.setLocation( \n     (locWidth > 0 ? locWidth : 100), \n     (locHeigth > 0 ? locHeigth : 100)); \n  } \n  this.setTitle(\"CQPlugin\"); \n \n this.projectFormImpl.setSplitPaneDividerLocation(this.getWidth()/2); \n } \n  \n private void showInforMessage(final String message) { \n  JOptionPane.showMessageDialog(this, message); \n } \n \n private JPanel getJContentPane() { \n  if (jContentPane == null) { \n   jContentPane = new JPanel(); \n   jContentPane.setLayout(new CardLayout()); \n   jContentPane.add(getTabBar(), getTabBar().getName()); \n  } \n  return jContentPane; \n } \n  \n public ProjectFormImpl getProjectFormImpl() { \n  return projectFormImpl; \n } \n \n public CompetenceQuestionsFormImpl getCompetenceQuestionsFormImpl() { \n  return cqFormImpl; \n } \n \n public TermsFormImpl getTermsFormImpl() { \n  return termsFormImpl; \n } \n  \n /*---------------------- \n  * Manipulation Methods: \n  ----------------------*/ \n private void slotOnMenuFileNewCommand() { \n  if (this.fileDialog == null) { \n\n\n\n  \n\n   fileDialog = new JFileChooser(); \n  } \n   \n  final int resposta = fileDialog.showDialog(this, \nNEW_PROJECT_DIALOG_TITLE); \n  if (resposta == JFileChooser.APPROVE_OPTION) { \n   File newFile = this.fileDialog.getSelectedFile(); \n   if (newFile != null) { \n    String fileName = newFile.getName();; \n    String fileAddress = newFile.getAbsolutePath(); \n    if (UtilClass.validateFileName(fileName)) { \n     this.presenter.startNewFile(fileName, \nfileAddress); \n    } else { \n     this.showInforMessage(\"The new file must \nhave the \\\"\"+UtilClass.APP_FILE_EXT+\"\\\" extension.\"); \n    } \n   } else { \n    this.showInforMessage(\"You must type or selected \na new file to begin.\"); \n   } \n  } \n } \n \n private void slotOnMenuFileOpenCommand() { \n  if (this.fileDialog == null) { \n   fileDialog = new JFileChooser(); \n  } \n   \n  final int resposta = fileDialog.showOpenDialog(this); \n  if (resposta == JFileChooser.APPROVE_OPTION) { \n   File newFile = this.fileDialog.getSelectedFile(); \n   if (newFile != null) { \n    String fileName = newFile.getName();; \n    String fileAddress = newFile.getAbsolutePath(); \n    if (UtilClass.validateFileName(fileName)) { \n     this.presenter.openFile(fileName, \nfileAddress); \n    } else { \n     this.showInforMessage(\"The file must have \nthe \\\"\"+UtilClass.APP_FILE_EXT+\"\\\" extension.\"); \n    } \n   } else { \n    this.showInforMessage(\"You must type or selected \na file to open.\"); \n   } \n  } \n } \n \n /*------------------- \n  * Interface Methods: \n  -------------------*/ \n @Override \n public&lt;T extends Presenter> void registerPresenter(T presenter) { \n  this.presenter = (MainPresenter)presenter; \n } \n \n @Override \n public void close() { \n  super.dispose(); \n } \n  \n @Override \n public void setAppTitle(String appTitle) { \n  this.setTitle(appTitle); \n } \n  \n @Override \n public void setMainFormEnabled(boolean enabled) { \n  this.menuFile.setEnabled(enabled); \n  this.allowViewChanges(enabled); \n } \n  \n @Override \n public void allowViewChanges(boolean allowed) { \n  this.tabBar.setEnabled(allowed); \n } \n  \n @Override \n public void selectProjectView() { \n\n\n\n  \n\n  this.tabBar.setSelectedIndex(Modules.PROJECT_FORM.ordinal()); \n } \n  \n @Override \n public void selectCompetenceQuestionsView() { \n \n this.tabBar.setSelectedIndex(Modules.COMPETENCE_QUESTIONS_FORM.ordinal(\n)); \n } \n  \n @Override \n public void selectTermsView() { \n  this.tabBar.setSelectedIndex(Modules.TERMS_FORM.ordinal()); \n } \n  \n @Override \n public void showMessage(MESSAGES message) { \n  final String viewMessage; \n  switch (message) { \n  case FAIL_ON_OPEN_PROJECT: { \n   viewMessage = \n    \"There was a problem on open the project.\\n\" + \n    \"Check the XML file structure!\"; \n   break; \n  } \n  case NO_PROJECT_TO_PERSIST: { \n   viewMessage = \"There is no open project to persist.\"; \n   break; \n  } \n  case FAIL_ON_PROJECT_PERSISTENCE: { \n   viewMessage = \"There was a problem on the persistence of \nthe project.\"; \n   break; \n  } \n  case PROJECT_PERSISTED: { \n   viewMessage = \"The project was persisted successfully.\"; \n   break; \n  } \n  default: { \n   viewMessage = null; \n   break; \n  } \n  } \n   \n  if (viewMessage != null) { \n   this.showInforMessage(viewMessage); \n  } \n } \n  \n private JTabbedPane getTabBar() { \n  if (tabBar == null) { \n   tabBar = new JTabbedPane(); \n   tabBar.setName(\"tabBar\"); \n    \n   tabBar.addTab(Modules.PROJECT_FORM.getTabTitle(), \ngetProjectFormImpl()); \n  \n tabBar.addTab(Modules.COMPETENCE_QUESTIONS_FORM.getTabTitle(), \ngetCompetenceQuestionsFormImpl()); \n   tabBar.addTab(Modules.TERMS_FORM.getTabTitle(), \ngetTermsFormImpl()); \n  } \n  return tabBar; \n } \n \n private JMenuBar getAppMenuBar() { \n  if (appMenuBar == null) { \n   appMenuBar = new JMenuBar(); \n   appMenuBar.add(getMenuFile()); \n  } \n  return appMenuBar; \n } \n \n private JMenu getMenuFile() { \n  if (menuFile == null) { \n   menuFile = new JMenu(); \n   menuFile.setText(\"File\"); \n   menuFile.add(getMenuItemNew()); \n   menuFile.add(getMenuItemOpen()); \n   menuFile.add(getMenuItemPersist()); \n\n\n\n  \n\n  } \n  return menuFile; \n } \n \n private JMenuItem getMenuItemNew() { \n  if (menuItemNew == null) { \n   menuItemNew = new JMenuItem(); \n   menuItemNew.setText(\"New...\"); \n   menuItemNew.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n     \n MainFormImpl.this.slotOnMenuFileNewCommand(); \n     } \n    } \n   }); \n  } \n  return menuItemNew; \n } \n \n private JMenuItem getMenuItemOpen() { \n  if (menuItemOpen == null) { \n   menuItemOpen = new JMenuItem(); \n   menuItemOpen.setText(\"Open...\"); \n   menuItemOpen.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n     \n MainFormImpl.this.slotOnMenuFileOpenCommand(); \n     } \n    } \n   }); \n  } \n  return menuItemOpen; \n } \n \n private JMenuItem getMenuItemPersist() { \n  if (menuItemPersist == null) { \n   menuItemPersist = new JMenuItem(); \n   menuItemPersist.setText(\"Persist project...\"); \n   menuItemPersist.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      presenter.persistProject(); \n     } \n    } \n   }); \n  } \n  return menuItemPersist; \n } \n} \n \n\n? Classe TermFormImpl.java: \npackage gui; \n \nimport java.awt.Dimension; \nimport java.awt.FlowLayout; \nimport java.awt.GridBagConstraints; \nimport java.awt.GridBagLayout; \nimport java.awt.Insets; \nimport java.util.ArrayList; \nimport java.util.LinkedHashMap; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \nimport java.util.Vector; \n \nimport javax.swing.JButton; \nimport javax.swing.JComboBox; \nimport javax.swing.JDesktopPane; \nimport javax.swing.JInternalFrame; \nimport javax.swing.JLabel; \n\n\n\n  \n\nimport javax.swing.JList; \nimport javax.swing.JOptionPane; \nimport javax.swing.JPanel; \nimport javax.swing.JScrollPane; \nimport javax.swing.JSplitPane; \nimport javax.swing.JTabbedPane; \nimport javax.swing.SwingConstants; \nimport javax.swing.WindowConstants; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport system.utils.UtilClass.MESSAGES; \nimport view.terms.TermsForm; \nimport view.terms.TermsPresenter; \n \npublic class TermsFormImpl extends JDesktopPane implements TermsForm { \n \n private static final long serialVersionUID = 1L; \n  \n private List<String> orderedTerms = null; \n private List<String> notOrderedTerms = null; \n  \n private List<String> combineTermsList = null; \n private Set<Integer> commonQuestions = null; \n private Set<Integer> commonAnswers = null; \n  \n private TermsPresenter presenter; \n \n private JPanel panelExtractCommands = null; \n private JButton buttonExtractTerms = null; \n private JScrollPane scrollPaneExtractedTerms = null; \n private JPanel panelMiddleButtons = null; \n private JButton buttonAddTerm = null; \n private JScrollPane scrollPaneChosenTerms = null; \n private JPanel panelPersistCommands = null; \n private JButton buttonPersistTerms = null; \n private JButton buttonCombineTerms = null; \n private JButton buttonOrderTerms = null; \n private JButton buttonRemoveTerm = null; \n private JListTerms jListExtractedTerms = null; \n private JListTerms jListChosenTerms = null; \n private JTabbedPane tabbedPaneExtractedTerms = null; \n private JTabbedPane tabbedPaneChosenTerms = null; \n private JPanel panelOrderBy = null; \n private JLabel captionOrderBy = null; \n private JComboBox comboBoxOrderBy = null; \n private JInternalFrame jInternalFrameOrderTerms = null; \n private JPanel jContentPaneOrderTerms = null; \n private JSplitPane jSplitPaneOrderTerms = null; \n private JScrollPane scrollPaneNotOrderedTerms = null; \n private JScrollPane scrollPaneOrderedTerms = null; \n private JList jListNotOrderedTerms = null; \n private JList jListOrderedTerms = null; \n private JLabel captionNotOrderedTerms = null; \n private JLabel captionOrderedTerms = null; \n private JPanel panelNotOrderedTerms = null; \n private JPanel panelOrderedTerms = null; \n private JPanel bottomBarOrderTerms = null; \n private JButton buttonOrderTermsConfirm = null; \n private JButton buttonOrderTermsCancel = null; \n private JButton buttonAddToOrderedTerms = null; \n private JButton buttonRemoveToNotOrderedTerms = null; \n private JButton buttonOrderUp = null; \n private JButton buttonOrderDown = null; \n private JInternalFrame jInternalFrameCombineTerms = null; \n private JPanel jContentPaneCombineTerms = null; \n private JScrollPane scrollPaneCombineTerms = null; \n private JList jListCombineTerms = null; \n private JPanel bottomBarCombineTerms = null; \n private JButton buttonCombineTermsConfirm = null; \n private JButton buttonCombineTermsCancel = null; \n private JPanel panelButtonsCombineTerms = null; \n private JButton buttonCombineTermsUp = null; \n private JButton buttonCombineTermsDown = null; \n private JButton buttonCombineTermsAdd = null; \n \n public TermsFormImpl() { \n  super(); \n  initialize(); \n } \n\n\n\n  \n\n \n private void initialize() { \n  GridBagConstraints gridBagConstraints2 = new \nGridBagConstraints(); \n  gridBagConstraints2.gridx = 3; \n  gridBagConstraints2.fill = GridBagConstraints.BOTH; \n  gridBagConstraints2.gridy = 0; \n  GridBagConstraints gridBagConstraints31 = new \nGridBagConstraints(); \n  gridBagConstraints31.fill = GridBagConstraints.BOTH; \n  gridBagConstraints31.gridy = 1; \n  gridBagConstraints31.weightx = 1.0; \n  gridBagConstraints31.weighty = 1.0; \n  gridBagConstraints31.anchor = GridBagConstraints.EAST; \n  gridBagConstraints31.insets = new Insets(0, 2, 2, 2); \n  gridBagConstraints31.gridwidth = 1; \n  gridBagConstraints31.gridx = 5; \n  GridBagConstraints gridBagConstraints22 = new \nGridBagConstraints(); \n  gridBagConstraints22.fill = GridBagConstraints.BOTH; \n  gridBagConstraints22.gridy = 1; \n  gridBagConstraints22.weightx = 1.0; \n  gridBagConstraints22.weighty = 1.0; \n  gridBagConstraints22.gridwidth = 1; \n  gridBagConstraints22.insets = new Insets(0, 2, 2, 2); \n  gridBagConstraints22.anchor = GridBagConstraints.WEST; \n  gridBagConstraints22.gridx = 0; \n  GridBagConstraints gridBagConstraints21 = new \nGridBagConstraints(); \n  gridBagConstraints21.gridx = 5; \n  gridBagConstraints21.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints21.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints21.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints21.gridy = 0; \n  GridBagConstraints gridBagConstraints3 = new \nGridBagConstraints(); \n  gridBagConstraints3.gridx = 3; \n  gridBagConstraints3.insets = new Insets(2, 2, 2, 2); \n  gridBagConstraints3.fill = GridBagConstraints.VERTICAL; \n  gridBagConstraints3.ipadx = 0; \n  gridBagConstraints3.ipady = 0; \n  gridBagConstraints3.gridy = 1; \n  GridBagConstraints gridBagConstraints = new \nGridBagConstraints(); \n  gridBagConstraints.gridx = 0; \n  gridBagConstraints.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints.gridy = 0; \n  this.setSize(600, 300); \n  this.setLayout(new GridBagLayout()); \n  this.add(getPanelExtractCommands(), gridBagConstraints); \n  this.add(getTabbedPaneExtractedTerms(), gridBagConstraints22); \n  this.add(getPanelMiddleButtons(), gridBagConstraints3); \n  this.add(getPanelPersistCommands(), gridBagConstraints21); \n  this.add(getTabbedPaneChosenTerms(), gridBagConstraints31); \n  this.add(getPanelOrderBy(), gridBagConstraints2); \n } \n  \n private void showInfoMessage(final String message) { \n  JOptionPane.showMessageDialog(this, message); \n } \n  \n /*------------------- \n  * Overrided Methods: \n  -------------------*/ \n @Override \n public void setVisible(boolean flag) { \n  super.setVisible(flag); \n  if (this.presenter != null) { \n   if (flag) { \n    this.presenter.fillIn(); \n   } else { \n    this.presenter.fillOut(); \n   } \n  } \n } \n  \n /*------------------- \n  * Interface Methods: \n\n\n\n  \n\n  -------------------*/ \n @Override \n public OrderByOptions getOrderByOption() { \n  final int orderChoise = this.getOrderChoise(); \n  if (orderChoise >= 0) { \n   return OrderByOptions.getOptionByOrdinal(orderChoise); \n  } \n  return null; \n } \n  \n @Override \n public List<String> getNotOrderedTerms() { \n  return this.notOrderedTerms; \n } \n  \n @Override \n public List<String> getOrderedTerms() { \n  return this.orderedTerms; \n } \n  \n @Override \n public void setModalMode(boolean modalEnabled) { \n  final boolean visible = !modalEnabled; \n   \n  this.panelOrderBy.setVisible(visible); \n  this.panelExtractCommands.setVisible(visible); \n  this.panelPersistCommands.setVisible(visible); \n  this.panelMiddleButtons.setVisible(visible);   \n  this.tabbedPaneExtractedTerms.setVisible(visible); \n  this.tabbedPaneChosenTerms.setVisible(visible); \n } \n  \n @Override \n public void showException(MESSAGES exceptionEnum) { \n  String message = null; \n  switch (exceptionEnum) { \n   case EXTRACT_TERMS_EXCEPTION: { \n    message = \"Houve um problema durante a extra\u00e7\u00e3o \ndos termos!\"; \n    break; \n   } \n   case NO_COMMON_ORIGINS: { \n    message = \"Os termos precisam ter perguntas de \ncompet\u00eancia (ou respostas) em comum para serem combinados.\"; \n    break; \n   } \n  } \n  if (message != null &amp;&amp; !message.isEmpty()) { \n   this.showInfoMessage(message); \n  } \n } \n \n @Override \n public&lt;T extends Presenter> void registerPresenter(T presenter) { \n  this.presenter = (TermsPresenter)presenter; \n } \n  \n @Override \n public void setExtractedTermsList(final Map<String, String> \nextractedTermsMap) { \n  this.jListExtractedTerms.setData(extractedTermsMap); \n } \n  \n @Override \n public void setChosenTermsList(Map<String, String> chosenTermsMap) { \n  this.jListChosenTerms.setData(chosenTermsMap); \n } \n  \n @Override \n public void setTermsPersistenceNeed(final boolean needed) { \n  this.buttonPersistTerms.setEnabled(needed); \n } \n  \n @Override \n public void showDetailToExtractTerms( \n   final Map<String, Integer> availableCategoriesToExtract) \n{ \n  if (availableCategoriesToExtract != null &amp;&amp; \n    availableCategoriesToExtract.size() > 0) { \n   final String choice = this.showExtractTermsDialog( \n\n\n\n  \n\n    \n availableCategoriesToExtract.keySet().toArray(new String[]{})); \n   if (choice != null &amp;&amp; !choice.isEmpty()) { \n    final Integer categoryID = \navailableCategoriesToExtract.get(choice); \n    presenter.extractTerms(categoryID); \n   } \n  } else { \n   this.showInfoMessage( \n     \"There aren't competence questions \navailable\\n\" + \n     \"for the extraction of terms.\"); \n  } \n } \n  \n @Override \n public void showDetailToRemoveTerms(final List<String> termsList) { \n  final String title = \"Removing chosen term...\"; \n  final String message = \"You really want to remove the selected \nchosen term(s)?\"; \n  final int choice = JOptionPane.showConfirmDialog(this, message, \ntitle, JOptionPane.OK_CANCEL_OPTION); \n  if (choice == JOptionPane.OK_OPTION) { \n   presenter.removeChosenTerms(termsList); \n  } \n } \n  \n @Override \n public void showDetailToOrderTerms(final List<String> orderedTerms, \n   final List<String> notOrderedTerms) { \n  if (orderedTerms != null &amp;&amp; notOrderedTerms != null &amp;&amp; \n    (orderedTerms.size() > 0 || \nnotOrderedTerms.size() > 0)) { \n   this.showOrderTermsDetail(orderedTerms, \nnotOrderedTerms); \n  } else { \n   this.showInfoMessage(\"No terms available to order.\"); \n  } \n } \n  \n @Override \n public void finishOrderTerms() { \n  if (this.jInternalFrameOrderTerms != null) { \n   this.jInternalFrameOrderTerms.doDefaultCloseAction(); \n  } \n } \n  \n @Override \n public void showDetailToCombineTerms(final List<String> termsList, \n   final Set<Integer> commonQuestions, final Set<Integer> \ncommonAnswers) { \n  this.combineTermsList = termsList; \n  this.commonQuestions = commonQuestions; \n  this.commonAnswers = commonAnswers; \n  if (this.jInternalFrameCombineTerms == null) { \n   this.add(this.getJInternalFrameCombineTerms(), null); \n  } \n  this.jInternalFrameCombineTerms.show(); \n  this.refreshCombineTermsList(); \n } \n  \n @Override \n public void finishCombineTerms(final MESSAGES message) { \n  if (jInternalFrameCombineTerms != null) { \n   jInternalFrameCombineTerms.doDefaultCloseAction(); \n  } \n  if (message == null) { \n   this.jListExtractedTerms.setSelectedIndices(new int[0]); \n  } else { \n   switch (message) { \n    case TERM_ALLREADY_EXIST: \n     this.showInfoMessage(\"O termo resultante \nda combina\u00e7\u00e3o j\u00e1 existe nos termos escolhidos.\"); \n     break; \n    case COMBINE_TERMS_EXCEPTION: \n     this.showInfoMessage(\"Houve um problema \ndurante a combina\u00e7\u00e3o dos termos!\"); \n     break; \n   } \n  } \n\n\n\n  \n\n } \n \n /*------------------------ \n  * Inner Details Methods: \n  ------------------------*/ \n private String showExtractTermsDialog(final String[] selectionValues) { \n  final String title = \"Terms extraction...\"; \n  final String message = \n   \"Select a category to perform the extraction\\n\" + \n   \"of the terms of their competence questions.\"; \n  return (String)JOptionPane.showInputDialog( \n    this, message, title, \nJOptionPane.OK_CANCEL_OPTION, null, \n    selectionValues, selectionValues[0]); \n } \n  \n private void showOrderTermsDetail(final List<String> orderedTerms, \n   final List<String> notOrderedTerms) { \n  this.orderedTerms = orderedTerms; \n  this.notOrderedTerms = notOrderedTerms; \n  if (this.jInternalFrameOrderTerms == null) { \n   this.add(this.getJInternalFrameOrderTerms(), null); \n  } \n  this.jInternalFrameOrderTerms.show(); \n  this.refreshNotOrderedListData(); \n  this.refreshOrderedListData(); \n } \n  \n /*---------------------- \n  * Manipulation Methods: \n  ----------------------*/ \n private void refreshOrderedListData() { \n  this.jListOrderedTerms.setListData(new \nVector<String>(this.orderedTerms)); \n } \n  \n private void refreshNotOrderedListData() { \n  this.jListNotOrderedTerms.setListData(new \nVector<String>(this.notOrderedTerms)); \n } \n  \n private void addToOrderedTermsList(final int[] selectedIndices) { \n  final List<String> auxList = new \nArrayList<String>(selectedIndices.length); \n  for (int index : selectedIndices) { \n   auxList.add(this.notOrderedTerms.get(index)); \n  } \n  this.orderedTerms.addAll(auxList); \n  this.notOrderedTerms.removeAll(auxList); \n  this.refreshNotOrderedListData(); \n  this.refreshOrderedListData(); \n } \n  \n private void removeToNotOrderedList(final int[] selectedIndices) { \n  final List<String> auxList = new \nArrayList<String>(selectedIndices.length); \n  for (int index : selectedIndices) { \n   auxList.add(this.orderedTerms.get(index)); \n  } \n  this.notOrderedTerms.addAll(auxList); \n  this.orderedTerms.removeAll(auxList); \n  this.refreshNotOrderedListData(); \n  this.refreshOrderedListData(); \n } \n  \n private void setOrderUp(final int index) { \n  if (index > 0) { \n   final String movedTerm = this.orderedTerms.get(index); \n   final int newPosition = index-1; \n   final int length = this.orderedTerms.size(); \n   final List<String> auxList = new \nArrayList<String>(length); \n   for (int i=0; i &lt;length; i++) { \n    if (i == newPosition) { \n     auxList.add(movedTerm); \n     auxList.add(this.orderedTerms.get(i)); \n    } else if (i != index) { \n     auxList.add(this.orderedTerms.get(i)); \n    } \n   } \n\n\n\n  \n\n   this.orderedTerms = auxList; \n   this.refreshOrderedListData(); \n   this.jListOrderedTerms.setSelectedIndex(newPosition); \n  } \n } \n  \n private void setOrderDown(final int index) { \n  final int length = this.orderedTerms.size(); \n  if (index &lt;(length-1)) { \n   final String movedTerm = this.orderedTerms.get(index); \n   final int newPosition = index+1; \n   final List<String> auxList = new \nArrayList<String>(length); \n   for (int i=0; i &lt;length; i++) { \n    if (i == newPosition) { \n     auxList.add(this.orderedTerms.get(i)); \n     auxList.add(movedTerm); \n    } else if (i != index) { \n     auxList.add(this.orderedTerms.get(i)); \n    } \n   } \n   this.orderedTerms = auxList; \n   this.refreshOrderedListData(); \n   this.jListOrderedTerms.setSelectedIndex(newPosition); \n  } \n } \n  \n private void refreshCombineTermsList() { \n  this.jListCombineTerms.setListData(new \nVector<String>(this.combineTermsList)); \n } \n  \n private void setCombineOrderUp(final int index) { \n  if (index > 0) { \n   final String movedTerm = \nthis.combineTermsList.get(index); \n   final int newPosition = index-1; \n   final int length = this.combineTermsList.size(); \n   final List<String> auxList = new \nArrayList<String>(length); \n   for (int i=0; i &lt;length; i++) { \n    if (i == newPosition) { \n     auxList.add(movedTerm); \n    \n auxList.add(this.combineTermsList.get(i)); \n    } else if (i != index) { \n    \n auxList.add(this.combineTermsList.get(i)); \n    } \n   } \n   this.combineTermsList = auxList; \n   this.refreshCombineTermsList(); \n   this.jListCombineTerms.setSelectedIndex(newPosition); \n  } \n } \n  \n private void setCombineOrderDown(final int index) { \n  final int length = this.combineTermsList.size(); \n  if (index &lt;(length-1)) { \n   final String movedTerm = \nthis.combineTermsList.get(index); \n   final int newPosition = index+1; \n   final List<String> auxList = new \nArrayList<String>(length); \n   for (int i=0; i &lt;length; i++) { \n    if (i == newPosition) { \n    \n auxList.add(this.combineTermsList.get(i)); \n     auxList.add(movedTerm); \n    } else if (i != index) { \n    \n auxList.add(this.combineTermsList.get(i)); \n    } \n   } \n   this.combineTermsList = auxList; \n   this.refreshCombineTermsList(); \n   this.jListCombineTerms.setSelectedIndex(newPosition); \n  } \n } \n  \n\n\n\n  \n\n private void addPrepositionToCombineTerms() { \n  final String title = \"Adding a preposition to combine terms...\"; \n  final String message = \"Informe a preposi\u00e7\u00e3o que deseja \ninserir:\"; \n  final String preposition = JOptionPane.showInputDialog(this, \nmessage, title, JOptionPane.OK_CANCEL_OPTION); \n   \n  if (preposition != null &amp;&amp; !preposition.trim().isEmpty()) { \n   final int length = this.combineTermsList.size(); \n   final List<String> auxList = new \nArrayList<String>(length+1); \n   final String addedTerm = \nUtilClass.formatTermsMapKey(preposition.trim()); \n   auxList.add(addedTerm); \n   for (int i=0; i &lt;length; i++) { \n    auxList.add(this.combineTermsList.get(i)); \n   } \n   this.combineTermsList = auxList; \n   this.refreshCombineTermsList(); \n   this.jListCombineTerms.setSelectedIndex(0); \n  } \n } \n  \n /*--------------- \n  * Inner Classes: \n  ---------------*/ \n private class JListTerms extends JList { \n \n  private static final long serialVersionUID = 1L; \n   \n  private Map<Integer, String> mapIndexToDataID; \n   \n  public JListTerms() { \n   super(); \n  } \n   \n  /** \n   * @deprecated usar setData(Map<String, String> termsMap) \n   */ \n  @Override \n  public void setListData(Object[] listData) { \n   super.setListData(listData); \n  } \n   \n  /** \n   * @deprecated usar setData(Map<String, String> termsMap) \n   */ \n  @Override \n  public void setListData(Vector<?> listData) { \n   super.setListData(listData); \n  } \n   \n  public void setData(final Map<String, String> termsMap) { \n   final int length = (termsMap != null ? termsMap.size() : \n0); \n   this.mapIndexToDataID = new LinkedHashMap<Integer, \nString>(length); \n   final Vector<String> listData = new \nVector<String>(length); \n    \n   if (length > 0) { \n    final Set<String> keySet = termsMap.keySet(); \n    for (String dataID : keySet) { \n     listData.add(termsMap.get(dataID)); \n    \n this.mapIndexToDataID.put(listData.size()-1, dataID); \n    } \n   } \n    \n   super.setListData(listData); \n  } \n   \n  public String getSelectedDataID() { \n   if (this.mapIndexToDataID != null &amp;&amp; \nthis.mapIndexToDataID.size() > 0) { \n    final int selectedIndex = \nsuper.getSelectedIndex(); \n    if (selectedIndex >= 0) { \n     return \nthis.mapIndexToDataID.get(selectedIndex); \n\n\n\n  \n\n    } \n   } \n   return null; \n  } \n   \n  public List<String> getSelectedDataIDsList() { \n   final int[] selectedIndices = \nsuper.getSelectedIndices(); \n   final int length = selectedIndices.length; \n   final List<String> selectedIDs = new \nArrayList<String>(length); \n   for (int i=0; i &lt;length; i++) { \n   \n selectedIDs.add(this.mapIndexToDataID.get(selectedIndices[i])); \n   } \n   return selectedIDs; \n  } \n   \n } \n  \n private JPanel getPanelExtractCommands() { \n  if (panelExtractCommands == null) { \n   FlowLayout flowLayout = new FlowLayout(); \n   flowLayout.setAlignment(java.awt.FlowLayout.LEFT); \n   panelExtractCommands = new JPanel(); \n   panelExtractCommands.setLayout(flowLayout); \n   panelExtractCommands.add(getButtonExtractTerms(), null); \n  } \n  return panelExtractCommands; \n } \n \n private JButton getButtonExtractTerms() { \n  if (buttonExtractTerms == null) { \n   buttonExtractTerms = new JButton(); \n   buttonExtractTerms.setText(\"Extract...\"); \n  \n buttonExtractTerms.setVerticalAlignment(SwingConstants.BOTTOM); \n   buttonExtractTerms.setToolTipText(\"Extract terms from \nthe competence questions.\"); \n   buttonExtractTerms.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      presenter.doExtractTerms(); \n     } \n    } \n   }); \n  } \n  return buttonExtractTerms; \n } \n \n private JScrollPane getScrollPaneExtractedTerms() { \n  if (scrollPaneExtractedTerms == null) { \n   scrollPaneExtractedTerms = new JScrollPane(); \n  \n scrollPaneExtractedTerms.setViewportView(getJListExtractedTerms()); \n  } \n  return scrollPaneExtractedTerms; \n } \n \n private JPanel getPanelMiddleButtons() { \n  if (panelMiddleButtons == null) { \n   GridBagConstraints gridBagConstraints1 = new \nGridBagConstraints(); \n   gridBagConstraints1.gridx = 0; \n   gridBagConstraints1.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints1.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints1.gridy = 1; \n   GridBagConstraints gridBagConstraints4 = new \nGridBagConstraints(); \n   gridBagConstraints4.gridx = 0; \n   gridBagConstraints4.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints4.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints4.gridy = 0; \n   panelMiddleButtons = new JPanel(); \n   panelMiddleButtons.setLayout(new GridBagLayout()); \n\n\n\n  \n\n   panelMiddleButtons.add(getButtonAddTerm(), \ngridBagConstraints4); \n   panelMiddleButtons.add(getButtonCombineTerms(), \ngridBagConstraints1); \n  } \n  return panelMiddleButtons; \n } \n \n private JButton getButtonAddTerm() { \n  if (buttonAddTerm == null) { \n   buttonAddTerm = new JButton(); \n   buttonAddTerm.setText(\"Add \u00bb\"); \n   buttonAddTerm.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final List<String> selectedIDs = \njListExtractedTerms.getSelectedDataIDsList(); \n      if (selectedIDs.size() == 0) { \n       showInfoMessage(\"Select, at \nleast, one extracted term to add.\"); \n      } else { \n      \n presenter.addExtractedTerms(selectedIDs); \n      } \n     } \n    } \n   }); \n  } \n  return buttonAddTerm; \n } \n \n private JScrollPane getScrollPaneChosenTerms() { \n  if (scrollPaneChosenTerms == null) { \n   scrollPaneChosenTerms = new JScrollPane(); \n  \n scrollPaneChosenTerms.setViewportView(getJListSelectedTerms()); \n  } \n  return scrollPaneChosenTerms; \n } \n \n private JPanel getPanelPersistCommands() { \n  if (panelPersistCommands == null) { \n   FlowLayout flowLayout1 = new FlowLayout(); \n   flowLayout1.setAlignment(java.awt.FlowLayout.RIGHT); \n   panelPersistCommands = new JPanel(); \n   panelPersistCommands.setLayout(flowLayout1); \n   panelPersistCommands.add(getButtonRemoveTerm(), null); \n   panelPersistCommands.add(getButtonOrderTerms(), null); \n   panelPersistCommands.add(getButtonPersistTerms(), null); \n  } \n  return panelPersistCommands; \n } \n \n private JButton getButtonPersistTerms() { \n  if (buttonPersistTerms == null) { \n   buttonPersistTerms = new JButton(); \n   buttonPersistTerms.setText(\"Persist\"); \n  \n buttonPersistTerms.setVerticalAlignment(SwingConstants.BOTTOM); \n   buttonPersistTerms.setToolTipText(\"Persist the chosen \nterms.\"); \n   buttonPersistTerms.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      presenter.persistTerms(); \n     } \n    } \n   }); \n  } \n  return buttonPersistTerms; \n } \n \n private JButton getButtonCombineTerms() { \n  if (buttonCombineTerms == null) { \n   buttonCombineTerms = new JButton(); \n   buttonCombineTerms.setText(\"Combine\"); \n\n\n\n  \n\n  \n buttonCombineTerms.setVerticalAlignment(SwingConstants.BOTTOM); \n   buttonCombineTerms.setToolTipText(\"Combine some \nextracted terms to generate a single one to add.\"); \n   buttonCombineTerms.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final List<String> selectedIDs = \njListExtractedTerms.getSelectedDataIDsList(); \n      final int length = \nselectedIDs.size(); \n      if (length >= 2) { \n      \n presenter.doCombineTerms(selectedIDs); \n      } else { \n       showInfoMessage(\"Selecione \nao menos 2 termos para combinar.\"); \n      } \n     } \n    } \n   }); \n  } \n  return buttonCombineTerms; \n } \n \n private JButton getButtonOrderTerms() { \n  if (buttonOrderTerms == null) { \n   buttonOrderTerms = new JButton(); \n   buttonOrderTerms.setText(\"Order...\"); \n  \n buttonOrderTerms.setVerticalAlignment(SwingConstants.BOTTOM); \n   buttonOrderTerms.setToolTipText(\"Order the chosen \nterms.\"); \n   buttonOrderTerms.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      presenter.doOrderTerms(); \n     } \n    } \n   }); \n  } \n  return buttonOrderTerms; \n } \n \n private JButton getButtonRemoveTerm() { \n  if (buttonRemoveTerm == null) { \n   buttonRemoveTerm = new JButton(); \n   buttonRemoveTerm.setText(\"Remove\"); \n  \n buttonRemoveTerm.setVerticalAlignment(SwingConstants.BOTTOM); \n   buttonRemoveTerm.setToolTipText(\"Remove the selected \nchosen terms.\"); \n   buttonRemoveTerm.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      final List<String> selectedIDs = \njListChosenTerms.getSelectedDataIDsList(); \n      if (selectedIDs.size() == 0) { \n       showInfoMessage(\"Select, at \nleast, one chosen term to remove.\"); \n      } else { \n      \n presenter.doRemoveTerm(selectedIDs); \n      } \n     } \n    } \n   }); \n  } \n  return buttonRemoveTerm; \n } \n \n private JListTerms getJListExtractedTerms() { \n  if (jListExtractedTerms == null) { \n   jListExtractedTerms = new JListTerms(); \n\n\n\n  \n\n  } \n  return jListExtractedTerms; \n } \n \n private JListTerms getJListSelectedTerms() { \n  if (jListChosenTerms == null) { \n   jListChosenTerms = new JListTerms(); \n  } \n  return jListChosenTerms; \n } \n \n private JTabbedPane getTabbedPaneExtractedTerms() { \n  if (tabbedPaneExtractedTerms == null) { \n   tabbedPaneExtractedTerms = new JTabbedPane(); \n   tabbedPaneExtractedTerms.addTab(\"Extracted Terms\", null, \ngetScrollPaneExtractedTerms(), null); \n  } \n  return tabbedPaneExtractedTerms; \n } \n \n private JTabbedPane getTabbedPaneChosenTerms() { \n  if (tabbedPaneChosenTerms == null) { \n   tabbedPaneChosenTerms = new JTabbedPane(); \n   tabbedPaneChosenTerms.addTab(\"Chosen Terms\", null, \ngetScrollPaneChosenTerms(), null); \n  } \n  return tabbedPaneChosenTerms; \n } \n \n private JPanel getPanelOrderBy() { \n  if (panelOrderBy == null) { \n   GridBagConstraints gridBagConstraints6 = new \nGridBagConstraints(); \n   gridBagConstraints6.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints6.gridy = 1; \n   gridBagConstraints6.weightx = 1.0; \n   gridBagConstraints6.insets = new Insets(0, 0, 0, 0); \n   gridBagConstraints6.gridx = 0; \n   GridBagConstraints gridBagConstraints5 = new \nGridBagConstraints(); \n   gridBagConstraints5.gridx = 0; \n   gridBagConstraints5.insets = new Insets(1, 1, 0, 1); \n   gridBagConstraints5.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints5.gridy = 0; \n   captionOrderBy = new JLabel(); \n   captionOrderBy.setText(\"Order by:\"); \n   panelOrderBy = new JPanel(); \n   panelOrderBy.setLayout(new GridBagLayout()); \n   panelOrderBy.setVisible(true); \n   panelOrderBy.add(captionOrderBy, gridBagConstraints5); \n   panelOrderBy.add(getComboBoxOrderBy(), \ngridBagConstraints6); \n  } \n  return panelOrderBy; \n } \n \n private JComboBox getComboBoxOrderBy() { \n  if (comboBoxOrderBy == null) { \n   comboBoxOrderBy = new JComboBox(); \n   this.loadOrderByItems(); \n   comboBoxOrderBy.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (presenter != null) { \n      presenter.changeListsOrdenation(); \n     } \n    } \n   }); \n  } \n  return comboBoxOrderBy; \n } \n \n private void loadOrderByItems() { \n  final int length = TermsForm.OrderByOptions.values().length; \n  for (int i=0; i &lt;length; i++) { \n   this.comboBoxOrderBy.addItem( \n\n\n\n  \n\n    \n TermsForm.OrderByOptions.getOptionByOrdinal(i).getLabel()); \n  } \n } \n  \n private int getOrderChoise() { \n  if (this.comboBoxOrderBy != null) { \n   return this.comboBoxOrderBy.getSelectedIndex(); \n  } \n  return -1; \n } \n \n private JInternalFrame getJInternalFrameOrderTerms() { \n  if (jInternalFrameOrderTerms == null) { \n   jInternalFrameOrderTerms = new JInternalFrame(); \n  \n jInternalFrameOrderTerms.setDefaultCloseOperation(WindowConstants.HIDE_\nON_CLOSE); \n   final Dimension size = new Dimension(400, 300); \n   jInternalFrameOrderTerms.setSize(size); \n   jInternalFrameOrderTerms.setMinimumSize(size); \n   jInternalFrameOrderTerms.setTitle(\"Order chosen terms\"); \n  \n jInternalFrameOrderTerms.setContentPane(getJContentPaneOrderTerms()); \n   jInternalFrameOrderTerms \n     .addComponentListener(new \njava.awt.event.ComponentAdapter() {    \n    public void \ncomponentShown(java.awt.event.ComponentEvent e) {     \n     if (presenter != null) { \n      presenter.setModalMode(true); \n     } \n    } \n    public void \ncomponentHidden(java.awt.event.ComponentEvent e) { \n     orderedTerms = null; \n     notOrderedTerms = null; \n     if (presenter != null) { \n      presenter.setModalMode(false); \n     } \n    } \n     }); \n  } \n  return jInternalFrameOrderTerms; \n } \n \n private JPanel getJContentPaneOrderTerms() { \n  if (jContentPaneOrderTerms == null) { \n   GridBagConstraints gridBagConstraints12 = new \nGridBagConstraints(); \n   gridBagConstraints12.insets = new Insets(0, 2, 2, 2); \n   gridBagConstraints12.gridx = 0; \n   gridBagConstraints12.gridy = 1; \n   gridBagConstraints12.fill = \nGridBagConstraints.HORIZONTAL; \n   captionOrderedTerms = new JLabel(); \n   captionOrderedTerms.setText(\"Ordered Terms:\"); \n   captionNotOrderedTerms = new JLabel(); \n   captionNotOrderedTerms.setText(\"Not Ordered Terms:\"); \n   GridBagConstraints gridBagConstraints7 = new \nGridBagConstraints(); \n   gridBagConstraints7.fill = GridBagConstraints.BOTH; \n   gridBagConstraints7.gridy = 0; \n   gridBagConstraints7.weightx = 1.0; \n   gridBagConstraints7.weighty = 1.0; \n   gridBagConstraints7.gridwidth = 1; \n   gridBagConstraints7.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints7.gridx = 0; \n   jContentPaneOrderTerms = new JPanel(); \n   jContentPaneOrderTerms.setLayout(new GridBagLayout()); \n   jContentPaneOrderTerms.add(getJSplitPaneOrderTerms(), \ngridBagConstraints7); \n   jContentPaneOrderTerms.add(getBottomBarOrderTerms(), \ngridBagConstraints12); \n  } \n  return jContentPaneOrderTerms; \n } \n \n private JSplitPane getJSplitPaneOrderTerms() { \n  if (jSplitPaneOrderTerms == null) { \n\n\n\n  \n\n   jSplitPaneOrderTerms = new JSplitPane(); \n   final int location = \njInternalFrameOrderTerms.getWidth()/2; \n   jSplitPaneOrderTerms.setDividerLocation(location); \n  \n jSplitPaneOrderTerms.setRightComponent(getPanelOrderedTerms()); \n  \n jSplitPaneOrderTerms.setLeftComponent(getPanelNotOrderedTerms()); \n  } \n  return jSplitPaneOrderTerms; \n } \n \n private JScrollPane getScrollPaneNotOrderedTerms() { \n  if (scrollPaneNotOrderedTerms == null) { \n   scrollPaneNotOrderedTerms = new JScrollPane(); \n  \n scrollPaneNotOrderedTerms.setViewportView(getJListNotOrderedTerms()); \n  } \n  return scrollPaneNotOrderedTerms; \n } \n \n private JScrollPane getScrollPaneOrderedTerms() { \n  if (scrollPaneOrderedTerms == null) { \n   scrollPaneOrderedTerms = new JScrollPane(); \n  \n scrollPaneOrderedTerms.setViewportView(getJListOrderedTerms()); \n  } \n  return scrollPaneOrderedTerms; \n } \n \n private JList getJListNotOrderedTerms() { \n  if (jListNotOrderedTerms == null) { \n   jListNotOrderedTerms = new JList(); \n  } \n  return jListNotOrderedTerms; \n } \n \n private JList getJListOrderedTerms() { \n  if (jListOrderedTerms == null) { \n   jListOrderedTerms = new JList(); \n  } \n  return jListOrderedTerms; \n } \n \n private JPanel getPanelNotOrderedTerms() { \n  if (panelNotOrderedTerms == null) { \n   GridBagConstraints gridBagConstraints13 = new \nGridBagConstraints(); \n   gridBagConstraints13.gridx = 0; \n   gridBagConstraints13.anchor = \nGridBagConstraints.NORTHEAST; \n   gridBagConstraints13.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints13.gridy = 0; \n   GridBagConstraints gridBagConstraints8 = new \nGridBagConstraints(); \n   gridBagConstraints8.gridx = -1; \n   gridBagConstraints8.anchor = GridBagConstraints.WEST; \n   gridBagConstraints8.insets = new Insets(2, 2, 0, 2); \n   gridBagConstraints8.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints8.gridy = 1; \n   GridBagConstraints gridBagConstraints10 = new \nGridBagConstraints(); \n   gridBagConstraints10.fill = GridBagConstraints.BOTH; \n   gridBagConstraints10.weighty = 1.0; \n   gridBagConstraints10.gridheight = 1; \n   gridBagConstraints10.gridx = 0; \n   gridBagConstraints10.gridy = 2; \n   gridBagConstraints10.weightx = 1.0; \n   panelNotOrderedTerms = new JPanel(); \n   panelNotOrderedTerms.setLayout(new GridBagLayout()); \n   panelNotOrderedTerms.add(getButtonAddToOrderedTerms(), \ngridBagConstraints13); \n   panelNotOrderedTerms.add(captionNotOrderedTerms, \ngridBagConstraints8); \n   panelNotOrderedTerms.add(getScrollPaneNotOrderedTerms(), \ngridBagConstraints10); \n  } \n  return panelNotOrderedTerms; \n } \n\n\n\n  \n\n \n private JPanel getPanelOrderedTerms() { \n  if (panelOrderedTerms == null) { \n   GridBagConstraints gridBagConstraints16 = new \nGridBagConstraints(); \n   gridBagConstraints16.gridx = 2; \n   gridBagConstraints16.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints16.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints16.gridy = 0; \n   GridBagConstraints gridBagConstraints15 = new \nGridBagConstraints(); \n   gridBagConstraints15.gridx = 1; \n   gridBagConstraints15.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints15.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints15.gridy = 0; \n   GridBagConstraints gridBagConstraints14 = new \nGridBagConstraints(); \n   gridBagConstraints14.gridx = 0; \n   gridBagConstraints14.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints14.insets = new Insets(2, 2, 2, 2); \n   gridBagConstraints14.fill = GridBagConstraints.NONE; \n   gridBagConstraints14.gridy = 0; \n   GridBagConstraints gridBagConstraints9 = new \nGridBagConstraints(); \n   gridBagConstraints9.gridx = 0; \n   gridBagConstraints9.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints9.insets = new Insets(2, 2, 0, 2); \n   gridBagConstraints9.anchor = GridBagConstraints.WEST; \n   gridBagConstraints9.gridwidth = 3; \n   gridBagConstraints9.gridy = 1; \n   GridBagConstraints gridBagConstraints11 = new \nGridBagConstraints(); \n   gridBagConstraints11.fill = GridBagConstraints.BOTH; \n   gridBagConstraints11.weighty = 1.0; \n   gridBagConstraints11.gridheight = 1; \n   gridBagConstraints11.gridx = 0; \n   gridBagConstraints11.gridy = 2; \n   gridBagConstraints11.gridwidth = 3; \n   gridBagConstraints11.weightx = 1.0; \n   panelOrderedTerms = new JPanel(); \n   panelOrderedTerms.setLayout(new GridBagLayout()); \n   panelOrderedTerms.add(captionOrderedTerms, \ngridBagConstraints9); \n   panelOrderedTerms.add(getScrollPaneOrderedTerms(), \ngridBagConstraints11); \n  \n panelOrderedTerms.add(getButtonRemoveToNotOrderedTerms(), \ngridBagConstraints14); \n   panelOrderedTerms.add(getButtonOrderUp(), \ngridBagConstraints15); \n   panelOrderedTerms.add(getButtonOrderDown(), \ngridBagConstraints16); \n  } \n  return panelOrderedTerms; \n } \n \n private JPanel getBottomBarOrderTerms() { \n  if (bottomBarOrderTerms == null) { \n   bottomBarOrderTerms = new JPanel(); \n   bottomBarOrderTerms.setLayout(new FlowLayout()); \n   bottomBarOrderTerms.add(getButtonOrderTermsConfirm(), \nnull); \n   bottomBarOrderTerms.add(getButtonOrderTermsCancel(), \nnull); \n  } \n  return bottomBarOrderTerms; \n } \n \n private JButton getButtonOrderTermsConfirm() { \n  if (buttonOrderTermsConfirm == null) { \n   buttonOrderTermsConfirm = new JButton(); \n   buttonOrderTermsConfirm.setText(\"Confirm\"); \n   buttonOrderTermsConfirm.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n\n\n\n  \n\n     if (presenter != null) { \n      presenter.doConfirmOrderedTerms(); \n     } \n    } \n   }); \n  } \n  return buttonOrderTermsConfirm; \n } \n \n private JButton getButtonOrderTermsCancel() { \n  if (buttonOrderTermsCancel == null) { \n   buttonOrderTermsCancel = new JButton(); \n   buttonOrderTermsCancel.setText(\"Cancel\"); \n   buttonOrderTermsCancel.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n    \n jInternalFrameOrderTerms.doDefaultCloseAction(); \n    } \n   }); \n  } \n  return buttonOrderTermsCancel; \n } \n \n private JButton getButtonAddToOrderedTerms() { \n  if (buttonAddToOrderedTerms == null) { \n   buttonAddToOrderedTerms = new JButton(); \n   buttonAddToOrderedTerms.setText(\">>\"); \n   buttonAddToOrderedTerms.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (notOrderedTerms != null &amp;&amp; \nnotOrderedTerms.size() > 0) { \n      final int[] selectedIndices = \njListNotOrderedTerms.getSelectedIndices(); \n      final int length = \nselectedIndices.length; \n      if (length == 0) { \n       showInfoMessage(\"Selecione \nao menos um termo para adicionar.\"); \n      } else { \n      \n TermsFormImpl.this.addToOrderedTermsList(selectedIndices); \n      }    \n   \n     } \n    } \n   }); \n  } \n  return buttonAddToOrderedTerms; \n } \n \n private JButton getButtonRemoveToNotOrderedTerms() { \n  if (buttonRemoveToNotOrderedTerms == null) { \n   buttonRemoveToNotOrderedTerms = new JButton(); \n   buttonRemoveToNotOrderedTerms.setText(\"<<\"); \n   buttonRemoveToNotOrderedTerms \n     .addActionListener(new \njava.awt.event.ActionListener() { \n      public void \nactionPerformed(java.awt.event.ActionEvent e) { \n       if (orderedTerms != null &amp;&amp; \norderedTerms.size() > 0) { \n        final int[] \nselectedIndices = jListOrderedTerms.getSelectedIndices(); \n        final int length = \nselectedIndices.length; \n        if (length == 0) { \n        \n showInfoMessage(\"Selecione ao menos um termo ordenado para remover da \nlistagem ordenada\"); \n        } else { \n        \n TermsFormImpl.this.removeToNotOrderedList(selectedIndices); \n        } \n       } \n      } \n     }); \n\n\n\n  \n\n  } \n  return buttonRemoveToNotOrderedTerms; \n } \n \n private JButton getButtonOrderUp() { \n  if (buttonOrderUp == null) { \n   buttonOrderUp = new JButton(); \n   buttonOrderUp.setText(\"UP\"); \n   buttonOrderUp.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (orderedTerms != null &amp;&amp; \norderedTerms.size() > 1) { \n      final int[] selectedIndices = \njListOrderedTerms.getSelectedIndices(); \n      final int length = \nselectedIndices.length; \n      if (length == 1) { \n      \n TermsFormImpl.this.setOrderUp(selectedIndices[0]); \n      } else if (length == 0) { \n       showInfoMessage(\"Selecione \num termo para indicar a ordem.\"); \n      } else { \n       showInfoMessage(\"Apenas um \ntermo pode ser selecionado para se indicar a ordem.\"); \n      } \n     } \n    } \n   }); \n  } \n  return buttonOrderUp; \n } \n \n private JButton getButtonOrderDown() { \n  if (buttonOrderDown == null) { \n   buttonOrderDown = new JButton(); \n   buttonOrderDown.setText(\"DOWN\"); \n   buttonOrderDown.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     if (orderedTerms != null &amp;&amp; \norderedTerms.size() > 1) { \n      final int[] selectedIndices = \njListOrderedTerms.getSelectedIndices(); \n      final int length = \nselectedIndices.length; \n      if (length == 1) { \n      \n TermsFormImpl.this.setOrderDown(selectedIndices[0]); \n      } else if (length == 0) { \n       showInfoMessage(\"Selecione \num termo para indicar a ordem.\"); \n      } else { \n       showInfoMessage(\"Apenas um \ntermo pode ser selecionado para se indicar a ordem.\"); \n      } \n     } \n    } \n   }); \n  } \n  return buttonOrderDown; \n } \n \n private JInternalFrame getJInternalFrameCombineTerms() { \n  if (jInternalFrameCombineTerms == null) { \n   jInternalFrameCombineTerms = new JInternalFrame(); \n   final Dimension size = new Dimension(250, 300); \n   jInternalFrameCombineTerms.setMinimumSize(size); \n   jInternalFrameCombineTerms.setSize(size); \n  \n jInternalFrameCombineTerms.setDefaultCloseOperation(WindowConstants.HID\nE_ON_CLOSE); \n  \n jInternalFrameCombineTerms.setContentPane(getJContentPaneCombineTerms()\n); \n   jInternalFrameCombineTerms \n\n\n\n  \n\n     .addComponentListener(new \njava.awt.event.ComponentAdapter() {    \n      public void \ncomponentShown(java.awt.event.ComponentEvent e) {     \n       if (presenter != null) { \n       \n presenter.setModalMode(true); \n       } \n      } \n      public void \ncomponentHidden(java.awt.event.ComponentEvent e) { \n       commonQuestions = null; \n       commonAnswers = null; \n       if (presenter != null) { \n       \n presenter.setModalMode(false); \n       } \n      } \n     }); \n  } \n  return jInternalFrameCombineTerms; \n } \n \n private JPanel getJContentPaneCombineTerms() { \n  if (jContentPaneCombineTerms == null) { \n   GridBagConstraints gridBagConstraints19 = new \nGridBagConstraints(); \n   gridBagConstraints19.gridx = 0; \n   gridBagConstraints19.fill = GridBagConstraints.BOTH; \n   gridBagConstraints19.anchor = GridBagConstraints.NORTH; \n   gridBagConstraints19.insets = new Insets(2, 2, 0, 2); \n   gridBagConstraints19.gridy = 0; \n   GridBagConstraints gridBagConstraints18 = new \nGridBagConstraints(); \n   gridBagConstraints18.gridx = 0; \n   gridBagConstraints18.anchor = GridBagConstraints.SOUTH; \n   gridBagConstraints18.fill = \nGridBagConstraints.HORIZONTAL; \n   gridBagConstraints18.insets = new Insets(0, 2, 2, 2); \n   gridBagConstraints18.gridy = 2; \n   GridBagConstraints gridBagConstraints17 = new \nGridBagConstraints(); \n   gridBagConstraints17.fill = GridBagConstraints.BOTH; \n   gridBagConstraints17.gridy = 1; \n   gridBagConstraints17.weightx = 1.0; \n   gridBagConstraints17.weighty = 1.0; \n   gridBagConstraints17.insets = new Insets(6, 6, 6, 6); \n   gridBagConstraints17.gridx = 0; \n   jContentPaneCombineTerms = new JPanel(); \n   jContentPaneCombineTerms.setLayout(new GridBagLayout()); \n  \n jContentPaneCombineTerms.add(getPanelButtonsCombineTerms(), \ngridBagConstraints19); \n  \n jContentPaneCombineTerms.add(getScrollPaneCombineTerms(), \ngridBagConstraints17); \n   jContentPaneCombineTerms.add(getBottomBarCombineTerms(), \ngridBagConstraints18); \n  } \n  return jContentPaneCombineTerms; \n } \n \n private JScrollPane getScrollPaneCombineTerms() { \n  if (scrollPaneCombineTerms == null) { \n   scrollPaneCombineTerms = new JScrollPane(); \n  \n scrollPaneCombineTerms.setViewportView(getJListCombineTerms()); \n  } \n  return scrollPaneCombineTerms; \n } \n \n private JList getJListCombineTerms() { \n  if (jListCombineTerms == null) { \n   jListCombineTerms = new JList(); \n  } \n  return jListCombineTerms; \n } \n \n private JPanel getBottomBarCombineTerms() { \n  if (bottomBarCombineTerms == null) { \n\n\n\n  \n\n   bottomBarCombineTerms = new JPanel(); \n   bottomBarCombineTerms.setLayout(new FlowLayout()); \n  \n bottomBarCombineTerms.add(getButtonCombineTermsConfirm(), null); \n   bottomBarCombineTerms.add(getButtonCombineTermsCancel(), \nnull); \n  } \n  return bottomBarCombineTerms; \n } \n \n private JButton getButtonCombineTermsConfirm() { \n  if (buttonCombineTermsConfirm == null) { \n   buttonCombineTermsConfirm = new JButton(); \n   buttonCombineTermsConfirm.setText(\"Confirm\"); \n   buttonCombineTermsConfirm \n     .addActionListener(new \njava.awt.event.ActionListener() { \n      public void \nactionPerformed(java.awt.event.ActionEvent e) { \n       if (presenter != null) { \n       \n presenter.addCombinedTerms( \n         \n combineTermsList, commonQuestions, commonAnswers); \n       } \n      } \n     }); \n  } \n  return buttonCombineTermsConfirm; \n } \n \n private JButton getButtonCombineTermsCancel() { \n  if (buttonCombineTermsCancel == null) { \n   buttonCombineTermsCancel = new JButton(); \n   buttonCombineTermsCancel.setText(\"Cancel\"); \n   buttonCombineTermsCancel.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n    \n jInternalFrameCombineTerms.doDefaultCloseAction(); \n    } \n   }); \n  } \n  return buttonCombineTermsCancel; \n } \n \n private JPanel getPanelButtonsCombineTerms() { \n  if (panelButtonsCombineTerms == null) { \n   panelButtonsCombineTerms = new JPanel(); \n   panelButtonsCombineTerms.setLayout(new FlowLayout()); \n   panelButtonsCombineTerms.add(getButtonCombineTermsUp(), \nnull); \n  \n panelButtonsCombineTerms.add(getButtonCombineTermsDown(), null); \n   panelButtonsCombineTerms.add(getButtonCombineTermsAdd(), \nnull); \n  } \n  return panelButtonsCombineTerms; \n } \n \n private JButton getButtonCombineTermsUp() { \n  if (buttonCombineTermsUp == null) { \n   buttonCombineTermsUp = new JButton(); \n   buttonCombineTermsUp.setText(\"UP\"); \n   buttonCombineTermsUp.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final int[] selectedIndices = \njListCombineTerms.getSelectedIndices(); \n     final int length = \nselectedIndices.length; \n     if (length == 1) { \n     \n TermsFormImpl.this.setCombineOrderUp(selectedIndices[0]); \n     } else if (length == 0) { \n      showInfoMessage(\"Selecione um \ntermo para indicar a ordem de combina\u00e7\u00e3o.\"); \n     } else { \n\n\n\n  \n\n      showInfoMessage(\"Apenas um termo \npode ser selecionado para se indicar a ordem de combina\u00e7\u00e3o.\"); \n     } \n    } \n   }); \n  } \n  return buttonCombineTermsUp; \n } \n \n private JButton getButtonCombineTermsDown() { \n  if (buttonCombineTermsDown == null) { \n   buttonCombineTermsDown = new JButton(); \n   buttonCombineTermsDown.setText(\"DOWN\"); \n   buttonCombineTermsDown.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final int[] selectedIndices = \njListCombineTerms.getSelectedIndices(); \n     final int length = \nselectedIndices.length; \n     if (length == 1) { \n     \n TermsFormImpl.this.setCombineOrderDown(selectedIndices[0]); \n     } else if (length == 0) { \n      showInfoMessage(\"Selecione um \ntermo para indicar a ordem de combina\u00e7\u00e3o.\"); \n     } else { \n      showInfoMessage(\"Apenas um termo \npode ser selecionado para se indicar a ordem de combina\u00e7\u00e3o.\"); \n     } \n    } \n   }); \n  } \n  return buttonCombineTermsDown; \n } \n \n private JButton getButtonCombineTermsAdd() { \n  if (buttonCombineTermsAdd == null) { \n   buttonCombineTermsAdd = new JButton(); \n   buttonCombineTermsAdd.setText(\"Add*\"); \n   _above_ \n   buttonCombineTermsAdd.setToolTipText( \n     \"Adiciona uma preposi\u00e7\u00e3o entre os \ntermos.\"); \n   buttonCombineTermsAdd.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n    \n TermsFormImpl.this.addPrepositionToCombineTerms();  \n    } \n   }); \n  } \n  return buttonCombineTermsAdd; \n } \n} \n \n\n? Classe ProjectFormImpl.java: \npackage gui; \n \nimport java.awt.CardLayout; \nimport java.awt.Component; \nimport java.awt.FlowLayout; \nimport java.awt.Font; \nimport java.awt.GridBagConstraints; \nimport java.awt.GridBagLayout; \nimport java.awt.Insets; \nimport java.util.ArrayList; \nimport java.util.Date; \nimport java.util.Iterator; \nimport java.util.List; \nimport java.util.Vector; \n \nimport javax.swing.JButton; \nimport javax.swing.JLabel; \nimport javax.swing.JList; \nimport javax.swing.JOptionPane; \n\n\n\n  \n\nimport javax.swing.JPanel; \nimport javax.swing.JScrollPane; \nimport javax.swing.JSplitPane; \nimport javax.swing.JTextArea; \nimport javax.swing.JTextField; \n \nimport system.mvp.Presenter; \nimport system.utils.UtilClass; \nimport view.project.ProjectForm; \nimport view.project.ProjectPresenter; \n \npublic class ProjectFormImpl extends JPanel implements ProjectForm { \n \n private static final long serialVersionUID = 1L; \n  \n private enum BottomBarMode { \n  EMPTY_MODE(), \n  VIEW_MODE(), \n  EDIT_TEMPLATE(); \n } \n  \n private List<String> listUsersDescriptions = new ArrayList<String>(0); \n private List<String> listUsesScenarios = new ArrayList<String>(0); \n  \n private ProjectPresenter presenter; \n \n private CardLayout bottomBarLayoutMgr; \n \n private JLabel captionName = null; \n private JLabel captionCreateDate = null; \n private JTextField fieldName = null; \n private JLabel fieldCreateDate = null; \n private JLabel captionAutor = null; \n private JTextField fieldAutor = null; \n private JLabel captionPurpose = null; \n private JScrollPane scrollPanePurpose = null; \n private JTextArea fieldPurpose = null; \n private JPanel bottomBar = null; \n private JButton buttonSave = null; \n private JButton buttonCancel = null; \n private JPanel templateEditButton = null; \n private JPanel templateSaveCancelButton = null; \n private JButton buttonEdit = null; \n private JLabel captionScope = null; \n private JScrollPane scrollPaneScope = null; \n private JTextArea fieldScope = null; \n private JLabel captionFormalityLevel = null; \n private JScrollPane scrollPaneFormalityLevel = null; \n private JTextArea fieldFormalityLevel = null; \n private JLabel captionUsersDescriptions = null; \n private JButton buttonAddUserDescription = null; \n private JScrollPane scrollPaneUsersDescriptions = null; \n private JLabel captionUsesScenarios = null; \n private JButton buttonAddUseScenario = null; \n private JScrollPane scrollPaneUsesScenarios = null; \n private JList jListUsersDescriptions = null; \n private JList jListUsesScenarios = null; \n private JPanel panelButtonsUsersDescriptions = null; \n private JButton buttonEditUserDescription = null; \n private JButton buttonRemoveUserDescription = null; \n private JPanel panelButtonsUsesScenarios = null; \n private JButton buttonEditUseScenario = null; \n private JButton buttonRemoveUseScenario = null; \n private JSplitPane splitPaneDescriptions = null; \n private JPanel leftPanel = null; \n private JPanel rightPanel = null; \n \n public ProjectFormImpl() { \n  super(); \n  initialize(); \n } \n  \n private void initialize() { \n  GridBagConstraints gridBagConstraints32 = new \nGridBagConstraints(); \n  gridBagConstraints32.fill = GridBagConstraints.BOTH; \n  gridBagConstraints32.gridy = 10; \n  gridBagConstraints32.weightx = 1.0; \n  gridBagConstraints32.weighty = 1.0; \n  gridBagConstraints32.gridwidth = 4; \n\n\n\n  \n\n  gridBagConstraints32.insets = new Insets(2, 2, 2, 2); \n  gridBagConstraints32.gridx = 0; \n  captionUsesScenarios = new JLabel(); \n  captionUsesScenarios.setText(\"Uses Scenarios:\"); \n  GridBagConstraints gridBagConstraints7 = new \nGridBagConstraints(); \n  gridBagConstraints7.gridx = 1; \n  gridBagConstraints7.gridy = 12; \n  captionUsersDescriptions = new JLabel(); \n  captionUsersDescriptions.setText(\"Users Descriptions:\"); \n  GridBagConstraints gridBagConstraints13 = new \nGridBagConstraints(); \n  gridBagConstraints13.gridx = 0; \n  gridBagConstraints13.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints13.fill = GridBagConstraints.BOTH; \n  gridBagConstraints13.gridwidth = 2; \n  gridBagConstraints13.insets = new Insets(2, 2, 2, 2); \n  gridBagConstraints13.gridy = 11; \n  GridBagConstraints gridBagConstraints5 = new \nGridBagConstraints(); \n  gridBagConstraints5.fill = GridBagConstraints.BOTH; \n  gridBagConstraints5.gridy = 9; \n  gridBagConstraints5.weightx = 1.0; \n  gridBagConstraints5.weighty = 1.0; \n  gridBagConstraints5.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints5.insets = new Insets(0, 2, 2, 2); \n  gridBagConstraints5.gridwidth = 4; \n  gridBagConstraints5.gridx = 0; \n  GridBagConstraints gridBagConstraints41 = new \nGridBagConstraints(); \n  gridBagConstraints41.gridx = 0; \n  gridBagConstraints41.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints41.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints41.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints41.gridwidth = 4; \n  gridBagConstraints41.gridy = 8; \n  captionFormalityLevel = new JLabel(); \n  captionFormalityLevel.setText(\"Formality Level:\"); \n  GridBagConstraints gridBagConstraints31 = new \nGridBagConstraints(); \n  gridBagConstraints31.fill = GridBagConstraints.BOTH; \n  gridBagConstraints31.gridy = 7; \n  gridBagConstraints31.weightx = 1.0; \n  gridBagConstraints31.weighty = 1.0; \n  gridBagConstraints31.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints31.insets = new Insets(0, 2, 2, 2); \n  gridBagConstraints31.gridwidth = 4; \n  gridBagConstraints31.gridx = 0; \n  GridBagConstraints gridBagConstraints11 = new \nGridBagConstraints(); \n  gridBagConstraints11.gridx = 0; \n  gridBagConstraints11.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints11.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints11.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints11.gridwidth = 4; \n  gridBagConstraints11.gridy = 6; \n  captionScope = new JLabel(); \n  captionScope.setText(\"Project scope:\"); \n  GridBagConstraints gridBagConstraints12 = new \nGridBagConstraints(); \n  gridBagConstraints12.gridx = 0; \n  gridBagConstraints12.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints12.anchor = GridBagConstraints.SOUTHWEST; \n  gridBagConstraints12.insets = new Insets(2, 2, 2, 2); \n  gridBagConstraints12.gridwidth = 4; \n  gridBagConstraints12.gridy = 17; \n  GridBagConstraints gbcScrollPaneDescription = new \nGridBagConstraints(); \n  gbcScrollPaneDescription.fill = GridBagConstraints.BOTH; \n  gbcScrollPaneDescription.gridy = 5; \n  gbcScrollPaneDescription.weightx = 1.0; \n  gbcScrollPaneDescription.weighty = 1.0; \n  gbcScrollPaneDescription.gridwidth = 4; \n  gbcScrollPaneDescription.anchor = GridBagConstraints.NORTHWEST; \n  gbcScrollPaneDescription.insets = new Insets(0, 2, 2, 2); \n  gbcScrollPaneDescription.gridx = 0; \n  GridBagConstraints gbcCaptionDescription = new \nGridBagConstraints(); \n  gbcCaptionDescription.gridx = 0; \n  gbcCaptionDescription.anchor = GridBagConstraints.NORTHWEST; \n\n\n\n  \n\n  gbcCaptionDescription.insets = new Insets(2, 2, 0, 2); \n  gbcCaptionDescription.fill = GridBagConstraints.HORIZONTAL; \n  gbcCaptionDescription.gridwidth = 4; \n  gbcCaptionDescription.gridy = 4; \n  captionPurpose = new JLabel(); \n  captionPurpose.setText(\"Project purpose:\"); \n  GridBagConstraints gridBagConstraints6 = new \nGridBagConstraints(); \n  gridBagConstraints6.fill = GridBagConstraints.BOTH; \n  gridBagConstraints6.gridy = 3; \n  gridBagConstraints6.weightx = 1.0; \n  gridBagConstraints6.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints6.gridwidth = 4; \n  gridBagConstraints6.insets = new Insets(0, 2, 2, 2); \n  gridBagConstraints6.gridx = 0; \n  GridBagConstraints gridBagConstraints4 = new \nGridBagConstraints(); \n  gridBagConstraints4.gridx = 0; \n  gridBagConstraints4.gridwidth = 4; \n  gridBagConstraints4.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints4.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints4.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints4.gridy = 2; \n  captionAutor = new JLabel(); \n  captionAutor.setText(\"Autor:\"); \n  GridBagConstraints gridBagConstraints3 = new \nGridBagConstraints(); \n  gridBagConstraints3.gridx = 3; \n  gridBagConstraints3.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints3.insets = new Insets(2, 2, 2, 2); \n  gridBagConstraints3.gridy = 1; \n  fieldCreateDate = new JLabel(); \n  fieldCreateDate.setText(\"01/01/09\"); \n  GridBagConstraints gridBagConstraints2 = new \nGridBagConstraints(); \n  gridBagConstraints2.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints2.gridy = 1; \n  gridBagConstraints2.weightx = 1.0; \n  gridBagConstraints2.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints2.gridwidth = 3; \n  gridBagConstraints2.insets = new Insets(0, 2, 2, 2); \n  gridBagConstraints2.gridx = 0; \n  GridBagConstraints gridBagConstraints1 = new \nGridBagConstraints(); \n  gridBagConstraints1.gridx = 3; \n  gridBagConstraints1.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints1.ipadx = 1; \n  gridBagConstraints1.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints1.gridy = 0; \n  captionCreateDate = new JLabel(); \n  captionCreateDate.setText(\"Create date:\"); \n  GridBagConstraints gridBagConstraints = new \nGridBagConstraints(); \n  gridBagConstraints.gridx = 0; \n  gridBagConstraints.anchor = GridBagConstraints.NORTHWEST; \n  gridBagConstraints.gridwidth = 3; \n  gridBagConstraints.fill = GridBagConstraints.HORIZONTAL; \n  gridBagConstraints.insets = new Insets(2, 2, 0, 2); \n  gridBagConstraints.gridy = 0; \n  captionName = new JLabel(); \n  captionName.setText(\"Project name:\"); \n  this.setLayout(new GridBagLayout()); \n  this.setSize(500, 400); \n  this.add(captionName, gridBagConstraints); \n  this.add(captionCreateDate, gridBagConstraints1); \n  this.add(getFieldName(), gridBagConstraints2); \n  this.add(fieldCreateDate, gridBagConstraints3); \n  this.add(captionAutor, gridBagConstraints4); \n  this.add(getFieldAutor(), gridBagConstraints6); \n  this.add(captionPurpose, gbcCaptionDescription); \n  this.add(getScrollPanePurpose(), gbcScrollPaneDescription); \n  this.add(captionScope, gridBagConstraints11); \n  this.add(getScrollPaneScope(), gridBagConstraints31); \n  this.add(captionFormalityLevel, gridBagConstraints41); \n  this.add(getScrollPaneFormalityLevel(), gridBagConstraints5); \n  this.add(getSplitPaneDescriptions(), gridBagConstraints32); \n  this.add(getBottomBar(), gridBagConstraints12); \n   \n } \n  \n\n\n\n  \n\n /*---------------------- \n  * Manipulation Methods: \n  ----------------------*/ \n private void showInfoMessage(final String message) { \n  JOptionPane.showMessageDialog(this, message); \n } \n  \n private void setFormMode(final BottomBarMode mode) { \n  switch (mode) { \n  case EMPTY_MODE: { \n   this.setFormEnabled(false); \n   this.bottomBarLayoutMgr.show(this.bottomBar, \ngetTemplateEditButton().getName()); \n   break; \n  } \n  default: { \n   this.setFormEnabled(true); \n   switch (mode) { \n   case VIEW_MODE: { \n    this.setFieldsEditable(false); \n    this.bottomBarLayoutMgr.show(this.bottomBar, \ngetTemplateEditButton().getName()); \n    break; \n   } \n   case EDIT_TEMPLATE: { \n    this.setFieldsEditable(true); \n    this.bottomBarLayoutMgr.show(this.bottomBar, \ngetTemplateSaveCancelButton().getName()); \n    break; \n   } \n   default: { \n    JOptionPane.showMessageDialog(this, \"setFormMode: \nModo n\u00e3o tratado.\"); \n   } \n   } \n  } \n  } \n } \n  \n private void setFormEnabled(final boolean enabled) { \n  this.fieldName.setEnabled(enabled); \n  this.fieldAutor.setEnabled(enabled); \n  this.fieldPurpose.setEnabled(enabled); \n  this.fieldScope.setEnabled(enabled); \n  this.fieldFormalityLevel.setEnabled(enabled); \n  this.setMoreInfoPanelEnabled(enabled); \n  this.setBottomBarEnabled(enabled); \n } \n  \n private void setMoreInfoPanelEnabled(final boolean enabled) { \n  this.buttonAddUserDescription.setEnabled(enabled); \n  this.buttonEditUserDescription.setEnabled(enabled); \n  this.buttonRemoveUserDescription.setEnabled(enabled); \n  this.jListUsersDescriptions.setEnabled(enabled); \n   \n  this.buttonAddUseScenario.setEnabled(enabled); \n  this.buttonEditUseScenario.setEnabled(enabled); \n  this.buttonRemoveUseScenario.setEnabled(enabled); \n  this.jListUsesScenarios.setEnabled(enabled); \n } \n  \n private void setBottomBarEnabled(final boolean enabled) { \n  List<Component[]> componentsGroups = new \nArrayList<Component[]>(); \n  componentsGroups.add(this.templateEditButton.getComponents()); \n \n componentsGroups.add(this.templateSaveCancelButton.getComponents()); \n   \n  for (Iterator<Component[]> it = componentsGroups.iterator(); \nit.hasNext();) { \n   Component[] components = it.next(); \n   if (components != null) { \n    for (int i=0; i &lt;components.length; i++) { \n     components[i].setEnabled(enabled); \n    } \n   } \n  } \n } \n  \n private void setFieldsEditable(final boolean flag) { \n\n\n\n  \n\n  this.fieldName.setEditable(flag); \n  this.fieldAutor.setEditable(flag); \n  this.fieldPurpose.setEditable(flag); \n  this.fieldScope.setEditable(flag); \n  this.fieldFormalityLevel.setEditable(flag); \n  this.setMoreInfoPanelEnabled(flag); \n } \n  \n /*------------------- \n  * Interface Methods: \n  -------------------*/ \n @Override \n public&lt;T extends Presenter> void registerPresenter(T presenter) { \n  this.presenter = (ProjectPresenter)presenter; \n } \n  \n @Override \n public String getProjectName() { \n  return this.fieldName.getText(); \n } \n \n @Override \n public String getProjectAutor() { \n  return this.fieldAutor.getText(); \n } \n \n @Override \n public String getProjectPurpose() { \n  return this.fieldPurpose.getText(); \n } \n  \n @Override \n public String getProjectScope() { \n  return this.fieldScope.getText(); \n } \n  \n @Override \n public String getProjectFormalityLevel() { \n  return this.fieldFormalityLevel.getText(); \n } \n  \n @Override \n public List<String> getProjectUsersDescriptionsList() { \n \n  if (this.listUsersDescriptions != null) { \n   final int length = this.listUsersDescriptions.size(); \n   for (int i=0; i &lt;length; i++) { \n   \n System.out.println(this.listUsersDescriptions.get(i)); \n   } \n  } else { \n   System.out.println(\"user descriptions is null\"); \n  } \n  return new ArrayList<String>(this.listUsersDescriptions); \n } \n  \n @Override \n public List<String> getProjectUsesScenariosList() { \n  return new ArrayList<String>(this.listUsesScenarios); \n } \n  \n @Override \n public void setProjectName(String value) { \n  this.fieldName.setText(value); \n } \n  \n @Override \n public void setProjectAutor(final String value) { \n  this.fieldAutor.setText(value); \n } \n  \n @Override \n public void setProjectPurpose(final String value) { \n  this.fieldPurpose.setText(value); \n } \n  \n @Override \n public void setProjectScope(final String value) { \n  this.fieldScope.setText(value); \n } \n\n\n\n  \n\n  \n @Override \n public void setProjectFormalityLevel(final String value) { \n  this.fieldFormalityLevel.setText(value); \n } \n  \n @Override \n public void setProjectUsersDescriptionsList(List<String> value) { \n  if (value != null) { \n   this.listUsersDescriptions = new \nArrayList<String>(value); \n  } else { \n   this.listUsersDescriptions.clear(); \n  } \n \n this.setComponentUsersDescriptionsList(this.listUsersDescriptions); \n } \n private void setComponentUsersDescriptionsList(final List<String> \nlistData) { \n \n this.jListUsersDescriptions.setListData(this.getListData(listData, \ntrue)); \n } \n  \n @Override \n public void setProjectUsesScenariosList(List<String> value) { \n  if (value != null) { \n   this.listUsesScenarios = new ArrayList<String>(value); \n  } else { \n   this.listUsesScenarios.clear(); \n  } \n  this.setComponentUsesScenariosList(this.listUsesScenarios); \n } \n private void setComponentUsesScenariosList(final List<String> listData) \n{ \n  this.jListUsesScenarios.setListData(this.getListData(listData, \nfalse)); \n } \n  \n private Vector<String> getListData(final List<String> originalListData, \n   final boolean isUserDescriptions) { \n  final int length = originalListData.size(); \n  final String prefix = ( isUserDescriptions ? \"User \" : \"Scenario \n\" ); \n  Vector<String> componentListData = new Vector<String>(length); \n  for (int i=0; i &lt;length; i++) { \n   componentListData.add(prefix + (i+1) + \": \" + \noriginalListData.get(i)); \n  } \n  return componentListData; \n } \n  \n private List<String> getRemoveList(final int[] removeIndices, \n   final List<String> originalList) { \n  final List<String> removeList = new ArrayList<String>(0); \n  final int length = removeIndices.length; \n  for (int i=0; i &lt;length; i++) { \n   removeList.add(originalList.get(removeIndices[i])); \n  } \n  return removeList; \n } \n  \n private void doRemoveUsersDescriptions(final int[] selectedUsers) { \n  this.listUsersDescriptions.removeAll( \n    this.getRemoveList(selectedUsers, \nthis.listUsersDescriptions)); \n \n this.setComponentUsersDescriptionsList(this.listUsersDescriptions); \n } \n  \n private void doRemoveUsesScenarios(final int[] selectedScenarios) { \n  this.listUsesScenarios.removeAll( \n    this.getRemoveList(selectedScenarios, \nthis.listUsesScenarios)); \n  this.setComponentUsesScenariosList(this.listUsesScenarios); \n } \n \n @Override \n public void setProjectCreateDate(final Date value) { \n  if (value != null) { \n\n\n\n  \n\n   this.fieldCreateDate.setText(value.toString());  \n  } else { \n  \n this.fieldCreateDate.setText(UtilClass.NO_CREATE_DATE_LABEL); \n  } \n } \n \n @Override \n public void setEmptyMode() { \n  this.setFormMode(BottomBarMode.EMPTY_MODE); \n } \n  \n @Override \n public void setViewMode() { \n  this.setFormMode(BottomBarMode.VIEW_MODE); \n } \n  \n @Override \n public void setEditMode() { \n  this.setFormMode(BottomBarMode.EDIT_TEMPLATE); \n } \n  \n /*----------------------- \n  * Show Dialoges Methods: \n  -----------------------*/ \n private String doShowInputDialog(final String title, final String \nmessage, final String initValue) { \n  return (String)JOptionPane.showInputDialog(this, message, title, \nJOptionPane.OK_CANCEL_OPTION, null, null, initValue); \n } \n  \n private int doShowConfirmDialog(final String title, final String \nmessage) { \n  return JOptionPane.showConfirmDialog(this, message, title, \nJOptionPane.OK_CANCEL_OPTION); \n } \n  \n private void showAddUserDescriptionDialog(final int userIndex) { \n  final String inputString = this.doShowInputDialog(\"Add user \ndescription\", \n    \"Write the description of the User \"+ (userIndex \n+ 1) +\":\", null); \n  if (inputString != null &amp;&amp; !inputString.trim().isEmpty()) { \n   this.listUsersDescriptions.add(inputString); \n  \n this.setComponentUsersDescriptionsList(this.listUsersDescriptions); \n  } \n } \n  \n private void showEditUserDescriptionDialog(final int userIndex) { \n  final String inputString = this.doShowInputDialog(\"Edit user \ndescription\", \n    \"Edit the description of the User \"+ (userIndex + \n1) +\":\", \n    this.listUsersDescriptions.get(userIndex)); \n  if (inputString != null &amp;&amp; !inputString.trim().isEmpty()) { \n   this.listUsersDescriptions.set(userIndex, inputString); \n  \n this.setComponentUsersDescriptionsList(this.listUsersDescriptions); \n  } else { \n   final int choice = this.doShowConfirmDialog(null, \n     \"You want to remove this description?\"); \n   if (choice == JOptionPane.OK_OPTION) { \n    this.doRemoveUsersDescriptions(new \nint[]{userIndex}); \n   } \n  } \n } \n  \n private void showRemoveUserDescriptionDialog(final int[] selectedUsers) \n{ \n  final int choice = this.doShowConfirmDialog(\"Removing users \ndescriptions\", \n    \"You really want to remove the selected \ndescription(s)?\"); \n  if (choice == JOptionPane.OK_OPTION) { \n   this.doRemoveUsersDescriptions(selectedUsers); \n  } \n } \n  \n\n\n\n  \n\n private void showAddUseScenarioDialog(final int scenarioIndex) { \n  final String inputString = this.doShowInputDialog(\"Add use \nscenario\", \n    \"Write the description of the Scenario \"+ \n(scenarioIndex + 1) +\":\", null); \n  if (inputString != null &amp;&amp; !inputString.trim().isEmpty()) { \n   this.listUsesScenarios.add(inputString); \n  \n this.setComponentUsesScenariosList(this.listUsesScenarios); \n  } \n } \n  \n private void showEditUseScenarioDialog(final int scenarioIndex) { \n  final String inputString = this.doShowInputDialog(\"Edit use \nscenario\", \n    \"Edit the description of the Use Scenario \"+ \n(scenarioIndex + 1) +\":\", \n    this.listUsesScenarios.get(scenarioIndex)); \n  if (inputString != null &amp;&amp; !inputString.trim().isEmpty()) { \n   this.listUsesScenarios.set(scenarioIndex, inputString); \n  \n this.setComponentUsesScenariosList(this.listUsesScenarios); \n  } else { \n   final int choice = this.doShowConfirmDialog(null, \n     \"You want to remove this description?\"); \n   if (choice == JOptionPane.OK_OPTION) { \n    this.doRemoveUsesScenarios(new \nint[]{scenarioIndex}); \n   } \n  } \n } \n  \n private void showRemoveUseScenarioDialog(final int[] selectedScenarios) \n{ \n  final int choice = this.doShowConfirmDialog(\"Removing uses \nscenarios\", \n    \"You really want to remove the selected \nscenario(s)?\"); \n  if (choice == JOptionPane.OK_OPTION) { \n   this.doRemoveUsesScenarios(selectedScenarios); \n  } \n } \n  \n private JTextField getFieldName() { \n  if (fieldName == null) { \n   fieldName = new JTextField(); \n   fieldName.setText(\"Name\"); \n  } \n  return fieldName; \n } \n \n private JTextField getFieldAutor() { \n  if (fieldAutor == null) { \n   fieldAutor = new JTextField(); \n   fieldAutor.setText(\"Autor\"); \n  } \n  return fieldAutor; \n } \n \n private JScrollPane getScrollPanePurpose() { \n  if (scrollPanePurpose == null) { \n   scrollPanePurpose = new JScrollPane(); \n   scrollPanePurpose.setViewportView(getFieldPurpose()); \n  } \n  return scrollPanePurpose; \n } \n \n private JTextArea getFieldPurpose() { \n  if (fieldPurpose == null) { \n   fieldPurpose = new JTextArea(); \n   fieldPurpose.setText(\"Description\"); \n  } \n  return fieldPurpose; \n } \n \n private JPanel getBottomBar() { \n  if (bottomBar == null) { \n   bottomBar = new JPanel(); \n   this.bottomBarLayoutMgr = new CardLayout(); \n   bottomBar.setLayout(this.bottomBarLayoutMgr); \n\n\n\n  \n\n   bottomBar.add(getTemplateEditButton(), \ngetTemplateEditButton().getName()); \n   bottomBar.add(getTemplateSaveCancelButton(), \ngetTemplateSaveCancelButton().getName()); \n  } \n  return bottomBar; \n } \n \n private JButton getButtonSave() { \n  if (buttonSave == null) { \n   buttonSave = new JButton(); \n   buttonSave.setText(\"Save\"); \n   buttonSave.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     presenter.doSaveAction(); \n    } \n   }); \n  } \n  return buttonSave; \n } \n \n private JButton getButtonCancel() { \n  if (buttonCancel == null) { \n   buttonCancel = new JButton(); \n   buttonCancel.setText(\"Cancel\"); \n   buttonCancel.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     presenter.doCancelAction(); \n    } \n   }); \n  } \n  return buttonCancel; \n } \n \n private JPanel getTemplateEditButton() { \n  if (templateEditButton == null) { \n   templateEditButton = new JPanel(); \n   templateEditButton.setLayout(new FlowLayout()); \n   templateEditButton.setName(\"jEditButtonPanel\"); \n   templateEditButton.add(getButtonEdit(), null); \n  } \n  return templateEditButton; \n } \n \n private JPanel getTemplateSaveCancelButton() { \n  if (templateSaveCancelButton == null) { \n   templateSaveCancelButton = new JPanel(); \n   templateSaveCancelButton.setLayout(new FlowLayout()); \n  \n templateSaveCancelButton.setName(\"jSaveCancelButtonPanel\"); \n   templateSaveCancelButton.add(getButtonSave(), null); \n   templateSaveCancelButton.add(getButtonCancel(), null); \n  } \n  return templateSaveCancelButton; \n } \n \n private JButton getButtonEdit() { \n  if (buttonEdit == null) { \n   buttonEdit = new JButton(); \n   buttonEdit.setText(\"Edit\"); \n   buttonEdit.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     presenter.doEditAction(); \n    } \n   }); \n  } \n  return buttonEdit; \n } \n \n private JScrollPane getScrollPaneScope() { \n  if (scrollPaneScope == null) { \n   scrollPaneScope = new JScrollPane(); \n   scrollPaneScope.setViewportView(getFieldScope()); \n  } \n\n\n\n  \n\n  return scrollPaneScope; \n } \n \n private JTextArea getFieldScope() { \n  if (fieldScope == null) { \n   fieldScope = new JTextArea(); \n   fieldScope.setText(\"Scope\"); \n  } \n  return fieldScope; \n } \n \n private JScrollPane getScrollPaneFormalityLevel() { \n  if (scrollPaneFormalityLevel == null) { \n   scrollPaneFormalityLevel = new JScrollPane(); \n  \n scrollPaneFormalityLevel.setViewportView(getFieldFormalityLevel()); \n  } \n  return scrollPaneFormalityLevel; \n } \n \n private JTextArea getFieldFormalityLevel() { \n  if (fieldFormalityLevel == null) { \n   fieldFormalityLevel = new JTextArea(); \n   fieldFormalityLevel.setText(\"Formality Level\"); \n  } \n  return fieldFormalityLevel; \n } \n \n private JButton getButtonAddUserDescription() { \n  if (buttonAddUserDescription == null) { \n   buttonAddUserDescription = new JButton(); \n   buttonAddUserDescription.setText(\"Add\"); \n   buttonAddUserDescription.setFont(new Font(\"Dialog\", \nFont.BOLD, 10)); \n   buttonAddUserDescription.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final int userIndex = \nlistUsersDescriptions.size(); \n     showAddUserDescriptionDialog(userIndex); \n    } \n   }); \n  } \n  return buttonAddUserDescription; \n } \n \n private JScrollPane getScrollPaneUsersDescriptions() { \n  if (scrollPaneUsersDescriptions == null) { \n   scrollPaneUsersDescriptions = new JScrollPane(); \n  \n scrollPaneUsersDescriptions.setViewportView(getJListUsersDescriptions()\n); \n  \n scrollPaneUsersDescriptions.setViewportView(getJListUsersDescriptions()\n); \n  } \n  return scrollPaneUsersDescriptions; \n } \n \n private JButton getButtonAddUseScenario() { \n  if (buttonAddUseScenario == null) { \n   buttonAddUseScenario = new JButton(); \n   buttonAddUseScenario.setText(\"Add\"); \n   buttonAddUseScenario.setFont(new Font(\"Dialog\", \nFont.BOLD, 10)); \n   buttonAddUseScenario.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final int scenarioIndex = \nlistUsesScenarios.size(); \n     showAddUseScenarioDialog(scenarioIndex); \n    } \n   }); \n  } \n  return buttonAddUseScenario; \n } \n \n private JScrollPane getScrollPaneUsesScenarios() { \n\n\n\n  \n\n  if (scrollPaneUsesScenarios == null) { \n   scrollPaneUsesScenarios = new JScrollPane(); \n  \n scrollPaneUsesScenarios.setViewportView(getJListUsesScenarios()); \n  } \n  return scrollPaneUsesScenarios; \n } \n \n private JList getJListUsersDescriptions() { \n  if (jListUsersDescriptions == null) { \n   jListUsersDescriptions = new JList(); \n  } \n  return jListUsersDescriptions; \n } \n \n private JList getJListUsesScenarios() { \n  if (jListUsesScenarios == null) { \n   jListUsesScenarios = new JList(); \n  } \n  return jListUsesScenarios; \n } \n \n private JPanel getPanelButtonsUsersDescriptions() { \n  if (panelButtonsUsersDescriptions == null) { \n   FlowLayout flowLayout = new FlowLayout(); \n   flowLayout.setAlignment(java.awt.FlowLayout.LEFT); \n   panelButtonsUsersDescriptions = new JPanel(); \n   panelButtonsUsersDescriptions.setLayout(flowLayout); \n  \n panelButtonsUsersDescriptions.add(getButtonAddUserDescription(), null); \n  \n panelButtonsUsersDescriptions.add(getButtonEditUserDescription(), \nnull); \n  \n panelButtonsUsersDescriptions.add(getButtonRemoveUserDescription(), \nnull); \n  } \n  return panelButtonsUsersDescriptions; \n } \n \n private JButton getButtonEditUserDescription() { \n  if (buttonEditUserDescription == null) { \n   buttonEditUserDescription = new JButton(); \n   buttonEditUserDescription.setText(\"Edit\"); \n   buttonEditUserDescription.setFont(new Font(\"Dialog\", \nFont.BOLD, 10)); \n   buttonEditUserDescription \n     .addActionListener(new \njava.awt.event.ActionListener() { \n      public void \nactionPerformed(java.awt.event.ActionEvent e) { \n       final int[] selectedIndices \n= jListUsersDescriptions.getSelectedIndices(); \n       if (selectedIndices.length \n== 0) { \n       \n showInfoMessage(\"Select one User Description to edit.\"); \n       } else if \n(selectedIndices.length > 1) { \n       \n showInfoMessage(\"Only one User Description can be edited at time.\"); \n       } else { \n       \n showEditUserDescriptionDialog(selectedIndices[0]); \n       } \n      } \n     }); \n  } \n  return buttonEditUserDescription; \n } \n \n private JButton getButtonRemoveUserDescription() { \n  if (buttonRemoveUserDescription == null) { \n   buttonRemoveUserDescription = new JButton(); \n   buttonRemoveUserDescription.setText(\"Remove\"); \n   buttonRemoveUserDescription.setFont(new Font(\"Dialog\", \nFont.BOLD, 10)); \n   buttonRemoveUserDescription \n     .addActionListener(new \njava.awt.event.ActionListener() { \n\n\n\n  \n\n      public void \nactionPerformed(java.awt.event.ActionEvent e) { \n       final int[] selectedIndices \n= jListUsersDescriptions.getSelectedIndices(); \n       if (selectedIndices.length \n== 0) { \n       \n showInfoMessage(\"Select at least one User Description to remove.\"); \n       } else { \n       \n showRemoveUserDescriptionDialog(selectedIndices); \n       } \n      } \n     }); \n  } \n  return buttonRemoveUserDescription; \n } \n \n private JPanel getPanelButtonsUsesScenarios() { \n  if (panelButtonsUsesScenarios == null) { \n   FlowLayout flowLayout1 = new FlowLayout(); \n   flowLayout1.setAlignment(java.awt.FlowLayout.LEFT); \n   panelButtonsUsesScenarios = new JPanel(); \n   panelButtonsUsesScenarios.setLayout(flowLayout1); \n   panelButtonsUsesScenarios.add(getButtonAddUseScenario(), \nnull); \n  \n panelButtonsUsesScenarios.add(getButtonEditUseScenario(), null); \n  \n panelButtonsUsesScenarios.add(getButtonRemoveUseScenario(), null); \n  } \n  return panelButtonsUsesScenarios; \n } \n \n private JButton getButtonEditUseScenario() { \n  if (buttonEditUseScenario == null) { \n   buttonEditUseScenario = new JButton(); \n   buttonEditUseScenario.setText(\"Edit\"); \n   buttonEditUseScenario.setFont(new Font(\"Dialog\", \nFont.BOLD, 10)); \n   buttonEditUseScenario.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final int[] selectedIndices = \njListUsesScenarios.getSelectedIndices(); \n     if (selectedIndices.length == 0) { \n      showInfoMessage(\"Select one Use \nScenario to edit.\"); \n     } else if (selectedIndices.length > 1) { \n      showInfoMessage(\"Only one Use \nScenario can be edited at time.\"); \n     } else { \n     \n showEditUseScenarioDialog(selectedIndices[0]); \n     } \n    } \n   }); \n  } \n  return buttonEditUseScenario; \n } \n \n private JButton getButtonRemoveUseScenario() { \n  if (buttonRemoveUseScenario == null) { \n   buttonRemoveUseScenario = new JButton(); \n   buttonRemoveUseScenario.setText(\"Remove\"); \n   buttonRemoveUseScenario.setFont(new Font(\"Dialog\", \nFont.BOLD, 10)); \n   buttonRemoveUseScenario.addActionListener(new \njava.awt.event.ActionListener() { \n    public void \nactionPerformed(java.awt.event.ActionEvent e) { \n     final int[] selectedIndices = \njListUsesScenarios.getSelectedIndices(); \n     if (selectedIndices.length == 0) { \n      showInfoMessage(\"Select at least \none Use Scenario to remove.\"); \n     } else { \n     \n showRemoveUseScenarioDialog(selectedIndices); \n\n\n\n  \n\n     } \n    } \n   }); \n  } \n  return buttonRemoveUseScenario; \n } \n \n private JSplitPane getSplitPaneDescriptions() { \n  if (splitPaneDescriptions == null) { \n   splitPaneDescriptions = new JSplitPane(); \n   final int divider = this.getWidth()/2; \n   splitPaneDescriptions.setDividerLocation(divider); \n   splitPaneDescriptions.setLeftComponent(getLeftPanel()); \n  \n splitPaneDescriptions.setRightComponent(getRightPanel()); \n  } \n  return splitPaneDescriptions; \n } \n  \n public void setSplitPaneDividerLocation(final int location) { \n  this.splitPaneDescriptions.setDividerLocation(location); \n } \n \n private JPanel getLeftPanel() { \n  if (leftPanel == null) { \n   GridBagConstraints gridBagConstraints17 = new \nGridBagConstraints(); \n   gridBagConstraints17.fill = GridBagConstraints.BOTH; \n   gridBagConstraints17.weighty = 1.0; \n   gridBagConstraints17.gridx = 0; \n   gridBagConstraints17.gridy = 2; \n   gridBagConstraints17.gridwidth = 2; \n   gridBagConstraints17.weightx = 1.0; \n   GridBagConstraints gridBagConstraints15 = new \nGridBagConstraints(); \n   gridBagConstraints15.anchor = \nGridBagConstraints.NORTHWEST; \n   gridBagConstraints15.insets = new Insets(0, 2, 2, 2); \n   gridBagConstraints15.gridwidth = 2; \n   gridBagConstraints15.gridx = -1; \n   gridBagConstraints15.gridy = -1; \n   gridBagConstraints15.weightx = 1.0; \n   gridBagConstraints15.weighty = 1.0; \n   gridBagConstraints15.fill = GridBagConstraints.BOTH; \n   GridBagConstraints gridBagConstraints10 = new \nGridBagConstraints(); \n   gridBagConstraints10.anchor = GridBagConstraints.WEST; \n   gridBagConstraints10.gridwidth = 1; \n   gridBagConstraints10.gridx = 0; \n   gridBagConstraints10.gridy = 1; \n   gridBagConstraints10.fill = \nGridBagConstraints.HORIZONTAL; \n   GridBagConstraints gridBagConstraints9 = new \nGridBagConstraints(); \n   gridBagConstraints9.anchor = \nGridBagConstraints.SOUTHWEST; \n   gridBagConstraints9.insets = new Insets(2, 2, 0, 2); \n   gridBagConstraints9.gridwidth = 2; \n   gridBagConstraints9.gridx = -1; \n   gridBagConstraints9.gridy = -1; \n   gridBagConstraints9.fill = \nGridBagConstraints.HORIZONTAL; \n   leftPanel = new JPanel(); \n   leftPanel.setLayout(new GridBagLayout()); \n   leftPanel.add(captionUsersDescriptions, \ngridBagConstraints9); \n   leftPanel.add(getPanelButtonsUsersDescriptions(), \ngridBagConstraints10); \n   leftPanel.add(getScrollPaneUsersDescriptions(), \ngridBagConstraints17); \n  } \n  return leftPanel; \n } \n \n private JPanel getRightPanel() { \n  if (rightPanel == null) { \n   GridBagConstraints gridBagConstraints14 = new \nGridBagConstraints(); \n   gridBagConstraints14.anchor = \nGridBagConstraints.NORTHWEST; \n\n\n\n  \n\n   gridBagConstraints14.insets = new Insets(0, 2, 2, 2); \n   gridBagConstraints14.gridwidth = 2; \n   gridBagConstraints14.gridx = 0; \n   gridBagConstraints14.gridy = 2; \n   gridBagConstraints14.weightx = 1.0; \n   gridBagConstraints14.weighty = 1.0; \n   gridBagConstraints14.fill = GridBagConstraints.BOTH; \n   GridBagConstraints gridBagConstraints16 = new \nGridBagConstraints(); \n   gridBagConstraints16.anchor = GridBagConstraints.WEST; \n   gridBagConstraints16.gridx = 0; \n   gridBagConstraints16.gridy = 1; \n   gridBagConstraints16.fill = \nGridBagConstraints.HORIZONTAL; \n   GridBagConstraints gridBagConstraints8 = new \nGridBagConstraints(); \n   gridBagConstraints8.anchor = \nGridBagConstraints.SOUTHWEST; \n   gridBagConstraints8.insets = new Insets(2, 2, 0, 2); \n   gridBagConstraints8.gridwidth = 2; \n   gridBagConstraints8.gridx = 0; \n   gridBagConstraints8.gridy = 0; \n   gridBagConstraints8.fill = \nGridBagConstraints.HORIZONTAL; \n   rightPanel = new JPanel(); \n   rightPanel.setLayout(new GridBagLayout()); \n   rightPanel.add(captionUsesScenarios, \ngridBagConstraints8); \n   rightPanel.add(getPanelButtonsUsesScenarios(), \ngridBagConstraints16); \n   rightPanel.add(getScrollPaneUsesScenarios(), \ngridBagConstraints14); \n  } \n  return rightPanel; \n } \n} \n \n\n? Pacote \u201croot\u201d: \n\n? Classe Starter.java: \npackage root; \n \nimport gui.MainFormImpl; \n \nimport javax.swing.SwingUtilities; \n \nimport system.Environment; \n \npublic class Starter { \n \n public static void main(String[] args) { \n  SwingUtilities.invokeLater(new Runnable() { \n   public void run() { \n    MainFormImpl mainForm = new MainFormImpl(); \n     \n    Environment.start(mainForm, \nmainForm.getProjectFormImpl(), \n     \n mainForm.getCompetenceQuestionsFormImpl(), \nmainForm.getTermsFormImpl()); \n   } \n  }); \n } \n} \n \n\n \n\n\n\n  \n\nANEXO B \u2014 ARTIGO \n\nDesenvolvimento de aplica\u00e7\u00e3o para a etapa de \nespecifica\u00e7\u00e3o da metodologia de desenvolvimento de \n\nontologias em rede NeOn. \n\nCleiton E. J. Duarte1, Jos\u00e9 L. Todesco1, Fernando A. O. Gauthier1 \n\n1Departamento de Inform\u00e1tica e Estat\u00edstica \u2013 INE \nUniversidade Federal de Santa Catarina \u2013 UFSC \n\nCaixa Postal 476 \u2013 88.040-900 \u2013 Florian\u00f3polis \u2013 SC \u2013 Brasil \n\ncleitone@inf.ufrgs.br, tite@inf.ufrgs.br, gauthier@inf.ufrgs. \n\nAbstract. This article is intended to summarize the course paper on \n\n\"Application development for the methodology specification stage \n\nfor development of networked ontologies NeOn\". On this paper the \n\nobjectives were to know and present the NeOn methodology, \n\nfocusing its specification stage, then moving to the establishment of a \n\nsystem that would support this activity. Structurally, the article \n\ndescribes the most important concepts concerned in this study \n\n(ontologies, ontology engineering, etc.) and in the specification stage \n\nof the NeOn, and then passing to the modeling of the application \n\nrequirements, closing up with conclusions about the development. \n\nResumo. Este artigo tem por prop\u00f3sito apresentar de forma sucinta \n\no trabalho de conclus\u00e3o de curso sobre \u201cDesenvolvimento de \n\naplica\u00e7\u00e3o para a etapa de especifica\u00e7\u00e3o da metodologia de \n\ndesenvolvimento de ontologias em rede NeOn\u201d. Nesse trabalho os \n\nobjetivos foram conhecer e apresentar a metodologia NeOn, com \n\nfoco na sua etapa de especifica\u00e7\u00e3o, passando na seq\u00fcencia \u00e0 \n\nelabora\u00e7\u00e3o de um sistema que desse suporte a esta atividade. \n\nEstruturalmente o artigo descreve os conceitos mais importantes do \n\nescopo de trabalho (ontologias, engenharia de ontologias, etc.) e da \n\netapa de especifica\u00e7\u00e3o do NeOn, passando ent\u00e3o a modelagem dos \n\nrequisitos da aplica\u00e7\u00e3o e finalizando com conclus\u00f5es sobre o \n\nreferido desenvolvimento. \n\n1. Introdu\u00e7\u00e3o \n\nO aumento gradativo do uso das ontologias tem exigido cada vez mais \nferramentas que automatizem o processo de constru\u00e7\u00e3o destas. Nesse sentido, \nsurgiu na Europa o projeto NeOn. Este projeto prop\u00f4s uma metodologia que \nprev\u00ea o desenvolvimento de ontologias em rede, visando o reuso e a \nreengenharia de ontologias j\u00e1 existentes para elabora\u00e7\u00e3o de novas. Para \nsuportar esta metodologia, foi concebido o NeOn Toolkit, um plataforma que \n\n\n\n  \n\nintegra v\u00e1rias ferramentas espec\u00edficas para atender a diferentes atividades \nrelacionadas a metodologia NeOn. \n\n Observando a falta de uma ferramenta que suportasse a etapa de \nespecifica\u00e7\u00e3o dessa metodologia este trabalho prop\u00f5e o \u201cDesenvolvimento de \numa aplica\u00e7\u00e3o para a etapa de especifica\u00e7\u00e3o da metodologia de \ndesenvolvimento de ontologias em rede NeOn\u201d. \n\n Como objetivo espec\u00edfico do trabalho est\u00e1 o desenvolvimento de uma \naplica\u00e7\u00e3o que suporte a etapa de especifica\u00e7\u00e3o da metodologia de \ndesenvolvimento de ontologias em rede NeOn. J\u00e1 os objetivos espec\u00edficos \nimpl\u00edcitos s\u00e3o: \n\nConhecer o projeto NeOn, seus objetivos e estrutura. \n\nConhecer a metodologia de desenvolvimento de ontologias em rede do NeOn. \n\nElaborar uma estrutura de classes que realize o suporte \u00e0 etapa de \nespecifica\u00e7\u00e3o de ontologias da metodologia NeOn. \n\nDesenvolver uma aplica\u00e7\u00e3o com base na estrutura de classes elaborada. \n\n2. Engenharia de ontologias \n\nA Engenharia de Ontologias \u00e9 a disciplina respons\u00e1vel por administrar e se \npreocupar com as atividades, processos, ciclos de vida, m\u00e9todos e \nmetodologias envolvidos no desenvolvimento de ontologias, bem como nas \nferramentas e linguagens envolvidos na constru\u00e7\u00e3o dessas ontologias \n(G\u00d3MEZ-P\u00c9REZ et al., 2004). \n\n A terminologia envolvida na Engenharia de Ontologias foi baseada na \nEngenharia de Software, advindo da\u00ed a semelhan\u00e7a nas atividades envolvidas \nno desenvolvimento de ontologias com as de desenvolvimento de software \n(PINTO; MARTINS, 2004). \n\n A seguir, as principais atividades presentes no desenvolvimento de \nontologias: \n\n? Especifica\u00e7\u00e3o: etapa onde s\u00e3o identificados prop\u00f3sito e escopo da ontologia \na ser desenvolvida. Podem ser aplicadas as perguntas \u201cPor que a ontologia \u00e9 \nconstru\u00edda?\u201d e \u201cQuais s\u00e3o as inten\u00e7\u00f5es de uso e usu\u00e1rios da ontologia?\u201d, pois \nas respostas destas ser\u00e3o as defini\u00e7\u00f5es, respectivamente, do prop\u00f3sito e do \nescopo. \n\n? Conceitualiza\u00e7\u00e3o: \u00e9 onde se define um modelo conceitual da ontologia, que \nrepresente os conceitos do dom\u00ednio abordado e as rela\u00e7\u00f5es entre estes. A \ndefini\u00e7\u00e3o se baseia nas informa\u00e7\u00f5es colhidas na atividade anterior \n(especifica\u00e7\u00e3o). \n\n? Formaliza\u00e7\u00e3o: nesta atividade o modelo conceitual anteriormente definido \n\u00e9 formalizado, aplicando-se restri\u00e7\u00f5es e axiomas aos conceitos j\u00e1 \nestabelecidos. Dessa forma \u00e9 feita a restri\u00e7\u00e3o das interpreta\u00e7\u00f5es desses termos \ne feita a organiza\u00e7\u00e3o hier\u00e1rquica dos mesmos (atrav\u00e9s de rela\u00e7\u00f5es estruturais \n\n\n\n  \n\ncomo \u201c\u00e9-um\u201d ou \u201cparte-de\u201d).? Implementa\u00e7\u00e3o: a ontologia \u00e9 implementada \natrav\u00e9s de uma linguagem de representa\u00e7\u00e3o do conhecimento, que deve ser \nescolhida adequadamente para cada caso. \n\n? Manuten\u00e7\u00e3o: como no desenvolvimento de softwares, \u00e9 onde s\u00e3o feitas \ncorre\u00e7\u00f5es e atualiza\u00e7\u00f5es na ontologia, algumas vezes provocados por novos \nrequisitos que surgem, ou s\u00e3o visualizados, durante o desenvolvimento. \n\n A seguir o cap\u00edtulo aborda alguns conceitos e processos envolvidos na \nEngenharia de Ontologias, discorrendo rapidamente a respeito do conceito \nontologia e sobre algumas metodologias existentes para desenvolvimento de \nontologias. \n\n2.1. Ontologia \n\nO conceito de ontologia variou de defini\u00e7\u00e3o desde seu surgimento na Filosofia \nat\u00e9 as sua aplica\u00e7\u00e3o atual no \u00e2mbito da Ci\u00eancia da Computa\u00e7\u00e3o e Engenharia \ndo Conhecimento (KIRYAKOV, 2006). Em sua origem o conceito era de uma \ndisciplina dedicada ao estudo da natureza e da exist\u00eancia dos elementos. J\u00e1 na \nCi\u00eancia da Computa\u00e7\u00e3o, trata da representa\u00e7\u00e3o do conhecimento, a \norganiza\u00e7\u00e3o e estrutura\u00e7\u00e3o dos conhecimentos sobre um determinado dom\u00ednio. \n\n A defini\u00e7\u00e3o inicialmente utilizada na Ci\u00eancia da Computa\u00e7\u00e3o veio, \nsegundo Kiryakov (2006), por Gruber (1993) que define o conceito de \nontologia como \u201cuma especifica\u00e7\u00e3o expl\u00edcita de uma conceitualiza\u00e7\u00e3o\u201d. Outro \nautor, Borst (1997) atribuiu mais detalhes a defini\u00e7\u00e3o, sendo que para ele \n\u201contologia \u00e9 uma especifica\u00e7\u00e3o formal e expl\u00edcita de uma conceitualiza\u00e7\u00e3o \ncompartilhada\u201d. \n\n Atualmente h\u00e1 a defini\u00e7\u00e3o dada por Devedzic (2002), que interpreta \nontologia como um sistema de conceitos e das rela\u00e7\u00f5es existentes entre esses \nconceitos, sendo os conceitos definidos e interpretados declarativamente. O \nsistema modelaria um determinado dom\u00ednio definindo o vocabul\u00e1rio de termos \ndo mesmo e as restri\u00e7\u00f5es das combina\u00e7\u00f5es poss\u00edveis entre esses termos. \n\n2.2. Metodologias para constru\u00e7\u00e3o de ontologias \n\nDentre as metodologias existentes para desenvolvimento de ontologias duas \nser\u00e3o consideradas para apresenta\u00e7\u00e3o neste artigo: a METHONTOLOGY e a \nmetodologia NeOn.  \n\n A METHONTOLOGY nasceu em um grupo de pesquisa em \nEngenharia de Ontologias da Universidade Polit\u00e9cnica de Madri, e tem forte \nembasamento nas metodologias de Engenharia de Software e Engenharia do \nConhecimento (GOM\u00c9Z-P\u00c9REZ et al., 2004). Nessa metodologia, o ciclo de \nvida de uma ontologia \u00e9 baseado em prot\u00f3tipos \u2014 a cada etapa do processo de \ndesenvolvimento (especifica\u00e7\u00e3o, conceitualiza\u00e7\u00e3o e demais) \u00e9 gerado um \nprot\u00f3tipo da ontologia at\u00e9 aquele ponto. As atividades dessa metodologia t\u00eam \nfoco na ger\u00eancia, desenvolvimento e suporte ao ciclo de vida, tendo esta \ncaracter\u00edstica forte liga\u00e7\u00e3o com a Engenharia de Software. \n\n\n\n  \n\n A metodologia NeOn \u2014 acr\u00f4nimo para Networked Ontologies \u2014 \ntrabalha com a id\u00e9ia de desenvolvimento colaborativo de ontologias, \npermitindo o reuso de ontologias para constru\u00e7\u00e3o de novas, promovendo isso \natrav\u00e9s de ontologias distribu\u00eddas em rede, em diferentes locais e \ncompartilhadas via web (SU\u00c1REZ-FIGUEROA et al., 2007). Assim n\u00e3o seria \nmais necess\u00e1rio construir uma ontologia totalmente do zero, ou ent\u00e3o replicar \nelementos de uma ontologia j\u00e1 existente para criar uma nova, bastaria \ncompartilhar a j\u00e1 existente e estend\u00ea-la para gerar a nova cria\u00e7\u00e3o. Para tal, a \nmetodologia trabalha de acordo com o cen\u00e1rio de constru\u00e7\u00e3o de uma ontologia \nem rede que se apresenta para o caso (constru\u00e7\u00e3o com reuso, com \nreengenharia da ontologia, com extens\u00e3o, etc.) aplicando atividades \nespec\u00edficas \u00e0s j\u00e1 conhecidas etapas da Engenharia de Ontologias. \n\n3. A fase de especifica\u00e7\u00e3o de ontologias \n\nNa Engenharia de Ontologias a etapa de especifica\u00e7\u00e3o visa identificar o \nprop\u00f3sito e escopo da ontologia a ser desenvolvida, respondendo \nrespectivamente as perguntas \u201cPor que a ontologia \u00e9 constru\u00edda?\u201d e \u201cQuais s\u00e3o \nas inten\u00e7\u00f5es de uso e usu\u00e1rios da ontologia?\u201d (PINTO; MARTINS, 2004) e \ntamb\u00e9m definir quais tipos de usu\u00e1rios, cen\u00e1rios de usos e n\u00edvel de \nformaliza\u00e7\u00e3o que a ontologia ir\u00e1 suportar e os requisitos que a mesma deve \natender (SU\u00c1REZ-FIGUEROA, 2008). A partir dessas defini\u00e7\u00f5es a etapa foi \nanalisada atrav\u00e9s da compara\u00e7\u00e3o entre duas vis\u00f5es, a descrita na metodologia \nNeOn e a que foi empregada na ferramenta para constru\u00e7\u00e3o de ontologias \nOntoKEM. \n\n3.1. Como \u00e9 visto no NeOn \n\nPara a metodologia NeOn foi proposta a t\u00e9cnica de perguntas de compet\u00eancia \n(GR\u00dcNINGER; FOX, 1995) para o levantamento dos requisitos da ontologia. \nAtrav\u00e9s das perguntas de compet\u00eancia \u00e9 que se levantar\u00e1 \u201co que\u201d a ontologia \ndeve responder \u2014 ao final ser\u00e3o essas perguntas que a mesma dever\u00e1 \nresponder. Os termos extra\u00eddos dessas perguntas \u00e9 que passar\u00e3o, na etapa \nseguinte da metodologia, a formar os conceitos e rela\u00e7\u00f5es entre conceitos da \nontologia. \n\n Como documento de resultado da etapa de especifica\u00e7\u00e3o a metodologia \nNeOn prop\u00f5e o OSRD (\u201cOntology Requirements Specification Document\u201d ou \n\u201cDocumento de Especifica\u00e7\u00e3o de Requisitos da Ontologia\u201d), um modelo \npadr\u00e3o que apresenta os requisitos da ontologia, sendo eles (SU\u00c1REZ-\nFIGUEROA, 2008): \n\n? Prop\u00f3sito (\u201cOntology purpose\u201d): aqui \u00e9 onde s\u00e3o detalhados os objetivos, \nas finalidades ao qual a ontologia se prop\u00f5e. \n\n? Escopo (\u201cOntology scope\u201d): identifica qual ser\u00e1 a abrang\u00eancia e a \ngranularidade da ontologia, at\u00e9 que profundidade a ontologia abordar\u00e1 o \ndom\u00ednio representado. \n\n\n\n  \n\n? N\u00edvel de Formalismo (\u201cLevel of Formality\u201d): indica qual o grau de \nformaliza\u00e7\u00e3o que se pretende adotar na implementa\u00e7\u00e3o da ontologia. Um \nexemplo de descri\u00e7\u00e3o de N\u00edvel de Formalismo seria: \u201cA ontologia ser\u00e1 \nimplementada na linguagem OWL\u201d. \n\n? Usu\u00e1rios desejados (\u201cIntended Users\u201d): o objetivo neste item \u00e9 criar as \ndescri\u00e7\u00f5es dos perfis de usu\u00e1rios desejados para essa ontologia. Atrav\u00e9s dessas \ndescri\u00e7\u00f5es \u00e9 poss\u00edvel, ap\u00f3s a elabora\u00e7\u00e3o da ontologia, desenvolver aplica\u00e7\u00f5es \nmelhor focadas nos perfis mais desejados, por exemplo. \n\n? Usos (Cen\u00e1rios) desejados (\u201cIntended Uses\u201d): este item detalhar os \ncen\u00e1rios de uso que a ontologia dever\u00e1 prover suporte ao estar conclu\u00edda. \nEstes cen\u00e1rios podem ser descritos atrav\u00e9s de linguagem natural ou at\u00e9 mesmo \natrav\u00e9s de diagramas UML, como diagramas casos de uso. Tamb\u00e9m facilita o \ndesenvolvimento de aplica\u00e7\u00f5es mais focadas. \n\n? Grupos de Perguntas de Compet\u00eancia (\u201cGroups of Competence \nQuestions\u201d): \u00e9 onde s\u00e3o inseridas as perguntas de compet\u00eancias elaboradas, \nbem como as suas respectivas respostas. As perguntas devem ser \ncategorizadas conforme a necessidade e tamb\u00e9m deve ser atribu\u00edda a \nprioridade de cada uma. \n\n A partir desses grupos, e de suas perguntas de compet\u00eancia, \u00e9 que \nser\u00e3o extra\u00eddos os termos e objetos para a ontologia. No projeto NeOn a \nproposta \u00e9 que essa extra\u00e7\u00e3o seja autom\u00e1tica: \u00e9 feita uma busca nas perguntas \ne extra\u00eddos os termos, que ent\u00e3o s\u00e3o exibidos ao usu\u00e1rio desenvolvedor que, \npor sua vez, pode selecionar quais s\u00e3o relevantes. \n\n? Termos (\u201cTerms\u201d): representam os termos extra\u00eddos das perguntas, sendo \nestes normalmente conceitos ou rela\u00e7\u00f5es entre conceitos da ontologia. Sempre \napresentam a freq\u00fc\u00eancia com a qual aparecem na listagem total de perguntas \nde compet\u00eancia e podem tamb\u00e9m receber ordena\u00e7\u00e3o de prioridade. \n\n? Objetos (\u201cObjects\u201d): representam os objetos extra\u00eddos das perguntas, sendo \nestes objetos normalmente inst\u00e2ncias da ontologia. Possuem as mesmas \ncaracter\u00edsticas de freq\u00fc\u00eancia e prioridade dos termos. \n\n3.2. Como foi visto no ontoKEM \n\nNa ferramenta ontoKEM, desenvolvida sob as metodologias On-to-\nKnowledge e METHONTOLOGY, pode-se notar algumas distin\u00e7\u00f5es em \nrela\u00e7\u00e3o a proposta da metodologia NeOn, mas que possuem uma certa \nsemelhan\u00e7a de objetivo. No ontoKEM (RAUTEMBERG et al., 2008) a etapa \nde especifica\u00e7\u00e3o \u00e9 dividida em dois m\u00f3dulos: o de \u201cProjeto\u201d e o de \u201cPerguntas \nde Compet\u00eancia\u201d. \n\n No de \u201cProjeto\u201d \u00e9 especificado, al\u00e9m do nome da ontologia, a \ndescri\u00e7\u00e3o da mesma \u2014 al\u00e9m da descri\u00e7\u00e3o da vers\u00e3o na qual se encontra a \nmesma. Em rela\u00e7\u00e3o ao NeOn esse campo de \u201cdescri\u00e7\u00e3o\u201d seria um equivalente \naos campos descritivos de \u201cprop\u00f3sito\u201d e \u201cescopo\u201d unificados. Na mesma \n\u201cdescri\u00e7\u00e3o\u201d poderiam ser inclu\u00eddos os campos \u201cn\u00edvel de formalismo\u201d e at\u00e9 \n\n\n\n  \n\n\u201cusu\u00e1rios desejados\u201d e \u201cusos (cen\u00e1rios) desejados\u201d do NeOn, que n\u00e3o \npossuem correspondentes diretos no ontoKEM. O problema seria o de que \ntodas essas informa\u00e7\u00f5es seriam repassadas juntas e na forma de texto livre. \n\n Tanto no ontoKEM quanto no NeOn \u00e9 proposta a t\u00e9cnica de perguntas \nde compet\u00eancia para o levantamento de requisitos, cabendo a ger\u00eancia disto ao \nm\u00f3dulo de \u201cPerguntas de compet\u00eancia\u201d. Ali, al\u00e9m dos cadastrados da \nperguntas, \u00e9 feito o cadastro dos termos para cada uma das perguntas. A \nextra\u00e7\u00e3o destes, por\u00e9m, \u00e9 feita manualmente pelo usu\u00e1rio desenvolvedor da \nontologia \u2014 ao contr\u00e1rio da proposta de extra\u00e7\u00e3o autom\u00e1tica do NeOn. Ap\u00f3s \no t\u00e9rmino do cadastro das perguntas e termos \u00e9 poss\u00edvel fazer uma \nvisualiza\u00e7\u00e3o e sele\u00e7\u00e3o dos termos, permitindo assim exportar os relevantes \npara a pr\u00f3xima etapa do desenvolvimento da ontologia. \n\n3.3. Considera\u00e7\u00f5es \n\nEm rela\u00e7\u00e3o aos procedimentos da etapa de especifica\u00e7\u00e3o adotados nas duas \nsolu\u00e7\u00f5es, podemos fazer algumas compara\u00e7\u00f5es. \n\n A divis\u00e3o proposta pelo NeOn para os requisitos mais descritivos da \nontologia \u2014 prop\u00f3sitos, escopo, n\u00edvel de formalismo \u2014 permite uma \ndefini\u00e7\u00e3o mais clara de cada um por parte de quem especifica a ontologia. \nApenas um campo descritivo pode permitir uma maior liberdade, mas com \nisso o desenvolvedor pode acabar esquecendo alguma dessas informa\u00e7\u00f5es, \ndeixando a especifica\u00e7\u00e3o mais pobre. \n\n A listagem de usu\u00e1rios desejados e dos cen\u00e1rios de uso da ontologia, \npropostas estas do NeOn, permitem uma defini\u00e7\u00e3o mais clara dos objetivos e \naplica\u00e7\u00f5es da ontologia, facilitando at\u00e9 o desenvolvimento posterior de \naplica\u00e7\u00f5es sobre a ontologia \u2014 podendo estas serem focadas sobre \ndeterminados usu\u00e1rios ou cen\u00e1rios de usos. \n\n O uso de perguntas de compet\u00eancia \u00e9 bem semelhante em ambos, \nsendo que no NeOn tamb\u00e9m s\u00e3o requeridas as respostas respectivas a cada \nquest\u00e3o. A extra\u00e7\u00e3o dos termos \u00e9 que faz a grande diferen\u00e7a nesta parte \u2014 \nmanual no ontoKEM e autom\u00e1tica atrav\u00e9s de t\u00e9cnicas de extra\u00e7\u00e3o \nterminol\u00f3gicas (SU\u00c1REZ-FIGUEROA, 2008) no NeOn. A extra\u00e7\u00e3o \nautom\u00e1tica, com possibilidade de posterior sele\u00e7\u00e3o dos mais relevantes, \nfacilita bastante o levantamento dos termos da ontologia, n\u00e3o havendo a \nnecessidade de um usu\u00e1rio ficar analisando cada pergunta e/ou resposta de \ncompet\u00eancia para verificar quais os termos que podem existir. \n\n O modelo proposto pela metodologia NeOn parece interessante e \neficaz como modelo de especifica\u00e7\u00e3o de ontologias. Observado isso, o \ndocumento OSRD e seus itens serviram de base para o desenvolvimento da \naplica\u00e7\u00e3o para suporte da etapa de especifica\u00e7\u00e3o da metodologia NeOn. \n\n\n\n  \n\n4. Aplica\u00e7\u00e3o para a fase de especifica\u00e7\u00e3o \n\nEm Su\u00e1rez-Figueroa (2008), ao final das explica\u00e7\u00f5es a respeito da etapa de \nespecifica\u00e7\u00e3o da metodologia NeOn, h\u00e1 uma sugest\u00e3o de implementa\u00e7\u00e3o. \nSugere-se o desenvolvimento de uma aplica\u00e7\u00e3o acopl\u00e1vel \u2014 um plugin \u2014 \npara a plataforma de desenvolvimento de ontologias em rede NeOn Toolkit, \nsendo que esta aplica\u00e7\u00e3o deve seguir os processos e atividades propostas na \netapa de especifica\u00e7\u00e3o da metodologia NeOn. \n\n No trabalho proposto o foco n\u00e3o foi no desenvolvimento somente de \num plugin para o NeOn Toolkit, mas sim em uma aplica\u00e7\u00e3o para especifica\u00e7\u00e3o \nde ontologias baseada na metodologia NeOn e que permitisse liberdade de \nacoplamento, tanto na parte visual quando na parte de sa\u00eddas resultantes \u2014 \ndocumentos que podem ser gerados ou formas de persist\u00eancia dos dados. Para \nisso houve a aplica\u00e7\u00e3o adaptada do padr\u00e3o de projeto conhecido por MVP. \n\n Tendo como ponto de partida o processo descrito na etapa de \nespecifica\u00e7\u00e3o da metodologia NeOn, foram levantados tr\u00eas casos de uso para a \naplica\u00e7\u00e3o: \n\n? Criar o Projeto: nesse processo s\u00e3o informados os requisitos gerais da \nespecifica\u00e7\u00e3o \u2014 o nome do projeto de especifica\u00e7\u00e3o (nome da ontologia), \nautores, prop\u00f3sito da ontologia, escopo, n\u00edvel de formalismo, usu\u00e1rios \ndesejados e cen\u00e1rios de uso da ontologia. Ao abstrair esse processo tamb\u00e9m \nfoi definida a forma de persist\u00eancia dos dados armazenados, que seria feita em \num arquivo XML, melhor detalhado posteriormente na sess\u00e3o 4.3. Ao criar o \nprojeto j\u00e1 \u00e9 gerada uma vers\u00e3o inicial do arquivo XML, guardando os \nrequisitos gerais cadastrados. \n\n? Cria\u00e7\u00e3o de categorias e perguntas de compet\u00eancia: \u00e9 o processo onde s\u00e3o \ncriadas as perguntas de compet\u00eancia e as categorias que as armazenam. Por \npadr\u00e3o, ao criar o projeto j\u00e1 \u00e9 criada uma categoria intitulada \u201cdefault\u201d (o \nnome pode ser alterado) para receber as perguntas. Mais categorias podem ser \ncriadas conforme a necessidade. As perguntas podem ter uma senten\u00e7a (sendo \nesta apenas a pergunta em si) ou ent\u00e3o duas senten\u00e7as (a pergunta e a sua \nresposta). Cada pergunta pode ser classificada a apenas uma categoria, \npodendo haver mudan\u00e7a posterior \u00e0 classifica\u00e7\u00e3o inicial. \n\n? Identifica\u00e7\u00e3o dos termos das perguntas de compet\u00eancia: este processo \u00e9 \nmais automatizado pela pr\u00f3pria aplica\u00e7\u00e3o. Nele \u00e9 realizada a extra\u00e7\u00e3o \nautom\u00e1tica dos termos das perguntas de compet\u00eancia (tanto das perguntas em \nsi quanto das respostas quando estas existirem). A extra\u00e7\u00e3o \u00e9 feita a partir de \ntodo o conjunto de perguntas ou do conjunto de perguntas de uma categoria \nespec\u00edfica. O conjunto dos termos encontrados s\u00e3o exibidos ao usu\u00e1rio \ndesenvolvedor para que este possa selecionar quais termos s\u00e3o relevantes para \no projeto. H\u00e1 a possibilidade tamb\u00e9m de realizar a combina\u00e7\u00e3o entre termos \ndurante a sele\u00e7\u00e3o, a fim de criar um termo composto que a extra\u00e7\u00e3o \nautom\u00e1tica n\u00e3o capturou nas senten\u00e7as. \n\n\n\n  \n\n Para a persist\u00eancia dos dados levantados pela aplica\u00e7\u00e3o, no processo de \nespecifica\u00e7\u00e3o de ontologia, optou-se pelo uso do XML. A estrutura deste \nsegue uma abstra\u00e7\u00e3o dos itens presentes no documento OSRD proposto na \netapa de especifica\u00e7\u00e3o do NeOn. Poderia ter sido utilizado a persist\u00eancia em \num banco de dados ou em outro tipo de reposit\u00f3rio de dados, mas o uso do \nXML permite \u00e0 aplica\u00e7\u00e3o uma maior comunica\u00e7\u00e3o com outros tipos de \nsistemas, ferramentas ou aplica\u00e7\u00f5es, bastando \u00e0s aplica\u00e7\u00f5es-clientes o \nconhecimento sobre a estrutura XML e a possibilidade de fazer leitura de \narquivos desse tipo. \n\n Com base nas modelagens acima descritas foi elaborada uma aplica\u00e7\u00e3o \nque atendesse \u00e0 mesmas e prestasse o suporte esperado a etapa de \nespecifica\u00e7\u00e3o da metodologia NeOn. \n\n5. Conclus\u00e3o \n\nEm rela\u00e7\u00e3o \u00e0 metodologia NeOn, mais exatamente sobre a etapa de \nespecifica\u00e7\u00e3o de ontologias, o ponto que mais se destaca \u00e9 a tentativa de \naproximar o processo de desenvolvimento de ontologias \u00e0 maturidade hoje \nobservada na Engenharia de Software, como inclusive \u00e9 citado em Su\u00e1rez-\nFigueroa (2008). \n\n O documento OSRD proposto na etapa de especifica\u00e7\u00e3o da \nmetodologia traz um padr\u00e3o exato das informa\u00e7\u00f5es relevantes \u00e0 etapa durante \no desenvolvimento da ontologia, organizando as informa\u00e7\u00f5es para que estas \nsirvam de subs\u00eddio para as etapas seguintes do processo de desenvolvimento. \n\n Com a aplica\u00e7\u00e3o h\u00e1 a possibilidade de automatizar o desenvolvimento \ndesse documento al\u00e9m de permitir uma comunica\u00e7\u00e3o facilitada com outras \naplica\u00e7\u00f5es durante o processo, respons\u00e1veis por outras etapas do mesmo, \nsendo isto poss\u00edvel a partir de um arquivo XML cuja estrutura seja de \nconhecimento comum, possibilitando a implementa\u00e7\u00e3o da correta forma de \nleitura e interpreta\u00e7\u00e3o do mesmo. \n\nReferences \n\nBORST, W. N. \u201cConstruction of Engineering Ontologies.\u201d Tese, University of \nTweenty \u2013 Centre for Telematica and Information Technology, Enschede, \nNederland, 1997. \n\nDEVEDZIC, V. \u201cUnderstanding Ontological Engineering. Communications of \nthe ACM\u201d, v. 45, n. 4, p. 136-144, 2002. \n\nG\u00d3MEZ-P\u00c9REZ, A; et al. \u201cOntologic Engineering: with examples from the \nareas of knowledge management, e-commerce and the semantic web.\u201d \nSpringer-Verlag, 2004. \n\nGRUBER, T. \u201cA translation approach  to portable ontology specification. \nKnowledge Acquisition\u201d, v. 5, n. 2, p. 199-220, 1993.  \n\n\n\n  \n\nGRUNINGER, M.; FOX, M. S. \u201cMethodology for the design and evaluation \nof ontologies.\u201d In Skuce D (ed) IJCAI95 Workshop on Basic Ontological \nIssues in Knowledge Sharing, pp 6.1\u20136.10.,1995. \n\nKIRYAKOV, A. \u201cOntologies for Knowledge Management.\u201d In: DAVIES, J.; \net al. (eds). Semantic Web Technologies: trends and research in ontology-\nbased systems, p. 115-138, 2006. \n\nPINTO, H. S.; MARTINS, J. P. \u201cOntologies: how can they be built? \nKnowledge and Information Systems\u201d, v. 6, n. 4, p. 441-464, 2004. \n\nRAUTENBERG, S.; et al. \u201contoKEM: uma ferramenta para constru\u00e7\u00e3o e \ndocumenta\u00e7\u00e3o de ontologias.\u201d In: Semin\u00e1rio de Pesquisa  em Ontologia no \nBrasil, Niter\u00f3i, Brasil, Agosto, 2008. Anais do 1\u00ba Semin\u00e1rio de Pesquisa em \nOntologia no Brasil, 2008. \n\nSU\u00c1REZ-FIGUEROA, M. C.; et al., \u201cD5.3.1 NeOn Development Process and \nOntology Life Cycle. NeOn: Lifecycle Support for Networked Ontologies\u201d, \nIntegrated Project (IST-2005-027595), NeOn-Project.org, 2007. \n\nSU\u00c1REZ-FIGUEROA, M. C., \u201cD5.4.1. NeOn Methodology for Building \nContextualized Ontology Networks. NeOn: Lifecycle Support for \nNetworked Ontologies\u201d, Integrated Project (IST-2005-027595), NeOn-\nProject.org, 2008."}]}}}