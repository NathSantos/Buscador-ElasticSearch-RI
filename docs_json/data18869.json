{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.22021"}, {"@name": "filename", "#text": "5884_dissertacao.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Programa\u00e7\u00e3o por restri\u00e7\u00f5es e\n\nescalonamento baseado em restri\u00e7\u00f5es:\n\nUm estudo de caso na programa\u00e7\u00e3o de\n\nrecursos para o desenvolvimento de\n\npo\u00e7os de petr\u00f3leo\n\nThiago Serra Azevedo Silva\n\nDisserta\u00e7\u00e3o apresentada\nao\n\nInstituto de Matem\u00e1tica e Estat\u00edstica\nda\n\nUniversidade de S\u00e3o Paulo\npara\n\nobten\u00e7\u00e3o do t\u00edtulo\nde\n\nMestre em Ci\u00eancias\n\nPrograma: Ci\u00eancia da Computa\u00e7\u00e3o\n\nOrientador: Profa. Dra. Yoshiko Wakabayashi\n\nS\u00e3o Paulo, julho de 2012\n\n\n\nPrograma\u00e7\u00e3o por restri\u00e7\u00f5es e escalonamento baseado em restri\u00e7\u00f5es:\nUm estudo de caso na programa\u00e7\u00e3o de recursos para o\n\ndesenvolvimento de po\u00e7os de petr\u00f3leo\n\nEsta disserta\u00e7\u00e3o cont\u00e9m as corre\u00e7\u00f5es e altera\u00e7\u00f5es\n\nsugeridas pela Comiss\u00e3o Julgadora durante a defesa\n\nrealizada por Thiago Serra Azevedo Silva em 23/05/2012.\n\nO original encontra-se dispon\u00edvel no Instituto de\n\nMatem\u00e1tica e Estat\u00edstica da Universidade de S\u00e3o Paulo.\n\nComiss\u00e3o Julgadora:\n\n\u2022 Profa. Dra. Yoshiko Wakabayashi (orientadora) ? IME-USP\n\n\u2022 Prof. Dr. Walter Figueiredo Mascarenhas ? IME-USP\n\n\u2022 Prof. Dr. Arnaldo Vieira Moura ? IC-UNICAMP\n\n\n\nResumo\n\nSERRA, T. Programa\u00e7\u00e3o por restri\u00e7\u00f5es e escalonamento baseado em restri\u00e7\u00f5es: Um\n\nestudo de caso na programa\u00e7\u00e3o de recursos para o desenvolvimento de po\u00e7os de pe-\n\ntr\u00f3leo.. 2012. 151 f. Disserta\u00e7\u00e3o (Mestrado) - Instituto de Matem\u00e1tica e Estat\u00edstica, Universidade\n\nde S\u00e3o Paulo, S\u00e3o Paulo, 2012.\n\nO objetivo dessa disserta\u00e7\u00e3o \u00e9 apresentar um problema de otimiza\u00e7\u00e3o do uso de recursos cr\u00edticos\n\nno desenvolvimento de po\u00e7os de petr\u00f3leo mar\u00edtimos e a t\u00e9cnica empregada para a abordagem pro-\n\nposta ao problema. A revis\u00e3o da t\u00e9cnica de Programa\u00e7\u00e3o por Restri\u00e7\u00f5es \u00e9 feita analisando aspectos\n\nrelevantes de modelagem, propaga\u00e7\u00e3o, busca e paradigmas de programa\u00e7\u00e3o. A especializa\u00e7\u00e3o da\n\nt\u00e9cnica para problemas de escalonamento, o Escalonamento Baseado em Restri\u00e7\u00f5es, \u00e9 descrita com\n\n\u00eanfase nos paradigmas descritivos e nos mecanismos de propaga\u00e7\u00e3o de restri\u00e7\u00f5es. Como subs\u00eddio\n\nao uso da t\u00e9cnica em outros problemas, a linguagem comercial de modelagem OPL \u00e9 apresentada\n\nno Ap\u00eandice. O objetivo da abordagem ao problema \u00e9 obter um escalonador para maximizar a\n\nprodu\u00e7\u00e3o de \u00f3leo obtida no curto prazo. O escalonador proposto baseia-se na declara\u00e7\u00e3o de um mo-\n\ndelo empregando vari\u00e1veis de intervalo. Um algoritmo e um modelo de Programa\u00e7\u00e3o Linear Inteira\n\nabordando relaxa\u00e7\u00f5es do problema s\u00e3o apresentados para que se obtenha um limitante superior\n\nao valor de produ\u00e7\u00e3o \u00f3timo. Para o cen\u00e1rio real no qual a an\u00e1lise experimental foi feita, foram\n\nobtidas solu\u00e7\u00f5es a menos de 16% do \u00f3timo ap\u00f3s uma hora de execu\u00e7\u00e3o; e os testes em inst\u00e2ncias\n\nde tamanhos variados evidenciaram a robustez do escalonador. Dire\u00e7\u00f5es para trabalhos futuros s\u00e3o\n\napresentadas ponderando os resultados obtidos.\n\nPalavras-chave: Programa\u00e7\u00e3o por Restri\u00e7\u00f5es, Escalonamento Baseado em Restri\u00e7\u00f5es, Desenvol-\n\nvimento de Po\u00e7os de Petr\u00f3leo Mar\u00edtimos.\n\ni\n\n\n\nii\n\n\n\nAbstract\n\nSERRA, T. Constraint programming and constraint-based scheduling: A case study in\n\nthe scheduling of resources for developing o?shore oil wells.. 2012. 151 f. Dissertation\n\n(M.Sc.) - Instituto de Matem\u00e1tica e Estat\u00edstica, Universidade de S\u00e3o Paulo, S\u00e3o Paulo, 2012.\n\nThe aim of this work is to present a problem of optimizing the use of critical resources to develop\n\no?shore oil wells and the technique used to approach the problem. The review of the Constraint\n\nProgramming technique is made by analyzing relevant aspects of modeling, propagation, search\n\nand programming paradigms. The specialization of the technique to scheduling problems, known as\n\nConstraint-Based Scheduling, is described with emphasis on descriptive paradigms and constraint\n\npropagation mechanisms. In order to support the use of the technique to tackle other problems, the\n\ncommercial modeling language OPL is presented in the appendix. The aim of the approach to the\n\nproblem is to obtain a scheduler that maximizes the short-term production of oil. The scheduler\n\npresented relies on the description of a model using interval variables. An algorithm and an Integer\n\nLinear Programming model approaching relaxations of the problem are presented in order to obtain\n\nan upper bound for the optimal production value. For the real scenario upon which the experimental\n\nanalysis was done, there were found solutions within 16% of the optimal after one hour of execution;\n\nand the tests on instances of varied sizes gave evidence of the robustness of the scheduler. Directions\n\nfor future work are presented based on the results achieved.\n\nKeywords: Constraint Programming, Constraint-Based Scheduling, O?shore Oil Well Develop-\n\nments.\n\niii\n\n\n\niv\n\n\n\nPref\u00e1cio\n\nEssa disserta\u00e7\u00e3o se divide entre a abordagem a um problema pr\u00e1tico oriundo da Petrobras\n\ne uma introdu\u00e7\u00e3o te\u00f3rica \u00e0 t\u00e9cnica empregada, sendo dado bastante destaque a essa \u00faltima. E\n\npor que tanta \u00eanfase \u00e0 t\u00e9cnica? Comparativamente, a programa\u00e7\u00e3o por restri\u00e7\u00f5es n\u00e3o goza de\n\nmuito reconhecimento no Brasil. Sua import\u00e2ncia se deve \u00e0 facilidade com que possibilita abordar\n\nproblemas combinat\u00f3rios e de escalonamento tratados frequentemente no meio acad\u00eamico e na\n\nind\u00fastria. Dessa forma, ainda que o problema estudado seja bastante interessante e pouco trivial,\n\nelaborar material atualizado e em portugu\u00eas sobre a t\u00e9cnica pode ser muito mais importante do\n\nque simplesmente reproduzir o conte\u00fado dos artigos elaborados acerca do problema. Por tal raz\u00e3o,\n\ndecidi dar igual import\u00e2ncia \u00e0 t\u00e9cnica e ao problema, al\u00e9m de repetir algumas de?ni\u00e7\u00f5es em mais\n\nde uma parte do trabalho para possibilitar ao leitor a uma leitura sequencial.\n\nPelo h\u00e1bito e con?an\u00e7a \u00e0 t\u00e9cnica, sei que me arrisco a ser omisso ou mesmo tendencioso. Dada\n\na multidisciplinaridade do campo da pesquisa operacional, \u00e9 muito comum que cada praticante se\n\nconcentre em algumas t\u00e9cnicas e acabe por ver qualquer problema apenas sob a \u00f3tica das mesmas. No\n\nmeu caso, a marcha foi inversa e acabei por me especializar no assunto em raz\u00e3o dos resultados que\n\nobtive no projeto aqui descrito. Entretanto, nem sempre fui bem-sucedido em passar essa mensagem\n\nadiante e utilizar os argumentos corretos para justi?car seu emprego. O material que apresento\n\nna primeira parte dessa disserta\u00e7\u00e3o re?ete o desenvolvimento do meu discurso a esse respeito,\n\nprocurando encorajar ao m\u00e1ximo a aplica\u00e7\u00e3o da t\u00e9cnica em situa\u00e7\u00f5es com maior potencial para\n\nsucesso. Al\u00e9m disso, a terminologia reconhecida em ingl\u00eas para os principais conceitos \u00e9 informada\n\npara que o leitor possa procurar por outras refer\u00eancias com maior facilidade. Como adendo a essa\n\nparte te\u00f3rica, a linguagem de modelagem comercial OPL \u00e9 introduzida no ap\u00eandice como forma de\n\nsubs\u00eddio \u00e0 utiliza\u00e7\u00e3o efetiva da t\u00e9cnica.\n\nN\u00e3o obstante o foco dado \u00e0 programa\u00e7\u00e3o por restri\u00e7\u00f5es, o problema abordado tem uma apli-\n\nca\u00e7\u00e3o importante e \u00e9 tratado em um grau de detalhe maior se comparado \u00e0 literatura existente.\n\nA programa\u00e7\u00e3o de recursos ditos cr\u00edticos ao desenvolvimento de novos po\u00e7os de petr\u00f3leo \u00e9 crucial\n\ndevido \u00e0 escassez e ao alto custo desses recursos, que s\u00e3o o gargalo do processo. Levando-se em conta\n\no cen\u00e1rio recente de descobertas relativamente abundantes na camada do pr\u00e9-sal e as limita\u00e7\u00f5es\n\necon\u00f4micas envolvidas, qualquer melhoria no desempenho operacional tem uma rela\u00e7\u00e3o direta com\n\na antecipa\u00e7\u00e3o da produ\u00e7\u00e3o nesses novos reservat\u00f3rios e com a consequente redu\u00e7\u00e3o dos investimen-\n\ntos necess\u00e1rios, ou com o aumento do escopo de tais investimentos. Al\u00e9m disso, o detalhamento\n\ndado ao problema serve tanto como registro documental sobre o processo sob o ponto de vista do\n\nproblema de otimiza\u00e7\u00e3o decorrente como tamb\u00e9m constitui um estudo de caso interessante pela\n\nvariedade de interdepend\u00eancias entre as atividades a serem programadas. A abordagem proposta\n\nat\u00e9m-se ao paradigma declarativo, de forma que sua relev\u00e2ncia se d\u00e1 pela forma com que captura\n\na estrutura do problema para que seja resolvido por ferramentas que se encontram no estado da\n\nv\n\n\n\nvi\n\narte. Dessa forma, al\u00e9m de validar a t\u00e9cnica com uma aplica\u00e7\u00e3o signi?cativa, o desenvolvimento do\n\nestudo de caso tamb\u00e9m ?gura como uma contribui\u00e7\u00e3o paralela \u00e0quela da apresenta\u00e7\u00e3o te\u00f3rica.\n\nMinha participa\u00e7\u00e3o nesse projeto da Petrobras concentrou-se no desenvolvimento de um novo\n\nm\u00f3dulo resolvedor para o sistema ORCA (Otimiza\u00e7\u00e3o dos Recursos Cr\u00edticos nas Atividades), que\n\nconsiste no estudo de caso apresentado. A exist\u00eancia do sistema na Petrobras precede em muito\n\nminha colabora\u00e7\u00e3o, sendo importante ressaltar o empenho pioneiro de Ricardo Accioly e Fernando\n\nMarcellino, de Romulo Albuquerque no desenvolvimento de um resolvedor para vers\u00f5es intermedi\u00e1-\n\nrias, de Gilberto Nishioka na retomada do projeto e nos detalhamentos posteriores, al\u00e9m de muitos\n\noutros colaboradores da for\u00e7a de trabalho da Petrobras, e de alunos e professores da Unicamp que\n\nse envolveram de alguma forma ao longo desses anos. Espero manter esse elo pr\u00e9-existente, fazendo\n\ncom que a publica\u00e7\u00e3o dessa disserta\u00e7\u00e3o auxilie em desenvolvimentos posteriores ou em projetos\n\nsimilares, al\u00e9m de encorajar o emprego da t\u00e9cnica em outros nichos com potencial de sucesso.\n\n\n\nAgradecimentos\n\nEm primeiro lugar, \u00e0 minha fam\u00edlia pelo papel fundamental para que esse trabalho se concre-\n\ntizasse. \u00c0 minha companheira Sabrina pela presen\u00e7a e carinho ao longo desses anos juntos, al\u00e9m\n\ndo apoio quando precisei me dedicar aos estudos e do capricho dos modelos que fez para minhas\n\napresenta\u00e7\u00f5es. \u00c0 minha m\u00e3e Ana Maria pelo sacrif\u00edcio, cuidado e amor com que criou seus ?lhos\n\ne possibilitou que pud\u00e9ssemos buscar nossos sonhos. \u00c0 minha irm\u00e3 Ana Caroline pela companhia\n\nnos bons e maus momentos desde muito cedo na vida. \u00c0 minha sogra Maria In\u00eas pelos conselhos da\n\nexperi\u00eancia e toda a co-orienta\u00e7\u00e3o informal ajudando nos meus escritos e apresenta\u00e7\u00f5es. Por ?m,\n\n\u00e0 mem\u00f3ria de meu pai Joaquim Benedito e de meus quatro av\u00f3s, que a seu tempo contribu\u00edram\n\ndireta e indiretamente para essa realiza\u00e7\u00e3o.\n\nN\u00e3o poderia tamb\u00e9m esquecer o apoio de v\u00e1rios professores e pro?ssionais diversos no \u00e2mbito\n\nacad\u00eamico. \u00c0 minha orientadora Yoshiko Wakabayashi por ter aceitado o desa?o de me orientar\n\nem um tema diferente de sua linha de pesquisa, bem como pelo n\u00edvel de suas aulas e aten\u00e7\u00e3o ao\n\ndesempenho dos alunos. Ao professor Arnaldo Vieira Moura, meu orientador de inicia\u00e7\u00e3o cient\u00ed?ca\n\nna Unicamp, por ter possibilitado meu primeiro contato com a Petrobras. Ao professor Carlos\n\nEduardo Ferreira que, em conjunto com a Yoshiko e o Arnaldo, contribuiu com sugest\u00f5es valiosas\n\nem minha banca de quali?ca\u00e7\u00e3o. Aos professores Arnaldo, Cid Carvalho de Souza, Cl\u00e1udio Leonardo\n\nLucchesi, Rodolfo Jardim Azevedo e Miguel Mira da Silva pelas cartas de recomenda\u00e7\u00e3o para minha\n\nadmiss\u00e3o no mestrado. Decerto que a lista de professores que ?zeram diferen\u00e7a \u00e9 muito maior que a\n\napresentada e gostaria de represent\u00e1-los simbolicamente por meio da professora Edileuza, da minha\n\nquarta s\u00e9rie do prim\u00e1rio, por remar contra a mar\u00e9 e se preocupar com seus alunos no contexto de\n\num ensino p\u00fablico de n\u00edveis b\u00e1sico e m\u00e9dio bastante de?cit\u00e1rio. Por ?m, ao corpo de funcion\u00e1rios\n\ndo IME e da USP por possibilitar a execu\u00e7\u00e3o de meu trabalho.\n\nCabem tamb\u00e9m agradecimentos para que o projeto ocorresse com sucesso na Petrobras. Ao\n\nFernando Marcellino por ter con?ado a mim a responsabilidade de desenvolver um novo m\u00f3dulo\n\nresolvedor. A toda a equipe do ORCA e \u00e0 estrutura subjacente, com especial aten\u00e7\u00e3o a Gilberto\n\nNishioka, Ant\u00f4nio de Oliveira e \u00e0 ger\u00eancia da TIC em S\u00e3o Paulo. A meus colegas e ex-colegas\n\nde trabalho pelos eventuais apoios, revis\u00f5es de rascunhos e sugest\u00f5es, incluindo Edson Nishida,\n\nTony Lopes, Daniel Ferber, Felipe Sodr\u00e9, Henrique Goulart e Gustavo Pacianotto. Aos colegas e\n\nprofessores da Universidade Petrobras, que acompanharam o momento de escrita desse trabalho.\n\nPor \u00faltimo, mas n\u00e3o menos importante, gostaria de lembrar algumas pessoas de contextos\n\ndiversos. A meus colegas de Unicamp Alan Godoy, Tiago Tavares e Andr\u00e9 Cir\u00e9, que acompanharam\n\nbem de perto o desenrolar desse mestrado e colaboraram como puderam para seu sucesso por meio\n\nda revis\u00e3o de rascunhos e trocas de id\u00e9ias. A outros amigos de longa data como a Amanda, o\n\nLeandro, o Lucas e o Gustavo em Santo Andr\u00e9; a Aline, o Pedro e o Hugo em Lisboa; e meus\n\ncolegas de EC03, CACo e Maratona na Unicamp. \u00c0 Ivonete pelo zelo com que cuidou de nossa casa\n\nvii\n\n\n\nviii\n\ne possibilitou que eu e a Sabrina pud\u00e9ssemos coordenar estudo e trabalho. E a todos os demais que,\n\nentendendo minha fraqueza de mem\u00f3ria e o curto espa\u00e7o dispon\u00edvel, saibam o quanto representam\n\npara essa realiza\u00e7\u00e3o por terem cruzado comigo pela vida.\n\n\n\n?Sabemos bem que toda a obra tem que ser imperfeita, e que a menos segura das nossas contem-\n\npla\u00e7\u00f5es est\u00e9ticas ser\u00e1 a de aquilo que escrevemos. Mas imperfeito \u00e9 tudo, nem h\u00e1 poente t\u00e3o belo\n\nque o n\u00e3o pudesse ser mais, ou brisa leve que nos d\u00ea sono que n\u00e3o pudesse dar-nos um sono mais\n\ncalmo ainda. E assim, contempladores iguais das montanhas e das est\u00e1tuas, gozando os dias como\n\nos livros, sonhando tudo, sobretudo, para o converter na nossa \u00edntima subst\u00e2ncia, faremos tamb\u00e9m\n\ndescri\u00e7\u00f5es e an\u00e1lises, que, uma vez feitas, passar\u00e3o a ser coisas alheias, que podemos gozar como\n\nse viessem na tarde.?\n\nBernardo Soares (heter\u00f4nimo de Fernando Pessoa), Livro do Desassossego\n\nix\n\n\n\nx\n\n\n\nSum\u00e1rio\n\nLista de Abreviaturas xv\n\nLista de Figuras xvii\n\nLista de Tabelas xix\n\nI INTRODU\u00c7\u00c3O 1\n\n1 Introdu\u00e7\u00e3o 3\n\n1.1 Refer\u00eancias e Notas de Apoio \u00e0 Leitura . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n1.2 A Ind\u00fastria de Petr\u00f3leo e a Programa\u00e7\u00e3o de Recursos Cr\u00edticos . . . . . . . . . . . . . 5\n\n1.3 Problemas de Escalonamento e a Programa\u00e7\u00e3o por Restri\u00e7\u00f5es . . . . . . . . . . . . . 8\n\n1.4 Organiza\u00e7\u00e3o do Restante do Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\nII DESCRI\u00c7\u00c3O DA T\u00c9CNICA 11\n\n2 Programa\u00e7\u00e3o por Restri\u00e7\u00f5es 13\n\n2.1 Modelagem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n2.1.1 Aplicabilidade em Fun\u00e7\u00e3o da Modelagem . . . . . . . . . . . . . . . . . . . . 15\n\n2.1.2 Boas Pr\u00e1ticas em Modelagem . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n2.2 Propaga\u00e7\u00e3o de Restri\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n2.2.1 T\u00e9cnicas de Consist\u00eancia Bin\u00e1ria . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n2.2.2 T\u00e9cnicas de Consist\u00eancia Generalizada . . . . . . . . . . . . . . . . . . . . . . 27\n\n2.3 Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n2.3.1 Busca por Recurs\u00e3o e Retrocesso . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\n2.3.2 Busca Local e Estoc\u00e1stica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n\n2.4 Paradigmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n\n2.4.1 Ferramentas Comerciais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\n2.4.2 Modelagem Abstrata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n\n3 Escalonamento Baseado em Restri\u00e7\u00f5es 41\n\n3.1 Modelagem e Paradigmas Descritivos . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n3.1.1 Caracteriza\u00e7\u00e3o por Atividades e Recursos . . . . . . . . . . . . . . . . . . . . 42\n\n3.1.2 Caracteriza\u00e7\u00e3o por Vari\u00e1veis de Intervalo . . . . . . . . . . . . . . . . . . . . 46\n\n3.2 Elementos Complementares de Resolu\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . 49\n\nxi\n\n\n\nxii SUM\u00c1RIO\n\n3.2.1 Propaga\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n\n3.2.2 Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n\nIII ESTUDO DE CASO 57\n\n4 O Problema da Programa\u00e7\u00e3o de Recursos Cr\u00edticos e Sua Abordagem 59\n\n4.1 Decis\u00f5es e Entidades Relacionadas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\n4.2 Crit\u00e9rios de Otimiza\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\n4.3 Restri\u00e7\u00f5es do Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n\n4.3.1 Restri\u00e7\u00f5es Gerais dos Recursos . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n\n4.3.2 Restri\u00e7\u00f5es Gerais de Execu\u00e7\u00e3o das Atividades . . . . . . . . . . . . . . . . . . 62\n\n4.3.3 Restri\u00e7\u00f5es de Estoque dos Recursos . . . . . . . . . . . . . . . . . . . . . . . . 62\n\n4.3.4 Restri\u00e7\u00f5es de Estoque das Atividades . . . . . . . . . . . . . . . . . . . . . . . 62\n\n4.4 Modelagem por Vari\u00e1veis de Intervalo . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n\n4.4.1 Associa\u00e7\u00e3o entre Atividades e Recursos . . . . . . . . . . . . . . . . . . . . . 63\n\n4.4.2 Associa\u00e7\u00e3o entre Atividades e Localidades . . . . . . . . . . . . . . . . . . . . 67\n\n4.4.3 Restri\u00e7\u00f5es de Estoque e Transporte de Linhas . . . . . . . . . . . . . . . . . . 68\n\n4.4.4 Fun\u00e7\u00e3o Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n4.5 Limitante Superior ao \u00d3timo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n4.5.1 Algoritmo Guloso sobre Relaxa\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . 71\n\n4.5.2 Modelo de PLI sobre Relaxa\u00e7\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . 71\n\n5 An\u00e1lise Experimental do Escalonador 77\n\n5.1 Dados Dispon\u00edveis e Ambiente de Testes . . . . . . . . . . . . . . . . . . . . . . . . . 77\n\n5.2 Experimentos Realizados e Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n\n5.3 Discuss\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n\nIV CONCLUS\u00c3O 83\n\n6 Conclus\u00e3o 85\n\nV AP\u00caNDICE 87\n\nA Programa\u00e7\u00e3o por Restri\u00e7\u00f5es em OPL 89\n\nA.1 A Linguagem OPL e o Resolvedor CP . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n\nA.2 Representa\u00e7\u00e3o do Modelo e da Entrada de Dados . . . . . . . . . . . . . . . . . . . . 90\n\nA.3 Elementos de Uso Geral da Linguagem . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n\nA.3.1 Escolha do Resolvedor do Modelo . . . . . . . . . . . . . . . . . . . . . . . . . 91\n\nA.3.2 Coment\u00e1rios em Arquivos de Modelo e de Dados . . . . . . . . . . . . . . . . 92\n\nA.3.3 Vari\u00e1veis de Tipos Primitivos e Atribui\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . 92\n\nA.3.4 Estruturas de Dados B\u00e1sicas: Vetores e Dom\u00ednios . . . . . . . . . . . . . . . . 93\n\nA.3.5 Atribui\u00e7\u00f5es B\u00e1sicas a Elementos de Vetores . . . . . . . . . . . . . . . . . . . 94\n\nA.3.6 Express\u00f5es Num\u00e9ricas e Predicados . . . . . . . . . . . . . . . . . . . . . . . . 95\n\n\n\nSUM\u00c1RIO xiii\n\nA.3.7 Operadores de Agrega\u00e7\u00e3o e Fun\u00e7\u00f5es Sobre Vetores . . . . . . . . . . . . . . . 96\n\nA.3.8 Estruturas de Dados Avan\u00e7adas: Tuplas e Conjuntos . . . . . . . . . . . . . . 98\n\nA.4 Modelagem de Problemas Combinat\u00f3rios . . . . . . . . . . . . . . . . . . . . . . . . . 99\n\nA.4.1 Vari\u00e1veis de Decis\u00e3o de Tipos Primitivos . . . . . . . . . . . . . . . . . . . . . 100\n\nA.4.2 Express\u00f5es de Decis\u00e3o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n\nA.4.3 Sobre a Impossibilidade de Usar Vari\u00e1veis float em CP . . . . . . . . . . . . 102\n\nA.4.4 Fun\u00e7\u00e3o Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n\nA.4.5 Restri\u00e7\u00f5es B\u00e1sicas Sobre Tipos Primitivos . . . . . . . . . . . . . . . . . . . . 103\n\nA.4.6 Restri\u00e7\u00f5es Especializadas Sobre Tipos Primitivos . . . . . . . . . . . . . . . . 104\n\nA.4.7 Execu\u00e7\u00e3o do Resolvedor e Con?gura\u00e7\u00f5es B\u00e1sicas do CP . . . . . . . . . . . . 105\n\nA.4.8 Manipula\u00e7\u00e3o da Solu\u00e7\u00e3o e Impress\u00e3o dos Resultados no P\u00f3s-Processamento . 106\n\nA.4.9 Um Exemplo de Problema Combinat\u00f3rio Modelado em OPL . . . . . . . . . . 106\n\nA.5 Modelagem de Problemas de Escalonamento . . . . . . . . . . . . . . . . . . . . . . . 108\n\nA.5.1 Problemas de Escalonamento e a Motiva\u00e7\u00e3o ao Emprego de CP . . . . . . . . 108\n\nA.5.2 Vari\u00e1veis de Intervalo e Suas Propriedades . . . . . . . . . . . . . . . . . . . . 108\n\nA.5.3 Restri\u00e7\u00f5es de Preced\u00eancia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\n\nA.5.4 Predicados Sobre Conjuntos de Intervalos . . . . . . . . . . . . . . . . . . . . 111\n\nA.5.5 Sequ\u00eancias e Transi\u00e7\u00f5es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n\nA.5.6 Modelagem de Recursos Limitados . . . . . . . . . . . . . . . . . . . . . . . . 113\n\nA.5.7 Fun\u00e7\u00f5es Cumulativas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n\nA.5.8 Fun\u00e7\u00f5es de Estado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117\n\nA.5.9 Um Exemplo de Problema de Escalonamento Modelado em OPL . . . . . . . 118\n\nA.6 Considera\u00e7\u00f5es Finais e Agradecimentos . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n\nRefer\u00eancias Bibliogr\u00e1?cas 121\n\n\u00cdndice Remissivo 127\n\n\n\nxiv SUM\u00c1RIO\n\n\n\nLista de Abreviaturas\n\nCBS Escalonamento Baseado em Restri\u00e7\u00f5es\n\n(de Constraint-Based Scheduling)\n\nCLP Programa\u00e7\u00e3o L\u00f3gica por Restri\u00e7\u00f5es\n\n(de Constraint Logic Programming)\n\nCP Programa\u00e7\u00e3o por Restri\u00e7\u00f5es\n\n(de Constraint Programming)\n\nCSOP Problema de Otimiza\u00e7\u00e3o da Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es\n\n(de Constraint Satisfaction Optimization Problem)\n\nCSP Problema de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es\n\n(de Constraint Satisfaction Problem)\n\nEBR Escalonamento Baseado em Restri\u00e7\u00f5es\n\nGRASP Procedimentos de Busca Gulosa, Aleat\u00f3ria e Adaptativa\n\n(de Greedy Randomized Adaptive Search Procedures)\n\nJSP Problema do Escalonamento de Ch\u00e3o-de-F\u00e1brica\n\n(de Job-Shop Scheduling Problem)\n\nMA Meta-Aprendizagem\n\nML Meta-Aprendizagem\n\n(de Meta-Learning)\n\nOPL Linguagem de Programa\u00e7\u00e3o de Otimiza\u00e7\u00e3o\n\n(de Optimization Programming Language)\n\nORCA Otimiza\u00e7\u00e3o de Recursos Cr\u00edticos nas Atividades\n\n(sistema desenvolvido na Petrobras)\n\nPEC Problema do Escalonamento de Ch\u00e3o-de-F\u00e1brica\n\nPI Programa\u00e7\u00e3o Inteira\n\nPLI Programa\u00e7\u00e3o Linear Inteira\n\nPM Programa\u00e7\u00e3o Matem\u00e1tica\n\nPLR Programa\u00e7\u00e3o L\u00f3gica por Restri\u00e7\u00f5es\n\nPR Programa\u00e7\u00e3o por Restri\u00e7\u00f5es\n\nPOSR Problema de Otimiza\u00e7\u00e3o da Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es\n\nPSR Problema de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es\n\nPTS Problema Temporal Simples\n\nSAT Problema de Satisfabilidade\n\nSTP Problema Temporal Simples\n\n(de Simple Temporal Problem)\n\nxv\n\n\n\nxvi LISTA DE ABREVIATURAS\n\n\n\nLista de Figuras\n\n1.1 Sonda mar\u00edtima Transocean Legend. . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n\n1.2 Barco lan\u00e7ador de linhas Polar Queen. . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n\n4.1 Rela\u00e7\u00e3o elementar entre intervalos associados a atividades e recursos. . . . . . . . . . 65\n\n4.2 Restri\u00e7\u00e3o de dom\u00ednios temporais e de aloca\u00e7\u00e3o no desenvolvimento de po\u00e7os. . . . . 66\n\n4.3 Rela\u00e7\u00e3o entre intervalos associados a atividades e suas respectivas localidades. . . . . 68\n\n4.4 Representa\u00e7\u00e3o das restri\u00e7\u00f5es de estoque do recurso por porto e na totalidade. . . . . 69\n\n5.1 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q1. . . . 79\n\n5.2 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q2. . . . 79\n\n5.3 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q3. . . . 79\n\n5.4 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q4. . . . 80\n\n5.5 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia H1. . . 80\n\n5.6 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia H2. . . 80\n\n5.7 Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia O. . . . 81\n\nxvii\n\n\n\nxviii LISTA DE FIGURAS\n\n\n\nLista de Tabelas\n\n4.1 Vari\u00e1veis de decis\u00e3o do modelo PLI do problema relaxado. . . . . . . . . . . . . . . . 72\n\n5.1 Principais caracter\u00edsticas das inst\u00e2ncias testadas. . . . . . . . . . . . . . . . . . . . . 77\n\n5.2 Principais resultados dos experimentos do escalonador. . . . . . . . . . . . . . . . . . 78\n\nxix\n\n\n\nxx LISTA DE TABELAS\n\n\n\nParte I\n\nINTRODU\u00c7\u00c3O\n\n1\n\n\n\n\n\nCap\u00edtulo 1\n\nIntrodu\u00e7\u00e3o\n\nProblemas combinat\u00f3rios ocorrem em diversas ind\u00fastrias, mas nem sempre s\u00e3o percebidos como\n\noportunidades para automa\u00e7\u00e3o, otimiza\u00e7\u00e3o e consequente redu\u00e7\u00e3o de custos. Um tratamento for-\n\nmal e anal\u00edtico desses problemas tem como benef\u00edcio um melhor aproveitamento de m\u00e3o-de-obra\n\nespecializada e dos bens de capital envolvidos. Tal aproveitamento pode ser observado em termos\n\nquantitativos de produ\u00e7\u00e3o, nas m\u00e9tricas de qualidade de servi\u00e7o, na observ\u00e2ncia a normas de segu-\n\nran\u00e7a, etc. Entretanto, \u00e9 importante observar que o sucesso de uma abordagem pr\u00e1tica depende da\n\nhabilidade com que o problema \u00e9 analisado e do ferramental \u00e0 disposi\u00e7\u00e3o dos pro?ssionais envol-\n\nvidos. Dessa forma, \u00e9 poss\u00edvel entender que a contribui\u00e7\u00e3o de um trabalho acad\u00eamico com foco na\n\naplica\u00e7\u00e3o se d\u00ea pelo legado para que projetos posteriores tenham maior chance de sucesso. Tendo\n\nessa observa\u00e7\u00e3o em mente, o caminho escolhido nessa disserta\u00e7\u00e3o foi o de integrar a abordagem de\n\num problema real \u00e0 descri\u00e7\u00e3o da t\u00e9cnica empregada.\n\nO problema estudado nessa disserta\u00e7\u00e3o relaciona-se ao desenvolvimento de novos po\u00e7os mar\u00edti-\n\nmos de produ\u00e7\u00e3o de petr\u00f3leo e \u00e0 manuten\u00e7\u00e3o de outros pr\u00e9-existentes, sendo abordado pela t\u00e9cnica\n\nde programa\u00e7\u00e3o por restri\u00e7\u00f5es. Cabe ressaltar que a t\u00e9cnica adotada para a abordagem n\u00e3o repre-\n\nsenta a \u00fanica op\u00e7\u00e3o poss\u00edvel, mas \u00e9 uma modalidade que goza de pouco reconhecimento a despeito\n\nda relativa facilidade com que poderia ser aplicada a muitos problemas. De forma a tornar o assunto\n\nabordado mais acess\u00edvel, alguns conceitos fundamentais de \u00e1reas correlatas e refer\u00eancias que entrem\n\nem maiores detalhes s\u00e3o apresentados na se\u00e7\u00e3o 1.1. Na sequ\u00eancia, as se\u00e7\u00f5es 1.2 e 1.3 contextua-\n\nlizam o problema em foco na ind\u00fastria em que se insere e em fun\u00e7\u00e3o do ferramental empregado,\n\nrespectivamente. O prop\u00f3sito do restante da disserta\u00e7\u00e3o \u00e9 apresentar a t\u00e9cnica adotada, introdu-\n\nzir uma ferramenta que viabilize seu uso e tratar o problema mencionado em maiores detalhes. A\n\norganiza\u00e7\u00e3o adotada para os demais cap\u00edtulos \u00e9 apresentada na se\u00e7\u00e3o 1.4.\n\n1.1 Refer\u00eancias e Notas de Apoio \u00e0 Leitura\n\nA apresenta\u00e7\u00e3o da ind\u00fastria petrol\u00edfera descrita neste cap\u00edtulo re?ete o conhecimento adquirido\n\npelo autor com sua experi\u00eancia na Petrobras, tanto por meio de treinamentos quanto pelo levanta-\n\nmentos de requisitos. Como sugest\u00e3o de refer\u00eancia para aprofundamento, veja Thomas (2004).\n\nComo parte da discuss\u00e3o sobre abordagens para a resolu\u00e7\u00e3o de problemas de otimiza\u00e7\u00e3o, s\u00e3o\n\nmencionados ou presumidos alguns conhecimentos de otimiza\u00e7\u00e3o n\u00famerica, programa\u00e7\u00e3o linear e\n\nde programa\u00e7\u00e3o linear inteira. Para uma introdu\u00e7\u00e3o ao primeiro t\u00f3pico e aos conceitos de conve-\n\nxidade de fun\u00e7\u00f5es que possibilitam o uso de algoritmos de gradiente para obter um \u00f3timo global,\n\n3\n\n\n\n4 INTRODU\u00c7\u00c3O 1.1\n\nveja Nocedal e Wright (2000). Para uma introdu\u00e7\u00e3o ao segundo, veja Bazaraa et al. (1990). Para\n\numa introdu\u00e7\u00e3o ao \u00faltimo e aos tipos de problemas que permitem uma resolu\u00e7\u00e3o e?ciente com seu\n\nuso, veja Wolsey (1998).\n\nPor ?m, diversos conceitos de teoria da computa\u00e7\u00e3o s\u00e3o mencionados no desenvolvimento te\u00f3-\n\nrico acerca da t\u00e9cnica. Para maiores detalhes sobre linguagens formais, veja Sipser (2007). Para\n\numa introdu\u00e7\u00e3o \u00e0s classes de complexidade de algoritmos, veja Cormen et al. (2002). Para maiores\n\ninforma\u00e7\u00f5es sobre teoria dos grafos, veja Bondy e Murty (2008). De forma a facilitar a consulta a\n\nconceitos de maior relev\u00e2ncia, um pequeno resumo de alguns deles \u00e9 apresentado a seguir.\n\nClasses de problemas.\n\n\u2022 Problemas NP. A classe dos problemas NP contempla problemas decis\u00f3rios cujas solu-\n\u00e7\u00f5es podem ser veri?cadas em tempo polinomial com rela\u00e7\u00e3o ao tamanho da entrada. (Mais\n\nformalmente, diz-se que tais solu\u00e7\u00f5es podem ser veri?cadas em tempo polinomial por uma\n\nm\u00e1quina de Turing n\u00e3o-determin\u00edstica.)\n\n\u2022 Problemas NP-Dif\u00edceis. Dizemos que um problema Q pertence \u00e0 classe dos problemas\nNP-Dif\u00edceis se todo problema em NP pode ser reduzido a Q em tempo polinomial.\n\n\u2022 Problemas NP-Completos. Dizemos que um problema Q pertence \u00e0 classe dos problemas\nNP-Completos se Q pertence \u00e0 classe NP, e al\u00e9m disso \u00e9 NP-Dif\u00edcil. Assim, se tiv\u00e9ssemos um\n\nalgoritmo polinomial para um problema NP-Completo, ent\u00e3o poder\u00edamos resolver em tempo\n\npolinomial todos os problemas em NP.\n\nGrafos. Um grafo G consiste em um par (V,E), onde V \u00e9 um conjunto de elementos chamados\n\nv\u00e9rtices e E \u00e9 um conjunto elementos chamados arestas, sendo que cada aresta corresponde a um\n\npar de v\u00e9rtices de V . Uma aresta correspondente a um par de v\u00e9rtices u,v ? V \u00e9 denotada por uv,\ne \u00e9 dita incidente ao tal par. Quando uma aresta \u00e9 duplamente incidente a um mesmo v\u00e9rtice, ela\n\n\u00e9 denominada la\u00e7o; e quando duas arestas distintas correspondem a um mesmo par de v\u00e9rtices elas\n\ns\u00e3o chamadas paralelas. Um grafo sem la\u00e7os e sem arestas m\u00faltiplas \u00e9 chamado simples.\n\n\u2022 Orienta\u00e7\u00e3o. Uma orienta\u00e7\u00e3o de um grafo G = (V,E) \u00e9 um grafo direcionado ? ou digrafo ?\nD = (V,E?) tendo o mesmo conjunto de v\u00e9rtices mas arestas dirigidas, de forma que a cada\n\naresta uv ? E corresponde uma aresta ??uv ? E ou ??vu ? E, mas n\u00e3o ambas.\n\n\u2022 Ordena\u00e7\u00e3o topol\u00f3gica. Uma ordena\u00e7\u00e3o topol\u00f3gica de um digrafo D = (V,E?) consiste em\numa ordena\u00e7\u00e3o linear de seus v\u00e9rtices tal que para cada aresta ??uv ? E?, o v\u00e9rtice u precede v\nnesta ordem (linear).\n\n\u2022 \u00c1rvore. Uma \u00e1rvore \u00e9 um grafo conexo e sem circuitos (ou equivalentemente, um grafo onde\nh\u00e1 um \u00fanico caminho entre cada par de v\u00e9rtices).\n\n\u2022 Subgrafo. Diz-se que um grafo H = (V ?,E?) \u00e9 subgrafo de G = (V,E) se V ? ? V e E? ? E.\n\n\u2022 Subgrafo induzido. Dizemos que H = (V ?,E?) \u00e9 um subgrafo induzido de G se E? corres-\nponde ao conjunto de todas as arestas de E incidentes exclusivamente a v\u00e9rtices de V ?. Neste\n\ncaso, H \u00e9 induzido por um conjunto de v\u00e9rtices. (O conceito de subgrafos induzidos por um\n\nconjunto de arestas n\u00e3o ser\u00e1 usado aqui.)\n\n\n\n1.2 A IND\u00daSTRIA DE PETR\u00d3LEO E A PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS 5\n\n\u2022 Isomor?smo. Dois grafos G = (V,E) e H = (V ?,E?) s\u00e3o isomorfos se existe uma bije\u00e7\u00e3o\nf : V ? V ? tal que uv ? E ? f(u)f(v) ? E?.\n\n\u2022 Grafo bipartido. Um grafo G = (V,E) \u00e9 bipartido se existem conjuntos disjuntos V1 e V2\ntais que V = V1 ?V2, e toda aresta em E \u00e9 incidente a um v\u00e9rtice de V1 e a um v\u00e9rtice de V2.\n\n\u2022 Emparelhamento m\u00e1ximo de um grafo bipartido. Um emparelhamento consiste em\num conjunto M ? E tal que nenhum par de arestas de M incide sobre um mesmo v\u00e9rtice.\nUm emparelhamento M de G \u00e9 m\u00e1ximo se n\u00e3o existe outro emparelhamento M ? de G tal que\n\n|M ?| > |M|.\n\n\u2022 Corte. Um corte de um grafo G = (V,E) \u00e9 o conjunto de todas as arestas incidentes a um\nalgum conjunto n\u00e3o-vazio W ? V e a seu complemento V \\W .\n\n1.2 A Ind\u00fastria de Petr\u00f3leo e a Programa\u00e7\u00e3o de Recursos Cr\u00edticos\n\nA ind\u00fastria petrol\u00edfera representa um cen\u00e1rio interessante a abordagens quantitativas para a\n\ntomada de decis\u00e3o devido aos altos custos envolvidos em v\u00e1rias etapas de sua cadeia produtiva.\n\nEm primeira inst\u00e2ncia, uma parcela consider\u00e1vel dos processos desenvolvidos nessa ind\u00fastria po-\n\ndem ser divididos entre o que se convencionou chamar de upstream e downstream, respectivamente\n\nrespons\u00e1veis pela obten\u00e7\u00e3o de \u00f3leo cru ? composto por g\u00e1s natural, \u00f3leo, \u00e1gua e sedimentos, sendo\n\nseparados ?sicamente ap\u00f3s a obten\u00e7\u00e3o ? e pelo seu processamento para a obten\u00e7\u00e3o de derivados ?\n\nprodutos resultantes de processos f\u00edsicos e qu\u00edmicos realizados em uma re?naria. No caso espec\u00ed-\n\n?co do upstream, os processos podem ser subdivididos entre explora\u00e7\u00e3o1 e produ\u00e7\u00e3o2, o primeiro\n\nrelacionado \u00e0 prospec\u00e7\u00e3o de potenciais reservat\u00f3rios e o segundo ao desenvolvimento e consequente\n\nextra\u00e7\u00e3o de mat\u00e9ria-prima dos reservat\u00f3rios descobertos. Para a produ\u00e7\u00e3o, destacam-se a etapa de\n\ndesenvolvimento dos po\u00e7os de um reservat\u00f3rio, a produ\u00e7\u00e3o de \u00f3leo e g\u00e1s propriamente dita, inter-\n\nven\u00e7\u00f5es peri\u00f3dicas de manuten\u00e7\u00e3o nos po\u00e7os e o fechamento dos po\u00e7os quando a produ\u00e7\u00e3o cessa. O\n\nfoco desse trabalho se dar\u00e1 nas etapas de desenvolvimento e manuten\u00e7\u00e3o dos po\u00e7os para produ\u00e7\u00e3o,\n\ncom aten\u00e7\u00e3o \u00e0s peculiaridades da extra\u00e7\u00e3o mar\u00edtima em \u00e1guas profundas. Por \u00e1guas profundas,\n\nconsideramos profundidades a partir de 300 metros por representarem o limite para a interven\u00e7\u00e3o\n\nhumana direta e para a utiliza\u00e7\u00e3o de armaduras nos po\u00e7os, o que possibilitaria aplicar t\u00e9cnicas\n\nsimilares \u00e0quelas da extra\u00e7\u00e3o terrestre.\n\nA execu\u00e7\u00e3o das atividades de desenvolvimento e manuten\u00e7\u00e3o da infraestrutura de produ\u00e7\u00e3o\n\ndepende da aloca\u00e7\u00e3o de recursos adequados \u00e0s restri\u00e7\u00f5es operacionais. No caso de \u00e1guas profundas,\n\nos recursos de maior criticidade s\u00e3o sondas mar\u00edtimas e barcos lan\u00e7adores de linhas, exempli?cados\n\npela ?gura 1.1 de Yue (2008) e pela ?gura 1.2 de Acergy-Group (2010). Esses recursos t\u00eam um\n\ncusto signi?cativamente maior do que aquele veri?cado para equipamentos empregados em outras\n\nmodalidades de produ\u00e7\u00e3o comercialmente vi\u00e1veis atualmente. Apesar dos custos envolvidos em\n\ndesenvolvimentos mar\u00edtimos serem muito maiores do que aqueles observados nas terrestres, eles\n\nainda s\u00e3o vi\u00e1veis em raz\u00e3o do pre\u00e7o pago pelo barril atualmente. No entanto, existe uma exig\u00eancia\n\nmais elevada de produ\u00e7\u00e3o para que exista uma compensa\u00e7\u00e3o ?nanceira ao desenvolvimento de po\u00e7os\n\nnessas condi\u00e7\u00f5es. Os recursos necess\u00e1rios a essas empreitas s\u00e3o tidos como cr\u00edticos por serem pouco\n\n1Denominada exploration em ingl\u00eas.\n2Denominada exploitation em ingl\u00eas.\n\n\n\n6 INTRODU\u00c7\u00c3O 1.2\n\nnumerosos e certas vezes alugados por per\u00edodos limitados de tempo, sendo necess\u00e1rio que transitem\n\nentre diversas localidades de uma regi\u00e3o de grandes dimens\u00f5es. Al\u00e9m disso, devem obedecer a rotinas\n\nconstantes de manuten\u00e7\u00e3o que interrompem a capacidade de execu\u00e7\u00e3o de alguns tipos de atividade\n\nou mesmo de qualquer atividade. Dessa forma, o uso adequado desses recursos pode representar um\n\nganho operacional signi?cativo.\n\nFigura 1.1: Sonda mar\u00edtima Transocean Legend.\n\nFigura 1.2: Barco lan\u00e7ador de linhas Polar Queen.\n\nA programa\u00e7\u00e3o das atividades nos recursos contempla tanto a aloca\u00e7\u00e3o a um recurso, i.e., como\n\n\n\n1.2 A IND\u00daSTRIA DE PETR\u00d3LEO E A PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS 7\n\nrealizar cada atividade, quanto o escalonamento do recurso, i.e., quando realiz\u00e1-las. Cada po\u00e7o\n\ncome\u00e7a a produzir ou tem uma retomada de sua produ\u00e7\u00e3o t\u00e3o logo suas atividades previstas sejam\n\nconclu\u00eddas. Por conseguinte, a programa\u00e7\u00e3o deve ser feita de forma a antecipar o ganho resultante\n\nno curto prazo para compensar os custos associados. Para o n\u00famero de atividades e de restri\u00e7\u00f5es\n\nde um cen\u00e1rio real desse problema, a programa\u00e7\u00e3o manual das atividades passou a ser invi\u00e1vel por\n\ntomar v\u00e1rios dias de trabalho de m\u00e3o-de-obra especializada. Nessa situa\u00e7\u00e3o, torna-se impratic\u00e1vel\n\nreprogramar, em curto prazo, a escala completa de atividades devido \u00e0 falta de um recurso ou ao\n\natraso na data de conclus\u00e3o prevista para uma atividade. Por consequ\u00eancia, a otimiza\u00e7\u00e3o da escala \u00e9\n\nmuitas vezes desconsiderada numa abordagem manual. Portanto, a formaliza\u00e7\u00e3o e o desenvolvimento\n\nde ferramentas capazes de resolver o problema de aloca\u00e7\u00e3o e escalonamento de recursos \u00e9 de grande\n\nimport\u00e2ncia para um melhor desempenho da organiza\u00e7\u00e3o.\n\nA primeira abordagem a este problema foi feita por Hasle et al. (1996) e motivou desenvolvi-\n\nmentos posteriores para escopos e realidades distintas, como \u00e9 o caso da brasileira. A abordagem\n\nde Hasle et al. (1996) consistia em um prot\u00f3tipo para aplica\u00e7\u00e3o no desenvolvimento de po\u00e7os no\n\nMar do Norte. Um sistema similar denominado ORCA foi desenvolvido pela Petrobras e descrito\n\nem Accioly et al. (2002). A exemplo do precursor, esse sistema empregava a t\u00e9cnica de programa\u00e7\u00e3o\n\npor restri\u00e7\u00f5es. Apesar de contemplar requisitos necess\u00e1rios ao desenvolvimento de po\u00e7os, o escopo\n\ndesse sistema restringiu-se \u00e0s atividades de manuten\u00e7\u00e3o. A demanda por esse escopo restrito surgiu\n\ndevido \u00e0 menor oferta relativa de recursos dispon\u00edveis para tal ?m, o que tornava imperativo o\n\nmelhor uso poss\u00edvel desses recursos. Uma abordagem alternativa empregando programa\u00e7\u00e3o mate-\n\nm\u00e1tica e busca tabu3 sobre uma simpli?ca\u00e7\u00e3o do problema tratado pelo sistema da Petrobras foi\n\ndesenvolvida por do Nascimento (2002) a partir de um contato inicial entre a empresa e a Unicamp.\n\nEssa autora provou que mesmo tal vers\u00e3o simpli?cada \u00e9 NP-Dif\u00edcil, sendo t\u00e3o dif\u00edcil quanto o Pro-\n\nblema do Escalonamento de Ch\u00e3o-de-F\u00e1brica (PEC)4, o que signi?ca que \u00e9 pouco prov\u00e1vel que\n\nexistam algoritmos e?cientes para o caso geral do problema tratado. Um detalhamento progressivo\n\ndessa especi?ca\u00e7\u00e3o original foi apresentado em trabalhos posteriores, cuja abordagem foi incorpo-\n\nrada ao sistema original da empresa. Pereira et al. (2005) abordou a vers\u00e3o completa do problema\n\nutilizando a meta-heur\u00edstica GRASP5, tendo um resultado superior ao original para determinados\n\ncen\u00e1rios. Um re?namento dessa abordagem \u00e9 apresentada por Moura et al. (2008b), contemplando\n\na incorpora\u00e7\u00e3o de restri\u00e7\u00f5es para o deslocamento de recursos entre localidades. O trabalho no sis-\n\ntema ORCA foi retomado recentemente e teve seu foco principal alterado para o desenvolvimento\n\nde po\u00e7os. A abordagem descrita nessa disserta\u00e7\u00e3o contempla o que foi publicado recentemente\n\nem Serra et al. (2010), Serra et al. (2011) e Serra et al. (2012), al\u00e9m de re?namentos adicionais\n\nque constar\u00e3o em publica\u00e7\u00e3o posterior sobre o trabalho desenvolvido. A retomada frequente no\n\ndesenvolvimento do ORCA se deve \u00e0 constante identi?ca\u00e7\u00e3o de novos gargalos que impossibilitem\n\na aplica\u00e7\u00e3o dos resultados sugeridos pelas solu\u00e7\u00f5es obtidas, o que \u00e9 natural em situa\u00e7\u00f5es desse tipo.\n\nConv\u00e9m observar que existem abordagens sobre problemas relacionados ao ciclo de vida dos\n\n3 Meta-heur\u00edstica denominada tabu search em ingl\u00eas, proposta por Glover (1989), na qual as opera\u00e7\u00f5es empregadas\nmais recentemente para obter uma solu\u00e7\u00e3o a partir de outra pr\u00e9-existente s\u00e3o memorizadas para n\u00e3o serem repetidas\npor um determinado n\u00famero de passos ao longo da busca por uma solu\u00e7\u00e3o de melhor qualidade.\n\n4 Tradu\u00e7\u00e3o livre adotada para o Job-Shop Scheduling Problem (JSP), que consiste no problema de minimar o\ntempo de conclus\u00e3o do escalonamento de um conjunto de sequ\u00eancias de tarefas, cada tarefa compat\u00edvel com um\ndeterminado recurso.\n\n5Acr\u00f4nimo em ingl\u00eas para Greedy Randomized Adaptive Search Procedures, ou Procedimentos de Busca Gulosa,\nAleat\u00f3ria e Adaptativa, proposta por Feo e Resende (1989), na qual solu\u00e7\u00f5es s\u00e3o geradas por meio de uma constru\u00e7\u00e3o\nsemi-gulosa que d\u00e1 margem \u00e0 aleatoriedade e de um aperfei\u00e7oamento simples ao ?nal da constu\u00e7\u00e3o\n\n\n\n8 INTRODU\u00c7\u00c3O 1.3\n\nreservat\u00f3rios de petr\u00f3leo, com rela\u00e7\u00e3o \u00e0s quais esse trabalho pode ser contextualizado. A programa-\n\n\u00e7\u00e3o de atividades de manuten\u00e7\u00e3o dos po\u00e7os em produ\u00e7\u00e3o representa um caso especial do problema\n\nem estudo, abordada por Paiva (1997) e Aloise et al. (2006) no caso de po\u00e7os terrestres. O plane-\n\njamento das atividades explorat\u00f3rias \u00e9 abordado por Glinz e Berumen (2009), sendo caracterizado\n\npor um n\u00edvel menor de detalhamento por representar um est\u00e1gio preliminar com menor grau de\n\ninforma\u00e7\u00e3o e maior incerteza acerca das caracter\u00edsticas e do potencial dos po\u00e7os a serem perfurados.\n\nAs decis\u00f5es tomadas no planejamento da explora\u00e7\u00e3o possuem um car\u00e1ter mais estrat\u00e9gico do que\n\noperacional, estando associadas \u00e0 aquisi\u00e7\u00e3o de recursos para aumentar o retorno do investimento.\n\nPor outro lado, as entidades na programa\u00e7\u00e3o do desenvolvimento de po\u00e7os possuem restri\u00e7\u00f5es rela-\n\ntivas \u00e0s caracter\u00edsticas de cada po\u00e7o, recurso ou atividade. N\u00e3o obstante tal n\u00edvel de detalhamento,\n\na programa\u00e7\u00e3o do desenvolvimento aqui abordada tem ainda um car\u00e1ter t\u00e1tico por possibilitar a\n\navalia\u00e7\u00e3o do ganho associado \u00e0 aquisi\u00e7\u00e3o de um novo recurso pela compara\u00e7\u00e3o das solu\u00e7\u00f5es com\n\ne sem o seu emprego. Dessa forma, o problema em estudo tem um papel mais cr\u00edtico devido \u00e0\n\nsua proximidade ao n\u00edvel operacional em um dos processos mais custosos na cadeia de valor da\n\ncompanhia.\n\n1.3 Problemas de Escalonamento e a Programa\u00e7\u00e3o por Restri\u00e7\u00f5es\n\nProblemas de escalonamento tratam da aloca\u00e7\u00e3o de atividades a recursos e de sua programa\u00e7\u00e3o\n\nno tempo, sendo sujeitos a restri\u00e7\u00f5es t\u00e9cnicas que devem ser satisfeitas para que essas decis\u00f5es sejam\n\nv\u00e1lidas em cada situa\u00e7\u00e3o poss\u00edvel. Conforme discutido anteriormente, \u00e9 comum que esse tipo de pro-\n\nblema envolva um detalhamento maior do que aquele encontrado em problemas de planejamento.\n\nEm muitos casos, isso acaba levando a modelos matem\u00e1ticos de representa\u00e7\u00e3o que descrevem pro-\n\nblemas computacionalmente dif\u00edceis. Por esse motivo, problemas de escalonamento nem sempre s\u00e3o\n\nabordados com a ambi\u00e7\u00e3o de que uma solu\u00e7\u00e3o \u00f3tima seja encontrada. A obten\u00e7\u00e3o de uma solu\u00e7\u00e3o\n\nfact\u00edvel j\u00e1 representa um grande avan\u00e7o de acordo com o caso, como no problema de programa\u00e7\u00e3o\n\nde transportes por dutos tratado por Moura et al. (2008a). Em outras situa\u00e7\u00f5es, \u00e9 importante ter\n\numa sistem\u00e1tica de busca que facilite a obten\u00e7\u00e3o de solu\u00e7\u00f5es cada vez melhores a um problema cuja\n\notimiza\u00e7\u00e3o seja a parte dif\u00edcil, com a ?nalidade de tornar os resultados mais con?\u00e1veis. Represen-\n\ntando um pouco de cada situa\u00e7\u00e3o, o problema tratado nesse trabalho encerra uma oportunidade\n\ninteressante para a an\u00e1lise do ferramental dispon\u00edvel para a resolu\u00e7\u00e3o de problemas de otimiza\u00e7\u00e3o\n\nde ordem pr\u00e1tica.\n\nNa aus\u00eancia de algoritmos espec\u00ed?cos que abordem um problema de modo e?ciente, t\u00e9cnicas\n\ngeneralistas como a Programa\u00e7\u00e3o Matem\u00e1tica (PM) s\u00e3o utilizadas para uma abordagem sucinta.\n\nDe maneira bem simpli?cada, em PM um problema \u00e9 descrito com a minimiza\u00e7\u00e3o ou maximiza\u00e7\u00e3o\n\nde uma fun\u00e7\u00e3o sujeita a restri\u00e7\u00f5es impostas por outras fun\u00e7\u00f5es sobre as mesmas vari\u00e1veis de decis\u00e3o.\n\nEm alguns casos, entretanto, problemas de escalonamento representam um desa?o \u00e0 aplica\u00e7\u00e3o de PM\n\ndevido a limita\u00e7\u00f5es de tempo e mem\u00f3ria dos recursos computacionais. Tais empecilhos decorrem das\n\nlimita\u00e7\u00f5es sobre o tipo de vari\u00e1veis e o tipo de restri\u00e7\u00f5es permitidos na formula\u00e7\u00e3o para o emprego\n\nde certos algoritmos. O emprego de formula\u00e7\u00f5es com restri\u00e7\u00e3o de linearidade acaba exigindo a\n\nintegralidade das vari\u00e1veis de decis\u00e3o em certos casos e faz com que seu tamanho tamb\u00e9m cres\u00e7a\n\nconsideravelmente com as dimens\u00f5es do problema. Por tal raz\u00e3o, o tempo necess\u00e1rio para resolver\n\num problema num\u00e9rico que seja t\u00e3o somente convexo acaba por crescer muito rapidamente com\n\n\n\n1.3 PROBLEMAS DE ESCALONAMENTO E A PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 9\n\ntais dimens\u00f5es. Disso resultam formula\u00e7\u00f5es maiores e, em certos casos, grandes demais para serem\n\nresolvidas com os recursos computacionais dispon\u00edveis. Dessa forma, a despeito do desenvolvimento\n\nobservado e do consenso sobre a e?c\u00e1cia da PM, nem todos os problemas podem ser abordados de\n\nforma e?ciente com a mesma6.\n\nA Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (PR) 7 representa uma alternativa \u00e0 abordagem de problemas\n\ncombinat\u00f3rios, inserindo-se no nicho n\u00e3o atendido completamente pela Programa\u00e7\u00e3o Linear In-\n\nteira (PLI) devido ao tamanho das formula\u00e7\u00f5es resultantes de tais abordagens. Em PR, a mode-\n\nlagem \u00e9 baseada em vari\u00e1veis sobre dom\u00ednios discretos e ?nitos com restri\u00e7\u00f5es arbitr\u00e1rias, por\u00e9m\n\nespecializadas. Dessa forma, a modelagem n\u00e3o est\u00e1 restrita a fun\u00e7\u00f5es lineares ou mesmo convexas\n\ncomo no caso das t\u00e9cnicas de PM; o que leva a algoritmos de busca diferentes daqueles de PM,\n\ntanto mais generalistas quanto mais focados na factibilidade do que na otimalidade. Apesar disso,\n\na modelagem possui uma liga\u00e7\u00e3o mais estreita com as t\u00e9cnicas de resolu\u00e7\u00e3o devido \u00e0 exist\u00eancia de\n\nrestri\u00e7\u00f5es dedicadas \u00e0 descri\u00e7\u00e3o de certas estruturas de problemas combinat\u00f3rios. Isso permite que\n\no algoritmo de resolu\u00e7\u00e3o possa trabalhar com maior facilidade no dom\u00ednio do problema e inferir\n\nredu\u00e7\u00f5es do espa\u00e7o de busca mais e?cazes. No caso de problemas de escalonamento, n\u00e3o apenas as\n\nrestri\u00e7\u00f5es como as pr\u00f3prias vari\u00e1veis de decis\u00e3o empregadas s\u00e3o espec\u00ed?cas ao dom\u00ednio de aplica-\n\n\u00e7\u00e3o, constituindo o que se conhece por Escalonamento Baseado em Restri\u00e7\u00f5es (EBR)8 . Em raz\u00e3o\n\ndessas peculiaridades de modelagem e da forma com que tais elementos s\u00e3o utilizados no processo\n\nde resolu\u00e7\u00e3o dos problemas, atribui-se \u00e0 t\u00e9cnica uma natureza declarativa.\n\nConv\u00e9m notar que existem t\u00e9cnicas alternativas com um enfoque no paradigma imperativo de\n\nprograma\u00e7\u00e3o, sendo tanto concorrentes quanto complementares \u00e0 PR, dado que podem ser empre-\n\ngadas como mecanismo de busca subjacente no segundo caso. Uma op\u00e7\u00e3o consiste no emprego de\n\nalgoritmos de aproxima\u00e7\u00e3o, que geram solu\u00e7\u00f5es de modo e?ciente e com uma garantia te\u00f3rica de\n\nproximidade ao \u00f3timo (Vazirani (2001)). No entanto, muitos desses algoritmos s\u00e3o propostos para\n\ninteresses mais te\u00f3ricos do que pr\u00e1ticos, o que faz com que nem sempre sejam considerados em\n\naplica\u00e7\u00f5es. Ainda pesa na op\u00e7\u00e3o por uma abordagem enumerativa como a PR em contraposi\u00e7\u00e3o ao\n\nemprego de um algoritmo determin\u00edstico a possibilidade de gera\u00e7\u00e3o de m\u00faltiplas solu\u00e7\u00f5es. Outra\n\nop\u00e7\u00e3o \u00e9 a do uso de heur\u00edsticas que se valem da experi\u00eancia pr\u00e1tica de tomadores de decis\u00e3o no\n\ndom\u00ednio de aplica\u00e7\u00e3o para que solu\u00e7\u00f5es com certa con?abilidade sejam obtidas de maneira e?ci-\n\nente. Entretanto, essa con?abilidade n\u00e3o \u00e9 traduzida em uma medida de proximidade \u00e0s solu\u00e7\u00f5es\n\n\u00f3timas e sim na evid\u00eancia de que cada heur\u00edstica se baseia em uma sucess\u00e3o de decis\u00f5es aparen-\n\ntemente razo\u00e1veis. Uma colet\u00e2nea de resultados satisfat\u00f3rios em casos diversos geralmente leva \u00e0\n\ngeneraliza\u00e7\u00e3o desses procedimentos sob a forma de meta-heur\u00edsticas aplic\u00e1veis a uma gama de pro-\n\nblemas combinat\u00f3rios. Tais meta-heur\u00edsticas podem servir tanto \u00e0 gera\u00e7\u00e3o de solu\u00e7\u00f5es quanto \u00e0\n\nobten\u00e7\u00e3o de novas solu\u00e7\u00f5es a partir de outras pr\u00e9-existentes, sendo respectivamente denominadas\n\nconstrutivas e de busca local9. A argumenta\u00e7\u00e3o em favor de alguns desses procedimentos generalis-\n\ntas remete, em muitos casos, a paralelos nos campos da f\u00edsica e da biologia, como pode ser observado\n\n6 Um leitor mais atento e experiente poderia objetar devido \u00e0 exist\u00eancia de t\u00e9cnicas para a abordagem de problemas\nde formula\u00e7\u00e3o explosiva, como a gera\u00e7\u00e3o de colunas ou de planos de corte em programa\u00e7\u00e3o linear inteira. Entretanto,\nconv\u00e9m lembrar que o enfoque dado no presente trabalho \u00e9 pela busca de uma abordagem mais acess\u00edvel e que exija\nmenos experi\u00eancia para ser replicada em outros problemas.\n\n7Denominada Constraint Programming (CP) em ingl\u00eas.\n8 Denominado Constraint-Based Scheduling (CBS) em ingl\u00eas.\n9 Conforme pode ser constatado pela descri\u00e7\u00e3o em notas anteriores, a GRASP \u00e9 construtiva e a Busca Tabu \u00e9 de\n\nbusca local.\n\n\n\n10 INTRODU\u00c7\u00c3O 1.4\n\nem Aarts e Lenstra (1997). Battiti et al. (2008) faz uma ressalva ao foco excessivo dado a esse tipo\n\nde argumento em trabalhos recentes em detrimento \u00e0 compreens\u00e3o do motivo pelo qual resultados\n\nsatisfat\u00f3rios s\u00e3o obtidos e, por consequ\u00eancia, \u00e0 ado\u00e7\u00e3o do mais adequado em cada caso. Por ?m,\n\n\u00e9 importante observar a compila\u00e7\u00e3o de estudos recentes por Hooker (2006) sobre a integra\u00e7\u00e3o de\n\nt\u00e9cnicas de forma a obter o melhor de cada uma delas, partindo de quais tipos de formula\u00e7\u00f5es s\u00e3o\n\nresolvidos com maior facilidade por quais t\u00e9cnicas de otimiza\u00e7\u00e3o. Ainda que boa parte do que foi\n\nmencionado neste par\u00e1grafo n\u00e3o seja retomada na disserta\u00e7\u00e3o, \u00e9 importante que tais considera\u00e7\u00f5es\n\nconstem como refer\u00eancia aos leitores interessados em abordagens alternativas.\n\n1.4 Organiza\u00e7\u00e3o do Restante do Trabalho\n\nAl\u00e9m da introdu\u00e7\u00e3o, esse trabalho possui outras tr\u00eas partes e um ap\u00eandice. Na segunda parte,\n\na t\u00e9cnica de programa\u00e7\u00e3o por restri\u00e7\u00f5es \u00e9 descrita no Cap\u00edtulo 2 e sua extens\u00e3o \u00e0 abordagem de\n\nproblemas de escalonamento \u00e9 apresentada no Cap\u00edtulo 3. Na terceira parte, o estudo de caso \u00e9\n\ndividido em duas etapas: a descri\u00e7\u00e3o do problema e a abordagem no Cap\u00edtulo 4, e a an\u00e1lise dos\n\nresultados obtidos no Cap\u00edtulo 5. A quarta parte contempla as considera\u00e7\u00f5es ?nais sobre o trabalho\n\ndesenvolvido. No Ap\u00eandice A, uma possibilidade de liga\u00e7\u00e3o entre a t\u00e9cnica descrita na segunda\n\nparte e a abordagem pr\u00e1tica tratada na terceira parte \u00e9 dada pela descri\u00e7\u00e3o de uma linguagem\n\nalg\u00e9brica comercial para o uso de PR.\n\nApesar da limita\u00e7\u00e3o imposta pela apresenta\u00e7\u00e3o de uma \u00fanica ferramenta para o uso pr\u00e1tico da\n\nt\u00e9cnica, \u00e9 importante frisar a import\u00e2ncia pedag\u00f3gica e introdut\u00f3ria; \u00e0 semelhan\u00e7a do que ocorre em\n\ndisciplinas de introdu\u00e7\u00e3o \u00e0 programa\u00e7\u00e3o, em que apenas os elementos b\u00e1sicos de uma linguagem s\u00e3o\n\napresentados. Espera-se que a bagagem te\u00f3rica e a no\u00e7\u00e3o de como \u00e9 poss\u00edvel coloc\u00e1-la em pr\u00e1tica\n\nd\u00eaem subs\u00eddios su?cientes para que leitores iniciantes no assunto possam tornar-se praticantes\n\nindependentes se assim o desejarem.\n\n\n\nParte II\n\nDESCRI\u00c7\u00c3O DA T\u00c9CNICA\n\n11\n\n\n\n\n\nCap\u00edtulo 2\n\nPrograma\u00e7\u00e3o por Restri\u00e7\u00f5es\n\nA Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (PR)1 \u00e9 uma t\u00e9cnica declarativa para formular e resolver proble-\n\nmas combinat\u00f3rios por meio da identi?ca\u00e7\u00e3o de estruturas que permitam uma representa\u00e7\u00e3o sucinta\n\ne facilmente explor\u00e1vel de cada problema. Devido \u00e0 essa generalidade de prop\u00f3sito e \u00e0 ?exibilidade\n\ncom que os problemas podem ser modelados, os mecanismos de resolu\u00e7\u00e3o geralmente se baseiam em\n\nt\u00e9cnicas do tipo ?tentativa-e-erro?. N\u00e3o obstante, seu diferencial ? e foco ? se deve \u00e0 explora\u00e7\u00e3o das\n\nrepresenta\u00e7\u00f5es adotadas para os problemas, de forma a reduzir o esfor\u00e7o necess\u00e1rio para a resolu\u00e7\u00e3o\n\ndos mesmos. Dessa forma, a teoria subjacente \u00e0 essa t\u00e9cnica possui tanto um foco especialista para\n\ncompreender como ela pode ser adequada a contextos de aplica\u00e7\u00e3o espec\u00ed?cos com maior e?c\u00e1cia\n\nquanto outro generalista para inferir as limita\u00e7\u00f5es ao estabelecimento de uma abordagem e?ciente\n\nde amplo espectro.\n\nO prop\u00f3sito deste cap\u00edtulo \u00e9 analisar os aspectos te\u00f3ricos gerais da PR para elucidar como\n\nela funciona e como tirar proveito dela, sendo foco do pr\u00f3ximo cap\u00edtulo a especializa\u00e7\u00e3o desses\n\nconceitos para o caso de problemas de escalonamento. Para tanto, conv\u00e9m compreender de antem\u00e3o\n\no signi?cado do nome da t\u00e9cnica e os elementos fundamentais de sua constitui\u00e7\u00e3o.\n\nA PR \u00e9 de?nida por Lustig e Puget (2001) como uma t\u00e9cnica de programa\u00e7\u00e3o de computadores\n\ndedicada \u00e0 resolu\u00e7\u00e3o de problemas combinat\u00f3rios. Por meio dela, tais problemas s\u00e3o modelados\n\ncom restri\u00e7\u00f5es projetadas para captar a estrutura do problema mais facilmente sobre as vari\u00e1veis\n\nde decis\u00e3o, sendo esta a raz\u00e3o para o nome e a vantagem subjacente \u00e0 t\u00e9cnica. Dessa forma, o termo\n\n?programa\u00e7\u00e3o? n\u00e3o assume o signi?cado de um problema matem\u00e1tico2, mas sim de uma t\u00e9cnica de\n\ncodi?ca\u00e7\u00e3o para gerar sistemas computacionais especialistas na resolu\u00e7\u00e3o de um determinado tipo de\n\nproblema combinat\u00f3rio. Lustig e Puget (2001) enfatizam a exist\u00eancia de uma camada de modelagem\n\ne outra de de?ni\u00e7\u00e3o da estrat\u00e9gia para a realiza\u00e7\u00e3o da busca, o que \u00e9 sintetizado simbolicamente\n\npor Hentenryck (2010) como ?PR = Modelo + Busca? 3. Tal decomposi\u00e7\u00e3o caracteriza a natureza\n\ndeclarativa da t\u00e9cnica, que \u00e9 devida \u00e0 independ\u00eancia do modelo quanto \u00e0 forma de busca. Devido\n\n\u00e0s sucessivas transforma\u00e7\u00f5es do paradigma \u00e0 aplica\u00e7\u00e3o da PR por usu\u00e1rios ?nais, Bart\u00e1k (1999)\n\nobserva uma \u00eanfase crescente \u00e0 modelagem em detrimento \u00e0 busca, culminando no paralelo atribu\u00eddo\n\n1 Denominada Constraint Programming (CP) em ingl\u00eas.\n2 Como exemplo oposto, \u00e9 destacada por Lustig e Puget (2001) a sem\u00e2ntica desse termo para o caso da Programa-\n\n\u00e7\u00e3o Linear (PL): a aloca\u00e7\u00e3o de recursos limitados visando otimizar um objetivo, ou seja, estabelecer a programa\u00e7\u00e3o\nmais adequada desses recursos. Para maiores detalhes, as prele\u00e7\u00f5es do Pr\u00eamio Nobel por Kantorovich (1975) e\nKoopmans (1975) apresentam a interpreta\u00e7\u00e3o econ\u00f4mica dos modelos resultantes, que conferem a sem\u00e2ntica diferen-\nciada ao uso do termo ?programa\u00e7\u00e3o?.\n\n3No original em ingl\u00eas, ?CP = Model + Search?.\n\n13\n\n\n\n14 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.1\n\na Eugene Freuder pela m\u00e1xima ?A Programa\u00e7\u00e3o por Restri\u00e7\u00f5es representa uma das abordagens mais\n\npr\u00f3ximas que a ci\u00eancia da computa\u00e7\u00e3o tem feito por ora ao Santo Graal da programa\u00e7\u00e3o: o usu\u00e1rio\n\nde?ne o problema, o computador resolve-o.4?. Entretanto, o bin\u00f4mio modelo-busca sobre sucessivos\n\nparadigmas n\u00e3o descreve com precis\u00e3o o funcionamento da PR por marginalizar a propaga\u00e7\u00e3o\n\nde restri\u00e7\u00f5es5, tida por refer\u00eancias como Bart\u00e1k (2001) como pe\u00e7a fundamental \u00e0 viabilidade do\n\nemprego dessa t\u00e9cnica. Como elemento do trip\u00e9, a propaga\u00e7\u00e3o opera na redu\u00e7\u00e3o ativa dos dom\u00ednios\n\ndas vari\u00e1veis de decis\u00e3o por meio de infer\u00eancias especializadas sobre as restri\u00e7\u00f5es em que tais\n\nvari\u00e1veis est\u00e3o presentes. Em outras palavras: de?ne-se um n\u00edvel desejado de consist\u00eancia entre\n\nas vari\u00e1veis do modelo para que atribui\u00e7\u00f5es de valores n\u00e3o con?item, sendo a manuten\u00e7\u00e3o de tal\n\nn\u00edvel garantida por algoritmos de ?ltragem. Conforme observado por Bockmayr e Kasper (1998),\n\ntal conceito guarda bastante similaridade com a gera\u00e7\u00e3o de planos de corte para a resolu\u00e7\u00e3o de\n\nproblemas de Programa\u00e7\u00e3o Linear Inteira (PLI), uma vez que ambos os casos representam o emprego\n\nde infer\u00eancia para a gera\u00e7\u00e3o de novas restri\u00e7\u00f5es sobre uma formula\u00e7\u00e3o. Em suma, a apresenta\u00e7\u00e3o\n\nda teoria geral sobre PR, que se segue, analisa separadamente modelagem, propaga\u00e7\u00e3o, busca e\n\nparadigmas de programa\u00e7\u00e3o nas se\u00e7\u00f5es 2.1 a 2.4.\n\n2.1 Modelagem\n\nFormalmente, o objeto da Programa\u00e7\u00e3o por Restri\u00e7\u00f5es \u00e9 o Problema de Satisfa\u00e7\u00e3o de Restri-\n\n\u00e7\u00f5es (PSR)6. O PSR consiste no problema de encontrar atribui\u00e7\u00f5es para um conjunto de n vari\u00e1veis\n\nde decis\u00e3o levando em conta m restri\u00e7\u00f5es de relacionamento entre tais vari\u00e1veis. Ele \u00e9 caracterizado\n\nna literatura pela tripla (X,D,R), sendo X o conjunto de vari\u00e1veis de decis\u00e3o xi para i = 1 . . .n,\n\nD o conjunto de dom\u00ednios Di para i = 1 . . .n, e R o conjunto de restri\u00e7\u00f5es rj para j = 1 . . .m.\n\nCada vari\u00e1vel possui seu respectivo dom\u00ednio discreto e ?nito de valores para atribui\u00e7\u00e3o, de forma\n\nque (xi ? xi) ? (xi ? Di) para i = 1 . . .n. Cada restri\u00e7\u00e3o rj(x1,x2, . . . ,xn) \u00e9 uma rela\u00e7\u00e3o mate-\nm\u00e1tica representando um subconjunto Sj do conjunto D1 \u00d7D2 \u00d7 . . .\u00d7Dn. Tais restri\u00e7\u00f5es podem\nser representadas tanto de modo enumerativo por meio da listagem de todas as tuplas que as satis-\n\nfazem quanto de modo declarativo por meio de uma express\u00e3o que descreva a linguagem formada\n\npelas tuplas que satisfazem a restri\u00e7\u00e3o7. Uma restri\u00e7\u00e3o rj \u00e9 dita satisfeita por (x1,x2, . . . ,xn) se,\n\ne somente se, (x1,x2, . . . ,xn) ? Sj. A solu\u00e7\u00e3o de um PSR consiste em uma atribui\u00e7\u00e3o a suas va-\nri\u00e1veis, digamos (x1,x2, . . . ,xn), tal que (x1,x2, . . . ,xn) ? Sj, j = 1 . . .m, i.e., (x1,x2, . . . ,xn)\nsatisfaz todo o conjunto de restri\u00e7\u00f5es R. No caso de um problema de otimiza\u00e7\u00e3o, a de?ni\u00e7\u00e3o do\n\nPSR \u00e9 estentida por Lustig e Puget (2001) e alguns outros autores como o Problema de Otimi-\n\nza\u00e7\u00e3o da Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (POSR)8 para contemplar a exist\u00eancia de uma fun\u00e7\u00e3o objetivo\n\nf : D1 \u00d7D2 \u00d7 . . .\u00d7Dn ?&lt;que mapeie cada solu\u00e7\u00e3o poss\u00edvel ou tentativa do PSR a um valor real,\na ser maximizado ou minimizado. Apesar do car\u00e1ter meramente formal das de?ni\u00e7\u00f5es apresentadas,\n\nelas acabam por corresponder \u00e0 estrutura com que os problemas s\u00e3o modelados em PR em raz\u00e3o\n\n4 No original em ingl\u00eas, citado por Bart\u00e1k (1999), ?Constraint Programming represents one of the closest appro-\naches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer\nsolves it.\".\n\n5 Denominada constraint propagation em ingl\u00eas.\n6 Denominado Constraint Satisfaction Problem (CSP) em ingl\u00eas.\n7 Na literatura, restri\u00e7\u00f5es declarativas s\u00e3o descritas como express\u00f5es num\u00e9ricas. Entretanto, uma express\u00e3o regular\n\ntamb\u00e9m \u00e9 conveniente ? e talvez mais apropriada em alguns casos ?, visto que representa qualquer combina\u00e7\u00e3o de\ntuplas de um alfabeto. No caso da PR, o alfabeto seriam os dom\u00ednios das vari\u00e1veis de decis\u00e3o.\n\n8 Denominado Constraint Satisfaction Optimization Problem (CSOP) em ingl\u00eas.\n\n\n\n2.1 MODELAGEM 15\n\nda generalidade com rela\u00e7\u00e3o \u00e0s restri\u00e7\u00f5es poss\u00edveis.\n\nNo entanto, conv\u00e9m ressaltar que a forma com que a otimiza\u00e7\u00e3o \u00e9 considerada na PR n\u00e3o \u00e9 de\n\ntodo consensual. Notadamente, o PSOR corresponde a uma concep\u00e7\u00e3o de otimiza\u00e7\u00e3o muito mais\n\narraigada \u00e0 pesquisa operacional do que \u00e0 intelig\u00eancia arti?cial, campos esses com vis\u00f5es bastante\n\ndistintas sobre a t\u00e9cnica. Brailsford et al. (1999) compreende a otimiza\u00e7\u00e3o na PR como a forma pela\n\nqual restri\u00e7\u00f5es fracas 9, cuja satisfa\u00e7\u00e3o \u00e9 desej\u00e1vel mas n\u00e3o necess\u00e1ria \u00e0 viabilidade das solu\u00e7\u00f5es\n\ndo problema, procuram ser satisfeitas. Nessa linha, a otimiza\u00e7\u00e3o \u00e9 interpretada como o processo de\n\nbusca de solu\u00e7\u00f5es que reduzam a viola\u00e7\u00e3o das restri\u00e7\u00f5es fracas. Essa vis\u00e3o \u00e9 partilhada por Dechter\n\n(2003), sendo esse o ponto de maior cr\u00edtica \u00e0 sua obra na resenha feita por Bart\u00e1k (2008). Sem\n\nembargo, dado o enfoque \u00e0 abordagem de um problema de pesquisa operacional na pr\u00f3xima parte\n\nda disserta\u00e7\u00e3o, optamos por enfatizar o PSOR como a forma com que consideramos a otimiza\u00e7\u00e3o\n\nna PR.\n\n2.1.1 Aplicabilidade em Fun\u00e7\u00e3o da Modelagem\n\nA utilidade da t\u00e9cnica de PR decorre da abrang\u00eancia de problemas que sua modelagem pode\n\ncontemplar e que, por conseguinte, sua busca pode ? em muitos casos ? solucionar. Uma vez que \u00e9\n\nposs\u00edvel representar problemas pertinentes \u00e0 classe NP-Completo por meio de PSRs, Dechter (2003)\n\nobserva que PSRs tamb\u00e9m s\u00e3o problemas NP-Completos. Por motivo similar, o PSOR pertence \u00e0\n\nclasse dos problemas NP-Dif\u00edceis, de forma que a expectativa sobre a PR nesse caso n\u00e3o \u00e9 de que\n\nsolu\u00e7\u00f5es \u00f3timas possam ser sempre encontradas em tempo polinomial para quaisquer inst\u00e2ncias.\n\nDessa feita, o esfor\u00e7o empreendido pela PR objetiva facilitar a resolu\u00e7\u00e3o de nichos espec\u00ed?cos em-\n\npregando o ferramental \u00e0 sua disposi\u00e7\u00e3o, i.e., modelos que facilitem a propaga\u00e7\u00e3o e a busca. Ainda\n\nque n\u00e3o seja uma percep\u00e7\u00e3o comum na literatura sobre PR, a pr\u00e1tica da \u00e1rea corresponde \u00e0 pedra\n\nangular da Meta-Aprendizagem (MA)10 para o problema da sele\u00e7\u00e3o de algoritmos. Smith-Miles\n\n(2008) apresenta o objeto de estudo da MA para a sele\u00e7\u00e3o de algoritmos como sendo a identi?ca\u00e7\u00e3o\n\nde par\u00e2metros de problemas que justi?quem a diferen\u00e7a de desempenho de diversos algoritmos, de\n\nforma a escolher o algoritmo mais apropriado a cada problema. Observa\u00e7\u00f5es preliminares \u00e0 elabo-\n\nra\u00e7\u00e3o dessa disserta\u00e7\u00e3o foram tecidas a esse respeito em Serra e Wakabayashi (2010), ressaltando\n\nque n\u00e3o \u00e9 poss\u00edvel obter o melhor benef\u00edcio poss\u00edvel da PR sem a compreens\u00e3o do tipo de problemas\n\npara os quais componentes espec\u00ed?cos foram concebidos. Destarte, \u00e9 importante avaliar se a forma\n\ncom que a propaga\u00e7\u00e3o e a busca operam sobre o modelo repercutem em uma gera\u00e7\u00e3o e?caz de\n\nsolu\u00e7\u00f5es. No caso de problemas de otimiza\u00e7\u00e3o, cabe ainda a avalia\u00e7\u00e3o da qualidade das solu\u00e7\u00f5es\n\nobtidas com rela\u00e7\u00e3o tanto ao que poderia ser obtido por outras t\u00e9cnicas cobrindo o mesmo nicho\n\nquanto pelo ganho potencial representado por pequenas modi?ca\u00e7\u00f5es sobre as solu\u00e7\u00f5es obtidas ?\n\no que evidenciaria falta de qualidade nas solu\u00e7\u00f5es geradas. Portanto, a adequa\u00e7\u00e3o da sintaxe de\n\nmodelagem a um problema representa uma condi\u00e7\u00e3o necess\u00e1ria mas n\u00e3o su?ciente para o sucesso\n\nda abordagem de tal problema pela t\u00e9cnica.\n\nNo que diz respeito aos tipos de problema com modelagem facilitada em PR, consideramos\n\naqueles contendo apenas decis\u00f5es discretas e para os quais, geralmente, a formula\u00e7\u00e3o utilizando\n\nPrograma\u00e7\u00e3o Inteira (PI) n\u00e3o \u00e9 uma op\u00e7\u00e3o devido \u00e0 explos\u00e3o no n\u00famero de vari\u00e1veis e/ou restri-\n\n\u00e7\u00f5es e \u00e0 di?culdade para satisfazer as restri\u00e7\u00f5es de integralidade. Tal \u00e9 o caso, por exemplo, de\n\n9Denominadas soft constraints em ingl\u00eas.\n10Denominada Meta-Learning (ML) em ingl\u00eas.\n\n\n\n16 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.1\n\nmuitos problemas de escalonamento: muitos deles s\u00e3o formulados com vari\u00e1veis 0/1 em que cada\n\nvari\u00e1vel, digamos yijt, expressa um predicado como ?atividade i est\u00e1 sendo realizada com con?gu-\n\nra\u00e7\u00e3o j no instante de tempo t?. No caso da PI, esse tipo de vari\u00e1vel permite que o problema seja\n\nmodelado empregando apenas rela\u00e7\u00f5es lineares no conjunto de restri\u00e7\u00f5es, de forma a se bene?ciar\n\ndos algoritmos mais e?cientes de PI que poderiam possivelmente resolver o problema. Entretanto,\n\ntal decomposi\u00e7\u00e3o em vari\u00e1veis bin\u00e1rias ? pelo produto cartesiano das dimens\u00f5es do problema ?\n\ncresce em tamanho muito rapidamente, especialmente se a dimens\u00e3o temporal \u00e9 aumentada. Por-\n\ntanto, apesar do fato de cada vari\u00e1vel de decis\u00e3o em PR requerer muito mais mem\u00f3ria de acordo\n\ncom o manual da IBM (2010), ela possui um valor sem\u00e2ntico muito maior e pode representar tanta\n\ninforma\u00e7\u00e3o quanto diversas vari\u00e1veis bin\u00e1rias combinadas. Esse mesmo argumento pode ser aplicado\n\ncom rela\u00e7\u00e3o ao conjunto de restri\u00e7\u00f5es. Dessa forma, o papel da PR acaba por ser complementar ao\n\nde outras t\u00e9cnicas e, no que diz respeito \u00e0 modelagem, sua aplica\u00e7\u00e3o \u00e9 favorecida em dom\u00ednios de\n\nproblemas nos quais representa\u00e7\u00f5es mais compactas s\u00e3o poss\u00edveis ? n\u00e3o se olvidando a quest\u00e3o de\n\ndesempenho do modelo mencionada anteriormente.\n\nExemplo de Aplica\u00e7\u00e3o: Rotula\u00e7\u00e3o Graciosa de Grafos\n\nPelo per?l de problemas que a PR se prop\u00f5e a resolver, a op\u00e7\u00e3o mais direta para exempli?car sua\n\naplica\u00e7\u00e3o seria por meio de modelos de problemas combinat\u00f3rios cl\u00e1ssicos para os quais foi observado\n\num desempenho razo\u00e1vel. Entretanto, isso n\u00e3o agregaria tanto quanto apontar um caso em que foi\n\npercebida uma vantagem consider\u00e1vel em um nicho com menos abordagens bem-sucedidas. E esse\n\n\u00e9 o caso do problema da rotula\u00e7\u00e3o graciosa11 de grafos.\n\nDiz-se que um grafo G = (V,E) com n = |V | v\u00e9rtices e m = |E| arestas possui uma rotula\u00e7\u00e3o\ngraciosa se \u00e9 poss\u00edvel atribuir a cada um de seus v\u00e9rtices um r\u00f3tulo \u00fanico f : V ?{0, 1, 2 . . .m}, e\na cada uma de suas arestas um r\u00f3tulo \u00fanico g : E ?{1, 2 . . .m}, de modo que g(ij) = |f(i)?f(j)|\npara cada aresta ij ? E, onde i,j ? V . O problema consiste em encontrar para um dado grafo uma\ntal rotula\u00e7\u00e3o graciosa, se existente.\n\nDe acordo com Lustig e Puget (2001), mesmo para pequenas inst\u00e2ncias desse problema, n\u00e3o\n\nse sabia se estas possu\u00edam ou n\u00e3o uma rotula\u00e7\u00e3o graciosa at\u00e9 que a PR fosse aplicada. Como\n\nforma de explicar o que signi?ca uma modelagem de PR na pr\u00e1tica, a seguir \u00e9 apresentado um\n\nmodelo adaptado de Lustig e Puget (2001) para esse problema na linguagem OPL. A adapta\u00e7\u00e3o foi\n\nnecess\u00e1ria devido \u00e0s mudan\u00e7as a que a linguagem foi submetida ao longo da \u00faltima d\u00e9cada. Para\n\nfacilitar a compreens\u00e3o, as vari\u00e1veis e dom\u00ednios do modelo tiveram sua nomenclatura traduzida.\n\nAinda que n\u00e3o seja o escopo dessa parte do trabalho a descri\u00e7\u00e3o de uma linguagem de modelagem\n\npara PR, o exemplo apresentado tem um papel importante por materializar a modelagem em PR e\n\npor permitir uma explica\u00e7\u00e3o no n\u00edvel necess\u00e1rio aos objetivos presentes. Para maiores informa\u00e7\u00f5es\n\nsobre a linguagem OPL, o leitor pode se referir ao Ap\u00eandice A.\n\n11 Tradu\u00e7\u00e3o livre da express\u00e3o graceful labeling em ingl\u00eas.\n\n\n\n2.1 MODELAGEM 17\n\n1 int noVertices = . . . ;\n\n2 range dVertices = 1 . . noVertices ;\n\n3 tuple Aresta {\n\n4 Vertices i ;\n\n5 Vertices j ;\n\n6 };\n\n7 {Aresta} arestas = . . . ;\n\n8 int noArestas = card ( arestas ) ;\n\n9 range dRotulos = 0 . . noArestas ;\n\n10 dvar int rotuloVertice [ dVertices ] in dRotulos ;\n\n11 dvar int rotuloAresta [ arestas ] in dRotulos ;\n\n12 subject to {\n\n13 a l l D i f f e r e n t ( rotuloVertice ) ;\n\n14 a l l D i f f e r e n t ( rotuloAresta ) ;\n\n15 f o r a l l (a in arestas ) {\n\n16 rotuloAresta [ a ] = abs ( rotuloVertice [ a . i ] ? rotuloVertice [ a . j ] ) ;\n17 rotuloAresta [ a ] > 0;\n\n18 }\n\n19 };\n\nAs primeiras nove linhas do modelo descrevem estruturas e entradas de dados. A declara\u00e7\u00e3o\n\nexpl\u00edcita de dom\u00ednio das rotula\u00e7\u00f5es na linha 9 serve como subs\u00eddio \u00e0 declara\u00e7\u00e3o das vari\u00e1veis de\n\ndecis\u00e3o. As vari\u00e1veis de decis\u00e3o referem-se aos valores de rotula\u00e7\u00e3o dos v\u00e9rtices e arestas, conforme\n\ndeclarado nas linhas 10 e 11. Como pode ser observado pela aus\u00eancia de um crit\u00e9rio de otimiza\u00e7\u00e3o\n\nno c\u00f3digo, trata-se de um problema estritamente de satisfabilidade. A restri\u00e7\u00e3o alldi?erent, repre-\n\nsentada nas linhas 13 e 14 pelo nome allDifferent em OPL, de?ne que os valores atribu\u00eddos a\n\ncada entrada do vetor de vari\u00e1veis de decis\u00e3o dado como argumento sejam \u00fanicos, de forma que\n\nv\u00e9rtices distintos ou arestas distintas s\u00e3o tenham a mesma rotula\u00e7\u00e3o. Essa restri\u00e7\u00e3o est\u00e1 presente\n\nem muitos modelos de problemas combinat\u00f3rios e \u00e9 descrita em maior detalhe na se\u00e7\u00e3o 2.2.2. Na\n\nlinha 15, \u00e9 declarado um bloco de restri\u00e7\u00f5es indexado sobre cada aresta do grafo, garantindo na\n\nlinha 16 a diferen\u00e7a absoluta de rotula\u00e7\u00e3o dos v\u00e9rtices conforme exigido pelo problema. Na linha 17,\n\nde?ne-se que a rotula\u00e7\u00e3o nula n\u00e3o seja dada a nenhuma aresta. Uma \u00faltima observa\u00e7\u00e3o importante\n\ndo modelo refere-se ao dom\u00ednio das vari\u00e1veis de decis\u00e3o: em uma formula\u00e7\u00e3o de PI, por exemplo, n\u00e3o\n\nseria poss\u00edvel expressar uma restri\u00e7\u00e3o como alldi?erent empregando o mesmo conjunto de vari\u00e1veis\n\nde decis\u00e3o adotado.\n\nOutros Exemplos de Aplica\u00e7\u00e3o: Problema das n Rainhas e Sudoku\n\nOutros dois exemplos de problemas mais conhecidos e que ilustram a expressividade da t\u00e9cnica\n\ns\u00e3o o problema das n rainhas e o sudoku. O primeiro deles, que consiste em posicionar n rainhas\n\nem um tabuleiro de xadrez sem nenhum par possa se atacar, \u00e9 apresentado na se\u00e7\u00e3o A.4.9 do\n\nap\u00eandice. O segundo, que consiste em preencher um quadro de 9x9 com os n\u00fameros 1 a 9 de tal\n\nforma que os n\u00fameros n\u00e3o se repitam em nenhuma linha, coluna ou quadrante 3x3, possui uma\n\nformula\u00e7\u00e3o bastante concisa por meio de restri\u00e7\u00f5es alldi?erent. Dessa forma, o modelo apresentado\n\na seguir pode ser utilizado para resolver problemas de sudoku, sendo que a inclus\u00e3o de valores ?xos\n\na algumas posi\u00e7\u00f5es \u00e9 facilmente tratada pela inclus\u00e3o de restri\u00e7\u00f5es adicionais ou pela declara\u00e7\u00e3o de\n\num dom\u00ednio mais restrito na primeira linha do modelo:\n\n\n\n18 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.1\n\n1 dvar int rotuloPosicao [ 1 . . 9 ] [ 1 . . 9 ] in 1 . . 9 ;\n\n2 subject to {\n\n3 f o r a l l ( i in 1 . . 9 ) {\n\n4 a l l D i f f e r e n t ( rotuloPosicao [ i ] ) ;\n\n5 a l l D i f f e r e n t ( a l l ( j in 1 . . 9 ) rotuloPosicao [ j ] [ i ] ) ;\n\n6 }\n\n7 f o r a l l ( i in 0 . . 2 , j in 0 . . 2 ) {\n\n8 a l l D i f f e r e n t (\n\n9 a l l ( i i in i ?3 + 1 . . i ?3+3, j j in j ?3 + 1 . . j ?3 +3)\n10 rotuloPosicao [ i i ] [ j j ] ) ;\n\n11 }\n\n12 };\n\nA restri\u00e7\u00e3o alldi?erent da linha 4 do modelo acima garante que o mesmo valor n\u00e3o seja usado\n\nmais de uma vez na mesma linha do quadro. A linha 5 garante o mesmo para cada coluna do quadro.\n\nNas linha 8 a 10, isso \u00e9 garantido para cada um dos 9 quadros 3x3 resultantes do particionamento\n\ndo quadro 9x9 em tr\u00eas partes horizontes e tr\u00eas partes verticais.\n\n2.1.2 Boas Pr\u00e1ticas em Modelagem\n\nA despeito dessa natureza declarativa e da generalidade com rela\u00e7\u00e3o \u00e0s restri\u00e7\u00f5es poss\u00edveis, j\u00e1 foi\n\nobservado anteriormente que n\u00e3o se pode ignorar o impacto da modelagem sobre o desempenho do\n\nsistema. Dito de outra forma, \u00e9 importante notar que a diferentes modelos com a mesma ?nalidade\n\ncorresponder\u00e3o desempenhos diversos.\n\nUm caso bem comum desse fator diz respeito \u00e0 exist\u00eancia de simetrias no modelo, tendo como\n\nconsequ\u00eancia um espa\u00e7o de busca maior do que o necess\u00e1rio. Consideremos, por exemplo, a situa-\n\n\u00e7\u00e3o mencionada por Hentenryck et al. (2000) em que diferentes con?gura\u00e7\u00f5es de um tabuleiro de\n\nxadrez diferem apenas por rota\u00e7\u00e3o: tais solu\u00e7\u00f5es seriam equivalentes para a resolu\u00e7\u00e3o do problema\n\nsendo abordado? Em caso positivo, pode-se partir para a identi?ca\u00e7\u00e3o de simetrias a serem que-\n\nbradas por meio do estabelecimento de restri\u00e7\u00f5es adicionais que reduzam o espa\u00e7o de busca. Tal\n\nredu\u00e7\u00e3o deve ser feita sem preju\u00edzo \u00e0 corretude, por meio da preserva\u00e7\u00e3o de ao menos uma solu\u00e7\u00e3o\n\nequivalente a cada solu\u00e7\u00e3o do modelo original. Cabe a ressalva de que a quebra de simetria pode\n\ntrazer mais sobrecarga do que benef\u00edcio. Isso pode ocorrer se o foco n\u00e3o for uma busca exaustiva e a\n\nquebra representada pela novas restri\u00e7\u00f5es incidir sobre alguma parte do espa\u00e7o de solu\u00e7\u00f5es que, de\n\noutra forma, seria explorado antes e com maior proveito. Dessa forma, compete que a identi?ca\u00e7\u00e3o\n\nde simetrias seja observada na modelagem, mas a implementa\u00e7\u00e3o de uma quebra deve atentar \u00e0\n\npossibilidade de ganho em desempenho para a resolu\u00e7\u00e3o do sistema.\n\nAl\u00e9m da quest\u00e3o sobre as simetrias, certos problemas podem admitir diversos modelos que\n\nrepresentem o mesmo espa\u00e7o de busca. A esse respeito, o manual da IBM (2010) enfatiza que o\n\nestabelecimento de boas pr\u00e1ticas para a modelagem usando PR ainda \u00e9 uma \u00e1rea bastante cinzenta,\n\npara a qual n\u00e3o existe uma consolida\u00e7\u00e3o similar \u00e0 descrita para a PM em Williams (2005). De certa\n\nforma, essa discuss\u00e3o n\u00e3o pode ser feita apenas no n\u00edvel da modelagem, uma vez que a quali?ca\u00e7\u00e3o do\n\ndesempenho do modelo depende de conceitos relativos \u00e0 propaga\u00e7\u00e3o e \u00e0 busca. Como exemplo dessa\n\ncorrela\u00e7\u00e3o, Brailsford et al. (1999) destaca a import\u00e2ncia do emprego de restri\u00e7\u00f5es redundantes no\n\nmodelo para que a precis\u00e3o do modelo n\u00e3o se deva \u00e0s mesmas restri\u00e7\u00f5es que mant\u00e9m o n\u00edvel de\n\npropaga\u00e7\u00e3o, podendo estas serem mais simples do que aquelas. Assim sendo, cabe que esse assunto\n\n\n\n2.2 PROPAGA\u00c7\u00c3O DE RESTRI\u00c7\u00d5ES 19\n\nseja sempre discutido em car\u00e1ter transversal aos elementos de modelo, busca e propaga\u00e7\u00e3o da PR.\n\n2.2 Propaga\u00e7\u00e3o de Restri\u00e7\u00f5es\n\nA propaga\u00e7\u00e3o de restri\u00e7\u00f5es consiste na gera\u00e7\u00e3o de infer\u00eancias sobre as restri\u00e7\u00f5es empregadas no\n\nmodelo como forma de reduzir o esfor\u00e7o necess\u00e1rio \u00e0 realiza\u00e7\u00e3o da busca. Tais infer\u00eancias consistem\n\nna inspe\u00e7\u00e3o de quais valores das vari\u00e1veis s\u00e3o incompat\u00edveis entre si em fun\u00e7\u00e3o das restri\u00e7\u00f5es,\n\nlevando \u00e0 remo\u00e7\u00e3o dos valores dos dom\u00ednios das vari\u00e1veis antes ou durante a busca. Essas redu\u00e7\u00f5es\n\ns\u00e3o fundamentadas no princ\u00edpio de que nenhuma solu\u00e7\u00e3o ao problema possuir\u00e1 os valores eliminados\n\natribu\u00eddos \u00e0s suas respectivas vari\u00e1veis. Se uma remo\u00e7\u00e3o \u00e9 realizada antes da busca, isso signi?ca\n\nque nunca ser\u00e1 desfeita porque n\u00e3o \u00e9 circunstancial. No caso de ser feita durante a busca, ela pode\n\nser re?exo de decis\u00f5es tomadas ao longo da resolu\u00e7\u00e3o. Nesse caso, ela pode ou n\u00e3o ser desfeita at\u00e9 o\n\nt\u00e9rmino da busca, de acordo com a necessidade de reverter tais decis\u00f5es para que n\u00e3o haja preju\u00edzo\n\n\u00e0 completude do processo. O n\u00edvel em que essa inspe\u00e7\u00e3o de compatibilidade entre as vari\u00e1veis \u00e9\n\nrealizada impacta tanto na redu\u00e7\u00e3o que pode ser obtida para os dom\u00ednios quanto nos recursos\n\ncomputacionais necess\u00e1rios para que tal redu\u00e7\u00e3o seja atingida. Portanto, compete avaliar onde\n\nreside a melhor rela\u00e7\u00e3o de custo-benef\u00edcio entre o esfor\u00e7o necess\u00e1rio e a redu\u00e7\u00e3o de dom\u00ednios obtida\n\npara cada caso. De modo geral, a propaga\u00e7\u00e3o permite que as solu\u00e7\u00f5es ao problema se tornem mais\n\nevidentes e que as inconsist\u00eancias remanescentes n\u00e3o prejudiquem tanto o desempenho da busca\n\npara encontr\u00e1-las.\n\nA propaga\u00e7\u00e3o \u00e9 realizada por t\u00e9cnicas de consist\u00eancia dos mais variados tipos e n\u00edveis. Com\n\nrela\u00e7\u00e3o ao tipo, existem t\u00e9cnicas dedicadas a uma restri\u00e7\u00e3o espec\u00ed?ca ou a uma classe delas, como a\n\nclasse de restri\u00e7\u00f5es que determinam a rela\u00e7\u00e3o entre um determinado n\u00famero de vari\u00e1veis. Para cada\n\nclasse de restri\u00e7\u00f5es, s\u00e3o estabelecidos n\u00edveis de consist\u00eancia em termos de certi?cados sobre quais\n\ncon?gura\u00e7\u00f5es inv\u00e1lidas s\u00e3o evitadas por meio das infer\u00eancias de redu\u00e7\u00e3o dos dom\u00ednios, como quantos\n\nvalores podem ser atribu\u00eddos sem que ocorra um con?ito. Tais infer\u00eancias podem ser produzidas\n\npor diversos algoritmos poss\u00edveis, ditos algoritmos de ?ltragem. Em raz\u00e3o da exist\u00eancia de mais\n\nde um n\u00edvel para a propaga\u00e7\u00e3o, torna-se evidente o fato que as redu\u00e7\u00f5es obtidas variam e, por\n\nconseguinte, a elimina\u00e7\u00e3o de atribui\u00e7\u00f5es inconsistentes n\u00e3o \u00e9 sempre completa. Na pr\u00e1tica, Bart\u00e1k\n\n(2001) observa que a consist\u00eancia completa do modelo ? situa\u00e7\u00e3o na qual a busca sobre o modelo\n\n\u00e9 feita sem que nenhuma decis\u00e3o da busca tenha que ser revertida ou que o modelo \u00e9 tido como\n\ninsatisfat\u00edvel por algum dom\u00ednio ter se tornado vazio ? n\u00e3o costuma ser uma op\u00e7\u00e3o vi\u00e1vel devido\n\nao esfor\u00e7o necess\u00e1rio para atingi-la. A?nal, reduzir os dom\u00ednios a tal ponto que a busca seja feita\n\nem tempo linear no n\u00famero de vari\u00e1veis ? ou seja, em tempo ?xo por atribui\u00e7\u00e3o ? corresponderia\n\na delegar \u00e0 propaga\u00e7\u00e3o a resolu\u00e7\u00e3o do problema NP-Completo em que consiste o PSR no caso\n\ngeral. Al\u00e9m disso, os n\u00edveis mais elementares costumam garantir a remo\u00e7\u00e3o da maior parte dos\n\nvalores inconsistentes, de forma que compensa mais explorar a combina\u00e7\u00e3o de outras t\u00e9cnicas com\n\nalgoritmos de consist\u00eancia que n\u00e3o consumam muito tempo. T\u00e9cnicas mais generalistas costumam\n\nser aplicadas a tipos mais simples e em n\u00edveis menores, ao passo que outras mais especializadas\n\ns\u00e3o mais e?cazes na tarefa de redu\u00e7\u00e3o de dom\u00ednios restritas a alguns tipos de restri\u00e7\u00f5es. No que\n\nse segue, as t\u00e9cnicas mais comuns de consist\u00eancia s\u00e3o apresentadas das mais generalistas e simples\n\npara as mais especializadas e elaboradas. Para maiores refer\u00eancias sobre a s\u00edntese feita da literatura\n\na respeito de propaga\u00e7\u00e3o, veja Bart\u00e1k (2001, 1999); Dechter (2003).\n\n\n\n20 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.2\n\n2.2.1 T\u00e9cnicas de Consist\u00eancia Bin\u00e1ria\n\nO tipo mais simples e comum de t\u00e9cnica de consist\u00eancia estudado envolve pares de vari\u00e1veis,\n\nsendo conhecido como consist\u00eancia bin\u00e1ria. Ela \u00e9 aplicada a restri\u00e7\u00f5es com uma ou duas vari\u00e1veis,\n\nrespectivamente denominadas de restri\u00e7\u00f5es un\u00e1rias e bin\u00e1rias. Nesse tipo de consist\u00eancia, o modelo\n\npode ser analisado por meio de um grafo G = (V,E), sendo cada vari\u00e1vel de decis\u00e3o xi representada\n\npor um v\u00e9rtice vi ? V , cada restri\u00e7\u00e3o bin\u00e1ria rj(xi1,xi2 ) por uma aresta vi1vi2 ? E incidente aos\nv\u00e9rtices vi1,vi2 ? V e cada restri\u00e7\u00e3o un\u00e1ria rj(xi) por um la\u00e7o vivi ? E duplamente incidente\nao v\u00e9rtice vi ? V . Um v\u00e9rtice \u00e9 dito consistente se nenhum valor do dom\u00ednio de sua vari\u00e1vel\ncorrespondente est\u00e1 em desacordo com qualquer restri\u00e7\u00e3o un\u00e1ria. Por analogia, uma aresta \u00e9 dita\n\nconsistente se para cada valor do dom\u00ednio de uma de suas vari\u00e1veis associadas existir um valor\n\ncorrespondente no dom\u00ednio da outra, de forma que a restri\u00e7\u00e3o possa ser satisfeita se tal valor for\n\natribu\u00eddo \u00e0 vari\u00e1vel. Se todas as arestas estiverem consistentes, ent\u00e3o o modelo \u00e9 dito consistente\n\nnesse n\u00edvel. Cabe ressaltar que, historicamente, o nome dado a esse n\u00edvel de consist\u00eancia \u00e9 o de\n\nconsist\u00eancia de arco e ao anterior o de consist\u00eancia de n\u00f3, sendo muito comum encontrar na literatura\n\numa nomenclatura sobre consist\u00eancia bin\u00e1ria trocando v\u00e9rtices por n\u00f3s e arestas por arcos12. Por\n\n?m, conforme veremos a seguir, n\u00edveis mais elevados ou incompletos e intermedi\u00e1rios podem ser\n\nestabelecidos para a consist\u00eancia bin\u00e1ria.\n\nAntes de proceder ao detalhamento dos n\u00edveis e algoritmos de consist\u00eancia bin\u00e1ria, vejamos no\n\nmodelo apresentado a seguir como os conceitos descritos se aplicam a um caso simples.\n\n1 using CP;\n\n2 dvar int x in 1 . . 1 0 ;\n\n3 dvar int y in 1 . . 1 0 ;\n\n4 subject to {\n\n5 x > 5;\n\n6 x &lt;y ;\n\n7 };\n\nNo modelo ilustrado, temos duas vari\u00e1veis x e y no dom\u00ednio dos inteiros entre 1 e 10, conforme\n\ndescrito nas linhas 2 e 3. Na linha 5, a primeira restri\u00e7\u00e3o for\u00e7a o valor de x a ser maior que 5. Dessa\n\nforma, a propaga\u00e7\u00e3o j\u00e1 poderia inferir que o dom\u00ednio de x est\u00e1 reduzido, na pr\u00e1tica, ao intervalo\n\nentre 6 e 10. Na linha 6, a rela\u00e7\u00e3o entre x e y permite reduzir ainda mais o dom\u00ednio de x, visto que\n\nele n\u00e3o pode assumir o valor 10, ao passo que o dom\u00ednio de y nas solu\u00e7\u00f5es se con?na ao intervalo\n\nentre 7 e 10. Assim sendo, os dom\u00ednios das vari\u00e1veis x e y podem ser reduzidos de 10 poss\u00edveis\n\nvalores para 4 cada.\n\nA consist\u00eancia ao n\u00edvel dos v\u00e9rtices \u00e9 atingida com a primeira infer\u00eancia sugerida sobre a restri\u00e7\u00e3o\n\nda linha 5. No caso geral, ela pode ser atingida com uma \u00fanica inspe\u00e7\u00e3o a cada restri\u00e7\u00e3o un\u00e1ria\n\ndo modelo. Por sua vez, a consist\u00eancia ao n\u00edvel das arestas \u00e9 atingida gradativamente por uma\n\nsucess\u00e3o de aplica\u00e7\u00f5es que garantem a consist\u00eancia individual de arestas. Conforme observado no\n\nexemplo, uma aresta pode ser inspecionada mais de uma vez para que o n\u00edvel de consist\u00eancia global\n\nseja atingido em raz\u00e3o dos efeitos colaterais das inspe\u00e7\u00f5es de arestas anteriores. Conv\u00e9m enfatizar\n\nque esse processo \u00e9 sempre ?nito, uma vez que novas inspe\u00e7\u00f5es a uma mesma aresta s\u00f3 ocorrem em\n\n12 Apesar de ser uma pr\u00e1tica aceita, essa nomenclatura n\u00e3o \u00e9 refor\u00e7ada nesse trabalho por n\u00e3o ser aquela empregada\nem teoria dos grafos, sob o risco de prejudicar a explica\u00e7\u00e3o dos conceitos ao p\u00fablico de interesse, que n\u00e3o corresponde\n\u00e0quele que j\u00e1 usa a t\u00e9cnica.\n\n\n\n2.2 PROPAGA\u00c7\u00c3O DE RESTRI\u00c7\u00d5ES 21\n\nfun\u00e7\u00e3o de redu\u00e7\u00f5es pr\u00e9vias, sendo o n\u00famero total de redu\u00e7\u00f5es limitado \u00e0 soma dos tamanhos dos\n\ndom\u00ednios das vari\u00e1veis do modelo.\n\nN\u00edveis de Consist\u00eancia Bin\u00e1ria\n\nConforme mencionado anteriormente, \u00e9 poss\u00edvel arbitrar diversas s\u00e9ries de n\u00edveis de consist\u00eancia.\n\nNa consist\u00eancia bin\u00e1ria, o caso padr\u00e3o \u00e9 dado sequencialmente pelo n\u00famero de vari\u00e1veis para as\n\nquais \u00e9 poss\u00edvel realizar uma atribui\u00e7\u00e3o sem que um con?ito ocorra. Abaixo segue uma listagem\n\ndesde os casos mais simples, passando pelas generaliza\u00e7\u00f5es at\u00e9 atingir a consist\u00eancia completa do\n\nmodelo:\n\n? Consist\u00eancia em n\u00edvel de v\u00e9rtice ou 1-consist\u00eancia13 Diz-se que o v\u00e9rtice vi do grafo\n\ndo modelo associado \u00e0 vari\u00e1vel de decis\u00e3o xi \u00e9 consistente se qualquer valor xi do dom\u00ednio Di\npuder ser atribu\u00eddo a xi sem que ocorra um con?ito com as restri\u00e7\u00f5es un\u00e1rias do modelo, i.e.,\n\nrestri\u00e7\u00f5es envolvendo apenas xi. Sendo todos os v\u00e9rtices do grafo do modelo consistentes, o\n\nmodelo \u00e9 dito consistente em n\u00edvel de v\u00e9rtice.\n\n? Consist\u00eancia em n\u00edvel de aresta ou 2-consist\u00eancia14 Uma aresta vi1vi2 do grafo do\n\nmodelo, associada a uma restri\u00e7\u00e3o rj envolvendo as vari\u00e1veis de decis\u00e3o xi1 e xi2 do modelo, \u00e9\n\ndita consistente se, para qualquer valor xi1 ? Di1, existir um valor xi2 ? Di2 tal que rj(xi1,xi2 )\nseja satisfeita e vice-e-versa, i.e., invertendo as posi\u00e7\u00f5es de xi1 e xi2 na condi\u00e7\u00e3o. Quando todas\n\nas arestas s\u00e3o consistentes, o modelo \u00e9 dito consistente em n\u00edvel de aresta.\n\n? Consist\u00eancia em n\u00edvel de caminho ou 3-consist\u00eancia15 Um caminho vi1vi2 . . .vik \u00e9\n\nconsistente se, para qualquer atribui\u00e7\u00e3o xi1 ? xi1 : xi1 ? Di1 e xik ? xik : xik ? Dik,\nexistirem valores xi2 ? Di2, . . ., xik?1 ? Dik?1 de forma que as arestas associadas \u00e0s restri\u00e7\u00f5es\nde cada par consecutivo de v\u00e9rtices do caminho esteja satisfeita. Conforme Bart\u00e1k (1999) e\n\nDechter (2003) ressaltam, se a consist\u00eancia dos caminhos de tamanho 2 (duas arestas e k = 3)\n\nfor satisfeita para o grafo do modelo, ent\u00e3o todos os caminhos s\u00e3o consistentes e o modelo \u00e9\n\nconsistente em n\u00edvel de caminho.\n\n? Consist\u00eancia em k-\u00e9simo n\u00edvel ou k-consist\u00eancia16 Dado um conjunto de valores para\n\natribui\u00e7\u00e3o a quaisquer k ? 1 vari\u00e1veis de um modelo dentro de seus respectivos dom\u00ednios ?\nxi1 ? xi1 : xi1 ? Di1, xi2 ? xi2 : xi2 ? Di2, . . ., xik?1 ? xik?1 : xik?1 ? Dik?1 ? o modelo \u00e9\ndito k-consistente se sempre houver um valor para atribui\u00e7\u00e3o no dom\u00ednio de qualquer outra\n\nk-\u00e9sima vari\u00e1vel ? xik ? xik : xik ? Dik ? tal que nenhuma restri\u00e7\u00e3o do modelo seja violada\npor tais atribui\u00e7\u00f5es. A k-consist\u00eancia representa uma generaliza\u00e7\u00e3o dos n\u00edveis apresentados\n\nacima.\n\n? Consist\u00eancia forte em k-\u00e9simo n\u00edvel ou k-consist\u00eancia forte17 Um modelo \u00e9 fortemente\n\nk-consistente se ele for k?-consistente para qualquer k? ? k. Conforme enfatizado por Dechter\n(2003), o fato de um modelo ser k?-consistente n\u00e3o implica que ele seja (k? ? 1)-consistente.\n\n13Denominada node consistency ou 1-consistency em ingl\u00eas.\n14Denominada arc consistency ou 2-consistency em ingl\u00eas.\n15Denominada path consistency ou 3-consistency em ingl\u00eas.\n16Denominada k-consistency em ingl\u00eas.\n17 Denominada strong k-consistency em ingl\u00eas.\n\n\n\n22 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.2\n\n? Consist\u00eancia completa do modelo ou n-consist\u00eancia18 Um modelo \u00e9 completamente\n\nconsistente se qualquer atribui\u00e7\u00e3o de valores dos dom\u00ednios \u00e0s vari\u00e1veis de decis\u00e3o ? xi1 ? xi1 :\nxi1 ? Di1, xi2 ? xi2 : xi2 ? Di2, . . ., xin ? xin : xin ? Din ? satis?zer \u00e0s restri\u00e7\u00f5es do modelo,\nde forma que ? conforme observado anteriormente ? passa a ser poss\u00edvel obter uma solu\u00e7\u00e3o\n\nao problema em tempo O(n). De acordo com Focacci et al. (2000), esse n\u00edvel corresponde\n\nnaturalmente \u00e0 n-\u00e9sima consist\u00eancia, mas pode ser atingido se a k + 1-\u00e9sima consist\u00eancia for\n\nveri?cada em um grafo de modelo cujo v\u00e9rtice de maior grau19 tenha valor k. Sem embargo,\n\nconv\u00e9m ressaltar que uma consist\u00eancia completa n\u00e3o depende apenas da redu\u00e7\u00e3o do dom\u00ednio\n\ndas vari\u00e1veis de decis\u00e3o, mas tamb\u00e9m da redu\u00e7\u00e3o dos dom\u00ednios das restri\u00e7\u00f5es. Tais dom\u00ednios\n\ns\u00e3o representados como subconjuntos das tuplas das vari\u00e1veis de decis\u00e3o associadas a cada\n\nrestri\u00e7\u00e3o. Em \u00faltima an\u00e1lise, a redu\u00e7\u00e3o dos mesmos signi?ca mudar a pr\u00f3pria sem\u00e2ntica\n\nda restri\u00e7\u00e3o nos modelos com consist\u00eancia mais elevada. Isso se opera para n ? 3 no caso\nbin\u00e1rio, pois j\u00e1 na inspe\u00e7\u00e3o de caminhos entre pares de v\u00e9rtices \u00e9 poss\u00edvel, por exemplo, que\n\nas respectivas vari\u00e1veis n\u00e3o tivessem nenhuma restri\u00e7\u00e3o m\u00fatua e suas combina\u00e7\u00f5es de valores\n\nconcorrentes tivessem que ser limitadas para garantir a consist\u00eancia em n\u00edvel de caminho.\n\nOutras s\u00e9ries foram estudadas ? ainda que em menor grau ? a partir da extens\u00e3o da s\u00e9rie\n\nacima, representando cada caso uma alternativa de generaliza\u00e7\u00e3o, diversidade ou compromisso com\n\nrela\u00e7\u00e3o ao paradigma estabelecido. Pela inclus\u00e3o de par\u00e2metros adicionais \u00e0 de?ni\u00e7\u00e3o dos n\u00edveis\n\nde consist\u00eancia, pode-se generalizar os n\u00edveis pr\u00e9-estabelecidos. Alternativamente, a pondera\u00e7\u00e3o de\n\npar\u00e2metros diversos possibilita uma perspectiva mais ampla sobre os certi?cados de consist\u00eancia\n\nposs\u00edveis. Por ?m, o estabelecimento de n\u00edveis intermedi\u00e1rios sobre a parametriza\u00e7\u00e3o de maior\n\naceita\u00e7\u00e3o representa um maior n\u00edvel de detalhamento acerca dos efeitos da propaga\u00e7\u00e3o. Dentre\n\nessas possibilidades, esta despertou maior aten\u00e7\u00e3o na literatura em raz\u00e3o de sua proximidade e\n\npotencial de catalisa\u00e7\u00e3o de resultados com rela\u00e7\u00e3o \u00e0 abordagem tradicional.\n\nO estabelecimento de n\u00edveis intermedi\u00e1rios parte de uma l\u00f3gica muito similar \u00e0quela aplicada\n\nna de?ni\u00e7\u00e3o dos n\u00edveis originais. Uma vez que a veri?ca\u00e7\u00e3o das restri\u00e7\u00f5es para garantir um n\u00edvel\n\nde consist\u00eancia pode ter efeitos colaterais no que diz respeito \u00e0 necessidade de uma nova itera\u00e7\u00e3o\n\npara ?ltragem, passou-se a apurar o impacto dessas novas itera\u00e7\u00f5es para a redu\u00e7\u00e3o dos dom\u00ednios\n\ne o esfor\u00e7o computacional que exigiam. A observa\u00e7\u00e3o emp\u00edrica de muitos autores a esse respeito \u00e9\n\nde que a quantidade de valores inconsistentes que s\u00e3o removidos dos dom\u00ednios \u00e9 muito maior nas\n\nprimeiras veri?ca\u00e7\u00f5es de propaga\u00e7\u00e3o das restri\u00e7\u00f5es do modelo do que nas itera\u00e7\u00f5es subsequentes.\n\nDessa forma, o esfor\u00e7o na remo\u00e7\u00e3o de valores nas primeiras veri?ca\u00e7\u00f5es tem maior compensa\u00e7\u00e3o do\n\nque aquele observado nas remo\u00e7\u00f5es seguintes. Em outros casos, foi observado que a forma com que o\n\nmodelo em estado consistente \u00e9 utilizado na busca pode fazer com que certo esfor\u00e7o adicional tenha\n\nsido em v\u00e3o. Por conseguinte, a revis\u00e3o exaustiva para a manuten\u00e7\u00e3o do n\u00edvel de consist\u00eancia em\n\num determinado n\u00edvel passa a ser t\u00e3o question\u00e1vel quanto a manuten\u00e7\u00e3o de n\u00edveis de consist\u00eancia\n\nmais elevados.\n\nA seguir est\u00e3o listadas algumas das de?ni\u00e7\u00f5es alternativas de n\u00edveis de propaga\u00e7\u00e3o:\n\n? Consist\u00eancia direcional em n\u00edvel de aresta20 A consist\u00eancia direcional em n\u00edvel de aresta\n\n\u00e9 de?nida exclusivamente sobre uma orienta\u00e7\u00e3o do grafo do modelo, i.e., cada aresta tem sua\n\n18Denominada full consistency ou n-consistency em ingl\u00eas.\n19 O grau de um v\u00e9rtice \u00e9 dado pelo n\u00famero de arestas incidentes ao mesmo no grafo.\n20 Denominada directed arc consistency em ingl\u00eas.\n\n\n\n2.2 PROPAGA\u00c7\u00c3O DE RESTRI\u00c7\u00d5ES 23\n\nconsist\u00eancia veri?cada em apenas um sentido. Esse sentido \u00e9 de?nido de acordo com uma\n\nordena\u00e7\u00e3o pr\u00e9via dos v\u00e9rtices do grafo do modelo: uma aresta vi1vi2 \u00e9 veri?cada de vi1 para\n\nvi2 se a vari\u00e1vel xi1 preceder xi2 na ordena\u00e7\u00e3o de?nida. Se as arestas forem percorridas de\n\nacordo com a ordena\u00e7\u00e3o topol\u00f3gica dos v\u00e9rtices correspondente \u00e0 ordena\u00e7\u00e3o das vari\u00e1veis\n\nde decis\u00e3o, i.e., vi1vi2 sendo veri?cada antes de vi3vi4 se xi2 preceder xi4 na ordem, ent\u00e3o\n\nnenhuma aresta precisa ser inspecionada pela segunda vez. Esse n\u00edvel de consist\u00eancia \u00e9 mais\n\nfraco que a consist\u00eancia ao n\u00edvel da aresta, mas pode ser equivalente em alguns modelos, como\n\naqueles representados por \u00e1rvores. Al\u00e9m disso, de acordo com Dechter (2003), o benef\u00edcio da\n\npropaga\u00e7\u00e3o nesse n\u00edvel \u00e9 sempre equivalente ao da consist\u00eancia ao n\u00edvel da aresta em uma\n\nbusca que atribua valores \u00e0s vari\u00e1veis de acordo com a mesma ordena\u00e7\u00e3o das vari\u00e1veis de\n\ndecis\u00e3o usada para a manuten\u00e7\u00e3o de consist\u00eancia.\n\n? Consist\u00eancia restrita em n\u00edvel de caminho21 A consist\u00eancia restrita em n\u00edvel de caminho\n\nencerra a consist\u00eancia em n\u00edvel de aresta acrescida de um caso espec\u00ed?co da consist\u00eancia em\n\nn\u00edvel de caminho. Esse caso \u00e9 representado pela veri?ca\u00e7\u00e3o da consist\u00eancia de caminho a partir\n\nde duas atribui\u00e7\u00f5es xi1 ? xi1 : xi1 ? Di1 e xik ? xik : xik ? Dik que devam obrigatoriamente\nocorrer em conjunto, i.e., (xi1 ? xi1 ) ? (xik ? xik ). O acr\u00e9scimo da veri?ca\u00e7\u00e3o desse caso \u00e0\nconsist\u00eancia de aresta se justi?ca pelo seu potencial na redu\u00e7\u00e3o dos dom\u00ednios envolvidos sem\n\nque todos os casos poss\u00edveis tenham que ser tratados.\n\n? Consist\u00eancia por limites22 A consist\u00eancia por limites representa uma simpli?ca\u00e7\u00e3o de\n\noutros n\u00edveis de consist\u00eancia pela veri?ca\u00e7\u00e3o restrita aos valores m\u00ednimo e m\u00e1ximo de cada\n\ndom\u00ednio. O conceito de m\u00ednino e m\u00e1ximo n\u00e3o conv\u00e9m a dom\u00ednios simb\u00f3licos ? i.e., em que\n\nn\u00e3o existe uma ordem de?nida entre os elementos do conjunto ?, mas facilita a an\u00e1lise em\n\ndom\u00ednios num\u00e9ricos, como uma faixa sequencial de n\u00fameros inteiros. Em alguns casos, a\n\nveri?ca\u00e7\u00e3o dos extremos do dom\u00ednio basta para atingir um determinado n\u00edvel de consist\u00eancia.\n\nQuando isso n\u00e3o \u00e9 poss\u00edvel, sua aplica\u00e7\u00e3o pode decorrer da constata\u00e7\u00e3o de que a diferen\u00e7a de\n\nredu\u00e7\u00e3o resultante \u00e9 pontual e \u00e9 compensada pelo menor tempo de processamento resultante\n\nda escolha.\n\n? Consist\u00eancia por conjunto unit\u00e1rio23 A consist\u00eancia por conjunto unit\u00e1rio representa\n\numa restri\u00e7\u00e3o adicional que pode ser aplicada a outros n\u00edveis de consist\u00eancia. Ela de?ne que\n\num determinado n\u00edvel de consist\u00eancia seja atingido para qualquer atribui\u00e7\u00e3o xi ? xi : xi ? Di\nposs\u00edvel do modelo, i.e., o modelo possui tal n\u00edvel de consist\u00eancia para qualquer atribui\u00e7\u00e3o\n\nadicional que seja feita.\n\n? Consist\u00eancia (i,j)24 A consist\u00eancia (i,j) representa uma generaliza\u00e7\u00e3o da k-consist\u00eancia:\n\nenquanto nesta garante-se que a atribui\u00e7\u00e3o de valores a k?1 vari\u00e1veis de decis\u00e3o n\u00e3o impe\u00e7a\na atribui\u00e7\u00e3o de valor a uma outra vari\u00e1vel de decis\u00e3o, naquela a garantia \u00e9 de que a atribui\u00e7\u00e3o\n\nde valores a i vari\u00e1veis de decis\u00e3o n\u00e3o impe\u00e7a a atribui\u00e7\u00e3o de valores a outras j vari\u00e1veis de\n\ndecis\u00e3o. Dessa forma, a k-consist\u00eancia \u00e9 equivalente \u00e0 consist\u00eancia (k ? 1, 1).\n21 Denominada path-restricted consistency em ingl\u00eas.\n22 Denominada bounds consistency em ingl\u00eas.\n23 Denominada singleton consistency em ingl\u00eas.\n24Denominada (i, j)-consistency em ingl\u00eas.\n\n\n\n24 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.2\n\n? Consist\u00eancia inversa25 A consist\u00eancia inversa representa uma especializa\u00e7\u00e3o da consist\u00eancia\n\n(i,j) no sentido oposto ao da k-consist\u00eancia: um modelo \u00e9 inversamente k-consistente se tiver\n\nconsist\u00eancia (1,k?1), i.e., a cada atribui\u00e7\u00e3o xi1 ? xi1 : xi1 ? Di1 deve corresponder ao menos\numa atribui\u00e7\u00e3o xi2 ? xi2 : xi2 ? Di2, . . ., xin ? xin : xin ? Din que n\u00e3o viole as restri\u00e7\u00f5es\ndo modelo, para quaisquer k vari\u00e1veis de decis\u00e3o.\n\nAlgoritmos de Filtragem para Consist\u00eancia Bin\u00e1ria\n\nA garantia de um n\u00edvel de consist\u00eancia pode ser feita por diversos algoritmos, sendo poss\u00edvel\n\nconceber muitos deles diretamente da de?ni\u00e7\u00e3o. A presente se\u00e7\u00e3o ilustra os algoritmos dos n\u00edveis\n\ngerais para os quais maior aten\u00e7\u00e3o foi dada. De forma a n\u00e3o tomar tanto espa\u00e7o em um texto\n\nintrodut\u00f3rio, apenas a l\u00f3gica por tr\u00e1s de tais algoritmos \u00e9 descrita. Longe de se prestar como\n\numa apresenta\u00e7\u00e3o exaustiva, a sucess\u00e3o de tais algoritmos de ?ltragem ilustra como os m\u00e9todos de\n\nmanuten\u00e7\u00e3o de consist\u00eancia podem ser aperfei\u00e7oados a partir de sua concep\u00e7\u00e3o original.\n\nPara garantir a consist\u00eancia em n\u00edvel de v\u00e9rtice, um algoritmo que realize o m\u00ednimo esfor\u00e7o\n\nnecess\u00e1rio pode ser trivialmente concebido: uma inspe\u00e7\u00e3o sobre cada restri\u00e7\u00e3o un\u00e1ria basta para\n\natingir o n\u00edvel. Assim sendo, o desenvolvimento descrito a seguir cobre os algoritmos de ?ltragem\n\npara a consist\u00eancia em n\u00edvel de aresta e de caminho. Os algoritmos para n\u00edveis intermedi\u00e1rios de\n\nconsist\u00eancia representam modi?ca\u00e7\u00f5es sobre aqueles para consist\u00eancia precisa. Em \u00faltima an\u00e1lise, o\n\nproblema de garantir a consist\u00eancia completa de um modelo que descreve um problema combinat\u00f3rio\n\nNP-Completo ? como o PSR no caso geral ? tamb\u00e9m ser\u00e1 NP-Completo.\n\nAlgoritmos para consist\u00eancia em n\u00edvel de aresta Existe um padr\u00e3o na literatura baseado na\n\nnomenclatura dos algoritmos para consist\u00eancia ao n\u00edvel da aresta pelo pre?xo AC26 seguido de um\n\n\u00edndice sequencial. Nessa linha, o algoritmo AC-1 representa o m\u00e9todo mais intuitivo, consistindo na\n\nrepeti\u00e7\u00e3o da revis\u00e3o dos dom\u00ednios das vari\u00e1veis associadas aos v\u00e9rtices at\u00e9 que nenhuma altera\u00e7\u00e3o\n\nocorra. No algoritmo AC-2, apenas as revis\u00f5es de dom\u00ednio necess\u00e1rias s\u00e3o repetidas: o dom\u00ednio da\n\nvari\u00e1vel de um v\u00e9rtice s\u00f3 \u00e9 revisado se ele for adjacente a qualquer v\u00e9rtice cuja vari\u00e1vel tenha tido\n\no dom\u00ednio reduzido desde sua \u00faltima revis\u00e3o. No AC-3, o processo de revis\u00e3o \u00e9 aperfei\u00e7oado pela\n\nopera\u00e7\u00e3o por itera\u00e7\u00e3o em uma ?la de arestas: inser\u00e7\u00f5es ocorrem quando o dom\u00ednio da vari\u00e1vel de um\n\nv\u00e9rtice incidente \u00e9 alterado e remo\u00e7\u00f5es ocorrem quando essas arestas s\u00e3o revisadas. O ganho obtido\n\npelo uso da ?la se deve \u00e0 preven\u00e7\u00e3o de que arestas sejam revisadas mais de uma vez. O algoritmo\n\nAC-4 itera sobre estruturas um pouco mais elaboradas, que evitam a revis\u00e3o de dom\u00ednios pela\n\nitera\u00e7\u00e3o sobre as arestas: para cada aresta vi1vi2 do grafo do modelo, cada valor xi1 ? Di1 da vari\u00e1vel\nxi1 associada ao v\u00e9rtice vi1 possui um conjunto de valores de suporte V Sxi1i2 ? Di2, correspondendo\n\u00e0queles que n\u00e3o s\u00e3o incompat\u00edveis com a atribui\u00e7\u00e3o xi1 ? xi1. Essa id\u00e9ia foi simpli?cada no AC-6,\nque armazena apenas um valor de suporte vsxi1i2 ? V Sxi1i2 para cada valor do dom\u00ednio de Di1 e\nprocura um novo valor de suporte se o anterior passar a ser inv\u00e1lido, evitando a utiliza\u00e7\u00e3o proibitiva\n\nde mem\u00f3ria e tempo de seu antecessor. O AC-7 representa uma redu\u00e7\u00e3o de esfor\u00e7o pela simples\n\nconstata\u00e7\u00e3o de que o suporte de valores \u00e9 sim\u00e9trico: se o valor xi1 ? Di1 suporta xi2 ? Di2, xi2 ? Di2\nsuporta xi1 ? Di1, i.e., (vsxi1i2 ? xi2 ) ? (vsxi2i1 ? xi1 ). Com rela\u00e7\u00e3o \u00e0 an\u00e1lise de complexidade\nassint\u00f3tica do tempo de execu\u00e7\u00e3o no pior caso, sendo m o n\u00famero de restri\u00e7\u00f5es, n o n\u00famero de\n\n25Denominada inverse consistency em ingl\u00eas.\n26Acr\u00f4nimo em ingl\u00eas para Arc Consistency.\n\n\n\n2.2 PROPAGA\u00c7\u00c3O DE RESTRI\u00c7\u00d5ES 25\n\nv\u00e9rtices e k o tamanho do maior dom\u00ednio considerado, AC-1 e AC-2 s\u00e3o O(mnk3), AC-3 \u00e9 O(mk3)\n\ne o limite inferior provado ao caso geral de O(mk2) \u00e9 constatado para o AC-4 em diante.\n\nCom rela\u00e7\u00e3o ao algoritmo AC-5 descrito em Hentenryck et al. (1992), conv\u00e9m uma an\u00e1lise\n\nmais apurada devido \u00e0 forma com que esse algoritmo representa o conceito da especializa\u00e7\u00e3o dos\n\nmecanismos de resolu\u00e7\u00e3o em fun\u00e7\u00e3o das restri\u00e7\u00f5es. O AC-5 n\u00e3o \u00e9 completamente de?nido, sendo\n\nposs\u00edvel parametriz\u00e1-lo por meio de implementa\u00e7\u00f5es diferenciadas para dois m\u00e9todos: um para\n\na veri?ca\u00e7\u00e3o inicial de quais valores do dom\u00ednio Di1 n\u00e3o s\u00e3o suportados por nenhum valor do\n\ndom\u00ednio Di2; outro para a veri?ca\u00e7\u00e3o iterativa em ?la de quais valores do dom\u00ednio Di1 n\u00e3o s\u00e3o\n\nmais suportados se o valor xi2 for removido do dom\u00ednio Di2. Uma implementa\u00e7\u00e3o poss\u00edvel desses\n\nm\u00e9todos coincide com o AC-3, ao passo que outra coincide com o AC-4. No entanto, a vantagem desse\n\nalgoritmo se deve ao fato que ele possibilita que a consist\u00eancia de classes espec\u00ed?cas de restri\u00e7\u00f5es\n\nsejam garantidas a uma complexidade de tempo inferior \u00e0quela do caso geral: restri\u00e7\u00f5es bin\u00e1rias\n\nfuncionais ? como xi1 + xi2 = k, sendo k uma constante ?, anti-funcionais ? como xi1 + xi2 6= k ?\ne monot\u00f4nicas ? como xi1 + xi2 &lt;k ? em todo o dom\u00ednio ou por partes podem ser propagadas em\n\ntempo O(mk).\n\nAlgoritmos para consist\u00eancia em n\u00edvel de caminho Os algoritmos para consist\u00eancia de\n\ncaminho foram desenvolvidos em paralelo aos de consist\u00eancia de aresta, sendo costumeiramente\n\npre?xados como PC27. Dessa forma, podemos resumi-los revisando as id\u00e9ias apresentadas anterior-\n\nmente. O algoritmo PC-1 consiste na revis\u00e3o de todos os caminhos at\u00e9 que n\u00e3o ocorra nenhuma\n\nredu\u00e7\u00e3o de dom\u00ednio. No PC-2, a veri?ca\u00e7\u00e3o \u00e9 repetida apenas para os caminhos que possam ter\n\nsido afetados por alguma revis\u00e3o pr\u00e9via. O algoritmo PC-3 representou a primeira proposta de\n\nextens\u00e3o das id\u00e9ias do algoritmo AC-4 para a consist\u00eancia em n\u00edvel de caminho. Entretanto, ele foi\n\nsubstitu\u00eddo pelo PC-4 por remover valores que poderiam pertencer a uma atribui\u00e7\u00e3o v\u00e1lida, caso\n\nevitado pelas corre\u00e7\u00f5es que diferem este algoritmo daquele. Por ?m, o algoritmo PC-5 represen-\n\ntou para o PC-4 a mesma simpli?ca\u00e7\u00e3o de implementa\u00e7\u00e3o que o AC-6 representou para o AC-4,\n\nreduzindo a quantidade de mem\u00f3ria utilizada em estruturas de dados auxiliares.\n\nAlgoritmos para n\u00edveis intermedi\u00e1rios de consist\u00eancia Por ser efetuada em uma \u00fanica pas-\n\nsagem, n\u00e3o existem nuances de aperfei\u00e7oamento para a execu\u00e7\u00e3o do n\u00edvel de consist\u00eancia direcional\n\nem n\u00edvel de aresta, \u00e0 semelhan\u00e7a do que observou-se para a consist\u00eancia em n\u00edvel de v\u00e9rtice. Por sua\n\nvez, a consist\u00eancia restrita ao n\u00edvel do caminho foi concebida como uma especializa\u00e7\u00e3o do algoritmo\n\nAC-4, havendo veri?ca\u00e7\u00e3o de consist\u00eancia de caminhos entre as atribui\u00e7\u00f5es xi1 ? xi1 e xi2 ? xi2\napenas quando |V Sxi1i2| = 1, i.e., o conjunto de suporte de uma atribui\u00e7\u00e3o se restringir a uma\n\u00fanica atribui\u00e7\u00e3o \u00e0 outra vari\u00e1vel.\n\nConsidera\u00e7\u00f5es sobre os demais n\u00edveis de consist\u00eancia De acordo com Bart\u00e1k (1999), apesar\n\nde existirem algoritmos para k-consist\u00eancia forte com k > 2, seu custo computacional raramente\n\ncompensa pelo fato de que ainda n\u00e3o s\u00e3o capazes de isentar a busca de falhas potenciais. Com\n\nrela\u00e7\u00e3o aos n\u00edveis alternativos de consist\u00eancia, Bart\u00e1k (2001) observa que a manuten\u00e7\u00e3o de i-uplas\n\npara a manuten\u00e7\u00e3o da consist\u00eancia (i,j) torna-se proibitiva para i ? 2. No caso da consist\u00eancia\ninversa, s\u00f3 h\u00e1 interesse para k = 3, uma vez que ela coincide com a consist\u00eancia convencional em\n\n27Acr\u00f4nimo em ingl\u00eas para Path Consistency.\n\n\n\n26 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.2\n\nn\u00edveis menores e torna-se proibitiva para n\u00edveis maiores. Por ?m, a implementa\u00e7\u00e3o de algoritmos\n\nde ?ltragem para consist\u00eancia por conjunto unit\u00e1rio geralmente consiste no acr\u00e9scimo de um la\u00e7o\n\nsuperior que ?xa cada atribui\u00e7\u00e3o poss\u00edvel.\n\nBinariza\u00e7\u00e3o de Restri\u00e7\u00f5es\n\nA hip\u00f3tese de representar um PSR por meio de predicados com aridade m\u00e1xima 2 ? i.e., via\n\nrestri\u00e7\u00f5es envolvendo at\u00e9 duas vari\u00e1veis de decis\u00e3o cada ? para que a propaga\u00e7\u00e3o bin\u00e1ria possa ser\n\nempregada \u00e9 bastante restritiva. Ainda que poss\u00edvel, ela pode levar a modelos demasiado extensos,\n\nde forma que muitas simpli?ca\u00e7\u00f5es n\u00e3o s\u00e3o poss\u00edveis sen\u00e3o por representa\u00e7\u00e3o imprecisas. Dessa\n\nlimita\u00e7\u00e3o surge o impasse entre empregar uma representa\u00e7\u00e3o simpli?cada, que possa se bene?ciar\n\nda propaga\u00e7\u00e3o bin\u00e1ria; ou recorrer a uma gama mais ampla de representa\u00e7\u00f5es, com potencial a uma\n\npropaga\u00e7\u00e3o mais e?caz no espa\u00e7o de busca ao risco de um custo computacional de execu\u00e7\u00e3o mais\n\nelevado. Entretanto, a op\u00e7\u00e3o a ser feita n\u00e3o \u00e9 exclusiva, pois o uso ativo de restri\u00e7\u00f5es redundantes\n\nna modelagem ? mencionado na se\u00e7\u00e3o 2.1.2 ? condiz com o emprego de ambas as possibilidades:\n\nrestri\u00e7\u00f5es precisas que s\u00e3o complementadas por aproxima\u00e7\u00f5es que possibilitem a propaga\u00e7\u00e3o em\n\num n\u00edvel mais elementar. Nessa se\u00e7\u00e3o, \u00e9 explorada a possibilidade de simpli?car automaticamente a\n\nrepresenta\u00e7\u00e3o por meio de decomposi\u00e7\u00f5es bin\u00e1rias. Adiante, ser\u00e1 discutida a hip\u00f3tese de trabalhar\n\ncom representa\u00e7\u00f5es mais elaboradas.\n\nA decomposi\u00e7\u00e3o em um modelo bin\u00e1rio pode se dar por diversas formas. Ainda que algumas\n\ndelas levem a modelos imprecisos, \u00e9 importante observar que, \u00e0 semelhan\u00e7a do caso das restri\u00e7\u00f5es re-\n\ndundantes, o objetivo de tais modelos n\u00e3o \u00e9 substituir o modelo original na veri?ca\u00e7\u00e3o da satisfa\u00e7\u00e3o\n\ndas restri\u00e7\u00f5es, mas t\u00e3o somente na opera\u00e7\u00e3o da propaga\u00e7\u00e3o. A seguir, constam tr\u00eas decomposi\u00e7\u00f5es\n\nidenti?cadas por Bart\u00e1k (2001):\n\n? Proje\u00e7\u00e3o A proje\u00e7\u00e3o consiste na aproxima\u00e7\u00e3o de uma restri\u00e7\u00e3o por um conjunto de rela\u00e7\u00f5es\n\nbin\u00e1rias. Para cada par de vari\u00e1veis envolvido na restri\u00e7\u00e3o original, delimita-se o dom\u00ednio\n\nposs\u00edvel para uma vari\u00e1vel em fun\u00e7\u00e3o da outra no contexto da restri\u00e7\u00e3o. Formalmente, para\n\ncada par de vari\u00e1veis xi1 e xi2 de uma restri\u00e7\u00e3o rj(. . . ,xi1, . . . ,xi2, . . .), de?ne-se uma restri\u00e7\u00e3o\n\nr?ji1i2 (xi1,xi2 ) satisfeita apenas por duplas (xi1,xi2 ) que possam concorrer em uma solu\u00e7\u00e3o\n\n? i.e., Sji1i2 = {(xi1,xi2 ) ? Di1 \u00d7 Di2 : ? (x1, . . . ,xi1, . . . ,xi2, . . . ,xn) ? Sj, x1 ? D1, . . . ,\nxi1?1 ? Di1?1, xi1+1 ? Di1+1, . . . , xi2?1 ? Di2?1, xi2+1 ? Di2+1, . . . , xn ? Dn}. Em alguns\ncasos, a proje\u00e7\u00e3o obtida \u00e9 t\u00e3o restritiva quanto a restri\u00e7\u00e3o original, mas em outros ela n\u00e3o\n\natinge o mesmo n\u00edvel e representa uma relaxa\u00e7\u00e3o do modelo.\n\n? Codi?ca\u00e7\u00e3o dual A codi?ca\u00e7\u00e3o dual refere-se \u00e0 dualiza\u00e7\u00e3o do modelo para representa\u00e7\u00e3o\n\npor meio de um grafo, feita pela invers\u00e3o entre vari\u00e1veis e restri\u00e7\u00f5es. Um v\u00e9rtice vj do grafo\n\nrepresenta a restri\u00e7\u00e3o rj do modelo original, tendo como dom\u00ednio Sj ? i.e., todas as tuplas\n\nde atribui\u00e7\u00f5es v\u00e1lidas para satisfazer a restri\u00e7\u00e3o. Por sua vez, cada aresta representa a in-\n\ntersec\u00e7\u00e3o de vari\u00e1veis de decis\u00e3o entre restri\u00e7\u00f5es distintas ? i.e., os v\u00e9rtices relativos a duas\n\nrestri\u00e7\u00f5es distintas s\u00e3o incidentes a uma aresta em comum se tais restri\u00e7\u00f5es compartilharem\n\numa determinada vari\u00e1vel de decis\u00e3o. Dessa forma, a opera\u00e7\u00e3o da propaga\u00e7\u00e3o nesse conjunto\n\nde arestas do grafo da dualiza\u00e7\u00e3o do modelo garante a unicidade do valor atribu\u00eddo a uma\n\nvari\u00e1vel de decis\u00e3o do modelo.\n\n\n\n2.2 PROPAGA\u00c7\u00c3O DE RESTRI\u00c7\u00d5ES 27\n\n? Codi?ca\u00e7\u00e3o por vari\u00e1veis ocultas Na codi?ca\u00e7\u00e3o por vari\u00e1veis ocultas, tanto os dom\u00ednios\n\ndas vari\u00e1veis de decis\u00e3o quanto os dom\u00ednios das restri\u00e7\u00f5es s\u00e3o considerados. Assim sendo, o\n\ngrafo resultante possui n + m v\u00e9rtices, sendo o subgrafo induzido pelos n v\u00e9rtices associados\n\n\u00e0s vari\u00e1veis de decis\u00e3o isomorfo ao grafo do modelo e o subgrafo induzido pelos m v\u00e9rtices\n\nrestantes, associados \u00e0s restri\u00e7\u00f5es, isomorfo ao grafo do modelo dual. Dessa forma, a inspe\u00e7\u00e3o\n\nde consist\u00eancia opera sobre ambos os tipos de dom\u00ednio.\n\n2.2.2 T\u00e9cnicas de Consist\u00eancia Generalizada\n\nA generaliza\u00e7\u00e3o dos conceitos de consist\u00eancia previamente explorados para o caso bin\u00e1rio pode\n\ndecorrer de uma necessidade incondicional para que uma determinada abordagem seja vi\u00e1vel ou\n\nemergir como uma oportunidade de maior benef\u00edcio em outros. Na primeira situa\u00e7\u00e3o, tratam-se\n\nde PSRs cujo modelo bin\u00e1rio obtido n\u00e3o apresenta um n\u00edvel de propaga\u00e7\u00e3o adequado para reduzir\n\no esfor\u00e7o necess\u00e1rio \u00e0 busca. Na segunda, o modelo corresponde ao que se esperaria de um caso\n\ngeral, mas oportunidades a uma propaga\u00e7\u00e3o mais e?caz s\u00e3o identi?cadas. Em ambas as situa\u00e7\u00f5es, o\n\nproblema se resume ao fato de a representa\u00e7\u00e3o bin\u00e1ria n\u00e3o ser capaz de atingir o n\u00edvel de propaga\u00e7\u00e3o\n\ndesejado.\n\nEntretanto, cabe ressaltar que a generaliza\u00e7\u00e3o do conceito de consist\u00eancia para a opera\u00e7\u00e3o sobre\n\nrestri\u00e7\u00f5es arbitr\u00e1rias por si s\u00f3 \u00e9 proibitiva. Em termos de implementa\u00e7\u00e3o, o caso geral implica na\n\nopera\u00e7\u00e3o sobre hipergrafos: hiper-arestas generalizando o conceito de arestas para um n\u00famero arbi-\n\ntr\u00e1rio de v\u00e9rtices. H\u00e1 um certo consenso na literatura de que essa via de abordagem n\u00e3o compensa o\n\nesfor\u00e7o devido \u00e0 di?culdade de implementa\u00e7\u00e3o e \u00e0 exig\u00eancia de recursos computacionais decorrentes.\n\nE \u00e9 nesse ponto que entra em cena o conceito central \u00e0 PR: empregar restri\u00e7\u00f5es adequadas para\n\npropagar de modo e?ciente sobre a estrutura do problema e se bene?ciar de suas especi?cidades,\n\nconforme tratado a seguir.\n\nRestri\u00e7\u00f5es Globais\n\nO conceito de restri\u00e7\u00e3o global28 representa tanto uma restri\u00e7\u00e3o especializada a um dom\u00ednio de\n\naplica\u00e7\u00e3o quanto o algoritmo de ?ltragem subjacente que garante a manuten\u00e7\u00e3o do n\u00edvel de con-\n\nsist\u00eancia. O termo ?global? atribu\u00eddo a uma propaga\u00e7\u00e3o especializada contrasta com as limita\u00e7\u00f5es\n\nde extens\u00e3o para que uma propaga\u00e7\u00e3o generalizada n\u00e3o tome demasiado tempo, raz\u00e3o pela qual\n\nesta envolve menos vari\u00e1veis e \u00e9 vista como ?local?. Dessa forma, a generaliza\u00e7\u00e3o de consist\u00eancia\n\nprovida pela restri\u00e7\u00e3o global vem ao custo de especializar o algoritmo de ?ltragem \u00e0quele caso. Essa\n\nabordagem especializada \u00e9 compensada pela recorr\u00eancia com que algumas dessas restri\u00e7\u00f5es acabam\n\npor ser encontradas na formula\u00e7\u00e3o de problemas. Disso resulta o esfor\u00e7o de catalogar sistematica-\n\nmente tais restri\u00e7\u00f5es por meio das propriedades estruturais que elas representam, conforme tratado\n\npor Beldiceanu et al. (2007). Portanto, a propaga\u00e7\u00e3o por meio de restri\u00e7\u00f5es globais representa um\n\nesfor\u00e7o de especializa\u00e7\u00e3o dos mecanismos de propaga\u00e7\u00e3o, tendo em vista n\u00e3o apenas o benef\u00edcio da\n\nabordagem imediata como a de outros problemas com a mesma estrutura.\n\nComo pode ser visto pela pr\u00f3pria de?ni\u00e7\u00e3o apresentada, o conceito de consist\u00eancia e o algoritmo\n\nde ?ltragem se misturam. Bessi\u00e8re e Hentenryck (2003) noticiam que um tutorial apresentado na\n\n28Denominada global constraint em ingl\u00eas.\n\n\n\n28 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.2\n\nconfer\u00eancia CP29 de 2002 levantou um debate acalorado em decorr\u00eancia de como pesquisadores\n\nde \u00e1reas distintas concebem restri\u00e7\u00f5es globais sob \u00f3ticas diferentes. Por esse motivo, esses autores\n\nsugerem uma de?ni\u00e7\u00e3o de n\u00edveis progressivos \u00e0 globalidade de uma restri\u00e7\u00e3o:\n\n? Algor\u00edtmico: a globalidade algor\u00edtmica corresponde \u00e0 obten\u00e7\u00e3o de um algoritmo de ?ltragem\n\nmais e?ciente do que aquele correspondente ao caso geral para o n\u00edvel de consist\u00eancia atingido.\n\n? Operacional: a globalidade operacional corresponde \u00e0 capacidade de que mais valores sejam\n\nremovidos do que no caso em que a mesma restri\u00e7\u00e3o seja representada por um conjunto de\n\nrestri\u00e7\u00f5es locais.\n\n? Sem\u00e2ntico: a globalidade sem\u00e2ntica corresponde \u00e0 possibilidade de representar uma restri\u00e7\u00e3o\n\nque um conjunto de restri\u00e7\u00f5es locais n\u00e3o \u00e9 capaz de representar.\n\nExemplo de restri\u00e7\u00e3o global operacional: alldi?erent\n\nA restri\u00e7\u00e3o alldi?erent representa uma estrutura comum a diversos problemas combinat\u00f3rios,\n\ncomo o da rotula\u00e7\u00e3o graciosa de grafos descrito na se\u00e7\u00e3o 2.1.1. Semanticamente,\n\nalldi?erent(x1, . . . ,xn) corresponde ao conjunto de restri\u00e7\u00f5es bin\u00e1rias xi 6= xj ? i ? [1,n],j ?\n[i + 1,n] ? i.e., de?ne que a atribui\u00e7\u00e3o de cada vari\u00e1vel de decis\u00e3o envolvida deve ter um valor\n\ndiferente das demais. O que confere o car\u00e1ter de globalidade operacional a essa restri\u00e7\u00e3o \u00e9 que, ao\n\ncontr\u00e1rio do conjunto de restri\u00e7\u00f5es bin\u00e1rias, ela possibilita que se detecte facilmente situa\u00e7\u00f5es como\n\na do modelo a seguir:\n\n1 using CP;\n\n2 dvar int x [ 1 . . 3 ] in 1 . . 2 ;\n\n3 subject to {\n\n4 a l l D i f f e r e n t (x) ;\n\n5 };\n\nNo modelo, tr\u00eas vari\u00e1veis de decis\u00e3o compartilham um dom\u00ednio contendo dois valores. Pelo princ\u00edpio\n\nda casa dos pombos30, \u00e9 evidente que qualquer atribui\u00e7\u00e3o de valores \u00e0s vari\u00e1veis incorrer\u00e1 em\n\nque ao menos duas vari\u00e1veis compartilhem a atribui\u00e7\u00e3o de algum valor, de forma que o modelo\n\n\u00e9 insatisfat\u00edvel ? i.e., n\u00e3o h\u00e1 como satisfaz\u00ea-lo e ele n\u00e3o tem solu\u00e7\u00e3o. No entanto, o modelo \u00e9\n\nconsistente em n\u00edvel de aresta e o tratamento de casos como o apresentado exigiria o emprego de\n\num n\u00edvel generalizado de consist\u00eancia.\n\nR\u00e9gin (1994) observa que garantir a consist\u00eancia generalizada da restri\u00e7\u00e3o alldi?erent com um\n\nalgoritmo de ?ltragem gen\u00e9rico demandaria a inspe\u00e7\u00e3o de todas as tuplas de atribui\u00e7\u00e3o poss\u00edveis\n\n? i.e., Ak,n =\nk!\n\n(n?k)!, para n vari\u00e1veis de decis\u00e3o e k valores distintos nos dom\u00ednios das vari\u00e1veis.\n\nDessa feita, R\u00e9gin (1994) prop\u00f5e um algoritmo de ?ltragem baseado no conceito de emparelhamento\n\nm\u00e1ximo de grafos bipartidos. Nesse algoritmo, utiliza-se um grafo bipartido no qual os v\u00e9rtices de\n\numa classe da parti\u00e7\u00e3o est\u00e3o associados \u00e0s vari\u00e1veis de decis\u00e3o da restri\u00e7\u00e3o, os v\u00e9rtices da outra\n\n29 A s\u00e9rie de confer\u00eancias anuais CP, acr\u00f4nimo reduzido para International Conference on Principles and Practice of\nConstraint Programming, ou Confer\u00eancia Internacional sobre os Princ\u00edpios e a Pr\u00e1tica da Programa\u00e7\u00e3o por Restri\u00e7\u00f5es,\nrepresenta a maior confer\u00eancia mundial de PR. A 17a edi\u00e7\u00e3o do evento ocorreu em Per\u00fagia, na It\u00e1lia, entre 12 e 16\nde setembro de 2011.\n\n30 O ?princ\u00edpio da casa dos pombos? consiste em um jarg\u00e3o empregado para a constata\u00e7\u00e3o de que n\u00e3o \u00e9 poss\u00edvel\nque n elementos sejam particionados em m conjuntos, para n > m, sem que ao menos um dos conjuntos tenha mais\ndo que um elemento.\n\n\n\n2.3 BUSCA 29\n\nclasse aos valores distintos dos dom\u00ednios dessas vari\u00e1veis e as arestas representam as atribui\u00e7\u00f5es\n\nposs\u00edveis entre a vari\u00e1vel associada a um v\u00e9rtice da primeira classe e o valor associado a um v\u00e9rtice\n\nda segunda. Portanto, a restri\u00e7\u00e3o s\u00f3 pode ser satisfeita por alguma atribui\u00e7\u00e3o de valores \u00e0s vari\u00e1veis\n\nse o emparelhamento m\u00e1ximo tiver tantas arestas quantas forem as vari\u00e1veis envolvidas, sendo que\n\numa atribui\u00e7\u00e3o s\u00f3 \u00e9 permitida se pertencer a algum emparelhamento m\u00e1ximo do grafo. O algoritmo\n\nproposto a partir das constata\u00e7\u00f5es anteriores vale-se de resultados da teoria dos grafos para atingir\n\na consist\u00eancia desejada em tempo O(n2k2). Por essa raz\u00e3o, o estudo de R\u00e9gin (1994) representa\n\num caso de particular interesse sobre como o tratamento de especi?cidades leva \u00e0 obten\u00e7\u00e3o de um\n\nmelhor desempenho na resolu\u00e7\u00e3o de problemas usando PR.\n\n2.3 Busca\n\nDevido ao car\u00e1ter declarativo da PR, a busca pode operar por meios bastante diversos. Conforme\n\nobservado anteriormente, os m\u00e9todos mais empregados para a busca em PR s\u00e3o denominados, de\n\num modo geral, como ?tentativa-e-erro?. Isso se deve ao fato de que a propaga\u00e7\u00e3o ? apesar de ser\n\num componente fundamental \u00e0 t\u00e9cnica ? n\u00e3o \u00e9 vi\u00e1vel operando isoladamente, de forma que cabe \u00e0\n\nbusca lidar com certo grau de inconsist\u00eancia do modelo. Como re?exo, o foco da busca em PR est\u00e1\n\nmuito mais ligado \u00e0 factibilidade do que \u00e0 otimalidade, i.e., costuma-se priorizar que uma solu\u00e7\u00e3o\n\nseja encontrada em tempo h\u00e1bil e n\u00e3o tanto que uma solu\u00e7\u00e3o \u00f3tima seja obtida. No entanto, seria\n\nerr\u00f4neo reduzir o ferramental de busca aos algoritmos de recurs\u00e3o e retrocesso ? i.e., que atribuem\n\nvalores a vari\u00e1veis de maneira ordenada e recuem em caso de con?ito -, ainda que boa parte das\n\nabordagens para a busca em PR envolvam esse tipo de algoritmo. Dessa forma, compete elencar as\n\nalternativas poss\u00edveis para ent\u00e3o compar\u00e1-las de acordo com os resultados descritos na literatura.\n\nA forma com que a busca \u00e9 feita em PR depende do objetivo de sua realiza\u00e7\u00e3o. A primeira\n\ndimens\u00e3o de an\u00e1lise diz respeito \u00e0 completude: \u00e9 necess\u00e1rio realizar uma busca exaustiva por todas\n\nas solu\u00e7\u00f5es poss\u00edveis ou basta encontrar uma solu\u00e7\u00e3o para encerrar a busca? A busca exaustiva,\n\ntamb\u00e9m dita completa, pode ser realizada por algoritmos de recurs\u00e3o e retrocesso ou de programa\u00e7\u00e3o\n\ndin\u00e2mica 31. Entretanto, a an\u00e1lise de algoritmos de programa\u00e7\u00e3o din\u00e2mica possui uma import\u00e2ncia\n\nmais te\u00f3rica do que pr\u00e1tica devido \u00e0 exig\u00eancia de mem\u00f3ria decorrente da aplica\u00e7\u00e3o no caso geral,\n\nconforme pode ser visto em Dechter (2003). Para a busca por factibilidade, geralmente incompleta\n\npor ?nalizar sem necessariamente exaurir o espa\u00e7o de busca, tanto os algoritmos de recurs\u00e3o e\n\nretrocesso quanto os de busca local ou estoc\u00e1stica podem ser empregados. A maior diferen\u00e7a entre\n\nesses procedimentos consiste na sistem\u00e1tica de explora\u00e7\u00e3o e garantia de ?naliza\u00e7\u00e3o daqueles, que\n\nn\u00e3o necessariamente encontram equival\u00eancia nestes devido \u00e0 forma intermitente e aleat\u00f3ria com que\n\nexploram o espa\u00e7o de busca. Em ambos os casos, artif\u00edcios podem ser empregados para orientar\n\na busca a uma conclus\u00e3o antecipada, tanto para a factibilidade quanto para obter uma solu\u00e7\u00e3o\n\nrazo\u00e1vel de acordo com a fun\u00e7\u00e3o objetivo que se quer otimizar. A ambival\u00eancia de emprego dos\n\nalgoritmos de recurs\u00e3o e retrocesso tanto na busca exaustiva quanto incompleta \u00e9 creditada por\n\nvan Beek (2006) ao fato de operarem sobre uma \u00fanica solu\u00e7\u00e3o por vez, de forma que a busca n\u00e3o\n\nprecisa ser ?nalizada para que alguma solu\u00e7\u00e3o seja obtida ? ao contr\u00e1rio do que ocorre no caso\n\nda programa\u00e7\u00e3o din\u00e2mica. \u00c9 por essa raz\u00e3o que o estudo de algoritmos de busca por recurs\u00e3o e\n\n31A programa\u00e7\u00e3o din\u00e2mica \u00e9 um m\u00e9todo de resolu\u00e7\u00e3o de problemas pela decomposi\u00e7\u00e3o em problemas menores,\nvalendo-se do princ\u00edpio da sub-estrutura \u00f3tima para que uma solu\u00e7\u00e3o \u00f3tima ao problema seja obtida a partir da\nsolu\u00e7\u00e3o \u00f3tima dos sub-problemas associados. Para uma introdu\u00e7\u00e3o ao tema, veja Cormen et al. (2002).\n\n\n\n30 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.3\n\nretrocesso para PSRs acaba por se confundir um pouco com o estudo da busca em PR. Entretanto,\n\n\u00e9 importante evitar uma associa\u00e7\u00e3o indissol\u00favel entre ambos os conceitos para que o emprego da\n\nt\u00e9cnica de PR n\u00e3o se torne demasiado restrito, conforme adverte Hooker (2007).\n\nO restante da se\u00e7\u00e3o \u00e9 dedicado \u00e0 introdu\u00e7\u00e3o dos principais elementos dos algoritmos de recurs\u00e3o\n\ne retrocesso e a uma breve apresenta\u00e7\u00e3o dos m\u00e9todos de busca local e estoc\u00e1stica.\n\n2.3.1 Busca por Recurs\u00e3o e Retrocesso\n\nA busca por recurs\u00e3o e retrocesso32 consiste no processo de atribuir progressivamente valores\n\n\u00e0s vari\u00e1veis que ainda n\u00e3o foram instanciadas. O algoritmo termina quando todas as possibilidades\n\nde atribui\u00e7\u00e3o foram tentadas ou quando alguma solu\u00e7\u00e3o \u00e9 encontrada durante o processo e isso\n\nbastar ao prop\u00f3sito da busca. O retrocesso se d\u00e1 quando uma falha \u00e9 detectada devido ao conjunto\n\nde atribui\u00e7\u00f5es acumulado ter violado alguma restri\u00e7\u00e3o do modelo, quando ent\u00e3o ao menos uma\n\ndas atribui\u00e7\u00f5es anteriores ter\u00e1 de ser desfeita e alterada. \u00c9 poss\u00edvel que o retrocesso se transforme\n\nem uma rea\u00e7\u00e3o em cadeia caso todos os valores poss\u00edveis j\u00e1 tenham sido atribu\u00eddos \u00e0 vari\u00e1vel\n\nanterior, levando a um novo retrocesso e assim por diante. Apesar de n\u00e3o ser necess\u00e1rio que seja\n\nimplementada como uma recurs\u00e3o, essa forma de busca se assemelha \u00e0 recurs\u00e3o em dois aspectos:\n\n? as atribui\u00e7\u00f5es anteriores s\u00e3o mantidas em uma estrutura de pilha para revers\u00e3o das mesmas\n\nno caso de retrocesso;\n\n? o algoritmo consiste em uma recorr\u00eancia sobre o passo da atribui\u00e7\u00e3o, de forma que a recurs\u00e3o\n\nemerge como uma forma evidente de implementa\u00e7\u00e3o.\n\nNessas linhas gerais, v\u00e1rios algoritmos foram propostos visando aperfei\u00e7oar aspectos espec\u00ed?cos da\n\nestrutura de funcionamento descrita.\n\nA despeito do algoritmo empregado, a extens\u00e3o da busca por recurs\u00e3o e retrocesso para tratar\n\nde PSORs em vez de PSRs pode ser feita de diversas formas que independem das especi?cidades\n\ndos aperfei\u00e7oamentos. Entretanto, a garantia de otimalidade em todos os casos depende de uma\n\nbusca exaustiva. A hip\u00f3tese mais simples consiste em registrar e manter atualizada a indica\u00e7\u00e3o de\n\nqual foi a solu\u00e7\u00e3o com melhor valor de acordo com a fun\u00e7\u00e3o objetivo. Outra possibilidade consiste\n\nem reiniciar a busca ap\u00f3s cada solu\u00e7\u00e3o encontrada, restringindo o espa\u00e7o de busca \u00e0s solu\u00e7\u00f5es que\n\nsejam melhores do que a obtida. Nesse caso, o espa\u00e7o de busca pode ser explorado pela busca no\n\nintervalo entre o valor da solu\u00e7\u00e3o obtida e algum limite evidente ao \u00f3timo, o que pode operar de\n\ntr\u00eas formas distintas segundo van Beek (2006):\n\n? pela restri\u00e7\u00e3o de que a solu\u00e7\u00e3o seja t\u00e3o somente melhor do que a atual;\n\n? pela restri\u00e7\u00e3o de que a solu\u00e7\u00e3o n\u00e3o apenas seja melhor do que atual mas que sua diferen\u00e7a\n\ncom rela\u00e7\u00e3o ao limite ao \u00f3timo esteja em uma determinada faixa;\n\n? pela bissec\u00e7\u00e3o do intervalo de busca, explorando primeiramente a metade mais pr\u00f3xima ao\n\nlimite ao \u00f3timo e explorando a outra metade somente se a primeira de?nir um PSR invi\u00e1vel.\n\nDessas formas, Lustig e Puget (2001) observam que a \u00faltima representa o de maior aceita\u00e7\u00e3o, sendo\n\ndenominada busca dicot\u00f4mica.\n32Denominada backtracking search em ingl\u00eas.\n\n\n\n2.3 BUSCA 31\n\nA forma mais elementar de recurs\u00e3o e retrocesso consiste naquela com retorno \u00e0 vari\u00e1vel de atri-\n\nbui\u00e7\u00e3o imediatamente anterior no caso de con?ito, sendo conhecido como retrocesso cronol\u00f3gico33\n\nou BT34. A respeito desse algoritmo mais elementar, Bart\u00e1k (1999) elenca tr\u00eas problemas comuns\n\nde desempenho decorrentes da aus\u00eancia de a\u00e7\u00f5es preventivas ou reativas \u00e0s falhas durante a busca:\n\n? Degenera\u00e7\u00e3o da busca35: o processo iterativo de instancia\u00e7\u00e3o das vari\u00e1veis falha repeti-\n\ntivamente por um mesmo motivo, carecendo de uma estrat\u00e9gia de conten\u00e7\u00e3o da causa da\n\nfalha.\n\n? Trabalho redundante: algumas vari\u00e1veis possuem valores con?itantes entre si, de forma\n\nque a memoriza\u00e7\u00e3o poderia evitar que fossem novamente atribu\u00eddos em conjunto durante o\n\nrestante da busca.\n\n? Detec\u00e7\u00e3o tardia de con?ito: nenhum con?ito de atribui\u00e7\u00e3o de vari\u00e1veis \u00e9 previsto com\n\nanteced\u00eancia, sendo todos tratados \u00e0 medida que ocorrem.\n\nAl\u00e9m desses fatores, constatou-se que a ado\u00e7\u00e3o de uma estrat\u00e9gia de atribui\u00e7\u00e3o de valores mais\n\nadequada a cada caso tem grande impacto no desempenho do processo de busca. Disso resultou a\n\nproposi\u00e7\u00e3o de um conjunto de aperfei\u00e7oamentos na literatura, sendo que muitos deles podem ser\n\nutilizados para a composi\u00e7\u00e3o de algoritmos de recurs\u00e3o e retrocesso mais elaborados. A seguir, ser\u00e3o\n\nmencionados alguns dos mais relevantes.\n\nEstrat\u00e9gias de Rami?ca\u00e7\u00e3o\n\nO progresso da busca recursiva costuma ser descrito como uma \u00e1rvore enraizada36 sobre a qual\n\nestrat\u00e9gias podem ser estabelecidas para antecipar a conclus\u00e3o da busca. Nessa representa\u00e7\u00e3o, cada\n\ndecis\u00e3o tomada durante a busca representa uma rami?ca\u00e7\u00e3o da \u00e1rvore. Da perspectiva do modelo\n\nsendo resolvido, tais rami?ca\u00e7\u00f5es correspondem a parti\u00e7\u00f5es do espa\u00e7o de busca. Em \u00faltima an\u00e1lise,\n\no processo de resolu\u00e7\u00e3o consiste na redu\u00e7\u00e3o progressiva do espa\u00e7o de busca pelo aumento da res-\n\ntritividade sobre o modelo ao ponto de restar apenas uma ou nenhuma solu\u00e7\u00e3o. Tais possibilidades\n\nrepresentam a distin\u00e7\u00e3o entre a satisfa\u00e7\u00e3o do PSR e o retrocesso na busca, respectivamente. A res-\n\npeito da forma com que esse processo de rami?ca\u00e7\u00e3o pode ser promovido, existem tipos diferentes de\n\nrami?ca\u00e7\u00e3o e heur\u00edsticas para decidir como rami?car, conforme apresentado a seguir. Na sequ\u00eancia,\n\numa an\u00e1lise da import\u00e2ncia dessas heur\u00edsticas e uma abordagem alternativa \u00e0 busca por recurs\u00e3o\n\ne retrocesso baseada nas mesmas \u00e9 indicada.\n\nTipos de rami?ca\u00e7\u00e3o. Tr\u00eas formas poss\u00edveis de rami?ca\u00e7\u00e3o para a resolu\u00e7\u00e3o de PSRs s\u00e3o\n\nelencadas por van Beek (2006):\n\n33Denominado chronological backtracking em ingl\u00eas.\n34Acr\u00f4nimo em ingl\u00eas surgido a partir do termo backtracking.\n35Denominada thrashing em ingl\u00eas.\n36 Uma \u00e1rvore enraizada consiste em uma \u00e1rvore orientada em que apenas um v\u00e9rtice ? a raiz ? possui apenas\n\narestas de sa\u00edda, de forma que existe um caminho direcionado entre a raiz e cada v\u00e9rtice da \u00e1rvore por meio das\narestas orientadas, sendo os v\u00e9rtices ?nais em cada dire\u00e7\u00e3o de rami?ca\u00e7\u00e3o denominados de folhas. Um v\u00e9rtice no\n?nal de um caminho \u00e9 dito sucessor ou descendente dos outros v\u00e9rtices do mesmo caminho, que lhe s\u00e3o antecessores\nou antecedentes.\n\n\n\n32 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.3\n\n? Pontos de decis\u00e3o bin\u00e1ria ou divis\u00e3o em 237: representa a op\u00e7\u00e3o de atribui\u00e7\u00e3o de um\n\ndeterminado valor a uma das vari\u00e1veis de decis\u00e3o, de forma que o n\u00edvel seguinte possui dois\n\nv\u00e9rtices: um em que esse valor \u00e9 ?xado \u00e0 vari\u00e1vel e outro em que a atribui\u00e7\u00e3o desse valor n\u00e3o\n\n\u00e9 mais permitida \u00e0 vari\u00e1vel.\n\n? Divis\u00e3o de dom\u00ednios38: n\u00e3o representa necessariamente a atribui\u00e7\u00e3o a uma vari\u00e1vel, mas\n\nantes a parti\u00e7\u00e3o de seu dom\u00ednio. Dessa forma, o conjunto de valores que podem ser atribu\u00eddos\n\n\u00e0 vari\u00e1vel nos dois v\u00e9rtices do n\u00edvel seguinte n\u00e3o possui intersec\u00e7\u00e3o entre si.\n\n? Enumera\u00e7\u00e3o ou divis\u00e3o em d39: representa a atribui\u00e7\u00e3o de cada valor poss\u00edvel a uma das\n\nvari\u00e1veis de decis\u00e3o, de forma que cada v\u00e9rtice do n\u00edvel seguinte representa o mesmo problema\n\ncom um valor distinto ?xado para tal vari\u00e1vel.\n\nCabe ressaltar que as tr\u00eas modalidades representam uma sequ\u00eancia de generaliza\u00e7\u00f5es que coincidem\n\npara o caso de dom\u00ednios bin\u00e1rios, visto que a divis\u00e3o em d coincide com a divis\u00e3o em 2 e que a\n\ndivis\u00e3o de um dom\u00ednio bin\u00e1rio invariavelmente induz a uma atribui\u00e7\u00e3o.\n\nHeur\u00edsticas para rami?ca\u00e7\u00e3o. A escolha da sequ\u00eancia de op\u00e7\u00f5es que ser\u00e3o realizadas ao longo\n\nda busca representa a estrat\u00e9gia de rami?ca\u00e7\u00e3o. Essa escolha pode ser baseada em decis\u00f5es locais a\n\ncada rami?ca\u00e7\u00e3o ou ser estabelecida de antem\u00e3o, sendo esse o ponto de distin\u00e7\u00e3o entre as ordena\u00e7\u00f5es\n\ndin\u00e2micas e est\u00e1ticas das atribui\u00e7\u00f5es. Tais decis\u00f5es s\u00e3o tomadas por meio de heur\u00edsticas sobre\n\nas propriedades do modelo e partem de premissas sobre a consequ\u00eancia de cada escolha poss\u00edvel\n\nmediante as condi\u00e7\u00f5es observadas durante a busca. O objetivo mais comum a essas escolhas \u00e9 de\n\nque fa\u00e7am com que a busca seja feita com o menor esfor\u00e7o poss\u00edvel. A esse respeito, Refalo (2004)\n\ndestaca tr\u00eas princ\u00edpios b\u00e1sicos que costumam orientar as rami?ca\u00e7\u00f5es:\n\n1. Sempre escolher para atribui\u00e7\u00e3o as vari\u00e1veis com maior potencial \u00e0 redu\u00e7\u00e3o do espa\u00e7o de\n\nbusca. Tal crit\u00e9rio pode direcionar a escolha, por exemplo, para aquelas com menor tamanho\n\nde dom\u00ednio ou maior participa\u00e7\u00e3o nas restri\u00e7\u00f5es do modelo. Na literatura, esse princ\u00edpio\n\ncostuma ser identi?cado pela express\u00e3o ?falhar primeiro?40 devido ao fato de induzir \u00e0 escolha\n\nde vari\u00e1veis com maior potencial \u00e0 ocorr\u00eancia de falhas prematuras durante a busca. Essa\n\nop\u00e7\u00e3o objetiva evitar que a mesma falha ocorra com maior frequ\u00eancia, caso essa falha viesse\n\na ocorrer em n\u00edveis posteriores da busca.\n\n2. Sempre escolher para atribui\u00e7\u00e3o os valores que maximizem as possibilidades de ocorr\u00eancia de\n\noutras atribui\u00e7\u00f5es, de forma que possuam uma maior probabilidade de presen\u00e7a nas solu\u00e7\u00f5es\n\nao problema. Como pode ser observado, o princ\u00edpio de escolha de valores \u00e9 antag\u00f4nico ao de\n\nescolha de vari\u00e1veis.\n\n3. Sempre privilegiar decis\u00f5es mais pr\u00f3ximas ao topo da \u00e1rvore de busca, pois t\u00eam uma impor-\n\nt\u00e2ncia maior devido \u00e0s consequ\u00eancias mais desastrosas que uma m\u00e1 decis\u00e3o a esse ponto traria.\n\nA raz\u00e3o desse princ\u00edpio \u00e9 consonante ao racioc\u00ednio apresentado para endossar o princ\u00edpio de\n\n?falhar primeiro?, mencionado anteriormente.\n\n37Denominada binary choice points ou 2-way em ingl\u00eas.\n38Denominada domain splitting em ingl\u00eas.\n39Denominada enumeration ou d-way em ingl\u00eas.\n40Denominado fail-?rst principle em ingl\u00eas.\n\n\n\n2.3 BUSCA 33\n\nRefalo (2004) observa que um desenvolvimento maior foi conferido inicialmente aos dois primeiros\n\nprinc\u00edpios enunciados por meio de heur\u00edsticas para ordenar a prefer\u00eancia de escolha de vari\u00e1veis e de\n\nvalores para atribui\u00e7\u00e3o, como pode ser observado na revis\u00e3o de Brailsford et al. (1999). No entanto,\n\no terceiro princ\u00edpio ganhou um reconhecimento maior ao longo da \u00faltima d\u00e9cada. Como exemplo\n\ndisso, Refalo (2004) explora o emprego de uma heur\u00edstica que demanda maior processamento na\n\nraiz da busca, Kautz et al. (2002) emprega estrat\u00e9gias din\u00e2micas de rein\u00edcio da busca para alterar a\n\nrami?ca\u00e7\u00e3o pr\u00f3xima da raiz e em Arbelaez et al. (2009) \u00e9 proposto um modelo preditivo de impacto\n\ndas heur\u00edsticas correlancionando diversas caracter\u00edsticas do modelo.\n\n\u00c9 importante n\u00e3o esquecer o car\u00e1ter tentativo de qualquer estrat\u00e9gia de rami?ca\u00e7\u00e3o devido ao\n\nfato de que o problema de formula\u00e7\u00e3o da estrat\u00e9gia \u00f3tima de rami?ca\u00e7\u00e3o acaba por tamb\u00e9m ser NP-\n\nDif\u00edcil. Isso pode ser constatado de forma simples no caso da abordagem a um PSR satisfat\u00edvel: uma\n\nestrat\u00e9gia perfeita de escolha de valores basta para que uma solu\u00e7\u00e3o seja obtida sem que nenhum\n\nretrocesso ocorra. No caso de um PSR insatisfat\u00edvel, a incumb\u00eancia para uma estrat\u00e9gia \u00f3tima\n\nrecai sobre a ordem de instancia\u00e7\u00e3o das vari\u00e1veis, uma vez que tal escolha induz a uma explora\u00e7\u00e3o\n\nexaustiva menos trabalhosa se os con?itos ocorrerem mais pr\u00f3ximos \u00e0 raiz da busca. \u00c9 interessante\n\nobservar que o foco na literatura se concentra muito mais na ordena\u00e7\u00e3o das vari\u00e1veis em raz\u00e3o da\n\nimport\u00e2ncia atribu\u00edda \u00e0 antecipa\u00e7\u00e3o dos con?itos na \u00e1rvore de busca. Como um contraponto a essa\n\n\u00eanfase, a seguir \u00e9 apresentado um algoritmo alternativo de busca que se concentra exclusivamente na\n\nordena\u00e7\u00e3o dos valores. Apesar de n\u00e3o ser exatamente um algoritmo baseado em retrocesso, optou-\n\nse por sua apresenta\u00e7\u00e3o dentro da presente se\u00e7\u00e3o devido \u00e0 similaridade entre ambos e \u00e0 forma\n\nalternativa com que explora estrat\u00e9gias de rami?ca\u00e7\u00e3o.\n\nBusca por discrep\u00e2ncia limitada. A busca por discrep\u00e2ncia limitada41 opera sobre instanci-\n\na\u00e7\u00f5es completas das vari\u00e1veis de decis\u00e3o at\u00e9 que seja obtida uma solu\u00e7\u00e3o ao problema, i.e., at\u00e9 que\n\nn\u00e3o haja nenhuma viola\u00e7\u00e3o \u00e0s restri\u00e7\u00f5es do PSR por parte das atribui\u00e7\u00f5es. Nesse algoritmo, parte-se\n\nde uma instancia\u00e7\u00e3o das vari\u00e1veis com o valor de maior prioridade a cada vari\u00e1vel, correspondente\n\n\u00e0 rami?ca\u00e7\u00e3o mais \u00e0 esquerda42 na \u00e1rvore de busca ? seja ela fact\u00edvel ou n\u00e3o. A cada itera\u00e7\u00e3o,\n\num n\u00famero progressivo de valores \u00e9 alterado a partir da instancia\u00e7\u00e3o original como forma de obter\n\numa solu\u00e7\u00e3o ? i.e., o n\u00edvel 0 consiste no conjunto de atribui\u00e7\u00f5es inicial, o n\u00edvel 1 aos conjuntos de\n\natribui\u00e7\u00f5es que diferem em apenas uma vari\u00e1vel do conjunto inicial e assim por diante. O intuito no\n\nprojeto desse algoritmo \u00e9 de que o espa\u00e7o de busca seja explorado apenas sob a orienta\u00e7\u00e3o de um\n\nconjunto referencial de valores de atribui\u00e7\u00e3o, assim evitando que uma m\u00e1 ordena\u00e7\u00e3o das vari\u00e1veis\n\ndegenere a busca. De acordo com Baptiste et al. (2001), a premissa ao sucesso dessa abordagem \u00e9\n\nde que as heur\u00edsticas empregadas falham em poucos pontos, a despeito de quais sejam esses pontos.\n\nDessa forma, o sucesso de uma busca desse tipo acaba por depender muito mais da forma com que\n\nos valores s\u00e3o ordenados.\n\nT\u00e9cnicas Preventivas de Melhoria da Busca\n\nO objetivo das t\u00e9cnicas preventivas43 \u00e9 de manter um n\u00edvel de consist\u00eancia do modelo ao longo da\n\nbusca como forma de evitar a detec\u00e7\u00e3o tardia de con?ito em determinados casos. Essa manuten\u00e7\u00e3o\n\n41Denominada Limited Discrepancy Search (LDS) em ingl\u00eas.\n42Por rami?ca\u00e7\u00e3o mais \u00e0 esquerda em uma \u00e1rvore de busca, ilustra-se gra?camente o conceito do caminho obtido\n\npela escolher da primeira op\u00e7\u00e3o em cada n\u00edvel da busca.\n43Denominadas look ahead schemas em ingl\u00eas.\n\n\n\n34 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.3\n\ncostuma ser feita por t\u00e9cnicas de consist\u00eancia em n\u00edvel de aresta, sendo as tr\u00eas modalidades mais\n\ncomuns as seguintes:\n\n? Veri?ca\u00e7\u00e3o adiantada ou FC44. Na veri?ca\u00e7\u00e3o adiantada, a manuten\u00e7\u00e3o da consist\u00eancia\n\nem n\u00edvel de aresta \u00e9 feita sobre restri\u00e7\u00f5es bin\u00e1rias envolvendo uma vari\u00e1vel instanciada e outra\n\nn\u00e3o instanciada. A propaga\u00e7\u00e3o resultante dessa manuten\u00e7\u00e3o ocorre a cada nova atribui\u00e7\u00e3o e\n\ndeve ser revertida se a atribui\u00e7\u00e3o for desfeita. Nessa modalidade, uma nova atribui\u00e7\u00e3o de valor\n\na uma vari\u00e1vel ser\u00e1 sempre v\u00e1lida devido aos dom\u00ednios estarem consistentes no corte entre os\n\nv\u00e9rtices das vari\u00e1veis instanciadas e os v\u00e9rtices das vari\u00e1veis n\u00e3o instanciadas. Dessa forma,\n\no retrocesso n\u00e3o opera devido ao con?ito imediato de uma atribui\u00e7\u00e3o \u00e0 satisfa\u00e7\u00e3o de uma\n\nrestri\u00e7\u00e3o, mas sim pelo esvaziamento do dom\u00ednio de uma vari\u00e1vel que ainda n\u00e3o foi instanciada\n\ndurante a propaga\u00e7\u00e3o ? raz\u00e3o pela qual haveria um con?ito iminente para qualquer atribui\u00e7\u00e3o\n\n\u00e0 vari\u00e1vel de dom\u00ednio esvaziado. Segundo Bart\u00e1k (1999), foi constatado que o desempenho\n\ndecorrente da aplica\u00e7\u00e3o dessa t\u00e9cnica \u00e9 superior ao do retrocesso cronol\u00f3gico.\n\n? Antecipa\u00e7\u00e3o parcial45. A antecipa\u00e7\u00e3o parcial consiste em um desdobramento \u00e0 manuten\u00e7\u00e3o\n\nda consist\u00eancia em n\u00edvel de aresta n\u00e3o apenas para as arestas no corte tratado pela veri?ca\u00e7\u00e3o\n\nadiantada, mas tamb\u00e9m em uma orienta\u00e7\u00e3o do restante das arestas entre v\u00e9rtices de vari\u00e1veis\n\nn\u00e3o instanciadas. Ela \u00e9 dita parcial por operar apenas sobre uma orienta\u00e7\u00e3o e n\u00e3o sobre todas\n\nas arestas do grafo do modelo, de forma que representa a consist\u00eancia direcional em n\u00edvel de\n\naresta. Conv\u00e9m ressaltar que essa modalidade \u00e9 elencada por Bart\u00e1k (1999) mas \u00e9 ignorada por\n\nvan Beek (2006), que considera apenas os outros dois casos. Entretanto, conforme mencionado\n\nanteriormente, Dechter (2003) aponta que a manuten\u00e7\u00e3o de consist\u00eancia direcional ao n\u00edvel\n\nda aresta surte o mesmo efeito que a n\u00e3o-direcional no caso em que a orienta\u00e7\u00e3o condiz com\n\na estrat\u00e9gia de rami?ca\u00e7\u00e3o da busca. Dessa forma, a antecipa\u00e7\u00e3o parcial pode substituir com\n\nvantagem de desempenho a antecipa\u00e7\u00e3o total em algumas situa\u00e7\u00f5es, como no caso de uma\n\nordena\u00e7\u00e3o est\u00e1tica para rami?ca\u00e7\u00e3o do restante do espa\u00e7o de busca.\n\n? Antecipa\u00e7\u00e3o total, manuten\u00e7\u00e3o da consist\u00eancia em n\u00edvel de aresta ou MAC46.\n\nComo o pr\u00f3prio nome alternativo anseia, a antecipa\u00e7\u00e3o total consiste na manuten\u00e7\u00e3o da\n\nconsist\u00eancia ao n\u00edvel da aresta a todo o grafo do modelo, sem restri\u00e7\u00e3o de orienta\u00e7\u00e3o ou\n\nextens\u00e3o. Bart\u00e1k (1999) observa que o esfor\u00e7o necess\u00e1rio \u00e0 MAC pode tornar seu desempenho\n\npior que o da veri?ca\u00e7\u00e3o antecipada ou do retrocesso cronol\u00f3gico em alguns casos. Por outro\n\nlado, van Beek (2006) considera que a controv\u00e9rsia a respeito da quest\u00e3o de desempenho nesse\n\ncaso foi superada por novos estudos emp\u00edricos e que a antecipa\u00e7\u00e3o total representa uma op\u00e7\u00e3o\n\nsuperior \u00e0s demais no caso geral.\n\nT\u00e9cnicas Reativas de Melhoria da Busca\n\nO objetivo das t\u00e9cnicas reativas47 \u00e9 utilizar informa\u00e7\u00f5es sobre con?itos que ocorreram durante\n\na busca para evitar sua repeti\u00e7\u00e3o ou prover uma conting\u00eancia mais adequada \u00e0 sua ocorr\u00eancia.\n\nSua necessidade se deve \u00e0 impossibilidade de se atingir n\u00edveis completos de consist\u00eancia, de forma\n\n44Denominada Forward Checking (FC) em ingl\u00eas.\n45Denominada partial look ahead em ingl\u00eas.\n46Denominada (full) look ahead ou Maintaining Arc Consistency (MAC) em ingl\u00eas.\n47Denominadas look back schemas em ingl\u00eas.\n\n\n\n2.3 BUSCA 35\n\nque a detec\u00e7\u00e3o tardia de con?ito n\u00e3o pode ser completamente erradicada. Assim sendo, o foco\n\ndessas t\u00e9cnicas \u00e9 evitar o trabalho redundante e, por consequ\u00eancia, a degenera\u00e7\u00e3o da busca. Entre-\n\ntanto, conv\u00e9m sempre avaliar se o esfor\u00e7o exigido para a execu\u00e7\u00e3o de procedimentos de veri?ca\u00e7\u00e3o\n\nadicionais n\u00e3o ser\u00e1 maior do que o perda em desempenho cuja ocorr\u00eancia se procura evitar.\n\nA seguir, listamos algumas das t\u00e9cnicas reativas mais estudadas na literatura, conforme Dechter\n\n(2003) e van Beek (2006):\n\n? Aprendizado de restri\u00e7\u00f5es48. O aprendizado de restri\u00e7\u00f5es consiste na acumula\u00e7\u00e3o de no-\n\nvas restri\u00e7\u00f5es ao modelo original em decorr\u00eancia dos con?itos detectados durante a busca.\n\nCada nova restri\u00e7\u00e3o \u00e9 obtida por meio da identi?ca\u00e7\u00e3o de um conjunto de con?ito, que repre-\n\nsenta o conjunto de vari\u00e1veis cujas atribui\u00e7\u00f5es justi?cam a viola\u00e7\u00e3o de alguma restri\u00e7\u00e3o. Por\n\nsua vez, as atribui\u00e7\u00f5es que conferem a viola\u00e7\u00e3o de uma restri\u00e7\u00e3o a esse conjunto de con?ito\n\nrepresentam uma rejei\u00e7\u00e3o49, a partir da qual de?ne-se uma nova restri\u00e7\u00e3o que pro\u00edba exata-\n\nmente esse conjunto de atribui\u00e7\u00f5es. Apesar de redundante por estar impl\u00edcita no conjunto de\n\nrestri\u00e7\u00f5es original do modelo, essa nova restri\u00e7\u00e3o possibilita uma propaga\u00e7\u00e3o mais e?ciente\n\npor evidenciar um con?ito que j\u00e1 ocorreu anteriormente, de forma que interessa determinar\n\no menor conjunto de con?ito poss\u00edvel para que uma quantidade maior de con?itos futuros\n\nseja evitada. O maior inconveniente a essa t\u00e9cnica ? e que faz com que n\u00e3o seja utilizada na\n\npr\u00e1tica ? \u00e9 que ela pode levar \u00e0 inclus\u00e3o de uma quantidade exagerada de restri\u00e7\u00f5es, de forma\n\nque exige a de?ni\u00e7\u00e3o de um crit\u00e9rio \u00e0 inclus\u00e3o de novas restri\u00e7\u00f5es para privilegiar as mais\n\ngeneralistas e outro crit\u00e9rio \u00e0 remo\u00e7\u00e3o de restri\u00e7\u00f5es para n\u00e3o continuar propagando aquelas\n\ncujos con?itos evitados j\u00e1 n\u00e3o possam mais ocorrer.\n\n? Retrocesso inteligente50. O retrocesso inteligente promove um retrocesso n\u00e3o-cronol\u00f3gico\n\n? i.e., n\u00e3o necessariamente \u00e0 \u00faltima vari\u00e1vel atribu\u00edda ? pela an\u00e1lise do conjunto de con?ito.\n\nDito de outra forma, ele salta vari\u00e1veis da pilha cuja atribui\u00e7\u00e3o n\u00e3o tenha rela\u00e7\u00e3o com a\n\nimpossibilidade de progresso da busca a partir daquele ponto. Sendo a altera\u00e7\u00e3o da atribui\u00e7\u00e3o\n\na alguma vari\u00e1vel do conjunto de con?ito condi\u00e7\u00e3o necess\u00e1ria ? mas n\u00e3o su?ciente ? para\n\nque alguma solu\u00e7\u00e3o seja obtida, um salto que ignore apenas vari\u00e1veis ausentes do conjunto\n\nn\u00e3o impede a completude da busca. Portanto, evita-se o trabalho redundante na busca pela\n\nexaust\u00e3o de possibilidades de atribui\u00e7\u00e3o que seriam exploradas sem serem capazes de evitar\n\na reincid\u00eancia da falha observada. Uma sequ\u00eancia de algoritmos contemplando uma gama\n\ncada vez mais ampla de saltos \u00e9 descrita na literatura, dos quais dois t\u00eam maior destaque: o\n\nalgoritmo de retrocesso por salto51 ou de Gaschnig, que retrocede n\u00e3o cronologicamente apenas\n\nde v\u00e9rtices da \u00e1rvore de busca cujos descendentes sejam folhas ? i.e., nenhuma atribui\u00e7\u00e3o\n\nocorreu sem con?ito a partir daquele ponto; e o algoritmo de retrocesso baseado em con?ito52,\n\nque pode retroceder a partir de outros v\u00e9rtices da \u00e1rvore de busca devido ao ac\u00famulo do\n\nconjunto de con?ito dos sucessores dos quais retornou.\n\n? Retrocesso din\u00e2mico53. O retrocesso din\u00e2mico consiste na permuta da ordem das vari\u00e1veis\n\n48Denominado backmarking em ingl\u00eas.\n49Denominada nogood em ingl\u00eas.\n50Denominado intelligent backtracking ou backjumping em ingl\u00eas.\n51Denominado BackJumping (BJ) em ingl\u00eas.\n52Denominado Con?ict-Based BackJumping (CBJ) em ingl\u00eas.\n53Denominado dynamic backtracking em ingl\u00eas.\n\n\n\n36 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.3\n\nda pilha de atribui\u00e7\u00f5es, de forma a aproximar a posi\u00e7\u00e3o das atribui\u00e7\u00f5es de vari\u00e1veis con?itan-\n\ntes. Dessa forma, o retrocesso din\u00e2mico representa uma alternativa ao retrocesso inteligente\n\npor reduzir o trabalho redundante ao diminuir o n\u00famero de atribui\u00e7\u00f5es a vari\u00e1veis em or-\n\ndem intermedi\u00e1ria com rela\u00e7\u00e3o \u00e0s con?itantes. No entanto, a livre permuta das vari\u00e1veis na\n\nordem de atribui\u00e7\u00e3o pode comprometer a sistem\u00e1tica da busca ? i.e., torn\u00e1-la c\u00edclica ou in-\n\ncompleta. Portanto, esse subterf\u00fagio tem maior utilidade no in\u00edcio da busca ou se incorporada\n\n\u00e0s estrat\u00e9gias de rami?ca\u00e7\u00e3o.\n\n2.3.2 Busca Local e Estoc\u00e1stica\n\nA busca local e a busca estoc\u00e1stica procuram explorar o espa\u00e7o de busca de forma n\u00e3o sistem\u00e1-\n\ntica, podendo valer-se dos resultados intermedi\u00e1rios para guiar o restante do processo de resolu\u00e7\u00e3o.\n\nNo caso da busca estoc\u00e1stica, a justi?cativa a um processo n\u00e3o sistem\u00e1tico se d\u00e1 pelo foco \u00e0 explo-\n\nra\u00e7\u00e3o de regi\u00f5es com maior potencial em detrimento \u00e0 completude. No entanto, \u00e9 poss\u00edvel conferir\n\nessa \u00faltima caracter\u00edstica a algumas das abordagens desse tipo. Como exemplo disso, temos as estra-\n\nt\u00e9gias de rein\u00edcio como as descritas em Gomes et al. (1998) e Kautz et al. (2002), que interrompem\n\na busca para reinici\u00e1-la com altera\u00e7\u00f5es \u00e0s estrat\u00e9gias de rami?ca\u00e7\u00e3o. Observa-se de Gomes et al.\n\n(1998) que \u00e9 poss\u00edvel manter a completude da busca empregando estrat\u00e9gias de rein\u00edcio se o n\u00famero\n\nm\u00ednimo de retrocessos \u00e0 interrup\u00e7\u00e3o da busca aumentar ao longo da resolu\u00e7\u00e3o, de forma que em\n\nalgum momento a quantidade m\u00ednima ultrapasse o n\u00famero de retrocessos necess\u00e1rios \u00e0 realiza\u00e7\u00e3o\n\nde uma busca completa. Entretanto, tal peculiaridade interessa menos como uma caracter\u00edstica\n\ndesse tipo de abordagem \u00e0 busca e mais como uma garantia de que o fracasso da estrat\u00e9gia de\n\nrein\u00edcio n\u00e3o prejudique a busca por sempre limit\u00e1-la apenas a algumas regi\u00f5es. No caso da busca\n\nlocal, a explora\u00e7\u00e3o do espa\u00e7o de busca \u00e9 limitada a aperfei\u00e7oar resultados obtidos por outros meios\n\nsob o argumento de que a completude n\u00e3o pode ser cogitada devido ao tamanho do espa\u00e7o de\n\nbusca. Ela opera por meio de transforma\u00e7\u00f5es de solu\u00e7\u00f5es obtidas anteriormente na resolu\u00e7\u00e3o, seja\n\npara minimizar a penaliza\u00e7\u00e3o decorrente de uma solu\u00e7\u00e3o que n\u00e3o atenda a todas as restri\u00e7\u00f5es ou\n\npara obter uma melhor aproxima\u00e7\u00e3o \u00e0 solu\u00e7\u00e3o \u00f3tima a partir de solu\u00e7\u00f5es que j\u00e1 sejam fact\u00edveis.\n\nDessa forma, existe uma certa similaridade e intersec\u00e7\u00e3o entre ambas as modalidades, mas conv\u00e9m\n\nanalis\u00e1-las separadamente devido ao escopo diferenciado de ambas: na busca estoc\u00e1stica ainda \u00e9\n\nposs\u00edvel operar sobre a mesma estrutura que a de recurs\u00e3o e retrocesso, enquanto que a busca local\n\nopera sobre estruturas alternativas.\n\nA estrutura\u00e7\u00e3o da busca local costuma priorizar a obten\u00e7\u00e3o de solu\u00e7\u00f5es a partir de outras pr\u00e9-\n\nexistentes. Essa gera\u00e7\u00e3o de solu\u00e7\u00f5es pode priorizar a qualidade ? seja por um melhor atendimento \u00e0s\n\nrestri\u00e7\u00f5es ou uma melhor valora\u00e7\u00e3o da fun\u00e7\u00e3o objetivo ? ou a variabilidade ? como no caso em que\n\nos crit\u00e9rios quantitativos de compara\u00e7\u00e3o das solu\u00e7\u00f5es n\u00e3o s\u00e3o tidos como su?cientes e certo grau de\n\nliberdade \u00e9 conferido \u00e0 interven\u00e7\u00e3o humana pela escolha dentre um conjunto de solu\u00e7\u00f5es distintas.\n\nPor quest\u00e3o de foco ao tipo de abordagem realizado no estudo de caso do presente trabalho, ser\u00e3o\n\nexempli?cadas a seguir apenas estruturas de prioriza\u00e7\u00e3o \u00e0 qualidade. Dechter (2003) ilustra o caso\n\nde melhor atendimento \u00e0s restri\u00e7\u00f5es pelo emprego de m\u00e9todos gulosos de busca local, de forma que a\n\nresolu\u00e7\u00e3o \u00e9 decomposta entre uma atribui\u00e7\u00e3o completa de valores despreocupada com o atendimento\n\n\u00e0s restri\u00e7\u00f5es e a opera\u00e7\u00e3o de reparos locais a tais atribui\u00e7\u00f5es como forma de reduzir a viola\u00e7\u00e3o\n\ndecorrente. \u00c9 poss\u00edvel observar certa similaridade entre essa estrutura e a busca por discrep\u00e2ncia\n\nlimitada, com ressalva \u00e0 aus\u00eancia de sistematiza\u00e7\u00e3o para completude da busca nesse caso. Focando a\n\n\n\n2.4 PARADIGMAS 37\n\notimalidade em vez da satisfabilidade, \u00e9 estudada uma decomposi\u00e7\u00e3o distinta em Laborie e Godard\n\n(2007), dividida entre operadores que geram novas solu\u00e7\u00f5es por meio de modi?ca\u00e7\u00f5es em solu\u00e7\u00f5es\n\nfact\u00edveis e operadores que ajustam as solu\u00e7\u00f5es geradas para que satisfa\u00e7am \u00e0s restri\u00e7\u00f5es no caso de\n\nalguma viola\u00e7\u00e3o ter sido causada. Duas refer\u00eancias s\u00e3o recomendadas para o aprofundamento na\n\naplica\u00e7\u00e3o de busca local em PR, tendo enfoques distintos: Dechter (2003) parte da PR para discutir\n\no emprego de busca local, ao passo que Hoos e St\u00fctzle (2005) partem da busca local estoc\u00e1stica\n\npara discutir sua aplica\u00e7\u00e3o em PR.\n\n2.4 Paradigmas\n\nO desenvolvimento da PR ao longo dos anos ocorreu sob uma sucess\u00e3o de paradigmas de sin-\n\ntaxe dos resolvedores cuja contextualiza\u00e7\u00e3o faz-se importante a uma melhor compreens\u00e3o de como\n\na t\u00e9cnica foi sendo aperfei\u00e7oada. O principal deles consiste na Programa\u00e7\u00e3o L\u00f3gica por Restri-\n\n\u00e7\u00f5es (PLR)54. De acordo com Bart\u00e1k (1999); Ja?ar e Lassez (1987), a PR partiu da extens\u00e3o de\n\nlinguagens l\u00f3gicas55 como Prolog para uma resolu\u00e7\u00e3o mais e?ciente de PSRs. A extens\u00e3o des-\n\nsas linguagens para a resolu\u00e7\u00e3o de PSRs se deu principalmente pela inclus\u00e3o de mecanismos de\n\ninfer\u00eancia sobre as restri\u00e7\u00f5es, de forma a permitir cortes56 mais e?cazes durante a busca. No en-\n\ntanto, elas conferiram aos programas resultantes um car\u00e1ter distinto devido \u00e0 manipula\u00e7\u00e3o expl\u00edcita\n\ndos predicados, remetendo ao paradigma de programa\u00e7\u00e3o funcional57. Nesse contexto de impasse,\n\nJa?ar e Lassez (1987) propuseram a de?ni\u00e7\u00e3o da classe de linguagens PLR como uma uni?ca\u00e7\u00e3o\n\ndos paradigmas declarativos funcional e l\u00f3gico capaz de descrever as extens\u00f5es sendo ent\u00e3o promo-\n\nvidas na literatura. A classe PLR representa linguagens direcionadas \u00e0 resolu\u00e7\u00e3o por infer\u00eancia no\n\ndom\u00ednio de discurso dos problemas, em contraposi\u00e7\u00e3o \u00e0 tradu\u00e7\u00e3o dos mesmos a uma estrutura uni-\n\n?cada de infer\u00eancia l\u00f3gica, dessa forma conservando o car\u00e1ter de programa\u00e7\u00e3o declarativa. Por essa\n\nraz\u00e3o, a PLR delineou uma estrutura pr\u00e1tica ao desenvolvimento de mecanismos de propaga\u00e7\u00e3o de\n\nresolvedores de problemas combinat\u00f3rios, provendo suporte ao emprego das t\u00e9cnicas pr\u00e9-existentes\n\ne facilitando a emerg\u00eancia de aperfei\u00e7oamentos \u00e0s mesmas.\n\nNo entanto, a PLR n\u00e3o bastou \u00e0 PR devido \u00e0 limita\u00e7\u00e3o do papel assumido pelo usu\u00e1rio ?nal\n\ndo resolvedor nessas linguagens. Isso porque a din\u00e2mica estabelecida impedia que manipula\u00e7\u00f5es\n\nespecializadas a dom\u00ednios mais restritos se viabilizassem. Essas manipula\u00e7\u00f5es foram facilitadas a\n\npartir dos anos 1990 pelo emprego de linguagens imperativas como C++, nas quais a estrutura de\n\nresolu\u00e7\u00e3o \u00e9 oferecida por meio de bibliotecas de c\u00f3digo que podem ser especializadas na de?ni\u00e7\u00e3o\n\nde como se operam tanto a propaga\u00e7\u00e3o quanto a busca. Entretanto, Lustig e Puget (2001) notam\n\nque a PR ainda permanecia como uma t\u00e9cnica bastante restrita a essa \u00e9poca devido \u00e0 exig\u00eancia\n\nde conhecimentos de programa\u00e7\u00e3o de computadores para seu emprego. Nesse contexto, linguagens\n\nde modelagem alg\u00e9brica como as empregadas para programa\u00e7\u00e3o matem\u00e1tica surgiram ao ?nal da\n\n54 Denominada Constraint Logic Programming (CLP) em ingl\u00eas.\n55 No paradigma de programa\u00e7\u00e3o l\u00f3gica, programas s\u00e3o de?nidos como um conjunto de express\u00f5es sobre vari\u00e1veis\n\nou termos constantes, designados predicados devido a seu resultado se resumir \u00e0s condi\u00e7\u00f5es de verdadeiro ou falso. O\nobjetivo da execu\u00e7\u00e3o de um programa l\u00f3gico consiste na veri?ca\u00e7\u00e3o de que um predicado possa ser satisfeito mediante\numa atribui\u00e7\u00e3o de valores constantes a suas vari\u00e1veis, sendo essa atribui\u00e7\u00e3o denominada uni?ca\u00e7\u00e3o. Para maiores\ndetalhes, veja Scott (1999).\n\n56 No contexto da programa\u00e7\u00e3o l\u00f3gica, um corte representa um ponto em que se assume a falha \u00e0 satisfa\u00e7\u00e3o de um\ndeterminado predicado na hip\u00f3tese de retrocesso durante a busca.\n\n57 No paradigma de programa\u00e7\u00e3o funcional, a declara\u00e7\u00e3o dos programas \u00e9 essencialmente recursiva e desprovida\nde atribui\u00e7\u00f5es expl\u00edcitas, evidenciando a forma com que a resolu\u00e7\u00e3o deve operar.\n\n\n\n38 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.4\n\nd\u00e9cada de 1990 e foram se transformando ao longo da d\u00e9cada seguinte. Ainda que essas lingua-\n\ngens j\u00e1 n\u00e3o correspondam \u00e0 estrutura dos mecanismos de resolu\u00e7\u00e3o subjacentes, existe uma rela\u00e7\u00e3o\n\nclara entre a expectativa de como o resolvedor ser\u00e1 utilizado e a disposi\u00e7\u00e3o da sintaxe de modela-\n\ngem. Dessa forma, a compreens\u00e3o da forma com que a PR tem se desenvolvido desde ent\u00e3o passa\n\nobrigatoriamente pela an\u00e1lise tanto das contribui\u00e7\u00f5es \u00e0 PR na literatura que foram adotadas nos\n\nresolvedores quanto da sintaxe com que os problemas passaram a ser modelados.\n\nComo subs\u00eddio a uma introdu\u00e7\u00e3o \u00e0s tend\u00eancias mais recentes observadas, a se\u00e7\u00e3o 2.4.1 serve\n\n\u00e0 analise de duas das ferramentas comerciais baseadas em PR mais empregadas, e a se\u00e7\u00e3o 2.4.2\n\naponta os esfor\u00e7os recentes voltados ao desenvolvimento de linguagens abstratas ? i.e., voltadas \u00e0\n\nPR mas independentes de resolvedores.\n\n2.4.1 Ferramentas Comerciais\n\nDuas linguagens ? e seus respectivos resolvedores ? bastante empregadas atualmente por pra-\n\nticantes da PR s\u00e3o a OPL58 e a Comet. A an\u00e1lise que se segue de cada uma delas \u00e9 baseada nos\n\nmanuais da IBM (2010) e Dynadec (2009), respectivas propriet\u00e1rias das mesmas, al\u00e9m de outras\n\nmen\u00e7\u00f5es observadas sobre seus desenvolvimentos na literatura.\n\nOPL\n\nDe acordo com Lustig e Puget (2001), a OPL foi uma das primeiras linguagens alg\u00e9bricas com\n\nsuporte \u00e0 PR. Ela oferece uma sintaxe declarativa para express\u00f5es matem\u00e1ticas e algumas restri-\n\n\u00e7\u00f5es especializadas a certos dom\u00ednios de aplica\u00e7\u00e3o, como no caso de problemas de escalonamento.\n\nComo pode ser observado pelos exemplos descritos em Hentenryck et al. (2000) e em Lustig e Puget\n\n(2001), as vers\u00f5es iniciais permitiam a de?ni\u00e7\u00e3o separada do modelo e da busca ? a \u00faltima em ter-\n\nmos de estrat\u00e9gias n\u00e3o necessariamente completas de rami?ca\u00e7\u00e3o. No entanto, vers\u00f5es mais recentes\n\nsofreram uma redu\u00e7\u00e3o do escopo em que a busca pode ser de?nida. Em parte, \u00e9 poss\u00edvel que isso\n\nse deva ao argumento de Puget (2004) de que a simplicidade de uso era necess\u00e1ria \u00e0 amplia\u00e7\u00e3o\n\ndo p\u00fablico-alvo da PR, defendida por ele como sendo ?qualquer engenheiro?. No mesmo evento,\n\nRefalo (2004) apresentou uma t\u00e9cnica de rami?ca\u00e7\u00e3o mais elaborada do que as heur\u00edsticas em uso\n\ncomo alternativa \u00e0 delega\u00e7\u00e3o de de?ni\u00e7\u00e3o da busca ao usu\u00e1rio, alegando inspira\u00e7\u00e3o na programa\u00e7\u00e3o\n\ninteira. Um esfor\u00e7o similar foi observado com rela\u00e7\u00e3o \u00e0 aplica\u00e7\u00e3o em problemas de escalonamento\n\nem todos as dimens\u00f5es poss\u00edveis:\n\n? novas abstra\u00e7\u00f5es de modelagem em Laborie e Rogerie (2008) e Laborie et al. (2009);\n\n? explora\u00e7\u00e3o de n\u00edveis de propaga\u00e7\u00e3o mais efetivos e de algoritmos de ?ltragem mais e?cientes\n\nem Laborie (2003a), entre outros;\n\n? algoritmos de busca dedicados a problemas de escalonamento em Godard e Laborie (2005) e\n\nLaborie e Godard (2007).\n\nDessa forma, a sintaxe da OPL foi se transformando em dire\u00e7\u00e3o \u00e0 automatiza\u00e7\u00e3o dos mecanismos\n\nde resolu\u00e7\u00e3o em detrimento \u00e0 manipula\u00e7\u00e3o da de?ni\u00e7\u00e3o da busca. Isso fez com que a de?ni\u00e7\u00e3o da\n\nbusca ?casse restrita \u00e0 con?gura\u00e7\u00e3o de par\u00e2metros do conjunto de t\u00e9cnicas empregadas.\n\n58Acr\u00f4nimo em ingl\u00eas para Optimization Programming Language, ou Linguagem de Programa\u00e7\u00e3o para Otimiza\u00e7\u00e3o.\n\n\n\n2.4 PARADIGMAS 39\n\nComet\n\nDe acordo com Hentenryck (2010), que foi um dos autores da OPL, a Comet teve sua primeira\n\nvers\u00e3o apresentada tr\u00eas anos ap\u00f3s a introdu\u00e7\u00e3o da OPL. A inten\u00e7\u00e3o da linguagem era permitir uma\n\nmanipula\u00e7\u00e3o expl\u00edcita de estrat\u00e9gias de busca local em PR. A princ\u00edpio, sua estrutura era muito\n\nparecida com aquele descrita anteriormente para a OPL em Hentenryck et al. (2000). No entanto, a\n\nlinguagem oferece muitos mecanismos de diferentes paradigmas de programa\u00e7\u00e3o, tais como fechos59\n\ne m\u00e9todos acionados por eventos60 em forma prop\u00edcia \u00e0 de?ni\u00e7\u00e3o de algoritmos de busca local. No\n\nque diz respeito ao dom\u00ednio de problemas de escalonamento, a estrutura de modelagem mant\u00e9m\n\no emprego de abstra\u00e7\u00f5es tradicionais como atividades e recursos por meio de uma gama de pos-\n\nsibilidades de restri\u00e7\u00f5es entre tais abstra\u00e7\u00f5es. No entanto, os algoritmos de resolu\u00e7\u00e3o subjacentes\n\n\u00e0 modelagem n\u00e3o diferem tanto entre a Comet e a OPL. Assim sendo, a maior diferen\u00e7a nos em-\n\nprego dessas linguagens e de seus respectivos mecanismos de resolu\u00e7\u00e3o \u00e9 que a de?ni\u00e7\u00e3o da busca \u00e9\n\nexpl\u00edcita na primeira e impl\u00edcita na segunda. Entretanto, algumas publica\u00e7\u00f5es recentes tiverem seu\n\nfoco voltado \u00e0 abstra\u00e7\u00e3o da busca na Comet, como a proposta de um sintetizador de algoritmos\n\nde busca baseado na estrutura do problema para a resolu\u00e7\u00e3o de PSRs em Hentenryck e Michel\n\n(2007) e de problemas de escalonamento especi?camente em Monette et al. (2009). A justi?cativa a\n\nambos os casos \u00e9 atribu\u00edda a Gomes e Selman (2007), sendo similar \u00e0quela apresentada por Puget\n\n(2004): a necessidade de ampliar a audi\u00eancia sendo atendida pela abstra\u00e7\u00e3o da busca. No caso de\n\nGomes e Selman (2007), alega-se a aus\u00eancia do que se convencionou chamar de resolvedores ?caixa-\n\npreta?, nos quais a modelagem independe de conhecimentos sobre como a busca opera ? algo que\n\ndeve ser tratado com cautela para obter o melhor desempenho poss\u00edvel, conforme defendido em\n\nSerra e Wakabayashi (2010).\n\n2.4.2 Modelagem Abstrata\n\nUma \u00e1rea de trabalho recente em PR diz respeito \u00e0s linguagens de modelagem abstratas, por\n\nmeio das quais um determinado tipo de problema possa ser modelado a despeito do resolvedor que\n\nser\u00e1 empregado. Esse tipo de linguagem surge com maior facilidade na programa\u00e7\u00e3o matem\u00e1tica\n\ndevido \u00e0 relativa uniformidade com que os problemas s\u00e3o modelados. No caso da PR, os obst\u00e1culos\n\ns\u00e3o maiores devido \u00e0 falta de padroniza\u00e7\u00e3o sobre como a modelagem deve ser feita. A MiniZinc,\n\noriginalmente proposta por Nethercote et al. (2007), representou a primeira empreita desse tipo.\n\nNela, os projetistas dos resolvedores s\u00e3o incumbidos de prover uma tradu\u00e7\u00e3o de baixo n\u00edvel entre as\n\nestruturas de modelagem dispon\u00edveis de um lado e a sintaxe de seu resolvedor do outro. No entanto,\n\nos autores reconhecem que h\u00e1 uma diferen\u00e7a consider\u00e1vel de desempenho contra a modelagem na\n\nlinguagem nativa do resolvedor, de forma que \u00e9 necess\u00e1rio que seja dada uma aten\u00e7\u00e3o maior \u00e0s\n\nrestri\u00e7\u00f5es globais e \u00e0 de?ni\u00e7\u00e3o da busca. Em meados de 2011, ocorreram testes controlados de\n\numa vers\u00e3o experimental da linguagem comercial de modelagem abstrata AIMMS capaz de utilizar\n\nresolvedores de PR, conforme divulgado em van Hoeve et al. (2011), sendo poss\u00edvel que as vers\u00f5es\n\no?ciais da linguagem contemplem essa possibilidade nas pr\u00f3ximas vers\u00f5es.\n\n59Mecanismo de linguagens funcionais representando um corpo de c\u00f3digo que pode ser manipulado e executado.\n60M\u00e9todos de programa\u00e7\u00e3o imperativa que podem ser acionados caso uma determinada condi\u00e7\u00e3o monitorada\n\nocorra.\n\n\n\n40 PROGRAMA\u00c7\u00c3O POR RESTRI\u00c7\u00d5ES 2.4\n\n\n\nCap\u00edtulo 3\n\nEscalonamento Baseado em Restri\u00e7\u00f5es\n\nO Escalonamento Baseado em Restri\u00e7\u00f5es (EBR)1 representa uma extens\u00e3o da PR \u00e0 aborda-\n\ngem de problemas de escalonamento. Essa extens\u00e3o consiste na especializa\u00e7\u00e3o dos elementos de\n\nmodelagem, propaga\u00e7\u00e3o e busca \u00e0 resolu\u00e7\u00e3o de problemas envolvendo a aloca\u00e7\u00e3o temporal de ativi-\n\ndades mediante as limita\u00e7\u00f5es dos recursos \u00e0 disposi\u00e7\u00e3o. Notadamente, o desenvolvimento observado\n\nnessa linha de aplica\u00e7\u00e3o destacou-se das demais em PR e foi alavancado por pesquisa tanto na\n\nacademia quanto na ind\u00fastria. O interesse acad\u00eamico se deu pela integra\u00e7\u00e3o e incentivo a frentes\n\nbastante diversas de pesquisa em um ferramental de resolu\u00e7\u00e3o uni?cado. Na ind\u00fastria, identi?cou-se\n\na oportunidade de aplica\u00e7\u00e3o a problemas reais gra\u00e7as \u00e0 forma compacta com que modelos de EBR\n\ndescrevem certos problemas e aos resultados observados. Dessa forma, o EBR representa um caso de\n\nparticular interesse da PR devido ao incentivo que representa \u00e0 aplica\u00e7\u00e3o da t\u00e9cnica e ao benef\u00edcio\n\nadvindo dessa aplica\u00e7\u00e3o no caso de problemas de escalonamento.\n\nO prop\u00f3sito deste cap\u00edtulo \u00e9 analisar a especializa\u00e7\u00e3o dos elementos constituintes da PR \u00e0\n\nabordagem de problemas de escalonamento de diversos tipos. Para tanto, conv\u00e9m apresentar de\n\nantem\u00e3o as raz\u00f5es pelas quais a articula\u00e7\u00e3o entre esses elementos encontrou um campo mais f\u00e9rtil\n\nnessa \u00e1rea do que em outras.\n\nDe acordo com Baptiste et al. (2006), o sucesso na abordagem de problemas de escalonamento\n\npor meio da PR se deu pela ader\u00eancia de t\u00e9cnicas pr\u00e9-existentes \u00e0 componentiza\u00e7\u00e3o de acordo com\n\no trip\u00e9 modelo-propaga\u00e7\u00e3o-busca, descrito no Cap\u00edtulo 2. A modelagem por meio de vari\u00e1veis e res-\n\ntri\u00e7\u00f5es especializadas possibilitou uma descri\u00e7\u00e3o natural e ?ex\u00edvel de problemas de escalonamento.\n\nA propaga\u00e7\u00e3o por meio de restri\u00e7\u00f5es globais aproveitou-se de uma sinergia entre a generalidade\n\nde constitui\u00e7\u00e3o dos problemas abordados na intelig\u00eancia arti?cial e a e?ci\u00eancia de algoritmos de\n\n?ltragem especializados da pesquisa operacional. A descri\u00e7\u00e3o das heur\u00edsticas mais comuns de esca-\n\nlonamento adequou-se \u00e0 estrutura de \u00e1rvore de busca empregada na PR. Al\u00e9m disso, a natureza\n\ndeclarativa da modelagem possibilitou o emprego de m\u00e9todos alternativos de busca, conforme men-\n\ncionado na introdu\u00e7\u00e3o do Cap\u00edtulo 2 e exempli?cado na se\u00e7\u00e3o 2.3.2. Dessa forma, a EBR representou\n\nantes uma compila\u00e7\u00e3o de ferramental disperso em uma organiza\u00e7\u00e3o prop\u00edcia do que uma constitui-\n\n\u00e7\u00e3o completamente in\u00e9dita e independente das abordagens alternativas \u00e0 resolu\u00e7\u00e3o de problemas\n\ndesse tipo.\n\nA organiza\u00e7\u00e3o do restante do cap\u00edtulo objetiva uma descri\u00e7\u00e3o do EBR por meio de suas especi?-\n\ncidades com rela\u00e7\u00e3o \u00e0 PR. Portanto, a estrutura do cap\u00edtulo \u00e9 mais compacta mas bastante similar\n\n1 Denominado Constraint-Based Scheduling (CBS) em ingl\u00eas.\n\n41\n\n\n\n42 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.1\n\n\u00e0quela empregada no cap\u00edtulo anterior. A se\u00e7\u00e3o 3.1 trata dos paradigmas e da modelagem para a\n\nde?ni\u00e7\u00e3o dos problemas no EBR e a se\u00e7\u00e3o 3.2 da propaga\u00e7\u00e3o e da busca para a resolu\u00e7\u00e3o desses\n\nproblemas.\n\n3.1 Modelagem e Paradigmas Descritivos\n\nApesar da modelagem dos problemas de escalonamento variar em fun\u00e7\u00e3o da tipologia de cada\n\nproblema, existem alguns elementos comuns a todos eles. Os PSRs espec\u00ed?cos ao EBR se baseiam\n\nnos conjuntos A = {a1, . . . ,an} de atividades e R = {r1, . . . ,rm} de recursos necess\u00e1rios \u00e0s ati-\nvidades. Sobre ambos os conjuntos, propriedades podem ser de?nidas como vari\u00e1veis ou restri\u00e7\u00f5es\n\ndo problema. Essas propriedades podem dizer respeito \u00e0 aloca\u00e7\u00e3o temporal das atividades, \u00e0 sua\n\ndemanda pela disponibilidade dos recursos, \u00e0s restri\u00e7\u00f5es temporais entre atividades ou \u00e0 limita\u00e7\u00e3o\n\nda disponibilidade dos recursos ao longo do tempo. No caso de POSRs, a constitui\u00e7\u00e3o da fun\u00e7\u00e3o\n\nobjetivo tamb\u00e9m \u00e9 feita de vari\u00e1veis de decis\u00e3o advindas dessas propriedades. O que varia com as\n\ndiferentes tipologias de problema \u00e9 a natureza, o valor ou a manipula\u00e7\u00e3o realizada das propriedades\n\nque caracterizam os elementos dos conjuntos A e R, bem como sua inter-rela\u00e7\u00e3o.\n\nConv\u00e9m, contudo, observar que a especializa\u00e7\u00e3o da modelagem no EBR acaba por depender\n\ndo paradigma subjacente em um grau que impede uma an\u00e1lise separada desses elementos. Dessa\n\nforma, o detalhamento da modelagem se dar\u00e1 pela descri\u00e7\u00e3o da forma cl\u00e1ssica de representa\u00e7\u00e3o\n\nde EBRs em fun\u00e7\u00e3o da manipula\u00e7\u00e3o expl\u00edcita de entidades representando atividades e recursos na\n\nse\u00e7\u00e3o 3.1.1 e por uma caracteriza\u00e7\u00e3o alternativa atrav\u00e9s de vari\u00e1veis de intervalo que representam\n\nindiretamente os conceitos de atividade e recurso na se\u00e7\u00e3o 3.1.2. Al\u00e9m disso, \u00e9 importante observar\n\nque a nota\u00e7\u00e3o adotada a seguir representa uma s\u00edntese dos conceitos por parte do autor e n\u00e3o guarda\n\ncorrespond\u00eancia exata com aquela encontrada na literatura. Entretanto, no caso da se\u00e7\u00e3o 3.1.2,\n\nh\u00e1 uma grande correspond\u00eancia ? ainda que n\u00e3o de todo precisa ? com a nota\u00e7\u00e3o da linguagem\n\nOPL devido ao fato da origem dessa modalidade estar associada ao pr\u00f3prio desenvolvimento da\n\nlinguagem.\n\n3.1.1 Caracteriza\u00e7\u00e3o por Atividades e Recursos\n\nA caracteriza\u00e7\u00e3o de PSRs do EBR por meio de rela\u00e7\u00f5es expl\u00edcitas entre as propriedades de\n\natividades e recursos permitiu que os mecanismos de resolu\u00e7\u00e3o se especializassem com um benef\u00edcio\n\ntang\u00edvel de desempenho. Ela \u00e9 adotada por refer\u00eancias centrais na literatura como Baptiste et al.\n\n(2001) e Baptiste et al. (2006). Al\u00e9m disso, \u00e9 empregada de modo direto na abordagem a problemas\n\nde escalonamento utilizando a linguagem Comet, de acordo com o manual da Dynadec (2009). E\n\nainda que n\u00e3o seja explicitamente adotada na linguagem OPL conforme o manual da IBM (2010),\n\nas representa\u00e7\u00f5es empregadas encerram correspond\u00eancia su?ciente para que os mesmos mecanismos\n\nde propaga\u00e7\u00e3o sejam utilizados nesse caso. Dessa forma, a caracteriza\u00e7\u00e3o por atividades e recursos\n\npersiste como dominante na literatura e a caracteriza\u00e7\u00e3o por vari\u00e1veis de intervalo ? tratada na\n\nse\u00e7\u00e3o 3.1.2 ? presta-se como uma representa\u00e7\u00e3o mais generalista mas ainda capaz de se bene?ciar\n\ndos desenvolvimentos voltados \u00e0 estrutura descrita na presente se\u00e7\u00e3o.\n\n\n\n3.1 MODELAGEM E PARADIGMAS DESCRITIVOS 43\n\nCaracteriza\u00e7\u00e3o do Conjunto de Atividades\n\nVisto que a modelagem dos recursos interessa somente \u00e0 medida em que limitam a execu\u00e7\u00e3o\n\ndas atividades, estas constituem o principal objeto de interesse no EBR. Cada atividade ai ? A\npode ter como propriedades a data de libera\u00e7\u00e3o2 dli a partir da qual pode ser executada, a data de\n\nlimite de conclus\u00e3o3 dci em que deve ter sido conclu\u00edda e o tempo de processamento a plena capa-\n\ncidade tpi que determina o esfor\u00e7o necess\u00e1rio \u00e0 sua realiza\u00e7\u00e3o. Quanto \u00e0 tipologia das atividades,\n\n\u00e9 poss\u00edvel caracterizar um problema de escalonamento em n\u00edveis crescentes de generaliza\u00e7\u00e3o como\n\nn\u00e3o-preemptivo, preemptivo ou el\u00e1stico em fun\u00e7\u00e3o da natureza de suas atividades e de sua rela\u00e7\u00e3o\n\ncom as propriedades descritas:\n\n? Atividade n\u00e3o-preemptiva Uma atividade n\u00e3o-preemptiva ai deve ser realizada de maneira\n\nininterrupta a partir de seu in\u00edcio. Dessa forma, ela pode ser caracterizada pelo par de vari\u00e1veis\n\ndiscretas inicio(ai) e fim(ai) representando, respectivamente, os instantes de in\u00edcio e ?m de\n\nai tais que:\n\ninicio(ai) ? dli (3.1)\n\nfim(ai) ? dci (3.2)\n\nfim(ai) ? inicio(ai) = tpi (3.3)\n\n? Atividade preemptiva Uma atividade preemptiva ai pode ser realizada de maneira intermi-\n\ntente. Dessa forma, \u00e9 poss\u00edvel caracteriz\u00e1-la pelo conjunto IF(ai) = {{inicioj(ai); fimj(ai)} :\nj ? [1,rodadas(ai)]} representando os pares de in\u00edcio e ?m das rodadas necess\u00e1rias \u00e0 execu\u00e7\u00e3o\nde ai tal que:\n\ninicioj(ai) &lt;fimj(ai), j ? [1,rodadas(ai)] (3.4)\n\nfimj?1(ai) ? inicioj(ai), j ? [1,rodadas(ai) ? 1] (3.5)\n\ninicio1(ai) ? dli (3.6)\n\nfimrodadas(ai)(ai) ? dci (3.7)\n\nrodadas(ai)?\nj=1\n\n(fimj(ai) ? inicioj(ai)) = tpi (3.8)\n\n? Atividade el\u00e1stica Uma atividade el\u00e1stica ai pode ser realizada a n\u00edveis vari\u00e1veis de in-\n\ntensidade, de forma que o tempo de execu\u00e7\u00e3o difere do tempo de processamento em raz\u00e3o\n\ndessa variabilidade. \u00c9 poss\u00edvel caracteriz\u00e1-la pelo conjunto IFP(ai) = {{inicioj(ai); fimj(ai);\nprodutividadej(ai)} : j ? [1,rodadas(ai)]} representando os trios de in\u00edcio, ?m e produtivi-\ndade das rodadas necess\u00e1rias \u00e0 execu\u00e7\u00e3o de ai. Ele difere da caracteriza\u00e7\u00e3o de IF(ai) apenas\n\n2Denominada release date em ingl\u00eas.\n3Denominada deadline em ingl\u00eas.\n\n\n\n44 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.1\n\nna \u00faltima rela\u00e7\u00e3o:\n\nrodadas(ai)?\nj=1\n\n(fimj(ai) ? inicioj(ai)) ?produtividadej(ai) = tpi (3.9)\n\nConv\u00e9m observar que cada vari\u00e1vel produtividadej(ai) representa uma fra\u00e7\u00e3o no intervalo\n\nreal (0, 1], algo que pode parecer contradit\u00f3rio com a manipula\u00e7\u00e3o de dom\u00ednios discretos e\n\n?nitos em PSRs. Contudo, os valores atribu\u00eddos a cada uma dessas vari\u00e1veis depende da forma\n\ncom que cada rodada expropria n\u00edveis discretos da capacidade dos recursos empregados em\n\nsua execu\u00e7\u00e3o ? conforme descrito adiante. Dessa forma, os n\u00edveis de produtividade de cada\n\nrodada n\u00e3o variam arbitrariamente, mas em parti\u00e7\u00f5es discretas da capacidade dos recursos\n\ndos quais dependem. Em \u00faltima an\u00e1lise, essas vari\u00e1veis n\u00e3o representam decis\u00f5es em si, mas\n\nsim propriedades advindas das decis\u00f5es discretas que determinam cada solu\u00e7\u00e3o poss\u00edvel.\n\nAl\u00e9m dessa tipologia de atividades, em alguns casos \u00e9 necess\u00e1rio ponderar pela ocorr\u00eancia ou n\u00e3o\n\nde cada atividade ai tida como opcional por meio de uma vari\u00e1vel booleana adicional ocorrencia(ai).\n\nE tanto esta quanto as outras propriedades das atividades podem ser empregadas para a de?ni\u00e7\u00e3o\n\nde restri\u00e7\u00f5es entre entidades distintas. Portanto, o n\u00edvel de generaliza\u00e7\u00e3o necess\u00e1rio a duas caracte-\n\nr\u00edsticas das atividades do conjunto A leva a seis possibilidades de classi?ca\u00e7\u00e3o para cada problema\n\nde escalonamento ? interessando-nos classi?car cada um no n\u00edvel mais espec\u00ed?co poss\u00edvel para o\n\nbenef\u00edcio de uma resolu\u00e7\u00e3o mais e?ciente.\n\nCaracteriza\u00e7\u00e3o do Conjunto de Recursos\n\nConforme observado anteriormente, a aloca\u00e7\u00e3o de uma atividade a um recurso interessa \u00e0 mo-\n\ndelagem na medida em que reduz a possibilidade de execu\u00e7\u00e3o de outras atividades. Essa aloca\u00e7\u00e3o\n\ntanto pode ser de?nida a priori quanto decidida a partir de um conjunto de recursos dispon\u00edveis em\n\nque cada um possa satisfazer \u00e0 necessidade da atividade, sendo poss\u00edvel que uma atividade dependa\n\nde diferentes recursos por diferentes crit\u00e9rios. As limita\u00e7\u00f5es dos recursos dizem respeito aos seus\n\nestados e capacidades.\n\nEstado dos recursos A cada recurso rj podem ser atribu\u00eddos diversos tipos de estado. Sendo ek\num desses tipos e Ek o conjunto de estados poss\u00edveis a esse tipo, \u00e9 poss\u00edvel expressar a necessidade de\n\nque uma atividade ai dependa do estado ek ? Ek atribu\u00eddo ao tipo de estado ek do recurso rj durante\nsua execu\u00e7\u00e3o por meio da restri\u00e7\u00e3o ek(rj,ai) = ek. Por meio do estabelecimento dessa restri\u00e7\u00e3o,\n\nevita-se que um mesmo recurso seja empregado simultaneamente por atividades que exijam estados\n\ndiferentes de um mesmo tipo ? o que torna seus per\u00edodos de execu\u00e7\u00e3o mutuamente excludentes.\n\nNo caso em que mais de um recurso possa satisfazer a exig\u00eancia de uma determinada atividade, a\n\nrestri\u00e7\u00e3o pode ser generalizada como sendo ek(Ri,ai) = ek para um conjunto Ri ? R de recursos\nque possam satisfazer \u00e0 demanda da atividade ai. Nesse caso, ao menos um recurso rj ? Ri deve\nsatisfazer a restri\u00e7\u00e3o ek(rj,ai) = ek para que a restri\u00e7\u00e3o ek(Ri,ai) = ek seja satisfeita. Al\u00e9m da\n\nexclusividade temporal de diferentes estados limitarem o uso do um recurso, a transi\u00e7\u00e3o entre\n\nesses estados pode tomar tempo e incorrer em custos \u00e0 solu\u00e7\u00e3o. Para representar essa situa\u00e7\u00e3o,\n\n\u00e0 declara\u00e7\u00e3o de um tipo de estado ek pode estar associada a uma fun\u00e7\u00e3o de tempo de transi\u00e7\u00e3o\n\nt : Ek\u00d7Ek ? N que mapeia cada transi\u00e7\u00e3o poss\u00edvel entre estados do tipo ek. De forma similar e para\n\n\n\n3.1 MODELAGEM E PARADIGMAS DESCRITIVOS 45\n\nefeito na fun\u00e7\u00e3o objetivo, \u00e9 poss\u00edvel de?nir uma fun\u00e7\u00e3o de custo de transi\u00e7\u00e3o c : Ek \u00d7Ek ? R. De\ncerta forma, no entanto, o mapeamento e a consequente restri\u00e7\u00e3o de estados possibilita um controle\n\nno modelo que acaba por ser mais qualitativo do que quantitativo por n\u00e3o impedir a concorr\u00eancia\n\nde uma quantidade arbitr\u00e1ria de atividades com mesma con?gura\u00e7\u00e3o de estados no recurso.\n\nCapacidade dos recursos Para um controle quantitativo mais apurado da concorr\u00eancia nos\n\nrecursos, a modelagem deve focar a capacidade em vez do estado dos mesmos. A respeito da capaci-\n\ndade, os recursos podem ser de?nidos gradativamente como disjuntivos, cumulativos ou reservat\u00f3rios\n\nem raz\u00e3o do limite de concorr\u00eancia de atividades:\n\n? Recurso disjuntivo Um recurso disjuntivo pode ser usado por apenas uma atividade por vez.\n\nPara um recurso rj e uma atividade ai, a restri\u00e7\u00e3o capacidade(rj) = 1 de?ne essa limita\u00e7\u00e3o\n\nunit\u00e1ria de concorr\u00eancia no recurso; e a restri\u00e7\u00e3o demanda(rj,ai) = 1 ou demanda(Ri,ai) = 1\n\nque a atividade ai exige o emprego em car\u00e1ter temporal exclusivo do recurso rj ou algum\n\nrecurso de Ri, respectivamente.\n\n? Recurso cumulativo Um recurso cumulativo pode ter mais de uma atividade sendo realizada\n\nao mesmo tempo, sendo que diferentes atividades podem exigir diferentes n\u00edveis de capacidade\n\ndo recurso. Nesse caso, o controle de concorr\u00eancia em um recurso rj \u00e9 generalizado pela\n\nrestri\u00e7\u00e3o capacidade(rj) = kj para um valor de capacidade kj ? 1. O mesmo se opera no\ncaso da atividade: a restri\u00e7\u00e3o demanda(rj,ai) = kij de?ne um valor de capacidade kij ? 1\nrequerida \u00e0 execu\u00e7\u00e3o da atividade ai no recurso rj. Dessa forma, a concorr\u00eancia de atividades\n\nno recurso \u00e9 limitada pelo n\u00edvel de capacidade requerido pelas mesmas contra o n\u00edvel m\u00e1ximo\n\nposs\u00edvel ao recurso.\n\n? Recurso reservat\u00f3rio Um recurso reservat\u00f3rio representa uma generaliza\u00e7\u00e3o do conceito de\n\ncapacidade pela manipula\u00e7\u00e3o de um montante que varia em fun\u00e7\u00e3o de eventos das atividades\n\nassociadas ao recurso. Em vez de uma capacidade ?xa do recurso rj e uma demanda simult\u00e2nea\n\n\u00e0 execu\u00e7\u00e3o de uma atividade ai, de?ne-se a capacidade como uma fun\u00e7\u00e3o capacidade(rj) : T ?\nN sobre o dom\u00ednio temporal T . Essa fun\u00e7\u00e3o varia a partir de um valor de capacidade inicial\ncapacidade0(rj) em decorr\u00eancia de acr\u00e9scimos ou decr\u00e9scimos de unidades de capacidade pelas\n\nrestri\u00e7\u00f5es producao(rj, t) = ki e consumo(rj, t) = ki, respectivamente, para uma quantia\n\nde ki unidades de varia\u00e7\u00e3o e t = inicio(ai) ou t = fim(ai) para alguma atividade ai. A\n\npartir dessa formaliza\u00e7\u00e3o, o valor de capacidade(rj) pode ser restrito a um determinado valor\n\nem um dado instante ou em todo o seu dom\u00ednio. Por exemplo, podemos de?nir a restri\u00e7\u00e3o\n\ncapacidade(rj) ? Mj para limitar superiormente a capacidade do recurso rj em Mj unidades\na todo instante.\n\nCom rela\u00e7\u00e3o \u00e0 forma de execu\u00e7\u00e3o, a contempla\u00e7\u00e3o de atividades el\u00e1sticas pode levar ao uso de quan-\n\ntidades fracion\u00e1rias da capacidade dos recursos. Entretanto, essa possibilidade n\u00e3o ser\u00e1 explorada\n\nexplicitamente devido ao prop\u00f3sito meramente introdut\u00f3rio do texto.\n\nLimites \u00e0 Caracteriza\u00e7\u00e3o por Atividades e Recursos\n\nUma das di?culdades do emprego dessa nota\u00e7\u00e3o expl\u00edcita envolvendo atividade e recursos de-\n\ncorre da combina\u00e7\u00e3o de possibilidades descritas anteriormente. Por exemplo, um recurso pode ter\n\n\n\n46 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.1\n\numa rela\u00e7\u00e3o de estado e capacidade com uma atividade, que por sua vez pode ou n\u00e3o ter sua\n\nexecu\u00e7\u00e3o dividida em rodadas. Isso se torna bem claro no caso do manual da Dynadec (2009):\n\ncontemplar todas as combina\u00e7\u00f5es poss\u00edveis leva a uma listagem bastante extensa de possibilidades.\n\nEm decorr\u00eancia desse tipo de limita\u00e7\u00e3o que di?culta um emprego elegante dessas rela\u00e7\u00f5es, a seguir\n\ndiscutimos a representa\u00e7\u00e3o por vari\u00e1veis de intervalo.\n\n3.1.2 Caracteriza\u00e7\u00e3o por Vari\u00e1veis de Intervalo\n\nA representa\u00e7\u00e3o de modelos de EBR por vari\u00e1veis de intervalo foi introduzida por\n\nLaborie e Rogerie (2008) como uma alternativa de modelagem que privilegia a representa\u00e7\u00e3o de\n\natividades opcionais, mesmo em problemas em que elas n\u00e3o ocorreriam explicitamente. Essa repre-\n\nsenta\u00e7\u00e3o parte do trabalho iniciado por Laborie (2003b), que estendeu problemas envolvendo apenas\n\na rela\u00e7\u00e3o entre vari\u00e1veis temporais tratada por Vilain et al. (1990) para a inclus\u00e3o de peculiarida-\n\ndes de recursos nos modelos. Em muitos aspectos, o intervalo corresponde em suas propriedades \u00e0\n\nno\u00e7\u00e3o previamente de?nida de atividade. Entretanto, ele difere na forma de manipula\u00e7\u00e3o ao ponto\n\nde tamb\u00e9m poder caracterizar recursos em alguns casos. Isso se explica pelo est\u00edmulo ao emprego\n\ncorriqueiro de intervalos opcionais por ser poss\u00edvel representar explicitamente cada combina\u00e7\u00e3o de\n\naloca\u00e7\u00e3o de uma atividade a um recurso por uma vari\u00e1vel distinta, de forma que as especi?cidades\n\nde cada combina\u00e7\u00e3o de aloca\u00e7\u00e3o possam ser tratadas separadamente. E naqueles pontos em que\n\ntal correspond\u00eancia entre intervalos e atividades ou recursos n\u00e3o seja poss\u00edvel, elementos adicio-\n\nnais foram propostos por Laborie et al. (2009) para complementa\u00e7\u00e3o. O benef\u00edcio alegado para essa\n\nabordagem consiste na facilidade de modelar uma gama maior de problemas de escalonamento e\n\nna consequente possibilidade de realizar uma propaga\u00e7\u00e3o mais e?ciente sobre as restri\u00e7\u00f5es estabe-\n\nlecidas. Dessa forma, a representa\u00e7\u00e3o por vari\u00e1veis intervalares se apresenta como uma alternativa\n\nde modelagem t\u00e3o desvencilhada quanto poss\u00edvel da caracteriza\u00e7\u00e3o convencional por atividades e\n\nrecursos sem, contudo, deixar de se bene?ciar dos mecanismos de resolu\u00e7\u00e3o pr\u00e9-existentes.\n\nPropriedades das Vari\u00e1veis de Intervalo\n\nPara uma introdu\u00e7\u00e3o aos pontos mais relevantes da formula\u00e7\u00e3o por vari\u00e1veis de intervalo, con-\n\nsideremos o conjunto V = {v1, . . . ,vn} de vari\u00e1veis intervalares. Cada vari\u00e1vel intervalar vi repre-\nsenta uma organiza\u00e7\u00e3o estruturada de decis\u00f5es interdependentes. Algumas delas s\u00e3o de?nidas a\n\npartir de propriedades an\u00e1logas \u00e0quelas que caracterizam atividades, como inicio(vi), fim(vi) e\n\nocorrencia(vi); al\u00e9m da propriedade duracao(vi) = fim(vi) ? inicio(vi), explicitada como forma\nde controlar diretamente o tempo de dura\u00e7\u00e3o e intensi?car a propaga\u00e7\u00e3o entre as vari\u00e1veis consti-\n\ntuintes do intervalo. Dessa forma, de?ne-se que uma vari\u00e1vel de intervalo vi representa um evento\n\nprogramado se o predicado ocorrencia(vi) for satisfeito, e sua extens\u00e3o temporal \u00e9 representada\n\npelo intervalo [inicio(vi),fim(vi)).\n\nRestri\u00e7\u00f5es entre Vari\u00e1veis de Intervalo\n\nDe acordo com Laborie e Rogerie (2008), as propriedades previamente elencadas j\u00e1 permitem\n\nestabelecer uma estrutura de propaga\u00e7\u00e3o local. Essa estrutura se d\u00e1 tanto em termos de restri\u00e7\u00f5es\n\nl\u00f3gicas relativas \u00e0 ocorr\u00eancia quanto de restri\u00e7\u00f5es temporais envolvendo as propriedades de in\u00edcio ou\n\n?m, ambas estabelecidas entre pares de vari\u00e1veis intervalares distintas. No caso de restri\u00e7\u00f5es l\u00f3gicas,\n\n\n\n3.1 MODELAGEM E PARADIGMAS DESCRITIVOS 47\n\ntemos restri\u00e7\u00f5es como ocorrencia(vi1 ) ? \u00acocorrencia(vi2 ), que estabelecem rela\u00e7\u00f5es diretas entre\nos dom\u00ednios booleanos de ocorr\u00eancia das vari\u00e1veis. No caso de restri\u00e7\u00f5es temporais, temos restri\u00e7\u00f5es\n\ncomo fim(vi1 )+ki1i2 ? inicio(vi2 ), que estabelecem rela\u00e7\u00f5es entre pares de propriedades de vari\u00e1veis\ndistintas.\n\nPara o caso de interdepend\u00eancias envolvendo uma quantidade arbitr\u00e1ria de vari\u00e1veis intervalares,\n\nalgumas restri\u00e7\u00f5es globais podem ser empregadas para estabelecer uma hierarquia entre as decis\u00f5es\n\ndo modelo. Para uma vari\u00e1vel de intervalo vi e um conjunto de vari\u00e1veis intervalares V\n? ? V\\{vi},\n\ntemos os seguintes exemplos:\n\n? span4 A restri\u00e7\u00e3o span(vi,V\n?) de?ne que a ocorr\u00eancia de vi est\u00e1 condicionada \u00e0 ocorr\u00eancia\n\nde ao menos uma vari\u00e1vel v? ? V ?; e que o in\u00edcio e o ?m de vi coincidem, respectivamente,\ncom o menor e o maior valor de in\u00edcio e ?m de alguma vari\u00e1vel do conjunto V ?. Dito de outra\n\nforma, temos as seguintes rela\u00e7\u00f5es:\n\nocorrencia(vi) ? (?v? ? V ? : ocorrencia(v?)) (3.10)\n\nocorrencia(vi) ? [(inicio(vi) ? inicio(v?) ?v? ? V ?) ? (?v? ? V ? : inicio(v?) = inicio(vi))]\n(3.11)\n\nocorrencia(vi) ? [(fim(vi) ? fim(v?) ?v? ? V ?) ? (?v? ? V ? : fim(v?) = fim(vi))] (3.12)\n\n? alternative A restri\u00e7\u00e3o alternative(vi,V\n?) de?ne que apenas uma vari\u00e1vel v? ? V ? pode\n\nocorrer e que seus valores coincidem com os de vi. Isso pode ser expresso compactamente pela\n\nseguinte rela\u00e7\u00e3o:\n\nocorrencia(vi) ? [?v? ? V ? : ocorrencia(v?)?(\u00acocorrencia(v??) ?v?? ? V ?\\{v?})?span(vi,{v?})]\n(3.13)\n\nEstruturas Complementares \u00e0s Vari\u00e1veis de Intervalo\n\nO mapeamento de outras caracter\u00edsticas dos recursos \u00e9 feito por meio de elementos complemen-\n\ntares de?nidos a partir de vari\u00e1veis de intervalo. Entre esses elementos, encontram-se sequ\u00eancias,\n\nfun\u00e7\u00f5es cumulativas e fun\u00e7\u00f5es de estado.\n\nSequ\u00eancia Uma sequ\u00eancia representa uma permuta\u00e7\u00e3o de um conjunto de vari\u00e1veis de intervalo.\n\nDe modo mais espec\u00ed?co, seja s uma vari\u00e1vel de sequ\u00eancia sobre um conjunto Vs de vari\u00e1veis\n\nintervalares, ent\u00e3o seu dom\u00ednio \u00e9 de?nido como sendo todas as poss\u00edveis fun\u00e7\u00f5es bijetoras ? : Vs ?\n[1, |Vs|], cada uma estabelecendo um sequenciamento distinto das vari\u00e1veis pertencentes a Vs. Em\nprimeira inst\u00e2ncia, sequ\u00eancias interessam \u00e0 modelagem pela possibilidade de estabelecer a restri\u00e7\u00e3o\n\nno-overlap(s), que impede a sobreposi\u00e7\u00e3o de intervalos e for\u00e7a sua ocorr\u00eancia na ordem de sequ\u00eancia\n\n4Ao contr\u00e1rio de outras terminologias, a nomenclatura de restri\u00e7\u00f5es globais difundidas na literatura como alldif-\nferent, span, alternative, always-in, always-nostate e always-constant foi preservada em ingl\u00eas ao longo do texto para\nevitar a cria\u00e7\u00e3o de termos desnecess\u00e1rios e que possam di?cultar a consulta \u00e0 literatura.\n\n\n\n48 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.2\n\ndas vari\u00e1veis. Opcionalmente, a restri\u00e7\u00e3o pode ser estabelecida pela sintaxe no-overlap(s,t) para\n\numa fun\u00e7\u00e3o de tempo de transi\u00e7\u00e3o t : Vs \u00d7 Vs ? N que de?ne o tempo m\u00ednimo entre o ?m e o\nin\u00edcio de intervalos consecutivos na sequ\u00eancia determinada. Formalmente, essa \u00faltima de?ni\u00e7\u00e3o da\n\nrestri\u00e7\u00e3o corresponde ao seguinte conjunto de rela\u00e7\u00f5es:\n\nfim(vi) + t(vi,vj) ? inicio(vj) ?vi,vj ? Vs : ?(vi) &lt;?(vj) (3.14)\n\nDessa forma, sequ\u00eancias correspondem \u00e0 representa\u00e7\u00e3o de recursos disjuntivos na caracteriza\u00e7\u00e3o\n\npor vari\u00e1veis de intervalo.\n\nFun\u00e7\u00e3o cumulativa Uma fun\u00e7\u00e3o cumulativa representa uma quantia discreta que varia ao longo\n\ndo tempo em fun\u00e7\u00e3o de eventos relacionados \u00e0s vari\u00e1veis de intervalo. Dessa forma, com base em\n\num dom\u00ednio temporal T , ela pode ser representada por uma fun\u00e7\u00e3o f : T ? N. A varia\u00e7\u00e3o no\nvalor de f se d\u00e1 em n\u00edveis discretos, i.e., por ?saltos? instant\u00e2neos decorrentes de acr\u00e9scimos ou\n\ndecr\u00e9scimos da quantia representada por meio de coe?cientes associados aos eventos de in\u00edcio e/ou\n\n?m de determinadas vari\u00e1veis intervalares. A natureza dessa varia\u00e7\u00e3o pode ser de duas formas\n\nelementares ? por degrau ou pulso:\n\n? Fun\u00e7\u00e3o degrau O termo degrau(t,k) representa uma fun\u00e7\u00e3o com valor 0 no dom\u00ednio (??, t)\ne valor k no dom\u00ednio [t, +?), sendo t = inicio(vi) ou t = fim(vi) para alguma vari\u00e1vel de\nintervalo vi.\n\n? Fun\u00e7\u00e3o pulso O termo pulso(t1, t2,k) representa uma fun\u00e7\u00e3o com valor 0 no dom\u00ednio\n\n(??, t1), valor k no dom\u00ednio [t1, t2) e valor 0 no dom\u00ednio [t2, +?), sendo t1 = inicio(vi)\ne t2 = fim(vi) para alguma vari\u00e1vel de intervalo vi.\n\nA partir desses termos, \u00e9 poss\u00edvel de?nir fun\u00e7\u00f5es cumulativas compostas como f =\n\ndegrau(inicio(v1), 1) ? degrau(fim(v2), 1). E sobre essas fun\u00e7\u00f5es, \u00e9 poss\u00edvel estabelecer restri-\n\u00e7\u00f5es gerais de valor, como f ? 0; ou restri\u00e7\u00f5es espec\u00ed?cas ao dom\u00ednio sobre um intervalo, como\nalways-in(f,v1, 0, 1), que restringe o valor da fun\u00e7\u00e3o f durante a ocorr\u00eancia do intervalo v1 aos\n\nvalores no dom\u00ednio [0, 1]. Ainda \u00e9 poss\u00edvel que a varia\u00e7\u00e3o dos termos elementares se d\u00ea por uma\n\nvari\u00e1vel inteira em vez de uma constante. Dessa forma, por meio de fun\u00e7\u00f5es cumulativas \u00e9 poss\u00edvel\n\nrepresentar desde recursos disjuntivos at\u00e9 recursos reservat\u00f3rios.\n\nFun\u00e7\u00e3o de estado De maneira an\u00e1loga \u00e0 caracteriza\u00e7\u00e3o de estado para recursos na se\u00e7\u00e3o 3.1.1,\n\na fun\u00e7\u00e3o de estado representa um equivalente qualitativo das fun\u00e7\u00f5es cumulativas. Dessa forma,\n\na de?ni\u00e7\u00e3o da fun\u00e7\u00e3o de estado difere da fun\u00e7\u00e3o cumulativa por n\u00e3o explicitar uma composi\u00e7\u00e3o.\n\nNo m\u00e1ximo, ela admite uma fun\u00e7\u00e3o de transi\u00e7\u00e3o para estabelecer o tempo m\u00ednimo entre estados\n\nconsecutivos. Assim sendo, a varia\u00e7\u00e3o dos estados \u00e9 completamente determinada pela imposi\u00e7\u00e3o de\n\nrestri\u00e7\u00f5es tanto da forma always-in como de outras similares: always-nostate(f,vi) para estabelecer\n\nque a fun\u00e7\u00e3o f n\u00e3o est\u00e1 de?nida durante a ocorr\u00eancia do intervalo de vi, always-constant(f,vi)\n\npara estabelecer que a fun\u00e7\u00e3o f n\u00e3o varie de estado a despeito de qual ele seja durante o intervalo\n\nde vi etc. A despeito do estado acabar por ser representado por uma quantidade, o que importa\n\nna modelagem por fun\u00e7\u00f5es de estado \u00e9 que o dom\u00ednio seja discreto e a representa\u00e7\u00e3o por valores\n\ninteiros atende a esse crit\u00e9rio. Em suma, a fun\u00e7\u00e3o de estado acaba por exercer papel similar \u00e0s\n\npropriedades de estado do recurso.\n\n\n\n3.2 ELEMENTOS COMPLEMENTARES DE RESOLU\u00c7\u00c3O 49\n\n3.2 Elementos Complementares de Resolu\u00e7\u00e3o\n\nA resolu\u00e7\u00e3o de problemas no EBR costuma apresentar algumas peculiaridades que o diferem\n\ndo que foi apresentado anteriormente para o caso geral da PR. Enquanto que a PR gen\u00e9rica tem\n\numa aplica\u00e7\u00e3o mais e?caz no caso de problemas com dom\u00ednios reduzidos, o mesmo n\u00e3o pode ser\n\ndito dos problemas do EBR em raz\u00e3o do tamanho dos dom\u00ednios temporais geralmente envolvidos.\n\nNaquele caso, a situa\u00e7\u00e3o \u00e9 prop\u00edcia para que a propaga\u00e7\u00e3o possa operar com impacto signi?cativo na\n\nredu\u00e7\u00e3o do espa\u00e7o de busca e que a rami?ca\u00e7\u00e3o por parti\u00e7\u00e3o dos dom\u00ednios seja e?caz em explorar as\n\npossibilidades remanescentes. No presente caso, n\u00e3o se espera uma redu\u00e7\u00e3o signi?cativa de dom\u00ednios\n\ntemporais em raz\u00e3o de seu tamanho e da baixa restritividade. Por consequ\u00eancia, o esfor\u00e7o necess\u00e1rio\n\n\u00e0 garantia de que todas as redu\u00e7\u00f5es poss\u00edveis foram obtidas passa a ser question\u00e1vel. Isso re?ete\n\nem duas decis\u00f5es de projeto importantes no caso do EBR:\n\n? a rami?ca\u00e7\u00e3o n\u00e3o se d\u00e1 por parti\u00e7\u00e3o de dom\u00ednios temporais, mas pela ordena\u00e7\u00e3o relativa entre\n\nas vari\u00e1veis temporais, de forma que a posi\u00e7\u00e3o absoluta seja determinada de acordo com a\n\nfun\u00e7\u00e3o objetivo;\n\n? os algoritmos de ?ltragem s\u00e3o projetados visando e?ci\u00eancia para reduzir ao m\u00e1ximo o espa\u00e7o\n\nde busca na primeira aplica\u00e7\u00e3o, nem sempre sendo aplicados repetidamente para convergir a\n\num ponto ?xo de consist\u00eancia.\n\nEssas decis\u00f5es de projeto estabelecem uma via dupla entre propaga\u00e7\u00e3o e busca que torna funda-\n\nmental analisar esses elementos de modo integrado. A forma diversa de rami?ca\u00e7\u00e3o da busca acaba\n\npor impactar na forma com que a propaga\u00e7\u00e3o opera para prover suporte, pois \u00e9 mais ben\u00e9?co que\n\nexista um alinhamento entre a forma que o espa\u00e7o de busca \u00e9 explorado e que a propaga\u00e7\u00e3o opera\n\npara reduzi-lo. E o mesmo se d\u00e1 no sentido inverso: se limitada, a forma com que a propaga\u00e7\u00e3o\n\nopera deve atentar \u00e0s rami?ca\u00e7\u00f5es que a busca provavelmente far\u00e1 na sequ\u00eancia para torn\u00e1-la mais\n\ne?caz. Dessa forma, considerar a propaga\u00e7\u00e3o e a busca de forma integrada no caso do EBR \u00e9 fun-\n\ndamental em raz\u00e3o das especi?cidades que foram observadas e das escolhas pertinentes ao projeto\n\ndos resolvedores que elas causaram.\n\nA apresenta\u00e7\u00e3o que se segue descreve mecanismos de propaga\u00e7\u00e3o relacionando-os \u00e0 busca. Em\n\nraz\u00e3o da variedade de tipos de algoritmos de propaga\u00e7\u00e3o e de busca, o detalhamento considera\n\napenas alguns dos mais elementares ou mais amplamente aceitos de acordo com refer\u00eancias como\n\nBaptiste et al. (2001), Laborie (2003a), Baptiste et al. (2006) e Vil\u00edm (2007). O tratamento ter\u00e1\n\num foco muito maior na propaga\u00e7\u00e3o do que na busca em decorr\u00eancia da relativa abund\u00e2ncia de\n\nabordagens e da consolida\u00e7\u00e3o da teoria relativa ao primeiro desses elementos, o que evidencia seu\n\ngrau de import\u00e2ncia na resolu\u00e7\u00e3o. Dessa forma, as considera\u00e7\u00f5es ?nais sobre a busca contemplam\n\napenas o que \u00e9 alheio \u00e0 propaga\u00e7\u00e3o.\n\n3.2.1 Propaga\u00e7\u00e3o\n\nA propaga\u00e7\u00e3o de restri\u00e7\u00f5es no escalonamento ? sobretudo aquela envolvendo restri\u00e7\u00f5es globais ?\n\nrepresenta uma das \u00e1reas de maior estudo no desenvolvimento de procedimentos de resolu\u00e7\u00e3o para\n\no EBR. Por um lado, existem estruturas entre pares de vari\u00e1veis que podem ser aproveitadas em\n\nmecanismos de propaga\u00e7\u00e3o localizada por meio de algoritmos de ?ltragem bastante e?cientes. Por\n\noutro lado, restri\u00e7\u00f5es globais emergem com facilidade nos modelos e a propaga\u00e7\u00e3o sobre estruturas\n\n\n\n50 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.2\n\ncom maior interdepend\u00eancia \u00e9 sempre prefer\u00edvel devido ao maior poder de redu\u00e7\u00e3o do espa\u00e7o de\n\nbusca. De modo semelhante aos n\u00edveis de consist\u00eancia para restri\u00e7\u00f5es gen\u00e9ricas, restri\u00e7\u00f5es globais\n\nde escalonamento possuem tipos variados de consist\u00eancia ? mas n\u00e3o necessariamente com alguma\n\nrela\u00e7\u00e3o de n\u00edvel estabelecida entre si. Dessa forma, incorre um questionamento ainda mais amplo que\n\nno caso geral da PR sobre a de?ni\u00e7\u00e3o dos melhores tipos de consist\u00eancia e algoritmos de ?ltragem\n\nassociados.\n\nPropaga\u00e7\u00e3o Local\n\nA propaga\u00e7\u00e3o localizada em problemas de escalonamento opera sobre redes booleanas e tem-\n\nporais ? as primeiras relativas \u00e0s vari\u00e1veis de ocorr\u00eancia de determinados eventos e as segundas\n\nrelativas \u00e0s restri\u00e7\u00f5es entre o in\u00edcio e o ?m de eventos distintos. Essas redes correspondem a grafos\n\norientados restringindo de modo conjugado o dom\u00ednio das vari\u00e1veis associadas. A respeito da con-\n\nsist\u00eancia completa nessas redes, \u00e9 observado por Laborie e Rogerie (2008) que ela pode ser obtida\n\ne?cientemente em modelos bin\u00e1rios se isolado cada caso, mas certas formas de integra\u00e7\u00e3o dos dois\n\ntipos \u00e9 su?ciente para tornar o tipo de problema resultante NP-Completo.\n\nRedes booleanas O caso mais simples de PSR consiste naquele em que o dom\u00ednio das vari\u00e1veis\n\n\u00e9 bin\u00e1rio, sendo denominado de problema de satisfabilidade ou simplesmente SAT. Quando as\n\nrela\u00e7\u00f5es se limitam apenas a pares de vari\u00e1veis, temos um 2-SAT. O 2-SAT pode ser resolvido\n\ne?cientemente pela constru\u00e7\u00e3o de um grafo em que cada v\u00e9rtice representa uma atribui\u00e7\u00e3o de um\n\nvalor a uma vari\u00e1vel e cada aresta uma restri\u00e7\u00e3o pela combina\u00e7\u00e3o de atribui\u00e7\u00f5es que n\u00e3o podem\n\nocorrer simultaneamente; de forma que o problema n\u00e3o possui solu\u00e7\u00e3o se, e somente se, houver\n\num caminho entre os v\u00e9rtices das duas atribui\u00e7\u00f5es poss\u00edveis a uma vari\u00e1vel ? o que acarreta uma\n\ncontradi\u00e7\u00e3o l\u00f3gica. Quando as rela\u00e7\u00f5es incluem um n\u00famero maior de vari\u00e1veis, Cormen et al. (2002)\n\nobserva que \u00e9 sempre poss\u00edvel reduzi-lo a um 3-SAT ? i.e., a um problema de dom\u00ednios bin\u00e1rios\n\nenvolvendo restri\u00e7\u00f5es entre at\u00e9 3 vari\u00e1veis. De qualquer forma, ele j\u00e1 se torna um problema NP-\n\nCompleto no caso geral. No entanto, algumas refer\u00eancias apontam que a decomposi\u00e7\u00e3o de restri\u00e7\u00f5es\n\nem rela\u00e7\u00f5es booleanas ainda sim pode ser proveitosa. Por exemplo, Brafman (2001) aponta que a\n\ndecomposi\u00e7\u00e3o de alguns problemas de planejamento em rela\u00e7\u00f5es booleanas leva a modelos nos quais\n\na maior parte das restri\u00e7\u00f5es envolve at\u00e9 duas vari\u00e1veis. Por essa raz\u00e3o, Brafman (2001) explora o\n\ndesenvolvimento de mecanismos de propaga\u00e7\u00e3o que simpli?quem as restri\u00e7\u00f5es n\u00e3o-bin\u00e1rias restantes\n\npara torn\u00e1-las menores em tamanho e quantidade, de forma que seja vi\u00e1vel que a busca opere por\n\n?tentativa-e-erro? na rami?ca\u00e7\u00e3o das vari\u00e1veis envolvidas nas restri\u00e7\u00f5es remanescentes desse tipo.\n\nRedes temporais A propaga\u00e7\u00e3o isolada em redes temporais consegue obter frequentemente a\n\nconsist\u00eancia completa da rede de modo e?ciente devido a premissas observadas na manipula\u00e7\u00e3o de\n\nmarcas de tempo no EBR. Conforme evidencia Baptiste et al. (2006), uma das caracter\u00edsticas mais\n\npeculiares da propaga\u00e7\u00e3o em redes temporais \u00e9 que ela opera sobre os limites do dom\u00ednio e n\u00e3o\n\nsobre cada valor do mesmo. Dois fatores pesam em favor dessa decis\u00e3o de projeto:\n\n? dom\u00ednios temporais costumam ser muito maiores do que aqueles em que a consist\u00eancia sobre\n\ncada valor \u00e9 aplicada, di?cultando a aplica\u00e7\u00e3o desse tipo de algoritmo de ?ltragem;\n\n? boa parte das restri\u00e7\u00f5es empregadas entre vari\u00e1veis temporais invalida as fronteiras do dom\u00ednio\n\ne n\u00e3o pontos espec\u00ed?cos em seu interior, de forma que o esfor\u00e7o necess\u00e1rio para contemplar a\n\n\n\n3.2 ELEMENTOS COMPLEMENTARES DE RESOLU\u00c7\u00c3O 51\n\nremo\u00e7\u00e3o de valores individuais internos em dom\u00ednios que s\u00e3o notadamente amplos acaba por\n\nn\u00e3o compensar.\n\nAl\u00e9m disso, outro aspecto que caracteriza os algoritmos de ?ltragem em redes temporais \u00e9 o fato de\n\nque a rela\u00e7\u00e3o entre vari\u00e1veis temporais costuma ser bin\u00e1ria por expressar o posicionamento relativo\n\nentre determinados eventos. Dessa forma, \u00e9 poss\u00edvel representar, com relativa precis\u00e3o, uma rede\n\nde rela\u00e7\u00f5es temporais atrav\u00e9s do Problema Temporal Simples (PTS)5.\n\nO PTS consiste em um conjunto de vari\u00e1veis temporais X = {x1, . . . ,xn} associadas, respecti-\nvamente, ao conjunto de dom\u00ednios cont\u00ednuos D = {[li1, ls1], . . . , [lin, lsn]} delimitando inferior e su-\nperiormente cada vari\u00e1vel e um conjunto de restri\u00e7\u00f5es entre pares de vari\u00e1veis R = {ri1i2 (xi1,xi2 ) ?\n(ai1i2 ? xi1 ? xi2 ? bi1i2 ),xi1 ? X,xi2 ? X} que estabelece limites superiores e inferiores para a\ndiferen\u00e7a entre o valor de alguns pares de vari\u00e1veis temporais em X. A vantagem dessa represen-\n\nta\u00e7\u00e3o se deve \u00e0 proposi\u00e7\u00e3o de ?ltragem do PTS por meio de algoritmos para caminhos de custo\n\nm\u00ednimo por Cesta e Oddi (1996), visto que as restri\u00e7\u00f5es em R possibilitam estabelecer o menor e o\n\nmaior tempo de aloca\u00e7\u00e3o de qualquer vari\u00e1vel xi ? X atrav\u00e9s de duas aplica\u00e7\u00f5es daquele algoritmo.\nNa primeira aplica\u00e7\u00e3o, obt\u00e9m-se o tempo m\u00ednimo de aloca\u00e7\u00e3o de cada vari\u00e1vel xi como sendo a\n\ndist\u00e2ncia m\u00ednima da origem ao v\u00e9rtice que a representa a partir de um grafo com uma origem ?ct\u00edcia\n\nno tempo 0, custo da aresta entre essa origem ?ct\u00edcia e o v\u00e9rtice de cada vari\u00e1vel xi dado pelos\n\nlimite inferior de dom\u00ednio lii, e custo da aresta entre v\u00e9rtices cujas vari\u00e1veis possuem uma restri\u00e7\u00e3o\n\nri1i2 dado em um sentido como ai1i2 e no outro sentido como bi1i2. Na segunda aplica\u00e7\u00e3o, o tempo\n\nm\u00e1ximo de aloca\u00e7\u00e3o de cada vari\u00e1vel xi \u00e9 obtido como a nega\u00e7\u00e3o da dist\u00e2ncia m\u00ednima entre o v\u00e9rtice\n\nrepresentante e um destino ?ct\u00edcio no tempo 0, sendo o custo da aresta entre o destino e o v\u00e9rtice de\n\ncada vari\u00e1vel vi dado pela nega\u00e7\u00e3o do limite superior, ?lsi, e o custo da aresta entre v\u00e9rtices cujas\nvari\u00e1veis possuem uma restri\u00e7\u00e3o ri1i2 dado em um sentido como ?ai1i2 e no outro sentido como\n?bi1i2. Por ?m, sendo mantida a representa\u00e7\u00e3o que gerou os novos limitantes, \u00e9 poss\u00edvel atualizar\nesses limites com base em decis\u00f5es de rami?ca\u00e7\u00e3o ao longo do processo de busca.\n\nPropaga\u00e7\u00e3o Global\n\nA propaga\u00e7\u00e3o global no EBR costuma depender, direta ou indiretamente, da ordena\u00e7\u00e3o relativa\n\ndas vari\u00e1veis temporais e nem sempre se opera de forma completa. O primeiro desses fatores decorre\n\nem parte do motivo j\u00e1 discutido pelo qual a propaga\u00e7\u00e3o temporal se d\u00e1 apenas nos limites do\n\ndom\u00ednio: a dimens\u00e3o dos dom\u00ednios \u00e9 relativamente maior e a determina\u00e7\u00e3o dos limites \u00e9 mais\n\nsigni?cativa do que a elimina\u00e7\u00e3o de valores espec\u00ed?cos. Al\u00e9m disso, Laborie (2003a) destaca que\n\na frequ\u00eancia com que restri\u00e7\u00f5es de preced\u00eancia temporal ocorrem em modelos de EBR torna sua\n\nmanipula\u00e7\u00e3o fundamental \u00e0 obten\u00e7\u00e3o de um melhor desempenho na resolu\u00e7\u00e3o. No entanto, essa\n\ntend\u00eancia foi se estabelecendo de maneira gradativa: primeiro pela de?ni\u00e7\u00e3o de tipos de consist\u00eancia\n\na partir de hip\u00f3teses de ordena\u00e7\u00e3o das vari\u00e1veis e depois pela manipula\u00e7\u00e3o expl\u00edcita dessa ordena\u00e7\u00e3o.\n\nCom rela\u00e7\u00e3o ao segundo fator, a amplitude dos dom\u00ednios tamb\u00e9m representa um argumento contra\n\na converg\u00eancia da consist\u00eancia a ponto ?xo, i.e., a aplica\u00e7\u00e3o repetitiva dos algoritmos de ?ltragem\n\npara garantir a consist\u00eancia de?nida, que pode ser necess\u00e1ria se uma modi?ca\u00e7\u00e3o de dom\u00ednio induzir\n\noutras modi?ca\u00e7\u00e3o para aquele n\u00edvel de consist\u00eancia. Conforme elencado no princ\u00edpio da se\u00e7\u00e3o 3.2,\n\numa vez que essas redu\u00e7\u00f5es v\u00e3o se tornando cada vez menos signi?cativas e que o espa\u00e7o de busca\n\n5Denominado Simple Temporal Problem (STP) em ingl\u00eas.\n\n\n\n52 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.2\n\n\u00e9 muito amplo, vale mais \u00e0 pena direcionar a propaga\u00e7\u00e3o em fun\u00e7\u00e3o do processo de busca e limitar\n\nsua execu\u00e7\u00e3o em raz\u00e3o do benef\u00edcio esperado. Dessa forma, a apresenta\u00e7\u00e3o de alguns dos tipos de\n\nconsist\u00eancia mais empregados e conhecidos feita a seguir segue o avan\u00e7o dessa tend\u00eancia ao longo\n\ndos anos, desde a veri?ca\u00e7\u00e3o completa de posi\u00e7\u00f5es absolutas no tempo at\u00e9 o emprego de veri?ca\u00e7\u00f5es\n\nincompletas e das rela\u00e7\u00f5es de preced\u00eancia como subs\u00eddio \u00e0 propaga\u00e7\u00e3o. A apresenta\u00e7\u00e3o \u00e9 organizada\n\ncom base em Laborie (2003a) e Baptiste et al. (2006), mas \u00e9 sintetizada pelo agrupamento de tipos\n\nsimilares de propaga\u00e7\u00e3o.\n\nPropaga\u00e7\u00e3o por tabela de tempos A tabela de tempos6 consiste na propaga\u00e7\u00e3o pela manipu-\n\nla\u00e7\u00e3o de dados absolutos sobre a utiliza\u00e7\u00e3o e disponibilidade dos recursos ao longo do tempo. Dessa\n\nforma, ela serve a uma propaga\u00e7\u00e3o da disponibilidade por duas vias: tanto de como a disponibili-\n\ndade do recurso impacta no dom\u00ednio de programa\u00e7\u00e3o da atividade quanto de como a programa\u00e7\u00e3o\n\nda atividade impacta na disponibilidade do recurso. A rela\u00e7\u00e3o a ser observada entre a aloca\u00e7\u00e3o dos\n\nrecursos e a programa\u00e7\u00e3o das atividades ao longo do tempo \u00e9 a seguinte:\n\n?\ni:inicio(ai)?t<fim(ai),i?[1,n]\n\ndemanda(rj,ai) ? capacidade(rj) ?t ? T,j ? [1,m] (3.15)\n\nPropaga\u00e7\u00e3o disjuntiva e energ\u00e9tica As modalidades de propaga\u00e7\u00e3o disjuntiva e energ\u00e9tica\n\ninferem redu\u00e7\u00f5es dos dom\u00ednios temporais a partir da constata\u00e7\u00e3o de impossibilidade de concorr\u00eancia\n\nentre um par de atividades por um determinado recurso.\n\n? Disjuntiva A propaga\u00e7\u00e3o disjuntiva representa o caso mais simples das duas, no qual a\n\nredu\u00e7\u00e3o de dom\u00ednios \u00e9 obtida pela infer\u00eancia de uma posi\u00e7\u00e3o relativa entre as atividades.\n\nDito de outra forma, uma atividade deve ser conclu\u00edda antes do in\u00edcio da outra para qualquer\n\npar de atividades (ai1,ai2 ) associadas a um mesmo recurso disjuntivo, conforme a seguinte\n\nrela\u00e7\u00e3o:\n\nDis(ai1,ai2 ) ? [fim(ai1 ) ? inicio(ai2 )] ? [fim(ai2 ) ? inicio(ai1 )] (3.16)\n\n? Energ\u00e9tica A propaga\u00e7\u00e3o energ\u00e9tica representa uma generaliza\u00e7\u00e3o desse conceito a partir de\n\ndemandas arbitr\u00e1rias para o caso do recurso ser cumulativo em vez de disjuntivo:\n\n[demanda(rj,ai1 ) + demanda(rj,ai2 ) ? capacidade(rj)]?\n\nDis(ai1,ai2 ) ?j ? [1,m], i1 e i2 ? [1,n], i1 6= i2\n(3.17)\n\nDessa forma, a propaga\u00e7\u00e3o disjuntiva corresponde ao caso no qual as demandas e a capacidade s\u00e3o\n\ntodas unit\u00e1rias.\n\nPropaga\u00e7\u00e3o por busca e aus\u00eancia de arestas Devido \u00e0 tend\u00eancia em manipular a ordena\u00e7\u00e3o\n\nrelativa das atividades na resolu\u00e7\u00e3o, uma das modalidades mais exploradas de propaga\u00e7\u00e3o consiste\n\nna an\u00e1lise dessa ordena\u00e7\u00e3o entre todas as atividades. Ela representa uma generaliza\u00e7\u00e3o do caso\n\nanterior pela manipula\u00e7\u00e3o de uma quantidade arbitr\u00e1ria de atividades por meio da de?ni\u00e7\u00e3o de\n\npropriedades an\u00e1logas \u00e0quelas de?nidas para cada atividade: para um conjunto de atividades ?,\n\nseja dl? = mini:ai??(dli) a data de libera\u00e7\u00e3o, dc? = maxi:ai??(dci) a data de limite de conclus\u00e3o e\n\n6Denominada timetable em ingl\u00eas.\n\n\n\n3.2 ELEMENTOS COMPLEMENTARES DE RESOLU\u00c7\u00c3O 53\n\ntp? =\n?\n\ni:ai??(tpi) o tempo de processamento a plena capacidade do conjunto de atividades ? ? A.\nTal ordena\u00e7\u00e3o conjunta pode ser vista como um grafo direcionado denominado grafo de preced\u00eancias,\n\nsendo cada atividade associada a um v\u00e9rtice e cada aresta orientada representando uma rela\u00e7\u00e3o de\n\npreced\u00eancia entre atividades cuja ordem relativa \u00e9 determinada. Para ?ns de nota\u00e7\u00e3o, as express\u00f5es\n\nai1 ? ai2 e ai2 ? ai1 denotam ambas que a atividade ai1 deve ser executada antes da atividade\nai2. Dessa representa\u00e7\u00e3o surgem duas modalidades comuns de propaga\u00e7\u00e3o:\n\n? Busca de arestas7 Na busca de arestas, o objetivo \u00e9 inferir novas arestas no grafo de prece-\n\nd\u00eancias a partir das janelas de execu\u00e7\u00e3o das atividades. Tal infer\u00eancia opera entre um conjunto\n\nde atividades ? e uma outra atividade ai /? ?, de forma a estabelecer se ai pode ou n\u00e3o ser a\nprimeira ou \u00faltima atividade a ser executada no conjunto ? ?{ai}. Nesse contexto, temos as\nseguintes rela\u00e7\u00f5es de infer\u00eancia poss\u00edveis entre as propriedades e a ordem relativa:\n\n?? ? A ?ai ? A\\ ? [dc??{ai} ?dl? &lt;tp? + tpi] ? [ai ? ?] (3.18)\n\n?? ? A ?ai ? A\\ ? [dc? ?dl??{ai} &lt;tp? + tpi] ? [ai ? ?] (3.19)\n\nNa primeira rela\u00e7\u00e3o, infere-se que ai precede as demais atividades em ? pela impossibilidade\n\nde principiar a execu\u00e7\u00e3o de ? ?{ai} com alguma atividade de ? e concluir antes da data\nlimite do conjunto ??{ai}. Na segunda rela\u00e7\u00e3o, infere-se que ai sucede as demais atividades\nem ? pela impossibilidade de concluir a execu\u00e7\u00e3o de ? ?{ai} com alguma atividade de ?\ndevido \u00e0 data limite do conjunto ? ?{ai}. No sentido inverso, a ?xa\u00e7\u00e3o de uma rela\u00e7\u00e3o de\nordem entre uma atividade e um conjunto reduz o dom\u00ednio de aloca\u00e7\u00e3o temporal da atividade\n\nde acordo com as seguintes rela\u00e7\u00f5es:\n\n?? ? A ?ai ? A\\ ? [ai ? ?] ? [fim(ai) ? min\n?6=????\n\n(dc?? ? tp??)] (3.20)\n\n?? ? A ?ai ? A\\ ? [ai ? ?] ? [inicio(ai) ? max\n?6=????\n\n(dl?? + tp??)] (3.21)\n\nA despeito da exist\u00eancia de O(n2n) pares do tipo (ai, ?) para |A| = n, Baptiste et al. (2006)\nobserva que existe uma rela\u00e7\u00e3o de domin\u00e2ncia de propaga\u00e7\u00e3o entre subconjuntos de A, de\n\nforma que n\u00e3o mais do que O(n2) dessas tuplas s\u00e3o necess\u00e1rias para garantir esse tipo de\n\npropaga\u00e7\u00e3o. O primeiro algoritmo de ?ltragem adotado para propaga\u00e7\u00e3o por busca de arestas\n\nem recursos disjuntivos foi extra\u00eddo dos cortes propostos por Carlier e Pinson (1994) para\n\nreduzir o tempo de resolu\u00e7\u00e3o do Problema de Escalonamento de Ch\u00e3o-de-F\u00e1brica (PEC) e\n\ntinha complexidade de tempo O(nlog(n)). Outros algoritmos foram propostos em sequ\u00eancia,\n\nnotadamente um de implementa\u00e7\u00e3o mais simples mas complexidade O(n2) por Baptiste et al.\n\n(2001) e outro de complexidade O(nlog(n)) ? por\u00e9m sem converg\u00eancia da consist\u00eancia a ponto\n\n?xo ? por Vil\u00edm (2007).\n\n? Aus\u00eancia de arestas8 A propaga\u00e7\u00e3o por aus\u00eancia de arestas representa uma generaliza\u00e7\u00e3o\n\nda busca de arestas pela infer\u00eancia reversa de quais atividades n\u00e3o podem ser a primeira ou a\n\n7Denominada edge-?nding em ingl\u00eas.\n8Denominada not-?rst / not-last em ingl\u00eas.\n\n\n\n54 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.2\n\n\u00faltima na execu\u00e7\u00e3o de um conjunto. Dessa forma, a infer\u00eancia de uma aresta posicionando uma\n\natividade ai com rela\u00e7\u00e3o a um conjunto de atividades ? na busca de arestas \u00e9 equivalente \u00e0\n\ninfer\u00eancia da aus\u00eancia de |?| poss\u00edveis arestas posicionando cada atividade a?i ? ? com rela\u00e7\u00e3o\nao conjunto ? ?{ai}. Apresentando um tempo maior de execu\u00e7\u00e3o, a redu\u00e7\u00e3o dos dom\u00ednios\nresultante desse tipo de propaga\u00e7\u00e3o domina a propaga\u00e7\u00e3o por busca de arestas. As redu\u00e7\u00f5es\n\ninferidas por esse tipo de propaga\u00e7\u00e3o s\u00e3o as seguintes:\n\n?? ? A ?ai ? A\\ ? [dci ?dl? &lt;tp? + tpi] ? [fim(ai) ? max\ni???\n\n(dci? ? tpi?)] (3.22)\n\n?? ? A ?ai ? A\\ ? [dc? ?dli &lt;tp? + tpi] ? [inicio(ai) ? min\ni???\n\n(dli? + tpi?)] (3.23)\n\nNo primeiro caso, infere-se que ai n\u00e3o pode ser a \u00faltima atividade a ser executada por n\u00e3o ser\n\nposs\u00edvel executar o conjunto ? ?{ai} entre o tempo de libera\u00e7\u00e3o dl? e o tempo de conclus\u00e3o\ndci, de forma que a conclus\u00e3o de ai deve preceder o in\u00edcio de execu\u00e7\u00e3o de ao menos uma\n\natividade de ?. No segundo caso, infere-se que ai n\u00e3o pode ser a primeira atividade a ser\n\nexecutada por n\u00e3o ser poss\u00edvel executar o conjunto ? ?{ai} entre o tempo de libera\u00e7\u00e3o dli\ne o tempo de conclus\u00e3o dc?, de forma que o in\u00edcio de ai deve suceder a conclus\u00e3o de ao\n\nmenos uma atividade de ?. Baptiste et al. (2006) e Vil\u00edm (2007) observam que os algoritmos\n\nde ?ltragem existentes relevantes a esse tipo de propaga\u00e7\u00e3o possuem complexidade de tempo\n\nO(n2) no pior caso.\n\nPreced\u00eancia energ\u00e9tica e balanceamento As modalidades de propaga\u00e7\u00e3o por preced\u00eancia\n\nenerg\u00e9tica e por balanceamento foram propostas por Laborie (2003a) como uma forma de valer-\n\nse explicitamente das preced\u00eancias entre atividades para obter uma redu\u00e7\u00e3o mais expressiva dos\n\ndom\u00ednios, em especial no caso em que os dom\u00ednios temporais das atividades s\u00e3o bastante folgados.\n\n? Preced\u00eancia energ\u00e9tica A propaga\u00e7\u00e3o por preced\u00eancia energ\u00e9tica infere a posterga\u00e7\u00e3o do\n\nin\u00edcio de uma atividade ai em raz\u00e3o da demanda pela capacidade de recursos de todas as\n\natividades que a precedam. Sendo esse conjunto de atividades precedentes a ai representado\n\ncomo ?, temos a seguinte rela\u00e7\u00e3o:\n\n[ai ? ?] ? [inicio(ai) ? dl? +\n?\n\ni?:ai???\n(demanda(rj,ai?) \u00d7 tpi?)\ncapacidade(rj)\n\n] ?j ? [1,m] (3.24)\n\nEla pode ser obtida por um algoritmo de ?ltragem apresentado em Laborie (2003a) em tempo\n\nO(n(p + log(n))) para um conjunto de n eventos de varia\u00e7\u00e3o da capacidade do recurso e at\u00e9\n\np preced\u00eancias para cada atividade.\n\n? Balanceamento A propaga\u00e7\u00e3o por balanceamento infere redu\u00e7\u00f5es do espa\u00e7o de busca pela\n\nestimativa de limites \u00e0 capacidade de um recurso reservat\u00f3rio ao longo do tempo em decorr\u00ean-\n\ncia das rela\u00e7\u00f5es da ordena\u00e7\u00e3o dos eventos associados. Esses limites s\u00e3o de?nidos sobre cada\n\nevento t = inicio(ai) ou t = fim(ai) de cada atividade ai ? A, e s\u00e3o de quatro tipos poss\u00edveis:\nL<min(t) para o menor valor de capacidade do recurso imediatamente antes da ocorr\u00eancia de\n\num evento t, L<max(t) para o maior valor nas mesmas circunst\u00e2ncias; e L\n>\nmin(t) e L\n\n>\nmax(t) para\n\nos respectivos valores equivalentes imediatamente ap\u00f3s a ocorr\u00eancia do evento t. Cada um\n\n\n\n3.2 ELEMENTOS COMPLEMENTARES DE RESOLU\u00c7\u00c3O 55\n\ndesses limites \u00e9 estipulado pelas combina\u00e7\u00f5es de maior e menor varia\u00e7\u00e3o de capacidade em\n\ndecorr\u00eancia dos eventos que alteram a capacidade do recurso e que podem ocorrer antes ou\n\ndepois de cada evento. Por meio dessas estimativas, torna-se poss\u00edvel promover quatro formas\n\nde propaga\u00e7\u00e3o:\n\n? descobrir antecipadamente que uma determinada con?gura\u00e7\u00e3o sendo constru\u00edda na re-\n\nsolu\u00e7\u00e3o n\u00e3o \u00e9 vi\u00e1vel pela car\u00eancia de capacidade no recurso;\n\n? deduzir limites mais restritos de capacidade dos recursos face \u00e0s possibilidades de pro-\n\ndu\u00e7\u00e3o e \u00e0s necessidades de consumo do reservat\u00f3rio;\n\n? reduzir o dom\u00ednio temporal dos eventos pela infer\u00eancia de que alguns eventos devem se\n\nposicionar antes ou ap\u00f3s determinado evento;\n\n? inferir novas rela\u00e7\u00f5es de preced\u00eancia entre os eventos quando o caso anterior se restringir\n\na uma rela\u00e7\u00e3o entre pares de eventos.\n\nO algoritmo de ?ltragem proposto por Laborie (2003a) para essa modalidade de propaga\u00e7\u00e3o\n\npossui complexidade de tempo O(n2) sem a infer\u00eancia de novas rela\u00e7\u00f5es de preced\u00eancia e\n\nO(n3) caso contr\u00e1rio. Por ?m, Laborie (2003a) sugere que as informa\u00e7\u00f5es sobre o balan\u00e7o\n\nenerg\u00e9tico sejam utilizadas como subs\u00eddio \u00e0s estrat\u00e9gias de rami?ca\u00e7\u00e3o do EBR.\n\n3.2.2 Busca\n\nConforme mencionado anteriormente, a estrutura\u00e7\u00e3o da busca no EBR ? sobretudo por recurs\u00e3o\n\ne retrocesso ? se d\u00e1 em torno dos mecanismos de propaga\u00e7\u00e3o empregados. De todo modo, os passos\n\ngerais da busca por recurs\u00e3o e retrocesso no EBR consistem nos seguintes segundo Baptiste et al.\n\n(2001):\n\n1. Selecionar um recurso no qual as atividades n\u00e3o est\u00e3o completamente ordenadas.\n\n2. Selecionar uma atividade para ser executada antes das demais no recurso; ?xar a rela\u00e7\u00e3o\n\nde preced\u00eancia entre ela e as demais; manter uma rela\u00e7\u00e3o das atividades restantes como\n\nsubstitutas no caso de retrocesso \u00e0 escolha da primeira atividade no recurso.\n\n3. Iterar sobre o passo anterior at\u00e9 que todas as atividades associadas estejam completamente\n\nordenadas no recurso.\n\n4. Iterar sobre os passos anteriores at\u00e9 que as atividades estejam completamente ordenadas em\n\ntodos os recursos.\n\nDessa forma, as estrat\u00e9gias de rami?ca\u00e7\u00e3o no EBR acabam por depender de heur\u00edsticas peculiares\n\na problemas de escalonamento para a ordena\u00e7\u00e3o de escolha dos recursos e das atividades durante\n\na resolu\u00e7\u00e3o. Decerto que essa escolha n\u00e3o \u00e9 completamente independente do tipo de propaga\u00e7\u00e3o\n\nsendo empregado, de forma que a variadas combina\u00e7\u00f5es de propaga\u00e7\u00e3o e busca competem estrat\u00e9gias\n\ndiversas. Portanto, as especi?cidades de cada modelo a ser resolvido podem determinar o emprego\n\nde combina\u00e7\u00f5es distintas.\n\nPor ?m, conv\u00e9m observar que o car\u00e1ter declarativo da PR corrobora a elabora\u00e7\u00e3o de algoritmos\n\nde busca estruturados de maneira diversa. Notadamente, um dos campos mais prof\u00edcuos foi o de\n\nbusca local. No resolvedor subjacente \u00e0 linguagem OPL, operadores de busca local para modi?car\n\n\n\n56 ESCALONAMENTO BASEADO EM RESTRI\u00c7\u00d5ES 3.2\n\nsolu\u00e7\u00f5es de problemas de escalonamento cumulativo foram propostas em Godard e Laborie (2005) e\n\nmecanismos adaptativos para a escolha dos operadores mais prop\u00edcios em cada rodada de resolu\u00e7\u00e3o\n\nforam estudados em Laborie e Godard (2007). No resolvedor subjacente \u00e0 linguagem Comet, o\n\nestudo descrito em Monette et al. (2009) revela um distanciamento de heur\u00edsticas especializadas em\n\nproblemas de escalonamento para a aplica\u00e7\u00e3o de meta-heur\u00edsticas mais prop\u00edcias a cada modelo em\n\nraz\u00e3o de sua estrutura. Em ambos os casos, evidencia-se a constata\u00e7\u00e3o de Dechter (2003) sobre o\n\nprop\u00f3sito de abordagens de busca local: resolver problemas com tamanho em ordens de grandeza\n\nmaiores do que seria poss\u00edvel de modo sistem\u00e1tico. Conv\u00e9m observar que essa linha de mecanismos\n\nadaptativos para a resolu\u00e7\u00e3o de EBRs seguida em ambos os casos j\u00e1 havia sido explorada por\n\noutros autores no \u00e2mbito estrito da academia, como Carchrae e Beck (2005). A abordagem de\n\nescolha automatizada condiz com uma linha em evid\u00eancia no ambiente acad\u00eamico em geral, para\n\na qual Smith-Miles (2008) prov\u00ea uma revis\u00e3o bastante ampla e Battiti et al. (2008) uma discuss\u00e3o\n\nsobre as principais decis\u00f5es de projeto envolvidas. Portanto, h\u00e1 um forte indicativo que essa linha\n\nde desenvolvimento persista por algum tempo para a resolu\u00e7\u00e3o de problemas por EBR.\n\n\n\nParte III\n\nESTUDO DE CASO\n\n57\n\n\n\n\n\nCap\u00edtulo 4\n\nO Problema da Programa\u00e7\u00e3o de\n\nRecursos Cr\u00edticos e Sua Abordagem\n\nRecursos cr\u00edticos como sondas e barcos lan\u00e7adores de linhas s\u00e3o utilizados nas etapas sequenciais\n\nde explora\u00e7\u00e3o, produ\u00e7\u00e3o e manuten\u00e7\u00e3o de po\u00e7os de petr\u00f3leo mar\u00edtimos. Informa\u00e7\u00f5es de uma etapa\n\ns\u00e3o necess\u00e1rias \u00e0s etapas seguintes, de forma que o desenvolvimento e a manuten\u00e7\u00e3o dos po\u00e7os de\n\num reservat\u00f3rio s\u00e3o projetados a partir dos dados obtidos na etapa de explora\u00e7\u00e3o. A explora\u00e7\u00e3o \u00e9\n\nrealizada em um conjunto de localiza\u00e7\u00f5es nas quais estudos geol\u00f3gicos preliminares identi?caram a\n\npossibilidade de que existam reservas de petr\u00f3leo e g\u00e1s em quantidade su?ciente para que a produ\u00e7\u00e3o\n\npossa ser comercialmente vi\u00e1vel. Uma vez con?rmada a exist\u00eancia da reserva por perfura\u00e7\u00f5es iniciais,\n\ns\u00e3o feitos planos para a perfura\u00e7\u00e3o de um conjunto de po\u00e7os cuja sequ\u00eancia de perfura\u00e7\u00e3o e entrada\n\nem produ\u00e7\u00e3o \u00e9 estipulada de forma a maximizar a extra\u00e7\u00e3o poss\u00edvel naquele reservat\u00f3rio. Alguns\n\npo\u00e7os s\u00e3o produtores e servem \u00e0 extra\u00e7\u00e3o de \u00f3leo e g\u00e1s do reservat\u00f3rio, enquanto outros s\u00e3o injetores\n\ne servem \u00e0 inser\u00e7\u00e3o de \u00e1gua ou g\u00e1s para manter a press\u00e3o de produ\u00e7\u00e3o do po\u00e7o. O estabelecimento de\n\ncada novo po\u00e7o envolve atividades de perfura\u00e7\u00e3o, completa\u00e7\u00e3o e interliga\u00e7\u00e3o. Ao ?nal da perfura\u00e7\u00e3o,\n\no po\u00e7o possui um revestimento externo de prote\u00e7\u00e3o e um duto interno para o escoamento de ?uidos.\n\nCom a completa\u00e7\u00e3o, instala-se um componente de controle de vaz\u00e3o na cabe\u00e7a do po\u00e7o conhecido\n\ncomo \u00c1rvore de Natal Molhada (ANM). Linhas s\u00e3o conectadas a cada ANM, interligando-as a\n\numa Unidade Estacion\u00e1ria de Produ\u00e7\u00e3o (UEP) na superf\u00edcie ou a um manifold intermedi\u00e1rio que\n\nconcentra o escoamento de v\u00e1rios po\u00e7os para reduzir o n\u00famero de linhas ligadas diretamente \u00e0\n\nUEP. Por ?m, atividades peri\u00f3dicas de manuten\u00e7\u00e3o s\u00e3o programadas em uma janela temporal\n\n?ex\u00edvel, de forma a manter a opera\u00e7\u00e3o dos po\u00e7os dentro dos patamares desej\u00e1veis. Dessa forma,\n\no emprego desses recursos cr\u00edticos atende a necessidades bastante distintas ao longo do ciclo de\n\nvida dos reservat\u00f3rios, sendo que a limita\u00e7\u00e3o em sua oferta impacta diretamente as opera\u00e7\u00f5es de\n\nprodu\u00e7\u00e3o da companhia.\n\nAs atividades a serem realizadas pelos recursos cr\u00edticos possuem prazos, rela\u00e7\u00f5es de preced\u00eancia\n\ne caracter\u00edsticas t\u00e9cnicas que devem ser obedecidas. Por exemplo, a profundidade na qual \u00e9 empre-\n\nendida uma atividade deve ser compat\u00edvel com a faixa de profundidades permitida \u00e0 opera\u00e7\u00e3o de\n\num dado recurso, enquanto que este deve possuir a bordo todos os equipamentos necess\u00e1rios \u00e0 exe-\n\ncu\u00e7\u00e3o daquela. Conforme observado no Cap\u00edtulo 1 e no par\u00e1grafo anterior, o n\u00edvel de detalhamento\n\ndessas atividades aumenta ao longo do ciclo de vida em raz\u00e3o das informa\u00e7\u00f5es previamente adqui-\n\nridas. Assim sendo, a programa\u00e7\u00e3o dos recursos cr\u00edticos para o desenvolvimento e a manuten\u00e7\u00e3o de\n\n59\n\n\n\n60 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.2\n\npo\u00e7os mar\u00edtimos possui diversas peculiaridades ignoradas quando se considera apenas a etapa de\n\nexplora\u00e7\u00e3o.\n\n4.1 Decis\u00f5es e Entidades Relacionadas\n\nA programa\u00e7\u00e3o de recursos cr\u00edticos na produ\u00e7\u00e3o pode ser vista como uma quest\u00e3o de decidir se,\n\nquando e como realizar cada uma dentre v\u00e1rias atividades valendo-se de um conjunto de sondas e\n\nbarcos. O tempo de programa\u00e7\u00e3o das atividades nos recursos \u00e9 discretizado em dias, a partir de uma\n\ndata inicial de?nida como 0. Cada atividade de desenvolvimento est\u00e1 associada a uma localidade\n\nconsistindo em um po\u00e7o mar\u00edtimo. Algumas atividades podem exigir a instala\u00e7\u00e3o de linhas que, por\n\nsua vez, devem ser carregadas previamente em um porto. Os carregamentos de linhas em portos\n\nrepresentam um dos tipos de atividade auxiliar necess\u00e1rias \u00e0 completa programa\u00e7\u00e3o do recurso.\n\nOutros eventos poderiam ser considerados como tipos de atividade auxiliar, como os per\u00edodos de\n\ndeslocamento e as manuten\u00e7\u00f5es programadas dos recursos. No entanto, a falta de liberdade sobre boa\n\nparte desses eventos em rela\u00e7\u00e3o aos demais faz com que eles n\u00e3o sejam considerados explicitamente\n\ncomo decis\u00f5es do problema mas apenas restri\u00e7\u00f5es \u00e0 ocorr\u00eancia dos restantes. Portanto, as principais\n\ndecis\u00f5es esperadas em uma solu\u00e7\u00e3o a este problema s\u00e3o as seguintes:\n\n? a aloca\u00e7\u00e3o de recursos a atividades de desenvolvimento;\n\n? a de?ni\u00e7\u00e3o do n\u00famero de cargas a serem associadas a cada recurso;\n\n? a associa\u00e7\u00e3o de linhas a cada carga;\n\n? a programa\u00e7\u00e3o temporal das atividades alocadas em cada recurso.\n\nPor conven\u00e7\u00e3o de nota\u00e7\u00e3o no detalhamento do problema, cada tipo de entidade principal em-\n\nprega um \u00edndice diferente a seguir. Recursos s\u00e3o representados pelo \u00edndice i, que varia entre 1 e nr.\n\nAtividades s\u00e3o representadas pelo \u00edndice j, que varia entre 1 e na, sendo as primeiras np atividades\n\nassociadas ao desenvolvimento de po\u00e7os e o restante a cargas em portos. Localidades s\u00e3o represen-\n\ntadas pelo \u00edndice k, que varia entre 1 e nlo, sejam elas po\u00e7os ou portos. Linhas s\u00e3o representadas\n\npelo \u00edndice l, que varia entre 1 e nl. Qualquer outro \u00edndice, quando necess\u00e1rio, ser\u00e1 representado\n\npor x.\n\nSendo o n\u00famero de atividades auxiliares de carga desconhecido, o valor de na \u00e9 indeterminado\n\na princ\u00edpio. Como forma de estabelecer um limite superior ?xo, emprega-se a rela\u00e7\u00e3o na = np + nl.\n\nEssa rela\u00e7\u00e3o contempla o caso extremo em que cada linha \u00e9 carregada separadamente das demais,\n\nde forma que cada atividade j ? [np + 1,np + nl] atende \u00e0s restri\u00e7\u00f5es necess\u00e1rias ao carregamento\nda linha l = j ?np. Dessa feita, uma das decis\u00f5es do problema passar a ser pela ocorr\u00eancia ou n\u00e3o\nde cada uma das na ?np atividades de carga resultantes.\n\n4.2 Crit\u00e9rios de Otimiza\u00e7\u00e3o\n\nO objetivo do problema da programa\u00e7\u00e3o de recursos cr\u00edticos \u00e9 antecipar ganhos e reduzir custos.\n\nNo presente caso, o objetivo prim\u00e1rio \u00e9 maximizar a produ\u00e7\u00e3o de curto prazo, de?nida como a\n\nquantidade que cada po\u00e7o ir\u00e1 produzir desde o dia em que \u00e9 conectado at\u00e9 uma data limite H.\n\nA cada atividade j \u00e9 associada uma taxa de produ\u00e7\u00e3o di\u00e1ria pj desde o dia em que \u00e9 conclu\u00edda,\n\n\n\n4.3 RESTRI\u00c7\u00d5ES DO PROBLEMA 61\n\nsendo n\u00e3o-nula somente quando for a atividade de conclus\u00e3o do desenvolvimento de um po\u00e7o. Assim\n\nsendo, atividades associadas a po\u00e7os com maior produ\u00e7\u00e3o acabam por ter prioridade na escala. No\n\nentanto, nem todas as atividades s\u00e3o conclu\u00eddas antes dessa data H e outras n\u00e3o possuem impacto\n\nna produ\u00e7\u00e3o independentemente do dia de conclus\u00e3o. Por essa raz\u00e3o, um crit\u00e9rio secund\u00e1rio \u00e9\n\nempregado: a minimiza\u00e7\u00e3o da soma dos tempos de conclus\u00e3o das atividades da solu\u00e7\u00e3o. Por meio\n\ndesse crit\u00e9rio de desempate, a conclus\u00e3o das atividades nos recursos \u00e9 antecipada e estes s\u00e3o liberados\n\no quanto antes. Apesar de fugir ao escopo do problema, essa antecipa\u00e7\u00e3o representa uma redu\u00e7\u00e3o\n\nde gastos no caso de recursos alugados ou uma maior disponibilidade futura para atividades ainda\n\nn\u00e3o previstas. Dessa forma, maximiza-se o retorno imediato associado ao emprego dos recursos\n\ndispon\u00edveis por meio de uma con?gura\u00e7\u00e3o que procura reduzir custos futuros.\n\n4.3 Restri\u00e7\u00f5es do Problema\n\n4.3.1 Restri\u00e7\u00f5es Gerais dos Recursos\n\n? Cada recurso pode realizar apenas uma atividade por vez.\n\n? Cada recurso i possui um per\u00edodo de contrato do dia ici at\u00e9 o dia fci, e n\u00e3o est\u00e1 dispon\u00edvel\n\nfora desse per\u00edodo.\n\n? Um recurso pode realizar apenas atividades que sejam compat\u00edveis com suas caracter\u00edsticas.\n\nTemos cij = 1 se, e somente se, o recurso i e a atividade j forem compat\u00edveis.\n\n? Durante o per\u00edodo de contrato, existem indisponibilidades previstas do recurso. Tais indispo-\n\nnibilidades representam per\u00edodos durante os quais nenhuma atividade pode ser realizada pelo\n\nrecurso. Para um recurso i, seja niri o n\u00famero de indisponibilidades associadas e o par (iirix,\n\nfirix) as respectivas datas de in\u00edcio e ?m da x-\u00e9sima indisponibilidade do recurso i.\n\n? Algumas indisponibilidades podem ser ?ex\u00edveis dentro de um intervalo em vez de comple-\n\ntamente pr\u00e9-determinadas, sendo dirix o tempo de dura\u00e7\u00e3o da x-\u00e9sima indisponibilidade do\n\nrecurso i, que deve ocorrer dentro do intervalo temporal [iirix, firix].\n\n? Certas indisponibilidades podem ser parciais, signi?cando uma restri\u00e7\u00e3o da capacidade do\n\nrecurso que impede a execu\u00e7\u00e3o de algumas, mas n\u00e3o de todas as atividades. Seja pirix = 1\n\nse, e somente se, a x-\u00e9sima indisponibilidade do recurso i for parcial e cirijx = 1 se, e so-\n\nmente se, a possibilidade de realiza\u00e7\u00e3o da atividade j no recurso i for afetada em raz\u00e3o da\n\nindisponibilidade x.\n\n? Apenas um recurso por vez pode operar sobre cada po\u00e7o.\n\n? Para que um recurso realize atividades consecutivas em localidades distintas, \u00e9 necess\u00e1rio\n\nconsiderar o tempo para mover o recurso de um lugar para o outro.\n\n? Alguns recursos n\u00e3o podem aproximar-se mais do que uma certa dist\u00e2ncia um do outro devido\n\nao risco de colis\u00e3o. No entanto, essa restri\u00e7\u00e3o n\u00e3o \u00e9 detalhada por falta de dados \u00e0 disposi\u00e7\u00e3o\n\npara teste.\n\n\n\n62 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.3\n\n4.3.2 Restri\u00e7\u00f5es Gerais de Execu\u00e7\u00e3o das Atividades\n\n? Cada atividade \u00e9 realizada ininterruptamente desde seu in\u00edcio at\u00e9 a conclus\u00e3o.\n\n? Cada atividade j possui datas pr\u00e9-de?nidas de in\u00edcio mais cedo e in\u00edcio mais tarde, represen-\n\ntadas por imcj e imtj.\n\n? Cada atividade j est\u00e1 relacionada a uma localidade locj.\n\n? Para cada atividade j que n\u00e3o de carregamento, a dura\u00e7\u00e3o \u00e9 ?xa e dada por dj .\n\n? Uma atividade pode ser precedida por outras, cada uma exigindo um tempo m\u00ednimo de\n\nintervalo entre a conclus\u00e3o de uma e o in\u00edcio da outra. Sem perda de generalidade, podemos\n\nde?nir prcj1j2 como o tempo m\u00ednimo entre a conclus\u00e3o da atividade j1 e o in\u00edcio da atividade\n\nj2, sendo prcj1j2 = ?? caso n\u00e3o exista uma rela\u00e7\u00e3o de preced\u00eancia entre j1 e j2.\n\n? Algumas atividades podem pertencer a um cluster, e todas as atividades de um cluster devem\n\nser realizadas por um mesmo recurso. Sem perda de generalidade, podemos supor que cada\n\natividade j est\u00e1 associada a um cluster de ind\u00edce clusterj, de forma que atividades pertencentes\n\na um mesmo cluster tenham valores iguais para esse \u00edndice e atividades que n\u00e3o pertencem a\n\nnenhum cluster tenham um valor \u00fanico.\n\n4.3.3 Restri\u00e7\u00f5es de Estoque dos Recursos\n\n? Todo recurso inicia suas atividades com estoque vazio.\n\n? Cada recurso i possui uma capacidade m\u00e1xima de estoque cei, que \u00e9 n\u00e3o-nula apenas para\n\nbarcos de carregamento.\n\n? Apenas recursos com capacidade de estoque positiva podem realizar atividades de carrega-\n\nmento nos portos.\n\n? Cada porto k pode receber at\u00e9 sk atividades de carregamento ao mesmo tempo.\n\n? Uma atividade de carregamento realizada por um recurso i dura de mici a maci dias.\n\n? O aumento do estoque de um recurso i devido a uma atividade de carregamento \u00e9 linearmente\n\nproporcional \u00e0 sua dura\u00e7\u00e3o, atingindo cei se durar maci dias.\n\n4.3.4 Restri\u00e7\u00f5es de Estoque das Atividades\n\n? Cada linha l est\u00e1 associada a uma atividade de conex\u00e3o cll, na qual a linha \u00e9 descarregada\n\ndo recurso.\n\n? Para realizar a atividade de conex\u00e3o de uma linha, o recurso precisa primeiramente realizar\n\na atividade de carregamento envolvendo a mesma linha.\n\n? Cada linha l possui peso pll para ?ns de impacto no estoque do recurso e pode ser carregada\n\nna base bll a partir de sua data de disponibiliza\u00e7\u00e3o dll.\n\n? Atividades de carregamento n\u00e3o est\u00e3o sujeitas a restri\u00e7\u00f5es de cluster ou preced\u00eancia.\n\n\n\n4.4 MODELAGEM POR VARI\u00c1VEIS DE INTERVALO 63\n\n? Uma atividade j de manuten\u00e7\u00e3o de linhas j\u00e1 instaladas pode exigir alguma capacidade dis-\n\npon\u00edvel cdj no recurso que a realizar.\n\n4.4 Modelagem por Vari\u00e1veis de Intervalo\n\nA abordagem de resolu\u00e7\u00e3o do problema apresentado como estudo de caso consiste em um mo-\n\ndelo de Escalonamento Baseado em Restri\u00e7\u00f5es (EBR) que emprega vari\u00e1veis de intervalo. Conforme\n\ndiscutido no Cap\u00edtulo 3, vari\u00e1veis intervalares representam uma abstra\u00e7\u00e3o para o agregado de de-\n\ncis\u00f5es interdependentes relacionado \u00e0 modelagem de problemas de escalonamento por meio de uma\n\nsintaxe que facilita a manipula\u00e7\u00e3o de eventos opcionais. Tal manipula\u00e7\u00e3o se d\u00e1 atrav\u00e9s de estruturas\n\nhier\u00e1rquicas, como \u00e9 o caso da rela\u00e7\u00e3o entre uma determinada tarefa e todas as possibilidades de\n\nrealiza\u00e7\u00e3o dessa tarefa por con?gura\u00e7\u00f5es distintas de uso dos recursos dispon\u00edveis. Sendo nosso foco\n\ndirigido \u00e0 concep\u00e7\u00e3o do modelo mais adequado \u00e0 resolu\u00e7\u00e3o do problema, enfatizamos as seguintes\n\ndiretrizes como orienta\u00e7\u00e3o \u00e0s diversas decis\u00f5es de projeto relativas ao desenvolvimento do modelo\n\nque se segue:\n\n? obter uma representa\u00e7\u00e3o do problema correta e compacta a partir da sintaxe de modelagem\n\n\u00e0 disposi\u00e7\u00e3o;\n\n? reduzir o espa\u00e7o de busca e intensi?car a propaga\u00e7\u00e3o decorrente da instancia\u00e7\u00e3o de cada\n\nvari\u00e1vel de decis\u00e3o;\n\n? prover diretivas a uma explora\u00e7\u00e3o mais e?ciente do espa\u00e7o de busca resultante do modelo.\n\nEssas quest\u00f5es s\u00e3o debatidas ao longo da descri\u00e7\u00e3o do modelo na presente se\u00e7\u00e3o. Na sequ\u00eancia, a\n\nse\u00e7\u00e3o 4.5 apresenta duas abordagens para estimar um limite superior ao valor \u00f3timo de produ\u00e7\u00e3o,\n\nde forma a analisar a qualidade das solu\u00e7\u00f5es obtidas.\n\nBoa parte das vari\u00e1veis de decis\u00e3o e restri\u00e7\u00f5es do problema de programa\u00e7\u00e3o de recursos cr\u00edticos\n\npode ser descrita atrav\u00e9s da sintaxe de vari\u00e1veis intervalares, para a qual Laborie e Rogerie (2008)\n\ne Laborie et al. (2009) propuseram tanto uma nota\u00e7\u00e3o alg\u00e9brica quanto gr\u00e1?ca. Na descri\u00e7\u00e3o que se\n\nsegue, as duas modalidades de nota\u00e7\u00e3o s\u00e3o adaptadas com a ?nalidade de facilitar a compreens\u00e3o\n\ndo modelo sendo descrito. Conv\u00e9m observar que a se\u00e7\u00e3o A.5 do ap\u00eandice apresenta a implementa-\n\n\u00e7\u00e3o desses conceitos por meio da linguagem OPL, e um exemplo menos detalhado de abordagem\n\nao problema \u00e9 apresentado na se\u00e7\u00e3o A.5.9. Pontos espec\u00ed?cos dessa parte do ap\u00eandice ser\u00e3o re-\n\nferenciados conforme necess\u00e1rio ao longo do texto. Al\u00e9m disso, ressaltamos que as representa\u00e7\u00f5es\n\ngr\u00e1?cas que complementam a descri\u00e7\u00e3o do modelo alg\u00e9brico n\u00e3o ilustram explicitamente todas as\n\nrela\u00e7\u00f5es poss\u00edveis entre as vari\u00e1veis do modelo ou os pormenores de cada um deles. A disposi\u00e7\u00e3o de\n\nilustra\u00e7\u00f5es buscou elucidar ao menos um exemplo de cada tipo de rela\u00e7\u00e3o do modelo e destacar os\n\nfatores mais relevantes a cada tipo de rela\u00e7\u00e3o como forma de transmitir visualmente a no\u00e7\u00e3o das\n\nhierarquias presentes no modelo.\n\n4.4.1 Associa\u00e7\u00e3o entre Atividades e Recursos\n\nCada atividade e cada recurso do problema \u00e9 representado por meio de um conjunto de vari\u00e1-\n\nveis de decis\u00e3o do modelo dispostos em vetores ou matrizes. A representa\u00e7\u00e3o mais elementar do\n\n\n\n64 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.4\n\nconjunto de atividades se d\u00e1 por meio do vetor de intervalos a, que cont\u00e9m uma vari\u00e1vel de inter-\n\nvalo associada a cada atividade do modelo, sendo as propriedades de cada vari\u00e1vel correspondentes\n\n\u00e0quelas da atividade em si. A implementa\u00e7\u00e3o desse conceito em OPL \u00e9 descrita na se\u00e7\u00e3o A.5.2 do\n\nap\u00eandice. Como as primeiras np atividades do problema referem-se ao desenvolvimento de po\u00e7os,\n\nsua ocorr\u00eancia \u00e9 compuls\u00f3ria e isso repercurte em uma restri\u00e7\u00e3o de obrigatoriedade dos respectivos\n\nintervalos:\n\nocorrencia(aj) = 1 ?j ? [1,np] . (4.1)\n\nA associa\u00e7\u00e3o entre atividades e recursos se d\u00e1 pela matriz de intervalos M, que representa o produto\n\ncartesiano dos conjuntos de recursos e atividades, de forma que cada vari\u00e1vel mij ? M representa o\nintervalo associado ao recurso i realizando a atividade j. O vetor a e a matrix M s\u00e3o relacionados\n\npor restri\u00e7\u00f5es alternative, cuja sintaxe em OPL \u00e9 descrita na se\u00e7\u00e3o A.5.4. Essa restri\u00e7\u00e3o associa\n\ncada entrada de um vetor a uma coluna da outra matriz1, de forma que no m\u00e1ximo um intervalo de\n\ncada coluna j de M ? representada por Mj ? ocorra e seus valores correspondem aos do intervalo\n\naj:\n\nalternative(aj,Mj) ?j ? [1,na] . (4.2)\n\nA representa\u00e7\u00e3o dos eventos associados a cada recurso se d\u00e1 pelo vetor de sequ\u00eancias r, sendo que\n\ncada sequ\u00eancia ri ? r agrupa as entradas de M associadas ao i-\u00e9simo recurso, ou seja, ri agrupa\nas entradas do vetor (MT )i. A representa\u00e7\u00e3o de sequ\u00eancias em OPL \u00e9 descrita na se\u00e7\u00e3o A.5.5.\n\nConsiderando cada sequ\u00eancia como um conjunto dos intervalos, temos o seguinte:\n\nri = {mij : j ? [1,nr]} . (4.3)\n\nDe forma a prevenir que um recurso seja associado a mais do que uma atividade ao mesmo tempo,\n\na restri\u00e7\u00e3o no-overlap \u00e9 associada a cada sequ\u00eancia ri ? r. Como argumento adicional, \u00e9 de?nida\numa fun\u00e7\u00e3o de tempo de transi\u00e7\u00e3o ti : [1,na] \u00d7 [1,na] ? N entre a conclus\u00e3o de um intervalo e o\nin\u00edcio de outro em fun\u00e7\u00e3o da localiza\u00e7\u00e3o das atividades associadas e do recurso em considera\u00e7\u00e3o:\n\nno-overlap(ri, ti) ?i ? [1,nr] . (4.4)\n\nA ?gura 4.1 apresenta os conceitos anteriormente descritos para modelar a associa\u00e7\u00e3o entre ativi-\n\ndades e recursos, al\u00e9m de um dos tipos de indisponibilidade descritos adiante.\n\nTanto nessa ?gura quanto nas demais que se seguem s\u00e3o adotadas algumas conven\u00e7\u00f5es de nota-\n\n\u00e7\u00e3o para facilitar a compreens\u00e3o do modelo. Vari\u00e1veis intervalares s\u00e3o apresentadas como ret\u00e2ngulos,\n\nsendo acinzentadas se sua presen\u00e7a \u00e9 obrigat\u00f3ria. Sequ\u00eancias s\u00e3o apresentadas como quadrados com\n\ncantos arredondados e fun\u00e7\u00f5es cumulativas como c\u00edrculos, tendo ambas uma linha diagonal no pre-\n\nenchimento interno. Restri\u00e7\u00f5es e composi\u00e7\u00f5es de sequ\u00eancias ou fun\u00e7\u00f5es s\u00e3o apresentadas por meio\n\nde setas, sendo rotuladas pela restri\u00e7\u00e3o ou regra de agrupamento que de?nem. O agrupamento de\n\nelementos \u00e9 feito por ret\u00e2ngulos mais espessos. Poss\u00edveis restri\u00e7\u00f5es entre intervalos de um deter-\n\nminado agrupamento s\u00e3o delimintadas por ret\u00e2ngulos pontilhados. Por ?m, conforme mencionado\n\nanteriormente, as restri\u00e7\u00f5es apresentadas gra?camente representam um tipo de cada e n\u00e3o todas\n\naquelas que existem no modelo.\n\n1 Por conven\u00e7\u00e3o de nota\u00e7\u00e3o, quando necess\u00e1rio, um vetor formado pela j-\u00e9sima coluna de M ser\u00e1 representado\ncomo Mj e um vetor formado pela i-\u00e9sima linha de M ser\u00e1 representado como (M\n\nT )i.\n\n\n\n4.4 MODELAGEM POR VARI\u00c1VEIS DE INTERVALO 65\n\n  \n\nmatriz de intervalos\nopcionais M\n\nvetor (transposto) de\nintervalos mistos a \n\nanp anp+1 anaa1\n\nm1nam11\n\nmnrnamnr1\n\nalternative vetor de \nsequ\u00eancias r\n\nno-overlap\nc/ transi\u00e7\u00e3o\n\nvetor (transposto) de \nfun\u00e7\u00f5es cumulativas u\n\nui=0 em indisponibilidades totais fixas\n\nui= ?\nj=1\n\nna\npulso(mij ,1)\n\nri={mij : j?[1 ,na]}\n\nFigura 4.1: Rela\u00e7\u00e3o elementar entre intervalos associados a atividades e recursos.\n\nA de?ni\u00e7\u00e3o dos dom\u00ednios temporais de programa\u00e7\u00e3o dos intervalos e dos dom\u00ednios booleanos\n\nde aloca\u00e7\u00e3o dos recursos \u00e9 feita sobre os elementos da matriz M. Essa escolha se deve \u00e0 maior\n\ne?c\u00e1cia de propagar da matriz M para o vetor a e do fato de tornar-se desnecess\u00e1rio o emprego de\n\nintervalos para representar a extens\u00e3o do contrato de cada recurso. A ocorr\u00eancia de cada intervalo\n\nmij depende da compatibilidade entre o recurso i e a atividade j, condicionado por cij = 1:\n\nocorrencia(mij) ? (cij = 1) ?i ? [1,nr],j ? [1,na] . (4.5)\n\nO in\u00edcio de cada intervalo mij de desenvolvimento est\u00e1 sujeito tanto ao in\u00edcio do contrato do recurso\n\nici quanto \u00e0 data de in\u00edcio mais cedo da atividade imcj:\n\nocorrencia(mij) ? [inicio(mij) ? MAX(ici, imcj)] ?i ? [1,nr],j ? [1,np] . (4.6)\n\nNo caso de atividades de carga, a correspond\u00eancia entre cada atividade j e a linha l = j ?np leva\n\u00e0 substitui\u00e7\u00e3o da data de in\u00edcio mais cedo pela data de disponibiliza\u00e7\u00e3o dll, de forma que temos a\n\nseguinte restri\u00e7\u00e3o para o in\u00edcio de cada carregamento:\n\nocorrencia(mij) ? [inicio(mij) ? MAX(ici,dlj?np )] ?i ? [1,nr],j ? [np + 1,na] . (4.7)\n\nDe forma similar, o ?m de cada intervalo mij de desenvolvimento est\u00e1 sujeito tanto ao ?m do\n\ncontrato do recurso fci quanto \u00e0 soma da data de in\u00edcio mais tarde imtj da atividade com a\n\ndura\u00e7\u00e3o dj da mesma:\n\nocorrencia(mij) ? [fim(mij) ? MIN(fci, imtj + dj)] ?i ? [1,nr],j ? [1,np] . (4.8)\n\nNo caso de atividades de carga, apenas o ?m do contrato do recurso \u00e9 levado em conta:\n\nocorrencia(mij) ? [fim(mij) ? fci ] ?i ? [1,nr],j ? [np + 1,na] . (4.9)\n\nPor sua vez, a dura\u00e7\u00e3o de cada intervalo mij associado a uma atividade de desenvolvimento \u00e9 ?xa\n\n\n\n66 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.4\n\nem dj e a dura\u00e7\u00e3o daqueles associados a atividades de carregamento varia entre os limites de tempo\n\nde carga mici e maci do recurso:\n\nocorrencia(mij) ? [duracao(mij) = dj] ?i ? [1,nr],j ? [1,np] . (4.10)\n\nocorrencia(mij) ? [mici ? duracao(mij) ? maci] ?i ? [1,nr],j ? [np + 1,na] . (4.11)\n\nPor ?m, as restri\u00e7\u00f5es de cluster s\u00e3o representadas por implica\u00e7\u00f5es l\u00f3gicas entre os elementos de M,\n\nde forma a for\u00e7ar a ocorr\u00eancia dos intervalos associados \u00e0s atividades de um cluster em uma \u00fanica\n\nlinha da matriz:\n\n[clusterj1 = clusterj2 ] ? [ocorrencia(mij1 ) ? ocorrencia(mij2 )] ?i ? [1,nr],j1 ? [1,np],j2 ? [1,np] .\n(4.12)\n\nA ?gura 4.2 ilustra as restri\u00e7\u00f5es b\u00e1sicas de dom\u00ednios temporais e de aloca\u00e7\u00e3o do modelo para as\n\natividades de desenvolvimento de po\u00e7os.\n\n  \n\nmatriz de intervalos\nopcionais M\n\nm1npm11\n\nmnrnpmnr1\n\nocorrencia(mij1\n)?ocorrencia(mij2\n\n)  em clusters\n\nocorrencia(mij)?(cij=1)\ninicio(mij)?MAX (ici ,imc j)\nfim(mij)?MIN ( fci ,imt j+d j)\n\nduracao(mij)=d j\n\nmij\n\nFigura 4.2: Restri\u00e7\u00e3o de dom\u00ednios temporais e de aloca\u00e7\u00e3o no desenvolvimento de po\u00e7os.\n\nPara representar a ocorr\u00eancia de indisponibilidades devidas \u00e0 manuten\u00e7\u00e3o dos recursos, estru-\n\nturas diversas s\u00e3o necess\u00e1rias em raz\u00e3o do grau de detalhamento de cada tipo poss\u00edvel como forma\n\nde garantir um melhor desempenho de resolu\u00e7\u00e3o nos casos mais simples. Para o caso de indisponi-\n\nbilidades totais, o uso de cada recurso i ao longo do tempo \u00e9 descrito pela fun\u00e7\u00e3o cumulativa ui do\n\nvetor u. O uso desse tipo de fun\u00e7\u00e3o na linguagem OPL \u00e9 descrita na se\u00e7\u00e3o A.5.7. Cada uma dessas\n\nfun\u00e7\u00f5es representa uma composi\u00e7\u00e3o de pulsos unit\u00e1rios de todos os intervalos de M associados ao\n\nmesmo recurso:\n\nui =\n\nna?\ni=1\n\npulso(mij, 1) ?i ? [1,nr] . (4.13)\n\nDessa forma, \u00e9 poss\u00edvel restringir o valor de ui a zero em per\u00edodos nos quais o recurso esteja em\n\nmanuten\u00e7\u00e3o total e ?xa atrav\u00e9s da restri\u00e7\u00e3o always-in, conforme ilustrado na ?gura 4.1:\n\n[dirix = (firix ? iirix) ?pirix 6= 1] ? always-in(ui, iirix,firix, 0, 0) ?i ? [1,nr],x ? [1,niri] .\n(4.14)\n\nA extens\u00e3o para o caso de indisponibilidades vari\u00e1veis no tempo \u00e9 feita pelo uso de uma matriz\n\nauxiliar de intervalos MI associada \u00e0 programa\u00e7\u00e3o temporal de cada um desses eventos delimitada\n\n\n\n4.4 MODELAGEM POR VARI\u00c1VEIS DE INTERVALO 67\n\nda seguinte forma:\n\nocorrencia(miix) ?i ? [1,nr],x ? [1,niri] . (4.15)\n\ninicio(miix) ? iirix ?i ? [1,nr],x ? [1,niri] . (4.16)\n\nfim(miix) ? firix ?i ? [1,nr],x ? [1,niri] . (4.17)\n\nduracao(miix) = dirix ?i ? [1,nr],x ? [1,niri] . (4.18)\n\nA partir das entradas de MI, \u00e9 poss\u00edvel estender a restri\u00e7\u00e3o anterior ao caso geral de indisponibi-\n\nlidades totais:\n\n[pirix 6= 1] ? always-in(ui,miix, 0, 0) ?i ? [1,nr],x ? [1,niri] . (4.19)\n\nA mesma estrutura poderia ser estendida para o caso de indisponibilidades parciais com o emprego\n\nde uma fun\u00e7\u00e3o cumulativa para cada conjunto distinto de atividades limitado por alguma indispo-\n\nnibilidade. No entanto, a modelagem adotada nesse caso considerou o emprego de sequ\u00eancias que\n\nagrupam cada intervalo de programa\u00e7\u00e3o de indisponibilidade com intervalos das atividades que s\u00e3o\n\nrespectivamente incompat\u00edveis com o mesmo. A composi\u00e7\u00e3o dessas sequ\u00eancias constitui a matriz\n\nMP , na qual cada elemento mpix consiste em uma sequ\u00eancia associada \u00e0 indisponibilidade x do\n\nrecurso i. Cada sequ\u00eancia mpix agrupa o intervalo de indisponibilidade miix e os intervalos de M\n\nassociados ao recurso i cuja compatibilidade \u00e9 afetada pela indisponibilidade x:\n\nmpix = {miix}?{mij : j ? [1,np] ? cij = 1 ? cirijx = 1} ?i ? [1,nr],x ? [1,niri] . (4.20)\n\nDessa forma, \u00e9 poss\u00edvel estabelecer a restri\u00e7\u00e3o de no-overlap sobre cada sequ\u00eancia de MP :\n\n[pirix = 1] ? no-overlap(mix) ?i ? [1,nr],x ? [1,niri] . (4.21)\n\nEssa escolha alternativa de modelagem para as indisponibilidades parciais se deu pela necessidade\n\nde uma propaga\u00e7\u00e3o dedicada \u00e0 interdepend\u00eancia entre o conjunto de intervalos envolvidos, algo\n\nque n\u00e3o se fazia t\u00e3o necess\u00e1rio no caso anterior devido \u00e0 redund\u00e2ncia decorrente da restri\u00e7\u00e3o de\n\nno-overlap sobre as sequ\u00eancias do vetor r e as fun\u00e7\u00f5es cumulativas do vetor u.\n\n4.4.2 Associa\u00e7\u00e3o entre Atividades e Localidades\n\nDe acordo com o limite de concorr\u00eancia, cada localidade do problema \u00e9 associada a uma sequ\u00ean-\n\ncia ou a uma fun\u00e7\u00e3o cumulativa, de forma a atender \u00e0s restri\u00e7\u00f5es do problema. Localidades re-\n\npresentando po\u00e7os s\u00e3o associadas a sequ\u00eancias do vetor p, enquanto que portos s\u00e3o associados a\n\nfun\u00e7\u00f5es cumulativas do vetor b.\n\nCada sequ\u00eancia pk ? p representa o conjunto de atividades associadas ao desenvolvimento de\num po\u00e7o identi?cado pela localidade k:\n\npk = {aj : j ? [1,np] ? locj = k} ?k ? [1,nlo] . (4.22)\n\n\n\n68 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.4\n\nDe forma a prevenir que duas atividades sejam programadas de modo concorrente em um po\u00e7o, a\n\nrestri\u00e7\u00e3o no-overlap \u00e9 estabelecida sobre cada sequ\u00eancia pk ? p:\n\nno-overlap(pk) ?k ? [1,nlo] . (4.23)\n\nPara modelar a restri\u00e7\u00e3o de dist\u00e2ncia de seguran\u00e7a entre recursos, a mesma l\u00f3gica poderia ser usada\n\npara estabelecer restri\u00e7\u00f5es sobre sequ\u00eancias representando atividades cuja execu\u00e7\u00e3o concorrente por\n\ndeterminados recursos n\u00e3o \u00e9 permitida.\n\nCada fun\u00e7\u00e3o cumulativa bk ? b representa o n\u00famero de cargas ocorrendo ao longo do tempo no\nporto identi?cado pela localidade k:\n\nbk =\n\nna?\ni=np+1\n\npulso(aj, 1) ?k ? [1,nlo] . (4.24)\n\nDessa forma, o controle de concorr\u00eancia em cada porto pode ser garantido pela seguinte restri\u00e7\u00e3o:\n\nbk ? sk ?k ? [1,nlo] . (4.25)\n\nPor ?m, \u00e9 comum que existam rela\u00e7\u00f5es de preced\u00eancia entre atividades relacionadas ao desenvol-\n\nvimento de um mesmo po\u00e7o, de forma que elas s\u00e3o descritas na presente se\u00e7\u00e3o em vez da anterior.\n\nElas s\u00e3o estabelecidas diretamente sobre os elementos do vetor a:\n\nfim(aj1 ) + prcj1j2 ? inicio(aj2 ) ?j1 ? [1,np],j2 ? [1,np] . (4.26)\n\nOs conceitos de associa\u00e7\u00e3o entre atividades e localidades no modelo s\u00e3o ilustrados na ?gura 4.3.\n\n  \n\nvetor (transposto) de\nIntervalos mistos a\n\nanp anp+1a1\n\npreced\u00eancias\n\nvetor (transposto) \nde sequ\u00eancias p\n\nno-overlap vetor (transposto) de \nfun\u00e7\u00f5es cumulativas b\n\npk={a j : j? [1,np] ?loc j=k} bk= ?\nj=np+1\n\nna\npulso(a j ,1)\n\nbk?sk\n\nana\n\nFigura 4.3: Rela\u00e7\u00e3o entre intervalos associados a atividades e suas respectivas localidades.\n\n4.4.3 Restri\u00e7\u00f5es de Estoque e Transporte de Linhas\n\nO controle do estoque a bordo de barcos \u00e9 feito por meio de fun\u00e7\u00f5es cumulativas do vetor l\n\ne das matrizes LB, CLB e DLB. Cada elemento lbik ? LB representa o estoque associado \u00e0s\nlinhas carregadas por um recurso i e um porto k, sendo de?nido como a diferen\u00e7a entre a fun\u00e7\u00e3o\n\ncumulativa clbik ? CLB relativa aos carregamentos realizados pelo recurso i no porto k e a fun\u00e7\u00e3o\ncumulativa dlbik ? DLB relativa aos descarregamentos equivalentes:\n\nclbik =\n\nna?\nj=np+1:locj =k\n\ndegrau(fim(mij,cei ?\nduracao(mij)\n\nmaci\n) ?i ? [1,nr],k ? [1,nlo] . (4.27)\n\n\n\n4.4 MODELAGEM POR VARI\u00c1VEIS DE INTERVALO 69\n\ndlbik =\n\nnl?\nl=1:bll=k\n\ndegrau(fim(mi cll,pll) ?i ? [1,nr],k ? [1,nlo] . (4.28)\n\nlbik = clbik ?dlbik ?i ? [1,nr],k ? [1,nlo] . (4.29)\n\nComo pode ser observado pelas rela\u00e7\u00f5es acima, a cada atividade de carga \u00e9 associado um acr\u00e9scimo\n\nde estoque proporcional \u00e0 sua dura\u00e7\u00e3o e capacidade de estoque mas inversamente proporcional\n\nao tempo necess\u00e1rio ao carregamento completo; e a cada atividade de descarga \u00e9 associado um\n\ndecr\u00e9scimo ?xo proporcional \u00e0 soma do peso das linhas que descarrega. O estoque no recurso i\n\n\u00e9 representado ao longo do tempo pela fun\u00e7\u00e3o cumulativa li ? l, que \u00e9 de?nida sobre cargas e\ndescargas associadas a cada porto k por meio da fun\u00e7\u00e3o cumulativa lbik ? LB e sobre estocagens\ntempor\u00e1rias associadas aos intervalos de (MT )i na forma de pulsos:\n\nli =\n\nnlo?\nk=1\n\nlbik +\n\nnp?\nj=1\n\npulso(mij,cdj) ?i ? [1,nr] . (4.30)\n\nA de?ni\u00e7\u00e3o separada da fun\u00e7\u00e3o de estoque associada \u00e0 carga em cada porto \u00e9 necess\u00e1ria para\n\nrestringir que o volume de origem em cada porto n\u00e3o seja descarregado em maior quantidade do\n\nque foi carregado:\n\nlbik ? 0 ?i ? [1,nr],k ? [1,nlo] . (4.31)\n\nPara completar o controle dos limites de estoque, resta a classe de restri\u00e7\u00f5es de estoque dos recursos\n\nem si ao longo do tempo, que atenta apenas ao limite a bordo devido \u00e0 garantia de n\u00e3o-negatividade\n\nadvinda do conjunto de restri\u00e7\u00f5es anterior:\n\nli ? cei ?i ? [1,nr] . (4.32)\n\nA ?gura 4.4 ilustra as restri\u00e7\u00f5es de estoque estabelecidas sobre cada recurso apresentando a com-\n\nposi\u00e7\u00e3o de LB diretamente das entradas de M.\n\n  \n\nmatriz de intervalos\nopcionais M\n(i-\u00e9sima linha)\n\nminp minp+1 minami1\n\nmatriz de fun\u00e7\u00f5es\ncumulativas LB\n(i-\u00e9sima linha transposta)? ?\n\nj=1 :loc j=k\n\nnp\ndegrau( fim(mi j) ,cll)\n\n?\nj=np+1 :loc j=k\n\nna\ndegrau( fim(mi j ,cei?duracao(mij)maci ))\n\n0?lbik\n\nvetor de fun\u00e7\u00f5es\ncumulativas l\n\nli?cei\n\npulso(mi j ,cd j)\n\nFigura 4.4: Representa\u00e7\u00e3o das restri\u00e7\u00f5es de estoque do recurso por porto e na totalidade.\n\n\n\n70 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.5\n\nDe forma a garantir que as linhas com restri\u00e7\u00e3o de data sejam carregadas apenas ap\u00f3s o prazo\n\ndeterminado, um conjunto de restri\u00e7\u00f5es \u00e9 estabelecido a partir da estrutura de cargas opcionais\n\nproporcionais ao n\u00famero de linhas existentes descrita previamente. Nesse contexto, a restri\u00e7\u00e3o\n\nassociada ao carregamento de cada linha l por cada recurso i \u00e9 descrita da seguinte forma:\n\nocorrencia(micll ) ?\n\nMINj?[np+1,na]:ocorrencia(mij )?dlj?np?dllfim(mij) ? inicio(micll )\n\n?i ? [1,nr], l ? [1,nl] .\n\n(4.33)\n\nDessa forma, a ocorr\u00eancia de ao menos uma carga cuja data m\u00ednima de in\u00edcio \u00e9 pelo menos t\u00e3o\n\ntarde quanto a data de disponibilidade da linha em quest\u00e3o e que o tempo de conclus\u00e3o da mesma\n\nseja menor do que o tempo de in\u00edcio da descarga da linha no mesmo recurso garantem que cada\n\nlinha pode ser carregada no tempo certo. A partir dessa garantia, a associa\u00e7\u00e3o das linhas \u00e0s cargas\n\npode ser feita de modo trivial.\n\n4.4.4 Fun\u00e7\u00e3o Objetivo\n\nA composi\u00e7\u00e3o da fun\u00e7\u00e3o objetivo de maximiza\u00e7\u00e3o fo \u00e9 baseada em uma combina\u00e7\u00e3o balanceada\n\ndas fun\u00e7\u00f5es de produ\u00e7\u00e3o de curto prazo fop e de somat\u00f3rio dos tempos de conclus\u00e3o das atividades\n\nfoc:\n\nfop =\n\nnp?\nj=1\n\nMAX(H ?fim(aj), 0) ?pj ; (4.34)\n\nfoc =\n\nna?\nj=1\n\n(fim(aj)) ; (4.35)\n\nfo = Mp ?fop?Mc ?foc . (4.36)\n\nO balanceamento dos coe?cientes Mp e Mc deve ser feito de forma a garantir que os valores assumidos\n\npor foc n\u00e3o afetem as decis\u00f5es a ponto de alterar o valor assumido por fop, o que teoricamente\n\ndenota-se por Mp ? Mc. Sem perda de generalidade, essa de?ni\u00e7\u00e3o pode ser feita sobre um dos\ncoe?cientes para um valor ?xo do outro. No entanto, conv\u00e9m observar que uma diferen\u00e7a de grandeza\n\nentre os coe?ciente al\u00e9m do necess\u00e1rio pode afetar a precis\u00e3o do resultado. Dessa forma, optou-se\n\npelo valor ?xo Mp = 1 e, sob a hip\u00f3tese de valores inteiros para a taxa de produ\u00e7\u00e3o, Mc tal que\n1\nMc\n\n> focMAX. O valor m\u00e1ximo assum\u00edvel pela fun\u00e7\u00e3o foc nas solu\u00e7\u00f5es, focMAX, pode ser estimado\n\npor pr\u00e9-inspe\u00e7\u00e3o dos dados do problema.\n\n4.5 Limitante Superior ao \u00d3timo\n\nDe forma a avaliar a qualidade das solu\u00e7\u00f5es obtidas, duas abordagens distintas foram desenvol-\n\nvidas para estabelecer limitantes superiores \u00e0 produ\u00e7\u00e3o de curto prazo de inst\u00e2ncias do problema.\n\nCom base nos limitantes obtidos e em sua diferen\u00e7a com rela\u00e7\u00e3o \u00e0s solu\u00e7\u00f5es obtidas pelo modelo,\n\n\u00e9 poss\u00edvel estimar a diferen\u00e7a, no pior caso, entre o valor de produ\u00e7\u00e3o dessas solu\u00e7\u00f5es e o valor\n\n\u00f3timo de produ\u00e7\u00e3o: ela corresponde ao \u00f3timo ser igual ao menor desses limites. As duas aborda-\n\ngens consistem na relaxa\u00e7\u00e3o de um conjunto de restri\u00e7\u00f5es do problema, de forma que uma solu\u00e7\u00e3o\n\n\n\n4.5 LIMITANTE SUPERIOR AO \u00d3TIMO 71\n\n\u00f3tima do problema relaxado possa ser obtida. No entanto, \u00e9 pouco prov\u00e1vel que a solu\u00e7\u00e3o de tal\n\nproblema relaxado seja tamb\u00e9m uma solu\u00e7\u00e3o vi\u00e1vel do problema original. No primeiro caso, o pro-\n\nblema resultante \u00e9 resolvido com um algoritmo guloso com baixo custo computacional. No segundo\n\ncaso, um modelo de PLI \u00e9 formulado para ser rodado em um resolvedor de PM. O desenvolvimento\n\nda primeira abordagem \u00e9 descrito em Serra et al. (2011) e visou estabelecer um limitante que n\u00e3o\n\ndependesse de outras ferramentas de resolu\u00e7\u00e3o. A segunda abordagem \u00e9 descrita em Serra et al.\n\n(2012) e visou obter uma estimativa mais precisa por relaxar menos o problema original. Apesar\n\ndos resultados obtidos com a segunda abordagem serem melhores, ambas s\u00e3o descritas a seguir com\n\no intuito de ilustrar a diferen\u00e7a dos resultados a partir do n\u00edvel de relaxa\u00e7\u00e3o adotado em cada caso.\n\n4.5.1 Algoritmo Guloso sobre Relaxa\u00e7\u00e3o\n\nO algoritmo de infer\u00eancia de limitante superior opera gerando uma inst\u00e2ncia relaxada do pro-\n\nblema cuja resolu\u00e7\u00e3o \u00e9 trivial e, resolvendo-a, gera um valor de produ\u00e7\u00e3o superestimado devido \u00e0s\n\nrelaxa\u00e7\u00f5es. As relaxa\u00e7\u00f5es presentes na inst\u00e2ncia gerada s\u00e3o de quatro tipos, cada qual afetando um\n\naspecto distinto da inst\u00e2ncia:\n\n1. N\u00famero e dura\u00e7\u00e3o das atividades de desenvolvimento: Reduz o desenvolvimento de\n\ncada po\u00e7o a uma \u00fanica atividade cuja dura\u00e7\u00e3o \u00e9 dada pelo tempo m\u00ednimo entre o in\u00edcio da\n\nprimeira atividade e o t\u00e9rmino da \u00faltima da sequ\u00eancia da inst\u00e2ncia original do problema.\n\n2. Produ\u00e7\u00e3o associada \u00e0s atividadades: Associa o maior valor de produ\u00e7\u00e3o de um po\u00e7o da\n\ninst\u00e2ncia original \u00e0 atividade da inst\u00e2ncia relaxada com menor dura\u00e7\u00e3o e assim por diante.\n\n3. Disponibilidade e compatibilidade dos recursos: Considera todos os recursos dispon\u00edveis\n\ninde?nidamente a partir do in\u00edcio de seu contrato e compat\u00edveis com todas as atividades.\n\n4. Linhas a serem transportadas: Ignora todas os transportes e cargas tempor\u00e1rias da ins-\n\nt\u00e2ncia original na inst\u00e2ncia relaxada.\n\nAssim sendo, a solu\u00e7\u00e3o \u00f3tima dessa relaxa\u00e7\u00e3o pode ser obtida pela escala das atividades em ordem\n\nn\u00e3o-crescente de produ\u00e7\u00e3o ? e, por consequ\u00eancia, n\u00e3o-decrescente de dura\u00e7\u00e3o ? nos recursos dispon\u00ed-\n\nveis. Dessa forma, a complexidade de pior caso do algortimo \u00e9 O(n2a +nlo?log(nlo) +nlo?nr), sendo\no primeiro termo relativo \u00e0 determina\u00e7\u00e3o da dura\u00e7\u00e3o m\u00ednima do desenvolvimento de cada po\u00e7o,\n\no segundo relativo \u00e0 ordena\u00e7\u00e3o das atividades associadas a cada po\u00e7o tanto por dura\u00e7\u00e3o quanto\n\npor produ\u00e7\u00e3o e o terceiro relativo \u00e0 aloca\u00e7\u00e3o dessas atividades nos recursos. A dura\u00e7\u00e3o m\u00ednima do\n\ndesenvolvimento de cada po\u00e7o \u00e9 obtida pelo emprego de um algoritmo de caminhos mais curtos a\n\npartir de uma \u00fanica origem atrav\u00e9s da convers\u00e3o dos tempos m\u00ednimos \u00e0 conclus\u00e3o de cada atividade\n\nem v\u00e9rtices para os quais \u00e9 medida a dist\u00e2ncia com rela\u00e7\u00e3o ao v\u00e9rtice associado ao instante inicial\n\nda escala. Portanto, o algoritmo de limitante superior gera uma relaxa\u00e7\u00e3o cuja produ\u00e7\u00e3o \u00f3tima\n\n\u00e9 ao menos t\u00e3o grande quanto a do problema original, resolve-a de modo e?ciente e gerando um\n\nlimitante v\u00e1lido \u00e0 produ\u00e7\u00e3o de curto prazo.\n\n4.5.2 Modelo de PLI sobre Relaxa\u00e7\u00e3o\n\nApesar de v\u00e1lida e de f\u00e1cil implementa\u00e7\u00e3o, a estimativa que pode ser obtida pelo m\u00e9todo descrito\n\nna se\u00e7\u00e3o anterior acaba por ser muito fraca devido \u00e0 grande quantidade de premissas adotadas para\n\n\n\n72 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.5\n\nrelaxar o problema. De forma a possibilitar que uma solu\u00e7\u00e3o \u00f3tima seja obtida por um algoritmo\n\nguloso, muitas restri\u00e7\u00f5es fundamentais foram ignoradas. Por esse motivo, uma segunda proposta de\n\nestimativa foi desenvolvida com base em um modelo de PLI. Nesse caso, apenas a obrigatoriadade\n\ndas atividades e os detalhes relacionados a linhas como exist\u00eancia, necessidade de carga em portos e\n\nmanuten\u00e7\u00e3o dos limites de estoque nos recursos foram abstra\u00eddos. Como resultado da manuten\u00e7\u00e3o\n\nde restri\u00e7\u00f5es de compatibilidade, do conjunto de atividades de desenvolvimento em cada po\u00e7o\n\ne da disponibilidade de casa recurso, um limite menor foi obtido em Serra et al. (2012) para o\n\nmesmo conjunto de inst\u00e2ncias e escala adotados em Serra et al. (2011) com o uso da abordagem\n\nanterior. Conv\u00e9m observar que o modelo de PLI n\u00e3o \u00e9 sempre resolvido rapidamente, de forma que\n\num tempo limite \u00e9 estabelecido para que o limitante superior do modelo relaxado seja utilizado no\n\nlugar da solu\u00e7\u00e3o \u00f3tima do mesmo. O modelo descrito a seguir representa a con?gura\u00e7\u00e3o com melhor\n\ndesempenho na an\u00e1lise emp\u00edrica desenvolvida em Serra et al. (2012).\n\nO conjunto de vari\u00e1veis de decis\u00e3o do modelo MIP \u00e9 descrito na tabela 4.1. Como pode ser obser-\n\nvado, vari\u00e1veis cont\u00ednuas foram utilizadas para representar a programa\u00e7\u00e3o das atividades ao longo\n\ndo tempo, sendo acompanhadas por vari\u00e1veis inteiras para representar a ocorr\u00eancia da atividade,\n\nsua atribui\u00e7\u00e3o a um recurso e seu sequenciamento com rela\u00e7\u00e3o a outras atividades.\n\nVar. Domain Description\n\nSj R\n+ Tempo de in\u00edcio da atividade j.\n\nEj R\n+ Tempo de ?naliza\u00e7\u00e3o da atividade j.\n\nYj {0, 1} Se a atividade j termina antes de H.\nXj R\n\n+ Dias antes da atividade j se conclu\u00edda se Yj = 1.\nFj R\n\n+ Vari\u00e1vel auxiliar que \u00e9 positiva se Yj = 0.\nWij {0, 1} Se o recurso i \u00e9 atribu\u00eddo \u00e0 atividade j.\nZj1j2 {0, 1} Se a atividade j1 precede a atividade j2.\n\nTabela 4.1: Vari\u00e1veis de decis\u00e3o do modelo PLI do problema relaxado.\n\nA fun\u00e7\u00e3o objetivo (4.37) descreve a maximiza\u00e7\u00e3o da produ\u00e7\u00e3o at\u00e9 o dia H:\n\nmax.\nnp?\nj=1\n\n(H \u00d7Yj ?Xj) \u00d7pj (4.37)\n\nAinda que seja possivel representar uma produ\u00e7\u00e3o negativa com essa fun\u00e7\u00e3o se Xj > 0 e Yj = 0 para\n\numa atividade j, tal situa\u00e7\u00e3o n\u00e3o ocorre na resolu\u00e7\u00e3o do problema porque uma produ\u00e7\u00e3o maior\n\npoderia ser atingida com Xj = 0 e Fj = Ej. Dessa forma, a solu\u00e7\u00e3o parcial obtida em cada etapa\n\nda busca sobre esse modelo sempre ter\u00e1 Xj = 0 em uma situa\u00e7\u00e3o desse tipo.\n\nPara as restri\u00e7\u00f5es (4.42), (4.50) e (4.53) a seguir, existe um coe?ciente Mj associado a cada\n\natividade j. Esse coe?ciente deve ter sempre um valor t\u00e3o grande quanto qualquer atribui\u00e7\u00e3o v\u00e1lida\n\na Ej. Na literatura, esse tipo de coe?ciente geralmente \u00e9 chamado de ?grande M\n2?. Apesar de ser\n\nposs\u00edvel de?nir Mj = imcj, o uso de um valor menor para cada um desses coe?cientes facilitaria\n\no processo de resolu\u00e7\u00e3o do problema. Dessa forma, em car\u00e1ter preliminar, um modelo contendo\n\napenas as restri\u00e7\u00f5es (4.38) a (4.55) \u00e9 rodado para atualizar o valor de Mj como Ej + H ? 1, onde\nEj \u00e9 o valor atribu\u00eddo a Ej como resultado da rodada. Explica\u00e7\u00f5es mais detalhadas a respeito\n\ndo comportamento do processo de resolu\u00e7\u00e3o em fun\u00e7\u00e3o do valor desses coe?cientes podem ser\n\n2Denominado ?big M? em ingl\u00eas.\n\n\n\n4.5 LIMITANTE SUPERIOR AO \u00d3TIMO 73\n\nencontradas em Camm et al. (1990), onde uma avalia\u00e7\u00e3o emp\u00edrica dos problemas de escalabilidade\n\ndecorrentes da sele\u00e7\u00e3o de valores muito grandes para esse tipo de coe?ciente \u00e9 discutida.\n\nAs restri\u00e7\u00f5es (4.38) a (4.40) limitam o valor das vari\u00e1veis temporais dos conjuntos S e E em\n\nfun\u00e7\u00e3o da data de in\u00edcio mais cedo, da data de in\u00edcio mais tarde e da dura\u00e7\u00e3o da atividade.\n\nSj + dj = Ej ?j ? [1,np] (4.38)\n\nSj ? imcj ?j ? [1,np] (4.39)\n\nEj ? imtj + dj ?j ? [1,np] (4.40)\n\nA sem\u00e2ntica dos conjuntos de vari\u00e1veis X e Y conforme descrita na tabela 4.1 \u00e9 garantida pelas\n\nrestri\u00e7\u00f5es (4.41) a (4.43). Dessa forma, Fj > 0 se, e somente se, Yj = 0 para cada atividade j.\n\nDe outra forma, Xj = Ej. Assim sendo, os conjuntos de vari\u00e1veis X e Y podem ser usados para\n\ncompor a fun\u00e7\u00e3o objetivo e representar a produ\u00e7\u00e3o obtida.\n\nEj = Xj + Fj ?j ? [1,np] (4.41)\n\nFj ? Mj \u00d7 (1 ?Yj) ?j ? [1,np] (4.42)\n\nEj ? H \u00d7 (1 ?Yj) ?j ? [1,np] (4.43)\n\nA restri\u00e7\u00e3o (4.44) \u00e9 um corte inclu\u00eddo para facilitar a resolu\u00e7\u00e3o. Esse corte prov\u00ea uma liga\u00e7\u00e3o\n\nadicional entre os conjuntos Y e X, de forma a evidenciar quando uma atividade n\u00e3o pode ser\n\nrealizada antes do dia H.\n\nXj + Yj ? H ?j ? [1,np] (4.44)\n\nCortes s\u00e3o restri\u00e7\u00f5es inferidas a partir do modelo se levadas em conta as restri\u00e7\u00f5es de integralidade.\n\nEssas restri\u00e7\u00f5es adicionais n\u00e3o s\u00e3o necess\u00e1rias para garantir a corretude do modelo, mas elas co-\n\nlaboram com a redu\u00e7\u00e3o do espa\u00e7o de busca pela elimina\u00e7\u00e3o de regi\u00f5es que n\u00e3o possuam solu\u00e7\u00f5es\n\ninteiras, o que facilita a resolu\u00e7\u00e3o do problema.\n\nAs rela\u00e7\u00f5es de preced\u00eancia s\u00e3o garantidas pela equa\u00e7\u00e3o (4.45) sobre os conjuntos de vari\u00e1veis S\n\ne E, bem como pelo corte adicional (4.46) em Y . Esse corte limita a ocorr\u00eancia de uma atividade\n\nantes de H ao caso no qual as suas predecessoras tamb\u00e9m ocorram antes de H.\n\nEj1 + prcj1j2 ? Sj2 ?j1,j2 ? [1,np] (4.45)\n\nYj1 ? Yj2 ?j1,j2 ? [1,np],prcj1j2 6= ?? (4.46)\n\nA equa\u00e7\u00e3o (4.47) garante que cada atividade conclu\u00edda antes de H \u00e9 atribu\u00edda a um recurso, bem\n\ncomo que esse recurso seja compat\u00edvel com a atividade.\n\n?\ni?[1,np]:cij =1\n\nWij = Yj ?j ? [1,np] (4.47)\n\nA equa\u00e7\u00e3o (4.48) limite a dura\u00e7\u00e3o total das atividades atribu\u00eddas a cada recurso \u00e0 disponibilidade\n\n\n\n74 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.5\n\nde curto prazo do mesmo.\n\nmin{H ? 1,fci}?min{H ? 1, ici}\n\n?\n?\n\nj?[1,np]:cij =1\n\ndj \u00d7Wij ?i ? [1,nr] (4.48)\n\nAs equa\u00e7\u00f5es (4.49) e (4.50) limitam a programa\u00e7\u00e3o de cada atividade ao contrato do recurso ao\n\nqual ela \u00e9 atribu\u00edda.\n\nSj ? ici \u00d7Wij ?i ? [1,nr],j ? [1,np],cij = 1 (4.49)\n\nEj ? fci + Mj \u00d7 (1 ?Wij) ?i ? [1,nr],j ? [1,np],\n\ncij = 1 (4.50)\n\nAs restri\u00e7\u00f5es (4.51) a (4.53) limitam a ocor\u00eancia simult\u00e2nea de atividades. Esse tipo de restri\u00e7\u00e3o\n\ndeve-se \u00e0 ocorr\u00eancia de atividades em um mesmo po\u00e7o e \u00e0 utiliza\u00e7\u00e3o de um mesmo recurso por\n\natividades distintas. No caso de atividades em um mesmo po\u00e7o, o tempo de transi\u00e7\u00e3o em (4.53) \u00e9\n\nnulo. No caso de atividades em localidades distintas, ele \u00e9 de?nido como o maior tempo de transi\u00e7\u00e3o\n\nde um recurso compat\u00edvel com ambas as atividades.\n\nZj1j2 + Zj2j1 ? 1 ? j1,j2 ? [1,np],j1 &lt;j2 (4.51)\n\nZj1j2 + Zj2j1 ? Yj1 ? j1,j2 ? [1,np],\n\nj1 6= j2, locj1 = locj2 (4.52)\n\nEj1 + dtj1j2 ? (Mj1 + dtj1j2 ) \u00d7 (1 ?Zj1j2 )\n\n? Sj2 ? j1,j2 ? [1,np],j1 6= j2 (4.53)\n\nA atribui\u00e7\u00e3o das atividades pertencentes a um mesmo cluster \u00e9 restrita a recursos capazes de\n\nrealizar aquelas atividades programadas no curto prazo pela restri\u00e7\u00e3o (4.54) e a um \u00fanico recurso\n\npela restri\u00e7\u00e3o (4.55).\n\nWij1 ? 1 ?Yj2 ?i ? [1,nr],j1,j2 ? [1,np],\n\ncij1 = 1,cij2 6= 1,\n\nclusterj1 = clusterj2 (4.54)\n\nWij1 ? 1 ?Yj2 + Wij2 ? i ? [1,nr],j1,j2 ? [1,np],\n\ncij1 = 1,cij2 = 1,\n\nclusterj1 = clusterj2 (4.55)\n\nPor ?m, o sequenciamento temporal das atividades atribu\u00eddas a um mesmo recurso \u00e9 garantido\n\npela restri\u00e7\u00e3o (4.56). Nesse caso, se duas atividades j1 e j2 s\u00e3o realizadas por um \u00fanico recurso,\n\n\n\n4.5 LIMITANTE SUPERIOR AO \u00d3TIMO 75\n\nZj1j2 = 1 ou Zj2j1 = 1 para evitar sua ocorr\u00eancia simult\u00e2nea.\n\nZj1j2 + Zj2j1? Wij1 + Wij2 ? 1\n\n?i ? [1,nr],j1,j2 ? [1,np],\n\ncij1 = 1,cij2 = 1\n\nj1 &lt;j2 (4.56)\n\n\n\n76 O PROBLEMA DA PROGRAMA\u00c7\u00c3O DE RECURSOS CR\u00cdTICOS E SUA ABORDAGEM 4.5\n\n\n\nCap\u00edtulo 5\n\nAn\u00e1lise Experimental do Escalonador\n\nAlguns experimentos foram conduzidos para analisar o desempenho do escalonador obtido a\n\npartir da implementa\u00e7\u00e3o do modelo proposto em um resolvedor comercial. O objetivo prim\u00e1rio\n\ndesses experimentos foi avaliar a qualidade das solu\u00e7\u00f5es obtidas ao longo do tempo e o resultado\n\nao ?nal do tempo de resolu\u00e7\u00e3o estipulado pelo usu\u00e1rio ?nal. Dessa forma, a abordagem descrita no\n\nCap\u00edtulo 4 foi implementada e testada sobre um conjunto de dados reais conforme a especi?ca\u00e7\u00e3o\n\ndescrita na se\u00e7\u00e3o 5.1. Os experimentos realizados e os resultados obtidos para os mesmos s\u00e3o\n\napresentados na se\u00e7\u00e3o 5.2 e discutidos na se\u00e7\u00e3o 5.3.\n\n5.1 Dados Dispon\u00edveis e Ambiente de Testes\n\nA avalia\u00e7\u00e3o experimental do escalonador foi baseada em um conjunto de dados representando\n\num cen\u00e1rio real ocorrido no passado. Devido ao fato desse cen\u00e1rio representar uma \u00fanica inst\u00e2ncia\n\ndo problema, outras inst\u00e2ncias foram geradas a partir desta como forma de avaliar a estabilidade de\n\ndesempenho do resolvedor. A inst\u00e2ncia O representa o cen\u00e1rio completo com 465 atividades em 171\n\npo\u00e7os. Essa inst\u00e2ncia foi particionada em conjuntos de atividades de tamanhos similares para gerar\n\ninst\u00e2ncias de porte menor a serem testadas individualmente, todas empregando o conjunto completo\n\nde recursos dispon\u00edvel. O primeiro particionamento das atividades foi em duas metades, H1 e H2,\n\ne a segunda em quatro quartos, Q1 a Q4. A tabela 5.1 descreve as principais caracter\u00edsticas de cada\n\numa dessas inst\u00e2ncias.\n\nO modelo de vari\u00e1veis intervalares foi implementado usando a linguagem OPL, para a qual o\n\nAp\u00eandice A prov\u00ea uma pequena introdu\u00e7\u00e3o. O escalonador foi executado em uma \u00fanica thread por\n\nmeio do resolvedor IBM Cplex Studio 12.2. O computador usado nos testes possui 4 processadores\n\nInst\u00e2ncia Q1 Q2 Q3 Q4 H1 H2 O\n\nAtividades 116 118 116 115 231 234 465\nPo\u00e7os 46 37 45 43 82 89 171\nLinhas 17 17 13 19 32 34 66\nSondas 64\nBarcos 9\nIndisponibilidades 12\n\nTabela 5.1: Principais caracter\u00edsticas das inst\u00e2ncias testadas.\n\n77\n\n\n\n78 AN\u00c1LISE EXPERIMENTAL DO ESCALONADOR 5.2\n\nInst\u00e2ncia Q1 Q2 Q3 Q4 H1 H2 O\n\nTempo Solu\u00e7\u00e3o Inicial (s)\nM\u00e9dia 3,14 2,99 3,86 2,82 10,19 12,71 13,62\nDesvio 0,08 0,16 0,22 0,12 0,64 2,63 6,64\n\nValor Solu\u00e7\u00e3o Inicial\nM\u00e9dia 97,23 86,03 99,08 86,13 95,98 91,86 88,31\nDesvio 0,13 22,17 0,52 8,58 1,19 0,41 0,98\n\nValor Solu\u00e7\u00e3o Final\nM\u00e9dia 99,98 100,00 99,98 99,88 99,66 99,60 98,98\nDesvio 0,03 0,00 0,02 0,20 0,28 0,35 1,18\n\nLimitante Superior\nAlgoritmo 122,20 138,56 117,82 118,30 122,83 125,02 135,61\nModelo 104,14 114,25 100,65 103,52 105,44 105,98 115,81\n\nTabela 5.2: Principais resultados dos experimentos do escalonador.\n\nDual-Core AMD Opteron 8220, 16 Gb de mem\u00f3ria RAM e sistema operacional Linux. Por ?m, o\n\nalgoritmo descrito na se\u00e7\u00e3o 4.5.1 para inferir um limitante superior para o \u00f3timo foi implementado\n\nem Java em raz\u00e3o da baixa demanda por recursos do mesmo e \u00e0 necessidade de compatibilidade e\n\nfacilidade de manuten\u00e7\u00e3o com rela\u00e7\u00e3o ao sistema existente. O modelo em PLI descrito na se\u00e7\u00e3o 4.5.2\n\nfoi implementado em OPL e utilizou o mesmo resolvedor para sua resolu\u00e7\u00e3o.\n\n5.2 Experimentos Realizados e Resultados\n\nOs testes realizados procuraram avaliar a estabilidade do resolvedor, seu comportamento de\n\nacordo com o tamanho do conjunto de atividades e a qualidade das solu\u00e7\u00f5es obtidas com base nos\n\nlimitantes obtidos. Eles s\u00e3o similares aos publicados em Serra et al. (2011) e Serra et al. (2012), que\n\nforam ambos realizados em uma vers\u00e3o simpli?cada do problema descrito neste trabalho. Essa vers\u00e3o\n\nsimpli?cada diferia por contemplar apenas indisponibilidades totais ?xas e n\u00e3o possuir restri\u00e7\u00e3o de\n\ndisponibilidade ou porto de embarque das linhas. Tais requisitos foram ignorados na \u00e9poca por ainda\n\nestarem em discuss\u00e3o. Cada inst\u00e2ncia foi resolvida quatro vezes pelo escalonador pelo tempo limite\n\nde uma hora, sendo registradas as solu\u00e7\u00f5es obtidas ao longo do processo de resolu\u00e7\u00e3o. Como forma de\n\nreduzir o efeito de m\u00e1s escolhas em quest\u00f5es de desempate arbitr\u00e1rio no processo de rami?ca\u00e7\u00e3o ao\n\nlongo da busca, a repeti\u00e7\u00e3o do processo de resolu\u00e7\u00e3o foi feita com sementes de aleatoriza\u00e7\u00e3o distintas.\n\nO uso de sementes de aleatoriza\u00e7\u00e3o e o fato de resultados diferentes serem esperados com seu uso\n\nse deve \u00e0 arbitra\u00e7\u00e3o de crit\u00e9rios de desempate ao longo da busca, conforme descrito na se\u00e7\u00e3o A.4.7\n\ndo ap\u00eandice. O tempo limite estabelecido \u00e9 baseado na expectativa de toler\u00e2ncia do usu\u00e1rio ?nal\n\npara obter uma solu\u00e7\u00e3o, sendo empregado tanto no modelo de PR quanto no de PLI. Por motivo de\n\nsigilo, a medida dos valores de produ\u00e7\u00e3o apresentados para cada solu\u00e7\u00e3o \u00e9 normalizada com base\n\nno valor 100 para a melhor solu\u00e7\u00e3o obtida em cada inst\u00e2ncia. Essa normaliza\u00e7\u00e3o tamb\u00e9m visou\n\nfacilitar a compara\u00e7\u00e3o de progresso da resolu\u00e7\u00e3o em inst\u00e2ncias distintas. Os principais resultados\n\ndesses experimentos est\u00e3o resumidos na tabela 5.2.\n\nComo forma de demonstrar o progresso do escalonador enquanto resolve o modelo, os gr\u00e1?-\n\ncos das ?guras que se seguem representam a melhor solu\u00e7\u00e3o obtida a cada instante de resolu\u00e7\u00e3o.\n\nAs ?guras 5.1 a 5.4 representam, respectivamente, o progresso nas 4 rodadas realizadas sobre as\n\ninst\u00e2ncias Q1 a Q4. Por sua vez, as ?guras 5.5 e 5.6 ilustram o progresso das 4 rodadas sobre as\n\ninst\u00e2ncias H1 e H2. Por ?m, a ?gura 5.7 apresenta o progresso de resolu\u00e7\u00e3o das 4 rodadas sobre a\n\ninst\u00e2ncia O.\n\n\n\n5.2 EXPERIMENTOS REALIZADOS E RESULTADOS 79\n\nFigura 5.1: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q1.\n\nFigura 5.2: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q2.\n\nFigura 5.3: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q3.\n\n\n\n80 AN\u00c1LISE EXPERIMENTAL DO ESCALONADOR 5.2\n\nFigura 5.4: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia Q4.\n\nFigura 5.5: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia H1.\n\nFigura 5.6: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia H2.\n\n\n\n5.3 DISCUSS\u00c3O 81\n\nFigura 5.7: Melhoria da solu\u00e7\u00e3o obtida em cada rodada do escalonador para a inst\u00e2ncia O.\n\n5.3 Discuss\u00e3o\n\nOs resultados indicam que o tempo limite estabelecido pelo usu\u00e1rio do escalonador \u00e9 satisfat\u00f3rio\n\npara evitar ?utua\u00e7\u00f5es muito grandes nos resultados ?nais. Isso pode ser observado pelo fato de que\n\na m\u00e9dia do valor das solu\u00e7\u00f5es ?nais obtidas nas rodadas para cada inst\u00e2ncia n\u00e3o ?cou muito abaixo\n\nde 1% da melhor solu\u00e7\u00e3o obtida. Al\u00e9m disso, os gr\u00e1?cos de melhor solu\u00e7\u00e3o obtida ao longo do\n\ntempo evidenciam uma converg\u00eancia a determinados patamares de valores. No entanto, a tend\u00eancia\n\naparente de aumento do valor do limitante com rela\u00e7\u00e3o \u00e0 melhor solu\u00e7\u00e3o obtida e a maior dispers\u00e3o\n\ndas curvas relativas \u00e0s inst\u00e2ncias com um maior n\u00famero de atividades evidenciam que os resultados\n\npoderiam ser melhores na hip\u00f3tese de um tempo limite de execu\u00e7\u00e3o maior para a resolu\u00e7\u00e3o de\n\ninst\u00e2ncias maiores.\n\nDe qualque forma, a in?u\u00eancia da quantidade de atividades da inst\u00e2ncia para a varia\u00e7\u00e3o dos\n\nresultados obtidos foi mais relevante com rela\u00e7\u00e3o ao tempo para obten\u00e7\u00e3o e ao valor da solu\u00e7\u00e3o\n\ninicial obtida do que com rela\u00e7\u00e3o ao valor da solu\u00e7\u00e3o ?nal. Para as inst\u00e2ncias Q1 a Q4, apenas\n\numa rodada de Q2 e tr\u00eas rodadas de Q4 tiveram uma solu\u00e7\u00e3o inicial com diferen\u00e7a maior do que\n\n3% com rela\u00e7\u00e3o \u00e0 melhor solu\u00e7\u00e3o obtida em uma hora, sendo que as solu\u00e7\u00f5es seguintes passam a\n\n?gurar dentro desse patamar. Outro fator relevante para a converg\u00eancia das rodadas \u00e9 a quantidade\n\nde linhas da inst\u00e2ncia, uma vez que a ?utua\u00e7\u00e3o observada para os resultados da inst\u00e2ncia Q4 ? que\n\npossui uma quantidade acima da m\u00e9dia para o n\u00famero de atividades ? foi maior. Nas inst\u00e2ncias H1\n\ne H2, as solu\u00e7\u00f5es iniciais de todas as rodadas tinham uma diferen\u00e7a inferior a 10% com rela\u00e7\u00e3o \u00e0\n\nmelhor solu\u00e7\u00e3o obtida em uma hora. No caso da inst\u00e2ncia O, no m\u00e1ximo duas solu\u00e7\u00f5es por rodada\n\nestavam abaixo da diferen\u00e7a de 10%. Com rela\u00e7\u00e3o \u00e0 qualidade das solu\u00e7\u00f5es, todas as rodadas\n\nobtiveram uma solu\u00e7\u00e3o ?nal a menos de 16% da solu\u00e7\u00e3o \u00f3tima. Com excess\u00e3o de Q2, esse valor foi\n\nmenor do que 6% nas menores inst\u00e2ncias. Al\u00e9m disso, conv\u00e9m observar que essa dist\u00e2ncia pode ser\n\nainda menor, uma vez que a diferen\u00e7a entre o valor das solu\u00e7\u00f5es obtidas e o \u00f3timo frequentemente\n\nn\u00e3o equivale \u00e0 diferen\u00e7a com rela\u00e7\u00e3o ao limitante. Dessa forma, h\u00e1 uma grande evid\u00eancia da robustez\n\ndo escalonador devido \u00e0 pequena quantidade de tempo para a obten\u00e7\u00e3o de uma solu\u00e7\u00e3o inicial, \u00e0\n\nestabilidade dos resultados ?nais entre rodadas independentes e sua diferen\u00e7a m\u00e1xima com rela\u00e7\u00e3o\n\nao \u00f3timo.\n\nA despeito desses resultados, ainda h\u00e1 muitas possibilidades a serem consideradas para melhorar\n\n\n\n82 AN\u00c1LISE EXPERIMENTAL DO ESCALONADOR 5.3\n\na qualidade da solu\u00e7\u00e3o inicial e reduzir o valor do limitante inferido. O desenvolvimento de um\n\ngerador de solu\u00e7\u00f5es iniciais para servir de entrada ao escalonador proposto serviria para levar\n\nem conta o conhecimento de quem realiza essa programa\u00e7\u00e3o manualmente e, por consequ\u00eancia,\n\nevitar a degenera\u00e7\u00e3o no in\u00edcio da busca. Se bem-sucedido, esse gerador levaria a uma diminui\u00e7\u00e3o\n\nda varia\u00e7\u00e3o observada entre inst\u00e2ncias e aumentaria a con?an\u00e7a do usu\u00e1rio ?nal no sistema. A\n\nsuspeita sobre a possibilidade de ser poss\u00edvel reduzir o limitante estimado deriva do fato que o\n\ncarregamento de linhas sequer foi considerado na relaxa\u00e7\u00e3o PLI, que obteve os limitantes mais\n\nprecisos. No mais, aquele valor \u00e9 um pouco elevado se levarmos em conta que a melhoria das solu\u00e7\u00f5es\n\nobtidas em inst\u00e2ncias menores cessa precocemente em algumas rodadas e melhorias signi?cativas\n\nn\u00e3o s\u00e3o normalmente esperadas nesses casos. Portanto, \u00e9 poss\u00edvel que uma relaxa\u00e7\u00e3o ainda menos\n\nsimpli?cada do problema possa ser obtida em tempo h\u00e1bil e levar a uma avalia\u00e7\u00e3o mais precisa da\n\nqualidade dos resultados do escalonador.\n\n\n\nParte IV\n\nCONCLUS\u00c3O\n\n83\n\n\n\n\n\nCap\u00edtulo 6\n\nConclus\u00e3o\n\nEste trabalho procurou atingir dois objetivos inter-relacionados. O primeiro era de introduzir\n\nem portugu\u00eas a t\u00e9cnica de Programa\u00e7\u00e3o por Restri\u00e7\u00f5es (PR) e seu desdobramento com foco na\n\nabordagem de problemas de escalonamento ? o Escalonamento Baseado em Restri\u00e7\u00f5es (EBR) ?\n\ncomo ferramental v\u00e1lido \u00e0 abordagem de problemas de otimiza\u00e7\u00e3o. A apresenta\u00e7\u00e3o se deu por\n\nmeio de uma revis\u00e3o bibliogr\u00e1?ca sobre o tema, incluindo uma de?ni\u00e7\u00e3o dos principais conceitos, a\n\ncontextualiza\u00e7\u00e3o de algumas das ferramentas comerciais dispon\u00edveis e um tutorial para facilitar o\n\nuso de uma das linguagens de modelagem mais utilizadas atualmente ? a OPL. O segundo era de\n\nabordar o Problema da Programa\u00e7\u00e3o de Recursos Cr\u00edticos, que consiste na programa\u00e7\u00e3o de sondas\n\ne barcos para o desenvolvimento de po\u00e7os de petr\u00f3leo. Tendo em vista as recentes descobertas de\n\nreservas abundantes na camada do pr\u00e9-sal da costa brasileira, a obten\u00e7\u00e3o e?ciente de solu\u00e7\u00f5es de\n\nalta qualidade em tempo razo\u00e1vel \u00e9 de grande import\u00e2ncia para que o pa\u00eds se posicione como um\n\ngrande exportador de petr\u00f3leo nos pr\u00f3ximos anos. Dessa forma, a abordagem do problema por meio\n\ndo uso da t\u00e9cnica permitiu ilustrar como empreg\u00e1-la em um problema real, com o intuito de que\n\nsirva de exemplo e encorajamento para que outros pro?ssionais tamb\u00e9m tentem utiliz\u00e1-la.\n\nConv\u00e9m observar que a abordagem proposta representa apenas uma das alternativas poss\u00edveis.\n\nN\u00e3o obstante, os resultados obtidos para o cen\u00e1rio real estudado foram bastante otimistas, uma vez\n\nque uma solu\u00e7\u00e3o a menos de 16% do \u00f3timo foi obtida para um problema com cerca de 70 recursos\n\ne mais de 400 atividades. Dessa forma, observamos como possibilidades de trabalho futuro tanto\n\nabordar em um maior n\u00edvel de detalhe o problema tratado quanto recorrer a outras t\u00e9cnicas de reso-\n\nlu\u00e7\u00e3o para a promo\u00e7\u00e3o de uma an\u00e1lise comparativa. Essa segunda possibilidade diz respeito tanto \u00e0\n\nresolu\u00e7\u00e3o do problema quanto \u00e0 obten\u00e7\u00e3o de um limitante superior mais preciso para avaliar a qua-\n\nlidade das solu\u00e7\u00f5es. Portanto, n\u00e3o se espera que este trabalho tenha car\u00e1ter conclusivo e asser\u00e7\u00f5es\n\nde?nitivas em nenhum aspecto, mas antes que sirva como base para futuros desenvolvimentos.\n\n85\n\n\n\n86 CONCLUS\u00c3O 6.0\n\n\n\nParte V\n\nAP\u00caNDICE\n\n87\n\n\n\n\n\nAp\u00eandice A\n\nPrograma\u00e7\u00e3o por Restri\u00e7\u00f5es em OPL\n\nO prop\u00f3sito deste ap\u00eandice \u00e9 apresentar os principais elementos da linguagem de modelagem\n\nOPL, com \u00eanfase naqueles relacionados \u00e0 t\u00e9cnica de programa\u00e7\u00e3o por restri\u00e7\u00f5es. Dessa forma, a\n\napresenta\u00e7\u00e3o da linguagem n\u00e3o ser\u00e1 completa e alguns conceitos ser\u00e3o introduzidos \u00e0 medida que\n\nnecess\u00e1rios ao escopo de?nido. Ainda sim, essa apresenta\u00e7\u00e3o cobrir\u00e1 uma boa parte dos elementos\n\nde uso geral \u00e0 modelagem de problemas de decis\u00e3o e de otimiza\u00e7\u00e3o. No entanto, conv\u00e9m a ressalva\n\nde que parte dos elementos s\u00e3o exclusivos \u00e0 modelagem pela t\u00e9cnica de programa\u00e7\u00e3o por restri\u00e7\u00f5es.\n\nEsse material foi adaptado de uma apostila elaborada pelo autor para ministrar um curso sobre\n\no emprego da linguagem OPL na t\u00e9cnica de programa\u00e7\u00e3o por restri\u00e7\u00f5es. Boa parte dessa apostila\n\n\u00e9 baseada no manual da IBM (2010), ainda que em um escopo bastante reduzido e numa estrutura\n\ndiferente. Para a adequada compreens\u00e3o do material, \u00e9 desej\u00e1vel algum conhecimento de otimiza\u00e7\u00e3o\n\ne de linguagens de programa\u00e7\u00e3o. O tratamento te\u00f3rico sobre programa\u00e7\u00e3o por restri\u00e7\u00f5es apresentado\n\nna segunda parte da disserta\u00e7\u00e3o pode ser de alguma valia, mas n\u00e3o ser\u00e1 exigido de maneira expl\u00edcita.\n\nNo decorrer do texto, ser\u00e1 introduzida a linguagem OPL e elementos importantes \u00e0 modelagem de\n\nproblemas combinat\u00f3rios e de escalonamento, em ordem crescente de complexidade. Dessa forma,\n\na leitura do ap\u00eandice pode ser independente do restante da disserta\u00e7\u00e3o ao passo que a forma como\n\no texto est\u00e1 estruturado difere um pouco devido ao prop\u00f3sito com que foi elaborado originalmente.\n\nA organiza\u00e7\u00e3o do restante do ap\u00eandice segue a estrutura descrita a seguir. Na se\u00e7\u00e3o A.1, \u00e9 dada\n\numa vis\u00e3o geral sobre o que \u00e9 a linguagem OPL, com especial \u00eanfase ao resolvedor de programa\u00e7\u00e3o\n\npor restri\u00e7\u00f5es CP Optimizer. A separa\u00e7\u00e3o entre modelo e dados \u00e9 tratada na se\u00e7\u00e3o A.2. Nesse ponto,\n\ncome\u00e7a a descri\u00e7\u00e3o da linguagem por meio de diversos exemplos auto-contidos em cada se\u00e7\u00e3o, de\n\nforma a facilitar a compreens\u00e3o sequencial e consulta posterior do material. Essa apresenta\u00e7\u00e3o se\n\nprolonga por 3 se\u00e7\u00f5es: a se\u00e7\u00e3o A.3 cobre elementos b\u00e1sicos da linguagem, desde a de?ni\u00e7\u00e3o do\n\nresolvedor, passando pela manipula\u00e7\u00e3o das estruturas de dados mais comuns at\u00e9 a formula\u00e7\u00e3o de\n\nexpress\u00f5es; a se\u00e7\u00e3o A.4 cobre vari\u00e1veis de decis\u00e3o, fun\u00e7\u00e3o objetivo, restri\u00e7\u00f5es e p\u00f3s-processamento,\n\nal\u00e9m de um exemplo no ?nal; e a se\u00e7\u00e3o A.5 trata das estruturas espec\u00ed?cas para problemas de esca-\n\nlonamento, com um exemplo de sua utiliza\u00e7\u00e3o. Por ?m, a se\u00e7\u00e3o A.6 apresenta algumas conclus\u00f5es\n\ne agradecimentos aos revisores das vers\u00f5es preliminares desse texto.\n\nA.1 A Linguagem OPL e o Resolvedor CP\n\nOPL \u00e9 uma linguagem de modelagem alg\u00e9brica para a descri\u00e7\u00e3o de problemas decis\u00f3rios ou de\n\notimiza\u00e7\u00e3o. Ela era de propriedade da ILOG, que foi adquirida em 2009 pela IBM. A descri\u00e7\u00e3o\n\n89\n\n\n\n90 AP\u00caNDICE A\n\nde um problema de otimiza\u00e7\u00e3o nessa linguagem consiste em um modelo. Uma vez especi?cado o\n\nmodelo, um resolvedor compat\u00edvel com a linguagem pode ser utilizado para resolver o problema.\n\nNo caso da linguagem OPL, existem dois resolvedores compat\u00edveis: o CPLEX e o CP.\n\nA OPL pode ser entendida como uma linguagem de programa\u00e7\u00e3o como outra qualquer, de\n\nacordo com a vis\u00e3o de Knuth destacada por Lustig e Puget (2001), pois ela se prop\u00f5e a instruir\n\numa m\u00e1quina sobre como resolver um determinado problema. Por\u00e9m, ela n\u00e3o \u00e9 feita para uso\n\ngeral mas para expressar problemas decis\u00f3rios ou de otimiza\u00e7\u00e3o de maneira clara. Al\u00e9m disso, sua\n\nestrutura \u00e9 essencialmente declarativa, de forma que boa parte do modelo descrito expressa qual\n\n\u00e9 o problema e n\u00e3o como resolv\u00ea-lo. Por\u00e9m, tanto no pr\u00e9 quanto no p\u00f3s-processamento, \u00e9 poss\u00edvel\n\nincluir alguns trechos de programa\u00e7\u00e3o imperativa para tratamento dos dados, impress\u00e3o na tela e\n\ncon?gura\u00e7\u00e3o do resolvedor, conforme veremos adiante.\n\nO grande diferencial da linguagem OPL foi que, ao contr\u00e1rio de suas predecessoras, ela d\u00e1 su-\n\nporte \u00e0 descri\u00e7\u00e3o de problemas para a utiliza\u00e7\u00e3o de resolvedores de programa\u00e7\u00e3o por restri\u00e7\u00f5es\n\ncomo o resolvedor CP. At\u00e9 ent\u00e3o, linguagens de modelagem s\u00f3 serviam \u00e0 descri\u00e7\u00e3o de problemas de\n\nprograma\u00e7\u00e3o matem\u00e1tica, desde programa\u00e7\u00e3o linear a casos especiais de programa\u00e7\u00e3o n\u00e3o-linear,\n\nque em OPL s\u00e3o cobertos pelo resolvedor CPLEX. Esse diferencial amplia a possibilidade de apli-\n\nca\u00e7\u00e3o da linguagem devido \u00e0s vantagens em se utilizar programa\u00e7\u00e3o por restri\u00e7\u00f5es em alguns tipos\n\nde problemas para os quais as t\u00e9cnicas de resolu\u00e7\u00e3o utilizando programa\u00e7\u00e3o matem\u00e1tica n\u00e3o s\u00e3o\n\nvi\u00e1veis devido ao excessivo consumo de tempo e mem\u00f3ria para uma representa\u00e7\u00e3o completa dos\n\nmodelos associados. Nesses casos, mesmo que uma abordagem utilizando programa\u00e7\u00e3o por restri-\n\n\u00e7\u00f5es resulte em uma solu\u00e7\u00e3o sem garantias de otimalidade, ao menos \u00e9 poss\u00edvel obter uma solu\u00e7\u00e3o\n\nfact\u00edvel em tempo h\u00e1bil e com menor exig\u00eancia computacional. E sendo uma ferramenta de mode-\n\nlagem alg\u00e9brica, a possibilidade de uso dessas t\u00e9cnicas torna-se acess\u00edvel a um p\u00fablico mais amplo\n\ndo que apenas programadores de computadores.\n\nA programa\u00e7\u00e3o por restri\u00e7\u00f5es consiste na modelagem e resolu\u00e7\u00e3o de problemas combinat\u00f3rios\n\nempregando vari\u00e1veis de decis\u00e3o com dom\u00ednios discretos e ?nitos, e restri\u00e7\u00f5es capazes de expressar\n\nconcisamente certas combina\u00e7\u00f5es de valores e dom\u00ednios. A mesma modelagem, em programa\u00e7\u00e3o\n\nmatem\u00e1tica, seria muito mais complexa ou mesmo invi\u00e1vel em alguns casos. Apesar da falta de\n\ngarantias das t\u00e9cnicas empregadas na programa\u00e7\u00e3o por restri\u00e7\u00f5es, mecanismos de redu\u00e7\u00e3o dos do-\n\nm\u00ednios baseados na propaga\u00e7\u00e3o das restri\u00e7\u00f5es e algoritmos espec\u00ed?cos para a resolu\u00e7\u00e3o de algumas\n\nclasses especiais de problemas foram respons\u00e1veis por um consider\u00e1vel ganho de credibilidade, conso-\n\nlidando a modelagem em programa\u00e7\u00e3o por restri\u00e7\u00f5es como uma boa pr\u00e1tica para diversos problemas\n\ncombinat\u00f3rios e, em especial, de problemas de escalonamento.\n\nA.2 Representa\u00e7\u00e3o do Modelo e da Entrada de Dados\n\nA descri\u00e7\u00e3o do modelo em OPL consiste em um arquivo geralmente com extens\u00e3o .mod que \u00e9\n\ninterpretado linha a linha. Como os dados do problema n\u00e3o s\u00e3o sempre os mesmos por variar de\n\ninst\u00e2ncia para inst\u00e2ncia, \u00e9 importante considerar a entrada de dados separadamente. Isso \u00e9 feito\n\npor meio de um segundo arquivo com extens\u00e3o .dat. Ao separar modelagem e a entrada de dados,\n\nevita-se que o projetista do modelo se preocupe em tratar detalhes da entrada no mesmo arquivo\n\nutilizado para representar a formula\u00e7\u00e3o do problema.\n\nNo arquivo de descri\u00e7\u00e3o do modelo, interessa-nos manipular o conjunto de dados, descrever o\n\n\n\nELEMENTOS DE USO GERAL DA LINGUAGEM 91\n\nproblema de otimiza\u00e7\u00e3o e dar sa\u00edda a esse resultado de alguma maneira. Dessa forma, n\u00e3o conv\u00e9m\n\no tratamento expl\u00edcito da entrada de dados, que s\u00f3 pode ser feito por meio de constantes dentro\n\ndo arquivo do modelo. Atrav\u00e9s do arquivo .dat, a entrada de dados pode ser feita por meio de\n\nacesso a banco de dados, planilhas eletr\u00f4nicas ou arquivos de texto que obede\u00e7am a algumas regras\n\nde formata\u00e7\u00e3o. Por simplicidade, nos ateremos apenas a esse \u00faltimo caso no restante do texto,\n\nespecialmente porque o acesso a banco e planilhas \u00e9 especi?cado por meio de um arquivo de texto\n\nnessa sintaxe, e o leitor pode encontrar facilmente como faz\u00ea-lo para uma variedade de plataformas\n\nna documenta\u00e7\u00e3o o?cial da linguagem. Portanto, o modelo consiste ?sicamente em um arquivo\n\nde texto interpretado em linha de comando em conjunto com um, nenhum ou v\u00e1rios arquivos de\n\nentrada de dados, geralmente com extens\u00e3o .dat. Vale lembrar que, para que uma execu\u00e7\u00e3o n\u00e3o\n\nresulte em erro imediato, \u00e9 necess\u00e1rio que todos os dados necess\u00e1rios \u00e0 execu\u00e7\u00e3o do modelo estejam\n\nde?nidos exatamente uma vez ? seja no c\u00f3digo do modelo ou nos demais arquivos de entrada de\n\ndados ? e que n\u00e3o exista nenhum dado sem correspond\u00eancia ao modelo nesses arquivos.\n\nNum exemplo simples de execu\u00e7\u00e3o em linha de comando com um arquivo de modelo modelo.mod\n\ne um arquivo de dados dados.dat, temos a seguinte chamada:\n\noplrun modelo.mod dados.dat\n\nApesar de interpretado em linha de comando, a execu\u00e7\u00e3o pode ser realizada por meio de ambi-\n\nentes fornecidos pela ILOG como a OPL IDE. Al\u00e9m do desenvolvimento de modelos e execu\u00e7\u00e3o, a\n\nOPL IDE permite que par\u00e2metros do resolvedor possam ser con?gurados em um terceiro arquivo\n\nde con?gura\u00e7\u00f5es com extens\u00e3o .ops. Entretanto, muitos desses par\u00e2metros podem ser de?nidos no\n\npr\u00f3prio modelo, motivo pelo qual ser\u00e1 abordada apenas essa \u00faltima op\u00e7\u00e3o quanto o assunto for\n\ntratado.\n\nA.3 Elementos de Uso Geral da Linguagem\n\nNesta se\u00e7\u00e3o, s\u00e3o apresentados muitos dos elementos de uso geral da linguagem OPL e alguns\n\npeculiares ao resolvedor CP. \u00c9 importante frisar ao leitor que n\u00e3o se trata de uma cobertura\n\nexaustiva, mas de uma que garanta ao leitor dom\u00ednio sobre as estruturas comuns de maior uso.\n\nEssa cobertura procura dar embasamento ao acompanhamento do restante do texto.\n\nMuitos trechos de c\u00f3digo ser\u00e3o apresentados, e por isso conv\u00e9m explicitar desde j\u00e1 a conven\u00e7\u00e3o\n\nadotada. Todos eles ser\u00e3o delimitados por barras formando um quadro. Trechos de c\u00f3digo do modelo\n\nser\u00e3o apresentados com barras duplas e trechos do arquivo de entrada de dados ser\u00e3o apresentados\n\ncom barras simples. A numera\u00e7\u00e3o de linhas s\u00f3 ocorrer\u00e1 se o modelo for completo, n\u00e3o se aplicando a\n\ntrechos isolados. No texto subsequente a cada trecho de c\u00f3digo, coment\u00e1rios sobre o exemplo dado\n\npodem conter refer\u00eancias a vari\u00e1veis em it\u00e1lico ou trechos entre aspas e it\u00e1lico, representando parte\n\ndo c\u00f3digo ilustrado ou alguma pequena varia\u00e7\u00e3o a partir desse c\u00f3digo. Esse trecho pode ou n\u00e3o ser\n\nv\u00e1lido na linguagem. Em especial, trechos incorretos apresentados como contra-exemplo n\u00e3o foram\n\ndestacados por meio de quadros para evitar que pudessem ser confundidos com os trechos corretos.\n\nA.3.1 Escolha do Resolvedor do Modelo\n\nDevido ao foco restrito \u00e0 programa\u00e7\u00e3o por restri\u00e7\u00e3o e sua aplica\u00e7\u00e3o \u00e0 modelagem de problemas\n\ncombinat\u00f3rios ou de escalonamento, o texto n\u00e3o se ater\u00e1 apenas a conceitos gerais da linguagem\n\n\n\n92 AP\u00caNDICE A\n\nOPL, mas tamb\u00e9m a elementos especialmente desenvolvidos para melhor expressar problemas desse\n\ntipo. Assim, ?ca claro que certos modelos desenvolvidos com base nesses elementos n\u00e3o s\u00e3o com-\n\npat\u00edveis com um resolvedor de programa\u00e7\u00e3o matem\u00e1tica, restando a quest\u00e3o de como poderia o\n\ninterpretador do modelo determinar qual resolvedor utilizar para um modelo descrito se ambos ser-\n\nvirem. Por padr\u00e3o, um modelo em OPL \u00e9 interpretado como sendo de programa\u00e7\u00e3o matem\u00e1tica, a\n\nmenos que na sua primeira linha exista uma refer\u00eancia em contr\u00e1rio. Atualmente, dois resolvedores\n\ns\u00e3o poss\u00edveis: o CP para programa\u00e7\u00e3o por restri\u00e7\u00f5es e o CPLEX para programa\u00e7\u00e3o matem\u00e1tica.\n\nPara utilizar o CP, faz-se necess\u00e1rio constar o seguinte na primeira linha do modelo:\n\nusing CP;\n\nA.3.2 Coment\u00e1rios em Arquivos de Modelo e de Dados\n\nComo em muitas outras linguagens, \u00e9 poss\u00edvel inserir algum texto explicativo que seja ignorado\n\npelo resolvedor tanto no arquivo de modelo quanto nos arquivos de dados, mas que seja de grande\n\nvalia para outros seres humanos compreenderem com maior facilidade um c\u00f3digo alheio. Os comen-\n\nt\u00e1rios em OPL possuem a mesma sintaxe que em C++ ou Java: qualquer texto ap\u00f3s a ocorr\u00eancia\n\nde um // numa linha \u00e9 ignorado, bem como qualquer texto entre uma ocorr\u00eancia de /* e a pr\u00f3xima\n\nocorr\u00eancia de */, conforme o exemplo abaixo:\n\n// Linha comentada .\n\n/?\n? Bloco de texto comentado .\n?/\n\nA.3.3 Vari\u00e1veis de Tipos Primitivos e Atribui\u00e7\u00f5es\n\nPara modelar qualquer problema relevante, \u00e9 necess\u00e1rios conhecer primeiramente os tipos pri-\n\nmitivos e estruturas de dados mais b\u00e1sicas da linguagem. Na OPL, existem tr\u00eas tipos primitivos:\n\nint, ?oat e string. Ao longo desse texto, ser\u00e3o enfatizados os dois primeiros tipos. Na declara\u00e7\u00e3o\n\nde uma vari\u00e1vel, \u00e9 facultativo realizar uma atribui\u00e7\u00e3o inicial no arquivo de modelo. No exemplo\n\nabaixo, s\u00e3o declaradas uma vari\u00e1vel inteira sem atribuir um valor, bem como uma vari\u00e1vel inteira\n\ne outra de ponto ?utuante com atribui\u00e7\u00e3o de valor. Repare que cada instru\u00e7\u00e3o \u00e9 ?nalizada por um\n\nponto-e-v\u00edrgula em OPL:\n\nint noFabricas ;\n\nint noDepositos = 10;\n\nf l o a t taxaProducao = 5 . 0 ;\n\nPara que uma vari\u00e1vel tenha seu valor inicial atribu\u00eddo por alguma fonte de dados externa, \u00e9\n\nrealizada uma atribui\u00e7\u00e3o simb\u00f3lica utilizando retic\u00eancias (tr\u00eas pontos) em vez de um valor, conforme\n\no exemplo abaixo:\n\nint noFabricas = . . . ;\n\nEm correspond\u00eancia a essa declara\u00e7\u00e3o, em algum dos arquivos de dados dever\u00e1 haver uma atribui\u00e7\u00e3o\n\nrelacionada, como a apresentada a seguir:\n\nnoFabricas = 7;\n\n\n\nELEMENTOS DE USO GERAL DA LINGUAGEM 93\n\nQuando n\u00e3o \u00e9 atribu\u00eddo um valor explicitamente, a inicializa\u00e7\u00e3o da vari\u00e1vel ter\u00e1 de ocorrer por\n\nmeio de blocos de programa\u00e7\u00e3o imperativa, representados pela palavra reservada execute, como no\n\ntrecho de modelo abaixo:\n\nint noFabricas ;\n\nexecute {\n\nnoFabricas = 7;\n\n}\n\nDentro desses blocos, \u00e9 utilizada uma linguagem de script chamada ILOG Script, cuja estrutura\n\n\u00e9 baseada em Javascript. Conforme abordado adiante, \u00e9 poss\u00edvel declarar vari\u00e1veis nos trechos de\n\nILOG Script, mas tais vari\u00e1veis n\u00e3o servem \u00e0 modelagem do problema e sim a controles internos\n\ndesses blocos. A?nal, tais vari\u00e1veis s\u00e3o vis\u00edveis somente dentro dos blocos imperativos e sequer\n\npossuem tipo expl\u00edcito.\n\nQuando um modelo \u00e9 interpretado, ele \u00e9 processado linha a linha. Dessa forma, quando o bloco\n\n\u00e9 executado, ele s\u00f3 tem visibilidade e poder de a\u00e7\u00e3o sobre as vari\u00e1veis com declara\u00e7\u00e3o nas linhas\n\nacima dele. \u00c9 importante frisar que com os blocos de script \u00e9 poss\u00edvel alterar o valor atribu\u00eddo a uma\n\nvari\u00e1vel ao longo do processamento do modelo, algo que n\u00e3o se pode fazer de maneira declarativa\n\nna linguagem. O ILOG Script ser\u00e1 tratado novamente em outros pontos ao longo do texto.\n\nA.3.4 Estruturas de Dados B\u00e1sicas: Vetores e Dom\u00ednios\n\nPor meio de vetores e dom\u00ednios j\u00e1 se torna poss\u00edvel representar de maneira razo\u00e1vel os dados de\n\nmuitos problemas, de forma que boa parte dos exemplos dados ao longo do texto empregar\u00e3o essas\n\nestruturas de dados.\n\nO vetor de?nido em OPL \u00e9 muito similar ao encontrado em outras linguagens de programa\u00e7\u00e3o.\n\nEle consiste em uma representa\u00e7\u00e3o compacta de um conjunto de dados por meio de indexa\u00e7\u00e3o de\n\numa ou mais dimens\u00f5es. Um vetor com uma \u00fanica dimens\u00e3o consiste em uma sequ\u00eancia de valores,\n\nenquanto que em duas dimens\u00f5es ele pode ser visto como uma matriz, e assim por diante. Segue\n\nabaixo um exemplo de declara\u00e7\u00e3o de vetores de uma dimens\u00e3o e de duas dimens\u00f5es em OPL:\n\nint noProcessos [ 1 . . 3 ] ;\n\nf l o a t teorEnxofre [ 1 . . 3 ] [ 1 . . 2 ] ;\n\nUma diferen\u00e7a a ser notada na declara\u00e7\u00e3o de vetores em OPL \u00e9 que, al\u00e9m do \u00edndice ?nal,\n\ndeclara-se explicitamente o \u00edndice inicial em vez de adotar algum padr\u00e3o como 0 na linguagem C\n\nou 1 em Pascal. Entre os \u00edndices inicial e ?nal, constam dois pontos consecutivos, utilizados em\n\nconjun\u00e7\u00e3o com os dois \u00edndices para formar o dom\u00ednio de cada dimens\u00e3o. Isso remete \u00e0 de?ni\u00e7\u00e3o da\n\nestrutura de dados utilizada para representar explicitamente um dom\u00ednio em OPL, o range, com o\n\nqual \u00e9 poss\u00edvel tornar a declara\u00e7\u00e3o acima mais clara conforme apresentado abaixo:\n\nrange dRefinarias = 1 . . noRefinarias ;\n\nrange dDerivados = 1 . . noDerivados ;\n\nint noProcessos [ dRefinarias ] ;\n\nf l o a t teorEnxofre [ dDerivados ] [ dRefinarias ] ;\n\nComo pode ser observado, os exemplos sendo apresentados possuem uma conven\u00e7\u00e3o sint\u00e1tica\n\npeculiar ? por exemplo, o pre?xo no para quantidades inteiras e o pre?xo d para o dom\u00ednio variando\n\n\n\n94 AP\u00caNDICE A\n\nentre 1 e a quantidade determinada. Apesar de n\u00e3o representar nenhuma regra estrita, essa conven-\n\n\u00e7\u00e3o partiu da observa\u00e7\u00e3o do autor de algumas nomenclaturas comuns de vari\u00e1veis nos modelos em\n\nOPL e foi complementada com outras conven\u00e7\u00f5es que facilitaram o desenvolvimento de modelos\n\nmais elaborados ao longo do tempo.\n\nA.3.5 Atribui\u00e7\u00f5es B\u00e1sicas a Elementos de Vetores\n\nDa mesma forma que se faz para vari\u00e1veis de tipos primitivos, \u00e9 poss\u00edvel atribuir os valores de\n\num vetor de vari\u00e1veis pelas formas mencionadas anteriormente: estaticamente, delegando a alguma\n\nfonte de entrada de dados ou por meio de blocos de programa\u00e7\u00e3o imperativa. Al\u00e9m disso, tanto em\n\num caso como no outro tamb\u00e9m \u00e9 poss\u00edvel usar express\u00f5es para uma atribui\u00e7\u00e3o declarativa mais\n\nconcisa, conforme ser\u00e1 visto mais adiante.\n\nNo trecho abaixo, os mesmos vetores dos exemplos anteriores s\u00e3o declarados em conjunto com\n\numa atribui\u00e7\u00e3o est\u00e1tica:\n\nint noProcessos [ dRefinarias ] = [ 10 , 15 , 2 0 ] ;\n\nf l o a t teorEnxofre [ dDerivados ] [ dRefinarias ] = [\n\n[ 1/1000 , 1/1000000] ,\n\n[ 1/1200 , 1/1200000] ,\n\n[ 1/1500 , 1/1500000]\n\n] ;\n\nAbaixo, o primeiro desses vetores \u00e9 representado com delega\u00e7\u00e3o de atribui\u00e7\u00e3o para alguma fonte\n\nde dados externa:\n\nint peso [ dCarros ] = . . . ;\n\nE a seguir o trecho na fonte de dados:\n\npeso = [ 10000 , 15000 , 20000];\n\nPara realizar atribui\u00e7\u00f5es a valores de vetores utilizando ILOG Script, \u00e9 poss\u00edvel empregar estru-\n\nturas de controle de ?uxo id\u00eanticas \u00e0s encontradas em Javascript. Temos, por exemplo, as primitivas\n\nif, for, while etc, bem como outros operadores da sintaxe de Javascript. Segue um exemplo usando\n\nfor:\n\nint peso [ dCarros ] ;\n\nexecute {\n\nfor ( var ic in dCarros ) {\n\npeso [ ic ] = 5000?( ic +1) ;\n}\n\n}\n\nComo pode ser visto no exemplo acima, \u00e9 poss\u00edvel declarar uma vari\u00e1vel sem tipologia utilizando a\n\npalavra reservada var e iterar sobre um dom\u00ednio com a palavra reservada in no ILOG Script.\n\nUma vari\u00e1vel declarada em um bloco \u00e9 acess\u00edvel por outros blocos de script, de forma que\n\ndeclarar duas vezes o mesmo identi?cador como vari\u00e1vel em blocos distintos resultar\u00e1 em erro de\n\ninterpreta\u00e7\u00e3o quando a segunda declara\u00e7\u00e3o for atingida pelo interpretador. Dessa forma, outra boa\n\npr\u00e1tica observada consiste em sempre utilizar identi?cadores diferentes para evitar que um pequeno\n\ndescuido leve a um erro de interpreta\u00e7\u00e3o nas linhas ?nais de um modelo, desperdi\u00e7ando muito\n\n\n\nELEMENTOS DE USO GERAL DA LINGUAGEM 95\n\ntempo de processamento. Por esse motivo, foi utilizado ?var ic? no exemplo em vez de ?var i?, como\n\nseria de praxe.\n\nDevido \u00e0 falta de tipologia na declara\u00e7\u00e3o e \u00e0 documenta\u00e7\u00e3o inconclusiva, o autor desconhece\n\nformas de declarar um vetor nos blocos de script mas n\u00e3o pode a?rmar que elas n\u00e3o existam.\n\nAinda sim, \u00e9 poss\u00edvel enunciar um vetor na parte declarativa do modelo para utiliza\u00e7\u00e3o na parte\n\nimperativa, como no exemplo dado.\n\nA.3.6 Express\u00f5es Num\u00e9ricas e Predicados\n\nPara realizar algumas atribui\u00e7\u00f5es comuns baseadas em rela\u00e7\u00f5es conhecidas entre os \u00edndices no\n\nvetor e o valor a ser atribu\u00eddo, as formas descritas anteriormente obrigariam o projetista do modelo\n\na inserir v\u00e1rios trechos de programa\u00e7\u00e3o imperativa no mesmo. No entanto, \u00e9 poss\u00edvel evitar isso por\n\nmeio de express\u00f5es, com as quais representam-se muitas dessas atribui\u00e7\u00f5es de maneira declarativa\n\ne muito mais simples. Por exemplo, \u00e9 poss\u00edvel atribuir um \u00fanico valor para todas as entradas de\n\numa matriz em sua declara\u00e7\u00e3o:\n\nint n = . . . ;\n\nint matrizNula [ 1 . . n ] [ 1 . . n ] = 0;\n\nTorna-se uma atribui\u00e7\u00e3o declarativa mais din\u00e2mica atrav\u00e9s da utiliza\u00e7\u00e3o de vari\u00e1veis identi?-\n\ncando os \u00edndices do vetor para atribuir valores individualmente para cada elemento do vetor. Por\n\nexemplo, vejamos a opera\u00e7\u00e3o de transposi\u00e7\u00e3o da matriz M no trecho de modelo abaixo:\n\nint n = . . . ;\n\nint M[ 1 . . n ] [ 1 . . n ] = . . . ;\n\nint transpostaM [ i in 1 . . n ] [ j in 1 . . n ] = M[ j ] [ i ] ;\n\n\u00c9 importante ressaltar que as atribui\u00e7\u00f5es em express\u00f5es sobre valores s\u00e3o feitas com base nos\n\npr\u00f3prios valores e n\u00e3o por refer\u00eancia. Dessa forma, se a matriz M for alterada ap\u00f3s a cria\u00e7\u00e3o da\n\nmatriz transpostaM, tais altera\u00e7\u00f5es n\u00e3o re?etir\u00e3o nessa segunda matriz.\n\nEm OPL, \u00e9 poss\u00edvel construir express\u00f5es num\u00e9ricas e booleanas, sendo as \u00faltimas normalmente\n\nconhecidas como predicados. Nessas express\u00f5es, podemos nos valer de vari\u00e1veis representando \u00edndi-\n\nces do vetor recebendo uma atribui\u00e7\u00e3o. Por exemplo, \u00e9 poss\u00edvel reescrever a atribui\u00e7\u00e3o apresentada\n\nna se\u00e7\u00e3o anterior com bloco imperativo em uma \u00fanica linha declarativa por meio de uma express\u00e3o:\n\nint peso [ c in dCarros ] = 5000?( c+1) ;\n\nNesse exemplo, uma express\u00e3o num\u00e9rica atribui um valor para cada elemento do vetor. Ao contr\u00e1rio\n\ndo que ocorre para os blocos de programa\u00e7\u00e3o imperativa, o escopo dessas vari\u00e1veis sobre os \u00edndices\n\nde um vetor \u00e9 restrito \u00e0 express\u00e3o de atribui\u00e7\u00e3o e o identi?cador do \u00edndice pode ser utilizado em\n\noutros contextos sem nenhum problema.\n\nPara express\u00f5es num\u00e9ricas com vari\u00e1veis e constantes inteiras, \u00e9 poss\u00edvel utilizar operadores\n\nconhecidos de outras linguagens como +, ?, ?, div, mod (ou %). Os dois \u00faltimos operadores podem\nparecer estranhos a alguns leitores em raz\u00e3o da nomenclatura adotada. Eles representam, respecti-\n\nvamente, as opera\u00e7\u00f5es para obten\u00e7\u00e3o de quociente e de resto em uma divis\u00e3o inteira. Al\u00e9m desses\n\noperadores, a fun\u00e7\u00e3o abs pode ser utilizada para obter o valor absoluto do inteiro dado como argu-\n\nmento e o termo maxint \u00e9 utilizado para representar a constante correspondendo ao maior inteiro\n\nposs\u00edvel em uma vari\u00e1vel do tipo int.\n\n\n\n96 AP\u00caNDICE A\n\nEm express\u00f5es num\u00e9ricas envolvendo alguma vari\u00e1vel ou constante de ponto ?utuante, conta-\n\nse com os operadores +, ?, ?, / e a palavra reservada infinity para representar simbolicamente\numa quantidade in?nita. Em OPL, o operador / \u00e9 utilizado exclusivamente para divis\u00e3o de ponto\n\n?utuante, de forma que o resultado de uma divis\u00e3o de inteiros com / representar\u00e1 sempre o valor\n\nda divis\u00e3o em ponto ?utuante desses inteiros e n\u00e3o a respectiva divis\u00e3o inteira.\n\nPara introduzir uma forma de express\u00e3o num\u00e9rica v\u00e1lida e extremamente \u00fatil para valores\n\ninteiros e de ponto ?utuante, apresentaremos outro exemplo de manipula\u00e7\u00e3o de matrizes. No trecho\n\nde modelagem abaixo, temos a instancia\u00e7\u00e3o de uma matriz identidade:\n\nint identidade [ i in 1 . . n ] [ j in 1 . . n ] = (( i==j ) ?(1) : ( 0 ) ) ;\n\nNo exemplo anterior, observamos a utiliza\u00e7\u00e3o do operador tern\u00e1rio com a mesma sintaxe e sem\u00e2ntica\n\nencontrada em C e outras linguagens: a express\u00e3o num\u00e9rica ((X)?(Y ) : (Z)). Ela \u00e9 composta por\n\numa express\u00e3o booleana X e duas express\u00f5es num\u00e9ricas Y e Z, sendo seu resultado igual ao de Y\n\nse X for verdadeira e igual a Z caso contr\u00e1rio. Dessa forma, no exemplo, conseguimos que toda\n\nentrada da diagonal principal tenha valor 1 e as demais entradas tenham valor 0.\n\nExpress\u00f5es de valor booleano tamb\u00e9m s\u00e3o chamadas de predicados. \u00c9 poss\u00edvel construir predica-\n\ndos utilizando express\u00f5es num\u00e9ricas, vari\u00e1veis e constantes num\u00e9ricas relacionadas pelos operadores\n\nde compara\u00e7\u00e3o ==, ! =, >,&lt;, >= e&lt;=. Al\u00e9m disso, predicados podem ser compostos por outros\n\npredicados com base nos operadores booleanos de conjun\u00e7\u00e3o (&amp;&amp;), disjun\u00e7\u00e3o (||) e nega\u00e7\u00e3o (!) \u00e0\nsemelhan\u00e7a do que existe em C e outras linguagens similares.\n\nExpress\u00f5es booleanas tamb\u00e9m podem ser vistas como express\u00f5es num\u00e9ricas, sendo cada pre-\n\ndicado verdadeiro equivalente \u00e0 constante true e ao valor 1, e cada predicado falso equivalente \u00e0\n\nconstante false e ao valor 0. Assim, poder\u00edamos reescrever o exemplo anterior de maneira ainda\n\nmais compacta ? ainda que de modo um tanto quanto obscuro ? como abaixo:\n\nint identidade [ i in 1 . . n ] [ j in 1 . . n ] = ( i = = j ) ;\n\nUma \u00faltima ressalva a ser feita com rela\u00e7\u00e3o \u00e0 equival\u00eancia entre express\u00f5es num\u00e9ricas e predicados\n\n\u00e9 que, ao contr\u00e1rio de outras linguagens nas quais 0 \u00e9 falso e qualquer outro valor \u00e9 verdadeiro,\n\nisso n\u00e3o \u00e9 sempre verdade em OPL. Dessa forma, no projeto de um modelo, o projetista deve estar\n\nciente de que n\u00e3o pode esperar mais do que 0 ser equivalente a falso e 1 a verdadeiro. De uma\n\nmaneira geral, o que podemos concluir dessa observa\u00e7\u00e3o \u00e9 que n\u00e3o \u00e9 boa pr\u00e1tica utilizar valores que\n\nn\u00e3o 0 ou 1 no lugar de express\u00f5es booleanas.\n\nComo em outras linguagens, operadores num\u00e9ricos e l\u00f3gicos inserem-se em uma rela\u00e7\u00e3o de pre-\n\nced\u00eancia de forma a resolver boa parte das ambiguidades poss\u00edveis na interpreta\u00e7\u00e3o das express\u00f5es\n\nv\u00e1lidas na linguagem. Na OPL, essa rela\u00e7\u00e3o \u00e9 id\u00eantica \u00e0 de muitas outras linguagens. Por exemplo, a\n\nmultiplica\u00e7\u00e3o \u00e9 precedente \u00e0 soma, que \u00e9 precedente a qualquer operador l\u00f3gico. Na d\u00favida, ou para\n\ngarantir a sem\u00e2ntica da express\u00e3o sendo constru\u00edda a despeito de grandes mudan\u00e7as na linguagem,\n\npar\u00eanteses podem ser utilizados \u00e0 vontade.\n\nA.3.7 Operadores de Agrega\u00e7\u00e3o e Fun\u00e7\u00f5es Sobre Vetores\n\nPara concluir a apresenta\u00e7\u00e3o sobre express\u00f5es e predicados, restam os operadores de agrega\u00e7\u00e3o\n\ne as fun\u00e7\u00f5es sobre vetores. Os operadores de agrega\u00e7\u00e3o representam opera\u00e7\u00f5es muito comuns no\n\ntratamento dos dados de problemas combinat\u00f3rios. Alguns deles operam sobre os termos de um\n\n\n\nELEMENTOS DE USO GERAL DA LINGUAGEM 97\n\nconjunto indexado num\u00e9rico, sendo eles min, max, sum e prod. Eles s\u00e3o usados, respectivamente,\n\npara obter o valor m\u00ednimo, o valor m\u00e1ximo, a somat\u00f3ria e o produto de um conjunto de termos.\n\nVide, por exemplo, a atribui\u00e7\u00e3o a um vetor usando a express\u00e3o max sobre as linhas de uma matriz\n\nM e de uma vari\u00e1vel usando a express\u00e3o sum sobre os elementos do vetor resultante:\n\nint n = . . . ;\n\nint M[ 1 . . n ] [ 1 . . n ] = . . . ;\n\nint maxLinha [ i in 1 . . n ] = max( j in 1 . . n) M[ i ] [ j ] ;\n\nint somaMaximos = sum( i in 1 . . n) maxLinha [ i ] ;\n\nAl\u00e9m de operadores de agrega\u00e7\u00e3o para express\u00f5es num\u00e9ricas, tamb\u00e9m existem operadores de\n\nagrega\u00e7\u00e3o para predicados, como or e and. O operador or representa um predicado com valor\n\nverdadeiro se algum termo do conjunto indexado for verdadeiro, enquanto que o and \u00e9 verdadeiro\n\nse todos os termos do conjunto indexado forem verdadeiros.\n\nUm item importante a ser observado \u00e9 o comportamento desses operadores quando o conjunto for\n\nvazio: min resulta em infinity, max em ?infinity, prod \u00e9 1, sum \u00e9 0, or \u00e9 falso e and verdadeiro.\nOs termos dos conjuntos utilizados nos operadores de agrega\u00e7\u00e3o podem ser outros operadores ou\n\nexpress\u00f5es da mesma natureza que o operador, seja ele num\u00e9rico ou booleano. No exemplo abaixo\n\nsobre como calcular o quadrado de uma matriz M, \u00e9 ilustrado um caso no qual cada termo de um\n\nsomat\u00f3rio consiste em uma express\u00e3o num\u00e9rica sobre o \u00edndice k:\n\nint quadradoM [ i in 1 . . n ] [ j in 1 . . n ] = sum (k in 1 . . n) M[ i ] [ k ]?M[ k ] [ j ] ;\n\nEm alguns casos, \u00e9 poss\u00edvel substituir a composi\u00e7\u00e3o de opera\u00e7\u00f5es de agrega\u00e7\u00e3o por uma \u00fanica\n\nopera\u00e7\u00e3o com mais \u00edndices. No exemplo abaixo, \u00e9 de?nido um somat\u00f3rio sobre termos da M em-\n\npregando dois \u00edndices distintos para somar apenas o valor dos elementos abaixo de sua diagonal\n\nprincipal:\n\nint somaElementosInferioresM = sum( i in 1 . . n , j in 1 . . n : i>j ) M[ i ] [ j ] ;\n\nPara se somar apenas os elementos abaixo da diagonal principal, uma condi\u00e7\u00e3o foi imposta al\u00e9m\n\nda especi?ca\u00e7\u00e3o do dom\u00ednio dos \u00edndices. Essa condi\u00e7\u00e3o delimita quais duplas de valores devem ser\n\nconsideradas utilizando o s\u00edmbolo : acrescido de um predicado que de?ne um crit\u00e9rio de ?ltragem.\n\nQuando especi?camos um subconjunto do produto cartesiano dos dom\u00ednios dos \u00edndices para uti-\n\nlizar um operador de agrega\u00e7\u00e3o, estamos de?nindo um par\u00e2metro formal. Mais adiante, ser\u00e3o vistas\n\noutras situa\u00e7\u00f5es na linguagem em que par\u00e2metros formais podem ser empregados para representar\n\nconjuntos. Vale ressaltar que, at\u00e9 a presente vers\u00e3o do OPL, par\u00e2metros formais n\u00e3o suportam\n\na utiliza\u00e7\u00e3o interna de operadores de agrega\u00e7\u00e3o, isto \u00e9, um operador de agrega\u00e7\u00e3o n\u00e3o pode ser\n\nutilizado dentro do \u00edndice de outro operador de agrega\u00e7\u00e3o.\n\nEm alguns casos especiais, \u00e9 poss\u00edvel substituir a utiliza\u00e7\u00e3o de operadores de agrega\u00e7\u00e3o sobre\n\nconjuntos indexados por uma fun\u00e7\u00e3o que opere sobre vetores. Por exemplo, para contar o n\u00famero de\n\nocorr\u00eancias de um valor em um vetor, pode-se utilizar a fun\u00e7\u00e3o count. Essa fun\u00e7\u00e3o recebe um vetor\n\nde uma dimens\u00e3o e um valor como par\u00e2metros para retornar o n\u00famero de vezes que o valor aparece\n\nno vetor. Para calcular o desvio padr\u00e3o de um vetor inteiro, existe a fun\u00e7\u00e3o standardDeviation.\n\nAmbas est\u00e3o apresentadas no exemplo a seguir:\n\n\n\n98 AP\u00caNDICE A\n\nint x = . . . ;\n\nint n = . . . ;\n\nint vetor [ 1 . . n ] = . . . ;\n\nint M[ 1 . . n ] [ 1 . . n ] = . . . ;\n\nint elementosVetorIguaisX = count ( vetor , x) ;\n\nint ocorrenciasXporLinhaM [ i in 1 . . n ] = count (M[ i ] , x) ;\n\nf l o a t desvioPadraoPorLinhaM [ i in 1 . . n ] = standardDeviation (M[ i ] ) ;\n\nNa pen\u00faltima linha do exemplo acima, foi utilizada a fun\u00e7\u00e3o count sobre um vetor extra\u00eddo da\n\nmatriz M. Dessa forma, foi contado o n\u00famero de ocorr\u00eancias de um valor para cada linha dessa\n\nmatriz. Tal vetor foi obtido a partir da matriz M pela n\u00e3o-indexa\u00e7\u00e3o de sua \u00faltima dimens\u00e3o. Fazer\n\no mesmo de forma t\u00e3o simples para obter uma coluna de M n\u00e3o \u00e9 poss\u00edvel, e em princ\u00edpio isso\n\npoderia limitar a aplicabilidade de fun\u00e7\u00f5es sobre vetores, como \u00e9 o caso de count.\n\nPara esses casos, utiliza-se o operador all para criar um vetor unidimensional a partir de um\n\npar\u00e2metro formal sobre um vetor qualquer de uma ou mais dimens\u00f5es. Esse operador \u00e9 necess\u00e1rio\n\nporque tais fun\u00e7\u00f5es n\u00e3o permitem a utiliza\u00e7\u00e3o de par\u00e2metros formais diretamente, como \u00e9 o caso\n\ndos operadores de agrega\u00e7\u00e3o. Seguem alguns exemplos:\n\nint ocorrenciasXporColuna [ j in 1 . . n ] = count ( a l l ( i in 1 . . n) M[ i ] [ j ] , x) ;\n\nint ocorrenciasXnaDiagonal = count ( a l l ( i in i . . n , j in 1 . . n : i==j ) M[ i ] [ j ] , x) ;\n\nNa primeira linha do exemplo acima, foi apresentada uma forma de contar as ocorr\u00eancias de um\n\nvalor na coluna de uma matriz por meio da cria\u00e7\u00e3o de um vetor contendo apenas os elementos\n\ndaquela coluna da matriz. Na segunda linha, foi apresentada uma forma de calcular a ocorr\u00eancia\n\nde um valor na diagonal principal dessa matriz.\n\nO operador all tamb\u00e9m pode ser utilizado para atribui\u00e7\u00e3o em um vetor, isto \u00e9, podemos extrair\n\na coluna de uma matriz para um vetor e at\u00e9 mesmo unir o resultado de algumas dessas opera\u00e7\u00f5es\n\npara obter um vetor maior por meio da fun\u00e7\u00e3o append, como nos exemplos abaixo:\n\nint coluna2deM [ 1 . . n ] = a l l ( i in 1 . . n) M[ i ] [ 2 ] ;\n\nint colunas2e5deM [ 1 . . 2 ? n ] =\nappend ( a l l ( i in 1 . . n) M[ i ] [ 2 ] , a l l ( i in 1 . . n) M[ i ] [ 5 ] ) ;\n\nNa primeira linha do exemplo, foi criado um vetor com base na segunda coluna de uma matriz M.\n\nNa segunda linha, foi criado um vetor com o dobro do tamanho do anterior por meio da jun\u00e7\u00e3o de\n\ndois vetores contendo, cada um, uma coluna de M.\n\nAs fun\u00e7\u00f5es count e standardDeviation n\u00e3o s\u00e3o os \u00fanicos exemplos de express\u00f5es que utilizem\n\nvetores de uma dimens\u00e3o como argumento. Quando forem tratadas as restri\u00e7\u00f5es especializadas e\n\npredicados para escalonamento, observaremos outras fun\u00e7\u00f5es com essa caracter\u00edstica, expandindo o\n\nleque de possibilidades de aplica\u00e7\u00e3o do operador all.\n\nA.3.8 Estruturas de Dados Avan\u00e7adas: Tuplas e Conjuntos\n\nDevido ao prop\u00f3sito introdut\u00f3rio desse texto, n\u00e3o se entrar\u00e1 em muitos detalhes sobre as es-\n\ntruturas de dados mais avan\u00e7adas dispon\u00edveis em OPL: as tuplas e os conjuntos. Entretanto, n\u00e3o\n\n\u00e9 possivel ignorar as tuplas e conjuntos por completo sem algum preju\u00edzo quando o texto atingir a\n\nparte sobre escalonamento.\n\n\n\nMODELAGEM DE PROBLEMAS COMBINAT\u00d3RIOS 99\n\nUma tupla consiste em uma composi\u00e7\u00e3o de vari\u00e1veis a partir da qual se de?ne um tipo atrav\u00e9s\n\nda palavra reservada tuple, possibilitando a declara\u00e7\u00e3o de vari\u00e1veis pre?xando-as com o tipo dado\n\n\u00e0 tupla, como no exemplo a seguir:\n\ntuple ProcessoConversao {\n\nf l o a t entrada ;\n\nf l o a t saida ;\n\n}\n\nProcessoConversao conversoes [ 1 . . 3 ] = [\n\n<3.5 , 2.9 > ,\n\n<4.0 , 3.0 > ,\n\n<4.5 , 3.1 > ,\n\n] ;\n\nCom base no exemplo acima, o acesso ao valor de entrada do primeiro processo \u00e9 dado pela express\u00e3o\n\n?conversoes[1].entrada?.\n\nOs conceitos apresentados para a atribui\u00e7\u00e3o por express\u00e3o tamb\u00e9m s\u00e3o v\u00e1lidos para tuplas, de\n\nforma que \u00e9 poss\u00edvel criar express\u00f5es indexadas para especi?car uma tupla para cada \u00edndice diferente\n\nde um vetor, como na adapta\u00e7\u00e3o do exemplo anterior feita abaixo:\n\nProcessoConversao conversoes [ i in 1 . . 3 ] =\n\n&lt;3 + 0.5? i , 2.8 + 0.1? i >;\n\nUm conjunto consiste em um agrupamento de valores de algum tipo que, ao contr\u00e1rio dos vetores,\n\nn\u00e3o possui dimens\u00f5es de indexa\u00e7\u00e3o. No exemplo abaixo, \u00e9 declarado um conjunto de inteiros sem\n\nqualquer indexa\u00e7\u00e3o expl\u00edcita:\n\n{ int } pesos = {10000 , 15000 , 20000};\n\nClaramente, existe uma vantagem expressiva pela utiliza\u00e7\u00e3o de tuplas e conjuntos pelo fato que\n\nas propriedades de uma entidade do modelo possam ser representadas compactamente tanto na\n\ndeclara\u00e7\u00e3o quanto na atribui\u00e7\u00e3o dos dados. Dessa forma, \u00e9 recomendado que o leitor interessado em\n\num uso prolongado da ferramenta se aprofunde no estudo dessas estruturas para projetar modelos\n\nmais estruturados.\n\nA.4 Modelagem de Problemas Combinat\u00f3rios\n\nAt\u00e9 esse ponto do texto foram tratados apenas elementos relevantes ao pr\u00e9-processamento do\n\nproblema: escolha do resolvedor, de?ni\u00e7\u00e3o das estruturas de dados, atribui\u00e7\u00e3o dos dados e mani-\n\npula\u00e7\u00e3o inicial dos dados. Com esses elementos em m\u00e3os e apropriadamente descritos no modelo,\n\npodemos passar \u00e0 formula\u00e7\u00e3o do problema para ser resolvido pelo resolvedor. Um arquivo de modelo\n\nem OPL geralmente consiste em um \u00fanico problema a ser resolvido. Ap\u00f3s a descri\u00e7\u00e3o do problema\n\nser interpretada e a etapa de resolu\u00e7\u00e3o conclu\u00edda, passa-se \u00e0 etapa de p\u00f3s-processamento, na qual\n\nnovas manipula\u00e7\u00f5es de dados tomam lugar e na qual, geralmente, encontram-se rotinas de impress\u00e3o\n\npara apresentar os resultados obtidos com o modelo da maneira que melhor interessar ao modelador.\n\nDessa forma, passaremos agora \u00e0 de?ni\u00e7\u00e3o do problema e quaisquer outras informa\u00e7\u00f5es relevan-\n\ntes ao p\u00f3s-processamento.\n\n\n\n100 AP\u00caNDICE A\n\nA.4.1 Vari\u00e1veis de Decis\u00e3o de Tipos Primitivos\n\nO primeiro passo para expressar um problema decis\u00f3rio ou de otimiza\u00e7\u00e3o consiste na declara\u00e7\u00e3o\n\nde suas vari\u00e1veis de decis\u00e3o. A solu\u00e7\u00e3o de um problema consistir\u00e1 em uma atribui\u00e7\u00e3o v\u00e1lida de\n\nvalores a tais vari\u00e1veis. A escolha dessa atribui\u00e7\u00e3o depender\u00e1 de outros fatores que ser\u00e3o vistos\n\nadiante, como o conjunto de restri\u00e7\u00f5es e a fun\u00e7\u00e3o objetivo.\n\nA palavra reservada dvar \u00e9 empregada antes do tipo da vari\u00e1vel para identi?car que a vari\u00e1vel\n\nsendo declarada \u00e9 de decis\u00e3o. Dos tipos primitivos, \u00e9 poss\u00edvel declarar vari\u00e1veis de decis\u00e3o usando\n\nint e float, al\u00e9m da op\u00e7\u00e3o de acrescer + ao nome do tipo para que a vari\u00e1vel seja n\u00e3o-negativa,\n\nisto \u00e9, maior ou igual a 0. Al\u00e9m disso, podemos substituir int por boolean se os valores v\u00e1lidos para\n\na vari\u00e1vel forem apenas 0 e 1. Conv\u00e9m observar que as vari\u00e1veis do tipo float n\u00e3o ser\u00e3o detalhadas\n\ndevido ao fato de n\u00e3o serem aceitas em modelos empregando o resolvedor CP. Isso se deve \u00e0 premissa\n\nde que as vari\u00e1veis tenham dom\u00ednio discreto e ?nito em problemas abordados com programa\u00e7\u00e3o por\n\nrestri\u00e7\u00f5es. \u00c9 poss\u00edvel declarar esse dom\u00ednio explicitamente utilizando a palavra reservada in ap\u00f3s o\n\nnome da vari\u00e1vel seguida do dom\u00ednio da mesma. Se um dom\u00ednio n\u00e3o for especi?cado, s\u00e3o utilizados\n\nos limites de uma vari\u00e1vel inteira na arquitetura adotada pelo resolvedor.\n\nAbaixo s\u00e3o apresentados alguns exemplos de declara\u00e7\u00f5es de vari\u00e1veis de decis\u00e3o inteiras na\n\nlinguagem OPL:\n\ndvar int escolha in 1 . . 5 ;\n\ndvar int+ quantidade ;\n\nNa primeira declara\u00e7\u00e3o do exemplo, temos uma vari\u00e1vel inteira restrita a um dom\u00ednio atrav\u00e9s da\n\nutiliza\u00e7\u00e3o do operador in. Na segunda declara\u00e7\u00e3o, temos uma vari\u00e1vel inteira n\u00e3o-negativa sem\n\nrestri\u00e7\u00e3o de dom\u00ednio, ?cando subentendido ao resolvedor que o dom\u00ednio da vari\u00e1vel \u00e9 0..maxint.\n\nOs conceitos apresentados acima s\u00e3o naturalmente aplic\u00e1veis \u00e0 declara\u00e7\u00e3o de vetores de vari\u00e1veis\n\nde decis\u00e3o. Nesse caso, express\u00f5es sobre os \u00edndices podem ser empregadas para de?nir um dom\u00ednio\n\ndiferente a cada vari\u00e1vel do vetor, como pode ser visto no exemplo a seguir:\n\nint noProcessos = . . . ;\n\nrange dProcessos = 1 . . noProcessos ;\n\nint nivelMaximoProcesso [ dProcessos ] = . . . ;\n\ndvar int nivel [ p in dProcessos ] in 0 . . nivelMaximoProcesso [ p ] ;\n\nAo contr\u00e1rio das outras vari\u00e1veis, as vari\u00e1veis de decis\u00e3o de um modelo normalmente n\u00e3o pos-\n\nsuem atribui\u00e7\u00e3o em sua declara\u00e7\u00e3o, apesar disso ser poss\u00edvel em casos mais elaborados fora do escopo\n\ndesse texto. No entanto, em algumas situa\u00e7\u00f5es o modelo sendo desenvolvido pode deixar clara a\n\nnecessidade de manipula\u00e7\u00e3o de algumas vari\u00e1veis dependentes de valores de vari\u00e1veis de decis\u00e3o.\n\nTais vari\u00e1veis poderiam ser de?nidas como vari\u00e1veis de decis\u00e3o e essa rela\u00e7\u00e3o poderia ser expressa\n\npor meio de restri\u00e7\u00f5es. No entanto, existe uma alternativa em OPL para evitar uma quantidade\n\nexcessiva de vari\u00e1veis de decis\u00e3o no modelo: as express\u00f5es de decis\u00e3o, descritas a seguir.\n\nA.4.2 Express\u00f5es de Decis\u00e3o\n\nUma express\u00e3o de decis\u00e3o pode ser entendida como uma vari\u00e1vel que possui o identi?cador dexpr\n\nantes de seu tipo na declara\u00e7\u00e3o. Ela sempre recebe uma atribui\u00e7\u00e3o na forma de express\u00e3o, que pode\n\nenvolver constantes, vari\u00e1veis, vari\u00e1veis de decis\u00e3o e outras express\u00f5es de decis\u00e3o. Ao contr\u00e1rio do\n\nque ocorre com as vari\u00e1veis de decis\u00e3o, n\u00e3o existe restri\u00e7\u00e3o sobre express\u00f5es de decis\u00e3o envolvendo o\n\n\n\nMODELAGEM DE PROBLEMAS COMBINAT\u00d3RIOS 101\n\ntipo float em modelos utilizando o resolvedor CP. Al\u00e9m disso, as express\u00f5es de decis\u00e3o possibilitam\n\nreduzir o espa\u00e7o de busca ao estabelecer uma rela\u00e7\u00e3o entre diferentes par\u00e2metros do sistema sendo\n\nmodelado sem necessariamente de?ni-los todos como vari\u00e1veis de decis\u00e3o. Dessa forma, \u00e9 poss\u00edvel\n\nde?nir uma hierarquia entre decis\u00f5es e facilitar o processo de resolu\u00e7\u00e3o do problema.\n\nAbaixo temos um exemplo da utiliza\u00e7\u00e3o de express\u00f5es de decis\u00e3o sobre o vetor de vari\u00e1veis de\n\ndecis\u00e3o previamente de?nido:\n\nint maxNivelProcesso = max (p in dProcessos ) nivelMaximoProcesso [ p ] ;\n\nrange dNiveis = 0 . . maxNivelProcesso ;\n\nf l o a t custoExecucaoProcessoNivel [ p in dProcessos ] [ dNiveis ] = . . . ;\n\ndexpr f l o a t custoExecucaoTotal =\n\nsum(p in dProcessos , n in dNiveis )\n\n( nivel [ p]==n) ?( custoExecucaoProcessoNivel [ p ] [ n ] ) : ( 0 ) ;\n\n\u00c0 primeira vista, pode parecer que a express\u00e3o de decis\u00e3o do exemplo acima poderia ser reescrita\n\nde maneiras mais compactas. Dessa forma, vamos analisar como se suporia que esse trecho poderia\n\nter sido progressivamente compactado para ilustrar as limita\u00e7\u00f5es inerentes.\n\nPrimeiro, poder\u00edamos supor que o predicado do operador condicional pudesse ser colocado den-\n\ntro do somat\u00f3rio, criando um par\u00e2metro formal mais restrito. Entretanto, isso n\u00e3o \u00e9 poss\u00edvel e esse\n\n\u00e9 um problema bastante comum nos primeiros modelos que se faz em OPL: vari\u00e1veis e express\u00f5es\n\nde decis\u00e3o n\u00e3o podem constar em par\u00e2metros formais antes do p\u00f3s-processamento, isto \u00e9, enquanto\n\nessas vari\u00e1veis n\u00e3o possuem um valor ?xo de?nido. \u00c9 mencionado em muitos pontos do manual o?-\n\ncial da linguagem que certos operadores e predicados n\u00e3o suportam aplica\u00e7\u00e3o como meta-restri\u00e7\u00f5es,\n\no que signi?ca que n\u00e3o se pode empregar nessas fun\u00e7\u00f5es nenhum argumento baseado em vari\u00e1veis\n\nde decis\u00e3o ou express\u00f5es de decis\u00e3o. Nesse caso, n\u00e3o \u00e9 poss\u00edvel escrever ?sum(p in dProcessos, n\n\nin dNiveis : nivel[p]==n)? porque ?nivel[p]? representa uma vari\u00e1vel de decis\u00e3o e a express\u00e3o n\u00e3o\n\npode ser interpretada antes dessa vari\u00e1vel ter seu valor decidido pela resolu\u00e7\u00e3o.\n\nSegundo, poder\u00edamos supor uma compacta\u00e7\u00e3o ainda maior do modelo usando as vari\u00e1veis de\n\ndecis\u00e3o para indexa\u00e7\u00e3o, reescrevendo o somat\u00f3rio como ?sum(p in dProcessos) (custoExecucaoPro-\n\ncessoNivel[p][nivel[p]])?. Entretanto, a limita\u00e7\u00e3o mencionada anteriormente tamb\u00e9m se estende \u00e0\n\nutiliza\u00e7\u00e3o de vari\u00e1veis pre?xadas por dvar e dexpr para o acesso a \u00edndices de vetores em express\u00f5es\n\nde decis\u00e3o ou mesmo em restri\u00e7\u00f5es. A?nal, isso signi?caria usar uma vari\u00e1vel de decis\u00e3o como \u00edndice\n\nde acesso a uma matriz para gerar o valor de uma express\u00e3o de decis\u00e3o durante a execu\u00e7\u00e3o, algo\n\nque o interpretador n\u00e3o \u00e9 capaz de fazer por n\u00e3o ter um valor de?nido \u00e0s vari\u00e1veis de decis\u00e3o e\n\nexpress\u00f5es.\n\nAl\u00e9m dessas quest\u00f5es, outra precau\u00e7\u00e3o a ser tomada com rela\u00e7\u00e3o a vari\u00e1veis de decis\u00e3o e expres-\n\ns\u00f5es de decis\u00e3o se relaciona ao fato de que elas s\u00e3o vari\u00e1veis sem valor de?nido para manipula\u00e7\u00e3o\n\nantes da resolu\u00e7\u00e3o do problema, que ocorre ap\u00f3s o bloco de restri\u00e7\u00f5es ? n\u00e3o tratado at\u00e9 esse ponto\n\ndo texto. Dessa forma, instru\u00e7\u00f5es imperativas que tentem acessar o valor dessas vari\u00e1veis antes do\n\np\u00f3s-processamento podem ter comportamento inesperado. No mais, essas vari\u00e1veis podem ser uti-\n\nlizadas indistintamente de outros tipos de vari\u00e1veis na de?ni\u00e7\u00e3o da fun\u00e7\u00e3o objetivo e das restri\u00e7\u00f5es\n\ndo modelo, como veremos adiante.\n\n\n\n102 AP\u00caNDICE A\n\nA.4.3 Sobre a Impossibilidade de Usar Vari\u00e1veis float em CP\n\nVisto que os valores que podem ser atribu\u00eddos a uma vari\u00e1vel de ponto ?utuante tamb\u00e9m repre-\n\nsentam um conjunto discreto devido \u00e0 limita\u00e7\u00e3o de precis\u00e3o em m\u00e1quina, poder-se-ia argumentar\n\nque tamb\u00e9m seria poss\u00edvel utilizar uma vari\u00e1vel de decis\u00e3o em ponto ?utuante em programa\u00e7\u00e3o por\n\nrestri\u00e7\u00f5es, a despeito da di?culdade de implementa\u00e7\u00e3o de algoritmos de resolu\u00e7\u00e3o baseados nesse\n\nfato.\n\nUm bom argumento para justi?car a inexist\u00eancia dessa possibilidade tanto em OPL como em\n\noutras linguagens \u00e9 o de que o objetivo da programa\u00e7\u00e3o por restri\u00e7\u00f5es consiste na resolu\u00e7\u00e3o de\n\nproblemas combinat\u00f3rios e n\u00e3o de programa\u00e7\u00e3o matem\u00e1tica, para os quais outros resolvedores\n\npossuem melhor desempenho. Essa especializa\u00e7\u00e3o dos algoritmos desenvolvidos para a resolu\u00e7\u00e3o\n\nde problemas combinat\u00f3rios em modelos de programa\u00e7\u00e3o por restri\u00e7\u00f5es torna a t\u00e9cnica bastante\n\ncompetitiva para tais problemas, mas implica em trabalhar sobre dom\u00ednios com caracter\u00edsticas\n\nbastante peculiares. No caso de um intervalo de valores represent\u00e1veis por uma vari\u00e1vel de ponto\n\n?utuante, isso exigiria o projeto de todo um novo conjunto de algoritmos mais complexos e que\n\nse prestariam, em muitos casos, a resolver problemas que podem ser tratados de maneira mais\n\nelegante por outras t\u00e9cnicas. Ainda sim, \u00e9 poss\u00edvel que algumas propriedades da solu\u00e7\u00e3o de um\n\nproblema combinat\u00f3rio tenham valores em ponto ?utuante sem que seja necess\u00e1rio representar tais\n\npropriedades como vari\u00e1veis de decis\u00e3o do modelo, como vimos para as vari\u00e1veis de express\u00e3o de\n\ndecis\u00e3o.\n\nA.4.4 Fun\u00e7\u00e3o Objetivo\n\nQuando trabalhamos com um problema de otimiza\u00e7\u00e3o, desejamos n\u00e3o apenas obter uma solu\u00e7\u00e3o\n\nque satisfa\u00e7a \u00e0s restri\u00e7\u00f5es do modelo ? como ser\u00e1 visto adiante. Al\u00e9m disso, podemos querer que\n\na solu\u00e7\u00e3o encontrada seja comparada com outras solu\u00e7\u00f5es poss\u00edveis de acordo com algum crit\u00e9rio\n\nquantitativo para que a solu\u00e7\u00e3o ?nal seja a melhor dentre as encontradas durante a resolu\u00e7\u00e3o. A essa\n\nmedida quantitativa damos o nome de fun\u00e7\u00e3o objetivo, que deve ser maximizada ou minimizada,\n\nconforme o problema e a modelagem dados.\n\nEm OPL, uma fun\u00e7\u00e3o objetivo \u00e9 declarada ap\u00f3s as vari\u00e1veis de decis\u00e3o e antes do bloco de\n\nrestri\u00e7\u00f5es, sendo poss\u00edvel declarar apenas uma fun\u00e7\u00e3o objetivo por modelo. Ela \u00e9 caracterizada por\n\nalguma das palavras reservadas minimize ou maximize, dependendo do problema ser de minimi-\n\nza\u00e7\u00e3o ou de maximiza\u00e7\u00e3o. Ap\u00f3s a palavra reservada, a fun\u00e7\u00e3o objetivo declarada segue as mesmas\n\nregras de composi\u00e7\u00e3o que as express\u00f5es de decis\u00e3o, sendo boa pr\u00e1tica em grandes projetos de?nir a\n\nfun\u00e7\u00e3o objetivo apenas sobre uma fun\u00e7\u00e3o linear de express\u00f5es de decis\u00e3o, isto \u00e9, a soma do produto\n\nde express\u00f5es de decis\u00e3o por constantes. Embora seja comum que problemas sejam de otimiza\u00e7\u00e3o,\n\nisso nem sempre \u00e9 verdade e ela pode n\u00e3o ser encontrada no modelo ? caso em que se trata de um\n\nproblema decis\u00f3rio. Nesse caso, o resolvedor interrompe a busca quando encontra a primeira solu-\n\n\u00e7\u00e3o, visto que n\u00e3o h\u00e1 raz\u00e3o para continuar a procura se n\u00e3o houver qualquer m\u00e9trica que justi?que\n\nque a solu\u00e7\u00e3o encontrada n\u00e3o seja a mais adequada.\n\nSegue abaixo um exemplo de fun\u00e7\u00e3o objetivo de minimiza\u00e7\u00e3o sobre a express\u00e3o de decis\u00e3o\n\ndeclarada anteriormente:\n\nminimize custoExecucaoTotal ;\n\n\n\nMODELAGEM DE PROBLEMAS COMBINAT\u00d3RIOS 103\n\nA.4.5 Restri\u00e7\u00f5es B\u00e1sicas Sobre Tipos Primitivos\n\nUma vez de?nidas as vari\u00e1veis de decis\u00e3o e a fun\u00e7\u00e3o objetivo, resta a de?ni\u00e7\u00e3o do conjunto\n\nde restri\u00e7\u00f5es para completar a modelagem do problema. Essa de?ni\u00e7\u00e3o \u00e9 feita dentro de um bloco\n\npre?xado por subject to, como a seguir:\n\nsubject to {\n\n// Restri\u00e7\u00f5es do modelo .\n\n}\n\nDentro desse bloco, ser\u00e3o especi?cados apenas predicados. Em termos de programa\u00e7\u00e3o por restri-\n\n\u00e7\u00f5es, esses predicados de?nir\u00e3o um problema de satisfabilidade, isto \u00e9, um problema para o qual a\n\nsolu\u00e7\u00e3o consistir\u00e1 em uma atribui\u00e7\u00e3o de valores \u00e0s vari\u00e1veis de decis\u00e3o de tal forma que todos os\n\npredicados do bloco de restri\u00e7\u00f5es estejam satisfeitos. Se n\u00e3o houver con?gura\u00e7\u00e3o com a qual isso\n\nseja poss\u00edvel, diz-se que o problema \u00e9 insatisfat\u00edvel, n\u00e3o havendo solu\u00e7\u00e3o.\n\nConforme mencionado anteriormente, esses predicados podem ser de?nidos em termos de ex-\n\npress\u00f5es num\u00e9ricas envolvendo opera\u00e7\u00f5es aritm\u00e9ticas inteiras e de ponto ?utuante, operadores de\n\nagrega\u00e7\u00e3o ou outras fun\u00e7\u00f5es como abs e count em associa\u00e7\u00e3o a comparadores, como no exemplo\n\nabaixo:\n\ndvar int+ criancas ;\n\ndvar int+ menores ;\n\ndvar int+ adolescentes ;\n\nsubject to {\n\ncriancas == menores ? adolescentes ;\n}\n\nNo exemplo acima, foi de?nida uma rela\u00e7\u00e3o entre as vari\u00e1veis de decis\u00e3o criancas, menores e\n\nadolescentes.\n\nA partir dos pr\u00f3ximos exemplos, as restri\u00e7\u00f5es ser\u00e3o geralmente apresentadas sem o bloco externo\n\ndemarcado com subject to, por simplicidade.\n\nEm muitos problemas de otimiza\u00e7\u00e3o, encontram-se conjuntos de restri\u00e7\u00f5es de?nidas sobre \u00edn-\n\ndices. Para fazer o mesmo em OPL, utiliza-se a palavra reservada forall seguida de um par de\n\npar\u00eanteses dentro do qual um par\u00e2metro formal \u00e9 de?nido e um bloco para a de?ni\u00e7\u00e3o de restri\u00e7\u00f5es\n\nque podem contar com os \u00edndices do par\u00e2metro formal. No exemplo a seguir, ilustra-se o conceito\n\ncom o vetor de vari\u00e1veis de decis\u00e3o de?nido na se\u00e7\u00e3o anterior:\n\nf o r a l l (p in dProcessos : p<noProcessos ) {\n\nnivel [ p ] >= nivel [ p+1];\n\n}\n\nCom a restri\u00e7\u00e3o acima, for\u00e7amos que o vetor esteja em ordem n\u00e3o-crescente de valores, i.e., o valor\n\nde nivel[p] nunca \u00e9 menor que o de nivel[p+ 1]. Observe que os limites de indexa\u00e7\u00e3o s\u00e3o observados\n\ngra\u00e7as a uma condi\u00e7\u00e3o no par\u00e2metro formal que impede o estouro do vetor.\n\nConv\u00e9m frisar novamente que, na de?ni\u00e7\u00e3o de par\u00e2metros formais dentro do bloco de restri\u00e7\u00f5es,\n\nn\u00e3o se pode utilizar vari\u00e1veis de decis\u00e3o. Apesar disso, existe uma constru\u00e7\u00e3o de implica\u00e7\u00e3o l\u00f3gica\n\nque aceita vari\u00e1veis de decis\u00e3o. Ela consiste de dois predicados separados por =>, signi?cando que a\n\nveracidade do primeiro implica na veracidade do segundo para que a restri\u00e7\u00e3o seja satisfeita. Segue\n\num exemplo baseado nas mesmas vari\u00e1veis e em declara\u00e7\u00f5es da se\u00e7\u00e3o anterior:\n\n\n\n104 AP\u00caNDICE A\n\nf o r a l l (p in dProcessos : p<) {\n\n( nivel [ p]==nivelMaximoProcesso [ p ] ) =>\n\n( nivel [ p+1] &lt;nivel [ p ] ) ;\n\n}\n\nA.4.6 Restri\u00e7\u00f5es Especializadas Sobre Tipos Primitivos\n\nAl\u00e9m das restri\u00e7\u00f5es poss\u00edveis pelo rol de elementos descritos at\u00e9 agora, em CP ainda \u00e9 pos-\n\ns\u00edvel utilizar algumas restri\u00e7\u00f5es especializadas. Essas restri\u00e7\u00f5es representam ocorr\u00eancias comuns\n\nem problemas combinat\u00f3rios, permitindo modelar v\u00e1rios problemas com uma quantidade menor\n\nde vari\u00e1veis e que o resolvedor trabalhe de maneira mais e?ciente em tais problemas por existi-\n\nrem algoritmos de redu\u00e7\u00e3o de dom\u00ednios espec\u00ed?cos para essas restri\u00e7\u00f5es. S\u00e3o elas: allDifferent,\n\nallMinDistance, inverse, lex e pack.\n\nO predicado allDifferent \u00e9 verdadeiro se todos os elementos do vetor inteiro unidimensional\n\ndado como argumento forem diferentes entre si. \u00c9 poss\u00edvel, por exemplo, expressar o seguinte:\n\na l l D i f f e r e n t ( niveis ) ;\n\nNesse exemplo, expressa-se que cada n\u00edvel dever\u00e1 ser diferente dos demais. Com allDifferent,\n\nevita-se ter que especi?car uma restri\u00e7\u00e3o de desigualdade para cada par de elementos distintos do\n\nvetor, reduzindo bastante o tamanho da modelagem e facilitando a resolu\u00e7\u00e3o do problema.\n\nO predicado allMinDistance representa uma generaliza\u00e7\u00e3o desse conceito, recebendo como\n\nsegundo argumento um valor inteiro que especi?ca a diferen\u00e7a absoluta m\u00ednima entre quaisquer\n\ndois elementos do vetor. Dessa forma, o valor 0 torna o predicado trivialmente verdadeiro e o valor\n\n1 torna o predicado equivalente ao anterior, isto \u00e9, \u00e9 poss\u00edvel expressar a mesma regra que foi\n\nmodelada anteriormente da seguinte forma:\n\nallMinDistance ( niveis , 1) ;\n\nO predicado inverse cria uma rela\u00e7\u00e3o de bije\u00e7\u00e3o entre dois vetores. Por exemplo, se forem\n\ndados como argumentos os vetores x e y, para qualquer \u00edndice i vale que, se x[i] = j, ent\u00e3o y[j] = i.\n\nO predicado lex tamb\u00e9m recebe dois vetores inteiros como argumento, sendo ambos do mesmo\n\ntamanho, e \u00e9 verdadeiro se o primeiro vetor for lexicogra?camente menor que o segundo vetor, isto\n\n\u00e9, se o elemento de cada posi\u00e7\u00e3o do primeiro for menor ou igual ao do segundo.\n\nPor ?m, o predicado pack representa boa parte das rela\u00e7\u00f5es existentes em um problema da\n\nmochila com m mochilas e n itens ? i.e., particionar n elementos de acordo com o limite de peso\n\nadmitido em cada uma das m parti\u00e7\u00f5es. Em sua vers\u00e3o mais simples, ele envolve tr\u00eas vetores inteiros\n\nunidimensionais, o primeiro com dimens\u00e3o m e os outros com dimens\u00e3o n. Um quarto argumento\n\nopcional consiste em um valor inteiro. O primeiro vetor consiste no peso total de cada mochila,\n\no segundo vetor na determina\u00e7\u00e3o da mochila a qual cada item foi atribu\u00eddo e o terceiro vetor ao\n\npeso de cada item. O argumento opcional representa a quantidade de mochilas com algum item\n\natribu\u00eddo. O terceiro vetor \u00e9 constante, mas os dois primeiros podem ser ambos de vari\u00e1veis de\n\ndecis\u00e3o ? mas n\u00e3o apenas um deles e o outro n\u00e3o. Se os dois primeiros vetores forem vari\u00e1veis de\n\ndecis\u00e3o, o quarto argumento pode ser uma vari\u00e1vel de decis\u00e3o tamb\u00e9m.\n\nA seguir, \u00e9 apresentado um exemplo envolvendo a atribui\u00e7\u00e3o de passageiros a carros e a rela\u00e7\u00e3o\n\ndo peso dos passageiros com o peso total em cada carro para ilustrar como o predicado pack opera:\n\n\n\nMODELAGEM DE PROBLEMAS COMBINAT\u00d3RIOS 105\n\nint noCarros = . . . ;\n\nrange dCarros = 1 . . noCarros ;\n\nint noPassageiros = . . . ;\n\nrange dPassageiros = 1 . . noPassageiros ;\n\nint pesoPassageiro [ p in dPassageiros ] = . . . ;\n\ndvar int pesoNoCarro [ c in dCarros ] ;\n\ndvar int carroComPassageiro [ p in dPassageiros ] in dCarros ;\n\ndvar int carros in dCarros ;\n\nsubject to {\n\npack ( pesoNoCarro , carroComPassageiro , pesoPassageiro , carros ) ;\n\n}\n\nNo exemplo, temos dois vetores de vari\u00e1veis de decis\u00e3o e uma vari\u00e1vel de decis\u00e3o inteira, todos\n\ncompletamente interdependentes: o modelo procura determinar em qual carro cada passageiro vai,\n\no que determina o peso total de passageiros nesse carro de acordo com o peso de cada um deles e\n\ntamb\u00e9m quantos carros t\u00eam pelo menos um passageiro atribu\u00eddo.\n\nA.4.7 Execu\u00e7\u00e3o do Resolvedor e Con?gura\u00e7\u00f5es B\u00e1sicas do CP\n\nUma vez realizado o pr\u00e9-processamento e processada a de?ni\u00e7\u00e3o do problema de otimiza\u00e7\u00e3o,\n\no interpretador realiza o passo geralmente mais demorado, que consiste na resolu\u00e7\u00e3o do problema\n\ndescrito pelo modelo. Na sa\u00edda visualizada na tela, \u00e9 poss\u00edvel observar informa\u00e7\u00f5es gerais sobre o\n\nmodelo, o consumo de mem\u00f3ria e tempo do processo de busca. Durante a busca, a per\u00edodos regulares\n\nocorre uma sa\u00edda sobre novas solu\u00e7\u00f5es encontradas ou sobre o n\u00famero de vari\u00e1veis sem atribui\u00e7\u00e3o.\n\nAcompanhando a varia\u00e7\u00e3o desse valor, com o tempo podemos inferir a di?culdade de resolu\u00e7\u00e3o do\n\nmodelo para uma dada inst\u00e2ncia do problema e compreender como modelar o problema de forma\n\nque sua resolu\u00e7\u00e3o seja facilitada.\n\nO processo de busca ocorre apenas se o resolvedor n\u00e3o inferir que o problema \u00e9 infact\u00edvel e pode\n\ndurar at\u00e9 que uma solu\u00e7\u00e3o seja encontrada no caso de n\u00e3o haver fun\u00e7\u00e3o objetivo, at\u00e9 a melhor\n\nsolu\u00e7\u00e3o ser encontrada se houver uma fun\u00e7\u00e3o objetivo, at\u00e9 todo o espa\u00e7o de busca ser examinado\n\nsem que nenhuma solu\u00e7\u00e3o seja encontrada ou ? caso essas situa\u00e7\u00f5es n\u00e3o ocorram facilmente ? at\u00e9\n\num determinado limite de tempo ou n\u00famero de itera\u00e7\u00f5es ser atingido. Tais limites representam\n\npar\u00e2metros de con?gura\u00e7\u00e3o do resolvedor. Para surtir efeito no processo de busca, tais par\u00e2me-\n\ntros devem ser alterados antes do bloco de restri\u00e7\u00f5es do modelo, isto \u00e9, no pr\u00e9-processamento. A\n\nparametriza\u00e7\u00e3o do resolvedor pode ser realizada por meio de instru\u00e7\u00f5es espec\u00ed?cas nos blocos de\n\nprograma\u00e7\u00e3o imperativa antes do bloco de restri\u00e7\u00f5es, como no exemplo abaixo:\n\nexecute {\n\ncp . param . TimeLimit = 60;\n\ncp . param . LogPeriod = 1000;\n\ncp . param . randomSeed = 42;\n\n}\n\nNesse exemplo, foram alterados tr\u00eas par\u00e2metros do resolvedor: estabelecemos que a busca deva\n\nterminar em, no m\u00e1ximo, 60 segundos; que uma linha de estado deve ser impressa na tela a cada\n\n1000 itera\u00e7\u00f5es realizadas; e atribu\u00edmos uma nova semente aleat\u00f3ria ao algoritmo. A import\u00e2ncia da\n\nde?ni\u00e7\u00e3o e varia\u00e7\u00e3o das sementes empregadas est\u00e1 relacionada ao emprego de crit\u00e9rios de desempate\n\nna escolha dos pr\u00f3ximos passos da busca: quando o crit\u00e9rio de avalia\u00e7\u00e3o tem um empate t\u00e9cnico\n\n\n\n106 AP\u00caNDICE A\n\nentre algumas op\u00e7\u00f5es ? como na escolha da pr\u00f3xima vari\u00e1vel ou valor a atribuir ?, \u00e9 poss\u00edvel arbitrar\n\na escolha com alguma aleatoriedade, de forma que pode ser interessante rodar o resolvedor v\u00e1rias\n\nvezes com sementes distintas.\n\nA ?xa\u00e7\u00e3o e posterior mudan\u00e7a no valor de uma semente para o modelo pode ser \u00fatil quando, por\n\nqualquer motivo, o resolvedor n\u00e3o gera uma solu\u00e7\u00e3o para uma inst\u00e2ncia apesar de gerar para outras\n\ninst\u00e2ncias muito parecidas. Se desejarmos avaliar a robustez no desempenho de um modelo, nosso\n\ninteresse ser\u00e1 em utilizar sementes variadas em execu\u00e7\u00f5es sucessivas do modelo sobre uma mesma\n\ninst\u00e2ncia para avaliar como isso altera os resultados obtidos. Nesse tipo de avalia\u00e7\u00e3o, a varia\u00e7\u00e3o na\n\nqualidade da solu\u00e7\u00e3o obtida ou no tempo de execu\u00e7\u00e3o para atingir solu\u00e7\u00f5es em um determinado\n\npatamar d\u00e1 um bom ind\u00edcio da robustez do modelo para o conjunto de inst\u00e2ncias esperado.\n\nA.4.8 Manipula\u00e7\u00e3o da Solu\u00e7\u00e3o e Impress\u00e3o dos Resultados no P\u00f3s-Processamento\n\nAp\u00f3s a resolu\u00e7\u00e3o do problema do modelo, \u00e9 poss\u00edvel inserir novas declara\u00e7\u00f5es de vetores e blocos\n\nde programa\u00e7\u00e3o imperativa; de forma a manipular os resultados obtidos para as vari\u00e1veis de decis\u00e3o\n\ne express\u00f5es de decis\u00e3o, obtendo assim informa\u00e7\u00f5es de interesse ao projetista do modelo. No p\u00f3s-\n\nprocessamento, as vari\u00e1veis de decis\u00e3o s\u00e3o vistas como vari\u00e1veis comuns nas express\u00f5es e podem\n\nser utilizadas para atribui\u00e7\u00f5es a novos vetores. \u00c9 nesse ponto que geralmente encontram-se blocos\n\nde programa\u00e7\u00e3o imperativa com rotinas de impress\u00e3o, apesar de que \u00e9 poss\u00edvel empregar rotinas\n\nde impress\u00e3o no pr\u00e9-processamento. Essas rotinas de impress\u00e3o consistem nas fun\u00e7\u00f5es imperativas\n\nwrite e writeln, com as quais podemos manipular texto da mesma forma como fazemos em Java,\n\nsendo a diferen\u00e7a entre ambas as fun\u00e7\u00f5es que a segunda pule de linha automaticamente ap\u00f3s a\n\nimpress\u00e3o de seu conte\u00fado.\n\nNo exemplo a seguir, ilustra-se um exemplo pela gera\u00e7\u00e3o de um vetor e impress\u00e3o da informa\u00e7\u00e3o\n\nde uma vari\u00e1vel de decis\u00e3o empregada em exemplos anteriores:\n\nint processosPorNivel [ n in dNiveis ] = count ( nivel , n) ;\n\nexecute {\n\nwriteln (\" Niveis definidos a algum processo :\") ;\n\nfor ( var i n i in dNiveis ) {\n\ni f ( processosPorNivel [ i n i ]>0) {\n\nwriteln (\" Nivel \"+i n i ) ;\n\n}\n\n}\n\n}\n\nConv\u00e9m observar que o exemplo poderia ainda ser reescrito com menos linhas se, em vez de declarar\n\num vetor, fosse utilizada diretamente a express\u00e3o ?count(nivel,ini)? na condi\u00e7\u00e3o do if.\n\nA.4.9 Um Exemplo de Problema Combinat\u00f3rio Modelado em OPL\n\nPara n\u00e3o concluir a apresenta\u00e7\u00e3o dos conceitos elementares da linguagem OPL para a modela-\n\ngem de problemas combinat\u00f3rios sem um exemplo completo para resolver um problema, segue um\n\nexemplo de Lustig e Puget (2001) baseado no problema das n rainhas. Nesse problema, interessa-nos\n\nposicionar n rainhas em um tabuleiro n\u00d7n sem que nenhuma delas possa atacar outra:\n\n\n\nMODELAGEM DE PROBLEMAS COMBINAT\u00d3RIOS 107\n\n1 using CP;\n\n2\n\n3 int n = . . . ;\n\n4 range dN = 1 . . n ;\n\n5 dvar int rainhaLinha [dN] in dN; // Define onde est\u00e1 a rainha de cada linha .\n\n6\n\n7 subject to {\n\n8 // Duas rainhas n\u00e3o podem f i c a r na mesma linha :\n\n9 a l l D i f f e r e n t ( rainhaLinha ) ;\n\n10\n\n11 // Duas rainhas n\u00e3o podem f i c a r na mesma diagonal :\n\n12 // Verif ica se quaisquer duas rainhas pertencem \u00e0 mesma diagonal .\n\n13 // \u00cdndice das rainhas \u00e9 ordenado para evitar v e r i f i c a \u00e7 \u00f5 e s desnecess\u00e1rias .\n\n14 f o r a l l ( i in dN, j in dN : i &lt;j ) {\n\n15\n\n16 // Rela\u00e7\u00e3o da diagonal principal : coluna + linha = constante\n\n17 ( rainhaLinha [ i ] + i ) !=( rainhaLinha [ j ] + j ) ;\n\n18\n\n19 // Rela\u00e7\u00e3o da diagonal secund\u00e1ria : coluna ? linha = constante\n\n20 ( rainhaLinha [ i ] ? i ) !=( rainhaLinha [ j ] ? j ) ;\n21 }\n\n22 }\n\n23\n\n24 execute {\n\n25 writeln (\" Resultado :\") ;\n\n26 for ( var i in dN) {\n\n27 writeln (\" Linha \" + i + \" ? Coluna \" + rainhaLinha [ i ] ) ;\n28 }\n\n29 }\n\nPara esse exemplo e n = 10, obtemos a seguinte resposta por meio de impress\u00f5es na tela:\n\nResultado:\n\nLinha 1 - Coluna 5\n\nLinha 2 - Coluna 9\n\nLinha 3 - Coluna 4\n\nLinha 4 - Coluna 7\n\nLinha 5 - Coluna 8\n\nLinha 6 - Coluna 6\n\nLinha 7 - Coluna 10\n\nLinha 8 - Coluna 1\n\nLinha 9 - Coluna 3\n\nLinha 10 - Coluna 2\n\nAinda com rela\u00e7\u00e3o ao exemplo apresentado, uma alternativa ao par\u00e2metro formal ?i in dN, j in\n\ndN : i &lt;j? poderia ser ?i in dN, j in 1..i?. Entretanto, tais ganhos de processamento devem ser\n\navaliados com cautela, pois podem tornar o c\u00f3digo menos leg\u00edvel. Uma vez processado o modelo\n\npara que o resolvedor proceda com a busca por meio de uma representa\u00e7\u00e3o mais simples, n\u00e3o haver\u00e1\n\ndiferen\u00e7a entre as duas representa\u00e7\u00f5es.\n\n\n\n108 AP\u00caNDICE A\n\nPode ser de interesse do leitor saber como obter solu\u00e7\u00f5es alternativas do problema. Para tanto,\n\n\u00e9 necess\u00e1rio um controle externo que solicitasse novas solu\u00e7\u00f5es do resolvedor. Isso \u00e9 feito por meio\n\nde um bloco imperativo declarado com a palavra reservada main em vez de execute no arquivo\n\nde modelo. Apesar de n\u00e3o tratarmos o assunto nesse texto introdut\u00f3rio, \u00e9 importante que o leitor\n\nsaiba da exist\u00eancia desse recurso.\n\nA.5 Modelagem de Problemas de Escalonamento\n\nUm problema de escalonamento consiste na programa\u00e7\u00e3o da execu\u00e7\u00e3o de um conjunto de ativi-\n\ndades ao longo de um per\u00edodo de tempo. Nessa se\u00e7\u00e3o, apresentaremos estruturas e especializa\u00e7\u00f5es\n\ninteressantes para a modelagem de problemas de escalonamento em OPL, de forma similar ao que\n\nfoi feito anteriormente para problemas combinat\u00f3rios. Esses elementos adicionais n\u00e3o descartam\n\ntudo o que foi visto at\u00e9 o momento para problemas combinat\u00f3rios, mas servem de complemento\n\npara a obten\u00e7\u00e3o de um grau maior de expressividade.\n\nA.5.1 Problemas de Escalonamento e a Motiva\u00e7\u00e3o ao Emprego de CP\n\nEm um problema de escalonamento, estamos interessados em decidir, entre outras coisas, quando\n\ncertos eventos ocorrem e como cada evento ocorre. Dessa forma, a solu\u00e7\u00e3o representa uma escala ?\n\nou programa\u00e7\u00e3o ? desses eventos. O conjunto de restri\u00e7\u00f5es quanto \u00e0s possibilidades de constru\u00e7\u00e3o\n\nde uma escala re?etem caracter\u00edsticas dos eventos, regras de ordena\u00e7\u00e3o entre eles, a utiliza\u00e7\u00e3o de\n\nalgum tipo de recurso compartilhado, o tempo de separa\u00e7\u00e3o entre eventos consecutivos de acordo\n\ncom suas caracter\u00edsticas etc.\n\nPara modelos de programa\u00e7\u00e3o matem\u00e1tica, as vari\u00e1veis de decis\u00e3o associadas a tais eventos\n\ngeralmente s\u00e3o vetores booleanos, representando se cada atividade ocorre ou \u00e9 iniciada em cada\n\ninstante de tempo poss\u00edvel, e podem ter muitas dimens\u00f5es de acordo com os graus de liberdade e\n\nas restri\u00e7\u00f5es do problema. Quando a janela de tempo \u00e9 muito grande e a discretiza\u00e7\u00e3o de intervalos\n\nmuito ?na, a resolu\u00e7\u00e3o de tais modelos pode se tornar invi\u00e1vel. Em muitos casos, n\u00e3o s\u00e3o conhecidas\n\nformas de expressar o problema de uma maneira mais compacta dentro dos limites do que \u00e9 poss\u00edvel\n\ncom programa\u00e7\u00e3o matem\u00e1tica.\n\nEm programa\u00e7\u00e3o por restri\u00e7\u00f5es, entretanto, os limites de ?exibiliza\u00e7\u00e3o s\u00e3o maiores. Dessa forma,\n\nvari\u00e1veis de decis\u00e3o com dom\u00ednios diversos e algoritmos de resolu\u00e7\u00e3o especializados d\u00e3o suporte\n\na formula\u00e7\u00f5es que usam menos mem\u00f3ria e tempo de processamento em algumas situa\u00e7\u00f5es. Isso\n\npossibilita a obten\u00e7\u00e3o de solu\u00e7\u00f5es para inst\u00e2ncias de problemas de escalonamento de grande porte\n\nque, de outra forma, n\u00e3o poderiam ser tratados com os recursos computacionais dispon\u00edveis.\n\nOs elementos apresentados a seguir servem ao prop\u00f3sito de expressar a modelagem de problemas\n\ncombinat\u00f3rios de escalonamento com sem\u00e2ntica mais apurada, o que torna sua representa\u00e7\u00e3o mais\n\ncompacta e facilita a resolu\u00e7\u00e3o desses modelos pela utiliza\u00e7\u00e3o de algoritmos especializados nessas\n\nestruturas.\n\nA.5.2 Vari\u00e1veis de Intervalo e Suas Propriedades\n\nMuitas vari\u00e1veis de um problema de escalonamento podem ser expressas por intervalos, delimi-\n\ntando propriedades como o in\u00edcio e o ?m de um evento. Em OPL, \u00e9 poss\u00edvel expressar vari\u00e1veis de\n\ndecis\u00e3o intervalares por meio do tipo interval, como a seguir:\n\n\n\nMODELAGEM DE PROBLEMAS DE ESCALONAMENTO 109\n\ndvar interval atividade ;\n\nO in\u00edcio e o ?m de um intervalo representam vari\u00e1veis de decis\u00e3o inteiras e interdependentes.\n\nQuando declara-se que um intervalo possui um dom\u00ednio, \u00e9 de?nido que o in\u00edcio e o ?m do intervalo\n\ndevem pertencer \u00e0quele dom\u00ednio, como no exemplo abaixo:\n\nint pDia = . . . ;\n\nint uDia = . . . ;\n\nrange dDias = pDia . . uDia ;\n\ndvar interval escalaAtividade in dDias ;\n\nAl\u00e9m do \u00ednicio e do ?m, uma vari\u00e1vel do tipo interval tamb\u00e9m possui outras propriedades\n\ninterdependentes como tamanho e dura\u00e7\u00e3o. Tais propriedades tamb\u00e9m podem ter algum grau de\n\nliberdade, situa\u00e7\u00e3o na qual assumem o papel de vari\u00e1veis de decis\u00e3o nas rela\u00e7\u00f5es entre in\u00edcio e\n\n?m. Para acessar explicitamente os valores de in\u00edcio e ?m de um intervalo em express\u00f5es, s\u00e3o\n\nutilizadas as fun\u00e7\u00f5es startOf e endOf dando como argumento o intervalo. A dura\u00e7\u00e3o, que consiste\n\nna diferen\u00e7a entre o ?m e o in\u00edcio de um intervalo, pode ser obtida com a fun\u00e7\u00e3o lengthOf. O\n\ntamanho de um intervalo, obtido pela fun\u00e7\u00e3o sizeOf, pode ser menor do que sua dura\u00e7\u00e3o. Isso\n\nocorre quando uma fun\u00e7\u00e3o de intensidade \u00e9 de?nida para o intervalo. Apesar de n\u00e3o se tratarem\n\nfun\u00e7\u00f5es de intensidade nesse texto introdut\u00f3rio, o conceito pode ser entendido de maneira f\u00e1cil pelo\n\nseguinte exemplo. Podemos dizer que uma atividade durou uma semana corrida, 7 dias. Entretanto,\n\nseu tamanho pode ser de 5 dias, visto que a fun\u00e7\u00e3o de intensidade possua valor nulo para os dias\n\ndo ?m-de-semana.\n\nO tamanho de uma vari\u00e1vel tamb\u00e9m pode ser especi?cado na declara\u00e7\u00e3o da vari\u00e1vel. Dessa\n\nforma, a de?ni\u00e7\u00e3o do dom\u00ednio de um intervalo em sua declara\u00e7\u00e3o pode se tornar mais elaborada\n\ndo que aquela encontrada em tipos primitivos. No exemplo a seguir, \u00e9 declarado um intervalo com\n\ntamanho ?xo:\n\nint tAtividade = . . . ;\n\ndvar interval escalaAtividade\n\nin dDias\n\ns i z e tAtividade ;\n\nAbaixo, tem-se um exemplo da declara\u00e7\u00e3o de um intervalo com tamanho vari\u00e1vel, utilizando\n\num dom\u00ednio para delimitar o menor e o maior valor poss\u00edvel para o tamanho do intervalo:\n\nint tMinAtividade = . . . ;\n\nint tMaxAtividade = . . . ;\n\nrange dTamAtividade = tMinAtividade . . tMaxAtividade ;\n\ndvar interval escalaAtividade\n\nin dDias\n\ns i z e dTamAtividade ;\n\nUm intervalo tamb\u00e9m pode ser opcional. Nessa condi\u00e7\u00e3o, \u00e9 facultada a op\u00e7\u00e3o de que ele n\u00e3o\n\nocorra, i.e., representa um evento que n\u00e3o necessariamente precisa ser escalonado numa solu\u00e7\u00e3o\n\ndo problema. O primeiro modi?cador da declara\u00e7\u00e3o de um intervalo opcional consiste na palavra\n\nreservada optional logo ap\u00f3s o identi?cador da vari\u00e1vel declarada, como no exemplo abaixo:\n\ndvar interval escalaAtividade optional ;\n\n\n\n110 AP\u00caNDICE A\n\nQuando se declara um vetor de vari\u00e1veis intervalares, \u00e9 poss\u00edvel de?nir que alguns intervalos do\n\nvetor s\u00e3o opcionais e outros obrigat\u00f3rios. Nesse caso, ao modi?cador optional \u00e9 acrescido um par\n\nde par\u00eanteses com uma express\u00e3o booleana de?nindo se o intervalo \u00e9 ou n\u00e3o opcional, como abaixo:\n\nint noAtividades = . . . ;\n\nrange dAtividades = 1 . . noAtividades ;\n\nint atividadeOpcional [ dAtividades ] = . . . ;\n\ndvar interval escalaAtividades [ a in dAtividades ] optional ( atividadeOpcional [ a ] ) ;\n\nSobre a utiliza\u00e7\u00e3o dessa estrutura, \u00e9 importante frisar que, salvo se o valor da express\u00e3o entre\n\npar\u00eanteses for igual a 1, o intervalo ser\u00e1 obrigat\u00f3rio. Isso j\u00e1 foi mencionado quando express\u00f5es\n\nnum\u00e9ricas e predicados foram discutidos, mas n\u00e3o custa repetir: apenas o valor 1 \u00e9 garantidamente\n\ninterpretado como verdadeiro e apenas o valor 0 como falso no contexto de uma express\u00e3o booleana\n\nem OPL.\n\nPara acessar a informa\u00e7\u00e3o sobre uma vari\u00e1vel intervalar opcional estar presente ou n\u00e3o em uma\n\nsolu\u00e7\u00e3o, \u00e9 utilizado o predicado presenceOf. Por exemplo, de?ne-se que um intervalo de \u00edndice b\n\npar em um vetor de intervalos deve estar presente se o intervalo de \u00edndice a que o precede estiver\n\npresente pelo seguinte conjunto de restri\u00e7\u00f5es:\n\nf o r a l l (a in dAtividades , b in dAtividades : b==a+1 &amp;&amp; b%2==0) {\n\npresenceOf ( escalaAtividade [ a ] ) =>\n\npresenceOf ( escalaAtividade [ b ] ) ;\n\n}\n\nAo contr\u00e1rio do que ocorre com os par\u00e2metros formais nos operadores de agrega\u00e7\u00e3o, a restri\u00e7\u00e3o\n\nde implica\u00e7\u00e3o l\u00f3gica permite que condi\u00e7\u00f5es sobre vari\u00e1veis de decis\u00e3o sejam empregadas. Assim,\n\npode-se usar n\u00e3o apenas o predicado presenceOf, como \u00e9 poss\u00edvel compor predicados com outras\n\nfun\u00e7\u00f5es que operam sobre predicados.\n\nPara as fun\u00e7\u00f5es startOf, endOf, sizeOf e lengthOf vistas anteriormente, existe um segundo\n\nargumento opcional: o valor retornado pela fun\u00e7\u00e3o se o intervalo n\u00e3o estiver presente. Por exemplo,\n\n\u00e9 poss\u00edvel de?nir que um vetor de atividades opcionais tenha todas as atividades presentes nas\n\nprimeiras posi\u00e7\u00f5es do vetor e que elas estejam dispostas em ordem crescente de in\u00edcio:\n\nf o r a l l (a in dAtividades , b in dAtividades : b==a+1) {\n\nstartOf ( escalaAtividade [ a ] , maxint )&lt;= startOf ( escalaAtividade [ b ] , maxint ) ;\n\n}\n\nRestri\u00e7\u00f5es desse tipo representam uma pr\u00e1tica frequente de modelagem em programa\u00e7\u00e3o por res-\n\ntri\u00e7\u00f5es: a quebra de simetria. Uma restri\u00e7\u00e3o de quebra de simetria reduz o conjunto poss\u00edvel de\n\nsolu\u00e7\u00f5es para um problema ao descartar solu\u00e7\u00f5es que s\u00e3o equivalentes. Nesse caso, por exemplo,\n\npoder\u00edamos ter solu\u00e7\u00f5es cuja diferen\u00e7a fosse apenas a ordem dos intervalos no vetor, sendo desne-\n\ncess\u00e1rio considerar tais solu\u00e7\u00f5es.\n\nA.5.3 Restri\u00e7\u00f5es de Preced\u00eancia\n\nEm problemas de escalonamento, \u00e9 bastante comum estabelecer restri\u00e7\u00f5es de preced\u00eancia entre\n\neventos. Um projetista pode, por exemplo, de?nir que um intervalo s\u00f3 come\u00e7a ap\u00f3s o ?m de outro\n\ne assim por diante. Apesar das fun\u00e7\u00f5es que acessam as propriedades de in\u00edcio, ?m e dura\u00e7\u00e3o de\n\num intervalo j\u00e1 serem su?cientes para estabelecer muitas dessas rela\u00e7\u00f5es no conjunto de restri\u00e7\u00f5es\n\n\n\nMODELAGEM DE PROBLEMAS DE ESCALONAMENTO 111\n\ndo modelo, sua frequ\u00eancia levou \u00e0 de?ni\u00e7\u00e3o de uma fam\u00edlia de predicados de preced\u00eancia, como o\n\nseguinte:\n\nendBeforeStart ( escalaAtividade [ 1 ] , escalaAtividade [ 2 ] , 5) ;\n\nNa restri\u00e7\u00e3o acima, expressa-se que o ?m do primeiro intervalo somado ao valor 5 \u00e9 menor ou igual\n\nao in\u00edcio do segundo intervalo. Um exemplo um pouco diferente \u00e9 o predicado abaixo, que de?ne\n\nque o in\u00edcio dos dois intervalos deve ser igual:\n\nstartAtStart ( escalaAtividade [ 1 ] , escalaAtividade [ 2 ] ) ;\n\nDe uma maneira geral, temos predicados come\u00e7ando pela propriedade do primeiro intervalo\n\n(start ou end), seguidos de um comparador (Before para ?<=?, At para ?==? e After para ?>=?)\n\ne por ?m a propriedade do segundo intervalo (Start ou End ? esse \u00faltimo, ao contr\u00e1rio do pri-\n\nmeiro, come\u00e7ando por letra mai\u00fascula). Esses predicados possuem dois intervalos como argumento\n\ne um terceiro argumento opcional representando um valor a ser somado \u00e0 propriedade do primeiro\n\nintervalo antes de compar\u00e1-lo \u00e0 propriedade do segundo intervalo.\n\nA.5.4 Predicados Sobre Conjuntos de Intervalos\n\nEm algumas situa\u00e7\u00f5es, pode ser necess\u00e1rio representar um evento por v\u00e1rios intervalos distintos\n\nou de?nir um intervalo delimitando o in\u00edcio e o ?m de um conjunto de outros intervalos. Em OPL,\n\nexistem tr\u00eas predicados que descrevem a rela\u00e7\u00e3o entre um intervalo a e um conjunto de intervalos\n\nB: span, alternative e synchronize, todos tendo como argumentos um intervalo a seguido de um\n\nvetor unidimensional B.\n\nCom o span, \u00e9 poss\u00edvel de?nir que um intervalo a inicia junto com o primeiro intervalo presente\n\nde B e termina junto com o \u00faltimo intervalo presente de B, e que o intervalo a \u00e9 ausente se todos\n\nos intervalos de B forem ausentes, como no exemplo abaixo:\n\ndvar interval escalaAtividade ;\n\ndvar interval escalaAtividades [ dAtividades ] ;\n\nspan ( escalaAtividade , escalaAtividades ) ;\n\nSe utilizado como uma restri\u00e7\u00e3o do modelo, o predicado span condiciona a presen\u00e7a do intervalo a\n\n\u00e0 presen\u00e7a de alguma atividade do vetor de intervalos B e vice-e-versa.\n\nUsando alternative, estabelece-se que apenas um intervalo de um vetor B est\u00e1 presente e seu\n\nin\u00edcio e ?m coincidem com aqueles do intevalo a. Por um condicionamento similar ao de span,\n\nse a n\u00e3o estiver presente, nenhum intervalo em B est\u00e1 presente. Por exemplo, \u00e9 poss\u00edvel ter um\n\nconjunto de atividades que devem ser realizadas e um conjunto de m\u00e1quinas capazes de realiz\u00e1-las,\n\ne expressar que uma, e apenas uma, m\u00e1quina deve realizar cada atividade, como no exemplo a\n\nseguir:\n\n\n\n112 AP\u00caNDICE A\n\nint noMaquinas = . . . ;\n\nrange dMaquinas = 1 . . noMaquinas ;\n\ndvar interval escalaMaquinaAtividade [ dMaquinas ] [ dAtividades ] optional ;\n\nsubject to {\n\nf o r a l l (a in dAtividades ) {\n\nalternative (\n\nescalaAtividades [ a ] ,\n\na l l (m in dMaquinas ) escalaMaquinaAtividade [m] [ a ] ) ;\n\n}\n\n}\n\nComo em outros casos vistos anteriormente, pelo exemplo dado observa-se que \u00e9 poss\u00edvel utilizar\n\no operador all para criar vetores unidimensionais de intervalos para aplicar predicados envolvendo\n\nvetores unidimensionais a qualquer conjunto poss\u00edvel de intervalos.\n\nPor ?m, com synchronize todos intervalos do conjunto B iniciam e terminam junto com o\n\nintervalo a ? se a estiver presente. Ao contr\u00e1rio de span e alternative, no predicado synchronize\n\na presen\u00e7a de algum intervalo de B n\u00e3o implica na presen\u00e7a do intervalo a e n\u00e3o existe nenhuma\n\nrestri\u00e7\u00e3o entre os intervalos de B se a for ausente.\n\nA.5.5 Sequ\u00eancias e Transi\u00e7\u00f5es\n\nVari\u00e1veis intervalares podem ser agrupadas em uma sequ\u00eancia, que \u00e9 um tipo de vari\u00e1vel de\n\ndecis\u00e3o declarado com a palavra reservada sequence. Ao criar um escalonamento, o resolvedor\n\nprocura ordenar os intervalos de cada sequ\u00eancia para s\u00f3 ent\u00e3o de?nir o instante de aloca\u00e7\u00e3o para\n\ncada intervalo do conjunto. Uma sequ\u00eancia \u00e9 declarada por um vetor unidimensional. Esse vetor \u00e9\n\nespeci?cado ap\u00f3s a palavra reservada in, como no exemplo abaixo:\n\ndvar sequence todasAtividades in escalaAtividades ;\n\nPara interesse imediato, com sequ\u00eancias consegue-se de?nir que n\u00e3o podem haver sobreposi\u00e7\u00f5es\n\nem um grupo de intervalos e ainda de?nir o tempo de transi\u00e7\u00e3o entre intervalos consecutivos na\n\nordena\u00e7\u00e3o. Mas isso s\u00f3 ocorre se uma restri\u00e7\u00e3o for imposta sobre a sequ\u00eancia. No exemplo abaixo,\n\nde?ne-se uma sequ\u00eancia sobre os intervalos de \u00edndice par de um vetor de intervalos, e \u00e9 estabelecido\n\nque apenas um deles pode ocorrer por vez atrav\u00e9s do predicado noOverlap:\n\ndvar sequence atividadesPares\n\nin a l l (a in dAtividades : a % 2 == 0) escalaAtividades [ a ] ;\n\nsubject to {\n\nnoOverlap ( atividadesPares ) ;\n\n}\n\nAl\u00e9m de impedir que dois intervalos se sobreponham numa sequ\u00eancia, com noOverlap \u00e9 pos-\n\ns\u00edvel de?nir uma separa\u00e7\u00e3o entre a conclus\u00e3o de um intervalo e o in\u00edcio do intervalo seguinte na\n\nsequ\u00eancia por meio de um argumento adicional especi?cando o tempo de transi\u00e7\u00e3o entre tipos de\n\nintervalos. O primeiro passo para que isso seja poss\u00edvel consiste em associar a cada intervalo de\n\numa sequ\u00eancia um inteiro representando seu tipo na pr\u00f3pria declara\u00e7\u00e3o da sequ\u00eancia por meio da\n\npalavra reservada types seguida de um vetor unidimensional de inteiros com o mesmo tamanho que\n\no vetor de intervalos especi?cado antes, de forma que cada entrada de um vetor seja associada \u00e0\n\n\n\nMODELAGEM DE PROBLEMAS DE ESCALONAMENTO 113\n\nentrada correspondente do outro vetor. Al\u00e9m disso, \u00e9 necess\u00e1rio passar como argumento da restri-\n\n\u00e7\u00e3o noOverlap o tempo de separa\u00e7\u00e3o de intervalos consecutivos de acordo com o inteiro associado\n\na cada intervalo. Isso \u00e9 feito por meio do argumento opcional de noOverlap. Ele consiste em um\n\nconjunto de tuplas, sendo cada tupla formada por tr\u00eas inteiros. Assim, a quantidade de unidades\n\nde tempo entre o ?m de um intervalo e o in\u00edcio do seguinte \u00e9 consultado nesse conjunto, sendo o\n\nprimeiro inteiro relativo ao tipo do intervalo anterior, o segundo ao tipo do posterior e o terceiro\n\nestabelece o tempo de separa\u00e7\u00e3o.\n\nUm exemplo de declara\u00e7\u00e3o de sequ\u00eancia com tipos para os intervalos e tempo de separa\u00e7\u00e3o entre\n\nintervalos consecutivos \u00e9 apresentado a seguir:\n\ndvar sequence todasAtividades\n\nin a l l (a in dAtividades ) escalaAtividades [ a ]\n\ntypes a l l (a in dAtividades ) a ;\n\ntuple TempoTransicao { int de ; int para ; int tempo ; };\n\n{ TempoTransicao } fTransicao = . . . ;\n\nsubject to {\n\nnoOverlap ( todasAtividades , fTransicao ) ;\n\n}\n\nNo exemplo apresentado, cada intervalo da sequ\u00eancia possui um identi?cador inteiro para seu tipo.\n\nTemos uma tupla representando uma estrutura com tr\u00eas inteiros: o tipo inicial, o tipo ?nal e o\n\ntempo entre o ?m de uma atividade do primeiro tipo e o in\u00edcio de uma atividade do segundo tipo\n\nna sequ\u00eancia, usado na declara\u00e7\u00e3o de um conjunto que serve de fun\u00e7\u00e3o de transi\u00e7\u00e3o, dado como\n\nsegundo argumento do predicado noOverlap.\n\nA atribui\u00e7\u00e3o a tuplas foi apresentada de maneira bem super?cial em um ponto anterior do texto.\n\nApenas para deixar claro como declarar no arquivo de entrada de dados o tempo de transi\u00e7\u00e3o para\n\no exemplo acima, \u00e9 apresentado abaixo um exemplo envolvendo dois tipos e os quatro respectivos\n\ntempos de transi\u00e7\u00e3o:\n\nfTransicao= {<1, 1 , 0>,&lt;1, 2 , 10>,&lt;2, 1 , 10>,&lt;2, 2 , 0> };\n\nNo exemplo apresentado acima, o tempo de transi\u00e7\u00e3o entre atividades do mesmo tipo \u00e9 0 e o tempo\n\nde transi\u00e7\u00e3o entre atividades de tipos distintos \u00e9 10.\n\nPor ?m, vale observar que a declara\u00e7\u00e3o dos nomes dos campos da tupla \u00e9 irrelevante para sua\n\nutiliza\u00e7\u00e3o na de?ni\u00e7\u00e3o dos tempos de transi\u00e7\u00e3o, de forma que o projetista tem toda a liberdade\n\nde de?nir a nomenclatura que mais lhe agradar, desde que mantida a ordem de que a primeira\n\nvari\u00e1vel representa o tipo da atividade anterior, a segunda do tipo seguinte e a terceira o tempo de\n\nsepara\u00e7\u00e3o.\n\nA.5.6 Modelagem de Recursos Limitados\n\nEm muitos problemas de escalonamento, al\u00e9m de eventos que podem ou n\u00e3o ocorrer, \u00e9 poss\u00edvel\n\nque existam recursos com propriedades que restrinjam a possibilidade de execu\u00e7\u00e3o conjunta desses\n\neventos. Muitas restri\u00e7\u00f5es envolvendo recursos associados a determinados conjuntos de eventos\n\npodem ser modelados em OPL por meio de fun\u00e7\u00f5es cumulativas e de estado, quando n\u00e3o por\n\npredicados sobre sequ\u00eancias, conforme j\u00e1 mencionado. Por exemplo, uma m\u00e1quina pode exigir\n\ncertas con?gura\u00e7\u00f5es para realizar uma determinada atividade e outras para realizar outra atividade,\n\nde forma que os intervalos representando cada uma delas n\u00e3o podem se sobrepor, ao passo que\n\n\n\n114 AP\u00caNDICE A\n\natividades com con?gura\u00e7\u00f5es id\u00eanticas podem ser realizadas simultaneamente. Entretanto, pode\n\ntamb\u00e9m ser o caso de haver um limite para o n\u00famero de atividades realizadas ao mesmo tempo.\n\nEnquanto que no primeiro caso temos uma situa\u00e7\u00e3o que pode ser modelada por uma fun\u00e7\u00e3o de\n\nestado, no segundo \u00e9 poss\u00edvel realizar a modelagem por meio de uma fun\u00e7\u00e3o cumulativa ? ambos\n\nos casos retratados nas pr\u00f3ximas se\u00e7\u00f5es.\n\nA.5.7 Fun\u00e7\u00f5es Cumulativas\n\nCom as fun\u00e7\u00f5es cumulativas, \u00e9 poss\u00edvel modelar propriedades do sistema que variam ao longo\n\ndo tempo em fun\u00e7\u00e3o da contribui\u00e7\u00e3o num\u00e9rica de express\u00f5es relacionadas ao in\u00edcio e/ou ?m de\n\num conjunto de intervalos, abrindo a possibilidade de expressar restri\u00e7\u00f5es sobre essas propriedades.\n\nUma fun\u00e7\u00e3o cumulativa \u00e9 identi?cada em sua declara\u00e7\u00e3o pela palavra reservada cumulFunction e\n\nconsiste em uma fun\u00e7\u00e3o temporal constante por partes e composta por degraus, cujos termos s\u00e3o\n\nexpress\u00f5es que aumentam ou diminuem o valor da fun\u00e7\u00e3o ao in\u00edcio e/ou ?m de um intervalo. Tais\n\nexpress\u00f5es elementares podem ser pulsos ou degraus.\n\nUm pulso, de?nido pela fun\u00e7\u00e3o pulse, em sua forma mais simples recebe como argumento um\n\nintervalo a e um valor constante positivo b. Ele representa uma fun\u00e7\u00e3o com valor 0 antes do in\u00edcio\n\nde a, b entre o in\u00edcio e o ?m de a, e 0 ap\u00f3s o ?m de a.\n\nUm degrau pode ser de?nido por ao menos duas fun\u00e7\u00f5es distintas: stepAtStart ou stepAtEnd.\n\nEm sua forma mais simples, tamb\u00e9m recebe como argumento um intervalo a e um valor constante\n\npositivo b. No caso de stepAtStart, representa uma fun\u00e7\u00e3o com valor 0 antes do in\u00edcio de a e b do\n\nin\u00edcio de a em diante. No caso de stepAtEnd, uma fun\u00e7\u00e3o com valor 0 antes do ?m de a e b do ?m\n\nde a em diante.\n\nA essa constante positiva b das fun\u00e7\u00f5es mencionadas, ser\u00e1 dado o nome de coe?ciente de varia\u00e7\u00e3o.\n\nAs restri\u00e7\u00f5es mais simples que podem ser formuladas com fun\u00e7\u00f5es cumulativas consistem na\n\ncompara\u00e7\u00e3o da fun\u00e7\u00e3o com um inteiro, indicando uma rela\u00e7\u00e3o v\u00e1lida para a fun\u00e7\u00e3o em todo o seu\n\ndom\u00ednio. Por exemplo, para de?nir que no m\u00e1ximo 5 atividades podem ocorrer simultaneamente, \u00e9\n\nposs\u00edvel expressar o seguinte:\n\ncumulFunction atividadesSimultaneas =\n\nsum(a in dAtividades ) pulse ( escalaAtividade [ a ] ,1) ;\n\nsubject to {\n\natividadesSimultaneas&lt;= 5;\n\n}\n\nComo pode ser visto no exemplo acima, foi criada uma fun\u00e7\u00e3o cumulativa composta por diversos\n\npulsos. Nunca \u00e9 demais lembrar que o coe?ciente de varia\u00e7\u00e3o das fun\u00e7\u00f5es de pulso e degrau deve\n\nser uma constante inteira positiva, mas ainda assim \u00e9 poss\u00edvel somar e subtrair pulsos e degraus\n\nna composi\u00e7\u00e3o de uma express\u00e3o de fun\u00e7\u00e3o cumulativa. Por exemplo, para expressar que o n\u00famero\n\nde atividades pares ocorrendo em qualquer instante de tempo \u00e9 maior que o n\u00famero de atividades\n\n\u00edmpares, \u00e9 poss\u00edvel de?nir o seguinte no modelo:\n\n\n\nMODELAGEM DE PROBLEMAS DE ESCALONAMENTO 115\n\ncumulFuncion saldoAtividadesPares =\n\nsum(a in dAtividades : a % 2 ==0) pulse ( escalaAtividade [ a ] ,1)\n\n? sum (a in dAtividades : a % 2==1) pulse ( escalaAtividade [ a ] ,1) ;\nsubject to {\n\nsaldoAtividadesPares >= 0;\n\n}\n\nTamb\u00e9m \u00e9 poss\u00edvel expressar restri\u00e7\u00f5es sobre partes do dom\u00ednio da fun\u00e7\u00e3o por meio do predicado\n\nalwaysIn que, em sua forma mais simples, leva como argumentos uma fun\u00e7\u00e3o cumulativa F , o\n\nintervalo a no qual o valor da fun\u00e7\u00e3o \u00e9 restrito e os valores constantes de m\u00ednimo x e m\u00e1ximo y\n\npermitidos \u00e0 fun\u00e7\u00e3o dentro desse intervalo. Por exemplo, \u00e9 poss\u00edvel expressar que sempre haver\u00e1 ao\n\nmenos uma e no m\u00e1ximo cinco atividades ocorrendo em cada instante desde o in\u00edcio da primeira\n\natividade de um vetor at\u00e9 o t\u00e9rmino da \u00faltima, conforme o exemplo a seguir:\n\ndvar interval escalaAtividade ;\n\ndvar interval escalaAtividades [ dAtividades ] ;\n\ncumulFunction atividadesSimultaneas =\n\nsum(a in dAtividades ) pulse ( escalaAtividade [ a ] ,1) ;\n\nsubject to {\n\nspan ( escalaAtividade , escalaAtividades ) ;\n\nalwaysIn ( atividadesSimultaneas , escalaAtividade , 1 , 5) ;\n\n}\n\nNas fun\u00e7\u00f5es pulse, stepAtStart, stepAtEnd e alwaysIn, o intervalo dado como argumento\n\npode ser substitu\u00eddo por duas constantes representando o in\u00edcio e o ?m de um intervalo ?xo. Por\n\nexemplo, pode-se expressar que exatamente duas atividades devem ocorrer simultaneamente no\n\nintervalo entre 31 e 40 do exemplo acima da seguinte forma:\n\nalwaysIn ( atividadesSimultaneas , 31 , 40 , 2 , 2) ;\n\nEm modelos mais elaborados, a varia\u00e7\u00e3o da fun\u00e7\u00e3o cumulativa em fun\u00e7\u00e3o de alguns intervalos\n\npode ter graus de liberdade. Isso \u00e9 obtido pela substitui\u00e7\u00e3o da constante b das fun\u00e7\u00f5es de pulso e\n\ndegrau por duas constantes x e y, representando que a varia\u00e7\u00e3o do valor da fun\u00e7\u00e3o cumulativa em\n\ndecorr\u00eancia dos eventos de in\u00edcio e/ou ?m de um dado intervalo pode assumir algum valor inteiro\n\nentre x e y. Por exemplo, para um determinado recurso podemos ter um conjunto de atividades de\n\ndescarga que devem ser realizadas e de atividades de carga opcionais, estas \u00faltimas realizadas para\n\nmanter o estoque do recurso, como no exemplo abaixo:\n\n\n\n116 AP\u00caNDICE A\n\nint noCargas = . . . ;\n\nint noDescargas = . . . ;\n\nrange dCargas = 1 . . noCargas ;\n\nrange dDescargas = 1 . . noDescargas ;\n\nint limEstoque = . . . ;\n\nint estoquePorDescarga [ dDescargas ] = . . . ;\n\ndvar interval atividadesCarga [ dCargas ] optional ;\n\ndvar interval atividadesDescarga [ dDescargas ] ;\n\ncumulFunction estoque =\n\nsum(a in dCargas )\n\nstepAtEnd ( atividadeCarga [ a ] ,1 , limEstoque )\n\n?\nsum(a in dDescargas )\n\nstepAtEnd ( atividadeDescarga [ a ] , estoquePorDescarga [ a ] ) ;\n\nsubject to {\n\nestoque >= 0;\n\nestoque&lt;= limEstoque ;\n\n}\n\nNo modelo apresentado, ao t\u00e9rmino de cada atividade de descarga ocorre uma varia\u00e7\u00e3o negativa\n\nespec\u00ed?ca do estoque. Devido \u00e0 exist\u00eancia da restri\u00e7\u00e3o de que o estoque deva ser sempre n\u00e3o-\n\nnegativo mas n\u00e3o maior que um limite, atividades de carga tamb\u00e9m s\u00e3o alocadas para que ocorram\n\nvaria\u00e7\u00f5es positivas no estoque modelado pela fun\u00e7\u00e3o. A varia\u00e7\u00e3o decorrente de cada atividade de\n\ncarga \u00e9 vari\u00e1vel, assumindo qualquer valor inteiro positivo at\u00e9 o limite m\u00e1ximo do estoque. Por n\u00e3o\n\nassumirmos um valor sempre ?xo para o impacto de um intervalo na fun\u00e7\u00e3o cumulativa, evitamos\n\nproblemas com combina\u00e7\u00f5es de cargas e descargas que gerem estoques residuais, por exemplo. Para\n\nexplicar um pouco melhor, imagine que permit\u00edssemos apenas uma carga completa, isto \u00e9, no valor\n\ndo limite m\u00e1ximo do estoque. Se n\u00e3o houver um conjunto de descargas que esvazie completamente\n\no estoque do recurso, isso implica que n\u00e3o h\u00e1 como realizar uma nova carga com o recurso e ele n\u00e3o\n\npoder\u00e1 ser recarregado para realizar outras atividades de descarga. A varia\u00e7\u00e3o na fun\u00e7\u00e3o cumulativa\n\nem fun\u00e7\u00e3o do in\u00edcio ou ?m de um intervalo pode ser medida como uma express\u00e3o de decis\u00e3o por meio\n\ndas fun\u00e7\u00f5es heightAtStart e heightAtEnd, que recebem como argumento um intervalo a e uma\n\nfun\u00e7\u00e3o cumulativa F e devolvem a varia\u00e7\u00e3o da fun\u00e7\u00e3o cumulativa ocorrida em F , respectivamente,\n\nno in\u00edcio ou ?m de a por conta de express\u00f5es envolvendo a. Essa varia\u00e7\u00e3o soma ou subtrai as\n\ncontribui\u00e7\u00f5es de cada termo de F de acordo com o sinal que precede cada termo. De posse dessa\n\nfun\u00e7\u00e3o, podemos estabelecer uma rela\u00e7\u00e3o entre o tempo da atividade de carga e sua varia\u00e7\u00e3o de\n\nestoque, como no exemplo a seguir:\n\nf o r a l l (a in dCargas ) {\n\nlengthOf ( atividadeCarga [ a ] ) == heightAtStart ( atividadeCarga [ a ] , estoque ) ;\n\n}\n\nAs fun\u00e7\u00f5es heightAtStart e heightAtEnd aceitam um terceiro argumento opcional com o valor\n\na ser devolvido caso o intervalo seja opcional e n\u00e3o esteja presente.\n\nUm \u00faltimo ponto a se observar sobre fun\u00e7\u00f5es cumulativas refere-se \u00e0 quest\u00e3o do limite de\n\nprecis\u00e3o do tipo inteiro: se a soma dos valores dos pulsos e degraus de todos os termos exceder o\n\nlimite represent\u00e1vel, o resolvedor pode considerar o problema infact\u00edvel mesmo que exista solu\u00e7\u00e3o\n\npara o problema e que as restri\u00e7\u00f5es do modelo impossibilitem que a fun\u00e7\u00e3o assuma um valor que\n\n\n\nMODELAGEM DE PROBLEMAS DE ESCALONAMENTO 117\n\nn\u00e3o possa ser representado por um inteiro.\n\nA.5.8 Fun\u00e7\u00f5es de Estado\n\nAl\u00e9m de fun\u00e7\u00f5es baseadas na contribui\u00e7\u00e3o num\u00e9rica dos intervalos, uma outra forma de analisar\n\npropriedades e estabelecer rela\u00e7\u00f5es entre intervalos consiste nas fun\u00e7\u00f5es de estado. Uma fun\u00e7\u00e3o de\n\nestado \u00e9 declarada pela palavra reservada stateFunction, mas n\u00e3o possui uma f\u00f3rmula expl\u00edcita\n\nem fun\u00e7\u00e3o dos intervalos. A rela\u00e7\u00e3o entre uma fun\u00e7\u00e3o de estado e intervalos \u00e9 feita por predicados\n\nno conjunto de restri\u00e7\u00f5es.\n\nComecemos pelo predicado alwaysIn, que \u00e9 id\u00eantico ao apresentado anteriormente para fun\u00e7\u00f5es\n\ncumulativas. Quando se de?ne que uma fun\u00e7\u00e3o de estado deve ter sempre um valor entre um m\u00ednimo\n\ne um m\u00e1ximo no dom\u00ednio de um intervalo, limita-se as possibilidades de concorr\u00eancia de intervalos.\n\nPor exemplo, \u00e9 poss\u00edvel de?nir que atividades pares e \u00edmpares n\u00e3o ocorram simultaneamente da\n\nseguinte forma:\n\nstateFunction tipoAtividade ;\n\nsubject to {\n\nf o r a l l (a in dAtividades : a % 2 == 0) {\n\nalwaysIn ( tipoAtividade , escalaAtividades [ a ] , 0 , 0) ;\n\n}\n\nf o r a l l (a in dAtividades : a % 2 == 1) {\n\nalwaysIn ( tipoAtividade , escalaAtividades [ a ] , 1 , 1) ;\n\n}\n\n}\n\nPelo exemplo acima, for\u00e7a-se que o valor da fun\u00e7\u00e3o de estado tipoAtividade sempre seja 0 durante\n\na execu\u00e7\u00e3o de atividades de \u00edndice par e sempre seja 1 durante a execu\u00e7\u00e3o de atividades de \u00edndice\n\n\u00edmpar. Dessa forma, uma atividade par e uma atividade \u00edmpar nunca concorrer\u00e3o pelo recurso ?\n\napenas uma delas pode ocorrer a cada instante.\n\nAl\u00e9m de alwaysIn, tamb\u00e9m existem os predicados alwaysEqual, alwaysConstant e alwaysNoState.\n\nO alwaysEqual consiste em uma especializa\u00e7\u00e3o do alwaysIn, recebendo apenas um valor v em vez\n\nde um valor m\u00ednimo e outro m\u00e1ximo como argumento, para expressar que o valor da fun\u00e7\u00e3o de\n\nestado F deve ser igual a v durante o intervalo a. No exemplo anterior, isso signi?caria n\u00e3o ter\n\nque colocar duas vezes o mesmo valor para for\u00e7ar a igualdade. O alwaysConstant \u00e9 uma forma\n\nde generaliza\u00e7\u00e3o do alwaysEqual, que determina que o valor da fun\u00e7\u00e3o de estado seja constante\n\nno dom\u00ednio do intervalo, sem especi?car que valor seria esse. De forma complementar, o predicado\n\nalwaysNoState estabelece que a fun\u00e7\u00e3o de estado n\u00e3o deve ter estado de?nido no intervalo dado.\n\nAl\u00e9m das restri\u00e7\u00f5es sobre os predicados mencionados, \u00e9 poss\u00edvel estabelecer o tempo de transi\u00e7\u00e3o\n\nentre estados da fun\u00e7\u00e3o. Essa transi\u00e7\u00e3o \u00e9 modelada com conjuntos de tuplas, da mesma forma como\n\n\u00e9 feito para as sequ\u00eancias. Por\u00e9m, ela \u00e9 associada diretamente \u00e0 fun\u00e7\u00e3o de estado em sua declara\u00e7\u00e3o\n\ncom a palavra reservada with, como abaixo:\n\ntuple tempoTransi\u00e7\u00e3o { int de ; int para ; int tempo ; };\n\n{ tempoTransi\u00e7\u00e3o } fTransi\u00e7\u00e3o = {&lt;i , j , (( i==j ) ?(0) : ( 1 ) )> : i in 0 . . 1 , j in\n\n0 . . 1 };\n\nstateFunction tipoAtividade with fTransi\u00e7\u00e3o ;\n\nNesse exemplo, foi estabelecido um tempo unit\u00e1rio de transi\u00e7\u00e3o entre os estados numericamente\n\nidenti?cados por 0 e 1.\n\n\n\n118 AP\u00caNDICE A\n\nA.5.9 Um Exemplo de Problema de Escalonamento Modelado em OPL\n\nPara concluir a apresenta\u00e7\u00e3o dos elementos para modelagem de problemas de escalonamento,\n\nser\u00e1 dado como exemplo um modelo completo para uma vers\u00e3o bem simples do problema de pro-\n\ngramar recursos m\u00f3veis para a execu\u00e7\u00e3o de um conjunto de atividades. Ele \u00e9 tratado em maiores\n\ndetalhes na terceira parte dessa disserta\u00e7\u00e3o.\n\nNessa vers\u00e3o simples, temos um conjunto de atividades e um conjunto de recursos. Cada ati-\n\nvidade possui uma localiza\u00e7\u00e3o associada e deve ser realizada por um recurso. Um recurso s\u00f3 pode\n\nfazer uma atividade por vez e dois recursos n\u00e3o podem ocupar o mesmo lugar ao mesmo tempo.\n\nPara realizar atividades consecutivas em locais diferentes, a aloca\u00e7\u00e3o de cada recurso deve conside-\n\nrar o tempo de deslocamento necess\u00e1rio entre terminar a atividade anterior em um local e come\u00e7ar\n\na atividade seguinte em outro local. Segue um exemplo de modelo para esse problema:\n\n\n\nMODELAGEM DE PROBLEMAS DE ESCALONAMENTO 119\n\n1 using CP;\n\n2\n\n3 int noAtividades = . . . ;\n\n4 range dAtividades = 1 . . noAtividades ;\n\n5\n\n6 int noRecursos = . . . ;\n\n7 range dRecursos = 1 . . noRecursos ;\n\n8 int noLocais = . . . ;\n\n9 range dLocais = 1 . . noLocais ;\n\n10\n\n11 // Vetor que , numericamente , associa cada atividade a um l o c a l .\n\n12 int localizacao [ a in dAtividades ] = . . . ;\n\n13 // Defini\u00e7\u00e3o da tupla representando o tempo de transi\u00e7\u00e3o entre l o c a i s .\n\n14 tuple Transicao { int deLocal ; int paraLocal ; int tempoDeslocamento ; };\n\n15 // Vetor de conjuntos\n\n16 {Transicao} tempoTransicao [ r in dRecursos ] = . . . ;\n\n17\n\n18 dvar interval escalaAtividade [ a in dAtividades ] ;\n\n19 dvar interval escalaAtividadeRecurso [ a in dAtividades ] [ r in dRecursos ] optional ;\n\n20\n\n21 // Agrupamento das atividades realizadas por cada recurso ,\n\n22 // associando tipo r e l a t i v o \u00e0 localiza\u00e7\u00e3o .\n\n23 dvar sequence sqAtvRecurso [ r in Resources ]\n\n24 in a l l (a in Atividades ) escalaAtividadeRecurso [ a ] [ r ]\n\n25 types a l l (a in Atividades ) localizacao [ a ] ;\n\n26 // Agrupamento das atividades realizadas por cada l o c a l .\n\n27 dvar sequence sqAtvLocal [ l in Locais ]\n\n28 in a l l (a in dAtividades : location [ a]==l ) escalaAtividade [ a ] ;\n\n29\n\n30 subject to {\n\n31 // Cada atividade \u00e9 realizada por exatamente um recurso .\n\n32 f o r a l l (a in dAtividades ) {\n\n33 // For\u00e7a com que cada atividade (com intervalo obrigat\u00f3rio ) esteja\n\n34 // presente em apenas um intervalo de recurso ( os intervalos da\n\n35 // matriz Atividade x Recurso s\u00e3o opcionais ) .\n\n36 alternative ( escalaAtividade [ a ] ,\n\n37 a l l ( r in dRecursos ) escalaAtividadeRecurso [ a ] [ r ] ) ;\n\n38 }\n\n39\n\n40 // Cada recurso r e a l i z a uma atividade por vez , e separa?as pelo tempo\n41 // de deslocamento entre os l o c a i s de atividades consecutivas .\n\n42 f o r a l l ( r in dRecursos ) {\n\n43 noOverlap ( sqAtvRecurso [ r ] , tempoTransicao [ r ] ) ;\n\n44 }\n\n45\n\n46 // Apenas uma atividade pode ser realizada por vez em cada l o c a l .\n\n47 f o r a l l ( l in dLocais ) {\n\n48 noOverlap ( sqAtvLocal [ l ] ) ;\n\n49 }\n\n50 }\n\n\n\n120 AP\u00caNDICE A\n\nA.6 Considera\u00e7\u00f5es Finais e Agradecimentos\n\nA expectativa do autor com rela\u00e7\u00e3o a este material \u00e9 que ele sirva \u00e0 apresenta\u00e7\u00e3o dos conceitos\n\nnecess\u00e1rios para familiarizar o leitor com a modelagem alg\u00e9brica de modelos utilizando a t\u00e9cnica\n\nde programa\u00e7\u00e3o por restri\u00e7\u00f5es. Como subs\u00eddio, foi utilizada a linguagem OPL em raz\u00e3o de sua\n\nmaturidade e popularidade. Para um aprofundamento na pr\u00e1tica atual usando OPL, recomenda-se\n\ntanto o manual da IBM (2010) quanto uma leitura de Laborie (2009). \u00c9 importante observar que\n\nalguns artigos mais antigos como Hentenryck et al. (2000) e Lustig e Puget (2001) apresentam uma\n\nsintaxe e certas estruturas que foram descontinuadas em vers\u00f5es posteriores. Entretanto, sua leitura\n\npermanece \u00fatil \u00e0 compreens\u00e3o dos princ\u00edpios que nortearam o desenvolvimento da linguagem e o\n\nfuncionamento do resolvedor.\n\nEsse texto contou com a colabora\u00e7\u00e3o de v\u00e1rios revisores, que contribu\u00edram para torn\u00e1-lo mais\n\nacess\u00edvel e direto por meio de uma leitura minuciosa. At\u00e9 a presente vers\u00e3o, foram eles: Gilberto\n\nKoji Nishioka, Edson Mikio Nishida, Daniel Felix Ferber, Gustavo Pacianotto Gouveia e Yoshiko\n\nWakabayashi.\n\n\n\nRefer\u00eancias Bibliogr\u00e1?cas\n\nAarts e Lenstra(1997) E. H. L. Aarts e J. K. Lenstra. Local Search in Combinatorial Optimiza-\ntion. Wiley. Citado na p\u00e1g. 10\n\nAccioly et al.(2002) R. Accioly, F. J. M. Marcellino e H. Kobayashi. Uma aplica\u00e7\u00e3o da programa-\n\u00e7\u00e3o por restri\u00e7\u00f5es no escalonamento de atividades em po\u00e7os de petr\u00f3leo. Em Simp\u00f3sio Brasileiro\nde Pesquisa Operacional. Sobrapo. Citado na p\u00e1g. 7\n\nAcergy-Group(2010) Acergy-Group. Polar queen apr 10.pdf. http://www.acergy-group.com/\npublicroot/webresources/6P6D55RDUN/$?le/Polar%20Queen%20Apr%2010.pdf, 2010. For-\nmato PDF. Acesso em: 1 jun. 2010. Citado na p\u00e1g. 5\n\nAloise et al.(2006) D. J. Aloise, D. Aloise, C. T. M. Rocha, C. C. Ribeiro, J. C. R. Filho e L. S. S.\nMoura. Scheduling workover rigs for onshore oil production. Discrete Applied Mathematics, 154:\n695?702(5). Citado na p\u00e1g. 8\n\nArbelaez et al.(2009) A. Arbelaez, Y. Hamadi e M. Sebag. Online heuristic selection in cons-\ntraint programming. Em Proceedings of the International Symposium on Combinatorial Search\n(SoCS'09), p\u00e1ginas 674?681. Citado na p\u00e1g. 33\n\nBaptiste et al.(2001) P. Baptiste, C. Le Pape e W. Nuijten. Constraint-Based Scheduling: Applying\nConstraint Programming to Scheduling Problems. Kluwer. Citado na p\u00e1g. 33, 42, 49, 53, 55\n\nBaptiste et al.(2006) P. Baptiste, P. Laborie, C. Le Pape e W. Nuijten. Constraint-based sche-\nduling and planning. Em F. Rossi, P. van Beek e T. Walsh, editors, Handbook of Constraint\nProgramming, chapter 22. Elsevier. Citado na p\u00e1g. 41, 42, 49, 50, 52, 53, 54\n\nBart\u00e1k(2001) R. Bart\u00e1k. Theory and practice of constraint propagation. Em Proceedings of the\n3rd Workshop on Constraint Programming for Decision and Control (CPDC2001), p\u00e1ginas 7?14.\nWydavnictvo Pracovni Komputerowej. Citado na p\u00e1g. 14, 19, 25, 26\n\nBart\u00e1k(1999) R. Bart\u00e1k. Constraint programming: In pursuit of the holy grail. Em Proceedings\nof the Week of Doctoral Students (WDS99), p\u00e1ginas 555?564. MatFyzPress. Citado na p\u00e1g. 13, 14,\n19, 21, 25, 31, 34, 37\n\nBart\u00e1k(2008) R. Bart\u00e1k. Book review: Constraint Processing, Handbook of Constraint Program-\nming. Computer Science Review, 2(2):123 ? 130. Citado na p\u00e1g. 15\n\nBattiti et al.(2008) R. Battiti, M. Brunato e F. Mascia. Reactive Search and Intelligent Optimi-\nzation. Springer. Citado na p\u00e1g. 10, 56\n\nBazaraa et al.(1990) M. S. Bazaraa, J. J. Jarvis e H. D. Sherali. Linear Programming and Network\nFlows. Wiley. Citado na p\u00e1g. 4\n\nBeldiceanu et al.(2007) Nicolas Beldiceanu, Mats Carlsson, Sophie Demassey e Thierry Petit.\nGlobal constraint catalogue: Past, present and future. Constraints, 12:21?62. Citado na p\u00e1g. 27\n\n121\n\nhttp://www.acergy-group.com/publicroot/webresources/6P6D55RDUN/$file/Polar%20Qu een%20Apr%2010.pdf\nhttp://www.acergy-group.com/publicroot/webresources/6P6D55RDUN/$file/Polar%20Qu een%20Apr%2010.pdf\n\n\n122 REFER\u00caNCIAS BIBLIOGR\u00c1FICAS\n\nBessi\u00e8re e Hentenryck(2003) C. Bessi\u00e8re e P. V. Hentenryck. To be or not to be ... a global\nconstraint. Em Francesca Rossi, editor, Principles and Practice of Constraint Programming,\nvolume 2823 of Lecture Notes in Computer Science, p\u00e1ginas 789?794. Springer Berlin Heidelberg.\nCitado na p\u00e1g. 27\n\nBockmayr e Kasper(1998) A. Bockmayr e T. Kasper. Branch and infer: A unifying framework\nfor integer and ?nite domain constraint programming. INFORMS Journal on Computing, 10:\n287?300(3). Citado na p\u00e1g. 14\n\nBondy e Murty(2008) A. Bondy e U. S. R. Murty. Graph Theory. Springer. Citado na p\u00e1g. 4\n\nBrafman(2001) R. I. Brafman. A simpli?er for propositional formulas with many binary clauses.\nEm Proceedings of the 17th International Joint Conference on Arti?cial Intelligence (IJCAI'01).\nCitado na p\u00e1g. 50\n\nBrailsford et al.(1999) S. C. Brailsford, C. N. Potts e B. M. Smith. Constraint satisfaction\nproblems: Algorithms and applications. European Jornal of Operational Research (EJOR), 119:\n557?581. Citado na p\u00e1g. 15, 18, 33\n\nCamm et al.(1990) J. D. Camm, A. S. Raturi e S. Tsubakitani. Cutting big M down to size.\nInterfaces, 20:61?66. Citado na p\u00e1g. 73\n\nCarchrae e Beck(2005) T. Carchrae e J.C. Beck. Applying machine learning to low knowledge\ncontrol of optimization algorithms. Computational Intelligence, 21:372?387. Citado na p\u00e1g. 56\n\nCarlier e Pinson(1994) J. Carlier e E. Pinson. Adjustment of heads and tails for the job-shop\nproblem. European Jornal of Operational Research (EJOR), 78:146?161. Citado na p\u00e1g. 53\n\nCesta e Oddi(1996) A. Cesta e A. Oddi. Gaining e?ciency and ?exibility in the simple tempo-\nral problem. Em Proceedings of the 3rd Workshop on Temporal Representation and Reasoning\n(TIME'96). Citado na p\u00e1g. 51\n\nCormen et al.(2002) T. H. Cormen, C. E. Leiserson, R. L. Rivest e S. Cli?ord. Algoritmos ?\nTeoria e Pr\u00e1tica. Editora Campus. Citado na p\u00e1g. 4, 29, 50\n\nDechter(2003) R. Dechter. Constraint Processing. Morgan Kaufmann. Citado na p\u00e1g. 15, 19, 21,\n23, 29, 34, 35, 36, 37, 56\n\ndo Nascimento(2002) J. M. do Nascimento. Ferramentas computacionais h\u00edbridas para a oti-\nmiza\u00e7\u00e3o da produ\u00e7\u00e3o de petr\u00f3leo em \u00c1guas profundas. Disserta\u00e7\u00e3o de Mestrado, Instituto de\nComputa\u00e7\u00e3o, Universidade Estadual de Campinas, Brasil. Citado na p\u00e1g. 7\n\nDynadec(2009) Dynadec. Comet 2.0 Tutorial, 2009. Citado na p\u00e1g. 38, 42, 46\n\nFeo e Resende(1989) T. A. Feo e M. G. C. Resende. A probabilistic heuristic for a computatio-\nnally di?cult set covering problem. Operations Research Letters, 8:67?71. Citado na p\u00e1g. 7\n\nFocacci et al.(2000) F. Focacci, A. Lodi, M. Milano e D. Vigo. An introduction to constraint\nprogramming. Ricerca Operativa, 91. Citado na p\u00e1g. 22\n\nGlinz e Berumen(2009) I. Glinz e L. Berumen. Optimization model for an oil well drilling\nprogram: Mexico case. Oil and Gas Business, 1. Citado na p\u00e1g. 8\n\nGlover(1989) F. Glover. Tabu search ? part I. ORSA Journal on Computing, 1:190?206(3). Citado\nna p\u00e1g. 7\n\nGodard e Laborie(2005) D. Godard e P. Laborie. Randomized large neighborhood search for\ncumulative scheduling. Em Proceedings of the 2005 International Conference on Automated Plan-\nning and Scheduling (ICAPS 2005), p\u00e1ginas 81?89. Citado na p\u00e1g. 38, 56\n\n\n\nREFER\u00caNCIAS BIBLIOGR\u00c1FICAS 123\n\nGomes e Selman(2007) C. Gomes e B. Selman. The science of constraints. Constraint Program-\nming Letters, 1:15?20. Citado na p\u00e1g. 39\n\nGomes et al.(1998) C. P. Gomes, B. Selman e H. Kautz. Boosting combinatorial search through\nrandomization. Em Proceedings of the Fifteenth National Conference on Arti?cial Intelligence\n(AAAI-98), p\u00e1ginas 431?437. Citado na p\u00e1g. 36\n\nHasle et al.(1996) G. Hasle, R. Haut, B. Johansen e T. \u00d8lberg. Well activity scheduling ? an\napplication of constraint reasoning. Em B. Braunschweig e B. A. Bremdal, editors, Arti?cial\nIntelligence in the Petroleum Industry: Symbolic and Computational Applications II, p\u00e1ginas\n209?228. Technip, Paris. Citado na p\u00e1g. 7\n\nHentenryck(2010) P. V. Hentenryck. Constraint programming as declarative algorithmics. Em\nF. Benhamou, N. Jussien e B. O'Sullivan, editors, Trends in Constraint Programming. Wiley.\nCitado na p\u00e1g. 13, 39\n\nHentenryck e Michel(2007) P. V. Hentenryck e L. Michel. Synthesis of constraint-based local\nsearch algorithms from high-level models. Em Proceedings of the 22nd National Conference on\nArti?cial Intelligence (AAAI-07), p\u00e1ginas 273?278. Citado na p\u00e1g. 39\n\nHentenryck et al.(1992) P. V. Hentenryck, Y. Deville e C. M. Teng. A generic arc-consistency\nalgorithm and its specializations. Arti?cial Intelligence, 57. Citado na p\u00e1g. 25\n\nHentenryck et al.(2000) P. V. Hentenryck, L. Perron e J. F. Puget. Search and strategies in opl.\nACM Transactions on Computational Logic (TOCL), 1:285?320(2). Citado na p\u00e1g. 18, 38, 39, 120\n\nHooker(2007) J. N. Hooker. Good and bad futures for constraint programming (and operations\nresearch). Constraint Programming Letters, 1:21?32. Citado na p\u00e1g. 30\n\nHooker(2006) J. N. Hooker. Integrated Methods for Optimization (International Series in Opera-\ntions Research &amp; Management Science). Springer-Verlag New York, Inc. Citado na p\u00e1g. 10\n\nHoos e St\u00fctzle(2005) H. H. Hoos e T. St\u00fctzle. Stochastic Local Search: Foundations and Appli-\ncations. Morgan Kaufmann. Citado na p\u00e1g. 37\n\nIBM(2010) IBM. ILOG CPLEX Optimization Studio 12.2 documentation for ODM Enterprise,\n2010. Citado na p\u00e1g. 16, 18, 38, 42, 89, 120\n\nJa?ar e Lassez(1987) J. Ja?ar e J. L. Lassez. Constraint logic programming. Em Proceedings of\nthe 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL\n'87), p\u00e1ginas 111?119. Citado na p\u00e1g. 37\n\nKantorovich(1975) L. V. Kantorovich. Mathematics in economics: Achievements, dif-\n?culties, perspectives. http://www.nobelprize.org/nobel_prizes/economics/laureates/1975/\nkantorovich-lecture.html, 1975. \u00daltimo acesso em 6/9/2011. Citado na p\u00e1g. 13\n\nKautz et al.(2002) H. Kautz, E. Horvitz, Y. Ruan, C. Gomes e B. Selman. Dynamic restart\npolicies. Em Proceedings of the Eighteenth National Conference on Arti?cial Intelligence (AAAI-\n02), p\u00e1ginas 674?681. Citado na p\u00e1g. 33, 36\n\nKoopmans(1975) T. C. Koopmans. Concepts of optimality and their uses. http://www.\nnobelprize.org/nobel_prizes/economics/laureates/1975/koopmans-lecture.html, 1975. \u00daltimo\nacesso em 6/9/2011. Citado na p\u00e1g. 13\n\nLaborie(2009) P. Laborie. IBM ILOG CP Optimizer for detailed scheduling illustrated on three\nproblems. Em W. J. van Hoeve e J. N. Hooker, editors, Integration of AI and OR Techniques\nin Constraint Programming for Combinatorial Optimization Problems, volume 5547 of Lecture\nNotes in Computer Science, p\u00e1ginas 148?162. Springer Berlin Heidelberg. Citado na p\u00e1g. 120\n\nhttp://www.nobelprize.org/nobel_prizes/economics/laureates/1975/kantorovich-lecture.html\nhttp://www.nobelprize.org/nobel_prizes/economics/laureates/1975/kantorovich-lecture.html\nhttp://www.nobelprize.org/nobel_prizes/economics/laureates/1975/koopmans-lecture.html\nhttp://www.nobelprize.org/nobel_prizes/economics/laureates/1975/koopmans-lecture.html\n\n\n124 REFER\u00caNCIAS BIBLIOGR\u00c1FICAS\n\nLaborie(2003a) P. Laborie. Algorithms for propagating resource constraints in AI planning and\nscheduling: Existing approaches and new results. Arti?cial Intelligence, 143:151?188. Citado na p\u00e1g.\n38, 49, 51, 52, 54, 55\n\nLaborie(2003b) P. Laborie. Resource temporal networks: De?nition and complexity. Em Proce-\nedings of the 18th International Joint Conference on Arti?cial Intelligence (IJCAI'03). Citado na\np\u00e1g. 46\n\nLaborie e Godard(2007) P. Laborie e D. Godard. Self-adapting large neighborhood search:\nApplication to single-mode scheduling problems. Em Proceedings of the 3rd Multidisciplinary\nInternational Conference on Scheduling: Theory and Applications (MISTA 2007), p\u00e1ginas 276?\n284. Citado na p\u00e1g. 37, 38, 56\n\nLaborie e Rogerie(2008) P. Laborie e J. Rogerie. Reasoning with conditional time-intervals. Em\nProceedings of the 21st International Florida Arti?cial Intelligence Research Society Conference\n(FLAIRS 2008). Citado na p\u00e1g. 38, 46, 50, 63\n\nLaborie et al.(2009) P. Laborie, J. Rogerie, P. Shaw e P. Vil\u00edm. Reasoning with conditional time-\nintervals, part ii: An algebraical model for resources. Em Proceedings of the 22st International\nFlorida Arti?cial Intelligence Research Society Conference (FLAIRS 2009). Citado na p\u00e1g. 38, 46,\n63\n\nLustig e Puget(2001) I. J. Lustig e J. F. Puget. Program does not equal program: Constraint\nprogramming and its relationship to mathematical programming. Interfaces, 31:29?53(6). Citado\nna p\u00e1g. 13, 14, 16, 30, 37, 38, 90, 106, 120\n\nMonette et al.(2009) J. N. Monette, Y. Deville e P. V. Hentenryck. Aeon: Synthesizing schedu-\nling algorithms from high-level models. Em Proceedings of 11th INFORMS Computing Society\nConference. Citado na p\u00e1g. 39, 56\n\nMoura et al.(2008a) A. V. Moura, C. C. de Souza, A. A. Cire e T. M. T. Lopes. Planning\nand scheduling the operation of a very large oil pipeline network. Em Peter Stuckey, editor,\nPrinciples and Practice of Constraint Programming, volume 5202 of Lecture Notes in Computer\nScience, p\u00e1ginas 36?51. Springer Berlin Heidelberg. Citado na p\u00e1g. 8\n\nMoura et al.(2008b) A. V. Moura, R. A. Pereira e C. C. de Souza. Scheduling activities at oil wells\nwith resource displacement. International Transactions in Operational Research, 15:659?683(25).\nCitado na p\u00e1g. 7\n\nNethercote et al.(2007) N. Nethercote, P. J. Stuckey, R. Becket, S. Brand, G. J. Duck e G. Tack.\nMiniZinc: Towards a standard CP modelling language. Em C. Bessi\u00e8re, editor, Principles and\nPractice of Constraint Programming, volume 4741 of Lecture Notes in Computer Science, p\u00e1ginas\n529?543. Springer Berlin Heidelberg. Citado na p\u00e1g. 39\n\nNocedal e Wright(2000) J. Nocedal e S. J. Wright. Numerical Optimization. Springer. Citado na\np\u00e1g. 4\n\nPaiva(1997) R. O. Paiva. Itiner\u00e1rio de sondas com quanti?ca\u00e7\u00e3o de perdas atrav\u00e9s de simulador\nde reservat\u00f3rios. Disserta\u00e7\u00e3o de Mestrado, Faculdade de Engenharia Mec\u00e2nica, Universidade\nEstadual de Campinas, Brasil. Citado na p\u00e1g. 8\n\nPereira et al.(2005) R. A. Pereira, A. V. Moura e C. C. de Souza. Comparative experiments with\nGRASP and constraint programming for the oil well drilling problem. Em S. E. Nikoletseas,\neditor, WEA, volume 3503 of Lecture Notes in Computer Science, p\u00e1ginas 328?340. Springer.\nCitado na p\u00e1g. 7\n\n\n\nREFER\u00caNCIAS BIBLIOGR\u00c1FICAS 125\n\nPuget(2004) J. F. Puget. Constraint programming next challenge: Simplicity of use. Em Mark\nWallace, editor, Principles and Practice of Constraint Programming, volume 3258 of Lecture Notes\nin Computer Science, p\u00e1ginas 5?8. Springer Berlin Heidelberg. Citado na p\u00e1g. 38, 39\n\nRefalo(2004) P. Refalo. Impact-based search strategies for constraint programming. Em Mark\nWallace, editor, Principles and Practice of Constraint Programming, volume 3258 of Lecture Notes\nin Computer Science, p\u00e1ginas 557?571. Springer Berlin Heidelberg. Citado na p\u00e1g. 32, 33, 38\n\nR\u00e9gin(1994) J. C. R\u00e9gin. A ?ltering algorithm for constraints of di?erence in CSPs. Em Procee-\ndings of the Twelfth National Conference on Arti?cial Intelligence (AAAI-94), p\u00e1ginas 362?367.\nCitado na p\u00e1g. 28, 29\n\nScott(1999) M. L. Scott. Programming Language Pragmatics. Morgan Kaufmann. Citado na p\u00e1g. 37\n\nSerra e Wakabayashi(2010) T. Serra e Y. Wakabayashi. The full employment theorem for solver\ndesigners and related issues in CP modeling. Em Anais do V Workshop de Teses e Disserta\u00e7\u00f5es\nem Andamento (WTDIA). SBC. Citado na p\u00e1g. 15, 39\n\nSerra et al.(2010) T. Serra, G. Nishioka e F. Marcellino. A constraint programming approach to\nthe problem of oil well drilling scheduling with resource displacement and inventory management.\nEm ALIO-INFORMS Joint International Meeting. ALIO-INFORMS. Citado na p\u00e1g. 7\n\nSerra et al.(2011) T. Serra, G. Nishioka e F. J. M. Marcellino. A constraint-based scheduling\nof o?shore well development activities with inventory management. Em Simp\u00f3sio Brasileiro de\nPesquisa Operacional. Sobrapo. Citado na p\u00e1g. 7, 71, 72, 78\n\nSerra et al.(2012) T. Serra, G. Nishioka e F. J. M. Marcellino. On estimating the return of resource\naquisitions through scheduling: An evaluation of continuous-time MILP models to approach the\ndevelopment of o?shore oil wells. Em Scheduling and Planning Applications woRKshop (SPARK).\nAAAI. Citado na p\u00e1g. 7, 71, 72, 78\n\nSipser(2007) M. Sipser. Introdu\u00e7\u00e3o \u00e0 Teoria da Computa\u00e7\u00e3o. Thomson. Citado na p\u00e1g. 4\n\nSmith-Miles(2008) K. A. Smith-Miles. Cross-disciplinary perspectives on meta-learning for al-\ngorithm selection. ACM Computing Surveys (CSUR), 41. Citado na p\u00e1g. 15, 56\n\nThomas(2004) J. E. Thomas. Fundamentos de Engenharia de Petr\u00f3leo. Interci\u00eancia. Citado na p\u00e1g.\n3\n\nvan Beek(2006) P. van Beek. Backtracking search algorithms. Em F. Rossi, P. van Beek e\nT. Walsh, editors, Handbook of Constraint Programming, chapter 4. Elsevier. Citado na p\u00e1g. 29, 30,\n31, 34, 35\n\nvan Hoeve et al.(2011) W. J. van Hoeve, M. Hunting e C. Kuip. The aimms interface to constraint\nprogramming. Em T. Achterberg e J. C. Beck, editors, Proceedings of CPAIOR Late Breaking\nAbstracts, p\u00e1ginas 41?43. Konrad-Zuse-Zentrum fur Informationstechnik Berlin. Citado na p\u00e1g. 39\n\nVazirani(2001) V. V. Vazirani. Approximation Algorithms. Springer-Verlag. Citado na p\u00e1g. 9\n\nVilain et al.(1990) M. Vilain, H. Kautz e P. van Beek. Constraint propagation algorithms for tem-\nporal reasoning: A revised report. Em Readings in qualitative reasoning about physical systems.\nMorgan Kaufmann. Citado na p\u00e1g. 46\n\nVil\u00edm(2007) P. Vil\u00edm. Global Constraints in Scheduling. Tese de Doutorado, Faculty of Mathe-\nmatics and Physics, Charles University, Rep\u00fablica Tcheca. Citado na p\u00e1g. 49, 53, 54\n\nWilliams(2005) H. P. Williams. Model Building in Mathematical Programming. Wiley. Citado na\np\u00e1g. 18\n\n\n\n126 REFER\u00caNCIAS BIBLIOGR\u00c1FICAS\n\nWolsey(1998) L. A. Wolsey. Integer Programming. Wiley. Citado na p\u00e1g. 4\n\nYue(2008) Z. Q. Yue. 9320168.jpg. http://www.panoramio.com/photo/9320168, 2008. Largura:\n2272 pixels. Altura: 1704 pixels. Tamanho: 1017,17KB. Formato JPEG. Acesso em: 1 jun. 2010.\nCitado na p\u00e1g. 5\n\nhttp://www.panoramio.com/photo/9320168\n\n\n\u00cdndice Remissivo\n\n\u00e1guas profundas, 5\n\u00e1rvore, 4\n\nalgoritmo\nAC, 24\nAC-1, 24\nAC-2, 24\nAC-3, 24\nAC-4, 24\nAC-5, 25\nAC-6, 24\nAC-7, 24\nBJ, 35\nBT, 31\nCBJ, 35\nde aproxima\u00e7\u00e3o, 9\nde busca, 29, 55\nde caminhos mais curtos, 71\nde ?ltragem, 14, 19, 24, 25, 28\nde retrocesso baseado em con?ito, 35\nde retrocesso por salto, 35\nFC, 34\nMAC, 34\nPC, 25\nPC-1, 25\nPC-2, 25\nPC-3, 25\nPC-4, 25\nPC-5, 25\n\naloca\u00e7\u00e3o, 6, 8\nantecipa\u00e7\u00e3o\n\nparcial, 34\ntotal, 34\n\narco, 20\natividade\n\nel\u00e1stica, 43\nn\u00e3o-preemptiva, 43\nopcional, 44, 46\npreemptiva, 43\n\nbarcos lan\u00e7adores de linhas, 5\nbusca, 13, 29, 39, 41, 55\n\nalgoritmo de, 55\n\ncompleta, 29\ncorte na, 37\ndegenera\u00e7\u00e3o da, 31, 35\ndicot\u00f4mica, 30\nespa\u00e7o de, 63\nestoc\u00e1stica, 29, 36\nexaustiva, 29\nincompleta, 29\nlocal, 9, 29, 36\nlocal estoc\u00e1stica, 37\npor discrep\u00e2ncia limitada, 33, 36\npor factibilidade, 29\ntabu, 7, 9\n\nclasse de problemas\nNP, 4\nNP-Completo, 4, 15, 19, 24, 50\nNP-Dif\u00edceis, 4, 7, 15\n\ncodi?ca\u00e7\u00e3o\ndual, 26\npor vari\u00e1veis ocultas, 27\n\nconjunto\nde con?ito, 35\nde valores de suporte, 24\n\nconsist\u00eancia, 14, 19, 33, 49\nk-consist\u00eancia, 21\nk-consist\u00eancia forte, 21\nn-consist\u00eancia, 22\n(i,j), 23\n1-consist\u00eancia, 21\n2-consist\u00eancia, 21\n3-consist\u00eancia, 21\nbin\u00e1ria, 20, 21, 24\nn\u00edveis de, 21\n\ncompleta, 19, 22\nde arco, 20\nde n\u00f3, 20\ndirecional em n\u00edvel de aresta, 22\nem k-\u00e9simo n\u00edvel, 21\nem n\u00edvel de aresta, 21, 24, 34\nem n\u00edvel de caminho, 21, 25\nem n\u00edvel de v\u00e9rtice, 21, 24\nforte, 21\n\n127\n\n\n\n128 \u00cdNDICE REMISSIVO\n\ngeneralizada, 27, 28\ninversa, 24\nmanuten\u00e7\u00e3o da, 34\nn\u00edveis de, 14, 19, 21, 22\nn\u00edveis intermedi\u00e1rios de, 25\nponto ?xo de, 49, 51, 53\npor conjunto unit\u00e1rio, 23\npor limites, 23, 50\nrestrita em n\u00edvel de caminho, 23\nt\u00e9cnicas de, 19\ntipos de, 19\n\nCP\nconfer\u00eancia, 28\n\ndata\nde libera\u00e7\u00e3o, 43, 52\nlimite de conclus\u00e3o, 43, 52\n\ndetec\u00e7\u00e3o tardia de con?ito, 31, 33, 35\ndom\u00ednio\n\nde restri\u00e7\u00e3o, 22\nde vari\u00e1vel, 14\n\ndownstream, 5\n\nemparelhamento m\u00e1ximo, 5, 28\nescalonamento, 7, 8, 41\n\nbaseado em restri\u00e7\u00f5es, 9, 41, 63\nexploitation, 5\nexplora\u00e7\u00e3o, 5\n\nfactibilidade, 29\nferramentas comerciais, 38\nfun\u00e7\u00e3o\n\ncumulativa, 48\ndegrau, 48\npulso, 48\n\nde custo de transi\u00e7\u00e3o, 45\nde estado, 48\nde tempo de transi\u00e7\u00e3o, 44, 48, 64\n\ngrafo, 4, 16\nbipartido, 5, 28\ncorte de um, 5\nde preced\u00eancias, 53\ndo modelo, 21, 27\ndo modelo dual, 26\nhipergrafo, 27\nsubgrafo, 4\nsubgrafo induzido, 4, 27\n\ngrafos\nisomor?smo de, 5, 27\nordena\u00e7\u00e3o topol\u00f3gica de, 4\norienta\u00e7\u00e3o de, 4\nrotula\u00e7\u00e3o graciosa de, 16\n\nGRASP, 7, 9\n\nheur\u00edstica, 9\nconstrutiva, 9\nde busca local, 9\nmeta-heur\u00edstica, 9\n\ninfer\u00eancia, 19\ngera\u00e7\u00e3o de, 19\n\ninvi\u00e1vel, 30\n\nlinguagem\nAIMMS, 39\nalg\u00e9brica, 38\nComet, 38, 39, 56\nde modelagem abstrata, 39\nMiniZinc, 39\nOPL, 16, 17, 38, 42, 55, 63, 77\nProlog, 37\n\nmeta-aprendizagem, 15\nmodelagem, 14, 18, 39, 41, 42\nmodelo, 13, 14, 18, 42, 63\n\nbin\u00e1rio, 26\ndual, 26\ninsatisfat\u00edvel, 28\n\nn\u00f3, 20\nn\u00edvel\n\nde planejamento, 8\noperacional, 8\nt\u00e1tico, 8\n\nORCA\nsistema, 7\n\nordena\u00e7\u00e3o\ndas atribui\u00e7\u00f5es, 32\ndin\u00e2mica, 32\nest\u00e1tica, 32\n\notimalidade, 29\notimiza\u00e7\u00e3o num\u00e9rica, 3\n\nparadigmas, 37\nprinc\u00edpio\n\nda casa dos pombos, 28\nda sub-estrutura \u00f3tima, 29\nde falhar primeiro, 32\n\nproblema\ncombinat\u00f3rio, 3, 9, 16\nda sele\u00e7\u00e3o de algoritmos, 15\ndas n rainhas, 17\nde escalonamento de ch\u00e3o-de-f\u00e1brica, 53\nde formula\u00e7\u00e3o da estrat\u00e9gia \u00f3tima de rami-\n\n?ca\u00e7\u00e3o, 33\nde otimiza\u00e7\u00e3o da satisfa\u00e7\u00e3o de restri\u00e7\u00f5es, 14\nde satisfa\u00e7\u00e3o de restri\u00e7\u00f5es, 14\n\n\n\n\u00cdNDICE REMISSIVO 129\n\nde satisfabilidade, 50\nde satisfabilidade 2-SAT, 50\ndo escalonamento de ch\u00e3o-de-f\u00e1brica, 7\ninsatisfat\u00edvel, 19, 33\nsatisfat\u00edvel, 33\ntemporal simples, 51\n\nprodu\u00e7\u00e3o, 5\nprograma\u00e7\u00e3o, 8\n\ndin\u00e2mica, 29\nfuncional, 37\ninteira, 15\nl\u00f3gica, 37\nl\u00f3gica por restri\u00e7\u00f5es, 37\nlinear, 3, 13\nlinear inteira, 3, 9, 14\nmatem\u00e1tica, 8\npor restri\u00e7\u00f5es, 7, 9, 13\n\nproje\u00e7\u00e3o, 26\npropaga\u00e7\u00e3o, 41, 63\n\nde restri\u00e7\u00f5es, 14, 19, 49\ndisjuntiva, 52\nenerg\u00e9tica, 52\nglobal, 27, 51\nlocal, 27, 50\npor aus\u00eancia de arestas, 53\npor balanceamento, 54\npor busca de arestas, 53\npor preced\u00eancia energ\u00e9tica, 54\npor tabela de tempos, 52\n\nquebra de simetrias, 18\n\nrami?ca\u00e7\u00e3o, 31, 78\nestrat\u00e9gias de, 31\nheur\u00edsticas para, 32\ntipos de, 31\n\nrecurs\u00e3o, 29, 30\nrecurso\n\ncapacidade do, 45\ncumulativo, 45\ndisjuntivo, 45\nestado do, 44\nreservat\u00f3rio, 45\ntipo de estado do, 44\n\nredes booleanas, 50\nrejei\u00e7\u00e3o, 35\nrelaxa\u00e7\u00e3o, 71\nresolvedor caixa-preta, 39\nrestri\u00e7\u00e3o, 14\n\nalldi?erent, 17, 18, 28\nalternative, 47, 64\nalways-constant, 48\nalways-in, 48, 66\n\nalways-nostate, 48\nanti-funcional, 25\naprendizado de, 35\naridade de, 26\nbin\u00e1ria, 20\nbinariza\u00e7\u00e3o de, 26\ndeclarativa, 14\nenumarativa, 14\nfraca, 15\nfuncional, 25\nglobal, 27, 39, 47\nalgor\u00edtmica, 28\noperacional, 28\nsem\u00e2ntica, 28\n\nimpl\u00edcita, 35\nmonot\u00f4nica, 25\nno-overlap, 47, 64, 67, 68\nredundante, 18, 26, 35\nspan, 47\nun\u00e1ria, 20, 24\n\nretrocesso, 29, 30\ncronol\u00f3gico, 31\ndin\u00e2mico, 35\ninteligente, 35\n\nSAT, veja problemade de satisfabilidade\nsequ\u00eancia de intervalos, 47\nsimetria, 18\nsintaxe, 63\nsistem\u00e1tica de explora\u00e7\u00e3o, 29\nsolu\u00e7\u00e3o equivalente, 18\nsondas mar\u00edtimas, 5\nsudoku, 17\n\nt\u00e9cnicas\npreventivas, 33\nreativas, 34\n\ntrabalho redundante, 31, 35, 36\n\nupstream, 5\n\nv\u00e9rtice\ngrau do, 22\n\nvalor de suporte, 24\nvari\u00e1vel\n\nde decis\u00e3o, 14\nde intervalo, 46, 63\n\nvari\u00e1vel intervalar, veja vari\u00e1vel de intervalo\nveri?ca\u00e7\u00e3o adiantada, 34\n\n\n\tLista de Abreviaturas\n\tLista de Figuras\n\tLista de Tabelas\n\tI INTRODU\u00c7\u00c3O\n\tIntrodu\u00e7\u00e3o\n\tRefer\u00eancias e Notas de Apoio \u00e0 Leitura\n\tA Ind\u00fastria de Petr\u00f3leo e a Programa\u00e7\u00e3o de Recursos Cr\u00edticos\n\tProblemas de Escalonamento e a Programa\u00e7\u00e3o por Restri\u00e7\u00f5es\n\tOrganiza\u00e7\u00e3o do Restante do Trabalho\n\n\n\tII DESCRI\u00c7\u00c3O DA T\u00c9CNICA\n\tPrograma\u00e7\u00e3o por Restri\u00e7\u00f5es\n\tModelagem\n\tAplicabilidade em Fun\u00e7\u00e3o da Modelagem\n\tBoas Pr\u00e1ticas em Modelagem\n\n\tPropaga\u00e7\u00e3o de Restri\u00e7\u00f5es\n\tT\u00e9cnicas de Consist\u00eancia Bin\u00e1ria\n\tT\u00e9cnicas de Consist\u00eancia Generalizada\n\n\tBusca\n\tBusca por Recurs\u00e3o e Retrocesso\n\tBusca Local e Estoc\u00e1stica\n\n\tParadigmas\n\tFerramentas Comerciais\n\tModelagem Abstrata\n\n\n\tEscalonamento Baseado em Restri\u00e7\u00f5es\n\tModelagem e Paradigmas Descritivos\n\tCaracteriza\u00e7\u00e3o por Atividades e Recursos\n\tCaracteriza\u00e7\u00e3o por Vari\u00e1veis de Intervalo\n\n\tElementos Complementares de Resolu\u00e7\u00e3o\n\tPropaga\u00e7\u00e3o\n\tBusca\n\n\n\n\tIII ESTUDO DE CASO\n\tO Problema da Programa\u00e7\u00e3o de Recursos Cr\u00edticos e Sua Abordagem\n\tDecis\u00f5es e Entidades Relacionadas\n\tCrit\u00e9rios de Otimiza\u00e7\u00e3o\n\tRestri\u00e7\u00f5es do Problema\n\tRestri\u00e7\u00f5es Gerais dos Recursos\n\tRestri\u00e7\u00f5es Gerais de Execu\u00e7\u00e3o das Atividades\n\tRestri\u00e7\u00f5es de Estoque dos Recursos\n\tRestri\u00e7\u00f5es de Estoque das Atividades\n\n\tModelagem por Vari\u00e1veis de Intervalo\n\tAssocia\u00e7\u00e3o entre Atividades e Recursos\n\tAssocia\u00e7\u00e3o entre Atividades e Localidades\n\tRestri\u00e7\u00f5es de Estoque e Transporte de Linhas\n\tFun\u00e7\u00e3o Objetivo\n\n\tLimitante Superior ao \u00d3timo\n\tAlgoritmo Guloso sobre Relaxa\u00e7\u00e3o\n\tModelo de PLI sobre Relaxa\u00e7\u00e3o\n\n\n\tAn\u00e1lise Experimental do Escalonador\n\tDados Dispon\u00edveis e Ambiente de Testes\n\tExperimentos Realizados e Resultados\n\tDiscuss\u00e3o\n\n\n\tIV CONCLUS\u00c3O\n\tConclus\u00e3o\n\n\tV AP\u00caNDICE\n\tPrograma\u00e7\u00e3o por Restri\u00e7\u00f5es em OPL\n\tA Linguagem OPL e o Resolvedor CP\n\tRepresenta\u00e7\u00e3o do Modelo e da Entrada de Dados\n\tElementos de Uso Geral da Linguagem\n\tEscolha do Resolvedor do Modelo\n\tComent\u00e1rios em Arquivos de Modelo e de Dados\n\tVari\u00e1veis de Tipos Primitivos e Atribui\u00e7\u00f5es\n\tEstruturas de Dados B\u00e1sicas: Vetores e Dom\u00ednios\n\tAtribui\u00e7\u00f5es B\u00e1sicas a Elementos de Vetores\n\tExpress\u00f5es Num\u00e9ricas e Predicados\n\tOperadores de Agrega\u00e7\u00e3o e Fun\u00e7\u00f5es Sobre Vetores\n\tEstruturas de Dados Avan\u00e7adas: Tuplas e Conjuntos\n\n\tModelagem de Problemas Combinat\u00f3rios\n\tVari\u00e1veis de Decis\u00e3o de Tipos Primitivos\n\tExpress\u00f5es de Decis\u00e3o\n\tSobre a Impossibilidade de Usar Vari\u00e1veis float em CP\n\tFun\u00e7\u00e3o Objetivo\n\tRestri\u00e7\u00f5es B\u00e1sicas Sobre Tipos Primitivos\n\tRestri\u00e7\u00f5es Especializadas Sobre Tipos Primitivos\n\tExecu\u00e7\u00e3o do Resolvedor e Configura\u00e7\u00f5es B\u00e1sicas do CP\n\tManipula\u00e7\u00e3o da Solu\u00e7\u00e3o e Impress\u00e3o dos Resultados no P\u00f3s-Processamento\n\tUm Exemplo de Problema Combinat\u00f3rio Modelado em OPL\n\n\tModelagem de Problemas de Escalonamento\n\tProblemas de Escalonamento e a Motiva\u00e7\u00e3o ao Emprego de CP\n\tVari\u00e1veis de Intervalo e Suas Propriedades\n\tRestri\u00e7\u00f5es de Preced\u00eancia\n\tPredicados Sobre Conjuntos de Intervalos\n\tSequ\u00eancias e Transi\u00e7\u00f5es\n\tModelagem de Recursos Limitados\n\tFun\u00e7\u00f5es Cumulativas\n\tFun\u00e7\u00f5es de Estado\n\tUm Exemplo de Problema de Escalonamento Modelado em OPL\n\n\tConsidera\u00e7\u00f5es Finais e Agradecimentos\n\n\tRefer\u00eancias Bibliogr\u00e1ficas\n\t\u00cdndice Remissivo"}]}}}