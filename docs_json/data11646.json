{"add": {"doc": {"field": [{"@name": "docid", "#text": "BR-TU.15458"}, {"@name": "filename", "#text": "21890_PFC-20141-MayconStamboroski.pdf"}, {"@name": "filetype", "#text": "PDF"}, {"@name": "text", "#text": "Desenvolvimento de uma API para \nintegra\u00e7\u00e3o de softwares sob um \n\npadr\u00e3o aberto \n \n\n \n\n \n\n \n\nRelat\u00f3rio submetido \u00e0 Universidade Federal de Santa Catarina \n\ncomo requisito para a aprova\u00e7\u00e3o na disciplina \n\nDAS 5511: Projeto de Fim de Curso \n\nMaycon Stamboroski \n\nFlorian\u00f3polis, julho de 2014\n\n\n\n2 \n\n \n\n \n\n \n\nDesenvolvimento de uma API para integra\u00e7\u00e3o de \nsoftwares sob um padr\u00e3o aberto \n\n \nMaycon Stamboroski \n\nEsta monografia foi julgada no contexto da disciplina  \nDAS5511: Projeto de Fim de Curso  \n\ne aprovada na sua forma final pelo \nCurso de Engenharia de Controle e Automa\u00e7\u00e3o \n\n \n \n \n\n \n\n \n\n \n\nProf. Ricardo J. Rabelo \n\n_______________________ \nAssinatura do Orientador \n\n  \n\n\n\n3 \n\n \n\nAgradecimentos  \n\n \n\n \n\n\n\n4 \n\n \n\nResumo \n\nEstamos caminhando em dire\u00e7\u00e3o aos ambientes altamente integrados. \n\nDesejamos que nossos e-mails estejam nos nossos computadores, \n\nsmartphones e at\u00e9 televis\u00f5es, ao mesmo tempo, instantaneamente e \n\nsincronizados. \n\nA ind\u00fastria tamb\u00e9m requer isso para seus trabalhos, ambientes \n\nintegrados geram menos custos, mais rapidez, flexibilidade na resolu\u00e7\u00e3o de \n\nproblemas e um apoio maior na tomada de decis\u00f5es. \n\nA empresa onde o PFC foi realizado atua num nicho de mercado, o de \n\nconstru\u00e7\u00e3o predial civil, que n\u00e3o apenas demanda, tamb\u00e9m necessita de \n\nambientes altamente integrados. Felizmente isso j\u00e1 vem sendo teorizado e \n\ndesenvolvido desde o come\u00e7o da d\u00e9cada de 70, por\u00e9m com a evolu\u00e7\u00e3o \n\ntecnol\u00f3gica agora estamos cada vez mais pr\u00f3ximos disso. \n\nContudo, tudo come\u00e7a com o passo inicial, no caso da AltoQi, a \n\nempresa em quest\u00e3o, busca integrar seus produtos a um padr\u00e3o aberto da \n\n\u00e1rea de constru\u00e7\u00e3o civil, o IFC, j\u00e1 que este \u00e9 uma pe\u00e7a fundamental no \n\nsucesso das solu\u00e7\u00f5es integradas baseadas em BIM.  \n\nMesmo atuante na \u00e1rea de tecnologia para a engenharia h\u00e1 mais de 25 \n\nanos, datando com produtos comercializados desde o final dos anos 80, os \n\naplicativos da empresa ainda t\u00eam espa\u00e7o para evoluir. Buscando a integra\u00e7\u00e3o \n\ndos seus sistemas desenvolvidos, tanto os mais atuais, os considerados \n\n\u201clegados\u201d e os que vir\u00e3o, o primeiro passo foi dado com o conceito da cria\u00e7\u00e3o \n\ndo Projeto Qi4D. \n\nUm projeto que busca modularizar os softwares desenvolvidos e ent\u00e3o \n\nuni-los sob a base do IFC. Isto \u00e9 contemplado atrav\u00e9s de uma refatora\u00e7\u00e3o \n\nparcial dos programas, focando em como seus objetos tridimensionais s\u00e3o \n\nconcebidos. Criando junto com eles uma estrutura de metadados flex\u00edvel e \n\nintercambi\u00e1vel, garantindo a interoperabilidade entre as solu\u00e7\u00f5es. Essa \n\ninteropera\u00e7\u00e3o ser\u00e1 dada atrav\u00e9s de uma API pr\u00f3pria e p\u00fablica que foi \n\n\n\n5 \n\n \n\ndesenvolvida neste projeto, contemplando as fun\u00e7\u00f5es descritas acima e \n\npodendo ser expandida conforme as evolu\u00e7\u00f5es tecnol\u00f3gicas. \n\nPalavras-chave: Integra\u00e7\u00e3o de sistemas, IFC, BIM, API. \n\n \n\n\n\n6 \n\n \n\nAbstract \n\nWe are heading toward highly integrated systems. We want our e-mails \n\nto be available in our computers, smartphones and televisions, at the same \n\ntime, instantly and synchronized. \n\nThe industry also requires that for its work. Highly integrated \n\nenvironments generate less cost, more speed, flexibility on problems resolution \n\nand a larger support for decision making. \n\nThe company where the PFC was fulfilled operates in a niche market, \n\ncivil building construction, which not only requires, but also demands for highly \n\nintegrated environment and systems. Hopefully, that is a topic which has been \n\nunder studies since the beginning of the 70's, and with the technological \n\nevolution, we are getting close to it. \n\nNevertheless, everything starts with the first step. AltoQi, the company in \n\nthe matter, searches for the integration of its products upon an open standard in \n\ncivil construction area, the IFC, a fundamental piece on the success of BIM \n\nbased integrated solutions. \n\nDespite its presence in technological solutions for civil engineering for \n\nabout 25 years, with products applications dated from the late 80's, the \n\ncompany softwares have room for evolution. Looking for system integration of \n\nits own developed products, from the more moderns, to that called \"legacy\" and \n\nfor the new ones to come, the Qi4D Project was created. \n\nA project for modularization of the developed softwares, and from that, \n\naggregated then upon the IFC assumption. This is contemplated with a partial \n\nrefactoring of the applications, focused on how the tridimensional objects are \n\ndesigned. Adding with it, the creation of a flexible, switchable and generic \n\nmetadata structure, allowing interoperation between solutions. This \n\ninteroperation will occur through a new API, with public visibility, which was \n\ndeveloped in the Qi4D Project, contemplating the functionalities described \n\nabove and able to be expanded with technological evolution. \n\n\n\n7 \n\n \n\nSum\u00e1rio \n \n\nAgradecimentos ....................................................................................... 3 \n\nResumo ................................................................................................... 4 \n\nAbstract ................................................................................................... 6 \n\n\u00cdndice de imagens ................................................................................... 8 \n\nSimbologia ............................................................................................. 10 \n\nCap\u00edtulo 1: Introdu\u00e7\u00e3o. ........................................................................ 11 \n\nCap\u00edtulo 2: A empresa. ........................................................................ 14 \n\nCap\u00edtulo 3: O projeto Qi4D. ................................................................. 17 \n\n3.1: Building Information Modeling (BIM) e Industry Foundation \n\nClasses (IFC) ................................................................................................ 17 \n\n3.2: Introdu\u00e7\u00e3o ao projeto .................................................................. 19 \n\n3.3: O conceito de API sob a \u00f3tica do Qi4D ....................................... 20 \n\n3.4: Requisitos do projeto .................................................................. 21 \n\n3.4.1: Requisitos funcionais ............................................................ 22 \n\n3.4.2: Requisitos n\u00e3o funcionais ..................................................... 24 \n\nCap\u00edtulo 4: O Novo Visualizador 3D .................................................... 28 \n\nCap\u00edtulo 5: Incorporando a API ao sistema existente .......................... 38 \n\nCap\u00edtulo 6: Resultados Obtidos ........................................................... 48 \n\nCap\u00edtulo 7: Conclus\u00f5es e Perspectivas ............................................... 54 \n\nBibliografia: ............................................................................................ 57 \n\n \n\n  \n\n\n\n8 \n\n \n\n\u00cdndice de imagens \n\nFigura 1 - Primeiros produtos da empresa ............................................ 14 \n\nFigura 2 - Primeira vers\u00e3o do Eberick ................................................... 15 \n\nFigura 3 - Exemplo de arquivo IFC para um pilar .................................. 19 \n\nFigura 4 - Diagrama da Framework  Qi4D ............................................. 22 \n\nFigura 5 - Arquitetura do novo visualizador ........................................... 29 \n\nFigura 6 - Arquitetura do novo visualizador com os produtos da empresa\n\n ......................................................................................................................... 31 \n\nFigura 7 - Hierarquia do desacoplamento dos m\u00f3dulos em camadas ... 33 \n\nFigura 8 - Exemplos de propriedades no QiBuilder (esquerda) e Eberick \n\n(direita) ............................................................................................................. 34 \n\nFigura 9 - Grafo ac\u00edclico dos metadados ............................................... 35 \n\nFigura 10 - Ilustra\u00e7\u00e3o das branches criadas para a tarefa ..................... 37 \n\nFigura 11 - Antiga hierarquia de objetos 3D no Eberick ........................ 38 \n\nFigura 12 - Hierarquia dos objetosOpenGL no Qi4D ............................. 39 \n\nFigura 13 - Hierarquia dos conversores OpenGL no Qi4D .................... 39 \n\nFigura 14 -  Hierarquia de classes no projeto Qi4D ............................... 40 \n\nFigura 15 - Chamadas do m\u00e9todo que busca por um conversor \n\nespec\u00edfico no hashmap .................................................................................... 40 \n\nFigura 16 - Registro do conversor no hashmap ao ser criado pelo \n\ndispatcher e chamadas deste m\u00e9todo .............................................................. 41 \n\nFigura 17 - Grafo de sequencia para a cria\u00e7\u00e3o de um novo elemento a \n\ncada frame ....................................................................................................... 42 \n\nFigura 18 - Grafo dos m\u00e9todos que requisitam pela cria\u00e7\u00e3o de um novo \n\nelemento convertido e as classes que o implementam .................................... 43 \n\nFigura 19 - Elementos que aceitam a visita ........................................... 44 \n\nFigura 20 - Diagrama de classes dos visitor .......................................... 45 \n\nFigura 21 - Diagrama de classes das factories ...................................... 45 \n\nFigura 22 - Classes singletons para cria\u00e7\u00e3o dos metadados ................ 47 \n\nFigura 23 - Factory de metadados ......................................................... 47 \n\nFigura 24 - Complexidade ciclom\u00e1tica antes das mudan\u00e7as ................. 49 \n\n\n\n9 \n\n \n\nFigura 25 - Complexidade ciclom\u00e1tica ap\u00f3s as altera\u00e7\u00f5es .................... 49 \n\nFigura 26 - Ilustra\u00e7\u00e3o dos m\u00f3dulos desacoplados ................................ 50 \n\nFigura 27 - Erro de duplica\u00e7\u00e3o de c\u00f3digo na gera\u00e7\u00e3o continua de \n\nvers\u00f5es ............................................................................................................. 51 \n\nFigura 28 - Nenhum erro encontrado na gera\u00e7\u00e3o continua de vers\u00f5es . 51 \n\nFigura 29 - Grafo de Kiviat para classe respons\u00e1vel pela cria\u00e7\u00e3o dos \n\nnovos elementos 3D ......................................................................................... 52 \n\nFigura 30 - Ferramenta de gerenciamento de projetos ......................... 53 \n\n \n\n  \n\n\n\n10 \n\n \n\nSimbologia \n\nA seguir: \n\nPAC - Projeto de Acelera\u00e7\u00e3o ao Crescimento \n\nPMCV - Projeto Minha Casa Minha Vida \n\nPIB - Produto Interno Bruto \n\nCBIC - C\u00e2mara Brasileira de Ind\u00fastria e Com\u00e9rcio \n\nABNT - Associa\u00e7\u00e3o Brasileira de Normas T\u00e9cnicas \n\nBIM - Building Information Modeling \n\nIFC - Industry Foundation Classes \n\nSTEP - Standard for the Exchange of Product Data \n\nAPI - Application Program Interface \n\nDSM - Design Structure Matrix  \n\nMVP - Model View Presenter \n\nISO - Organiza\u00e7\u00e3o Internacional para Padroniza\u00e7\u00e3o \n\nIEC - International Electrotechnical Commission \n\nSVN \u2013 Apache Subversion Client \n\nTDD - Test Driven Development  \n\nBDD - Behavior Driven Development \n\nVTK - The Visualization Toolkit \n\nOpenGL - Open Graphics Library \n\n \n\n \n\n\n\n11 \n\n \n\nCap\u00edtulo 1: Introdu\u00e7\u00e3o. \n\nO setor de constru\u00e7\u00e3o civil est\u00e1 em franca expans\u00e3o no Brasil. Os \n\nprogramas governamentais como o Projeto de Acelera\u00e7\u00e3o ao Crescimento \n\n(PAC) e o Projeto Minha Casa Minha Vida (PMCV) impulsionaram o setor nos \n\n\u00faltimos anos, aliado a isso, h\u00e1 o investimento em infraestrutura devido aos \n\neventos grandes mundiais sediados pelo pa\u00eds, como a Copa do Mundo em \n\n2014 e as Olimp\u00edadas em 2016. \n\nEm mat\u00e9ria publicada em dezembro de 2013 [ 1 ], a revista Exame apontou \n\num crescimento previsto para o setor de 2,8% em 2014, seguindo o \n\ncrescimento do PIB brasileiro. Por\u00e9m estudos publicados pela C\u00e2mara \n\nBrasileira de Ind\u00fastria e Com\u00e9rcio (CBIC) entre 2009 e 2013 [ 2 ] mostram que \n\npara o setor continuar crescendo e a economia continuar competitiva, \u00e9 \n\nnecess\u00e1rio aumentar a produtividade. \n\nEsses estudos tamb\u00e9m avaliaram onde encontram-se os gargalos dos \n\nprojetos, enfatizando problemas com prazos, custos, integra\u00e7\u00e3o com \u00f3rg\u00e3os e \n\nlegisla\u00e7\u00f5es, entre outros. A empresa AltoQi atua no ramo oferecendo softwares \n\npara projetos de edifica\u00e7\u00f5es, integrando al\u00e9m do projeto estrutural, o projeto \n\nhidrossanit\u00e1rio, el\u00e9trico, g\u00e1s, projeto de instala\u00e7\u00f5es hidr\u00e1ulicas de combate \u00e0 \n\ninc\u00eandio, entre outas solu\u00e7\u00f5es, todas baseadas nas normas brasileiras \n\ngerenciadas pela ABNT. O uso destes softwares al\u00e9m de aumentar a \n\nprodutividade, diminuindo o tempo de projeto, tamb\u00e9m oferece uma base de \n\nseguran\u00e7a pela sua integra\u00e7\u00e3o com a norma e possibilidade de otimiza\u00e7\u00e3o no \n\nuso de materiais. \n\nO conceito de BIM (Building Information Modeling) j\u00e1 \u00e9 utilizado desde \n\n1987 na cria\u00e7\u00e3o de \u201cEdifica\u00e7\u00f5es Virtuais\u201d [ 3 ], e sobre estes princ\u00edpios os \n\nsoftwares da empresa s\u00e3o desenvolvidos. O Comit\u00ea Norte Americano para \n\nPadr\u00f5es de Projetos e Modelos Informacionais em Constru\u00e7\u00f5es define o BIM \n\ncomo: \u201cUma representa\u00e7\u00e3o digital das funcionalidades e caracter\u00edsticas f\u00edsicas \n\nde uma constru\u00e7\u00e3o. O BIM \u00e9 um recurso de conhecimento compartilhado que \n\nbusca fornecer uma base confi\u00e1vel de informa\u00e7\u00f5es de uma constru\u00e7\u00e3o, \n\n\n\n12 \n\n \n\nauxiliando a tomada de decis\u00f5es durante o seu ciclo de vida.\u201d Por\u00e9m h\u00e1 uma \n\ncar\u00eancia na integra\u00e7\u00e3o das funcionalidades fornecidas pelos softwares da \n\nempresa. Para solucionar este problema, apoia-se na solu\u00e7\u00e3o de formatos de \n\narquivo IFC (Industry Foundation Classes). \n\nO IFC foi desenvolvido pela buildingSMART usando os conceitos e \n\nespecifica\u00e7\u00f5es da STEP (Standard for the Exchange of Product Data), a fim de \n\ncriar um modelo de dados consistente para representa\u00e7\u00e3o de uma edifica\u00e7\u00e3o, \n\nsendo um \u201cPadr\u00e3o Aberto\u201d para troca de informa\u00e7\u00f5es de diferentes tipos de \n\nsoftware [ 4 ]. \n\nPara uma compreens\u00e3o melhor da import\u00e2ncia dos modelos IFCs, prop\u00f5e-\n\nse um caso de estudo chamado \u201cA Torre de Babel\u201d, um edif\u00edcio  residencial \n\nmulti-familiar. Para este projeto sup\u00f5e-se que o projeto arquitetural ser\u00e1 \n\ndesenhado no Revit (da empresa AutoCAD), o projeto estrutural modelado no \n\nEberick (da empresa AltoQi) e os projetos hidr\u00e1ulico e el\u00e9trico no software \n\nQiBuilder (ambos tamb\u00e9m da AltoQi). \n\nO dono do edif\u00edcio cria o projeto e disponibiliza-o para os profissionais \n\nreferentes a cada \u00e1rea da constru\u00e7\u00e3o. Sup\u00f5e-se que o projeto base ser\u00e1 o \n\narquitetural, o projetista exporta o modelo criado no formato IFC e o associa \u00e0 \n\nconstru\u00e7\u00e3o espec\u00edfica. Os outros profissionais agora podem acessar o arquivo \n\nIFC e trabalhando paralelamente, criar seus modelos espec\u00edficos para o \n\nprojeto, vinculando-os \u00e0 mesma constru\u00e7\u00e3o. \n\nAp\u00f3s todos os projetos conclu\u00eddos, o dono da constru\u00e7\u00e3o importa o modelo \n\nIFC agregado de todos os projetos, podendo visualizar o modelo tridimensional \n\ntotal da solu\u00e7\u00e3o. Para os produtos da AltoQi participarem deste novo cen\u00e1rio \n\ndo mercado de arquitetura e constru\u00e7\u00e3o civil, o pr\u00e9-requisito \u00e9 o sucesso do \n\nprojeto Qi4D, para que com a integra\u00e7\u00e3o obtida, seja poss\u00edvel levar os sistemas \n\nda empresa a um novo patamar de colabora\u00e7\u00e3o. \n\nO engenheiro de controle e automa\u00e7\u00e3o \u00e9 uma pe\u00e7a fundamental no projeto \n\nde sistemas interoper\u00e1veis, como \u00e9 o caso. A integra\u00e7\u00e3o de sistemas est\u00e1 \n\nintrinsicamente ligada ao desenvolvimento de software, n\u00e3o s\u00f3 pelo fato de \n\nmuitas vezes ser necess\u00e1rio \u201ccolocar a m\u00e3o na massa\u201d e desenvolver linhas de \n\n\n\n13 \n\n \n\nc\u00f3digo, mas tamb\u00e9m pelo fato que a vis\u00e3o de arquitetura do sistema e \n\nconceitos de arquitetura de software s\u00e3o necess\u00e1rios. Somam-se a isso os \n\nrequisitos de qualidade de mercado, onde os sistemas precisam operar \n\nrapidamente e sem erros.  \n\n \n\n\n\n14 \n\n \n\nCap\u00edtulo 2: A empresa. \n\nConhecer um pouco a hist\u00f3ria da empresa e seus produtos criados \u00e9 \n\nfundamental para entender a import\u00e2ncia do projeto desenvolvido. A AltoQi \u00e9 \n\nl\u00edder em software para projetos de edifica\u00e7\u00f5es no Brasil. Existente desde 1989, \n\niniciou suas atividades com o lan\u00e7amento e comercializa\u00e7\u00e3o do software \n\nPROVIGA, e entre os anos 1991 a 1993 completou seu leque de solu\u00e7\u00f5es com \n\nos softwares PROPILAR, PROLAJE e PROINFRA. Esses sistemas eram \n\nbaseados em DOS e buscavam suprir a demanda por automatiza\u00e7\u00e3o do \n\nconhecimento j\u00e1 existente na \u00e9poca. \n\nNos anos seguintes, uma empresa estrangeira entrou no mercado \n\nbrasileiro, oferecendo estas solu\u00e7\u00f5es em um software \u00fanico e com interface \n\ngr\u00e1fica. Consequentemente a AltoQi se viu obrigada a reestruturar-se, para n\u00e3o \n\nperder mercado. Entre os anos de 1993 a 1996 a empresa concentrou seus \n\nesfor\u00e7os no desenvolvimento de um sistema, integrando os m\u00f3dulos j\u00e1 \n\nexistentes em um \u00fanico produto de projetos estruturais e sob uma camada de \n\ninterface gr\u00e1fica em CAD. Isso culminou para que, em 1996, fosse lan\u00e7ado o \n\nsoftware AltoQi Eberick, o carro chefe da empresa at\u00e9 hoje e respons\u00e1vel pela \n\nsua retomada de mercado. O Eberick continua em desenvolvimento, recebendo \n\natualiza\u00e7\u00f5es e novas funcionalidades regularmente. \n\nFigura 1 - Primeiros produtos da empresa \n\n\n\n15 \n\n \n\nEntre o final da d\u00e9cada de noventa e come\u00e7o dos anos dois mil, a \n\nempresa completou o seu hall de solu\u00e7\u00f5es com mais dois novos produtos, o \n\nAltoQi Hydros, que engloba projetos hidr\u00e1ulicos, sanit\u00e1rios, de inc\u00eandio e g\u00e1s, \n\ne o AltoQi Lumine, contemplando projetos el\u00e9tricos, telef\u00f4nicos e de \n\ncabeamento estruturado. Esses softwares s\u00e3o maduros e est\u00e3o em um est\u00e1gio \n\nonde todos os recursos solicitados pelos usu\u00e1rios j\u00e1 est\u00e3o desenvolvidos, \n\nposicionando-se assim acima dos seus concorrentes. \n\nPor volta de 2005, algumas m\u00e1s escolhas no desenvolvimento do \n\nEberick come\u00e7aram a cobrar seu pre\u00e7o, como descrito abaixo:  \n\n\"No final de 93, quando iniciamos o desenvolvimento do Eberick, a \n\nferramenta escolhida foi o Borland C++. Esta oferecia uma framework para \n\ndesenvolvimento em Windows chamada OWL, que era fundamentalmente uma \n\nhierarquia de classes que faziam uma \u201ccasca\u201d sobre a API do Windows \n\nBaseamos ent\u00e3o todo o software sobre essa framework, utilizando \n\nintensivamente as classes, tipos e estruturas de dados que eram oferecidas. \n\nN\u00e3o prestamos aten\u00e7\u00e3o ao fato de que aquilo era uma framework para \n\ninterface, e que poderia mudar a qualquer momento. No in\u00edcio de 95 j\u00e1 \n\nsentimos os primeiros preju\u00edzos: a nova vers\u00e3o do Borland C++, 4.0 na \u00e9poca, \n\ntrazia a framework totalmente modificada, baseada em templates. Tivemos \n\nent\u00e3o um enorme trabalho reescrevendo o programa para a nova abordagem. \n\nMas continuamos utilizando a framework como se esta fosse realmente parte \n\nda linguagem. Em 97 o Borland C++ chegou \u00e0 sua vers\u00e3o 5.02 e algum tempo \n\ndepois se concluiu que esta seria a \u00faltima. Ao mesmo tempo em que Eberick \n\nFigura 2 - Primeira vers\u00e3o do Eberick \n\n\n\n16 \n\n \n\ncome\u00e7ava a amadurecer como produto, sua ferramenta de desenvolvimento \n\nchegava \u00e0 aposentadoria. E hoje (2005!), o Eberick continua sendo escrito \n\nsobre a mesma ferramenta. O grande problema disso \u00e9 que ser\u00e1 imposs\u00edvel \n\nacompanhar as novas tecnologias (.net, Windows 64 bits, etc.) com uma \n\nferramenta descontinuada h\u00e1 oito anos.\" (trecho de \"Para onde estamos indo\", \n\npor Adriano Coser [ 5 ]). \n\nCom esse problema necessitando de resolu\u00e7\u00e3o, a empresa resolveu por \n\nadotar uma abordagem do tipo \u201cThe great refactoring in the sky\u201d. Assim iniciou-\n\nse o projeto do QiCAD, que consiste numa framework pr\u00f3pria para ambientes \n\nCAD, assim fornecendo uma base para a futura reestrutura\u00e7\u00e3o e integra\u00e7\u00e3o \n\ndos produtos existentes e dos novos a serem criados. A evolu\u00e7\u00e3o desse projeto \n\n\u00e9 o QiBuilder, um programa novo, desenvolvido sobre o conceito nativo de \n\nintegra\u00e7\u00e3o, onde os recursos criados s\u00e3o naturalmente parte de um mesmo \n\nambiente computacional. O QiBuilder \u00e9 desenvolvido com a ferramenta \n\nC++Builder da Borland e pode-se agregar novas funcionalidades ao programa, \n\ncomo a interface Ribbon da Qt. \n\nPor\u00e9m fazem cerca de dez anos que come\u00e7ou essa corrida para que o \n\nQiBuilder alcance os softwares j\u00e1 existentes, al\u00e9m disso, essa arquitetura \n\nadotada tamb\u00e9m come\u00e7ou a mostrar suas defici\u00eancias nesse tempo. Al\u00e9m \n\ndisso, o time original do desenvolvimento do projeto n\u00e3o se encontra mais na \n\nempresa, e provavelmente muitas das inten\u00e7\u00f5es originais de c\u00f3digo j\u00e1 se \n\ndesviaram. Isso fez com que se come\u00e7asse a adotar uma pol\u00edtica de \n\nrefatora\u00e7\u00e3o cont\u00ednua nos softwares, obtendo um controle na qualidade do \n\nc\u00f3digo criado. \n\nRecentemente, o mercado come\u00e7ou a exigir que os softwares CADs \n\nfossem compat\u00edveis com o modelo BIM. Alinhando-se com a vis\u00e3o da empresa \n\ne a ideia de melhorar a integra\u00e7\u00e3o dos softwares, decidiu-se por iniciar o \n\nprojeto Qi4D. Esse projeto busca aumentar a interoperabilidade entre os \n\nsoftwares existentes dentro da empresa e garantir que ser\u00e3o compat\u00edveis com \n\no padr\u00e3o IFC. \n\n\n\n17 \n\n \n\nCap\u00edtulo 3: O projeto Qi4D. \n\n3.1: Building Information Modeling (BIM) e Industry Foundation \n\nClasses (IFC) \n\nO conceito de edifica\u00e7\u00f5es virtuais redireciona o modelo 3D como chave \n\nde integra\u00e7\u00e3o CAD/CAM/CAE e planejamento. De acordo com Charles \n\nEastmam [ 6 ], o BIM \u00e9 um modelo estrutural de informa\u00e7\u00e3o digital, \n\ntridimensional onde constam os v\u00e1rios objetos que comp\u00f5em um edif\u00edcio, \n\ncapturando a sua forma, comportamento e rela\u00e7\u00e3o nas v\u00e1rias partes do \n\nedif\u00edcio, sendo poss\u00edvel indexar todo um conjunto de dados a um determinado \n\nelemento. Deste modo, envolvem-se tecnologias e processos para o \n\ndesenvolvimento de uma pr\u00e1tica de projeto integrada, no qual os participantes \n\nunam seus esfor\u00e7os na constru\u00e7\u00e3o de um modelo \u00fanico de edif\u00edcio[ 7 ]. \n\nCom o advento de modelos 3D na ind\u00fastria da arquitetura e constru\u00e7\u00e3o \n\ncivil e posterior incremento de funcionalidades nestes softwares, definiu-se o \n\nconceito do BIM 4D. Este modelo possibilita a visualiza\u00e7\u00e3o do projeto da \n\nconstru\u00e7\u00e3o, planejamento do CPM, gerenciamento da cadeia de suprimentos, \n\ngerencia de custos e riscos, mantendo a interoperabilidade com o CAD 3D, \n\npara prover uma simula\u00e7\u00e3o do edif\u00edcio virtual. O papel do BIM 4D \u00e9 adicionar \n\numa nova dimens\u00e3o aos modelos CAD 3D, juntando informa\u00e7\u00f5es aos \n\nelementos tridimensionais do modelo [ 8 ]. \n\nPara o sucesso do BIM e a obten\u00e7\u00e3o de um modelo \u00fanico com toda a \n\ninforma\u00e7\u00e3o do projeto, \u00e9 imprescind\u00edvel a integra\u00e7\u00e3o de softwares para a \n\ncolabora\u00e7\u00e3o, coordena\u00e7\u00e3o e gerenciamento de informa\u00e7\u00f5es, isto \u00e9 alcan\u00e7\u00e1vel \n\natrav\u00e9s de um modelo padronizado distribu\u00eddo, neste caso, o IFC. \n\nO IFC \u00e9 fruto dos esfor\u00e7os da BuildingSMART Alliance na cria\u00e7\u00e3o de \n\numa padr\u00e3o que permita a interoperabilidade entre programas da \u00e1rea de BIM, \n\nfacilitando a transfer\u00eancia de dados representativos de partes de edifica\u00e7\u00f5es e \n\n\n\n18 \n\n \n\nsuas rela\u00e7\u00f5es. O formato teve sua primeira especifica\u00e7\u00e3o em 1997 e encontra-\n\nse na vers\u00e3o IFC4, sendo est\u00e1 aceita tamb\u00e9m como norma ISO. \n\nO modelo de dados IFC \u00e9 um modelo de dados baseado em defini\u00e7\u00e3o \n\nde classes representando objetos. Ele \u00e9 baseado em tr\u00eas entidades principais  \n\n[ 17 ]: o IfcRoot,  ProxyObjects e as PropertySets. O IfcRoot funciona de forma \n\nan\u00e1loga \u00e0 uma interface abstrata em rela\u00e7\u00e3o \u00e0 linguagens computacionais \n\norientadas a objetos. Assim, as entidades individuais dentro do IFC s\u00e3o \n\nbaseadas no IfcRoot, sendo elas objetos, propriedades e rela\u00e7\u00f5es entre estes. \n\nOs objetos para o IFC s\u00e3o as geometrias dos elementos, a ideia do modelo 3D \n\ns\u00f3lido. As propriedades representam os conceitos como: materiais, resist\u00eancia \n\nao cisalhamento, revestimento, entre ouras caracter\u00edsticas contextuais. As \n\nrela\u00e7\u00f5es s\u00e3o o que fazem o acoplamento entre objetos diferentes ou \n\npropriedades e objetos, definidas como classifica\u00e7\u00f5es abstratas. \n\nAs outras duas entidades, ProxyObjects e PropertySets s\u00e3o \n\nrespons\u00e1veis por estender o uso do padr\u00e3o. Elas funcionam de forma an\u00e1loga \n\naos objetos e propriedades, respectivamente, definidas no IFC, mas atrav\u00e9s \n\ndestas, s\u00e3o poss\u00edveis definir novos elementos que n\u00e3o existem no modelo. \n\nDesta forma, pode-se definir atributos e objetos que s\u00e3o importantes dentro de \n\num contexto, empresa ou localidade, sem precisar fugir do padr\u00e3o. \n\n\n\n19 \n\n \n\n \n\nFigura 3 - Exemplo de arquivo IFC para um pilar \n\n3.2: Introdu\u00e7\u00e3o ao projeto \n\nComo relatado nos t\u00f3picos anteriores, o conceito de BIM se apoia no \n\nideal de interoperabilidade, parametriza\u00e7\u00e3o e colabora\u00e7\u00e3o entre diferentes \n\nsistemas. Isso pode ser alcan\u00e7ado utilizando diversas estrat\u00e9gias, como \n\nexploradas na disciplina de Integra\u00e7\u00e3o de Sistemas Corporativos nesta \n\nuniversidade. Atualmente os softwares da empresa obt\u00e9m certo n\u00edvel de \n\ninteroperabilidade usando o conceito de troca de arquivos, por\u00e9m alguns dados \n\ne funcionalidades s\u00e3o perdidos nesse processo, al\u00e9m de ser um processo \n\nlento, com maior custo de armazenamento e propenso a retrabalho. \n\nPara ampliar essa interoperabilidade, n\u00e3o apenas entre os softwares \n\ndesenvolvidos dentro da empresa, mas tamb\u00e9m com outras solu\u00e7\u00f5es do \n\n\n\n20 \n\n \n\nmercado, optou-se por aplicar novos conceitos nos produtos. O primeiro deles \n\n\u00e9 a abordagem por intera\u00e7\u00e3o de sistemas, obtida atrav\u00e9s de uma nova API \n\ncriada, sendo ela uma interface de integra\u00e7\u00e3o. A segunda solu\u00e7\u00e3o \u00e9 adotar a \n\ntroca de informa\u00e7\u00f5es atrav\u00e9s de um padr\u00e3o aberto, que para este caso, est\u00e1 \n\nsendo baseado no formato IFC. Somando-se aos dois, ap\u00f3s o fim do projeto, \n\nespera-se poss\u00edvel adotar a abordagem Top-Down de interoperabilidade para e \n\nempresa, utilizando e expandindo os conceitos obtidos no projeto Qi4D para os \n\noutros projetos. \n\n Esta \u00f3tica de integra\u00e7\u00e3o e os requisitos do mercado para que isto \n\nocorra, abriu a possibilidade para a cria\u00e7\u00e3o de um novo projeto para fornecer \n\nessas solu\u00e7\u00f5es e oferecer uma maior interoperabilidade entre os programas \n\nexistentes da empresa. O Projeto Qi4D visa a cria\u00e7\u00e3o de um novo sistema \n\nelaborado para substituir as janelas 3D existentes no Eberick e no QiBuilder. \n\nPara isso, as novas funcionalidades e pacotes ser\u00e3o encapsulados por APIs \n\nabstratas, e os softwares existentes ser\u00e3o refatorados para sua utiliza\u00e7\u00e3o. \n\n \n\n3.3: O conceito de API sob a \u00f3tica do Qi4D \n\nAPI \u00e9 a sigla para Application Programming Interface, ou interface \n\nprogram\u00e1vel da aplica\u00e7\u00e3o. Uma API \u00e9 um conjunto de regras e especifica\u00e7\u00f5es \n\nparticular que um programa deve seguir para acessar e fazer uso de servi\u00e7os e \n\nrecursos provenientes de outro software em particular que implementa esta \n\nAPI. Ela serve como uma interface, uma ponte de liga\u00e7\u00e3o, entre diferentes \n\nprogramas, facilitando a intera\u00e7\u00e3o entre eles, de maneira similar como uma \n\ninterface humano-m\u00e1quina facilita a comunica\u00e7\u00e3o entre humanos e \n\ncomputadores[ 9 ]. \n\nUma API foi desenvolvida para fornecer uma estrat\u00e9gia de integra\u00e7\u00e3o \n\nglobal para o projeto Qi4D. Ela foi desenvolvida para criar uma estrutura \n\ngen\u00e9rica de informa\u00e7\u00f5es e dados, que pode ser reutiliz\u00e1vel em v\u00e1rias \n\nsitua\u00e7\u00f5es. A API, a principio, foi concebida para generalizar o modelo 3D e \n\nsuas carater\u00edsticas (metadados), poder ler e gerar arquivos no padr\u00e3o IFC e \n\ngarantir a persist\u00eancia desses dados. \n\n\n\n21 \n\n \n\nAssim, esfor\u00e7ou-se para modificar os produtos da empresa para \n\ntornarem-se condizentes com as regras e especifica\u00e7\u00f5es da API.  Desta forma, \n\nse novas aplica\u00e7\u00f5es seguirem as mesmas regras, elas funcionar\u00e3o \n\nprontamente entre os diversos softwares da empresa. \n\nComo exemplo podemos citar os motores gr\u00e1ficos utilizados, VTK para o \n\nQiBuilder e OpenGL para o Eberick. Ao adequar-se os respectivos softwares \n\npara a API, pode-se intercambiar estas ferramentas de desenho 3D e elas \n\nfuncionaram sem grandes problemas nos dois softwares. O mesmo ser\u00e1 \n\nposs\u00edvel caso deseje-se mudar como a persist\u00eancia de dados \u00e9 feita, para um \n\nbanco de dados NoSQL, hipoteticamente. Al\u00e9m disso, novas aplica\u00e7\u00f5es \n\ndesenvolvidas sob a API funcionaram para ambos os programas e pode-se \n\nterceirizar o desenvolvimento sem abrir o c\u00f3digo fonte do programa, apenas \n\napresentando este conjunto de regras e documenta\u00e7\u00e3o adicional explicando-\n\nas. \n\n \n\n3.4: Requisitos do projeto  \n\nO framework Qi4D ser\u00e1 compartilhado pelas aplica\u00e7\u00f5es existentes e as \n\nnovas que vir\u00e3o a serem criadas. Suas principais funcionalidades s\u00e3o a \n\nrepresenta\u00e7\u00e3o do modelo tridimensional (modelo geom\u00e9trico) e a transfer\u00eancia \n\ndos seguintes tipos de informa\u00e7\u00e3o entre as aplica\u00e7\u00f5es: dados dos elementos, \n\ndados da constru\u00e7\u00e3o, informa\u00e7\u00f5es de concreto, dados colaborativos e colis\u00f5es \n\nentre modelos.  \n\nTodas as informa\u00e7\u00f5es dos modelos 3D ser\u00e3o compartilhadas por todos \n\nos softwares e a transfer\u00eancia de dados podendo ser feita, primeiramente, \n\natrav\u00e9s da troca de arquivos. A ades\u00e3o dos programas \u00e0 nova framework \n\npossibilita a extens\u00e3o dessa troca de informa\u00e7\u00f5es para novos ambientes, como \n\nweb e mobile. \n\n\n\n22 \n\n \n\nO integrador Qi4D \u00e9 a aplica\u00e7\u00e3o respons\u00e1vel por unir os diferentes \n\nprojetos em um \u00fanico modelo 3D. Al\u00e9m disso, a framework pode ser utilizada \n\npara o desenvolvimento de v\u00e1rias outras aplica\u00e7\u00f5es, por exemplo, h\u00e1 a \n\npossiblidade de se adicionar informa\u00e7\u00f5es temporais ao projeto, permitindo a \n\noutra aplica\u00e7\u00e3o ser respons\u00e1vel pelo planejamento e gerenciamento da \n\nconstru\u00e7\u00e3o. \n\n \n\nPara melhor entendimento dos requisitos do projeto, eles podem ser \n\ndivididos em dois subconjuntos: requisitos funcionais, que representam o \n\ncomportamento e caracter\u00edsticas desejadas pelo sistema e requisitos n\u00e3o \n\nfuncionais, que definem a forma que o software ser\u00e1 produzido, padr\u00f5es de \n\nqualidade, recursos que devem ser utilizados, entre outros. \n\n3.4.1: Requisitos funcionais \n\nPara o sucesso e viabilidade do projeto, \u00e9 necess\u00e1rio que as seguintes \n\nfuncionalidades estejam presentes nos programas englobados pela refatora\u00e7\u00e3o \n\ne interfaceados pela framework Qi4D: \n\nFigura 4 - Diagrama da Framework  Qi4D \n\n\n\n23 \n\n \n\n? Gravar e ler modelos do servidor: Como exemplificado na \n\nintrodu\u00e7\u00e3o, dever\u00e1 ser poss\u00edvel o acesso do usu\u00e1rio \u00e0 plataforma \n\nweb, para que seja poss\u00edvel obter e enviar o modelo geom\u00e9trico e \n\ndemais dados de elementos da constru\u00e7\u00e3o, concreto e outros \n\ndados colaborativos, com as limita\u00e7\u00f5es de acesso definidas pelo \n\nadministrador do projeto; \n\n? Visualizar modelos 3D: Ao receber os modelos geom\u00e9tricos \n\ngerados pelo Eberick e QiBuilder, em seus formatos internos, a \n\nferramenta deve gerar primitivas tridimensionais e renderiz\u00e1-las \n\npara fornecer uma visualiza\u00e7\u00e3o, al\u00e9m de ferramentas b\u00e1sicas \n\npara isto; \n\n? Exportar IFC: A ferramenta deve gerar um arquivo no formato IFC \n\nque inclua o modelo geom\u00e9trico, os dados dos elementos dos \n\nprojetos e instala\u00e7\u00f5es. Este arquivo deve ser lido por outros \n\nprogramas BIM de forma eficiente; \n\n? Importar Objetos 3D: O software QiBuilder apresenta um cadastro \n\nde pe\u00e7as, visto que este \u00e9 uma ferramenta mais abrangente, \n\ntrabalhando com modelos hidr\u00e1ulicos e el\u00e9tricos de edifica\u00e7\u00f5es. \n\nDeseja-se que no caso de alguns tipo de pe\u00e7as em formatos mais \n\nelaborados e com geometria fixa elaborados em outros softwares \n\n(como o AutoCad), seja poss\u00edvel a substitui\u00e7\u00e3o de elementos 3d \n\ngerados via c\u00f3digo por estes, consequentemente atualizando o \n\ncadastro de pe\u00e7as e substituindo o objeto anterior pelo novo na \n\nvisualiza\u00e7\u00e3o do 3D; \n\n? Editar dados dos elementos: Atrav\u00e9s da sele\u00e7\u00e3o de um ou mais \n\nobjetos (como um grupo), dentro do visualizador 3D, deve ser \n\nposs\u00edvel alterar seus dados de constru\u00e7\u00e3o e de concreto. \n\n? Visualizar colis\u00f5es: As colis\u00f5es de elementos e modelos, como, \n\npor exemplo, uma tubula\u00e7\u00e3o atravessando um pilar, devem ser \n\nidentificadas na Edifica\u00e7\u00e3o atrav\u00e9s de uma ferramenta para isto. \n\nEstes dados ent\u00e3o devem ser acessados via uma lista ou atrav\u00e9s \n\nda visualiza\u00e7\u00e3o do modelo tridimensional. \n\n\n\n24 \n\n \n\nGravar backup do projeto no servidor: Ao autor do projeto deve \n\nser poss\u00edvel criar uma c\u00f3pia deste, seja no Eberick ou Qibuilder, e \n\narmazen\u00e1-lo num servidor local ou remoto. Esta c\u00f3pia tamb\u00e9m poder\u00e1 \n\nser restaurada pelo usu\u00e1rio, devidamente identificada e sem erros. \n\n3.4.2: Requisitos n\u00e3o funcionais \n\nPor ser um projeto novo, com uma arquitetura pr\u00f3pria e por ser uma API \n\nque eventualmente pode ser disponibilizada publicamente, as funcionalidades \n\ndesenvolvidas seguem um rigoroso protocolo para garantir sua qualidade.  \n\nOs requisitos b\u00e1sicos s\u00e3o: o c\u00f3digo tem que ser desenvolvido sob o \n\nparadigma de orienta\u00e7\u00e3o a objetos, ser utilizada a linguagem C++ seguindo o \n\npadr\u00e3o C++03 definido pela ISO/IEC 14882:2003 e as aplica\u00e7\u00f5es bin\u00e1rias \n\ngeradas devem ser nativamente compat\u00edveis com 64-bits. \n\nComo os outros projetos da empresa, este tamb\u00e9m segue as \n\nconven\u00e7\u00f5es de formata\u00e7\u00e3o da empresa, descrito em documentos internos. H\u00e1 \n\nalguns anos a empresa tamb\u00e9m vem adotando a ideologia do Clean Code [ 10 \n\n] descrita no livro \u201cClean Code: A Handbook of Agile Software Craftsmanship\u201d, \n\nde Robert C. Martin. As principais premissas s\u00e3o: simplicidade, aus\u00eancia de \n\nduplica\u00e7\u00e3o, facilidade de leitura e eleg\u00e2ncia. Estas caracter\u00edsticas podem ser \n\nobtidas seguindo alguns par\u00e2metros, descritos a seguir: \n\n? Limita\u00e7\u00e3o no n\u00famero de par\u00e2metros de uma fun\u00e7\u00e3o, tentando \n\nmant\u00ea-los menores ou iguais a tr\u00eas; \n\n? Manter os m\u00e9todos com menos de 20 linhas; \n\n? Evitar o uso de coment\u00e1rios, apenas em situa\u00e7\u00f5es muito \n\nespec\u00edficas; \n\n? O uso de coment\u00e1rios deve ser substitu\u00eddo por nomes de \n\nm\u00e9todos e atributos que descrevem completamente sua \n\nfuncionalidade e objetivo; \n\n? Minimizar ao m\u00e1ximo a duplica\u00e7\u00e3o de c\u00f3digo. \n\nA arquitetura do projeto segue os par\u00e2metros dos produtos definidos \n\npela AltoQi,  de forma geral, o sistema deve ser representado na forma de uma \n\n\n\n25 \n\n \n\nDSM (Design Structure Matrix) na forma triangular inferior [ 11 ], onde os \n\npacotes s\u00e3o distribu\u00eddos em camadas (layers) e cada pacote s\u00f3 pode acessar \n\naqueles que est\u00e3o abaixo da sua camada. Al\u00e9m disso, cada pacote deve ser \n\nisolado de outro atrav\u00e9s de APIs abstratas. \n\nTamb\u00e9m segue-se o padr\u00e3o MVP (Model \u2013 View \u2013 Presenter), para o \n\ndesenho da interface de usu\u00e1rio. Este modelo facilita a utiliza\u00e7\u00e3o de testes \n\nunit\u00e1rios automatizados, descritos logo adiante, e melhora a apresenta\u00e7\u00e3o da \n\nl\u00f3gica do modelo. Seguindo esse padr\u00e3o, cada visualiza\u00e7\u00e3o \u00e9 divida em tr\u00eas \n\nconceitos: modelo de dados (definidos pela camada model), a opera\u00e7\u00e3o/ l\u00f3gica \n\nde controle (gerenciados pela camada view) e a interface direta com o usu\u00e1rio \n\n(presenter) [ 12 ]. \n\nPara evitar problemas referentes a bibliotecas externas (como o \n\nexemplo do ocorrido com o Eberick e o compilador Borland), as APIs e suas \n\nimplementa\u00e7\u00f5es devem utilizar apenas tipos simples (int, bool, double, etc) ou \n\nprimitivas mais complexas definidas na QiPrimitives, uma biblioteca pr\u00f3pria da \n\nempresa que encapsula as funcionalidades necess\u00e1rias vindas de outras \n\nbibliotecas. Esta diretriz busca garantir a portabilidade e independ\u00eancia do \n\nc\u00f3digo. \n\nOutra m\u00e9trica que come\u00e7ou a ser utiliza no projeto Qi4D \u00e9 o da \n\nComplexidade Ciclom\u00e1tica (ou complexidade condicional). Este conceito, \n\ndescrito por Thomas J. McCabe  em 1976 [ 13 ], define quantidade de decis\u00f5es \n\nl\u00f3gicas tomadas pelo c\u00f3digo fonte de uma fun\u00e7\u00e3o, isto \u00e9, o n\u00famero de \n\ncaminhos independentes que um programa, ou m\u00e9todo, pode tomar durante a \n\nsua execu\u00e7\u00e3o. V\u00e1rios estudos indicam que o valor da complexidade ciclom\u00e1tica \n\nest\u00e1 correlatado com o n\u00famero de potenciais bugs no c\u00f3digo analisado. Al\u00e9m \n\ndisso, limitar este valor favorece a legibilidade, reusabilidade, manuten\u00e7\u00e3o e \n\nmodularidade do c\u00f3digo fonte. O SEI (Software Engineering Institute) oferece \n\nno seu guia de refer\u00eancia \u201cC4 Technololy Guide\u201d [ 14 ], uma tabela com os \n\nseguintes valores para a complexidade ciclom\u00e1tica: \n\n? 1 \u2013 10: m\u00e9todo simples, sem muitos riscos; \n\n? 11 \u2013 20: m\u00e9todo com complexidade m\u00e9dia, riscos moderados; \n\n? 21 \u2013 50: m\u00e9todo complexo, risco elevado; \n\n\n\n26 \n\n \n\n? Maior que 50: m\u00e9todo inst\u00e1vel, risco elevad\u00edssimo.  \n\nPara o c\u00f3digo desenvolvido na empresa, leva-se em conta os crit\u00e9rios \n\nabaixo durante a escrita do c\u00f3digo: \n\n? Complexidade m\u00e1xima por m\u00e9todo: menor ou igual a 10; \n\n? Complexidade m\u00e9dia por m\u00e9todo: menor ou igual a 2; \n\n? Complexidade m\u00e1xima por arquivo ou classe: menor ou igual a \n\n100; \n\n? Complexidade m\u00e9dia por arquivo e classe: menor ou igual a 10; \n\n? N\u00edvel de nidifica\u00e7\u00e3o: menor ou igual a 4. \n\nQuando h\u00e1 a necessidade da cria\u00e7\u00e3o de uma nova estrutura de dados \n\nou quando forem refatorados m\u00f3dulos muito grandes de c\u00f3digo, procura-se \n\nadotar os design patterns mais propensos para cada situa\u00e7\u00e3o. Desing patterns, \n\nou padr\u00f5es de projeto, s\u00e3o descri\u00e7\u00f5es de problemas conhecidos e as \n\ness\u00eancias das solu\u00e7\u00f5es destes, para que estas possam ser configuradas de \n\nacordo com a necessidade do usu\u00e1rio. Ian Somerville [ 15 ] descreve-os como \n\n\u201cThe pattern is not a detailed specification. Rather, you can think of it as a \n\ndescription of accumulated wisdom and experience, a well-tried solution to a \n\ncommon problem.\u201d \n\nOs requisitos de qualidade descritos acima s\u00e3o do tipo de an\u00e1lise \n\nest\u00e1tica, ou seja, acontecem durante a escrita do c\u00f3digo. Em geral, a valida\u00e7\u00e3o \n\ndesses requisitos acontece na m\u00e1quina do desenvolvedor atrav\u00e9s de \n\nprogramas espec\u00edficos para cada uso (por exemplo, o Cpp Check) e atrav\u00e9s da \n\nrevis\u00e3o de c\u00f3digo, obrigat\u00f3ria ser aprovada antes do profissional poder fazer \n\nseu \u201ccommit\u201d no SVN (sistema de controle de vers\u00f5es). Por fim, ocorre tamb\u00e9m \n\na valida\u00e7\u00e3o destes requisitos e m\u00e9tricas atrav\u00e9s do servidor de builds \n\ncont\u00ednuos, o Jenkins, que \u00e9 integrado com o SVN. \n\nSomando \u00e0 qualidade dos softwares desenvolvidos pela empresa, uma \n\nparte importante da \u201ccadeia de produ\u00e7\u00e3o\u201d s\u00e3o as an\u00e1lises din\u00e2micas do \n\nprograma. Essas an\u00e1lises s\u00f3 podem ser feitas com o programa em execu\u00e7\u00e3o. \n\nSob esse escopo, a primeira an\u00e1lise realizada \u00e9 para vazamentos de \n\nmem\u00f3ria. Vazamentos de mem\u00f3ria \u00e9 um aspecto recorrente em C++, ocorrem \n\n\n\n27 \n\n \n\nquando um bloco de mem\u00f3ria \u00e9 dinamicamente alocado e nunca liberado, \n\npodendo acabar com a mem\u00f3ria dispon\u00edvel do sistema ou levar a erros durante \n\na execu\u00e7\u00e3o do programa. \n\nEm seguida parte-se para os testes. Para o projeto espec\u00edfico do Qi4D \n\nbuscou-se agregar a ideia de testes unit\u00e1rios, TDD (Test Driven Development) \n\ne sua evolu\u00e7\u00e3o, o BDD (Behavior Driven Development) [ 16 ]. Idealmente, cada \n\nfun\u00e7\u00e3o deve ter um teste espec\u00edfico para si, validando seus dados de \n\nentrada/sa\u00edda. O BDD expande esse conceito, incorporando ferramentas \n\nexternas ao desenvolvimento e fazendo que o c\u00f3digo passe por testes de \n\ncomportamento do sistema. Desse modo, garante-se que as funcionalidades \n\ncriadas estejam de acordo com o esperado pelo \u201ccliente\u201d e que, ao exercitar o \n\ncomportamento do sistema, tamb\u00e9m se est\u00e1 exercitando seus m\u00e9todos \n\nprivados e unit\u00e1rios, garantindo a integridade da solu\u00e7\u00e3o. \n\nPor fim, cada build gerada pelo servidor \u00e9 validada por um \u201ctestador\u201d, \n\nque avalia o impacto da solu\u00e7\u00e3o no programa, a exist\u00eancia de novos bugs e os \n\nrequisitos de performance, que s\u00e3o o tempo de resposta e o uso de mem\u00f3ria.  \n\nAo fim disso, a \u00faltima vers\u00e3o gerada no dia passa por uma bateria de testes \n\nautomatizados com o programa em execu\u00e7\u00e3o. \n\n \n\n \n\n   \n\n\n\n28 \n\n \n\nCap\u00edtulo 4: O Novo Visualizador 3D \n\nO desenvolvimento desta monografia se deu paralelamente ao \u201cRelease \n\n3\u201d do projeto Qi4D. Est\u00e1 \u00e9 a terceira parte das implementa\u00e7\u00f5es previstas e \u00e9 \n\nfocada na cria\u00e7\u00e3o do novo visualizador 3D, vinculado \u00e0 nova API, para o \n\nEberick e a prototipagem dos novos metadados associados a essa \n\nvisualiza\u00e7\u00e3o. \n\nO padr\u00e3o IFC define a classifica\u00e7\u00e3o de suas entidades em tr\u00eas \n\ncategorias [ 17 ]: objetos, propriedades e rela\u00e7\u00f5es. Para o projeto Qi4D, as \n\nrela\u00e7\u00f5es (que podem ser entre objeto e propriedade ou entre objetos) e as \n\npropriedades s\u00e3o modeladas como Metadados, associados a um objeto. \n\n J\u00e1 os objetos do IFC est\u00e3o intrinsicamente associados com sua \n\ngeometria no espa\u00e7o tridimensional, ou seja, ao ler ou gerar dados no padr\u00e3o \n\nIFC, esperam-se objetos modelados em 3D. O framework Qi4D tem uma \n\nmodelagem gen\u00e9rica de objetos que suporta as informa\u00e7\u00f5es do IFC, por\u00e9m o \n\nmesmo n\u00e3o ocorre para as aplica\u00e7\u00f5es existentes na empresa. Para isso, um \n\nnovo modulo de visualiza\u00e7\u00e3o tridimensional precisou ser projetado, e os \n\nsoftwares da empresa precisaram de uma grande refatora\u00e7\u00e3o para seu uso. \n\nPara o caso do Eberick, esta separa\u00e7\u00e3o e interfaceamento para um novo \n\nm\u00f3dulo \u00e9 bastante complicado, pois ele \u00e9 um sistema legado e altamente \n\nacoplado. \n\nEste novo visualizador deve ser independe da plataforma e aplica\u00e7\u00e3o \n\nutilizada, fornecendo uma interface gen\u00e9rica para os v\u00e1rios produtos da \n\nempresa. A imagem abaixo ilustra a arquitetura pretendida do visualizador. \n\n\n\n29 \n\n \n\n \n\nUma explica\u00e7\u00e3o r\u00e1pida de cada m\u00f3dulo: \n\n? Tablet Viewer: A aplica\u00e7\u00e3o visualizadora para plataformas \n\nmobile. \u00c9 constru\u00edda agregando v\u00e1rios m\u00f3dulos existentes; \n\n? Desktop Viewer: \u00c9 a aplica\u00e7\u00e3o para visualiza\u00e7\u00e3o do modelo em \n\ndesktops (computadores de mesa e notebooks), tamb\u00e9m \u00e9 \n\nconstru\u00edda agregando m\u00f3dulos e funcionalidades j\u00e1 existentes \n\nem outros pacotes; \n\n? QiBuilder: \u00c9 o programa \u201cQiBuilder\u201d j\u00e1 existente da empresa; \n\n? Eberick: \u00c9 o programa \u201cEberick\u201d j\u00e1 existente da empresa; \n\nFigura 5 - Arquitetura do novo visualizador \n\n\n\n30 \n\n \n\n? QiViewerTablet: \u00c9 o c\u00f3digo da interface gr\u00e1fica para usu\u00e1rios \n\n(GUI) mobile; \n\n? QiViewerDesktop: \u00c9 o c\u00f3digo da interface gr\u00e1fica para usu\u00e1rios \n\n(GUI) da aplica\u00e7\u00e3o em desktop; \n\n? QiViewerTools: \u00c9 o m\u00f3dulo respons\u00e1vel por gerenciar as \n\nferramentas utilizadas pelos visualizadores; \n\n? Qi3DEngine: \u00c9 o m\u00f3dulo de visualiza\u00e7\u00e3o 3D. \u00c9 respons\u00e1vel por \n\nreceber informa\u00e7\u00f5es dos modelos 3D e apresenta-los na tela \n\nnum ambiente tridimensional virtual. Deve ser poss\u00edvel utiliza-lo \n\npelas aplica\u00e7\u00f5es visualizadoras mencionadas e diretamente \n\npelos programas existentes na empresa. Sua \u00fanica depend\u00eancia \n\ndeve ser  do m\u00f3dulo QiDrawing3DModel; \n\n? QiDrawing3DModel: \u00c9 a defini\u00e7\u00e3o do modelo que representa as \n\nentidades 3D utilizados pela Engine; \n\n? Qi3DIFCImporter: M\u00f3dulo respons\u00e1vel por converter as \n\ninforma\u00e7\u00f5es dos modelos 3D vindos dos arquivos IFC em \n\nmodelos no formato Qi3DDrawingModel; \n\n? Qi3DDrawingModelPersistence: M\u00f3dulo respons\u00e1vel pela \n\npersist\u00eancia dos dados dos modelos de elementos 3D. \n\nComo explicado no in\u00edcio deste cap\u00edtulo, um dos objetivos do projeto \u00e9 a \n\nutiliza\u00e7\u00e3o do visualizado 3D nos programas j\u00e1 existentes na empresa, isso \n\ndeve ocorrer atrav\u00e9s da adi\u00e7\u00e3o e utiliza\u00e7\u00e3o dos m\u00f3dulos Qi3DEngine e \n\nQiDrawing3DModel nas aplica\u00e7\u00f5es. A figura a seguir define a arquitetura desta \n\nimplementa\u00e7\u00e3o. \n\n\n\n31 \n\n \n\n \n\nPara o projeto dos visualizadores 3D, foram especificados como \n\nrequisitos funcionais m\u00ednimos, independente da interface dos programas, os \n\nseguintes t\u00f3picos: \n\n? Exibir os elementos contidos no modelo em perspectiva; \n\n? Para cada elemento, ser poss\u00edvel alterar a sua cor, transpar\u00eancia \n\ne visibilidade (op\u00e7\u00e3o de esconder ou mostrar no modelo); \n\n? Opera\u00e7\u00f5es b\u00e1sicas de manipula\u00e7\u00e3o: aproxima\u00e7\u00e3o e afastamento \n\nda c\u00e2mera, rota\u00e7\u00e3o, deslocamento (pan) do modelo, rota\u00e7\u00e3o \n\ndin\u00e2mica e diferen\u00e7as do comportamento da c\u00e2mera quando \n\ndentro ou fora da edifica\u00e7\u00e3o; \n\n? Filtros para visualiza\u00e7\u00e3o de mais de um tipo de projeto, pavimento \n\nou elemento; \n\nFigura 6 - Arquitetura do novo visualizador com os produtos da empresa \n\n\n\n32 \n\n \n\n? Inser\u00e7\u00e3o de planos de corte nos eixos X, Y e Z, positivos ou \n\nnegativos; \n\nComo dito anteriormente, para a utiliza\u00e7\u00e3o do novo visualizador 3D nos \n\nprogramas existentes foi necess\u00e1ria uma grande altera\u00e7\u00e3o no c\u00f3digo-fonte das \n\naplica\u00e7\u00f5es. Tanto no caso do QiBuilder quanto no Eberick, as primitivas 3D e \n\nas engines utilizadas estavam \u201cmisturadas\u201d com outras partes de c\u00f3digo, n\u00e3o \n\nrespeitando a hierarquia desejada. Ressaltando que para o QiBuilder o motor \n\ngr\u00e1fico 3D atualmente utilizado \u00e9 o VTK e para o Eberick o OpenGL.  \n\nA refatora\u00e7\u00e3o dos dois programas utilizou uma metodologia semelhante. \n\nO primeiro passo \u00e9 descobrir quais elementos de cada motor gr\u00e1fico s\u00e3o \n\nrealmente utilizados e ap\u00f3s isso, entender como a transfer\u00eancia de \n\ninforma\u00e7\u00f5es para desenho dos elementos \u00e9 realizada. O pr\u00f3ximo passo \u00e9 criar \n\numa nova hierarquia de representa\u00e7\u00e3o dos dados, que seja independente do \n\nprograma ao qual est\u00e1 associada, por\u00e9m mantendo a mesma funcionalidade j\u00e1 \n\nexistente, para que n\u00e3o se insira novos erros nos softwares existentes. \n\nEssa nova hierarquia criada, deve servir como ponte entre a engine \n\nexistente e os modelos da biblioteca Qi3DModel e para validar sua \n\nindepend\u00eancia, deve ser apta a compilar em mais de uma IDE existente. \n\nDepois dessa valida\u00e7\u00e3o, modifica-se a forma de desenho dos programas \n\nexistentes, fazendo que obrigatoriamente sejam utilizados os elementos dessa \n\nnova arquitetura.  \n\nA etapa seguinte \u00e9 substituir a forma como os programas criam suas \n\nprimitivas 3D, pelos novos modelos vindos da Qi3DModel, associ\u00e1-los com os \n\nnovos Metadados e criar os filtros para os novos modelos. Dessa forma j\u00e1 se \n\ntem a aplica\u00e7\u00e3o parcialmente desacoplada dos motores gr\u00e1ficos utilizados \n\nanteriormente. A parte final \u00e9 substituir o motor gr\u00e1fico pela Qi3DEngine e faz\u00ea-\n\nla se comunicar com a API de desenho respectiva. \n\n\n\n33 \n\n \n\nComo j\u00e1 frisado, estes novos objetos tridimensionais est\u00e3o associados \u00e0 \n\nMetadados que tamb\u00e9m foram desenvolvidos durante o projeto. A solu\u00e7\u00e3o \n\nbuscada para este caso tamb\u00e9m tenta oferecer uma forma flex\u00edvel e de baixo \n\nacoplamento para resolver o problema.  \n\nNas aplica\u00e7\u00f5es existentes, cada elemento dentro do modelo \n\ntridimensional tem uma s\u00e9rie de propriedades, como: nome, tipo, pavimento \n\nassociado, nome do projeto e etc. Estas informa\u00e7\u00f5es s\u00e3o utilizadas no \n\nvisualizador 3D para gerenciar objetos, por exemplo, mostrando somente \n\naqueles pertencentes a um pavimento, ou alterando a cor de um grupo. \n\nFigura 7 - Hierarquia do desacoplamento dos m\u00f3dulos em camadas \n\n\n\n34 \n\n \n\nPara o Qi4D, especificou-se que os objetos podem ter qualquer tipo de \n\npropriedades, estas podendo ser tipos simples ou estruturas complexas, onde \n\nas estruturas complexas t\u00eam sub-propriedades. Esta estrat\u00e9gia \u00e9 aplicada \n\nutilizando-se de um grafo ac\u00edclico para representa\u00e7\u00e3o das propriedades. \n\nNeste grafo, cada objeto independente que representa uma entidade \n\nque pode se relacionais com outra, \u00e9 chamado de \u201cn\u00f3\u201d do grafo. Cada \u201cn\u00f3\u201d tem \n\num identificador (ID) \u00fanico e suas propriedades podem ser um atributo simples \n\nou uma refer\u00eancia para outro n\u00f3 (atributos como estruturas complexas). Para \n\ndefinir um \u201cn\u00f3\u201d como propriedade de outro, este precisa ser \u201cfilho\u201d do primeiro \n\n \n\n \n\n \n\nFigura 8 - Exemplos de propriedades no QiBuilder (esquerda) e Eberick (direita) \n\n\n\n35 \n\n \n\n \n\n \n\n \n\nComo exemplo, na figura acima, t\u00eam-se os n\u00f3s \u201c3DObjects\u201d, \u201cBatch\u201d e \n\n\u201cStage\u201d. Os atributos \u201cName\u201d e \u201cFloorName\u201d s\u00e3o propriedades de cada \n\n\u201c3DObject\u201d e o n\u00f3 \u201cBatch\u201d \u00e9 uma propriedade de \u201c3DObject\u201d cujo identificador \n\n(node_id) \u00e9 seis. \n\nUm ponto importante de se frisar \u00e9 que as aplica\u00e7\u00f5es da empresa \n\ncontinuaram o seu desenvolvimento paralelo, corrigindo bugs e adicionando \n\nfuncionalidades previstas, pois como softwares comercias, s\u00e3o necess\u00e1rias \n\nFigura 9 - Grafo ac\u00edclico dos metadados \n\n\n\n36 \n\n \n\nconstantes atualiza\u00e7\u00f5es e inova\u00e7\u00f5es para continuarem competitivos. As \n\nmudan\u00e7as propostas pelo projeto Qi4D s\u00e3o consideras de alto risco, pois \n\npodem desestabilizar os programas e gerar novos erros. \n\nPara minimizar estes tipos de problemas, a empresa utiliza um sistema \n\nde controle de vers\u00f5es. Esses sistemas permitem o acompanhamento do \n\ntrabalho e das modifica\u00e7\u00f5es realizadas em um grupo de arquivos, fornecendo \n\nsuporte para que v\u00e1rios desenvolvedores alterem os c\u00f3digos do programa sem \n\nsobreposi\u00e7\u00e3o de implementa\u00e7\u00f5es. Al\u00e9m disso, \u00e9 poss\u00edvel criar linhas de \n\ndesenvolvimento paralelas com a linha original. \n\nO sistema de controle de vers\u00f5es utilizado na empresa \u00e9 o Apache \n\nSubversion (abreviado por SVN). Este baseia-se em uma met\u00e1fora de \u00e1rvore \n\npara facilitar sua utiliza\u00e7\u00e3o pelos desenvolvedores. Para o SVN, a linha \n\nprincipal de desenvolvimento de um software \u00e9 chamada de trunk (ou tronco, \n\nao traduzir para o portugu\u00eas) e as linhas paralelas s\u00e3o chamadas de branches \n\n(galhos). A todo o momento \u00e9 poss\u00edvel criar um nova branch onde as \n\nmodifica\u00e7\u00f5es feitas n\u00e3o alteram o trunk, e caso seja necess\u00e1rio, pode-se \n\nreintegrar essa branch ao trunk. Isto \u00e9 importante quando se espera grandes \n\nmodifica\u00e7\u00f5es em partes espec\u00edficas de um sistema [ 18 ], como \u00e9 o caso do \n\nprojeto Qi4D. Assim pode-se abrir uma branch, realizar as modifica\u00e7\u00f5es \n\nnecess\u00e1rias e ap\u00f3s todos os testes e corre\u00e7\u00f5es, reintegr\u00e1-la a linha de \n\ndesenvolvimento principal. \n\nO projeto Qi4D por si pr\u00f3prio \u00e9 considerado uma linha principal de \n\ndesenvolvimento. As modifica\u00e7\u00f5es descritas nos pr\u00f3ximos cap\u00edtulos foram \n\nprimeiramente aplicadas em branchs, tanto do Qi4D como dos programas \n\nprincipais da empresa, e depois reintegrados. A imagem abaixo ilustra essas \n\nlinhas de desenvolvimento. \n\n \n\n\n\n37 \n\n \n\n \n\n \n\nFigura 10 - Ilustra\u00e7\u00e3o das branches criadas para a tarefa \n\n\n\n38 \n\n \n\nCap\u00edtulo 5: Incorporando a API ao sistema existente \n\nComo dito anteriormente, o PFC ocorreu durante o Release 3 (ou seja, a \n\nterceira parte) do projeto Qi4D. Esta parte \u00e9 concentrada em estender a \n\nrefatora\u00e7\u00e3o do Engine3D (tratado no QiBuilder durante o Release 2) tamb\u00e9m \n\npara o Eberick. Tamb\u00e9m inclui no seu escopo a primeira fase de exporta\u00e7\u00e3o de \n\narquivos no formato IFC e estudos sobre a persist\u00eancia do modelo e aplica\u00e7\u00e3o \n\nde testes unit\u00e1rios. \n\nPara in\u00edcio dos trabalhos, seguiu-se a metodologia explicada no cap\u00edtulo \n\n4, fazendo um levantamento das funcionalidades que o Eberick utilizava \n\nadvindas do OpenGL. A imagem abaixo ilustra a antiga hierarquia de classes \n\nde desenho 3D, todas as classes filhas de T3DObject precisaram ser refeitas. \n\n \n\nA continua\u00e7\u00e3o deu-se pela cria\u00e7\u00e3o de classes que representassem os \n\nobjetos 3D OpenGL, com o \u00fanico objetivo de saberem se desenhar no contexto \n\ndo OpenGL, de forma independente das primitivas Qi4D originais. Essas \n\nclasses compartilham de uma interface comum, chamada IQi3DGLObject, que \n\ndefine os m\u00e9todos b\u00e1sicos necess\u00e1rios, permitindo o uso da pattern de inje\u00e7\u00e3o \n\nde depend\u00eancia quando necess\u00e1rio. Esse objetos OpenGL ficaram \n\norganizados na seguinte estrutura: \n\nFigura 11 - Antiga hierarquia de objetos 3D no Eberick \n\n\n\n39 \n\n \n\nComo esperava-se que esta implementa\u00e7\u00e3o resultasse num m\u00f3dulo \n\nindependente e intercambi\u00e1vel entre os programas da empresa, passou-se \n\npara a cria\u00e7\u00e3o de classes conversoras, com o intuito de converter as \n\nprimitivas Qi3DObject (Qi4D) nos objetos 3D OpenGL criados. Esses \n\nconversores foram desenvolvidos seguindo os design patterns Dispatcher e \n\nBuilder. Como pode-se ver nas figuras a seguir, nem todas as classes \n\nexistentes no Qi4D precisaram ser incorporadas no Eberick, apenas aquelas \n\nque s\u00e3o efetivamente utilizadas. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nFigura 12 - Hierarquia dos objetosOpenGL no Qi4D \n\nFigura 13 - Hierarquia dos conversores OpenGL no Qi4D \n\n\n\n40 \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nO design pattern Dispatcher [ 19 ] busca criar uma ponte entre a classe \n\nusu\u00e1ria do dispatcher e a execu\u00e7\u00e3o de um fluxo de a\u00e7\u00f5es respons\u00e1veis pela \n\ngera\u00e7\u00e3o de conte\u00fado gen\u00e9rico e din\u00e2mico. Isto permite o desacoplamento entre \n\no \u201cusu\u00e1rio\u201d da fun\u00e7\u00e3o e o \u201cprovedor\u201d dos dados. O pattern Builder [ 20 ] se \n\ndestina \u00e0 separa\u00e7\u00e3o da constru\u00e7\u00e3o de um objeto complexo da sua \n\nrepresenta\u00e7\u00e3o, dessa forma, o mesmo processo de constru\u00e7\u00e3o pode criar \n\ndiferentes representa\u00e7\u00f5es. \n\n \n\n \n\n \n\n \n\n \n\nFigura 15 - Chamadas do m\u00e9todo que busca por um conversor \nespec\u00edfico no hashmap \n\nFigura 14 -  Hierarquia de classes no projeto Qi4D \n\n\n\n41 \n\n \n\n \n\n \n\n \n\nAo fim dessa tarefa, obteve-se um m\u00f3dulo que \u00e9 independente dos \n\nprogramas da empresa e que segue os padr\u00f5es de qualidade impostos, \n\nressaltando que sua compila\u00e7\u00e3o foi validada nos ambientes: Borland 5.02, \n\nVisual Studio 2006 e Borland C++Builder. Por\u00e9m um dos requisitos n\u00e3o pode \n\nser avaliado, a funcionalidade din\u00e2mica com os programas em execu\u00e7\u00e3o. Para \n\ngarantir a \u201catomicidade\u201d da solu\u00e7\u00e3o, optou-se pela aplica\u00e7\u00e3o desse m\u00f3dulo \n\ncriado no software Eberick da empresa, j\u00e1 que ele se utiliza do motor gr\u00e1fico \n\nOpenGL, teoricamente, n\u00e3o precisando de muitas modifica\u00e7\u00f5es para o \n\nfuncionamento do novo m\u00f3dulo no programa. \n\nEsta parte seguiu-se criando novos conversores, neste caso, para haver \n\numa ponte entre os objetos j\u00e1 existentes no Eberick com os novos OpenGL \n\ncriados. Esses conversores somente serviram para o momento de \u201cdesenho\u201d \n\ndos elementos na janela 3D. Quando um dos elementos estava prestes a ser \n\nrepresentado da tela, ele chamava seu conversor e ent\u00e3o o desenho era \n\nrealizado pelos novos objetos OpenGL, sem diferen\u00e7a com o conceito j\u00e1 \n\nexistente no programa. Isto gerou um grande problema na performance do \n\nprograma na hora da renderiza\u00e7\u00e3o dos objetos 3D, pois a cada frame era \n\nnecess\u00e1rio destruir, converter e construir um novo objeto.\n\nFigura 16 - Registro do conversor no hashmap ao ser criado pelo dispatcher e chamadas deste m\u00e9todo \n\n\n\n42 \n\n \n\n \n\n \n\nFigura 17 - Grafo de sequencia para a cria\u00e7\u00e3o de um novo elemento a cada frame \n\nA princ\u00edpio, como o objetivo desta parte da tarefa era apenas avaliar a \n\nfuncionalidade das novas primitivas OpenGL criadas, isto foi alcan\u00e7ado. \n\nPor\u00e9m optou-se pela reintegra\u00e7\u00e3o deste branch \u00e0 trunk principal de \n\ndesenvolvimento, e a queda de desempenho n\u00e3o \u00e9 aceit\u00e1vel. Para resolver \n\neste novo problema, resolveu-se persistir os novos objetos OpenGL no \n\nprograma, fazendo com que eles s\u00f3 fossem recriado quando houvessem \n\naltera\u00e7\u00f5es nas suas caracter\u00edsticas. Neste momento, a interface criada \n\nanteriormente foi de suma import\u00e2ncia, pois pode-se adotar o padr\u00e3o de \n\ninje\u00e7\u00e3o de depend\u00eancias para o novos objetos. Novamente, as \n\nmodifica\u00e7\u00f5es foram realizadas com sucesso e foi poss\u00edvel reintegrar essas \n\nmudan\u00e7as a trunk do programa.  \n\n\n\n43 \n\n \n\n \n\n \n\nO passo seguinte foi efetivamente substituir todos os elementos 3D \n\ngerados pelo software pelos elementos da framework Qi4D. O Eberick \n\ntrabalhava com as seguintes classes gerando elementos 3D e suas \n\nparticularidades: \n\n? Trechos: geram vigas curvas, retas e inclinadas com diferentes \n\nse\u00e7\u00f5es, al\u00e9m de furos nas vigas; \n\n? Lajes: geram as lajes, lajes com aberturas e rampas, com ou sem \n\nnervuras; \n\n? Pilar: geram os pilares com suas respectivas varia\u00e7\u00f5es de se\u00e7\u00e3o; \n\n? Escadas: geram rampas, escadas com fundo plano e escadas \n\nplissadas; \n\n? Funda\u00e7\u00e3o: geram os pilares de funda\u00e7\u00e3o, blocos, sapatas, \n\ntubul\u00f5es e estacas, com diferentes se\u00e7\u00f5es; \n\n? Elemento N\u00f3: respons\u00e1vel pela gera\u00e7\u00e3o do capitel; \n\n? Muro: gera\u00e7\u00e3o do muro em alvenaria; \n\n? Parede: gera\u00e7\u00e3o da parede em alvenaria; \n\n? Barras: gera\u00e7\u00e3o do p\u00f3rtico unifilar e grelha das lajes. \n\nFigura 18 - Grafo dos m\u00e9todos que requisitam pela cria\u00e7\u00e3o de um novo elemento convertido e as classes que o implementam \n\n\n\n44 \n\n \n\nAproveitando essa necessidade de mudan\u00e7a, tamb\u00e9m decidiu-se \n\nimplantar um design pattern de comportamento, o Visitor [ 21 ]. Este design \n\npattern busca oferecer um novo comportamento para uma classe sem alter\u00e1-la. \n\nO prop\u00f3sito prim\u00e1rio do Visitor \u00e9 abstrair uma funcionalidade que ser\u00e1 aplicada \n\nnuma hierarquia agregada de objetos diferentes, possibilitando a cria\u00e7\u00e3o de \n\nclasse mais leves e flex\u00edveis. Al\u00e9m disso, h\u00e1 a implementa\u00e7\u00e3o do conceito \n\n\u201cdouble dispatch\u201d, onde a opera\u00e7\u00e3o a ser executada depende do nome da \n\nrequisi\u00e7\u00e3o e do tipo dos dois receptores (no caso, o tipo da classe Visitor e o \n\ntipo da classe a ser visitada).  \n\nFigura 19 - Elementos que aceitam a visita \n\n\n\n45 \n\n \n\nComplementando o pattern Visitor, foi tamb\u00e9m implementado o pattern \n\nFactory, um pattern de cria\u00e7\u00e3o de objetos [ 22 ] , onde define-se uma interface \n\npara cria\u00e7\u00e3o dos objetos, mas permitem \u00e0s subclasses decidirem quais objetos \n\ninstanciarem, consequentemente, auxiliando na padroniza\u00e7\u00e3o do modelo de \n\narquitetura. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n  \n\nFigura 20 - Diagrama de classes dos visitor \n\nFigura 21 - Diagrama de classes das factories \n\n\n\n46 \n\n \n\n Completando a nova forma que as informa\u00e7\u00f5es s\u00e3o organizadas e \n\nmanipuladas no programa, criou-se a estrutura de metadados citada \n\nanteriormente. Em particular, as primitivas tridimensionais do Eberick utilizam \n\nos seguintes tipos de informa\u00e7\u00f5es: \n\n? Nome do elemento: cada elemento tridimensional tem um nome \n\n\u00fanico, que \u00e9 o mesmo associado a sua entidade existente no \n\ncroqui de desenho; \n\n? Estado de exibi\u00e7\u00e3o: \u00e9 um atributo booleano que indica se o \n\nelemento deve ser exibido na janela 3D no momento ou n\u00e3o; \n\n? Pavimento associado: como cada croqui representa um \n\npavimento, esta informa\u00e7\u00e3o tamb\u00e9m deve estar presente nos \n\nelementos 3D; \n\n? Nome do grupo: cada elemento necessita saber a qual grupo ele \n\npertence, por exemplo, se o elemento pertence a grupo de lajes, \n\nrampas ou escadas; \n\n? N\u00edvel do pavimento: fornece a informa\u00e7\u00e3o de continuidade do \n\nelemento entre pavimentos. \n\nUtilizando o conceito do grafo ac\u00edclico explicado anteriormente, os \n\npavimentos e grupos ser\u00e3o estruturas complexas de dados, al\u00e9m de serem \n\npartilhadas entre elementos diferentes, desta forma, ser\u00e3o associados, como \n\nfilhos, ao metadados dos objetos tridimensionais.  \n\nA cria\u00e7\u00e3o dos tipos de propriedades de metadados foi implementada \n\nutilizando-se de um design pattern de cria\u00e7\u00e3o, o Singleton[ 23 ]. Este pattern \n\nem especial tem como carater\u00edstica marcante garantir que uma determinada \n\nclasse tenha somente uma inst\u00e2ncia, fornecendo pontos de acesso a ela. Esta \n\nestrat\u00e9gia foi adotada para encapsular a forma como os metadados s\u00e3o criados \n\ne garantir que os mesmos tipos de elementos tenham os mesmos formatos de \n\ndados, apenas com valores diferentes. \n\n \n\n \n\n \n\n\n\n47 \n\n \n\n \n\nComplementado as funcionalidades necess\u00e1rias, uma classe do tipo \n\nFactory foi criada para que, atrav\u00e9s do polimorfismo, possa encapsular a l\u00f3gica \n\nde cria\u00e7\u00e3o dos metadados para cada elemento estrutural do Eberick que cria \n\nseu respectivo objeto 3D. \n\n \n\n \n\nFigura 22 - Classes singletons para cria\u00e7\u00e3o dos metadados \n\nFigura 23 - Factory de metadados \n\n\n\n48 \n\n \n\nCap\u00edtulo 6: Resultados Obtidos \n\nUma mudan\u00e7a que foi consequ\u00eancia do projeto, por\u00e9m \u00e9 de suma \n\nimport\u00e2ncia, \u00e9 a valida\u00e7\u00e3o do Eberick com as primitivas pr\u00f3prias da empresa \n\npresente no modulo QiPrimitives. Este m\u00f3dulo \u00e9 utilizado no programa \n\nQiBuilder da empresa, e como foi desenvolvido numa plataforma bem mais \n\natual, temia-se que n\u00e3o fosse retro compat\u00edvel com o c\u00f3digo legado. Por\u00e9m \n\ncom alguns esfor\u00e7os conseguiu-se validar sua solu\u00e7\u00e3o e compila\u00e7\u00e3o na vers\u00e3o \n\n5.02 do compilador Borland. \n\nEste sucesso, al\u00e9m da import\u00e2ncia vital para o projeto, j\u00e1 que o novo \n\nvisualizador tridimensional \u00e9 escrito sob estas primitivas, tamb\u00e9m estendeu as \n\nsolu\u00e7\u00f5es poss\u00edveis de serem utilizadas no Eberick. Somando-se a isso, \n\nprioriza-se pela utiliza\u00e7\u00e3o destas primitivas para a cria\u00e7\u00e3o de novas \n\nfuncionalidades e em momentos de refatora\u00e7\u00e3o de c\u00f3digo, para que em tempo \n\nh\u00e1bil, seja poss\u00edvel substituir totalmente estas primitivas do Eberick, tornando o \n\nmodulo citado outra parte da interoperabilidade entre estes sistemas. \n\nSeguindo adiante, outra mudan\u00e7a n\u00e3o t\u00e3o facilmente mensur\u00e1vel foi a \n\nrefatora\u00e7\u00e3o direta do c\u00f3digo. Ao reorganiza-lo e reescreve-lo sob os requisitos \n\nde qualidade do projeto Qi4D e do clean code, obteve-se um c\u00f3digo mais \n\nleg\u00edvel, com um entendimento mais intuitivo e consequentemente facilitando \n\nsua manuten\u00e7\u00e3o. N\u00e3o foi citado anteriormente, por\u00e9m todo o c\u00f3digo presente \n\nna framework Qi4D deve ser escrito em ingl\u00eas, assim o novo c\u00f3digo est\u00e1 nesta \n\nl\u00edngua, aumentando o leque de possibilidades para \u201coutsourcing\u201d das solu\u00e7\u00f5es \n\nnecess\u00e1rias na empresa, sem precisar abrir totalmente seu c\u00f3digo a terceiros. \n\nUm dos objetivos principais, a redu\u00e7\u00e3o da complexidade ciclom\u00e1tica e \n\nreestrutura\u00e7\u00e3o do programa dentro das m\u00e9tricas de qualidade, foi alcan\u00e7ado \n\ncom sucesso. O grafo de Kiviat abaixo ilustra como estavam os valores base \n\nantes das altera\u00e7\u00f5es, comparando-os com as m\u00e9tricas impostas: \n\n \n\n \n\n\n\n49 \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nE como pode ser visto na pr\u00f3xima figura, os valores obtidos para o \n\nprojeto est\u00e3o dentro do desejado. \n\n \n\nFoi poss\u00edvel obter o desacoplamento das primitivas 3D desejadas. As \n\nantigas primitivas derivadas de T3DObject (vide figura 11) foram \n\ncompletamente removidas do c\u00f3digo, assim como suas estruturas de dados \n\nassociadas.  \n\nFigura 24 - Complexidade ciclom\u00e1tica antes das mudan\u00e7as \n\nFigura 25 - Complexidade ciclom\u00e1tica ap\u00f3s as altera\u00e7\u00f5es \n\n\n\n50 \n\n \n\nOs padr\u00f5es de projeto aplicados contribu\u00edram fortemente para a \n\nmodulariza\u00e7\u00e3o da solu\u00e7\u00e3o, ao concentrar a gera\u00e7\u00e3o dos objetos 3D num \u00fanico \n\nponto, facilita-se a manuten\u00e7\u00e3o do c\u00f3digo e possibilidade de melhorias futuras. \n\nNo decorrer do projeto, observou-se a necessidade da cria\u00e7\u00e3o de uma \n\ninterface para os motores gr\u00e1ficos utilizados. Isto, al\u00e9m de ser \n\narquiteturalmente mais correto, reduziu a complexidade ciclom\u00e1tica do modulo \n\nQi3DOpenGL, pois anteriormente nele estava incluso a antiga implementa\u00e7\u00e3o \n\nconcreta da engine OpenGL. \n\n  \n\nFigura 26 - Ilustra\u00e7\u00e3o dos m\u00f3dulos desacoplados \n\n\n\n51 \n\n \n\nA cria\u00e7\u00e3o dos elementos OpenGL e seus respectivos conversores \n\ntamb\u00e9m foram aprovados na gera\u00e7\u00e3o autom\u00e1tica de vers\u00f5es pelo servidor de \n\nBuilds cont\u00ednuas. A figura 27 aponta a duplica\u00e7\u00e3o de c\u00f3digo encontrada, na \n\nvers\u00e3o #210 e corrigida em seguida, na vers\u00e3o #211, como mostrada na figura \n\n28. \n\n \n\nPara a conformidade da aplica\u00e7\u00e3o das primitivas da API no programa \n\nEberick n\u00e3o pode-se validar uma melhoria quantitativa para a refatora\u00e7\u00e3o \n\natrav\u00e9s dos grados de Kiviat, pois o c\u00f3digo antigo estava espalhado por todo o \n\nprograma, \u201ccontaminando e sendo contaminado\u201d por outras partes, logo o \n\nresultado n\u00e3o refletiria o real cen\u00e1rio da aplica\u00e7\u00e3o. Para a nova refatora\u00e7\u00e3o, \n\nprocurou-se manter as l\u00f3gicas existentes, apenas alterando o que fosse \n\nnecess\u00e1rio para as novas primitivas. Essa escolha foi tomada, pois as \n\nestruturas para desenhos 3D existentes s\u00e3o complexas e extensas, uma \n\nFigura 27 - Erro de duplica\u00e7\u00e3o de c\u00f3digo na gera\u00e7\u00e3o continua de vers\u00f5es \n\nFigura 28 - Nenhum erro encontrado na gera\u00e7\u00e3o continua de vers\u00f5es \n\n\n\n52 \n\n \n\nrefatora\u00e7\u00e3o total tomaria muito mais tempo que o dispon\u00edvel para ser conclu\u00edda, \n\nal\u00e9m de possivelmente levar a novos erros inesperados, que necessitariam \n\nmais corre\u00e7\u00f5es. Como ilustra\u00e7\u00e3o, o grafo abaixo mostra o estado atual da \n\nclasse respons\u00e1vel por gerar as primitivas tridimensionais. \u00c9 poss\u00edvel ver que \n\npara este caso est\u00e1 ultrapassando as m\u00e9tricas de qualidade, mas foi aceito \n\ncomo v\u00e1lido devido \u00e0s limita\u00e7\u00f5es citadas. \n\n \n\n \n\nDe modo como foi apresentado no cap\u00edtulo 3, as modifica\u00e7\u00f5es passaram \n\npela bateria de testes din\u00e2micos. Como as modifica\u00e7\u00f5es aconteceram em uma \n\nbranch do programa, foi poss\u00edvel criar uma tarefa no servidor de gera\u00e7\u00e3o de \n\nbuilds para gerar vers\u00f5es com estas altera\u00e7\u00f5es. O pr\u00f3prio sucesso na gera\u00e7\u00e3o \n\nda vers\u00e3o \u00e9 um teste, pois para isso o programa necessita ser completamente \n\nrecompilado sem erros. Como \u00e9 poss\u00edvel ver na figura 30, alguns \u201cbugs\u201d \n\nocorreram durante o desenvolvimento da tarefa, estes ent\u00e3o s\u00e3o corrigidos e \n\npassados para novos testes din\u00e2micos, a tarefa \u00e9 dada por conclu\u00edda quando \n\ntodas as funcionalidades desejadas est\u00e3o implementadas e todos os erros \n\ncorrigidos. Quando todas as tarefas de um projeto foram conclu\u00eddas, ele \u00e9 \n\nencerrado. \n\n \n\nFigura 29 - Grafo de Kiviat para classe respons\u00e1vel pela cria\u00e7\u00e3o dos novos \nelementos 3D \n\n\n\n53 \n\n \n\nPor fim, foi poss\u00edvel associar a nova estrutura de metadados aos novos \n\nelementos 3D, at\u00e9 o momento da conclus\u00e3o deste trabalho, o visualizador \n\nestava gerando todos os elementos existentes no programa sem erros e as \n\nfuncionalidades de manipula\u00e7\u00e3o do modelo, troca de cores e transpar\u00eancia via \n\ndi\u00e1logo haviam sido reestabelecidas. Tamb\u00e9m j\u00e1 haviam sido conclu\u00eddos a \n\nvis\u00e3o dos elementos no modo \u201cwireframe\u201d, a op\u00e7\u00e3o de desativar a visibilidade \n\nde um grupo de elementos e a estrutura dos planos de cortes. \n\nFigura 30 - Ferramenta de gerenciamento de projetos \n\n\n\n54 \n\n \n\nCap\u00edtulo 7: Conclus\u00f5es e Perspectivas \n\nOs ideais de automa\u00e7\u00e3o de sistemas e tarefas se mesclam com as \n\nt\u00e9cnicas e conceitos da Tecnologia da informa\u00e7\u00e3o. Os softwares criados pela \n\nempresa para auxiliar os profissionais da \u00e1rea de constru\u00e7\u00e3o civil na cria\u00e7\u00e3o, \n\nexecu\u00e7\u00e3o e gerenciamento de seus projetos s\u00e3o mais um dos exemplos disso, \n\nal\u00e9m de refor\u00e7ar que a automa\u00e7\u00e3o vai muito al\u00e9m do ch\u00e3o de f\u00e1brica. \n\nCom a evolu\u00e7\u00e3o tecnol\u00f3gica e social, estes mesmos softwares criados \n\npara facilitar as tarefas acabaram encontrando um novo problema, cada vez \n\nmais comum na \u00e1rea de automa\u00e7\u00e3o de sistemas: a falta de interoperabilidade \n\nentre eles. O que \u00e9 demonstrado por v\u00e1rias caracter\u00edsticas comuns nestes \n\ncasos: as tecnologias utilizadas n\u00e3o s\u00e3o totalmente compat\u00edveis entre os \n\nsoftwares, as terminologias s\u00e3o diferentes, a arquitetura utilizada no \n\ndesenvolvimento est\u00e1 defasada, os sistemas n\u00e3o mostram seus dados e \n\nresultados nas novas plataformas e um dos softwares j\u00e1 pode ser considerado \n\num sistema legado. \n\nPara tentar combater estes problemas e fornecer uma maior \n\ninteroperabilidade, buscou-se adotar um padr\u00e3o aberto para troca de \n\ninforma\u00e7\u00f5es, e o padr\u00e3o que est\u00e1 em voga na \u00e1rea de constru\u00e7\u00e3o civil \u00e9 o IFC. \n\nA adequa\u00e7\u00e3o dos produtos desenvolvidos nesse padr\u00e3o foi custosa, \n\ntomou tempo e havia o risco de n\u00e3o obter-se os resultados esperados. Vale \n\nlembrar que os softwares desenvolvidos s\u00e3o produtos comerciais finais, que \n\nprecisam sempre de novas funcionalidades para garantir sua perman\u00eancia no \n\nmercado, logo, ter uma equipe destinada exclusivamente \u00e0 refatora\u00e7\u00f5es e \n\nadequa\u00e7\u00f5es internas dos produtos \u00e9 estrategicamente sens\u00edvel. \n\nO projeto mostrou-se mais extenso e complexo que o previsto, havendo \n\numa extens\u00e3o de aproximadamente dois meses a mais que o estimado. Entre \n\nos fatores que contribu\u00edram para isso, podem-se destacar: \n\n\n\n55 \n\n \n\n? As adequa\u00e7\u00f5es necess\u00e1rias ao c\u00f3digo fonte das novas \n\nfuncionalidades ao tenta-las portar para o compilador Borland \n\n5.02; \n\n? A necessidade de retrabalhado duplo para erros na gera\u00e7\u00e3o de \n\nelementos pelo motor gr\u00e1fico OpenGL. Isto acontece pois foi \n\ndecidido manter suporte para duas vers\u00f5es da linguagem gr\u00e1fica, \n\nj\u00e1 que alguns usu\u00e1rios n\u00e3o possuem o hardware m\u00ednimo para a \n\nutiliza\u00e7\u00e3o de novas solu\u00e7\u00f5es 3D. \n\n? Expans\u00f5es necess\u00e1rias e n\u00e3o previstas de funcionalidades na \n\nAPI para adequar-se com problemas encontrados durante as \n\nrefatora\u00e7\u00f5es nos programas. Em alguns casos, mudan\u00e7as \n\nrealizadas em m\u00e9todos j\u00e1 existentes resultavam no retrabalho \n\ndos dois programas.  \n\nOs esfor\u00e7os desprendidos resultaram no sucesso de aplicar o novo \n\npadr\u00e3o, o projeto realizado tamb\u00e9m conseguiu desacoplar partes significativas \n\ndos sistemas, fornecendo uma maior vida \u00fatil a eles. Algumas funcionalidades \n\nn\u00e3o estavam totalmente implementadas at\u00e9 o fim do PFC. Podem-se citar:  \n\n? O caso de edi\u00e7\u00e3o de elementos dentro do visualizador, pois a \n\nl\u00f3gica utilizada antigamente n\u00e3o pode ser replicada devido \u00e0 nova \n\nutiliza\u00e7\u00e3o da estrutura de metadados;  \n\n? A importa\u00e7\u00e3o e exporta\u00e7\u00e3o do modelo IFC dentro do Eberick, \n\napesar da estrutura de dados estar adequada para isto, ainda \n\nnecessita-se criar uma interface GUI e adequar o c\u00f3digo para \n\nestes novos m\u00e9todos da API. Para o QiBuilder, ainda ocorrem \n\nalgumas bugs na importa\u00e7\u00e3o/exporta\u00e7\u00e3o, que est\u00e3o em fase de \n\ncorre\u00e7\u00e3o. \n\nApesar disto, as mudan\u00e7as forneceram um precedente para futuros \n\nprojetos que busquem aumentar esta modulariza\u00e7\u00e3o dos sistemas. Somou-se a \n\nisso a isso a cria\u00e7\u00e3o de uma framework pr\u00f3pria e compartilhada entre os \n\nsoftwares, que pode ser expandida para as novas funcionalidades desejadas \n\ncom certa garantia de sucesso, fornecida pela conclus\u00e3o positiva do projeto. \n\n\n\n56 \n\n \n\nComo perspectivas futuras, o projeto do Qi4D deveria continuar sua \n\nexpans\u00e3o para os ambientes web e mobile, como desejado. Sobretudo, \n\ntamb\u00e9m \u00e9 necess\u00e1rio continuar com esse conceito de desacoplamento e \n\nmodulariza\u00e7\u00e3o dos softwares, para que em tempo h\u00e1bil seja poss\u00edvel implantar \n\nnovas solu\u00e7\u00f5es tecnol\u00f3gicas sem grandes custos e num escopo temporal \n\nfact\u00edvel para o mercado. Ainda h\u00e1 muito trabalho a ser feito para chegar neste \n\nponto, mas a empresa est\u00e1 seguindo pelo caminho certo.  \n\n \n\n\n\n57 \n\n \n\nBibliografia: \n\n[ 1 ] AYRES, Marcela. \u201cInd\u00fastria da constru\u00e7\u00e3o civil deve crescer 2,8% \n\nem 2014\u201d. Dispon\u00edvel em http://exame.abril.com.br/economia/noticias/industria-\n\nbrasileira-de-construcao-civil-deve-crescer-2-8-em-2014, acesso em 17 maio \n\n2014. \n\n[ 2 ]CBIC. \u201cBalan\u00e7o Nacional da Ind\u00fastria da Constru\u00e7\u00e3o\u201d. Dispon\u00edvel em  \n\nhttp://www.cbicdados.com.br/menu/estudos-especificos-da-construcao-\n\ncivil/balanco-nacional-da-industria-da-construcao, acesso em 17 maio 2014. \n\n[ 3 ]WIKIPEDIA. \u201cBIM\u201d. Dispon\u00edvel em http://pt.wikipedia.org/wiki/BIM, \n\nacesso em 18 maio 2014. \n\nNATIONAL BIM STANDARD. \u201cWhat is a BIM?\u201d. Dispon\u00edvel em \n\nhttp://www.nationalbimstandard.org/faq.php#faq1, acesso em 18 maio 2014. \n\n[ 4 ]COORDENAR \u2013 CONSULTORIA DE A\u00c7\u00c3O. \u201cO IFC \u00e9 muito mais \n\nque um simples formato de arquivo\u201d. Dispon\u00edvel em \n\nhttp://www.coordenar.com.br/o-ifc-e-muito-mais-que-um-simples-formato-de-\n\narquivo/, acesso em 18 maio 2014. \n\n[ 5 ]ALTOQI. \u201cWiki AltoQi\u201d. Dispon\u00edvel em http://wiki.altoqi.com.br/, \n\nprimeiro acesso em mar. 2014. \n\n[ 6 ]EASTMAM, Chuck; TEICHOLZ, Paul; SACKS, Rafael; LISTON, \n\nKathleen. \u201cBIM Handbook: A guide to Building Information Modeling for Owners, \n\nManagers, Designers, Engineers, and Contractors\u201d. New Jersey: John Wiley &amp; \n\nSons, 2008. \n\n[ 7 ]PINHO, S\u00e9rgio Miguel Ferreira de. \u201cO modelo IFC como agente de \n\ninteroperabilidade\u201d. Mestrado Integrado em Engenharia Civil - 2012/2013, \n\nDepartamento de Engenharia Civil, Faculdade de Engenharia da Universidade \n\ndo Porto, Porto, Portugal, 2013. \n\n[ 8 ]WIKIPEDIA. \u201c4D BIM\u201d. Dispon\u00edvel em  \n\nhttp://en.wikipedia.org/wiki/4D_BIM, acesso em 12 jul. 2014. \n\nhttp://exame.abril.com.br/economia/noticias/industria-brasileira-de-construcao-civil-deve-crescer-2-8-em-2014\nhttp://exame.abril.com.br/economia/noticias/industria-brasileira-de-construcao-civil-deve-crescer-2-8-em-2014\nhttp://www.cbicdados.com.br/menu/estudos-especificos-da-construcao-civil/balanco-nacional-da-industria-da-construcao\nhttp://www.cbicdados.com.br/menu/estudos-especificos-da-construcao-civil/balanco-nacional-da-industria-da-construcao\nhttp://pt.wikipedia.org/wiki/BIM\nhttp://www.nationalbimstandard.org/faq.php#faq1\nhttp://www.coordenar.com.br/o-ifc-e-muito-mais-que-um-simples-formato-de-arquivo/\nhttp://www.coordenar.com.br/o-ifc-e-muito-mais-que-um-simples-formato-de-arquivo/\nhttp://wiki.altoqi.com.br/\nhttp://en.wikipedia.org/wiki/4D_BIM\n\n\n58 \n\n \n\n[ 9 ]3SCALE \u2013 infrastructure for the programmable web. \u201cWhat is an \n\nAPI? Your guide to the Internet Business (R)evolution\u201d. Dispon\u00edvel em \n\nhttp://www.3scale.net/wp-content/uploads/2012/06/What-is-an-API-1.0.pdf, \n\nacesso em 11 jul. 2014. \n\n[ 10 ]MARTIN, Robert C. \u201cClean Code: A handbook of agile software \n\ncraftsmanship\u201d. Prentice Hall, 2008. \n\n[ 11 ]WIKIPEDIA. \u201cDesign structure matrix\u201d. Dispon\u00edvel em \n\nhttp://en.wikipedia.org/wiki/Design_structure_matrix, acesso em 24 maio 2014. \n\n[ 12 ]QUICOLI Paulo. \u201cO padr\u00e3o MVP (Model \u2013 View \u2013 Presenter)\u201d. \n\nDispon\u00edvel em http://www.devmedia.com.br/o-padrao-mvp-model-view-\n\npresenter/3043, acesso em 24 maio 2014. \n\n[ 13 ]MCCABEE T.J.; WATSON A. H. \u201cStructured Testing: A Testing \n\nMethodology Using the Cyclomatic Complexity Metric\u201d. National Institute of \n\nStandards and Technology Special Publication 500-235, September 1996. \n\n[ 14 ]SOFTWARE ENGINEERING INSTITUTE. \u201cC4 Software \n\nTechnology Reference Guide \u2013 A Prototype\u201d. Carnegie Mellon University, pp. \n\n145-147, jan. 1997. \n\n[ 15 ]SOMMERVILLE, Ian. \u201cSoftware Engineering\u201d, Addison Wesley, 7\u00aa \n\nedi\u00e7\u00e3o, 2014. \n\n[ 16 ]PIRES, Eduardo. \u201cDDD, TDD, BDD, Afinal o que s\u00e3o essas \n\nsiglas?\u201d. Dispon\u00edvel em http://eduardopires.net.br/2012/06/ddd-tdd-bdd/, acesso \n\nem 25 maio 2014. \n\n[ 17 ]ANDRADE, Max Lira Veras X. de; RUSCHEL, Regina Coeli. \n\n\u201cInteroperabilidade de aplicativos BIM usados em arquitetura por meio do \n\nformato IFC\u201d. Gest\u00e3o &amp; Tecnologia de Projetos, Brasil, v. 4, n. 2, p. p.76-111, \n\njan. 2010. ISSN 1981-1543. Dispon\u00edvel em: \n\n<http://www.revistas.usp.br/gestaodeprojetos/article/view/50960>, acesso em: 7 \n\nJun. 2014. \n\nhttp://www.3scale.net/wp-content/uploads/2012/06/What-is-an-API-1.0.pdf\nhttp://en.wikipedia.org/wiki/Design_structure_matrix\nhttp://www.devmedia.com.br/o-padrao-mvp-model-view-presenter/3043\nhttp://www.devmedia.com.br/o-padrao-mvp-model-view-presenter/3043\nhttp://eduardopires.net.br/2012/06/ddd-tdd-bdd/\nhttp://www.revistas.usp.br/gestaodeprojetos/article/view/50960\n\n\n59 \n\n \n\n[ 18 ]MARTINS, Andr\u00e9. \u201cSVN: conceitos, boas pr\u00e1ticas e dicas de \n\nutiliza\u00e7\u00e3o\u201d. Dispon\u00edvel em http://intentor.com.br/svn-conceitos-boas-praticas-\n\ndicas-de-utilizacao/ , acesso em 7 jun. 2014. \n\n[ 19 ]DOAN Duy Hai. \u201cDesign Pattern: the Asynchronous Dispatcher\u201d. \n\nDispon\u00edvel em http://doanduyhai.wordpress.com/2012/08/04/design-pattern-the-\n\nasynchronous-dispatcher/, acesso em 14 jun. 2014. \n\n[ 20 ]FREY Gerhard; PAVLOVA, Marina; SHVETS, Alexander. \u201cBuilder \n\nDesign Pattern\u201d. Dispon\u00edvel em \n\nhttp://sourcemaking.com/design_patterns/builder, acesso em 14 jun. 2014. \n\n[ 21 ]FREY Gerhard; PAVLOVA, Marina; SHVETS, Alexander. \u201cVisitor \n\nDesign Pattern\u201d. Dispon\u00edvel em \n\nhttp://sourcemaking.com/design_patterns/visitor, acesso em 14 jun. 2014. \n\n[ 22 ]FREY Gerhard; PAVLOVA, Marina; SHVETS, Alexander. \u201cFactory \n\nMethod Design Pattern\u201d. Dispon\u00edvel em \n\nhttp://sourcemaking.com/design_patterns/factory_method, acesso em 14 jun. \n\n2014. \n\n[ 23  ]FREY Gerhard; PAVLOVA, Marina; SHVETS, Alexander. \n\n\u201cSingleton Design Pattern\u201d. Dispon\u00edvel em \n\nhttp://sourcemaking.com/design_patterns/singleton, acesso em 21 jun. 2014. \n\n \n\nhttp://intentor.com.br/svn-conceitos-boas-praticas-dicas-de-utilizacao/\u00a0\nhttp://intentor.com.br/svn-conceitos-boas-praticas-dicas-de-utilizacao/\u00a0\nhttp://doanduyhai.wordpress.com/2012/08/04/design-pattern-the-asynchronous-dispatcher/\nhttp://doanduyhai.wordpress.com/2012/08/04/design-pattern-the-asynchronous-dispatcher/\nhttp://sourcemaking.com/design_patterns/builder\nhttp://sourcemaking.com/design_patterns/visitor\nhttp://sourcemaking.com/design_patterns/factory_method\nhttp://sourcemaking.com/design_patterns/singleton"}]}}}